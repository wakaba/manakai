package Whatpm::HTML::Parser; # -*- Perl -*-
use strict;
#use warnings;
no warnings 'utf8';
our $VERSION = '1.0';
use Encode;
use Whatpm::HTML::Defs;
use Whatpm::HTML::Tokenizer;
push our @ISA, qw(Whatpm::HTML::Tokenizer);

!!!pdebug { use Data::Dumper; };

use Whatpm::HTML::Tokenizer;

## ISSUE:
## var doc = implementation.createDocument (null, null, null);
## doc.write ('');
## alert (doc.compatMode);

## Namespace URLs

sub HTML_NS () { q<http://www.w3.org/1999/xhtml> }
sub MML_NS () { q<http://www.w3.org/1998/Math/MathML> }
sub SVG_NS () { q<http://www.w3.org/2000/svg> }

## Element categories

## Bits 14-18
sub BUTTON_SCOPING_EL () { 0b1_000000000000000000 } ## Special
sub SPECIAL_EL () { 0b1_00000000000000000 }         ## Special
sub SCOPING_EL () { 0b1_0000000000000000 }          ## Special
sub FORMATTING_EL () { 0b1_000000000000000 }        ## Formatting
sub PHRASING_EL () { 0b1_00000000000000 }           ## Ordinary

## Bits 10-13
sub SVG_EL () { 0b1_0000000000000 }
sub MML_EL () { 0b1_000000000000 }
#sub FOREIGN_EL () { 0b1_00000000000 } # see Whatpm::HTML::Tokenizer
sub FOREIGN_FLOW_CONTENT_EL () { 0b1_0000000000 }

## Bits 6-9
sub TABLE_SCOPING_EL () { 0b1_000000000 }
sub TABLE_ROWS_SCOPING_EL () { 0b1_00000000 }
sub TABLE_ROW_SCOPING_EL () { 0b1_0000000 }
sub TABLE_ROWS_EL () { 0b1_000000 }

## Bit 5
sub ADDRESS_DIV_P_EL () { 0b1_00000 }

## NOTE: Used in </body> and EOF algorithms.
## Bit 4
sub ALL_END_TAG_OPTIONAL_EL () { 0b1_0000 }

## NOTE: Used in "generate implied end tags" algorithm.
## NOTE: There is a code where a modified version of
## END_TAG_OPTIONAL_EL is used in "generate implied end tags"
## implementation (search for the algorithm name).
## Bit 3
sub END_TAG_OPTIONAL_EL () { 0b1_000 }

## Bits 0-2

sub MISC_SPECIAL_EL () { SPECIAL_EL | 0b000 }
sub FORM_EL () { SPECIAL_EL | 0b001 }
sub FRAMESET_EL () { SPECIAL_EL | 0b010 }
sub HEADING_EL () { SPECIAL_EL | 0b011 }
sub SELECT_EL () { SPECIAL_EL | 0b100 }
sub SCRIPT_EL () { SPECIAL_EL | 0b101 }
sub BUTTON_EL () { SPECIAL_EL | BUTTON_SCOPING_EL | 0b110 }

sub ADDRESS_DIV_EL () { SPECIAL_EL | ADDRESS_DIV_P_EL | 0b001 }
sub BODY_EL () { SPECIAL_EL | ALL_END_TAG_OPTIONAL_EL | 0b001 }

sub DTDD_EL () {
  SPECIAL_EL |
  END_TAG_OPTIONAL_EL |
  ALL_END_TAG_OPTIONAL_EL |
  0b010
}
sub LI_EL () {
  SPECIAL_EL |
  END_TAG_OPTIONAL_EL |
  ALL_END_TAG_OPTIONAL_EL |
  0b100
}
sub P_EL () {
  SPECIAL_EL |
  ADDRESS_DIV_P_EL |
  END_TAG_OPTIONAL_EL |
  ALL_END_TAG_OPTIONAL_EL |
  0b001
}

sub TABLE_ROW_EL () {
  SPECIAL_EL |
  TABLE_ROWS_EL |
  TABLE_ROW_SCOPING_EL |
  ALL_END_TAG_OPTIONAL_EL |
  0b001
}
sub TABLE_ROW_GROUP_EL () {
  SPECIAL_EL |
  TABLE_ROWS_EL |
  TABLE_ROWS_SCOPING_EL |
  ALL_END_TAG_OPTIONAL_EL |
  0b001
}

sub MISC_SCOPING_EL () { SCOPING_EL | BUTTON_SCOPING_EL | 0b000 }
sub CAPTION_EL () { SCOPING_EL | BUTTON_SCOPING_EL | 0b010 }
sub HTML_EL () {
  SCOPING_EL |
  BUTTON_SCOPING_EL |
  TABLE_SCOPING_EL |
  TABLE_ROWS_SCOPING_EL |
  TABLE_ROW_SCOPING_EL |
  ALL_END_TAG_OPTIONAL_EL |
  0b001
}
sub TABLE_EL () {
  SCOPING_EL |
  BUTTON_SCOPING_EL |
  TABLE_ROWS_EL |
  TABLE_SCOPING_EL |
  0b001
}
sub TABLE_CELL_EL () {
  SCOPING_EL |
  BUTTON_SCOPING_EL |
  ALL_END_TAG_OPTIONAL_EL |
  0b001
}

sub MISC_FORMATTING_EL () { FORMATTING_EL | 0b000 }
sub A_EL () { FORMATTING_EL | 0b001 }
sub NOBR_EL () { FORMATTING_EL | 0b010 }

sub RUBY_EL () { PHRASING_EL | 0b001 }

## NOTE: These elements are not included in |ALL_END_TAG_OPTIONAL_EL|.
sub OPTGROUP_EL () { PHRASING_EL | END_TAG_OPTIONAL_EL | 0b001 }
sub OPTION_EL () { PHRASING_EL | END_TAG_OPTIONAL_EL | 0b010 }
sub RUBY_COMPONENT_EL () { PHRASING_EL | END_TAG_OPTIONAL_EL | 0b100 }

## "MathML text integration point" elements.
sub MML_TEXT_INTEGRATION_EL () {
  MML_EL |
  SCOPING_EL |
  BUTTON_SCOPING_EL |
  FOREIGN_EL |
  FOREIGN_FLOW_CONTENT_EL
} # MML_TEXT_INTEGRATION_EL

sub MML_AXML_EL () {
  MML_EL |
  SCOPING_EL |
  BUTTON_SCOPING_EL |
  FOREIGN_EL |
  0b001
} # MML_AXML_EL

## "HTML integration point" elements in SVG namespace.
sub SVG_INTEGRATION_EL () {
  SVG_EL |
  SCOPING_EL |
  BUTTON_SCOPING_EL |
  FOREIGN_EL |
  FOREIGN_FLOW_CONTENT_EL
} # SVG_INTEGRATION_EL

sub SVG_SCRIPT_EL () {
  SVG_EL |
  FOREIGN_EL |
  0b101
} # SVG_SCRIPT_EL

my $el_category = {
  a => A_EL,
  address => ADDRESS_DIV_EL,
  applet => MISC_SCOPING_EL,
  area => MISC_SPECIAL_EL,
  article => MISC_SPECIAL_EL,
  aside => MISC_SPECIAL_EL,
  b => FORMATTING_EL,
  base => MISC_SPECIAL_EL,
  basefont => MISC_SPECIAL_EL,
  bgsound => MISC_SPECIAL_EL,
  big => FORMATTING_EL,
  blockquote => MISC_SPECIAL_EL,
  body => BODY_EL,
  br => MISC_SPECIAL_EL,
  button => BUTTON_EL,
  caption => CAPTION_EL,
  center => MISC_SPECIAL_EL,
  code => FORMATTING_EL,
  col => MISC_SPECIAL_EL,
  colgroup => MISC_SPECIAL_EL,
  command => MISC_SPECIAL_EL,
  #datagrid => MISC_SPECIAL_EL,
  dd => DTDD_EL,
  details => MISC_SPECIAL_EL,
  dir => MISC_SPECIAL_EL,
  div => ADDRESS_DIV_EL,
  dl => MISC_SPECIAL_EL,
  dt => DTDD_EL,
  em => FORMATTING_EL,
  embed => MISC_SPECIAL_EL,
  fieldset => MISC_SPECIAL_EL,
  figcaption => MISC_SPECIAL_EL,
  figure => MISC_SPECIAL_EL,
  font => FORMATTING_EL,
  footer => MISC_SPECIAL_EL,
  form => FORM_EL,
  frame => MISC_SPECIAL_EL,
  frameset => FRAMESET_EL,
  h1 => HEADING_EL,
  h2 => HEADING_EL,
  h3 => HEADING_EL,
  h4 => HEADING_EL,
  h5 => HEADING_EL,
  h6 => HEADING_EL,
  head => MISC_SPECIAL_EL,
  header => MISC_SPECIAL_EL,
  hgroup => MISC_SPECIAL_EL,
  hr => MISC_SPECIAL_EL,
  html => HTML_EL,
  i => FORMATTING_EL,
  iframe => MISC_SPECIAL_EL,
  img => MISC_SPECIAL_EL,
  #image => MISC_SPECIAL_EL, ## NOTE: Commented out in the spec.
  input => MISC_SPECIAL_EL,
  isindex => MISC_SPECIAL_EL,
  ## XXX keygen? (Whether a void element is in Special or not does not
  ## affect to the processing, however.)
  li => LI_EL,
  link => MISC_SPECIAL_EL,
  listing => MISC_SPECIAL_EL,
  marquee => MISC_SCOPING_EL,
  menu => MISC_SPECIAL_EL,
  meta => MISC_SPECIAL_EL,
  nav => MISC_SPECIAL_EL,
  nobr => NOBR_EL,
  noembed => MISC_SPECIAL_EL,
  noframes => MISC_SPECIAL_EL,
  noscript => MISC_SPECIAL_EL,
  object => MISC_SCOPING_EL,
  ol => MISC_SPECIAL_EL,
  optgroup => OPTGROUP_EL,
  option => OPTION_EL,
  p => P_EL,
  param => MISC_SPECIAL_EL,
  plaintext => MISC_SPECIAL_EL,
  pre => MISC_SPECIAL_EL,
  rp => RUBY_COMPONENT_EL,
  rt => RUBY_COMPONENT_EL,
  ruby => RUBY_EL,
  s => FORMATTING_EL,
  script => MISC_SPECIAL_EL,
  select => SELECT_EL,
  section => MISC_SPECIAL_EL,
  small => FORMATTING_EL,
  strike => FORMATTING_EL,
  strong => FORMATTING_EL,
  style => MISC_SPECIAL_EL,
  summary => MISC_SPECIAL_EL,
  table => TABLE_EL,
  tbody => TABLE_ROW_GROUP_EL,
  td => TABLE_CELL_EL,
  textarea => MISC_SPECIAL_EL,
  tfoot => TABLE_ROW_GROUP_EL,
  th => TABLE_CELL_EL,
  thead => TABLE_ROW_GROUP_EL,
  title => MISC_SPECIAL_EL,
  tr => TABLE_ROW_EL,
  tt => FORMATTING_EL,
  u => FORMATTING_EL,
  ul => MISC_SPECIAL_EL,
  wbr => MISC_SPECIAL_EL,
  xmp => MISC_SPECIAL_EL,
};

my $el_category_f = {
  (MML_NS) => {
    'annotation-xml' => MML_AXML_EL,
    mi => MML_TEXT_INTEGRATION_EL,
    mo => MML_TEXT_INTEGRATION_EL,
    mn => MML_TEXT_INTEGRATION_EL,
    ms => MML_TEXT_INTEGRATION_EL,
    mtext => MML_TEXT_INTEGRATION_EL,
  },
  (SVG_NS) => {
    foreignObject => SVG_INTEGRATION_EL,
    desc => SVG_INTEGRATION_EL,
    title => SVG_INTEGRATION_EL,
    script => SVG_SCRIPT_EL,
  },
  ## NOTE: In addition, FOREIGN_EL is set to non-HTML elements, MML_EL
  ## is set to MathML elements, and SVG_EL is set to SVG elements.
};

require Whatpm::HTML::ParserData;

my $svg_attr_name = $Whatpm::HTML::ParserData::SVGAttrNameFixup;
my $mml_attr_name = $Whatpm::HTML::ParserData::MathMLAttrNameFixup;
my $foreign_attr_xname = $Whatpm::HTML::ParserData::ForeignAttrNamespaceFixup;

## TODO: Invoke the reset algorithm when a resettable element is
## created (cf. HTML5 revision 2259).

sub parse_byte_string ($$$$;$$) {
  #my ($self, $charset_name, $string, $doc, $onerror, $get_wrapper) = @_;
  my $self = ref $_[0] ? $_[0] : $_[0]->new;
  my $doc = $self->{document} = $_[3];

  my $embedded_encoding_name;
  PARSER: {
    @{$self->{document}->child_nodes} = ();
    
    my $inputref = \($_[2]);
    $self->_encoding_sniffing
        (transport_encoding_name => $_[1],
         embedded_encoding_name => $embedded_encoding_name,
         read_head => sub {
           return $inputref;
         });
    $self->{document}->input_encoding ($self->{input_encoding});

    $self->{line_prev} = $self->{line} = 1;
    $self->{column_prev} = -1;
    $self->{column} = 0;

    $self->{chars} = [split //, decode $self->{input_encoding}, $$inputref];
    $self->{chars_pos} = 0;
    $self->{chars_pull_next} = sub { 0 };
    delete $self->{chars_was_cr};

    $self->{restart_parser} = sub {
      $embedded_encoding_name = $_[0];
      die bless {}, 'Whatpm::HTML::InputStream::RestartParser';
    };

    my $onerror = $_[4] || $self->onerror;
    $self->{parse_error} = sub {
      $onerror->(line => $self->{line}, column => $self->{column}, @_);
    };

    $self->_initialize_tokenizer;
    $self->_initialize_tree_constructor;
    $self->{t} = $self->_get_next_token;
    my $error;
    {
      local $@;
      eval { $self->_construct_tree; 1 } or $error = $@;
    }
    if ($error) {
      if (ref $error eq 'Whatpm::HTML::InputStream::RestartParser') {
        redo PARSER;
      }
      die $error;
    }
    $self->_terminate_tree_constructor;
    $self->_clear_refs;
  } # PARSER

  return $doc;
} # parse_byte_string

## NOTE: HTML5 spec says that the encoding layer MUST NOT strip BOM
## and the HTML layer MUST ignore it.  However, we does strip BOM in
## the encoding layer and the HTML layer does not ignore any U+FEFF,
## because the core part of our HTML parser expects a string of
## character, not a string of bytes or code units or anything which
## might contain a BOM.  Therefore, any parser interface that accepts
## a string of bytes, such as |parse_byte_string| in this module, must
## ensure that it does strip the BOM and never strip any ZWNBSP.

## XXX The policy mentioned above might change when we implement
## Encoding Standard spec.

sub parse_char_string ($$$;$$) {
  #my ($self, $string, $document, $onerror, $get_wrapper) = @_;
  my $self = ref $_[0] ? $_[0] : $_[0]->new;
  my $doc = $self->{document} = $_[2];
  @{$self->{document}->child_nodes} = ();

  ## Confidence: irrelevant.
  $self->{confident} = 1 unless exists $self->{confident};
  $self->{document}->input_encoding ($self->{input_encoding})
      if defined $self->{input_encoding};

  $self->{line_prev} = $self->{line} = 1;
  $self->{column_prev} = -1;
  $self->{column} = 0;

  $self->{chars} = [split //, $_[1]];
  $self->{chars_pos} = 0;
  $self->{chars_pull_next} = sub { 0 };
  delete $self->{chars_was_cr};

  my $onerror = $_[3] || $self->onerror;
  $self->{parse_error} = sub {
    $onerror->(line => $self->{line}, column => $self->{column}, @_);
  };

  $self->_initialize_tokenizer;
  $self->_initialize_tree_constructor;
  $self->{t} = $self->_get_next_token;
  $self->_construct_tree;
  $self->_terminate_tree_constructor;
  $self->_clear_refs;

  return $doc;
} # parse_char_string

## Insertion modes

sub AFTER_HTML_IMS () { 0b100 }
sub HEAD_IMS ()       { 0b1000 }
sub BODY_IMS ()       { 0b10000 }
sub BODY_TABLE_IMS () { 0b100000 }
sub TABLE_IMS ()      { 0b1000000 }
sub ROW_IMS ()        { 0b10000000 }
sub BODY_AFTER_IMS () { 0b100000000 }
sub FRAME_IMS ()      { 0b1000000000 }
sub SELECT_IMS ()     { 0b10000000000 }
sub IN_CDATA_RCDATA_IM () { 0b1000000000000 }
    ## NOTE: "in CDATA/RCDATA" insertion mode is also special; it is
    ## combined with the original insertion mode.  In thie parser,
    ## they are stored together in the bit-or'ed form.

sub IM_MASK () { 0b11111111111 }

## NOTE: These insertion modes are special.
sub INITIAL_IM () { -1 }
sub BEFORE_HTML_IM () { -2 }

## NOTE: "after after body" insertion mode.
sub AFTER_HTML_BODY_IM () { AFTER_HTML_IMS | BODY_AFTER_IMS }

## NOTE: "after after frameset" insertion mode.
sub AFTER_HTML_FRAMESET_IM () { AFTER_HTML_IMS | FRAME_IMS }

sub IN_HEAD_IM () { HEAD_IMS | 0b00 }
sub IN_HEAD_NOSCRIPT_IM () { HEAD_IMS | 0b01 }
sub AFTER_HEAD_IM () { HEAD_IMS | 0b10 }
sub BEFORE_HEAD_IM () { HEAD_IMS | 0b11 }
sub IN_BODY_IM () { BODY_IMS }
sub IN_CELL_IM () { BODY_IMS | BODY_TABLE_IMS | 0b01 }
sub IN_CAPTION_IM () { BODY_IMS | BODY_TABLE_IMS | 0b10 }
sub IN_ROW_IM () { TABLE_IMS | ROW_IMS | 0b01 }
sub IN_TABLE_BODY_IM () { TABLE_IMS | ROW_IMS | 0b10 }
sub IN_TABLE_IM () { TABLE_IMS }
sub AFTER_BODY_IM () { BODY_AFTER_IMS }
sub IN_FRAMESET_IM () { FRAME_IMS | 0b01 }
sub AFTER_FRAMESET_IM () { FRAME_IMS | 0b10 }
sub IN_SELECT_IM () { SELECT_IMS | 0b01 }
sub IN_SELECT_IN_TABLE_IM () { SELECT_IMS | 0b10 }
sub IN_COLUMN_GROUP_IM () { 0b10 }

!!!pdebug { sub _printim ($) { my $v = shift; (print STDERR "C-") && ($v = $v & ~IN_CDATA_RCDATA_IM) if $v >= 0 && $v & IN_CDATA_RCDATA_IM; for (grep { /_IM$/ } keys %Whatpm::HTML::Parser::) { if (__PACKAGE__->$_ == $v) { print STDERR $_, "\n"; return; } } print STDERR $v, "\n"; } };

sub _initialize_tree_constructor ($) {
  my $self = shift;
  ## NOTE: $self->{document} MUST be specified before this method is called
  $self->{document}->strict_error_checking (0);
  ## TODO: Turn mutation events off # MUST
  ## TODO: Turn loose Document option (manakai extension) on
  $self->{document}->manakai_is_html (1); # MUST
  $self->{document}->set_user_data (manakai_source_line => 1);
  $self->{document}->set_user_data (manakai_source_column => 1);

  $self->{frameset_ok} = 1;
  delete $self->{active_formatting_elements};
  delete $self->{insert};
  delete $self->{open_tables};

  $self->{insertion_mode} = INITIAL_IM;
  undef $self->{form_element};
  undef $self->{head_element};
  $self->{open_elements} = [];
  undef $self->{inner_html_node};
  undef $self->{ignore_newline};
} # _initialize_tree_constructor

sub _terminate_tree_constructor ($) {
  my $self = shift;
  $self->{document}->strict_error_checking (1);
  delete $self->{active_formatting_elements};
  delete $self->{insert};
  delete $self->{open_tables};
  ## TODO: Turn mutation events on
} # _terminate_tree_constructor

## ISSUE: Should append_child (for example) in script executed in tree construction stage fire mutation events?

## When an interactive UA render the $self->{document} available to
## the user, or when it begin accepting user input, are not defined.

sub _reset_insertion_mode ($) {
  my $self = shift;

  ## Step 1
  my $last;
  
  ## Step 2
  my $i = -1;
  my $node = $self->{open_elements}->[$i];
    
  ## LOOP: Step 3
  LOOP: {
    if ($self->{open_elements}->[0]->[0] eq $node->[0]) {
      $last = 1;
      if (defined $self->{inner_html_node}) {
        !!!cp ('t28');
        $node = $self->{inner_html_node};
      } else {
        die "_reset_insertion_mode: t27";
      }
    }
    
    ## Step 4..13
    my $new_mode;
    if ($node->[1] == TABLE_CELL_EL) {
      if ($last) {
        !!!cp ('t28.2');
        #
      } else {
        !!!cp ('t28.3');
        $new_mode = IN_CELL_IM;
      } 
    } elsif ($node->[1] & FOREIGN_EL) {
      #
    } else {
      !!!cp ('t28.4');
      $new_mode = {
        select => IN_SELECT_IM,
        ## NOTE: |option| and |optgroup| do not set insertion mode to
        ## "in select" by themselves.
        tr => IN_ROW_IM,
        tbody => IN_TABLE_BODY_IM,
        thead => IN_TABLE_BODY_IM,
        tfoot => IN_TABLE_BODY_IM,
        caption => IN_CAPTION_IM,
        colgroup => IN_COLUMN_GROUP_IM,
        table => IN_TABLE_IM,
        head => IN_BODY_IM, # not in head!
        body => IN_BODY_IM,
        frameset => IN_FRAMESET_IM,
      }->{$node->[0]->manakai_local_name};
    }
    $self->{insertion_mode} = $new_mode and last LOOP if defined $new_mode;
    
    ## Step 14
    if ($node->[1] == HTML_EL) {
      ## NOTE: Commented out in the spec (HTML5 revision 3894).
      #unless (defined $self->{head_element}) {
        !!!cp ('t29');
        $self->{insertion_mode} = BEFORE_HEAD_IM;
      #} else {
        !!!cp ('t30');
      #  $self->{insertion_mode} = AFTER_HEAD_IM;
      #}
      last LOOP;
    } else {
      !!!cp ('t31');
    }
    
    ## Step 15
    $self->{insertion_mode} = IN_BODY_IM and last LOOP if $last;
    
    ## Step 16
    $i--;
    $node = $self->{open_elements}->[$i];
    
    ## Step 17
    redo LOOP;
  } # LOOP
  
  ## END
} # _reset_insertion_mode

  my $parse_rcdata = sub ($$$$) {
    my ($self, $insert, $open_tables, $parse_refs) = @_;

    ## Step 1
    my $start_tag_name = $self->{t}->{tag_name};
    !!!insert-element-t ($self->{t}->{tag_name}, $self->{t}->{attributes}, $self->{t});

    ## Step 2
    if ($parse_refs) {
      $self->{state} = RCDATA_STATE;
    } else {
      $self->{state} = RAWTEXT_STATE;
    }
    delete $self->{escape}; # MUST

    ## Step 3, 4
    $self->{insertion_mode} |= IN_CDATA_RCDATA_IM;

    !!!nack ('t40.1');
    !!!next-token;
  }; # $parse_rcdata

  my $script_start_tag = sub ($$$) {
    my ($self, $insert, $open_tables) = @_;

    ## Step 1
    my $script_el;
    !!!create-element ($script_el, HTML_NS, 'script', $self->{t}->{attributes}, $self->{t});

    ## Step 2
    ## TODO: mark as "parser-inserted"

    ## Step 3
    ## TODO: Mark as "already executed", if ...

    ## Step 4 (HTML5 revision 2702)
    $insert->($self, $script_el, $open_tables);
    push @{$self->{open_elements}}, [$script_el, $el_category->{script}];

    ## Step 5
    $self->{state} = SCRIPT_DATA_STATE;
    delete $self->{escape}; # MUST

    ## Step 6-7
    $self->{insertion_mode} |= IN_CDATA_RCDATA_IM;

    !!!nack ('t40.2');
    !!!next-token;
  }; # $script_start_tag

sub push_afe ($$) {
  my ($item => $afes) = @_;
  my $item_token = $item->[2];

  my $depth = 0;
  OUTER: for my $i (reverse 0..$#$afes) {
    my $afe = $afes->[$i];
    if ($afe->[0] eq '#marker') {
      last OUTER;
    } else {
      my $afe_token = $afe->[2];
      ## Both |$afe_token| and |$item_token| should be start tag tokens.
      if ($afe_token->{tag_name} eq $item_token->{tag_name}) {
        if ((keys %{$afe_token->{attributes}}) !=
            (keys %{$item_token->{attributes}})) {
          next OUTER;
        }
        for my $attr_name (keys %{$item_token->{attributes}}) {
          next OUTER unless $afe_token->{attributes}->{$attr_name};
          next OUTER unless
              $afe_token->{attributes}->{$attr_name}->{value} eq 
              $item_token->{attributes}->{$attr_name}->{value};
        }

        $depth++;
        if ($depth == 3) {
          splice @$afes, $i, 1 => ();
          last OUTER;
        }
      }

      ## We don't have to check namespaces of elements and attributes,
      ##  nevertheless the spec requires it, because |$afes| could
      ##  never contain a non-HTML element at the time of writing.  In
      ##  addition, scripted changes would never change the original
      ##  start tag token.
    }
  } # OUTER

  push @$afes, $item;
} # push_afe

  my $formatting_end_tag = sub {
    my ($self, $active_formatting_elements, $open_tables, $end_tag_token) = @_;
    my $tag_name = $end_tag_token->{tag_name};

    ## NOTE: The adoption agency algorithm (AAA).

    ## Step 1
    my $outer_loop_counter = 0;

    ## Step 2
    OUTER: {
      if ($outer_loop_counter >= 8) {
        !!!next-token;
        last OUTER;
      }

      ## Step 3
      $outer_loop_counter++;
      
      ## Step 4
      my $formatting_element;
      my $formatting_element_i_in_active;
      AFE: for (reverse 0..$#$active_formatting_elements) {
        if ($active_formatting_elements->[$_]->[0] eq '#marker') {
          !!!cp ('t52');
          last AFE;
        } elsif ($active_formatting_elements->[$_]->[0]->manakai_local_name
                     eq $tag_name) {
          ## NOTE: Non-HTML elements can't be in the list of active
          ## formatting elements.
          !!!cp ('t51');
          $formatting_element = $active_formatting_elements->[$_];
          $formatting_element_i_in_active = $_;
          last AFE;
        }
      } # AFE
      unless (defined $formatting_element) {
        !!!cp ('t53');
        !!!parse-error (type => 'unmatched end tag', text => $tag_name, token => $end_tag_token);
        ## Ignore the token
        !!!next-token;
        return;
      }
      ## has an element in scope
      my $in_scope = 1;
      my $formatting_element_i_in_open;  
      INSCOPE: for (reverse 0..$#{$self->{open_elements}}) {
        my $node = $self->{open_elements}->[$_];
        if ($node->[0] eq $formatting_element->[0]) {
          if ($in_scope) {
            !!!cp ('t54');
            $formatting_element_i_in_open = $_;
            last INSCOPE;
          } else { # in open elements but not in scope
            !!!cp ('t55');
            !!!parse-error (type => 'unmatched end tag',
                            text => $self->{t}->{tag_name},
                            token => $end_tag_token);
            ## Ignore the token
            !!!next-token;
            return;
          }
        } elsif ($node->[1] & SCOPING_EL) {
          !!!cp ('t56');
          $in_scope = 0;
        }
      } # INSCOPE
      unless (defined $formatting_element_i_in_open) {
        !!!cp ('t57');
        !!!parse-error (type => 'unmatched end tag',
                        text => $self->{t}->{tag_name},
                        token => $end_tag_token);
        pop @$active_formatting_elements; # $formatting_element
        !!!next-token; ## TODO: ok?
        return;
      }
      if (not $self->{open_elements}->[-1]->[0] eq $formatting_element->[0]) {
        !!!cp ('t58');
        !!!parse-error (type => 'not closed',
                        text => $self->{open_elements}->[-1]->[0]
                            ->manakai_local_name,
                        token => $end_tag_token);
      }
      
      ## Step 5
      my $furthest_block;
      my $furthest_block_i_in_open;
      OE: for (reverse 0..$#{$self->{open_elements}}) {
        my $node = $self->{open_elements}->[$_];
        if ($node->[1] & SPECIAL_EL or $node->[1] & SCOPING_EL) { ## "Special"
          !!!cp ('t59');
          $furthest_block = $node;
          $furthest_block_i_in_open = $_;
	  ## NOTE: The topmost (eldest) node.
        } elsif ($node->[0] eq $formatting_element->[0]) {
          !!!cp ('t60');
          last OE;
        }
      } # OE
      
      ## Step 6
      unless (defined $furthest_block) { # MUST
        !!!cp ('t61');
        splice @{$self->{open_elements}}, $formatting_element_i_in_open;
        splice @$active_formatting_elements, $formatting_element_i_in_active, 1;
        !!!next-token;
        return;
      }
      
      ## Step 7
      my $common_ancestor_node = $self->{open_elements}->[$formatting_element_i_in_open - 1];
      
      ## Step 8
      my $bookmark_prev_el
        = $active_formatting_elements->[$formatting_element_i_in_active - 1]
          ->[0];
      
      ## Step 9
      my $node = $furthest_block;
      my $node_i_in_open = $furthest_block_i_in_open;
      my $last_node = $furthest_block;

      ## Step 9.1
      my $inner_loop_counter = 0;

      INNER: {
        ## Step 9.2
        if ($inner_loop_counter >= 3) {
          !!!next-token;
          last OUTER;
        }

        ## Step 9.3
        $inner_loop_counter++;

        ## Step 9.4
        $node_i_in_open--;
        $node = $self->{open_elements}->[$node_i_in_open];
        
        ## Step 9.5
        my $node_i_in_active;
        my $node_token;
        S7S2: {
          for (reverse 0..$#$active_formatting_elements) {
            if ($active_formatting_elements->[$_]->[0] eq $node->[0]) {
              !!!cp ('t63');
              $node_i_in_active = $_;
              $node_token = $active_formatting_elements->[$_]->[2];
              last S7S2;
            }
          }
          splice @{$self->{open_elements}}, $node_i_in_open, 1;
          redo INNER;
        } # S7S2
        
        ## Step 9.6
        last INNER if $node->[0] eq $formatting_element->[0];
        
        ## Step 9.7
        my $new_element = [];
        !!!create-element ($new_element->[0], HTML_NS, $node_token->{tag_name}, $node_token->{attributes}, $node_token);
        $new_element->[1] = $node->[1];
        $new_element->[2] = $node_token;
        $active_formatting_elements->[$node_i_in_active] = $new_element;
        $self->{open_elements}->[$node_i_in_open] = $new_element;
        $node = $new_element;
        
        ## Step 9.8
        if ($last_node->[0] eq $furthest_block->[0]) {
          !!!cp ('t64');
          $bookmark_prev_el = $node->[0];
        }
        
        ## Step 9.9
        $node->[0]->append_child ($last_node->[0]);
        
        ## Step 9.10
        $last_node = $node;
        
        ## Step 9.11
        redo INNER;
      } # INNER
      
      ## Step 10
      if ($common_ancestor_node->[1] & TABLE_ROWS_EL) {
        ## Foster parenting.
        my $foster_parent_element;
        my $next_sibling;
        OE: for (reverse 0..$#{$self->{open_elements}}) {
          if ($self->{open_elements}->[$_]->[1] == TABLE_EL) {
            !!!cp ('t65.2');
            $foster_parent_element = $self->{open_elements}->[$_ - 1]->[0];
            $next_sibling = $self->{open_elements}->[$_]->[0];
            undef $next_sibling
                unless $next_sibling->parent_node eq $foster_parent_element;
            last OE;
          }
        } # OE
        $foster_parent_element ||= $self->{open_elements}->[0]->[0];

        $foster_parent_element->insert_before ($last_node->[0], $next_sibling);
        $open_tables->[-1]->[1] = 1; # tainted
      } else {
        !!!cp ('t65.3');
        $common_ancestor_node->[0]->append_child ($last_node->[0]);
      }
      
      ## Step 11
      my $new_element = [];
      !!!create-element ($new_element->[0], HTML_NS, $formatting_element->[2]->{tag_name}, $formatting_element->[2]->{attributes}, $formatting_element->[2]);
      $new_element->[1] = $formatting_element->[1];
      $new_element->[2] = $formatting_element->[2];
      
      ## Step 12
      my @cn = @{$furthest_block->[0]->child_nodes};
      $new_element->[0]->append_child ($_) for @cn;
      
      ## Step 13
      $furthest_block->[0]->append_child ($new_element->[0]);
      
      ## Step 14
      my $i;
      AFE: for (reverse 0..$#$active_formatting_elements) {
        if ($active_formatting_elements->[$_]->[0] eq $formatting_element->[0]) {
          !!!cp ('t66');
          splice @$active_formatting_elements, $_, 1;
          $i-- and last AFE if defined $i;
        } elsif ($active_formatting_elements->[$_]->[0] eq $bookmark_prev_el) {
          !!!cp ('t67');
          $i = $_;
        }
      } # AFE
      splice @$active_formatting_elements, $i + 1, 0 => $new_element;
      
      ## Step 15
      undef $i;
      OE: for (reverse 0..$#{$self->{open_elements}}) {
        if ($self->{open_elements}->[$_]->[0] eq $formatting_element->[0]) {
          !!!cp ('t68');
          splice @{$self->{open_elements}}, $_, 1;
          $i-- and last OE if defined $i;
        } elsif ($self->{open_elements}->[$_]->[0] eq $furthest_block->[0]) {
          !!!cp ('t69');
          $i = $_;
        }
      } # OE
      splice @{$self->{open_elements}}, $i + 1, 0, $new_element;
      
      ## Step 16
      redo OUTER;
    } # OUTER
  }; # $formatting_end_tag

  my $reconstruct_active_formatting_elements = sub ($$$$) {
    my ($self, $insert, $active_formatting_elements, $open_tables) = @_;

    ## Step 1
    return unless @$active_formatting_elements;

    ## Step 3
    my $i = -1;
    my $entry = $active_formatting_elements->[$i];

    ## Step 2
    return if $entry->[0] eq '#marker';
    for (@{$self->{open_elements}}) {
      if ($entry->[0] eq $_->[0]) {
        !!!cp ('t32');
        return;
      }
    }
    
    S4: {
      ## Step 4
      last S4 if $active_formatting_elements->[0]->[0] eq $entry->[0];

      ## Step 5
      $i--;
      $entry = $active_formatting_elements->[$i];

      ## Step 6
      if ($entry->[0] eq '#marker') {
        !!!cp ('t33_1');
        #
      } else {
        my $in_open_elements;
        OE: for (@{$self->{open_elements}}) {
          if ($entry->[0] eq $_->[0]) {
            !!!cp ('t33');
            $in_open_elements = 1;
            last OE;
          }
        }
        if ($in_open_elements) {
          !!!cp ('t34');
          #
        } else {
          ## NOTE: <!DOCTYPE HTML><p><b><i><u></p> <p>X
          !!!cp ('t35');
          redo S4;
        }
      }

      ## Step 7
      $i++;
      $entry = $active_formatting_elements->[$i];
    } # S4

    S7: {
      ## Step 8
      my $clone = [$entry->[0]->clone_node (0), $entry->[1], $entry->[2]];
    
      ## Step 9
      $insert->($self, $clone->[0], $open_tables);
      push @{$self->{open_elements}}, $clone;
      
      ## Step 10
      $active_formatting_elements->[$i] = $self->{open_elements}->[-1];

      ## Step 11
      unless ($clone->[0] eq $active_formatting_elements->[-1]->[0]) {
        !!!cp ('t36');
        ## Step 7'
        $i++;
        $entry = $active_formatting_elements->[$i];
        
        redo S7;
      }

      !!!cp ('t37');
    } # S7
  }; # $reconstruct_active_formatting_elements

  my $clear_up_to_marker = sub ($) {
    my $active_formatting_elements = $_[0];
    for (reverse 0..$#$active_formatting_elements) {
      if ($active_formatting_elements->[$_]->[0] eq '#marker') {
        !!!cp ('t38');
        splice @$active_formatting_elements, $_;
        return;
      }
    }

    !!!cp ('t39');
  }; # $clear_up_to_marker
  my $insert_to_current = sub {
    #my ($self, $child, $open_tables) = @_;
    $_[0]->{open_elements}->[-1]->[0]->append_child ($_[1]);
  }; # $insert_to_current

  ## Foster parenting.  Note that there are three "foster parenting"
  ## code in the parser: for elements (this one), for texts, and for
  ## elements in the AAA code.
  my $insert_to_foster = sub {
    my ($self, $child, $open_tables) = @_;
    if ($self->{open_elements}->[-1]->[1] & TABLE_ROWS_EL) {
      # MUST
      my $foster_parent_element;
      my $next_sibling;
      OE: for (reverse 0..$#{$self->{open_elements}}) {
        if ($self->{open_elements}->[$_]->[1] == TABLE_EL) {
          !!!cp ('t71');
          $foster_parent_element = $self->{open_elements}->[$_ - 1]->[0];
          $next_sibling = $self->{open_elements}->[$_]->[0];
          undef $next_sibling
              unless $next_sibling->parent_node eq $foster_parent_element;
          last OE;
        }
      } # OE
      $foster_parent_element ||= $self->{open_elements}->[0]->[0];

      $foster_parent_element->insert_before ($child, $next_sibling);
      $open_tables->[-1]->[1] = 1; # tainted
    } else {
      !!!cp ('t72');
      $self->{open_elements}->[-1]->[0]->append_child ($child);
    }
  }; # $insert_to_foster

sub _construct_tree ($) {
  my $self = $_[0];

  ## "List of active formatting elements".  Each item in this array is
  ## an array reference, which contains: [0] - the element node; [1] -
  ## the local name of the element; [2] - the token that is used to
  ## create [0].
  my $active_formatting_elements = $self->{active_formatting_elements} ||= [];

  my $insert = $self->{insert} ||= $insert_to_current;

  ## NOTE: $open_tables->[-1]->[0] is the "current table" element node.
  ## NOTE: $open_tables->[-1]->[1] is the "tainted" flag (OBSOLETE; unused).
  ## NOTE: $open_tables->[-1]->[2] is set false when non-Text node inserted.
  my $open_tables = $self->{open_tables} ||= [];

  B: while (1) {
    !!!pdebug { print STDERR join ' ', map { $_->[0] ? $_->[0]->manakai_local_name : '' } @{$self->{open_elements}}; print STDERR ' '; _printim ($self->{insertion_mode}); warn Dumper $self->{t}; };

    if ($self->{t}->{type} == ABORT_TOKEN) {
      return;
    }

    if ($self->{t}->{n}++ == 100) {
      !!!parse-error (type => 'parser impl error', # XXXtest
                      token => $self->{t});
      require Data::Dumper;
      warn "====== HTML Parser Error ======\n";
      warn join (' ', map { $_->[0]->manakai_local_name } @{$self->{open_elements}}) . ' #' . $self->{insertion_mode} . "\n";
      warn Data::Dumper::Dumper ($self->{t});
      !!!next-token;
      next B;
    }

    if ($self->{insertion_mode} == INITIAL_IM) {
      if ($self->{t}->{type} == DOCTYPE_TOKEN) {
        ## NOTE: Conformance checkers MAY, instead of reporting "not
        ## HTML5" error, switch to a conformance checking mode for
        ## another language.  (We don't support such mode switchings;
        ## it is nonsense to do anything different from what browsers
        ## do.)
        my $doctype_name = $self->{t}->{name};
        $doctype_name = '' unless defined $doctype_name;
        my $doctype = $self->{document}->create_document_type_definition
            ($doctype_name);
        
        if ($doctype_name ne 'html') {
          !!!cp ('t1');
          !!!parse-error (type => 'not HTML5', token => $self->{t});
        } elsif (defined $self->{t}->{pubid}) {
          ## Obsolete permitted DOCTYPEs (case-sensitive)
          my $xsysid = $Whatpm::HTML::ParserData::ObsoletePermittedDoctypes
              ->{$self->{t}->{pubid}};
          if (defined $xsysid and
              (not defined $self->{t}->{sysid} or
               $self->{t}->{sysid} eq $xsysid)) {
            !!!cp ('t2');
            !!!parse-error (type => 'obs DOCTYPE', token => $self->{t},
                            level => $self->{level}->{obsconforming});
          } else {
            !!!cp ('t2.1');
            !!!parse-error (type => 'not HTML5', token => $self->{t});
          }
        } elsif (defined $self->{t}->{sysid}) {
          if ($self->{t}->{sysid} eq 'about:legacy-compat') {
            ## <!DOCTYPE HTML SYSTEM "about:legacy-compat">
            !!!cp ('t1.2');
            !!!parse-error (type => 'XSLT-compat', token => $self->{t},
                            level => $self->{level}->{should});
          } else {
            !!!parse-error (type => 'not HTML5', token => $self->{t});
          }
        } else { ## <!DOCTYPE HTML>
          !!!cp ('t3');
          #
        }
        
        ## NOTE: Default value for both |public_id| and |system_id|
        ## attributes are empty strings, so that we don't set any
        ## value in missing cases.
        $doctype->public_id ($self->{t}->{pubid})
            if defined $self->{t}->{pubid};
        $doctype->system_id ($self->{t}->{sysid})
            if defined $self->{t}->{sysid};
        
        ## NOTE: Other DocumentType attributes are null or empty
        ## lists.  In Firefox3, |internalSubset| attribute is set to
        ## the empty string, while |null| is an allowed value for the
        ## attribute according to DOM3 Core.

        $self->{document}->append_child ($doctype);
        
        if ($self->{t}->{quirks} or $doctype_name ne 'html') {
          !!!cp ('t4');
          $self->{document}->manakai_compat_mode ('quirks');
        } elsif (defined $self->{t}->{pubid}) {
          my $pubid = $self->{t}->{pubid};
          $pubid =~ tr/a-z/A-Z/; ## ASCII case-insensitive.
          my $prefix = $Whatpm::HTML::ParserData::QuirkyPublicIDPrefixes;
          my $match;
          for (@$prefix) {
            if (substr ($pubid, 0, length $_) eq $_) {
              $match = 1;
              last;
            }
          }
          if ($match or
              $Whatpm::HTML::ParserData::QuirkyPublicIDs->{$pubid}) {
            !!!cp ('t5');
            $self->{document}->manakai_compat_mode ('quirks');
          } elsif ($pubid =~ m[^-//W3C//DTD HTML 4.01 FRAMESET//] or
                   $pubid =~ m[^-//W3C//DTD HTML 4.01 TRANSITIONAL//]) {
            if (defined $self->{t}->{sysid}) {
              !!!cp ('t6');
              $self->{document}->manakai_compat_mode ('quirks');
            } else {
              !!!cp ('t7');
              $self->{document}->manakai_compat_mode ('limited quirks');
            }
          } elsif ($pubid =~ m[^-//W3C//DTD XHTML 1.0 FRAMESET//] or
                   $pubid =~ m[^-//W3C//DTD XHTML 1.0 TRANSITIONAL//]) {
            !!!cp ('t8');
            $self->{document}->manakai_compat_mode ('limited quirks');
          } else {
            !!!cp ('t9');
          }
        } else {
          !!!cp ('t10');
        }
        if (defined $self->{t}->{sysid}) {
          my $sysid = $self->{t}->{sysid};
          $sysid =~ tr/A-Z/a-z/; ## ASCII case-insensitive.
          if ($sysid eq "http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd") {
            ## NOTE: Ensure that |PUBLIC "(limited quirks)"
            ## "(quirks)"| is signaled as in quirks mode!
            $self->{document}->manakai_compat_mode ('quirks');
            !!!cp ('t11');
          } else {
            !!!cp ('t12');
          }
        } else {
          !!!cp ('t13');
        }
        
        $self->{insertion_mode} = BEFORE_HTML_IM;
        !!!next-token;
        next B;
      } elsif ({
                START_TAG_TOKEN, 1,
                END_TAG_TOKEN, 1,
                END_OF_FILE_TOKEN, 1,
               }->{$self->{t}->{type}}) {
        unless ($self->{document}->manakai_is_srcdoc) {
          !!!cp ('t14.1');
          !!!parse-error (type => 'no DOCTYPE', token => $self->{t});
          $self->{document}->manakai_compat_mode ('quirks');
        } else {
          !!!cp ('t14.2');
        }
        $self->{insertion_mode} = BEFORE_HTML_IM;
        ## Reprocess the token.
        !!!ack-later;
        redo B;
      } elsif ($self->{t}->{type} == CHARACTER_TOKEN) {
        if ($self->{t}->{data} =~ s/^([\x09\x0A\x0C\x20]+)//) {
          ## Ignore the token
          
          unless (length $self->{t}->{data}) {
            !!!cp ('t15');
            ## Stay in the insertion mode.
            !!!next-token;
            redo B;
          } else {
            !!!cp ('t16');
          }
        } else {
          !!!cp ('t17');
        }
        
        unless ($self->{document}->manakai_is_srcdoc) {
          !!!cp ('t17.1');
          !!!parse-error (type => 'no DOCTYPE', token => $self->{t});
          $self->{document}->manakai_compat_mode ('quirks');
        } else {
          !!!cp ('t17.2');
        }
        $self->{insertion_mode} = BEFORE_HTML_IM;
        ## Reprocess the token.
        redo B;
      } elsif ($self->{t}->{type} == COMMENT_TOKEN) {
        !!!cp ('t18');
        my $comment = $self->{document}->create_comment
            ($self->{t}->{data});
        $self->{document}->append_child ($comment);
        
        ## Stay in the insertion mode.
        !!!next-token;
        next B;
      } else {
        die "$0: $self->{t}->{type}: Unknown token type";
      }
    } elsif ($self->{insertion_mode} == BEFORE_HTML_IM) {
      if ($self->{t}->{type} == DOCTYPE_TOKEN) {
        !!!cp ('t19');
        !!!parse-error (type => 'in html:#DOCTYPE', token => $self->{t});
        ## Ignore the token.
        !!!next-token;
        redo B;
      } elsif ($self->{t}->{type} == COMMENT_TOKEN) {
        !!!cp ('t20');
        my $comment = $self->{document}->create_comment
            ($self->{t}->{data});
        $self->{document}->append_child ($comment);
        !!!next-token;
        redo B;
      } elsif ($self->{t}->{type} == CHARACTER_TOKEN) {
        if ($self->{t}->{data} =~ s/^([\x09\x0A\x0C\x20]+)//) {
          ## Ignore the token.
          
          unless (length $self->{t}->{data}) {
            !!!cp ('t21');
            !!!next-token;
            redo B;
          } else {
            !!!cp ('t22');
          }
        } else {
          !!!cp ('t23');
        }
        
        $self->{application_cache_selection}->(undef);
        
        #
      } elsif ($self->{t}->{type} == START_TAG_TOKEN) {
        if ($self->{t}->{tag_name} eq 'html') {
          my $root_element;
          !!!create-element ($root_element, HTML_NS, $self->{t}->{tag_name}, $self->{t}->{attributes}, $self->{t});
          $self->{document}->append_child ($root_element);
          push @{$self->{open_elements}},
              [$root_element, $el_category->{html}];
          
          if ($self->{t}->{attributes}->{manifest}) {
            !!!cp ('t24');
            ## XXX resolve URL and drop fragment
            ## <http://html5.org/tools/web-apps-tracker?from=3479&to=3480>
            ## <http://manakai.g.hatena.ne.jp/task/2/95>
            $self->{application_cache_selection}
                 ->($self->{t}->{attributes}->{manifest}->{value});
          } else {
            !!!cp ('t25');
            $self->{application_cache_selection}->(undef);
          }
          
          !!!nack ('t25.1');
          
          !!!next-token;
          $self->{insertion_mode} = BEFORE_HEAD_IM;
          next B;
        } else {
          !!!cp ('t25.2');
          #
        }
      } elsif ($self->{t}->{type} == END_TAG_TOKEN) {
        if ({
             head => 1, body => 1, html => 1, br => 1,
            }->{$self->{t}->{tag_name}}) {
          !!!cp ('t25.3');
          #
        } else {
          !!!cp ('t25.4');
          !!!parse-error (type => 'unmatched end tag',
                          text => $self->{t}->{tag_name},
                          token => $self->{t});
          ## Ignore the token.
          !!!next-token;
          redo B;
        }
      } elsif ($self->{t}->{type} == END_OF_FILE_TOKEN) {
        !!!cp ('t26');
        #
      } else {
        die "$0: $self->{t}->{type}: Unknown token type";
      }
      
      my $root_element;
      !!!create-element ($root_element, HTML_NS, 'html',, $self->{t});
      $self->{document}->append_child ($root_element);
      push @{$self->{open_elements}},
          [$root_element, $el_category->{html}];
      push @$open_tables, [[$root_element]];
      
      $self->{application_cache_selection}->(undef);
      
      ## Reprocess the token.
      !!!ack-later;
      $self->{insertion_mode} = BEFORE_HEAD_IM;
      redo B;
    } # insertion mode

    if (
      (not @{$self->{open_elements}}) or
      (not $self->{open_elements}->[-1]->[1] & FOREIGN_EL) or ## HTML element
      ($self->{open_elements}->[-1]->[1] == MML_TEXT_INTEGRATION_EL and
       (($self->{t}->{type} == START_TAG_TOKEN and
         $self->{t}->{tag_name} ne 'mglyph' and
         $self->{t}->{tag_name} ne 'malignmark') or
        $self->{t}->{type} == CHARACTER_TOKEN)) or
      ($self->{open_elements}->[-1]->[1] & MML_AXML_EL and
       $self->{t}->{type} == START_TAG_TOKEN and
       $self->{t}->{tag_name} eq 'svg') or
      ( ## If the current node is an HTML integration point (other
        ## than |annotation-xml|).
       $self->{open_elements}->[-1]->[1] == SVG_INTEGRATION_EL and
       ($self->{t}->{type} == START_TAG_TOKEN or
        $self->{t}->{type} == CHARACTER_TOKEN)) or
      ( ## If the current node is an |annotation-xml| whose |encoding|
        ## is |text/html| or |application/xhtml+xml| (HTML integration
        ## point).
       $self->{open_elements}->[-1]->[1] == MML_AXML_EL and
       ($self->{t}->{type} == START_TAG_TOKEN or
        $self->{t}->{type} == CHARACTER_TOKEN) and
       do {
         my $encoding = $self->{open_elements}->[-1]->[0]->get_attribute_ns (undef, 'encoding') || '';
         $encoding =~ tr/A-Z/a-z/; ## ASCII case-insensitive.
         if ($encoding eq 'text/html' or 
             $encoding eq 'application/xhtml+xml') {
           1;
         } else {
           0;
         }
       }) or
      ($self->{t}->{type} == END_OF_FILE_TOKEN)) {
      !!!cp ('t87.1');
      ## Use the rules for the current insertion mode in HTML content.
      #
    } else {
      ## Use the rules for the foreign content.

      if ($self->{t}->{type} == CHARACTER_TOKEN) {
        ## "In foreign content", character tokens.
        my $data = $self->{t}->{data};
        while ($data =~ s/\x00/\x{FFFD}/) {
          !!!parse-error (type => 'NULL', token => $self->{t});
        }
        $self->{open_elements}->[-1]->[0]->manakai_append_text ($data);
        if ($data =~ /[^\x09\x0A\x0C\x0D\x20]/) {
          delete $self->{frameset_ok};
        }
        
        !!!next-token;
        next B;
      } elsif ($self->{t}->{type} == START_TAG_TOKEN) {
        ## "In foreign content", start tag token.

        if (
          {
            b => 1, big => 1, blockquote => 1, body => 1, br => 1,
            center => 1, code => 1, dd => 1, div => 1, dl => 1, dt => 1,
            em => 1, embed => 1, h1 => 1, h2 => 1, h3 => 1, h4 => 1,
            h5 => 1, h6 => 1, head => 1, hr => 1, i => 1, img => 1, li => 1,
            listing => 1, menu => 1, meta => 1, nobr => 1, ol => 1,
            p => 1, pre => 1, ruby => 1, s => 1, small => 1, span => 1,
            strong => 1, strike => 1, sub => 1, sup => 1, table => 1,
            tt => 1, u => 1, ul => 1, var => 1,
          }->{$self->{t}->{tag_name}} or
          ($self->{t}->{tag_name} eq 'font' and
           ($self->{t}->{attributes}->{color} or
            $self->{t}->{attributes}->{face} or
            $self->{t}->{attributes}->{size}))
        ) {
          ## "In foreign content", HTML-only start tag.
          !!!cp ('t87.2');

          !!!parse-error (type => 'not closed',
                          text => $self->{open_elements}->[-1]->[0]
                              ->manakai_local_name,
                          token => $self->{t});

          pop @{$self->{open_elements}};
          V: {
            my $current_node = $self->{open_elements}->[-1];
            if (
              ## An HTML element.
              not $current_node->[1] & FOREIGN_EL or

              ## An MathML text integration point.
              $current_node->[1] == MML_TEXT_INTEGRATION_EL or
              
              ## An HTML integration point.
              $current_node->[1] == SVG_INTEGRATION_EL or
              ($current_node->[1] == MML_AXML_EL and
               do {
                 my $encoding = $current_node->[0]->get_attribute_ns (undef, 'encoding') || '';
                 $encoding =~ tr/A-Z/a-z/; ## ASCII case-insensitive.
                 ($encoding eq 'text/html' or
                  $encoding eq 'application/xhtml+xml');
               })
            ) {
              last V;
            }
            
            pop @{$self->{open_elements}};
            redo V;
          }
          
          ## Reprocess the token.
          next B;

        } else {
          ## "In foreign content", foreign start tag.

          my $nsuri = $self->{open_elements}->[-1]->[0]->namespace_uri;
          my $tag_name = $self->{t}->{tag_name};
          if ($nsuri eq SVG_NS) {
            $tag_name = $Whatpm::HTML::ParserData::SVGElementNameFixup
                ->{$tag_name} || $tag_name;
          }

          ## "adjust SVG attributes" (SVG only) - done in insert-element-f

          ## "adjust foreign attributes" - done in insert-element-f

          !!!insert-element-f ($nsuri, $tag_name, $self->{t}->{attributes}, $self->{t});

          if ($self->{self_closing}) {
            pop @{$self->{open_elements}};
            !!!ack ('t87.3');
          } else {
            !!!cp ('t87.4');
          }

          !!!next-token;
          next B;
        }

      } elsif ($self->{t}->{type} == END_TAG_TOKEN) {
        ## "In foreign content", end tag.

        if ($self->{t}->{tag_name} eq 'script' and
            $self->{open_elements}->[-1]->[1] == SVG_SCRIPT_EL) {
          ## "In foreign content", "script" end tag, if the current
          ## node is an SVG |script| element.
          !!!cp ('t87.41');
          pop @{$self->{open_elements}};

          ## XXXscript: Execute script here.
          !!!next-token;
          next B;

        } else {
          ## "In foreign content", end tag.
          !!!cp ('t87.42');
          
          ## 1.
          my $i = -1;
          my $node = $self->{open_elements}->[$i];
          
          ## 2.
          my $tag_name = $node->[0]->manakai_local_name;
          $tag_name =~ tr/A-Z/a-z/; ## ASCII case-insensitive.
          if ($tag_name ne $self->{t}->{tag_name}) {
            !!!parse-error (type => 'unmatched end tag',
                            text => $self->{t}->{tag_name},
                            level => $self->{level}->{must});
          }

          ## 3.
          LOOP: {
            my $tag_name = $node->[0]->manakai_local_name;
            $tag_name =~ tr/A-Z/a-z/; ## ASCII case-insensitive.
            if ($tag_name eq $self->{t}->{tag_name}) {
              splice @{$self->{open_elements}}, $i, -$i, ();
              !!!next-token;
              next B;
            }
            
            ## 4.
            $i--;
            $node = $self->{open_elements}->[$i];

            ## 5.
            if ($node->[1] & FOREIGN_EL) {
              redo LOOP;
            }
          } # LOOP

          ## Step 6 (Use the current insertion mode in HTML content)
          #
        }

      } elsif ($self->{t}->{type} == COMMENT_TOKEN) {
        ## "In foreign content", comment token.
        my $comment = $self->{document}->create_comment ($self->{t}->{data});
        $self->{open_elements}->[-1]->[0]->append_child ($comment);
        !!!next-token;
        next B;
      } elsif ($self->{t}->{type} == DOCTYPE_TOKEN) {
        !!!cp ('t87.2');
        ## "In foreign content", DOCTYPE token.
        !!!parse-error (type => 'in html:#DOCTYPE', token => $self->{t});
        ## Ignore the token.
        !!!next-token;
        next B;
      } else {
        die "$0: $self->{t}->{type}: Unknown token type";        
      }
    } # foreign

    ## The "in table text" insertion mode.
    if ($self->{insertion_mode} & TABLE_IMS and
        not $self->{insertion_mode} & IN_CDATA_RCDATA_IM) {
      C: {
        my $s;
        if ($self->{t}->{type} == CHARACTER_TOKEN) {
          !!!cp ('t194');
          $self->{pending_chars} ||= [];
          push @{$self->{pending_chars}}, $self->{t};
          !!!next-token;
          next B;
        } else {
          ## There is an "insert pending chars" code clone.
          if ($self->{pending_chars}) {
            $s = join '', map { $_->{data} } @{$self->{pending_chars}};
            delete $self->{pending_chars};
            while ($s =~ s/\x00//) {
              !!!parse-error (type => 'NULL', token => $self->{t});
            }
            if ($s eq '') {
              last C;
            } elsif ($s =~ /[^\x09\x0A\x0C\x0D\x20]/) {
              !!!cp ('t195');
              #
            } else {
              !!!cp ('t195.1');
              $self->{open_elements}->[-1]->[0]->manakai_append_text ($s);
              last C;
            }
          } else {
            !!!cp ('t195.2');
            last C;
          }
        }

        ## "in table" insertion mode, "Anything else".

        ## Foster parenting.
        !!!parse-error (type => 'in table:#text', token => $self->{t});

        ## NOTE: As if in body, but insert into the foster parent element.
        $reconstruct_active_formatting_elements
            ->($self, $insert_to_foster, $active_formatting_elements,
               $open_tables);
            
        if ($self->{open_elements}->[-1]->[1] & TABLE_ROWS_EL) {
          # MUST
          my $foster_parent_element;
          my $next_sibling;
          OE: for (reverse 0..$#{$self->{open_elements}}) {
            if ($self->{open_elements}->[$_]->[1] == TABLE_EL) {
              !!!cp ('t197');
              $foster_parent_element = $self->{open_elements}->[$_ - 1]->[0];
              $next_sibling = $self->{open_elements}->[$_]->[0];
              undef $next_sibling
                unless $next_sibling->parent_node eq $foster_parent_element;
              last OE;
            }
          } # OE
          $foster_parent_element ||= $self->{open_elements}->[0]->[0];

          !!!cp ('t199');
          $foster_parent_element->insert_before
              ($self->{document}->create_text_node ($s), $next_sibling);

          $open_tables->[-1]->[1] = 1; # tainted
          $open_tables->[-1]->[2] = 1; # ~node inserted
        } else {
          ## NOTE: Fragment case or in a foster parent'ed element
          ## (e.g. |<table><span>a|).  In fragment case, whether the
          ## character is appended to existing node or a new node is
          ## created is irrelevant, since the foster parent'ed nodes
          ## are discarded and fragment parsing does not invoke any
          ## script.
          !!!cp ('t200');
          $self->{open_elements}->[-1]->[0]->manakai_append_text ($s);
        }
      } # C
    } # TABLE_IMS

    if ($self->{t}->{type} == DOCTYPE_TOKEN) {
      !!!cp ('t73');
      !!!parse-error (type => 'in html:#DOCTYPE', token => $self->{t});
      ## Ignore the token
      ## Stay in the phase
      !!!next-token;
      next B;
    } elsif ($self->{t}->{type} == START_TAG_TOKEN and
             $self->{t}->{tag_name} eq 'html') {
      if ($self->{insertion_mode} == AFTER_HTML_BODY_IM) {
        !!!cp ('t79');
        !!!parse-error (type => 'after html', text => 'html', token => $self->{t});
        $self->{insertion_mode} = AFTER_BODY_IM;
      } elsif ($self->{insertion_mode} == AFTER_HTML_FRAMESET_IM) {
        !!!cp ('t80');
        !!!parse-error (type => 'after html', text => 'html', token => $self->{t});
        $self->{insertion_mode} = AFTER_FRAMESET_IM;
      } else {
        !!!cp ('t81');
      }

      !!!cp ('t82');
      !!!parse-error (type => 'not first start tag', token => $self->{t});
      my $top_el = $self->{open_elements}->[0]->[0];
      for my $attr_name (keys %{$self->{t}->{attributes}}) {
        unless ($top_el->has_attribute_ns (undef, $attr_name)) {
          !!!cp ('t84');
          $top_el->set_attribute_ns
            (undef, [undef, $attr_name], 
             $self->{t}->{attributes}->{$attr_name}->{value});
        }
      }
      !!!nack ('t84.1');
      !!!next-token;
      next B;
    } elsif ($self->{t}->{type} == COMMENT_TOKEN) {
      my $comment = $self->{document}->create_comment ($self->{t}->{data});
      if ($self->{insertion_mode} & AFTER_HTML_IMS) {
        !!!cp ('t85');
        $self->{document}->append_child ($comment);
      } elsif ($self->{insertion_mode} == AFTER_BODY_IM) {
        !!!cp ('t86');
        $self->{open_elements}->[0]->[0]->append_child ($comment);
      } else {
        !!!cp ('t87');
        $self->{open_elements}->[-1]->[0]->append_child ($comment);
        $open_tables->[-1]->[2] = 0 if @$open_tables; # ~node inserted
      }
      !!!next-token;
      next B;
    } elsif ($self->{insertion_mode} & IN_CDATA_RCDATA_IM) {
      if ($self->{t}->{type} == CHARACTER_TOKEN) {
        $self->{t}->{data} =~ s/^\x0A// if $self->{ignore_newline};
        delete $self->{ignore_newline};

        if (length $self->{t}->{data}) {
          !!!cp ('t43');
          ## NOTE: NULLs are replaced into U+FFFDs in tokenizer.
          $self->{open_elements}->[-1]->[0]->manakai_append_text
              ($self->{t}->{data});
        } else {
          !!!cp ('t43.1');
        }
        !!!next-token;
        next B;
      } elsif ($self->{t}->{type} == END_TAG_TOKEN) {
        delete $self->{ignore_newline};

        if ($self->{t}->{tag_name} eq 'script') {
          !!!cp ('t50');
          
          ## Para 1-2
          my $script = pop @{$self->{open_elements}};
          
          ## Para 3
          $self->{insertion_mode} &= ~ IN_CDATA_RCDATA_IM;

          ## Para 4
          ## TODO: $old_insertion_point = $current_insertion_point;
          ## TODO: $current_insertion_point = just before $self->{nc};

          ## Para 5
          ## TODO: Run the $script->[0].

          ## Para 6
          ## TODO: $current_insertion_point = $old_insertion_point;

          ## Para 7
          ## TODO: if ($pending_external_script) {
            ## TODO: ...
          ## TODO: }

          !!!next-token;
          next B;
        } else {
          !!!cp ('t42');
 
          pop @{$self->{open_elements}};

          $self->{insertion_mode} &= ~ IN_CDATA_RCDATA_IM;
          !!!next-token;
          next B;
        }
      } elsif ($self->{t}->{type} == END_OF_FILE_TOKEN) {
        delete $self->{ignore_newline};

        !!!cp ('t44');
        !!!parse-error (type => 'not closed',
                        text => $self->{open_elements}->[-1]->[0]
                            ->manakai_local_name,
                        token => $self->{t});

        #if ($self->{open_elements}->[-1]->[1] == SCRIPT_EL) {
        #  ## TODO: Mark as "already executed"
        #}

        pop @{$self->{open_elements}};

        $self->{insertion_mode} &= ~ IN_CDATA_RCDATA_IM;
        ## Reprocess.
        next B;
      } else {
        die "$0: $self->{t}->{type}: In CDATA/RCDATA: Unknown token type";        
      }
    } # insertion_mode

    if ($self->{insertion_mode} & HEAD_IMS) {
      if ($self->{t}->{type} == CHARACTER_TOKEN) {
        if ($self->{t}->{data} =~ s/^([\x09\x0A\x0C\x20]+)//) {
          unless ($self->{insertion_mode} == BEFORE_HEAD_IM) {
            !!!cp ('t88.2');
            $self->{open_elements}->[-1]->[0]->manakai_append_text ($1);
          } else {
            !!!cp ('t88.1');
            ## Ignore the token.
            #
          }
          unless (length $self->{t}->{data}) {
            !!!cp ('t88');
            !!!next-token;
            next B;
          }
## TODO: set $self->{t}->{column} appropriately
        }

        if ($self->{insertion_mode} == BEFORE_HEAD_IM) {
          !!!cp ('t89');
          ## As if <head>
          !!!create-element ($self->{head_element}, HTML_NS, 'head',, $self->{t});
          $self->{open_elements}->[-1]->[0]->append_child ($self->{head_element});
          push @{$self->{open_elements}},
              [$self->{head_element}, $el_category->{head}];

          ## Reprocess in the "in head" insertion mode...
          pop @{$self->{open_elements}};

          ## Reprocess in the "after head" insertion mode...
        } elsif ($self->{insertion_mode} == IN_HEAD_NOSCRIPT_IM) {
          !!!cp ('t90');
          ## As if </noscript>
          pop @{$self->{open_elements}};
          !!!parse-error (type => 'in noscript:#text', token => $self->{t});
          
          ## Reprocess in the "in head" insertion mode...
          ## As if </head>
          pop @{$self->{open_elements}};

          ## Reprocess in the "after head" insertion mode...
        } elsif ($self->{insertion_mode} == IN_HEAD_IM) {
          !!!cp ('t91');
          pop @{$self->{open_elements}};

          ## Reprocess in the "after head" insertion mode...
        } else {
          !!!cp ('t92');
        }

        ## "after head" insertion mode
        ## As if <body>
        !!!insert-element ('body',, $self->{t});
        $self->{insertion_mode} = IN_BODY_IM;
        ## The "frameset-ok" flag is left unchanged in this case.
        ## Reporcess the token.
        next B;
      } elsif ($self->{t}->{type} == START_TAG_TOKEN) {
        if ($self->{t}->{tag_name} eq 'head') {
          if ($self->{insertion_mode} == BEFORE_HEAD_IM) {
            !!!cp ('t93');
            !!!create-element ($self->{head_element}, HTML_NS, $self->{t}->{tag_name}, $self->{t}->{attributes}, $self->{t});
            $self->{open_elements}->[-1]->[0]->append_child
                ($self->{head_element});
            push @{$self->{open_elements}},
                [$self->{head_element}, $el_category->{head}];
            $self->{insertion_mode} = IN_HEAD_IM;
            !!!nack ('t93.1');
            !!!next-token;
            next B;
          } elsif ($self->{insertion_mode} == AFTER_HEAD_IM) {
            !!!cp ('t93.2');
            !!!parse-error (type => 'after head', text => 'head',
                            token => $self->{t});
            ## Ignore the token
            !!!nack ('t93.3');
            !!!next-token;
            next B;
          } else {
            !!!cp ('t95');
            !!!parse-error (type => 'in head:head',
                            token => $self->{t}); # or in head noscript
            ## Ignore the token
            !!!nack ('t95.1');
            !!!next-token;
            next B;
          }
        } elsif ($self->{insertion_mode} == BEFORE_HEAD_IM) {
          !!!cp ('t96');
          ## As if <head>
          !!!create-element ($self->{head_element}, HTML_NS, 'head',, $self->{t});
          $self->{open_elements}->[-1]->[0]->append_child ($self->{head_element});
          push @{$self->{open_elements}},
              [$self->{head_element}, $el_category->{head}];

          $self->{insertion_mode} = IN_HEAD_IM;
          ## Reprocess in the "in head" insertion mode...
        } else {
          !!!cp ('t97');
        }

        if ($self->{t}->{tag_name} eq 'base') {
          if ($self->{insertion_mode} == IN_HEAD_NOSCRIPT_IM) {
            !!!cp ('t98');
            ## As if </noscript>
            pop @{$self->{open_elements}};
            !!!parse-error (type => 'in noscript', text => 'base',
                            token => $self->{t});
          
            $self->{insertion_mode} = IN_HEAD_IM;
            ## Reprocess in the "in head" insertion mode...
          } else {
            !!!cp ('t99');
          }

          ## NOTE: There is a "as if in head" code clone.
          if ($self->{insertion_mode} == AFTER_HEAD_IM) {
            !!!cp ('t100');
            !!!parse-error (type => 'after head',
                            text => $self->{t}->{tag_name}, token => $self->{t});
            push @{$self->{open_elements}},
                [$self->{head_element}, $el_category->{head}];
          } else {
            !!!cp ('t101');
          }
          !!!insert-element ($self->{t}->{tag_name}, $self->{t}->{attributes}, $self->{t});
          pop @{$self->{open_elements}};
          pop @{$self->{open_elements}} # <head>
              if $self->{insertion_mode} == AFTER_HEAD_IM;
          !!!nack ('t101.1');
          !!!next-token;
          next B;
        } elsif ({
          link => 1, basefont => 1, bgsound => 1,
        }->{$self->{t}->{tag_name}}) {
          ## NOTE: There is a "as if in head" code clone.
          if ($self->{insertion_mode} == AFTER_HEAD_IM) {
            !!!cp ('t102');
            !!!parse-error (type => 'after head',
                            text => $self->{t}->{tag_name}, token => $self->{t});
            push @{$self->{open_elements}},
                [$self->{head_element}, $el_category->{head}];
          } else {
            !!!cp ('t103');
          }
          !!!insert-element ($self->{t}->{tag_name}, $self->{t}->{attributes}, $self->{t});
          pop @{$self->{open_elements}};
          pop @{$self->{open_elements}} # <head>
              if $self->{insertion_mode} == AFTER_HEAD_IM;
          !!!ack ('t103.1');
          !!!next-token;
          next B;
        } elsif ($self->{t}->{tag_name} eq 'command') {
          if ($self->{insertion_mode} == IN_HEAD_IM) {
            ## NOTE: If the insertion mode at the time of the emission
            ## of the token was "before head", $self->{insertion_mode}
            ## is already changed to |IN_HEAD_IM|.

            ## NOTE: There is a "as if in head" code clone.
            !!!insert-element ($self->{t}->{tag_name}, $self->{t}->{attributes}, $self->{t});
            pop @{$self->{open_elements}};
            pop @{$self->{open_elements}} # <head>
                if $self->{insertion_mode} == AFTER_HEAD_IM;
            !!!ack ('t103.2');
            !!!next-token;
            next B;
          } else {
            ## NOTE: "in head noscript" or "after head" insertion mode
            ## - in these cases, these tags are treated as same as
            ## normal in-body tags.
            !!!cp ('t103.3');
            #
          }
        } elsif ($self->{t}->{tag_name} eq 'meta') {
          ## NOTE: There is a "as if in head" code clone.
          if ($self->{insertion_mode} == AFTER_HEAD_IM) {
            !!!cp ('t104');
            !!!parse-error (type => 'after head',
                            text => $self->{t}->{tag_name}, token => $self->{t});
            push @{$self->{open_elements}},
                [$self->{head_element}, $el_category->{head}];
          } else {
            !!!cp ('t105');
          }
          !!!insert-element ($self->{t}->{tag_name}, $self->{t}->{attributes}, $self->{t});
          my $meta_el = pop @{$self->{open_elements}};

              unless ($self->{confident}) {
                if ($self->{t}->{attributes}->{charset}) {
                  !!!cp ('t106');
                  ## NOTE: Whether the encoding is supported or not,
                  ## an ASCII-compatible charset is not, is handled in
                  ## the |_change_encoding| method.
                  $self->_change_encoding
                      ($self->{t}->{attributes}->{charset}->{value}, $self->{t});
                  
                  $meta_el->[0]->get_attribute_node_ns (undef, 'charset')
                      ->set_user_data (manakai_has_reference =>
                                           $self->{t}->{attributes}->{charset}
                                               ->{has_reference});
                } elsif ($self->{t}->{attributes}->{content} and
                         $self->{t}->{attributes}->{'http-equiv'}) {
                  if ($self->{t}->{attributes}->{'http-equiv'}->{value}
                      =~ /\A[Cc][Oo][Nn][Tt][Ee][Nn][Tt]-[Tt][Yy][Pp][Ee]\z/ and
                      $self->{t}->{attributes}->{content}->{value}
                      =~ /[Cc][Hh][Aa][Rr][Ss][Ee][Tt]
                          [\x09\x0A\x0C\x0D\x20]*=
                          [\x09\x0A\x0C\x0D\x20]*(?>"([^"]*)"|'([^']*)'|
                          ([^"'\x09\x0A\x0C\x0D\x20]
                           [^\x09\x0A\x0C\x0D\x20\x3B]*))/x) {
                    !!!cp ('t107');
                    ## NOTE: Whether the encoding is supported or not,
                    ## an ASCII-compatible charset is not, is handled
                    ## in the |_change_encoding| method.
                    $self->_change_encoding
                        (defined $1 ? $1 : defined $2 ? $2 : $3, $self->{t});
                    $meta_el->[0]->get_attribute_node_ns (undef, 'content')
                        ->set_user_data (manakai_has_reference =>
                                             $self->{t}->{attributes}->{content}
                                                   ->{has_reference});
                  } else {
                    !!!cp ('t108');
                  }
                }
              } else {
                if ($self->{t}->{attributes}->{charset}) {
                  !!!cp ('t109');
                  $meta_el->[0]->get_attribute_node_ns (undef, 'charset')
                      ->set_user_data (manakai_has_reference =>
                                           $self->{t}->{attributes}->{charset}
                                               ->{has_reference});
                }
                if ($self->{t}->{attributes}->{content}) {
                  !!!cp ('t110');
                  $meta_el->[0]->get_attribute_node_ns (undef, 'content')
                      ->set_user_data (manakai_has_reference =>
                                           $self->{t}->{attributes}->{content}
                                               ->{has_reference});
                }
              }

              pop @{$self->{open_elements}} # <head>
                  if $self->{insertion_mode} == AFTER_HEAD_IM;
              !!!ack ('t110.1');
              !!!next-token;
              next B;
        } elsif ($self->{t}->{tag_name} eq 'title') {
          if ($self->{insertion_mode} == IN_HEAD_NOSCRIPT_IM) {
            !!!cp ('t111');
            ## As if </noscript>
            pop @{$self->{open_elements}};
            !!!parse-error (type => 'in noscript', text => 'title',
                            token => $self->{t});
          
            $self->{insertion_mode} = IN_HEAD_IM;
            ## Reprocess in the "in head" insertion mode...
          } elsif ($self->{insertion_mode} == AFTER_HEAD_IM) {
            !!!cp ('t112');
            !!!parse-error (type => 'after head',
                            text => $self->{t}->{tag_name}, token => $self->{t});
            push @{$self->{open_elements}},
                [$self->{head_element}, $el_category->{head}];
          } else {
            !!!cp ('t113');
          }

          ## NOTE: There is a "as if in head" code clone.
          $parse_rcdata->($self, $insert, $open_tables, 1); # RCDATA

          ## NOTE: At this point the stack of open elements contain
          ## the |head| element (index == -2) and the |script| element
          ## (index == -1).  In the "after head" insertion mode the
          ## |head| element is inserted only for the purpose of
          ## providing the context for the |script| element, and
          ## therefore we can now and have to remove the element from
          ## the stack.
          splice @{$self->{open_elements}}, -2, 1, () # <head>
              if ($self->{insertion_mode} & IM_MASK) == AFTER_HEAD_IM;
          next B;
        } elsif ($self->{t}->{tag_name} eq 'style' or
                 $self->{t}->{tag_name} eq 'noframes') {
          ## NOTE: Or (scripting is enabled and tag_name eq 'noscript' and
          ## insertion mode IN_HEAD_IM)
          ## NOTE: There is a "as if in head" code clone.
          if ($self->{insertion_mode} == AFTER_HEAD_IM) {
            !!!cp ('t114');
            !!!parse-error (type => 'after head',
                            text => $self->{t}->{tag_name}, token => $self->{t});
            push @{$self->{open_elements}},
                [$self->{head_element}, $el_category->{head}];
          } else {
            !!!cp ('t115');
          }
          $parse_rcdata->($self, $insert, $open_tables, 0); # RAWTEXT
          splice @{$self->{open_elements}}, -2, 1, () # <head>
              if ($self->{insertion_mode} & IM_MASK) == AFTER_HEAD_IM;
          next B;
        } elsif ($self->{t}->{tag_name} eq 'noscript') {
              if ($self->{insertion_mode} == IN_HEAD_IM) {
                !!!cp ('t116');
                ## NOTE: and scripting is disalbed
                !!!insert-element ($self->{t}->{tag_name}, $self->{t}->{attributes}, $self->{t});
                $self->{insertion_mode} = IN_HEAD_NOSCRIPT_IM;
                !!!nack ('t116.1');
                !!!next-token;
                next B;
              } elsif ($self->{insertion_mode} == IN_HEAD_NOSCRIPT_IM) {
                !!!cp ('t117');
                !!!parse-error (type => 'in noscript', text => 'noscript',
                                token => $self->{t});
                ## Ignore the token
                !!!nack ('t117.1');
                !!!next-token;
                next B;
              } else {
                !!!cp ('t118');
                #
              }
        } elsif ($self->{t}->{tag_name} eq 'script') {
          if ($self->{insertion_mode} == IN_HEAD_NOSCRIPT_IM) {
            !!!cp ('t119');
            ## As if </noscript>
            pop @{$self->{open_elements}};
            !!!parse-error (type => 'in noscript', text => 'script',
                            token => $self->{t});
          
            $self->{insertion_mode} = IN_HEAD_IM;
            ## Reprocess in the "in head" insertion mode...
          } elsif ($self->{insertion_mode} == AFTER_HEAD_IM) {
            !!!cp ('t120');
            !!!parse-error (type => 'after head',
                            text => $self->{t}->{tag_name}, token => $self->{t});
            push @{$self->{open_elements}},
                [$self->{head_element}, $el_category->{head}];
          } else {
            !!!cp ('t121');
          }

          ## NOTE: There is a "as if in head" code clone.
          $script_start_tag->($self, $insert, $open_tables);
          ## ISSUE: A spec bug  [Bug 6038]
          splice @{$self->{open_elements}}, -2, 1 # <head>
              if ($self->{insertion_mode} & IM_MASK) == AFTER_HEAD_IM;
          next B;
        } elsif ($self->{t}->{tag_name} eq 'body' or
                 $self->{t}->{tag_name} eq 'frameset') {
          if ($self->{insertion_mode} == IN_HEAD_NOSCRIPT_IM) {
            !!!cp ('t122');
            ## As if </noscript>
            pop @{$self->{open_elements}};
            !!!parse-error (type => 'in noscript',
                            text => $self->{t}->{tag_name}, token => $self->{t});
            
            ## Reprocess in the "in head" insertion mode...
            ## As if </head>
            pop @{$self->{open_elements}};
            
            ## Reprocess in the "after head" insertion mode...
          } elsif ($self->{insertion_mode} == IN_HEAD_IM) {
            !!!cp ('t124');
            pop @{$self->{open_elements}};
            
            ## Reprocess in the "after head" insertion mode...
          } else {
            !!!cp ('t125');
          }

          ## "after head" insertion mode
          !!!insert-element ($self->{t}->{tag_name}, $self->{t}->{attributes}, $self->{t});
          if ($self->{t}->{tag_name} eq 'body') {
            !!!cp ('t126');
            delete $self->{frameset_ok};
            $self->{insertion_mode} = IN_BODY_IM;
          } elsif ($self->{t}->{tag_name} eq 'frameset') {
            !!!cp ('t127');
            $self->{insertion_mode} = IN_FRAMESET_IM;
          } else {
            die "$0: tag name: $self->{tag_name}";
          }
          !!!nack ('t127.1');
          !!!next-token;
          next B;
        } else {
          !!!cp ('t128');
          #
        }

            if ($self->{insertion_mode} == IN_HEAD_NOSCRIPT_IM) {
              !!!cp ('t129');
              ## As if </noscript>
              pop @{$self->{open_elements}};
              !!!parse-error (type => 'in noscript:/',
                              text => $self->{t}->{tag_name}, token => $self->{t});
              
              ## Reprocess in the "in head" insertion mode...
              ## As if </head>
              pop @{$self->{open_elements}};

              ## Reprocess in the "after head" insertion mode...
            } elsif ($self->{insertion_mode} == IN_HEAD_IM) {
              !!!cp ('t130');
              ## As if </head>
              pop @{$self->{open_elements}};

              ## Reprocess in the "after head" insertion mode...
            } else {
              !!!cp ('t131');
            }

        ## "after head" insertion mode
        ## As if <body>
        !!!insert-element ('body',, $self->{t});
        $self->{insertion_mode} = IN_BODY_IM;
        ## The "frameset-ok" flag is not changed in this case.
        ## Reprocess the token.
        !!!ack-later;
        next B;
      } elsif ($self->{t}->{type} == END_TAG_TOKEN) {
        ## "Before head", "in head", and "after head" insertion modes
        ## ignore most of end tags.  Exceptions are "body", "html",
        ## and "br" end tags.  "Before head" and "in head" insertion
        ## modes also recognize "head" end tag.  "In head noscript"
        ## insertion modes ignore end tags except for "noscript" and
        ## "br".

        if ($self->{t}->{tag_name} eq 'head') {
          if ($self->{insertion_mode} == BEFORE_HEAD_IM) {
            !!!cp ('t132');
            ## As if <head>
            !!!create-element ($self->{head_element}, HTML_NS, 'head',, $self->{t});
            $self->{open_elements}->[-1]->[0]->append_child ($self->{head_element});
            push @{$self->{open_elements}},
                [$self->{head_element}, $el_category->{head}];

            ## Reprocess in the "in head" insertion mode...
            pop @{$self->{open_elements}};
            $self->{insertion_mode} = AFTER_HEAD_IM;
            !!!next-token;
            next B;
          } elsif ($self->{insertion_mode} == IN_HEAD_NOSCRIPT_IM) {
            !!!cp ('t133');
            #
          } elsif ($self->{insertion_mode} == IN_HEAD_IM) {
            !!!cp ('t134');
            pop @{$self->{open_elements}};
            $self->{insertion_mode} = AFTER_HEAD_IM;
            !!!next-token;
            next B;
          } elsif ($self->{insertion_mode} == AFTER_HEAD_IM) {
            !!!cp ('t134.1');
            #
          } else {
            die "$0: $self->{insertion_mode}: Unknown insertion mode";
          }
        } elsif ($self->{t}->{tag_name} eq 'noscript') {
          if ($self->{insertion_mode} == IN_HEAD_NOSCRIPT_IM) {
            !!!cp ('t136');
            pop @{$self->{open_elements}};
            $self->{insertion_mode} = IN_HEAD_IM;
            !!!next-token;
            next B;
          } else {
            !!!cp ('t138');
            #
          }
        } elsif ({
            body => ($self->{insertion_mode} != IN_HEAD_NOSCRIPT_IM),
            html => ($self->{insertion_mode} != IN_HEAD_NOSCRIPT_IM),
            br => 1,
        }->{$self->{t}->{tag_name}}) {
          if ($self->{insertion_mode} == BEFORE_HEAD_IM) {
            !!!cp ('t142.2');
            ## (before head) as if <head>, (in head) as if </head>
            !!!create-element ($self->{head_element}, HTML_NS, 'head',, $self->{t});
            $self->{open_elements}->[-1]->[0]->append_child ($self->{head_element});
            $self->{insertion_mode} = AFTER_HEAD_IM;
  
            ## Reprocess in the "after head" insertion mode...
          } elsif ($self->{insertion_mode} == IN_HEAD_IM) {
            !!!cp ('t143.2');
            ## As if </head>
            pop @{$self->{open_elements}};
            $self->{insertion_mode} = AFTER_HEAD_IM;
  
            ## Reprocess in the "after head" insertion mode...
          } elsif ($self->{insertion_mode} == IN_HEAD_NOSCRIPT_IM) {
            !!!cp ('t143.3');
            ## NOTE: Two parse errors for <head><noscript></br>
            !!!parse-error (type => 'unmatched end tag',
                            text => $self->{t}->{tag_name}, token => $self->{t});
            ## As if </noscript>
            pop @{$self->{open_elements}};
            $self->{insertion_mode} = IN_HEAD_IM;

            ## Reprocess in the "in head" insertion mode...
            ## As if </head>
            pop @{$self->{open_elements}};
            $self->{insertion_mode} = AFTER_HEAD_IM;

            ## Reprocess in the "after head" insertion mode...
          } elsif ($self->{insertion_mode} == AFTER_HEAD_IM) {
            !!!cp ('t143.4');
            #
          } else {
            die "$0: $self->{insertion_mode}: Unknown insertion mode";
          }

          ## "after head" insertion mode
          ## As if <body>
          !!!insert-element ('body',, $self->{t});
          $self->{insertion_mode} = IN_BODY_IM;
          ## The "frameset-ok" flag is left unchanged in this case.
          ## Reprocess the token.
          next B;
        }

        ## End tags are ignored by default.
        !!!cp ('t145');
        !!!parse-error (type => 'unmatched end tag',
                        text => $self->{t}->{tag_name}, token => $self->{t});
        ## Ignore the token.
        !!!next-token;
        next B;
      } elsif ($self->{t}->{type} == END_OF_FILE_TOKEN) {
        if ($self->{insertion_mode} == BEFORE_HEAD_IM) {
          !!!cp ('t149.1');

          ## NOTE: As if <head>
          !!!create-element ($self->{head_element}, HTML_NS, 'head',, $self->{t});
          $self->{open_elements}->[-1]->[0]->append_child
              ($self->{head_element});
          #push @{$self->{open_elements}},
          #    [$self->{head_element}, $el_category->{head}];
          #$self->{insertion_mode} = IN_HEAD_IM;
          ## NOTE: Reprocess.

          ## NOTE: As if </head>
          #pop @{$self->{open_elements}};
          #$self->{insertion_mode} = IN_AFTER_HEAD_IM;
          ## NOTE: Reprocess.
          
          #
        } elsif ($self->{insertion_mode} == IN_HEAD_IM) {
          !!!cp ('t149.2');

          ## NOTE: As if </head>
          pop @{$self->{open_elements}};
          #$self->{insertion_mode} = IN_AFTER_HEAD_IM;
          ## NOTE: Reprocess.

          #
        } elsif ($self->{insertion_mode} == IN_HEAD_NOSCRIPT_IM) {
          !!!cp ('t149.3');

          !!!parse-error (type => 'in noscript:#eof', token => $self->{t});

          ## As if </noscript>
          pop @{$self->{open_elements}};
          #$self->{insertion_mode} = IN_HEAD_IM;
          ## NOTE: Reprocess.

          ## NOTE: As if </head>
          pop @{$self->{open_elements}};
          #$self->{insertion_mode} = IN_AFTER_HEAD_IM;
          ## NOTE: Reprocess.

          #
        } else {
          !!!cp ('t149.4');
          #
        }

        ## NOTE: As if <body>
        !!!insert-element ('body',, $self->{t});
        $self->{insertion_mode} = IN_BODY_IM;
        ## The "frameset-ok" flag is left unchanged in this case.
        ## Reprocess the token.
        next B;
      } else {
        die "$0: $self->{t}->{type}: Unknown token type";
      }

    } elsif ($self->{insertion_mode} & BODY_IMS) {
      if ($self->{t}->{type} == CHARACTER_TOKEN) {
        ## "In body" insertion mode, character token.  It is also used
        ## for character tokens "in foreign content" for certain
        ## cases.

        while ($self->{t}->{data} =~ s/\x00//g) {
          !!!parse-error (type => 'NULL', token => $self->{t});
        }
        if ($self->{t}->{data} eq '') {
          !!!next-token;
          next B;
        }

        !!!cp ('t150');
        $reconstruct_active_formatting_elements
            ->($self, $insert_to_current, $active_formatting_elements,
               $open_tables);
        
        $self->{open_elements}->[-1]->[0]->manakai_append_text ($self->{t}->{data});

        if ($self->{frameset_ok} and
            $self->{t}->{data} =~ /[^\x09\x0A\x0C\x0D\x20]/) {
          delete $self->{frameset_ok};
        }

        !!!next-token;
        next B;
      } elsif ($self->{t}->{type} == START_TAG_TOKEN) {
            if ({
                 caption => 1, col => 1, colgroup => 1, tbody => 1,
                 td => 1, tfoot => 1, th => 1, thead => 1, tr => 1,
                }->{$self->{t}->{tag_name}}) {
              if (($self->{insertion_mode} & IM_MASK) == IN_CELL_IM) {
                ## have an element in table scope
                for (reverse 0..$#{$self->{open_elements}}) {
                  my $node = $self->{open_elements}->[$_];
                  if ($node->[1] == TABLE_CELL_EL) {
                    !!!cp ('t151');

                    ## Close the cell
                    !!!back-token; # <x>
                    $self->{t} = {type => END_TAG_TOKEN,
                              tag_name => $node->[0]->manakai_local_name,
                              line => $self->{t}->{line},
                              column => $self->{t}->{column}};
                    next B;
                  } elsif ($node->[1] & TABLE_SCOPING_EL) {
                    !!!cp ('t152');
                    ## ISSUE: This case can never be reached, maybe.
                    last;
                  }
                }

                !!!cp ('t153');
                !!!parse-error (type => 'start tag not allowed',
                    text => $self->{t}->{tag_name}, token => $self->{t});
                ## Ignore the token
                !!!nack ('t153.1');
                !!!next-token;
                next B;
              } elsif (($self->{insertion_mode} & IM_MASK) == IN_CAPTION_IM) {
                !!!parse-error (type => 'not closed', text => 'caption',
                                token => $self->{t});
                
                ## NOTE: As if </caption>.
                ## have a table element in table scope
                my $i;
                INSCOPE: {
                  for (reverse 0..$#{$self->{open_elements}}) {
                    my $node = $self->{open_elements}->[$_];
                    if ($node->[1] == CAPTION_EL) {
                      !!!cp ('t155');
                      $i = $_;
                      last INSCOPE;
                    } elsif ($node->[1] & TABLE_SCOPING_EL) {
                      !!!cp ('t156');
                      last;
                    }
                  }

                  !!!cp ('t157');
                  !!!parse-error (type => 'start tag not allowed',
                                  text => $self->{t}->{tag_name}, token => $self->{t});
                  ## Ignore the token
                  !!!nack ('t157.1');
                  !!!next-token;
                  next B;
                } # INSCOPE
                
                ## generate implied end tags
                while ($self->{open_elements}->[-1]->[1]
                           & END_TAG_OPTIONAL_EL) {
                  !!!cp ('t158');
                  pop @{$self->{open_elements}};
                }

                unless ($self->{open_elements}->[-1]->[1] == CAPTION_EL) {
                  !!!cp ('t159');
                  !!!parse-error (type => 'not closed',
                                  text => $self->{open_elements}->[-1]->[0]
                                      ->manakai_local_name,
                                  token => $self->{t});
                } else {
                  !!!cp ('t160');
                }
                
                splice @{$self->{open_elements}}, $i;
                
                $clear_up_to_marker->($active_formatting_elements);
                
                $self->{insertion_mode} = IN_TABLE_IM;
                
                ## reprocess
                !!!ack-later;
                next B;
              } else {
                !!!cp ('t161');
                #
              }
            } else {
              !!!cp ('t162');
              #
            }
          } elsif ($self->{t}->{type} == END_TAG_TOKEN) {
            if ($self->{t}->{tag_name} eq 'td' or $self->{t}->{tag_name} eq 'th') {
              if (($self->{insertion_mode} & IM_MASK) == IN_CELL_IM) {
                ## have an element in table scope
                my $i;
                INSCOPE: for (reverse 0..$#{$self->{open_elements}}) {
                  my $node = $self->{open_elements}->[$_];
                  if ($node->[0]->manakai_local_name eq $self->{t}->{tag_name}) {
                    !!!cp ('t163');
                    $i = $_;
                    last INSCOPE;
                  } elsif ($node->[1] & TABLE_SCOPING_EL) {
                    !!!cp ('t164');
                    last INSCOPE;
                  }
                } # INSCOPE
                  unless (defined $i) {
                    !!!cp ('t165');
                    !!!parse-error (type => 'unmatched end tag',
                                    text => $self->{t}->{tag_name},
                                    token => $self->{t});
                    ## Ignore the token
                    !!!next-token;
                    next B;
                  }
                
                ## generate implied end tags
                while ($self->{open_elements}->[-1]->[1]
                           & END_TAG_OPTIONAL_EL) {
                  !!!cp ('t166');
                  pop @{$self->{open_elements}};
                }

                if ($self->{open_elements}->[-1]->[0]->manakai_local_name
                        ne $self->{t}->{tag_name}) {
                  !!!cp ('t167');
                  !!!parse-error (type => 'not closed',
                                  text => $self->{open_elements}->[-1]->[0]
                                      ->manakai_local_name,
                                  token => $self->{t});
                } else {
                  !!!cp ('t168');
                }
                
                splice @{$self->{open_elements}}, $i;
                
                $clear_up_to_marker->($active_formatting_elements);
                
                $self->{insertion_mode} = IN_ROW_IM;
                
                !!!next-token;
                next B;
              } elsif (($self->{insertion_mode} & IM_MASK) == IN_CAPTION_IM) {
                !!!cp ('t169');
                !!!parse-error (type => 'unmatched end tag',
                                text => $self->{t}->{tag_name}, token => $self->{t});
                ## Ignore the token
                !!!next-token;
                next B;
              } else {
                !!!cp ('t170');
                #
              }
            } elsif ($self->{t}->{tag_name} eq 'caption') {
              if (($self->{insertion_mode} & IM_MASK) == IN_CAPTION_IM) {
                ## have a table element in table scope
                my $i;
                INSCOPE: {
                  for (reverse 0..$#{$self->{open_elements}}) {
                    my $node = $self->{open_elements}->[$_];
                    if ($node->[1] == CAPTION_EL) {
                      !!!cp ('t171');
                      $i = $_;
                      last INSCOPE;
                    } elsif ($node->[1] & TABLE_SCOPING_EL) {
                      !!!cp ('t172');
                      last;
                    }
                  }

                  !!!cp ('t173');
                  !!!parse-error (type => 'unmatched end tag',
                                  text => $self->{t}->{tag_name}, token => $self->{t});
                  ## Ignore the token
                  !!!next-token;
                  next B;
                } # INSCOPE
                
                ## generate implied end tags
                while ($self->{open_elements}->[-1]->[1]
                           & END_TAG_OPTIONAL_EL) {
                  !!!cp ('t174');
                  pop @{$self->{open_elements}};
                }
                
                unless ($self->{open_elements}->[-1]->[1] == CAPTION_EL) {
                  !!!cp ('t175');
                  !!!parse-error (type => 'not closed',
                                  text => $self->{open_elements}->[-1]->[0]
                                      ->manakai_local_name,
                                  token => $self->{t});
                } else {
                  !!!cp ('t176');
                }
                
                splice @{$self->{open_elements}}, $i;
                
                $clear_up_to_marker->($active_formatting_elements);
                
                $self->{insertion_mode} = IN_TABLE_IM;
                
                !!!next-token;
                next B;
              } elsif (($self->{insertion_mode} & IM_MASK) == IN_CELL_IM) {
                !!!cp ('t177');
                !!!parse-error (type => 'unmatched end tag',
                                text => $self->{t}->{tag_name}, token => $self->{t});
                ## Ignore the token
                !!!next-token;
                next B;
              } else {
                !!!cp ('t178');
                #
              }
            } elsif ({
                      table => 1, tbody => 1, tfoot => 1, 
                      thead => 1, tr => 1,
                     }->{$self->{t}->{tag_name}} and
                     ($self->{insertion_mode} & IM_MASK) == IN_CELL_IM) {
              ## have an element in table scope
              my $i;
              my $tn;
              INSCOPE: {
                for (reverse 0..$#{$self->{open_elements}}) {
                  my $node = $self->{open_elements}->[$_];
                  if ($node->[0]->manakai_local_name eq $self->{t}->{tag_name}) {
                    !!!cp ('t179');
                    $i = $_;

                    ## Close the cell
                    !!!back-token; # </x>
                    $self->{t} = {type => END_TAG_TOKEN, tag_name => $tn,
                              line => $self->{t}->{line},
                              column => $self->{t}->{column}};
                    next B;
                  } elsif ($node->[1] == TABLE_CELL_EL) {
                    !!!cp ('t180');
                    $tn = $node->[0]->manakai_local_name;
                    ## NOTE: There is exactly one |td| or |th| element
                    ## in scope in the stack of open elements by definition.
                  } elsif ($node->[1] & TABLE_SCOPING_EL) {
                    ## ISSUE: Can this be reached?
                    !!!cp ('t181');
                    last;
                  }
                }

                !!!cp ('t182');
                !!!parse-error (type => 'unmatched end tag',
                    text => $self->{t}->{tag_name}, token => $self->{t});
                ## Ignore the token
                !!!next-token;
                next B;
              } # INSCOPE
            } elsif ($self->{t}->{tag_name} eq 'table' and
                     ($self->{insertion_mode} & IM_MASK) == IN_CAPTION_IM) {
              !!!parse-error (type => 'not closed', text => 'caption',
                              token => $self->{t});

              ## As if </caption>
              ## have a table element in table scope
              my $i;
              INSCOPE: for (reverse 0..$#{$self->{open_elements}}) {
                my $node = $self->{open_elements}->[$_];
                if ($node->[1] == CAPTION_EL) {
                  !!!cp ('t184');
                  $i = $_;
                  last INSCOPE;
                } elsif ($node->[1] & TABLE_SCOPING_EL) {
                  !!!cp ('t185');
                  last INSCOPE;
                }
              } # INSCOPE
              unless (defined $i) {
                !!!cp ('t186');
	## TODO: Wrong error type?
                !!!parse-error (type => 'unmatched end tag',
                                text => 'caption', token => $self->{t});
                ## Ignore the token
                !!!next-token;
                next B;
              }
              
              ## generate implied end tags
              while ($self->{open_elements}->[-1]->[1] & END_TAG_OPTIONAL_EL) {
                !!!cp ('t187');
                pop @{$self->{open_elements}};
              }

              unless ($self->{open_elements}->[-1]->[1] == CAPTION_EL) {
                !!!cp ('t188');
                !!!parse-error (type => 'not closed',
                                text => $self->{open_elements}->[-1]->[0]
                                    ->manakai_local_name,
                                token => $self->{t});
              } else {
                !!!cp ('t189');
              }

              splice @{$self->{open_elements}}, $i;

              $clear_up_to_marker->($active_formatting_elements);

              $self->{insertion_mode} = IN_TABLE_IM;

              ## reprocess
              next B;
            } elsif ({
                      body => 1, col => 1, colgroup => 1, html => 1,
                     }->{$self->{t}->{tag_name}}) {
              if ($self->{insertion_mode} & BODY_TABLE_IMS) {
                !!!cp ('t190');
                !!!parse-error (type => 'unmatched end tag',
                                text => $self->{t}->{tag_name}, token => $self->{t});
                ## Ignore the token
                !!!next-token;
                next B;
              } else {
                !!!cp ('t191');
                #
              }
        } elsif ({
                  tbody => 1, tfoot => 1,
                  thead => 1, tr => 1,
                 }->{$self->{t}->{tag_name}} and
                 ($self->{insertion_mode} & IM_MASK) == IN_CAPTION_IM) {
          !!!cp ('t192');
          !!!parse-error (type => 'unmatched end tag',
                          text => $self->{t}->{tag_name}, token => $self->{t});
          ## Ignore the token
          !!!next-token;
          next B;
        } else {
          !!!cp ('t193');
          #
        }
      } elsif ($self->{t}->{type} == END_OF_FILE_TOKEN) {
        for my $entry (@{$self->{open_elements}}) {
          unless ($entry->[1] & ALL_END_TAG_OPTIONAL_EL) {
            !!!cp ('t75');
            !!!parse-error (type => 'in body:#eof', token => $self->{t});
            last;
          }
        }

        ## Stop parsing.
        last B;
      } else {
        die "$0: $self->{t}->{type}: Unknown token type";
      }

      $self->{insert} = $insert = $insert_to_current;
      #
    } elsif ($self->{insertion_mode} & TABLE_IMS) {
      if ($self->{t}->{type} == START_TAG_TOKEN) {
        if ({
             tr => (($self->{insertion_mode} & IM_MASK) != IN_ROW_IM),
             th => 1, td => 1,
            }->{$self->{t}->{tag_name}}) {
          if (($self->{insertion_mode} & IM_MASK) == IN_TABLE_IM) {
            ## Clear back to table context
            while (not ($self->{open_elements}->[-1]->[1]
                            & TABLE_SCOPING_EL)) {
              !!!cp ('t201');
              pop @{$self->{open_elements}};
            }
            
            !!!insert-element ('tbody',, $self->{t});
            $self->{insertion_mode} = IN_TABLE_BODY_IM;
            ## reprocess in the "in table body" insertion mode...
          }
          
          if (($self->{insertion_mode} & IM_MASK) == IN_TABLE_BODY_IM) {
            unless ($self->{t}->{tag_name} eq 'tr') {
              !!!cp ('t202');
              !!!parse-error (type => 'missing start tag:tr', token => $self->{t});
            }
                
            ## Clear back to table body context
            while (not ($self->{open_elements}->[-1]->[1]
                            & TABLE_ROWS_SCOPING_EL)) {
              !!!cp ('t203');
              ## ISSUE: Can this case be reached?
              pop @{$self->{open_elements}};
            }
                
            $self->{insertion_mode} = IN_ROW_IM;
            if ($self->{t}->{tag_name} eq 'tr') {
              !!!cp ('t204');
              !!!insert-element ($self->{t}->{tag_name}, $self->{t}->{attributes}, $self->{t});
              $open_tables->[-1]->[2] = 0 if @$open_tables; # ~node inserted
              !!!nack ('t204');
              !!!next-token;
              next B;
            } else {
              !!!cp ('t205');
              !!!insert-element ('tr',, $self->{t});
              ## reprocess in the "in row" insertion mode
            }
          } else {
            !!!cp ('t206');
          }

              ## Clear back to table row context
              while (not ($self->{open_elements}->[-1]->[1]
                              & TABLE_ROW_SCOPING_EL)) {
                !!!cp ('t207');
                pop @{$self->{open_elements}};
              }
              
          !!!insert-element ($self->{t}->{tag_name}, $self->{t}->{attributes}, $self->{t});
          $open_tables->[-1]->[2] = 0 if @$open_tables; # ~node inserted
          $self->{insertion_mode} = IN_CELL_IM;

          push @$active_formatting_elements, ['#marker', '', undef];
          
          !!!nack ('t207.1');
          !!!next-token;
          next B;
        } elsif ({
                  caption => 1, col => 1, colgroup => 1,
                  tbody => 1, tfoot => 1, thead => 1,
                  tr => 1, # $self->{insertion_mode} == IN_ROW_IM
                 }->{$self->{t}->{tag_name}}) {
          if (($self->{insertion_mode} & IM_MASK) == IN_ROW_IM) {
            ## XXXgeneratetoken
            ## As if </tr>
            ## have an element in table scope
            my $i;
            INSCOPE: for (reverse 0..$#{$self->{open_elements}}) {
              my $node = $self->{open_elements}->[$_];
              if ($node->[1] == TABLE_ROW_EL) {
                !!!cp ('t208');
                $i = $_;
                last INSCOPE;
              } elsif ($node->[1] & TABLE_SCOPING_EL) {
                !!!cp ('t209');
                last INSCOPE;
              }
            } # INSCOPE
            unless (defined $i) { 
              !!!cp ('t210');
              ## TODO: This type is wrong.
              !!!parse-error (type => 'unmacthed end tag',
                              text => $self->{t}->{tag_name}, token => $self->{t});
              ## Ignore the token
              !!!nack ('t210.1');
              !!!next-token;
              next B;
            }
                
                ## Clear back to table row context
                while (not ($self->{open_elements}->[-1]->[1]
                                & TABLE_ROW_SCOPING_EL)) {
                  !!!cp ('t211');
                  ## ISSUE: Can this case be reached?
                  pop @{$self->{open_elements}};
                }
                
                pop @{$self->{open_elements}}; # tr
                $self->{insertion_mode} = IN_TABLE_BODY_IM;
                if ($self->{t}->{tag_name} eq 'tr') {
                  !!!cp ('t212');
                  ## reprocess
                  !!!ack-later;
                  next B;
                } else {
                  !!!cp ('t213');
                  ## reprocess in the "in table body" insertion mode...
                }
              }

              if (($self->{insertion_mode} & IM_MASK) == IN_TABLE_BODY_IM) {
                ## have an element in table scope
                my $i;
                INSCOPE: for (reverse 0..$#{$self->{open_elements}}) {
                  my $node = $self->{open_elements}->[$_];
                  if ($node->[1] == TABLE_ROW_GROUP_EL) {
                    !!!cp ('t214');
                    $i = $_;
                    last INSCOPE;
                  } elsif ($node->[1] & TABLE_SCOPING_EL) {
                    !!!cp ('t215');
                    last INSCOPE;
                  }
                } # INSCOPE
                unless (defined $i) {
                  !!!cp ('t216');
## TODO: This erorr type is wrong.
                  !!!parse-error (type => 'unmatched end tag',
                                  text => $self->{t}->{tag_name}, token => $self->{t});
                  ## Ignore the token
                  !!!nack ('t216.1');
                  !!!next-token;
                  next B;
                }

                ## Clear back to table body context
                while (not ($self->{open_elements}->[-1]->[1]
                                & TABLE_ROWS_SCOPING_EL)) {
                  !!!cp ('t217');
                  ## ISSUE: Can this state be reached?
                  pop @{$self->{open_elements}};
                }
                
                ## As if <{current node}>
                ## have an element in table scope
                ## true by definition
                
                ## Clear back to table body context
                ## nop by definition
                
                pop @{$self->{open_elements}};
                $self->{insertion_mode} = IN_TABLE_IM;
                ## reprocess in "in table" insertion mode...
              } else {
                !!!cp ('t218');
              }

          if ($self->{t}->{tag_name} eq 'col') {
            ## Clear back to table context
            while (not ($self->{open_elements}->[-1]->[1]
                            & TABLE_SCOPING_EL)) {
              !!!cp ('t219');
              ## ISSUE: Can this state be reached?
              pop @{$self->{open_elements}};
            }
            
            !!!insert-element ('colgroup',, $self->{t});
            $self->{insertion_mode} = IN_COLUMN_GROUP_IM;
            ## reprocess
            $open_tables->[-1]->[2] = 0 if @$open_tables; # ~node inserted
            !!!ack-later;
            next B;
          } elsif ({
                    caption => 1,
                    colgroup => 1,
                    tbody => 1, tfoot => 1, thead => 1,
                   }->{$self->{t}->{tag_name}}) {
            ## Clear back to table context
            while (not ($self->{open_elements}->[-1]->[1]
                        & TABLE_SCOPING_EL)) {
              !!!cp ('t220');
              ## ISSUE: Can this state be reached?
              pop @{$self->{open_elements}};
            }
            
            push @$active_formatting_elements, ['#marker', '', undef]
                if $self->{t}->{tag_name} eq 'caption';
            
            !!!insert-element ($self->{t}->{tag_name}, $self->{t}->{attributes}, $self->{t});
            $open_tables->[-1]->[2] = 0 if @$open_tables; # ~node inserted
            $self->{insertion_mode} = {
                                       caption => IN_CAPTION_IM,
                                       colgroup => IN_COLUMN_GROUP_IM,
                                       tbody => IN_TABLE_BODY_IM,
                                       tfoot => IN_TABLE_BODY_IM,
                                       thead => IN_TABLE_BODY_IM,
                                      }->{$self->{t}->{tag_name}};
            !!!next-token;
            !!!nack ('t220.1');
            next B;
          } else {
            die "$0: in table: <>: $self->{t}->{tag_name}";
          }
            } elsif ($self->{t}->{tag_name} eq 'table') {
              !!!parse-error (type => 'not closed',
                              text => $self->{open_elements}->[-1]->[0]
                                  ->manakai_local_name,
                              token => $self->{t});

              ## XXXgeneratetoken
              ## As if </table>
              ## have a table element in table scope
              my $i;
              INSCOPE: for (reverse 0..$#{$self->{open_elements}}) {
                my $node = $self->{open_elements}->[$_];
                if ($node->[1] == TABLE_EL) {
                  !!!cp ('t221');
                  $i = $_;
                  last INSCOPE;
                } elsif ($node->[1] & TABLE_SCOPING_EL) {
                  !!!cp ('t222');
                  last INSCOPE;
                }
              } # INSCOPE
              unless (defined $i) {
                !!!cp ('t223');
## TODO: The following is wrong, maybe.
                !!!parse-error (type => 'unmatched end tag', text => 'table',
                                token => $self->{t});
                ## Ignore tokens </table><table>
                !!!nack ('t223.1');
                !!!next-token;
                next B;
              }
              
## TODO: Followings are removed from the latest spec. 
              ## generate implied end tags
              while ($self->{open_elements}->[-1]->[1] & END_TAG_OPTIONAL_EL) {
                !!!cp ('t224');
                pop @{$self->{open_elements}};
              }

              unless ($self->{open_elements}->[-1]->[1] == TABLE_EL) {
                !!!cp ('t225');
                ## NOTE: |<table><tr><table>|
                !!!parse-error (type => 'not closed',
                                text => $self->{open_elements}->[-1]->[0]
                                    ->manakai_local_name,
                                token => $self->{t});
              } else {
                !!!cp ('t226');
              }

              splice @{$self->{open_elements}}, $i;
              pop @{$open_tables};

              $self->_reset_insertion_mode; 

          ## reprocess
          !!!ack-later;
          next B;
        } elsif ($self->{t}->{tag_name} eq 'style') {
          !!!cp ('t227.8');
          ## NOTE: This is a "as if in head" code clone.
          $parse_rcdata->($self, $insert, $open_tables, 0); # RAWTEXT
          $open_tables->[-1]->[2] = 0 if @$open_tables; # ~node inserted
          next B;
        } elsif ($self->{t}->{tag_name} eq 'script') {
          !!!cp ('t227.6');
          ## NOTE: This is a "as if in head" code clone.
          $script_start_tag->($self, $insert, $open_tables);
          $open_tables->[-1]->[2] = 0 if @$open_tables; # ~node inserted
          next B;
        } elsif ($self->{t}->{tag_name} eq 'input') {
          if ($self->{t}->{attributes}->{type}) {
            my $type = $self->{t}->{attributes}->{type}->{value};
            $type =~ tr/A-Z/a-z/; ## ASCII case-insensitive.
            if ($type eq 'hidden') {
              !!!cp ('t227.3');
              !!!parse-error (type => 'in table',
                              text => $self->{t}->{tag_name}, token => $self->{t});

              !!!insert-element ($self->{t}->{tag_name}, $self->{t}->{attributes}, $self->{t});
              $open_tables->[-1]->[2] = 0 if @$open_tables; # ~node inserted

              ## TODO: form element pointer

              pop @{$self->{open_elements}};

              !!!next-token;
              !!!ack ('t227.2.1');
              next B;
            } else {
              !!!cp ('t227.1');
              #
            }
          } else {
            !!!cp ('t227.4');
            #
          }
        } elsif ($self->{t}->{tag_name} eq 'form') {
          !!!parse-error (type => 'form in table', token => $self->{t}); # XXX documentation
          
          if ($self->{form_element}) {
            ## Ignore the token.
            !!!next-token;
            !!!nack ('t227.5');
            next B;
          } else {
            !!!insert-element ($self->{t}->{tag_name}, $self->{t}->{attributes}, $self->{t});
            $self->{form_element} = $self->{open_elements}->[-1]->[0];
            
            pop @{$self->{open_elements}};
            
            !!!next-token;
            !!!nack ('t227.6');
            next B;
          }
        } else {
          !!!cp ('t227');
          #
        }

        !!!parse-error (type => 'in table', text => $self->{t}->{tag_name},
                        token => $self->{t});

        $self->{insert} = $insert = $insert_to_foster;
        #
      } elsif ($self->{t}->{type} == END_TAG_TOKEN) {
        if ($self->{t}->{tag_name} eq 'tr' and
            ($self->{insertion_mode} & IM_MASK) == IN_ROW_IM) {
          ## have an element in table scope
              my $i;
              INSCOPE: for (reverse 0..$#{$self->{open_elements}}) {
                my $node = $self->{open_elements}->[$_];
                if ($node->[1] == TABLE_ROW_EL) {
                  !!!cp ('t228');
                  $i = $_;
                  last INSCOPE;
                } elsif ($node->[1] & TABLE_SCOPING_EL) {
                  !!!cp ('t229');
                  last INSCOPE;
                }
              } # INSCOPE
              unless (defined $i) {
                !!!cp ('t230');
                !!!parse-error (type => 'unmatched end tag',
                                text => $self->{t}->{tag_name}, token => $self->{t});
                ## Ignore the token
                !!!nack ('t230.1');
                !!!next-token;
                next B;
              } else {
                !!!cp ('t232');
              }

              ## Clear back to table row context
              while (not ($self->{open_elements}->[-1]->[1]
                              & TABLE_ROW_SCOPING_EL)) {
                !!!cp ('t231');
## ISSUE: Can this state be reached?
                pop @{$self->{open_elements}};
              }

              pop @{$self->{open_elements}}; # tr
              $self->{insertion_mode} = IN_TABLE_BODY_IM;
              !!!next-token;
              !!!nack ('t231.1');
              next B;
            } elsif ($self->{t}->{tag_name} eq 'table') {
              if (($self->{insertion_mode} & IM_MASK) == IN_ROW_IM) {
                ## XXXgeneratetoken
                ## As if </tr>
                ## have an element in table scope
                my $i;
                INSCOPE: for (reverse 0..$#{$self->{open_elements}}) {
                  my $node = $self->{open_elements}->[$_];
                  if ($node->[1] == TABLE_ROW_EL) {
                    !!!cp ('t233');
                    $i = $_;
                    last INSCOPE;
                  } elsif ($node->[1] & TABLE_SCOPING_EL) {
                    !!!cp ('t234');
                    last INSCOPE;
                  }
                } # INSCOPE
                unless (defined $i) {
                  !!!cp ('t235');
## TODO: The following is wrong.
                  !!!parse-error (type => 'unmatched end tag',
                                  text => $self->{t}->{type}, token => $self->{t});
                  ## Ignore the token
                  !!!nack ('t236.1');
                  !!!next-token;
                  next B;
                }
                
                ## Clear back to table row context
                while (not ($self->{open_elements}->[-1]->[1]
                                & TABLE_ROW_SCOPING_EL)) {
                  !!!cp ('t236');
## ISSUE: Can this state be reached?
                  pop @{$self->{open_elements}};
                }
                
                pop @{$self->{open_elements}}; # tr
                $self->{insertion_mode} = IN_TABLE_BODY_IM;
                ## reprocess in the "in table body" insertion mode...
              }

              if (($self->{insertion_mode} & IM_MASK) == IN_TABLE_BODY_IM) {
                ## have an element in table scope
                my $i;
                INSCOPE: for (reverse 0..$#{$self->{open_elements}}) {
                  my $node = $self->{open_elements}->[$_];
                  if ($node->[1] == TABLE_ROW_GROUP_EL) {
                    !!!cp ('t237');
                    $i = $_;
                    last INSCOPE;
                  } elsif ($node->[1] & TABLE_SCOPING_EL) {
                    !!!cp ('t238');
                    last INSCOPE;
                  }
                } # INSCOPE
                unless (defined $i) {
                  !!!cp ('t239');
                  !!!parse-error (type => 'unmatched end tag',
                                  text => $self->{t}->{tag_name}, token => $self->{t});
                  ## Ignore the token
                  !!!nack ('t239.1');
                  !!!next-token;
                  next B;
                }
                
                ## Clear back to table body context
                while (not ($self->{open_elements}->[-1]->[1]
                                & TABLE_ROWS_SCOPING_EL)) {
                  !!!cp ('t240');
                  pop @{$self->{open_elements}};
                }
                
                ## As if <{current node}>
                ## have an element in table scope
                ## true by definition
                
                ## Clear back to table body context
                ## nop by definition
                
                pop @{$self->{open_elements}};
                $self->{insertion_mode} = IN_TABLE_IM;
                ## reprocess in the "in table" insertion mode...
              }

              ## NOTE: </table> in the "in table" insertion mode.
              ## When you edit the code fragment below, please ensure that
              ## the code for <table> in the "in table" insertion mode
              ## is synced with it.

              ## have a table element in table scope
              my $i;
              INSCOPE: for (reverse 0..$#{$self->{open_elements}}) {
                my $node = $self->{open_elements}->[$_];
                if ($node->[1] == TABLE_EL) {
                  !!!cp ('t241');
                  $i = $_;
                  last INSCOPE;
                } elsif ($node->[1] & TABLE_SCOPING_EL) {
                  !!!cp ('t242');
                  last INSCOPE;
                }
              } # INSCOPE
              unless (defined $i) {
                !!!cp ('t243');
                !!!parse-error (type => 'unmatched end tag',
                                text => $self->{t}->{tag_name}, token => $self->{t});
                ## Ignore the token
                !!!nack ('t243.1');
                !!!next-token;
                next B;
              }
                
              splice @{$self->{open_elements}}, $i;
              pop @{$open_tables};
              
              $self->_reset_insertion_mode;
              
              !!!next-token;
              next B;
            } elsif ({
                      tbody => 1, tfoot => 1, thead => 1,
                     }->{$self->{t}->{tag_name}} and
                     $self->{insertion_mode} & ROW_IMS) {
              if (($self->{insertion_mode} & IM_MASK) == IN_ROW_IM) {
                ## have an element in table scope
                my $i;
                INSCOPE: for (reverse 0..$#{$self->{open_elements}}) {
                  my $node = $self->{open_elements}->[$_];
                  if ($node->[0]->manakai_local_name eq $self->{t}->{tag_name}) {
                    !!!cp ('t247');
                    $i = $_;
                    last INSCOPE;
                  } elsif ($node->[1] & TABLE_SCOPING_EL) {
                    !!!cp ('t248');
                    last INSCOPE;
                  }
                } # INSCOPE
                  unless (defined $i) {
                    !!!cp ('t249');
                    !!!parse-error (type => 'unmatched end tag',
                                    text => $self->{t}->{tag_name}, token => $self->{t});
                    ## Ignore the token
                    !!!nack ('t249.1');
                    !!!next-token;
                    next B;
                  }
                
                ## XXXgeneratetoken
                ## As if </tr>
                ## have an element in table scope
                my $i;
                INSCOPE: for (reverse 0..$#{$self->{open_elements}}) {
                  my $node = $self->{open_elements}->[$_];
                  if ($node->[1] == TABLE_ROW_EL) {
                    !!!cp ('t250');
                    $i = $_;
                    last INSCOPE;
                  } elsif ($node->[1] & TABLE_SCOPING_EL) {
                    !!!cp ('t251');
                    last INSCOPE;
                  }
                } # INSCOPE
                  unless (defined $i) {
                    !!!cp ('t252');
                    !!!parse-error (type => 'unmatched end tag',
                                    text => 'tr', token => $self->{t});
                    ## Ignore the token
                    !!!nack ('t252.1');
                    !!!next-token;
                    next B;
                  }
                
                ## Clear back to table row context
                while (not ($self->{open_elements}->[-1]->[1]
                                & TABLE_ROW_SCOPING_EL)) {
                  !!!cp ('t253');
## ISSUE: Can this case be reached?
                  pop @{$self->{open_elements}};
                }
                
                pop @{$self->{open_elements}}; # tr
                $self->{insertion_mode} = IN_TABLE_BODY_IM;
                ## reprocess in the "in table body" insertion mode...
              }

              ## have an element in table scope
              my $i;
              INSCOPE: for (reverse 0..$#{$self->{open_elements}}) {
                my $node = $self->{open_elements}->[$_];
                if ($node->[0]->manakai_local_name eq $self->{t}->{tag_name}) {
                  !!!cp ('t254');
                  $i = $_;
                  last INSCOPE;
                } elsif ($node->[1] & TABLE_SCOPING_EL) {
                  !!!cp ('t255');
                  last INSCOPE;
                }
              } # INSCOPE
              unless (defined $i) {
                !!!cp ('t256');
                !!!parse-error (type => 'unmatched end tag',
                                text => $self->{t}->{tag_name}, token => $self->{t});
                ## Ignore the token
                !!!nack ('t256.1');
                !!!next-token;
                next B;
              }

              ## Clear back to table body context
              while (not ($self->{open_elements}->[-1]->[1]
                              & TABLE_ROWS_SCOPING_EL)) {
                !!!cp ('t257');
## ISSUE: Can this case be reached?
                pop @{$self->{open_elements}};
              }

              pop @{$self->{open_elements}};
              $self->{insertion_mode} = IN_TABLE_IM;
              !!!nack ('t257.1');
              !!!next-token;
              next B;
            } elsif ({
                      body => 1, caption => 1, col => 1, colgroup => 1,
                      html => 1, td => 1, th => 1,
                      tr => 1, # $self->{insertion_mode} == IN_ROW_IM
                      tbody => 1, tfoot => 1, thead => 1, # $self->{insertion_mode} == IN_TABLE_IM
                     }->{$self->{t}->{tag_name}}) {
          !!!cp ('t258');
          !!!parse-error (type => 'unmatched end tag',
                          text => $self->{t}->{tag_name}, token => $self->{t});
          ## Ignore the token
          !!!nack ('t258.1');
           !!!next-token;
          next B;
        } else {
          !!!cp ('t259');
          !!!parse-error (type => 'in table:/',
                          text => $self->{t}->{tag_name}, token => $self->{t});

          $self->{insert} = $insert = $insert_to_foster;
          #
        }
      } elsif ($self->{t}->{type} == END_OF_FILE_TOKEN) {
        unless ($self->{open_elements}->[-1]->[1] == HTML_EL and
                @{$self->{open_elements}} == 1) { # redundant, maybe
          !!!parse-error (type => 'in body:#eof', token => $self->{t});
          !!!cp ('t259.1');
          #
        } else {
          !!!cp ('t259.2');
          #
        }

        ## Stop parsing
        last B;
      } else {
        die "$0: $self->{t}->{type}: Unknown token type";
      }
    } elsif (($self->{insertion_mode} & IM_MASK) == IN_COLUMN_GROUP_IM) {
          if ($self->{t}->{type} == CHARACTER_TOKEN) {
            if ($self->{t}->{data} =~ s/^([\x09\x0A\x0C\x20]+)//) {
              $self->{open_elements}->[-1]->[0]->manakai_append_text ($1);
              unless (length $self->{t}->{data}) {
                !!!cp ('t260');
                !!!next-token;
                next B;
              }
            }
            
            !!!cp ('t261');
            #
          } elsif ($self->{t}->{type} == START_TAG_TOKEN) {
            if ($self->{t}->{tag_name} eq 'col') {
              !!!cp ('t262');
              !!!insert-element ($self->{t}->{tag_name}, $self->{t}->{attributes}, $self->{t});
              pop @{$self->{open_elements}};
              !!!ack ('t262.1');
              !!!next-token;
              next B;
            } else { 
              !!!cp ('t263');
              #
            }
          } elsif ($self->{t}->{type} == END_TAG_TOKEN) {
            if ($self->{t}->{tag_name} eq 'colgroup') {
              if ($self->{open_elements}->[-1]->[1] == HTML_EL) {
                !!!cp ('t264');
                !!!parse-error (type => 'unmatched end tag',
                                text => 'colgroup', token => $self->{t});
                ## Ignore the token
                !!!next-token;
                next B;
              } else {
                !!!cp ('t265');
                pop @{$self->{open_elements}}; # colgroup
                $self->{insertion_mode} = IN_TABLE_IM;
                !!!next-token;
                next B;             
              }
            } elsif ($self->{t}->{tag_name} eq 'col') {
              !!!cp ('t266');
              !!!parse-error (type => 'unmatched end tag',
                              text => 'col', token => $self->{t});
              ## Ignore the token
              !!!next-token;
              next B;
            } else {
              !!!cp ('t267');
              # 
            }
      } elsif ($self->{t}->{type} == END_OF_FILE_TOKEN) {
        if ($self->{open_elements}->[-1]->[1] == HTML_EL and
            @{$self->{open_elements}} == 1) { # redundant, maybe
          !!!cp ('t270.2');
          ## Stop parsing.
          last B;
        } else {
          ## XXXgeneratetoken
          ## NOTE: As if </colgroup>.
          !!!cp ('t270.1');
          pop @{$self->{open_elements}}; # colgroup
          $self->{insertion_mode} = IN_TABLE_IM;
          ## Reprocess.
          next B;
        }
      } else {
        die "$0: $self->{t}->{type}: Unknown token type";
      }

          ## XXXgeneratetoken
          ## As if </colgroup>
          if ($self->{open_elements}->[-1]->[1] == HTML_EL) {
            !!!cp ('t269');
## TODO: Wrong error type?
            !!!parse-error (type => 'unmatched end tag',
                            text => 'colgroup', token => $self->{t});
            ## Ignore the token
            !!!nack ('t269.1');
            !!!next-token;
            next B;
          } else {
            !!!cp ('t270');
            pop @{$self->{open_elements}}; # colgroup
            $self->{insertion_mode} = IN_TABLE_IM;
            !!!ack-later;
            ## reprocess
            next B;
          }
    } elsif ($self->{insertion_mode} & SELECT_IMS) {
      if ($self->{t}->{type} == CHARACTER_TOKEN) {
        !!!cp ('t271');
        my $data = $self->{t}->{data};
        while ($data =~ s/\x00//) {
          !!!parse-error (type => 'NULL', token => $self->{t});
        }
        $self->{open_elements}->[-1]->[0]->manakai_append_text ($data)
            if $data ne '';
        !!!next-token;
        next B;
      } elsif ($self->{t}->{type} == START_TAG_TOKEN) {
        if ($self->{t}->{tag_name} eq 'option') {
          if ($self->{open_elements}->[-1]->[1] == OPTION_EL) {
            !!!cp ('t272');
            ## XXXgeneratetoken
            ## As if </option>
            pop @{$self->{open_elements}};
          } else {
            !!!cp ('t273');
          }

          !!!insert-element ($self->{t}->{tag_name}, $self->{t}->{attributes}, $self->{t});
          !!!nack ('t273.1');
          !!!next-token;
          next B;
        } elsif ($self->{t}->{tag_name} eq 'optgroup') {
          if ($self->{open_elements}->[-1]->[1] == OPTION_EL) {
            !!!cp ('t274');
            ## XXXgenereatetoken
            ## As if </option>
            pop @{$self->{open_elements}};
          } else {
            !!!cp ('t275');
          }

          if ($self->{open_elements}->[-1]->[1] == OPTGROUP_EL) {
            !!!cp ('t276');
            ## XXXgeneratetoken
            ## As if </optgroup>
            pop @{$self->{open_elements}};
          } else {
            !!!cp ('t277');
          }

          !!!insert-element ($self->{t}->{tag_name}, $self->{t}->{attributes}, $self->{t});
          !!!nack ('t277.1');
          !!!next-token;
          next B;

        } elsif ($self->{t}->{tag_name} eq 'select') {
          ## "In select" / "in select in table" insertion mode,
          ## "select" start tag.
          !!!cp ('t278');

          !!!parse-error (type => 'select in select', ## XXX: documentation
                          token => $self->{t});

          ## XXXgenereatetoken
          ## Act as if the token were </select>.
          $self->{t} = {type => END_TAG_TOKEN, tag_name => 'select',
                    line => $self->{t}->{line}, column => $self->{t}->{column}};
          next B;

        } elsif ({
          input => 1, textarea => 1, keygen => 1,
        }->{$self->{t}->{tag_name}}) {
          ## "In select" / "in select in table" insertion mode,
          ## "input", "keygen", "textarea" start tag.

          ## Parse error.
          !!!parse-error (type => 'not closed', text => 'select',
                          token => $self->{t});

          ## If there "have an element in select scope" where element
          ## is a |select| element.
          my $i;
          INSCOPE: for (reverse 0..$#{$self->{open_elements}}) {
            my $node = $self->{open_elements}->[$_];
            if ($node->[1] == SELECT_EL) {
              !!!cp ('t280');
              $i = $_;
              last INSCOPE;
            } elsif ($node->[1] == OPTGROUP_EL or
                     $node->[1] == OPTION_EL) {
              !!!cp ('t280.2');
              #
            } else {
              !!!cp ('t279');
              last INSCOPE;
            }
          } # INSCOPE
          unless (defined $i) {
            ## Ignore the token.
            !!!nack ('t280.1');
            !!!next-token;
            next B;
          }

          ## Otherwise, act as if there were </select>, then reprocess
          ## the token.
          !!!back-token;
          $self->{t} = {type => END_TAG_TOKEN, tag_name => 'select',
                    line => $self->{t}->{line}, column => $self->{t}->{column}};
          next B;

        } elsif (
          ($self->{insertion_mode} & IM_MASK) == IN_SELECT_IN_TABLE_IM and
          {
            caption => 1, table => 1, tbody => 1, tfoot => 1, thead => 1,
            tr => 1, td => 1, th => 1,
          }->{$self->{t}->{tag_name}}
        ) {
          ## "In select in table" insertion mode, table-related start
          ## tags.

          ## Parse error.
          !!!parse-error (type => 'not closed', text => 'select',
                          token => $self->{t});

          ## Act as if there were </select>, then reprocess the token.
          !!!back-token;
          $self->{t} = {type => END_TAG_TOKEN, tag_name => 'select',
                    line => $self->{t}->{line}, column => $self->{t}->{column}};
          next B;

        } elsif ($self->{t}->{tag_name} eq 'script') {
          !!!cp ('t281.3');
          ## NOTE: This is an "as if in head" code clone
          $script_start_tag->($self, $insert, $open_tables);
          next B;
        } else {
          !!!cp ('t282');
          !!!parse-error (type => 'in select',
                          text => $self->{t}->{tag_name}, token => $self->{t});
          ## Ignore the token
          !!!nack ('t282.1');
          !!!next-token;
          next B;
        }

      } elsif ($self->{t}->{type} == END_TAG_TOKEN) {
        if ($self->{t}->{tag_name} eq 'optgroup') {
          if ($self->{open_elements}->[-1]->[1] == OPTION_EL and
              $self->{open_elements}->[-2]->[1] == OPTGROUP_EL) {
            !!!cp ('t283');
            ## XXXgeneratetoken
            ## As if </option>
            splice @{$self->{open_elements}}, -2;
          } elsif ($self->{open_elements}->[-1]->[1] == OPTGROUP_EL) {
            !!!cp ('t284');
            pop @{$self->{open_elements}};
          } else {
            !!!cp ('t285');
            !!!parse-error (type => 'unmatched end tag',
                            text => $self->{t}->{tag_name}, token => $self->{t});
            ## Ignore the token
          }
          !!!nack ('t285.1');
          !!!next-token;
          next B;
        } elsif ($self->{t}->{tag_name} eq 'option') {
          if ($self->{open_elements}->[-1]->[1] == OPTION_EL) {
            !!!cp ('t286');
            pop @{$self->{open_elements}};
          } else {
            !!!cp ('t287');
            !!!parse-error (type => 'unmatched end tag',
                            text => $self->{t}->{tag_name}, token => $self->{t});
            ## Ignore the token
          }
          !!!nack ('t287.1');
          !!!next-token;
          next B;

        } elsif ($self->{t}->{tag_name} eq 'select') {
          ## "In select" / "in select in table" insertion mode,
          ## "select" end tag.

          ## There "have an element in select scope" where the element
          ## is |select|.
          my $i;
          INSCOPE: for (reverse 0..$#{$self->{open_elements}}) {
            my $node = $self->{open_elements}->[$_];
            if ($node->[1] == SELECT_EL) {
              !!!cp ('t288');
              $i = $_;
              last INSCOPE;
            } elsif ($node->[1] == OPTION_EL or
                     $node->[1] == OPTGROUP_EL) {
              !!!cp ('t289.1');
              #
            } else {
              !!!cp ('t289');
              last INSCOPE;
            }
          } # INSCOPE
          unless (defined $i) {
            !!!cp ('t290');
            !!!parse-error (type => 'unmatched end tag',
                            text => $self->{t}->{tag_name}, token => $self->{t});
            ## Ignore the token.
            !!!nack ('t290.1');
            !!!next-token;
            next B;
          }
          
          ## Otherwise,
          !!!cp ('t291');
          splice @{$self->{open_elements}}, $i;

          $self->_reset_insertion_mode;

          !!!nack ('t291.1');
          !!!next-token;
          next B;

        } elsif (
          ($self->{insertion_mode} & IM_MASK) == IN_SELECT_IN_TABLE_IM and
          {
            caption => 1, table => 1, tbody => 1, tfoot => 1, thead => 1,
            tr => 1, td => 1, th => 1,
          }->{$self->{t}->{tag_name}}
        ) {
          ## "In select in table" insertion mode, table-related end
          ## tags.

          !!!parse-error (type => 'unmatched end tag',
                          text => $self->{t}->{tag_name}, token => $self->{t});

          ## There "have an element in table scope" where the element
          ## is same tag name as |$self->{t}|.
          my $i;
          INSCOPE: for (reverse 0..$#{$self->{open_elements}}) {
            my $node = $self->{open_elements}->[$_];
            if ($node->[0]->manakai_local_name eq $self->{t}->{tag_name}) {
              !!!cp ('t292');
              $i = $_;
              last INSCOPE;
            } elsif ($node->[1] & TABLE_SCOPING_EL) {
              !!!cp ('t293');
              last INSCOPE;
            }
          } # INSCOPE
          unless (defined $i) {
            !!!cp ('t294');
            ## Ignore the token
            !!!nack ('t294.1');
            !!!next-token;
            next B;
          }
          
          ## Act as if there were </select>, then reprocess the token.
          !!!back-token;
          $self->{t} = {type => END_TAG_TOKEN, tag_name => 'select',
                    line => $self->{t}->{line}, column => $self->{t}->{column}};
          next B;

        } else {
          !!!cp ('t299');
          !!!parse-error (type => 'in select:/',
                          text => $self->{t}->{tag_name}, token => $self->{t});
          ## Ignore the token
          !!!nack ('t299.3');
          !!!next-token;
          next B;
        }
      } elsif ($self->{t}->{type} == END_OF_FILE_TOKEN) {
        unless ($self->{open_elements}->[-1]->[1] == HTML_EL and
                @{$self->{open_elements}} == 1) { # redundant, maybe
          !!!cp ('t299.1');
          !!!parse-error (type => 'in body:#eof', token => $self->{t});
        } else {
          !!!cp ('t299.2');
        }

        ## Stop parsing.
        last B;
      } else {
        die "$0: $self->{t}->{type}: Unknown token type";
      }
    } elsif ($self->{insertion_mode} & BODY_AFTER_IMS) {
      if ($self->{t}->{type} == CHARACTER_TOKEN) {
        if ($self->{t}->{data} =~ s/^([\x09\x0A\x0C\x20]+)//) {
          my $data = $1;
          ## As if in body
          $reconstruct_active_formatting_elements
              ->($self, $insert_to_current, $active_formatting_elements,
                 $open_tables);
              
          $self->{open_elements}->[-1]->[0]->manakai_append_text ($1);
          
          unless (length $self->{t}->{data}) {
            !!!cp ('t300');
            !!!next-token;
            next B;
          }
        }
        
        if ($self->{insertion_mode} == AFTER_HTML_BODY_IM) {
          !!!cp ('t301');
          !!!parse-error (type => 'after html:#text', token => $self->{t});
          #
        } else {
          !!!cp ('t302');
          ## "after body" insertion mode
          !!!parse-error (type => 'after body:#text', token => $self->{t});
          #
        }

        $self->{insertion_mode} = IN_BODY_IM;
        ## reprocess
        next B;
      } elsif ($self->{t}->{type} == START_TAG_TOKEN) {
        if ($self->{insertion_mode} == AFTER_HTML_BODY_IM) {
          !!!cp ('t303');
          !!!parse-error (type => 'after html',
                          text => $self->{t}->{tag_name}, token => $self->{t});
          #
        } else {
          !!!cp ('t304');
          ## "after body" insertion mode
          !!!parse-error (type => 'after body',
                          text => $self->{t}->{tag_name}, token => $self->{t});
          #
        }

        $self->{insertion_mode} = IN_BODY_IM;
        !!!ack-later;
        ## reprocess
        next B;
      } elsif ($self->{t}->{type} == END_TAG_TOKEN) {
        if ($self->{insertion_mode} == AFTER_HTML_BODY_IM) {
          !!!cp ('t305');
          !!!parse-error (type => 'after html:/',
                          text => $self->{t}->{tag_name}, token => $self->{t});
          
          $self->{insertion_mode} = IN_BODY_IM;
          ## Reprocess.
          next B;
        } else {
          !!!cp ('t306');
        }

        ## "after body" insertion mode
        if ($self->{t}->{tag_name} eq 'html') {
          if (defined $self->{inner_html_node}) {
            !!!cp ('t307');
            !!!parse-error (type => 'unmatched end tag',
                            text => 'html', token => $self->{t});
            ## Ignore the token
            !!!next-token;
            next B;
          } else {
            !!!cp ('t308');
            $self->{insertion_mode} = AFTER_HTML_BODY_IM;
            !!!next-token;
            next B;
          }
        } else {
          !!!cp ('t309');
          !!!parse-error (type => 'after body:/',
                          text => $self->{t}->{tag_name}, token => $self->{t});

          $self->{insertion_mode} = IN_BODY_IM;
          ## reprocess
          next B;
        }
      } elsif ($self->{t}->{type} == END_OF_FILE_TOKEN) {
        !!!cp ('t309.2');
        ## Stop parsing
        last B;
      } else {
        die "$0: $self->{t}->{type}: Unknown token type";
      }
    } elsif ($self->{insertion_mode} & FRAME_IMS) {
      if ($self->{t}->{type} == CHARACTER_TOKEN) {
        if ($self->{t}->{data} =~ s/^([\x09\x0A\x0C\x20]+)//) {
          $self->{open_elements}->[-1]->[0]->manakai_append_text ($1);
          
          unless (length $self->{t}->{data}) {
            !!!cp ('t310');
            !!!next-token;
            next B;
          }
        }
        
        if ($self->{t}->{data} =~ s/^[^\x09\x0A\x0C\x20]+//) {
          if ($self->{insertion_mode} == IN_FRAMESET_IM) {
            !!!cp ('t311');
            !!!parse-error (type => 'in frameset:#text', token => $self->{t});
          } elsif ($self->{insertion_mode} == AFTER_FRAMESET_IM) {
            !!!cp ('t312');
            !!!parse-error (type => 'after frameset:#text', token => $self->{t});
          } else { # "after after frameset"
            !!!cp ('t313');
            !!!parse-error (type => 'after html:#text', token => $self->{t});
          }
          
          ## Ignore the token.
          if (length $self->{t}->{data}) {
            !!!cp ('t314');
            ## reprocess the rest of characters
          } else {
            !!!cp ('t315');
            !!!next-token;
          }
          next B;
        }
        
        die qq[$0: Character "$self->{t}->{data}"];
      } elsif ($self->{t}->{type} == START_TAG_TOKEN) {
        if ($self->{t}->{tag_name} eq 'frameset' and
            $self->{insertion_mode} == IN_FRAMESET_IM) {
          !!!cp ('t318');
          !!!insert-element ($self->{t}->{tag_name}, $self->{t}->{attributes}, $self->{t});
          !!!nack ('t318.1');
          !!!next-token;
          next B;
        } elsif ($self->{t}->{tag_name} eq 'frame' and
                 $self->{insertion_mode} == IN_FRAMESET_IM) {
          !!!cp ('t319');
          !!!insert-element ($self->{t}->{tag_name}, $self->{t}->{attributes}, $self->{t});
          pop @{$self->{open_elements}};
          !!!ack ('t319.1');
          !!!next-token;
          next B;
        } elsif ($self->{t}->{tag_name} eq 'noframes') {
          !!!cp ('t320');
          ## NOTE: As if in head.
          $parse_rcdata->($self, $insert, $open_tables, 0); # RAWTEXT
          next B;

          ## NOTE: |<!DOCTYPE HTML><frameset></frameset></html><noframes></noframes>|
          ## has no parse error.
        } else {
          if ($self->{insertion_mode} == IN_FRAMESET_IM) {
            !!!cp ('t321');
            !!!parse-error (type => 'in frameset',
                            text => $self->{t}->{tag_name}, token => $self->{t});
          } elsif ($self->{insertion_mode} == AFTER_FRAMESET_IM) {
            !!!cp ('t322');
            !!!parse-error (type => 'after frameset',
                            text => $self->{t}->{tag_name}, token => $self->{t});
          } else { # "after after frameset"
            !!!cp ('t322.2');
            !!!parse-error (type => 'after after frameset',
                            text => $self->{t}->{tag_name}, token => $self->{t});
          }
          ## Ignore the token
          !!!nack ('t322.1');
          !!!next-token;
          next B;
        }
      } elsif ($self->{t}->{type} == END_TAG_TOKEN) {
        if ($self->{t}->{tag_name} eq 'frameset' and
            $self->{insertion_mode} == IN_FRAMESET_IM) {
          if ($self->{open_elements}->[-1]->[1] == HTML_EL and
              @{$self->{open_elements}} == 1) {
            !!!cp ('t325');
            !!!parse-error (type => 'unmatched end tag',
                            text => $self->{t}->{tag_name}, token => $self->{t});
            ## Ignore the token
            !!!next-token;
          } else {
            !!!cp ('t326');
            pop @{$self->{open_elements}};
            !!!next-token;
          }

          if (not defined $self->{inner_html_node} and
              not ($self->{open_elements}->[-1]->[1] == FRAMESET_EL)) {
            !!!cp ('t327');
            $self->{insertion_mode} = AFTER_FRAMESET_IM;
          } else {
            !!!cp ('t328');
          }
          next B;
        } elsif ($self->{t}->{tag_name} eq 'html' and
                 $self->{insertion_mode} == AFTER_FRAMESET_IM) {
          !!!cp ('t329');
          $self->{insertion_mode} = AFTER_HTML_FRAMESET_IM;
          !!!next-token;
          next B;
        } else {
          if ($self->{insertion_mode} == IN_FRAMESET_IM) {
            !!!cp ('t330');
            !!!parse-error (type => 'in frameset:/',
                            text => $self->{t}->{tag_name}, token => $self->{t});
          } elsif ($self->{insertion_mode} == AFTER_FRAMESET_IM) {
            !!!cp ('t330.1');
            !!!parse-error (type => 'after frameset:/',
                            text => $self->{t}->{tag_name}, token => $self->{t});
          } else { # "after after html"
            !!!cp ('t331');
            !!!parse-error (type => 'after after frameset:/',
                            text => $self->{t}->{tag_name}, token => $self->{t});
          }
          ## Ignore the token
          !!!next-token;
          next B;
        }
      } elsif ($self->{t}->{type} == END_OF_FILE_TOKEN) {
        unless ($self->{open_elements}->[-1]->[1] == HTML_EL and
                @{$self->{open_elements}} == 1) { # redundant, maybe
          !!!cp ('t331.1');
          !!!parse-error (type => 'in body:#eof', token => $self->{t});
        } else {
          !!!cp ('t331.2');
        }
        
        ## Stop parsing
        last B;
      } else {
        die "$0: $self->{t}->{type}: Unknown token type";
      }
    } else {
      die "$0: $self->{insertion_mode}: Unknown insertion mode";
    }

    ## "in body" insertion mode
    if ($self->{t}->{type} == START_TAG_TOKEN) {
      if ($self->{t}->{tag_name} eq 'script') {
        !!!cp ('t332');
        ## NOTE: This is an "as if in head" code clone
        $script_start_tag->($self, $insert, $open_tables);
        next B;
      } elsif ($self->{t}->{tag_name} eq 'style') {
        !!!cp ('t333');
        ## NOTE: This is an "as if in head" code clone
        $parse_rcdata->($self, $insert, $open_tables, 0); # RAWTEXT
        next B;
      } elsif ({
        base => 1, command => 1, link => 1, basefont => 1, bgsound => 1,
      }->{$self->{t}->{tag_name}}) {
        !!!cp ('t334');
        ## NOTE: This is an "as if in head" code clone, only "-t" differs
        !!!insert-element-t ($self->{t}->{tag_name}, $self->{t}->{attributes}, $self->{t});
        pop @{$self->{open_elements}};
        !!!ack ('t334.1');
        !!!next-token;
        next B;
      } elsif ($self->{t}->{tag_name} eq 'meta') {
        ## NOTE: This is an "as if in head" code clone, only "-t" differs
        !!!insert-element-t ($self->{t}->{tag_name}, $self->{t}->{attributes}, $self->{t});
        my $meta_el = pop @{$self->{open_elements}};

        unless ($self->{confident}) {
          if ($self->{t}->{attributes}->{charset}) {
            !!!cp ('t335');
            ## NOTE: Whether the encoding is supported or not, an
            ## ASCII-compatible charset is not, is handled in the
            ## |_change_encoding| method.
            $self->_change_encoding
                ($self->{t}->{attributes}->{charset}->{value}, $self->{t});
            
            $meta_el->[0]->get_attribute_node_ns (undef, 'charset')
                ->set_user_data (manakai_has_reference =>
                                     $self->{t}->{attributes}->{charset}
                                         ->{has_reference});
          } elsif ($self->{t}->{attributes}->{content} and
                   $self->{t}->{attributes}->{'http-equiv'}) {
            if ($self->{t}->{attributes}->{'http-equiv'}->{value}
                =~ /\A[Cc][Oo][Nn][Tt][Ee][Nn][Tt]-[Tt][Yy][Pp][Ee]\z/ and
                $self->{t}->{attributes}->{content}->{value}
                =~ /[Cc][Hh][Aa][Rr][Ss][Ee][Tt]
                    [\x09\x0A\x0C\x0D\x20]*=
                    [\x09\x0A\x0C\x0D\x20]*(?>"([^"]*)"|'([^']*)'|
                    ([^"'\x09\x0A\x0C\x0D\x20][^\x09\x0A\x0C\x0D\x20\x3B]*))
                   /x) {
              !!!cp ('t336');
              ## NOTE: Whether the encoding is supported or not, an
              ## ASCII-compatible charset is not, is handled in the
              ## |_change_encoding| method.
              $self->_change_encoding
                  (defined $1 ? $1 : defined $2 ? $2 : $3, $self->{t});
              $meta_el->[0]->get_attribute_node_ns (undef, 'content')
                  ->set_user_data (manakai_has_reference =>
                                       $self->{t}->{attributes}->{content}
                                             ->{has_reference});
            }
          }
        } else {
          if ($self->{t}->{attributes}->{charset}) {
            !!!cp ('t337');
            $meta_el->[0]->get_attribute_node_ns (undef, 'charset')
                ->set_user_data (manakai_has_reference =>
                                     $self->{t}->{attributes}->{charset}
                                         ->{has_reference});
          }
          if ($self->{t}->{attributes}->{content}) {
            !!!cp ('t338');
            $meta_el->[0]->get_attribute_node_ns (undef, 'content')
                ->set_user_data (manakai_has_reference =>
                                     $self->{t}->{attributes}->{content}
                                         ->{has_reference});
          }
        }

        !!!ack ('t338.1');
        !!!next-token;
        next B;
      } elsif ($self->{t}->{tag_name} eq 'title') {
        !!!cp ('t341');
        ## NOTE: This is an "as if in head" code clone
        $parse_rcdata->($self, $insert, $open_tables, 1); # RCDATA
        next B;

      } elsif ($self->{t}->{tag_name} eq 'body') {
        ## "In body" insertion mode, "body" start tag token.
        !!!parse-error (type => 'in body', text => 'body', token => $self->{t});
              
        if (@{$self->{open_elements}} == 1 or
            not ($self->{open_elements}->[1]->[1] == BODY_EL)) {
          !!!cp ('t342');
          ## Ignore the token
        } else {
          delete $self->{frameset_ok};
          my $body_el = $self->{open_elements}->[1]->[0];
          for my $attr_name (keys %{$self->{t}->{attributes}}) {
            unless ($body_el->has_attribute_ns (undef, $attr_name)) {
              !!!cp ('t343');
              $body_el->set_attribute_ns
                (undef, [undef, $attr_name],
                 $self->{t}->{attributes}->{$attr_name}->{value});
            }
          }
        }
        !!!nack ('t343.1');
        !!!next-token;
        next B;
      } elsif ($self->{t}->{tag_name} eq 'frameset') {
        !!!parse-error (type => 'in body', text => $self->{t}->{tag_name},
                        token => $self->{t});

        if (@{$self->{open_elements}} == 1 or
            not ($self->{open_elements}->[1]->[1] == BODY_EL)) {
          !!!cp ('t343.2');
          ## Ignore the token.
        } elsif (not $self->{frameset_ok}) {
          !!!cp ('t343.3');
          ## Ignore the token.
        } else {
          !!!cp ('t343.4');
          
          ## 1. Remove the second element.
          my $body = $self->{open_elements}->[1]->[0];
          my $body_parent = $body->parent_node;
          $body_parent->remove_child ($body) if $body_parent;

          ## 2. Pop nodes.
          splice @{$self->{open_elements}}, 1;

          ## 3. Insert.
          !!!insert-element-t ($self->{t}->{tag_name}, $self->{t}->{attributes}, $self->{t});

          ## 4. Switch.
          $self->{insertion_mode} = IN_FRAMESET_IM;
        }

        !!!nack ('t343.5');
        !!!next-token;
        next B;

      } elsif ({
        ## "In body" insertion mode, non-phrasing flow-content
        ## elements start tags.

        address => 1, article => 1, aside => 1, blockquote => 1,
        center => 1, details => 1, dir => 1, div => 1, dl => 1,
        fieldset => 1, figcaption => 1, figure => 1, footer => 1,
        header => 1, hgroup => 1, menu => 1, nav => 1, ol => 1,
        p => 1, section => 1, ul => 1, summary => 1,
        # datagrid => 1,

        ## Closing any heading element
        h1 => 1, h2 => 1, h3 => 1, h4 => 1, h5 => 1, h6 => 1, 

        ## Ignoring any leading newline in content
        pre => 1, listing => 1,

        ## Form element pointer
        form => 1,
        
        ## A quirk & switching of insertion mode
        table => 1,

        ## Void element
        hr => 1,
      }->{$self->{t}->{tag_name}}) {

        ## 1. When there is an opening |form| element:
        if ($self->{t}->{tag_name} eq 'form' and defined $self->{form_element}) {
          !!!cp ('t350');
          !!!parse-error (type => 'in form:form', token => $self->{t});
          ## Ignore the token
          !!!nack ('t350.1');
          !!!next-token;
          next B;
        }

        ## 2. Close the |p| element, if any.
        if ($self->{t}->{tag_name} ne 'table' or # The Hixie Quirk
            $self->{document}->manakai_compat_mode ne 'quirks') {
          ## "have a |p| element in button scope"
          INSCOPE: for (reverse @{$self->{open_elements}}) {
            if ($_->[1] == P_EL) {
              !!!cp ('t344');
              !!!back-token; # <form>
              $self->{t} = {type => END_TAG_TOKEN, tag_name => 'p',
                        line => $self->{t}->{line}, column => $self->{t}->{column}};
              next B;
            } elsif ($_->[1] & BUTTON_SCOPING_EL) {
              !!!cp ('t345');
              last INSCOPE;
            }
          } # INSCOPE
        }

        ## 3. Close the opening <hn> element, if any.
        if ({h1 => 1, h2 => 1, h3 => 1,
             h4 => 1, h5 => 1, h6 => 1}->{$self->{t}->{tag_name}}) {
          if ($self->{open_elements}->[-1]->[1] == HEADING_EL) {
            !!!parse-error (type => 'not closed',
                            text => $self->{open_elements}->[-1]->[0]->manakai_local_name,
                            token => $self->{t});
            pop @{$self->{open_elements}};
          }
        }

        ## 4. Insertion.
        !!!insert-element-t ($self->{t}->{tag_name}, $self->{t}->{attributes}, $self->{t});
        if ($self->{t}->{tag_name} eq 'pre' or $self->{t}->{tag_name} eq 'listing') {
          !!!nack ('t346.1');
          !!!next-token;
          if ($self->{t}->{type} == CHARACTER_TOKEN) {
            $self->{t}->{data} =~ s/^\x0A//;
            unless (length $self->{t}->{data}) {
              !!!cp ('t346');
              !!!next-token;
            } else {
              !!!cp ('t349');
            }
          } else {
            !!!cp ('t348');
          }

          delete $self->{frameset_ok};
        } elsif ($self->{t}->{tag_name} eq 'form') {
          !!!cp ('t347.1');
          $self->{form_element} = $self->{open_elements}->[-1]->[0];

          !!!nack ('t347.2');
          !!!next-token;
        } elsif ($self->{t}->{tag_name} eq 'table') {
          !!!cp ('t382');
          push @{$open_tables}, [$self->{open_elements}->[-1]->[0]];

          delete $self->{frameset_ok};
          
          $self->{insertion_mode} = IN_TABLE_IM;

          !!!nack ('t382.1');
          !!!next-token;
        } elsif ($self->{t}->{tag_name} eq 'hr') {
          !!!cp ('t386');
          pop @{$self->{open_elements}};
          
          !!!ack ('t386.1');

          delete $self->{frameset_ok};

          !!!next-token;
        } else {
          !!!nack ('t347.1');
          !!!next-token;
        }
        next B;

      } elsif ($self->{t}->{tag_name} eq 'li') {
        ## "In body" insertion mode, "li" start tag.  As normal, but
        ## imply </li> when there's another <li>.

        ## NOTE: Special, Scope (<li><foo><li> == <li><foo><li/></foo></li>)::
          ## Interpreted as <li><foo/></li><li/> (non-conforming):
          ## blockquote (O9.27), center (O), dd (Fx3, O, S3.1.2, IE7),
          ## dt (Fx, O, S, IE), dl (O), fieldset (O, S, IE), form (Fx, O, S),
          ## hn (O), pre (O), applet (O, S), button (O, S), marquee (Fx, O, S),
          ## object (Fx)
          ## Generate non-tree (non-conforming):
          ## basefont (IE7 (where basefont is non-void)), center (IE),
          ## form (IE), hn (IE)
        ## address, div, p (<li><foo><li> == <li><foo/></li><li/>)::
          ## Interpreted as <li><foo><li/></foo></li> (non-conforming):
          ## div (Fx, S)

        ## 1. Frameset-ng
        delete $self->{frameset_ok};

        my $non_optional;
        my $i = -1;

        ## 2.
        for my $node (reverse @{$self->{open_elements}}) {
          if ($node->[1] == LI_EL) {
            ## XXXgeneratetoken
            ## 3. (a) As if </li>
            {
              ## If no </li> - not applied
              #

              ## Otherwise

              ## 1. generate implied end tags, except for </li>
              #

              ## 2. If current node != "li", parse error
              if ($non_optional) {
                !!!parse-error (type => 'not closed',
                                text => $non_optional->[0]->manakai_local_name,
                                token => $self->{t});
                !!!cp ('t355');
              } else {
                !!!cp ('t356');
              }

              ## 3. Pop
              splice @{$self->{open_elements}}, $i;
            }

            last; ## 3. (b) goto 5.
          } elsif (
                   ## NOTE: "special" category
                   ($node->[1] & SPECIAL_EL or
                    $node->[1] & SCOPING_EL) and
                   ## NOTE: "li", "dt", and "dd" are in |SPECIAL_EL|.
                   (not $node->[1] & ADDRESS_DIV_P_EL)
                  ) {
            ## 4.
            !!!cp ('t357');
            last; ## goto 6.
          } elsif ($node->[1] & END_TAG_OPTIONAL_EL) {
            !!!cp ('t358');
            #
          } else {
            !!!cp ('t359');
            $non_optional ||= $node;
            #
          }
          ## 5.
          ## goto 3.
          $i--;
        }

        ## 6. (a) "have a |p| element in button scope".
        INSCOPE: for (reverse @{$self->{open_elements}}) {
          if ($_->[1] == P_EL) {
            !!!cp ('t353');

            ## NOTE: |<p><li>|, for example.

            !!!back-token; # <x>
            $self->{t} = {type => END_TAG_TOKEN, tag_name => 'p',
                      line => $self->{t}->{line}, column => $self->{t}->{column}};
            next B;
          } elsif ($_->[1] & BUTTON_SCOPING_EL) {
            !!!cp ('t354');
            last INSCOPE;
          }
        } # INSCOPE

        ## 6. (b) insert
        !!!insert-element-t ($self->{t}->{tag_name}, $self->{t}->{attributes}, $self->{t});
        !!!nack ('t359.1');
        !!!next-token;
        next B;

      } elsif ($self->{t}->{tag_name} eq 'dt' or $self->{t}->{tag_name} eq 'dd') {
        ## "In body" insertion mode, "dt" or "dd" start tag.  As
        ## normal, but imply </dt> or </dd> when there's antoher <dt>
        ## or <dd>.

        ## 1. Frameset-ng
        delete $self->{frameset_ok};

        my $non_optional;
        my $i = -1;

        ## 2.
        for my $node (reverse @{$self->{open_elements}}) {
          if ($node->[1] == DTDD_EL) {
            ## XXXgeneratetoken
            ## 3. (a) As if </li>
            {
              ## If no </li> - not applied
              #

              ## Otherwise

              ## 1. generate implied end tags, except for </dt> or </dd>
              #

              ## 2. If current node != "dt"|"dd", parse error
              if ($non_optional) {
                !!!parse-error (type => 'not closed',
                                text => $non_optional->[0]->manakai_local_name,
                                token => $self->{t});
                !!!cp ('t355.1');
              } else {
                !!!cp ('t356.1');
              }

              ## 3. Pop
              splice @{$self->{open_elements}}, $i;
            }

            last; ## 3. (b) goto 5.
          } elsif (
                   ## NOTE: "special" category
                   ($node->[1] & SPECIAL_EL or $node->[1] & SCOPING_EL) and
                   ## NOTE: "li", "dt", and "dd" are in |SPECIAL_EL|.

                   (not $node->[1] & ADDRESS_DIV_P_EL)
                  ) {
            ## 4.
            !!!cp ('t357.1');
            last; ## goto 5.
          } elsif ($node->[1] & END_TAG_OPTIONAL_EL) {
            !!!cp ('t358.1');
            #
          } else {
            !!!cp ('t359.1');
            $non_optional ||= $node;
            #
          }
          ## 5.
          ## goto 3.
          $i--;
        }

        ## 6. (a) "have a |p| element in button scope".
        INSCOPE: for (reverse @{$self->{open_elements}}) {
          if ($_->[1] == P_EL) {
            !!!cp ('t353.1');
            !!!back-token; # <x>
            $self->{t} = {type => END_TAG_TOKEN, tag_name => 'p',
                      line => $self->{t}->{line}, column => $self->{t}->{column}};
            next B;
          } elsif ($_->[1] & BUTTON_SCOPING_EL) {
            !!!cp ('t354.1');
            last INSCOPE;
          }
        } # INSCOPE

        ## 6. (b) insert
        !!!insert-element-t ($self->{t}->{tag_name}, $self->{t}->{attributes}, $self->{t});
        !!!nack ('t359.2');
        !!!next-token;
        next B;

      } elsif ($self->{t}->{tag_name} eq 'plaintext') {
        ## "In body" insertion mode, "plaintext" start tag.  As
        ## normal, but effectively ends parsing.

        ## "has a |p| element in scope".
        INSCOPE: for (reverse @{$self->{open_elements}}) {
          if ($_->[1] == P_EL) {
            !!!cp ('t367');
            !!!back-token; # <plaintext>
            $self->{t} = {type => END_TAG_TOKEN, tag_name => 'p',
                      line => $self->{t}->{line}, column => $self->{t}->{column}};
            next B;
          } elsif ($_->[1] & BUTTON_SCOPING_EL) {
            !!!cp ('t368');
            last INSCOPE;
          }
        } # INSCOPE
          
        !!!insert-element-t ($self->{t}->{tag_name}, $self->{t}->{attributes}, $self->{t});
        
        $self->{state} = PLAINTEXT_STATE;
          
        !!!nack ('t368.1');
        !!!next-token;
        next B;

      } elsif ($self->{t}->{tag_name} eq 'a') {
        AFE: for my $i (reverse 0..$#$active_formatting_elements) {
          my $node = $active_formatting_elements->[$i];
          if ($node->[1] == A_EL) {
            !!!cp ('t371');
            !!!parse-error (type => 'in a:a', token => $self->{t});
            
            !!!back-token; # <a>
            $self->{t} = {type => END_TAG_TOKEN, tag_name => 'a',
                      line => $self->{t}->{line}, column => $self->{t}->{column}};
            $formatting_end_tag->($self, $active_formatting_elements,
                                  $open_tables, $self->{t});
            
            AFE2: for (reverse 0..$#$active_formatting_elements) {
              if ($active_formatting_elements->[$_]->[0] eq $node->[0]) {
                !!!cp ('t372');
                splice @$active_formatting_elements, $_, 1;
                last AFE2;
              }
            } # AFE2
            OE: for (reverse 0..$#{$self->{open_elements}}) {
              if ($self->{open_elements}->[$_]->[0] eq $node->[0]) {
                !!!cp ('t373');
                splice @{$self->{open_elements}}, $_, 1;
                last OE;
              }
            } # OE
            last AFE;
          } elsif ($node->[0] eq '#marker') {
            !!!cp ('t374');
            last AFE;
          }
        } # AFE
        
        my $insert = $self->{insertion_mode} & TABLE_IMS
            ? $insert_to_foster : $insert_to_current;
        $reconstruct_active_formatting_elements
            ->($self, $insert, $active_formatting_elements, $open_tables);

        !!!insert-element-t ($self->{t}->{tag_name}, $self->{t}->{attributes}, $self->{t});
        push_afe [$self->{open_elements}->[-1]->[0],
                  $self->{open_elements}->[-1]->[1],
                  $self->{t}]
            => $active_formatting_elements;

        !!!nack ('t374.1');
        !!!next-token;
        next B;
      } elsif ($self->{t}->{tag_name} eq 'nobr') {
        my $insert = $self->{insertion_mode} & TABLE_IMS
            ? $insert_to_foster : $insert_to_current;
        $reconstruct_active_formatting_elements
            ->($self, $insert, $active_formatting_elements, $open_tables);

        ## has a |nobr| element in scope
        INSCOPE: for (reverse 0..$#{$self->{open_elements}}) {
          my $node = $self->{open_elements}->[$_];
          if ($node->[1] == NOBR_EL) {
            !!!cp ('t376');
            !!!parse-error (type => 'in nobr:nobr', token => $self->{t});
            !!!back-token; # <nobr>
            $self->{t} = {type => END_TAG_TOKEN, tag_name => 'nobr',
                      line => $self->{t}->{line}, column => $self->{t}->{column}};
            next B;
          } elsif ($node->[1] & SCOPING_EL) {
            !!!cp ('t377');
            last INSCOPE;
          }
        } # INSCOPE
        
        !!!insert-element-t ($self->{t}->{tag_name}, $self->{t}->{attributes}, $self->{t});
        push_afe [$self->{open_elements}->[-1]->[0],
                  $self->{open_elements}->[-1]->[1],
                  $self->{t}]
            => $active_formatting_elements;
        
        !!!nack ('t377.1');
        !!!next-token;
        next B;
      } elsif ($self->{t}->{tag_name} eq 'button') {
        ## has a button element in scope
        INSCOPE: for (reverse 0..$#{$self->{open_elements}}) {
          my $node = $self->{open_elements}->[$_];
          if ($node->[1] == BUTTON_EL) {
            !!!cp ('t378');
            !!!parse-error (type => 'in button:button', token => $self->{t});
            !!!back-token; # <button>
            $self->{t} = {type => END_TAG_TOKEN, tag_name => 'button',
                      line => $self->{t}->{line}, column => $self->{t}->{column}};
            next B;
          } elsif ($node->[1] & SCOPING_EL) {
            !!!cp ('t379');
            last INSCOPE;
          }
        } # INSCOPE
          
        my $insert = $self->{insertion_mode} & TABLE_IMS
            ? $insert_to_foster : $insert_to_current;
        $reconstruct_active_formatting_elements
            ->($self, $insert, $active_formatting_elements, $open_tables);
          
        !!!insert-element-t ($self->{t}->{tag_name}, $self->{t}->{attributes}, $self->{t});

        ## TODO: associate with $self->{form_element} if defined

        delete $self->{frameset_ok};

        !!!nack ('t379.1');
        !!!next-token;
        next B;
      } elsif ({
                xmp => 1,
                iframe => 1,
                noembed => 1,
                noframes => 1, ## NOTE: This is an "as if in head" code clone.
                noscript => 0, ## TODO: 1 if scripting is enabled
               }->{$self->{t}->{tag_name}}) {
        if ($self->{t}->{tag_name} eq 'xmp') {
          ## "In body" insertion mode, "xmp" start tag.  As normal
          ## flow-content element start tag, but CDATA parsing.
          !!!cp ('t381');

          ## "have a |p| element in button scope".
          INSCOPE: for (reverse @{$self->{open_elements}}) {
            if ($_->[1] == P_EL) {
              !!!cp ('t381.2');
              !!!back-token; # <xmp>
              $self->{t} = {type => END_TAG_TOKEN, tag_name => 'p',
                        line => $self->{t}->{line}, column => $self->{t}->{column}};
              next B;
            } elsif ($_->[1] & BUTTON_SCOPING_EL) {
              !!!cp ('t381.3');
              last INSCOPE;
            }
          } # INSCOPE

          my $insert = $self->{insertion_mode} & TABLE_IMS
              ? $insert_to_foster : $insert_to_current;
          $reconstruct_active_formatting_elements
              ->($self, $insert, $active_formatting_elements,
                 $open_tables);

          delete $self->{frameset_ok};
        } elsif ($self->{t}->{tag_name} eq 'iframe') {
          !!!cp ('t381.1');
          delete $self->{frameset_ok};
        } else {
          !!!cp ('t399');
        }
        ## NOTE: There is an "as if in body" code clone.
        $parse_rcdata->($self, $insert, $open_tables, 0); # RAWTEXT
        next B;
      } elsif ($self->{t}->{tag_name} eq 'isindex') {
        !!!parse-error (type => 'isindex', token => $self->{t});
        
        if (defined $self->{form_element}) {
          !!!cp ('t389');
          ## Ignore the token
          !!!nack ('t389'); ## NOTE: Not acknowledged.
          !!!next-token;
          next B;
        } else {
          !!!ack ('t391.1');

          my $at = $self->{t}->{attributes};
          my $form_attrs;
          $form_attrs->{action} = $at->{action} if $at->{action};
          my $prompt_attr = $at->{prompt};
          $at->{name} = {name => 'name', value => 'isindex'};
          delete $at->{action};
          delete $at->{prompt};
          my @tokens = (
                        {type => START_TAG_TOKEN, tag_name => 'form',
                         attributes => $form_attrs,
                         line => $self->{t}->{line}, column => $self->{t}->{column}},
                        {type => START_TAG_TOKEN, tag_name => 'hr',
                         line => $self->{t}->{line}, column => $self->{t}->{column}},
                        {type => START_TAG_TOKEN, tag_name => 'label',
                         line => $self->{t}->{line}, column => $self->{t}->{column}},
                       );
          if ($prompt_attr) {
            !!!cp ('t390');
            push @tokens, {type => CHARACTER_TOKEN, data => $prompt_attr->{value},
                           #line => $self->{t}->{line}, column => $self->{t}->{column},
                          };
          } else {
            !!!cp ('t391');
            push @tokens, {type => CHARACTER_TOKEN,
                           data => 'This is a searchable index. Enter search keywords: ',
                           #line => $self->{t}->{line}, column => $self->{t}->{column},
                          }; # SHOULD
            ## TODO: make this configurable
          }
          push @tokens,
                        {type => START_TAG_TOKEN, tag_name => 'input', attributes => $at,
                         line => $self->{t}->{line}, column => $self->{t}->{column}},
                        #{type => CHARACTER_TOKEN, data => ''}, # SHOULD
                        {type => END_TAG_TOKEN, tag_name => 'label',
                         line => $self->{t}->{line}, column => $self->{t}->{column}},
                        {type => START_TAG_TOKEN, tag_name => 'hr',
                         line => $self->{t}->{line}, column => $self->{t}->{column}},
                        {type => END_TAG_TOKEN, tag_name => 'form',
                         line => $self->{t}->{line}, column => $self->{t}->{column}};
          !!!back-token (@tokens);
          !!!next-token;
          next B;
        }
      } elsif ($self->{t}->{tag_name} eq 'textarea') {
        ## 1. Insert
        !!!insert-element-t ($self->{t}->{tag_name}, $self->{t}->{attributes}, $self->{t});
        
        ## Step 2 # XXX
        ## TODO: $self->{form_element} if defined

        ## 2. Drop U+000A LINE FEED
        $self->{ignore_newline} = 1;

        ## 3. RCDATA
        $self->{state} = RCDATA_STATE;
        delete $self->{escape}; # MUST

        ## 4., 6. Insertion mode
        $self->{insertion_mode} |= IN_CDATA_RCDATA_IM;

        ## 5. Frameset-ng.
        delete $self->{frameset_ok};

        !!!nack ('t392.1');
        !!!next-token;
        next B;
      } elsif ($self->{t}->{tag_name} eq 'optgroup' or
               $self->{t}->{tag_name} eq 'option') {
        if ($self->{open_elements}->[-1]->[1] == OPTION_EL) {
          !!!cp ('t397.1');
          ## XXXgeneratetoken
          ## NOTE: As if </option>
          !!!back-token; # <option> or <optgroup>
          $self->{t} = {type => END_TAG_TOKEN, tag_name => 'option',
                    line => $self->{t}->{line}, column => $self->{t}->{column}};
          next B;
        }

        my $insert = $self->{insertion_mode} & TABLE_IMS
            ? $insert_to_foster : $insert_to_current;
        $reconstruct_active_formatting_elements
            ->($self, $insert, $active_formatting_elements, $open_tables);

        !!!insert-element-t ($self->{t}->{tag_name}, $self->{t}->{attributes}, $self->{t});

        !!!nack ('t397.3');
        !!!next-token;
        redo B;
      } elsif ($self->{t}->{tag_name} eq 'rt' or
               $self->{t}->{tag_name} eq 'rp') {
        ## has a |ruby| element in scope
        INSCOPE: for (reverse 0..$#{$self->{open_elements}}) {
          my $node = $self->{open_elements}->[$_];
          if ($node->[1] == RUBY_EL) {
            !!!cp ('t398.1');
            ## generate implied end tags
            while ($self->{open_elements}->[-1]->[1] & END_TAG_OPTIONAL_EL) {
              !!!cp ('t398.2');
              pop @{$self->{open_elements}};
            }
            unless ($self->{open_elements}->[-1]->[1] == RUBY_EL) {
              !!!cp ('t398.3');
              !!!parse-error (type => 'not closed',
                              text => $self->{open_elements}->[-1]->[0]
                                  ->manakai_local_name,
                              token => $self->{t});
            }
            last INSCOPE;
          } elsif ($node->[1] & SCOPING_EL) {
            !!!cp ('t398.4');
            last INSCOPE;
          }
        } # INSCOPE

        !!!insert-element-t ($self->{t}->{tag_name}, $self->{t}->{attributes}, $self->{t});

        !!!nack ('t398.5');
        !!!next-token;
        redo B;
      } elsif ($self->{t}->{tag_name} eq 'math' or
               $self->{t}->{tag_name} eq 'svg') {
        my $insert = $self->{insertion_mode} & TABLE_IMS
            ? $insert_to_foster : $insert_to_current;
        $reconstruct_active_formatting_elements
            ->($self, $insert, $active_formatting_elements, $open_tables);

        ## "Adjust MathML attributes" ('math' only) - done in insert-element-f

        ## "adjust SVG attributes" ('svg' only) - done in insert-element-f

        ## "adjust foreign attributes" - done in insert-element-f
        
        !!!insert-element-f ($self->{t}->{tag_name} eq 'math' ? MML_NS : SVG_NS, $self->{t}->{tag_name}, $self->{t}->{attributes}, $self->{t});
        
        if ($self->{self_closing}) {
          pop @{$self->{open_elements}};
          !!!ack ('t398.6');
        } else {
          !!!cp ('t398.7');
        }

        !!!next-token;
        next B;
      } elsif ({
                caption => 1, col => 1, colgroup => 1, frame => 1,
                head => 1,
                tbody => 1, td => 1, tfoot => 1, th => 1,
                thead => 1, tr => 1,
               }->{$self->{t}->{tag_name}}) {
        !!!cp ('t401');
        !!!parse-error (type => 'in body',
                        text => $self->{t}->{tag_name}, token => $self->{t});
        ## Ignore the token
        !!!nack ('t401.1'); ## NOTE: |<col/>| or |<frame/>| here is an error.
        !!!next-token;
        next B;
      } elsif ($self->{t}->{tag_name} eq 'param' or
               $self->{t}->{tag_name} eq 'source' or
               $self->{t}->{tag_name} eq 'track') {
        !!!insert-element-t ($self->{t}->{tag_name}, $self->{t}->{attributes}, $self->{t});
        pop @{$self->{open_elements}};

        !!!ack ('t398.5');
        !!!next-token;
        redo B;
      } else {
        if ($self->{t}->{tag_name} eq 'image') {
          !!!cp ('t384');
          !!!parse-error (type => 'image', token => $self->{t});
          $self->{t}->{tag_name} = 'img';
        } else {
          !!!cp ('t385');
        }

        ## NOTE: There is an "as if <br>" code clone.
        my $insert = $self->{insertion_mode} & TABLE_IMS
            ? $insert_to_foster : $insert_to_current;
        $reconstruct_active_formatting_elements
            ->($self, $insert, $active_formatting_elements, $open_tables);
        
        !!!insert-element-t ($self->{t}->{tag_name}, $self->{t}->{attributes}, $self->{t});

        if ({
             applet => 1, marquee => 1, object => 1,
            }->{$self->{t}->{tag_name}}) {
          !!!cp ('t380');

          push @$active_formatting_elements, ['#marker', '', undef];

          delete $self->{frameset_ok};

          !!!nack ('t380.1');
        } elsif ({
                  b => 1, big => 1, code => 1, em => 1, font => 1, i => 1,
                  s => 1, small => 1, strike => 1,
                  strong => 1, tt => 1, u => 1,
                 }->{$self->{t}->{tag_name}}) {
          !!!cp ('t375');
          push_afe [$self->{open_elements}->[-1]->[0],
               $self->{open_elements}->[-1]->[1],
               $self->{t}]
              => $active_formatting_elements;
          !!!nack ('t375.1');
        } elsif ($self->{t}->{tag_name} eq 'input') {
          !!!cp ('t388');
          ## TODO: associate with $self->{form_element} if defined

          pop @{$self->{open_elements}};

          if ($self->{t}->{attributes}->{type}) {
            my $type = $self->{t}->{attributes}->{type}->{value};
            $type =~ tr/A-Z/a-z/; ## ASCII case-insensitive.
            if ($type eq 'hidden') {
              #
            } else {
              delete $self->{frameset_ok};
            }
          } else {
            delete $self->{frameset_ok};
          }

          !!!ack ('t388.2');
        } elsif ({
          area => 1, br => 1, embed => 1, img => 1, wbr => 1, keygen => 1,
        }->{$self->{t}->{tag_name}}) {
          !!!cp ('t388.1');

          pop @{$self->{open_elements}};

          delete $self->{frameset_ok};

          !!!ack ('t388.3');
        } elsif ($self->{t}->{tag_name} eq 'select') {
          ## TODO: associate with $self->{form_element} if defined

          delete $self->{frameset_ok};
          
          if ($self->{insertion_mode} & TABLE_IMS or
              $self->{insertion_mode} & BODY_TABLE_IMS) {
            !!!cp ('t400.1');
            $self->{insertion_mode} = IN_SELECT_IN_TABLE_IM;
          } else {
            !!!cp ('t400.2');
            $self->{insertion_mode} = IN_SELECT_IM;
          }
          !!!nack ('t400.3');
        } else {
          !!!nack ('t402');
        }
        
        !!!next-token;
        next B;
      }
    } elsif ($self->{t}->{type} == END_TAG_TOKEN) {
      if ($self->{t}->{tag_name} eq 'body' or $self->{t}->{tag_name} eq 'html') {

        ## 1. If not "have an element in scope":
        ## "has a |body| element in scope"
        my $i;
        INSCOPE: {
          for (reverse @{$self->{open_elements}}) {
            if ($_->[1] == BODY_EL) {
              !!!cp ('t405');
              $i = $_;
              last INSCOPE;
            } elsif ($_->[1] & SCOPING_EL) {
              !!!cp ('t405.1');
              last;
            }
          }

          ## NOTE: |<marquee></body>|, |<svg><foreignobject></body>|,
          ## and fragment cases.

          !!!parse-error (type => 'unmatched end tag',
                          text => $self->{t}->{tag_name}, token => $self->{t});
          ## Ignore the token.  (</body> or </html>)
          !!!next-token;
          next B;
        } # INSCOPE

        ## 2. If unclosed elements:
        for (@{$self->{open_elements}}) {
          unless ($_->[1] & ALL_END_TAG_OPTIONAL_EL ||
                  $_->[1] == OPTGROUP_EL ||
                  $_->[1] == OPTION_EL ||
                  $_->[1] == RUBY_COMPONENT_EL) {
            !!!cp ('t403');
            !!!parse-error (type => 'not closed',
                            text => $_->[0]->manakai_local_name,
                            token => $self->{t});
            last;
          } else {
            !!!cp ('t404');
          }
        }

        ## 3. Switch the insertion mode.
        $self->{insertion_mode} = AFTER_BODY_IM;
        if ($self->{t}->{tag_name} eq 'body') {
          !!!next-token;
        } else { # html
          ## Reprocess.
        }
        next B;

      } elsif ({
        ## "In body" insertion mode, end tags for non-phrasing flow
        ## content elements.

                address => 1, article => 1, aside => 1, blockquote => 1,
                center => 1,
                #datagrid => 1,
                details => 1,
                dir => 1, div => 1, dl => 1, fieldset => 1, figure => 1,
                footer => 1, header => 1, hgroup => 1,
                listing => 1, menu => 1, nav => 1,
                ol => 1, pre => 1, section => 1, ul => 1,
                figcaption => 1, summary => 1,

                ## NOTE: As normal, but ... optional tags
                dd => 1, dt => 1, li => 1,

                applet => 1, button => 1, marquee => 1, object => 1,
               }->{$self->{t}->{tag_name}}) {
        ## XXXgeneraetetoken
        ## NOTE: Code for <li> start tags includes "as if </li>" code.
        ## Code for <dt> or <dd> start tags includes "as if </dt> or
        ## </dd>" code.

        ## has an element in scope
        my $i;
        INSCOPE: for (reverse 0..$#{$self->{open_elements}}) {
          my $node = $self->{open_elements}->[$_];
          if ($node->[0]->manakai_local_name eq $self->{t}->{tag_name}) {
            !!!cp ('t410');
            $i = $_;
            last INSCOPE;
          } elsif ($node->[1] & SCOPING_EL) {
            !!!cp ('t411');
            last INSCOPE;
          } elsif ($self->{t}->{tag_name} eq 'li' and
                   {ul => 1, ol => 1}->{$node->[0]->manakai_local_name}) {
            ## Has an element in list item scope
            !!!cp ('t411.4');
            last INSCOPE;
          }
        } # INSCOPE

        unless (defined $i) { # has an element in scope
          !!!cp ('t413');
          !!!parse-error (type => 'unmatched end tag',
                          text => $self->{t}->{tag_name}, token => $self->{t});
          ## NOTE: Ignore the token.
        } else {
          ## Step 1. generate implied end tags
          while ({
                  ## END_TAG_OPTIONAL_EL
                  dd => ($self->{t}->{tag_name} ne 'dd'),
                  dt => ($self->{t}->{tag_name} ne 'dt'),
                  li => ($self->{t}->{tag_name} ne 'li'),
                  option => 1,
                  optgroup => 1,
                  p => 1,
                  rt => 1,
                  rp => 1,
                 }->{$self->{open_elements}->[-1]->[0]->manakai_local_name}) {
            !!!cp ('t409');
            pop @{$self->{open_elements}};
          }

          ## Step 2.
          if ($self->{open_elements}->[-1]->[0]->manakai_local_name
                  ne $self->{t}->{tag_name}) {
            !!!cp ('t412');
            !!!parse-error (type => 'not closed',
                            text => $self->{open_elements}->[-1]->[0]
                                ->manakai_local_name,
                            token => $self->{t});
          } else {
            !!!cp ('t414');
          }

          ## Step 3.
          splice @{$self->{open_elements}}, $i;

          ## Step 4.
          $clear_up_to_marker->($active_formatting_elements)
              if {
                applet => 1, marquee => 1, object => 1,
              }->{$self->{t}->{tag_name}};
        }
        !!!next-token;
        next B;
      } elsif ($self->{t}->{tag_name} eq 'form') {
        ## NOTE: As normal, but interacts with the form element pointer

        undef $self->{form_element};

        ## has an element in scope
        my $i;
        INSCOPE: for (reverse 0..$#{$self->{open_elements}}) {
          my $node = $self->{open_elements}->[$_];
          if ($node->[1] == FORM_EL) {
            !!!cp ('t418');
            $i = $_;
            last INSCOPE;
          } elsif ($node->[1] & SCOPING_EL) {
            !!!cp ('t419');
            last INSCOPE;
          }
        } # INSCOPE

        unless (defined $i) { # has an element in scope
          !!!cp ('t421');
          !!!parse-error (type => 'unmatched end tag',
                          text => $self->{t}->{tag_name}, token => $self->{t});
          ## NOTE: Ignore the token.
        } else {
          ## Step 1. generate implied end tags
          while ($self->{open_elements}->[-1]->[1] & END_TAG_OPTIONAL_EL) {
            !!!cp ('t417');
            pop @{$self->{open_elements}};
          }
          
          ## Step 2. 
          if ($self->{open_elements}->[-1]->[0]->manakai_local_name
                  ne $self->{t}->{tag_name}) {
            !!!cp ('t417.1');
            !!!parse-error (type => 'not closed',
                            text => $self->{open_elements}->[-1]->[0]
                                ->manakai_local_name,
                            token => $self->{t});
          } else {
            !!!cp ('t420');
          }  
          
          ## Step 3.
          splice @{$self->{open_elements}}, $i;
        }

        !!!next-token;
        next B;
      } elsif ({
                ## NOTE: As normal, except acts as a closer for any ...
                h1 => 1, h2 => 1, h3 => 1, h4 => 1, h5 => 1, h6 => 1,
               }->{$self->{t}->{tag_name}}) {
        ## has an element in scope
        my $i;
        INSCOPE: for (reverse 0..$#{$self->{open_elements}}) {
          my $node = $self->{open_elements}->[$_];
          if ($node->[1] == HEADING_EL) {
            !!!cp ('t423');
            $i = $_;
            last INSCOPE;
          } elsif ($node->[1] & SCOPING_EL) {
            !!!cp ('t424');
            last INSCOPE;
          }
        } # INSCOPE

        unless (defined $i) { # has an element in scope
          !!!cp ('t425.1');
          !!!parse-error (type => 'unmatched end tag',
                          text => $self->{t}->{tag_name}, token => $self->{t});
          ## NOTE: Ignore the token.
        } else {
          ## Step 1. generate implied end tags
          while ($self->{open_elements}->[-1]->[1] & END_TAG_OPTIONAL_EL) {
            !!!cp ('t422');
            pop @{$self->{open_elements}};
          }
          
          ## Step 2.
          if ($self->{open_elements}->[-1]->[0]->manakai_local_name
                  ne $self->{t}->{tag_name}) {
            !!!cp ('t425');
            !!!parse-error (type => 'unmatched end tag',
                            text => $self->{t}->{tag_name}, token => $self->{t});
          } else {
            !!!cp ('t426');
          }

          ## Step 3.
          splice @{$self->{open_elements}}, $i;
        }
        
        !!!next-token;
        next B;

      } elsif ($self->{t}->{tag_name} eq 'p') {
        ## "In body" insertion mode, "p" start tag. As normal, except
        ## </p> implies <p> and ...

        ## "have an element in button scope".
        my $non_optional;
        my $i;
        INSCOPE: for (reverse 0..$#{$self->{open_elements}}) {
          my $node = $self->{open_elements}->[$_];
          if ($node->[1] == P_EL) {
            !!!cp ('t410.1');
            $i = $_;
            last INSCOPE;
          } elsif ($node->[1] & BUTTON_SCOPING_EL) {
            !!!cp ('t411.1');
            last INSCOPE;
          } elsif ($node->[1] & END_TAG_OPTIONAL_EL) {
            ## NOTE: |END_TAG_OPTIONAL_EL| includes "p"
            !!!cp ('t411.2');
            #
          } else {
            !!!cp ('t411.3');
            $non_optional ||= $node;
            #
          }
        } # INSCOPE

        if (defined $i) {
          ## 1. Generate implied end tags
          #

          ## 2. If current node != "p", parse error
          if ($non_optional) {
            !!!cp ('t412.1');
            !!!parse-error (type => 'not closed',
                            text => $non_optional->[0]->manakai_local_name,
                            token => $self->{t});
          } else {
            !!!cp ('t414.1');
          }

          ## 3. Pop
          splice @{$self->{open_elements}}, $i;
        } else {
          !!!cp ('t413.1');
          !!!parse-error (type => 'unmatched end tag',
                          text => $self->{t}->{tag_name}, token => $self->{t});

          !!!cp ('t415.1');
          ## As if <p>, then reprocess the current token
          my $el;
          !!!create-element ($el, HTML_NS, 'p',, $self->{t});
          $insert->($self, $el, $open_tables);
          ## NOTE: Not inserted into |$self->{open_elements}|.
        }

        !!!next-token;
        next B;
      } elsif ({
                a => 1,
                b => 1, big => 1, code => 1, em => 1, font => 1, i => 1,
                nobr => 1, s => 1, small => 1, strike => 1,
                strong => 1, tt => 1, u => 1,
               }->{$self->{t}->{tag_name}}) {
        !!!cp ('t427');
        $formatting_end_tag->($self, $active_formatting_elements,
                              $open_tables, $self->{t});
        next B;
      } elsif ($self->{t}->{tag_name} eq 'br') {
        !!!cp ('t428');
        !!!parse-error (type => 'unmatched end tag',
                        text => 'br', token => $self->{t});

        ## As if <br>
        my $insert = $self->{insertion_mode} & TABLE_IMS
            ? $insert_to_foster : $insert_to_current;
        $reconstruct_active_formatting_elements
            ->($self, $insert, $active_formatting_elements, $open_tables);
        
        my $el;
        !!!create-element ($el, HTML_NS, 'br',, $self->{t});
        $insert->($self, $el, $open_tables);
        
        ## Ignore the token.
        !!!next-token;
        next B;
      } else {
        if ($self->{t}->{tag_name} eq 'sarcasm') {
          sleep 0.001; # take a deep breath
        }

        ## Step 1
        my $node_i = -1;
        my $node = $self->{open_elements}->[$node_i];

        ## Step 2
        LOOP: {
          my $node_tag_name = $node->[0]->manakai_local_name;
          $node_tag_name =~ tr/A-Z/a-z/; # for SVG camelCase tag names
          if ($node_tag_name eq $self->{t}->{tag_name}) {
            ## Step 1
            ## generate implied end tags
            while ($self->{open_elements}->[-1]->[1] & END_TAG_OPTIONAL_EL and
                   $self->{open_elements}->[-1]->[0]->manakai_local_name
                       ne $self->{t}->{tag_name}) {
              !!!cp ('t430');
              ## NOTE: |<ruby><rt></ruby>|.
              pop @{$self->{open_elements}};
              $node_i++;
            }
        
            ## Step 2
            my $current_tag_name
                = $self->{open_elements}->[-1]->[0]->manakai_local_name;
            $current_tag_name =~ tr/A-Z/a-z/;
            if ($current_tag_name ne $self->{t}->{tag_name}) {
              !!!cp ('t431');
              ## NOTE: <x><y></x>
              !!!parse-error (type => 'not closed',
                              text => $self->{open_elements}->[-1]->[0]
                                  ->manakai_local_name,
                              token => $self->{t});
            } else {
              !!!cp ('t432');
            }
            
            ## Step 3
            splice @{$self->{open_elements}}, $node_i if $node_i < 0;

            !!!next-token;
            last LOOP;
          } else {
            ## Step 3
            if ($node->[1] & SPECIAL_EL or $node->[1] & SCOPING_EL) { ## "Special"
              !!!cp ('t433');
              !!!parse-error (type => 'unmatched end tag',
                              text => $self->{t}->{tag_name}, token => $self->{t});
              ## Ignore the token
              !!!next-token;
              last LOOP;

              ## NOTE: |<span><dd></span>a|: In Safari 3.1.2 and Opera
              ## 9.27, "a" is a child of <dd> (conforming).  In
              ## Firefox 3.0.2, "a" is a child of <body>.  In WinIE 7,
              ## "a" is a child of both <body> and <dd>.
            }
            
            !!!cp ('t434');
          }
          
          ## Step 4
          $node_i--;
          $node = $self->{open_elements}->[$node_i];
          
          ## Step 5;
          redo LOOP;
        } # LOOP
	next B;
      }
    }
    next B;
  } # B

  ## Stop parsing # MUST
  
  ## TODO: script stuffs
} # _tree_construct_main

## XXX: How this method is organized is somewhat out of date, although
## it still does what the current spec documents.
sub set_inner_html ($$$$) {
  #my ($self, $string, $onerror, $get_wrapper) = @_;
  my ($class, $self);
  if (ref $_[0]) {
    $self = shift;
    $class = ref $self;
  } else {
    $class = shift;
    $self = $class->new;
  }
  my $node = shift; # /context/
  #my $s = \$_[0];
  my $onerror = $_[1];
  my $get_wrapper = $_[2] || sub ($) { return $_[0] };

  my $nt = $node->node_type;
  if ($nt == 9) { # Document (invoke the algorithm with no /context/ element)
    # MUST
    
    ## Step 1 # MUST
    ## TODO: If the document has an active parser, ...
    ## ISSUE: There is an issue in the spec.
    
    ## Step 2 # MUST
    my @cn = @{$node->child_nodes};
    for (@cn) {
      $node->remove_child ($_);
    }

    ## Step 3, 4, 5 # MUST
    $self->parse_char_string ($_[0] => $node, $onerror, $get_wrapper);
  } elsif ($nt == 1) { # Element (invoke the algorithm with /context/ element)
    ## TODO: If non-html element

    ## NOTE: Most of this code is copied from |parse_string|

## TODO: Support for $get_wrapper

    ## F1. Create an HTML document.
    my $this_doc = $node->owner_document;
    my $doc = $this_doc->implementation->create_document;
    $doc->manakai_is_html (1);

    ## F2. Propagate quirkness flag
    my $node_doc = $node->owner_document;
    $doc->manakai_compat_mode ($node_doc->manakai_compat_mode);

    ## F3. Create an HTML parser
    my $p = $self;
    $p->{document} = $doc;

    ## Step 8 # MUST
    my $i = 0;
    $p->{line_prev} = $p->{line} = 1;
    $p->{column_prev} = -1;
    $p->{column} = 0;

    $self->{chars} = [split //, $_[0]];
    $self->{chars_pos} = 0;
    $self->{chars_pull_next} = sub { 0 };
    delete $self->{chars_was_cr};

    my $ponerror = $onerror || $self->onerror;
    $p->{parse_error} = sub {
      $ponerror->(line => $p->{line}, column => $p->{column}, @_);
    };

    $p->_initialize_tokenizer;
    $p->_initialize_tree_constructor;

    ## F4. If /context/ is not undef...

    ## F4.1. content model flag
    my $node_ns = $node->namespace_uri || '';
    my $node_ln = $node->manakai_local_name;
    if ($node_ns eq HTML_NS) {
      if ($node_ln eq 'title' or $node_ln eq 'textarea') {
        $p->{state} = RCDATA_STATE;
      } elsif ($node_ln eq 'script') {
        $p->{state} = SCRIPT_DATA_STATE;
      } elsif ({
        style => 1,
        script => 1,
        xmp => 1,
        iframe => 1,
        noembed => 1,
        noframes => 1,
        noscript => 1,
      }->{$node_ln}) {
        $p->{state} = RAWTEXT_STATE;
      } elsif ($node_ln eq 'plaintext') {
        $p->{state} = PLAINTEXT_STATE;
      }
      
      $p->{inner_html_node} = [$node, $el_category->{$node_ln}];
    } elsif ($node_ns eq SVG_NS) {
      $p->{inner_html_node} = [$node,
                               $el_category_f->{$node_ns}->{$node_ln}
                                   || FOREIGN_EL | SVG_EL];
    } elsif ($node_ns eq MML_NS) {
      $p->{inner_html_node} = [$node,
                               $el_category_f->{$node_ns}->{$node_ln}
                                   || FOREIGN_EL | MML_EL];
    } else {
      $p->{inner_html_node} = [$node, FOREIGN_EL];
    }

    ## F4.2. Root |html| element
    my $root = $doc->create_element_ns
      ('http://www.w3.org/1999/xhtml', [undef, 'html']);

    ## F4.3.
    $doc->append_child ($root);

    ## F4.4.
    push @{$p->{open_elements}}, [$root, $el_category->{html}];
    $p->{open_tables} = [[$root]];

    undef $p->{head_element};

    ## F4.5.
    $p->_reset_insertion_mode;

    ## F4.6.
    my $anode = $node;
    AN: while (defined $anode) {
      if ($anode->node_type == 1) {
        my $nsuri = $anode->namespace_uri;
        if (defined $nsuri and $nsuri eq HTML_NS) {
          if ($anode->manakai_local_name eq 'form') {
            !!!cp ('i5');
            $p->{form_element} = $anode;
            last AN;
          }
        }
      }
      $anode = $anode->parent_node;
    } # AN

    ## F.5. Set the input stream.
    $p->{confident} = 1; ## Confident: irrelevant.

    ## F.6. Start the parser.
    $p->{t} = $p->_get_next_token;
    $p->_construct_tree;

    ## F.7.
    my @cn = @{$node->child_nodes};
    for (@cn) {
      $node->remove_child ($_);
    }
    ## ISSUE: mutation events? read-only?

    ## Step 11 # MUST
    @cn = @{$root->child_nodes};
    for (@cn) {
      $this_doc->adopt_node ($_);
      $node->append_child ($_);
    }
    ## ISSUE: mutation events?

    $p->_terminate_tree_constructor;
    $p->_clear_refs;
  } else {
    die "$0: |set_inner_html| is not defined for node of type $nt";
  }
} # set_inner_html

1;

=head1 LICENSE

Copyright 2007-2012 Wakaba <w@suika.fam.cx>.

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.

=cut
