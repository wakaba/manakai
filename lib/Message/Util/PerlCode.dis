Module:
  @QName:
    Util:PerlCode
  @FullName:
    @@lang: en
    @@@:
      Perl Code Constructor
  @Namespace:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/PerlCode#
  
  @Description:
    @@lang:en
    @@@:
      This module provides an object-oriented interface to construct 
      Perl code. 

  @DISCore:author: DISCore|Wakaba
  @License:
    @@@:
      license:Perl+MPL
    @@Original:
      @@@FullName:
        manakai <CODE::lib/manakai/genlib.pl>
      @@@Year:2004
      @@@DISCore:author: DISCore|Wakaba
  @Date:
    @@@:
      $Date: 2005/10/12 00:31:06 $
    @@ContentType:
      dis:Date.RCS
  
  @Require:
    @@Module:
      @@@QName: MDOM|DOMCore
      @@@WithFor: ManakaiDOM|ManakaiDOMLatest

  @DefaultFor: ManakaiDOM|ManakaiDOMLatest

Namespace:
  @DIS:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS#
  @dis:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#dis--
  @dis2pm:
    http://suika.fam.cx/~wakaba/archive/2004/11/8/dis2pm#
  @DISlib:
    http://suika.fam.cx/~wakaba/archive/2004/dis/
  @DOMCore:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#
  @DOMLS:
    http://suika.fam.cx/~wakaba/archive/2004/dom/ls#
  @DOMMain:
    http://suika.fam.cx/~wakaba/archive/2004/dom/main#
  @DOMMetaImpl:
    http://suika.fam.cx/~wakaba/archive/2004/dom/meta#
  @dx:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#
  @ecore:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/Core/
  @f:
    http://suika.fam.cx/~wakaba/archive/2004/dom/feature#
  @idl:
    http://suika.fam.cx/~wakaba/archive/2004/dis/IDL#
  @infoset:
    http://www.w3.org/2001/04/infoset#
  @kwd:
    http://suika.fam.cx/~wakaba/archive/2005/rfc2119/
  @lang:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#
  @license:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/license#
  @ManakaiDOM:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#
  @Markup:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Markup#
  @MDOM:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#ManakaiDOM.
  @MDOMX:
    http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#
  @mn:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/ManakaiNode#
  @owl:
    http://www.w3.org/2002/07/owl#
  @pc:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/PerlCode#
  @Perl:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#Perl--
  @rdf:
    http://www.w3.org/1999/02/22-rdf-syntax-ns#
  @rdfs:
    http://www.w3.org/2000/01/rdf-schema#
  @s:
    http://suika.fam.cx/~wakaba/archive/2004/dis/Markup#
  @swcfg21:
    http://suika.fam.cx/~wakaba/archive/2005/swcfg21#
  @TreeCore:\
  @Util:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/

## -- Module sets

ResourceDef:
  @QName: Util|
  @For: ManakaiDOM|DOM
  @rdf:type: dis|ModuleGroup
  @FullName:
    @@lang:en
    @@@:
      Manakai support modules
  @DISPerl:packageName:
    Message::Util::
  @DISPerl:interfacePackageName:
    @@@:
      Message::Util::IF::
    @@For: ManakaiDOM|ManakaiDOM !ManakaiDOM|ManakaiDOMLatest
  @DISPerl:interfacePackageName:
    @@@:
      Message::Util::IFLatest::
    @@For: ManakaiDOM|ManakaiDOMLatest
  @ImplNote:
    @@lang:en
    @@@:
      Resources <Q::Util|> for <Q::ManakaiDOM|all> and for <Q::ManakaiDOM|Perl>
      is defined in module <Module::Util|ManakaiNode>.

## -- Features

ElementTypeBinding:
  @Name: FeatureDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DOMFeature|Feature
    @@For: =ManakaiDOM|all

ElementTypeBinding:
  @Name: FeatureVerDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DOMFeature|Feature

ElementTypeBinding:
  @Name: featureQName
  @ElementType:
    DOMFeature:name
  @ShadowContent:
    @@ContentType: DISCore|QName

FeatureDef:
  @QName: CoreFeature
  @featureQName:
    Util:PerlCode
  @FeatureVerDef:
    @@QName: CoreFeature10
    @@Version: 1.0
    @@ISA: CoreFeature
    @@FullName:
      @@@lang:en
      @@@@:
        Perl Code Constructor, version 1.0
    @@Description:
      @@@lang:en
      @@@@:
        Perl Code Constructor, version 1.0.

ElementTypeBinding:
  @Name: IFClsDef
  @ElementType: 
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      @@@@: dis|MultipleResource
      @@@ForCheck: !ManakaiDOM|ForIF !ManakaiDOM|ForClass
    @@resourceFor: ManakaiDOM|ForIF
    @@resourceFor: pc|ForClassCompat
    @@resourceFor: pc|ForClass
    @@For: ManakaiDOM|Perl

    @@rdf:type:
      @@@@: DISLang|Interface
      @@@ForCheck: ManakaiDOM|ForIF

    @@rdf:type:
      @@@@: DISLang|Class
      @@@ForCheck: ManakaiDOM|ForClass
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOM||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOMLatest||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOMLatest

    @@f:implements: pc|CoreFeature10

ForDef:
  @QName: pc|ForClassCompat
  @ISA: ManakaiDOM|ForClass

ForDef:
  @QName: pc|ForClass
  @ISA: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: IFClsETDef
  @ElementType: 
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      @@@@: dis|MultipleResource
      @@@ForCheck: !ManakaiDOM|ForIF !ManakaiDOM|ForClass !s|ForML
    @@resourceFor: ManakaiDOM|ForIF
    @@resourceFor: pc|ForClassCompat
    @@resourceFor: pc|ForClass
    @@resourceFor: s|ForML
    @@For: ManakaiDOM|Perl

    @@rdf:type:
      @@@@: DISLang|Interface
      @@@ForCheck: ManakaiDOM|ForIF
    @@s:elementType:
      @@@@: ||+||s|ForML
      @@@ForCheck: ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames

    @@rdf:type:
      @@@@: DISLang|Class
      @@@ForCheck: ManakaiDOM|ForClass
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOM||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOMLatest||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOMLatest
    @@s:elementType:
      @@@@: ||+||s|ForML
      @@@ForCheck: pc|ForClass
      @@@ContentType: DISCore|TFPQNames
      @@@DISCore:stopISARecursive:1

    @@rdf:type:
      @@@@: s|ElementType
      @@@ForCheck: s|ForML

    @@f:implements: pc|CoreFeature10

ElementTypeBinding:
  @Name: ClsDef
  @ElementType: 
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      @@@@: dis|MultipleResource
      @@@ForCheck: !ManakaiDOM|ForIF !ManakaiDOM|ForClass

    @@resourceFor: ManakaiDOM|ForClass
    @@For: ManakaiDOM|Perl

    @@rdf:type:
      @@@@: ManakaiDOM|Class
      @@@ForCheck: ManakaiDOM|ForClass

    @@DOMMain:implementFeature: CoreFeature10

ElementTypeBinding:
  @Name: caType
  @ElementType:
    dis:actualType
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: IFQName
  @ElementType:
    dis:QName
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForIF

ElementTypeBinding:
  @Name: ClsQName
  @ElementType:
    dis:QName
  @ShadowContent:
    @@ForCheck: pc|ForClassCompat

ElementTypeBinding:
  @Name: CQName
  @ElementType:
    dis:QName
  @ShadowContent:
    @@ForCheck: pc|ForClass

ElementTypeBinding:
  @Name: IFISA
  @ElementType:
    dis:ISA
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForIF

ElementTypeBinding:
  @Name: ClsISA
  @ElementType:
    dis:ISA
  @ShadowContent:
    @@ForCheck: pc|ForClassCompat

ElementTypeBinding:
  @Name: CISA
  @ElementType:
    dis:ISA
  @ShadowContent:
    @@ForCheck: pc|ForClass

## -- Classes

IFClsDef:
  @IFQName: PerlCode
  @ClsQName: ManakaiPerlCodeFragment
  @CQName: ManakaiPCCode

  @ClsISA:
    ManakaiDOM:ManakaiDOMNodeReference::ManakaiDOM:Perl
  @CISA: DOMCore|ManakaiDOMElement
  @ClsISA:
    dx:ManakaiDefaultExceptionHandler::ManakaiDOM:Perl

  @enDesc:
    A class on which another Perl code classes are constructed based. 

  @Attr:
    @@ForCheck: !pc|ForClass
    @@Name: parentNode
    @@enDesc:
      The parent construction of this object. 
    @@Get:
      @@@Type: PerlCode
      @@@caType: ManakaiPerlCodeFragment
      @@@nullCase:
        @@@@enDesc:
          This object has no parent. 
      @@@PerlDef:
        $r = $self->{<H::mn:node>}->{<H::pc:parent>};
        $r = <ClassM::ManakaiPerlCodeFragment.getNodeReference> ($r) if $r;

  @Attr:
    @@Name: fileNode
    @@enDesc:
      The root <QUOTE::file> node of the tree to which this node belongs.
    @@Type: PerlCode
    @@Get:
      @@@enDesc:
        The <QUOTE::file> node of the tree.
      @@@nullCase:
        @@@@enDesc:
          This node does not belong to any file tree.
      @@@PerlDef:
        @@@@ForCheck: !pc|ForClass
        @@@@@:
        $r = $self->{<H::mn:node>}->{<H::pc:parent>};
        {
          if ($r->{<H::pc:parent>}) {
            $r = $r->{<H::pc:parent>};
            redo;
          }
        };
        if ($r) {
          if ($r->{<H::pc:nodeType>} eq 'file') {
            __DEEP{
              $r = <ClassM::ManakaiPerlCodeFragment.getNodeReference> ($r);
            }__;
          } else {
            $r = null;
          }
        } elsif ($self->{<H::mn:node>}->{<H::pc:nodeType>} eq 'file') {
          $r = $self;
        }
      @@@PerlDef:
        @@@@ForCheck: pc|ForClass
        @@@@@:
          __DEEP{
            $r = $self-><AG::Node.ownerDocument>
                      -><AG::Document.documentElement>;
            if ($r) {
              unless (defined $r-><AG::Node.namespaceURI> and
                      $r-><AG::Node.namespaceURI> eq <Q::pc:> and
                      $r-><AG::Node.localName> eq 'file') {
                $r = null;
              }
            }
          }__;

  @IntMethod:
    @@ForCheck: !pc|ForClass
    @@Name: getNodeReference
    @@ManakaiDOM:isStatic:1
    @@enDesc:
      Gets a node reference for a node object. 
    @@Param:
      @@@Name: object
      @@@Type:
        ManakaiDOM:ManakaiDOMNodeReference::ManakaiDOM:Perl
      @@@enDesc:
        A node object. 
    @@Return:
      @@@Type:
        ManakaiDOM:ManakaiDOMNodeReference::ManakaiDOM:Perl
      @@@PerlDef:
        my $nt = $object->{<H::pc:nodeType>};
        my $pack;
        __CODE{pc:nodeTypeToPackageName::
                 $nodeType => $nt, $packageName => $pack, $object => $object}__;
        __CODE{ManakaiNode:getNewReference||ManakaiDOM|Perl::
                 $object => $object, $ref => $r, $class => $pack}__;

  @Method:
    @@Name: replaceVariable
    @@enDesc:
      Replaces a variable. 
      \
      {NOTE:: For objects of type <Class::ManakaiPerlFile>, 
              <Class::ManakaiPerlPackageScope>,
              <Class::ManakaiPerlSub> and
              <Class::ManakaiPerlVariable>, the result is undefined.
      \
      }
    @@Param:
      @@@Name: originalVariable
      @@@Type:
        lang:Perl::ManakaiDOM:all
      @@@enDesc:
        Original variable specification, including prefix. 
        \
        {NOTE:: Qualified name variable and hash key is not supported.
        \
        }
    @@Param:
      @@@Name: newValue
      @@@Type: 
        DOMMain:any::ManakaiDOM:all
      @@@enDesc:
        New value to replace.
      @@@InCase:
        @@@@Type: PerlCode
        @@@@caType: ManakaiPerlCodeFragment
        @@@@enDesc:
          New Perl code fragment to replace by.
      @@@InCase:
        @@@@Type:
          lang:Perl::ManakaiDOM:all
        @@@@enDesc:
          Inline Perl code fragment string to replace by.
    @@Return:
      @@@PerlDef:
        @@@@ForCheck: !pc|ForClass
        @@@@@:
        my $node = $self->{<H::mn:node>};
        if ($node->{<H::pc:nodeType>} eq 'unparsed' or
            $node->{<H::pc:nodeType>} eq 'inunparsed') {
          my $newVariable = ref $newValue ? $newValue->stringify : ''.$newValue;
          $node->{<H::pc:code>} =~ s/\Q$originalVariable\E\b/$newVariable/g;
        } elsif ($node->{<H::pc:childNodes>}) {
          __DEEP{
            for my $cnoi (0..$#{$node->{<H::pc:childNodes>}}) {
              my $cno = $node->{<H::pc:childNodes>}->[$cnoi];
              if ($cno->{<H::pc:nodeType>} eq 'variable') {
                if (substr ($originalVariable, 0, 1)
                                  eq $cno->{<H::pc:variableType>} and
                    not $cno->{<H::pc:packageName>} and
                    substr ($originalVariable, 1)
                                  eq $cno->{<H::pc:localName>} and
                    not $cno->{<H::pc:hashKey>}) {
                  if (ref $newValue) {
                    CORE::delete $cno->{<H::pc:parent>};
                    $cno-><M::ManakaiDOM:ManakaiDOMNodeObject
                            ::ManakaiDOM:Perl.orphanate>;
                    my $newnode = $newValue->{<H::mn:node>};
                    $node-><M::ManakaiDOM:ManakaiDOMNodeObject
                                ::ManakaiDOM:Perl.importTree> ($newnode);
                    $newnode->{<H::pc:parent>} = $node;
                    $node->{<H::pc:childNodes>}->[$cnoi] = $newnode;
                  } else {
                    my $cn;
                    __CODE{ManakaiNode:getWeakReference||ManakaiDOM|Perl::
                      $object => $cno, $ref => $cn,
                      $class => {<ClassName::ManakaiPerlCodeFragment>},
                    }__;
                    $cn-><M::ManakaiPerlInlineContainer.appendCode>
                              ($newValue);
                  }
                }
              } else { ## Non-variable child
                my $cn;
                __CODE{ManakaiNode:getWeakReference||ManakaiDOM|Perl::
                  $object => $cno, $ref => $cn,
                  $class => {<ClassName::ManakaiPerlCodeFragment>},
                }__;
                $cn-><M::ManakaiPerlCodeFragment.replaceVariable>
                                       ($originalVariable => $newValue);
              }
            }
          }__;
        }
      @@@PerlDef:
        @@@@ForCheck: pc|ForClass
        @@@@@:
          my $ln = $self-><AG::Node.localName>;
          if ($ln eq 'unparsed' or
              $ln eq 'inlineUnparsed') {
            my $new_var = ref $newValue ? $newValue->stringify : ''.$newValue;
            my $val = $self-><AG::Node.textContent>;
            $val =~ s/\Q$originalVariable\E\b/$new_var/g;
            $self-><AS::Node.textContent> ($val);
          } elsif ($ln eq 'stringLiteral' or $ln eq 'atom' or
                   $ln eq 'tokens') {
            # 
          } elsif ($self-><M::Node.hasChildNodes>) {
            __DEEP{
              my @child_nodes = @{$self-><AG::Node.childNodes>};
              for my $child_node (@child_nodes) {
                if (defined $child_node-><AG::Node.namespaceURI> and
                    $child_node-><AG::Node.namespaceURI> eq <Q::pc:>) {
                  if ($child_node-><AG::Node.localName> eq 'variable') {
                    if (substr ($originalVariable, 0, 1) eq
                          $child_node-><AG::PerlVariable.variableType> and
                        not defined $child_node-><AG::PerlVariable.packageName> and
                        substr ($originalVariable, 1) eq
                          $child_node-><AG::PerlVariable.pcLocalName> and
                        not defined $child_node-><AG::PerlVariable.hashKey>) {
                      if (ref $newValue) {
                        $self-><M::Node.replaceChild> ($child_node => $newValue);
                      } else {  ## ISSUE: Is this correct?
                        $child_node-><M::PerlCodeInlines.appendCode> ($newValue);
                      }
                    }
                  } else {  ## Non-variable child
                    $child_node-><M::PerlCode.replaceVariable>
                                              ($originalVariable => $newValue);
                  }
                } else {
                  # 
                }
              }
            }__;
          } # has child

  @ResourceDef:
    @@ForCheck: pc|ForClass
    @@QName: addNameListAttr
    @@rdf:type: DISPerl|BlockCode
    @@PerlDef:
      my %__mn = map {$_ => true}
                 split /\s+/, $node-><M::Element.getAttributeNS>
                                             (<Q::pc:>, $attrName);
      $__mn{$newName} = true;
      $node-><M::Element.setAttributeNS>
                      (<Q::pc:>, 'pc:'.$attrName => join ' ', keys %__mn);


  @Method:
    @@Name: addUsePerlModuleName
    @@enDesc:
      Adds a Perl module into the list of Perl modules 
      <Perl::use>d by this code fragment.
    @@Param:
      @@@Name: moduleName
      @@@Type: DOMString
      @@@enDesc:
        The name of the module package that should be <Perl::use>d.
    @@Return:
      @@@PerlDef:
        @@@@ForCheck: !pc|ForClass
        @@@@@:
        $self->{<H::mn:node>}->{<H::pc:useModuleName>}
             ->{$moduleName} = true;
      @@@PerlDef:
        @@@@ForCheck: pc|ForClass
        @@@@@:
          __DEEP{
            __CODE{addNameListAttr::
              $node => {$self},
              $attrName => 'useModuleName',
              $newName => {$moduleName},
            }__;
          }__;

  @Method:
    @@Name: addUseCharClassName
    @@enDesc:
      Adds a Perl module into the list of Perl character classes 
      <Perl::use>d by this code fragment.
    @@Param:
      @@@Name: moduleName
      @@@Type: DOMString
      @@@enDesc:
        The name of the module package that should be <Perl::use>d.
    @@Param:
      @@@Name: charClassName
      @@@Type: DOMString
      @@@enDesc:
        The name of the character class.
    @@Return:
      @@@PerlDef:
        @@@@ForCheck: !pc|ForClass
        @@@@@:
        $self->{<H::mn:node>}->{<H::pc:useCharClassName>}
             ->{$moduleName}->{$charClassName} = true;
      @@@PerlDef:
        @@@@ForCheck: pc|ForClass
        @@@@@:
          __DEEP{
            __CODE{addNameListAttr::
              $node => {$self},
              $attrName => 'useCharClassName',
              $newName => {$moduleName.'.'.$charClassName},
            }__;
          }__;

  @Method:
    @@Name: addRequirePerlModuleName
    @@enDesc:
      Adds a Perl module into the list of Perl modules 
      <Perl::require>d by this code fragment.
    @@Param:
      @@@Name: moduleName
      @@@Type: DOMString
      @@@enDesc:
        The name of the module package that should be <Perl::require>d.
    @@Return:
      @@@PerlDef:
        @@@@ForCheck: !pc|ForClass
        @@@@@:
        $self->{<H::mn:node>}->{<H::pc:requireModuleName>}
             ->{$moduleName} = true;
      @@@PerlDef:
        @@@@ForCheck: pc|ForClass
        @@@@@:
          __DEEP{
            __CODE{addNameListAttr::
              $node => {$self},
              $attrName => 'requireModuleName',
              $newName => {$moduleName},
            }__;
          }__;

  @Method:
    @@Name: addExceptionInterfacePackageName
    @@enDesc:
      Adds a Perl exception interface into the list of Perl packages.
    @@Param:
      @@@Name: moduleName
      @@@Type: DOMString
      @@@enDesc:
        The name of the interface package.
    @@Return:
      @@@PerlDef:
        @@@@ForCheck: !pc|ForClass
        @@@@@:
        $self->{<H::mn:node>}->{<H::pc:exceptionInterfaceName>}
             ->{$moduleName} = true;
      @@@PerlDef:
        @@@@ForCheck: pc|ForClass
        @@@@@:
          __DEEP{
            __CODE{addNameListAttr::
              $node => {$self},
              $attrName => 'exceptionInterfaceName',
              $newName => {$moduleName},
            }__;
          }__;

  @ResourceDef:
    @@ForCheck: pc|ForClass
    @@QName: getNameListAttrR
    @@rdf:type: DISPerl|BlockCode
    @@PerlDef:
      my @__nodes = ($node);
      my %__result;
      while (@__nodes) {
        my $__cnode = shift @__nodes;
        if ($__cnode-><AG::Node.nodeType> == <C::Node.ELEMENT_NODE> and
            defined $__cnode-><AG::Node.namespaceURI> and
            $__cnode-><AG::Node.namespaceURI> eq <Q::pc:>) {
          for (split /\s+/, $__cnode-><M::Element.getAttributeNS>
                               (<Q::pc:>, $attrName)) {
            $__result{$_} = true;
          }
          push @__nodes, @{$__cnode-><AG::Node.childNodes>};
        }
      }
      $result = [sort {$a cmp $b} keys %__result];
  @ResourceDef:
    @@ForCheck: pc|ForClass
    @@QName: getNameListAttr
    @@rdf:type: DISPerl|BlockCode
    @@PerlDef:
       my %__result;
      for (split /\s+/,
                 $node-><M::Element.getAttributeNS> (<Q::pc:>, $attrName)) {
        $__result{$_} = true;
      }
      $result = [sort {$a cmp $b} keys %__result];

  @Method:
    @@Name: getUsePerlModuleNameList
    @@enDesc:
      Returns a list of Perl modules names that is <Perl::use>d
      by this code fragment, including all descendant nodes. 
    @@Return:
      @@@Type: DISPerl|ARRAY||ManakaiDOM|all
      @@@enDesc:
        A list of module names.  Note that the list is <EM::dead>; 
        any modification to it does not affect to the code fragment
        and vice versa.
      @@@PerlDef:
        @@@@ForCheck: !pc|ForClass
        @@@@@:
        my $list = {};
        my @node = ($self->{<H::mn:node>});
        while (my $node = shift @node) {
          next unless ref $node;
          for my $mname (keys %{$node->{<H::pc:useModuleName>} || {}}) {
            $list->{$mname} ||= $node->{<H::pc:useModuleName>}->{$mname};
          }
          push @node, $node->{$_} for @{$node->{<Q::TreeCore:subnode0>}};
          my @n;
          for my $nn (map {$node->{$_}} @{$node->{<Q::TreeCore:subnode2>}}) {
            push @n, (ref $nn eq 'ARRAY' ? @$nn : values %{$nn || {}});
          }
          for my $n ((map {$node->{$_}} @{$node->{<Q::TreeCore:subnode>}}), @n) {
            push @node, (ref $n eq 'ARRAY' ? @$n : values %{$n || {}});
          }
        }
        $r = [grep {$list->{$_}} keys %$list];
      @@@PerlDef:
        @@@@ForCheck: pc|ForClass
        @@@@@:
          __DEEP{
            __CODE{getNameListAttrR::
              $node => {$self},
              $attrName => 'useModuleName',
              $result => {$r},
            }__;
          }__;

  @Method:
    @@Name: getUseCharClassNameList
    @@enDesc:
      Returns a list of Perl character class names that is <Perl::use>d
      by this code fragment, including all descendant nodes. 
    @@Return:
      @@@Type: DISPerl|HASH||ManakaiDOM|all
      @@@enDesc:
        A list of module names.  Note that the list is <EM::dead>; 
        any modification to it does not affect to the code fragment
        and vice versa.
      @@@PerlDef:
        @@@@ForCheck: !pc|ForClass
        @@@@@:
        my @node = ($self->{<H::mn:node>});
        while (my $node = shift @node) {
          next unless ref $node;
          for my $mname (keys %{$node->{<H::pc:useCharClassName>} || {}}) {
            for my $cname (keys %{$node->{<H::pc:useCharClassName>}
                                       ->{$mname}}) {
              $r->{$mname}->{$cname}
                  ||= $node->{<H::pc:useCharClassName>}->{$mname}->{$cname};
            }
          }
          push @node, $node->{$_} for @{$node->{<Q::TreeCore:subnode0>}};
          my @n;
          for my $nn (map {$node->{$_}} @{$node->{<Q::TreeCore:subnode2>}}) {
            push @n, (ref $nn eq 'ARRAY' ? @$nn : values %{$nn || {}});
          }
          for my $n ((map {$node->{$_}} @{$node->{<Q::TreeCore:subnode>}}), @n) {
            push @node, (ref $n eq 'ARRAY' ? @$n : values %{$n || {}});
          }
        }
      @@@PerlDef:
        @@@@ForCheck: pc|ForClass
        @@@@@:
          my $mc;
          __DEEP{
            __CODE{getNameListAttrR::
              $node => {$self},
              $attrName => 'useCharClassName',
              $result => {$mc},
            }__;
          }__;
          for (@$mc) {
            my ($m, $c) = split /\./, $_, 2;
            $r->{$m}->{$c} = true;
          }

  @Method:
    @@Name: getRequirePerlModuleNameList
    @@enDesc:
      Returns a list of Perl modules names that is <Perl::require>d
      by this code fragment, including all descendant nodes. 
    @@Return:
      @@@Type: DISPerl|ARRAY||ManakaiDOM|all
      @@@enDesc:
        A list of module names.  Note that the list is <EM::dead>; 
        any modification to it does not affect to the code fragment
        and vice versa.
      @@@PerlDef:
        @@@@ForCheck: !pc|ForClass
        @@@@@:
        my $list = {};
        my @node = ($self->{<H::mn:node>});
        while (my $node = shift @node) {
          next unless ref $node;
          for my $mname (keys %{$node->{<H::pc:requireModuleName>} || {}}) {
            $list->{$mname} ||= $node->{<H::pc:requireModuleName>}->{$mname};
          }
          push @node, $node->{$_} for @{$node->{<Q::TreeCore:subnode0>}};
          my @n;
          for my $nn (map {$node->{$_}} @{$node->{<Q::TreeCore:subnode2>}}) {
            push @n, (ref $nn eq 'ARRAY' ? @$nn : values %{$nn || {}});
          }
          for my $n ((map {$node->{$_}} @{$node->{<Q::TreeCore:subnode>}}), @n) {
            push @node, (ref $n eq 'ARRAY' ? @$n : values %{$n || {}});
          }
        }
        $r = [grep {$list->{$_}} keys %$list];
      @@@PerlDef:
        @@@@ForCheck: pc|ForClass
        @@@@@:
          __DEEP{
            __CODE{getNameListAttrR::
              $node => {$self},
              $attrName => 'requireModuleName',
              $result => {$r},
            }__;
          }__;

  @Method:
    @@Name: getExceptionInterfacePackageNameList
    @@enDesc:
      Returns a list of Perl exception interface package names 
      by this code fragment, including all descendant nodes. 
    @@Return:
      @@@Type: DISPerl|ARRAY||ManakaiDOM|all
      @@@enDesc:
        A list of package names.  Note that the list is <EM::dead>; 
        any modification to it does not affect to the code fragment
        and vice versa.
      @@@PerlDef:
        @@@@ForCheck: !pc|ForClass
        @@@@@:
        my $list = {};
        my @node = ($self->{<H::mn:node>});
        while (my $node = shift @node) {
          next unless ref $node;
          for my $mname (keys %{$node->{<H::pc:exceptionInterfaceName>} || {}}) {
            $list->{$mname} ||= $node->{<H::pc:exceptionInterfaceName>}->{$mname};
          }
          push @node, $node->{$_} for @{$node->{<Q::TreeCore:subnode0>}};
          my @n;
          for my $nn (map {$node->{$_}} @{$node->{<Q::TreeCore:subnode2>}}) {
            push @n, (ref $nn eq 'ARRAY' ? @$nn : values %{$nn || {}});
          }
          for my $n ((map {$node->{$_}} @{$node->{<Q::TreeCore:subnode>}}), @n) {
            push @node, (ref $n eq 'ARRAY' ? @$n : values %{$n || {}});
          }
        }
        $r = [grep {$list->{$_}} keys %$list];
      @@@PerlDef:
        @@@@ForCheck: pc|ForClass
        @@@@@:
          __DEEP{
            __CODE{getNameListAttrR::
              $node => {$self},
              $attrName => 'exceptionInterfaceName',
              $result => {$r},
            }__;
          }__;

  @Method:
    @@Name: disAddRequireURI
    @@enDesc:
      Adds a <QUOTE::dis> resource into the list of <Perl::require>d
      resources of this code fragment.
    @@Param:
      @@@Name: uriArg
      @@@Type: DOMString
      @@@enDesc:
        The URI reference of the resource to add.
    @@Return:
      @@@PerlDef:
        @@@@ForCheck: !pc|ForClass
        @@@@@:
        $self->{<H::mn:node>}->{<H::pc:requireResourceURI>}
             ->{$uriArg} = true;
      @@@PerlDef:
        @@@@ForCheck: pc|ForClass
        @@@@@:
          __DEEP{
            __CODE{addNameListAttr::
              $node => {$self},
              $attrName => 'requireResourceURI',
              $newName => {$uriArg},
            }__;
          }__;

  @Method:
    @@Name: disGetRequireURIList
    @@enDesc:
      Returns a list of <QUOTE::dis> resource URI references that is
      <Perl::require>d by this code fragment, including all descendant nodes. 
    @@Return:
      @@@Type: DISPerl|ARRAY||ManakaiDOM|all
      @@@enDesc:
        A list of resource URI references.  Note that the list is <EM::dead>; 
        any modification to it does not affect to the code fragment
        and vice versa.
      @@@PerlDef:
        @@@@ForCheck: !pc|ForClass
        @@@@@:
        my $list = {};
        my @node = ($self->{<H::mn:node>});
        while (my $node = shift @node) {
          next unless ref $node;
          for my $mname (keys %{$node->{<H::pc:requireResourceURI>} || {}}) {
            $list->{$mname} ||= $node->{<H::pc:requireResourceURI>}->{$mname};
          }
          push @node, $node->{$_} for @{$node->{<Q::TreeCore:subnode0>}};
          my @n;
          for my $nn (map {$node->{$_}} @{$node->{<Q::TreeCore:subnode2>}}) {
            push @n, (ref $nn eq 'ARRAY' ? @$nn : values %{$nn || {}});
          }
          for my $n ((map {$node->{$_}} @{$node->{<Q::TreeCore:subnode>}}), @n) {
            push @node, (ref $n eq 'ARRAY' ? @$n : values %{$n || {}});
          }
        }
        $r = [grep {$list->{$_}} keys %$list];
      @@@PerlDef:
        @@@@ForCheck: pc|ForClass
        @@@@@:
          __DEEP{
            __CODE{getNameListAttrR::
              $node => {$self},
              $attrName => 'requireResourceURI',
              $result => {$r},
            }__;
          }__;

  @Method:
    @@ForCheck: pc|ForClass
    @@Operator: DISPerl|CloneMethod
    @@Return:
      @@@Type: PerlCode
      @@@PerlDef:
        __DEEP{
          $r = $self-><M::Node.cloneNode> (true);
        }__;
##PerlCode

PropDef:
  @QName: useModuleName
  @enDesc:
    The list of modules. 

PropDef:
  @QName: pc|exceptionInterfaceName
  @enDesc:
    The list of exception interface packages.

PropDef:
  @QName: useCharClassName
  @enDesc:
    The list of modules. 

PropDef:
  @QName: requireResourceURI
  @enDesc:
    The list of resources.

ResourceDef:
  @For: ManakaiDOM|Perl
  @QName: nodeTypeToPackageName
  @rdf:type:
    dis2pm:BlockCode
  @enDesc:
    Gets Perl class package name from a node type string.
  @PerlCDef:
        if ($nodeType eq 'unparsed') {
          $packageName = <ClassName::ManakaiPerlUnparsedCode>;
        } elsif ($nodeType eq 'bare') {
          $packageName = <ClassName::ManakaiPerlBare>;
        } elsif ($nodeType eq 'atom') {
          $packageName = <ClassName::ManakaiPerlAtom>;
        } elsif ($nodeType eq 'variable') {
          $packageName = <ClassName::ManakaiPerlVariable>;
        } elsif ($nodeType eq 'inunparsed') {
          $packageName = <ClassName::ManakaiPerlInlineUnparsedCode>;
        } elsif ($nodeType eq 'incontainer') {
          $packageName = <ClassName::ManakaiPerlInlineContainer>;
        } elsif ($nodeType eq 'statement') {
          $packageName = <ClassName::ManakaiPerlStatement>;
        } elsif ($nodeType eq 'assign') {
          $packageName = <ClassName::ManakaiPerlAssignment>;
        } elsif ($nodeType eq 'string') {
          $packageName = <ClassName::ManakaiPerlStringLiteral>;
        } elsif ($nodeType eq 'blockcontainer') {
          $packageName = <ClassName::ManakaiPerlBlockContainer>;
        } elsif ($nodeType eq 'block') {
          $packageName = <ClassName::ManakaiPerlBlock>;
        } elsif ($nodeType eq 'if') {
          $packageName = <ClassName::ManakaiPerlIf>;
        } elsif ($nodeType eq 'sub') {
          $packageName = <ClassName::ManakaiPerlSub>;
        } elsif ($nodeType eq 'package') {
          $packageName = <ClassName::ManakaiPerlPackageScope>;
        } elsif ($nodeType eq 'file') {
          $packageName = <ClassName::ManakaiPerlFile>;
        } else {
          __ASSERT{DISPerl:invariant::
            msg => {qq[Node type: "$nodeType" ].
                    qq[(ref: "@{[ref $object]}")]},
          }__;
        }


PropDef:
  @QName: nodeType
  @enDesc:
    Node type. 

ElementTypeBinding:
  @Name: ETQName
  @ElementType:
    dis:AppName
  @ShadowContent:
    @@ForCheck: s|ForML
    @@ContentType: DISCore|QName

IFClsETDef:
  @IFQName: PerlFile
  @ClsQName: ManakaiPerlFile
  @CQName: ManakaiPCFile
  @ETQName: pc|file

  @IFISA: PerlCode

  @IFISA: PerlCodeStatements
  @ClsISA: ManakaiPerlStatementContainer
  @CISA: ManakaiPCCodeStatements

  @enDesc:
    Perl source code files.

  @IntMethod:
    @@ForCheck: !pc|ForClass
    @@Name:newObject
    @@ManakaiDOM:isStatic:1
    @@Description:
      @@@lang:en
      @@@@:
        Creates a new instance object for <Class::ManakaiPerlFile>. 
    @@Return:
      @@@Type:
        ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl
      @@@Description:
        @@@@lang:en
        @@@@@:
          The newly created node object.
      @@@PerlDef:
        @@@@@:
          my $node = $r = <ClassM::ManakaiDOM:ManakaiDOMNodeObject
                                        ::ManakaiDOM:Perl.new>;
          push @{$node->{<Q::TreeCore:subnode>}}, <H::pc:childNodes>;
          $node->{<H::pc:childNodes>} = [];
          $node->{<H::pc:sourceFile>} = '';
          $node->{<H::pc:sourceModule>} = '';
          $node->{<H::pc:sourceFor>} = '';
          $node->{<H::pc:currentPackage>} = 'main';
          $node->{<H::pc:currentChunk>} = 0;
          $node->{<H::pc:nodeType>} = 'file';
        @@@@ImplNote:
          @@@@@lang:en
          @@@@@@:
            Properties: <Q::pc:sourceFile>,
               <Q::pc:sourceModule>, <Q::pc:sourceFor>, <Q::childNodes>, 
               <Q::pc:currentPackage>, <Q::pc:currentChunk>,
               <Q::pc:nodeType>, <Q::pc:useModuleName>,
               <Q::pc:useCharClassName>, 
               <Q::pc:requireResourceURI>, <Q::pc:requireModuleName>.

  @Method:
    @@Name: appendNewPackage
    @@enDesc:
      Appends a new package scope block. 
    @@Param:
      @@@Name: packageName
      @@@Type: DOMString
      @@@enDesc:
        The fully-qualified name of the package to create. 
    @@Return:
      @@@Type: PerlPackage
      @@@enDesc:
        The newly created package scope object. 
      @@@PerlDef:
        @@@@ForCheck: !pc|ForClass
        @@@@@:
        $r = <ClassM::ManakaiPerlPackageScope.newObject>;
        $r->{<H::pc:packageName>} = $packageName;
        $self->{<H::mn:node>}
             -><M::ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl
                            .importTree> ($r);
        push @{$self->{<H::mn:node>}->{<H::pc:childNodes>}}, $r;
        $r->{<H::pc:parent>} = $self->{<H::mn:node>};
        __CODE{ManakaiNode:getNewReference||ManakaiDOM|Perl::
                 $object => $r, $ref => $r,
                 $class => {<ClassName::ManakaiPerlPackageScope>}}__;
      @@@PerlDef:
        @@@@ForCheck: pc|ForClass
        @@@@@:
          __DEEP{
            $r = $self-><AG::Node.ownerDocument>-><M::Document.createElementNS>
                                                          (<Q::pc:>, 'package');
            $r-><AS::PerlPackage.packageName> ($packageName);
            $self-><M::Node.appendChild> ($r);
          }__;

  @Method:
    @@Name: appendPackage
    @@enDesc:
      Appends a Perl package scope object.
    @@Param:
      @@@Name: codeArg
      @@@Type: PerlPackage
      @@@enDesc:
        The package to append.
    @@Return:
      @@@RaiseException:
        @@@@@:IN_USE_NODE_ERR
        @@@@enDesc:
          An attempt is made to set a subroutine that is 
          already used elsewhere. 
      @@@PerlDef:
        @@@@ForCheck: !pc|ForClass
        @@@@@:
        my $packobj = $codeArg->{<H::mn:node>};
        if ($packobj->{<H::pc:parent>}) {
          __EXCEPTION{IN_USE_NODE_ERR::
            pc:childNode => {$codeArg},
            MDOMX:param-name => 'codeArg',
          }__;
        }
        $self->{<H::mn:node>}
             -><M::ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl
                            .importTree> ($packobj);
        push @{$self->{<H::mn:node>}->{<H::pc:childNodes>}}, $packobj;
        $packobj->{<H::pc:parent>} = $self->{<H::mn:node>};
      @@@PerlDef:
        @@@@ForCheck: pc|ForClass
        @@@@@:
          if ($codeArg-><AG::Node.parentNode>) {
            __EXCEPTION{IN_USE_NODE_ERR::
              pc:childNode => {$codeArg},
              MDOMX:param-name => 'codeArg',
            }__;
          }
          __DEEP{
            $self-><AG::Node.ownerDocument>-><M::Document.adoptNode> ($codeArg);
            $self-><M::Node.appendChild> ($codeArg);
          }__;

  @Method:
    @@Name: getLastPackage
    @@enDesc:
      Gets the last package scope block of a name. 
    @@Param:
      @@@Name: packageName
      @@@@Type:
        Perl:package-name::ManakaiDOM:all
      @@@@enDesc:
        The fully-qualified name of the package to get. 
    @@NamedParam:
      @@@Name: makeNewPackage
      @@@Type:
        DOMMain:boolean::ManakaiDOM:all
      @@@enDesc:
        Whether a new package scope object should be created if 
        no package of <P::packageName> found. 
      @@@TrueCase:
        @@@@enDesc:
          Makes a new object if not found. 
      @@@FalseCase:
        @@@@enDesc:
          Don't make a new object. 
    @@Return:
      @@@Type: PerlPackage
      @@@enDesc:
        The last package scope object whose name is equal to 
        <P::packageName>.
      @@@nullCase:
        @@@@enDesc:
          There is no <P::packageName> package object and 
          the <P::makeNewPackage> parameter is set to <DOM::false>. 
      @@@PerlDef:
        @@@@ForCheck: !pc|ForClass
        @@@@@:
        for my $cn (reverse @{$self->{<H::mn:node>}
                                   ->{<H::pc:childNodes>}}) {
          if ($cn->{<H::pc:nodeType>} eq 'package' and
              $cn->{<H::pc:packageName>} eq $packageName) {
            $r = $cn;
            last;
          }
        }
        if ($r) {
          __CODE{ManakaiNode:getNewReference||ManakaiDOM|Perl::
                   $object => $r, $ref => $r,
                   $class => {<ClassName::ManakaiPerlPackageScope>}}__;
        } elsif ($makeNewPackage) {
          __DEEP{
            $r = $self-><M::ManakaiPerlFile.appendNewPackage> ($packageName);
          }__;
        }
      @@@PerlDef:
        @@@@ForCheck: pc|ForClass
        @@@@@:
          __DEEP{
            for my $child (@{$self-><AG::Node.childNodes>}) {
              if ($child-><AG::Node.nodeType> == <C::Node.ELEMENT_NODE> and
                  defined $child-><AG::Node.namespaceURI> and
                  $child-><AG::Node.namespaceURI> eq <Q::pc:> and
                  $child-><AG::Node.localName> eq 'package') {
                if ($child-><M::Element.getAttributeNS>
                               (<Q::pc:>, 'packageName') eq $packageName) {
                  $r = $child;
                }
              }
            }
            if (not $r and $makeNewPackage) {
              $r = $self-><M::PerlFile.appendNewPackage> ($packageName);
            }
          }__;

  @ATTR:
    @@Name: sourceFile
    @@ATTRQName: pc|sourceFile
    @@enDesc:
      The file name of the source file from which this 
      Perl code is primary generated. 
    @@ReflectCDATA:
    @@Get:
      @@@disDef:
        @@@@GetProp: sourceFile
        @@@@ForCheck: !pc|ForClass
    @@Set:
      @@@disDef:
        @@@@SetProp: sourceFile
        @@@@ForCheck: !pc|ForClass

  @ATTR:
    @@Name: sourceModule
    @@ATTRQName: pc|sourceModule
    @@enDesc:
      The name URI reference of the source module that this package defines.
    @@ReflectCDATA:
    @@Get:
      @@@disDef:
        @@@@GetProp: sourceModule
        @@@@ForCheck: !pc|ForClass
    @@Set:
      @@@disDef:
        @@@@SetProp: sourceModule
        @@@@ForCheck: !pc|ForClass

  @ATTR:
    @@Name: sourceFor
    @@ATTRQName: pc|sourceFor
    @@enDesc:
      The URI reference of the source module <QUOTE::for> for which this 
      package is. 
    @@ReflectCDATA:
    @@Get:
      @@@disDef:
        @@@@GetProp: sourceFor
        @@@@ForCheck: !pc|ForClass
    @@Set:
      @@@disDef:
        @@@@SetProp: sourceFor
        @@@@ForCheck: !pc|ForClass

  @ToStringMethod:
    @@Return:
      @@@Type: DOMString
      @@@enDesc:
        The Perl code generated. 
      @@@PerlDef:
        @@@@ForCheck: !pc|ForClass
        @@@@@:
        __DEEP{
          my $node = $self->{<H::mn:node>};
          ## -- Header
          $r = qq<#!/usr/bin/perl \n>;
          $r .= <ClassM::ManakaiPerlCodeImplementation.perlComment>
                  (q<This file is automatically generated>);
          $r .= <ClassM::ManakaiPerlCodeImplementation.perlComment>
                 (q<	at >.<ClassM::ManakaiPerlCodeImplementation
                                           .rfc3339DateTime> (time).q<,>);
          $r .= <ClassM::ManakaiPerlCodeImplementation.perlComment>
                  (q<	from file ">.$node->{<H::pc:sourceFile>}.q<",>);
          $r .= <ClassM::ManakaiPerlCodeImplementation.perlComment>
                  (q[	module <].$node->{<H::pc:sourceModule>}.q[>,]);
          $r .= <ClassM::ManakaiPerlCodeImplementation.perlComment>
                  (q[	for <].$node->{<H::pc:sourceFor>}.q[>.]);
          $r .= <ClassM::ManakaiPerlCodeImplementation.perlComment>
                  (q<Don't edit by hand!>);
          $r .= qq<use strict;\n>;
          $self-><AS::ManakaiPerlFile.currentPackage> ('main');
          $self-><AS::ManakaiPerlFile.currentChunkNumber> (0);

          ## -- Requires
          my $req = $self-><M::ManakaiPerlCodeFragment
                              .getRequirePerlModuleNameList>;
          for my $pack (sort {$a cmp $b} @$req) {
            $r .= qq<require $pack;\n>;
          }

          ## -- Packages and global objects
          my $pack = {};
          for my $cno (@{$node->{<H::pc:childNodes>}}) {
            my $cn = <ClassM::ManakaiPerlCodeFragment.getNodeReference> ($cno);
            $r .= $cn->stringify;
            if ($cno->{<H::pc:nodeType>} eq 'package') {
              for my $ipack (keys %{$cno->{<H::dis:Implement>}}) {
                $pack->{$ipack} ||= true; # not defined
              }
              $pack->{$cno->{<H::pc:packageName>}} = []; # defined
            }
          }

          ## -- Exception interface packages
          for (sort {$a cmp $b} @{$self-><M::PerlCode
                                     .getExceptionInterfacePackageNameList>}) {
            next if ref $pack->{$_};
            $pack->{$_} = [];
            $r .= sprintf q<push @%s::ISA, 'Message::Util::Error' >.
                          q<unless @%s::ISA;%s>, $_, $_, "\n";
          }

          ## -- Enables interface packages
          my @packs = map {'$' . $_ . '::'}
                      sort {$a cmp $b}
                      grep {not ref $pack->{$_} and $pack->{$_}}
                      keys %$pack;
          $r .= q<for (>. join (', ', @packs) . qq<){}\n> if @packs;

          ## -- Footer
          $r .= <ClassM::ManakaiPerlCodeImplementation.perlComment>
                  (q[License: <].$node->{<H::dis:License>}.qq[>\n]);
          $r .= qq<1;\n>;
        }__;
      @@@PerlDef:
        @@@@ForCheck: pc|ForClass
        @@@@@:
          __DEEP{
            ## -- Header
            $r = qq<#!/usr/bin/perl \n>;
            $r .= <ClassM::ManakaiPerlCodeImplementation.perlComment>
                    (q<This file is automatically generated>);
            $r .= <ClassM::ManakaiPerlCodeImplementation.perlComment>
                   (q<	at >.<ClassM::ManakaiPerlCodeImplementation
                                             .rfc3339DateTime> (time).q<,>);
            $r .= <ClassM::ManakaiPerlCodeImplementation.perlComment>
                    (q<	from file ">.$self-><AG::PerlFile.sourceFile>.q<",>);
            $r .= <ClassM::ManakaiPerlCodeImplementation.perlComment>
                    (q[	module <].$self-><AG::PerlFile.sourceModule>.q[>,]);
            $r .= <ClassM::ManakaiPerlCodeImplementation.perlComment>
                    (q[	for <].$self-><AG::PerlFile.sourceFor>.q[>.]);
            $r .= <ClassM::ManakaiPerlCodeImplementation.perlComment>
                    (q<Don't edit by hand!>);
            $r .= qq<use strict;\n>;
            $self-><AS::PerlFile.currentPackage> ('main');
            $self-><AS::PerlFile.currentChunkNumber> (0);

            ## -- Requires
            my $req = $self-><M::PerlCode.getRequirePerlModuleNameList>;
            for my $pack (sort {$a cmp $b} @$req) {
              $r .= qq<require $pack;\n>;
            }

            ## -- Packages and global objects
            my $pack = {};
            for my $child (@{$self-><AG::Node.childNodes>}) {
              $r .= $child->stringify;
              if ($child-><AG::Node.nodeType> == <C::Node.ELEMENT_NODE> and
                  defined $child-><AG::Node.namespaceURI> and
                  $child-><AG::Node.namespaceURI> eq <Q::pc:> and
                  $child-><AG::Node.localName> eq 'package') {
                for my $ipack (@{$child-><M::PerlPackage
                                             .getImplementPackageNameList>}) {
                  $pack->{$ipack} ||= true; # not defined
                }
                $pack->{$child-><AG::PerlPackage.packageName>} = []; # defined
              }
            }

            ## -- Exception interface packages
            for (sort {$a cmp $b} @{$self-><M::PerlCode
                                     .getExceptionInterfacePackageNameList>}) {
              next if ref $pack->{$_};
              $pack->{$_} = [];
              $r .= sprintf q<push @%s::ISA, 'Message::Util::Error' >.
                            q<unless @%s::ISA;%s>, $_, $_, "\n";
            }

            ## -- Enables interface packages
            my @packs = map {'$' . $_ . '::'}
                        sort {$a cmp $b}
                        grep {not ref $pack->{$_} and $pack->{$_}}
                        keys %$pack;
            $r .= q<for (>. join (', ', @packs) . qq<){}\n> if @packs;

            ## -- Footer
            $r .= <ClassM::ManakaiPerlCodeImplementation.perlComment>
                    (q[License: <].$self-><AG::PerlFile.licenseURI>.qq[>\n]);
            $r .= qq<1;\n>;
          }__;

  @Attr:
    @@Name: currentPackage
    @@enDesc:
      The current Perl package (used in stringify method).

      {NOTE:: This attribute is not preserved by the <Perl::clone> operation.
      }
    @@Type: DOMString
    @@Get:
      @@@disDef:
        @@@@GetProp: currentPackage
    @@Set:
      @@@disDef:
        @@@@SetProp: currentPackage

  @Attr:
    @@Name: currentChunkNumber
    @@enDesc:
      The current code chunk number (used in stringify method). 
  
      {NOTE:: This attribute is not preserved by the <Perl::clone> operation.
      }
    @@Type: idl|unsignedLong||ManakaiDOM|all
    @@Get:
      @@@disDef:
        @@@@GetProp: currentChunk
    @@Set:
      @@@disDef:
        @@@@SetProp: currentChunk

  @Method:
    @@Name: getNextChunkNumber
    @@enDesc:
      Increments the current chunk number of this file 
      and returns it. 
    @@Return:
      @@@Type: idl|unsignedLong||ManakaiDOM|all
      @@@enDesc:
        The next chunk number.
      @@@PerlDef:
        $r = ++$self->{<H::mn:node>}->{<H::pc:currentChunk>};
  
  @ATTR:
    @@Name: licenseURI
    @@ATTRQName: dis|License
    @@enDesc:
      The license term URI reference for this code. 
    @@ReflectCDATA:
    @@Get:
      @@@disDef:
        @@@@GetProp: 
          dis:License
        @@@@ForCheck: !pc|ForClass
    @@Set:
      @@@disDef:
        @@@@SetProp:
          dis:License
        @@@@ForCheck: !pc|ForClass
##PerlFile

PropDef:
  @QName: export
  @enDesc:
    The list of exported members.

PropDef:
  @QName: requireModuleName
  @enDesc:
    The list of <Perl::require>d Perl module names

PropDef:
  @QName: sourceModule
  @enDesc:
    The soruce module name URI reference. 

PropDef:
  @QName: sourceFor
  @enDesc:
    The source module <QUOTE::for> URI reference. 

PropDef:
  @QName: currentPackage
  @enDesc:
    The current Perl package name (used for stringify).

PropDef:
  @QName: currentChunk
  @enDesc:
    The current code chunk (used for stringify). 

ElementTypeBinding:
  @Name: ReflectCDATA
  @ElementType:
    dis:Type
  @ShadowContent:
    @@@: DOMString
  @ShadowSibling:
    @@actualType: CDATADOMString

ResourceDef:
  @QName: DOMString
  @For: ManakaiDOM|Perl
  @AliasFor: DOMMain|DOMString||ManakaiDOM|ManakaiDOMLatest

ReflectTypeDef:
  @QName: CDATADOMString
  @enDesc:
    <IF::DOMMain:DOMString> for DOM attributes reflecting
    <SGML::CDATA> element attributes.
  @rdfs:subClassOf: DOMString
  @ResourceDef:
    @@rdf:type: DOMMain|ReflectGet
    @@enDesc:
      The DOM attribute returns the current value of the element attribute
      in a transparent, case-sensitive manner.
      \
      If the element attribute is absent, the default value, if any,
      or an empty string is returned.
    @@PerlCDef:
      __DEEP{
        $r = $self-><M::Element.getAttributeNS> ($NS_URI_NO_NULL, $LOCAL_NAME);
      }__;
  @ResourceDef:
    @@QName: CDATADOMStringSet
    @@rdf:type: DOMMain|ReflectSet
    @@enDesc:
      The corresponding element attribute is set to the given value,
      in a transparent, case-sensitive manner.
    @@ImplNote:
      @@@lang:en
      @@@@: 
        What will happen if the <DOM::null> value is given?
    @@PerlCDef:
      __DEEP{
        if (defined $given) {
          $self-><M::Element.setAttributeNS> ($NS_URI_NO_NULL, $LOCAL_NAME
                                              => $given);
        } else {
          $self-><M::Element.removeAttributeNS> ($NS_URI_NO_NULL, $LOCAL_NAME);
        }
      }__;

ElementTypeBinding:
  @Name: ReflectTypeDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|DataType
    @@ForCheck: !ManakaiDOM|IDL
    @@For: ManakaiDOM|DOM

ElementTypeBinding:
  @Name: ATTR
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      @@@@: s|Attribute
      @@@ForCheck: s|ForML
    @@rdf:type:
      @@@@: DISLang|Attribute
      @@@ForCheck: ManakaiDOM|ForClass
    @@rdf:type:
      @@@@: DISLang|Attribute
      @@@ForCheck: ManakaiDOM|ForIF
    @@DocAttr:
      @@@@: ||+||s|ForML
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass
    @@DocAttr:
      @@@@: ||+||s|ForML
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForIF
    @@ForCheck: !=ManakaiDOM|ManakaiDOM

ElementTypeBinding:
  @Name: ATTRQName
  @ElementType:
    dis:AppName
  @ShadowContent:
    @@ForCheck: s|ForML
    @@ContentType: DISCore|QName

IFClsETDef:
  @IFQName: PerlPackage
  @ClsQName: ManakaiPerlPackageScope
  @CQName: ManakaiPCPackage
  @ETQName: pc|package

  @IFISA: PerlCode

  @IFISA: PerlCodeStatements
  @ClsISA: ManakaiPerlStatementContainer
  @CISA: ManakaiPCCodeStatements

  @enDesc:
    A Perl lexical lines for which a <Perl::package> declaration
    in effect. 

  @ATTR:
    @@Name: packageName
    @@ATTRQName: pc|packageName
    @@ReflectCDATA:
    @@enDesc:
      The fully-qualified package name. 
    @@Get: 
      @@@disDef:
        @@@@GetProp: packageName
        @@@@ForCheck: !pc|ForClass
    @@Set:
      @@@ForCheck: !pc|ForClassCompat

  @IntMethod:
    @@ForCheck: ManakaiDOM|ForClass !pc|ForClass
    @@Name:newObject
    @@ManakaiDOM:isStatic:1
    @@Description:
      @@@lang:en
      @@@@:
        Creates a new instance object for <Class::ManakaiPerlPackageScope>. 
    @@Return:
      @@@Type:
        ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl
      @@@Description:
        @@@@lang:en
        @@@@@:
          The newly created node object.
      @@@PerlDef:
        @@@@@:
          my $node = $r = <ClassM::ManakaiDOM:ManakaiDOMNodeObject
                                        ::ManakaiDOM:Perl.new>;
          push @{$node->{<Q::TreeCore:subnode>}}, <H::pc:sub>,
                                                 <H::dis2pm:operator>,
                                                 <H::pc:childNodes>;
          push @{$node->{<Q::TreeCore:origin>}}, <H::pc:parent>;
          $node->{<H::pc:sub>} = {};
          $node->{<H::dis2pm:operator>} = {};
          $node->{<H::dis:ISA>} = [];
          $node->{<H::dis:Implement>} = {};
          $node->{<H::pc:nodeType>} = 'package';
          $node->{<H::pc:childNodes>} = [];
        @@@@ImplNote:
          @@@@@lang:en
          @@@@@@:
            Properties: <Q::pc:sub>, <Q::dis2pm:operator>,
              <Q::dis:ISA>, <Q::dis:Implement>,
              <Q::pc:nodeType>, <Q::pc:useModuleName>,
              <Q::pc:useCharClassName>,  
              <Q::pc:requireResourceURI>, <Q::pc:childNodes>,
              <Q::pc:export>, <Q::pc:requireModuleName>.

  @Method:
    @@Name: getSub
    @@enDesc:
      Gets a subroutine. 
    @@Param:
      @@@Name: subName
      @@@Type:
        DISPerl:SubName::ManakaiDOM:all
      @@@enDesc:
        The name of subroutine to get. 
    @@NamedParam:
      @@@Name: makeNewNode
      @@@Type:
        DOMMain:boolean::ManakaiDOM:all
      @@@enDesc:
        Whether a new subroutine object should be created, 
        if it is not exist, or not. 
    @@Return:
      @@@Type: PerlSub
      @@@enDesc:
        The subroutine object. 
      @@@nullCase:
        @@@@enDesc:
          Either the specified subroutine is not found and 
          the <P::makeNewNode> parameter is set to <DOM::false> or
          the subroutine is defined as an alias. 
      @@@PerlDef:
        @@@@ForCheck: !pc|ForClass
        @@@@@:
        if ($self->{<H::mn:node>}->{<H::pc:sub>}->{$subName}) {
          $r = ref $self->{<H::mn:node>}->{<H::pc:sub>}->{$subName}
             ? $self->{<H::mn:node>}->{<H::pc:sub>}->{$subName} : null;
        } elsif ($makeNewNode) {
          $r = $self->{<H::mn:node>}->{<H::pc:sub>}->{$subName}
             = <ClassM::ManakaiPerlSub.newObject>;
          $self->{<H::mn:node>}
               -><M::ManakaiDOM:ManakaiDOMNodeObject
                   ::ManakaiDOM:Perl.importTree> ($r);
          $r->{<H::pc:parent>} = $self->{<H::mn:node>};
          $r->{<H::pc:localName>} = $subName;
        }
        if ($r) {
          __CODE{ManakaiNode:getNewReference||ManakaiDOM|Perl::
                   $object => $r, $ref => $r,
                   $class => {<ClassName::ManakaiPerlSub>}}__;
        }
      @@@PerlDef:
        @@@@ForCheck: pc|ForClass
        @@@@@:
          __DEEP{
            F: {
              for my $child (@{$self-><AG::Node.childNodes>}) {
                if ($child-><AG::Node.nodeType> == <C::Node.ELEMENT_NODE> and
                    defined $child-><AG::Node.namespaceURI> and
                    $child-><AG::Node.namespaceURI> eq <Q::pc:> and
                    $child-><AG::Node.localName> eq 'sub') {
                  if ($child-><M::PerlSub.hasPerlName> ($subName)) {
                    $r = $child;
                    last F;
                  }
                }
              }
              if ($makeNewNode) {
                $r = $self-><AG::Node.ownerDocument>
                          -><M::Document.createElementNS>
                               (<Q::pc:>, 'sub');
                $r-><M::PerlSub.addPerlName> ($subName);
                $self-><M::Node.appendChild> ($r);
              }
            } # F
          }__;

  @Method:
    @@Name: setSub
    @@enDesc:
      Sets a subrotine. 
    @@Param:
      @@@Name: subName
      @@@Type:
        DISLang:String::ManakaiDOM:all
      @@@enDesc:
        The name of the subroutine. 
        \
        {NOTE:: The <P::subName> value must be equal to the 
                <A::PerlSub.pcLocalName> of the <P::subArg>.

        }
    @@Param:
      @@@Name: subArg
      @@@Type: PerlSub
      @@@caType: ManakaiPerlSub
      @@@enDesc:
        The subroutine object.
    @@Return:
      @@@RaiseException:
        @@@@@:IN_USE_NODE_ERR
        @@@@enDesc:
          An attempt is made to set a subroutine that is 
          already used elsewhere. 
      @@@PerlDef:
        @@@@ForCheck: !pc|ForClass
        @@@@@:
        my $ops = $self->{<H::mn:node>}->{<H::pc:sub>};
        if (ref $ops->{$subName}) {
          CORE::delete $ops->{<H::pc:parent>};
          $ops->{$subName}
              -><M::ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl.orphanate>;
        }
        if ($subArg->{<H::mn:node>}->{<H::pc:parent>}) {
          __EXCEPTION{IN_USE_NODE_ERR::
            pc:childNode => {$subArg},
          }__;
        }
        $self->{<H::mn:node>}-><M::MNodeObject.importTree>
                                          ($subArg->{<H::mn:node>});
        $ops->{$subName} = $subArg->{<H::mn:node>};
        $subArg->{<H::mn:node>}->{<H::pc:parent>}
                         = $self->{<H::mn:node>};

  @Method:
    @@ForCheck: !pc|ForClassCompat
    @@Name: setSubNode
    @@enDesc:
      Sets a subrotine. 
    @@Param:
      @@@Name: subArg
      @@@Type: PerlSub
      @@@caType: ManakaiPerlSub
      @@@enDesc:
        The subroutine object.
    @@Return:
      @@@RaiseException:
        @@@@@:IN_USE_NODE_ERR
        @@@@enDesc:
          An attempt is made to set a subroutine that is 
          already used elsewhere. 
      @@@PerlDef:
          __DEEP{
            if ($subArg-><AG::Node.parentNode>) {
              __UNDEEP{__EXCEPTION{IN_USE_NODE_ERR::
                pc:childNode => {$subArg},
              }__}__;
            }
            $self-><AG::Node.ownerDocument>-><M::Document.adoptNode> ($subArg);
            $self-><M::Node.appendChild> ($subArg);
          }__;

  @Method:
    @@ForCheck: pc|ForClassCompat
    @@Name: getSubAliasName
    @@enDesc:
      Gets the secondary name of a subroutine. 
    @@Param:
      @@@Name: subName
      @@@Type:
        DISLang:String::ManakaiDOM:all
      @@@enDesc:
        The name of the alias subroutine. 
    @@Return:
      @@@Type: 
        DISLang:String::ManakaiDOM:all
      @@@enDesc:
        The real name. 
      @@@nullCase:
        @@@@enDesc:
          The specified name is used. 
      @@@InCase:
        @@@@Value:\#CODE
        @@@@ContentType: DISCore|String
        @@@@enDesc:
          The specified name is not an alias. 
      @@@PerlDef:
        if ($self->{<H::mn:node>}->{<H::pc:sub>}->{$subName}) {
          $r = ref $self->{<H::mn:node>}
                        ->{<H::pc:sub>}->{$subName}
             ? q<#CODE> : $self->{<H::mn:node>}
                           ->{<H::pc:sub>}->{$subName};
        }

  @Method:
    @@ForCheck: pc|ForClassCompat
    @@Name: setSubAliasName
    @@enDesc:
      Sets a subroutine name as an alias of another subroutine. 
    @@Param:
      @@@Name: aliasName
      @@@Type:
        DISLang:String::ManakaiDOM:all
      @@@enDesc:
        The alias name. 
    @@Param:
      @@@Name: realName
      @@@Type:
        DISLang:String::ManakaiDOM:all
      @@@enDesc:
        The real name. 
    @@Return:
      @@@UnknownOperatorException:
      @@@PerlDef:
        my $ops = $self->{<H::mn:node>}->{<H::pc:sub>};
        if (ref $ops->{$aliasName}) {
          CORE::delete $ops->{<H::pc:parent>};
          $ops->{$aliasName}
              -><M::ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl.orphanate>;
        }
        $ops->{$aliasName} = $realName;

  @Method:
    @@Name: getOverloadSub
    @@enDesc:
      Gets an overloading subroutine. 
    @@Param:
      @@@Name: opName
      @@@Type:
        DISLang:String::ManakaiDOM:all
      @@@enDesc:
        The name of the overloaded operator. 
    @@NamedParam:
      @@@Name: makeNewNode
      @@@Type:
        DOMMain:boolean::ManakaiDOM:all
      @@@enDesc:
        Whether a new subroutine object should be created, 
        if it is not exist, or not. 
    @@Return:
      @@@Type: PerlSub
      @@@caType: ManakaiPerlSub
      @@@enDesc:
        The subroutine object. 
      @@@nullCase:
        @@@@enDesc:
          Either the specified subroutine is not found and 
          the <P::makeNewNode> parameter is set to <DOM::false> or
          the specified operator is overloaded by specifying method name. 
      @@@UnknownOperatorException:
      @@@PerlDef:
        @@@@ForCheck: !pc|ForClass
        @@@@@:
        unless (<Code::operatorNameList>->{$opName}) {
          __EXCEPTION{UNSUPPORTED_OPERATOR_ERR::
            pc:operator => {$opName},
          }__;
        }
        if ($self->{<H::mn:node>}->{<H::dis2pm:operator>}->{$opName}) {
          $r = ref $self->{<H::mn:node>}
                        ->{<H::dis2pm:operator>}->{$opName}
             ? $self->{<H::mn:node>}
                        ->{<H::dis2pm:operator>}->{$opName} : null;
        } elsif ($makeNewNode) {
          $r = $self->{<H::mn:node>}->{<H::dis2pm:operator>}->{$opName}
             = <ClassM::ManakaiPerlSub.newObject>;
          $self->{<H::mn:node>}
               -><M::ManakaiDOM:ManakaiDOMNodeObject
                   ::ManakaiDOM:Perl.importTree> ($r);
          $r->{<H::pc:parent>} = $self->{<H::mn:node>};
        }
        if ($r) {
          __CODE{ManakaiNode:getNewReference||ManakaiDOM|Perl::
                   $object => $r, $ref => $r,
                   $class => {<ClassName::ManakaiPerlSub>}}__;
        }
      @@@PerlDef:
        @@@@ForCheck: pc|ForClass
        @@@@@:
          unless (<Code::operatorNameList>->{$opName}) {
            __EXCEPTION{UNSUPPORTED_OPERATOR_ERR::
              pc:operator => {$opName},
              MDOMX:param-name => 'opName',
            }__;
          }
          __DEEP{
            F: {
              for my $child (@{$self-><AG::Node.childNodes>}) {
                if ($child-><AG::Node.nodeType> == <C::Node.ELEMENT_NODE> and
                    defined $child-><AG::Node.namespaceURI> and
                    $child-><AG::Node.namespaceURI> eq <Q::pc:> and
                    $child-><AG::Node.localName> eq 'sub') {
                  if ($child-><M::PerlSub.hasPerlOperator> ($opName)) {
                    $r = $child;
                    last F;
                  }
                }
              }
              if ($makeNewNode) {
                $r = $self-><AG::Node.ownerDocument>
                          -><M::Document.createElementNS>
                               (<Q::pc:>, 'sub');
                $r-><M::PerlSub.addPerlOperator> ($opName);
                $self-><M::Node.appendChild> ($r);
              }
            } # F
          }__;

  @Method:
    @@ForCheck: pc|ForClassCompat
    @@Name: setOverloadSub
    @@enDesc:
      Sets an overloading subrotine. 
    @@Param:
      @@@Name: opName
      @@@Type:
        DISLang:String::ManakaiDOM:all
      @@@enDesc:
        The name of the opeartor to overload. 
    @@Param:
      @@@Name: subArg
      @@@Type: PerlSub
      @@@caType: ManakaiPerlSub
      @@@enDesc:
        The subroutine object.
    @@Return:
      @@@UnknownOperatorException:
      @@@RaiseException:
        @@@@@:IN_USE_NODE_ERR
        @@@@enDesc:
          An attempt is made to set a subroutine that is 
          already used elsewhere. 
      @@@PerlDef:
        unless (<Code::operatorNameList>->{$opName}) {
          __EXCEPTION{UNSUPPORTED_OPERATOR_ERR::
            pc:operator => {$opName},
          }__;
        }
        my $ops = $self->{<H::mn:node>}->{<H::dis2pm:operator>};
        if (ref $ops->{$opName}) {
          CORE::delete $ops->{<H::pc:parent>};
          $ops->{$opName}
              -><M::ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl.orphanate>;
        }
        if ($subArg->{<H::mn:node>}->{<H::pc:parent>}) {
          __EXCEPTION{IN_USE_NODE_ERR::
            pc:parentNode => {$self},
            pc:childNode => {$subArg},
          }__;
        }
        $self->{<H::mn:node>}-><M::MNodeObject.importTree>
                                          ($subArg->{<H::mn:node>});
        $ops->{$opName} = $subArg->{<H::mn:node>};
        $subArg->{<H::mn:node>}->{<H::pc:parent>}
                         = $self->{<H::mn:node>};


  @Method:
    @@ForCheck: pc|ForClassCompat
    @@Name: getOverloadMethodName
    @@enDesc:
      Gets an overloading method name. 
    @@Param:
      @@@Name: opName
      @@@Type:
        DISLang:String::ManakaiDOM:all
      @@@enDesc:
        The name of the overloaded operator. 
    @@Return:
      @@@Type: 
        DISLang:String::ManakaiDOM:all
      @@@enDesc:
        The method name. 
      @@@nullCase:
        @@@@enDesc:
          The specified operator is not overloaded.
      @@@InCase:
        @@@@Value:\#CODE
        @@@@enDesc:
          The operator is overloaded by an anonymous subroutine. 
      @@@PerlDef:
        if ($self->{<H::mn:node>}->{<H::dis2pm:operator>}->{$opName}) {
          $r = ref $self->{<H::mn:node>}
                        ->{<H::dis2pm:operator>}->{$opName}
             ? q<#CODE> : $self->{<H::mn:node>}
                           ->{<H::dis2pm:operator>}->{$opName};
        }

  @Method:
    @@ForCheck: pc|ForClassCompat
    @@Name: setOverloadMethodName
    @@enDesc:
      Sets an overloading method name. 
    @@Param:
      @@@Name: opName
      @@@Type:
        DISLang:String::ManakaiDOM:all
      @@@enDesc:
        The name of the overloaded operator. 
    @@Param:
      @@@Name: methodName
      @@@Type:
        DISLang:String::ManakaiDOM:all
      @@@enDesc:
        The name of the method by which overloads an operator. 
        \
        {NOTE:: The method may or may not belong to this package. 
        \
        }
    @@Return:
      @@@UnknownOperatorException:
      @@@PerlDef:
        unless (<Code::operatorNameList>->{$opName}) {
          __EXCEPTION{UNSUPPORTED_OPERATOR_ERR::
            pc:operator => {$opName},
          }__;
        }
        my $ops = $self->{<H::mn:node>}->{<H::dis2pm:operator>};
        if (ref $ops->{$opName}) {
          CORE::delete $ops->{<H::pc:parent>};
          $ops->{$opName}
              -><M::ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl.orphanate>;
        }
        $ops->{$opName} = $methodName;

  @Method:
    @@Name: addISAPackage
    @@enDesc:
      Adds a class package that this class inherits. 
    @@Param:
      @@@Name: packageName
      @@@Type: DOMString
      @@@enDesc:
        The name of package to add. 
    @@Return:
      @@@PerlDef:
        @@@@ForCheck: !pc|ForClass
        @@@@@:
        push @{$self->{<H::mn:node>}->{<H::dis:ISA>}}, $packageName;
      @@@PerlDef:
        @@@@ForCheck: pc|ForClass
        @@@@@:
          __DEEP{
            $self-><M::Element.setAttributeNS>
              (<Q::pc:>, 'pc:extends' =>
               join ' ', (split /\s+/, $self-><M::Element.getAttributeNS>
                                           (<Q::pc:>, 'extends')), $packageName);
          }__;

  @Method:
    @@ForCheck: !pc|ForClassCompat
    @@Name: getISAPackageNameList
    @@enDesc:
      Returns a list of names of packages extended by the package.
    @@Return:
      @@@Type: DISPerl|ARRAY||ManakaiDOM|all
      @@@enDesc:
        An ordered snapshot list of superpackage names.
      @@@PerlDef:
        __DEEP{
          $r = [split /\s+/, $self-><M::Element.getAttributeNS>
                                (<Q::pc:>, 'extends')];
        }__;

  @Method:
    @@Name: addImplementPackage
    @@enDesc:
      Adds a interface package that this class implements. 
    @@Param:
      @@@Name: packageName
      @@@Type: DOMString
      @@@enDesc:
        The name of package to add.
    @@Return:
      @@@PerlDef:
        @@@@ForCheck: !pc|ForClass
        @@@@@:
        $self->{<H::mn:node>}->{<H::dis:Implement>}->{$packageName} = true;
      @@@PerlDef:
        @@@@ForCheck: pc|ForClass
        @@@@@:
          __DEEP{
            __CODE{addNameListAttr::
              $node => {$self},
              $attrName => 'implements',
              $newName => {$packageName},
            }__;
          }__;

  @Method:
    @@ForCheck: !pc|ForClassCompat
    @@Name: getImplementPackageNameList
    @@enDesc:
      Returns a list of names of packages implemented by the package.
    @@Return:
      @@@Type: DISPerl|ARRAY||ManakaiDOM|all
      @@@enDesc:
        An unordered snapshot list of interface packages.
      @@@PerlDef:
          __DEEP{
            __CODE{getNameListAttr::
              $node => {$self},
              $attrName => 'implements',
              $result => {$r},
            }__;
          }__;

  @ToStringMethod:
    @@Return:
      @@@Type: DOMString
      @@@enDesc:
        Perl code. 
      @@@PerlDef:
        @@@@ForCheck: !pc|ForClass
        @@@@@:
        my $file = $self-><AG::ManakaiPerlCodeFragment.parentNode>;
        my $node = $self->{<H::mn:node>};

        ## Package name
        my $pn = $node->{<H::pc:packageName>};
        $r .= q<package > . $pn . ";\n";

        ## Package version
        __DEEP{
          $file-><AS::ManakaiPerlFile.currentPackage> ($pn);
          $r .= 'our $VERSION = '.
                <ClassM::ManakaiPerlCodeImplementation.versionDateTime> (time).
                ";\n";
        }__;

        ## Inheritance
        my @isa = (@{$node->{<H::dis:ISA>}},
                   sort {$a cmp $b} keys %{$node->{<H::dis:Implement>}});
        if (@isa) {
          $r .= 'push our @ISA, ' .
                <ClassM::ManakaiPerlCodeImplementation.perlList> (\@isa) .
                ";\n";
        }

        ## Uses
        my $use = $self-><M::ManakaiPerlCodeFragment.getUsePerlModuleNameList>;
        for my $pack (@$use) {
          $r .= 'use ' . $pack . ";\n";
        }

        my $cls = $self-><M::ManakaiPerlCodeFragment.getUseCharClassNameList>;
        for my $pack (sort {$a cmp $b} keys %$cls) {
          $r .= 'use ' . $pack . ' ' .
                <ClassM::ManakaiPerlCodeImplementation.perlList>
                   ([grep {$cls->{$pack}->{$_}} keys %{$cls->{$pack}}]) . ";\n";
        }

        ## Package-scope objects
        for my $cno (@{$node->{<H::pc:childNodes>}}) {
          my $cn = <ClassM::ManakaiPerlCodeFragment.getNodeReference> ($cno);
          $r .= $cn->stringify;
        }

        ## Subroutines
        for my $cnk (sort {$a cmp $b} keys %{$node->{<H::pc:sub>}}) {
          my $cno = $node->{<H::pc:sub>}->{$cnk};
          if (ref $cno) {
            my $cn;
            __CODE{ManakaiNode:getWeakReference||ManakaiDOM|Perl::
                     $object => $cno, $ref => $cn,
                     $class => {<ClassName::ManakaiPerlSub>}}__;
            $r .= $cn->stringify;
          } else {
            $r .= qq<*$cnk = \\&$cno;\n>;
          }
        }

        ## Operators
        my $op = '';
        for my $cnk (sort {$a cmp $b} keys %{$node->{<H::dis2pm:operator>}}) {
          my $cno = $node->{<H::dis2pm:operator>}->{$cnk};
          if (ref $cno) {
            my $cn;
            __CODE{ManakaiNode:getWeakReference||ManakaiDOM|Perl::
                     $object => $cno, $ref => $cn,
                     $class => {<ClassName::ManakaiPerlSub>}}__;
            $op .= <ClassM::ManakaiPerlCodeImplementation.perlLiteral> ($cnk)
                .  ' => ' . $cn->stringify . ', ';
          } elsif (defined $cno) {
            $op .= <ClassM::ManakaiPerlCodeImplementation.perlList>
                                                        ([$cnk => $cno]) . ', ';
          }
        }
        $r .= 'use overload bool => sub () {1}, ' .
              $op . qq[fallback => 1;\n] if $op;


        ## -- Exports
        if (%{$node->{<H::pc:export>} || {}}) {
          $r .= q[our %EXPORT_TAG = (] . 
                  <ClassM::ManakaiPerlCodeImplementation.perlList>
                     ([map {$_ => [sort {$a cmp $b}
                                        keys %{$node->{<H::pc:export>}->{$_}}]}
                       sort {$a cmp $b}
                       grep {$_} keys %{$node->{<H::pc:export>}}]) . qq[);\n];
          $r .= q[our @EXPORT_OK = (] .
                  <ClassM::ManakaiPerlCodeImplementation.perlList>
                     ([map {sort {$a cmp $b}
                            keys %{$node->{<H::pc:export>}->{$_}}}
                       sort {$a cmp $b}
                       keys %{$node->{<H::pc:export>}}]) . qq[);\n];
          $r .= q[use Exporter; push our @ISA, 'Exporter';] . qq[\n];
        }
      @@@PerlDef:
        @@@@ForCheck: pc|ForClass
        @@@@@:
          __DEEP{
            my $file = $self-><AG::PerlCode.fileNode>;

            ## Package name
            my $pn = $self-><AG::PerlPackage.packageName>;
            $r .= q<package > . $pn . ";\n";
            $file-><AS::PerlFile.currentPackage> ($pn) if $file;

            ## Package version
            $r .= 'our $VERSION = '.
                <ClassM::ManakaiPerlCodeImplementation.versionDateTime> (time).
                ";\n";

            ## Inheritance
            my @isa = (@{$self-><M::PerlPackage.getISAPackageNameList>},
                       sort {$a cmp $b} @{$self-><M::PerlPackage
                                               .getImplementPackageNameList>});
            if (@isa) {
              $r .= 'push our @ISA, ' .
                <ClassM::ManakaiPerlCodeImplementation.perlList> (\@isa) .
                ";\n";
            }

            ## Use'ing modules
            for my $pack (sort {$a cmp $b} @{$self-><M::PerlCode
                                                 .getUsePerlModuleNameList>}) {
              $r .= 'use ' . $pack . ";\n";
            }

            my $cls = $self-><M::PerlCode.getUseCharClassNameList>;
            for my $pack (sort {$a cmp $b} keys %$cls) {
              $r .= 'use ' . $pack . ' ' .
                <ClassM::ManakaiPerlCodeImplementation.perlList>
                   ([sort {$a cmp $b} grep {$cls->{$pack}->{$_}}
                     keys %{$cls->{$pack}}]) . ";\n";
            }

            ## Package-scope objects
            my $has_bool;
            my $op = '';
            for my $child (@{$self-><AG::Node.childNodes>}) {
              if ($child-><AG::Node.nodeType> == <C::Node.ELEMENT_NODE> and
                  defined $child-><AG::Node.namespaceURI> and
                  $child-><AG::Node.namespaceURI> eq <Q::pc:>) {
                my $ln = $child-><AG::Node.localName>;
                if ($ln eq 'sub') {
                  my $names = $child-><M::PerlSub.getPerlNameList>;
                  my $ops = $child-><M::PerlSub.getPerlOperatorList>;
                  if (@$names) {
                    $r .= $child->stringify;
                    if (@$names > 1) {
                      $r .= sprintf q<*%s = \&%s;%s>,
                                  $_, $names->[0], "\n" for @$names[1..$#$names];
                    }
                    for (@$ops) {
                      $op .= sprintf q['%s' => '%s', %s],
                                     $_ => $names->[0], "\n";
                      $has_bool = true if $_ eq 'bool';
                    }
                  } else {
                    my $v = $child->stringify;
                    for (@$ops) {
                      $op .= sprintf q['%s' => %s, %s], $_ => $v, "\n";
                      $has_bool = true if $_ eq 'bool';
                    }
                  }
                } else {
                  $r .= $child->stringify;
                }
              } # pc:*
            } # children 

            if (length $op) {
              $r .= "use overload \n";
              $r .= "bool => sub () {1}, \n" unless $has_bool;
              $r .= $op . "fallback => 1;\n";
            }

            ## -- Exports
            my $xport = $self-><M::PerlPackage.getExportList>;
            if (map {values %$_} values %$xport) {
              $r .= q[our %EXPORT_TAG = (] . 
                    <ClassM::ManakaiPerlCodeImplementation.perlList>
                       ([map {$_ => [sort {$a cmp $b} keys %{$xport->{$_}}]}
                         sort {$a cmp $b} grep {length}
                         keys %$xport]) . qq[);\n];
              $r .= q[our @EXPORT_OK = (] .
                    <ClassM::ManakaiPerlCodeImplementation.perlList>
                       ([map {sort {$a cmp $b} keys %{$xport->{$_}}}
                         sort {$a cmp $b} keys %$xport]) . qq[);\n];
              $r .= q[use Exporter; push our @ISA, 'Exporter';] . qq[\n];
            }
          }__;

  @Method:
    @@ForCheck: !pc|ForClassCompat
    @@Name: getExportList
    @@enDesc:
      Returns a list of export tag and names.
    @@Return:
      @@@Type: DISPerl|HASH||ManakaiDOM|all
      @@@enDesc:
        Snapshot list of lists.
      @@@PerlDef:
          my $mc;
          __DEEP{
            __CODE{getNameListAttr::
              $node => {$self},
              $attrName => 'export',
              $result => {$mc},
            }__;
          }__;
          for (@$mc) {
            my ($m, $c) = split /\./, $_, 2;
            $r->{$m}->{$c} = true;
          }

  @Method:
    @@Name: addExport
    @@enDesc:
      Adds a name to the list of exported items (<Perl::@EXPORT_OK>).
    @@Param:
      @@@Name: exportTag
      @@@Type: DOMString
      @@@enDesc:
        The name of the tag (without <CHAR::COLON> prefix). 
        The <P::exportName> is added both to <Perl::@EXPORT_OK>
        and <Perl::$EXPORT_OK{<P::exportTag>}>.
      @@@nullCase:
        @@@@enDesc:
          The <P::exportName> is added only to the <Perl::@EXPORT_OK>.
    @@Param:
      @@@Name: exportName
      @@@Type: DOMString
      @@@enDesc:
        The name to be exported.
    @@Return:
      @@@PerlDef:
        @@@@ForCheck: !pc|ForClass
        @@@@@:
        $self->{<H::mn:node>}->{<H::pc:export>}
             ->{defined $exportTag ? $exportTag : ''}->{$exportName} = true;
      @@@PerlDef:
        @@@@ForCheck: pc|ForClass
        @@@@@:
          __DEEP{
            __CODE{addNameListAttr::
              $node => {$self},
              $attrName => 'export',
              $newName => {$exportTag.'.'.$exportName},
            }__;
          }__;
##PerlPackageScope

PropDef:
  @QName:
    dis2pm:operator
  @enDesc:
    Overloaded operators.

ElementTypeBinding:
  @Name: UnknownOperatorException
  @ElementType:
    ManakaiDOM:raises
  @ShadowContent:
    @@@:UNSUPPORTED_OPERATOR_ERR
    @@enDesc:
      An attempt is made to overload an unknown operator. 

XParamDef:
  @QName:
    pc:operator
  @enDesc:
    An operator to overload. 

ResourceDef:
  @For: ManakaiDOM|Perl
  @QName: operatorNameList
  @enDesc:
    The list of valid operators for <PerlModule::operator> pragma. 
  @rdf:type:
    dis2pm:InlineCode
  @PerlCDef:
    {qw[
                    +  1 -  1 *  1 /  1 %  1 **  1 <<  1 >>  1 x  1 .  1
                    += 1 -= 1 *= 1 /= 1 %= 1 **= 1 <<= 1 >>= 1 x= 1 .= 1
                    <  1 <= 1 >  1 >= 1 == 1 != 1 <=> 1
                    lt 1 le 1 gt 1 ge 1 eq 1 ne 1 cmp 1
                    & 1 | 1 ^ 1 neg 1 ! 1 ~ 1
                    ++ 1 -- 1 = 1
                    atan2 1 cos 1 sin 1 exp 1 abs 1 log 1 sqrt 1
                    bool 1 "" 1 0+ 1 ${} 1 @{} 1 %{} 1 &{} 1 *{} 1 <> 1
                    nomethod 1
    ]}

IFClsETDef:
  @IFQName: PerlCodeStatements
  @ClsQName: ManakaiPerlStatementContainer
  @CQName: ManakaiPCCodeStatements
  @ETQName:
    @@@: pc|statementContainer
    @@ImplNote:
      @@@lang:en
      @@@@: Dummy.

  @IFISA: PerlCodeUnits
  @ClsISA: ManakaiPerlAnyContainer
  @CISA: ManakaiPCCodeUnits
  @enDesc:
    A base class for node types that contains zero or more
    statements and/or blocks.

  @ATTR:
    @@Name: sourceFile
    @@ATTRQName: pc|sourceFile
    @@enDesc:
      The source file name of this fragment. 
    @@ReflectCDATA:
    @@Get:
      @@@enDesc:
        Any string identifying the source. 
      @@@nullCase:
        @@@@enDesc: No source file name is set. 
      @@@disDef:
        @@@@GetProp: sourceFile
        @@@@ForCheck: !pc|ForClass
    @@Set:
      @@@nullCase:
        @@@@enDesc: No (or unknown) source file. 
      @@@disDef:
        @@@@SetProp: sourceFile
        @@@@ForCheck: !pc|ForClass

  @ATTR:
    @@Name: sourceLine
    @@ATTRQName: pc|sourceLine
    @@enDesc:
      Source file line number of the first line of this fragment. 
    @@ReflectCDATA:
    @@Get:
      @@@disDef:
        @@@@GetProp: sourceLine
        @@@@ForCheck: pc|ForClassCompat
    @@Set:
      @@@disDef:
        @@@@SetProp: sourceLine
        @@@@ForCheck: pc|ForClassCompat

  @ATTR:
    @@Name: currentSourceFile
    @@ATTRQName: pc|currentSourceFile
    @@enDesc:
      The current source file name that is referred when 
      a code fragment is added. 
    @@ReflectCDATA:
    @@Get:
      @@@nullCase:
        @@@@enDesc: No source file name is set. 
      @@@disDef:
        @@@@GetProp:currentSourceFile
        @@@@ForCheck: pc|ForClassCompat
    @@Set:
      @@@nullCase:
        @@@@enDesc: No (or unknown) source file. 
      @@@disDef:
        @@@@SetProp:currentSourceFile
        @@@@ForCheck: pc|ForClassCompat

  @ATTR:
    @@Name: currentSourceLine
    @@ATTRQName: pc|currentSourceLine
    @@enDesc:
      The current line number in source file that is referred when 
      a code fragment is added. 
    @@ReflectCDATA:
    @@Get:
      @@@disDef:
        @@@@GetProp:currentSourceLine
        @@@@ForCheck: pc|ForClassCompat
    @@Set:
      @@@disDef:
        @@@@SetProp:currentSourceLine
        @@@@ForCheck: pc|ForClassCompat

  @Method:
    @@Name: appendCodeFragment
    @@enDesc:
      Appends a <Class::ManakaiPerlCodeFragment> object. 
    @@Param:
      @@@Name: codeArg
      @@@Type: PerlCode
      @@@caType: ManakaiPerlCodeFragment
      @@@enDesc:
        A code fragment object. 
    @@Return:
      @@@RaiseException:
        @@@@@:BAD_CHILD_ERR
        @@@@enDesc:
          An attempt is made to append a child
          that is not a <Class::ManakaiPerlUnparsedCode>.
      @@@RaiseException:
        @@@@@:IN_USE_NODE_ERR
        @@@@enDesc:
          An attempt is made to append a node that is 
          already used elsewhere. 
      @@@PerlDef:
        @@@@ForCheck: !pc|ForClass
        @@@@@:
        if ({
          unparsed => 1, if => 1, statement => 1, block => 1,
          blockcontainer => true,
          inunparsed => 1, variable => 1, bare => 1, atom => 1,
          incontainer => 1, string => 1, assign => 1,
        }->{$codeArg->{<H::mn:node>}->{<H::pc:nodeType>}}) {
          if ($codeArg->{<H::mn:node>}->{<H::pc:parent>}) {
            __EXCEPTION{IN_USE_NODE_ERR::
              pc:childNode => {$codeArg},
            }__;
          }
          $self->{<H::mn:node>}-><M::MNodeObject.importTree>
                                          ($codeArg->{<H::mn:node>});
          push @{$self->{<H::mn:node>}->{<H::pc:childNodes>}},
               $codeArg->{<H::mn:node>};
          $codeArg->{<H::mn:node>}->{<H::pc:parent>}
                                         = $self->{<H::mn:node>};
        } else {
          __EXCEPTION{BAD_CHILD_ERR::
            pc:parentNode => {$self},
            pc:childNode => {$codeArg},
          }__;
        }
      @@@PerlDef:
        @@@@ForCheck: pc|ForClass
        @@@@@:
          if ({
            unparsed => 1, if => 1, statement => 1, block => 1,
            blockContainer => true,
            inlineUnparsed => 1, variable => 1, tokens => 1, atom => 1,
            inlineContainer => 1, stringLiteral => 1, assignment => 1,
          }->{$codeArg-><AG::Node.localName>}) {
            if ($codeArg-><AG::Node.parentNode>) {
              __EXCEPTION{IN_USE_NODE_ERR::
                pc:childNode => {$codeArg},
                MDOMX:param-name => 'codeArg',
              }__;
            }
            __DEEP{
              $self-><AG::Node.ownerDocument>
                   -><M::Document.adoptNode> ($codeArg);
              $self-><M::Node.appendChild> ($codeArg);
            }__;
          } else {
            __EXCEPTION{BAD_CHILD_ERR::
              pc:parentNode => {$self},
              pc:childNode => {$codeArg},
              MDOMX:param-name => 'codeArg',
            }__;
          }

  @Method:
    @@Name: appendCode
    @@enDesc:
      Appends an unparsed Perl code fragment. 
    @@Param:
      @@@Name: codeArg
      @@@Type: DOMString
      @@@enDesc:
        An unparsed Perl code fragment. 
    @@Return:
      @@@Type: PerlUnparsedCode
      @@@enDesc:
        The newly created Perl code object. 
      @@@PerlDef:
        @@@@ForCheck: !pc|ForClass
        @@@@@:
        $r = <ClassM::ManakaiPerlUnparsedCode.newObject>;
        my $node = $self->{<H::mn:node>};
        $r->{<H::pc:sourceFile>} = $node->{<H::pc:currentSourceFile>};
        $r->{<H::pc:sourceLine>} = $node->{<H::pc:currentSourceLine>};
        $r->{<H::pc:code>} = $codeArg;
        $node->{<H::pc:currentSourceLine>} += ($codeArg =~ tr/\x0A/\x0A/);
        $node-><M::ManakaiDOM:ManakaiDOMNodeObject
                 ::ManakaiDOM:Perl.importTree> ($r);
        push @{$node->{<H::pc:childNodes>}}, $r;
        $r->{<H::pc:parent>} = $node;
        __CODE{ManakaiNode:getNewReference||ManakaiDOM|Perl::
          $object => $r, $ref => $r,
          $class =>{<ClassName::ManakaiPerlUnparsedCode>},
        }__;
      @@@PerlDef:
        @@@@ForCheck: pc|ForClass
        @@@@@:
          __DEEP{
            $r = $self-><AG::Node.ownerDocument>-><M::Document.createElementNS>
                                                      (<Q::pc:>, 'unparsed');
            $r-><AS::Node.textContent> ($codeArg);
            $r-><AS::PerlCodeStatements.sourceFile>
               ($self-><AG::PerlCodeStatements.currentSourceFile>);
            my $sl = $self-><AG::PerlCodeStatements.currentSourceLine>;
            $r-><AS::PerlCodeStatements.sourceLine> ($sl);
            $self-><AG::PerlCodeStatements.currentSourceLine>
                      ($sl + ($codeArg =~ tr/\x0A/\x0A/));
            $self-><M::Node.appendChild> ($r);
          }__;

  @Method:
    @@Name: skipLines
    @@enDesc:
      Skips lines in a code. 
    @@Param:
      @@@Name: codeArg
      @@@Type: DOMString
      @@@enDesc:
        A code fragment, which is counted lines. 
    @@Return:
      @@@PerlDef:
        $self->{<H::mn:node>}->{<H::pc:currentSourceLine>}
                            += ($codeArg =~ tr/\x0A/\x0A/);

  @ImplNote:
    @@lang:en
    @@@:
      A <Class::ManakaiPerlStatementContainer> object must have
      a property:
        <Q::pc:childNodes>.
    @@ForCheck: pc|ForClassCompat

  @ATTR:
    @@Name: label
    @@ATTRQName: pc|label
    @@enDesc:
      Label for this block.
    @@ReflectCDATA:
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          No label.
      @@@disDef:
        @@@@GetProp:label
        @@@@ForCheck: pc|ForClassCompat
    @@Set:
      @@@nullCase:
        @@@@enDesc:
          No label.
      @@@disDef:
        @@@@SetProp:label
        @@@@ForCheck: pc|ForClassCompat

  @Method:
    @@Name: appendBlock
    @@enDesc:
      Appends a Perl block code.
    @@Return:
      @@@Type: PerlBlock
      @@@enDesc:
        The newly created Perl code object. 
      @@@PerlDef:
        @@@@ForCheck: !pc|ForClass
        @@@@@:
        $r = <ClassM::ManakaiPerlBlock.newObject>;
        my $node = $self->{<H::mn:node>};
        $node-><M::ManakaiDOM:ManakaiDOMNodeObject
                 ::ManakaiDOM:Perl.importTree> ($r);
        push @{$node->{<H::pc:childNodes>}}, $r;
        $r->{<H::pc:parent>} = $node;
        if (defined wantarray) {
          __CODE{ManakaiNode:getNewReference||ManakaiDOM|Perl::
            $object => $r, $ref => $r,
            $class =>{<ClassName::ManakaiPerlBlock>},
          }__;
        }
      @@@PerlDef:
        @@@@ForCheck: pc|ForClass
        @@@@@:
          __DEEP{
            $r = $self-><AG::Node.ownerDocument>-><M::Document.createElementNS>
                                                         (<Q::pc:>, 'block');
            $self-><M::Node.appendChild> ($r);
          }__;

  @Method:
    @@Name: appendStatement
    @@enDesc:
      Appends a Perl statement.
    @@Param:
      @@@Name: codeArg
      @@@Type:
        lang:Perl::ManakaiDOM:all
      @@@enDesc:
        A Perl statement without terminating <Perl::;>.
      @@@nullCase:
        @@@@enDesc:
          No initial content.
    @@Return:
      @@@Type: PerlStatement
      @@@caType: ManakaiPerlStatement
      @@@enDesc:
        The newly created Perl code object. 
      @@@PerlDef:
        @@@@ForCheck: !pc|ForClass
        @@@@@:
        $r = <ClassM::ManakaiPerlStatement.newObject>;
        my $node = $self->{<H::mn:node>};
        $node-><M::ManakaiDOM:ManakaiDOMNodeObject
                 ::ManakaiDOM:Perl.importTree> ($r);
        push @{$node->{<H::pc:childNodes>}}, $r;
        $r->{<H::pc:parent>} = $node;
        if (defined wantarray or defined $codeArg) {
          __CODE{ManakaiNode:getNewReference||ManakaiDOM|Perl::
            $object => $r, $ref => $r,
            $class =>{<ClassName::ManakaiPerlStatement>},
          }__;
          if (defined $codeArg) {
            __DEEP{
              $r-><M::ManakaiPerlAnyContainer.appendBare> ($codeArg);
            }__;
          }
        }
      @@@PerlDef:
        @@@@ForCheck: pc|ForClass
        @@@@@:
          __DEEP{
            $r = $self-><AG::Node.ownerDocument>-><M::Document.createElementNS>
                                                         (<Q::pc:>, 'statement');
            if (defined $codeArg) {
              $r-><M::PerlCodeUnits.appendBare> ($codeArg);
            }
            $self-><M::Node.appendChild> ($r);
          }__;

  @Method:
    @@Name: appendNewIf
    @@enDesc:
      Appends a newly created <Class::ManakaiPerlIf> object. 
    @@Param:
      @@@Name: conditionArg
      @@@Type: PerlCode
      @@@enDesc:
        Conditoon code fragment object.
    @@Param:
      @@@Name: trueArg
      @@@Type: PerlCode
      @@@enDesc:
        A true code fragment object. 
      @@@nullCase:
        @@@@enDesc: No true code.
    @@Param:
      @@@Name: falseArg
      @@@Type: PerlCode
      @@@enDesc:
        A false code fragment object. 
      @@@nullCase:
        @@@@enDesc: No false code.
    @@Return:
      @@@Type:
        @@@@@: PerlIf
        @@@@ForCheck: !pc|ForClassCompat
      @@@enDesc:
        The newly created element.
      @@@RaiseException:
        @@@@@:BAD_CHILD_ERR
        @@@@enDesc:
          An attempt is made to append a child
          that is not valid type.
      @@@RaiseException:
        @@@@@:IN_USE_NODE_ERR
        @@@@enDesc:
          An attempt is made to append a node that is 
          already used elsewhere. 
      @@@PerlDef:
        @@@@ForCheck: !pc|ForClass
        @@@@@:
        for my $arg ([conditionArg => $conditionArg]) {
          if ({
            atom => 1, bare => 1, incontainer => 1, assign => true,
            inunparsed => 1, variable => 1, string => true,
          }->{$arg->[1]->{<H::mn:node>}->{<H::pc:nodeType>}}) {
            if ($arg->[1]->{<H::mn:node>}->{<H::pc:parent>}) {
              __EXCEPTION{IN_USE_NODE_ERR::
                pc:childNode => {$arg->[1]},
                MDOMX:param-name => {$arg->[0]},
              }__;
            }
          } else {
            __EXCEPTION{BAD_CHILD_ERR::
              pc:parentNode => {$self},
              pc:childNode => {$arg->[1]},
              MDOMX:param-name => {$arg->[0]},
            }__;
          }
        } # c

        for my $arg ([trueArg => $trueArg],
                     [falseArg => $falseArg]) {
          next unless $arg->[1];
          if ({
                blockcontainer => true,
              }->{$arg->[1]->{<H::mn:node>}->{<H::pc:nodeType>}}) {
            if ($arg->[1]->{<H::mn:node>}->{<H::pc:parent>}) {
              __EXCEPTION{IN_USE_NODE_ERR::
                pc:childNode => {$arg->[1]},
                MDOMX:param-name => {$arg->[0]},
              }__;
            }
          } else {
            __EXCEPTION{BAD_CHILD_ERR::
              pc:parentNode => {$self},
              pc:childNode => {$arg->[1]},
              MDOMX:param-name => {$arg->[0]},
            }__;
          }
        } # t/f

        my $assign = <ClassM::ManakaiPerlIf.newObject>;
        $assign->{<H::pc:condition>} = $conditionArg->{<H::mn:node>};
        $assign->{<H::pc:true>} = $trueArg->{<H::mn:node>} if $trueArg;
        $assign->{<H::pc:false>} = $falseArg->{<H::mn:node>} if $falseArg;
        $conditionArg->{<H::mn:node>}->{<H::pc:parent>} = $assign;
        $trueArg->{<H::mn:node>}->{<H::pc:parent>} = $assign if $trueArg;
        $falseArg->{<H::mn:node>}->{<H::pc:parent>} = $assign if $falseArg;
        $self->{<H::mn:node>}-><M::MNodeObject.importTree> ($assign);
        $assign->{<H::pc:parent>} = $self->{<H::mn:node>};
        push @{$self->{<H::mn:node>}->{<H::pc:childNodes>}}, $assign;
      @@@PerlDef:
        @@@@ForCheck: pc|ForClass
        @@@@@:
          for my $arg ([conditionArg => $conditionArg]) {
            if ({
              atom => 1, tokens => 1, inlineContainer => 1, assignment => true,
              inlineUnparsed => 1, variable => 1, stringLiteral => true,
            }->{$arg->[1]-><AG::Node.localName>}) {
              if ($arg->[1]-><AG::Node.parentNode>) {
                __EXCEPTION{IN_USE_NODE_ERR::
                  pc:childNode => {$arg->[1]},
                  MDOMX:param-name => {$arg->[0]},
                }__;
              }
            } else {
              __EXCEPTION{BAD_CHILD_ERR::
                pc:parentNode => {$self},
                pc:childNode => {$arg->[1]},
                MDOMX:param-name => {$arg->[0]},
              }__;
            }
          } # c

          for my $arg ([trueArg => $trueArg],
                       [falseArg => $falseArg]) {
            next unless $arg->[1];
            if ({
                  blockContainer => true,
                }->{$arg->[1]-><AG::Node.localName>}) {
              if ($arg->[1]-><AG::Node.parentNode>) {
                __EXCEPTION{IN_USE_NODE_ERR::
                  pc:childNode => {$arg->[1]},
                  MDOMX:param-name => {$arg->[0]},
                }__;
              }
            } else {
              __EXCEPTION{BAD_CHILD_ERR::
                pc:parentNode => {$self},
                pc:childNode => {$arg->[1]},
                MDOMX:param-name => {$arg->[0]},
              }__;
            }
          } # t/f

          __DEEP{
            $r = $self-><AG::Node.ownerDocument>-><M::Document.createElementNS>
                                                   (<Q::pc:>, 'if');
            $r-><AS::PerlIf.condition> ($conditionArg);
            $r-><AS::PerlIf.trueCode> ($trueArg) if $trueArg;
            $r-><AS::PerlIf.falseCode> ($falseArg) if $falseArg;
            $self-><M::Node.appendChild> ($r);
          }__;
##PCIf

IFClsETDef:
  @IFQName: PerlSub
  @ClsQName: ManakaiPerlSub
  @CQName: ManakaiPCSub
  @ETQName: pc|sub

  @IFISA: PerlCode

  @IFISA: PerlCodeStatements
  @ClsISA: ManakaiPerlStatementContainer
  @CISA: ManakaiPCCodeStatements

  @enDesc:
    Perl subroutines. 
  
  @IntMethod:
    @@ForCheck: ManakaiDOM|ForClass !pc|ForClass
    @@Name:newObject
    @@ManakaiDOM:isStatic:1
    @@Description:
      @@@lang:en
      @@@@:
        Creates a new instance object for <Class::ManakaiPerlSub>. 
    @@Return:
      @@@Type:
        ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl
      @@@Description:
        @@@@lang:en
        @@@@@:
          The newly created node object.
      @@@PerlDef:
        @@@@@:
          my $node = $r = <ClassM::ManakaiDOM:ManakaiDOMNodeObject
                                        ::ManakaiDOM:Perl.new>;
          push @{$node->{<Q::TreeCore:subnode>}}, <H::pc:childNodes>;
          push @{$node->{<Q::TreeCore:origin>}}, <H::pc:parent>;
          $node->{<H::pc:childNodes>} = [];
          $node->{<H::pc:sourceLine>} = 0;
          $node->{<H::pc:nodeType>} = 'sub';
        @@@@ImplNote:
          @@@@@lang:en
          @@@@@@:
            Optional properties: <Q::pc:localName>, <Q::pc:useCharClassName>, 
               <Q::pc:sourceFile>, <Q::pc:sourceLine>,
               <Q::pc:nodeType>, <Q::pc:useModuleName>, 
               <Q::pc:requireResourceURI>, <Q::pc:requireModuleName>,
               <Q::pc:prototype>.

  @IntCloneMethod:
    @@Return:
      @@@Type:
        ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl
      @@@PerlDef:
          my $node = $r = <ClassM::ManakaiDOM:ManakaiDOMNodeObject
                                        ::ManakaiDOM:Perl.new>;
          $node->{<H::pc:nodeType>} = 'sub';
          push @{$node->{<Q::TreeCore:origin>}}, <H::pc:parent>;
          push @{$node->{<Q::TreeCore:subnode>}}, <H::pc:childNodes>;
          for my $prop (<H::pc:sourceFile>, <H::pc:sourceLine>,
                        <H::pc:localName>, <H::pc:prototype>) {
            $node->{$prop} = $nodeObject->{$prop};
          }
          $node->{<H::pc:requireResourceURI>}
             = {%{$nodeObject->{<H::pc:requireResourceURI>} || {}}};
          $node->{<H::pc:useModuleName>}
             = {%{$nodeObject->{<H::pc:useModuleName>} || {}}};
          $node->{<H::pc:useCharClassName>}
             = {map {$_ => {%{$nodeObject->{<H::pc:useCharClassName>}->{$_}}}}
                keys %{$nodeObject->{<H::pc:useCharClassName>} || {}}};
          $node->{<H::pc:requireModuleName>}
             = {%{$nodeObject->{<H::pc:requireModuleName>} || {}}};
          $node->{<H::pc:childNodes>} = [];
          for my $cno (@{$nodeObject->{<H::pc:childNodes>}}) {
            my $pack;
            my $nt = $cno->{<H::pc:nodeType>};
            __CODE{pc:nodeTypeToPackageName::
                     $nodeType => $nt, $packageName => $pack, $object => $cno}__;
                                 ## NOTE: Method name written directly
            my $cno_clone = $pack->_make_clone_object ($cno);
            push @{$node->{<H::pc:childNodes>}}, $cno_clone;
            $cno_clone->{<H::pc:parent>} = $node;
            ## NOTE: Tree ID is not updated yet.
          }

  @Attr:
    @@Name: pcLocalName
    @@enDesc:
      The name of this subroutine. 
    @@Type: DOMString
    @@Get: 
      @@@nullCase:
        @@@@enDesc:
          This subroutine has no name. 
      @@@disDef:
        @@@@GetProp: localName
        @@@@ForCheck: pc|ForClassCompat
      @@@PerlDef:
        @@@@ForCheck: pc|ForClass
        @@@@@:
          __DEEP{
            $r = $self-><M::PerlSub.getPerlNameList>->[0];
          }__;
    @@Set:
      @@@ForCheck: pc|ForClassCompat
      @@@enDesc:
        Sets the name of this subroutine. 
        \
        {NOTE:: Setting this attribute does not change the 
                name by which the subroutine is registerred to 
                the parent object.
        \
        }
      @@@nullCase:
        @@@@enDesc:
          This subroutine has no name. 
      @@@disDef:
        @@@@SetProp: localName

  @Method:
    @@ForCheck: !pc|ForClassCompat
    @@Name: addPerlName
    @@enDesc:
      Adds a subroutine name.
    @@Param:
      @@@Name: subName
      @@@Type: DOMString
      @@@enDesc: The name to add.
    @@Return:
      @@@PerlDef:
        __DEEP{
          __CODE{addNameListAttr::
            $node => {$self},
            $attrName => 'localName',
            $newName => {$subName},
          }__;
        }__;

  @Method:
    @@ForCheck: !pc|ForClassCompat
    @@Name: getPerlNameList
    @@enDesc:
      Returns a list of names of the subroutine.
    @@Return:
      @@@Type: DISPerl|ARRAY||ManakaiDOM|all
      @@@enDesc:
        An unordered snapshot list of names.
      @@@PerlDef:
        __DEEP{
          __CODE{getNameListAttr::
            $node => {$self},
            $attrName => 'localName',
            $result => {$r},
          }__;
        }__;

  @Method:
    @@ForCheck: !pc|ForClassCompat
    @@Name: hasPerlName
    @@enDesc:
      Returns whether the subroutine has a name or not.
    @@Param:
      @@@Name: subName
      @@@Type: DOMString
      @@@enDesc: The name.
    @@Return:
      @@@Type: idl|boolean||ManakaiDOM|all
      @@@PerlDef:
        __DEEP{
          my $l;
          __CODE{getNameListAttr::
            $node => {$self},
            $attrName => 'localName',
            $result => {$l},
          }__;
          F: for (@$l) {
            if ($_ eq $subName) {
              $r = true;
              last F;
            }
          }
        }__;

  @Method:
    @@ForCheck: !pc|ForClassCompat
    @@Name: addPerlOperator
    @@enDesc:
      Adds an operator overloaded by the method.
    @@Param:
      @@@Name: op
      @@@Type: DOMString
      @@@enDesc: The operator to add.
    @@Return:
      @@@PerlDef:
        __DEEP{
          __CODE{addNameListAttr::
            $node => {$self},
            $attrName => 'operator',
            $newName => {$op},
          }__;
        }__;

  @Method:
    @@ForCheck: !pc|ForClassCompat
    @@Name: getPerlOperatorList
    @@enDesc:
      Returns a list of operators of the subroutine.
    @@Return:
      @@@Type: DISPerl|ARRAY||ManakaiDOM|all
      @@@enDesc:
        An unordered snapshot list of operators.
      @@@PerlDef:
        __DEEP{
          __CODE{getNameListAttr::
            $node => {$self},
            $attrName => 'operator',
            $result => {$r},
          }__;
        }__;

  @Method:
    @@ForCheck: !pc|ForClassCompat
    @@Name: hasPerlOperator
    @@enDesc:
      Returns whether the subroutine has an operator or not.
    @@Param:
      @@@Name: op
      @@@Type: DOMString
      @@@enDesc: The operator.
    @@Return:
      @@@Type: idl|boolean||ManakaiDOM|all
      @@@PerlDef:
        __DEEP{
          my $l;
          __CODE{getNameListAttr::
            $node => {$self},
            $attrName => 'operator',
            $result => {$l},
          }__;
          F: for (@$l) {
            if ($_ eq $op) {
              $r = true;
              last F;
            }
          }
        }__;

  @ATTR:
    @@Name: prototype
    @@ATTRQName: pc|prototype
    @@enDesc:
      The prototype of this subroutine. 
    @@ReflectCDATA:
    @@Get:
      @@@disDef:
        @@@@GetProp: prototype
        @@@@ForCheck: pc|ForClassCompat
      @@@nullCase:
        @@@@enDesc:
          No prototype is set. 
    @@Set:
      @@@disDef:
        @@@@SetProp: prototype
        @@@@ForCheck: pc|ForClassCompat
      @@@nullCase:
        @@@@enDesc:
          No prototype declaration. 
  
  @ToStringMethod:
    @@Return:
      @@@Type: DOMString
      @@@enDesc:
        Perl code. 
      @@@PerlDef:
        @@@@ForCheck: !pc|ForClass
        @@@@@:
        my $node = $self->{<H::mn:node>};
        $r = q<sub>;
        $r .= ' ' . $node->{<H::pc:localName>}
                if defined $node->{<H::pc:localName>};
        $r .= ' (' . $node->{<H::pc:prototype>} . ')'
                if defined $node->{<H::pc:prototype>};
        $r .= " {\n";
        for my $cno (@{$node->{<H::pc:childNodes>}}) {
          my $cn = <ClassM::ManakaiPerlCodeFragment.getNodeReference> ($cno);
          $r .= $cn->stringify;
        }
        $r .= "}\n";
      @@@PerlDef:
        @@@@ForCheck: pc|ForClass
        @@@@@:
          __DEEP{
            $r = q<sub>;
            my $nm = $self-><M::PerlSub.getPerlNameList>;
            $r .= q< > . $nm->[0] if @$nm;
            my $pt = $self-><AG::PerlSub.prototype>;
            $r .= q< (> . $pt . q<)> if length $pt;
            $r .= qq< {\n>;
            for my $child (@{$self-><AG::Node.childNodes>}) {
              $r .= $child->stringify;
            }
            $r .= qq<}\n>;
          }__;

  @NumValMethod:
    @@Return:
      @@@Type: idl|unsignedLong||ManakaiDOM|all
      @@@PerlDef:
        @@@@ForCheck: !pc|ForClass
        @@@@@:
        my $cno = $self->{<H::mn:node>}->{<H::pc:childNodes>}->[-1];
        if ($cno) {
          my $cn = <ClassM::ManakaiPerlCodeFragment.getNodeReference> ($cno);
          $r = 0 + $cn;
        }
      @@@PerlDef:
        @@@@ForCheck: pc|ForClass
        @@@@@:
          __DEEP{
            $r = 0 + $self-><AG::Node.lastChild>;
          }__;
##PCSub

XParamDef:
  @QName: parentNode
  @enDesc:
    Parent node. 

XParamDef:
  @QName: childNode
  @enDesc:
    Child node. 

IFClsETDef:
  @IFQName: PerlUnparsedCode
  @ClsQName: ManakaiPerlUnparsedCode
  @CQName: ManakaiPCUnparsedCode
  @ETQName: pc|unparsed

  @IFISA: PerlCode
  @ClsISA: ManakaiPerlCodeFragment
  @CISA: ManakaiPCCode

  @enDesc:
    Unparsed Perl code fragments. 
  
  @IntMethod:
    @@ForCheck: ManakaiDOM|ForClass !pc|ForClass
    @@Name:newObject
    @@ManakaiDOM:isStatic:1
    @@Description:
      @@@lang:en
      @@@@:
        Creates a new instance object for <Class::ManakaiPerlUnparsedCode>. 
    @@Return:
      @@@Type:
        ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl
      @@@Description:
        @@@@lang:en
        @@@@@:
          The newly created node object.
      @@@PerlDef:
        @@@@@:
          my $node = $r = <ClassM::ManakaiDOM:ManakaiDOMNodeObject
                                        ::ManakaiDOM:Perl.new>;
          push @{$node->{<Q::TreeCore:origin>}}, <H::pc:parent>;
          $node->{<H::pc:code>} = '';
          $node->{<H::pc:nodeType>} = 'unparsed';
        @@@@ImplNote:
          @@@@@lang:en
          @@@@@@:
            Properties: <Q::pc:nodeType>, <Q::pc:code>,
                        <Q::pc:sourceFile>, <Q::pc:sourceLine>,
               <Q::pc:useModuleName>, <Q::pc:useCharClassName>,  
               <Q::pc:requireResourceURI>, <Q::pc:requireModuleName>.

  @IntCloneMethod:
    @@Return:
      @@@Type:
        ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl
      @@@PerlDef:
          my $node = $r = <ClassM::ManakaiDOM:ManakaiDOMNodeObject
                                        ::ManakaiDOM:Perl.new>;
          push @{$node->{<Q::TreeCore:origin>}}, <H::pc:parent>;
          for my $prop (<H::pc:sourceFile>, <H::pc:sourceLine>, <H::pc:code>) {
            $node->{$prop} = $nodeObject->{$prop};
          }
          $node->{<H::pc:nodeType>} = 'unparsed';
          $node->{<H::pc:requireResourceURI>}
             = {%{$nodeObject->{<H::pc:requireResourceURI>} || {}}};
          $node->{<H::pc:useModuleName>}
             = {%{$nodeObject->{<H::pc:useModuleName>} || {}}};
          $node->{<H::pc:useCharClassName>}
             = {map {$_ => {%{$nodeObject->{<H::pc:useCharClassName>}->{$_}}}}
                keys %{$nodeObject->{<H::pc:useCharClassName>} || {}}};
          $node->{<H::pc:requireModuleName>}
             = {%{$nodeObject->{<H::pc:requireModuleName>} || {}}};

  @Attr:
    @@Name: code
    @@enDesc:
      Perl code. 
    @@Type: DOMString
    @@Get:
      @@@disDef:
        @@@@GetProp: code
        @@@@ForCheck: !pc|ForClass
      @@@disDef:
        @@@@DISPerl:cloneCode: DOMCore|ManakaiDOMNode.textContent.get
        @@@@ForCheck: pc|ForClass
    @@Set:
      @@@disDef:
        @@@@SetProp: code
        @@@@ForCheck: !pc|ForClass
      @@@disDef:
        @@@@DISPerl:cloneCode: DOMCore|ManakaiDOMNode.textContent.set
        @@@@ForCheck: pc|ForClass

  @ATTR:
    @@Name: sourceFile
    @@ATTRQName: pc|sourceFile
    @@enDesc:
      The source file name of this fragment. 
    @@ReflectCDATA:
    @@Get:
      @@@enDesc:
        Any string identifying the source. 
      @@@nullCase:
        @@@@enDesc: No source file name is set. 
      @@@disDef:
        @@@@GetProp: sourceFile
        @@@@ForCheck: !pc|ForClass
    @@Set:
      @@@nullCase:
        @@@@enDesc: No (or unknown) source file. 
      @@@disDef:
        @@@@SetProp: sourceFile
        @@@@ForCheck: !pc|ForClass

  @ATTR:
    @@Name: sourceLine
    @@ATTRQName: pc|sourceLine
    @@enDesc:
      Source file line number of the first line of this fragment. 
    @@ReflectCDATA:
    @@Get:
      @@@disDef:
        @@@@GetProp: sourceLine
        @@@@ForCheck: !pc|ForClass
    @@Set:
      @@@disDef:
        @@@@SetProp: sourceLine
        @@@@ForCheck: !pc|ForClass

  @ToStringMethod:
    @@Return:
      @@@Type: DOMString
      @@@enDesc:
        Perl code. 
      @@@PerlDef:
        @@@@ForCheck: !pc|ForClass
        @@@@@:
        my $node = $self->{<H::mn:node>};
        __DEEP{
          my $file = $self-><AG::ManakaiPerlCodeFragment.fileNode>;
          $r = sprintf (qq<\n#line %d "%s [u] (Chunk #%d)"\n>,
                        $node->{<H::pc:sourceLine>} || 1,
                        $node->{<H::pc:sourceFile>} ||
                          $file-><AG::ManakaiPerlFile.sourceFile>,
                        $file-><M::ManakaiPerlFile.getNextChunkNumber>)
             . $node->{<H::pc:code>}
             . sprintf (qq<\n#line 1 "%s [/u] (Chunk #%d)"\n>,
                        $file-><AG::ManakaiPerlFile.sourceFile>,
                        $file-><M::ManakaiPerlFile.getNextChunkNumber>);
        }__;
      @@@PerlDef:
        @@@@ForCheck: pc|ForClass
        @@@@@:
          __DEEP{
            $r = $self-><AG::Node.textContent>;
            my $file = $self-><AG::PerlCode.fileNode>;
            my $src_file = $file ? $file-><AG::PerlFile.sourceFile> : '';
            my $nxt_cnum = $file ? $file-><M::PerlFile.getNextChunkNumber> : 0;
            $r = sprintf qq<\n#line %d "%s [u] (Chunk #%d)"\n%s>.
                         qq<\n#line 1 "%s [/u] (Chunk #%d)"\n>,
                         $self-><AG::PerlUnparsedCode.sourceLine> || 1,
                         $self-><AG::PerlUnparsedCode.sourceFile> || $src_file,
                         $file ? $file-><M::PerlFile.getNextChunkNumber> : 0,
                         $self-><AG::Node.textContent>,
                         $src_file,
                         $file ? $file-><M::PerlFile.getNextChunkNumber> : 0;
          }__;
##PerlUnparsedCode

IFClsETDef:
  @IFQName: PerlInlineUnparsedCode
  @ClsQName: ManakaiPerlInlineUnparsedCode
  @CQName: ManakaiPCInlineUnparsedCode
  @ETQName: pc|inlineUnparsed

  @IFISA: PerlCode
  @ClsISA: ManakaiPerlCodeFragment
  @CISA: ManakaiPCCode

  @enDesc:
    Unparsed Perl inline code fragments. 
  
  @IntMethod:
    @@ForCheck: ManakaiDOM|ForClass !pc|ForClass
    @@Name:newObject
    @@ManakaiDOM:isStatic:1
    @@Description:
      @@@lang:en
      @@@@:
        Creates a new instance object for
        <Class::ManakaiPerlInlineUnparsedCode>. 
    @@Return:
      @@@Type:
        ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl
      @@@Description:
        @@@@lang:en
        @@@@@:
          The newly created node object.
      @@@PerlDef:
        @@@@@:
          my $node = $r = <ClassM::ManakaiDOM:ManakaiDOMNodeObject
                                        ::ManakaiDOM:Perl.new>;
          push @{$node->{<Q::TreeCore:origin>}}, <H::pc:parent>;
          $node->{<H::pc:code>} = '';
          $node->{<H::pc:nodeType>} = 'inunparsed';
        @@@@ImplNote:
          @@@@@lang:en
          @@@@@@:
            Properties: <Q::pc:nodeType>, <Q::pc:code>, <Q::pc:useModuleName>, 
               <Q::pc:useCharClassName>, 
               <Q::pc:requireResourceURI>, <Q::pc:requireModuleName>.

  @IntCloneMethod:
    @@Return:
      @@@Type:
        ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl
      @@@PerlDef:
          my $node = $r = <ClassM::ManakaiDOM:ManakaiDOMNodeObject
                                        ::ManakaiDOM:Perl.new>;
          push @{$node->{<Q::TreeCore:origin>}}, <H::pc:parent>;
          for my $prop (<H::pc:code>) {
            $node->{$prop} = $nodeObject->{$prop};
          }
          $node->{<H::pc:nodeType>} = 'inunparsed';
          $node->{<H::pc:requireResourceURI>}
             = {%{$nodeObject->{<H::pc:requireResourceURI>} || {}}};
          $node->{<H::pc:useModuleName>}
             = {%{$nodeObject->{<H::pc:useModuleName>} || {}}};
          $node->{<H::pc:useCharClassName>}
             = {map {$_ => {%{$nodeObject->{<H::pc:useCharClassName>}->{$_}}}}
                keys %{$nodeObject->{<H::pc:useCharClassName>} || {}}};
          $node->{<H::pc:requireModuleName>}
             = {%{$nodeObject->{<H::pc:requireModuleName>} || {}}};

  @Attr:
    @@Name: code
    @@enDesc:
      Perl code. 
    @@Type: DOMString
    @@Get:
      @@@disDef:
        @@@@GetProp: code
        @@@@ForCheck: !pc|ForClass
      @@@disDef:
        @@@@DISPerl:cloneCode: DOMCore|ManakaiDOMNode.textContent.get
        @@@@ForCheck: pc|ForClass
    @@Set:
      @@@disDef:
        @@@@SetProp: code
        @@@@ForCheck: !pc|ForClass
      @@@disDef:
        @@@@DISPerl:cloneCode: DOMCore|ManakaiDOMNode.textContent.set
        @@@@ForCheck: pc|ForClass

  @ToStringMethod:
    @@Return:
      @@@Type:
        DISLang:String::ManakaiDOM:all
      @@@enDesc:
        Perl code. 
      @@@PerlDef:
        @@@@ForCheck: !pc|ForClass
        @@@@@:
        my $node = $self->{<H::mn:node>};
        $r = $node->{<H::pc:code>};
      @@@PerlDef:
        @@@@ForCheck: pc|ForClass
        @@@@@:
          __DEEP{
            $r = $self-><AG::Node.textContent>;
          }__;
##PerlInlineUnparsedCode

IFClsETDef:
  @IFQName: PerlStringLiteral
  @ClsQName: ManakaiPerlStringLiteral
  @CQName: ManakaiPCPerlStringLiteral
  @ETQName: pc|stringLiteral

  @IFISA: PerlCode
  @ClsISA: ManakaiPerlCodeFragment
  @CISA: ManakaiPCCode

  @enDesc:
    Perl string literal.
  
  @IntMethod:
    @@ForCheck: ManakaiDOM|ForClass !pc|ForClass
    @@Name:newObject
    @@ManakaiDOM:isStatic:1
    @@Description:
      @@@lang:en
      @@@@:
        Creates a new instance object for
        <Class::ManakaiPerlStringLiteral>. 
    @@Return:
      @@@Type:
        ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl
      @@@Description:
        @@@@lang:en
        @@@@@:
          The newly created node object.
      @@@PerlDef:
        @@@@@:
          my $node = $r = <ClassM::ManakaiDOM:ManakaiDOMNodeObject
                                        ::ManakaiDOM:Perl.new>;
          push @{$node->{<Q::TreeCore:origin>}}, <H::pc:parent>;
          $node->{<H::infoset:content>} = '';
          $node->{<H::pc:nodeType>} = 'string';
        @@@@ImplNote:
          @@@@@lang:en
          @@@@@@:
            Properties: <Q::pc:nodeType>, <Q::pc:useCharClassName>, 
               <Q::infoset:content>, <Q::pc:useModuleName>, 
               <Q::pc:requireResourceURI>, <Q::pc:requireModuleName>.

  @IntCloneMethod:
    @@Return:
      @@@Type:
        ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl
      @@@PerlDef:
          my $node = $r = <ClassM::ManakaiDOM:ManakaiDOMNodeObject
                                        ::ManakaiDOM:Perl.new>;
          push @{$node->{<Q::TreeCore:origin>}}, <H::pc:parent>;
          for my $prop (<H::infoset:content>) {
            $node->{$prop} = $nodeObject->{$prop};
          }
          $node->{<H::pc:nodeType>} = 'string';
          $node->{<H::pc:requireResourceURI>}
             = {%{$nodeObject->{<H::pc:requireResourceURI>} || {}}};
          $node->{<H::pc:useModuleName>}
             = {%{$nodeObject->{<H::pc:useModuleName>} || {}}};
          $node->{<H::pc:useCharClassName>}
             = {map {$_ => {%{$nodeObject->{<H::pc:useCharClassName>}->{$_}}}}
                keys %{$nodeObject->{<H::pc:useCharClassName>} || {}}};
          $node->{<H::pc:requireModuleName>}
             = {%{$nodeObject->{<H::pc:requireModuleName>} || {}}};

  @Attr:
    @@Name: data
    @@enDesc:
      String data. 
    @@Type: DOMString
    @@Get:
      @@@disDef:
        @@@@GetProp: infoset|content
        @@@@ForCheck: !pc|ForClass
      @@@disDef:
        @@@@DISPerl:cloneCode: DOMCore|ManakaiDOMNode.textContent.get
        @@@@ForCheck: pc|ForClass
    @@Set:
      @@@disDef:
        @@@@SetProp: infoset|content
        @@@@ForCheck: !pc|ForClass
      @@@disDef:
        @@@@DISPerl:cloneCode: DOMCore|ManakaiDOMNode.textContent.set
        @@@@ForCheck: pc|ForClass

  @NumValMethod:
    @@Return:
      @@@Type: idl|unsignedLong||ManakaiDOM|all
      @@@enDesc:
        Numeric value of the Perl code. 
      @@@PerlDef:
        @@@@ForCheck: !pc|ForClass
        @@@@@:
        $r = 0 + $self->{<H::mn:node>}->{<H::infoset:content>};
      @@@PerlDef:
        @@@@ForCheck: pc|ForClass
        @@@@@:
          __DEEP{
            $r = 0 + $self-><AG::Node.textContent>;
          }__;

  @ToStringMethod:
    @@Return:
      @@@Type: DOMString
      @@@enDesc:
        Perl code. 
      @@@PerlDef:
        @@@@ForCheck: !pc|ForClass
        @@@@@:
        my $node = $self->{<H::mn:node>};
        $r = $node->{<H::infoset:content>};
        $r =~ s/(['\\])/\\$1/g;
        $r = q<'> . $r . q<'>;
      @@@PerlDef:
        @@@@ForCheck: pc|ForClass
        @@@@@:
          __DEEP{
            $r = $self-><AG::Node.textContent>;
            $r =~ s/(['\\])/\\$1/g;
            $r = q<'> . $r . q<'>;
          }__;
##PerlStringLiteral

IFClsETDef:
  @IFQName: PerlTokens
  @ClsQName: ManakaiPerlBare
  @CQName: ManakaiPCTokens
  @ETQName: pc|tokens

  @IFISA: PerlCode
  @ClsISA: ManakaiPerlCodeFragment
  @CISA: ManakaiPCCode

  @enDesc:
    Unparsed Perl inline code fragments. 
  
  @IntMethod:
    @@ForCheck: ManakaiDOM|ForClass !pc|ForClass
    @@Name:newObject
    @@ManakaiDOM:isStatic:1
    @@Description:
      @@@lang:en
      @@@@:
        Creates a new instance object for
        <Class::ManakaiPerlInlineBare>. 
    @@Return:
      @@@Type:
        ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl
      @@@Description:
        @@@@lang:en
        @@@@@:
          The newly created node object.
      @@@PerlDef:
        @@@@@:
          my $node = $r = <ClassM::ManakaiDOM:ManakaiDOMNodeObject
                                        ::ManakaiDOM:Perl.new>;
          push @{$node->{<Q::TreeCore:origin>}}, <H::pc:parent>;
          $node->{<H::pc:code>} = '';
          $node->{<H::pc:nodeType>} = 'bare';
        @@@@ImplNote:
          @@@@@lang:en
          @@@@@@:
            Properties: <Q::pc:nodeType>, <Q::pc:code>, <Q::pc:useModuleName>, 
               <Q::pc:useCharClassName>, 
               <Q::pc:requireResourceURI>, <Q::pc:requireModuleName>.

  @IntCloneMethod:
    @@Return:
      @@@Type:
        ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl
      @@@PerlDef:
          my $node = $r = <ClassM::ManakaiDOM:ManakaiDOMNodeObject
                                        ::ManakaiDOM:Perl.new>;
          push @{$node->{<Q::TreeCore:origin>}}, <H::pc:parent>;
          for my $prop (<H::pc:code>) {
            $node->{$prop} = $nodeObject->{$prop};
          }
          $node->{<H::pc:nodeType>} = 'bare';
          $node->{<H::pc:requireResourceURI>}
             = {%{$nodeObject->{<H::pc:requireResourceURI>} || {}}};
          $node->{<H::pc:useModuleName>}
             = {%{$nodeObject->{<H::pc:useModuleName>} || {}}};
          $node->{<H::pc:useCharClassName>}
             = {map {$_ => {%{$nodeObject->{<H::pc:useCharClassName>}->{$_}}}}
                keys %{$nodeObject->{<H::pc:useCharClassName>} || {}}};
          $node->{<H::pc:requireModuleName>}
             = {%{$nodeObject->{<H::pc:requireModuleName>} || {}}};

  @Attr:
    @@Name: code
    @@enDesc:
      Perl code. 
    @@Type: DOMString
    @@Get:
      @@@disDef:
        @@@@GetProp: code
        @@@@ForCheck: !pc|ForClass
      @@@disDef:
        @@@@DISPerl:cloneCode: DOMCore|ManakaiDOMNode.textContent.get
        @@@@ForCheck: pc|ForClass
    @@Set:
      @@@disDef:
        @@@@SetProp: code
        @@@@ForCheck: !pc|ForClass
      @@@disDef:
        @@@@DISPerl:cloneCode: DOMCore|ManakaiDOMNode.textContent.set
        @@@@ForCheck: pc|ForClass

  @ToStringMethod:
    @@Return:
      @@@Type:
        DISLang:String::ManakaiDOM:all
      @@@enDesc:
        Perl code. 
      @@@PerlDef:
        @@@@ForCheck: !pc|ForClass
        @@@@@:
        my $node = $self->{<H::mn:node>};
        $r = $node->{<H::pc:code>};
      @@@PerlDef:
        @@@@ForCheck: pc|ForClass
        @@@@@:
          __DEEP{
            $r = $self-><AG::Node.textContent>;
          }__;
##PCTokens

IFClsETDef:
  @IFQName: PerlAtom
  @ClsQName: ManakaiPerlAtom
  @CQName: ManakaiPCAtom
  @ETQName: pc|atom

  @IFISA: PerlCode

  @ClsISA: ManakaiPerlBare
  @CISA: ManakaiPCTokens

  @enDesc:
    Unparsed Perl atomic code fragments (such as numeric literal). 
  
  @IntMethod:
    @@ForCheck: ManakaiDOM|ForClass !pc|ForClass
    @@Name:newObject
    @@ManakaiDOM:isStatic:1
    @@Description:
      @@@lang:en
      @@@@:
        Creates a new instance object for
        <Class::ManakaiPerlAtom>. 
    @@Return:
      @@@Type:
        ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl
      @@@Description:
        @@@@lang:en
        @@@@@:
          The newly created node object.
      @@@PerlDef:
        @@@@@:
          my $node = $r = <ClassM::ManakaiDOM:ManakaiDOMNodeObject
                                        ::ManakaiDOM:Perl.new>;
          push @{$node->{<Q::TreeCore:origin>}}, <H::pc:parent>;
          $node->{<H::pc:code>} = '';
          $node->{<H::pc:nodeType>} = 'atom';
        @@@@ImplNote:
          @@@@@lang:en
          @@@@@@:
            Properties: <Q::pc:nodeType>, <Q::pc:code>, <Q::pc:useModuleName>, 
               <Q::pc:useCharClassName>, 
               <Q::pc:requireResourceURI>, <Q::pc:requireModuleName>.

  @IntCloneMethod:
    @@Return:
      @@@Type:
        ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl
      @@@PerlDef:
          my $node = $r = <ClassM::ManakaiDOM:ManakaiDOMNodeObject
                                        ::ManakaiDOM:Perl.new>;
          push @{$node->{<Q::TreeCore:origin>}}, <H::pc:parent>;
          for my $prop (<H::pc:code>) {
            $node->{$prop} = $nodeObject->{$prop};
          }
          $node->{<H::pc:nodeType>} = 'atom';
          $node->{<H::pc:requireResourceURI>}
             = {%{$nodeObject->{<H::pc:requireResourceURI>} || {}}};
          $node->{<H::pc:useModuleName>}
             = {%{$nodeObject->{<H::pc:useModuleName>} || {}}};
          $node->{<H::pc:useCharClassName>}
             = {map {$_ => {%{$nodeObject->{<H::pc:useCharClassName>}->{$_}}}}
                keys %{$nodeObject->{<H::pc:useCharClassName>} || {}}};
          $node->{<H::pc:requireModuleName>}
             = {%{$nodeObject->{<H::pc:requireModuleName>} || {}}};

  @NumValMethod:
    @@Return:
      @@@Type: idl|unsignedLong||ManakaiDOM|all
      @@@enDesc:
        Numeric value of the Perl code. 
      @@@PerlDef:
        @@@@ForCheck: !pc|ForClass
        @@@@@:
        $r = 0 + $self->{<H::mn:node>}->{<H::pc:code>};
      @@@PerlDef:
        @@@@ForCheck: pc|ForClass
        @@@@@:
          __DEEP{
            $r = 0 + $self-><AG::Node.textContent>;
          }__;

  @ToStringMethod:
    @@Return:
      @@@Type: DOMString
      @@@enDesc:
        Perl code. 
      @@@PerlDef:
        @@@@ForCheck: !pc|ForClass
        @@@@@:
        my $node = $self->{<H::mn:node>};
        $r = $node->{<H::pc:code>};
      @@@PerlDef:
        @@@@ForCheck: pc|ForClass
        @@@@@:
          __DEEP{
            $r = $self-><AG::Node.textContent>;
          }__;
##PerlAtom

IFClsETDef:
  @IFQName: PerlVariable
  @ClsQName: ManakaiPerlVariable
  @CQName: ManakaiPCVariable
  @ETQName: pc|variable

  @IFISA: PerlCode
  @ClsISA: ManakaiPerlCodeFragment
  @CISA: ManakaiPCCode

  @enDesc:
    Unparsed Perl variable. 
    \
    {NOTE:: Future version of the implementation may 
            support to specify array index or hash key.
     \
    }
  
  @IntMethod:
    @@ForCheck: ManakaiDOM|ForClass !pc|ForClass
    @@Name:newObject
    @@ManakaiDOM:isStatic:1
    @@Description:
      @@@lang:en
      @@@@:
        Creates a new instance object for
        <Class::ManakaiPerlVariable>. 
    @@Return:
      @@@Type:
        ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl
      @@@Description:
        @@@@lang:en
        @@@@@:
          The newly created node object.
      @@@PerlDef:
        @@@@@:
          my $node = $r = <ClassM::ManakaiDOM:ManakaiDOMNodeObject
                                        ::ManakaiDOM:Perl.new>;
          push @{$node->{<Q::TreeCore:origin>}}, <H::pc:parent>;
          $node->{<H::pc:variableType>} = '';
          $node->{<H::pc:nodeType>} = 'variable';
        @@@@ImplNote:
          @@@@@lang:en
          @@@@@@:
            Properties: <Q::pc:nodeType>, <Q::pc:variableType>,
              <Q::packageName>, <Q::localName> (required),
              <Q::pc:useCharClassName>, 
              <Q::variableScope>, <Q::hashKey>, <Q::pc:useModuleName>, 
               <Q::pc:requireResourceURI>, <Q::pc:requireModuleName>.

  @IntCloneMethod:
    @@Return:
      @@@Type:
        ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl
      @@@PerlDef:
          my $node = $r = <ClassM::ManakaiDOM:ManakaiDOMNodeObject
                                        ::ManakaiDOM:Perl.new>;
          push @{$node->{<Q::TreeCore:origin>}}, <H::pc:parent>;
          for my $prop (<H::pc:variableType>, <H::pc:packageName>,
                        <H::pc:localName>, <H::pc:variableScope>, <H::pc:hashKey>) {
            $node->{$prop} = $nodeObject->{$prop};
          }
          $node->{<H::pc:nodeType>} = 'variable';
          $node->{<H::pc:requireResourceURI>}
             = {%{$nodeObject->{<H::pc:requireResourceURI>} || {}}};
          $node->{<H::pc:useModuleName>}
             = {%{$nodeObject->{<H::pc:useModuleName>} || {}}};
          $node->{<H::pc:useCharClassName>}
             = {map {$_ => {%{$nodeObject->{<H::pc:useCharClassName>}->{$_}}}}
                keys %{$nodeObject->{<H::pc:useCharClassName>} || {}}};
          $node->{<H::pc:requireModuleName>}
             = {%{$nodeObject->{<H::pc:requireModuleName>} || {}}};

  @ATTR:
    @@Name: variableType
    @@ATTRQName: pc|variableType
    @@enDesc:
      Perl variable type (<CODE::$>, <CODE::@>, <CODE::%>,
      <CODE::&> or empty string). 
    @@ReflectCDATA:
    @@Get:
      @@@disDef:
        @@@@GetProp: variableType
        @@@@ForCheck: pc|ForClassCompat
    @@Set:
      @@@disDef:
        @@@@SetProp: variableType
        @@@@ForCheck: pc|ForClassCompat

  @ATTR:
    @@Name: packageName
    @@ATTRQName: pc|packageName
    @@enDesc:
      The name of the package to which this variable belongs.
    @@ReflectCDATA:
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          This package belongs to the current package or 
          does not belong to any package.
      @@@disDef:
        @@@@GetProp: packageName
        @@@@ForCheck: pc|ForClassCompat
    @@Set:
      @@@nullCase:
        @@@@enDesc:
          This package belongs to the current package or
          does not belong to any package.
      @@@disDef:
        @@@@SetProp: packageName
        @@@@ForCheck: pc|ForClassCompat

  @ATTR:
    @@Name:
      @@@@: localName
      @@@ForCheck: pc|ForClassCompat
    @@Name: 
      @@@@: pcLocalName
      @@@ForCheck: !pc|ForClassCompat
    @@ATTRQName: pc|localName
    @@enDesc:
      The local variable name.
    @@ReflectCDATA:
    @@Get:
      @@@disDef:
        @@@@GetProp: localName
        @@@@ForCheck: pc|ForClassCompat
    @@Set:
      @@@disDef:
        @@@@SetProp: localName
        @@@@ForCheck: pc|ForClassCompat

  @ATTR:
    @@Name: variableScope
    @@ATTRQName: pc|variableScope
    @@enDesc:
      Scope modifier (<CODE::my> or <CODE::our> or <CODE::local>).
    @@ReflectCDATA:
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          This variable does not have scope modifier.
      @@@disDef:
        @@@@GetProp: variableScope
        @@@@ForCheck: pc|ForClassCompat
    @@Set:
      @@@nullCase:
        @@@@enDesc:
          This variable does not have scope modifier.
      @@@disDef:
        @@@@SetProp: variableScope
        @@@@ForCheck: pc|ForClassCompat

  @ToStringMethod:
    @@Return:
      @@@Type: DOMString
      @@@enDesc:
        Perl code. 
      @@@PerlDef:
        @@@@ForCheck: !pc|ForClass
        @@@@@:
        my $node = $self->{<H::mn:node>};
        if ($node->{<H::pc:variableScope>}) {
          $r = $node->{<H::pc:variableScope>} . ' ';
        }
        $r .= $node->{<H::pc:variableType>};
        $r .= $node->{<H::pc:packageName>} . '::'
          if defined $node->{<H::pc:packageName>};
        $r .= $node->{<H::pc:localName>};
        if ($node->{<H::pc:variableType>} eq '$' and
            defined $node->{<H::pc:hashKey>}) {
          my $hashKey = $node->{<H::pc:hashKey>};
          $hashKey =~ s/(['\\])/\\$1/g;
          $r .= q<{'> . $hashKey . q<'}>;
        }
      @@@PerlDef:
        @@@@ForCheck: pc|ForClass
        @@@@@:
          __DEEP{
            my $t = $self-><AG::PerlVariable.variableScope>;
            $r .= $t . ' ' if length $t;
            $r .= $self-><AG::PerlVariable.variableType>;
            my $v = $self-><AG::PerlVariable.packageName>;
            $r .= $v . '::' if length $v;
            $r .= $self-><AG::PerlVariable.pcLocalName>;
            $v = $self-><AG::PerlVariable.hashKey>;
            if ($t eq '$' and length $v) {
              $v =~ s/(['\\])/\\$1/g;
              $r .= q<{'> . $v . q<'}>;
            }
          }__;

  @ATTR:
    @@Name: hashKey
    @@ATTRQName: pc|hashKey
    @@enDesc:
      The key for hash. 
      \
      {NOTE:: Using Perl code for key is not supported in the current
              version of the implementation.
      \
      }
    @@ReflectCDATA:
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          This variable is not for hash value access.
      @@@disDef:
        @@@@GetProp: hashKey
        @@@@ForCheck: pc|ForClassCompat
    @@Set:
      @@@nullCase:
        @@@@enDesc:
          This variable is not for hash value access.
      @@@disDef:
        @@@@SetProp: hashKey
        @@@@ForCheck: pc|ForClassCompat
##PerlVariable

PropDef:
  @QName: variableScope
  @enDesc:
    Variable scope (<CODE::local>, <CODE::my> or <CODE::our>).

PropDef:
  @QName: variableType
  @enDesc:
    Variable type prefix.

PropDef:
  @QName: hashKey
  @enDesc:
    Hash key string.

IFClsDef:
  @IFQName: PerlCodeUnits
  @ClsQName: ManakaiPerlAnyContainer
  @CQName: ManakaiPCCodeUnits

  @ClsISA: ManakaiPerlCodeFragment
  @CISA: ManakaiPCCode

  @enDesc:
    A base class implemented by both inline container and
    block-level container.
  
  @Attr:
    @@Name: length
    @@enDesc:
      The number of child code fragments. 
    @@Type: idl|unsignedLong||ManakaiDOM|all
    @@Get:
      @@@PerlDef:
        @@@@ForCheck: !pc|ForClass
        @@@@@:
        $r = @{$self->{<H::mn:node>}->{<H::pc:childNodes>}};
      @@@PerlDef:
        @@@@ForCheck: pc|ForClass
        @@@@@:
          __DEEP{
            $r = @{$self-><AG::Node.childNodes>};
          }__;

  @Method:
    @@Name: appendStringLiteral
    @@enDesc:
      Appends a Perl string literal (<CODE::q>).
    @@Param:
      @@@Name: stringArg
      @@@Type: DOMString
      @@@enDesc:
        A string.
    @@Return:
      @@@Type: PerlStringLiteral
      @@@enDesc:
        The newly created Perl string literal object. 
      @@@PerlDef:
        @@@@ForCheck: !pc|ForClass
        @@@@@:
        $r = <ClassM::ManakaiPerlStringLiteral.newObject>;
        my $node = $self->{<H::mn:node>};
        $r->{<H::infoset:content>} = $stringArg;
        $node-><M::ManakaiDOM:ManakaiDOMNodeObject
                 ::ManakaiDOM:Perl.importTree> ($r);
        push @{$node->{<H::pc:childNodes>}}, $r;
        $r->{<H::pc:parent>} = $node;
        if (defined wantarray) {
          __CODE{ManakaiNode:getNewReference||ManakaiDOM|Perl::
            $object => $r, $ref => $r,
            $class =>{<ClassName::ManakaiPerlStringLiteral>},
          }__;
        }
      @@@PerlDef:
        @@@@ForCheck: pc|ForClass
        @@@@@:
          __DEEP{
            $r = $self-><AG::Node.ownerDocument>-><M::Document.createElementNS>
                                           (<Q::pc:>, 'stringLiteral');
            $r-><AS::Node.textContent> ($stringArg);
            $self-><M::Node.appendChild> ($r);
          }__;

  @Method:
    @@Name: appendAtom
    @@enDesc:
      Appends a Perl atomic code fragment.
    @@Param:
      @@@Name: codeArg
      @@@Type: DOMString
      @@@enDesc:
        An atom.
    @@Return:
      @@@Type: PerlAtom
      @@@enDesc:
        The newly created Perl code object. 
      @@@PerlDef:
        @@@@ForCheck: !pc|ForClass
        @@@@@:
        $r = <ClassM::ManakaiPerlAtom.newObject>;
        my $node = $self->{<H::mn:node>};
        $r->{<H::pc:code>} = $codeArg;
        $node-><M::ManakaiDOM:ManakaiDOMNodeObject
                 ::ManakaiDOM:Perl.importTree> ($r);
        push @{$node->{<H::pc:childNodes>}}, $r;
        $r->{<H::pc:parent>} = $node;
        if (defined wantarray) {
          __CODE{ManakaiNode:getNewReference||ManakaiDOM|Perl::
            $object => $r, $ref => $r,
            $class =>{<ClassName::ManakaiPerlAtom>},
          }__;
        }
      @@@PerlDef:
        @@@@ForCheck: pc|ForClass
        @@@@@:
          __DEEP{
            $r = $self-><AG::Node.ownerDocument>-><M::Document.createElementNS>
                                                   (<Q::pc:>, 'atom');
            $r-><AS::Node.textContent> ($codeArg);
            $self-><M::Node.appendChild> ($r);
          }__;

  @Method:
    @@Name: appendBare
    @@enDesc:
      Appends a Perl bare code fragment.
    @@Param:
      @@@Name: codeArg
      @@@Type: DOMString
      @@@enDesc:
        An bare code.
    @@Return:
      @@@Type: PerlBare
      @@@enDesc:
        The newly created Perl code object. 
      @@@PerlDef:
        @@@@ForCheck: !pc|ForClass
        @@@@@:
        $r = <ClassM::ManakaiPerlBare.newObject>;
        my $node = $self->{<H::mn:node>};
        $r->{<H::pc:code>} = $codeArg;
        $node-><M::ManakaiDOM:ManakaiDOMNodeObject
                 ::ManakaiDOM:Perl.importTree> ($r);
        push @{$node->{<H::pc:childNodes>}}, $r;
        $r->{<H::pc:parent>} = $node;
        if (defined wantarray) {
          __CODE{ManakaiNode:getNewReference||ManakaiDOM|Perl::
            $object => $r, $ref => $r,
            $class =>{<ClassName::ManakaiPerlBare>},
          }__;
        }
      @@@PerlDef:
        @@@@ForCheck: pc|ForClass
        @@@@@:
          __DEEP{
            $r = $self-><AG::Node.ownerDocument>-><M::Document.createElementNS>
                                                   (<Q::pc:>, 'tokens');
            $r-><AS::Node.textContent> ($codeArg);
            $self-><M::Node.appendChild> ($r);
          }__;

  @Method:
    @@Name: appendNewAssignment
    @@enDesc:
      Appends a newly created <Class::ManakaiPerlAssign> object. 
    @@Param:
      @@@Name: leftArg
      @@@Type: PerlCode
      @@@enDesc:
        A left hand side code fragment object. 
    @@Param:
      @@@Name: rightArg
      @@@Type: PerlCode
      @@@enDesc:
        A right hand side code fragment object. 
    @@Return:
      @@@Type: 
        @@@@@: PerlAssignment
        @@@@ForCheck: !pc|ForClassCompat
      @@@RaiseException:
        @@@@@:BAD_CHILD_ERR
        @@@@enDesc:
          An attempt is made to append a child
          that is not valid type.
      @@@RaiseException:
        @@@@@:IN_USE_NODE_ERR
        @@@@enDesc:
          An attempt is made to append a node that is 
          already used elsewhere. 
      @@@PerlDef:
        @@@@ForCheck: !pc|ForClass
        @@@@@:
        for my $arg ([leftArg => $leftArg], [rightArg => $rightArg]) {
          if ({
            atom => 1, bare => 1, incontainer => 1, assign => true,
            inunparsed => 1, variable => 1, string => true,
          }->{$arg->[1]->{<H::mn:node>}->{<H::pc:nodeType>}}) {
            if ($arg->[1]->{<H::mn:node>}->{<H::pc:parent>}) {
              __EXCEPTION{IN_USE_NODE_ERR::
                pc:childNode => {$arg->[1]},
                MDOMX:param-name => {$arg->[0]},
              }__;
            }
          } else {
            __EXCEPTION{BAD_CHILD_ERR::
              pc:parentNode => {$self},
              pc:childNode => {$arg->[1]},
              MDOMX:param-name => {$arg->[0]},
            }__;
          }
        } # left/right

        my $assign = <ClassM::ManakaiPerlAssignment.newObject>;
        $assign->{<H::pc:left>} = $leftArg->{<H::mn:node>};
        $assign->{<H::pc:right>} = $rightArg->{<H::mn:node>};
        $leftArg->{<H::mn:node>}->{<H::pc:parent>} = $assign;
        $rightArg->{<H::mn:node>}->{<H::pc:parent>} = $assign;
        $self->{<H::mn:node>}-><M::MNodeObject.importTree> ($assign);
        $assign->{<H::pc:parent>} = $self->{<H::mn:node>};
        push @{$self->{<H::mn:node>}->{<H::pc:childNodes>}}, $assign;
      @@@PerlDef:
        @@@@ForCheck: pc|ForClass
        @@@@@:
          for my $arg ([leftArg => $leftArg], [rightArg => $rightArg]) {
            if ({
              atom => 1, tokens => 1, inlineContainer => 1, assignment => true,
              inlineUnparsed => 1, variable => 1, stringLiteral => true,
            }->{$arg->[1]-><AG::Node.localName>}) {
              if ($arg->[1]-><AG::Node.parentNode>) {
                __EXCEPTION{IN_USE_NODE_ERR::
                  pc:childNode => {$arg->[1]},
                  MDOMX:param-name => {$arg->[0]},
                }__;
              }
            } else {
              __EXCEPTION{BAD_CHILD_ERR::
                pc:parentNode => {$self},
                pc:childNode => {$arg->[1]},
                MDOMX:param-name => {$arg->[0]},
              }__;
            }
          } # left/right

          __DEEP{
            $r = $self-><AG::Node.ownerDocument>-><M::Document.createElementNS>
                                                (<Q::pc:>, 'assignment');
            $r-><AS::PerlAssignment.leftCode> ($leftArg);
            $r-><AS::PerlAssignment.rightCode> ($rightArg);
            $self-><M::Node.appendChild> ($r);
          }__;
##PCAssignment

IFClsETDef:
  @IFQName: PerlStatement
  @ClsQName: ManakaiPerlStatement
  @CQName: ManakaiPCStatement
  @ETQName: pc|statement

  @IFISA: PerlCode

  @IFISA: PerlCodeInlines
  @ClsISA: ManakaiPerlInlineContainer
  @CISA: ManakaiPCCodeInlines

  @enDesc:
    Perl statements. 
  
  @IntMethod:
    @@ForCheck: ManakaiDOM|ForClass !pc|ForClass
    @@Name:newObject
    @@ManakaiDOM:isStatic:1
    @@Description:
      @@@lang:en
      @@@@:
        Creates a new instance object for
        <Class::ManakaiPerlStatement>. 
    @@Return:
      @@@Type:
        ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl
      @@@Description:
        @@@@lang:en
        @@@@@:
          The newly created node object.
      @@@PerlDef:
        @@@@@:
          my $node = $r = <ClassM::ManakaiDOM:ManakaiDOMNodeObject
                                        ::ManakaiDOM:Perl.new>;
          push @{$node->{<Q::TreeCore:origin>}}, <H::pc:parent>;
          push @{$node->{<Q::TreeCore:subnode>}}, <H::pc:childNodes>;
          $node->{<H::pc:childNodes>} = [];
          $node->{<H::pc:nodeType>} = 'statement';
        @@@@ImplNote:
          @@@@@lang:en
          @@@@@@:
            Properties: <Q::pc:nodeType>, <Q::pc:childNodes>,
               <Q::pc:parent>, <Q::pc:useModuleName>, <Q::pc:useCharClassName>,  
               <Q::pc:requireResourceURI>, <Q::pc:requireModuleName>.

  @IntCloneMethod:
    @@Return:
      @@@Type:
        ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl
      @@@PerlDef:
          my $node = $r = <ClassM::ManakaiDOM:ManakaiDOMNodeObject
                                        ::ManakaiDOM:Perl.new>;
          push @{$node->{<Q::TreeCore:origin>}}, <H::pc:parent>;
          $node->{<H::pc:nodeType>} = 'statement';
          push @{$node->{<Q::TreeCore:subnode>}}, <H::pc:childNodes>;
          $node->{<H::pc:childNodes>} = [];
          for my $cno (@{$nodeObject->{<H::pc:childNodes>}}) {
            my $pack;
            my $nt = $cno->{<H::pc:nodeType>};
            __CODE{pc:nodeTypeToPackageName::
                     $nodeType => $nt, $packageName => $pack, $object => $cno}__;
                                 ## NOTE: Method name written directly
            my $cno_clone = $pack->_make_clone_object ($cno);
            push @{$node->{<H::pc:childNodes>}}, $cno_clone;
            $cno_clone->{<H::pc:parent>} = $node;
            ## NOTE: Tree ID is not updated yet.
          }
          $node->{<H::pc:requireResourceURI>}
             = {%{$nodeObject->{<H::pc:requireResourceURI>} || {}}};
          $node->{<H::pc:useModuleName>}
             = {%{$nodeObject->{<H::pc:useModuleName>} || {}}};
          $node->{<H::pc:useCharClassName>}
             = {map {$_ => {%{$nodeObject->{<H::pc:useCharClassName>}->{$_}}}}
                keys %{$nodeObject->{<H::pc:useCharClassName>} || {}}};
          $node->{<H::pc:requireModuleName>}
             = {%{$nodeObject->{<H::pc:requireModuleName>} || {}}};

  @ToStringMethod:
    @@Return:
      @@@Type: DOMString
      @@@enDesc:
        Perl code. 
      @@@PerlDef:
        $r = $self->SUPER::stringify;
        $r .= ";\n" if length $r;
##PerlStatement

IFClsETDef:
  @IFQName: PerlCodeInlines
  @ClsQName: ManakaiPerlInlineContainer
  @CQName: ManakaiPCCodeInlines
  @ETQName: pc|inlineContainer

  @ClsISA: ManakaiPerlAnyContainer
  @CISA: ManakaiPCCodeUnits

  @enDesc:
    Unparsed Perl inline code block. 
  
  @IntMethod:
    @@ForCheck: ManakaiDOM|ForClass !pc|ForClass
    @@Name:newObject
    @@ManakaiDOM:isStatic:1
    @@Description:
      @@@lang:en
      @@@@:
        Creates a new instance object for
        <Class::ManakaiPerlInlineContainer>. 
    @@Return:
      @@@Type:
        ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl
      @@@Description:
        @@@@lang:en
        @@@@@:
          The newly created node object.
      @@@PerlDef:
        @@@@@:
          my $node = $r = <ClassM::ManakaiDOM:ManakaiDOMNodeObject
                                        ::ManakaiDOM:Perl.new>;
          push @{$node->{<Q::TreeCore:origin>}}, <H::pc:parent>;
          push @{$node->{<Q::TreeCore:subnode>}}, <H::pc:childNodes>;
          $node->{<H::pc:childNodes>} = [];
          $node->{<H::pc:nodeType>} = 'incontainer';
        @@@@ImplNote:
          @@@@@lang:en
          @@@@@@:
            Properties: <Q::pc:nodeType>, <Q::pc:childNodes>,
               <Q::pc:parent>, <Q::pc:useModuleName>, <Q::pc:useCharClassName>,  
               <Q::pc:requireResourceURI>, <Q::pc:requireModuleName>.

  @IntCloneMethod:
    @@Return:
      @@@Type:
        ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl
      @@@PerlDef:
          my $node = $r = <ClassM::ManakaiDOM:ManakaiDOMNodeObject
                                        ::ManakaiDOM:Perl.new>;
          push @{$node->{<Q::TreeCore:origin>}}, <H::pc:parent>;
          push @{$node->{<Q::TreeCore:subnode>}}, <H::pc:childNodes>;
          $node->{<H::pc:nodeType>} = 'incontainer';
          $node->{<H::pc:childNodes>} = [];
          for my $cno (@{$nodeObject->{<H::pc:childNodes>}}) {
            my $pack;
            my $nt = $cno->{<H::pc:nodeType>};
            __CODE{pc:nodeTypeToPackageName::
                     $nodeType => $nt, $packageName => $pack, $object => $cno}__;
                                 ## NOTE: Method name written directly
            my $cno_clone = $pack->_make_clone_object ($cno);
            push @{$node->{<H::pc:childNodes>}}, $cno_clone;
            $cno_clone->{<H::pc:parent>} = $node;
            ## NOTE: Tree ID is not updated yet.
          }
          $node->{<H::pc:requireResourceURI>}
             = {%{$nodeObject->{<H::pc:requireResourceURI>} || {}}};
          $node->{<H::pc:useModuleName>}
             = {%{$nodeObject->{<H::pc:useModuleName>} || {}}};
          $node->{<H::pc:useCharClassName>}
             = {map {$_ => {%{$nodeObject->{<H::pc:useCharClassName>}->{$_}}}}
                keys %{$nodeObject->{<H::pc:useCharClassName>} || {}}};
          $node->{<H::pc:requireModuleName>}
             = {%{$nodeObject->{<H::pc:requireModuleName>} || {}}};

  @Method:
    @@Name: appendCodeFragment
    @@enDesc:
      Appends a <IF::PerlCode> object. 
    @@Param:
      @@@Name: codeArg
      @@@Type: PerlCode
      @@@enDesc:
        A code fragment object. 
    @@Return:
      @@@RaiseException:
        @@@@@:BAD_CHILD_ERR
        @@@@enDesc:
          An attempt is made to append a child
          that is not a <Class::ManakaiPerlUnparsedCode>.
      @@@RaiseException:
        @@@@@:IN_USE_NODE_ERR
        @@@@enDesc:
          An attempt is made to append a node that is 
          already used elsewhere. 
      @@@PerlDef:
        @@@@ForCheck: !pc|ForClass
        @@@@@:
        if ({
          atom => 1, bare => 1, incontainer => 1, assign => true,
          inunparsed => 1, variable => 1, string => 1,
        }->{$codeArg->{<H::mn:node>}->{<H::pc:nodeType>}}) {
          if ($codeArg->{<H::mn:node>}->{<H::pc:parent>}) {
            __EXCEPTION{IN_USE_NODE_ERR::
              pc:childNode => {$codeArg},
            }__;
          }
          $self->{<H::mn:node>}-><M::MNodeObject.importTree>
                                          ($codeArg->{<H::mn:node>});
          push @{$self->{<H::mn:node>}->{<H::pc:childNodes>}},
               $codeArg->{<H::mn:node>};
          $codeArg->{<H::mn:node>}->{<H::pc:parent>}
                                         = $self->{<H::mn:node>};
        } else {
          __EXCEPTION{BAD_CHILD_ERR::
            pc:parentNode => {$self},
            pc:childNode => {$codeArg},
          }__;
        }
      @@@PerlDef:
        @@@@ForCheck: pc|ForClass
        @@@@@:
          if ({
            atom => 1, tokens => 1, inlineContainer => 1, assignment => true,
            inlineUnparsed => 1, variable => 1, stringLiteral => true,
          }->{$codeArg-><AG::Node.localName>}) {
            if ($codeArg-><AG::Node.parentNode>) {
              __EXCEPTION{IN_USE_NODE_ERR::
                pc:childNode => {$codeArg},
              }__;
            }
            __DEEP{
              $self-><AG::Node.ownerDocument>
                   -><M::Document.adoptNode> ($codeArg);
              $self-><M::Node.appendChild> ($codeArg);
            }__;
          } else {
            __EXCEPTION{BAD_CHILD_ERR::
              pc:parentNode => {$self},
              pc:childNode => {$codeArg},
            }__;
          }

  @Method:
    @@Name: appendCode
    @@enDesc:
      Appends an unparsed Perl code fragment. 
    @@Param:
      @@@Name: codeArg
      @@@Type: DOMString
      @@@enDesc:
        An unparsed Perl code fragment. 
    @@Return:
      @@@Type: PerlInlineUnparsedCode
      @@@enDesc:
        The newly created Perl code object. 
      @@@PerlDef:
        @@@@ForCheck: !pc|ForClass
        @@@@@:
        $r = <ClassM::ManakaiPerlInlineUnparsedCode.newObject>;
        my $node = $self->{<H::mn:node>};
        $r->{<H::pc:code>} = $codeArg;
        $node-><M::ManakaiDOM:ManakaiDOMNodeObject
                 ::ManakaiDOM:Perl.importTree> ($r);
        push @{$node->{<H::pc:childNodes>}}, $r;
        $r->{<H::pc:parent>} = $node;
        if (defined wantarray) {
          __CODE{ManakaiNode:getNewReference||ManakaiDOM|Perl::
            $object => $r, $ref => $r,
            $class =>{<ClassName::ManakaiPerlInlineUnparsedCode>},
          }__;
        }
      @@@PerlDef:
        @@@@ForCheck: pc|ForClass
        @@@@@:
          __DEEP{
            $r = $self-><AG::Node.ownerDocument>-><M::Document.createElementNS>
                                                (<Q::pc:>, 'inlineUnparsed');
            $r-><AS::Node.textContent> ($codeArg);
            $self-><M::Node.appendChild> ($r);
          }__;

  @ToStringMethod:
    @@Return:
      @@@Type: DOMString
      @@@enDesc:
        Perl code. 
      @@@PerlDef:
        @@@@ForCheck: !pc|ForClass
        @@@@@:
        for my $cno (@{$self->{<H::mn:node>}->{<H::pc:childNodes>}}) {
          my $cn = <ClassM::ManakaiPerlCodeFragment.getNodeReference> ($cno);
          if ($cno->{<H::pc:nodeType>} eq 'incontainer' and
   \          @{$self->{<H::mn:node>}->{<H::pc:childNodes>}} == 1) {
            $r .= '(' . $cn->stringify . ')';
          } else {
            $r .= $cn->stringify;
          }
        }
      @@@PerlDef:
        @@@@ForCheck: pc|ForClass
        @@@@@:
          __DEEP{
            my @child = @{$self-><AG::Node.childNodes>};
            for my $child (@child) {
              if ($child-><AG::Node.namespaceURI> eq <Q::pc:> and
                  $child-><AG::Node.localName> eq 'inlineContainer' and
                  1 == @child) {
                $r .= '(' . $child->stringify . ')';
              } else {
                $r .= $child->stringify;
              }
            }
          }__;
##PCCodeInlines

IFClsETDef:
  @IFQName: PerlBlock
  @ClsQName: ManakaiPerlBlock
  @CQName: ManakaiPCBlock
  @ETQName: pc|block

  @IFISA: PerlCode

  @IFISA: PerlCodeStatements
  @ClsISA: ManakaiPerlStatementContainer
  @CISA: ManakaiPCCodeStatements

  @enDesc:
    Perl block-level code block. 
  
  @IntMethod:
    @@ForCheck: ManakaiDOM|ForClass !pc|ForClass
    @@Name:newObject
    @@ManakaiDOM:isStatic:1
    @@Description:
      @@@lang:en
      @@@@:
        Creates a new instance object for
        <Class::ManakaiPerlBlock>. 
    @@Return:
      @@@Type:
        ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl
      @@@Description:
        @@@@lang:en
        @@@@@:
          The newly created node object.
      @@@PerlDef:
        @@@@@:
          my $node = $r = <ClassM::ManakaiDOM:ManakaiDOMNodeObject
                                        ::ManakaiDOM:Perl.new>;
          push @{$node->{<Q::TreeCore:origin>}}, <H::pc:parent>;
          push @{$node->{<Q::TreeCore:subnode>}}, <H::pc:childNodes>;
          $node->{<H::pc:childNodes>} = [];
          $node->{<H::pc:nodeType>} = 'block';
        @@@@ImplNote:
          @@@@@lang:en
          @@@@@@:
            Properties: <Q::pc:nodeType>, <Q::pc:childNodes>, <Q::pc:label>,
                <Q::pc:parent>, <Q::pc:sourceFile>, <Q::pc:sourceLine>,
                <Q::pc:currentSoruceFile>, <Q::pc:useCharClassName>, 
                <Q::pc:currentSourceLine>, <Q::pc:useModuleName>, 
                <Q::pc:requireResourceURI>, <Q::pc:requireModuleName>.

  @IntCloneMethod:
    @@Return:
      @@@Type:
        ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl
      @@@PerlDef:
          my $node = $r = <ClassM::ManakaiDOM:ManakaiDOMNodeObject
                                        ::ManakaiDOM:Perl.new>;
          push @{$node->{<Q::TreeCore:origin>}}, <H::pc:parent>;
          push @{$node->{<Q::TreeCore:subnode>}}, <H::pc:childNodes>;
          $node->{<H::pc:nodeType>} = 'block';
          $node->{<H::pc:childNodes>} = [];
          for my $cno (@{$nodeObject->{<H::pc:childNodes>}}) {
            my $pack;
            my $nt = $cno->{<H::pc:nodeType>};
            __CODE{pc:nodeTypeToPackageName::
                     $nodeType => $nt, $packageName => $pack, $object => $cno}__;
                                 ## NOTE: Method name written directly
            my $cno_clone = $pack->_make_clone_object ($cno);
            push @{$node->{<H::pc:childNodes>}}, $cno_clone;
            $cno_clone->{<H::pc:parent>} = $node;
            ## NOTE: Tree ID is not updated yet.
          }
          for my $prop (<H::pc:label>, <H::pc:sourceFile>, <H::pc:sourceLine>,
                        <H::pc:currentSourceFile>, <H::pc:currentSourceLine>) {
            $node->{$prop} = $nodeObject->{$prop};
          }
          $node->{<H::pc:requireResourceURI>}
             = {%{$nodeObject->{<H::pc:requireResourceURI>} || {}}};
          $node->{<H::pc:useModuleName>}
             = {%{$nodeObject->{<H::pc:useModuleName>} || {}}};
          $node->{<H::pc:useCharClassName>}
             = {map {$_ => {%{$nodeObject->{<H::pc:useCharClassName>}->{$_}}}}
                keys %{$nodeObject->{<H::pc:useCharClassName>} || {}}};
          $node->{<H::pc:requireModuleName>}
             = {%{$nodeObject->{<H::pc:requireModuleName>} || {}}};

  @ToStringMethod:
    @@Return:
      @@@Type: DOMString
      @@@enDesc:
        Perl code. 
      @@@PerlDef:
        @@@@ForCheck: !pc|ForClass
        @@@@@:
        my $node = $self->{<H::mn:node>};
        if (@{$node->{<H::pc:childNodes>}} == 1 and
            $node->{<H::pc:childNodes>}->[0]->{<H::pc:nodeType>} eq 'block') {
          my $cn;
          __CODE{ManakaiNode:getWeakReference||ManakaiDOM|Perl::
                     $object => {$node->{<H::pc:childNodes>}->[0]},
                     $ref => $cn,
                     $class => {<ClassName::ManakaiPerlBlock>}}__;
          $r = $cn->stringify;
        } else {
          for my $cno (@{$node->{<H::pc:childNodes>}}) {
            my $cn = <ClassM::ManakaiPerlCodeFragment.getNodeReference> ($cno);
            if ($cno->{<H::pc:nodeType>} eq 'incontainer' and
   \            @{$node->{<H::pc:childNodes>}} == 1) {
              $r .= '(' . $cn->stringify . ')';
            } else {
              $r .= $cn->stringify;
            }
          }
          __DEEP{
            my $file = $self-><AG::ManakaiPerlCodeFragment.fileNode>;
            $r = sprintf (qq<\n{\n#line %d "%s [b] (Chunk #%d)"\n>,
                          $node->{<H::pc:sourceLine>} || 1,
                          $node->{<H::pc:sourceFile>} ||
                            $file-><AG::ManakaiPerlFile.sourceFile>,
                          $file-><M::ManakaiPerlFile.getNextChunkNumber>)
               . $r
               . sprintf (qq<\n#line 1 "%s [/b] (Chunk #%d)"\n;}\n>,
                          $file-><AG::ManakaiPerlFile.sourceFile>,
                          $file-><M::ManakaiPerlFile.getNextChunkNumber>)
              if length $r;
          }__;
        }
      @@@PerlDef:
        @@@@ForCheck: pc|ForClass
        @@@@@:
          my @child = @{$self-><AG::Node.childNodes>};
          if (@child == 1 and 
              $child[0]-><AG::Node.localName> eq 'block') {
            $r = $child[0]->stringify;
          } elsif (@child == 1 and
                   $child[0]-><AG::Node.localName> eq 'unparsed' and
                   $child[0]-><AG::Node.textContent> =~ /^\s*$/) {
            # 
          } else {
            for my $child (@child) {
              if ($child-><AG::Node.localName> eq 'inlineContainer' and
                  1 == @child) {
                $r .= '(' . $child->stringify . ')';
              } else {
                $r .= $child->stringify;
              }
            }

            __DEEP{
              my $file = $self-><AG::PerlCode.fileNode>;
              my $sfile = $file ? $file-><AG::PerlFile.sourceFile> : '';
              $r = sprintf qq<\n{\n#line %d "%s [b] (Chunk #%d)"\n%s>.
                           qq<\n#line 1 "%s [/b] (Chunk #%d)"\n}\n>,
                           $self-><AG::PerlCodeStatements.sourceLine> || 1,
                           $self-><AG::PerlCodeStatements.sourceFile> || $sfile,
                           $file ? $file-><M::PerlFile.getNextChunkNumber> : 0,
                           $r,
                           $sfile,
                           $file ? $file-><M::PerlFile.getNextChunkNumber> : 0
                if length $r;
            }__;
          }
##PCBlock

IFClsETDef:
  @IFQName: PerlCodeBlocks
  @ClsQName: ManakaiPerlBlockContainer
  @CQName: ManakaiPCCodeBlocks
  @ETQName: pc|blockContainer

  @IFISA: PerlCodeStatements
  @ClsISA: ManakaiPerlStatementContainer
  @CISA: ManakaiPCCodeStatements

  @enDesc:
    Perl block-level code container whose content may or may
    not semantically be self-contained. 
  
  @IntMethod:
    @@ForCheck: ManakaiDOM|ForClass !pc|ForClass
    @@Name:newObject
    @@ManakaiDOM:isStatic:1
    @@Description:
      @@@lang:en
      @@@@:
        Creates a new instance object for
        <Class::ManakaiPerlBlockContainer>. 
    @@Return:
      @@@Type:
        ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl
      @@@Description:
        @@@@lang:en
        @@@@@:
          The newly created node object.
      @@@PerlDef:
        @@@@@:
          my $node = $r = <ClassM::ManakaiDOM:ManakaiDOMNodeObject
                                        ::ManakaiDOM:Perl.new>;
          push @{$node->{<Q::TreeCore:origin>}}, <H::pc:parent>;
          push @{$node->{<Q::TreeCore:subnode>}}, <H::pc:childNodes>;
          $node->{<H::pc:childNodes>} = [];
          $node->{<H::pc:nodeType>} = 'blockcontainer';
        @@@@ImplNote:
          @@@@@lang:en
          @@@@@@:
            Properties: <Q::pc:nodeType>, <Q::pc:childNodes>,
                <Q::pc:parent>, <Q::pc:sourceFile>, <Q::pc:sourceLine>,
                <Q::pc:currentSourceFile>, <Q::pc:useCharClassName>, 
                <Q::pc:currentSourceLine>, <Q::pc:useModuleName>, 
                <Q::pc:requireResourceURI>, <Q::pc:requireModuleName>.

  @IntCloneMethod:
    @@Return:
      @@@Type:
        ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl
      @@@PerlDef:
          my $node = $r = <ClassM::ManakaiDOM:ManakaiDOMNodeObject
                                        ::ManakaiDOM:Perl.new>;
          push @{$node->{<Q::TreeCore:origin>}}, <H::pc:parent>;
          push @{$node->{<Q::TreeCore:subnode>}}, <H::pc:childNodes>;
          $node->{<H::pc:nodeType>} = 'blockcontainer';
          $node->{<H::pc:childNodes>} = [];
          for my $cno (@{$nodeObject->{<H::pc:childNodes>}}) {
            my $pack;
            my $nt = $cno->{<H::pc:nodeType>};
            __CODE{pc:nodeTypeToPackageName::
                     $nodeType => $nt, $packageName => $pack, $object => $cno}__;
                                 ## NOTE: Method name written directly
            my $cno_clone = $pack->_make_clone_object ($cno);
            push @{$node->{<H::pc:childNodes>}}, $cno_clone;
            $cno_clone->{<H::pc:parent>} = $node;
            ## NOTE: Tree ID is not updated yet.
          }
          for my $prop (<H::pc:sourceFile>, <H::pc:sourceLine>,
                        <H::pc:currentSourceFile>, <H::pc:currentSourceLine>) {
            $node->{$prop} = $nodeObject->{$prop};
          }
          $node->{<H::pc:requireResourceURI>}
             = {%{$nodeObject->{<H::pc:requireResourceURI>} || {}}};
          $node->{<H::pc:useModuleName>}
             = {%{$nodeObject->{<H::pc:useModuleName>} || {}}};
          $node->{<H::pc:useCharClassName>}
             = {map {$_ => {%{$nodeObject->{<H::pc:useCharClassName>}->{$_}}}}
                keys %{$nodeObject->{<H::pc:useCharClassName>} || {}}};
          $node->{<H::pc:requireModuleName>}
             = {%{$nodeObject->{<H::pc:requireModuleName>} || {}}};

  @ToStringMethod:
    @@Return:
      @@@Type: DOMString
      @@@enDesc:
        Perl code. 
      @@@PerlDef:
        @@@@ForCheck: !pc|ForClass
        @@@@@:
        my $node = $self->{<H::mn:node>};
        if (@{$node->{<H::pc:childNodes>}} == 1 and
            {
              block => true, blockcontainer => true,
            }->{$node->{<H::pc:childNodes>}->[0]->{<H::pc:nodeType>}}) {
          my $cn;
          __CODE{ManakaiNode:getWeakReference||ManakaiDOM|Perl::
                     $object => {$node->{<H::pc:childNodes>}->[0]},
                     $ref => $cn,
                     $class => {<ClassName::ManakaiPerlBlock>}}__;
          $r = $cn->stringify;
        } else {
          for my $cno (@{$node->{<H::pc:childNodes>}}) {
            my $cn = <ClassM::ManakaiPerlCodeFragment.getNodeReference> ($cno);
            if ($cno->{<H::pc:nodeType>} eq 'incontainer' and
   \            @{$node->{<H::pc:childNodes>}} == 1) {
              $r .= '(' . $cn->stringify . ')';
            } else {
              $r .= $cn->stringify;
            }
          }
          __DEEP{
            my $file = $self-><AG::ManakaiPerlCodeFragment.fileNode>;
            $r = sprintf (qq<\n#line %d "%s [bc] (Chunk #%d)"\n>,
                          $node->{<H::pc:sourceLine>} || 1,
                          $node->{<H::pc:sourceFile>} ||
                            $file-><AG::ManakaiPerlFile.sourceFile>,
                          $file-><M::ManakaiPerlFile.getNextChunkNumber>)
               . $r
               . sprintf (qq<\n#line 1 "%s [/bc] (Chunk #%d)"\n>,
                          $file-><AG::ManakaiPerlFile.sourceFile>,
                          $file-><M::ManakaiPerlFile.getNextChunkNumber>);
          }__;
        }
      @@@PerlDef:
        @@@@ForCheck: pc|ForClass
        @@@@@:
          my @child = @{$self-><AG::Node.childNodes>};
          if (@child == 1 and 
              {
                block => true, blockContainer => true,
              }->{$child[0]-><AG::Node.localName>}) {
            $r = $child[0]->stringify;
          } else {
            for my $child (@child) {
              if ($child-><AG::Node.localName> eq 'inlineContainer' and
                  1 == @child) {
                $r .= '(' . $child->stringify . ')';
              } else {
                $r .= $child->stringify;
              }
            }

            __DEEP{
              my $file = $self-><AG::PerlCode.fileNode>;
              my $sfile = $file ? $file-><AG::PerlFile.sourceFile> : '';
              $r = sprintf qq<\n#line %d "%s [bc] (Chunk #%d)"\n%s>.
                           qq<\n#line 1 "%s [/bc] (Chunk #%d)"\n>,
                           $self-><AG::PerlCodeStatements.sourceLine> || 1,
                           $self-><AG::PerlCodeStatements.sourceFile> || $sfile,
                           $file ? $file-><M::PerlFile.getNextChunkNumber> : 0,
                           $r,
                           $sfile,
                           $file ? $file-><M::PerlFile.getNextChunkNumber> : 0;
            }__;
          }
##PCCodeBlocks

IFClsETDef:
  @IFQName: PerlAssignment
  @ClsQName: ManakaiPerlAssignment
  @CQName: ManakaiPCAssignment
  @ETQName: pc|assignment

  @IFISA: PerlCode
  @ClsISA: ManakaiPerlCodeFragment
  @CISA: ManakaiPCCode

  @enDesc:
    Perl variable assignment.
  
  @IntMethod:
    @@ForCheck: ManakaiDOM|ForClass !pc|ForClass
    @@Name:newObject
    @@ManakaiDOM:isStatic:1
    @@Description:
      @@@lang:en
      @@@@:
        Creates a new instance object for
        <Class::ManakaiPerlAssignment>. 
    @@Return:
      @@@Type:
        ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl
      @@@Description:
        @@@@lang:en
        @@@@@:
          The newly created node object.
      @@@PerlDef:
        @@@@@:
          my $node = $r = <ClassM::ManakaiDOM:ManakaiDOMNodeObject
                                        ::ManakaiDOM:Perl.new>;
          push @{$node->{<Q::TreeCore:origin>}}, <H::pc:parent>;
          push @{$node->{<Q::TreeCore:subnode0>}}, <H::pc:left>, <H::pc:right>;
          $node->{<H::pc:nodeType>} = 'assign';
        @@@@ImplNote:
          @@@@@lang:en
          @@@@@@:
            Properties: <Q::pc:nodeType>, <Q::pc:left>, <Q::pc:right>,
                <Q::pc:parent>, <Q::pc:useModuleName>, <Q::pc:useCharClassName>, 
               <Q::pc:requireResourceURI>, <Q::pc:requireModuleName>.

  @IntCloneMethod:
    @@Return:
      @@@Type:
        ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl
      @@@PerlDef:
          my $node = $r = <ClassM::ManakaiDOM:ManakaiDOMNodeObject
                                        ::ManakaiDOM:Perl.new>;
          push @{$node->{<Q::TreeCore:origin>}}, <H::pc:parent>;
          push @{$node->{<Q::TreeCore:subnode0>}}, <H::pc:left>, <H::pc:right>;
          $node->{<H::pc:nodeType>} = 'assign';
          for my $prop (<H::pc:left>, <H::pc:right>) {
            my $pack;
            my $cno = $nodeObject->{$prop};
            my $nt = $cno->{<H::pc:nodeType>};
            __CODE{pc:nodeTypeToPackageName::
                     $nodeType => $nt, $packageName => $pack, $object => $cno}__;
                                 ## NOTE: Method name written directly
            my $cno_clone = $pack->_make_clone_object ($cno);
            $node->{$prop} = $cno_clone;
            $cno_clone->{<H::pc:parent>} = $node;
            ## NOTE: Tree ID is not updated yet.
          }
          $node->{<H::pc:requireResourceURI>}
             = {%{$nodeObject->{<H::pc:requireResourceURI>} || {}}};
          $node->{<H::pc:useModuleName>}
             = {%{$nodeObject->{<H::pc:useModuleName>} || {}}};
          $node->{<H::pc:useCharClassName>}
             = {map {$_ => {%{$nodeObject->{<H::pc:useCharClassName>}->{$_}}}}
                keys %{$nodeObject->{<H::pc:useCharClassName>} || {}}};
          $node->{<H::pc:requireModuleName>}
             = {%{$nodeObject->{<H::pc:requireModuleName>} || {}}};

  @ToStringMethod:
    @@Return:
      @@@Type: DOMString
      @@@enDesc:
        Perl code. 
      @@@PerlDef:
        @@@@ForCheck: !pc|ForClass
        @@@@@:
        my $node = $self->{<H::mn:node>};
        $r = <ClassM::ManakaiPerlCodeFragment.getNodeReference>
                ($node->{<H::pc:left>})->stringify . ' = ' .
             <ClassM::ManakaiPerlCodeFragment.getNodeReference>
                ($node->{<H::pc:right>})->stringify;
      @@@PerlDef:
        @@@@ForCheck: pc|ForClass
        @@@@@:
          __DEEP{
            $r = $self-><AG::PerlAssignment.leftCode>->stringify
               . ' = '
               . $self-><AG::PerlAssignment.rightCode>->stringify;
          }__;

  @Attr:
    @@ForCheck: !pc|ForClassCompat
    @@Name: leftCode
    @@enDesc:
      Left-hand expression.
    @@Type: PerlCodeInlines
    @@Get:
      @@@nullCase:
        @@@@enDesc: Left-hand code not yet specified.
      @@@PerlDef:
        __DEEP{
          F: for my $child (@{$self-><AG::Node.childNodes>}) {
            if ($child-><AG::Node.namespaceURI> eq <Q::pc:> and
                $child-><AG::Node.localName> eq 'left') {
              $r = $child-><AG::Node.lastChild>;
              last F;
            }
          }
        }__;
    @@Set:
      @@@PerlDef:
        __DEEP{
          $self-><AG::Node.ownerDocument>-><M::Document.adoptNode> ($given);
          F: {
            for my $child (@{$self-><AG::Node.childNodes>}) {
              if ($child-><AG::Node.namespaceURI> eq <Q::pc:> and
                  $child-><AG::Node.localName> eq 'left') {
                $child-><AS::Node.textContent> ('');
                $child-><M::Node.appendChild> ($given);
                last F;
              }
            }
            my $node = $self-><AG::Node.ownerDocument>
                            -><M::Document.createElementNS>
                                   (<Q::pc:>, 'left');
            $node-><M::Node.appendChild> ($given);
            $self-><M::Node.appendChild> ($node);
          }
        }__;

  @Attr:
    @@ForCheck: !pc|ForClassCompat
    @@Name: rightCode
    @@enDesc:
      Right-hand expression.
    @@Type: PerlCodeInlines
    @@Get:
      @@@nullCase:
        @@@@enDesc: Right-hand code not yet specified.
      @@@PerlDef:
        __DEEP{
          F: for my $child (@{$self-><AG::Node.childNodes>}) {
            if ($child-><AG::Node.namespaceURI> eq <Q::pc:> and
                $child-><AG::Node.localName> eq 'right') {
              $r = $child-><AG::Node.lastChild>;
              last F;
            }
          }
        }__;
    @@Set:
      @@@PerlDef:
        __DEEP{
          $self-><AG::Node.ownerDocument>-><M::Document.adoptNode> ($given);
          F: {
            for my $child (@{$self-><AG::Node.childNodes>}) {
              if ($child-><AG::Node.namespaceURI> eq <Q::pc:> and
                  $child-><AG::Node.localName> eq 'right') {
                $child-><AS::Node.textContent> ('');
                $child-><M::Node.appendChild> ($given);
                last F;
              }
            }
            my $node = $self-><AG::Node.ownerDocument>
                            -><M::Document.createElementNS>
                                   (<Q::pc:>, 'right');
            $node-><M::Node.appendChild> ($given);
            $self-><M::Node.appendChild> ($node);
          }
        }__;
##PerlAssignment

IFClsETDef:
  @IFQName: PerlIf
  @ClsQName: ManakaiPerlIf
  @CQName: ManakaiPCIf
  @ETQName: pc|if

  @IFISA: PerlCode
  @ClsISA: ManakaiPerlCodeFragment
  @CISA: ManakaiPCCode

  @enDesc:
    Perl variable assignment.
  
  @IntMethod:
    @@ForCheck: !pc|ForClass
    @@Name:newObject
    @@ManakaiDOM:isStatic:1
    @@Description:
      @@@lang:en
      @@@@:
        Creates a new instance object for
        <Class::ManakaiPerlAssignment>. 
    @@Return:
      @@@Type:
        ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl
      @@@Description:
        @@@@lang:en
        @@@@@:
          The newly created node object.
      @@@PerlDef:
        @@@@@:
          my $node = $r = <ClassM::ManakaiDOM:ManakaiDOMNodeObject
                                        ::ManakaiDOM:Perl.new>;
          push @{$node->{<Q::TreeCore:origin>}}, <H::pc:parent>;
          push @{$node->{<Q::TreeCore:subnode0>}}, <H::pc:condition>,
                     <H::pc:true>, <H::pc:false>;
          $node->{<H::pc:nodeType>} = 'if';
        @@@@ImplNote:
          @@@@@lang:en
          @@@@@@:
            Properties: <Q::pc:nodeType>, <Q::pc:true>, <Q::pc:false>,
               <Q::pc:useCharClassName>, 
                <Q::pc:parent>, <Q::pc:condition>, <Q::pc:useModuleName>, 
               <Q::pc:requireResourceURI>, <Q::pc:requireModuleName>.

  @IntCloneMethod:
    @@Return:
      @@@Type:
        ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl
      @@@PerlDef:
          my $node = $r = <ClassM::ManakaiDOM:ManakaiDOMNodeObject
                                        ::ManakaiDOM:Perl.new>;
          push @{$node->{<Q::TreeCore:origin>}}, <H::pc:parent>;
          push @{$node->{<Q::TreeCore:subnode0>}}, <H::pc:condition>,
                     <H::pc:true>, <H::pc:false>;
          $node->{<H::pc:nodeType>} = 'if';
          for my $prop (<H::pc:true>, <H::pc:false>, <H::pc:condition>) {
            my $pack;
            my $cno = $nodeObject->{$prop};
            next unless $cno;
            my $nt = $cno->{<H::pc:nodeType>};
            __CODE{pc:nodeTypeToPackageName::
                     $nodeType => $nt, $packageName => $pack, $object => $cno}__;
                                 ## NOTE: Method name written directly
            my $cno_clone = $pack->_make_clone_object ($cno);
            $node->{$prop} = $cno_clone;
            $cno_clone->{<H::pc:parent>} = $node;
            ## NOTE: Tree ID is not updated yet.
          }
          $node->{<H::pc:requireResourceURI>}
             = {%{$nodeObject->{<H::pc:requireResourceURI>} || {}}};
          $node->{<H::pc:useModuleName>}
             = {%{$nodeObject->{<H::pc:useModuleName>} || {}}};
          $node->{<H::pc:useCharClassName>}
             = {map {$_ => {%{$nodeObject->{<H::pc:useCharClassName>}->{$_}}}}
                keys %{$nodeObject->{<H::pc:useCharClassName>} || {}}};
          $node->{<H::pc:requireModuleName>}
             = {%{$nodeObject->{<H::pc:requireModuleName>} || {}}};

  @ToStringMethod:
    @@Return:
      @@@Type: DOMString
      @@@enDesc:
        Perl code. 
      @@@PerlDef:
        @@@@ForCheck: !pc|ForClass
        @@@@@:
        my $node = $self->{<H::mn:node>};
        $r = <ClassM::ManakaiPerlCodeFragment.getNodeReference>
                ($node->{<H::pc:condition>})->stringify;
        my $true_code = <ClassM::ManakaiPerlCodeFragment.getNodeReference>
                     ($node->{<H::pc:true>})->stringify if $node->{<H::pc:true>};
        my $false_code = <ClassM::ManakaiPerlCodeFragment.getNodeReference>
                   ($node->{<H::pc:false>})->stringify if $node->{<H::pc:false>};
        if (defined $true_code) {
          if (defined $false_code) {
            $r = q<if (> . $r . q<) {> . $true_code .
                 q<} else {> . $false_code . q<}>;
          } else {
            $r = q<if (> . $r . q<) {> . $true_code . q<}>;
          }
        } else {
          $r = q<unless (> . $r . q<) {> . $false_code . q<}>;
        }
      @@@PerlDef:
        @@@@ForCheck: pc|ForClass
        @@@@@:
          __DEEP{
            my $tcode = $self-><AG::PerlIf.trueCode>;
            my $fcode = $self-><AG::PerlIf.falseCode>;
            my $ccode = $self-><AG::PerlIf.condition>;
            if (defined $tcode) {
              if (defined $fcode) {
                $r = q<if (> . $ccode->stringify . q<) {> . $tcode->stringify .
                     q<} else {> . $fcode->stringify . qq<}\n>;
              } else {
                $r = q<if (> . $ccode->strigify . q<) {> . $tcode->stringify .
                     qq<}\n>;
              }
            } else {
              $r = q<unless (> . $ccode->stringify . q<) {> . $fcode->stringify .
                   qq<}\n>;
            }
          }__;

  @Attr:
    @@ForCheck: !pc|ForClassCompat
    @@Name: condition
    @@enDesc:
      Condition expression.
    @@Type: PerlCodeInlines
    @@Get:
      @@@nullCase:
        @@@@enDesc: Condition code not yet specified.
      @@@PerlDef:
        __DEEP{
          F: for my $child (@{$self-><AG::Node.childNodes>}) {
            if ($child-><AG::Node.namespaceURI> eq <Q::pc:> and
                $child-><AG::Node.localName> eq 'condition') {
              $r = $child-><AG::Node.lastChild>;
              last F;
            }
          }
        }__;
    @@Set:
      @@@PerlDef:
        __DEEP{
          $self-><AG::Node.ownerDocument>-><M::Document.adoptNode> ($given);
          F: {
            for my $child (@{$self-><AG::Node.childNodes>}) {
              if ($child-><AG::Node.namespaceURI> eq <Q::pc:> and
                  $child-><AG::Node.localName> eq 'condition') {
                $child-><AS::Node.textContent> ('');
                $child-><M::Node.appendChild> ($given);
                last F;
              }
            }
            my $node = $self-><AG::Node.ownerDocument>
                            -><M::Document.createElementNS>
                                   (<Q::pc:>, 'condition');
            $node-><M::Node.appendChild> ($given);
            $self-><M::Node.appendChild> ($node);
          }
        }__;

  @Attr:
    @@ForCheck: !pc|ForClassCompat
    @@Name: trueCode
    @@enDesc:
      True-case code.
    @@Type: PerlCodeBlocks
    @@Get:
      @@@nullCase:
        @@@@enDesc: True-case code not yet specified.
      @@@PerlDef:
        __DEEP{
          F: for my $child (@{$self-><AG::Node.childNodes>}) {
            if ($child-><AG::Node.namespaceURI> eq <Q::pc:> and
                $child-><AG::Node.localName> eq 'tr'.'ue') {
              $r = $child-><AG::Node.lastChild>;
              last F;
            }
          }
        }__;
    @@Set:
      @@@PerlDef:
        __DEEP{
          $self-><AG::Node.ownerDocument>-><M::Document.adoptNode> ($given);
          F: {
            for my $child (@{$self-><AG::Node.childNodes>}) {
              if ($child-><AG::Node.namespaceURI> eq <Q::pc:> and
                  $child-><AG::Node.localName> eq 'tr'.'ue') {
                $child-><AS::Node.textContent> ('');
                $child-><M::Node.appendChild> ($given);
                last F;
              }
            }
            my $node = $self-><AG::Node.ownerDocument>
                            -><M::Document.createElementNS>
                                   (<Q::pc:>, 'tr'.'ue');
            $node-><M::Node.appendChild> ($given);
            $self-><M::Node.appendChild> ($node);
          }
        }__;

  @Attr:
    @@ForCheck: !pc|ForClassCompat
    @@Name: falseCode
    @@enDesc:
      False-case code.
    @@Type: PerlCodeBlocks
    @@Get:
      @@@nullCase:
        @@@@enDesc: True-case code not yet specified.
      @@@PerlDef:
        __DEEP{
          F: for my $child (@{$self-><AG::Node.childNodes>}) {
            if ($child-><AG::Node.namespaceURI> eq <Q::pc:> and
                $child-><AG::Node.localName> eq 'fal'.'se') {
              $r = $child-><AG::Node.lastChild>;
              last F;
            }
          }
        }__;
    @@Set:
      @@@PerlDef:
        __DEEP{
          $self-><AG::Node.ownerDocument>-><M::Document.adoptNode> ($given);
          F: {
            for my $child (@{$self-><AG::Node.childNodes>}) {
              if ($child-><AG::Node.namespaceURI> eq <Q::pc:> and
                  $child-><AG::Node.localName> eq 'fal'.'se') {
                $child-><AS::Node.textContent> ('');
                $child-><M::Node.appendChild> ($given);
                last F;
              }
            }
            my $node = $self-><AG::Node.ownerDocument>
                            -><M::Document.createElementNS>
                                   (<Q::pc:>, 'fal'.'se');
            $node-><M::Node.appendChild> ($given);
            $self-><M::Node.appendChild> ($node);
          }
        }__;
##PerlIf

PropDef:
  @QName:condition
  @enDesc:
    Condition.
PropDef:
  @QName:true
  @enDesc:
    If true.
PropDef:
  @QName:false
  @enDesc:
    If false.

PropDef:
  @QName:left
  @FullName:
    @@lang:en
    @@@: Left hand side
PropDef:
  @QName:right
  @FullName:
    @@lang:en
    @@@: Right hand side

PropDef:
  @QName:label
  @enDesc:
    Perl statement / block label.

ElementTypeBinding:
  @Name: RaiseException
  @ElementType:
    ManakaiDOM:raises

IFClsDef:
  @IFQName: PCImplementation
  @ClsQName: ManakaiPerlCodeImplementation
  @CQName: ManakaiPCImplementation

  @enDesc:
    The class that provides factory methods. 

  @ClsISA: DOMFeature|ManakaiMinimumImplementation||ManakaiDOM|ManakaiDOMLatest
  @ClsISA:
    dx:ManakaiDefaultExceptionHandler::ManakaiDOM:Perl
  @CISA: DOMCore|ManakaiDOMImplementation||ManakaiDOM|ManakaiDOMLatest
  @CISA: dx|ManakaiDefaultExceptionHandler||ManakaiDOM|Perl

  @f:provides: pc|CoreFeature10

  @Method:
    @@Name: createPerlFile
    @@enDesc:
      Creates a Perl code file. 
    @@Return:
      @@@Type: PerlFile
      @@@enDesc: A newly created Perl source file object. 
      @@@PerlDef:
        @@@@ForCheck: !pc|ForClass
        @@@@@:
        $r = <ClassM::ManakaiPerlFile.newObject>;
        __CODE{ManakaiNode:getNewReference||ManakaiDOM|Perl::
                 $object => $r, $ref => $r,
                 $class => {<ClassName::ManakaiPerlFile>}}__;
      @@@PerlDef:
        @@@@ForCheck: pc|ForClass
        @@@@@:
          __DEEP{
            $r = $self-><M::DOMImpl.createDocument> (<Q::pc:>, 'file')
                      -><AG::Document.documentElement>;
          }__;

  @Method:
    @@Name: createPerlPackage
    @@enDesc:
      Creates a new package scope block. 
    @@Param:
      @@@Name: packageName
      @@@Type: DOMString
      @@@enDesc:
        The fully-qualified name of the package to create. 
    @@Return:
      @@@Type: PerlPackage
      @@@enDesc:
        The newly created package scope object. 
      @@@PerlDef:
        @@@@ForCheck: !pc|ForClass
        @@@@@:
        $r = <ClassM::ManakaiPerlPackageScope.newObject>;
        $r->{<H::pc:packageName>} = $packageName;
        __CODE{ManakaiNode:getNewReference||ManakaiDOM|Perl::
                 $object => $r, $ref => $r,
                 $class => {<ClassName::ManakaiPerlPackageScope>}}__;
      @@@PerlDef:
        @@@@ForCheck: pc|ForClass
        @@@@@:
          __DEEP{
            $r = $self-><M::DOMImpl.createDocument>
                      -><M::Document.createElementNS> (<Q::pc:>, 'package');
            $r-><AS::PerlPackage.packageName> ($packageName);
          }__;

  @IntMethod:
    @@ForCheck: ManakaiDOM|ForClass
    @@Name: perlComment
    @@ManakaiDOM:isStatic:1
    @@enDesc:
      Generates a Perl comment string. 
    @@Param:
      @@@Name: str
      @@@Type: DOMString
      @@@enDesc:
        A comment text. 
    @@Return:
      @@@Type: DOMString
      @@@enDesc:
        A Perl comment string.
      @@@PerlDef:
        $r = $str;
        $r =~ s/\n/\n## /g;
        $r =~ s/\n## $/\n/s;
        $r .= "\n" unless $r =~ /\n$/;
        $r = q<## > . $r;

  @IntMethod:
    @@ForCheck: ManakaiDOM|ForClass
    @@Name: rfc3339DateTime
    @@ManakaiDOM:isStatic:1
    @@enDesc:
      Returns RFC 3339 <CODE::date-time> representation of a date. 
    @@Param:
      @@@Name: perlDate
      @@@Type: idl|unsignedLong||ManakaiDOM|all
      @@@enDesc:
        A Perl representation of date. 
    @@Return:
      @@@Type: DOMString
      @@@enDesc:
        RFC 3339 date string. 
      @@@PerlDef:
        my @time = gmtime $perlDate;
        $r = sprintf q<%04d-%02d-%02dT%02d:%02d:%02d+00:00>,
                     $time[5] + 1900, $time[4] + 1, @time[3,2,1,0];

  @IntMethod:
    @@ForCheck: ManakaiDOM|ForClass
    @@Name: versionDateTime
    @@ManakaiDOM:isStatic:1
    @@enDesc:
      Returns date for version. 
    @@Param:
      @@@Name: perlDate
      @@@Type: idl|unsignedLong||ManakaiDOM|all
      @@@enDesc:
        A Perl representation of date. 
    @@Return:
      @@@Type: DOMString
      @@@enDesc:
        A Perl number literal. 
      @@@PerlDef:
        my @time = gmtime $perlDate;
        $r = sprintf q<%04d%02d%02d.%02d%02d>,
                     $time[5] + 1900, $time[4] + 1, @time[3,2,1];
  
  @Method:
    @@Name: perlLiteral
    @@enDesc:
      Perl code representation. 
    @@Param:
      @@@Name: val
      @@@Type: DISPerl|Any||ManakaiDOM|all
      @@@enDesc:
        A Perl value. 
    @@Return:
      @@@Type: DOMString
      @@@enDesc:
        A Perl lexical representation of <P::val>. 
      @@@PerlDef:
        unless (defined $val) {
          $r = q<undef>;
        } elsif (ref $val eq 'ARRAY') {
          __DEEP{
            $r = q<[> . <ClassM::ManakaiPerlCodeImplementation
                                            .perlList> ($val) . q<]>;
          }__;
        } elsif (ref $val eq 'HASH') {
          __DEEP{
            $r = q<{>
               . <ClassM::ManakaiPerlCodeImplementation.perlList>
                   ([map {$_ => $val->{$_}} sort {$a cmp $b} keys %$val])
               . q<}>;
          }__;
        } else {
          $val =~ s/(['\\])/\\$1/g;
          $r = q<'> . $val . q<'>;
        }

  @Method:
    @@Name: perlList
    @@enDesc:
      Perl code representation of a list. 
    @@Param:
      @@@Name: val
      @@@Type: DISPerl|ARRAY||ManakaiDOM|all
      @@@enDesc:
        A Perl array reference. 
    @@Return:
      @@@Type: DOMString
      @@@enDesc:
        A Perl lexical representation of <CODE::@$val>. 
      @@@PerlDef:
        __DEEP{
          $r = join (q<, >, map {<ClassM::ManakaiPerlCodeImplementation
                                              .perlLiteral> ($_)} @{$val});
        }__;

  @Method:
    @@Name: createPerlSub
    @@enDesc:
      Creates a new <IF::PerlSub> object. 
    @@Param:
      @@@Name: subName
      @@@Type: DOMString
      @@@enDesc:
        The name of the subroutine to create.
      @@@nullCase:
        @@@@enDesc:
          The subroutine created has no name. 
    @@Return:
      @@@Type: PerlSub
      @@@enDesc: 
        Newly created Perl subroutine object. 
      @@@PerlDef:
        @@@@ForCheck: !pc|ForClass
        @@@@@:
        __DEEP{
          $r = <ClassM::ManakaiPerlSub.newObject>;
          __CODE{ManakaiNode:getNewReference||ManakaiDOM|Perl::
                   $object => $r, $ref => $r,
                   $class => {<ClassName::ManakaiPerlSub>}}__;
          $r-><AS::ManakaiPerlSub.pcLocalName> ($subName) if defined $subName;
        }__;
      @@@PerlDef:
        @@@@ForCheck: pc|ForClass
        @@@@@:
          __DEEP{
            $r = $self-><M::DOMImpl.createDocument>
                      -><M::Document.createElementNS> (<Q::pc:>, 'sub');
            $r-><M::PerlSub.addPerlName> ($subName) if defined $subName;
          }__;

  @Method:
    @@Name: createPerlUnparsedCode
    @@enDesc:
      Creates a new <Class::ManakaiPerlUnparsedCode> object. 
    @@Param:
      @@@Name: codeArg
      @@@Type: DOMString
      @@@enDesc:
        The code fragment. 
      @@@nullCase:
        @@@@enDesc:
          The fragment initially has no code. 
    @@Return:
      @@@Type: PerlUnparsedCode
      @@@enDesc: 
        Newly created Perl code object. 
      @@@PerlDef:
        @@@@ForCheck: !pc|ForClass
        @@@@@:
        __DEEP{
          $r = <ClassM::ManakaiPerlUnparsedCode.newObject>;
          __CODE{ManakaiNode:getNewReference||ManakaiDOM|Perl::
                   $object => $r, $ref => $r,
                   $class => {<ClassName::ManakaiPerlUnparsedCode>}}__;
          $r-><AS::ManakaiPerlUnparsedCode.code> ($codeArg) if defined $codeArg;
        }__;
      @@@PerlDef:
        @@@@ForCheck: pc|ForClass
        @@@@@:
          __DEEP{
            $r = $self-><M::DOMImpl.createDocument>
                      -><M::Document.createElementNS> (<Q::pc:>, 'unparsed');
            $r-><AS::Node.textContent> ($codeArg) if defined $codeArg;
          }__;

  @Method:
    @@Name: createPerlInlineContainer
    @@enDesc:
      Creates a new <IF::PerlInlineContainer> object. 
    @@Return:
      @@@Type: PerlCodeInlines
      @@@enDesc: 
        Newly created Perl code object. 
      @@@PerlDef:
        @@@@ForCheck: !pc|ForClass
        @@@@@:
        __DEEP{
          $r = <ClassM::ManakaiPerlInlineContainer.newObject>;
          __CODE{ManakaiNode:getNewReference||ManakaiDOM|Perl::
                   $object => $r, $ref => $r,
                   $class => {<ClassName::ManakaiPerlInlineContainer>}}__;
        }__;
      @@@PerlDef:
        @@@@ForCheck: pc|ForClass
        @@@@@:
          __DEEP{
            $r = $self-><M::DOMImpl.createDocument>
                  -><M::Document.createElementNS> (<Q::pc:>, 'inlineContainer');
          }__;

  @Method:
    @@Name: createPerlInlineUnparsedCode
    @@enDesc:
      Creates a new <IF::PerlInlineUnparsedCode> object. 
    @@Param:
      @@@Name: codeArg
      @@@Type: DOMString
      @@@enDesc:
        The code fragment. 
      @@@nullCase:
        @@@@enDesc:
          The fragment initially has no code. 
    @@Return:
      @@@Type: PerlInlineUnparsedCode
      @@@enDesc: 
        Newly created Perl code object. 
      @@@PerlDef:
        @@@@ForCheck: !pc|ForClass
        @@@@@:
        __DEEP{
          $r = <ClassM::ManakaiPerlInlineUnparsedCode.newObject>;
          __CODE{ManakaiNode:getNewReference||ManakaiDOM|Perl::
                   $object => $r, $ref => $r,
                   $class => {<ClassName::ManakaiPerlInlineUnparsedCode>}}__;
          $r-><AS::ManakaiPerlInlineUnparsedCode.code> ($codeArg)
            if defined $codeArg;
        }__;
      @@@PerlDef:
        @@@@ForCheck: pc|ForClass
        @@@@@:
          __DEEP{
            $r = $self-><M::DOMImpl.createDocument>
                   -><M::Document.createElementNS> (<Q::pc:>, 'inlineUnparsed');
            $r-><AS::Node.textContent> ($codeArg) if defined $codeArg;
          }__;

  @Method:
    @@Name: createPerlBare
    @@enDesc:
      Creates a new <IF::PerlTokens> object. 
    @@Param:
      @@@Name: codeArg
      @@@Type: DOMString
      @@@enDesc:
        The code fragment. 
    @@Return:
      @@@Type: PerlTokens
      @@@enDesc: 
        Newly created Perl code object. 
      @@@PerlDef:
        @@@@ForCheck: !pc|ForClass
        @@@@@:
        __DEEP{
          $r = <ClassM::ManakaiPerlBare.newObject>;
          __CODE{ManakaiNode:getNewReference||ManakaiDOM|Perl::
                   $object => $r, $ref => $r,
                   $class => {<ClassName::ManakaiPerlBare>}}__;
          $r-><AS::ManakaiPerlBare.code> ($codeArg);
        }__;
      @@@PerlDef:
        @@@@ForCheck: pc|ForClass
        @@@@@:
          __DEEP{
            $r = $self-><M::DOMImpl.createDocument>
                      -><M::Document.createElementNS> (<Q::pc:>, 'tokens');
            $r-><AS::Node.textContent> ($codeArg) if defined $codeArg;
          }__;

  @Method:
    @@Name: createPerlAtom
    @@enDesc:
      Creates a new <IF::PerlAtom> object. 
    @@Param:
      @@@Name: codeArg
      @@@Type: DOMString
      @@@enDesc:
        The code fragment. 
    @@Return:
      @@@Type: PerlAtom
      @@@enDesc: 
        Newly created Perl code object. 
      @@@PerlDef:
        @@@@ForCheck: !pc|ForClass
        @@@@@:
        __DEEP{
          $r = <ClassM::ManakaiPerlAtom.newObject>;
          __CODE{ManakaiNode:getNewReference||ManakaiDOM|Perl::
                   $object => $r, $ref => $r,
                   $class => {<ClassName::ManakaiPerlAtom>}}__;
          $r-><AS::ManakaiPerlBare.code> ($codeArg);
        }__;
      @@@PerlDef:
        @@@@ForCheck: pc|ForClass
        @@@@@:
          __DEEP{
            $r = $self-><M::DOMImpl.createDocument>
                      -><M::Document.createElementNS> (<Q::pc:>, 'atom');
            $r-><AS::Node.textContent> ($codeArg) if defined $codeArg;
          }__;

  @Method:
    @@Name: createPerlStringLiteral
    @@enDesc:
      Creates a new <IF::PerlStringLiteral> object. 
    @@Param:
      @@@Name: stringArg
      @@@Type: DOMString
      @@@enDesc: A string.
    @@Return:
      @@@Type: PerlStringLiteral
      @@@enDesc: 
        Newly created Perl code object. 
      @@@PerlDef:
        @@@@ForCheck: !pc|ForClass
        @@@@@:
        __DEEP{
          $r = <ClassM::ManakaiPerlStringLiteral.newObject>;
          __CODE{ManakaiNode:getNewReference||ManakaiDOM|Perl::
                   $object => $r, $ref => $r,
                   $class => {<ClassName::ManakaiPerlStringLiteral>}}__;
          $r-><AS::ManakaiPerlStringLiteral.data> ($stringArg);
        }__;
      @@@PerlDef:
        @@@@ForCheck: pc|ForClass
        @@@@@:
          __DEEP{
            $r = $self-><M::DOMImpl.createDocument>
                   -><M::Document.createElementNS> (<Q::pc:>, 'stringLiteral');
            $r-><AS::Node.textContent> ($stringArg);
          }__;

  @Method:
    @@Name: createPerlVariable
    @@enDesc:
      Creates a new <IF::PerlVariable> object. 
    @@Param:
      @@@Name: variableType
      @@@Type: DOMString
      @@@enDesc:
        Variable prefix.
      @@@nullCase:
        @@@@enDesc:
          If the <P::packageName> is <DOM::null>, then 
          the <P::variableType> is detected by the prefix of
          <P::localName>.  Otherwise, it is an unprefixed variable
          such as file handle.
    @@Param:
      @@@Name: packageName
      @@@Type: DOMString
      @@@enDesc:
        Package name.
      @@@nullCase:
        @@@@enDesc:
          The variable belongs to the current package or a 
          lexical-scoped variable.
    @@Param:
      @@@Name: localName
      @@@Type: DOMString
      @@@enDesc:
        Variable name.  If both <P::variableType> and <P::packageName>
        is <DOM::null>, the <P::localName> value may be prefixed
        by any possible <P::variableType> value.
    @@Return:
      @@@Type: PerlVariable
      @@@enDesc: 
        Newly created Perl variable object. 
      @@@PerlDef:
        @@@@ForCheck: !pc|ForClass
        @@@@@:
        __DEEP{
          $r = <ClassM::ManakaiPerlVariable.newObject>;
          __CODE{ManakaiNode:getNewReference||ManakaiDOM|Perl::
                   $object => $r, $ref => $r,
                   $class => {<ClassName::ManakaiPerlVariable>}}__;
          if (not $variableType and not $packageName and
              $localName =~ s/^(\\?[\$\@%&*])//) {
            $variableType = $1;
          }
          $r-><AS::ManakaiPerlVariable.variableType> ($variableType);
          $r-><AS::ManakaiPerlVariable.packageName> ($packageName);
          $r-><AS::ManakaiPerlVariable.localName> ($localName);
        }__;
      @@@PerlDef:
        @@@@ForCheck: pc|ForClass
        @@@@@:
          __DEEP{
            $r = $self-><M::DOMImpl.createDocument>
                      -><M::Document.createElementNS> (<Q::pc:>, 'variable');
            if (not $variableType and not $packageName and
                $localName =~ s/^(\\?[\$\@%&*])//) {
              $variableType = $1;
            }
            $r-><AS::PerlVariable.variableType> ($variableType)
                                                  if defined $variableType;
            $r-><AS::PerlVariable.packageName> ($packageName)
                                                  if defined $packageName;
            $r-><AS::PerlVariable.pcLocalName> ($localName);
          }__;

  @Method:
    @@Name: createPerlBlock
    @@enDesc:
      Creates a new <IF::PerlBlock> object. 
    @@Return:
      @@@Type: PerlBlock
      @@@enDesc: 
        Newly created Perl code object. 
      @@@PerlDef:
        @@@@ForCheck: !pc|ForClass
        @@@@@:
        __DEEP{
          $r = <ClassM::ManakaiPerlBlock.newObject>;
          __CODE{ManakaiNode:getNewReference||ManakaiDOM|Perl::
                   $object => $r, $ref => $r,
                   $class => {<ClassName::ManakaiPerlBlock>}}__;
        }__;
      @@@PerlDef:
        @@@@ForCheck: pc|ForClass
        @@@@@:
          __DEEP{
            $r = $self-><M::DOMImpl.createDocument>
                      -><M::Document.createElementNS> (<Q::pc:>, 'block');
          }__;

  @Method:
    @@Name: createPerlBlockContainer
    @@enDesc:
      Creates a new <Class::ManakaiPerlBlockContainer> object. 
    @@Return:
      @@@Type: PerlCodeBlocks
      @@@enDesc: 
        Newly created Perl code object. 
      @@@PerlDef:
        @@@@ForCheck: !pc|ForClass
        @@@@@:
        __DEEP{
          $r = <ClassM::ManakaiPerlBlockContainer.newObject>;
          __CODE{ManakaiNode:getNewReference||ManakaiDOM|Perl::
                   $object => $r, $ref => $r,
                   $class => {<ClassName::ManakaiPerlBlockContainer>}}__;
        }__;
      @@@PerlDef:
        @@@@ForCheck: pc|ForClass
        @@@@@:
          __DEEP{
            $r = $self-><M::DOMImpl.createDocument>
                    -><M::Document.createElementNS> (<Q::pc:>, 'blockContainer');
          }__;

  @Method:
    @@Name: createPerlStatement
    @@enDesc:
      Creates a new Perl statement.
    @@Param:
      @@@Name: codeArg
      @@@Type: DOMString
      @@@enDesc:
        A Perl statement without terminating <Perl::;>.
      @@@nullCase:
        @@@@enDesc:
          No initial content.
    @@Return:
      @@@Type: PerlStatement
      @@@enDesc:
        The newly created Perl code object. 
      @@@PerlDef:
        @@@@ForCheck: !pc|ForClass
        @@@@@:
        $r = <ClassM::ManakaiPerlStatement.newObject>;
        __CODE{ManakaiNode:getNewReference||ManakaiDOM|Perl::
          $object => $r, $ref => $r,
          $class =>{<ClassName::ManakaiPerlStatement>},
        }__;
        if (defined $codeArg) {
          __DEEP{
            $r-><M::ManakaiPerlAnyContainer.appendBare> ($codeArg);
          }__;
        }
      @@@PerlDef:
        @@@@ForCheck: pc|ForClass
        @@@@@:
          __DEEP{
            $r = $self-><M::DOMImpl.createDocument>
                      -><M::Document.createElementNS> (<Q::pc:>, 'statement');
            if (defined $codeArg) {
              $r-><M::PerlCodeUnits.appendBare> ($codeArg);
            }
          }__;

  @Method:
    @@Name: createPerlIf
    @@enDesc:
      Creates a <IF::PerlIf> object. 
    @@Param:
      @@@Name: conditionArg
      @@@Type: PerlCodeInlines
      @@@enDesc:
        Conditoon code fragment object.
    @@Param:
      @@@Name: trueArg
      @@@Type: PerlCodeBlocks
      @@@enDesc:
        A true code fragment object. 
      @@@nullCase:
        @@@@enDesc: No true code.
    @@Param:
      @@@Name: falseArg
      @@@Type: PerlCodeBlocks
      @@@enDesc:
        A false code fragment object. 
      @@@nullCase:
        @@@@enDesc: No false code.
    @@Return:
      @@@Type: PerlIf
      @@@RaiseException:
        @@@@@:BAD_CHILD_ERR
        @@@@enDesc:
          An attempt is made to append a child
          that is not valid type.
      @@@RaiseException:
        @@@@@:IN_USE_NODE_ERR
        @@@@enDesc:
          An attempt is made to append a node that is 
          already used elsewhere. 
      @@@PerlDef:
        @@@@ForCheck: !pc|ForClass
        @@@@@:
        for my $arg ([conditionArg => $conditionArg]) {
          if ({
            atom => 1, bare => 1, incontainer => 1, assign => true,
            inunparsed => 1, variable => 1, string => true,
          }->{$arg->[1]->{<H::mn:node>}->{<H::pc:nodeType>}}) {
            if ($arg->[1]->{<H::mn:node>}->{<H::pc:parent>}) {
              __EXCEPTION{IN_USE_NODE_ERR::
                pc:childNode => {$arg->[1]},
                MDOMX:param-name => {$arg->[0]},
              }__;
            }
          } else {
            __EXCEPTION{BAD_CHILD_ERR::
              pc:parentNode => {$self},
              pc:childNode => {$arg->[1]},
              MDOMX:param-name => {$arg->[0]},
            }__;
          }
        } # c

        for my $arg ([trueArg => $trueArg],
                     [falseArg => $falseArg]) {
          next unless $arg->[1];
          if ({
                blockcontainer => true,
              }->{$arg->[1]->{<H::mn:node>}->{<H::pc:nodeType>}}) {
            if ($arg->[1]->{<H::mn:node>}->{<H::pc:parent>}) {
              __EXCEPTION{IN_USE_NODE_ERR::
                pc:childNode => {$arg->[1]},
                MDOMX:param-name => {$arg->[0]},
              }__;
            }
          } else {
            __EXCEPTION{BAD_CHILD_ERR::
              pc:parentNode => {$self},
              pc:childNode => {$arg->[1]},
              MDOMX:param-name => {$arg->[0]},
            }__;
          }
        } # t/f

        my $assign = <ClassM::ManakaiPerlIf.newObject>;
        $assign->{<H::pc:condition>} = $conditionArg->{<H::mn:node>};
        $assign->{<H::pc:true>} = $trueArg->{<H::mn:node>} if $trueArg;
        $assign->{<H::pc:false>} = $falseArg->{<H::mn:node>} if $falseArg;
        $assign-><M::MNodeObject.importTree> ($_)
           for (grep {$_}
                  $assign->{<H::pc:condition>}, $assign->{<H::pc:true>},
                  $assign->{<H::pc:false>});
        $conditionArg->{<H::mn:node>}->{<H::pc:parent>} = $assign;
        $trueArg->{<H::mn:node>}->{<H::pc:parent>} = $assign if $trueArg;
        $falseArg->{<H::mn:node>}->{<H::pc:parent>} = $assign if $falseArg;
        if (defined wantarray) {
          __CODE{ManakaiNode:getNewReference||ManakaiDOM|Perl::
            $object => $assign, $ref => $r,
            $class =>{<ClassName::ManakaiPerlIf>},
          }__;
        }
      @@@PerlDef:
        @@@@ForCheck: pc|ForClass
        @@@@@:
          for my $arg ([conditionArg => $conditionArg]) {
            if ({
              atom => 1, tokens => 1, inlineContainer => 1, assignment => true,
              inlineUnparsed => 1, variable => 1, stringLiteral => true,
            }->{$arg->[1]-><AG::Node.localName>}) {
              if ($arg->[1]-><AG::Node.parentNode>) {
                __EXCEPTION{IN_USE_NODE_ERR::
                  pc:childNode => {$arg->[1]},
                  MDOMX:param-name => {$arg->[0]},
                }__;
              }
            } else {
              __EXCEPTION{BAD_CHILD_ERR::
                pc:parentNode => {$self},
                pc:childNode => {$arg->[1]},
                MDOMX:param-name => {$arg->[0]},
              }__;
            }
          } # c

          for my $arg ([trueArg => $trueArg],
                       [falseArg => $falseArg]) {
            next unless $arg->[1];
            if ({
                  blockContainer => true,
                }->{$arg->[1]-><AG::Node.localName>}) {
              if ($arg->[1]-><AG::Node.parentNode>) {
                __EXCEPTION{IN_USE_NODE_ERR::
                  pc:childNode => {$arg->[1]},
                  MDOMX:param-name => {$arg->[0]},
                }__;
              }
            } else {
              __EXCEPTION{BAD_CHILD_ERR::
                pc:parentNode => {$self},
                pc:childNode => {$arg->[1]},
                MDOMX:param-name => {$arg->[0]},
              }__;
            }
          } # t/f

          __DEEP{
            $r = $self-><M::DOMImpl.createDocument>
                      -><M::Document.createElementNS>
                            (<Q::pc:>, 'if');
            $r-><AS::PerlIf.condition> ($conditionArg) if $conditionArg;
            $r-><AS::PerlIf.trueCode> ($trueArg) if $trueArg;
            $r-><AS::PerlIf.falseCode> ($falseArg) if $falseArg;
          }__;
##PCImplementation

ResourceDef:
  @QName: MNodeObject
  @AliasFor:
    ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl
  @For: ManakaiDOM|Perl

PropDef:
  @QName: code
  @enDesc: Perl code. 

PropDef:
  @QName: sourceFile
  @enDesc:
    Source file. 

PropDef:
  @QName: sourceLine
  @enDesc:
    Source line number. 

PropDef:
  @QName: currentSourceFile
  @enDesc:
    <QUOTE::Current> source file. 

PropDef:
  @QName: currentSourceLine
  @enDesc:
    <QUOTE::Current> source line number. 

PropDef:
  @QName: prototype
  @enDesc:
    Prototype of subroutine.

PropDef:
  @QName: parent
  @enDesc:
    Higher-level object. 

PropDef:
  @QName: sub
  @enDesc:
    Perl subroutines. 

PropDef:
  @QName: packageName
  @Type:
    Perl:package-name::ManakaiDOM:all
  @enDesc:
    The fully qualified names of packages. 

PropDef:
  @QName: childNodes
  @enDesc:
    Child code fragments. 

PropDef:
  @QName: localName
  @enDesc:
    Scoped names.

ResourceDef:
  @QName: DOMImpl
  @AliasFor: DOMCore|DOMImplementation
  @For: ManakaiDOM|DOM

ResourceDef:
  @QName: Node
  @AliasFor: DOMCore|Node
  @For: ManakaiDOM|DOM

ResourceDef:
  @QName: Element
  @AliasFor: DOMCore|Element
  @For: ManakaiDOM|DOM

ResourceDef:
  @QName: Document
  @AliasFor: DOMCore|Document
  @For: ManakaiDOM|DOM

## -- Exceptions

ResourceDef:
  @rdf:type:
    @@@: dis|MultipleResource
    @@ForCheck: !ManakaiDOM|ForIF !ManakaiDOM|ForClass
  @resourceFor: ManakaiDOM|ForIF
  @resourceFor: ManakaiDOM|ForClass

  @For: ManakaiDOM|Perl

  @rdf:type:
    @@@: dx|Interface
    @@ForCheck: ManakaiDOM|ForIF

  @rdf:type:
    @@@: dx|Class
    @@ForCheck: ManakaiDOM|ForClass

  @Implement:
    @@@: ||ManakaiDOM|ManakaiDOM|ManakaiDOM||ManakaiDOM|ForIF
    @@ContentType: DISCore|TFPQNames
    @@ForCheck: ManakaiDOM|ForClass
  @Implement:
    @@@: ||ManakaiDOM|ManakaiDOM|ManakaiDOMLatest||ManakaiDOM|ForIF
    @@ContentType: DISCore|TFPQNames
    @@ForCheck: ManakaiDOM|ForClass
  @dx:implementedBy: ||ManakaiDOM|ManakaiDOMLatest||ManakaiDOM|ForClass

  @f:implements: pc|CoreFeature10

  @ISA:
    @@@: dx|Exception||ManakaiDOM|Perl
    @@ForCheck: ManakaiDOM|ForClass

  @IFQName: PCException
  @QName:
    @@@: ManakaiPCException
    @@ForCheck: ManakaiDOM|ForClass

  @enDesc:
    Exceptions for the <Module::Util:PerlCode> module.

  @ResourceDef:
    @@ForCheck: ManakaiDOM|ForIF
    @@rdf:type: DISLang|ConstGroup

    @@IFQName: PCExceptionCode

    @@enDesc:
      Exception codes for <IF::PCException>. 

    @@Type: idl|unsignedShort||ManakaiDOM|all
    @@rdfs:subClassOf: idl|unsignedShort||ManakaiDOM|all

    @@XConstDef:
      @@@Name: HIERARCHY_REQUEST_ERR
      @@@Value:
        @@@@@:3
        @@@@ContentType: DISCore|Integer
      @@@enDesc:
        An attempt is made to break the hierarchy. 
      @@@XSubTypeDef:
        @@@@QName: BAD_CHILD_ERR
        @@@@enDesc:
          An attempt is made to append a node as a child whose type 
          is not allowed. 
        @@@@XParam:
          @@@@@QName: childNode
          @@@@@enDesc:
            The node attempted to append. 
        @@@@XParam:
          @@@@@QName: parentNode
          @@@@@enDesc:
            The node to whose child list an attempt to append is made. 
      @@@XSubTypeDef:
        @@@@QName: IN_USE_NODE_ERR
        @@@@enDesc:
          An attempt is made to append a node that has already been used
          elsewhere. 
        @@@@XParam:
          @@@@@QName: childNode
          @@@@@enDesc:
            The node attempted to append. 
        @@@@XParam:
          @@@@@QName: parentNode
          @@@@@enDesc:
            The parent node of the <XP::childNode>. 
    @@XConstDef:
      @@@Name: NOT_SUPPORTED_ERR
      @@@Value:
        @@@@@:9
        @@@@ContentType: DISCore|Integer
      @@@enDesc:
        An attempt is made to do something the implementation does not support. 
      @@@XSubTypeDef:
        @@@@QName: UNSUPPORTED_OPERATOR_ERR
        @@@@enDesc:
          The implementation does not support the specified operator. 
        @@@@XParam:
          @@@@@QName: operator
          @@@@@enDesc:
            The operator that is not supported. 
        @@@@enMufDef:
          Operator "%p (name => {<Q::pc:operator>});" is not supported
##PCException

ElementTypeBinding:
  @Name: XConstDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: dx|ErrorCode

ElementTypeBinding:
  @Name: XSubTypeDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: dx|ErrorSubCode

ElementTypeBinding:
  @Name: XParam
  @ElementType:
    ecore:hasParameter

ElementTypeBinding:
  @Name: XParamDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: ecore|Parameter
    @@For: =ManakaiDOM|all

ElementTypeBinding:
  @Name: enMufDef
  @ElementType:
    dis:Def
  @ShadowContent:
    @@ContentType:
      lang:muf
    @@lang:en

ElementTypeBinding:
  @Name: Method
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:Method

ElementTypeBinding:
  @Name: ToStringMethod
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:Method
    @@Operator:
      @@@@:
        DISPerl:AsStringMethod
      @@@ContentType: DISCore|QName
    @@Description:
      @@@lang:en
      @@@@:
        Returns the textual Perl source code representation of this object. 

ElementTypeBinding:
  @Name: NumValMethod
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:Method
    @@Operator:
      @@@@: 0+
      @@@ContentType:
        lang:Perl
    @@Description:
      @@@lang:en
      @@@@:
        Returns the numeric value of this object.

ElementTypeBinding:
  @Name: IntCloneMethod
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:Method
    @@Name: makeCloneObject
    @@Description:
      @@@lang:en
      @@@@:
        Returns the node object of a deep clone of a node object.
    @@ManakaiDOM:isStatic:1
    @@ManakaiDOM:isForInternal:1
    @@ForCheck: ManakaiDOM|ForClass pc|ForClassCompat
    @@ResourceDef:
      @@@rdf:type:
        DISLang:MethodParameter
      @@@Name: nodeObject
      @@@Type: 
        ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl
      @@@Description:
        @@@@lang:en
        @@@@@: Node object to copy.
  @ShadowSibling:
    @@ResourceDef:
      @@@ForCheck: pc|ForClassCompat
      @@@rdf:type:
        DISLang:Method
      @@@Operator:
        @@@@@:
          DISPerl:CloneMethod
        @@@@ContentType:
          dis:TypeQName
      @@@Description:
        @@@@lang:en
        @@@@@:
          Generates a deep clone of this node and returns it.
      @@@ResourceDef:
        @@@@rdf:type:
          DISLang:MethodReturn
        @@@@Type: ManakaiPerlCodeFragment
        @@@@Description:
          @@@@@lang:en
          @@@@@@: 
            The newly created clone node.
            \
            {NOTE:: The <A::.parentNode> attribute of the clone
                    is set to <DOM::null>.
            \
            }
        @@@@Def:
          @@@@@ForCheck: ManakaiDOM|ForClass
          @@@@@ContentType:
            lang:Perl
          @@@@@@:
                            ## NOTE: Method name directly written
            my $ro = $self->_make_clone_object ($self->{<H::mn:node>});
            $ro-><M::ManakaiDOM:ManakaiDOMNodeObject
                   ::ManakaiDOM:Perl.changeTreeID>
                                 (<Code::ManakaiDOM:generateUniqueID
                                       ||ManakaiDOM:Perl>);
            $r = <ClassM::ManakaiPerlCodeFragment.getNodeReference> ($ro);

ElementTypeBinding:
  @Name: IntMethod
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:Method
    @@ManakaiDOM:isForInternal:1

ElementTypeBinding:
  @Name: Attr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:Attribute

ElementTypeBinding:
  @Name: Return
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:MethodReturn

ElementTypeBinding:
  @Name: Get
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:AttributeGet

ElementTypeBinding:
  @Name: Set
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:AttributeSet

ElementTypeBinding:
  @Name: Param
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:MethodParameter

ElementTypeBinding:
  @Name: plCName
  @ElementType:
    DISPerl:exportTagName

ElementTypeBinding:
  @Name: PerlDef
  @ElementType:
    dis:Def
  @ShadowContent:
    @@ContentType:
      lang:Perl
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: PerlCDef
  @ElementType:
    dis:Def
  @ShadowContent:
    @@ContentType:
      lang:Perl

ElementTypeBinding:
  @Name: disDef
  @ElementType:
    dis:Def
  @ShadowContent:
    @@ContentType:
      lang:dis
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: InCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:InCase

ElementTypeBinding:
  @Name: nullCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:InCase
    @@Value:
      @@@is-null:1

ElementTypeBinding:
  @Name: TrueCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:InCase
    @@Value:
      @@@@:1
      @@@ContentType: DISCore|Boolean
    @@Type:
      DOMMain:boolean::ManakaiDOM:all


ElementTypeBinding:
  @Name: FalseCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:InCase
    @@Value:
      @@@@:0
      @@@ContentType: DISCore|Boolean
    @@Type:
      DOMMain:boolean::ManakaiDOM:all

ElementTypeBinding:
  @Name: enDesc
  @ElementType:
    dis:Description
  @ShadowContent:
    @@lang:en

ElementTypeBinding:
  @Name: PropDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      rdf:Property
    @@For: =ManakaiDOM|all

ElementTypeBinding:
  @Name: NamedParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:MethodParameter
    @@DISPerl:isNamedParameter:1

