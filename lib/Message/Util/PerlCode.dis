Module:
  @QName:
    Util:PerlCode
  @FullName:
    @@lang: en
    @@@:
      Perl Code Constructor
  @Namespace:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/PerlCode#
  
  @Description:
    @@lang:en
    @@@:
      This module provides an object-oriented interface to construct 
      Perl code. 

  @DISCore:author: DISCore|Wakaba
  @License:
    @@@:
      license:Perl+MPL
    @@Original:
      @@@FullName:
        manakai <CODE::lib/manakai/genlib.pl>
      @@@Year:2004
      @@@DISCore:author: DISCore|Wakaba
  @Date:
    $Date: 2006/11/03 17:53:34 $
  
  @Require:
    @@Module:
      @@@QName: MDOM|DOMCore
      @@@WithFor: ManakaiDOM|ManakaiDOMLatest
    @@Module:
      @@@QName: DISlib|DISMarkup
      @@@WithFor: ManakaiDOM|all
  @DefaultFor: ManakaiDOM|ManakaiDOMLatest

Namespace:
  @c:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#
  @cfg:
    http://suika.fam.cx/www/2006/dom-config/
  @DIS:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS#
  @dis:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#dis--
  @DISlib:
    http://suika.fam.cx/~wakaba/archive/2004/dis/
  @f:
    http://suika.fam.cx/~wakaba/archive/2004/dom/feature#
  @idl:
    http://suika.fam.cx/~wakaba/archive/2004/dis/IDL#
  @kwd:
    http://suika.fam.cx/~wakaba/archive/2005/rfc2119/
  @lang:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#
  @license:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/license#
  @ManakaiDOM:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#
  @MDOM:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#ManakaiDOM.
  @MDOMX:
    http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#
  @pc:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/PerlCode#
  @pc2:
    http://suika.fam.cx/~wakaba/archive/2005/12/pc/
  @rdf:
    http://www.w3.org/1999/02/22-rdf-syntax-ns#
  @s:
    http://suika.fam.cx/~wakaba/archive/2004/dis/Markup#
  @tc:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/DOM/TreeCore/
  @td:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/DOM/Document/
  @te:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/DOM/Element/
  @test:
    http://suika.fam.cx/~wakaba/archive/2004/dis/Test#
  @Util:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/

## -- Module sets

ResourceDef:
  @QName: Util|
  @For: ManakaiDOM|DOM
  @rdf:type: dis|ModuleGroup
  @FullName:
    @@lang:en
    @@@:
      Manakai support modules
  @DISPerl:packageName:
    Message::Util::
  @DISPerl:interfacePackageName:
    @@@:
      Message::Util::IF::
    @@For: ManakaiDOM|ManakaiDOM !ManakaiDOM|ManakaiDOMLatest
  @DISPerl:interfacePackageName:
    @@@:
      Message::Util::IFLatest::
    @@For: ManakaiDOM|ManakaiDOMLatest
  @ImplNote:
    @@lang:en
    @@@:
      Resources <Q::Util|> for <Q::ManakaiDOM|all> and for <Q::ManakaiDOM|Perl>
      is defined in module <Module::Util|ManakaiNode>.

## -- Features

ElementTypeBinding:
  @Name: FeatureDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: f|Feature
    @@For: =ManakaiDOM|all

ElementTypeBinding:
  @Name: FeatureVerDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: f|Feature

ElementTypeBinding:
  @Name: featureQName
  @ElementType:
    f:name
  @ShadowContent:
    @@ContentType: DISCore|QName

FeatureDef:
  @QName: CoreFeature
  @featureQName:
    Util:PerlCode
  @FeatureVerDef:
    @@QName: CoreFeature10
    @@Version: 1.0
    @@ISA: CoreFeature
    @@FullName:
      @@@lang:en
      @@@@:
        Perl Code Constructor, version 1.0
    @@Description:
      @@@lang:en
      @@@@:
        Perl Code Constructor, version 1.0.

ElementTypeBinding:
  @Name: IFClsDef
  @ElementType: 
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      @@@@: dis|MultipleResource
      @@@ForCheck: !ManakaiDOM|ForIF !ManakaiDOM|ForClass
    @@resourceFor: ManakaiDOM|ForIF
    @@resourceFor:
      @@@@: ManakaiDOM|ForClass
      @@@For: ManakaiDOM|ManakaiDOMLatest
    @@For: ManakaiDOM|ManakaiDOM

    @@rdf:type:
      @@@@: DISLang|Interface
      @@@ForCheck: ManakaiDOM|ForIF

    @@rdf:type:
      @@@@: DISLang|Class
      @@@ForCheck: ManakaiDOM|ForClass
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOM||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOMLatest||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOMLatest

    @@f:implements: pc|CoreFeature10

ElementTypeBinding:
  @Name: IFClsETDef
  @ElementType: 
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      @@@@: dis|MultipleResource
      @@@ForCheck: !ManakaiDOM|ForIF !ManakaiDOM|ForClass !s|ForML
    @@resourceFor: ManakaiDOM|ForIF
    @@resourceFor: ManakaiDOM|ForClass
    @@resourceFor: s|ForML
    @@For: ManakaiDOM|ManakaiDOM

    @@rdf:type:
      @@@@: DISLang|Interface
      @@@ForCheck: ManakaiDOM|ForIF

    @@rdf:type:
      @@@@: DISLang|Class
      @@@ForCheck: ManakaiDOM|ForClass
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOM||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOMLatest||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOMLatest

    @@s:elementType:
      @@@@: ||+||s|ForML
      @@@ContentType: DISCore|TFPQNames
      @@@DISCore:stopISARecursive:1

    @@rdf:type:
      @@@@: s|ElementType
      @@@ForCheck: s|ForML

    @@f:implements: pc|CoreFeature10

ElementTypeBinding:
  @Name: IFQName
  @ElementType:
    dis:QName
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForIF

ElementTypeBinding:
  @Name: CQName
  @ElementType:
    dis:QName
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: IFISA
  @ElementType:
    dis:ISA
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForIF

ElementTypeBinding:
  @Name: CISA
  @ElementType:
    dis:ISA
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass

## -- Classes

IFClsDef:
  @IFQName: PerlCode
  @CQName: ManakaiPCCode

  @CISA: te|ManakaiDOMElement

  @s:elementType: AnyPCElement||ManakaiDOM|all
  @s:elementType: AnyPC2Element||ManakaiDOM|all

  @enDesc:
    A class on which another Perl code classes are constructed based. 

  @Test:
    @@QName: Document.createElementNS.PerlCode.pc1.test
    @@PerlDef:
      my $doc;
      __CODE{createPCDocumentForTest:: $doc => $doc}__;

      my $el1 = $doc-><M::Document.createElementNS>
                        (<Q::pc:>, 'pc:NoSuchElementType');

      $test->id ('pc.Element');
      $test->assert_isa ($el1, <IFName::Element>);

      $test->id ('pc.PerlCode');
      $test->assert_isa ($el1, <IFName::PerlCode>);
  @Test:
    @@QName: Document.createElementNS.PerlCode.pc2.test
    @@PerlDef:
      my $doc;
      __CODE{createPCDocumentForTest:: $doc => $doc}__;

      my $el2 = $doc-><M::Document.createElementNS>
                        (<Q::pc2:>, 'pc2:NoSuchElementType');

      $test->id ('pc2.Element');
      $test->assert_isa ($el2, <IFName::Element>);

      $test->id ('pc2.PerlCode');
      $test->assert_isa ($el2, <IFName::PerlCode>);

  @Attr:
    @@Name: fileNode
    @@enDesc:
      The root <QUOTE::file> node of the tree to which this node belongs.
    @@Type: PerlCode
    @@Get:
      @@@enDesc:
        The <QUOTE::file> node of the tree.
      @@@nullCase:
        @@@@enDesc:
          This node does not belong to any file tree.
      @@@PerlDef:
          __DEEP{
            $r = $self-><AG::Node.ownerDocument>
                      -><AG::Document.documentElement>;
            if ($r) {
              unless (defined $r-><AG::Node.namespaceURI> and
                      $r-><AG::Node.namespaceURI> eq <Q::pc:> and
                      $r-><AG::Node.localName> eq 'file') {
                $r = null;
              }
            }
          }__;

  @Method:
    @@Name: replaceVariable
    @@enDesc:
      Replaces a variable. 
      \
      {NOTE:: For objects of type <Class::ManakaiPerlFile>, 
              <Class::ManakaiPerlPackageScope>,
              <Class::ManakaiPerlSub> and
              <Class::ManakaiPerlVariable>, the result is undefined.
      \
      }
    @@Param:
      @@@Name: originalVariable
      @@@Type:
        lang:Perl::ManakaiDOM:all
      @@@enDesc:
        Original variable specification, including prefix. 
        \
        {NOTE:: Qualified name variable and hash key is not supported.
        \
        }
    @@Param:
      @@@Name: newValue
      @@@Type: 
        DOMMain:any::ManakaiDOM:all
      @@@enDesc:
        New value to replace.
      @@@InCase:
        @@@@Type: PerlCode
        @@@@enDesc:
          New Perl code fragment to replace by.
      @@@InCase:
        @@@@Type:
          lang:Perl::ManakaiDOM:all
        @@@@enDesc:
          Inline Perl code fragment string to replace by.
    @@Return:
      @@@PerlDef:
          my $ln = $self-><AG::Node.localName>;
          if ($ln eq 'unparsed' or
              $ln eq 'inlineUnparsed') {
            my $new_var = ref $newValue ? $newValue->stringify : ''.$newValue;
            my $val = $self-><AG::Node.textContent>;
            $val =~ s/\Q$originalVariable\E\b/$new_var/g;
            $self-><AS::Node.textContent> ($val);
          } elsif ($ln eq 'stringLiteral' or $ln eq 'atom' or
                   $ln eq 'tokens') {
            # 
          } elsif ($self-><M::Node.hasChildNodes>) {
            __DEEP{
              my @child_nodes = @{$self-><AG::Node.childNodes>};
              for my $child_node (@child_nodes) {
                my $nsuri = $child_node-><AG::Node.namespaceURI>;
                if (defined $nsuri and
                    ($nsuri eq <Q::pc:> or $nsuri eq <Q::pc2:>)) {
                  if ($child_node-><AG::Node.localName> eq 'variable') {
                    if (substr ($originalVariable, 0, 1) eq
                          $child_node-><AG::PerlVariable.variableType> and
                        not defined $child_node-><AG::PerlVariable.packageName> and
                        substr ($originalVariable, 1) eq
                          $child_node-><AG::PerlVariable.pcLocalName> and
                        not defined $child_node-><AG::PerlVariable.hashKey>) {
                      if (ref $newValue) {
                        $self-><M::Node.replaceChild> ($child_node => $newValue);
                      } else {  ## ISSUE: Is this correct?
                        $child_node-><M::PerlCodeInlines.appendCode> ($newValue);
                      }
                    }
                  } else {  ## Non-variable child
                    $child_node-><M::PerlCode.replaceVariable>
                                              ($originalVariable => $newValue);
                  }
                } else {
                  # 
                }
              }
            }__;
          } # has child

  @ResourceDef:
    @@ForCheck: ManakaiDOM|ForClass
    @@QName: addNameListAttr
    @@rdf:type: DISPerl|BlockCode
    @@PerlDef:
      my $__v = $node-><M::Element.getAttributeNS> (<Q::pc:>, $attrName);
      my %__mn = map {$_ => true}
                 split /\s+/, defined $__v ? $__v : '';
      $__mn{$newName} = true;
      $node-><M::Element.setAttributeNS>
                      (<Q::pc:>, 'pc:'.$attrName => join ' ', keys %__mn);


  @Method:
    @@Name: addUsePerlModuleName
    @@enDesc:
      Adds a Perl module into the list of Perl modules 
      <Perl::use>d by this code fragment.
    @@Param:
      @@@Name: moduleName
      @@@Type: DOMString
      @@@enDesc:
        The name of the module package that should be <Perl::use>d.
    @@Return:
      @@@PerlDef:
          __DEEP{
            __CODE{addNameListAttr::
              $node => {$self},
              $attrName => 'useModuleName',
              $newName => {$moduleName},
            }__;
          }__;

  @Method:
    @@Name: addUseCharClassName
    @@enDesc:
      Adds a Perl module into the list of Perl character classes 
      <Perl::use>d by this code fragment.
    @@Param:
      @@@Name: moduleName
      @@@Type: DOMString
      @@@enDesc:
        The name of the module package that should be <Perl::use>d.
    @@Param:
      @@@Name: charClassName
      @@@Type: DOMString
      @@@enDesc:
        The name of the character class.
    @@Return:
      @@@PerlDef:
          __DEEP{
            __CODE{addNameListAttr::
              $node => {$self},
              $attrName => 'useCharClassName',
              $newName => {$moduleName.'.'.$charClassName},
            }__;
          }__;

  @Method:
    @@Name: addRequirePerlModuleName
    @@enDesc:
      Adds a Perl module into the list of Perl modules 
      <Perl::require>d by this code fragment.
    @@Param:
      @@@Name: moduleName
      @@@Type: DOMString
      @@@enDesc:
        The name of the module package that should be <Perl::require>d.
    @@Return:
      @@@PerlDef:
          __DEEP{
            __CODE{addNameListAttr::
              $node => {$self},
              $attrName => 'requireModuleName',
              $newName => {$moduleName},
            }__;
          }__;

  @Method:
    @@Name: addExceptionInterfacePackageName
    @@enDesc:
      Adds a Perl exception interface into the list of Perl packages.
    @@Param:
      @@@Name: moduleName
      @@@Type: DOMString
      @@@enDesc:
        The name of the interface package.
    @@Return:
      @@@PerlDef:
          __DEEP{
            __CODE{addNameListAttr::
              $node => {$self},
              $attrName => 'exceptionInterfaceName',
              $newName => {$moduleName},
            }__;
          }__;

  @ResourceDef:
    @@ForCheck: ManakaiDOM|ForClass
    @@QName: getNameListAttrR
    @@rdf:type: DISPerl|BlockCode
    @@PerlDef:
      my @__nodes = ($node);
      my %__result;
      while (@__nodes) {
        my $__cnode = shift @__nodes;
        if ($__cnode-><AG::Node.nodeType> == <C::Node.ELEMENT_NODE>) {
          my $__v = $__cnode-><M::Element.getAttributeNS>
                               (<Q::pc:>, $attrName);
          for (split /\s+/, defined $__v ? $__v : '') {
            $__result{$_} = true;
          }
          push @__nodes, @{$__cnode-><AG::Node.childNodes>};
        }
      }
      $result = [sort {$a cmp $b} keys %__result];
  @ResourceDef:
    @@ForCheck: ManakaiDOM|ForClass
    @@QName: getNameListAttrRM
    @@rdf:type: DISPerl|BlockCode
    @@enDesc:
      Except <Q::pc:require> subtree.
    @@PerlDef:
      my @__nodes = ();
      my %__result;
      {
        my $__cnode = $node;
        if ($__cnode-><AG::Node.nodeType> == <C::Node.ELEMENT_NODE>) {
          my $__v = $__cnode-><M::Element.getAttributeNS>
                               (<Q::pc:>, $attrName);
          for (split /\s+/, defined $__v ? $__v : '') {
            $__result{$_} = true;
          }
          push @__nodes, @{$__cnode-><AG::Node.childNodes>};
        }
      }
      N: while (@__nodes) {
        my $__cnode = shift @__nodes;
        if ($__cnode-><AG::Node.nodeType> == <C::Node.ELEMENT_NODE>) {
          if (defined $__cnode-><AG::Node.namespaceURI> and
              $__cnode-><AG::Node.namespaceURI> eq <Q::pc:> and
              $__cnode-><AG::Node.localName> eq 'package') {
            next N;
          }
          my $__v = $__cnode-><M::Element.getAttributeNS>
                               (<Q::pc:>, $attrName);
          for (split /\s+/, defined $__v ? $__v : '') {
            $__result{$_} = true;
          }
          push @__nodes, @{$__cnode-><AG::Node.childNodes>};
        }
      }
      $result = [sort {$a cmp $b} keys %__result];
  @ResourceDef:
    @@ForCheck: ManakaiDOM|ForClass
    @@QName: getNameListAttr
    @@rdf:type: DISPerl|BlockCode
    @@PerlDef:
      my %__result;
      my $__v = $node-><M::Element.getAttributeNS> (<Q::pc:>, $attrName);
      for (split /\s+/, defined $__v ? $__v : '') {                 
        $__result{$_} = true;
      }
      $result = [sort {$a cmp $b} keys %__result];

  @Method:
    @@Name: getUsePerlModuleNameList
    @@enDesc:
      Returns a list of Perl modules names that is <Perl::use>d
      by this code fragment, including all descendant nodes
      except <Q::pc:package> nodes and their descendant nodes. 
    @@Return:
      @@@Type: DISPerl|ARRAY||ManakaiDOM|all
      @@@enDesc:
        A list of module names.  Note that the list is <EM::dead>; 
        any modification to it does not affect to the code fragment
        and vice versa.
      @@@PerlDef:
          __DEEP{
            __CODE{getNameListAttrRM::
              $node => {$self},
              $attrName => 'useModuleName',
              $result => {$r},
            }__;
          }__;

  @Method:
    @@Name: getUseCharClassNameList
    @@enDesc:
      Returns a list of Perl character class names that is <Perl::use>d
      by this code fragment, including all descendant nodes
      except <Q::pc:package> nodes and their descendant nodes. 
    @@Return:
      @@@Type: DISPerl|HASH||ManakaiDOM|all
      @@@enDesc:
        A list of module names.  Note that the list is <EM::dead>; 
        any modification to it does not affect to the code fragment
        and vice versa.
      @@@PerlDef:
          my $mc;
          __DEEP{
            __CODE{getNameListAttrRM::
              $node => {$self},
              $attrName => 'useCharClassName',
              $result => {$mc},
            }__;
          }__;
          for (@$mc) {
            my ($m, $c) = split /\./, $_, 2;
            $r->{$m}->{$c} = true;
          }

  @Method:
    @@Name: getRequirePerlModuleNameList
    @@enDesc:
      Returns a list of Perl modules names that is <Perl::require>d
      by this code fragment, including all descendant nodes. 
    @@Return:
      @@@Type: DISPerl|ARRAY||ManakaiDOM|all
      @@@enDesc:
        A list of module names.  Note that the list is <EM::dead>; 
        any modification to it does not affect to the code fragment
        and vice versa.
      @@@PerlDef:
          __DEEP{
            __CODE{getNameListAttrR::
              $node => {$self},
              $attrName => 'requireModuleName',
              $result => {$r},
            }__;
          }__;

  @Method:
    @@Name: getExceptionInterfacePackageNameList
    @@enDesc:
      Returns a list of Perl exception interface package names 
      by this code fragment, including all descendant nodes. 
    @@Return:
      @@@Type: DISPerl|ARRAY||ManakaiDOM|all
      @@@enDesc:
        A list of package names.  Note that the list is <EM::dead>; 
        any modification to it does not affect to the code fragment
        and vice versa.
      @@@PerlDef:
          __DEEP{
            __CODE{getNameListAttrR::
              $node => {$self},
              $attrName => 'exceptionInterfaceName',
              $result => {$r},
            }__;
          }__;

  @Method:
    @@Name: disAddRequireURI
    @@enDesc:
      Adds a <QUOTE::dis> resource into the list of <Perl::require>d
      resources of this code fragment.
    @@Param:
      @@@Name: uriArg
      @@@Type: DOMString
      @@@enDesc:
        The URI reference of the resource to add.
    @@Return:
      @@@PerlDef:
          __DEEP{
            __CODE{addNameListAttr::
              $node => {$self},
              $attrName => 'requireResourceURI',
              $newName => {$uriArg},
            }__;
          }__;

  @Method:
    @@Name: disGetRequireURIList
    @@enDesc:
      Returns a list of <QUOTE::dis> resource URI references that is
      <Perl::require>d by this code fragment, including all descendant nodes. 
    @@Return:
      @@@Type: DISPerl|ARRAY||ManakaiDOM|all
      @@@enDesc:
        A list of resource URI references.  Note that the list is <EM::dead>; 
        any modification to it does not affect to the code fragment
        and vice versa.
      @@@PerlDef:
          __DEEP{
            __CODE{getNameListAttrR::
              $node => {$self},
              $attrName => 'requireResourceURI',
              $result => {$r},
            }__;
          }__;

  @Method:
    @@ForCheck: ManakaiDOM|ForClass
    @@Operator: DISPerl|CloneMethod
    @@Return:
      @@@Type: PerlCode
      @@@PerlDef:
        __DEEP{
          $r = $self-><M::Node.cloneNode> (true);
        }__;
##PerlCode

ResourceDef:
  @QName: AnyPCElement
  @DISCore:resourceType: s|AnyElementInNS
  @AppName:
    @@@: pc|*
    @@ContentType: DISCore|QName
  @ForCheck: =ManakaiDOM|all

ResourceDef:
  @QName: AnyPC2Element
  @DISCore:resourceType: s|AnyElementInNS
  @AppName:
    @@@: pc2|*
    @@ContentType: DISCore|QName
  @ForCheck: =ManakaiDOM|all

ElementTypeBinding:
  @Name: ETQName
  @ElementType:
    dis:AppName
  @ShadowContent:
    @@ForCheck: s|ForML
    @@ContentType: DISCore|QName

IFClsETDef:
  @IFQName: PerlFile
  @CQName: ManakaiPCFile
  @ETQName: pc|file
  @QName:
    @@@: pc|file
    @@ForCheck: s|ForML

  @IFISA: PerlCode

  @IFISA: PerlCodeStatements
  @CISA: ManakaiPCCodeStatements

  @enDesc:
    Perl source code files.

  @Method:
    @@Name: appendNewPackage
    @@enDesc:
      Appends a new package scope block. 
    @@Param:
      @@@Name: packageName
      @@@Type: DOMString
      @@@enDesc:
        The fully-qualified name of the package to create. 
    @@Return:
      @@@Type: PerlPackage
      @@@enDesc:
        The newly created package scope object. 
      @@@PerlDef:
          __DEEP{
            $r = $self-><AG::Node.ownerDocument>-><M::Document.createElementNS>
                                                          (<Q::pc:>, 'package');
            $r-><AS::PerlPackage.packageName> ($packageName);
            $self-><M::Node.appendChild> ($r);
          }__;

  @Method:
    @@Name: getLastPackage
    @@enDesc:
      Gets the last package scope block of a name. 
    @@Param:
      @@@Name: packageName
      @@@@Type: DOMString
      @@@@enDesc:
        The fully-qualified name of the package to get. 
    @@NamedParam:
      @@@Name: makeNewPackage
      @@@Type: idl|boolean||ManakaiDOM|all
      @@@enDesc:
        Whether a new package scope object should be created if 
        no package of <P::packageName> found. 
      @@@TrueCase:
        @@@@enDesc:
          Makes a new object if not found. 
      @@@FalseCase:
        @@@@enDesc:
          Don't make a new object. 
    @@Return:
      @@@Type: PerlPackage
      @@@enDesc:
        The last package scope object whose name is equal to 
        <P::packageName>.
      @@@nullCase:
        @@@@enDesc:
          There is no <P::packageName> package object and 
          the <P::makeNewPackage> parameter is set to <DOM::false>. 
      @@@PerlDef:
          __DEEP{
            for my $child (@{$self-><AG::Node.childNodes>}) {
              if ($child-><AG::Node.nodeType> == <C::Node.ELEMENT_NODE> and
                  defined $child-><AG::Node.namespaceURI> and
                  $child-><AG::Node.namespaceURI> eq <Q::pc:> and
                  $child-><AG::Node.localName> eq 'package') {
                my $v = $child-><M::Element.getAttributeNS>
                               (<Q::pc:>, 'packageName');
                if (defined $v and $v eq $packageName) {
                  $r = $child;
                }
              }
            }
            if (not $r and $makeNewPackage) {
              $r = $self-><M::PerlFile.appendNewPackage> ($packageName);
            }
          }__;

  @ATTR:
    @@Name: sourceFile
    @@ATTRQName: pc|sourceFile
    @@enDesc:
      The file name of the source file from which this 
      Perl code is primary generated. 
    @@ReflectCDATA:
    @@Get:
    @@Set:

  @ATTR:
    @@Name: sourceModule
    @@ATTRQName: pc|sourceModule
    @@enDesc:
      The name URI reference of the source module that this package defines.
    @@ReflectCDATA:
    @@Get:
    @@Set:

  @ATTR:
    @@Name: sourceFor
    @@ATTRQName: pc|sourceFor
    @@enDesc:
      The URI reference of the source module <QUOTE::for> for which this 
      package is. 
    @@ReflectCDATA:
    @@Get:
    @@Set:

  @ToStringMethod:
    @@Return:
      @@@Type: DOMString
      @@@enDesc:
        The Perl code generated. 
      @@@PerlDef:
          __DEEP{
            ## -- Header
            $r = qq<#!/usr/bin/perl \n>;
            $r .= <ClassM::ManakaiPCImplementation.perlComment>
                    (q<This file is automatically generated>);
            $r .= <ClassM::ManakaiPCImplementation.perlComment>
                   (q<	at >.<ClassM::ManakaiPCImplementation
                                             .rfc3339DateTime> (time).q<,>);
            $r .= <ClassM::ManakaiPCImplementation.perlComment>
                    (q<	from file ">.$self-><AG::PerlFile.sourceFile>.q<",>);
            $r .= <ClassM::ManakaiPCImplementation.perlComment>
                    (q[	module <].$self-><AG::PerlFile.sourceModule>.q[>,]);
            $r .= <ClassM::ManakaiPCImplementation.perlComment>
                    (q[	for <].$self-><AG::PerlFile.sourceFor>.q[>.]);
            $r .= <ClassM::ManakaiPCImplementation.perlComment>
                    (q<Don't edit by hand!>);
            $r .= qq<use strict;\n>;
            $self-><AS::PerlFile.currentPackage> ('main');

            ## -- |require| Perl Modules
            my $req = $self-><M::PerlCode.getRequirePerlModuleNameList>;
            for my $pack (sort {$a cmp $b} @$req) {
              $r .= qq<require $pack;\n>;
            }

            ## -- |use| Perl Modules
            for my $pack (sort {$a cmp $b} @{$self-><M::PerlCode
                                                 .getUsePerlModuleNameList>}) {
              $r .= 'use ' . $pack . ";\n";
            }

            ## -- |use| Character Classes
            my $cls = $self-><M::PerlCode.getUseCharClassNameList>;
            for my $pack (sort {$a cmp $b} keys %$cls) {
              $r .= 'use ' . $pack . ' ' .
                <ClassM::ManakaiPCImplementation.perlList>
                   ([sort {$a cmp $b} grep {$cls->{$pack}->{$_}}
                     keys %{$cls->{$pack}}]) . ";\n";
            }

            ## -- Packages and global objects
            my $pack = {};
            for my $child (@{$self-><AG::Node.childNodes>}) {
              $r .= $child->stringify;
              if ($child-><AG::Node.nodeType> == <C::Node.ELEMENT_NODE> and
                  defined $child-><AG::Node.namespaceURI> and
                  $child-><AG::Node.namespaceURI> eq <Q::pc:> and
                  $child-><AG::Node.localName> eq 'package') {
                for my $ipack (@{$child-><M::PerlPackage
                                             .getImplementPackageNameList>}) {
                  $pack->{$ipack} ||= true; # not defined
                }
                $pack->{$child-><AG::PerlPackage.packageName>} = []; # defined
              }
            }

            ## -- Exception interface packages
            for (sort {$a cmp $b} @{$self-><M::PerlCode
                                     .getExceptionInterfacePackageNameList>}) {
              next if ref $pack->{$_};
              $pack->{$_} = [];
              $r .= sprintf q<push @%s::ISA, 'Message::Util::Error' >.
                            q<unless @%s::ISA;%s>, $_, $_, "\n";
            }

            ## -- Enables interface packages
            my @packs = map {'$' . $_ . '::'}
                        sort {$a cmp $b}
                        grep {not ref $pack->{$_} and $pack->{$_}}
                        keys %$pack;
            $r .= q<for (>. join (', ', @packs) . qq<){}\n> if @packs;

            ## -- Footer
            $r .= <ClassM::ManakaiPCImplementation.perlComment>
                    (q[License: <].$self-><AG::PerlFile.licenseURI>.qq[>\n]);
            $r .= qq<1;\n>;
          }__;

  @ATTR:
    @@Name: currentPackage
    @@ATTRQName: pc|currentPackage
    @@enDesc:
      The current Perl package (used in stringify method).
    @@ReflectCDATA:
    @@Get:
    @@Set:

  @ATTR:
    @@Name: licenseURI
    @@ATTRQName: pc|license
    @@enDesc:
      The license term URI reference for this code. 
    @@ReflectCDATA:
    @@Get:
    @@Set:
##PerlFile

ElementTypeBinding:
  @Name: ReflectCDATA
  @ElementType:
    dis:Type
  @ShadowContent:
    @@@: DOMString
  @ShadowSibling:
    @@actualType: CDATADOMString

ElementTypeBinding:
  @Name: ReflectCDATA2
  @ElementType:
    dis:Type
  @ShadowContent:
    @@@: DOMString
  @ShadowSibling:
    @@actualType: CDATADOMString2

ResourceDef:
  @QName: DOMString
  @For: ManakaiDOM|Perl
  @AliasFor: DOMMain|DOMString||ManakaiDOM|ManakaiDOMLatest

ReflectTypeDef:
  @QName: CDATADOMString
  @enDesc:
    <TYPE::DOMString> for DOM attributes reflecting
    <SGML::CDATA> element attributes.
  @subsetOf: DOMString
  @ResourceDef:
    @@DISCore:resourceType: DOMMain|ReflectGet
    @@enDesc:
      The DOM attribute returns the current value of the element attribute
      in a transparent, case-sensitive manner.
      \
      If the element attribute is absent, the default value, if any,
      or an empty string is returned.
    @@PerlCDef:
      __DEEP{
        $r = $self-><M::Element.getAttributeNS> ($NS_URI, $LOCAL_NAME);
        $r = '' unless defined $r;
      }__;

  @ResourceDef:
    @@QName: CDATADOMStringSet
    @@DISCore:resourceType: DOMMain|ReflectSet
    @@enDesc:
      The corresponding element attribute is set to the given value,
      in a transparent, case-sensitive manner.
    @@ImplNote:
      @@@lang:en
      @@@@: 
        What will happen if the <DOM::null> value is given?
    @@PerlCDef:
      __DEEP{
        if (defined $given) {
          $self-><M::Element.setAttributeNS>
                   ($NS_URI, $QNAME, $given);
        } else {
          $self-><M::Element.removeAttributeNS> ($NS_URI, $LOCAL_NAME);
        }
      }__;

ReflectTypeDef:
  @QName: CDATADOMString2
  @enDesc:
    <TYPE::DOMString> for DOM attributes reflecting
    <SGML::CDATA> element attributes.
  @subsetOf: DOMString
  @ResourceDef:
    @@DISCore:resourceType: DOMMain|ReflectGet
    @@enDesc:
      The DOM attribute returns the current value of the element attribute
      in a transparent, case-sensitive manner.
      \
      If the element attribute is absent, the default value, if any,
      or <DOM::null> is returned.
    @@PerlCDef:
      __DEEP{
        $r = $self-><M::Element.getAttributeNS> ($NS_URI, $LOCAL_NAME);
      }__;

  @ResourceDef:
    @@DISCore:resourceType: DOMMain|ReflectSet
    @@enDesc:
      The corresponding element attribute is set to the given value,
      in a transparent, case-sensitive manner.
    @@ImplNote:
      @@@lang:en
      @@@@: 
        What will happen if the <DOM::null> value is given?
    @@PerlCDef:
      __DEEP{
        if (defined $given) {
          $self-><M::Element.setAttributeNS>
                   ($NS_URI, $QNAME, $given);
        } else {
          $self-><M::Element.removeAttributeNS> ($NS_URI, $LOCAL_NAME);
        }
      }__;

ElementTypeBinding:
  @Name: ReflectTypeDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|DataType
    @@ForCheck: !ManakaiDOM|IDL
    @@For: ManakaiDOM|DOM

ElementTypeBinding:
  @Name: ATTR
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      @@@@: s|Attribute
      @@@ForCheck: s|ForML
    @@rdf:type:
      @@@@: DISLang|Attribute
      @@@ForCheck: ManakaiDOM|ForClass
    @@rdf:type:
      @@@@: DISLang|Attribute
      @@@ForCheck: ManakaiDOM|ForIF
    @@DocAttr:
      @@@@: ||+||s|ForML
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass
    @@DocAttr:
      @@@@: ||+||s|ForML
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForIF
    @@ForCheck: !=ManakaiDOM|ManakaiDOM

ElementTypeBinding:
  @Name: ATTRQName
  @ElementType:
    dis:AppName
  @ShadowContent:
    @@ForCheck: s|ForML
    @@ContentType: DISCore|QName

IFClsETDef:
  @IFQName: PerlPackage
  @CQName: ManakaiPCPackage
  @ETQName: pc|package

  @IFISA: PerlCode

  @IFISA: PerlCodeStatements
  @CISA: ManakaiPCCodeStatements

  @enDesc:
    A Perl lexical lines for which a <Perl::package> declaration
    in effect. 

  @ATTR:
    @@Name: packageName
    @@ATTRQName: pc|packageName
    @@ReflectCDATA:
    @@enDesc:
      The fully-qualified package name. 
    @@Get: 
    @@Set:

  @Method:
    @@Name: getSub
    @@enDesc:
      Gets a subroutine. 
    @@Param:
      @@@Name: subName
      @@@Type: DOMString
      @@@enDesc:
        The name of subroutine to get. 
    @@NamedParam:
      @@@Name: makeNewNode
      @@@Type: idl|boolean||ManakaiDOM|all
      @@@enDesc:
        Whether a new subroutine object should be created, 
        if it is not exist, or not. 
    @@Return:
      @@@Type: PerlSub
      @@@enDesc:
        The subroutine object. 
      @@@nullCase:
        @@@@enDesc:
          Either the specified subroutine is not found and 
          the <P::makeNewNode> parameter is set to <DOM::false> or
          the subroutine is defined as an alias. 
      @@@PerlDef:
          __DEEP{
            F: {
              for my $child (@{$self-><AG::Node.childNodes>}) {
                if ($child-><AG::Node.nodeType> == <C::Node.ELEMENT_NODE> and
                    defined $child-><AG::Node.namespaceURI> and
                    $child-><AG::Node.namespaceURI> eq <Q::pc:> and
                    $child-><AG::Node.localName> eq 'sub') {
                  if ($child-><M::PerlSub.hasPerlName> ($subName)) {
                    $r = $child;
                    last F;
                  }
                }
              }
              if ($makeNewNode) {
                $r = $self-><AG::Node.ownerDocument>
                          -><M::Document.createElementNS>
                               (<Q::pc:>, 'sub');
                $r-><M::PerlSub.addPerlName> ($subName);
                $self-><M::Node.appendChild> ($r);
              }
            } # F
          }__;

  @Method:
    @@Name: addISAPackage
    @@enDesc:
      Adds a class package that this class inherits. 
    @@Param:
      @@@Name: packageName
      @@@Type: DOMString
      @@@enDesc:
        The name of package to add. 
    @@Return:
      @@@PerlDef:
        __DEEP{
          my $v = $self-><M::Element.getAttributeNS> (<Q::pc:>, 'extends');
          $self-><M::Element.setAttributeNS>
              (<Q::pc:>, 'pc:extends' =>
               join ' ', (split /\s+/, defined $v ? $v : ''), $packageName);
        }__;

  @Method:
    @@Name: getISAPackageNameList
    @@enDesc:
      Returns a list of names of packages extended by the package.
    @@Return:
      @@@Type: DISPerl|ARRAY||ManakaiDOM|all
      @@@enDesc:
        An ordered snapshot list of superpackage names.
      @@@PerlDef:
        __DEEP{
          my $v = $self-><M::Element.getAttributeNS> (<Q::pc:>, 'extends');
          $r = [split /\s+/, defined $v ? $v : ''];
        }__;

  @Method:
    @@Name: addRevISAPackage
    @@enDesc:
      Adds a class package name into the list of the package
      name of classes extending this class.
    @@Param:
      @@@Name: packageName
      @@@Type: DOMString
      @@@enDesc:
        The package name of the class added to the list.
    @@Return:
      @@@PerlDef:
        __DEEP{
          my $v = $self->get_attribute_ns (<Q::pc:>, 'extending-classes');
          $self->set_attribute_ns
              (<Q::pc:>, 'pc:extending-classes' =>
               join ' ', (split /\s+/, defined $v ? $v : ''), $packageName);
        }__;

  @Method:
    @@Name: getRevISAPackageNameList
    @@enDesc:
      Returns a snapshot list of the package names
      of the classes extending this class.
    @@Return:
      @@@Type: DISPerl|ARRAY||ManakaiDOM|all
      @@@enDesc:
        An ordered snapshot list of superpackage names.
      @@@PerlDef:
        __DEEP{
          my $v = $self->get_attribute_ns (<Q::pc:>, 'extending-classes');
          $r = [split /\s+/, defined $v ? $v : ''];
        }__;

  @Method:
    @@Name: addImplementPackage
    @@enDesc:
      Adds a interface package that this class implements. 
    @@Param:
      @@@Name: packageName
      @@@Type: DOMString
      @@@enDesc:
        The name of package to add.
    @@Return:
      @@@PerlDef:
          __DEEP{
            __CODE{addNameListAttr::
              $node => {$self},
              $attrName => 'implements',
              $newName => {$packageName},
            }__;
          }__;

  @Method:
    @@Name: getImplementPackageNameList
    @@enDesc:
      Returns a list of names of packages implemented by the package.
    @@Return:
      @@@Type: DISPerl|ARRAY||ManakaiDOM|all
      @@@enDesc:
        An unordered snapshot list of interface packages.
      @@@PerlDef:
          __DEEP{
            __CODE{getNameListAttr::
              $node => {$self},
              $attrName => 'implements',
              $result => {$r},
            }__;
          }__;

  @ToStringMethod:
    @@Return:
      @@@Type: DOMString
      @@@enDesc:
        Perl code. 
      @@@PerlDef:
          __DEEP{
            my $file = $self-><AG::PerlCode.fileNode>;

            ## Package name
            my $pn = $self-><AG::PerlPackage.packageName>;
            $r .= q<package > . $pn . ";\n";
            $file-><AS::PerlFile.currentPackage> ($pn) if $file;

            ## Package version
            $r .= 'our $VERSION = '.
                <ClassM::ManakaiPCImplementation.versionDateTime> (time).
                ";\n";

            ## Inheritance
            my @isa = (@{$self-><M::PerlPackage.getISAPackageNameList>},
                       sort {$a cmp $b} @{$self-><M::PerlPackage
                                               .getImplementPackageNameList>});
            if (@isa) {
              $r .= 'push our @ISA, ' .
                <ClassM::ManakaiPCImplementation.perlList> (\@isa) .
                ";\n";
            }

            for my $pack_name (@{$self->get_rev_isa_package_name_list}) {
              $r .= 'push @' . $pack_name . '::ISA, q<' . $pn .
                  "> unless $pack_name->isa q<$pn>;\n";
            }

            ## |use| Perl Modules
            for my $pack (sort {$a cmp $b} @{$self-><M::PerlCode
                                                 .getUsePerlModuleNameList>}) {
              $r .= 'use ' . $pack . ";\n";
            }

            ## |use| Character Classes
            my $cls = $self-><M::PerlCode.getUseCharClassNameList>;
            for my $pack (sort {$a cmp $b} keys %$cls) {
              $r .= 'use ' . $pack . ' ' .
                <ClassM::ManakaiPCImplementation.perlList>
                   ([sort {$a cmp $b} grep {$cls->{$pack}->{$_}}
                     keys %{$cls->{$pack}}]) . ";\n";
            }

            ## Package-scope objects
            my $has_bool;
            my $op = '';
            for my $child (@{$self-><AG::Node.childNodes>}) {
              if ($child-><AG::Node.nodeType> == <C::Node.ELEMENT_NODE> and
                  defined $child-><AG::Node.namespaceURI> and
                  $child-><AG::Node.namespaceURI> eq <Q::pc:>) {
                my $ln = $child-><AG::Node.localName>;
                if ($ln eq 'sub') {
                  my $names = $child-><M::PerlSub.getPerlNameList>;
                  my $ops = $child-><M::PerlSub.getPerlOperatorList>;
                  if (@$names) {
                    $r .= $child->stringify;
                    if (@$names > 1) {
                      $r .= sprintf q<*%s = \&%s;%s>,
                                  $_, $names->[0], "\n" for @$names[1..$#$names];
                    }
                    for (@$ops) {
                      $op .= sprintf q['%s' => '%s', %s],
                                     $_ => $names->[0], "\n";
                      $has_bool = true if $_ eq 'bool';
                    }
                  } else {
                    my $v = $child->stringify;
                    for (@$ops) {
                      $op .= sprintf q['%s' => %s, %s], $_ => $v, "\n";
                      $has_bool = true if $_ eq 'bool';
                    }
                  }
                } else {
                  $r .= $child->stringify;
                }
              } elsif ($child-><AG::Node.nodeType> == <C::Node.ELEMENT_NODE>) {
                $r .= $child;
              }
            } # children 

            if (length $op) {
              $r .= "use overload \n";
              $r .= "bool => sub () {1}, \n" unless $has_bool;
              $r .= $op . "fallback => 1;\n";
            }

            ## -- Exports
            my $xport = $self-><M::PerlPackage.getExportList>;
            if (map {values %$_} values %$xport) {
              $r .= q[our %EXPORT_TAG = (] . 
                    <ClassM::ManakaiPCImplementation.perlList>
                       ([map {$_ => [sort {$a cmp $b} keys %{$xport->{$_}}]}
                         sort {$a cmp $b} grep {length}
                         keys %$xport]) . qq[);\n];
              $r .= q[our @EXPORT_OK = (] .
                    <ClassM::ManakaiPCImplementation.perlList>
                       ([map {sort {$a cmp $b} keys %{$xport->{$_}}}
                         sort {$a cmp $b} keys %$xport]) . qq[);\n];
              $r .= q[use Exporter; push our @ISA, 'Exporter';] . qq[\n];
            }
          }__;

  @Method:
    @@Name: getExportList
    @@enDesc:
      Returns a list of export tag and names.
    @@Return:
      @@@Type: DISPerl|HASH||ManakaiDOM|all
      @@@enDesc:
        Snapshot list of lists.
      @@@PerlDef:
          my $mc;
          __DEEP{
            __CODE{getNameListAttr::
              $node => {$self},
              $attrName => 'export',
              $result => {$mc},
            }__;
          }__;
          for (@$mc) {
            my ($m, $c) = split /\./, $_, 2;
            $r->{$m}->{$c} = true;
          }

  @Method:
    @@Name: addExport
    @@enDesc:
      Adds a name to the list of exported items (<Perl::@EXPORT_OK>).
    @@Param:
      @@@Name: exportTag
      @@@Type: DOMString
      @@@enDesc:
        The name of the tag (without <CHAR::COLON> prefix). 
        The <P::exportName> is added both to <Perl::@EXPORT_OK>
        and <Perl::$EXPORT_OK{<P::exportTag>}>.
      @@@nullCase:
        @@@@enDesc:
          The <P::exportName> is added only to the <Perl::@EXPORT_OK>.
    @@Param:
      @@@Name: exportName
      @@@Type: DOMString
      @@@enDesc:
        The name to be exported.
    @@Return:
      @@@PerlDef:
          __DEEP{
            __CODE{addNameListAttr::
              $node => {$self},
              $attrName => 'export',
              $newName => {$exportTag.'.'.$exportName},
            }__;
          }__;
##PCPackage

IFClsETDef:
  @IFQName: PerlCodeStatements
  @CQName: ManakaiPCCodeStatements
  @ETQName:
    @@@: pc|statementContainer
    @@ImplNote:
      @@@lang:en
      @@@@: Dummy.

  @IFISA: PerlCodeUnits
  @CISA: ManakaiPCCodeUnits

  @enDesc:
    A base class for node types that contains zero or more
    statements and/or blocks.

  @Method:
    @@Name: appendCode
    @@enDesc:
      Appends an unparsed Perl code fragment. 
    @@Param:
      @@@Name: codeArg
      @@@Type: DOMString
      @@@enDesc:
        An unparsed Perl code fragment. 
    @@Return:
      @@@Type: PerlUnparsedCode
      @@@enDesc:
        The newly created Perl code object. 
      @@@PerlDef:
          __DEEP{
            $r = $self-><AG::Node.ownerDocument>-><M::Document.createElementNS>
                                                      (<Q::pc:>, 'unparsed');
            $r-><AS::Node.textContent> ($codeArg);
            $self-><M::Node.appendChild> ($r);
          }__;

  @ATTR:
    @@Name: label
    @@ATTRQName: pc|label
    @@enDesc:
      Label for this block.
    @@ReflectCDATA:
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          No label.
    @@Set:
      @@@nullCase:
        @@@@enDesc:
          No label.

  @Method:
    @@Name: appendBlock
    @@enDesc:
      Appends a Perl block code.
    @@Return:
      @@@Type: PerlBlock
      @@@enDesc:
        The newly created Perl code object. 
      @@@PerlDef:
          __DEEP{
            $r = $self-><AG::Node.ownerDocument>-><M::Document.createElementNS>
                                                         (<Q::pc:>, 'block');
            $self-><M::Node.appendChild> ($r);
          }__;

  @Method:
    @@Name: appendStatement
    @@enDesc:
      Appends a Perl statement.
    @@Param:
      @@@Name: codeArg
      @@@Type: DOMString
      @@@enDesc:
        A Perl statement without terminating <Perl::;>.
      @@@nullCase:
        @@@@enDesc:
          No initial content.
    @@Return:
      @@@Type: PerlStatement
      @@@enDesc:
        The newly created Perl code object. 
      @@@PerlDef:
          __DEEP{
            $r = $self-><AG::Node.ownerDocument>-><M::Document.createElementNS>
                                                         (<Q::pc:>, 'statement');
            if (defined $codeArg) {
              $r-><M::PerlCodeUnits.appendBare> ($codeArg);
            }
            $self-><M::Node.appendChild> ($r);
          }__;

  @Method:
    @@Name: appendNewPCBlock
    @@enDesc:
      Creates a <Q::pc2:block> and appends it to the node.
    @@Return:
      @@@Type: PCBlock
      @@@enDesc:
        The newly created block element.
      @@@PerlDef:
        __DEEP{
          $r = $self-><AG::Node.ownerDocument>-><M::PCDocument.createPCBlock>;
          $self-><M::Node.appendChild> ($r);
        }__;

  @Method:
    @@Name: appendNewPCChoose
    @@enDesc:
      Creates a <Q::pc:choose> and appends it to the node.
    @@Return:
      @@@Type: PCChoose
      @@@enDesc:
        The newly created choose element.
      @@@PerlDef:
        __DEEP{
          $r = $self-><AG::Node.ownerDocument>-><M::PCDocument.createPCChoose>;
          $self-><M::Node.appendChild> ($r);
        }__;

  @Method:
    @@Name: appendNewPCWhile
    @@enDesc:
      Creates a <Q::pc:while> and appends it to the node.
    @@Return:
      @@@Type: PCWhile
      @@@enDesc:
        The newly created while element.
      @@@PerlDef:
        __DEEP{
          $r = $self-><AG::Node.ownerDocument>-><M::PCDocument.createPCWhile>;
          $self-><M::Node.appendChild> ($r);
        }__;

  @Method:
    @@Name: appendNewIf
    @@enDesc:
      Appends a newly created <Class::ManakaiPerlIf> object. 
    @@Param:
      @@@Name: conditionArg
      @@@Type: PerlCode
      @@@enDesc:
        Conditoon code fragment object.
    @@Param:
      @@@Name: trueArg
      @@@Type: PerlCode
      @@@enDesc:
        A true code fragment object. 
      @@@nullCase:
        @@@@enDesc: No true code.
    @@Param:
      @@@Name: falseArg
      @@@Type: PerlCode
      @@@enDesc:
        A false code fragment object. 
      @@@nullCase:
        @@@@enDesc: No false code.
    @@Return:
      @@@Type: PerlIf
      @@@enDesc:
        The newly created element.
      @@@PerlDef:
          __DEEP{
            $r = $self-><AG::Node.ownerDocument>-><M::Document.createElementNS>
                                                   (<Q::pc:>, 'if');
            $r-><AS::PerlIf.condition> ($conditionArg);
            $r-><AS::PerlIf.trueCode> ($trueArg) if $trueArg;
            $r-><AS::PerlIf.falseCode> ($falseArg) if $falseArg;
            $self-><M::Node.appendChild> ($r);
          }__;
##PCIf

IFClsETDef:
  @IFQName: PerlSub
  @CQName: ManakaiPCSub
  @ETQName: pc|sub

  @IFISA: PerlCode

  @IFISA: PerlCodeStatements
  @CISA: ManakaiPCCodeStatements

  @enDesc:
    Perl subroutines.   

  @Attr:
    @@Name: pcLocalName
    @@enDesc:
      The name of this subroutine. 
    @@Type: DOMString
    @@Get: 
      @@@nullCase:
        @@@@enDesc:
          This subroutine has no name. 
      @@@PerlDef:
          __DEEP{
            $r = $self-><M::PerlSub.getPerlNameList>->[0];
          }__;

  @Method:
    @@Name: addPerlName
    @@enDesc:
      Adds a subroutine name.
    @@Param:
      @@@Name: subName
      @@@Type: DOMString
      @@@enDesc: The name to add.
    @@Return:
      @@@PerlDef:
        __DEEP{
          __CODE{addNameListAttr::
            $node => {$self},
            $attrName => 'localName',
            $newName => {$subName},
          }__;
        }__;

  @Method:
    @@Name: getPerlNameList
    @@enDesc:
      Returns a list of names of the subroutine.
    @@Return:
      @@@Type: DISPerl|ARRAY||ManakaiDOM|all
      @@@enDesc:
        An unordered snapshot list of names.
      @@@PerlDef:
        __DEEP{
          __CODE{getNameListAttr::
            $node => {$self},
            $attrName => 'localName',
            $result => {$r},
          }__;
        }__;

  @Method:
    @@Name: hasPerlName
    @@enDesc:
      Returns whether the subroutine has a name or not.
    @@Param:
      @@@Name: subName
      @@@Type: DOMString
      @@@enDesc: The name.
    @@Return:
      @@@Type: idl|boolean||ManakaiDOM|all
      @@@PerlDef:
        __DEEP{
          my $l;
          __CODE{getNameListAttr::
            $node => {$self},
            $attrName => 'localName',
            $result => {$l},
          }__;
          F: for (@$l) {
            if ($_ eq $subName) {
              $r = true;
              last F;
            }
          }
        }__;

  @Method:
    @@Name: clearPerlName
    @@enDesc:
      Removes all Perl name associated to the <IF::PerlSub>.
    @@Return:
      @@@PerlDef:
        __DEEP{
          $self-><M::Element.removeAttributeNS> (<Q::pc:>, 'localName');
        }__;

  @Method:
    @@Name: addPerlOperator
    @@enDesc:
      Adds an operator overloaded by the method.
    @@Param:
      @@@Name: op
      @@@Type: DOMString
      @@@enDesc: The operator to add.
    @@Return:
      @@@PerlDef:
        __DEEP{
          __CODE{addNameListAttr::
            $node => {$self},
            $attrName => 'operator',
            $newName => {$op},
          }__;
        }__;

  @Method:
    @@Name: getPerlOperatorList
    @@enDesc:
      Returns a list of operators of the subroutine.
    @@Return:
      @@@Type: DISPerl|ARRAY||ManakaiDOM|all
      @@@enDesc:
        An unordered snapshot list of operators.
      @@@PerlDef:
        __DEEP{
          __CODE{getNameListAttr::
            $node => {$self},
            $attrName => 'operator',
            $result => {$r},
          }__;
        }__;

  @Method:
    @@Name: hasPerlOperator
    @@enDesc:
      Returns whether the subroutine has an operator or not.
    @@Param:
      @@@Name: op
      @@@Type: DOMString
      @@@enDesc: The operator.
    @@Return:
      @@@Type: idl|boolean||ManakaiDOM|all
      @@@PerlDef:
        __DEEP{
          my $l;
          __CODE{getNameListAttr::
            $node => {$self},
            $attrName => 'operator',
            $result => {$l},
          }__;
          F: for (@$l) {
            if ($_ eq $op) {
              $r = true;
              last F;
            }
          }
        }__;

  @ATTR:
    @@Name: prototype
    @@ATTRQName: pc|prototype
    @@enDesc:
      The prototype of this subroutine. 
    @@ReflectCDATA2:
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          No prototype is set. 
    @@Set:
      @@@nullCase:
        @@@@enDesc:
          No prototype declaration. 

    @@Test:
      @@@QName: PCSub.prototype.empty.test
      @@@enDesc:
        Getting value after setting empty value must return an empty string.
      @@@PerlDef:
        my $doc;
        __CODE{createPCDocumentForTest:: $doc => $doc}__;

        my $sub = $doc-><M::PCDocument.createPerlSub> ("sub_name");

        $test->id ('PerlSub');
        $test->assert_not_null ($sub);
        
        $test->id ('default');
        $test->assert_null ($sub-><AG::PerlSub.prototype>);

        $sub-><AS::PerlSub.prototype> ('');

        $test->id ('attribute');
        $test->assert_string (actual_value => $sub-><AG::PerlSub.prototype>,
                              expected_value => '');

        $test->id ('stringify');
        $test->assert_true ($sub->stringify =~ /^sub sub_name \(\)/);
  
  @ToStringMethod:
    @@Return:
      @@@Type: DOMString
      @@@enDesc:
        Perl code. 
      @@@PerlDef:
          __DEEP{
            $r = q<sub>;
            my $nm = $self-><M::PerlSub.getPerlNameList>;
            $r .= q< > . $nm->[0] if @$nm;
            if ($self-><M::Element.hasAttributeNS> (<Q::pc:>, 'prototype')) {
              $r .= q< (> . $self-><AG::PerlSub.prototype> . q<)>;
            }
            $r .= qq< {\n>;
            for my $child (@{$self-><AG::Node.childNodes>}) {
              $r .= $child->stringify;
            }
            $r .= qq<}\n>;
          }__;

  @NumValMethod:
    @@Return:
      @@@Type: idl|unsignedLong||ManakaiDOM|all
      @@@PerlDef:
          __DEEP{
            $r = 0 + $self-><AG::Node.lastChild>;
          }__;
##PerlSub

ElementTypeBinding:
  @Name: Test
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: test|StandaloneTest
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: TestC
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: test|StandaloneTest

IFClsETDef:
  @IFQName: PerlUnparsedCode
  @CQName: ManakaiPCUnparsedCode
  @ETQName: pc|unparsed

  @IFISA: PerlCode
  @CISA: ManakaiPCCode

  @enDesc:
    Unparsed Perl code fragments. 

  @ToStringMethod:
    @@Return:
      @@@Type: DOMString
      @@@enDesc:
        Perl code. 
      @@@PerlDef:
          __DEEP{
            $r = "\x0A" . $self-><AG::Node.textContent> . "\x0A";
          }__;
##PerlUnparsedCode

IFClsETDef:
  @IFQName: PerlInlineUnparsedCode
  @CQName: ManakaiPCInlineUnparsedCode
  @ETQName: pc|inlineUnparsed

  @IFISA: PerlCode
  @CISA: ManakaiPCCode

  @enDesc:
    Unparsed Perl inline code fragments.   

  @ToStringMethod:
    @@Return:
      @@@Type: DOMString
      @@@enDesc:
        Perl code.
      @@@PerlDef:
        __DEEP{
          $r = $self-><AG::Node.textContent>;
        }__;
##PCInlineUnparsedCode

IFClsETDef:
  @IFQName: PCNumberLiteral
  @CQName: ManakaiPCNumberLiteral
  @ETQName: pc|numberLiteral
 
  @IFISA: PerlCode
  @CISA: ManakaiPCCode

  @enDesc:
    A <IF::PCNumberLiteral> object represents a Perl number literal.
    The <A::Node.textContent> of a <IF::PCNumberLiteral> object
    is a Perl source code representation of the number for the object.

  @ToStringMethod:
    @@Return:
      @@@Type: DOMString
      @@@PerlDef:
        __DEEP{
          $r = $self-><AG::Node.textContent>;
        }__;
##PCNumberLiteral

IFClsETDef:
  @IFQName: PerlStringLiteral
  @CQName: ManakaiPCPerlStringLiteral
  @ETQName: pc|stringLiteral

  @IFISA: PerlCode
  @CISA: ManakaiPCCode

  @enDesc:
    Perl string literal.  

  @NumValMethod:
    @@Return:
      @@@Type: idl|unsignedLong||ManakaiDOM|all
      @@@enDesc:
        Numeric value of the Perl code. 
      @@@PerlDef:
          __DEEP{
            $r = 0 + $self-><AG::Node.textContent>;
          }__;

  @ToStringMethod:
    @@Return:
      @@@Type: DOMString
      @@@enDesc:
        Perl code. 
      @@@PerlDef:
          __DEEP{
            $r = $self-><AG::Node.textContent>;
            $r =~ s/(['\\])/\\$1/g;
            my $escaped = ($r =~ s{([^\x0A\x0D\x20-\x7E])}
                                  {sprintf '\x{%X}', ord $1}ge);
            if ($escaped or
                $self-><AG::Node.ownerDocument>
                     -><AG::Document.domConfig>
                     -><M::CFG.getParameter>
                          (<Q::pc:preserve-line-break>)) {
              $r =~ s/\x0D/\\x0D/gs;
              $r =~ s/\x0A/\\x0A/gs;
              $r =~ s/\@/\\\@/g;
              $r =~ s/\$/\\\$/g;
              $r =~ s/"/\\"/g;
              $r = q<"> . $r . q<">;
            } else {
              $r = q<'> . $r . q<'>;
            }
          }__;
##PerlStringLiteral

IFClsETDef:
  @IFQName: PCList
  @CQName: ManakaiPCList
  @ETQName: pc|list

  @IFISA: PerlCode
  @CISA: ManakaiPCCode

  @enDesc:
    A <IF::PCList> is a Perl list, i.e. <CHAR::COMMA> separated
    list of values.

  @Method:
    @@Name: item
    @@enDesc:
      Returns the <P::index>th item in the list.
    @@Param:
      @@@Name: index
      @@@Type: unsignedLong
      @@@enDesc:
        The ordinal index of the item.
    @@Return:
      @@@Type: PerlCodeInlines
      @@@enDesc:
        The <P::index>th item in the list.
      @@@nullCase:
        @@@@enDesc:
          Either <P::index> is negative or the <P::index> is 
          greater than the number of the items in the list.
      @@@PerlDef:
        __DEEP{
          $r = $self-><AG::Node.childNodes>-><M::NodeList.item> ($index);
        }__;

  @Attr:
    @@Name: length
    @@enDesc:
      The number of items in the list.
    @@Type: unsignedLong
    @@Get:
      @@@PerlDef:
        __DEEP{
          $r = $self-><AG::Node.childNodes>-><AG::NodeList.length>;
        }__;

  @ToStringMethod:
    @@Return:
      @@@Type: DOMString
      @@@enDesc:
        Perl code. 
      @@@PerlDef:
        __DEEP{
          my @r = map {$_->stringify} @{$self-><AG::Node.childNodes>};
          $r = '(' . join (', ', @r) . ')';
        }__;
##PCList

IFClsETDef:
  @IFQName: PCArrayRefLiteral
  @CQName: ManakaiPCArrayRefLiteral
  @ETQName: pc|arrayRefLiteral

  @IFISA: PerlCode
  @CISA: ManakaiPCCode

  @enDesc:
    A <IF::PCArrayRefLiteral> is a Perl array reference literal.

  @Method:
    @@Name: item
    @@enDesc:
      Returns the <P::index>th item in the list.
    @@Param:
      @@@Name: index
      @@@Type: unsignedLong
      @@@enDesc:
        The ordinal index of the item.
    @@Return:
      @@@Type: PerlCodeInlines
      @@@enDesc:
        The <P::index>th item in the list.
      @@@nullCase:
        @@@@enDesc:
          Either <P::index> is negative or the <P::index> is 
          greater than the number of the items in the list.
      @@@PerlDef:
        __DEEP{
          $r = $self-><AG::Node.childNodes>-><M::NodeList.item> ($index);
        }__;

  @Attr:
    @@Name: length
    @@enDesc:
      The number of items in the list.
    @@Type: unsignedLong
    @@Get:
      @@@PerlDef:
        __DEEP{
          $r = $self-><AG::Node.childNodes>-><AG::NodeList.length>;
        }__;

  @ToStringMethod:
    @@Return:
      @@@Type: DOMString
      @@@enDesc:
        Perl code. 
      @@@PerlDef:
        __DEEP{
          my @r = map {$_->stringify} @{$self-><AG::Node.childNodes>};
          $r = '[' . join (",\n", @r) . ']';
        }__;
##PCArrayRefLiteral

IFClsETDef:
  @IFQName: PCHashRefLiteral
  @CQName: ManakaiPCHashRefLiteral
  @ETQName: pc|hashRefLiteral

  @IFISA: PerlCode
  @CISA: ManakaiPCCode

  @enDesc:
    A <IF::PCHashRefLiteral> is a Perl hash reference literal.

  @Method:
    @@Name: key
    @@enDesc:
      Returns the <P::index>th key in the list.

        {NOTE:: Although the order of key-value pairs is
                preserved in the object, it is not preserved
                in Perl source codes and in Perl language.
        }
    @@Param:
      @@@Name: index
      @@@Type: unsignedLong
      @@@enDesc:
        The ordinal index of the key.
    @@Return:
      @@@Type: PerlCodeInlines
      @@@enDesc:
        The <P::index>th key in the list.
      @@@nullCase:
        @@@@enDesc:
          Either <P::index> is negative or the <P::index> is 
          greater than the number of the keys in the list.
      @@@PerlDef:
        __DEEP{
          $r = $self-><AG::Node.childNodes>-><M::NodeList.item> ($index * 2);
        }__;

  @Method:
    @@Name: value
    @@enDesc:
      Returns the <P::index>th value in the list.

        {NOTE:: Although the order of key-value pairs is
                preserved in the object, it is not preserved
                in Perl source codes and in Perl language.
        }
    @@Param:
      @@@Name: index
      @@@Type: unsignedLong
      @@@enDesc:
        The ordinal index of the value.
    @@Return:
      @@@Type: PerlCodeInlines
      @@@enDesc:
        The <P::index>th value in the list.
      @@@nullCase:
        @@@@enDesc:
          Either <P::index> is negative or the <P::index> is 
          greater than the number of the values in the list.

            {NOTE:: <MATH::<A::PCHashRefLiteral.length> - 1>th
                    value might not be found.
            }
      @@@PerlDef:
        __DEEP{
          $r = $self-><AG::Node.childNodes>-><M::NodeList.item> ($index * 2 + 1);
        }__;

  @Attr:
    @@Name: length
    @@enDesc:
      The number of key-value pairs in the list.
    @@Type: unsignedLong
    @@Get:
      @@@PerlDef:
        __DEEP{
          my $length = $self-><AG::Node.childNodes>-><AG::NodeList.length>;
          $r = int ($length / 2) + ($length % 2);
        }__;

  @Method:
    @@Name: setNamedItem
    @@enDesc:
      Set a named item.
    @@Param:
      @@@Name: key
      @@@Type: DOMString
      @@@enDesc:
        The key.
    @@Param:
      @@@Name: value
      @@@Type: PerlCodeInlines
      @@@enDesc:
        The value.
    @@Return:
      @@@PerlDef:
        __DEEP{
          my @children = @{$self-><AG::Node.childNodes>};
          R: {
            while (@children) {
              my $ckey = shift @children;
              my $cval = shift @children;
              if ($ckey-><AG::Node.textContent> eq $key) {
                $self-><M::Node.replaceChild> ($value, $cval);
                last R;
              }
            }

            $self-><M::Node.appendChild>
              ($self-><AG::Node.ownerDocument>
                    -><M::Document.createElementNS>
                        (<Q::pc:>, 'stringLiteral'))
                 -><AS::Node.textContent> ($key);
            $self-><M::Node.appendChild> ($value);
          } # R
        }__;

  @ToStringMethod:
    @@Return:
      @@@Type: DOMString
      @@@enDesc:
        Perl code. 
      @@@PerlDef:
        __DEEP{
          my %r = map {$_->stringify} @{$self-><AG::Node.childNodes>};
                  ## Different values with same key are not preserved.
          $r = '{' . join (",\n", map {$_ => $r{$_}}
                                 sort {$a cmp $b} keys %r) . '}';
        }__;
##PCHashRefLiteral

ResourceDef:
  @QName: unsignedLong
  @AliasFor: idl|unsignedLong||ManakaiDOM|all
  @For: ManakaiDOM|DOM

IFClsETDef:
  @IFQName: PerlTokens
  @CQName: ManakaiPCTokens
  @ETQName: pc|tokens

  @IFISA: PerlCode
  @CISA: ManakaiPCCode

  @enDesc:
    Unparsed Perl inline code fragments.   

  @ToStringMethod:
    @@Return:
      @@@Type: DOMString
      @@@PerlDef:
          __DEEP{
            $r = $self-><AG::Node.textContent>;
          }__;
##PCTokens

IFClsETDef:
  @IFQName: PerlAtom
  @CQName: ManakaiPCAtom
  @ETQName: pc|atom

  @IFISA: PerlCode
  @CISA: ManakaiPCTokens

  @enDesc:
    Unparsed Perl atomic code fragments (such as numeric literal). 
  
  @NumValMethod:
    @@Return:
      @@@Type: idl|unsignedLong||ManakaiDOM|all
      @@@enDesc:
        Numeric value of the Perl code. 
      @@@PerlDef:
          __DEEP{
            $r = 0 + $self-><AG::Node.textContent>;
          }__;

  @ToStringMethod:
    @@Return:
      @@@Type: DOMString
      @@@enDesc:
        Perl code. 
      @@@PerlDef:
          __DEEP{
            $r = $self-><AG::Node.textContent>;
          }__;
##PerlAtom

IFClsETDef:
  @IFQName: PerlVariable
  @CQName: ManakaiPCVariable
  @ETQName: pc|variable

  @IFISA: PerlCode
  @CISA: ManakaiPCCode

  @enDesc:
    Unparsed Perl variable. 
    \
    {NOTE:: Future version of the implementation may 
            support to specify array index or hash key.
     \
    }  

  @ATTR:
    @@Name: variableType
    @@ATTRQName: pc|variableType
    @@enDesc:
      Perl variable type (<CODE::$>, <CODE::@>, <CODE::%>,
      <CODE::&> or empty string). 
    @@ReflectCDATA:
    @@Get:
    @@Set:

  @ATTR:
    @@Name: packageName
    @@ATTRQName: pc|packageName
    @@enDesc:
      The name of the package to which this variable belongs.
    @@ReflectCDATA:
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          This package belongs to the current package or 
          does not belong to any package.
    @@Set:
      @@@nullCase:
        @@@@enDesc:
          This package belongs to the current package or
          does not belong to any package.

  @ATTR:
    @@Name: pcLocalName
    @@ATTRQName: pc|localName
    @@enDesc:
      The local variable name.
    @@ReflectCDATA:
    @@Get:
    @@Set:

  @ATTR:
    @@Name: variableScope
    @@ATTRQName: pc|variableScope
    @@enDesc:
      Scope modifier (<CODE::my> or <CODE::our> or <CODE::local>).
    @@ReflectCDATA:
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          This variable does not have scope modifier.
    @@Set:
      @@@nullCase:
        @@@@enDesc:
          This variable does not have scope modifier.

  @ToStringMethod:
    @@Return:
      @@@Type: DOMString
      @@@enDesc:
        Perl code. 
      @@@PerlDef:
          __DEEP{
            my $t = $self-><AG::PerlVariable.variableScope>;
            $r .= $t . ' ' if length $t;
            $r .= $t = $self-><AG::PerlVariable.variableType>;
            my $v = $self-><AG::PerlVariable.packageName>;
            $r .= $v . '::' if length $v;
            $r .= $self-><AG::PerlVariable.pcLocalName>;
            $v = $self-><AG::PerlVariable.hashKey>;
            if ($t eq '$' and length $v) {
              $v =~ s/(['\\])/\\$1/g;
              $r .= q<{'> . $v . q<'}>;
            }
          }__;

  @ATTR:
    @@Name: hashKey
    @@ATTRQName: pc|hashKey
    @@enDesc:
      The key for hash. 
      \
      {NOTE:: Using Perl code for key is not supported in the current
              version of the implementation.
      \
      }
    @@ReflectCDATA:
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          This variable is not for hash value access.
    @@Set:
      @@@nullCase:
        @@@@enDesc:
          This variable is not for hash value access.
##PerlVariable

IFClsDef:
  @IFQName: PerlCodeUnits
  @CQName: ManakaiPCCodeUnits

  @CISA: ManakaiPCCode

  @enDesc:
    A base class implemented by both inline container and
    block-level container.
  
  @Attr:
    @@Name: length
    @@enDesc:
      The number of child code fragments. 
    @@Type: idl|unsignedLong||ManakaiDOM|all
    @@Get:
      @@@PerlDef:
          __DEEP{
            $r = @{$self-><AG::Node.childNodes>};
          }__;

  @Method:
    @@Name: appendStringLiteral
    @@enDesc:
      Appends a Perl string literal (<CODE::q>).
    @@Param:
      @@@Name: stringArg
      @@@Type: DOMString
      @@@enDesc:
        A string.
    @@Return:
      @@@Type: PerlStringLiteral
      @@@enDesc:
        The newly created Perl string literal object. 
      @@@PerlDef:
          __DEEP{
            $r = $self-><AG::Node.ownerDocument>-><M::Document.createElementNS>
                                           (<Q::pc:>, 'stringLiteral');
            $r-><AS::Node.textContent> ($stringArg);
            $self-><M::Node.appendChild> ($r);
          }__;

  @Method:
    @@Name: appendNewPCLiteral
    @@enDesc:
      Creates a <IF::PCLiteral> object and appends it to the node.
    @@Param:
      @@@Name: value
      @@@Type: DISPerl|Any
      @@@enDesc: The value.
    @@Return:
      @@@Type: PerlCode
      @@@enDesc:
        The newly created object.
      @@@PerlDef:
        __DEEP{
          $r = $self-><AG::Node.ownerDocument>
                    -><M::PCDocument.createPCLiteral> ($value);
          $self-><M::Node.appendChild> ($r);
        }__;

  @Method:
    @@Name: appendNewPCNumberLiteral
    @@enDesc:
      Creates a <IF::PCNumberLiteral> object and appends it to the node.
    @@Param:
      @@@Name: value
      @@@Type: DISPerl|NumberValue
      @@@enDesc:
        The value.
    @@Return:
      @@@Type: PCNumberLiteral
      @@@enDesc:
        The newly created node.
      @@@PerlDef:
        __DEEP{
          $r = $self-><AG::Node.ownerDocument>
                    -><M::PCDocument.createPCNumberLiteral> ($value);
          $self-><M::Node.appendChild> ($r);
        }__; 

  @Method:
    @@Name: appendAtom
    @@enDesc:
      Appends a Perl atomic code fragment.
    @@Param:
      @@@Name: codeArg
      @@@Type: DOMString
      @@@enDesc:
        An atom.
    @@Return:
      @@@Type: PerlAtom
      @@@enDesc:
        The newly created Perl code object. 
      @@@PerlDef:
          __DEEP{
            $r = $self-><AG::Node.ownerDocument>-><M::Document.createElementNS>
                                                   (<Q::pc:>, 'atom');
            $r-><AS::Node.textContent> ($codeArg);
            $self-><M::Node.appendChild> ($r);
          }__;

  @Method:
    @@Name: appendBare
    @@enDesc:
      Appends a Perl bare code fragment.
    @@Param:
      @@@Name: codeArg
      @@@Type: DOMString
      @@@enDesc:
        An bare code.
    @@Return:
      @@@Type: PerlBare
      @@@enDesc:
        The newly created Perl code object. 
      @@@PerlDef:
          __DEEP{
            $r = $self-><AG::Node.ownerDocument>-><M::Document.createElementNS>
                                                   (<Q::pc:>, 'tokens');
            $r-><AS::Node.textContent> ($codeArg);
            $self-><M::Node.appendChild> ($r);
          }__;

  @Method:
    @@Name: appendNewPCVariable
    @@enDesc:
      Creates a variable object and appends it to the children list of 
      the node.
    @@Param:
      @@@Name: variableTypeArg
      @@@Type: DOMString
      @@@enDesc:
        The variable type prefix such as <Perl::$>, if any, or an empty string.
    @@Param:
      @@@Name: packageNameArg
      @@@Type: DOMString
      @@@enDesc:
        The name of the package to which the variable belongs.
      @@@nullCase:
        @@@@enDesc:
          The variable does not belong to any package or belongs
          to the current package.
    @@Param:
      @@@Name: localNameArg
      @@@Type: DOMString
      @@@enDesc:
        The local part of the variable name.
    @@Return:
      @@@Type: PerlVariable
      @@@enDesc:
        The newly created variable object.
      @@@PerlDef:
        __DEEP{
          $r = $self-><AG::Node.ownerDocument>
                    -><M::PCDocument.createPCVariable>
                        ($variableTypeArg, $packageNameArg, $localNameArg);
          $self-><M::Node.appendChild> ($r);
        }__;

  @Method:
    @@Name: appendNewPCDereference
    @@enDesc:
      Creates a <IF::PCDereference> object and appends it to the child
      node list of the node.
    @@Param:
      @@@Name: variableTypeArg
      @@@Type: DOMString
      @@@enDesc:
        The type of the referenced value, such as <Perl::$>.
    @@Return:
      @@@Type: PCDereference
      @@@enDesc:
        The newly created element node.
      @@@PerlDef:
        __DEEP{
          $r = $self-><AG::Node.ownerDocument>
                    -><M::PCDocument.createPCDereference>
                        ($variableTypeArg);
          $self-><M::Node.appendChild> ($r);
        }__;

  @Method:
    @@Name: appendNewPCReference
    @@enDesc:
      Creates a <IF::PCReference> object and appends it to the child
      node list of the node.
    @@Return:
      @@@Type: PCReference
      @@@enDesc:
        The newly created element node.
      @@@PerlDef:
        __DEEP{
          $r = $self-><AG::Node.ownerDocument>
                    -><M::PCDocument.createPCReference>;
          $self-><M::Node.appendChild> ($r);
        }__;

  @Method:
    @@Name: appendNewPCExpression
    @@enDesc:
      Appends a newly created <IF::PCExpression> node.
    @@Param:
      @@@Name: operatorArg
      @@@Type: DOMString
      @@@enDesc:
        The operator of the expression.
    @@Return:
      @@@Type: PCExpression
      @@@enDesc:
        The newly created expression object.
      @@@PerlDef:
        __DEEP{
          $r = $self-><AG::Node.ownerDocument>
                    -><M::PCDocument.createPCExpression> ($operatorArg);
          $self-><M::Node.appendChild> ($r);
        }__;

  @Method:
    @@Name: appendNewAssignment
    @@enDesc:
      Appends a newly created <Class::ManakaiPerlAssign> object. 
    @@Param:
      @@@Name: leftArg
      @@@Type: PerlCode
      @@@enDesc:
        A left hand side code fragment object. 
    @@Param:
      @@@Name: rightArg
      @@@Type: PerlCode
      @@@enDesc:
        A right hand side code fragment object. 
    @@Return:
      @@@Type: PerlAssignment
      @@@PerlDef:
          __DEEP{
            $r = $self-><AG::Node.ownerDocument>-><M::Document.createElementNS>
                                                (<Q::pc:>, 'assignment');
            $r-><AS::PerlAssignment.leftCode> ($leftArg);
            $r-><AS::PerlAssignment.rightCode> ($rightArg);
            $self-><M::Node.appendChild> ($r);
          }__;

  @Method:
    @@Name: appendNewPCApply
    @@enDesc:
      Creates a <IF::PCApply> object and appends it to the children list
      of the node.
    @@Return:
      @@@Type: PCApply
      @@@enDesc: The newly created node.
      @@@PerlDef:
        __DEEP{
          $r = $self-><AG::Node.ownerDocument>-><M::PCDocument.createPCApply>;
          $self-><M::Node.appendChild> ($r);
        }__;

  @Method:
    @@Name: appendNewPCFunctionCall
    @@enDesc:
      Appends a newly created <IF::PCFunctionCall> node.
    @@Param:
      @@@Name: packageArg
      @@@Type: DOMString
      @@@enDesc:
        The package name of the function.
      @@@nullCase:
        @@@@enDesc: No package name.
    @@Param:
      @@@Name: localNameArg
      @@@Type: DOMString
      @@@enDesc:
        The local part of the function name.
    @@Return:
      @@@Type: PCFunctionCall
      @@@enDesc:
        The newly created functin call object.
      @@@PerlDef:
        __DEEP{
          $r = $self-><AG::Node.ownerDocument>
                    -><M::PCDocument.createPCFunctionCall>
                        ($packageArg, $localNameArg);
          $self-><M::Node.appendChild> ($r);
        }__;
##PCCodeUnits

IFClsETDef:
  @IFQName: PerlStatement
  @CQName: ManakaiPCStatement
  @ETQName: pc|statement

  @IFISA: PerlCode
  @IFISA: PerlCodeInlines
  @CISA: ManakaiPCCodeInlines

  @enDesc:
    Perl statements.   

  @ToStringMethod:
    @@Return:
      @@@Type: DOMString
      @@@enDesc:
        Perl code. 
      @@@PerlDef:
        $r = $self->SUPER::stringify;
        $r .= ";\n" if length $r;
##PerlStatement

IFClsETDef:
  @IFQName: PerlCodeInlines
  @CQName: ManakaiPCCodeInlines
  @ETQName: pc|inlineContainer

  @CISA: ManakaiPCCodeUnits

  @enDesc:
    Perl inline code block.   

  @Method:
    @@Name: appendCode
    @@enDesc:
      Appends an unparsed Perl code fragment. 
    @@Param:
      @@@Name: codeArg
      @@@Type: DOMString
      @@@enDesc:
        An unparsed Perl code fragment. 
    @@Return:
      @@@Type: PerlInlineUnparsedCode
      @@@enDesc:
        The newly created Perl code object. 
      @@@PerlDef:
          __DEEP{
            $r = $self-><AG::Node.ownerDocument>-><M::Document.createElementNS>
                                                (<Q::pc:>, 'inlineUnparsed');
            $r-><AS::Node.textContent> ($codeArg);
            $self-><M::Node.appendChild> ($r);
          }__;

  @ToStringMethod:
    @@Return:
      @@@Type: DOMString
      @@@enDesc:
        Perl code. 
      @@@PerlDef:
          __DEEP{
            my @child = @{$self-><AG::Node.childNodes>};
            for my $child (@child) {
              if ($child-><AG::Node.namespaceURI> eq <Q::pc:> and
                  $child-><AG::Node.localName> eq 'inlineContainer' and
                  1 == @child) {
                $r .= '(' . $child->stringify . ')';
              } else {
                $r .= $child->stringify;
              }
            }
          }__;
##PCCodeInlines

IFClsETDef:
  @IFQName: PerlBlock
  @CQName: ManakaiPerlBlock
  @ETQName: pc|block

  @IFISA: PerlCode
  @IFISA: PerlCodeStatements
  @CISA: ManakaiPCCodeStatements

  @enDesc:
    Perl block-level code block.   

  @ToStringMethod:
    @@Return:
      @@@Type: DOMString
      @@@enDesc:
        Perl code. 
      @@@PerlDef:
        __DEEP{        
          my @child = @{$self-><AG::Node.childNodes>};
          my $label = $self-><AG::PerlCodeStatements.label>;
          if (not $label and @child == 1 and 
              $child[0]-><AG::Node.localName> eq 'block') {
            $r = "\x0A" . $child[0]->stringify . "\x0A";
          } elsif (not $label and @child == 1 and
                   $child[0]-><AG::Node.localName> eq 'unparsed' and
                   $child[0]-><AG::Node.textContent> =~ /^\s*$/) {
            # 
          } else {
            $r = "\x0A";
            for my $child (@child) {
              if ($child-><AG::Node.localName> eq 'inlineContainer' and
                  1 == @child) {
                $r .= '(' . $child->stringify . ')';
              } else {
                $r .= $child->stringify;
              }
            }
            $r .= "\x0A";

            $r = "\n{\n$r\n;}\n" if 2 < length $r;

              $r = "\n" . $label . ':' . $r if $label;
            }
          }__;
##PerlBlock

IFClsETDef:
  @IFQName: PerlCodeBlocks
  @CQName: ManakaiPCCodeBlocks
  @ETQName: pc|blockContainer

  @IFISA: PerlCodeStatements
  @CISA: ManakaiPCCodeStatements

  @enDesc:
    Perl block-level code container whose content may or may
    not semantically be self-contained. 
  
  @ToStringMethod:
    @@Return:
      @@@Type: DOMString
      @@@enDesc:
        Perl code. 
      @@@PerlDef:
          my @child = @{$self-><AG::Node.childNodes>};
          if (@child == 1 and 
              {
                block => true, blockContainer => true,
              }->{$child[0]-><AG::Node.localName>}) {
            $r = $child[0]->stringify;
          } else {
            for my $child (@child) {
              if ($child-><AG::Node.localName> eq 'inlineContainer' and
                  1 == @child) {
                $r .= '(' . $child->stringify . ')';
              } else {
                $r .= $child->stringify;
              }
            }
          }
##PCCodeBlocks

IFClsETDef:
  @IFQName: PCDereference
  @CQName: ManakaiPCDereference
  @ETQName: pc|dereference
  
  @IFISA: PerlCode
  @IFISA: PerlCodeInlines
  @CISA: ManakaiPCCodeInlines

  @enDesc:
    A <IF::PCDereference> object represents a dereference.

  @ATTR:
    @@Name: variableType
    @@ATTRQName: pc|variableType
    @@enDesc:
      The type of the value, such as <Perl::$>.
    @@ReflectCDATA:
    @@Get:
    @@Set:

  @ToStringMethod:
    @@Return:
      @@@Type: DOMString
      @@@PerlDef:
        __DEEP{
          $r = $self-><AG::PCDereference.variableType> . '{';
          A: for my $child (@{$self-><AG::Node.childNodes>}) {
            next A unless $child-><AG::Node.nodeType> == <C::Node.ELEMENT_NODE>;
            $r .= $child;
          }
          $r .= '}';
        }__;
##PCDereference

IFClsETDef:
  @IFQName: PCReference
  @CQName: ManakaiPCReference
  @ETQName: pc|reference
  
  @IFISA: PerlCode
  @IFISA: PerlCodeInlines
  @CISA: ManakaiPCCodeInlines

  @enDesc:
    A <IF::PCReference> object represents a reference (<Perl::\>) operation.

  @ToStringMethod:
    @@Return:
      @@@Type: DOMString
      @@@PerlDef:
        __DEEP{
          $r = '\(undef)';
          no warnings 'uninitialized';
          A: for my $child (@{$self-><AG::Node.childNodes>}) {
            next A unless $child-><AG::Node.nodeType> ==
                          <C::Node.ELEMENT_NODE>;
            $r = $child;
            unless ({
              <Q::pc:variable> => true,
            }->{$child-><AG::Node.namespaceURI>.
                $child-><AG::Node.localName>}) {
              $r = '\('.$r.')';
            }
            last A;
          }
        }__;
##PCReference

IFClsETDef:
  @IFQName: PCApply
  @CQName: ManakaiPCApply
  @ETQName: pc|apply

  @IFISA: PerlCode
  @IFISA: PerlCodeInlines
  @CISA: ManakaiPCCodeInlines

  @enDesc:
    A <IF::PCApply> object represents a function call.

    The first child element must be an expression results in a function name
    (such as bare function or operator name represented
    as a <IF::PCVariable> object or an <IF::PCExpression> with
    operator <Perl::-<gt>> whose last operand is a method name.
    
    The second child element, if any, is an expression intended to be
    an argument for the function.  It is possible to specify more than
    one arguments by <IF::PCExpression> with operator <Perl::,>.

    The third child element, if any, is an expression that is put
    into the indirect object slot.

  @Attr:
    @@Name: function
    @@enDesc:
      The function child element of the element.
    @@Type: PerlCode
    @@Get:
      @@@nullCase:
        @@@@enDesc: There is no child element.
      @@@PerlDef:
        __DEEP{
          A: for my $child (@{$self-><AG::Node.childNodes>}) {
            next A unless $child-><AG::Node.nodeType> == <C::Node.ELEMENT_NODE>;
            $r = $child;
            last A;
          }
        }__;

  @Attr:
    @@Name: argument
    @@enDesc:
      The argument child element of the element.
    @@Type: PerlCode
    @@Get:
      @@@nullCase:
        @@@@enDesc: There is no argument element.
      @@@PerlDef:
        __DEEP{
          my $x;
          A: for my $child (@{$self-><AG::Node.childNodes>}) {
            next A unless $child-><AG::Node.nodeType> == <C::Node.ELEMENT_NODE>;
            if ($x) {
              $r = $child;
              last A;
            } else {
              $x = true;
            }
          }
        }__;

  @Attr:
    @@Name: indirect
    @@enDesc:
      The indirect object slot child element of the element.
    @@Type: PerlCode
    @@Get:
      @@@nullCase:
        @@@@enDesc: There is no indirect object element.
      @@@PerlDef:
        __DEEP{
          my $x = 0;
          A: for my $child (@{$self-><AG::Node.childNodes>}) {
            next A unless $child-><AG::Node.nodeType> == <C::Node.ELEMENT_NODE>;
            if ($x++ == 2) {
              $r = $child;
              last A;
            }
          }
        }__;


  @ToStringMethod:
    @@Return:
      @@@Type: DOMString
      @@@PerlDef:
        __DEEP{
          my $f;
          my $arg;
          my $obj;
          no warnings 'uninitialized';
          A: for my $child (@{$self-><AG::Node.childNodes>}) {
            next A unless $child-><AG::Node.nodeType> == <C::Node.ELEMENT_NODE>;
            if (not defined $f) {
              $f = ''.$child;
            } elsif (not defined $arg) {
              $arg = ''.$child;
            } else {
              $obj = ''.$child;
              last A;
            }
          }

          $r = $f;
          $r .= ' ' . $obj if defined $obj;

          if ({
                'die' => true,
                'last' => true,
                'next' => true,
                'redo' => true,
                'return' => true,
                'warn' => true,
              }->{$r}) {
            $r .= ' ' . $arg;
          } else {
            $r .= ' (' . $arg . ')';
          }
        }__;
##PCApply

IFClsETDef:
  @IFQName: PCExpression
  @CQName: ManakaiPCExpression
  @ETQName: pc|expression

  @IFISA: PerlCode
  @IFISA: PerlCodeInlines
  @CISA: ManakaiPCCodeInlines

  @enDesc:
    A <IF::PCExpression> object represents a sequence of one or more
    expression fragments (operands) separated by the same operator.

  @ATTR:
    @@Name: operator
    @@ATTRQName: pc|operator
    @@enDesc:
      The operator.
    @@ReflectCDATA:
    @@Get:
    @@Set:
 
  @Attr:
    @@Name: operandNumber
    @@enDesc:
      The number of operands.
    @@Type: idl|unsignedLong||ManakaiDOM|all
    @@Get:
      @@@PerlDef:
        __DEEP{
          $r = @{$self-><AG::Node.childNodes>};
        }__;

  @ToStringMethod:
    @@Return:
      @@@Type: DOMString
      @@@PerlDef:
        __DEEP{
          my @r;
          no warnings 'uninitialized';
          A: for my $child (@{$self-><AG::Node.childNodes>}) {
            next A unless $child-><AG::Node.nodeType> == <C::Node.ELEMENT_NODE>;
            my $xuri = $child-><AG::Node.namespaceURI>
                     . $child-><AG::Node.localName>;
            push @r, [$child.'', $child, $xuri];
          }
          if (@r > 1) {
            my $op = $self-><AG::PCExpression.operator>;
            for (@r) {
              if ($_->[2] ne <Q::pc:expression> and not {
                <Q::pc:apply> => true,
                <Q::pc:arrayRefLiteral> => true,
                <Q::pc:atom> => true,
                <Q::pc:dereference> => true,
                <Q::pc:hashRefLiteral> => true,
                <Q::pc:numberLiteral> => true,
                <Q::pc:stringLiteral> => true,
                <Q::pc:tokens> => true,
                <Q::pc:variable> => true,
              }->{$_->[2]}) {
                $_ = '(' . $_->[0] . ')';
              } elsif ($_->[2] eq <Q::pc:expression> and
              (not {
                '**'  => {'->' => true},
                '=~'  => {'->' => true},
                '!~'  => {'->' => true},
                '*'   => {'->' => true, '*' => true},
                '/'   => {'->' => true},
                '%'   => {'->' => true},
                'x'   => {'->' => true},
                '+'   => {'->' => true, '*' => true, '+' => true, '-' => true},
                '-'   => {'->' => true, '*' => true},
                '.'   => {'->' => true},
                '<'   => {'->' => true},
                '>'   => {'->' => true},
                '<='  => {'->' => true},
                '>='  => {'->' => true},
                'lt'  => {'->' => true},
                'gt'  => {'->' => true},
                'le'  => {'->' => true},
                'gr'  => {'->' => true},
                '=='  => {'->' => true},
                '!='  => {'->' => true},
                '<=>' => {'->' => true},
                'eq'  => {'->' => true},
                'ne'  => {'->' => true},
                'cmp' => {'->' => true},
                '&&'  => {'->' => true, '&&' => true},
                '||'  => {'->' => true, '||' => true},
                '..'  => {'->' => true},
                '='   => {'->' => true},
                ','   => {'->' => true, ',' => true, '=>' => true},
                '=>'  => {'->' => true, ',' => true, '=>' => true},
                'and' => {'->' => true, 'and' => true},
                'or'  => {'->' => true, 'or' => true},
              }->{$op}->{$_->[1]-><AG::PCExpression.operator>}) and
              $_->[1]-><AG::PCExpression.operandNumber> > 1) {
                $_ = '(' . $_->[0] . ')';
              } else {
                $_ = $_->[0];
              }
            }
            $op = ' '.$op unless {
              ',' => true,
              '->' => true,
              '..' => true,
              '...' => true,
            }->{$op};
            $op = $op.' ' unless {
              '->' => true,
              '..' => true,
              '...' => true,
            }->{$op};
            $r = join $op, @r;
          } elsif (@r) {
            $r = $r[0]->[0];
          } elsif ($self-><AG::PCExpression.operator> eq ',') {
            $r = '()';
          } else {
            $r = 'undef';
          }
        }__;
##PCExpression

IFClsETDef:
  @IFQName: PerlAssignment
  @CQName: ManakaiPCAssignment
  @ETQName: pc|assignment

  @IFISA: PerlCode
  @CISA: ManakaiPCCode

  @enDesc:
    Perl variable assignment.  

  @ToStringMethod:
    @@Return:
      @@@Type: DOMString
      @@@enDesc:
        Perl code. 
      @@@PerlDef:
          __DEEP{
            $r = $self-><AG::PerlAssignment.leftCode>->stringify
               . ' = '
               . $self-><AG::PerlAssignment.rightCode>->stringify;
          }__;

  @Attr:
    @@Name: leftCode
    @@enDesc:
      Left-hand expression.
    @@Type: PerlCodeInlines
    @@Get:
      @@@nullCase:
        @@@@enDesc: Left-hand code not yet specified.
      @@@PerlDef:
        __DEEP{
          F: for my $child (@{$self-><AG::Node.childNodes>}) {
            if ($child-><AG::Node.namespaceURI> eq <Q::pc:> and
                $child-><AG::Node.localName> eq 'left') {
              $r = $child-><AG::Node.lastChild>;
              last F;
            }
          }
        }__;
    @@Set:
      @@@PerlDef:
        __DEEP{
          F: {
            for my $child (@{$self-><AG::Node.childNodes>}) {
              if ($child-><AG::Node.namespaceURI> eq <Q::pc:> and
                  $child-><AG::Node.localName> eq 'left') {
                $child-><AS::Node.textContent> ('');
                $child-><M::Node.appendChild> ($given);
                last F;
              }
            }
            my $node = $self-><AG::Node.ownerDocument>
                            -><M::Document.createElementNS>
                                   (<Q::pc:>, 'left');
            $node-><M::Node.appendChild> ($given);
            $self-><M::Node.appendChild> ($node);
          }
        }__;

  @Attr:
    @@Name: rightCode
    @@enDesc:
      Right-hand expression.
    @@Type: PerlCodeInlines
    @@Get:
      @@@nullCase:
        @@@@enDesc: Right-hand code not yet specified.
      @@@PerlDef:
        __DEEP{
          F: for my $child (@{$self-><AG::Node.childNodes>}) {
            if ($child-><AG::Node.namespaceURI> eq <Q::pc:> and
                $child-><AG::Node.localName> eq 'right') {
              $r = $child-><AG::Node.lastChild>;
              last F;
            }
          }
        }__;
    @@Set:
      @@@PerlDef:
        __DEEP{
          F: {
            for my $child (@{$self-><AG::Node.childNodes>}) {
              if ($child-><AG::Node.namespaceURI> eq <Q::pc:> and
                  $child-><AG::Node.localName> eq 'right') {
                $child-><AS::Node.textContent> ('');
                $child-><M::Node.appendChild> ($given);
                last F;
              }
            }
            my $node = $self-><AG::Node.ownerDocument>
                            -><M::Document.createElementNS>
                                   (<Q::pc:>, 'right');
            $node-><M::Node.appendChild> ($given);
            $self-><M::Node.appendChild> ($node);
          }
        }__;
##PerlAssignment

IFClsETDef:
  @IFQName: PCCondition
  @CQName: ManakaiPCCondition
  @ETQName: pc2|condition

  @IFISA: PerlCode
  @IFISA: PerlCodeInlines
  @CISA: ManakaiPCCodeInlines

  @enDesc:
    A <IF::PCCondition> object represents a condition expression
    part of an <Perl::if> or <Perl::while> statement.

  @ToStringMethod:
    @@Return:
      @@@Type: DOMString
      @@@PerlDef:
        __DEEP{
          A: for my $child (@{$self-><AG::Node.childNodes>}) {
            next A unless $child-><AG::Node.nodeType> == <C::Node.ELEMENT_NODE>;
            $r .= $child;
          }
        }__;
##PCCondition

IFClsETDef:
  @IFQName: PCBlock
  @CQName: ManakaiPCBlock
  @ETQName: pc2|block

  @IFISA: PerlCode
  @IFISA: PerlCodeStatements
  @CISA: ManakaiPCCodeStatements

  @enDesc:
    A <Q::PCBlock> object represents a Perl code block, i.e. 
    a set of statements enclosed by <CHAR::{> and <CHAR::}> pair.

  @ToStringMethod:
    @@Return:
      @@@Type: DOMString
      @@@PerlDef:
        __DEEP{        
          my @child = @{$self-><AG::Node.childNodes>};
          my $label = $self-><AG::PerlCodeStatements.label>;

            $r = "\x0A";
            for my $child (@child) {
              if ($child-><AG::Node.localName> eq 'inlineContainer' and
                  1 == @child) {
                $r .= '(' . $child->stringify . ')';
              } else {
                $r .= $child->stringify;
              }
            }
            $r .= "\x0A";
            $r .= ';' unless @child;

            $r = "\n{\n$r\n}\n";

              $r = "\n" . $label . ':' . $r . '# ' . $label . "\n"
                if length $label;

          }__;
##PCBlock

IFClsETDef:
  @IFQName: PCWhile
  @CQName: ManakaiPCWhile
  @ETQName: pc|while
  
  @IFISA: PerlCode
  @CISA: ManakaiPCCode

  @enDesc:
    A <IF::PCWhile> object represents a <Perl::while> statement.
    It can contain two child elements: <Q::pc2|condition> and <Q::pc2|block>,
    each represents the condition expression and the block of the <Perl::while>
    statement.

  @ATTR:
    @@Name: label
    @@ATTRQName: pc|label
    @@enDesc:
      Label for this block.
    @@ReflectCDATA:
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          No label.
    @@Set:
      @@@nullCase:
        @@@@enDesc:
          No label.

  @Attr:
    @@Name: condition
    @@enDesc:
      The condition object.
    @@Type: PCCondition
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          There is no condition element.
      @@@PerlDef:
        __CODE{getChildElementByType::
          $namespaceURI => {<Q::pc2:>},
          $localName => {'condition'},
          $parent => $self,
          $result => $r,
        }__;

  @Attr:
    @@Name: block
    @@enDesc:
      The code block that is executed while the <A::PCWhile.condition> met.
    @@Type: PCBlock
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          There is no <Q::pc2:block> child element.
      @@@PerlDef:
        __CODE{getChildElementByType::
          $namespaceURI => {<Q::pc2:>},
          $localName => {'block'},
          $parent => $self,
          $result => $r,
        }__;

  @ToStringMethod:
    @@Return:
      @@@Type: DOMString
      @@@PerlDef:
        __DEEP{
          $r = 'while (';
          my $cond = $self-><AG::PCWhile.condition>;
          if ($cond) {
            $r .= $cond->stringify;
          } else {
            $r .= '0';
          }
          $r .= ') ';
          my $block = $self-><AG::PCWhile.block>;
          if ($block) {
            $r .= $block->stringify;
          } else {
            $r .= "{ }\n";
          }

          my $label = $self-><AG::PCWhile.label>;
          $r = "\n" . $label . ': ' . $r . ' # ' . $label . "\n"
            if length $label;
        }__;
##PCWhile

IFClsETDef:
  @IFQName: PCChoose
  @CQName: ManakaiPCChoose
  @ETQName: pc|choose

  @IFISA: PerlCode
  @CISA: ManakaiPCCode

  @enDesc:
    A <IF::PCChoose> object, or a <Q::pc|choose> element, represents
    a set of <Perl::if>, <Perl::elsif>, and <Perl::else> statements.

  @Method:
    @@Name: getWhen
    @@enDesc:
      Returns a <IF::PCWhen> by its ordinal index.
    @@Param:
      @@@Name: index
      @@@Type: idl|unsignedLong||ManakaiDOM|all
      @@@enDesc:
        The ordinal index of the <Q::pc|when> element.
    @@Return:
      @@@Type: PCWhen
      @@@enDesc:
        The <P::index>th <Q::pc|when> object.
      @@@nullCase:
        @@@@enDesc:
          There is no <P::index>th element.
      @@@PerlDef:
        __DEEP{
          my $i = 0;
          no warnings 'uninitialized';
          A: for my $child (@{$self-><AG::Node.childNodes>}) {
            if ($child-><AG::Node.nodeType> == <C::Node.ELEMENT_NODE> and
                $child-><AG::Node.namespaceURI> eq <Q::pc:> and
                $child-><AG::Node.localName> eq 'when' and
                ++$i == $index) {
              $r = $child;
              last A;
            }
          }
        }__;

  @Method:
    @@Name: appendNewPCWhen
    @@enDesc:
      Appends a new <Q::pc|when> element.
    @@Return:
      @@@Type: PCWhen
      @@@enDesc:
        The newly created <Q::pc|when> element.
      @@@PerlDef:
        __DEEP{
          my $od = $self-><AG::Node.ownerDocument>;
          $r = $od-><M::Document.createElementNS> (<Q::pc:>, 'when');
          my $cond = $od-><M::Document.createElementNS>
                              (<Q::pc2:>, 'condition');
          $r-><M::Node.appendChild> ($cond);
          my $block = $od-><M::Document.createElementNS>
                              (<Q::pc2:>, 'block');
          $r-><M::Node.appendChild> ($block);
          $self-><M::Node.insertBefore> ($r, $self-><AG::PCChoose.otherwise>);
        }__;

  @Attr:
    @@Name: otherwise
    @@enDesc:
      Returns the <IF::PCOtherwise> by its ordinal index.
    @@Type: PCOtherwise
    @@Get:
      @@@enDesc:
        The <Q::pc|otherwise> object.
      @@@nullCase:
        @@@@enDesc:
          There is no <Q::pc|otherwise> element.
      @@@PerlDef:
        __CODE{getChildElementByType::
          $namespaceURI => {<Q::pc:>},
          $localName => {'otherwise'},
          $parent => $self,
          $result => $r,
        }__;

  @Method:
    @@Name: appendNewPCOtherwise
    @@enDesc:
      Appends a new <Q::pc|otherwise> element.  If there is already the
      <Q::pc|otherwise> element, then no element is created and
      the element is returned.
    @@Return:
      @@@Type: PCOtherwise
      @@@enDesc:
        The <Q::pc|otherwise> element.
      @@@PerlDef:
        __DEEP{
          $r = $self-><AG::PCChoose.otherwise>;
          unless ($r) {
            my $od = $self-><AG::Node.ownerDocument>;
            $r = $od-><M::Document.createElementNS> (<Q::pc:>, 'otherwise');
            my $block = $od-><M::Document.createElementNS>
                              (<Q::pc2:>, 'block');
            $r-><M::Node.appendChild> ($block);
            $self-><M::Node.appendChild> ($r);
          }
        }__;

  @ToStringMethod:
    @@Return:
      @@@Type: DOMString
      @@@PerlDef:
        __DEEP{
          S: for my $child (@{$self-><AG::Node.childNodes>}) {
            next S unless $child-><AG::Node.nodeType> == <C::Node.ELEMENT_NODE>;
            next S unless $child-><AG::Node.namespaceURI> eq <Q::pc:>;
            my $ln = $child-><AG::Node.localName>;
            if ($ln eq 'when') {
              $r .= 'els' if length $r;
              $r .= $child->stringify;
            } elsif ($ln eq 'otherwise') {
              $r .= $child->stringify;
              last S;
            }
          } # S
        }__;
##PCChoose

IFClsETDef:
  @IFQName: PCWhen
  @CQName: ManakaiPCWhen
  @ETQName: pc|when
  
  @IFISA: PerlCode
  @CISA: ManakaiPCCode

  @enDesc:
    A <IF::PCWhen> object, or a <Q::pc|when> element, represents an
    <Perl::if> or <Perl::elsif> block.

  @Attr:
    @@Name: condition
    @@enDesc:
      The condition object.
    @@Type: PCCondition
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          There is no condition element.
      @@@PerlDef:
        __CODE{getChildElementByType::
          $namespaceURI => {<Q::pc2:>},
          $localName => {'condition'},
          $parent => $self,
          $result => $r,
        }__;

  @Attr:
    @@Name: block
    @@enDesc:
      The code block that is executed when the <A::PCWhen.condition> met.
    @@Type: PCBlock
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          There is no <Q::pc2:block> child element.
      @@@PerlDef:
        __CODE{getChildElementByType::
          $namespaceURI => {<Q::pc2:>},
          $localName => {'block'},
          $parent => $self,
          $result => $r,
        }__;

  @ToStringMethod:
    @@Return:
      @@@Type: DOMString
      @@@PerlDef:
        __DEEP{
          $r = 'if (';
          my $cond = $self-><AG::PCWhen.condition>;
          if ($cond) {
            $r .= $cond->stringify;
          } else {
            $r .= '0';
          }
          $r .= ') ';
          my $block = $self-><AG::PCWhen.block>;
          if ($block) {
            $r .= $block->stringify;
          } else {
            $r .= "{ }\n";
          }
        }__;
##PCWhen

IFClsETDef:
  @IFQName: PCOtherwise
  @CQName: ManakaiPCOtherwise
  @ETQName: pc|otherwise
  
  @IFISA: PerlCode
  @CISA: ManakaiPCCode

  @enDesc:
    A <IF::PCOtherwise> object, or a <Q::pc|otherwise> element, represents an
    <Perl::else> clause.

  @Attr:
    @@Name: block
    @@enDesc:
      The code block that is executed.
    @@Type: PCBlock
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          There is no <Q::pc2:block> child element.
      @@@PerlDef:
        __CODE{getChildElementByType::
          $namespaceURI => {<Q::pc2:>},
          $localName => {'block'},
          $parent => $self,
          $result => $r,
        }__;

  @ToStringMethod:
    @@Return:
      @@@Type: DOMString
      @@@PerlDef:
        __DEEP{
          my $block = $self-><AG::PCOtherwise.block>;
          if ($block) {
            $r = 'else ' . $block->stringify;
          }
        }__;
##PCOtherwise

ResourceDef:
  @For: ManakaiDOM|ManakaiDOM
  @QName: getChildElementByType
  @rdf:type: DISPerl|BlockCode
  @enDesc:
    Returns the first element of a type.
  @PerlCDef:
    __DEEP{
      no warnings 'uninitialized';
      A: for my $__child (@{$parent-><AG::Node.childNodes>}) {
        if ($__child-><AG::Node.nodeType> == <C::Node.ELEMENT_NODE> and
            $__child-><AG::Node.namespaceURI> eq $namespaceURI and
            $__child-><AG::Node.localName> eq $localName) {
          $result = $__child;
          last A;
        }
      }
    }__;

IFClsETDef:
  @IFQName: PerlIf
  @CQName: ManakaiPCIf
  @ETQName: pc|if

  @IFISA: PerlCode
  @CISA: ManakaiPCCode

  @enDesc:
    Perl variable assignment.

  @ToStringMethod:
    @@Return:
      @@@Type: DOMString
      @@@enDesc:
        Perl code. 
      @@@PerlDef:
          __DEEP{
            my $tcode = $self-><AG::PerlIf.trueCode>;
            my $fcode = $self-><AG::PerlIf.falseCode>;
            my $ccode = $self-><AG::PerlIf.condition>;
            if (defined $tcode) {
              if (defined $fcode) {
                $r = q<if (> . $ccode->stringify . q<) {> . $tcode->stringify .
                     q<} else {> . $fcode->stringify . qq<}\n>;
              } else {
                $r = q<if (> . $ccode->stringify . q<) {> . $tcode->stringify .
                     qq<}\n>;
              }
            } else {
              $r = q<unless (> . $ccode->stringify . q<) {> . $fcode->stringify .
                   qq<}\n>;
            }
          }__;

  @Attr:
    @@Name: condition
    @@enDesc:
      Condition expression.
    @@Type: PerlCodeInlines
    @@Get:
      @@@nullCase:
        @@@@enDesc: Condition code not yet specified.
      @@@PerlDef:
        __DEEP{
          F: for my $child (@{$self-><AG::Node.childNodes>}) {
            if ($child-><AG::Node.namespaceURI> eq <Q::pc:> and
                $child-><AG::Node.localName> eq 'condition') {
              $r = $child-><AG::Node.lastChild>;
              last F;
            }
          }
        }__;
    @@Set:
      @@@PerlDef:
        __DEEP{
          F: {
            for my $child (@{$self-><AG::Node.childNodes>}) {
              if ($child-><AG::Node.namespaceURI> eq <Q::pc:> and
                  $child-><AG::Node.localName> eq 'condition') {
                $child-><AS::Node.textContent> ('');
                $child-><M::Node.appendChild> ($given);
                last F;
              }
            }
            my $node = $self-><AG::Node.ownerDocument>
                            -><M::Document.createElementNS>
                                   (<Q::pc:>, 'condition');
            $node-><M::Node.appendChild> ($given);
            $self-><M::Node.appendChild> ($node);
          }
        }__;

  @Attr:
    @@Name: trueCode
    @@enDesc:
      True-case code.
    @@Type: PerlCodeBlocks
    @@Get:
      @@@nullCase:
        @@@@enDesc: True-case code not yet specified.
      @@@PerlDef:
        __DEEP{
          F: for my $child (@{$self-><AG::Node.childNodes>}) {
            if ($child-><AG::Node.namespaceURI> eq <Q::pc:> and
                $child-><AG::Node.localName> eq 'tr'.'ue') {
              $r = $child-><AG::Node.lastChild>;
              last F;
            }
          }
        }__;
    @@Set:
      @@@PerlDef:
        __DEEP{
          F: {
            for my $child (@{$self-><AG::Node.childNodes>}) {
              if ($child-><AG::Node.namespaceURI> eq <Q::pc:> and
                  $child-><AG::Node.localName> eq 'tr'.'ue') {
                $child-><AS::Node.textContent> ('');
                $child-><M::Node.appendChild> ($given);
                last F;
              }
            }
            my $node = $self-><AG::Node.ownerDocument>
                            -><M::Document.createElementNS>
                                   (<Q::pc:>, 'tr'.'ue');
            $node-><M::Node.appendChild> ($given);
            $self-><M::Node.appendChild> ($node);
          }
        }__;

  @Attr:
    @@Name: falseCode
    @@enDesc:
      False-case code.
    @@Type: PerlCodeBlocks
    @@Get:
      @@@nullCase:
        @@@@enDesc: True-case code not yet specified.
      @@@PerlDef:
        __DEEP{
          F: for my $child (@{$self-><AG::Node.childNodes>}) {
            if ($child-><AG::Node.namespaceURI> eq <Q::pc:> and
                $child-><AG::Node.localName> eq 'fal'.'se') {
              $r = $child-><AG::Node.lastChild>;
              last F;
            }
          }
        }__;
    @@Set:
      @@@PerlDef:
        __DEEP{
          F: {
            for my $child (@{$self-><AG::Node.childNodes>}) {
              if ($child-><AG::Node.namespaceURI> eq <Q::pc:> and
                  $child-><AG::Node.localName> eq 'fal'.'se') {
                $child-><AS::Node.textContent> ('');
                $child-><M::Node.appendChild> ($given);
                last F;
              }
            }
            my $node = $self-><AG::Node.ownerDocument>
                            -><M::Document.createElementNS>
                                   (<Q::pc:>, 'fal'.'se');
            $node-><M::Node.appendChild> ($given);
            $self-><M::Node.appendChild> ($node);
          }
        }__;
##PerlIf

IFClsETDef:
  @IFQName: PCFunctionCall
  @CQName: ManakaiPCFunctionCall
  @ETQName: pc|call

  @IFISA: PerlCode
  @IFISA: PerlCodeInlines
  @CISA: ManakaiPCCodeInlines

  @enDesc:
    A <IF::PCFunctionCall> object represents a function call or
    function-like statement such as <Perl::next>.

  @ATTR:
    @@Name: variableType
    @@ATTRQName: pc|variableType
    @@enDesc:
      The value of the attribute <kwd:MAY> be <Perl::&>,
      which introduces a subroutine name.
    @@ReflectCDATA:
    @@Get:
    @@Set:

  @ATTR:
    @@Name: packageName
    @@ATTRQName: pc|packageName
    @@enDesc:
      The name of the package to which the subroutine belongs.
    @@ReflectCDATA:
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          The object belongs to the current package or 
          does not belong to any package.
    @@Set:
      @@@nullCase:
        @@@@enDesc:
          The object belongs to the current package or
          does not belong to any package.

  @ATTR:
    @@Name: pcLocalName
    @@ATTRQName: pc|localName
    @@enDesc:
      The local part of the subroutine name.
    @@ReflectCDATA:
    @@Get:
    @@Set:

  @ToStringMethod:
    @@Return:
      @@@Type: DOMString
      @@@PerlDef:
        __DEEP{
          $r .= $self-><AG::PCFunctionCall.variableType>;
          my $v = $self-><AG::PCFunctionCall.packageName>;
          $r .= $v . '::' if length $v;
          $r .= $self-><AG::PCFunctionCall.pcLocalName>;

          my @arg;
          no warnings 'uninitialized';
          A: for my $child (@{$self-><AG::Node.childNodes>}) {
            next A unless $child-><AG::Node.nodeType> == <C::Node.ELEMENT_NODE>;
            push @arg, ''.$child;
          }
          my $arg = join ', ', @arg;
          if ({
                'die' => true,
                'last' => true,
                'next' => true,
                'redo' => true,
                'return' => true,
                'warn' => true,
              }->{$r}) {
            $r .= ' ' . $arg;
          } else {
            $r .= ' (' . $arg . ')';
          }
        }__;
##PCFunctionCall

## -- Configuration Parameters

boolCParam:
  @QName: pc|preserve-line-break
  @nodeProp: plb
  @c:targetType: tc|Document
  @IsSupportRequired:1
  @TrueCase:
    @@c:isSupported:1
    @@enDesc:
      When stringifying a <IF::PerlStringLiteral>, if it contains
      <CODE::U+000A> and / or <CODE::U+000D> characters, then
      they are escaped (e.g. <Perl::\x0A>).
    @@TestC:
      @@@QName: cfg.preserve-line-break.true.test
      @@@PerlCDef:
        my $doc;
        __CODE{createPCDocumentForTest:: $doc => $doc}__;

        my $cfg = $doc-><AG::Document.domConfig>;
        $cfg-><M::CFG.setParameter> (<Q::pc|preserve-line-break> => true);
        
        $test->id ('crlf');
        my $sl = $doc-><M::PCDocument.createPCLiteral> ("ab\x0D\x0Acd");
        my $str = $sl->stringify;
        $test->assert_equals ($str, q<"ab\x0D\x0Acd">);
        
        $test->id ('lf');
        my $sl2 = $doc-><M::PCDocument.createPCLiteral> ("ab\x0Acd");
        my $str2 = $sl2->stringify;
        $test->assert_equals ($str2, q<"ab\x0Acd">);
  @FalseCase:
    @@c:isSupported:1
    @@IsSupportRequired:1
    @@IsDefault:1
    @@enDesc:
      Line break characters are stringified as is.
    @@TestC:
      @@@QName: cfg.preserve-line-break.false.test
      @@@PerlCDef:
        my $doc;
        __CODE{createPCDocumentForTest:: $doc => $doc}__;

        my $cfg = $doc-><AG::Document.domConfig>;
        $cfg-><M::CFG.setParameter> (<Q::pc|preserve-line-break> => false);
        
        $test->id ('crlf');
        my $sl = $doc-><M::PCDocument.createPCLiteral> ("ab\x0D\x0Acd");
        my $str = $sl->stringify;
        $test->assert_equals ($str, q<'ab>.qq<\x0D\x0A>.q<cd'>);
        
        $test->id ('lf');
        my $sl2 = $doc-><M::PCDocument.createPCLiteral> ("ab\x0Acd");
        my $str2 = $sl2->stringify;
        $test->assert_equals ($str2, q<'ab>.qq<\x0A>.q<cd'>);
  @TestC:
    @@QName: cfg.preserve-line-break.set.test
    @@PerlCDef:
      my $doc;
      __CODE{createPCDocumentForTest:: $doc => $doc}__;

      my $cfg = $doc-><AG::Document.domConfig>;

      $test->id ('default');
      $test->assert_false ($cfg-><M::CFG.getParameter>
                                   (<Q::pc|preserve-line-break>));

      $test->id ('set.f.to.t');
      $cfg-><M::CFG.setParameter> (<Q::pc|preserve-line-break> => true);
      $test->assert_true ($cfg-><M::CFG.getParameter>
                                   (<Q::pc|preserve-line-break>));

      $test->id ('set.t.to.f');
      $cfg-><M::CFG.setParameter> (<Q::pc|preserve-line-break> => false);
      $test->assert_false ($cfg-><M::CFG.getParameter>
                                   (<Q::pc|preserve-line-break>));

      $cfg-><M::CFG.setParameter> (<Q::pc|preserve-line-break> => true);

      $test->id ('reset');
      $cfg-><M::CFG.setParameter> (<Q::pc|preserve-line-break> => null);
      $test->assert_false ($cfg-><M::CFG.getParameter>
                                   (<Q::pc|preserve-line-break>));

ResourceDef:
  @QName: CFG
  @AliasFor: c|DOMConfiguration
  @For: ManakaiDOM|DOM3

CParam:
  @QName: pc|split-resolver
  @nodeProp: pcsres
  @IsSupportRequired:1
  @c:targetType: tc|Document
  @Type: DISPerl|CODE||ManakaiDOM|all
  @enDesc:
    Splits module file.  The parameter value <kwd:MUST> be
    a Perl code reference.  The serializer would invoke
    the code with arguments: a reserved parameter, a <IF::PerlFile>
    whose serialization is being split, and a string
    that identifies the split part.  The code is expected
    to return a <IF::DOMLS:LSOutput> object to which the module part
    is written.  Note that splitting serialized module file
    does not affect to the <IF::PerlFile> tree.
  @nullCase:
    @@enDesc:
      Does not split module file.

ElementTypeBinding:
  @Name: nodeProp
  @ElementType:
    tc:nodeStemKey
  @ShadowContent:
    @@For: =ManakaiDOM|all

ElementTypeBinding:
  @Name: CParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      @@@@: c|DOMConfigurationParameter
      @@@For: ManakaiDOM|DOM
    @@rdf:type:
      @@@@: DISCore|Property
      @@@For: =ManakaiDOM|all
    @@For: ManakaiDOM|DOM3
    @@For: =ManakaiDOM|all

ElementTypeBinding:
  @Name: boolCParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      @@@@: c|DOMConfigurationParameter
      @@@For: ManakaiDOM|DOM
    @@rdf:type:
      @@@@: DISCore|Property
      @@@For: =ManakaiDOM|all
    @@For: ManakaiDOM|DOM3
    @@For: =ManakaiDOM|all
    @@Type: idl|boolean||ManakaiDOM|all

## -- PCDocument

IFClsDef:
  @IFQName: PCDocument
  @CQName: ManakaiPCDocument

  @IFISA: Document
  @CISA: td|ManakaiDOMDocument

  @enDesc:
    A <IF::PCDocument> is a <IF::Document> that represents a Perl code.

  @s:rootElementType: pc|file

  @Test:
    @@QName: DOMImplementation.createDocument.PCDocument.test
    @@PerlDef:
      my $impl;
      __CODE{tc|createImplForTest:: $impl => $impl}__;
 
      my $doc = $impl-><M::DOMImpl.createDocument> (<Q::pc:>, 'pc:file');

      $test->id ('Document');
      $test->assert_isa ($doc, <IFName::Document>);

      $test->id ('PCDocument');
      $test->assert_isa ($doc, <IFName::PCDocument>);

      my $de = $doc-><AG::Document.documentElement>;

      $test->id ('documentElement.Element');
      $test->assert_isa ($de, <IFName::Element>);

      $test->id ('documentElement.PerlFile');
      $test->assert_isa ($de, <IFName::PerlFile>);

  @Method:
    @@Name: createPCLiteral
    @@enDesc:
      Creates a literal object.

        {NOTE:: If a member of <P::value> is a <IF::PerlCode> object,
                then it is appended to the tree as is.
        }
    @@Param:
      @@@Name: value
      @@@Type: DISPerl|Any||ManakaiDOM|all
      @@@enDesc:
        The value.
      @@@InCase:
        @@@@Type: DISPerl|String||ManakaiDOM|all
        @@@@enDesc:
          A <IF::PerlStringLiteral> whose value is <P::value> is created.
      @@@InCase:
        @@@@Type: DISPerl|ARRAY||ManakaiDOM|all
        @@@@enDesc:
          A <IF::PCArrayRefLiteral> is created.  If <P::value>
          has items, then objects are recursively created.
      @@@InCase:
        @@@@Type: DISPerl|HASH||ManakaiDOM|all
        @@@@enDesc:
          A <IF::PCHashRefLiteral> is created.  If <P::value>
          has key-value pairs, then objects are recursively created.
    @@Return:
      @@@Type: PerlCode
      @@@enDesc: The newly created value object.
      @@@PerlDef:
        __DEEP{
          if (ref $value eq 'HASH' or ref $value eq 'ARRAY') {
            $r = $self-><M::Document.createElementNS>
                     (<Q::pc:>, ref $value eq 'HASH' ? 'hashRefLiteral'
                                                     : 'arrayRefLiteral');
            for my $v (ref $value eq 'HASH' ? %$value : @$value) {
              unless (UNIVERSAL::isa ($v, <IFName::PerlCode>)) {
                $v = $self-><M::PCDocument.createPCLiteral> ($v);
              }
              $r-><M::Node.appendChild> ($v);
            }
          } elsif (defined $value) {
            $r = $self-><M::Document.createElementNS>
                   (<Q::pc:>, 'stringLiteral');
            $r-><AS::Node.textContent> ($value);
          } else {
            $r = $self-><M::Document.createElementNS>
                          (<Q::pc:>, 'atom');
            $r-><AS::Node.textContent> ('undef');
          }
        }__;
    @@Test:
      @@@QName: PCDocument.createPCLiteral.undef.test
      @@@PerlDef:
        my $doc;
        __CODE{createPCDocumentForTest:: $doc => $doc}__;

        $test->id ('undef.element');
        my $e1 = $doc-><M::PCDocument.createPCLiteral> (null);
        $test->assert_isa ($e1, <IFName::PerlAtom>);
        $test->assert_equals ($e1-><AG::Node.textContent>, 'undef');

        $test->id ('string.empty.element');
        my $e2 = $doc-><M::PCDocument.createPCLiteral> ('');
        $test->assert_isa ($e2, <IFName::PerlStringLiteral>);
        $test->assert_equals ($e2-><AG::Node.textContent>, '');

        $test->id ('string.zero.element');
        my $e3 = $doc-><M::PCDocument.createPCLiteral> ('0');
        $test->assert_isa ($e3, <IFName::PerlStringLiteral>);
        $test->assert_equals ($e3-><AG::Node.textContent>, '0');

  @Method:
    @@Name: createPCNumberLiteral
    @@enDesc:
      Creates a number literal object.
    @@Param:
      @@@Name: value
      @@@Type: DISPerl|NumberValue
      @@@enDesc:
        The value.
    @@Return:
      @@@Type: PCNumberValue
      @@@enDesc: The newly created value object.
      @@@PerlDef:
        __DEEP{
          $r = $self-><M::Document.createElementNS>
                   (<Q::pc:>, 'numberLiteral');
          $r-><AS::Node.textContent> ($value);
        }__;

  @Method:
    @@Name: createPCVariable
    @@enDesc:
      Creates a new <IF::PerlVariable> object. 
    @@Param:
      @@@Name: variableType
      @@@Type: DOMString
      @@@enDesc:
        Variable prefix.
      @@@nullCase:
        @@@@enDesc:
          If the <P::packageName> is <DOM::null>, then 
          the <P::variableType> is detected by the prefix of
          <P::localName>.  Otherwise, it is an unprefixed variable
          such as file handle.
    @@Param:
      @@@Name: packageName
      @@@Type: DOMString
      @@@enDesc:
        Package name.
      @@@nullCase:
        @@@@enDesc:
          The variable belongs to the current package or a 
          lexical-scoped variable.
    @@Param:
      @@@Name: localName
      @@@Type: DOMString
      @@@enDesc:
        Variable name.  If both <P::variableType> and <P::packageName>
        is <DOM::null>, the <P::localName> value may be prefixed
        by any possible <P::variableType> value.
    @@Return:
      @@@Type: PerlVariable
      @@@enDesc: 
        Newly created Perl variable object. 
      @@@PerlDef:
          __DEEP{
            $r = $self-><M::Document.createElementNS> (<Q::pc:>, 'variable');
            if (not $variableType and not $packageName and
                $localName =~ s/^(\\?[\$\@%&*])//) {
              $variableType = $1;
            }
            $r-><AS::PerlVariable.variableType> ($variableType)
                                                  if defined $variableType;
            $r-><AS::PerlVariable.packageName> ($packageName)
                                                  if defined $packageName;
            $r-><AS::PerlVariable.pcLocalName> ($localName);
          }__;

  @Method:
    @@Name: createPCDereference
    @@enDesc:
      Creates a <IF::PCDereference> object.
    @@Param:
      @@@Name: variableType
      @@@Type: DOMString
      @@@enDesc:
        The type of the referenced value, such as <Perl::$>.
    @@Return:
      @@@Type: PCDereference
      @@@enDesc:
        The newly created element node.
      @@@PerlDef:
        __DEEP{
          $r = $self-><M::Document.createElementNS>
                        (<Q::pc:>, 'dereference');
          $r-><AS::PCDereference.variableType> ($variableType);
        }__;

  @Method:
    @@Name: createPCReference
    @@enDesc:
      Creates a <IF::PCReference> object.
    @@Return:
      @@@Type: PCReference
      @@@enDesc:
        The newly created element node.
      @@@PerlDef:
        __DEEP{
          $r = $self-><M::Document.createElementNS>
                        (<Q::pc:>, 'reference');
        }__;

  @Method:
    @@Name: createPCExpression
    @@enDesc:
      Creates a <Q::pc:expression> element node.
    @@Param:
      @@@Name: operator
      @@@Type: DOMString
      @@@enDesc:
        The operator of the expression.
    @@Return:
      @@@Type: PCExpression
      @@@enDesc:
        The newly created expression object.
      @@@PerlDef:
        __DEEP{
          $r = $self-><M::Document.createElementNS> (<Q::pc:>, 'expression');
          $r-><AS::PCExpression.operator> ($operator);
        }__;

  @Method:
    @@Name: createPCApply
    @@enDesc:
      Creates a <Q::pc:apply> element node.
    @@Return:
      @@@Type: PCApply
      @@@enDesc: The newly created element node.
      @@@PerlDef:
        __DEEP{
          $r = $self-><M::Document.createElementNS> (<Q::pc:>, 'apply');
        }__;

  @Method:
    @@Name: createPCFunctionCall
    @@enDesc:
      Creates a function call element node.
    @@Param:
      @@@Name: package
      @@@Type: DOMString
      @@@enDesc:
        The package to which the function belongs.
      @@@nullCase:
        @@@@enDesc: No package name.
    @@Param:
      @@@Name: localName
      @@@Type: DOMString
      @@@enDesc:
        The local part of the function name.
    @@Return:
      @@@Type: PCApply
      @@@enDesc:
        The newly created function object.
      @@@PerlDef:
        __DEEP{
          $r = $self-><M::Document.createElementNS> (<Q::pc:>, 'apply');
          my $func = $self-><M::PCDocument.createPCVariable>
                              ('', $package, $localName);
          $r-><M::Node.appendChild> ($func);
        }__;

  @Method:
    @@Name: createPCStatement
    @@enDesc:
      Creates a statement object.
    @@Return:
      @@@Type: PerlStatement
      @@@enDesc:
        The newly created statement element node.
      @@@PerlDef:
        __DEEP{
          $r = $self-><M::Document.createElementNS> (<Q::pc:>, 'statement');
        }__;      

  @Method:
    @@Name: createPCBlock
    @@enDesc:
      Creates a <Q::pc2:block> element node.
    @@Return:
      @@@Type: PCBlock
      @@@enDesc:
        The newly created <Q::pc2:block> element.
      @@@PerlDef:
        __DEEP{
          $r = $self-><M::Document.createElementNS> (<Q::pc2:>, 'block');
        }__;

  @Method:
    @@Name: createPCChoose
    @@enDesc:
      Creates a <Q::pc:choose> element node.
    @@Return:
      @@@Type: PCChoose
      @@@enDesc:
        The newly created <Q::pc:choose> element.
      @@@PerlDef:
        __DEEP{
          $r = $self-><M::Document.createElementNS> (<Q::pc:>, 'choose');
        }__;

  @Method:
    @@Name: createPCWhile
    @@enDesc:
      Creates a <Q::pc:while> element node.
    @@Return:
      @@@Type: PCWhile
      @@@enDesc:
        The newly created <Q::pc:while> element.
      @@@PerlDef:
        __DEEP{
          $r = $self-><M::Document.createElementNS> (<Q::pc:>, 'while');
          $r-><M::Node.appendChild>
                ($self-><M::Document.createElementNS> (<Q::pc2:>, 'condition'));
          $r-><M::Node.appendChild>
                ($self-><M::Document.createElementNS> (<Q::pc2:>, 'block'));
        }__;

  @Method:
    @@Name: createPerlSub
    @@enDesc:
      Creates a new <IF::PerlSub> object. 
    @@Param:
      @@@Name: subName
      @@@Type: DOMString
      @@@enDesc:
        The name of the subroutine to create.
      @@@nullCase:
        @@@@enDesc:
          The subroutine created has no name. 
    @@Return:
      @@@Type: PerlSub
      @@@enDesc: 
        Newly created Perl subroutine object. 
      @@@PerlDef:
          __DEEP{
            $r = $self-><M::Document.createElementNS> (<Q::pc:>, 'sub');
            $r-><M::PerlSub.addPerlName> ($subName) if defined $subName;
          }__;

  @ResourceDef:
    @@ForCheck: ManakaiDOM|ForClass
    @@QName: createPCDocumentForTest
    @@rdf:type: DISPerl|BlockCode
    @@PerlDef:
      my $impl = <Class::ManakaiPCImplementation>->_new;
      $doc = $impl-><M::DOMImpl.createDocument> (<Q::pc:>, 'file');

  @Method:
    @@Name: createPCIf
    @@enDesc:
      Creates a <IF::PerlIf> object. 
    @@Param:
      @@@Name: conditionArg
      @@@Type: PerlCodeInlines
      @@@enDesc:
        Condition code fragment object.
    @@Param:
      @@@Name: trueArg
      @@@Type: PerlCodeBlocks
      @@@enDesc:
        A true code fragment object. 
      @@@nullCase:
        @@@@enDesc: No true code.
    @@Param:
      @@@Name: falseArg
      @@@Type: PerlCodeBlocks
      @@@enDesc:
        A false code fragment object. 
      @@@nullCase:
        @@@@enDesc: No false code.
    @@Return:
      @@@Type: PerlIf
      @@@PerlDef:
        __DEEP{
          $r = $self-><M::Document.createElementNS> (<Q::pc:>, 'if');
          $r-><AS::PerlIf.condition> ($conditionArg) if defined $conditionArg;
          $r-><AS::PerlIf.trueCode> ($trueArg) if defined $trueArg;
          $r-><AS::PerlIf.falseCode> ($falseArg) if defined $falseArg;
        }__;

    @@Test:
      @@@QName: PCDocument.createPCIf.noarg.test
      @@@PerlDef:
        my $doc;
        __CODE{createPCDocumentForTest:: $doc => $doc}__;

        my $e1 = $doc-><M::Document.createElementNS> (null, 'e1');

        my $if = $doc-><M::PCDocument.createPCIf> ($e1);

        $test->assert_isa ($if, <IFName::PerlIf>);

        $test->id ('condition');
        $test->assert_equals ($if-><AG::PerlIf.condition>, $e1);

        $test->id ('trueCode');
        $test->assert_null ($if-><AG::PerlIf.trueCode>);

        $test->id ('falseCode');
        $test->assert_null ($if-><AG::PerlIf.falseCode>);
    @@Test:
      @@@QName: PCDocument.createPCIf.args.test
      @@@PerlDef:
        my $doc;
        __CODE{createPCDocumentForTest:: $doc => $doc}__;

        my $e1 = $doc-><M::Document.createElementNS> (null, 'e1');
        my $e2 = $doc-><M::Document.createElementNS> (null, 'e2');
        my $e3 = $doc-><M::Document.createElementNS> (null, 'e3');

        my $if = $doc-><M::PCDocument.createPCIf> ($e1, $e2, $e3);

        $test->id ('return');
        $test->assert_isa ($if, <IFName::PerlIf>);

        $test->id ('condition');
        $test->assert_equals ($if-><AG::PerlIf.condition>, $e1);

        $test->id ('trueCode');
        $test->assert_equals ($if-><AG::PerlIf.trueCode>, $e2);

        $test->id ('falseCode');
        $test->assert_equals ($if-><AG::PerlIf.falseCode>, $e3);

  @Method:
    @@Name: createPCPackage
    @@enDesc:
      Creates a new package scope block. 
    @@Param:
      @@@Name: packageName
      @@@Type: DOMString
      @@@enDesc:
        The fully-qualified name of the package to create. 
    @@Return:
      @@@Type: PerlPackage
      @@@enDesc:
        The newly created package scope object. 
      @@@PerlDef:
        __DEEP{
          $r = $self-><M::Document.createElementNS> (<Q::pc:>, 'package');
          $r-><AS::PerlPackage.packageName> ($packageName);
        }__;

    @@Test:
      @@@QName: PCDocument.createPCPackage
      @@@PerlDef:
        my $doc;
        __CODE{createPCDocumentForTest:: $doc => $doc}__;

        my $pack = $doc-><M::PCDocument.createPCPackage> ('Package::Name');

        $test->id ('package');
        $test->assert_isa ($pack, <IFName::PerlPackage>);

        $test->id ('packageName');
        $test->assert_equals ($pack-><AG::PerlPackage.packageName>,
                              'Package::Name');

  @Method:
    @@Name: getAutoloadDefinitionList
    @@enDesc:
      Returns a set of definitions for autoloading.
    @@Return:
      @@@Type: DISPerl|HASH||ManakaiDOM|all
      @@@PerlDef:
        __DEEP{
          my $file = $self->document_element;
          my $first_pack;
          my $first_pack_name;
          for my $pack (@{$file ? $file->child_nodes : []}) {
            next unless $pack->can ('get_rev_isa_package_name_list');
            unless (defined $first_pack) {
              $first_pack = $pack;
              $first_pack_name = $first_pack->package_name;
            }
            my $rev_isa = $pack->get_rev_isa_package_name_list;
            next unless @$rev_isa;
            my $pack_name = $pack->package_name;
            for my $mem (@{$pack->child_nodes}) {
              next unless $mem->can ('get_perl_name_list');
              my $proto = $mem->prototype;
              for my $name (@{$mem->get_perl_name_list}) {
                $r->{method}->{$_}->{$name} = {
                  module => $first_pack_name,
                  class => $pack_name,
                  prototype =>  $proto,
                } for @$rev_isa;
              }
            }
          }
        }__;

    @@ImplNote:
      {TODO::
        Test
      }
##PCDocument

## -- Implementation

IFClsDef:
  @IFQName: PCImplementation
  @CQName: ManakaiPCImplementation

  @enDesc:
    The class that provides factory methods. 

  @CISA: c|ManakaiDOMImplementation||ManakaiDOM|ManakaiDOMLatest

  @f:provides: pc|CoreFeature10

  @Test:
    @@QName: ImplementationRegistry.PCImplementation.1.0.test
    @@PerlDef:
      my $impl = $Message::DOM::ImplementationRegistry
                   ->get_implementation ({<Q::Util|PerlCode> => '1.0'});

      $test->assert_isa ($impl, <IFName::PCImplementation>);
  @Test:
    @@QName: ImplementationRegistry.PCImplementation.empty.test
    @@PerlDef:
      my $impl = $Message::DOM::ImplementationRegistry
                   ->get_implementation ({<Q::Util|PerlCode> => ''});

      $test->assert_isa ($impl, <IFName::PCImplementation>);
  @Test:
    @@QName: ImplementationRegistry.PCImplementation.null.test
    @@PerlDef:
      my $impl = $Message::DOM::ImplementationRegistry
                   ->get_implementation ({<Q::Util|PerlCode> => null});

      $test->assert_isa ($impl, <IFName::PCImplementation>);

  @Method:
    @@Name: createPCFile
    @@enDesc:
      Creates a <IF::PerlFile> object that belongs to the new
      <IF::PCDocument>.
    @@Return:
      @@@Type: PerlFile
      @@@enDesc:
        {P:: The newly created Perl file object where:

           - The <A::Document.strictErrorChecking> attribute
             is set to <DOM::false>.

           - The <Q::cfg|dtd-default-attribute> configuration
             parameter is set to <DOM::false>.

           - The <Q::cfg|dtd-attribute-type> configuration
             parameter is set to <DOM::false>.

        }
      @@@PerlDef:
        __DEEP{
          my $rdoc = $self-><M::DOMImpl.createDocument> (<Q::pc:>, 'file');

          $rdoc-><AS::Document.strictErrorChecking> (false);
          my $rdoc_cfg = $rdoc-><AG::Document.domConfig>;
          $rdoc_cfg-><M::CFG.setParameter>
                       (<Q::cfg|dtd-default-attribute> => false);
          $rdoc_cfg-><M::CFG.setParameter>
                       (<Q::cfg|dtd-attribute-type> => false);

          $r = $rdoc-><AG::Document.documentElement>;
        }__;

    @@Test:
      @@@QName: PCImplementation.createPCFile.test
      @@@PerlDef:
        my $impl;
        __CODE{tc|createImplForTest:: $impl => $impl}__;
        $impl = $impl->get_feature (<Q::Util|PerlCode> => '1.0');

        my $file = $impl-><M::PCImplementation.createPCFile>;

        $test->id ('interface');
        $test->assert_isa ($file, <IFName::PerlFile>);

        my $od = $file->owner_document;

        $test->id ('od.interface');
        $test->assert_isa ($od, <IFName::PCDocument>);

        $test->id ('parentNode');
        $test->assert_equals ($file->parent_node, $od);

        $test->id ('strictErrorChecking');
        $test->assert_false ($od->strict_error_checking);

        my $cfg = $od->dom_config;

        $test->id ('cfg.dtd-default-attribute');
        $test->assert_false ($cfg->get_parameter
                                     (<Q::cfg|dtd-default-attribute>));

        $test->id ('cfg.dtd-attribute-type');
        $test->assert_false ($cfg->get_parameter
                                     (<Q::cfg|dtd-attribute-type>));

  @IntMethod:
    @@ForCheck: ManakaiDOM|ForClass
    @@Name: perlComment
    @@ManakaiDOM:isStatic:1
    @@enDesc:
      Generates a Perl comment string. 
    @@Param:
      @@@Name: str
      @@@Type: DOMString
      @@@enDesc:
        A comment text. 
    @@Return:
      @@@Type: DOMString
      @@@enDesc:
        A Perl comment string.
      @@@PerlDef:
        $r = $str;
        $r =~ s/\n/\n## /g;
        $r =~ s/\n## $/\n/s;
        $r .= "\n" unless $r =~ /\n$/;
        $r = q<## > . $r;

  @IntMethod:
    @@ForCheck: ManakaiDOM|ForClass
    @@Name: rfc3339DateTime
    @@ManakaiDOM:isStatic:1
    @@enDesc:
      Returns RFC 3339 <CODE::date-time> representation of a date. 
    @@Param:
      @@@Name: perlDate
      @@@Type: idl|unsignedLong||ManakaiDOM|all
      @@@enDesc:
        A Perl representation of date. 
    @@Return:
      @@@Type: DOMString
      @@@enDesc:
        RFC 3339 date string. 
      @@@PerlDef:
        my @time = gmtime $perlDate;
        $r = sprintf q<%04d-%02d-%02dT%02d:%02d:%02d+00:00>,
                     $time[5] + 1900, $time[4] + 1, @time[3,2,1,0];

  @IntMethod:
    @@ForCheck: ManakaiDOM|ForClass
    @@Name: versionDateTime
    @@ManakaiDOM:isStatic:1
    @@enDesc:
      Returns date for version. 
    @@Param:
      @@@Name: perlDate
      @@@Type: idl|unsignedLong||ManakaiDOM|all
      @@@enDesc:
        A Perl representation of date. 
    @@Return:
      @@@Type: DOMString
      @@@enDesc:
        A Perl number literal. 
      @@@PerlDef:
        my @time = gmtime $perlDate;
        $r = sprintf q<%04d%02d%02d.%02d%02d>,
                     $time[5] + 1900, $time[4] + 1, @time[3,2,1];
  
  @Method:
    @@Name: perlLiteral
    @@enDesc:
      Perl code representation. 
    @@Param:
      @@@Name: val
      @@@Type: DISPerl|Any||ManakaiDOM|all
      @@@enDesc:
        A Perl value. 
    @@Return:
      @@@Type: DOMString
      @@@enDesc:
        A Perl lexical representation of <P::val>. 
      @@@PerlDef:
        unless (defined $val) {
          $r = q<undef>;
        } elsif (ref $val eq 'ARRAY') {
          __DEEP{
            $r = q<[> . <ClassM::ManakaiPCImplementation
                                            .perlList> ($val) . q<]>;
          }__;
        } elsif (ref $val eq 'HASH') {
          __DEEP{
            $r = q<{>
               . <ClassM::ManakaiPCImplementation.perlList>
                   ([map {$_ => $val->{$_}} sort {$a cmp $b} keys %$val])
               . q<}>;
          }__;
        } elsif (ref $val eq 'manakai::code') {
          $r = $$val;
        } else {
          $val =~ s/(['\\])/\\$1/g;
          $r = q<'> . $val . q<'>;
        }

  @Method:
    @@Name: perlList
    @@enDesc:
      Perl code representation of a list. 
    @@Param:
      @@@Name: val
      @@@Type: DISPerl|ARRAY||ManakaiDOM|all
      @@@enDesc:
        A Perl array reference. 
    @@Return:
      @@@Type: DOMString
      @@@enDesc:
        A Perl lexical representation of <CODE::@$val>. 
      @@@PerlDef:
        __DEEP{
          $r = join (qq<,\n>, map {<ClassM::ManakaiPCImplementation
                                              .perlLiteral> ($_)} @{$val});
        }__;
##PCImplementation

ResourceDef:
  @QName: DOMImpl
  @AliasFor: c|DOMImplementation
  @For: ManakaiDOM|DOM

ResourceDef:
  @QName: NodeList
  @AliasFor: tc|NodeList
  @For: ManakaiDOM|DOM

ResourceDef:
  @QName: Node
  @AliasFor: tc|Node
  @For: ManakaiDOM|DOM

ResourceDef:
  @QName: Element
  @AliasFor: tc|Element
  @For: ManakaiDOM|DOM

ResourceDef:
  @QName: Document
  @AliasFor: tc|Document
  @For: ManakaiDOM|DOM

ElementTypeBinding:
  @Name: Method
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:Method

ElementTypeBinding:
  @Name: ToStringMethod
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:Method
    @@Operator:
      @@@@:
        DISPerl:AsStringMethod
      @@@ContentType: DISCore|QName
    @@Description:
      @@@lang:en
      @@@@:
        Returns the textual Perl source code representation of this object. 

ElementTypeBinding:
  @Name: NumValMethod
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:Method
    @@Operator:
      @@@@: 0+
      @@@ContentType:
        lang:Perl
    @@Description:
      @@@lang:en
      @@@@:
        Returns the numeric value of this object.

ElementTypeBinding:
  @Name: IntMethod
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:Method
    @@ManakaiDOM:isForInternal:1

ElementTypeBinding:
  @Name: Attr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:Attribute

ElementTypeBinding:
  @Name: Return
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:MethodReturn

ElementTypeBinding:
  @Name: Get
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:AttributeGet

ElementTypeBinding:
  @Name: Set
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:AttributeSet

ElementTypeBinding:
  @Name: Param
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:MethodParameter

ElementTypeBinding:
  @Name: PerlDef
  @ElementType:
    dis:Def
  @ShadowContent:
    @@ContentType:
      lang:Perl
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: PerlCDef
  @ElementType:
    dis:Def
  @ShadowContent:
    @@ContentType:
      lang:Perl

ElementTypeBinding:
  @Name: disDef
  @ElementType:
    dis:Def
  @ShadowContent:
    @@ContentType:
      lang:dis
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: InCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:InCase

ElementTypeBinding:
  @Name: nullCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:InCase
    @@Value:
      @@@is-null:1

ElementTypeBinding:
  @Name: TrueCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:InCase
    @@Value:
      @@@@:1
      @@@ContentType: DISCore|Boolean
    @@Type:
      DOMMain:boolean::ManakaiDOM:all


ElementTypeBinding:
  @Name: FalseCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:InCase
    @@Value:
      @@@@:0
      @@@ContentType: DISCore|Boolean
    @@Type:
      DOMMain:boolean::ManakaiDOM:all

ElementTypeBinding:
  @Name: enDesc
  @ElementType:
    dis:Description
  @ShadowContent:
    @@lang:en

ElementTypeBinding:
  @Name: NamedParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:MethodParameter
    @@DISPerl:isNamedParameter:1

