Module:
  @QName:
    Util:PerlCode
  @FullName:
    @@lang: en
    @@@:
      Perl Code Constructor
  @Namespace:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/PerlCode#
  
  @Description:
    @@lang:en
    @@@:
      This module provides an object-oriented interface to construct 
      Perl code. 

  @DISCore:author: DISCore|Wakaba
  @License:
    @@@:
      license:Perl+MPL
    @@Original:
      @@@FullName:
        manakai <CODE::lib/manakai/genlib.pl>
      @@@Year:2004
      @@@DISCore:author: DISCore|Wakaba
  @Date:
    @@@:
      $Date: 2005/09/29 09:14:58 $
    @@ContentType:
      dis:Date.RCS
  
  @Require:
    @@Module:
      @@@Name: ManakaiNode
      @@@WithFor:
        ManakaiDOM:Perl
    @@Module:
      @@@QName:
        MDOM:DOMFeature
      @@@WithFor:
        ManakaiDOM:ManakaiDOMLatest

  @DefaultFor: 
    ManakaiDOM:Perl

Namespace:
  @DIS:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS#
  @dis:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#dis--
  @dis2pm:
    http://suika.fam.cx/~wakaba/archive/2004/11/8/dis2pm#
  @DISlib:
    http://suika.fam.cx/~wakaba/archive/2004/dis/
  @DOMCore:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#
  @DOMLS:
    http://suika.fam.cx/~wakaba/archive/2004/dom/ls#
  @DOMMain:
    http://suika.fam.cx/~wakaba/archive/2004/dom/main#
  @DOMMetaImpl:
    http://suika.fam.cx/~wakaba/archive/2004/dom/meta#
  @dx:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#
  @infoset:
    http://www.w3.org/2001/04/infoset#
  @kwd:
    http://suika.fam.cx/~wakaba/archive/2005/rfc2119/
  @lang:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#
  @license:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/license#
  @ManakaiDOM:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#
  @Markup:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Markup#
  @MDOM:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#ManakaiDOM.
  @MDOMX:
    http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#
  @mn:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/ManakaiNode#
  @owl:
    http://www.w3.org/2002/07/owl#
  @pc:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/PerlCode#
  @Perl:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#Perl--
  @rdf:
    http://www.w3.org/1999/02/22-rdf-syntax-ns#
  @rdfs:
    http://www.w3.org/2000/01/rdf-schema#
  @swcfg21:
    http://suika.fam.cx/~wakaba/archive/2005/swcfg21#
  @TreeCore:\
  @Util:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/

## -- Features

ElementTypeBinding:
  @Name: FeatureDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DOMFeature|Feature
    @@For: =ManakaiDOM|all

ElementTypeBinding:
  @Name: FeatureVerDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DOMFeature|Feature

ElementTypeBinding:
  @Name: featureQName
  @ElementType:
    DOMFeature:name
  @ShadowContent:
    @@ContentType: DISCore|QName

FeatureDef:
  @QName: CoreFeature
  @featureQName:
    Util:PerlCode
  @FeatureVerDef:
    @@QName: CoreFeature10
    @@Version: 1.0
    @@ISA: CoreFeature
    @@FullName:
      @@@lang:en
      @@@@:
        Perl Code Constructor, version 1.0
    @@Description:
      @@@lang:en
      @@@@:
        Perl Code Constructor, version 1.0.

ElementTypeBinding:
  @Name: IFClsDef
  @ElementType: 
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      @@@@: dis|MultipleResource
      @@@ForCheck: !ManakaiDOM|ForIF !ManakaiDOM|ForClass
    @@resourceFor: ManakaiDOM|ForIF
    @@resourceFor: ManakaiDOM|ForClass
    @@For: ManakaiDOM|Perl

    @@rdf:type:
      @@@@: ManakaiDOM|IF
      @@@ForCheck: ManakaiDOM|ForIF

    @@rdf:type:
      @@@@: ManakaiDOM|Class
      @@@ForCheck: ManakaiDOM|ForClass
    @@Implement:
      @@@@: ||ManakaiDOM|Perl||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|Perl

    @@DOMMain:implementFeature: CoreFeature10

ElementTypeBinding:
  @Name: ClsDef
  @ElementType: 
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      @@@@: dis|MultipleResource
      @@@ForCheck: !ManakaiDOM|ForIF !ManakaiDOM|ForClass

    @@resourceFor: ManakaiDOM|ForClass
    @@For: ManakaiDOM|Perl

    @@rdf:type:
      @@@@: ManakaiDOM|Class
      @@@ForCheck: ManakaiDOM|ForClass

    @@DOMMain:implementFeature: CoreFeature10

ElementTypeBinding:
  @Name: caType
  @ElementType:
    dis:actualType
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: IFQName
  @ElementType:
    dis:QName
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForIF

ElementTypeBinding:
  @Name: ClsQName
  @ElementType:
    dis:QName
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: IFISA
  @ElementType:
    dis:ISA
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForIF

ElementTypeBinding:
  @Name: ClsISA
  @ElementType:
    dis:ISA
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass

## -- Classes

IFClsDef:
  @IFQName: PerlCode
  @ClsQName: ManakaiPerlCodeFragment

  @ClsISA:
    ManakaiDOM:ManakaiDOMNodeReference::ManakaiDOM:Perl
  @ClsISA:
    dx:ManakaiDefaultExceptionHandler::ManakaiDOM:Perl

  @enDesc:
    A class on which another Perl code classes are constructed based. 

  @Attr:
    @@Name: parentNode
    @@enDesc:
      The parent construction of this object. 
    @@Get:
      @@@Type: PerlCode
      @@@caType: ManakaiPerlCodeFragment
      @@@nullCase:
        @@@@enDesc:
          This object has no parent. 
      @@@PerlDef:
        $r = $self->{<H::mn:node>}->{<H::pc:parent>};
        $r = <ClassM::ManakaiPerlCodeFragment.getNodeReference> ($r) if $r;

  @Attr:
    @@Name: fileNode
    @@enDesc:
      The root <QUOTE::file> node of the tree to which this node belongs.
    @@Type: PerlCode
    @@caType: ManakaiPerlCodeFragment
    @@Get:
      @@@enDesc:
        The <QUOTE::file> node of the tree.
      @@@nullCase:
        @@@@enDesc:
          This node does not belong to any file tree.
      @@@PerlDef:
        $r = $self->{<H::mn:node>}->{<H::pc:parent>};
        {
          if ($r->{<H::pc:parent>}) {
            $r = $r->{<H::pc:parent>};
            redo;
          }
        };
        if ($r) {
          if ($r->{<H::pc:nodeType>} eq 'file') {
            __DEEP{
              $r = <ClassM::ManakaiPerlCodeFragment.getNodeReference> ($r);
            }__;
          } else {
            $r = null;
          }
        } elsif ($self->{<H::mn:node>}->{<H::pc:nodeType>} eq 'file') {
          $r = $self;
        }

  @IntMethod:
    @@Name: getNodeReference
    @@ManakaiDOM:isStatic:1
    @@enDesc:
      Gets a node reference for a node object. 
    @@Param:
      @@@Name: object
      @@@Type:
        ManakaiDOM:ManakaiDOMNodeReference::ManakaiDOM:Perl
      @@@enDesc:
        A node object. 
    @@Return:
      @@@Type:
        ManakaiDOM:ManakaiDOMNodeReference::ManakaiDOM:Perl
      @@@PerlDef:
        my $nt = $object->{<H::pc:nodeType>};
        my $pack;
        __CODE{pc:nodeTypeToPackageName::
                 $nodeType => $nt, $packageName => $pack, $object => $object}__;
        __CODE{ManakaiNode:getNewReference::
                 $object => $object, $ref => $r, $class => $pack}__;

  @Method:
    @@Name: replaceVariable
    @@enDesc:
      Replaces a variable. 
      \
      {NOTE:: For objects of type <Class::ManakaiPerlFile>, 
              <Class::ManakaiPerlPackageScope>,
              <Class::ManakaiPerlSub> and
              <Class::ManakaiPerlVariable>, the result is undefined.
      \
      }
    @@Param:
      @@@Name: originalVariable
      @@@Type:
        lang:Perl::ManakaiDOM:all
      @@@enDesc:
        Original variable specification, including prefix. 
        \
        {NOTE:: Qualified name variable and hash key is not supported.
        \
        }
    @@Param:
      @@@Name: newValue
      @@@Type: 
        DOMMain:any::ManakaiDOM:all
      @@@enDesc:
        New value to replace.
      @@@InCase:
        @@@@Type: PerlCode
        @@@@caType: ManakaiPerlCodeFragment
        @@@@enDesc:
          New Perl code fragment to replace by.
      @@@InCase:
        @@@@Type:
          lang:Perl::ManakaiDOM:all
        @@@@enDesc:
          Inline Perl code fragment string to replace by.
    @@Return:
      @@@PerlDef:
        my $node = $self->{<H::mn:node>};
        if ($node->{<H::pc:nodeType>} eq 'unparsed' or
            $node->{<H::pc:nodeType>} eq 'inunparsed') {
          my $newVariable = ref $newValue ? $newValue->stringify : ''.$newValue;
          $node->{<H::pc:code>} =~ s/\Q$originalVariable\E\b/$newVariable/g;
        } elsif ($node->{<H::pc:childNodes>}) {
          __DEEP{
            for my $cnoi (0..$#{$node->{<H::pc:childNodes>}}) {
              my $cno = $node->{<H::pc:childNodes>}->[$cnoi];
              if ($cno->{<H::pc:nodeType>} eq 'variable') {
                if (substr ($originalVariable, 0, 1)
                                  eq $cno->{<H::pc:variableType>} and
                    not $cno->{<H::pc:packageName>} and
                    substr ($originalVariable, 1)
                                  eq $cno->{<H::pc:localName>} and
                    not $cno->{<H::pc:hashKey>}) {
                  if (ref $newValue) {
                    CORE::delete $cno->{<H::pc:parent>};
                    $cno-><M::ManakaiDOM:ManakaiDOMNodeObject
                            ::ManakaiDOM:Perl.orphanate>;
                    my $newnode = $newValue->{<H::mn:node>};
                    $node-><M::ManakaiDOM:ManakaiDOMNodeObject
                                ::ManakaiDOM:Perl.importTree> ($newnode);
                    $newnode->{<H::pc:parent>} = $node;
                    $node->{<H::pc:childNodes>}->[$cnoi] = $newnode;
                  } else {
                    my $cn;
                    __CODE{ManakaiNode:getWeakReference::
                      $object => $cno, $ref => $cn,
                      $class => {<ClassName::ManakaiPerlCodeFragment>},
                    }__;
                    $cn-><M::ManakaiPerlInlineContainer.appendCode>
                              ($newValue);
                  }
                }
              } else { ## Non-variable child
                my $cn;
                __CODE{ManakaiNode:getWeakReference::
                  $object => $cno, $ref => $cn,
                  $class => {<ClassName::ManakaiPerlCodeFragment>},
                }__;
                $cn-><M::ManakaiPerlCodeFragment.replaceVariable>
                                       ($originalVariable => $newValue);
              }
            }
          }__;
        }

  @Method:
    @@Name: addUsePerlModuleName
    @@enDesc:
      Adds a Perl module into the list of Perl modules 
      <Perl::use>d by this code fragment.
    @@Param:
      @@@Name: moduleName
      @@@Type:
        Perl:package-name::ManakaiDOM:all
      @@@enDesc:
        The name of the module package that should be <Perl::use>d.
    @@Return:
      @@@PerlDef:
        $self->{<H::mn:node>}->{<H::pc:useModuleName>}
             ->{$moduleName} = true;

  @Method:
    @@Name: addUseCharClassName
    @@enDesc:
      Adds a Perl module into the list of Perl character classes 
      <Perl::use>d by this code fragment.
    @@Param:
      @@@Name: moduleName
      @@@Type:
        Perl:package-name::ManakaiDOM:all
      @@@enDesc:
        The name of the module package that should be <Perl::use>d.
    @@Param:
      @@@Name: charClassName
      @@@Type:
        lang:Perl::ManakaiDOM:all
      @@@enDesc:
        The name of the character class.
    @@Return:
      @@@PerlDef:
        $self->{<H::mn:node>}->{<H::pc:useCharClassName>}
             ->{$moduleName}->{$charClassName} = true;

  @Method:
    @@Name: addRequirePerlModuleName
    @@enDesc:
      Adds a Perl module into the list of Perl modules 
      <Perl::require>d by this code fragment.
    @@Param:
      @@@Name: moduleName
      @@@Type:
        Perl:package-name::ManakaiDOM:all
      @@@enDesc:
        The name of the module package that should be <Perl::require>d.
    @@Return:
      @@@PerlDef:
        $self->{<H::mn:node>}->{<H::pc:requireModuleName>}
             ->{$moduleName} = true;

  @Method:
    @@Name: getUsePerlModuleNameList
    @@enDesc:
      Returns a list of Perl modules names that is <Perl::use>d
      by this code fragment, including all descendant nodes. 
    @@Return:
      @@@Type:
        Perl:ARRAY::ManakaiDOM:all
      @@@enDesc:
        A list of module names.  Note that the list is <EM::dead>; 
        any modification to it does not affect to the code fragment
        and vice versa.
      @@@PerlDef:
        my $list = {};
        my @node = ($self->{<H::mn:node>});
        while (my $node = shift @node) {
          next unless ref $node;
          for my $mname (keys %{$node->{<H::pc:useModuleName>} || {}}) {
            $list->{$mname} ||= $node->{<H::pc:useModuleName>}->{$mname};
          }
          push @node, $node->{$_} for @{$node->{<Q::TreeCore:subnode0>}};
          my @n;
          for my $nn (map {$node->{$_}} @{$node->{<Q::TreeCore:subnode2>}}) {
            push @n, (ref $nn eq 'ARRAY' ? @$nn : values %{$nn || {}});
          }
          for my $n ((map {$node->{$_}} @{$node->{<Q::TreeCore:subnode>}}), @n) {
            push @node, (ref $n eq 'ARRAY' ? @$n : values %{$n || {}});
          }
        }
        $r = [grep {$list->{$_}} keys %$list];

  @Method:
    @@Name: getUseCharClassNameList
    @@enDesc:
      Returns a list of Perl character class names that is <Perl::use>d
      by this code fragment, including all descendant nodes. 
    @@Return:
      @@@Type:
        Perl:HASH::ManakaiDOM:all
      @@@enDesc:
        A list of module names.  Note that the list is <EM::dead>; 
        any modification to it does not affect to the code fragment
        and vice versa.
      @@@PerlDef:
        my @node = ($self->{<H::mn:node>});
        while (my $node = shift @node) {
          next unless ref $node;
          for my $mname (keys %{$node->{<H::pc:useCharClassName>} || {}}) {
            for my $cname (keys %{$node->{<H::pc:useCharClassName>}
                                       ->{$mname}}) {
              $r->{$mname}->{$cname}
                  ||= $node->{<H::pc:useCharClassName>}->{$mname}->{$cname};
            }
          }
          push @node, $node->{$_} for @{$node->{<Q::TreeCore:subnode0>}};
          my @n;
          for my $nn (map {$node->{$_}} @{$node->{<Q::TreeCore:subnode2>}}) {
            push @n, (ref $nn eq 'ARRAY' ? @$nn : values %{$nn || {}});
          }
          for my $n ((map {$node->{$_}} @{$node->{<Q::TreeCore:subnode>}}), @n) {
            push @node, (ref $n eq 'ARRAY' ? @$n : values %{$n || {}});
          }
        }

  @Method:
    @@Name: getRequirePerlModuleNameList
    @@enDesc:
      Returns a list of Perl modules names that is <Perl::require>d
      by this code fragment, including all descendant nodes. 
    @@Return:
      @@@Type:
        Perl:ARRAY::ManakaiDOM:all
      @@@enDesc:
        A list of module names.  Note that the list is <EM::dead>; 
        any modification to it does not affect to the code fragment
        and vice versa.
      @@@PerlDef:
        my $list = {};
        my @node = ($self->{<H::mn:node>});
        while (my $node = shift @node) {
          next unless ref $node;
          for my $mname (keys %{$node->{<H::pc:requireModuleName>} || {}}) {
            $list->{$mname} ||= $node->{<H::pc:requireModuleName>}->{$mname};
          }
          push @node, $node->{$_} for @{$node->{<Q::TreeCore:subnode0>}};
          my @n;
          for my $nn (map {$node->{$_}} @{$node->{<Q::TreeCore:subnode2>}}) {
            push @n, (ref $nn eq 'ARRAY' ? @$nn : values %{$nn || {}});
          }
          for my $n ((map {$node->{$_}} @{$node->{<Q::TreeCore:subnode>}}), @n) {
            push @node, (ref $n eq 'ARRAY' ? @$n : values %{$n || {}});
          }
        }
        $r = [grep {$list->{$_}} keys %$list];

  @Method:
    @@Name: disAddRequireURI
    @@enDesc:
      Adds a <QUOTE::dis> resource into the list of <Perl::require>d
      resources of this code fragment.
    @@Param:
      @@@Name: uriArg
      @@@Type:
        DISLang:String::ManakaiDOM:all
      @@@enDesc:
        The URI reference of the resource to add.
    @@Return:
      @@@PerlDef:
        $self->{<H::mn:node>}->{<H::pc:requireResourceURI>}
             ->{$uriArg} = true;

  @Method:
    @@Name: disGetRequireURIList
    @@enDesc:
      Returns a list of <QUOTE::dis> resource URI references that is
      <Perl::require>d by this code fragment, including all descendant nodes. 
    @@Return:
      @@@Type:
        Perl:ARRAY::ManakaiDOM:all
      @@@enDesc:
        A list of resource URI references.  Note that the list is <EM::dead>; 
        any modification to it does not affect to the code fragment
        and vice versa.
      @@@PerlDef:
        my $list = {};
        my @node = ($self->{<H::mn:node>});
        while (my $node = shift @node) {
          next unless ref $node;
          for my $mname (keys %{$node->{<H::pc:requireResourceURI>} || {}}) {
            $list->{$mname} ||= $node->{<H::pc:requireResourceURI>}->{$mname};
          }
          push @node, $node->{$_} for @{$node->{<Q::TreeCore:subnode0>}};
          my @n;
          for my $nn (map {$node->{$_}} @{$node->{<Q::TreeCore:subnode2>}}) {
            push @n, (ref $nn eq 'ARRAY' ? @$nn : values %{$nn || {}});
          }
          for my $n ((map {$node->{$_}} @{$node->{<Q::TreeCore:subnode>}}), @n) {
            push @node, (ref $n eq 'ARRAY' ? @$n : values %{$n || {}});
          }
        }
        $r = [grep {$list->{$_}} keys %$list];
##PerlCode

PropDef:
  @QName: useModuleName
  @enDesc:
    The list of modules. 

PropDef:
  @QName: useCharClassName
  @enDesc:
    The list of modules. 

PropDef:
  @QName: requireResourceURI
  @enDesc:
    The list of resources.

ResourceDef:
  @For: ManakaiDOM|Perl
  @QName: nodeTypeToPackageName
  @rdf:type:
    dis2pm:BlockCode
  @enDesc:
    Gets Perl class package name from a node type string.
  @PerlCDef:
        if ($nodeType eq 'unparsed') {
          $packageName = <ClassName::ManakaiPerlUnparsedCode>;
        } elsif ($nodeType eq 'bare') {
          $packageName = <ClassName::ManakaiPerlBare>;
        } elsif ($nodeType eq 'atom') {
          $packageName = <ClassName::ManakaiPerlAtom>;
        } elsif ($nodeType eq 'variable') {
          $packageName = <ClassName::ManakaiPerlVariable>;
        } elsif ($nodeType eq 'inunparsed') {
          $packageName = <ClassName::ManakaiPerlInlineUnparsedCode>;
        } elsif ($nodeType eq 'incontainer') {
          $packageName = <ClassName::ManakaiPerlInlineContainer>;
        } elsif ($nodeType eq 'statement') {
          $packageName = <ClassName::ManakaiPerlStatement>;
        } elsif ($nodeType eq 'assign') {
          $packageName = <ClassName::ManakaiPerlAssignment>;
        } elsif ($nodeType eq 'string') {
          $packageName = <ClassName::ManakaiPerlStringLiteral>;
        } elsif ($nodeType eq 'blockcontainer') {
          $packageName = <ClassName::ManakaiPerlBlockContainer>;
        } elsif ($nodeType eq 'block') {
          $packageName = <ClassName::ManakaiPerlBlock>;
        } elsif ($nodeType eq 'if') {
          $packageName = <ClassName::ManakaiPerlIf>;
        } elsif ($nodeType eq 'sub') {
          $packageName = <ClassName::ManakaiPerlSub>;
        } elsif ($nodeType eq 'package') {
          $packageName = <ClassName::ManakaiPerlPackageScope>;
        } elsif ($nodeType eq 'file') {
          $packageName = <ClassName::ManakaiPerlFile>;
        } else {
          __ASSERT{DISPerl:invariant::
            msg => {qq[Node type: "$nodeType" ].
                    qq[(ref: "@{[ref $object]}")]},
          }__;
        }


PropDef:
  @QName: nodeType
  @enDesc:
    Node type. 

IFClsDef:
  @IFQName: PerlFile
  @ClsQName: ManakaiPerlFile

  @IFISA: PerlCode

  @IFISA: PerlCodeStatements
  @ClsISA: ManakaiPerlStatementContainer

  @enDesc:
    Perl source code files.

  @IntMethod:
    @@Name:newObject
    @@ManakaiDOM:isStatic:1
    @@Description:
      @@@lang:en
      @@@@:
        Creates a new instance object for <Class::ManakaiPerlFile>. 
    @@Return:
      @@@Type:
        ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl
      @@@Description:
        @@@@lang:en
        @@@@@:
          The newly created node object.
      @@@PerlDef:
        @@@@@:
          my $node = $r = <ClassM::ManakaiDOM:ManakaiDOMNodeObject
                                        ::ManakaiDOM:Perl.new>;
          push @{$node->{<Q::TreeCore:subnode>}}, <H::pc:childNodes>;
          $node->{<H::pc:childNodes>} = [];
          $node->{<H::pc:sourceFile>} = '';
          $node->{<H::pc:sourceModule>} = '';
          $node->{<H::pc:sourceFor>} = '';
          $node->{<H::pc:currentPackage>} = 'main';
          $node->{<H::pc:currentChunk>} = 0;
          $node->{<H::pc:nodeType>} = 'file';
        @@@@ImplNote:
          @@@@@lang:en
          @@@@@@:
            Properties: <Q::pc:sourceFile>,
               <Q::pc:sourceModule>, <Q::pc:sourceFor>, <Q::childNodes>, 
               <Q::pc:currentPackage>, <Q::pc:currentChunk>,
               <Q::pc:nodeType>, <Q::pc:useModuleName>,
               <Q::pc:useCharClassName>, 
               <Q::pc:requireResourceURI>, <Q::pc:requireModuleName>.

  @Method:
    @@Name: appendNewPackage
    @@enDesc:
      Appends a new package scope block. 
    @@Param:
      @@@Name: packageName
      @@@Type:
        Perl:package-name::ManakaiDOM:all
      @@@enDesc:
        The fully-qualified name of the package to create. 
    @@Return:
      @@@Type: PerlPackage
      @@@caType: ManakaiPerlPackageScope
      @@@enDesc:
        The newly created package scope object. 
      @@@PerlDef:
        $r = <ClassM::ManakaiPerlPackageScope.newObject>;
        $r->{<H::pc:packageName>} = $packageName;
        $self->{<H::mn:node>}
             -><M::ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl
                            .importTree> ($r);
        push @{$self->{<H::mn:node>}->{<H::pc:childNodes>}}, $r;
        $r->{<H::pc:parent>} = $self->{<H::mn:node>};
        __CODE{ManakaiNode:getNewReference::
                 $object => $r, $ref => $r,
                 $class => {<ClassName::ManakaiPerlPackageScope>}}__;

  @Method:
    @@Name: appendPackage
    @@enDesc:
      Appends a Perl package scope object.
    @@Param:
      @@@Name: codeArg
      @@@Type: PerlPackage
      @@@caType: ManakaiPerlPackageScope
      @@@enDesc:
        The package to append.
    @@Return:
      @@@RaiseException:
        @@@@@:IN_USE_NODE_ERR
        @@@@enDesc:
          An attempt is made to set a subroutine that is 
          already used elsewhere. 
      @@@PerlDef:
        my $packobj = $codeArg->{<H::mn:node>};
        if ($packobj->{<H::pc:parent>}) {
          __EXCEPTION{IN_USE_NODE_ERR::
            pc:childNode => {$codeArg},
            MDOMX:param-name => 'codeArg',
          }__;
        }
        $self->{<H::mn:node>}
             -><M::ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl
                            .importTree> ($packobj);
        push @{$self->{<H::mn:node>}->{<H::pc:childNodes>}}, $packobj;
        $packobj->{<H::pc:parent>} = $self->{<H::mn:node>};

  @Method:
    @@Name: getFirstPackage
    @@enDesc:
      Gets the first package scope block of a name. 
    @@Param:
      @@@Name: packageName
      @@@@Type:
        Perl:package-name::ManakaiDOM:all
      @@@@enDesc:
        The fully-qualified name of the package to get. 
    @@NamedParam:
      @@@Name: makeNewPackage
      @@@Type:
        DOMMain:boolean::ManakaiDOM:all
      @@@enDesc:
        Whether a new package scope object should be created if 
        no package of <P::packageName> found. 
      @@@TrueCase:
        @@@@enDesc:
          Makes a new object if not found. 
      @@@FalseCase:
        @@@@enDesc:
          Don't make a new object. 
    @@Return:
      @@@Type: PerlPackage
      @@@caType: ManakaiPerlPackageScope
      @@@enDesc:
        The first package scope object whose name is equal to 
        <P::packageName>.
      @@@nullCase:
        @@@@enDesc:
          There is no <P::packageName> package object and 
          the <P::makeNewPackage> parameter is set to <DOM::false>. 
      @@@PerlDef:
        for my $cn (@{$self->{<H::mn:node>}->{<H::pc:childNodes>}}) {
          if ($cn->{<H::pc:nodeType>} eq 'package' and
              $cn->{<H::pc:packageName>} eq $packageName) {
            $r = $cn;
            last;
          }
        }
        if ($r) {
          __CODE{ManakaiNode:getNewReference::
                   $object => $r, $ref => $r,
                   $class => {<ClassName::ManakaiPerlPackageScope>}}__;
        } elsif ($makeNewPackage) {
          __DEEP{
            $r = $self-><M::ManakaiPerlFile.appendNewPackage> ($packageName);
          }__;
        }

  @Method:
    @@Name: getLastPackage
    @@enDesc:
      Gets the last package scope block of a name. 
    @@Param:
      @@@Name: packageName
      @@@@Type:
        Perl:package-name::ManakaiDOM:all
      @@@@enDesc:
        The fully-qualified name of the package to get. 
    @@NamedParam:
      @@@Name: makeNewPackage
      @@@Type:
        DOMMain:boolean::ManakaiDOM:all
      @@@enDesc:
        Whether a new package scope object should be created if 
        no package of <P::packageName> found. 
      @@@TrueCase:
        @@@@enDesc:
          Makes a new object if not found. 
      @@@FalseCase:
        @@@@enDesc:
          Don't make a new object. 
    @@Return:
      @@@Type: PerlPackage
      @@@caType: ManakaiPerlPackageScope
      @@@enDesc:
        The last package scope object whose name is equal to 
        <P::packageName>.
      @@@nullCase:
        @@@@enDesc:
          There is no <P::packageName> package object and 
          the <P::makeNewPackage> parameter is set to <DOM::false>. 
      @@@PerlDef:
        for my $cn (reverse @{$self->{<H::mn:node>}
                                   ->{<H::pc:childNodes>}}) {
          if ($cn->{<H::pc:nodeType>} eq 'package' and
              $cn->{<H::pc:packageName>} eq $packageName) {
            $r = $cn;
            last;
          }
        }
        if ($r) {
          __CODE{ManakaiNode:getNewReference::
                   $object => $r, $ref => $r,
                   $class => {<ClassName::ManakaiPerlPackageScope>}}__;
        } elsif ($makeNewPackage) {
          __DEEP{
            $r = $self-><M::ManakaiPerlFile.appendNewPackage> ($packageName);
          }__;
        }

  @Attr:
    @@Name: sourceFile
    @@enDesc:
      The file name of the source file from which this 
      Perl code is primary generated. 
    @@Get:
      @@@Type:
        DISLang:String::ManakaiDOM:all
      @@@disDef:
        @@@@GetProp: sourceFile
    @@Set:
      @@@Type:
        DISLang:String::ManakaiDOM:all
      @@@disDef:
        @@@@SetProp: sourceFile

  @Attr:
    @@Name: sourceModule
    @@enDesc:
      The name URI reference of the source module that this package defines.
    @@Get:
      @@@Type:
        DISLang:String::ManakaiDOM:all
      @@@disDef:
        @@@@GetProp: sourceModule
    @@Set:
      @@@Type:
        DISLang:String::ManakaiDOM:all
      @@@disDef:
        @@@@SetProp: sourceModule

  @Attr:
    @@Name: sourceFor
    @@enDesc:
      The URI reference of the source module <QUOTE::for> for which this 
      package is. 
    @@Get:
      @@@Type:
        DISLang:String::ManakaiDOM:all
      @@@disDef:
        @@@@GetProp: sourceFor
    @@Set:
      @@@Type:
        DISLang:String::ManakaiDOM:all
      @@@disDef:
        @@@@SetProp: sourceFor

  @ToStringMethod:
    @@Return:
      @@@Type:
        DISLang:String::ManakaiDOM:all
      @@@enDesc:
        The Perl code generated. 
      @@@PerlDef:
        __DEEP{
          my $node = $self->{<H::mn:node>};
          ## -- Header
          $r = qq<#!/usr/bin/perl \n>;
          $r .= <ClassM::ManakaiPerlCodeImplementation.perlComment>
                  (q<This file is automatically generated>);
          $r .= <ClassM::ManakaiPerlCodeImplementation.perlComment>
                 (q<	at >.<ClassM::ManakaiPerlCodeImplementation
                                           .rfc3339DateTime> (time).q<,>);
          $r .= <ClassM::ManakaiPerlCodeImplementation.perlComment>
                  (q<	from file ">.$node->{<H::pc:sourceFile>}.q<",>);
          $r .= <ClassM::ManakaiPerlCodeImplementation.perlComment>
                  (q[	module <].$node->{<H::pc:sourceModule>}.q[>,]);
          $r .= <ClassM::ManakaiPerlCodeImplementation.perlComment>
                  (q[	for <].$node->{<H::pc:sourceFor>}.q[>.]);
          $r .= <ClassM::ManakaiPerlCodeImplementation.perlComment>
                  (q<Don't edit by hand!>);
          $r .= qq<use strict;\n>;
          $self-><AS::ManakaiPerlFile.currentPackage> ('main');
          $self-><AS::ManakaiPerlFile.currentChunkNumber> (0);

          ## -- Requires
          my $req = $self-><M::ManakaiPerlCodeFragment
                              .getRequirePerlModuleNameList>;
          for my $pack (@$req) {
            $r .= qq<require $pack;\n>;
          }

          ## -- Packages and global objects
          my $pack = {};
          for my $cno (@{$node->{<H::pc:childNodes>}}) {
            my $cn = <ClassM::ManakaiPerlCodeFragment.getNodeReference> ($cno);
            $r .= $cn->stringify;
            if ($cno->{<H::pc:nodeType>} eq 'package') {
              for my $ipack (keys %{$cno->{<H::dis:Implement>}}) {
                $pack->{$ipack} ||= true; # not defined
              }
              $pack->{$cno->{<H::pc:packageName>}} = []; # defined
            }
          }

          ## -- Enables interface packages
          my @packs = map {'$' . $_ . '::'}
                      grep {not ref $pack->{$_} and $pack->{$_}}
                      keys %$pack;
          $r .= q<for (>. join (', ', @packs) . qq<){}\n> if @packs;

          ## -- Footer
          $r .= <ClassM::ManakaiPerlCodeImplementation.perlComment>
                  (q[License: <].$node->{<H::dis:License>}.qq[>\n]);
          $r .= qq<1;\n>;
        }__;

  @Attr:
    @@Name: currentPackage
    @@enDesc:
      The current Perl package (used in stringify method).
    @@Type:
      Perl:package-name::ManakaiDOM:all
    @@Get:
      @@@disDef:
        @@@@GetProp: currentPackage
    @@Set:
      @@@disDef:
        @@@@SetProp: currentPackage

  @Attr:
    @@Name: currentChunkNumber
    @@enDesc:
      The current code chunk number (used in stringify method). 
    @@Type:
      DOMMain:unsigned-long::ManakaiDOM:all
    @@Get:
      @@@disDef:
        @@@@GetProp: currentChunk
    @@Set:
      @@@disDef:
        @@@@SetProp: currentChunk

  @Method:
    @@Name: getNextChunkNumber
    @@enDesc:
      Increments the current chunk number of this file 
      and returns it. 
    @@Return:
      @@@Type:
        DOMMain:unsigned-long::ManakaiDOM:all
      @@@enDesc:
        The next chunk number.
      @@@PerlDef:
        $r = ++$self->{<H::mn:node>}->{<H::pc:currentChunk>};
  
  @Attr:
    @@Name: licenseURI
    @@enDesc:
      The license term URI reference for this code. 
    @@Type:
      DISLang:String::ManakaiDOM:all
    @@Get:
      @@@disDef:
        @@@@GetProp: 
          dis:License
    @@Set:
      @@@disDef:
        @@@@SetProp:
          dis:License
##PerlFile

PropDef:
  @QName: export
  @enDesc:
    The list of exported members.

PropDef:
  @QName: requireModuleName
  @enDesc:
    The list of <Perl::require>d Perl module names

PropDef:
  @QName: sourceModule
  @enDesc:
    The soruce module name URI reference. 

PropDef:
  @QName: sourceFor
  @enDesc:
    The source module <QUOTE::for> URI reference. 

PropDef:
  @QName: currentPackage
  @enDesc:
    The current Perl package name (used for stringify).

PropDef:
  @QName: currentChunk
  @enDesc:
    The current code chunk (used for stringify). 

IFClsDef:
  @IFQName: PerlPackage
  @ClsQName: ManakaiPerlPackageScope

  @IFISA: PerlCode

  @IFISA: PerlCodeStatements
  @ClsISA: ManakaiPerlStatementContainer

  @enDesc:
    A Perl lexical lines for which a <Perl::package> declaration
    in effect. 

  @Attr:
    @@Name: packageName
    @@Type:
      Perl:package-name::ManakaiDOM:all
    @@enDesc:
      The fully-qualified package name. 
    @@Get: 
      @@@disDef:
        @@@@GetProp: packageName

  @IntMethod:
    @@ForCheck: ManakaiDOM|ForClass
    @@Name:newObject
    @@ManakaiDOM:isStatic:1
    @@Description:
      @@@lang:en
      @@@@:
        Creates a new instance object for <Class::ManakaiPerlPackageScope>. 
    @@Return:
      @@@Type:
        ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl
      @@@Description:
        @@@@lang:en
        @@@@@:
          The newly created node object.
      @@@PerlDef:
        @@@@@:
          my $node = $r = <ClassM::ManakaiDOM:ManakaiDOMNodeObject
                                        ::ManakaiDOM:Perl.new>;
          push @{$node->{<Q::TreeCore:subnode>}}, <H::pc:sub>,
                                                 <H::dis2pm:operator>,
                                                 <H::pc:childNodes>;
          push @{$node->{<Q::TreeCore:origin>}}, <H::pc:parent>;
          $node->{<H::pc:sub>} = {};
          $node->{<H::dis2pm:operator>} = {};
          $node->{<H::dis:ISA>} = [];
          $node->{<H::dis:Implement>} = {};
          $node->{<H::pc:nodeType>} = 'package';
          $node->{<H::pc:childNodes>} = [];
        @@@@ImplNote:
          @@@@@lang:en
          @@@@@@:
            Properties: <Q::pc:sub>, <Q::dis2pm:operator>,
              <Q::dis:ISA>, <Q::dis:Implement>,
              <Q::pc:nodeType>, <Q::pc:useModuleName>,
              <Q::pc:useCharClassName>,  
              <Q::pc:requireResourceURI>, <Q::pc:childNodes>,
              <Q::pc:export>, <Q::pc:requireModuleName>.

  @Method:
    @@Name: getSub
    @@enDesc:
      Gets a subroutine. 
    @@Param:
      @@@Name: subName
      @@@Type:
        DISPerl:SubName::ManakaiDOM:all
      @@@enDesc:
        The name of subroutine to get. 
    @@NamedParam:
      @@@Name: makeNewNode
      @@@Type:
        DOMMain:boolean::ManakaiDOM:all
      @@@enDesc:
        Whether a new subroutine object should be created, 
        if it is not exist, or not. 
    @@Return:
      @@@Type: PerlSub
      @@@caType: ManakaiPerlSub
      @@@enDesc:
        The subroutine object. 
      @@@nullCase:
        @@@@enDesc:
          Either the specified subroutine is not found and 
          the <P::makeNewNode> parameter is set to <DOM::false> or
          the subroutine is defined as an alias. 
      @@@PerlDef:
        if ($self->{<H::mn:node>}->{<H::pc:sub>}->{$subName}) {
          $r = ref $self->{<H::mn:node>}->{<H::pc:sub>}->{$subName}
             ? $self->{<H::mn:node>}->{<H::pc:sub>}->{$subName} : null;
        } elsif ($makeNewNode) {
          $r = $self->{<H::mn:node>}->{<H::pc:sub>}->{$subName}
             = <ClassM::ManakaiPerlSub.newObject>;
          $self->{<H::mn:node>}
               -><M::ManakaiDOM:ManakaiDOMNodeObject
                   ::ManakaiDOM:Perl.importTree> ($r);
          $r->{<H::pc:parent>} = $self->{<H::mn:node>};
          $r->{<H::pc:localName>} = $subName;
        }
        if ($r) {
          __CODE{ManakaiNode:getNewReference::
                   $object => $r, $ref => $r,
                   $class => {<ClassName::ManakaiPerlSub>}}__;
        }

  @Method:
    @@Name: setSub
    @@enDesc:
      Sets a subrotine. 
    @@Param:
      @@@Name: subName
      @@@Type:
        DISLang:String::ManakaiDOM:all
      @@@enDesc:
        The name of the subroutine. 
        \
        {NOTE:: The <P::subName> value must be equal to the 
                <A::ManakaiPerlSub.localName> of the <P::subArg>.

        }
    @@Param:
      @@@Name: subArg
      @@@Type: PerlSub
      @@@caType: ManakaiPerlSub
      @@@enDesc:
        The subroutine object.
    @@Return:
      @@@RaiseException:
        @@@@@:IN_USE_NODE_ERR
        @@@@enDesc:
          An attempt is made to set a subroutine that is 
          already used elsewhere. 
      @@@PerlDef:
        my $ops = $self->{<H::mn:node>}->{<H::pc:sub>};
        if (ref $ops->{$subName}) {
          CORE::delete $ops->{<H::pc:parent>};
          $ops->{$subName}
              -><M::ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl.orphanate>;
        }
        if ($subArg->{<H::mn:node>}->{<H::pc:parent>}) {
          __EXCEPTION{IN_USE_NODE_ERR::
            pc:childNode => {$subArg},
          }__;
        }
        $self->{<H::mn:node>}-><M::MNodeObject.importTree>
                                          ($subArg->{<H::mn:node>});
        $ops->{$subName} = $subArg->{<H::mn:node>};
        $subArg->{<H::mn:node>}->{<H::pc:parent>}
                         = $self->{<H::mn:node>};

  @Method:
    @@Name: getSubAliasName
    @@enDesc:
      Gets the real name of a subroutine. 
    @@Param:
      @@@Name: subName
      @@@Type:
        DISLang:String::ManakaiDOM:all
      @@@enDesc:
        The name of the alias subroutine. 
    @@Return:
      @@@Type: 
        DISLang:String::ManakaiDOM:all
      @@@enDesc:
        The real name. 
      @@@nullCase:
        @@@@enDesc:
          The specified name is used. 
      @@@InCase:
        @@@@Value:\#CODE
        @@@@ContentType: DISCore|String
        @@@@enDesc:
          The specified name is not an alias. 
      @@@PerlDef:
        if ($self->{<H::mn:node>}->{<H::pc:sub>}->{$subName}) {
          $r = ref $self->{<H::mn:node>}
                        ->{<H::pc:sub>}->{$subName}
             ? q<#CODE> : $self->{<H::mn:node>}
                           ->{<H::pc:sub>}->{$subName};
        }

  @Method:
    @@Name: setSubAliasName
    @@enDesc:
      Sets a subroutine name as an alias of another subroutine. 
    @@Param:
      @@@Name: aliasName
      @@@Type:
        DISLang:String::ManakaiDOM:all
      @@@enDesc:
        The alias name. 
    @@Param:
      @@@Name: realName
      @@@Type:
        DISLang:String::ManakaiDOM:all
      @@@enDesc:
        The real name. 
    @@Return:
      @@@UnknownOperatorException:
      @@@PerlDef:
        my $ops = $self->{<H::mn:node>}->{<H::pc:sub>};
        if (ref $ops->{$aliasName}) {
          CORE::delete $ops->{<H::pc:parent>};
          $ops->{$aliasName}
              -><M::ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl.orphanate>;
        }
        $ops->{$aliasName} = $realName;

  @Method:
    @@Name: getOverloadSub
    @@enDesc:
      Gets an overloading subroutine. 
    @@Param:
      @@@Name: opName
      @@@Type:
        DISLang:String::ManakaiDOM:all
      @@@enDesc:
        The name of the overloaded operator. 
    @@NamedParam:
      @@@Name: makeNewNode
      @@@Type:
        DOMMain:boolean::ManakaiDOM:all
      @@@enDesc:
        Whether a new subroutine object should be created, 
        if it is not exist, or not. 
    @@Return:
      @@@Type: PerlSub
      @@@caType: ManakaiPerlSub
      @@@enDesc:
        The subroutine object. 
      @@@nullCase:
        @@@@enDesc:
          Either the specified subroutine is not found and 
          the <P::makeNewNode> parameter is set to <DOM::false> or
          the specified operator is overloaded by specifying method name. 
      @@@UnknownOperatorException:
      @@@PerlDef:
        unless (<Code::operatorNameList>->{$opName}) {
          __EXCEPTION{UNSUPPORTED_OPERATOR_ERR::
            pc:operator => {$opName},
          }__;
        }
        if ($self->{<H::mn:node>}->{<H::dis2pm:operator>}->{$opName}) {
          $r = ref $self->{<H::mn:node>}
                        ->{<H::dis2pm:operator>}->{$opName}
             ? $self->{<H::mn:node>}
                        ->{<H::dis2pm:operator>}->{$opName} : null;
        } elsif ($makeNewNode) {
          $r = $self->{<H::mn:node>}->{<H::dis2pm:operator>}->{$opName}
             = <ClassM::ManakaiPerlSub.newObject>;
          $self->{<H::mn:node>}
               -><M::ManakaiDOM:ManakaiDOMNodeObject
                   ::ManakaiDOM:Perl.importTree> ($r);
          $r->{<H::pc:parent>} = $self->{<H::mn:node>};
        }
        if ($r) {
          __CODE{ManakaiNode:getNewReference::
                   $object => $r, $ref => $r,
                   $class => {<ClassName::ManakaiPerlSub>}}__;
        }

  @Method:
    @@Name: setOverloadSub
    @@enDesc:
      Sets an overloading subrotine. 
    @@Param:
      @@@Name: opName
      @@@Type:
        DISLang:String::ManakaiDOM:all
      @@@enDesc:
        The name of the opeartor to overload. 
    @@Param:
      @@@Name: subArg
      @@@Type: PerlSub
      @@@caType: ManakaiPerlSub
      @@@enDesc:
        The subroutine object.
    @@Return:
      @@@UnknownOperatorException:
      @@@RaiseException:
        @@@@@:IN_USE_NODE_ERR
        @@@@enDesc:
          An attempt is made to set a subroutine that is 
          already used elsewhere. 
      @@@PerlDef:
        unless (<Code::operatorNameList>->{$opName}) {
          __EXCEPTION{UNSUPPORTED_OPERATOR_ERR::
            pc:operator => {$opName},
          }__;
        }
        my $ops = $self->{<H::mn:node>}->{<H::dis2pm:operator>};
        if (ref $ops->{$opName}) {
          CORE::delete $ops->{<H::pc:parent>};
          $ops->{$opName}
              -><M::ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl.orphanate>;
        }
        if ($subArg->{<H::mn:node>}->{<H::pc:parent>}) {
          __EXCEPTION{IN_USE_NODE_ERR::
            pc:parentNode => {$self},
            pc:childNode => {$subArg},
          }__;
        }
        $self->{<H::mn:node>}-><M::MNodeObject.importTree>
                                          ($subArg->{<H::mn:node>});
        $ops->{$opName} = $subArg->{<H::mn:node>};
        $subArg->{<H::mn:node>}->{<H::pc:parent>}
                         = $self->{<H::mn:node>};


  @Method:
    @@Name: getOverloadMethodName
    @@enDesc:
      Gets an overloading method name. 
    @@Param:
      @@@Name: opName
      @@@Type:
        DISLang:String::ManakaiDOM:all
      @@@enDesc:
        The name of the overloaded operator. 
    @@Return:
      @@@Type: 
        DISLang:String::ManakaiDOM:all
      @@@enDesc:
        The method name. 
      @@@nullCase:
        @@@@enDesc:
          The specified operator is not overloaded.
      @@@InCase:
        @@@@Value:\#CODE
        @@@@enDesc:
          The operator is overloaded by an anonymous subroutine. 
      @@@PerlDef:
        if ($self->{<H::mn:node>}->{<H::dis2pm:operator>}->{$opName}) {
          $r = ref $self->{<H::mn:node>}
                        ->{<H::dis2pm:operator>}->{$opName}
             ? q<#CODE> : $self->{<H::mn:node>}
                           ->{<H::dis2pm:operator>}->{$opName};
        }

  @Method:
    @@Name: setOverloadMethodName
    @@enDesc:
      Sets an overloading method name. 
    @@Param:
      @@@Name: opName
      @@@Type:
        DISLang:String::ManakaiDOM:all
      @@@enDesc:
        The name of the overloaded operator. 
    @@Param:
      @@@Name: methodName
      @@@Type:
        DISLang:String::ManakaiDOM:all
      @@@enDesc:
        The name of the method by which overloads an operator. 
        \
        {NOTE:: The method may or may not belong to this package. 
        \
        }
    @@Return:
      @@@UnknownOperatorException:
      @@@PerlDef:
        unless (<Code::operatorNameList>->{$opName}) {
          __EXCEPTION{UNSUPPORTED_OPERATOR_ERR::
            pc:operator => {$opName},
          }__;
        }
        my $ops = $self->{<H::mn:node>}->{<H::dis2pm:operator>};
        if (ref $ops->{$opName}) {
          CORE::delete $ops->{<H::pc:parent>};
          $ops->{$opName}
              -><M::ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl.orphanate>;
        }
        $ops->{$opName} = $methodName;

  @Method:
    @@Name: addISAPackage
    @@enDesc:
      Adds a class package that this class inherits. 
    @@Param:
      @@@Name: packageName
      @@@Type:
        Perl:package-name::ManakaiDOM:all
      @@@enDesc:
        The name of package to add. 
    @@Return:
      @@@PerlDef:
        push @{$self->{<H::mn:node>}->{<H::dis:ISA>}}, $packageName;

  @Method:
    @@Name: addImplementPackage
    @@enDesc:
      Adds a interface package that this class implements. 
    @@Param:
      @@@Name: packageName
      @@@Type:
        Perl:package-name::ManakaiDOM:all
      @@@enDesc:
        The name of package to add.
    @@Return:
      @@@PerlDef:
        $self->{<H::mn:node>}->{<H::dis:Implement>}->{$packageName} = true;

  @ToStringMethod:
    @@Return:
      @@@Type:
        DISLang:String::ManakaiDOM:all
      @@@enDesc:
        Perl code. 
      @@@PerlDef:
        my $file = $self-><AG::ManakaiPerlCodeFragment.parentNode>;
        my $node = $self->{<H::mn:node>};

        ## Package name
        my $pn = $node->{<H::pc:packageName>};
        $r .= q<package > . $pn . ";\n";

        ## Package version
        __DEEP{
          $file-><AS::ManakaiPerlFile.currentPackage> ($pn);
          $r .= 'our $VERSION = '.
                <ClassM::ManakaiPerlCodeImplementation.versionDateTime> (time).
                ";\n";
        }__;

        ## Inheritance
        my @isa = (@{$node->{<H::dis:ISA>}},
                   sort keys %{$node->{<H::dis:Implement>}});
        if (@isa) {
          $r .= 'push our @ISA, ' .
                <ClassM::ManakaiPerlCodeImplementation.perlList> (\@isa) .
                ";\n";
        }

        ## Uses
        my $use = $self-><M::ManakaiPerlCodeFragment.getUsePerlModuleNameList>;
        for my $pack (@$use) {
          $r .= 'use ' . $pack . ";\n";
        }

        my $cls = $self-><M::ManakaiPerlCodeFragment.getUseCharClassNameList>;
        for my $pack (keys %$cls) {
          $r .= 'use ' . $pack . ' ' .
                <ClassM::ManakaiPerlCodeImplementation.perlList>
                   ([grep {$cls->{$pack}->{$_}} keys %{$cls->{$pack}}]) . ";\n";
        }

        ## Package-scope objects
        for my $cno (@{$node->{<H::pc:childNodes>}}) {
          my $cn = <ClassM::ManakaiPerlCodeFragment.getNodeReference> ($cno);
          $r .= $cn->stringify;
        }

        ## Subroutines
        for my $cnk (keys %{$node->{<H::pc:sub>}}) {
          my $cno = $node->{<H::pc:sub>}->{$cnk};
          if (ref $cno) {
            my $cn;
            __CODE{ManakaiNode:getWeakReference::
                     $object => $cno, $ref => $cn,
                     $class => {<ClassName::ManakaiPerlSub>}}__;
            $r .= $cn->stringify;
          } else {
            $r .= qq<*$cnk = \\&$cno;\n>;
          }
        }

        ## Operators
        my $op = '';
        for my $cnk (keys %{$node->{<H::dis2pm:operator>}}) {
          my $cno = $node->{<H::dis2pm:operator>}->{$cnk};
          if (ref $cno) {
            my $cn;
            __CODE{ManakaiNode:getWeakReference::
                     $object => $cno, $ref => $cn,
                     $class => {<ClassName::ManakaiPerlSub>}}__;
            $op .= <ClassM::ManakaiPerlCodeImplementation.perlLiteral> ($cnk)
                .  ' => ' . $cn->stringify . ', ';
          } elsif (defined $cno) {
            $op .= <ClassM::ManakaiPerlCodeImplementation.perlList>
                                                        ([$cnk => $cno]) . ', ';
          }
        }
        $r .= 'use overload bool => sub () {1}, ' .
              $op . qq[fallback => 1;\n] if $op;


        ## -- Exports
        if (keys %{$node->{<H::pc:export>} || {}}) {
          $r .= q[our %EXPORT_TAG = (] . 
                  <ClassM::ManakaiPerlCodeImplementation.perlList>
                     ([map {$_ => [keys %{$node->{<H::pc:export>}->{$_}}]}
                       grep {$_} keys %{$node->{<H::pc:export>}}]) . qq[);\n];
          $r .= q[our @EXPORT_OK = (] .
                  <ClassM::ManakaiPerlCodeImplementation.perlList>
                     ([map {keys %{$node->{<H::pc:export>}->{$_}}}
                       keys %{$node->{<H::pc:export>}}]) . qq[);\n];
          $r .= q[use Exporter; push our @ISA, 'Exporter';] . qq[\n];
        }

  @Method:
    @@Name: addExport
    @@enDesc:
      Adds a name to the list of exported items (<Perl::@EXPORT_OK>).
    @@Param:
      @@@Name: exportTag
      @@@Type:
        lang:Perl::ManakaiDOM:all
      @@@enDesc:
        The name of the tag (without <CHAR::COLON> prefix). 
        The <P::exportName> is added both to <Perl::@EXPORT_OK>
        and <Perl::$EXPORT_OK{<P::exportTag>}>.
      @@@nullCase:
        @@@@enDesc:
          The <P::exportName> is added only to the <Perl::@EXPORT_OK>.
    @@Param:
      @@@Name: exportName
      @@@Type:
        lang:Perl::ManakaiDOM:all
      @@@enDesc:
        The name to be exported.
    @@Return:
      @@@PerlDef:
        $self->{<H::mn:node>}->{<H::pc:export>}
             ->{defined $exportTag ? $exportTag : ''}->{$exportName} = true;
##PerlPackageScope

PropDef:
  @QName:
    dis2pm:operator
  @enDesc:
    Overloaded operators.

ElementTypeBinding:
  @Name: UnknownOperatorException
  @ElementType:
    ManakaiDOM:raises
  @ShadowContent:
    @@@:UNSUPPORTED_OPERATOR_ERR
    @@enDesc:
      An attempt is made to overload an unknown operator. 

XParamDef:
  @QName:
    pc:operator
  @enDesc:
    An operator to overload. 

ResourceDef:
  @For: ManakaiDOM|Perl
  @QName: operatorNameList
  @enDesc:
    The list of valid operators for <PerlModule::operator> pragma. 
  @rdf:type:
    dis2pm:InlineCode
  @PerlCDef:
    {qw[
                    +  1 -  1 *  1 /  1 %  1 **  1 <<  1 >>  1 x  1 .  1
                    += 1 -= 1 *= 1 /= 1 %= 1 **= 1 <<= 1 >>= 1 x= 1 .= 1
                    <  1 <= 1 >  1 >= 1 == 1 != 1 <=> 1
                    lt 1 le 1 gt 1 ge 1 eq 1 ne 1 cmp 1
                    & 1 | 1 ^ 1 neg 1 ! 1 ~ 1
                    ++ 1 -- 1 = 1
                    atan2 1 cos 1 sin 1 exp 1 abs 1 log 1 sqrt 1
                    bool 1 "" 1 0+ 1 ${} 1 @{} 1 %{} 1 &{} 1 *{} 1 <> 1
                    nomethod 1
    ]}

IFClsDef:
  @IFQName: PerlCodeStatements
  @ClsQName: ManakaiPerlStatementContainer

  @IFISA: PerlCodeUnits
  @ClsISA: ManakaiPerlAnyContainer
  @enDesc:
    A base class for node types that contains zero or more
    statements and/or blocks.

  @Attr:
    @@Name: sourceFile
    @@enDesc:
      The source file name of this fragment. 
    @@Type:
      DISLang:String::ManakaiDOM:all
    @@Get:
      @@@enDesc:
        Any string identifying the source. 
      @@@nullCase:
        @@@@enDesc: No source file name is set. 
      @@@disDef:
        @@@@GetProp: sourceFile
    @@Set:
      @@@nullCase:
        @@@@enDesc: No (or unknown) source file. 
      @@@disDef:
        @@@@SetProp: sourceFile

  @Attr:
    @@Name: sourceLine
    @@enDesc:
      Source file line number of the first line of this fragment. 
    @@Type:
      DOMMain:unsigned-long::ManakaiDOM:all
    @@Get:
      @@@disDef:
        @@@@GetProp: sourceLine
    @@Set:
      @@@disDef:
        @@@@SetProp: sourceLine

  @Attr:
    @@Name: currentSourceFile
    @@enDesc:
      The current source file name that is referred when 
      a code fragment is added. 
    @@Type:
      DISLang:String::ManakaiDOM:all
    @@Get:
      @@@nullCase:
        @@@@enDesc: No source file name is set. 
      @@@disDef:
        @@@@GetProp:currentSourceFile
    @@Set:
      @@@nullCase:
        @@@@enDesc: No (or unknown) source file. 
      @@@disDef:
        @@@@SetProp:currentSourceFile

  @Attr:
    @@Name: currentSourceLine
    @@enDesc:
      The current line number in source file that is referred when 
      a code fragment is added. 
    @@Type:
      DOMMain:unsigned-long::ManakaiDOM:all
    @@Get:
      @@@disDef:
        @@@@GetProp:currentSourceLine
    @@Set:
      @@@disDef:
        @@@@SetProp:currentSourceLine

  @Method:
    @@Name: appendCodeFragment
    @@enDesc:
      Appends a <Class::ManakaiPerlCodeFragment> object. 
    @@Param:
      @@@Name: codeArg
      @@@Type: PerlCode
      @@@caType: ManakaiPerlCodeFragment
      @@@enDesc:
        A code fragment object. 
    @@Return:
      @@@RaiseException:
        @@@@@:BAD_CHILD_ERR
        @@@@enDesc:
          An attempt is made to append a child
          that is not a <Class::ManakaiPerlUnparsedCode>.
      @@@RaiseException:
        @@@@@:IN_USE_NODE_ERR
        @@@@enDesc:
          An attempt is made to append a node that is 
          already used elsewhere. 
      @@@PerlDef:
        if ({
          unparsed => 1, if => 1, statement => 1, block => 1,
          blockcontainer => true,
          inunparsed => 1, variable => 1, bare => 1, atom => 1,
          incontainer => 1, string => 1, assign => 1,
        }->{$codeArg->{<H::mn:node>}->{<H::pc:nodeType>}}) {
          if ($codeArg->{<H::mn:node>}->{<H::pc:parent>}) {
            __EXCEPTION{IN_USE_NODE_ERR::
              pc:childNode => {$codeArg},
            }__;
          }
          $self->{<H::mn:node>}-><M::MNodeObject.importTree>
                                          ($codeArg->{<H::mn:node>});
          push @{$self->{<H::mn:node>}->{<H::pc:childNodes>}},
               $codeArg->{<H::mn:node>};
          $codeArg->{<H::mn:node>}->{<H::pc:parent>}
                                         = $self->{<H::mn:node>};
        } else {
          __EXCEPTION{BAD_CHILD_ERR::
            pc:parentNode => {$self},
            pc:childNode => {$codeArg},
          }__;
        }

  @Method:
    @@Name: appendCode
    @@enDesc:
      Appends an unparsed Perl code fragment. 
    @@Param:
      @@@Name: codeArg
      @@@Type: 
        lang:Perl::ManakaiDOM:all
      @@@enDesc:
        An unparsed Perl code fragment. 
    @@Return:
      @@@Type: PerlUnparsedCode
      @@@caType: ManakaiPerlUnparsedCode
      @@@enDesc:
        The newly created Perl code object. 
      @@@PerlDef:
        $r = <ClassM::ManakaiPerlUnparsedCode.newObject>;
        my $node = $self->{<H::mn:node>};
        $r->{<H::pc:sourceFile>} = $node->{<H::pc:currentSourceFile>};
        $r->{<H::pc:sourceLine>} = $node->{<H::pc:currentSourceLine>};
        $r->{<H::pc:code>} = $codeArg;
        $node->{<H::pc:currentSourceLine>} += ($codeArg =~ tr/\x0A/\x0A/);
        $node-><M::ManakaiDOM:ManakaiDOMNodeObject
                 ::ManakaiDOM:Perl.importTree> ($r);
        push @{$node->{<H::pc:childNodes>}}, $r;
        $r->{<H::pc:parent>} = $node;
        __CODE{ManakaiNode:getNewReference::
          $object => $r, $ref => $r,
          $class =>{<ClassName::ManakaiPerlUnparsedCode>},
        }__;

  @Method:
    @@Name: skipLines
    @@enDesc:
      Skips lines in a code. 
    @@Param:
      @@@Name: codeArg
      @@@Type: 
        lang:Perl::ManakaiDOM:all
      @@@enDesc:
        A code fragment, which is counted lines. 
    @@Return:
      @@@PerlDef:
        $self->{<H::mn:node>}->{<H::pc:currentSourceLine>}
                            += ($codeArg =~ tr/\x0A/\x0A/);

  @ImplNote:
    @@lang:en
    @@@:
      A <Class::ManakaiPerlStatementContainer> object must have
      a property:
        <Q::pc:childNodes>.

  @Attr:
    @@Name: label
    @@enDesc:
      Label for this block.
    @@Type:
      DISLang:String::ManakaiDOM:all
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          No label.
      @@@disDef:
        @@@@GetProp:label
    @@Set:
      @@@nullCase:
        @@@@enDesc:
          No label.
      @@@disDef:
        @@@@SetProp:label

  @Method:
    @@Name: appendBlock
    @@enDesc:
      Appends a Perl block code.
    @@Return:
      @@@Type: PerlBlock
      @@@caType: ManakaiPerlBlock
      @@@enDesc:
        The newly created Perl code object. 
      @@@PerlDef:
        $r = <ClassM::ManakaiPerlBlock.newObject>;
        my $node = $self->{<H::mn:node>};
        $node-><M::ManakaiDOM:ManakaiDOMNodeObject
                 ::ManakaiDOM:Perl.importTree> ($r);
        push @{$node->{<H::pc:childNodes>}}, $r;
        $r->{<H::pc:parent>} = $node;
        if (defined wantarray) {
          __CODE{ManakaiNode:getNewReference::
            $object => $r, $ref => $r,
            $class =>{<ClassName::ManakaiPerlBlock>},
          }__;
        }

  @Method:
    @@Name: appendStatement
    @@enDesc:
      Appends a Perl statement.
    @@Param:
      @@@Name: codeArg
      @@@Type:
        lang:Perl::ManakaiDOM:all
      @@@enDesc:
        A Perl statement without terminating <Perl::;>.
      @@@nullCase:
        @@@@enDesc:
          No initial content.
    @@Return:
      @@@Type: PerlStatement
      @@@caType: ManakaiPerlStatement
      @@@enDesc:
        The newly created Perl code object. 
      @@@PerlDef:
        $r = <ClassM::ManakaiPerlStatement.newObject>;
        my $node = $self->{<H::mn:node>};
        $node-><M::ManakaiDOM:ManakaiDOMNodeObject
                 ::ManakaiDOM:Perl.importTree> ($r);
        push @{$node->{<H::pc:childNodes>}}, $r;
        $r->{<H::pc:parent>} = $node;
        if (defined wantarray or defined $codeArg) {
          __CODE{ManakaiNode:getNewReference::
            $object => $r, $ref => $r,
            $class =>{<ClassName::ManakaiPerlStatement>},
          }__;
          if (defined $codeArg) {
            __DEEP{
              $r-><M::ManakaiPerlAnyContainer.appendBare> ($codeArg);
            }__;
          }
        }

  @Method:
    @@Name: appendNewIf
    @@enDesc:
      Appends a newly created <Class::ManakaiPerlIf> object. 
    @@Param:
      @@@Name: conditionArg
      @@@Type: PerlCode
      @@@caType: ManakaiPerlCodeFragment
      @@@enDesc:
        Conditoon code fragment object.
    @@Param:
      @@@Name: trueArg
      @@@Type: PerlCode
      @@@caType: ManakaiPerlCodeFragment
      @@@enDesc:
        A true code fragment object. 
      @@@nullCase:
        @@@@enDesc: No true code.
    @@Param:
      @@@Name: falseArg
      @@@Type: PerlCode
      @@@caType: ManakaiPerlCodeFragment
      @@@enDesc:
        A false code fragment object. 
      @@@nullCase:
        @@@@enDesc: No false code.
    @@Return:
      @@@RaiseException:
        @@@@@:BAD_CHILD_ERR
        @@@@enDesc:
          An attempt is made to append a child
          that is not valid type.
      @@@RaiseException:
        @@@@@:IN_USE_NODE_ERR
        @@@@enDesc:
          An attempt is made to append a node that is 
          already used elsewhere. 
      @@@PerlDef:
        for my $arg ([conditionArg => $conditionArg]) {
          if ({
            atom => 1, bare => 1, incontainer => 1, assign => true,
            inunparsed => 1, variable => 1, string => true,
          }->{$arg->[1]->{<H::mn:node>}->{<H::pc:nodeType>}}) {
            if ($arg->[1]->{<H::mn:node>}->{<H::pc:parent>}) {
              __EXCEPTION{IN_USE_NODE_ERR::
                pc:childNode => {$arg->[1]},
                MDOMX:param-name => {$arg->[0]},
              }__;
            }
          } else {
            __EXCEPTION{BAD_CHILD_ERR::
              pc:parentNode => {$self},
              pc:childNode => {$arg->[1]},
              MDOMX:param-name => {$arg->[0]},
            }__;
          }
        } # c

        for my $arg ([trueArg => $trueArg],
                     [falseArg => $falseArg]) {
          next unless $arg->[1];
          if ({
                blockcontainer => true,
              }->{$arg->[1]->{<H::mn:node>}->{<H::pc:nodeType>}}) {
            if ($arg->[1]->{<H::mn:node>}->{<H::pc:parent>}) {
              __EXCEPTION{IN_USE_NODE_ERR::
                pc:childNode => {$arg->[1]},
                MDOMX:param-name => {$arg->[0]},
              }__;
            }
          } else {
            __EXCEPTION{BAD_CHILD_ERR::
              pc:parentNode => {$self},
              pc:childNode => {$arg->[1]},
              MDOMX:param-name => {$arg->[0]},
            }__;
          }
        } # t/f

        my $assign = <ClassM::ManakaiPerlIf.newObject>;
        $assign->{<H::pc:condition>} = $conditionArg->{<H::mn:node>};
        $assign->{<H::pc:true>} = $trueArg->{<H::mn:node>} if $trueArg;
        $assign->{<H::pc:false>} = $falseArg->{<H::mn:node>} if $falseArg;
        $conditionArg->{<H::mn:node>}->{<H::pc:parent>} = $assign;
        $trueArg->{<H::mn:node>}->{<H::pc:parent>} = $assign if $trueArg;
        $falseArg->{<H::mn:node>}->{<H::pc:parent>} = $assign if $falseArg;
        $self->{<H::mn:node>}-><M::MNodeObject.importTree> ($assign);
        $assign->{<H::pc:parent>} = $self->{<H::mn:node>};
        push @{$self->{<H::mn:node>}->{<H::pc:childNodes>}}, $assign;
##PerlCodeStatements

IFClsDef:
  @IFQName: PerlSub
  @ClsQName: ManakaiPerlSub

  @IFISA: PerlCode

  @IFISA: PerlCodeStatements
  @ClsISA: ManakaiPerlStatementContainer

  @enDesc:
    Perl subroutines. 
  
  @IntMethod:
    @@ForCheck: ManakaiDOM|ForClass
    @@Name:newObject
    @@ManakaiDOM:isStatic:1
    @@Description:
      @@@lang:en
      @@@@:
        Creates a new instance object for <Class::ManakaiPerlSub>. 
    @@Return:
      @@@Type:
        ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl
      @@@Description:
        @@@@lang:en
        @@@@@:
          The newly created node object.
      @@@PerlDef:
        @@@@@:
          my $node = $r = <ClassM::ManakaiDOM:ManakaiDOMNodeObject
                                        ::ManakaiDOM:Perl.new>;
          push @{$node->{<Q::TreeCore:subnode>}}, <H::pc:childNodes>;
          push @{$node->{<Q::TreeCore:origin>}}, <H::pc:parent>;
          $node->{<H::pc:childNodes>} = [];
          $node->{<H::pc:sourceLine>} = 0;
          $node->{<H::pc:nodeType>} = 'sub';
        @@@@ImplNote:
          @@@@@lang:en
          @@@@@@:
            Optional properties: <Q::pc:localName>, <Q::pc:useCharClassName>, 
               <Q::pc:sourceFile>, <Q::pc:sourceLine>,
               <Q::pc:nodeType>, <Q::pc:useModuleName>, 
               <Q::pc:requireResourceURI>, <Q::pc:requireModuleName>,
               <Q::pc:prototype>.

  @IntCloneMethod:
    @@Return:
      @@@Type:
        ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl
      @@@PerlDef:
          my $node = $r = <ClassM::ManakaiDOM:ManakaiDOMNodeObject
                                        ::ManakaiDOM:Perl.new>;
          $node->{<H::pc:nodeType>} = 'sub';
          push @{$node->{<Q::TreeCore:origin>}}, <H::pc:parent>;
          push @{$node->{<Q::TreeCore:subnode>}}, <H::pc:childNodes>;
          for my $prop (<H::pc:sourceFile>, <H::pc:sourceLine>,
                        <H::pc:localName>, <H::pc:prototype>) {
            $node->{$prop} = $nodeObject->{$prop};
          }
          $node->{<H::pc:requireResourceURI>}
             = {%{$nodeObject->{<H::pc:requireResourceURI>} || {}}};
          $node->{<H::pc:useModuleName>}
             = {%{$nodeObject->{<H::pc:useModuleName>} || {}}};
          $node->{<H::pc:useCharClassName>}
             = {map {$_ => {%{$nodeObject->{<H::pc:useCharClassName>}->{$_}}}}
                keys %{$nodeObject->{<H::pc:useCharClassName>} || {}}};
          $node->{<H::pc:requireModuleName>}
             = {%{$nodeObject->{<H::pc:requireModuleName>} || {}}};
          $node->{<H::pc:childNodes>} = [];
          for my $cno (@{$nodeObject->{<H::pc:childNodes>}}) {
            my $pack;
            my $nt = $cno->{<H::pc:nodeType>};
            __CODE{pc:nodeTypeToPackageName::
                     $nodeType => $nt, $packageName => $pack, $object => $cno}__;
                                 ## NOTE: Method name written directly
            my $cno_clone = $pack->_make_clone_object ($cno);
            push @{$node->{<H::pc:childNodes>}}, $cno_clone;
            $cno_clone->{<H::pc:parent>} = $node;
            ## NOTE: Tree ID is not updated yet.
          }

  @Attr:
    @@Name: localName
    @@enDesc:
      The name of this subroutine. 
    @@Type:
      DISPerl:SubName::ManakaiDOM:all
    @@Get: 
      @@@nullCase:
        @@@@enDesc:
          This subroutine has no name. 
      @@@disDef:
        @@@@GetProp: localName
    @@Set:
      @@@enDesc:
        Sets the name of this subroutine. 
        \
        {NOTE:: Setting this attribute does not change the 
                name by which the subroutine is registerred to 
                the parent object.
        \
        }
      @@@nullCase:
        @@@@enDesc:
          This subroutine has no name. 
      @@@disDef:
        @@@@SetProp: localName

  @Attr:
    @@Name: prototype
    @@enDesc:
      The prototype of this subroutine. 
    @@Type:
      DISPerl:SubPrototype::ManakaiDOM:all
    @@Get:
      @@@disDef:
        @@@@GetProp: prototype
      @@@nullCase:
        @@@@enDesc:
          No prototype is set. 
    @@Set:
      @@@disDef:
        @@@@SetProp: prototype
      @@@nullCase:
        @@@@enDesc:
          No prototype declaration. 
  
  @ToStringMethod:
    @@Return:
      @@@Type:
        DISLang:String::ManakaiDOM:all
      @@@enDesc:
        Perl code. 
      @@@PerlDef:
        my $node = $self->{<H::mn:node>};
        $r = q<sub>;
        $r .= ' ' . $node->{<H::pc:localName>}
                if defined $node->{<H::pc:localName>};
        $r .= ' (' . $node->{<H::pc:prototype>} . ')'
                if defined $node->{<H::pc:prototype>};
        $r .= " {\n";
        for my $cno (@{$node->{<H::pc:childNodes>}}) {
          my $cn = <ClassM::ManakaiPerlCodeFragment.getNodeReference> ($cno);
          $r .= $cn->stringify;
        }
        $r .= "}\n";

  @NumValMethod:
    @@Return:
      @@@Type:
        DISIDL:AnyRealNumber::ManakaiDOM:all
      @@@PerlDef:
        my $cno = $self->{<H::mn:node>}->{<H::pc:childNodes>}->[-1];
        if ($cno) {
          my $cn = <ClassM::ManakaiPerlCodeFragment.getNodeReference> ($cno);
          $r = 0 + $cn;
        }
##PerlSub

XParamDef:
  @QName: parentNode
  @enDesc:
    Parent node. 

XParamDef:
  @QName: childNode
  @enDesc:
    Child node. 

IFClsDef:
  @IFQName: PerlUnparsedCode
  @ClsQName: ManakaiPerlUnparsedCode

  @IFISA: PerlCode
  @ClsISA: ManakaiPerlCodeFragment

  @enDesc:
    Unparsed Perl code fragments. 
  
  @IntMethod:
    @@ForCheck: ManakaiDOM|ForClass
    @@Name:newObject
    @@ManakaiDOM:isStatic:1
    @@Description:
      @@@lang:en
      @@@@:
        Creates a new instance object for <Class::ManakaiPerlUnparsedCode>. 
    @@Return:
      @@@Type:
        ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl
      @@@Description:
        @@@@lang:en
        @@@@@:
          The newly created node object.
      @@@PerlDef:
        @@@@@:
          my $node = $r = <ClassM::ManakaiDOM:ManakaiDOMNodeObject
                                        ::ManakaiDOM:Perl.new>;
          push @{$node->{<Q::TreeCore:origin>}}, <H::pc:parent>;
          $node->{<H::pc:code>} = '';
          $node->{<H::pc:nodeType>} = 'unparsed';
        @@@@ImplNote:
          @@@@@lang:en
          @@@@@@:
            Properties: <Q::pc:nodeType>, <Q::pc:code>,
                        <Q::pc:sourceFile>, <Q::pc:sourceLine>,
               <Q::pc:useModuleName>, <Q::pc:useCharClassName>,  
               <Q::pc:requireResourceURI>, <Q::pc:requireModuleName>.

  @IntCloneMethod:
    @@Return:
      @@@Type:
        ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl
      @@@PerlDef:
          my $node = $r = <ClassM::ManakaiDOM:ManakaiDOMNodeObject
                                        ::ManakaiDOM:Perl.new>;
          push @{$node->{<Q::TreeCore:origin>}}, <H::pc:parent>;
          for my $prop (<H::pc:sourceFile>, <H::pc:sourceLine>, <H::pc:code>) {
            $node->{$prop} = $nodeObject->{$prop};
          }
          $node->{<H::pc:nodeType>} = 'unparsed';
          $node->{<H::pc:requireResourceURI>}
             = {%{$nodeObject->{<H::pc:requireResourceURI>} || {}}};
          $node->{<H::pc:useModuleName>}
             = {%{$nodeObject->{<H::pc:useModuleName>} || {}}};
          $node->{<H::pc:useCharClassName>}
             = {map {$_ => {%{$nodeObject->{<H::pc:useCharClassName>}->{$_}}}}
                keys %{$nodeObject->{<H::pc:useCharClassName>} || {}}};
          $node->{<H::pc:requireModuleName>}
             = {%{$nodeObject->{<H::pc:requireModuleName>} || {}}};

  @Attr:
    @@Name: code
    @@enDesc:
      Perl code. 
    @@Type:
      lang:Perl::ManakaiDOM:all
    @@Get:
      @@@disDef:
        @@@@GetProp: code
    @@Set:
      @@@disDef:
        @@@@SetProp: code

  @Attr:
    @@Name: sourceFile
    @@enDesc:
      The source file name of this fragment. 
    @@Type:
      DISLang:String::ManakaiDOM:all
    @@Get:
      @@@enDesc:
        Any string identifying the source. 
      @@@nullCase:
        @@@@enDesc: No source file name is set. 
      @@@disDef:
        @@@@GetProp: sourceFile
    @@Set:
      @@@nullCase:
        @@@@enDesc: No (or unknown) source file. 
      @@@disDef:
        @@@@SetProp: sourceFile

  @Attr:
    @@Name: sourceLine
    @@enDesc:
      Source file line number of the first line of this fragment. 
    @@Type:
      DOMMain:unsigned-long::ManakaiDOM:all
    @@Get:
      @@@disDef:
        @@@@GetProp: sourceLine
    @@Set:
      @@@disDef:
        @@@@SetProp: sourceLine

  @ToStringMethod:
    @@Return:
      @@@Type:
        DISLang:String::ManakaiDOM:all
      @@@enDesc:
        Perl code. 
      @@@PerlDef:
        my $node = $self->{<H::mn:node>};
        __DEEP{
          my $file = $self-><AG::ManakaiPerlCodeFragment.fileNode>;
          $r = sprintf (qq<\n#line %d "%s [u] (Chunk #%d)"\n>,
                        $node->{<H::pc:sourceLine>} || 1,
                        $node->{<H::pc:sourceFile>} ||
                          $file-><AG::ManakaiPerlFile.sourceFile>,
                        $file-><M::ManakaiPerlFile.getNextChunkNumber>)
             . $node->{<H::pc:code>}
             . sprintf (qq<\n#line 1 "%s [/u] (Chunk #%d)"\n>,
                        $file-><AG::ManakaiPerlFile.sourceFile>,
                        $file-><M::ManakaiPerlFile.getNextChunkNumber>);
        }__;
##PerlUnparsedCode

IFClsDef:
  @IFQName: PerlInlineUnparsedCode
  @ClsQName: ManakaiPerlInlineUnparsedCode

  @IFISA: PerlCode
  @ClsISA: ManakaiPerlCodeFragment

  @enDesc:
    Unparsed Perl inline code fragments. 
  
  @IntMethod:
    @@ForCheck: ManakaiDOM|ForClass
    @@Name:newObject
    @@ManakaiDOM:isStatic:1
    @@Description:
      @@@lang:en
      @@@@:
        Creates a new instance object for
        <Class::ManakaiPerlInlineUnparsedCode>. 
    @@Return:
      @@@Type:
        ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl
      @@@Description:
        @@@@lang:en
        @@@@@:
          The newly created node object.
      @@@PerlDef:
        @@@@@:
          my $node = $r = <ClassM::ManakaiDOM:ManakaiDOMNodeObject
                                        ::ManakaiDOM:Perl.new>;
          push @{$node->{<Q::TreeCore:origin>}}, <H::pc:parent>;
          $node->{<H::pc:code>} = '';
          $node->{<H::pc:nodeType>} = 'inunparsed';
        @@@@ImplNote:
          @@@@@lang:en
          @@@@@@:
            Properties: <Q::pc:nodeType>, <Q::pc:code>, <Q::pc:useModuleName>, 
               <Q::pc:useCharClassName>, 
               <Q::pc:requireResourceURI>, <Q::pc:requireModuleName>.

  @IntCloneMethod:
    @@Return:
      @@@Type:
        ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl
      @@@PerlDef:
          my $node = $r = <ClassM::ManakaiDOM:ManakaiDOMNodeObject
                                        ::ManakaiDOM:Perl.new>;
          push @{$node->{<Q::TreeCore:origin>}}, <H::pc:parent>;
          for my $prop (<H::pc:code>) {
            $node->{$prop} = $nodeObject->{$prop};
          }
          $node->{<H::pc:nodeType>} = 'inunparsed';
          $node->{<H::pc:requireResourceURI>}
             = {%{$nodeObject->{<H::pc:requireResourceURI>} || {}}};
          $node->{<H::pc:useModuleName>}
             = {%{$nodeObject->{<H::pc:useModuleName>} || {}}};
          $node->{<H::pc:useCharClassName>}
             = {map {$_ => {%{$nodeObject->{<H::pc:useCharClassName>}->{$_}}}}
                keys %{$nodeObject->{<H::pc:useCharClassName>} || {}}};
          $node->{<H::pc:requireModuleName>}
             = {%{$nodeObject->{<H::pc:requireModuleName>} || {}}};

  @Attr:
    @@Name: code
    @@enDesc:
      Perl code. 
    @@Type:
      lang:Perl::ManakaiDOM:all
    @@Get:
      @@@disDef:
        @@@@GetProp: code
    @@Set:
      @@@disDef:
        @@@@SetProp: code

  @ToStringMethod:
    @@Return:
      @@@Type:
        DISLang:String::ManakaiDOM:all
      @@@enDesc:
        Perl code. 
      @@@PerlDef:
        my $node = $self->{<H::mn:node>};
        $r = $node->{<H::pc:code>};
##PerlInlineUnparsedCode

IFClsDef:
  @IFQName: PerlStringLiteral
  @ClsQName: ManakaiPerlStringLiteral

  @IFISA: PerlCode
  @ClsISA: ManakaiPerlCodeFragment

  @enDesc:
    Perl string literal.
  
  @IntMethod:
    @@ForCheck: ManakaiDOM|ForClass
    @@Name:newObject
    @@ManakaiDOM:isStatic:1
    @@Description:
      @@@lang:en
      @@@@:
        Creates a new instance object for
        <Class::ManakaiPerlStringLiteral>. 
    @@Return:
      @@@Type:
        ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl
      @@@Description:
        @@@@lang:en
        @@@@@:
          The newly created node object.
      @@@PerlDef:
        @@@@@:
          my $node = $r = <ClassM::ManakaiDOM:ManakaiDOMNodeObject
                                        ::ManakaiDOM:Perl.new>;
          push @{$node->{<Q::TreeCore:origin>}}, <H::pc:parent>;
          $node->{<H::infoset:content>} = '';
          $node->{<H::pc:nodeType>} = 'string';
        @@@@ImplNote:
          @@@@@lang:en
          @@@@@@:
            Properties: <Q::pc:nodeType>, <Q::pc:useCharClassName>, 
               <Q::infoset:content>, <Q::pc:useModuleName>, 
               <Q::pc:requireResourceURI>, <Q::pc:requireModuleName>.

  @IntCloneMethod:
    @@Return:
      @@@Type:
        ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl
      @@@PerlDef:
          my $node = $r = <ClassM::ManakaiDOM:ManakaiDOMNodeObject
                                        ::ManakaiDOM:Perl.new>;
          push @{$node->{<Q::TreeCore:origin>}}, <H::pc:parent>;
          for my $prop (<H::infoset:content>) {
            $node->{$prop} = $nodeObject->{$prop};
          }
          $node->{<H::pc:nodeType>} = 'string';
          $node->{<H::pc:requireResourceURI>}
             = {%{$nodeObject->{<H::pc:requireResourceURI>} || {}}};
          $node->{<H::pc:useModuleName>}
             = {%{$nodeObject->{<H::pc:useModuleName>} || {}}};
          $node->{<H::pc:useCharClassName>}
             = {map {$_ => {%{$nodeObject->{<H::pc:useCharClassName>}->{$_}}}}
                keys %{$nodeObject->{<H::pc:useCharClassName>} || {}}};
          $node->{<H::pc:requireModuleName>}
             = {%{$nodeObject->{<H::pc:requireModuleName>} || {}}};

  @Attr:
    @@Name: data
    @@enDesc:
      String data. 
    @@Type:
      DISLang:String::ManakaiDOM:all
    @@Get:
      @@@disDef:
        @@@@GetProp: 
          infoset:content
    @@Set:
      @@@disDef:
        @@@@SetProp: 
          infoset:content

  @NumValMethod:
    @@Return:
      @@@Type:
        DISIDL:AnyRealNumber::ManakaiDOM:all
      @@@enDesc:
        Numeric value of the Perl code. 
      @@@PerlDef:
        $r = 0 + $self->{<H::mn:node>}->{<H::infoset:content>};

  @ToStringMethod:
    @@Return:
      @@@Type:
        DISLang:String::ManakaiDOM:all
      @@@enDesc:
        Perl code. 
      @@@PerlDef:
        my $node = $self->{<H::mn:node>};
        $r = $node->{<H::infoset:content>};
        $r =~ s/(['\\])/\\$1/g;
        $r = q<'> . $r . q<'>;
##PerlStringLiteral

IFClsDef:
  @IFQName: PerlTokens
  @ClsQName: ManakaiPerlBare

  @IFISA: PerlCode
  @ClsISA: ManakaiPerlCodeFragment

  @enDesc:
    Unparsed Perl inline code fragments. 
  
  @IntMethod:
    @@ForCheck: ManakaiDOM|ForClass
    @@Name:newObject
    @@ManakaiDOM:isStatic:1
    @@Description:
      @@@lang:en
      @@@@:
        Creates a new instance object for
        <Class::ManakaiPerlInlineBare>. 
    @@Return:
      @@@Type:
        ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl
      @@@Description:
        @@@@lang:en
        @@@@@:
          The newly created node object.
      @@@PerlDef:
        @@@@@:
          my $node = $r = <ClassM::ManakaiDOM:ManakaiDOMNodeObject
                                        ::ManakaiDOM:Perl.new>;
          push @{$node->{<Q::TreeCore:origin>}}, <H::pc:parent>;
          $node->{<H::pc:code>} = '';
          $node->{<H::pc:nodeType>} = 'bare';
        @@@@ImplNote:
          @@@@@lang:en
          @@@@@@:
            Properties: <Q::pc:nodeType>, <Q::pc:code>, <Q::pc:useModuleName>, 
               <Q::pc:useCharClassName>, 
               <Q::pc:requireResourceURI>, <Q::pc:requireModuleName>.

  @IntCloneMethod:
    @@Return:
      @@@Type:
        ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl
      @@@PerlDef:
          my $node = $r = <ClassM::ManakaiDOM:ManakaiDOMNodeObject
                                        ::ManakaiDOM:Perl.new>;
          push @{$node->{<Q::TreeCore:origin>}}, <H::pc:parent>;
          for my $prop (<H::pc:code>) {
            $node->{$prop} = $nodeObject->{$prop};
          }
          $node->{<H::pc:nodeType>} = 'bare';
          $node->{<H::pc:requireResourceURI>}
             = {%{$nodeObject->{<H::pc:requireResourceURI>} || {}}};
          $node->{<H::pc:useModuleName>}
             = {%{$nodeObject->{<H::pc:useModuleName>} || {}}};
          $node->{<H::pc:useCharClassName>}
             = {map {$_ => {%{$nodeObject->{<H::pc:useCharClassName>}->{$_}}}}
                keys %{$nodeObject->{<H::pc:useCharClassName>} || {}}};
          $node->{<H::pc:requireModuleName>}
             = {%{$nodeObject->{<H::pc:requireModuleName>} || {}}};

  @Attr:
    @@Name: code
    @@enDesc:
      Perl code. 
    @@Type:
      lang:Perl::ManakaiDOM:all
    @@Get:
      @@@disDef:
        @@@@GetProp: code
    @@Set:
      @@@disDef:
        @@@@SetProp: code

  @ToStringMethod:
    @@Return:
      @@@Type:
        DISLang:String::ManakaiDOM:all
      @@@enDesc:
        Perl code. 
      @@@PerlDef:
        my $node = $self->{<H::mn:node>};
        $r = $node->{<H::pc:code>};
##PerlBare

IFClsDef:
  @IFQName: PerlAtom
  @ClsQName: ManakaiPerlAtom

  @IFISA: PerlCode

  @ClsISA: ManakaiPerlBare

  @enDesc:
    Unparsed Perl atomic code fragments (such as numeric literal). 
  
  @IntMethod:
    @@ForCheck: ManakaiDOM|ForClass
    @@Name:newObject
    @@ManakaiDOM:isStatic:1
    @@Description:
      @@@lang:en
      @@@@:
        Creates a new instance object for
        <Class::ManakaiPerlAtom>. 
    @@Return:
      @@@Type:
        ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl
      @@@Description:
        @@@@lang:en
        @@@@@:
          The newly created node object.
      @@@PerlDef:
        @@@@@:
          my $node = $r = <ClassM::ManakaiDOM:ManakaiDOMNodeObject
                                        ::ManakaiDOM:Perl.new>;
          push @{$node->{<Q::TreeCore:origin>}}, <H::pc:parent>;
          $node->{<H::pc:code>} = '';
          $node->{<H::pc:nodeType>} = 'atom';
        @@@@ImplNote:
          @@@@@lang:en
          @@@@@@:
            Properties: <Q::pc:nodeType>, <Q::pc:code>, <Q::pc:useModuleName>, 
               <Q::pc:useCharClassName>, 
               <Q::pc:requireResourceURI>, <Q::pc:requireModuleName>.

  @IntCloneMethod:
    @@Return:
      @@@Type:
        ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl
      @@@PerlDef:
          my $node = $r = <ClassM::ManakaiDOM:ManakaiDOMNodeObject
                                        ::ManakaiDOM:Perl.new>;
          push @{$node->{<Q::TreeCore:origin>}}, <H::pc:parent>;
          for my $prop (<H::pc:code>) {
            $node->{$prop} = $nodeObject->{$prop};
          }
          $node->{<H::pc:nodeType>} = 'atom';
          $node->{<H::pc:requireResourceURI>}
             = {%{$nodeObject->{<H::pc:requireResourceURI>} || {}}};
          $node->{<H::pc:useModuleName>}
             = {%{$nodeObject->{<H::pc:useModuleName>} || {}}};
          $node->{<H::pc:useCharClassName>}
             = {map {$_ => {%{$nodeObject->{<H::pc:useCharClassName>}->{$_}}}}
                keys %{$nodeObject->{<H::pc:useCharClassName>} || {}}};
          $node->{<H::pc:requireModuleName>}
             = {%{$nodeObject->{<H::pc:requireModuleName>} || {}}};

  @NumValMethod:
    @@Return:
      @@@Type:
        DISIDL:AnyRealNumber::ManakaiDOM:all
      @@@enDesc:
        Numeric value of the Perl code. 
      @@@PerlDef:
        $r = 0 + $self->{<H::mn:node>}->{<H::pc:code>};

  @ToStringMethod:
    @@Return:
      @@@Type:
        DISLang:String::ManakaiDOM:all
      @@@enDesc:
        Perl code. 
      @@@PerlDef:
        my $node = $self->{<H::mn:node>};
        $r = $node->{<H::pc:code>};
##PerlAtom

IFClsDef:
  @IFQName: PerlVariable
  @ClsQName: ManakaiPerlVariable

  @IFISA: PerlCode
  @ClsISA: ManakaiPerlCodeFragment

  @enDesc:
    Unparsed Perl variable. 
    \
    {NOTE:: Future version of the implementation may 
            support to specify array index or hash key.
     \
    }
  
  @IntMethod:
    @@ForCheck: ManakaiDOM|ForClass
    @@Name:newObject
    @@ManakaiDOM:isStatic:1
    @@Description:
      @@@lang:en
      @@@@:
        Creates a new instance object for
        <Class::ManakaiPerlVariable>. 
    @@Return:
      @@@Type:
        ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl
      @@@Description:
        @@@@lang:en
        @@@@@:
          The newly created node object.
      @@@PerlDef:
        @@@@@:
          my $node = $r = <ClassM::ManakaiDOM:ManakaiDOMNodeObject
                                        ::ManakaiDOM:Perl.new>;
          push @{$node->{<Q::TreeCore:origin>}}, <H::pc:parent>;
          $node->{<H::pc:variableType>} = '';
          $node->{<H::pc:nodeType>} = 'variable';
        @@@@ImplNote:
          @@@@@lang:en
          @@@@@@:
            Properties: <Q::pc:nodeType>, <Q::pc:variableType>,
              <Q::packageName>, <Q::localName> (required),
              <Q::pc:useCharClassName>, 
              <Q::variableScope>, <Q::hashKey>, <Q::pc:useModuleName>, 
               <Q::pc:requireResourceURI>, <Q::pc:requireModuleName>.

  @IntCloneMethod:
    @@Return:
      @@@Type:
        ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl
      @@@PerlDef:
          my $node = $r = <ClassM::ManakaiDOM:ManakaiDOMNodeObject
                                        ::ManakaiDOM:Perl.new>;
          push @{$node->{<Q::TreeCore:origin>}}, <H::pc:parent>;
          for my $prop (<H::pc:variableType>, <H::pc:packageName>,
                        <H::pc:localName>, <H::pc:variableScope>, <H::pc:hashKey>) {
            $node->{$prop} = $nodeObject->{$prop};
          }
          $node->{<H::pc:nodeType>} = 'variable';
          $node->{<H::pc:requireResourceURI>}
             = {%{$nodeObject->{<H::pc:requireResourceURI>} || {}}};
          $node->{<H::pc:useModuleName>}
             = {%{$nodeObject->{<H::pc:useModuleName>} || {}}};
          $node->{<H::pc:useCharClassName>}
             = {map {$_ => {%{$nodeObject->{<H::pc:useCharClassName>}->{$_}}}}
                keys %{$nodeObject->{<H::pc:useCharClassName>} || {}}};
          $node->{<H::pc:requireModuleName>}
             = {%{$nodeObject->{<H::pc:requireModuleName>} || {}}};

  @Attr:
    @@Name: variableType
    @@enDesc:
      Perl variable type (<CODE::$>, <CODE::@>, <CODE::%>,
      <CODE::&> or empty string). 
    @@Type:
      lang:Perl::ManakaiDOM:all
    @@Get:
      @@@disDef:
        @@@@GetProp: variableType
    @@Set:
      @@@disDef:
        @@@@SetProp: variableType

  @Attr:
    @@Name: packageName
    @@enDesc:
      The name of the package to which this variable belongs.
    @@Type:
      Perl:package-name::ManakaiDOM:all
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          This package belongs to the current package or 
          does not belong to any package.
      @@@disDef:
        @@@@GetProp: packageName
    @@Set:
      @@@nullCase:
        @@@@enDesc:
          This package belongs to the current package or
          does not belong to any package.
      @@@disDef:
        @@@@SetProp: packageName

  @Attr:
    @@Name: localName
    @@enDesc:
      The local variable name.
    @@Type:
      lang:Perl::ManakaiDOM:all
    @@Get:
      @@@disDef:
        @@@@GetProp: localName
    @@Set:
      @@@disDef:
        @@@@SetProp: localName

  @Attr:
    @@Name: variableScope
    @@enDesc:
      Scope modifier (<CODE::my> or <CODE::our> or <CODE::local>).
    @@Type:
      lang:Perl::ManakaiDOM:all
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          This variable does not have scope modifier.
      @@@disDef:
        @@@@GetProp: variableScope
    @@Set:
      @@@nullCase:
        @@@@enDesc:
          This variable does not have scope modifier.
      @@@disDef:
        @@@@SetProp: variableScope

  @ToStringMethod:
    @@Return:
      @@@Type:
        DISLang:String::ManakaiDOM:all
      @@@enDesc:
        Perl code. 
      @@@PerlDef:
        my $node = $self->{<H::mn:node>};
        if ($node->{<H::pc:variableScope>}) {
          $r = $node->{<H::pc:variableScope>} . ' ';
        }
        $r .= $node->{<H::pc:variableType>};
        $r .= $node->{<H::pc:packageName>} . '::'
          if defined $node->{<H::pc:packageName>};
        $r .= $node->{<H::pc:localName>};
        if ($node->{<H::pc:variableType>} eq '$' and
            defined $node->{<H::pc:hashKey>}) {
          my $hashKey = $node->{<H::pc:hashKey>};
          $hashKey =~ s/(['\\])/\\$1/g;
          $r .= q<{'> . $hashKey . q<'}>;
        }

  @Attr:
    @@Name: hashKey
    @@enDesc:
      The key for hash. 
      \
      {NOTE:: Using Perl code for key is not supported in the current
              version of the implementation.
      \
      }
    @@Type:
      DISLang:String::ManakaiDOM:all
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          This variable is not for hash value access.
      @@@disDef:
        @@@@GetProp: hashKey
    @@Set:
      @@@nullCase:
        @@@@enDesc:
          This variable is not for hash value access.
      @@@disDef:
        @@@@SetProp: hashKey
##PerlVariable

PropDef:
  @QName: variableScope
  @enDesc:
    Variable scope (<CODE::local>, <CODE::my> or <CODE::our>).

PropDef:
  @QName: variableType
  @enDesc:
    Variable type prefix.

PropDef:
  @QName: hashKey
  @enDesc:
    Hash key string.

IFClsDef:
  @IFQName: PerlCodeUnits
  @ClsQName: ManakaiPerlAnyContainer

  @ClsISA: ManakaiPerlCodeFragment

  @enDesc:
    A base class implemented by both inline container and
    block-level container.
  
  @Attr:
    @@Name: length
    @@enDesc:
      The number of child code fragments. 
    @@Type:
      DOMMain:unsigned-long::ManakaiDOM:all
    @@Get:
      @@@PerlDef:
        $r = @{$self->{<H::mn:node>}->{<H::pc:childNodes>}};

  @Method:
    @@Name: appendStringLiteral
    @@enDesc:
      Appends a Perl string literal (<CODE::q>).
    @@Param:
      @@@Name: stringArg
      @@@Type: 
        DISLang:String::ManakaiDOM:all
      @@@enDesc:
        A string.
    @@Return:
      @@@Type: ManakaiPerlStringLiteral
      @@@enDesc:
        The newly created Perl string literal object. 
      @@@PerlDef:
        $r = <ClassM::ManakaiPerlStringLiteral.newObject>;
        my $node = $self->{<H::mn:node>};
        $r->{<H::infoset:content>} = $stringArg;
        $node-><M::ManakaiDOM:ManakaiDOMNodeObject
                 ::ManakaiDOM:Perl.importTree> ($r);
        push @{$node->{<H::pc:childNodes>}}, $r;
        $r->{<H::pc:parent>} = $node;
        if (defined wantarray) {
          __CODE{ManakaiNode:getNewReference::
            $object => $r, $ref => $r,
            $class =>{<ClassName::ManakaiPerlStringLiteral>},
          }__;
        }


  @Method:
    @@Name: appendAtom
    @@enDesc:
      Appends a Perl atomic code fragment.
    @@Param:
      @@@Name: codeArg
      @@@Type: 
        lang:Perl::ManakaiDOM:all
      @@@enDesc:
        An atom.
    @@Return:
      @@@Type: ManakaiPerlAtom
      @@@enDesc:
        The newly created Perl code object. 
      @@@PerlDef:
        $r = <ClassM::ManakaiPerlAtom.newObject>;
        my $node = $self->{<H::mn:node>};
        $r->{<H::pc:code>} = $codeArg;
        $node-><M::ManakaiDOM:ManakaiDOMNodeObject
                 ::ManakaiDOM:Perl.importTree> ($r);
        push @{$node->{<H::pc:childNodes>}}, $r;
        $r->{<H::pc:parent>} = $node;
        if (defined wantarray) {
          __CODE{ManakaiNode:getNewReference::
            $object => $r, $ref => $r,
            $class =>{<ClassName::ManakaiPerlAtom>},
          }__;
        }


  @Method:
    @@Name: appendBare
    @@enDesc:
      Appends a Perl bare code fragment.
    @@Param:
      @@@Name: codeArg
      @@@Type: 
        lang:Perl::ManakaiDOM:all
      @@@enDesc:
        An bare code.
    @@Return:
      @@@Type: ManakaiPerlBare
      @@@enDesc:
        The newly created Perl code object. 
      @@@PerlDef:
        $r = <ClassM::ManakaiPerlBare.newObject>;
        my $node = $self->{<H::mn:node>};
        $r->{<H::pc:code>} = $codeArg;
        $node-><M::ManakaiDOM:ManakaiDOMNodeObject
                 ::ManakaiDOM:Perl.importTree> ($r);
        push @{$node->{<H::pc:childNodes>}}, $r;
        $r->{<H::pc:parent>} = $node;
        if (defined wantarray) {
          __CODE{ManakaiNode:getNewReference::
            $object => $r, $ref => $r,
            $class =>{<ClassName::ManakaiPerlBare>},
          }__;
        }

  @Method:
    @@Name: appendNewAssignment
    @@enDesc:
      Appends a newly created <Class::ManakaiPerlAssign> object. 
    @@Param:
      @@@Name: leftArg
      @@@Type: ManakaiPerlCodeFragment
      @@@enDesc:
        A left hand side code fragment object. 
    @@Param:
      @@@Name: rightArg
      @@@Type: ManakaiPerlCodeFragment
      @@@enDesc:
        A right hand side code fragment object. 
    @@Return:
      @@@RaiseException:
        @@@@@:BAD_CHILD_ERR
        @@@@enDesc:
          An attempt is made to append a child
          that is not valid type.
      @@@RaiseException:
        @@@@@:IN_USE_NODE_ERR
        @@@@enDesc:
          An attempt is made to append a node that is 
          already used elsewhere. 
      @@@PerlDef:
        for my $arg ([leftArg => $leftArg], [rightArg => $rightArg]) {
          if ({
            atom => 1, bare => 1, incontainer => 1, assign => true,
            inunparsed => 1, variable => 1, string => true,
          }->{$arg->[1]->{<H::mn:node>}->{<H::pc:nodeType>}}) {
            if ($arg->[1]->{<H::mn:node>}->{<H::pc:parent>}) {
              __EXCEPTION{IN_USE_NODE_ERR::
                pc:childNode => {$arg->[1]},
                MDOMX:param-name => {$arg->[0]},
              }__;
            }
          } else {
            __EXCEPTION{BAD_CHILD_ERR::
              pc:parentNode => {$self},
              pc:childNode => {$arg->[1]},
              MDOMX:param-name => {$arg->[0]},
            }__;
          }
        } # left/right

        my $assign = <ClassM::ManakaiPerlAssignment.newObject>;
        $assign->{<H::pc:left>} = $leftArg->{<H::mn:node>};
        $assign->{<H::pc:right>} = $rightArg->{<H::mn:node>};
        $leftArg->{<H::mn:node>}->{<H::pc:parent>} = $assign;
        $rightArg->{<H::mn:node>}->{<H::pc:parent>} = $assign;
        $self->{<H::mn:node>}-><M::MNodeObject.importTree> ($assign);
        $assign->{<H::pc:parent>} = $self->{<H::mn:node>};
        push @{$self->{<H::mn:node>}->{<H::pc:childNodes>}}, $assign;
##PerlAnyContainer

IFClsDef:
  @IFQName: PerlStatement
  @ClsQName: ManakaiPerlStatement

  @IFISA: PerlCode

  @IFISA: PerlCodeInlines
  @ClsISA: ManakaiPerlInlineContainer

  @enDesc:
    Perl statements. 
  
  @IntMethod:
    @@ForCheck: ManakaiDOM|ForClass
    @@Name:newObject
    @@ManakaiDOM:isStatic:1
    @@Description:
      @@@lang:en
      @@@@:
        Creates a new instance object for
        <Class::ManakaiPerlStatement>. 
    @@Return:
      @@@Type:
        ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl
      @@@Description:
        @@@@lang:en
        @@@@@:
          The newly created node object.
      @@@PerlDef:
        @@@@@:
          my $node = $r = <ClassM::ManakaiDOM:ManakaiDOMNodeObject
                                        ::ManakaiDOM:Perl.new>;
          push @{$node->{<Q::TreeCore:origin>}}, <H::pc:parent>;
          push @{$node->{<Q::TreeCore:subnode>}}, <H::pc:childNodes>;
          $node->{<H::pc:childNodes>} = [];
          $node->{<H::pc:nodeType>} = 'statement';
        @@@@ImplNote:
          @@@@@lang:en
          @@@@@@:
            Properties: <Q::pc:nodeType>, <Q::pc:childNodes>,
               <Q::pc:parent>, <Q::pc:useModuleName>, <Q::pc:useCharClassName>,  
               <Q::pc:requireResourceURI>, <Q::pc:requireModuleName>.

  @IntCloneMethod:
    @@Return:
      @@@Type:
        ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl
      @@@PerlDef:
          my $node = $r = <ClassM::ManakaiDOM:ManakaiDOMNodeObject
                                        ::ManakaiDOM:Perl.new>;
          push @{$node->{<Q::TreeCore:origin>}}, <H::pc:parent>;
          $node->{<H::pc:nodeType>} = 'statement';
          push @{$node->{<Q::TreeCore:subnode>}}, <H::pc:childNodes>;
          $node->{<H::pc:childNodes>} = [];
          for my $cno (@{$nodeObject->{<H::pc:childNodes>}}) {
            my $pack;
            my $nt = $cno->{<H::pc:nodeType>};
            __CODE{pc:nodeTypeToPackageName::
                     $nodeType => $nt, $packageName => $pack, $object => $cno}__;
                                 ## NOTE: Method name written directly
            my $cno_clone = $pack->_make_clone_object ($cno);
            push @{$node->{<H::pc:childNodes>}}, $cno_clone;
            $cno_clone->{<H::pc:parent>} = $node;
            ## NOTE: Tree ID is not updated yet.
          }
          $node->{<H::pc:requireResourceURI>}
             = {%{$nodeObject->{<H::pc:requireResourceURI>} || {}}};
          $node->{<H::pc:useModuleName>}
             = {%{$nodeObject->{<H::pc:useModuleName>} || {}}};
          $node->{<H::pc:useCharClassName>}
             = {map {$_ => {%{$nodeObject->{<H::pc:useCharClassName>}->{$_}}}}
                keys %{$nodeObject->{<H::pc:useCharClassName>} || {}}};
          $node->{<H::pc:requireModuleName>}
             = {%{$nodeObject->{<H::pc:requireModuleName>} || {}}};

  @ToStringMethod:
    @@Return:
      @@@Type:
        DISLang:String::ManakaiDOM:all
      @@@enDesc:
        Perl code. 
      @@@PerlDef:
        $r = $self->SUPER::stringify;
        $r .= ";\n" if length $r;
##PerlStatement

IFClsDef:
  @IFQName: PerlCodeInlines
  @ClsQName: ManakaiPerlInlineContainer

  @ClsISA: ManakaiPerlAnyContainer

  @enDesc:
    Unparsed Perl inline code block. 
  
  @IntMethod:
    @@ForCheck: ManakaiDOM|ForClass
    @@Name:newObject
    @@ManakaiDOM:isStatic:1
    @@Description:
      @@@lang:en
      @@@@:
        Creates a new instance object for
        <Class::ManakaiPerlInlineContainer>. 
    @@Return:
      @@@Type:
        ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl
      @@@Description:
        @@@@lang:en
        @@@@@:
          The newly created node object.
      @@@PerlDef:
        @@@@@:
          my $node = $r = <ClassM::ManakaiDOM:ManakaiDOMNodeObject
                                        ::ManakaiDOM:Perl.new>;
          push @{$node->{<Q::TreeCore:origin>}}, <H::pc:parent>;
          push @{$node->{<Q::TreeCore:subnode>}}, <H::pc:childNodes>;
          $node->{<H::pc:childNodes>} = [];
          $node->{<H::pc:nodeType>} = 'incontainer';
        @@@@ImplNote:
          @@@@@lang:en
          @@@@@@:
            Properties: <Q::pc:nodeType>, <Q::pc:childNodes>,
               <Q::pc:parent>, <Q::pc:useModuleName>, <Q::pc:useCharClassName>,  
               <Q::pc:requireResourceURI>, <Q::pc:requireModuleName>.

  @IntCloneMethod:
    @@Return:
      @@@Type:
        ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl
      @@@PerlDef:
          my $node = $r = <ClassM::ManakaiDOM:ManakaiDOMNodeObject
                                        ::ManakaiDOM:Perl.new>;
          push @{$node->{<Q::TreeCore:origin>}}, <H::pc:parent>;
          push @{$node->{<Q::TreeCore:subnode>}}, <H::pc:childNodes>;
          $node->{<H::pc:nodeType>} = 'incontainer';
          $node->{<H::pc:childNodes>} = [];
          for my $cno (@{$nodeObject->{<H::pc:childNodes>}}) {
            my $pack;
            my $nt = $cno->{<H::pc:nodeType>};
            __CODE{pc:nodeTypeToPackageName::
                     $nodeType => $nt, $packageName => $pack, $object => $cno}__;
                                 ## NOTE: Method name written directly
            my $cno_clone = $pack->_make_clone_object ($cno);
            push @{$node->{<H::pc:childNodes>}}, $cno_clone;
            $cno_clone->{<H::pc:parent>} = $node;
            ## NOTE: Tree ID is not updated yet.
          }
          $node->{<H::pc:requireResourceURI>}
             = {%{$nodeObject->{<H::pc:requireResourceURI>} || {}}};
          $node->{<H::pc:useModuleName>}
             = {%{$nodeObject->{<H::pc:useModuleName>} || {}}};
          $node->{<H::pc:useCharClassName>}
             = {map {$_ => {%{$nodeObject->{<H::pc:useCharClassName>}->{$_}}}}
                keys %{$nodeObject->{<H::pc:useCharClassName>} || {}}};
          $node->{<H::pc:requireModuleName>}
             = {%{$nodeObject->{<H::pc:requireModuleName>} || {}}};

  @Method:
    @@Name: appendCodeFragment
    @@enDesc:
      Appends a <Class::ManakaiPerlCodeFragment> object. 
    @@Param:
      @@@Name: codeArg
      @@@Type: PerlCode
      @@@caType: ManakaiPerlCodeFragment
      @@@enDesc:
        A code fragment object. 
    @@Return:
      @@@RaiseException:
        @@@@@:BAD_CHILD_ERR
        @@@@enDesc:
          An attempt is made to append a child
          that is not a <Class::ManakaiPerlUnparsedCode>.
      @@@RaiseException:
        @@@@@:IN_USE_NODE_ERR
        @@@@enDesc:
          An attempt is made to append a node that is 
          already used elsewhere. 
      @@@PerlDef:
        if ({
          atom => 1, bare => 1, incontainer => 1, assign => true,
          inunparsed => 1, variable => 1, string => 1,
        }->{$codeArg->{<H::mn:node>}->{<H::pc:nodeType>}}) {
          if ($codeArg->{<H::mn:node>}->{<H::pc:parent>}) {
            __EXCEPTION{IN_USE_NODE_ERR::
              pc:childNode => {$codeArg},
            }__;
          }
          $self->{<H::mn:node>}-><M::MNodeObject.importTree>
                                          ($codeArg->{<H::mn:node>});
          push @{$self->{<H::mn:node>}->{<H::pc:childNodes>}},
               $codeArg->{<H::mn:node>};
          $codeArg->{<H::mn:node>}->{<H::pc:parent>}
                                         = $self->{<H::mn:node>};
        } else {
          __EXCEPTION{BAD_CHILD_ERR::
            pc:parentNode => {$self},
            pc:childNode => {$codeArg},
          }__;
        }

  @Method:
    @@Name: appendCode
    @@enDesc:
      Appends an unparsed Perl code fragment. 
    @@Param:
      @@@Name: codeArg
      @@@Type: 
        lang:Perl::ManakaiDOM:all
      @@@enDesc:
        An unparsed Perl code fragment. 
    @@Return:
      @@@Type: PerlInlineUnparsedCode
      @@@caType: ManakaiPerlInlineUnparsedCode
      @@@enDesc:
        The newly created Perl code object. 
      @@@PerlDef:
        $r = <ClassM::ManakaiPerlInlineUnparsedCode.newObject>;
        my $node = $self->{<H::mn:node>};
        $r->{<H::pc:code>} = $codeArg;
        $node-><M::ManakaiDOM:ManakaiDOMNodeObject
                 ::ManakaiDOM:Perl.importTree> ($r);
        push @{$node->{<H::pc:childNodes>}}, $r;
        $r->{<H::pc:parent>} = $node;
        if (defined wantarray) {
          __CODE{ManakaiNode:getNewReference::
            $object => $r, $ref => $r,
            $class =>{<ClassName::ManakaiPerlInlineUnparsedCode>},
          }__;
        }

  @ToStringMethod:
    @@Return:
      @@@Type:
        DISLang:String::ManakaiDOM:all
      @@@enDesc:
        Perl code. 
      @@@PerlDef:
        for my $cno (@{$self->{<H::mn:node>}->{<H::pc:childNodes>}}) {
          my $cn = <ClassM::ManakaiPerlCodeFragment.getNodeReference> ($cno);
          if ($cno->{<H::pc:nodeType>} eq 'incontainer' and
   \          @{$self->{<H::mn:node>}->{<H::pc:childNodes>}} == 1) {
            $r .= '(' . $cn->stringify . ')';
          } else {
            $r .= $cn->stringify;
          }
        }
##PerlInlineContainer

IFClsDef:
  @IFQName: PerlBlock
  @ClsQName: ManakaiPerlBlock

  @IFISA: PerlCode

  @IFISA: PerlCodeStatements
  @ClsISA: ManakaiPerlStatementContainer

  @enDesc:
    Perl block-level code block. 
  
  @IntMethod:
    @@ForCheck: ManakaiDOM|ForClass
    @@Name:newObject
    @@ManakaiDOM:isStatic:1
    @@Description:
      @@@lang:en
      @@@@:
        Creates a new instance object for
        <Class::ManakaiPerlBlock>. 
    @@Return:
      @@@Type:
        ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl
      @@@Description:
        @@@@lang:en
        @@@@@:
          The newly created node object.
      @@@PerlDef:
        @@@@@:
          my $node = $r = <ClassM::ManakaiDOM:ManakaiDOMNodeObject
                                        ::ManakaiDOM:Perl.new>;
          push @{$node->{<Q::TreeCore:origin>}}, <H::pc:parent>;
          push @{$node->{<Q::TreeCore:subnode>}}, <H::pc:childNodes>;
          $node->{<H::pc:childNodes>} = [];
          $node->{<H::pc:nodeType>} = 'block';
        @@@@ImplNote:
          @@@@@lang:en
          @@@@@@:
            Properties: <Q::pc:nodeType>, <Q::pc:childNodes>, <Q::pc:label>,
                <Q::pc:parent>, <Q::pc:sourceFile>, <Q::pc:sourceLine>,
                <Q::pc:currentSoruceFile>, <Q::pc:useCharClassName>, 
                <Q::pc:currentSourceLine>, <Q::pc:useModuleName>, 
                <Q::pc:requireResourceURI>, <Q::pc:requireModuleName>.

  @IntCloneMethod:
    @@Return:
      @@@Type:
        ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl
      @@@PerlDef:
          my $node = $r = <ClassM::ManakaiDOM:ManakaiDOMNodeObject
                                        ::ManakaiDOM:Perl.new>;
          push @{$node->{<Q::TreeCore:origin>}}, <H::pc:parent>;
          push @{$node->{<Q::TreeCore:subnode>}}, <H::pc:childNodes>;
          $node->{<H::pc:nodeType>} = 'block';
          $node->{<H::pc:childNodes>} = [];
          for my $cno (@{$nodeObject->{<H::pc:childNodes>}}) {
            my $pack;
            my $nt = $cno->{<H::pc:nodeType>};
            __CODE{pc:nodeTypeToPackageName::
                     $nodeType => $nt, $packageName => $pack, $object => $cno}__;
                                 ## NOTE: Method name written directly
            my $cno_clone = $pack->_make_clone_object ($cno);
            push @{$node->{<H::pc:childNodes>}}, $cno_clone;
            $cno_clone->{<H::pc:parent>} = $node;
            ## NOTE: Tree ID is not updated yet.
          }
          for my $prop (<H::pc:label>, <H::pc:sourceFile>, <H::pc:sourceLine>,
                        <H::pc:currentSourceFile>, <H::pc:currentSourceLine>) {
            $node->{$prop} = $nodeObject->{$prop};
          }
          $node->{<H::pc:requireResourceURI>}
             = {%{$nodeObject->{<H::pc:requireResourceURI>} || {}}};
          $node->{<H::pc:useModuleName>}
             = {%{$nodeObject->{<H::pc:useModuleName>} || {}}};
          $node->{<H::pc:useCharClassName>}
             = {map {$_ => {%{$nodeObject->{<H::pc:useCharClassName>}->{$_}}}}
                keys %{$nodeObject->{<H::pc:useCharClassName>} || {}}};
          $node->{<H::pc:requireModuleName>}
             = {%{$nodeObject->{<H::pc:requireModuleName>} || {}}};

  @ToStringMethod:
    @@Return:
      @@@Type:
        DISLang:String::ManakaiDOM:all
      @@@enDesc:
        Perl code. 
      @@@PerlDef:
        my $node = $self->{<H::mn:node>};
        if (@{$node->{<H::pc:childNodes>}} == 1 and
            $node->{<H::pc:childNodes>}->[0]->{<H::pc:nodeType>} eq 'block') {
          my $cn;
          __CODE{ManakaiNode:getWeakReference::
                     $object => {$node->{<H::pc:childNodes>}->[0]},
                     $ref => $cn,
                     $class => {<ClassName::ManakaiPerlBlock>}}__;
          $r = $cn->stringify;
        } else {
          for my $cno (@{$node->{<H::pc:childNodes>}}) {
            my $cn = <ClassM::ManakaiPerlCodeFragment.getNodeReference> ($cno);
            if ($cno->{<H::pc:nodeType>} eq 'incontainer' and
   \            @{$node->{<H::pc:childNodes>}} == 1) {
              $r .= '(' . $cn->stringify . ')';
            } else {
              $r .= $cn->stringify;
            }
          }
          __DEEP{
            my $file = $self-><AG::ManakaiPerlCodeFragment.fileNode>;
            $r = sprintf (qq<\n{\n#line %d "%s [b] (Chunk #%d)"\n>,
                          $node->{<H::pc:sourceLine>} || 1,
                          $node->{<H::pc:sourceFile>} ||
                            $file-><AG::ManakaiPerlFile.sourceFile>,
                          $file-><M::ManakaiPerlFile.getNextChunkNumber>)
               . $r
               . sprintf (qq<\n#line 1 "%s [/b] (Chunk #%d)"\n}\n>,
                          $file-><AG::ManakaiPerlFile.sourceFile>,
                          $file-><M::ManakaiPerlFile.getNextChunkNumber>)
              if length $r;
          }__;
        }
##PerlBlock

IFClsDef:
  @IFQName: PerlCodeBlocks
  @ClsQName: ManakaiPerlBlockContainer

  @IFISA: PerlCodeStatements
  @ClsISA: ManakaiPerlStatementContainer

  @enDesc:
    Perl block-level code container whose content may or may
    not semantically be self-contained. 
  
  @IntMethod:
    @@ForCheck: ManakaiDOM|ForClass
    @@Name:newObject
    @@ManakaiDOM:isStatic:1
    @@Description:
      @@@lang:en
      @@@@:
        Creates a new instance object for
        <Class::ManakaiPerlBlockContainer>. 
    @@Return:
      @@@Type:
        ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl
      @@@Description:
        @@@@lang:en
        @@@@@:
          The newly created node object.
      @@@PerlDef:
        @@@@@:
          my $node = $r = <ClassM::ManakaiDOM:ManakaiDOMNodeObject
                                        ::ManakaiDOM:Perl.new>;
          push @{$node->{<Q::TreeCore:origin>}}, <H::pc:parent>;
          push @{$node->{<Q::TreeCore:subnode>}}, <H::pc:childNodes>;
          $node->{<H::pc:childNodes>} = [];
          $node->{<H::pc:nodeType>} = 'blockcontainer';
        @@@@ImplNote:
          @@@@@lang:en
          @@@@@@:
            Properties: <Q::pc:nodeType>, <Q::pc:childNodes>,
                <Q::pc:parent>, <Q::pc:sourceFile>, <Q::pc:sourceLine>,
                <Q::pc:currentSourceFile>, <Q::pc:useCharClassName>, 
                <Q::pc:currentSourceLine>, <Q::pc:useModuleName>, 
                <Q::pc:requireResourceURI>, <Q::pc:requireModuleName>.

  @IntCloneMethod:
    @@Return:
      @@@Type:
        ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl
      @@@PerlDef:
          my $node = $r = <ClassM::ManakaiDOM:ManakaiDOMNodeObject
                                        ::ManakaiDOM:Perl.new>;
          push @{$node->{<Q::TreeCore:origin>}}, <H::pc:parent>;
          push @{$node->{<Q::TreeCore:subnode>}}, <H::pc:childNodes>;
          $node->{<H::pc:nodeType>} = 'blockcontainer';
          $node->{<H::pc:childNodes>} = [];
          for my $cno (@{$nodeObject->{<H::pc:childNodes>}}) {
            my $pack;
            my $nt = $cno->{<H::pc:nodeType>};
            __CODE{pc:nodeTypeToPackageName::
                     $nodeType => $nt, $packageName => $pack, $object => $cno}__;
                                 ## NOTE: Method name written directly
            my $cno_clone = $pack->_make_clone_object ($cno);
            push @{$node->{<H::pc:childNodes>}}, $cno_clone;
            $cno_clone->{<H::pc:parent>} = $node;
            ## NOTE: Tree ID is not updated yet.
          }
          for my $prop (<H::pc:sourceFile>, <H::pc:sourceLine>,
                        <H::pc:currentSourceFile>, <H::pc:currentSourceLine>) {
            $node->{$prop} = $nodeObject->{$prop};
          }
          $node->{<H::pc:requireResourceURI>}
             = {%{$nodeObject->{<H::pc:requireResourceURI>} || {}}};
          $node->{<H::pc:useModuleName>}
             = {%{$nodeObject->{<H::pc:useModuleName>} || {}}};
          $node->{<H::pc:useCharClassName>}
             = {map {$_ => {%{$nodeObject->{<H::pc:useCharClassName>}->{$_}}}}
                keys %{$nodeObject->{<H::pc:useCharClassName>} || {}}};
          $node->{<H::pc:requireModuleName>}
             = {%{$nodeObject->{<H::pc:requireModuleName>} || {}}};

  @ToStringMethod:
    @@Return:
      @@@Type:
        DISLang:String::ManakaiDOM:all
      @@@enDesc:
        Perl code. 
      @@@PerlDef:
        my $node = $self->{<H::mn:node>};
        if (@{$node->{<H::pc:childNodes>}} == 1 and
            {
              block => true, blockcontainer => true,
            }->{$node->{<H::pc:childNodes>}->[0]->{<H::pc:nodeType>}}) {
          my $cn;
          __CODE{ManakaiNode:getWeakReference::
                     $object => {$node->{<H::pc:childNodes>}->[0]},
                     $ref => $cn,
                     $class => {<ClassName::ManakaiPerlBlock>}}__;
          $r = $cn->stringify;
        } else {
          for my $cno (@{$node->{<H::pc:childNodes>}}) {
            my $cn = <ClassM::ManakaiPerlCodeFragment.getNodeReference> ($cno);
            if ($cno->{<H::pc:nodeType>} eq 'incontainer' and
   \            @{$node->{<H::pc:childNodes>}} == 1) {
              $r .= '(' . $cn->stringify . ')';
            } else {
              $r .= $cn->stringify;
            }
          }
          __DEEP{
            my $file = $self-><AG::ManakaiPerlCodeFragment.fileNode>;
            $r = sprintf (qq<\n#line %d "%s [bc] (Chunk #%d)"\n>,
                          $node->{<H::pc:sourceLine>} || 1,
                          $node->{<H::pc:sourceFile>} ||
                            $file-><AG::ManakaiPerlFile.sourceFile>,
                          $file-><M::ManakaiPerlFile.getNextChunkNumber>)
               . $r
               . sprintf (qq<\n#line 1 "%s [/bc] (Chunk #%d)"\n>,
                          $file-><AG::ManakaiPerlFile.sourceFile>,
                          $file-><M::ManakaiPerlFile.getNextChunkNumber>);
          }__;
        }
##PerlBlockContainer

IFClsDef:
  @IFQName: PerlAssignment
  @ClsQName: ManakaiPerlAssignment

  @IFISA: PerlCode
  @ClsISA: ManakaiPerlCodeFragment

  @enDesc:
    Perl variable assignment.
  
  @IntMethod:
    @@ForCheck: ManakaiDOM|ForClass
    @@Name:newObject
    @@ManakaiDOM:isStatic:1
    @@Description:
      @@@lang:en
      @@@@:
        Creates a new instance object for
        <Class::ManakaiPerlAssignment>. 
    @@Return:
      @@@Type:
        ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl
      @@@Description:
        @@@@lang:en
        @@@@@:
          The newly created node object.
      @@@PerlDef:
        @@@@@:
          my $node = $r = <ClassM::ManakaiDOM:ManakaiDOMNodeObject
                                        ::ManakaiDOM:Perl.new>;
          push @{$node->{<Q::TreeCore:origin>}}, <H::pc:parent>;
          push @{$node->{<Q::TreeCore:subnode0>}}, <H::pc:left>, <H::pc:right>;
          $node->{<H::pc:nodeType>} = 'assign';
        @@@@ImplNote:
          @@@@@lang:en
          @@@@@@:
            Properties: <Q::pc:nodeType>, <Q::pc:left>, <Q::pc:right>,
                <Q::pc:parent>, <Q::pc:useModuleName>, <Q::pc:useCharClassName>, 
               <Q::pc:requireResourceURI>, <Q::pc:requireModuleName>.

  @IntCloneMethod:
    @@Return:
      @@@Type:
        ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl
      @@@PerlDef:
          my $node = $r = <ClassM::ManakaiDOM:ManakaiDOMNodeObject
                                        ::ManakaiDOM:Perl.new>;
          push @{$node->{<Q::TreeCore:origin>}}, <H::pc:parent>;
          push @{$node->{<Q::TreeCore:subnode0>}}, <H::pc:left>, <H::pc:right>;
          $node->{<H::pc:nodeType>} = 'assign';
          for my $prop (<H::pc:left>, <H::pc:right>) {
            my $pack;
            my $cno = $nodeObject->{$prop};
            my $nt = $cno->{<H::pc:nodeType>};
            __CODE{pc:nodeTypeToPackageName::
                     $nodeType => $nt, $packageName => $pack, $object => $cno}__;
                                 ## NOTE: Method name written directly
            my $cno_clone = $pack->_make_clone_object ($cno);
            $node->{$prop} = $cno_clone;
            $cno_clone->{<H::pc:parent>} = $node;
            ## NOTE: Tree ID is not updated yet.
          }
          $node->{<H::pc:requireResourceURI>}
             = {%{$nodeObject->{<H::pc:requireResourceURI>} || {}}};
          $node->{<H::pc:useModuleName>}
             = {%{$nodeObject->{<H::pc:useModuleName>} || {}}};
          $node->{<H::pc:useCharClassName>}
             = {map {$_ => {%{$nodeObject->{<H::pc:useCharClassName>}->{$_}}}}
                keys %{$nodeObject->{<H::pc:useCharClassName>} || {}}};
          $node->{<H::pc:requireModuleName>}
             = {%{$nodeObject->{<H::pc:requireModuleName>} || {}}};

  @ToStringMethod:
    @@Return:
      @@@Type:
        DISLang:String::ManakaiDOM:all
      @@@enDesc:
        Perl code. 
      @@@PerlDef:
        my $node = $self->{<H::mn:node>};
        $r = <ClassM::ManakaiPerlCodeFragment.getNodeReference>
                ($node->{<H::pc:left>})->stringify . ' = ' .
             <ClassM::ManakaiPerlCodeFragment.getNodeReference>
                ($node->{<H::pc:right>})->stringify;
##PerlAssignment

IFClsDef:
  @IFQName: PerlIf
  @ClsQName: ManakaiPerlIf

  @IFISA: PerlCode
  @ClsISA: ManakaiPerlCodeFragment

  @enDesc:
    Perl variable assignment.
  
  @IntMethod:
    @@Name:newObject
    @@ManakaiDOM:isStatic:1
    @@Description:
      @@@lang:en
      @@@@:
        Creates a new instance object for
        <Class::ManakaiPerlAssignment>. 
    @@Return:
      @@@Type:
        ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl
      @@@Description:
        @@@@lang:en
        @@@@@:
          The newly created node object.
      @@@PerlDef:
        @@@@@:
          my $node = $r = <ClassM::ManakaiDOM:ManakaiDOMNodeObject
                                        ::ManakaiDOM:Perl.new>;
          push @{$node->{<Q::TreeCore:origin>}}, <H::pc:parent>;
          push @{$node->{<Q::TreeCore:subnode0>}}, <H::pc:condition>,
                     <H::pc:true>, <H::pc:false>;
          $node->{<H::pc:nodeType>} = 'if';
        @@@@ImplNote:
          @@@@@lang:en
          @@@@@@:
            Properties: <Q::pc:nodeType>, <Q::pc:true>, <Q::pc:false>,
               <Q::pc:useCharClassName>, 
                <Q::pc:parent>, <Q::pc:condition>, <Q::pc:useModuleName>, 
               <Q::pc:requireResourceURI>, <Q::pc:requireModuleName>.

  @IntCloneMethod:
    @@Return:
      @@@Type:
        ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl
      @@@PerlDef:
          my $node = $r = <ClassM::ManakaiDOM:ManakaiDOMNodeObject
                                        ::ManakaiDOM:Perl.new>;
          push @{$node->{<Q::TreeCore:origin>}}, <H::pc:parent>;
          push @{$node->{<Q::TreeCore:subnode0>}}, <H::pc:condition>,
                     <H::pc:true>, <H::pc:false>;
          $node->{<H::pc:nodeType>} = 'if';
          for my $prop (<H::pc:true>, <H::pc:false>, <H::pc:condition>) {
            my $pack;
            my $cno = $nodeObject->{$prop};
            next unless $cno;
            my $nt = $cno->{<H::pc:nodeType>};
            __CODE{pc:nodeTypeToPackageName::
                     $nodeType => $nt, $packageName => $pack, $object => $cno}__;
                                 ## NOTE: Method name written directly
            my $cno_clone = $pack->_make_clone_object ($cno);
            $node->{$prop} = $cno_clone;
            $cno_clone->{<H::pc:parent>} = $node;
            ## NOTE: Tree ID is not updated yet.
          }
          $node->{<H::pc:requireResourceURI>}
             = {%{$nodeObject->{<H::pc:requireResourceURI>} || {}}};
          $node->{<H::pc:useModuleName>}
             = {%{$nodeObject->{<H::pc:useModuleName>} || {}}};
          $node->{<H::pc:useCharClassName>}
             = {map {$_ => {%{$nodeObject->{<H::pc:useCharClassName>}->{$_}}}}
                keys %{$nodeObject->{<H::pc:useCharClassName>} || {}}};
          $node->{<H::pc:requireModuleName>}
             = {%{$nodeObject->{<H::pc:requireModuleName>} || {}}};

  @ToStringMethod:
    @@Return:
      @@@Type:
        DISLang:String::ManakaiDOM:all
      @@@enDesc:
        Perl code. 
      @@@PerlDef:
        my $node = $self->{<H::mn:node>};
        $r = <ClassM::ManakaiPerlCodeFragment.getNodeReference>
                ($node->{<H::pc:condition>})->stringify;
        my $true_code = <ClassM::ManakaiPerlCodeFragment.getNodeReference>
                     ($node->{<H::pc:true>})->stringify if $node->{<H::pc:true>};
        my $false_code = <ClassM::ManakaiPerlCodeFragment.getNodeReference>
                   ($node->{<H::pc:false>})->stringify if $node->{<H::pc:false>};
        if (defined $true_code) {
          if (defined $false_code) {
            $r = q<if (> . $r . q<) {> . $true_code .
                 q<} else {> . $false_code . q<}>;
          } else {
            $r = q<if (> . $r . q<) {> . $true_code . q<}>;
          }
        } else {
          $r = q<unless (> . $r . q<) {> . $false_code . q<}>;
        }
##PerlIf

PropDef:
  @QName:condition
  @enDesc:
    Condition.
PropDef:
  @QName:true
  @enDesc:
    If true.
PropDef:
  @QName:false
  @enDesc:
    If false.

PropDef:
  @QName:left
  @FullName:
    @@lang:en
    @@@: Left hand side
PropDef:
  @QName:right
  @FullName:
    @@lang:en
    @@@: Right hand side

PropDef:
  @QName:label
  @enDesc:
    Perl statement / block label.

ElementTypeBinding:
  @Name: RaiseException
  @ElementType:
    ManakaiDOM:raises

IFClsDef:
  @IFQName: PCImplementation
  @ClsQName: ManakaiPerlCodeImplementation

  @enDesc:
    The class that provides factory methods. 

  @ClsISA: DOMFeature|ManakaiMinimumImplementation||ManakaiDOM|ManakaiDOMLatest
  @ClsISA:
    dx:ManakaiDefaultExceptionHandler::ManakaiDOM:Perl


  @DOMMetaImpl:provideFeature: CoreFeature10

  @Method:
    @@Name: createPerlFile
    @@enDesc:
      Creates a Perl code file. 
    @@Return:
      @@@Type: PerlFile
      @@@caType: ManakaiPerlFile
      @@@enDesc: A newly created Perl source file object. 
      @@@PerlDef:
        $r = <ClassM::ManakaiPerlFile.newObject>;
        __CODE{ManakaiNode:getNewReference::
                 $object => $r, $ref => $r,
                 $class => {<ClassName::ManakaiPerlFile>}}__;

  @Method:
    @@Name: createPerlPackage
    @@enDesc:
      Creates a new package scope block. 
    @@Param:
      @@@Name: packageName
      @@@Type:
        Perl:package-name::ManakaiDOM:all
      @@@enDesc:
        The fully-qualified name of the package to create. 
    @@Return:
      @@@Type: PerlPackage
      @@@caType: ManakaiPerlPackageScope
      @@@enDesc:
        The newly created package scope object. 
      @@@PerlDef:
        $r = <ClassM::ManakaiPerlPackageScope.newObject>;
        $r->{<H::pc:packageName>} = $packageName;
        __CODE{ManakaiNode:getNewReference::
                 $object => $r, $ref => $r,
                 $class => {<ClassName::ManakaiPerlPackageScope>}}__;

  @IntMethod:
    @@ForCheck: ManakaiDOM|ForClass
    @@Name: perlComment
    @@ManakaiDOM:isStatic:1
    @@enDesc:
      Generates a Perl comment string. 
    @@Param:
      @@@Name: str
      @@@Type: 
        DISLang:String::ManakaiDOM:all
      @@@enDesc:
        A comment text. 
    @@Return:
      @@@Type:
        DISLang:String::ManakaiDOM:all
      @@@enDesc:
        A Perl comment string.
      @@@PerlDef:
        $r = $str;
        $r =~ s/\n/\n## /g;
        $r =~ s/\n## $/\n/s;
        $r .= "\n" unless $r =~ /\n$/;
        $r = q<## > . $r;

  @IntMethod:
    @@ForCheck: ManakaiDOM|ForClass
    @@Name: rfc3339DateTime
    @@ManakaiDOM:isStatic:1
    @@enDesc:
      Returns RFC 3339 <CODE::date-time> representation of a date. 
    @@Param:
      @@@Name: perlDate
      @@@Type:
        DOMMain:unsigned-long::ManakaiDOM:all
      @@@enDesc:
        A Perl representation of date. 
    @@Return:
      @@@Type:
        DISLang:String::ManakaiDOM:all
      @@@enDesc:
        RFC 3339 date string. 
      @@@PerlDef:
        my @time = gmtime $perlDate;
        $r = sprintf q<%04d-%02d-%02dT%02d:%02d:%02d+00:00>,
                     $time[5] + 1900, $time[4] + 1, @time[3,2,1,0];

  @IntMethod:
    @@ForCheck: ManakaiDOM|ForClass
    @@Name: versionDateTime
    @@ManakaiDOM:isStatic:1
    @@enDesc:
      Returns date for version. 
    @@Param:
      @@@Name: perlDate
      @@@Type:
        DOMMain:unsigned-long::ManakaiDOM:all
      @@@enDesc:
        A Perl representation of date. 
    @@Return:
      @@@Type:
        DISLang:String::ManakaiDOM:all
      @@@enDesc:
        A Perl number literal. 
      @@@PerlDef:
        my @time = gmtime $perlDate;
        $r = sprintf q<%04d%02d%02d.%02d%02d>,
                     $time[5] + 1900, $time[4] + 1, @time[3,2,1];
  
  @Method:
    @@Name: perlLiteral
    @@enDesc:
      Perl code representation. 
    @@Param:
      @@@Name: val
      @@@Type: 
        DOMMain:any::ManakaiDOM:all
      @@@enDesc:
        A Perl value. 
    @@Return:
      @@@Type:
        DISLang:String::ManakaiDOM:all
      @@@enDesc:
        A Perl lexical representation of <P::val>. 
      @@@PerlDef:
        unless (defined $val) {
          $r = q<undef>;
        } elsif (ref $val eq 'ARRAY') {
          __DEEP{
            $r = q<[> . <ClassM::ManakaiPerlCodeImplementation
                                            .perlList> ($val) . q<]>;
          }__;
        } elsif (ref $val eq 'HASH') {
          __DEEP{
            $r = q<{>
               . <ClassM::ManakaiPerlCodeImplementation.perlList>
                   ([map {$_ => $val->{$_}} sort {$a cmp $b} keys %$val])
               . q<}>;
          }__;
        } else {
          $val =~ s/(['\\])/\\$1/g;
          $r = q<'> . $val . q<'>;
        }

  @Method:
    @@Name: perlList
    @@enDesc:
      Perl code representation of a list. 
    @@Param:
      @@@Name: val
      @@@Type: 
        Perl:ARRAY::ManakaiDOM:all
      @@@enDesc:
        A Perl array reference. 
    @@Return:
      @@@Type:
        DISLang:String::ManakaiDOM:all
      @@@enDesc:
        A Perl lexical representation of <CODE::@$val>. 
      @@@PerlDef:
        __DEEP{
          $r = join (q<, >, map {<ClassM::ManakaiPerlCodeImplementation
                                              .perlLiteral> ($_)} @{$val});
        }__;

  @Method:
    @@Name: createPerlSub
    @@enDesc:
      Creates a new <Class::ManakaiPerlSub> object. 
    @@Param:
      @@@Name: subName
      @@@Type:
        DISLang:String::ManakaiDOM:all
      @@@enDesc:
        The name of the subroutine to create.
      @@@nullCase:
        @@@@enDesc:
          The subroutine created has no name. 
    @@Return:
      @@@Type: PerlSub
      @@@caType: ManakaiPerlSub
      @@@enDesc: 
        Newly created Perl subroutine object. 
      @@@PerlDef:
        __DEEP{
          $r = <ClassM::ManakaiPerlSub.newObject>;
          __CODE{ManakaiNode:getNewReference::
                   $object => $r, $ref => $r,
                   $class => {<ClassName::ManakaiPerlSub>}}__;
          $r-><AS::ManakaiPerlSub.localName> ($subName) if defined $subName;
        }__;

  @Method:
    @@Name: createPerlUnparsedCode
    @@enDesc:
      Creates a new <Class::ManakaiPerlUnparsedCode> object. 
    @@Param:
      @@@Name: codeArg
      @@@Type:
        lang:Perl::ManakaiDOM:all
      @@@enDesc:
        The code fragment. 
      @@@nullCase:
        @@@@enDesc:
          The fragment initially has no code. 
    @@Return:
      @@@Type: PerlUnparsedCode
      @@@caType: ManakaiPerlUnparsedCode
      @@@enDesc: 
        Newly created Perl code object. 
      @@@PerlDef:
        __DEEP{
          $r = <ClassM::ManakaiPerlUnparsedCode.newObject>;
          __CODE{ManakaiNode:getNewReference::
                   $object => $r, $ref => $r,
                   $class => {<ClassName::ManakaiPerlUnparsedCode>}}__;
          $r-><AS::ManakaiPerlUnparsedCode.code> ($codeArg) if defined $codeArg;
        }__;

  @Method:
    @@Name: createPerlInlineContainer
    @@enDesc:
      Creates a new <Class::ManakaiPerlInlineContainer> object. 
    @@Return:
      @@@Type: PerlCodeInlines
      @@@caType: ManakaiPerlInlineContainer
      @@@enDesc: 
        Newly created Perl code object. 
      @@@PerlDef:
        __DEEP{
          $r = <ClassM::ManakaiPerlInlineContainer.newObject>;
          __CODE{ManakaiNode:getNewReference::
                   $object => $r, $ref => $r,
                   $class => {<ClassName::ManakaiPerlInlineContainer>}}__;
        }__;

  @Method:
    @@Name: createPerlInlineUnparsedCode
    @@enDesc:
      Creates a new <Class::ManakaiPerlInlineUnparsedCode> object. 
    @@Param:
      @@@Name: codeArg
      @@@Type:
        lang:Perl::ManakaiDOM:all
      @@@enDesc:
        The code fragment. 
      @@@nullCase:
        @@@@enDesc:
          The fragment initially has no code. 
    @@Return:
      @@@Type: PerlInlineUnparsedCode
      @@@caType: ManakaiPerlInlineUnparsedCode
      @@@enDesc: 
        Newly created Perl code object. 
      @@@PerlDef:
        __DEEP{
          $r = <ClassM::ManakaiPerlInlineUnparsedCode.newObject>;
          __CODE{ManakaiNode:getNewReference::
                   $object => $r, $ref => $r,
                   $class => {<ClassName::ManakaiPerlInlineUnparsedCode>}}__;
          $r-><AS::ManakaiPerlInlineUnparsedCode.code> ($codeArg)
            if defined $codeArg;
        }__;

  @Method:
    @@Name: createPerlBare
    @@enDesc:
      Creates a new <Class::ManakaiPerlBare> object. 
    @@Param:
      @@@Name: codeArg
      @@@Type:
        lang:Perl::ManakaiDOM:all
      @@@enDesc:
        The code fragment. 
    @@Return:
      @@@Type: PerlTokens
      @@@caType: ManakaiPerlBare
      @@@enDesc: 
        Newly created Perl code object. 
      @@@PerlDef:
        __DEEP{
          $r = <ClassM::ManakaiPerlBare.newObject>;
          __CODE{ManakaiNode:getNewReference::
                   $object => $r, $ref => $r,
                   $class => {<ClassName::ManakaiPerlBare>}}__;
          $r-><AS::ManakaiPerlBare.code> ($codeArg);
        }__;

  @Method:
    @@Name: createPerlAtom
    @@enDesc:
      Creates a new <Class::ManakaiPerlAtom> object. 
    @@Param:
      @@@Name: codeArg
      @@@Type:
        lang:Perl::ManakaiDOM:all
      @@@enDesc:
        The code fragment. 
    @@Return:
      @@@Type: PerlAtom
      @@@caType: ManakaiPerlAtom
      @@@enDesc: 
        Newly created Perl code object. 
      @@@PerlDef:
        __DEEP{
          $r = <ClassM::ManakaiPerlAtom.newObject>;
          __CODE{ManakaiNode:getNewReference::
                   $object => $r, $ref => $r,
                   $class => {<ClassName::ManakaiPerlAtom>}}__;
          $r-><AS::ManakaiPerlBare.code> ($codeArg);
        }__;

  @Method:
    @@Name: createPerlStringLiteral
    @@enDesc:
      Creates a new <Class::ManakaiPerlStringLiteral> object. 
    @@Param:
      @@@Name: stringArg
      @@@Type:
        DISLang:String::ManakaiDOM:all
      @@@enDesc: A string.
    @@Return:
      @@@Type: PerlStringLiteral
      @@@caType: ManakaiPerlStringLiteral
      @@@enDesc: 
        Newly created Perl code object. 
      @@@PerlDef:
        __DEEP{
          $r = <ClassM::ManakaiPerlStringLiteral.newObject>;
          __CODE{ManakaiNode:getNewReference::
                   $object => $r, $ref => $r,
                   $class => {<ClassName::ManakaiPerlStringLiteral>}}__;
          $r-><AS::ManakaiPerlStringLiteral.data> ($stringArg);
        }__;

  @Method:
    @@Name: createPerlVariable
    @@enDesc:
      Creates a new <Class::ManakaiPerlVariable> object. 
    @@Param:
      @@@Name: variableType
      @@@Type:
        DISLang:String::ManakaiDOM:all
      @@@enDesc:
        Variable prefix.
      @@@nullCase:
        @@@@enDesc:
          If the <P::packageName> is <DOM::null>, then 
          the <P::variableType> is detected by the prefix of
          <P::localName>.  Otherwise, it is an unprefixed variable
          such as file handle.
    @@Param:
      @@@Name: packageName
      @@@Type:
        Perl:package-name::ManakaiDOM:all
      @@@enDesc:
        Package name.
      @@@nullCase:
        @@@@enDesc:
          The variable belongs to the current package or a 
          lexical-scoped variable.
    @@Param:
      @@@Name: localName
      @@@Type:
        DISLang:String::ManakaiDOM:all
      @@@enDesc:
        Variable name.  If both <P::variableType> and <P::packageName>
        is <DOM::null>, the <P::localName> value may be prefixed
        by any possible <P::variableType> value.
    @@Return:
      @@@Type: PerlVariable
      @@@caType: ManakaiPerlVariable
      @@@enDesc: 
        Newly created Perl variable object. 
      @@@PerlDef:
        __DEEP{
          $r = <ClassM::ManakaiPerlVariable.newObject>;
          __CODE{ManakaiNode:getNewReference::
                   $object => $r, $ref => $r,
                   $class => {<ClassName::ManakaiPerlVariable>}}__;
          if (not $variableType and not $packageName and
              $localName =~ s/^(\\?[\$\@%&*])//) {
            $variableType = $1;
          }
          $r-><AS::ManakaiPerlVariable.variableType> ($variableType);
          $r-><AS::ManakaiPerlVariable.packageName> ($packageName);
          $r-><AS::ManakaiPerlVariable.localName> ($localName);
        }__;

  @Method:
    @@Name: createPerlBlock
    @@enDesc:
      Creates a new <Class::ManakaiPerlBlock> object. 
    @@Return:
      @@@Type: PerlBlock
      @@@caType: ManakaiPerlBlock
      @@@enDesc: 
        Newly created Perl code object. 
      @@@PerlDef:
        __DEEP{
          $r = <ClassM::ManakaiPerlBlock.newObject>;
          __CODE{ManakaiNode:getNewReference::
                   $object => $r, $ref => $r,
                   $class => {<ClassName::ManakaiPerlBlock>}}__;
        }__;

  @Method:
    @@Name: createPerlBlockContainer
    @@enDesc:
      Creates a new <Class::ManakaiPerlBlockContainer> object. 
    @@Return:
      @@@Type: PerlCodeBlocks
      @@@caType: ManakaiPerlBlockContainer
      @@@enDesc: 
        Newly created Perl code object. 
      @@@PerlDef:
        __DEEP{
          $r = <ClassM::ManakaiPerlBlockContainer.newObject>;
          __CODE{ManakaiNode:getNewReference::
                   $object => $r, $ref => $r,
                   $class => {<ClassName::ManakaiPerlBlockContainer>}}__;
        }__;

  @Method:
    @@Name: createPerlStatement
    @@enDesc:
      Creates a new Perl statement.
    @@Param:
      @@@Name: codeArg
      @@@Type:
        lang:Perl::ManakaiDOM:all
      @@@enDesc:
        A Perl statement without terminating <Perl::;>.
      @@@nullCase:
        @@@@enDesc:
          No initial content.
    @@Return:
      @@@Type: PerlStatement
      @@@caType: ManakaiPerlStatement
      @@@enDesc:
        The newly created Perl code object. 
      @@@PerlDef:
        $r = <ClassM::ManakaiPerlStatement.newObject>;
        __CODE{ManakaiNode:getNewReference::
          $object => $r, $ref => $r,
          $class =>{<ClassName::ManakaiPerlStatement>},
        }__;
        if (defined $codeArg) {
          __DEEP{
            $r-><M::ManakaiPerlAnyContainer.appendBare> ($codeArg);
          }__;
        }

  @Method:
    @@Name: createPerlIf
    @@enDesc:
      Creates a <Class::ManakaiPerlIf> object. 
    @@Param:
      @@@Name: conditionArg
      @@@Type: PerlCode
      @@@caType: ManakaiPerlCodeFragment
      @@@enDesc:
        Conditoon code fragment object.
    @@Param:
      @@@Name: trueArg
      @@@Type: PerlCode
      @@@caType: ManakaiPerlCodeFragment
      @@@enDesc:
        A true code fragment object. 
      @@@nullCase:
        @@@@enDesc: No true code.
    @@Param:
      @@@Name: falseArg
      @@@Type: PerlCode
      @@@caType: ManakaiPerlCodeFragment
      @@@enDesc:
        A false code fragment object. 
      @@@nullCase:
        @@@@enDesc: No false code.
    @@Return:
      @@@Type: PerlIf
      @@@caType: ManakaiPerlIf
      @@@RaiseException:
        @@@@@:BAD_CHILD_ERR
        @@@@enDesc:
          An attempt is made to append a child
          that is not valid type.
      @@@RaiseException:
        @@@@@:IN_USE_NODE_ERR
        @@@@enDesc:
          An attempt is made to append a node that is 
          already used elsewhere. 
      @@@PerlDef:
        for my $arg ([conditionArg => $conditionArg]) {
          if ({
            atom => 1, bare => 1, incontainer => 1, assign => true,
            inunparsed => 1, variable => 1, string => true,
          }->{$arg->[1]->{<H::mn:node>}->{<H::pc:nodeType>}}) {
            if ($arg->[1]->{<H::mn:node>}->{<H::pc:parent>}) {
              __EXCEPTION{IN_USE_NODE_ERR::
                pc:childNode => {$arg->[1]},
                MDOMX:param-name => {$arg->[0]},
              }__;
            }
          } else {
            __EXCEPTION{BAD_CHILD_ERR::
              pc:parentNode => {$self},
              pc:childNode => {$arg->[1]},
              MDOMX:param-name => {$arg->[0]},
            }__;
          }
        } # c

        for my $arg ([trueArg => $trueArg],
                     [falseArg => $falseArg]) {
          next unless $arg->[1];
          if ({
                blockcontainer => true,
              }->{$arg->[1]->{<H::mn:node>}->{<H::pc:nodeType>}}) {
            if ($arg->[1]->{<H::mn:node>}->{<H::pc:parent>}) {
              __EXCEPTION{IN_USE_NODE_ERR::
                pc:childNode => {$arg->[1]},
                MDOMX:param-name => {$arg->[0]},
              }__;
            }
          } else {
            __EXCEPTION{BAD_CHILD_ERR::
              pc:parentNode => {$self},
              pc:childNode => {$arg->[1]},
              MDOMX:param-name => {$arg->[0]},
            }__;
          }
        } # t/f

        my $assign = <ClassM::ManakaiPerlIf.newObject>;
        $assign->{<H::pc:condition>} = $conditionArg->{<H::mn:node>};
        $assign->{<H::pc:true>} = $trueArg->{<H::mn:node>} if $trueArg;
        $assign->{<H::pc:false>} = $falseArg->{<H::mn:node>} if $falseArg;
        $assign-><M::MNodeObject.importTree> ($_)
           for (grep {$_}
                  $assign->{<H::pc:condition>}, $assign->{<H::pc:true>},
                  $assign->{<H::pc:false>});
        $conditionArg->{<H::mn:node>}->{<H::pc:parent>} = $assign;
        $trueArg->{<H::mn:node>}->{<H::pc:parent>} = $assign if $trueArg;
        $falseArg->{<H::mn:node>}->{<H::pc:parent>} = $assign if $falseArg;
        if (defined wantarray) {
          __CODE{ManakaiNode:getNewReference::
            $object => $assign, $ref => $r,
            $class =>{<ClassName::ManakaiPerlIf>},
          }__;
        }
##PCImplementation

ResourceDef:
  @QName: MNodeObject
  @AliasFor:
    ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl
  @For: ManakaiDOM|Perl

PropDef:
  @QName: code
  @enDesc: Perl code. 

PropDef:
  @QName: sourceFile
  @enDesc:
    Source file. 

PropDef:
  @QName: sourceLine
  @enDesc:
    Source line number. 

PropDef:
  @QName: currentSourceFile
  @enDesc:
    <QUOTE::Current> source file. 

PropDef:
  @QName: currentSourceLine
  @enDesc:
    <QUOTE::Current> source line number. 

PropDef:
  @QName: prototype
  @enDesc:
    Prototype of subroutine.

PropDef:
  @QName: parent
  @enDesc:
    Higher-level object. 

PropDef:
  @QName: sub
  @enDesc:
    Perl subroutines. 

PropDef:
  @QName: packageName
  @Type:
    Perl:package-name::ManakaiDOM:all
  @enDesc:
    The fully qualified names of packages. 

PropDef:
  @QName: childNodes
  @enDesc:
    Child code fragments. 

PropDef:
  @QName: localName
  @enDesc:
    Scoped names.

## -- Exceptions

ResourceDef:
  @rdf:type:
    @@@: dis|MultipleResource
    @@ForCheck: !ManakaiDOM|ForIF !ManakaiDOM|ForClass
  @resourceFor: ManakaiDOM|ForIF
  @resourceFor: ManakaiDOM|ForClass

  @For: ManakaiDOM|Perl

  @rdf:type:
    @@@: ManakaiDOM|ExceptionIF
    @@ForCheck: ManakaiDOM|ForIF

  @rdf:type:
    @@@: ManakaiDOM|ExceptionClass
    @@ForCheck: ManakaiDOM|ForClass

  @Implement:
    @@@: ||ManakaiDOM|Perl||ManakaiDOM|ForIF
    @@ContentType: DISCore|TFPQNames
    @@ForCheck: ManakaiDOM|ForClass

  @DOMMain:implementFeature: CoreFeature10

  @Implement:
    @@@: DOMMain|ManakaiDOMExceptionIF||ManakaiDOM|Perl
    @@ForCheck: ManakaiDOM|ForClass

  @ISA:
    @@@: ManakaiDOM|ManakaiDOMException||ManakaiDOM|Perl
    @@ForCheck: ManakaiDOM|ForClass

  @IFQName: PCException
  @ClsQName: ManakaiPerlCodeException

  @enDesc:
    Exceptions for the <Module::Util:PerlCode> module.

  @ResourceDef:
    @@rdf:type: ManakaiDOM|ConstGroup

    @@IFQName: PCExceptionCode
    @@ClsQName: ManakaiPerlCodeExceptionCode
    @@plCName: PCExceptionCode

    @@enDesc:
      Exception codes for <IF::PCException>. 

    @@Type: DOMMain|unsigned-short||ManakaiDOM|all
    @@rdfs:subClassOf: DOMMain|unsigned-short||ManakaiDOM|all

    @@XConstDef:
      @@@Name: HIERARCHY_REQUEST_ERR
      @@@Value:
        @@@@@:3
        @@@@ContentType: DISCore|Integer
      @@@enDesc:
        An attempt is made to break the hierarchy. 
      @@@XSubTypeDef:
        @@@@QName: BAD_CHILD_ERR
        @@@@enDesc:
          An attempt is made to append a node as a child whose type 
          is not allowed. 
        @@@@XParam:
          @@@@@QName: childNode
          @@@@@enDesc:
            The node attempted to append. 
        @@@@XParam:
          @@@@@QName: parentNode
          @@@@@enDesc:
            The node to whose child list an attempt to append is made. 
      @@@XSubTypeDef:
        @@@@QName: IN_USE_NODE_ERR
        @@@@enDesc:
          An attempt is made to append a node that has already been used
          elsewhere. 
        @@@@XParam:
          @@@@@QName: childNode
          @@@@@enDesc:
            The node attempted to append. 
        @@@@XParam:
          @@@@@QName: parentNode
          @@@@@enDesc:
            The parent node of the <XP::childNode>. 
    @@XConstDef:
      @@@Name: NOT_SUPPORTED_ERR
      @@@Value:
        @@@@@:9
        @@@@ContentType: DISCore|Integer
      @@@enDesc:
        An attempt is made to do something the implementation does not support. 
      @@@XSubTypeDef:
        @@@@QName: UNSUPPORTED_OPERATOR_ERR
        @@@@enDesc:
          The implementation does not support the specified operator. 
        @@@@XParam:
          @@@@@QName: operator
          @@@@@enDesc:
            The operator that is not supported. 
        @@@@enMufDef:
          Operator "%p (name => {<Q::pc:operator>});" is not supported
##PCException

ElementTypeBinding:
  @Name: XConstDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:Const

ElementTypeBinding:
  @Name: XSubTypeDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:ExceptionOrWarningSubType
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: XParam
  @ElementType:
    ManakaiDOM:exceptionOrWarningParameter

ElementTypeBinding:
  @Name: XParamDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: 
      DOMMain:XWParameter
    @@For: =ManakaiDOM|all

ElementTypeBinding:
  @Name: enMufDef
  @ElementType:
    dis:Def
  @ShadowContent:
    @@ContentType:
      lang:muf
    @@lang:en

ElementTypeBinding:
  @Name: Method
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:Method

ElementTypeBinding:
  @Name: ToStringMethod
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:Method
    @@Operator:
      @@@@:
        DISPerl:AsStringMethod
      @@@ContentType:
        dis:TypeQName
    @@Description:
      @@@lang:en
      @@@@:
        Returns the textual Perl source code representation of this object. 

ElementTypeBinding:
  @Name: NumValMethod
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:Method
    @@Operator:
      @@@@: 0+
      @@@ContentType:
        lang:Perl
    @@Description:
      @@@lang:en
      @@@@:
        Returns the numeric value of this object.

ElementTypeBinding:
  @Name: IntCloneMethod
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:Method
    @@Name: makeCloneObject
    @@Description:
      @@@lang:en
      @@@@:
        Returns the node object of a deep clone of a node object.
    @@ManakaiDOM:isStatic:1
    @@ManakaiDOM:isForInternal:1
    @@ForCheck: ManakaiDOM|ForClass
    @@ResourceDef:
      @@@rdf:type:
        DISLang:MethodParameter
      @@@Name: nodeObject
      @@@Type: 
        ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl
      @@@Description:
        @@@@lang:en
        @@@@@: Node object to copy.
  @ShadowSibling:
    @@ResourceDef:
      @@@rdf:type:
        DISLang:Method
      @@@Operator:
        @@@@@:
          DISPerl:CloneMethod
        @@@@ContentType:
          dis:TypeQName
      @@@Description:
        @@@@lang:en
        @@@@@:
          Generates a deep clone of this node and returns it.
      @@@ResourceDef:
        @@@@rdf:type:
          DISLang:MethodReturn
        @@@@Type: ManakaiPerlCodeFragment
        @@@@Description:
          @@@@@lang:en
          @@@@@@: 
            The newly created clone node.
            \
            {NOTE:: The <A::.parentNode> attribute of the clone
                    is set to <DOM::null>.
            \
            }
        @@@@Def:
          @@@@@ForCheck: ManakaiDOM|ForClass
          @@@@@ContentType:
            lang:Perl
          @@@@@@:
                            ## NOTE: Method name directly written
            my $ro = $self->_make_clone_object ($self->{<H::mn:node>});
            $ro-><M::ManakaiDOM:ManakaiDOMNodeObject
                   ::ManakaiDOM:Perl.changeTreeID>
                                 (<Code::ManakaiDOM:generateUniqueID
                                       ::ManakaiDOM:Perl>);
            $r = <ClassM::ManakaiPerlCodeFragment.getNodeReference> ($ro);

ElementTypeBinding:
  @Name: IntMethod
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:Method
    @@ManakaiDOM:isForInternal:1

ElementTypeBinding:
  @Name: Attr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:Attribute

ElementTypeBinding:
  @Name: Return
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:MethodReturn

ElementTypeBinding:
  @Name: Get
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:AttributeGet

ElementTypeBinding:
  @Name: Set
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:AttributeSet

ElementTypeBinding:
  @Name: Param
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:MethodParameter

ElementTypeBinding:
  @Name: plCName
  @ElementType:
    DISPerl:exportTagName

ElementTypeBinding:
  @Name: PerlDef
  @ElementType:
    dis:Def
  @ShadowContent:
    @@ContentType:
      lang:Perl
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: PerlCDef
  @ElementType:
    dis:Def
  @ShadowContent:
    @@ContentType:
      lang:Perl

ElementTypeBinding:
  @Name: disDef
  @ElementType:
    dis:Def
  @ShadowContent:
    @@ContentType:
      lang:dis
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: InCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:InCase

ElementTypeBinding:
  @Name: nullCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:InCase
    @@Value:
      @@@is-null:1

ElementTypeBinding:
  @Name: TrueCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:InCase
    @@Value:
      @@@@:1
      @@@ContentType: DISCore|Boolean
    @@Type:
      DOMMain:boolean::ManakaiDOM:all


ElementTypeBinding:
  @Name: FalseCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:InCase
    @@Value:
      @@@@:0
      @@@ContentType: DISCore|Boolean
    @@Type:
      DOMMain:boolean::ManakaiDOM:all

ElementTypeBinding:
  @Name: enDesc
  @ElementType:
    dis:Description
  @ShadowContent:
    @@lang:en

ElementTypeBinding:
  @Name: PropDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      rdf:Property
    @@For: =ManakaiDOM|all

ElementTypeBinding:
  @Name: NamedParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:MethodParameter
    @@DISPerl:isNamedParameter:1

