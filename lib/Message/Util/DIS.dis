Module:
  @QName:
    Util:DIS
  @FullName:
    @@lang: en
    @@@:
      <QUOTE::DIS> Object Model
  @Namespace:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS#
  
  @Description:
    @@lang:en
    @@@:
      This module provides an object model for <QUITE::dis> document format.  

  @Author:
    @@FullName: Wakaba
    @@Mail: w@suika.fam.cx
  @License:
    @@@:
      license:Perl+MPL
    @@Original:
      @@@FullName:
        manakai <CODE::lib/manakai/dis.pl>
      @@@Year:2004
      @@@Author:
        @@@@FullName:Wakaba
        @@@@Mail:w@suika.fam.cx
  @Date:
    @@@:
      $Date: 2005/03/06 11:12:42 $
    @@ContentType:
      dis:Date.RCS
  
  @Require:
    @@Module:
      @@@Name: SuikaWikiConfig21
      @@@QName:
        Markup:SuikaWikiConfig21
      @@@WithFor:
        swcfg21:ForLatest
    @@Module:
      @@@Name: DIS
      @@@WithFor: 
        DIS:ForLatest
    @@Module:
      @@@Name: PerlCode
      @@@WithFor:
        ManakaiDOM:Perl

  @DefaultFor: 
    DIS:ForLatest

Namespace:
  @DIS:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS#
  @dis:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#dis--
  @dis2pm:
    http://suika.fam.cx/~wakaba/archive/2004/11/8/dis2pm#
  @DISlib:
    http://suika.fam.cx/~wakaba/archive/2004/dis/
  @DOMCore:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#
  @DOMLS:
    http://suika.fam.cx/~wakaba/archive/2004/dom/ls#
  @DOMMain:
    http://suika.fam.cx/~wakaba/archive/2004/dom/main#
  @infoset:
    http://www.w3.org/2001/04/infoset#
  @lang:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#
  @license:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/license#
  @ManakaiDOM:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#
  @Markup:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Markup#
  @MDOMX:
    http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#
  @owl:
    http://www.w3.org/2002/07/owl#
  @Perl:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#Perl--
  @rdf:
    http://www.w3.org/1999/02/22-rdf-syntax-ns#
  @rdfs:
    http://www.w3.org/2000/01/rdf-schema#
  @swcfg21:
    http://suika.fam.cx/~wakaba/archive/2005/swcfg21#
  @TreeCore:\
  @Util:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/

## -- "For" definitions

ForDef:
  @QName: 
    DIS:ForLatest
  @Description:
    @@lang:en
    @@@:
      For latest version of the <Module::Util:DIS> module implementation
  @ISA:
    ManakaiDOM:Perl

## -- Features

ElementTypeBinding:
  @Name: FeatureDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DOMMain:DOMFeature
    @@AliasFor:
      @@@@:
        ::ManakaiDOM:all
      @@@For:
        !=ManakaiDOM:all

ElementTypeBinding:
  @Name: FeatureVerDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DOMMain:DOMFeature

ElementTypeBinding:
  @Name: featureQName
  @ElementType:
    dis:AppName
  @ShadowContent:
    @@ContentType:
      dis:TypeQName

FeatureDef:
  @QName: Core
  @FeatureVerDef:
    @@QName: CoreFeature10
    @@Version: 1.0
    @@ISA: Core
    @@FullName:
      @@@lang:en
      @@@@:
        The <QUOTE::dis> object model, version 1.0
    @@Description:
      @@@lang:en
      @@@@:
        The <QUOTE::dis> object model, version 1.0. 
    @@DOMMain:requireFeature: 
      swcfg21:CoreFeature21

## -- SuikaWikiConfig/2.1 extended classes

ClsDef:
  @ClsQName: ManakaiDISImplementation
  @ClsISA:
    swcfg21:ManakaiSWCFGImplementation::swcfg21:ForLatest
  @Description:
    @@lang:en
    @@@:
      A <QUOTE::dis> implementation object. 

  @Method:
    @@Name: createDISDocument
    @@Description:
      @@@lang:en
      @@@@:
        Creates an empty <Class::ManakaiDISDocument> object. 
    @@Return:
      @@@Type:ManakaiDISDocument
      @@@Description:
        @@@@lang:en
        @@@@@:
          The newly created <QUOTE::dis> document object.
      @@@PerlDef:
        $r = $self-><M::swcfg21:SWCFGImplementation::swcfg21:ForLatest
                                              .createSWCFGDocument>;
        $r-><AS::swcfg21:SWCFGDocument::swcfg21:ForLatest
                                        .defaultElementTypeNamespaceURI>
                    (<Q::dis:>);

  @Method:
    @@Name: createDISParser
    @@Description:
      @@@lang:en
      @@@@:
        Creates a <Class::ManakaiDISParser> object. 
    @@Return:
      @@@Type: ManakaiDISParser
      @@@Description:
        @@@@lang:en
        @@@@@: 
          A newly created <QUOTE::dis> parser. 
      @@@PerlDef:
        $r = bless $self-><M::swcfg21:SWCFGImplementation::swcfg21:ForLatest
                                           .createSWCFGParser>,
                   <ClassName::ManakaiDISParser>;

  @Method:
    @@Name: createDISDatabase
    @@Description:
      @@@lang:en
      @@@@:
        Creates a new <QUOTE::dis> database.
    @@Return:
      @@@Type:ManakaiDISDatabase
      @@@Description:
        @@@@lang:en
        @@@@@:
          A newly created <QUOTE::dis> parser.
      @@@PerlDef:
        $r = bless {
          forDef => {
            <Q::ManakaiDOM:all> => bless ({
              uri => <Q::ManakaiDOM:all>,
              isa => {<Q::ManakaiDOM:all> => 1},
              revISA => {},
            }, <ClassName::ManakaiDISForDefinition>),
          },
          resDef => {},
          modDef => {},
          seq => 0,
        }, <ClassName::ManakaiDISDatabase>;

  @Method:
    @@Name: tfurisToURI
    @@Description:
      @@@lang:en
      @@@@:
        Converts a pair of name URI reference and <QUOTE::for> URI reference 
        into a <TYPE::dis:TFQNames>-expanded URI reference. 
    @@Param:
      @@@Name: typeURI
      @@@Type: NameURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          A URI reference to identify a resource. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            Equivalent to <Q::DOMMain:any> (for historical reason). 
    @@Param:
      @@@Name: forURI
      @@@Type: ForURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          A <QUOTE::for> URI reference. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            Equivalent to <QUOTE::for all>, i.e. <Q::ManakaiDOM:all>. 
    @@Return:
      @@@Type: 
        DISCore:TFURI::ManakaiDOM:all
      @@@Description:
        @@@@lang:en
        @@@@@:
          The <TYPE::dis:TFQNames>-expanded URI references.  
      @@@PerlDef:
        $typeURI = <Q::DOMMain:any> unless defined $typeURI;
        $forURI = <Q::ManakaiDOM:all> unless defined $forURI;
        __CODE{tfurisToURI:: $turi => $typeURI, $furi => $forURI, $uri => $r}__;

  @ResourceDef:
    @@QName: tfurisToURI
    @@rdf:type:
      dis2pm:BlockCode
    @@enDesc:
        Converts a pair of name URI reference and <QUOTE::for> URI reference 
        into a <TYPE::dis:TFQNames>-expanded URI reference. 
    @@PerlDef:      
        if ($furi eq <Q::ManakaiDOM:all>) {
          $uri = $turi;
        } else {
          ## NOTE: [RFC 3986]
          ##       fragment    := *(pchar / "/" / "?")
          ##       pchar       := unreserved / pct-encoded / sub-delims / [:@]
          ##       unreserved  := ALPHA / DIGIT / [._~-]
          ##       sub-delims  := [!$&'()*+,;=]
          ## NOTE: [XPointer Framework]
          ##       SchemeData  := *EscapedData
          ##       EscapedData := NormalChar / "^(" / "^)" / "^^"
          ##                    / "(" SchemeData ")"
          ##       NormalChar  := UnicodeChar - [()^]
          my $__turi = $turi;
          my $__furi = $furi;
          for my $__uri ($__turi, $__furi) {
            $__uri =~ s{([^0-9A-Za-z:;?=_./-])}{sprintf '%%%02X', ord $1}ge;
          }
          $uri = qq<data:,200411tf#xmlns(t=data:,200411tf%23)>.
                                qq<t:tf($__turi,$__furi)>;
        }

  @ResourceDef:
    @@QName: tfpurisToURI
    @@rdf:type:
      dis2pm:BlockCode
    @@enDesc:
        Converts a set of name URI reference and <QUOTE::for> URI reference 
        and <QUOTE::for+> URI references into a URi reference. 
    @@PerlDef:      
        if ($furi eq <Q::ManakaiDOM:all> and @{$forp} == 0) {
          $uri = $turi;
        } elsif (@{$forp}) {
          my $__turi = $turi;
          my $__furi = $furi;
          for my $__uri ($__turi, $__furi) {
            $__uri =~ s{([^0-9A-Za-z:;?=_./~!&+-])}{sprintf '%%%02X', ord $1}ge;
          }
          my @__fp;
          for my $__uri (@{$forp}) {
            my $__fpuri = $__uri;
            $__fpuri =~ s{([^0-9A-Za-z:;?=_./~!&+-])}
                         {sprintf '%%%02X', ord $1}ge;
            push @__fp, $__fpuri;
          }
          $uri = qq<data:,200411tf#xmlns(t=data:,200411tf%23)>.
                               qq<t:tfp($__turi,$__furi,>.join (',', @__fp).q<)>;
        } else {
          my $__turi = $turi;
          my $__furi = $furi;
          for my $__uri ($__turi, $__furi) {
            $__uri =~ s{([^0-9A-Za-z:;?=_./-])}{sprintf '%%%02X', ord $1}ge;
          }
          $uri = qq<data:,200411tf#xmlns(t=data:,200411tf%23)>.
                                qq<t:tf($__turi,$__furi)>;
        }

  @ResourceDef:
    @@QName: getChildResourceURI
    @@rdf:type: 
      dis2pm:BlockCode
    @@enDesc:
      Gets an anonymous URI reference of a child resource of another 
      resource. 
    @@PerlDef:
      my $__parent = $parentURI;
      my $__ln = $localName;
      for my $__uri ($__parent, $__ln) {
        $__uri =~ s{([^0-9A-Za-z:;?=_./~!&+-])}{sprintf '%%%02X', ord $1}ge;
      }
      $result = q<data:,200411tf#xmlns(t=data:,200411tf%23)>.
                              qq<t:child($__parent,$__ln)>;

  @IntMethod:
    @@Name: camelCaseToUnderscoreName
    @@enDesc:
      Converts a camelCase name to a underscored_name. 
    @@ManakaiDOM:isStatic:1
    @@Param:
      @@@Name: camelName
      @@@Type:
        DISLang:String
      @@@enDesc:
        The source name. 
    @@Return:
      @@@Type:
        DISLang:String
      @@@enDesc:
        The result name. 
      @@@PerlDef:
        $r = $camelName;
        $r =~ s/^([A-Z0-9]+)$/lc $1/ge;
        $r =~ s/([A-Z][A-Z0-9]*)$/"_".lc $1/ge;
        $r =~ s/([A-Z0-9])([A-Z0-9]*)([A-Z0-9])/$1.lc ($2)."_".lc $3/ge;
        $r =~ s/([A-Z])/"_".lc $1/ge;
        $r =~ s/(?=[0-9](?!$))/_/g;

  @Method:
    @@Name: plLoadDISDatabase
    @@enDesc:
      Loads a database from a file that was saved by 
      <M::ManakaiDISDatabase.plStore>. 
      \
      {NOTE:: <QUOTE::dis> documents restored from external file
              would have different <A::ManakaiDISDocument.implementation> 
              than this <Class::ManakaiDISImplementation>, even if 
              it has been created by this implementation
              and stored in the same session. 
      \
      }
    @@Param:
      @@@Name:fileName
      @@@Type: 
        DISLang:String
      @@@enDesc:
        An environment-dependent file name. 
    @@Return:
      @@@Type: ManakaiDISDatabase
      @@@SimpleException:
      @@@PerlDef:
        use Storable qw/retrieve/;
        local $Carp::CarpLevel = $Carp::CarpLevel + 1;
        $r = retrieve $fileName;

        ## Restores weak references
        require Scalar::Util;
        for my $doc (values %{$r->{<Q::DIS:sourceFile>}}) {
          Scalar::Util::weaken ($doc->{<Q::TreeCore:node>}->{<Q::DIS:db>});
        }
        for my $def (values %{$r->{modDef}},
                     values %{$r->{forDef}},
                     values %{$r->{resDef}}) {
          Scalar::Util::weaken ($def->{db});
        }
##DISImplementation

ElementTypeBinding:
  @Name: SimpleException
  @ElementType:
    dis:Description
  @ShadowContent:
    @@lang:en
    @@@:
      - Exception of type <PerlModule::Error::Simple>::: 
             I/O error or other error reported by <PerlModule::Storable>. 

## TODO: Formal description required for simple exception

ClsDef:
  @ClsQName: ManakaiDISParser
  @ClsISA:
    swcfg21:ManakaiSWCFGParser::swcfg21:ForLatest
  @Description:
    @@lang:en
    @@@:
      A SuikaWikiConfig/2.1 parser that returns <QUOTE::dis> object. 
  @Method:
    @@Name: parse
    @@Description:
      @@@lang:en
      @@@@:
        Parses a <QUOTE::dis> document and returns it as an object tree. 
    @@Param:
      @@@Name: input
      @@@Type:
        DOMLS:LSInput::ManakaiDOM:ManakaiDOM3
      @@@Description:
        @@@@lang:en
        @@@@@:
          The input source. 
    @@Return:
      @@@Type: ManakaiDISDocument
      @@@Description:
        @@@@lang:en
        @@@@@:
          The <QUOTE::dis> document object created from the <P::input>. 
      @@@RaiseException:
        @@@@@:
          swcfg21:SWCFG_PARSE_ERR
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The <IF::swcfg21:SWCFGParser> was unable to load the SuikaWikiConfig 
            document. 
      @@@PerlDef:
        __DEEP{
          $r = $self-><M::swcfg21:ManakaiSWCFGParser
                        ::swcfg21:ForLatest.parse> ($input);
        }__;
        if (defined $r) {
          $r = bless $r, <ClassName::ManakaiDISDocument>;
          $r-><AS::swcfg21:SWCFGDocument::swcfg21:ForLatest
                                        .defaultElementTypeNamespaceURI>
                    (<Q::dis:>);
        }
##DISParser

ClsDef:
  @ClsQName: ManakaiDISNode
  @Description:
    @@lang:en
    @@@:
      <QUOTE::dis> node objects. 
  @ImplNote:
    @@lang:en
    @@@:
      This class does not inherit 
      <Class::swcfg21:ManakaiSWCFGNode::swcfg21:ForLatest>, since 
      inheriting classes such as <Class::ManakaiDISElement> indirectly 
      inherit it. 

  @MethodRedef:
    @@Name:lookupNamespacePrefix
    @@Description:
      @@@lang:en
      @@@@:
        Looks up the namespace prefix associated to the given 
        namespace URI.  The default namespaces are ignored. 
    @@Param:
      @@@Name:namespaceURI
      @@@Type: AnyURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          The namespace URI to look for. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The <DOM::null> namespace. 
    @@NamedParam:
      @@@Name: makeNewBinding
      @@@Type: 
        DOMMain:boolean
      @@@Description:
        @@@@lang:en
        @@@@@:
          Whether a new namespace prefix should be bound when 
          no namespace URI has been associated yet. 
      @@@InCase:
        @@@@Value:true
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            New binding is made if no prefix associated. 
      @@@InCase:
        @@@@Value:false
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            Simply returns the <DOM::null> if no prefix associated. 
    @@Return:
      @@@Type:
        DISCore:NamespacePrefix::ManakaiDOM:all
      @@@Description:
        @@@@lang:en
        @@@@@:
           An associated namespace prefix.  If more than one prefix 
           are associated to the namespace URI, the returned prefix 
           is implementation dependent. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            No associated namespace prefix found. 
      @@@PerlDef:
        $r = null;
        my $od = $self-><AG::swcfg21:SWCFGNode::swcfg21:ForLatest
                                          .ownerDocument> || $self;
        my $binds = $od->{<Q::TreeCore:node>}->{<Q::swcfg21:nsBinding>};
        if (defined $namespaceURI) {
          FIND: {
            for my $prefix (keys %$binds) {
              if (defined $binds->{$prefix} and
                  $binds->{$prefix} eq $namespaceURI) {
                $r = $prefix;
                last FIND;
              }
            }

            ## From module list
            try {
              my $db = $self-><AG::ManakaiDISNode.ownerDISDocument>
                            -><AG::ManakaiDISDocument.disDatabase>;
              for my $mod_uri (keys %{$db->{modDef}}) {
                my $mod = $db-><M::ManakaiDISDatabase.getModule> ($mod_uri);
                my $mod_ln = $mod-><AG::ManakaiDISModuleDefinition.localName>;
                next if exists $binds->{$mod_ln};
                my $ns_uri = $mod-><M::ManakaiDISPropertyAccessor
                                            .getPropertyText>
                                                 (<Q::dis:Namespace>, '');
                if ($ns_uri eq $namespaceURI) {
                  $r = $mod_ln;
                  last FIND;
                }
              }
            } catch <Class::ManakaiDISException> with {
              my $err = shift;
              $err->throw
                unless $err->{<Q::MDOMX:subtype>} eq <Q::NO_DB_ASSOCIATED_ERR>;
            };

            last FIND unless $makeNewBinding;
            ## Not found
            if ($namespaceURI =~ /(\w+)$/) {
              my $prefix = $1;
              unless (exists $binds->{$prefix}) {
                $binds->{$prefix} = $namespaceURI;
                $r = $prefix;
                last FIND;
              }
            }
            my $i = 1;
            {
              unless (exists $binds->{'ns'.$i}) {
                $binds->{$r = 'ns'.$i} = $namespaceURI;
                last FIND;
              }
              $i++;
              redo;
            }
          } # FIND
        } else {  ## Null namespace
          FIND: {
            if (exists $binds->{'nu'.'ll'} and not defined $binds->{'nu'.'ll'}) {
              $r = 'nu'.'ll';
              last FIND;
            }
            for my $prefix (keys %$binds) {
              if (not defined $prefix) {
                $r = $prefix;
                last FIND;
              }
            }
            last FIND unless $makeNewBinding;
            ## Not found
            my $i = '';
            {
              unless (exists $binds->{'nu'.'ll'.$i}) {
                $binds->{$r = 'nu'.'ll'.$i} = null;
                last FIND;
              }
              $i++;
              redo;
            }
          }
        }

  @MethodRedef:
    @@Name:lookupNamespaceURI
    @@Description:
      @@@lang:en
      @@@@:
        Looks up the namespace URI associated to the given prefix. 
    @@Param:
      @@@Name:prefix
      @@@Type:
        DISCore:NamespacePrefix::ManakaiDOM:all
      @@@Description:
        @@@@lang:en
        @@@@@:
          The namespace URI to look for. 
    @@NamedParam:
      @@@Name: makeNewBinding
      @@@Type:
        DOMMain:boolean
      @@@Description:
        @@@@lang:en
        @@@@@:
          Whether a new binding should be created if no namespace URI 
          is associated with the <P::prefix> or not. 
      @@@InCase:
        @@@@Value:true
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            A new binding to the temporary namespace URI 
            exactly same as <P::prefix> is created 
            if no binding found. 
      @@@InCase:
        @@@@Value:false
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            No new binding is created if no binding found.  Note that 
            even if no association newly created, this method 
            returns the <DOM::null> value. 
    @@NamedParam:
      @@@Name: raisePrefixException
      @@@Type:
        DOMMain:boolean
      @@@enDesc:
        Whehter an exception should be thrown if <P::prefix>
        is not declared or not. 
    @@Return:
      @@@Type: AnyURI
      @@@Description:
        @@@@lang:en
        @@@@@:The associated namespace URI. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            No namespace URI is associated to the prefix or 
            the <DOM::null> namespace is associated. 
      @@@UndeclaredPrefixException:
      @@@PerlDef:
        my $od = $self-><AG::swcfg21:SWCFGNode::swcfg21:ForLatest
                                               .ownerDocument> || $self;
        my $binds = $od->{<Q::TreeCore:node>}->{<Q::swcfg21:nsBinding>};
        if (exists $binds->{$prefix}) {
          $r = $binds->{$prefix};
        } else {
          ## From module list
          FIND: {
            try {
              my $db = $self-><AG::ManakaiDISNode.ownerDISDocument>
                            -><AG::ManakaiDISDocument.disDatabase>;
              for my $mod_uri (keys %{$db->{modDef}}) {
                my $mod = $db-><M::ManakaiDISDatabase.getModule> ($mod_uri);
                if ($mod-><AG::ManakaiDISModuleDefinition.localName>
                      eq $prefix) {
                  $r = $mod-><M::ManakaiDISPropertyAccessor
                                              .getPropertyText>
                                                   (<Q::dis:Namespace>, null);
                  last FIND;
                }            
              }
            } catch <Class::ManakaiDISException> with {
              my $err = shift;
              $err->throw
                unless $err->{<Q::MDOMX:subtype>} eq <Q::NO_DB_ASSOCIATED_ERR>;
            };
            if ($makeNewBinding) {
              $r = $binds->{$prefix} = $prefix;
            } elsif ($raisePrefixException) {
              __EXCEPTION{DIS:UNDECLARED_NS_PREFIX_ERR::
                infoset:prefix => {$prefix},
                MDOMX:param-name => 'prefix',
                DIS:sourceNode => {$self},
              }__;
            } else {
              $r = null;
            }
          } # FIND
        }

  @IntMethod:
    @@Name:getNodeReference
    @@Description:
      @@@lang:en
      @@@@:
        Returns a new reference to the node object. 
    @@ManakaiDOM:isStatic:1
    @@Param:
      @@@Name:object
      @@@Type:
        ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl
      @@@Description:
        @@@@lang:en
        @@@@@:
          The node object to be referred. 
    @@Return:
      @@@Type: ManakaiDISNode
      @@@Description:
        @@@@lang:en
        @@@@@:
          A newly created reference.
      @@@PerlDef:
        my $class;
        if ($object->{<Q::swcfg21:nodeType>} eq '#element') {
          $class = <ClassName::ManakaiDISElement>;
        } elsif ($object->{<Q::swcfg21:nodeType>} eq '#comment') {
          $class = <ClassName::ManakaiDISComment>;
        } elsif ($object->{<Q::swcfg21:nodeType>} eq '#document') {
          $class = <ClassName::ManakaiDISDocument>;
        } elsif ($object->{<Q::swcfg21:nodeType>} eq '#fragment') {
          $class = <ClassName::ManakaiDISDocumentFragment>;
        } else {
          __ASSERT{DISPerl:invariant::
            msg => {qq[Node type: "$object->{<Q::swcfg21:nodeType>}" ].
                    qq[(ref: "@{[ref $object]}")]},
          }__;
        }
        $r = $object-><M::ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl
                                  .newReference> ($class);
  
  @Attr:
    @@Name:ownerDISDocument
    @@Description:
      @@@lang:en
      @@@@:
        The <QUOTE::dis> document object associated with this node. 
    @@Get:
      @@@Type:ManakaiDISDocument
      @@@Description:
        @@@@lang:en
        @@@@@:
          The document object associated with this node. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            This node is a document node. 
      @@@PerlDef:
        $r = <ClassM::ManakaiDISNode.getNodeReference>
                ($self->{<Q::TreeCore:node>}->{<Q::DOMCore:ownerDocument>})
          if $self->{<Q::TreeCore:node>}->{<Q::DOMCore:ownerDocument>};
##DISNode

ClsDef:
  @ClsQName: ManakaiDISElement
  @ClsISA: ManakaiDISNode
  @ClsISA:
    swcfg21:ManakaiSWCFGElement::swcfg21:ForLatest
  @Description:
    @@lang:en
    @@@:
      <QUOTE::dis> element node objects. 

  @Method:
    @@Name: forMatch
    @@Description:
      @@@lang:en
      @@@@:
        Tests whether this element is for a <QUOTE::for> or not. 
    @@Param:
      @@@Name: forArg
      @@@Type: ForURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          The <QUOTE::For> URI reference to test against. 
    @@Param:
      @@@Name: forpArg
      @@@Type: ForURIList
      @@@Description:
        @@@@lang:en
        @@@@@:
          The <QUOTE::For+> URI references to test against. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            No additional <QUOTE::For> URI reference. 
            Equivalent to an empty array reference. 
    @@Return:
      @@@Type:
        DOMMain:boolean
      @@@Description:
        @@@@lang:en
        @@@@@:
          Whether this element is for <P::forArg> and <P::forpArg> or not. 
      @@@UndeclaredPrefixException:
      @@@NoDBException:
      @@@PerlDef:
        $forArg = <Q::ManakaiDOM:all> unless defined $forArg;
        $forpArg ||= [];

        FORMATCH: {
          __DEEP{
            my $for_res = $self-><AG::ManakaiDISNode.ownerDISDocument>
                                   -><AG::ManakaiDISDocument.disDatabase>
                                   -><M::ManakaiDISDatabase.getFor> ($forArg);
            my $forp_res = [map {
                                  $self-><AG::ManakaiDISNode.ownerDISDocument>
                                       -><AG::ManakaiDISDocument.disDatabase>
                                       -><M::ManakaiDISDatabase.getFor> ($_)
                                } @{$forpArg}];

            my @ce = @{$self-><M::ManakaiDISElement.disAllChildElements>};
            for my $ce (@ce) {
              my $et = $ce-><AG::swcfg21:SWCFGElement::swcfg21:ForLatest
                                                      .expandedURI>;
              if ($et eq <Q::dis:ForCheck>) {
                my $fors = [split /\s+/, $ce-><AG::swcfg21:SWCFGNode
                                                 ::swcfg21:ForLatest.value>];
                FCs: for my $f (@$fors) {
                  if ($f =~ /^!=(.+)$/) {        ## -- NOT EQUAL TO
                    my $uri = $self-><AG::ManakaiDISElement.qnameToURI> ($1);
                    my $for = $self-><AG::ManakaiDISNode.ownerDISDocument>
                                   -><AG::ManakaiDISDocument.disDatabase>
                                   -><M::ManakaiDISDatabase.getFor> ($uri);
                    $for-><AG::ManakaiDISForDefinition.isReferred> ($ce);
                    for my $arg_res ($for_res, @{$forp_res}) {
                      if ($arg_res eq $for) {
                        $r = false;
                        last FORMATCH;
                      }
                    }
                  } elsif ($f =~ /^!(.+)$/) {    ## -- NOT ISA
                    my $uri = $self-><AG::ManakaiDISElement.qnameToURI> ($1);
                    my $for = $self-><AG::ManakaiDISNode.ownerDISDocument>
                                   -><AG::ManakaiDISDocument.disDatabase>
                                   -><M::ManakaiDISDatabase.getFor> ($uri);
                    $for-><AG::ManakaiDISForDefinition.isReferred> ($ce);
                    for my $arg_res ($for_res, @{$forp_res}) {
                      if ($arg_res-><M::ManakaiDISForDefinition.isaURI> ($uri)) {
                        $r = false;
                        last FORMATCH;
                      }
                    }
                  } elsif ($f =~ /^=(.+)$/) {    ## -- EQUAL TO
                    my $uri = $self-><AG::ManakaiDISElement.qnameToURI> ($1);
                    my $for = $self-><AG::ManakaiDISNode.ownerDISDocument>
                                   -><AG::ManakaiDISDocument.disDatabase>
                                   -><M::ManakaiDISDatabase.getFor> ($uri);
                    $for-><AG::ManakaiDISForDefinition.isReferred> ($ce);
                    for my $arg_res ($for_res, @{$forp_res}) {
                      if ($arg_res eq $for) {
                        next FCs;
                      }
                    }
                    $r = false;
                    last FORMATCH;
                  } else {                       ## -- ISA
                    my $uri = $self-><AG::ManakaiDISElement.qnameToURI> ($f);
                    my $for = $self-><AG::ManakaiDISNode.ownerDISDocument>
                                   -><AG::ManakaiDISDocument.disDatabase>
                                   -><M::ManakaiDISDatabase.getFor> ($uri);
                    $for-><AG::ManakaiDISForDefinition.isReferred> ($ce);
                    for my $arg_res ($for_res, @{$forp_res}) {
                      if ($arg_res-><M::ManakaiDISForDefinition.isaURI> ($uri)) {
                        next FCs;
                      }
                    }
                    $r = false;
                    last FORMATCH;
                  }
                } # FCs
              } # dis:ForCheck
            } # children

            my $has_for = false;
            for my $ce (@ce) {
              if ($ce-><AG::swcfg21:SWCFGElement::swcfg21:ForLatest
                                                     .expandedURI> eq
                  <Q::dis:For>) {
                my $fors = [split /\s+/, $ce-><AG::swcfg21:SWCFGNode
                                                 ::swcfg21:ForLatest.value>];
                my $ok = true;
                $has_for = true;
                AFOR: for my $f (@$fors) {
                  if ($f =~ /^!=(.+)$/) {         ## -- NOT EQUAL TO
                    my $uri = $self-><AG::ManakaiDISElement.qnameToURI> ($1);
                    my $for = $self-><AG::ManakaiDISNode.ownerDISDocument>
                                   -><AG::ManakaiDISDocument.disDatabase>
                                   -><M::ManakaiDISDatabase.getFor> ($uri);
                    $for-><AG::ManakaiDISForDefinition.isReferred> ($ce);
                    if ($for eq $for_res) {
                      $ok = false;
                      last AFOR;
                    }
                  } elsif ($f =~ /^!(.+)$/) {     ## -- NOT ISA
                    my $uri = $self-><AG::ManakaiDISElement.qnameToURI> ($1);
                    my $for = $self-><AG::ManakaiDISNode.ownerDISDocument>
                                   -><AG::ManakaiDISDocument.disDatabase>
                                   -><M::ManakaiDISDatabase.getFor> ($uri);
                    $for-><AG::ManakaiDISForDefinition.isReferred> ($ce);
                    if ($for_res-><M::ManakaiDISForDefinition.isaURI> ($uri)) {
                      $ok = false;
                      last AFOR;
                    }
                  } elsif ($f =~ /^=(.+)$/) {     ## -- EQUAL TO
                    my $uri = $self-><AG::ManakaiDISElement.qnameToURI> ($1);
                    my $for = $self-><AG::ManakaiDISNode.ownerDISDocument>
                                   -><AG::ManakaiDISDocument.disDatabase>
                                   -><M::ManakaiDISDatabase.getFor> ($uri);
                    $for-><AG::ManakaiDISForDefinition.isReferred> ($ce);
                    unless ($for eq $for_res) {
                      $ok = false;
                      last AFOR;
                    }
                  } else {                        ## -- ISA
                    my $uri = $self-><AG::ManakaiDISElement.qnameToURI> ($f);
                    my $for = $self-><AG::ManakaiDISNode.ownerDISDocument>
                                   -><AG::ManakaiDISDocument.disDatabase>
                                   -><M::ManakaiDISDatabase.getFor> ($uri);
                    $for-><AG::ManakaiDISForDefinition.isReferred> ($ce);
                    unless ($for_res-><M::ManakaiDISForDefinition.isaURI>($uri)){
                      $ok = false;
                      last AFOR;
                    }
                  }
                } # AFOR
                if ($ok) {
                  $r = true;
                  last FORMATCH;
                }
              } # dis:For
            } # $ce
            $r = $has_for ? false : true;
          }__;
        } # FORMATCH

  @Method:
    @@Name: mediaTypeMatch
    @@Description:
      @@@lang:en
      @@@@:
        Tests whether the content media type of this element matches to 
        a type or not. 
    @@Param:
      @@@Name: mediaType
      @@@Type: MediaTypeURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          A media type URI reference to test against. 
    @@Param:
      @@@Name: defaultMediaType
      @@@Type: MediaTypeURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          The default media type for this element. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            No default type provided.  All <P::mediaType> will match. 
    @@ForParam:
    @@ForpParam:
    @@Return:
      @@@Type:
        DOMMain:boolean
      @@@Description:
        @@@@lang:en
        @@@@@:
          Whether this element is of <P::mediaType> or not. 
      @@@PerlDef:
        if (defined $mediaType) {
          __DEEP{
            my $ctn = $self-><M::ManakaiDISElement.disGetAttribute>
                                  (<Q::dis:ContentType>, for_arg => $forArg,
                                   forp_arg => $forpArg);
            my $ct;
            $ct = $ctn-><AG::ManakaiDISElement.qnameValueURI> if $ctn;
            $ct = $defaultMediaType unless defined $ct;
            my $res = $self-><AG::ManakaiDISNode.ownerDISDocument>
                                 -><AG::ManakaiDISDocument.disDatabase>
                                 -><M::ManakaiDISDatabase.getResource> ($ct);
            $res-><AS::ManakaiDISResourceDefinition.isReferred> ($ctn or $self);
            unless ($res-><M::ManakaiDISResourceDefinition
                                               .isSubsetOfURI> ($mediaType)) {
              $r = false;
            } else {
              $r = true;
            }
          }__;
        } else {
          $r = true;
        }

  @Method:
    @@Name:mediaTypeURI
    @@enDesc:
      The URI reference of the media type of this element. 
    @@Type: MediaTypeURI
    @@NamedParam:
      @@@Name:defaultMediaType
      @@@Type:MediaTypeURI
      @@@enDesc:
        The default media type URI reference. 
      @@@nullCase:
        @@@@enDesc:
          No default is specified. 
    @@ForParam:
    @@ForpParam:
    @@Return:
      @@@enDesc:
        The media type URI reference of this element. 
      @@@nullCase:
        @@@@enDesc:
          This element has no media type information and 
          <P::defaultMediaType> parameter is not provided. 
      @@@UndeclaredPrefixException:
      @@@PerlDef:
          __DEEP{
            my $ctn = $self-><M::ManakaiDISElement.disGetAttribute>
                                (<Q::dis:ContentType>, for_arg => $forArg,
                                 forp_arg => $forpArg);
            $r = $ctn-><AG::ManakaiDISElement.qnameValueURI> if $ctn;
          }__;

  @Method:
    @@Name: prefixToURI
    @@Description:
      @@@lang:en
      @@@@:
        Converts a namespace prefix into associated URI reference. 
    @@Param:
      @@@Name: prefix
      @@@Type:
        DISCore:NamespacePrefix::ManakaiDOM:all
      @@@Description:
        @@@@lang:en
        @@@@@:
          A namespace prefix to look for. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            Returns the default namespace URI. 
    @@NodeParam:
    @@Return:
      @@@Type: AnyURI
      @@@Description:
        @@@@lang:en
        @@@@@: The URI references associated. 
      @@@UndeclaredPrefixException:
      @@@PerlDef:
        if (defined $prefix) {
          __DEEP{
            $r = $self-><M::swcfg21:SWCFGNode::swcfg21:ForLatest
                                       .lookupNamespaceURI> ($prefix);
          }__;
          unless (defined $r) {
            __EXCEPTION{UNDECLARED_NS_PREFIX_ERR::
              infoset:prefix => {$prefix},
              MDOMX:param-name => 'prefix',
              DIS:sourceNode => {$node},
            }__;
          }
        } else {  ## Default namespace
          __DEEP{
            $r = ($self-><AG::ManakaiDISNode.ownerDISDocument> || $self)
                       -><AG::ManakaiDISDocument.moduleElement>
                       -><AG::ManakaiDISModuleElement.definingNamespaceURI>;
          }__;
        }

  @Method:
    @@QName: qnameToURI
    @@Description:
      @@@lang:en
      @@@@:
        Converts a qualified name (<TYPE::dis:TypeQName>) to 
        an expanded URI reference. 
    @@Param:
      @@@Name: qname
      @@@Type:
        dis:TypeQName
      @@@Description:
        @@@@lang:en
        @@@@@:
          A qualified name. 
    @@NodeParam:
    @@Return:
      @@@Type: AnyURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          The expanded URI reference. 
      @@@UndeclaredPrefixException:
      @@@PerlDef:
        $qname =~ s/^\s+//; $qname =~ s/\s+$//;
        my ($prefix, $lname) = split /:/, $qname, 2;
        __DEEP{
          if (defined $lname) {
            $r = $self-><M::ManakaiDISElement.prefixToURI> ($prefix) . $lname;
          } else {  ## In default namespace
            $r = $self-><M::ManakaiDISElement.prefixToURI> (null) . $prefix;
          }
        }__;

  @Method:
    @@QName: qnameToPair
    @@Description:
      @@@lang:en
      @@@@:
        Converts a qualified name (<TYPE::dis:TypeQName>) to 
        a pair of namespace URI and local name. 
    @@Param:
      @@@Name: qname
      @@@Type:
        dis:TypeQName
      @@@Description:
        @@@@lang:en
        @@@@@:
          A qualified name. 
    @@NodeParam:
    @@Return:
      @@@Type:
        Perl:ARRAY
      @@@Description:
        @@@@lang:en
        @@@@@:
          A list of namespace URI and local name. 
      @@@UndeclaredPrefixException:
      @@@PerlDef:
        $qname =~ s/^\s+//; $qname =~ s/\s+$//;
        my ($prefix, $lname) = split /:/, $qname, 2;
        __DEEP{
          if (defined $lname) {
            $r = [$self-><M::ManakaiDISElement.prefixToURI> ($prefix), $lname];
          } else {  ## In default namespace
            $r = [$self-><M::ManakaiDISElement.prefixToURI> (null), $prefix];
          }
        }__;

  @Method:
    @@Name: tfqnamesToURI
    @@Description:
      @@@lang:en
      @@@@:
        Converts a <TYPE::dis:TFQNames>
        into an expanded URI reference. 
    @@Param:
      @@@Name: tfqnames
      @@@Type: 
        dis:TFQNames
      @@@Description:
        @@@@lang:en
        @@@@@:
          A <TYPE::dis:TFQNames> to identify a resource. 
    @@Param:
      @@@Name: defaultTypeURI
      @@@Type: NameURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          A name URI reference used if it is missing from 
          <P::tfqnames>. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            Equivalent to <Q::DOMMain:any>. 
    @@Param:
      @@@Name: defaultForURI
      @@@Type: ForURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          A <QUOTE::for> URI reference used if it is missing from 
          <P::tfqnames>. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            Equivalent to <QUOTE::for all>, i.e. <Q::ManakaiDOM:all>. 
    @@NodeParam:
    @@Return:
      @@@Type: 
        DISCore:TFURI::ManakaiDOM:all
      @@@Description:
        @@@@lang:en
        @@@@@:
          The <TYPE::dis:TFQNames>-expanded URI references.  
      @@@UndeclaredPrefixException:
      @@@PerlDef:
        my ($typeq, $forq) = split /\s*::\s*/, $tfqnames, 2;
        my ($typeURI, $forURI);
        if (defined $forq) {
          __DEEP{
            $typeURI = $typeq eq ''
                       ? defined $defaultTypeURI ? $defaultTypeURI
                                                 : <Q::DOMMain:any>
                       : $self-><M::ManakaiDISElement.qnameToURI> ($typeq, %opt);
          }__;
          if (length $forq) {
            $forURI = $self-><M::ManakaiDISElement.qnameToURI> ($forq, %opt);
          } else {
            $forURI = <Q::ManakaiDOM:all>;
          }
        } else {  ## "For" omitted
          __DEEP{
            $typeURI = $typeq eq ''
                       ? defined $defaultTypeURI ? $defaultTypeURI
                                                 : <Q::DOMMain:any>
                       : $self-><M::ManakaiDISElement.qnameToURI> ($typeq, %opt);
          }__;
          $forURI = defined $defaultForURI ? $defaultForURI
                                           : <Q::ManakaiDOM:all>;
        }
        __CODE{tfurisToURI:: $turi => $typeURI, $furi => $forURI, $uri => $r}__;

  @Method:
    @@Name: disGetAttribute
    @@enDesc:
      Gets an attribute node. 
    @@Param:
      @@@Name: attrName
      @@@Type: AnyURI
      @@@enDesc:
        The name expanded URI of the node to retrieve. 
    @@ForParam:
    @@ForpParam:
    @@MediaTypeParam:
    @@MediaTypeDefaultParam:
    @@Return:
      @@@Type: ManakaiDISElement
      @@@enDesc:
        The attribute (property) element node. 
      @@@nullCase:
        @@@@enDesc:
          No attribute node found. 
      @@@PerlDef:
        for my $c (@{$self-><M::ManakaiDISElement.disChildElements>
                                  (for_arg => $forArg, forp_arg => $forpArg)}) {
          if ($c-><AG::swcfg21:SWCFGElement::swcfg21:ForLatest
                                    .expandedURI> eq $attrName and
              $c-><M::ManakaiDISElement.mediaTypeMatch>
                                  ($mediaType, $defaultMediaType,
                                   for_arg => $forArg, forp_arg => $forpArg)) {
            $r = $c;
            last;
          }
        }

  @Method:
    @@Name: disGetAttributeList
    @@enDesc:
      Gets attribute nodes. 
    @@Param:
      @@@Name: attrName
      @@@Type: AnyURI
      @@@enDesc:
        The name expanded URI of the node to retrieve. 
    @@ForParam:
    @@ForpParam:
    @@MediaTypeParam:
    @@MediaTypeDefaultParam:
    @@Return:
      @@@Type: ManakaiDISElementList
      @@@enDesc:
        The attribute (property) element nodes. 
      @@@PerlDef:
        $r = bless [], <ClassName::ManakaiDISElementList>;
        for my $c (@{$self-><M::ManakaiDISElement.disChildElements>
                                  (for_arg => $forArg, forp_arg => $forpArg)}) {
          if ($c-><AG::swcfg21:SWCFGElement::swcfg21:ForLatest
                                          .expandedURI> eq $attrName and
              $c-><M::ManakaiDISElement.mediaTypeMatch>
                                  ($mediaType, $defaultMediaType,
                                   for_arg => $forArg, forp_arg => $forpArg)) {
            push @$r, $c;
          }
        }

  @Method:
    @@Name: disChildElements
    @@enDesc:
      A list of child elements, with <QUOTE::for> check.  
    @@ForParam:
    @@ForpParam:
    @@Return:
      @@@Type: ManakaiDISElementList
      @@@enDesc:
        The current snapshot of child nodes. 
      @@@PerlDef:
        $r = bless [], <ClassName::ManakaiDISElementList>;    
        __DEEP{
          for my $cn (@{$self-><AG::swcfg21:SWCFGNode::swcfg21:ForLatest
                                                       .childNodes>}) {
            ## $cn is an #element.
            my $dn = $cn->{<Q::TreeCore:node>}
                        -><M::ManakaiDOM:ManakaiDOMNodeObject
                            ::ManakaiDOM:Perl.newReference>
                                      (<ClassName::ManakaiDISElement>);
            next unless $dn-><M::ManakaiDISElement.forMatch> ($forArg, $forpArg);
            push @$r, $dn;
          }
        }__;

  @Method:
    @@Name: disAllChildElements
    @@enDesc:
      A list of child elements, without <QUOTE::for> check.  
    @@Return:
      @@@Type: ManakaiDISElementList
      @@@enDesc:
        The current snapshot of child nodes. 
      @@@PerlDef:
        $r = bless [], <ClassName::ManakaiDISElementList>;    
        __DEEP{
          for my $cn (@{$self-><AG::swcfg21:SWCFGNode::swcfg21:ForLatest
                                                       .childNodes>}) {
            ## $cn is an #element.
            my $dn = $cn->{<Q::TreeCore:node>}
                        -><M::ManakaiDOM:ManakaiDOMNodeObject
                            ::ManakaiDOM:Perl.newReference>
                                      (<ClassName::ManakaiDISElement>);
            push @$r, $dn;
          }
        }__;

  @Attr:
    @@Name: qnameValueURI
    @@enDesc:
      The element value (written as <TYPE::dis:TypeQName>), as URI reference. 
      \
      {NOTE:: What should be if list value?
      \
      }
    @@Get:
      @@@Type:AnyURI
      @@@nullCase:
        @@@@enDesc:
          No value. 
      @@@UndeclaredPrefixException:
      @@@PerlDef:
        __DEEP{
          my $v = $self-><AG::swcfg21:SWCFGNode::swcfg21:ForLatest.value>;
          if (defined $v and not ref $v eq 'ARRAY') {
            $r = $self-><AG::ManakaiDISElement.qnameToURI> ($v, node => $self);
          } else {
            $r = null;
          }
        }__;

  @Attr:
    @@Name: qnameValueLocalName
    @@enDesc:
      The local name part of the element value (assumed as 
      written as <TYPE::dis:TypeQName>). 
      \
      {NOTE:: What should be if list value?
      \
      }
    @@Get:
      @@@Type:
        DISCore:LocalName
      @@@nullCase:
        @@@@enDesc:
          No value. 
      @@@PerlDef:
        __DEEP{
          my $v = $self-><AG::swcfg21:SWCFGNode::swcfg21:ForLatest.value>;
          if (defined $v and not ref $v eq 'ARRAY') {
            my ($n, $v) = split /:/, $v, 2;
            $r = defined $v ? $v : $n;
          } else {
            $r = null;
          }
        }__;

  @Attr:
    @@Name: qnameValueNamespaceURI
    @@enDesc:
      The namespace URI of the element value (assumed as written 
      in <TYPE::dis:TypeQName>). 
      \
      {NOTE:: What should be if list value?
      \
      }
    @@Get:
      @@@Type:AnyURI
      @@@nullCase:
        @@@@enDesc:
          No value. 
      @@@UndeclaredPrefixException:
      @@@PerlDef:
        __DEEP{
          my $v = $self-><AG::swcfg21:SWCFGNode::swcfg21:ForLatest.value>;
          if (defined $v and not ref $v eq 'ARRAY') {
            my ($p, $v) = split /:/, $v, 2;
            $r = $self-><AG::ManakaiDISElement.prefixToURI>
                                            (defined $v ? $p : null);
          } else {
            $r = null;
          }
        }__;

  @Method:
    @@Name: tfqnamesValueURI
    @@enDesc:
      The element value (written as <TYPE::dis:TFQNames>),
      as URI reference. 
      \
      {NOTE:: What should be if list value?
      \
      }
    @@Param:
      @@@Name: defaultTypeURI
      @@@Type: NameURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          A name URI reference used if it is missing from 
          <P::tfqnames>. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            Equivalent to <Q::DOMMain:any>. 
    @@Param:
      @@@Name: defaultForURI
      @@@Type: ForURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          A <QUOTE::for> URI reference used if it is missing from 
          <P::tfqnames>. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            Equivalent to <QUOTE::for all>, i.e. <Q::ManakaiDOM:all>. 
    @@Return:
      @@@Type:ResourceURI
      @@@nullCase:
        @@@@enDesc:
          No value. 
      @@@UndeclaredPrefixException:
      @@@PerlDef:
        my $v = $self-><AG::swcfg21:SWCFGNode::swcfg21:ForLatest.value>;
        if (defined $v and not ref $v eq 'ARRAY') {
          __DEEP{
            $r = $self-><AG::ManakaiDISElement.tfqnamesToURI>
                                  ($v, $defaultTypeURI, $defaultForURI);
          }__;
        } else {
          $r = null;
        }

  @Method:
    @@Name: elementTypeMatch
    @@enDesc:
      Returns whether the element type of this element matches 
      with another element type (either the same element type or
      this type is a subtype of another type). 
    @@Param:
      @@@Name: etype
      @@@Type: ResourceURI
      @@@enDesc:
        An element type name URI reference to test. 
    @@Return:
      @@@Type:
        DOMMain:boolean
      @@@TrueCase:
        @@@@enDesc:
          Either the element type expanded URI reference of this element is 
          same as <P::etype> or it is a sub-element type of <P::etype>. 
      @@@FalseCase:
        @@@@enDesc:
          This element is not of <P::etype>. 
      @@@NoDBException:
      @@@PerlDef:
        __DEEP{
          my $et = $self-><M::swcfg21:SWCFGElement::swcfg21:ForLatest
                                                          .expandedURI>;
          my $rdef = $self-><AG::ManakaiDISNode.ownerDISDocument>
                                   -><AG::ManakaiDISDocument.disDatabase>
                                   -><M::ManakaiDISDatabase.getResource> ($et);
          $r = $rdef-><M::ManakaiDISResourceDefinition.isSubsetOfURI> ($etype);
        }__;

  @Attr:
    @@Name: isResourceElement
    @@enDesc:
      Whether this element defines a resource or not. 
      \
      {NOTE:: An element defines a resource if its element type is 
              <Q::dis:ResourceDef> or its subtype.
      \
      }
    @@Get:
      @@@Type:
        DOMMain:boolean
      @@@TrueCase:
        @@@@enDesc:
          This element defines a resource. 
      @@@FalseCase:
        @@@@enDesc:
          This element does not define any resource.
      @@@NoDBException:
      @@@PerlDef:
        __DEEP{
          $r = $self-><M::ManakaiDISElement.elementTypeMatch>
                                                (<Q::dis:ResourceDef>);
        }__;

  @Attr:
    @@Name: isPropertyElement
    @@enDesc:
      Whether this element is a property or not. 
      \
      {NOTE:: An element is a property if its element type is
              <Q::rdf:type> or if its element type's <Q::rdf:type> 
              property is <Q::rdf:Property> or is <Q::dis:subsetOf> 
              <Q::rdf:Property>. 
      \
      }
    @@Get:
      @@@Type:
        DOMMain:boolean
      @@@TrueCase:
        @@@@enDesc:
          This element is a property.
      @@@FalseCase:
        @@@@enDesc:
          This element is not a property. 
      @@@NoDBException:
      @@@PerlDef:
        __DEEP{
          my $xn = $self-><AG::swcfg21:SWCFGElement::swcfg21:ForLatest
                                                            .expandedURI>;
          if ($xn eq <Q::rdf:type>) {
            $r = true;
          } else {
            my $rdef = $self-><AG::ManakaiDISNode.ownerDISDocument>
                                   -><AG::ManakaiDISDocument.disDatabase>
                                   -><M::ManakaiDISDatabase.getResource> ($xn);
            $r = $rdef-><M::ManakaiDISResourceDefinition.isTypeURI>
                                                           (<Q::rdf:Resource>);
          }
        }__;
##DISElement

ClsDef:
  @ClsQName: ManakaiDISModuleElement
  @ClsISA: ManakaiDISElement
  @enDesc:
    The <Q::dis:Module> elements. 

  @Attr:
    @@Name: requireElement
    @@enDesc:
      The <Q::dis:Require> child element.  The element is 
      newly created if not exist. 
    @@Type: ManakaiDISElement
    @@Get:
      @@@PerlDef:
        __DEEP{
          $r = $self-><M::swcfg21:SWCFGNode
                        ::swcfg21:ForLatest.getAttributeNS>
                                   (<Q::dis:>, 'Require', make_new_node => true);
        }__;

  @Attr:
    @@Name: defaultForURI
    @@enDesc:
      The value of <Q::dis:DefaultFor> attribute. 
    @@Type: ForURI
    @@Get:
      @@@enDesc:
        The value of <Q::dis:DefaultFor> child element.  If missing, 
        <Q::ManakaiDOM:all> is returned. 
      @@@PerlDef:
        __DEEP{
          my $df = $self-><M::swcfg21:SWCFGNode::swcfg21:ForLatest
                                .getAttributeNS>
                                         (<Q::dis:>, 'DefaultFor');
          if ($df) {
            $r = $df-><AG::ManakaiDISElement.qnameValueURI>
              || <Q::ManakaiDOM:all>;
          } else {
            $r = <Q::ManakaiDOM:all>;
          }
        }__;
    @@Set:
      @@@PerlDef:
        __DEEP{
          $self-><M::swcfg21:SWCFGNode::swcfg21:ForLatest.setAttributeNS>
                                     (<Q::dis:>, 'DefaultFor' => $given);
        }__;

  @Attr:
    @@Name: definingNamespaceURI
    @@enDesc:
      The value of <Q::dis:NamespaceURI> attribute, i.e. 
      the URI reference of the namespace that this module primary 
      defines.
      \
      {NOTE:: Defining namespace URI is <QUOTE::for> independent. 
      \
      }
    @@Type: AnyURI
    @@Get:
      @@@PerlDef:
        __DEEP{
          my $df = $self-><M::swcfg21:SWCFGNode::swcfg21:ForLatest
                                .getAttributeNS>
                                         (<Q::dis:>, 'Namespace');
          if ($df) {
            $r = $df-><AG::swcfg21:SWCFGNode::swcfg21:ForLatest.value>;
          } else {
            __ASSERT{DISPerl:invariant::
              msg => {qq["dis:Namespace" attribute not found]},
            }__;
          }
        }__;
    @@Set:
      @@@PerlDef:
        __DEEP{
          $self-><M::swcfg21:SWCFGNode::swcfg21:ForLatest.setAttributeNS>
                                     (<Q::dis:>, 'Namespace' => $given);
        }__;
##DISModuleElement

ClsDef:
  @ClsQName: ManakaiDISElementList
  @enDesc:
    @@lang:en
    @@@:
      Lists of elements. 
      \
      {NOTE:: <Class::ManakaiDISElementList> is <QUOTE::dead>; 
              later changes to the tree does not affect this type of objects. 
      \
      }
##DISElementList

ClsDef:
  @ClsQName: ManakaiDISComment
  @ClsISA: ManakaiDISNode
  @ClsISA:
    swcfg21:ManakaiSWCFGComment::swcfg21:ForLatest
  @Description:
    @@lang:en
    @@@:
      <QUOTE::dis> comment node objects. 
##DISComment

ClsDef:
  @ClsQName: ManakaiDISDocumentFragment
  @ClsISA: ManakaiDISNode
  @ClsISA:
    swcfg21:ManakaiSWCFGDocumentFragment::swcfg21:ForLatest
  @Description:
    @@lang:en
    @@@:
      <QUOTE::dis> document fragment node objects. 
##DISDocumentFragment

ClsDef:
  @ClsQName: ManakaiDISDocument
  @ClsISA: ManakaiDISNode
  @ClsISA:
    swcfg21:ManakaiSWCFGDocument::swcfg21:ForLatest
  @Description:
    @@lang:en
    @@@:
      <QUOTE::dis> document node objects. 

  @Attr:
    @@Name: moduleElement
    @@enDesc:
      The <Q::dis:Module> element in this document.  The element is 
      newly created if not exist. 
    @@Type: ManakaiDISModuleElement
    @@Get:
      @@@PerlDef:
        __DEEP{
          $r = $self-><M::swcfg21:SWCFGNode
                        ::swcfg21:ForLatest.getAttributeNS>
                                   (<Q::dis:>, 'Module', make_new_node => true);
        }__;
        $r = bless $r, <ClassName::ManakaiDISModuleElement>;

  @Attr:
    @@Name: disDatabase
    @@enDesc:
      Associated <QUOTE::dis> database. 

    @@Type: ManakaiDISDatabase
    @@Get:
      @@@NoDBException:
      @@@PerlDef:
        if ($self->{<Q::TreeCore:node>}->{<Q::db>}) {
          $r = $self->{<Q::TreeCore:node>}->{<Q::db>};
        } else {
          __EXCEPTION{NO_ASSOCIATED_DB_ERR}__;
        }
    @@Set:
      @@@PerlDef:
        $self->{<Q::TreeCore:node>}->{<Q::db>} = $given;
        require Scalar::Util;
        Scalar::Util::weaken ($self->{<Q::TreeCore:node>}->{<Q::db>});

  @Method:
    @@Name: disChildElements
    @@enDesc:
      A list of child elements, with <QUOTE::for> checks.  
    @@ForParam:
    @@ForpParam:
    @@Return:
      @@@Type: ManakaiDISElementList
      @@@enDesc:
        The current snapshot of child nodes. 
      @@@PerlDef:
        $r = bless [], <ClassName::ManakaiDISElementList>;    
        __DEEP{
          for my $cn (@{$self-><AG::swcfg21:SWCFGNode::swcfg21:ForLatest
                                                       .childNodes>}) {
            next unless $cn-><AG::swcfg21:SWCFGNode::swcfg21:ForLatest
                                              .nodeType> eq '#element';
            my $dn = $cn->{<Q::TreeCore:node>}
                        -><M::ManakaiDOM:ManakaiDOMNodeObject
                            ::ManakaiDOM:Perl.newReference>
                                      (<ClassName::ManakaiDISElement>);
            next unless $dn-><M::ManakaiDISElement.forMatch> ($forArg, $forpArg);
            push @$r, $dn;
          }
        }__;

  @Method:
    @@Name: disAllChildElements
    @@enDesc:
      A list of child elements, without <QUOTE::for> checks.  
    @@Return:
      @@@Type: ManakaiDISElementList
      @@@enDesc:
        The current snapshot of child nodes. 
      @@@PerlDef:
        $r = bless [], <ClassName::ManakaiDISElementList>;    
        __DEEP{
          for my $cn (@{$self-><AG::swcfg21:SWCFGNode::swcfg21:ForLatest
                                                       .childNodes>}) {
            next unless $cn-><AG::swcfg21:SWCFGNode::swcfg21:ForLatest
                                              .nodeType> eq '#element';
            my $dn = $cn->{<Q::TreeCore:node>}
                        -><M::ManakaiDOM:ManakaiDOMNodeObject
                            ::ManakaiDOM:Perl.newReference>
                                      (<ClassName::ManakaiDISElement>);
            push @$r, $dn;
          }
        }__;
##DISDocument

PropDef:
  @QName: db
  @enDesc:
    Associated <QUOTE::dis> database. 
  @rdfs:domain: ManakaiDISDocument
  @rdfs:range: ManakaiDISDatabase

## -- Definition object database

ClsDef:
  @ClsQName: ManakaiDISDatabase
  @enDesc:
    Resource database created from <QUOTE::dis> source data. 
  @ClsISA: ManakaiDISExceptionTarget

  @Method:
    @@Name: getModule
    @@Description:
      @@@lang:en
      @@@@:
        Returns a <QUOTE::dis> module definition. 
    @@Param:
      @@@Name: moduleURI
      @@@Type: ModuleURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          A <QUOTE::dis> module URI reference. 
    @@ForParam:
    @@Return:
      @@@Type: ManakaiDISModuleDefinition
      @@@Description:
        @@@@lang:en
        @@@@@:
          The module definition. 
      @@@PerlDef:
        my $modURI;
        if (defined $forArg) {
          __CODE{tfurisToURI:: $turi => $moduleURI, $furi => $forArg,
                               $uri => $modURI}__;
        } else {
          $modURI = $moduleURI;
        }
        if (defined $self->{modDef}->{$modURI}) {
          $r = $self->{modDef}->{$modURI};
        } else {
          $r = $self->{modDef}->{$modURI}
             = bless {
                 uri => $modURI,
                 db => $self,
                 for => <Q::ManakaiDOM:all>,
                 forp => [],
               }, <ClassName::ManakaiDISModuleDefinition>;
          require Scalar::Util;
          Scalar::Util::weaken ($r->{db});
        }

  @Method:
    @@Name: getFor
    @@Description:
      @@@lang:en
      @@@@:
        Returns a <QUOTE::for> definition object. 
    @@Param:
      @@@Name: forURI
      @@@Type: ForURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          A <QUOTE::for> URI reference. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            Defaulted to <Q::ManakaiDOM:all>. 
    @@Return:
      @@@Type: ManakaiDISForDefinition
      @@@PerlDef:
        $forURI = <Q::ManakaiDOM:all> unless defined $forURI;
        if (defined $self->{forDef}->{$forURI}) {
          $r = $self->{forDef}->{$forURI};
        } else {
          $r = $self->{forDef}->{$forURI}
             = bless {
                 uri => $forURI,
                 isa => {<Q::ManakaiDOM:all> => true},
                 revISA => {},
                 db => $self,
               }, <ClassName::ManakaiDISForDefinition>;
          $self->{forDef}->{<Q::ManakaiDOM:all>}->{revISA}->{$forURI} = true;
          require Scalar::Util;
          Scalar::Util::weaken ($r->{db});
        }

  @Method:
    @@Name: getResource
    @@Description:
      @@@lang:en
      @@@@:
        Returns a <QUOTE::dis> resource definition. 
    @@Param:
      @@@Name: resourceURI
      @@@Type: ResourceURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          A <QUOTE::dis> resource URI reference. 
      @@@nullCase:
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            Defaulted to <Q::DOMMain:any>. 
    @@ForParam:
    @@Return:
      @@@Type: ManakaiDISResourceDefinition
      @@@Description:
        @@@@lang:en
        @@@@@:
          The resource definition. 
      @@@PerlDef:
        $resourceURI = <Q::DOMMain:any> unless defined $resourceURI;
        my $resURI;
        if (defined $forArg) {
          __CODE{tfurisToURI:: $turi => $resourceURI, $furi => $forArg,
                               $uri => $resURI}__;
        } else {
          $resURI = $resourceURI;
        }
        if (defined $self->{resDef}->{$resURI}) {
          $r = $self->{resDef}->{$resURI};
        } else {
          $r = $self->{resDef}->{$resURI}
             = bless {
                 uri => $resURI,
                 aliasURI => {$resURI => true},
                 subOf => {},
                 supOf => {},
                 db => $self,
                 for => <Q::ManakaiDOM:all>,
                 forp => [],
                 seq => -1,
               }, <ClassName::ManakaiDISResourceDefinition>;
          require Scalar::Util;
          Scalar::Util::weaken ($r->{db});
        }

  @Method:
    @@Name: getSourceFile
    @@enDesc:
      Gets <QUOTE::dis> source document. 
    @@Param:
      @@@Name: fileName
      @@@Type: FileURI
      @@@enDesc:
        A URI reference identifying a file. 
    @@Return:
      @@@Type: ManakaiDISDocument
      @@@enDesc:
        The <QUOTE::dis> source document. 
      @@@nullCase:
        @@@@enDesc:
          No document associated with that <P::fileName>. 
      @@@PerlDef:
        $r = $self->{<Q::sourceFile>}->{$fileName};
  @Method:
    @@Name: setSourceFile
    @@enDesc:
      Puts <QUOTE::dis> source document object. 
    @@Param:
      @@@Name: fileName
      @@@Type: FileURI
      @@@enDesc:
        A URI reference identifying a file.  If there is already a 
        source document, then the association has been updated. 
    @@Param:
      @@@Name: doc
      @@@Type: ManakaiDISDocument
      @@@enDesc:
        The document object to set. 
    @@Return:
      @@@PerlDef:
        $self->{<Q::sourceFile>}->{$fileName} = $doc;

  @Method:
    @@Name: loadModule
    @@enDesc:
      Loads definitions from a <QUOTE::dis> document. 
    @@Param:
      @@@Name: doc
      @@@Type:ManakaiDISDocument
      @@@enDesc:
        The source <QUOTE::dis> document object.  Its 
        <A::ManakaiDISDocument.disDatabase> must be this database. 
    @@Param:
      @@@Name: resolver
      @@@Type: DISModuleResolver
      @@@enDesc:
        The resolver to convert module name into <QUOTE::dis> document object. 
    @@ForParam:
    @@Return:
      @@@RaiseException:
        @@@@@: NO_MODULE_QNAME_ERR
        @@@@enDesc:
          The <Q::dis:Module> element must have a <Q::dis:QName> attribute. 
      @@@RaiseException:
        @@@@@: UNABLE_TO_GET_MODULE_ERR
        @@@@enDesc:
          The implementation is unable to get a module source. 
      @@@ForDefDupException:
      @@@ForDefNoQNameException:
      @@@ResDefDupException:
      @@@ElementNotAllowedException:
      @@@RaiseException:
        @@@@@:NO_REQUIRED_ATTR_ERR
        @@@@enDesc:
          The <Q::dis:Module> element does not have 
          <Q::dis:Namespace> attribute. 
      @@@PerlDef:
        $resolver = bless $resolver, <ClassName::ManakaiDISModuleResolver>
                      if ref $resolver eq 'CODE'; 
        ## -- Module Name, URI
        $forArg = <Q::ManakaiDOM:all> unless defined $forArg;
        my $mod_node;
        my $mod_name_node;
        __DEEP{
          $mod_node = $doc-><AG::ManakaiDISDocument.moduleElement>;
          $mod_name_node = $mod_node-><M::swcfg21:SWCFGNode
                                        ::swcfg21:ForLatest.getAttributeNS>
                                                 (<Q::dis:>, 'QName');
          unless ($mod_name_node) {
            __UNDEEP{
              __EXCEPTION{NO_MODULE_QNAME_ERR::
                DIS:sourceNode => {$mod_node},
              }__;
            }__;
          }
          my $mod_name_uri = $mod_name_node
                                -><AG::ManakaiDISElement.qnameValueURI>;
          my $mod = $self-><M::ManakaiDISDatabase.getModule>
                                   ($mod_name_uri, for_arg => $forArg);
        
          unless ($mod-><M::ManakaiDISModuleDefinition.isDefined>) {
            ## -- Initializes Module Definition Object
            $mod->{nameURI} = $mod_name_uri;
            $mod->{localName} = $mod_name_node-><AG::ManakaiDISElement
                                                       .qnameValueLocalName>;
            $mod->{namespaceURI} = $mod_name_node-><AG::ManakaiDISElement
                                                       .qnameValueNamespaceURI>;
            $mod->{for} = $forArg;
            $mod->{src} = $mod_node;
            $mod->{<Q::isDefined>} = true;
            $self-><M::ManakaiDISDatabase.setSourceFile>
                                        ($mod->{nameURI} => $doc);

            $mod->{<Q::DIS:sourceFile>}
              = $mod->{src}
                    -><AG::swcfg21:SWCFGNode::swcfg21:ForLatest.ownerDocument>
                    -><M::swcfg21:SWCFGNode::swcfg21:ForLatest.flag>
                                         (<Q::swcfg21:fileName>);
            
            ## -- Loads "for" definition
            my $root_elements
                       = $doc-><M::ManakaiDISDocument.disAllChildElements>;
            if ($mod->{for} eq <Q::ManakaiDOM:all>) {
              for my $el (@$root_elements) {
                next unless $el-><M::swcfg21:SWCFGElement::swcfg21:ForLatest
                                          .expandedURI> eq <Q::dis:ForDef>;
                $self-><M::ManakaiDISDatabase.loadFor> ($mod, $el);
              }
            }

            ## -- Loads "for all"
            my $rmod = $self-><M::ManakaiDISDatabase.getModule>
                               ($mod->{nameURI}, for_arg => <Q::ManakaiDOM:all>);
            unless ($rmod-><AG::ManakaiDISModuleDefinition.isDefined>) {
              my $rdoc = $resolver-><M::ManakaiDISModuleResolver.uriToDocument>
                               ($self, $rmod->{uri}, $mod->{namespaceURI},
                                $mod->{localName}, <Q::ManakaiDOM:all>);
              unless ($rdoc) {
                __UNDEEP{
                  __EXCEPTION{UNABLE_TO_GET_MODULE_ERR::
                    DIS:uri => {$rmod->{uri}},
                    DIS:namespaceURI => {$mod->{namespaceURI}},
                    DIS:localName => {$mod->{localName}},
                    DIS:for => {<Q::ManakaiDOM:all>},
                    DIS:sourceNode => {$mod->{src}},
                  }__;
                }__;
              }
              $self-><M::ManakaiDISDatabase.loadModule>
                            ($rdoc, $resolver, for_arg => <Q::ManakaiDOM:all>);
            } # Unless "for all" loaded

            ## -- Loads Required Modules
            ##    NOTE:: "dis:For" is not allowed since "dis:ForDef" is not read
            my $req_node = $mod_node-><AG::ManakaiDISModuleElement
                                                          .requireElement>;
            for my $rm (@{$req_node-><M::ManakaiDISElement
                                                    .disAllChildElements>}) {
              next unless $rm-><AG::swcfg21:SWCFGElement::swcfg21:ForLatest
                                               .expandedURI> eq <Q::dis:Module>;
              my ($uri, $nuri, $ln, $for);
              my $mqn = $rm-><AG::swcfg21:SWCFGNode::swcfg21:ForLatest
                                      .getAttributeNS> (<Q::dis:>, 'QName');
              if ($mqn) {
                my $mqv = $mqn-><AG::swcfg21:SWCFGNode::swcfg21:ForLatest
                                                                   .value>;
                my $mqp = $mqn-><AG::ManakaiDISElement.qnameToPair>
                                                       ($mqv, node => $mqn);
                ($nuri, $ln) = @$mqp;
              } else {
                my $mn = $rm-><AG::swcfg21:SWCFGNode::swcfg21:ForLatest
                                      .getAttributeNS> (<Q::dis:>, 'Name');
                if ($mn) {
                  $nuri = $mod->{namespaceURI};
                  $ln = $mn-><AG::swcfg21:SWCFGNode::swcfg21:ForLatest.value>;
                } else {
                  $nuri = $mod->{namespaceURI};
                  $ln = $mod->{localName};
                }
              }
              my $wfn = $rm-><AG::swcfg21:SWCFGNode::swcfg21:ForLatest
                                      .getAttributeNS> (<Q::dis:>, 'WithFor');
              if ($wfn) {
                $for = $wfn-><AG::ManakaiDISElement.qnameValueURI>;
              } else {
                $for = $mod->{for};
              }
              my $rmod = $self-><M::ManakaiDISDatabase.getModule>
                                       ($nuri . $ln, for_arg => $for);
              unless ($rmod-><AG::ManakaiDISModuleDefinition.isDefined>) {
                my $rdoc = $resolver-><M::ManakaiDISModuleResolver.uriToDocument>
                                       ($self, $rmod->{uri}, $nuri, $ln, $for);
                unless ($rdoc) {
                  __UNDEEP{
                    __EXCEPTION{UNABLE_TO_GET_MODULE_ERR::
                      DIS:uri => {$rmod->{uri}},
                      DIS:namespaceURI => {$nuri},
                      DIS:localName => {$ln},
                      DIS:for => {$for},
                      DIS:sourceNode => {$rm},
                    }__;
                  }__;
                }
                $self-><M::ManakaiDISDatabase.loadModule>
                                       ($rdoc, $resolver, for_arg => $for);
              }
            } # Child Module elements
            
            ## -- Loads child resources
            $root_elements = $doc-><M::ManakaiDISDocument.disChildElements>
                                         (for_arg => $forArg);
            for my $el (@$root_elements) {
              if ($el-><AG::ManakaiDISElement.isResourceElement>) {
                $self-><M::ManakaiDISDatabase.loadResource>
                                         ($mod, null, null, $el,
                                          for_arg => $forArg);
              } else {
                my $et = $el-><M::swcfg21:SWCFGElement::swcfg21:ForLatest
                                                               .expandedURI>;
                if ({
                         <Q::dis:ForDef> => 1,
                         <Q::dis:Module> => 1,
                         <Q::dis:ImplNote> => 1,
                    }->{$et}) {
                  # 
                } else {
                  __UNDEEP{
                    __EXCEPTION{ELEMENT_NOT_ALLOWED_ERR::
                      DIS:elementType => {$et},
                      DIS:sourceNode => {$el},
                      DIS:uri => {$mod->{uri}},
                    }__;
                  }__;
                }
              } # element types
            }
            
            my $dn = $mod_node-><M::swcfg21:SWCFGNode::swcfg21:ForLatest
                                .getAttributeNS>
                                         (<Q::dis:>, 'Namespace');
            unless ($dn and defined $dn-><AG::swcfg21:SWCFGNode
                                            ::swcfg21:ForLatest.value>) {
              __UNDEEP{
                __EXCEPTION{NO_REQUIRED_ATTR_ERR::
                  DIS:elementType => {<Q::dis:Namespace>},
                  DIS:sourceNode => {$mod_node},
                }__;
              }__;
            }
          } # Unless this module loaded
        }__; # Deep

  @Method:
    @@Name: loadFor
    @@enDesc:
      Loads definition of a <QUOTE::for> from a <Q::dis:ForDef> element. 
    @@Param:
      @@@Name: mod
      @@@Type: ManakaiDISModuleDefinition
      @@@enDesc:
        The module in which the <QUOTE::for> to load is defined. 
    @@Param:
      @@@Name: el
      @@@Type:ManakaiDISElement
      @@@enDesc:
        The source <QUOTE::dis> <Q::dis:ForDef> element object. 
    @@Return:
      @@@ForDefDupException:
      @@@ForDefNoQNameException:
      @@@ElementNotAllowedException:
      @@@PerlDef:
        __DEEP{
          my $qn_node = $el-><M::swcfg21:SWCFGNode
                                        ::swcfg21:ForLatest.getAttributeNS>
                                                 (<Q::dis:>, 'QName');
          unless ($qn_node) {
            __UNDEEP{
              __EXCEPTION{NO_FOR_QNAME_ERR::
                DIS:sourceNode => {$qn_node},
              }__;
            }__;
          }
          my $qn_uri = $qn_node-><AG::ManakaiDISElement.qnameValueURI>;
          my $for = $self-><M::ManakaiDISDatabase.getFor> ($qn_uri);
        
          unless ($for-><M::ManakaiDISForDefinition.isDefined>) {
            ## -- Initializes "For" Definition Object
            $for->{src} = $el;
            $for->{<Q::isDefined>} = true;
            $for->{<Q::definingModule>} = $mod->{uri};

            for my $ce (@{$el-><M::ManakaiDISElement.disAllChildElements>}) {
              my $xn = $ce-><AG::swcfg21:SWCFGElement::swcfg21:ForLatest
                                                       .expandedURI>;
              if ($xn eq <Q::dis:ISA> or $xn eq <Q::dis:Implement>) {
                my $sfor = $self-><M::ManakaiDISDatabase.getFor>
                            ($ce-><AG::ManakaiDISElement.qnameValueURI>);
                $for-><M::ManakaiDISForDefinition.addISA> ($sfor);
                $sfor-><M::ManakaiDISForDefinition.isReferred> ($ce);
                ## TODO: warn if dis:Implement
              } elsif ({
                         <Q::dis:Description> => 1,
                         <Q::dis:ImplNote> => 1,
                         <Q::dis:FullName> => 1,
                         <Q::dis:QName> => 1,
                       }->{$xn}) {
                # 
              } else {
                __UNDEEP{
                  __EXCEPTION{ELEMENT_NOT_ALLOWED_ERR::
                    DIS:elementType => {$xn},
                    DIS:sourceNode => {$ce},
                    DIS:uri => {$mod->{uri}},
                  }__;
                }__;
              }
            }
          } else {
            __UNDEEP{
              __EXCEPTION{FOR_ALREADY_DEFINED_ERR::
                DIS:sourceNode => {$el},
                DIS:anotherSourceNode => {$for->{src}},
              }__;
            }__;
          } # isDefine?
        }__; # DEEP
        
  @Method:
    @@Name: loadResource
    @@enDesc:
      Loads definition of a <QUOTE::dis> resource from a 
      <Q::dis:ResourceDef> element. 
    @@Param:
      @@@Name: mod
      @@@Type: ManakaiDISModuleDefinition
      @@@enDesc:
        The module in which the resource to load is defined. 
    @@Param:
      @@@Name: parentResource
      @@@Type: ManakaiDISResourceDefinition
      @@@enDesc:
        The (static) parent resource in which the resource to load is defined. 
      @@@nullCase:
        @@@@enDesc:
          The resource to load is a root resource, i.e. <P::el> is 
          a direct child of the document node. 
    @@Param:
      @@@Name: dynParent
      @@@Type: ManakaiDISResourceDefinition
      @@@enDesc:
        The dynamic parent resource of the resource to load. 
      @@@nullCase:
        @@@@enDesc:
          If this resource is a root resource, i.e. <P::el> is
          a direct child of the document node. 
    @@Param:
      @@@Name: el
      @@@Type:ManakaiDISElement
      @@@enDesc:
        The source <QUOTE::dis> <Q::dis:ResourceDef> element object. 
    @@ForParam:
    @@ForpParam:
    @@Return:
      @@@ResDefDupException:
      @@@ElementNotAllowedException:
      @@@PerlDef:
        $forArg = <Q::ManakaiDOM:all> unless defined $forArg;
        $forpArg ||= [];
        __DEEP{
          ## -- Node names

          ## Unique resource identifier generated from node id
          my $node_id = $el-><AG::swcfg21:SWCFGNode::swcfg21:ForLatest.nodeID>;
          my $node_uri;
          __CODE{tfpurisToURI:: $turi => $node_id, $furi => $forArg,
                                $forp => $forpArg, $uri => $node_uri}__;

          ## User defined resource identifiers
          my $qn_node = $el-><M::ManakaiDISElement.disGetAttribute>
                                      (<Q::dis:QName>, for_arg => $forArg,
                                       forp_arg => $forpArg);
          my $res;
          if ($qn_node) {
            my $qn_uri = $qn_node-><AG::ManakaiDISElement.qnameValueURI>;
            $res = $self-><M::ManakaiDISDatabase.getResource>
                                ($qn_uri, for_arg => $forArg);
            if ($res-><M::ManakaiDISForDefinition.isDefined>) {
              __UNDEEP{
                __EXCEPTION{RESOURCE_ALREADY_DEFINED_ERR::
                  DIS:uri => {$res->{uri}},
                  DIS:sourceNode => {$qn_node},
                  DIS:anotherSourceNode => {$res->{src}},
                }__;
              }__;
            }
            $res->{nameURI} = $qn_uri;
            $res->{localName} = $qn_node-><AG::ManakaiDISElement
                                                       .qnameValueLocalName>;
            $res->{namespaceURI} = $qn_node-><AG::ManakaiDISElement
                                                       .qnameValueNamespaceURI>;
          } else { ## Anonymous or local
            my $n_node = $el-><M::ManakaiDISElement.disGetAttribute>
                                      (<Q::dis:Name>, for_arg => $forArg,
                                       forp_arg => $forpArg);
            if ($n_node) {
              if ($parentResource) {
                my $puri = $parentResource->{uri};
                my $ru;
                my $ln = $n_node-><AG::swcfg21:SWCFGNode
                                     ::swcfg21:ForLatest.value>;
                __CODE{getChildResourceURI:: $parentURI => $puri,
                                             $localName => $ln,
                                             $result => $ru}__;
                $res = $self-><M::ManakaiDISDatabase.getResource>
                                    ($ru, for_arg => $forArg);
                $res->{nameURI} = $ru;
                $res->{localName} = $n_node-><AG::swcfg21:SWCFGNode
                                                ::swcfg21:ForLatest.value>;
                $res->{<Q::isAnon>} = true;
              } else {  ## Root local name resource
                my $ln = $n_node-><AG::swcfg21:SWCFGNode
                                                ::swcfg21:ForLatest.value>;
                my $ns_uri = $mod-><M::ManakaiDISPropertyAccessor
                                            .getPropertyText>
                                                 (<Q::dis:Namespace>, null);
                my $qn_uri = $ns_uri . $ln;
                $res = $self-><M::ManakaiDISDatabase.getResource>
                                    ($qn_uri, for_arg => $forArg);
                if ($res-><M::ManakaiDISForDefinition.isDefined>) {
                  __UNDEEP{
                    __EXCEPTION{RESOURCE_ALREADY_DEFINED_ERR::
                      DIS:uri => {$res->{uri}},
                      DIS:sourceNode => {$n_node},
                      DIS:anotherSourceNode => {$res->{src}},
                    }__;
                 }__;
                }
                $res->{nameURI} = $qn_uri;
                $res->{namespaceURI} = $ns_uri;
                $res->{localName} = $ln;
              }
            } else {
              $res = $self-><M::ManakaiDISDatabase.getResource> ($node_uri);
              $res->{<Q::isAnon>} = true;
            }
          } # anon
          $res->{for} = $forArg;
          $res->{forp} = $forpArg;
          $res->{src} = $el;
          $res->{<Q::definingModule>} = $mod->{uri};
          $mod-><M::ManakaiDISPropertyAccessor.addPropertyResourceList>
                                            (<Q::DIS:resource>, $res);
          $res->{<Q::dis2pm:parentResource>}
             = $parentResource ? $parentResource->{uri} : null;
          $res->{<Q::dynamicParentResource>}
             = $dynParent ? $dynParent->{uri} : null;
          unless ($res->{uri} eq $node_uri) {
            my $nu_res = $self-><M::ManakaiDISDatabase.getResource> ($node_uri);
            $res-><M::ManakaiDISResourceDefinition.mergeAsAlias> ($nu_res);
          }
          $res->{<Q::isDefined>} = true;
          $res->{seq} = $self->{seq}++;
          
          ## -- Alias
          my $al_node = $el-><M::ManakaiDISElement.disGetAttribute>
                                      (<Q::dis:AliasFor>, for_arg => $forArg,
                                       forp_arg => $forpArg);
          if ($al_node) {
            my $canon_uri = $al_node-><M::ManakaiDISElement.tfqnamesValueURI>
                                                           ($node_id, $forArg);
            my $canon_res = $self-><M::ManakaiDISDatabase.getResource>
                                                           ($canon_uri);
            $canon_res-><M::ManakaiDISResourceDefinition.isReferred> ($al_node);
            $canon_res-><M::ManakaiDISResourceDefinition.mergeAsAlias>
                                      ($res, node => $al_node);
            $res = $canon_res;
          }

          ## -- Registers as child
          $parentResource-><M::ManakaiDISPropertyAccessor
                                    .addPropertyResourceList>
                                      (<Q::DIS:childResource>, $res)
             if $parentResource;
          $dynParent-><M::ManakaiDISPropertyAccessor
                                    .addPropertyResourceList>
                                      (<Q::DIS:dynamicChildResource>, $res)
             if $dynParent;

          my $is_multires = false;
          my @props;
          my @cres;
          my @ce0 = @{$el-><M::ManakaiDISElement.disChildElements>
                                    (for_arg => $forArg, forp_arg => $forpArg)};
          while (@ce0) {
            my $ce = shift @ce0;
            if ($ce-><M::ManakaiDISElement.elementTypeMatch> (<Q::rdf:type>)) {
              my $type_uri = $ce-><AG::ManakaiDISElement.qnameValueURI>;
              $res->{<Q::rdf:type>}->{$type_uri} = true;
              my $type = $self-><M::ManakaiDISDatabase.getResource> ($type_uri);
              $type-><M::ManakaiDISResourceDefinition.isReferred> ($ce);
              if ($type-><M::ManakaiDISResourceDefinition.isSubsetOfURI>
                                               (<Q::dis:MultipleResource>)) {
                $is_multires = true;
              }
            } elsif ($ce-><M::ManakaiDISElement.elementTypeMatch>
                                                   (<Q::dis:subsetOf>)) {
              my $sres = $self-><M::ManakaiDISDatabase.getResource>
                                  ($ce-><M::ManakaiDISElement.tfqnamesValueURI>
                                                    ($node_id, $forArg));
              $res-><M::ManakaiDISResourceDefinition.addSuperResource> ($sres);
            } elsif ($ce-><AG::ManakaiDISElement.isResourceElement>) {
              push @cres, $ce;
            } else {
              ## Property and invalid element is not checked, since not
              ## all property definitions has loaded at this stage. 
              push @props, $ce;
            }
          } # @ce0
   
          ## -- Child resources
          unless ($is_multires) {
            for my $re (@cres) {
              unless ($al_node) {
                $self-><M::ManakaiDISDatabase.loadResource>
                                     ($mod, $res, $res, $re,
                                      for_arg => $forArg, forp_arg => $forpArg);
              } else {
                my $ac = $re-><M::ManakaiDISElement.disGetAttribute>
                                    (<Q::dis:aliasChild>, for_arg => $forArg,
                                     forp_arg => $forpArg);
                if ($ac and $ac-><M::swcfg21:SWCFGNode
                                   ::swcfg21:ForLatest.value>) {
                  $self-><M::ManakaiDISDatabase.loadResource>
                                     ($mod, $res, $res, $re,
                                      for_arg => $forArg, forp_arg => $forpArg);
                }
              }
            }
          }

          ## -- Multiple representations
          if ($is_multires) {
            for my $pe (@props) {
              if ($pe-><M::ManakaiDISElement.elementTypeMatch>
                                               (<Q::dis:resourceFor>)) {
                my $for_uri = $pe-><M::ManakaiDISElement.qnameValueURI>;
                my $for = $self-><M::ManakaiDISDatabase.getFor> ($for_uri);
                $for-><M::ManakaiDISForDefinition.isReferred> ($pe);
                $self-><M::ManakaiDISDatabase.loadResource>
                                ($mod, $parentResource, $res, $el,
                                 for_arg => $forArg,
                                 forp_arg => [@{$forpArg}, $for_uri]);
              }
            }
          }
        }__; # DEEP

  @Method:
    @@Name: checkUndefinedResource
    @@enDesc:
      Checks whether there is referred but undefined resource or not. 
    @@Return:
      @@@RaiseException:
        @@@@@: FOR_NOT_DEFINED_ERR
        @@@@enDesc:
          There is a <QUOTE::for> that is referred but not defined.
      @@@RaiseException:
        @@@@@: RESOURCE_NOT_DEFINED_ERR
        @@@@enDesc:
          There is a resource that is referred but not defined.
      @@@PerlDef:
        for my $fd (values %{$self->{forDef}}) {
          if (my $ref = $fd-><AG::ManakaiDISForDefinition.isReferred> and
              not $fd-><AG::ManakaiDISForDefinition.isDefined>) {
            __EXCEPTION{FOR_NOT_DEFINED_ERR::
              DIS:uri => {$fd->{uri}},
              DIS:sourceNode => {$ref},
            }__;
          }
        }
        for my $fd (values %{$self->{resDef}}) {
          if (my $ref = $fd-><AG::ManakaiDISResourceDefinition.isReferred> and
              not $fd-><AG::ManakaiDISResourceDefinition.isDefined>) {
            __EXCEPTION{RESOURCE_NOT_DEFINED_ERR::
              DIS:uri => {$fd->{uri}},
              DIS:sourceNode => {$ref},
            }__;
          }
        }
        

  @Method:
    @@Name: plStore
    @@enDesc:
      Saves this database to an external file. 
      \
      {NOTE:: Saved files can be loaded by 
              <M::ManakaiDISImplementation.plLoadDISDatabase>.
      \
      }
    @@Param:
      @@@Name: fileName
      @@@Type:
        DISLang:String
      @@@enDesc:
        An environment-dependent file name of external database to save. 
        \
        {NOTE:: If there is already a file named as <P::fileName>, then 
                it is overwritten. 
        \
        }
    @@Return:
      @@@SimpleException:
      @@@PerlDef:
        use Storable qw/nstore/;
        local $Carp::CarpLevel = $Carp::CarpLevel + 1;
        nstore $self, $fileName;
##DISDatabase

PropDef:
  @QName: resource
  @enDesc:
    Resources defined in a module. 
  @rdfs:range: ManakaiDISResourceDefinition
  @rdfs:domain: ManakaiDISModuleDefinition

PropDef:
  @QName:
    dis2pm:parentResource
  @enDesc:
    Static parent resource.  No parent for root resources.

PropDef:
  @QName: dynamicParentResource
  @enDesc:
    Dynamic parent resource.   No parent for root resources. 

PropDef:
  @QName: childResource
  @enDesc:
    Static child resources.

PropDef:
  @QName: dynamicChildResource
  @enDesc:
    Dynamic child resources.

ElementTypeBinding:
  @Name: ForDefDupException
  @ElementType:
    ManakaiDOM:raises
  @ShadowContent:
    @@@: FOR_ALREADY_DEFINED_ERR
    @@Description:
      @@@lang:en
      @@@@:
        The <QUOTE::for> is already defined elsewhere. 

ElementTypeBinding:
  @Name: ForDefNoQNameException
  @ElementType:
    ManakaiDOM:raises
  @ShadowContent:
    @@@: NO_FOR_QNAME_ERR
    @@Description:
      @@@lang:en
      @@@@:
        A <Q::dis:ForDef> element must have a <Q::dis:QName> attribute. 

ElementTypeBinding:
  @Name: ResDefDupException
  @ElementType:
    ManakaiDOM:raises
  @ShadowContent:
    @@@: RESOURCE_ALREADY_DEFINED_ERR
    @@Description:
      @@@lang:en
      @@@@:
        The <QUOTE::dis> resource is already defined elsewhere. 

ElementTypeBinding:
  @Name: ElementNotAllowedException
  @ElementType:
    ManakaiDOM:raises
  @ShadowContent:
    @@@: ELEMENT_NOT_ALLOWED_ERR
    @@Description:
      @@@lang:en
      @@@@:
        An element has found where it is not allowed. 

IFClsDef:
  @QName:
    @@@: DISModuleResolver
    @@ForCheck: ForIF
  @QName:
    @@@: ManakaiDISModuleResolver
    @@ForCheck: ForClass
  @enDesc:
    Objects implementing <IF::DISModuleResolver> interface 
    are used to convert module name into <QUOTE::dis> document object. 
    \
    {NOTE:: It is also acceptable to pass a <Perl::CODE> reference 
            as a method parameter where <IF::DISModuleResolver> is 
            expected.
    \
    }
  @Method:
    @@Name: uriToDocument
    @@enDesc:
      Returns a <QUOTE::dis> document from module name information. 
    @@Param:
      @@@Name: disDB
      @@@Type: ManakaiDISDatabase
      @@@enDesc:
        The <QUOTE::dis> database. 
    @@Param:
      @@@Name: moduleURI
      @@@Type: ModuleURI
      @@@enDesc:
        The URI reference of the module. 
        \
        {NOTE:: This parameter is redundant, since it can be 
                composed from other three parameters.
        \
        }
    @@Param:
      @@@Name: moduleNamespaceURI
      @@@Type: AnyURI
      @@@enDesc:
        The namespace URI of the module name. 
    @@Param:
      @@@Name: moduleLocalName
      @@@Type: 
        DISCore:LocalName
      @@@enDesc:
        The local name of the module name. 
    @@Param:
      @@@Name: moduleFor
      @@@Type: ForURI
      @@@enDesc:
        The <QUOTE::for> URI reference for which the module is defined. 
    @@Return:
      @@@Type: ManakaiDISDocument
      @@@enDesc:
        The <QUOTE::dis> document.  It don't have to be a newly created
        object. 
      @@@nullCase:
        @@@@enDesc:
          The method is unable to resolve the reference. 
      @@@PerlDef:
        $r = $self->(@_);
  @ManakaiDOM:inputNormalizer:
    @@ContentType:
      lang:Perl
    @@@:
      $INPUT = bless $INPUT, <ClassName::ManakaiDISModuleResolver>
                 if ref $INPUT eq 'CODE';
    @@ImplNote:
      @@@lang:en
      @@@@:
        <FILE::cdis2pm.pl> does not support non-datatype input normalizers yet.
##DISModuleResolver

PropDef:
  @QName: sourceFile
  @enDesc:
    Source <QUOTE::dis> documents. 
  @rdfs:domain: ManakaiDISDatabase
  @rdfs:range: ManakaiDISDocument

ClsDef:
  @ClsQName: ManakaiDISModuleDefinition
  @enDesc:
    <QUOTE::dis> module definitions. 
  @ClsISA: ManakaiDISPropertyAccessor
  @ClsISA: ManakaiDISExceptionTarget
  
  @Attr:
    @@Name: uri
    @@Type: ModuleURI
    @@Description:
      @@@lang:en
      @@@@:
        The URI reference of this <QUOTE::dis> module. 
    @@Get:
      @@@PerlDef:
        $r = $self->{uri};

  @Attr:
    @@Name: nameURI
    @@Type: NameURI
    @@enDesc:
      The URI reference of this module, without 
      <QUOTE::for> identifier. 
    @@Get:
      @@@PerlDef:
        $r = $self->{nameURI};

  @Attr:
    @@Name: localName
    @@enDesc:
      The local name of this module. 
    @@Type:
      DISCore:LocalName::ManakaiDOM:all
    @@Get:
      @@@PerlDef:
        $r = $self->{localName};

  @Attr:
    @@Name: namespaceURI
    @@Type: AnyURI
    @@enDesc:
      The namespace URI of the name of this resource. 
    @@Get:
      @@@PerlDef:
        $r = $self->{namespaceURI};

  @Attr:
    @@Name: forURI
    @@Type: ForURI
    @@enDesc:
      The <QUOTE::for> URI reference for which this module is defined. 
    @@Get:
      @@@PerlDef:
        $r = $self->{for};

  @Attr:
    @@Name: isDefined
    @@Description:
      @@@lang:en
      @@@@:
        Whether this module is defined or not. 
    @@Type:
      DOMMain:boolean
    @@Get:
      @@@PerlDef:
        $r = $self->{<Q::isDefined>};

  @Attr:
    @@Name: plFullyQualifiedName
    @@enDesc:
      The fully-qualified Perl class package name. 
    @@Type:
      Perl:package-name::ManakaiDOM:all
    @@Get:
      @@@NoPerlModuleNameException:
      @@@PerlDef:
        __DEEP{
          my $mg = $self->{db}-><M::ManakaiDISDatabase.getResource>
                                              ($self->{namespaceURI});
          unless ($self-><AG::ManakaiDISResourceDefinition.isDefined>) {
            __UNDEEP{
              __EXCEPTION{RESOURCE_NOT_DEFINED_ERR::
                DIS:uri => {$self->{namespaceURI}},
                DIS:sourceNode => {$self->{src}},
              }__;
            }__;
          }
          my $an = $mg->{src}-><M::ManakaiDISElement.disGetAttribute>
                                     (<Q::dis:AppName>, for_arg => $self->{for},
                                      media_type => <Q::lang:Perl>,
                                      default_media_type => <Q::lang:Perl>);
          if ($an) {
            $r = $an-><M::swcfg21:SWCFGNode::swcfg21:ForLatest.value>;
            $r =~ s/::$//g;
            $r .= '::' . $self->{localName};
            my $sf = $an-><M::ManakaiDISElement.disGetAttribute>
                                 (<Q::ManakaiDOM:moduleSuffix>,
                                  for_arg => $self->{for},
                                  media_type => <Q::lang:Perl>,
                                  default_media_type => <Q::lang:Perl>);
            if ($sf) {
              $r .= $sf-><M::swcfg21:SWCFGNode::swcfg21:ForLatest.value>;
            }
          } else {
            $r = ($mg->{localName} || 'main') . '::' . $self->{localName};
          }
        }__;

  @Attr:
    @@Name: plInterfaceName
    @@enDesc:
      The fully-qualified Perl interface package name. 
    @@Type:
      Perl:package-name::ManakaiDOM:all
    @@Get:
      @@@NoPerlModuleNameException:
      @@@PerlDef:
        __DEEP{
          my $mg = $self->{db}-><M::ManakaiDISDatabase.getResource>
                                              ($self->{namespaceURI});
          unless ($self-><AG::ManakaiDISResourceDefinition.isDefined>) {
            __UNDEEP{
              __EXCEPTION{RESOURCE_NOT_DEFINED_ERR::
                DIS:uri => {$self->{namespaceURI}},
                DIS:sourceNode => {$self->{src}},
              }__;
            }__;
          }
          my $an = $mg->{src}-><M::ManakaiDISElement.disGetAttribute>
                                     (<Q::dis:AppName>, for_arg => $self->{for},
                                      forp_arg => [<Q::ManakaiDOM:ForIF>],
                                      media_type => <Q::lang:Perl>,
                                      default_media_type => <Q::lang:Perl>);
          if ($an) {
            $r = $an-><M::swcfg21:SWCFGNode::swcfg21:ForLatest.value>;
            $r =~ s/::$//g;
            my $sf = $an-><M::ManakaiDISElement.disGetAttribute>
                                 (<Q::ManakaiDOM:moduleSuffix>,
                                  for_arg => $self->{for},
                                  forp_arg => [<Q::ManakaiDOM:ForIF>],
                                  media_type => <Q::lang:Perl>,
                                  default_media_type => <Q::lang:Perl>);
            if ($sf) {
              $r .= $sf-><M::swcfg21:SWCFGNode::swcfg21:ForLatest.value>;
            }
          } else {
            $r = $self-><M::ManakaiDISModuleDefinition.plFullyQualifiedName>;
          }
        }__;
##DISModuleDefinition

ElementTypeBinding:
  @Name: NoPerlModuleNameException
  @ElementType:
    ManakaiDOM:raises
  @ShadowContent:
    @@@: RESOURCE_NOT_DEFINED_ERR
    @@Description:
      @@@lang:en
      @@@@:
        The module group corresponding to the namespace URI
        of this module is not defined. 

ClsDef:
  @ClsQName: ManakaiDISForDefinition
  @Description:
    @@lang:en
    @@@:
      <QUOTE::dis> <QUOTE::for> definitions. 
  @ClsISA: ManakaiDISExceptionTarget
  
  @Attr:
    @@Name: uri
    @@Type: ForURI
    @@Description:
      @@@lang:en
      @@@@:
        The URI reference of this <QUOTE::for>. 
    @@Get:
      @@@PerlDef:
        $r = $self->{uri};

  @IntMethod:
    @@Operator:
      @@@@:eq
      @@@ContentType:
        lang:Perl
    @@enDesc:
      Whether two <QUOTE::for> definitions are equal or not. 
      Two <QUOTE::for> definitions are equal iff one's URI reference 
      is one of another's URI reference. 
      \
      {NOTE:: Aliases for <QUOTE::for> is not allowed.
      \
      }
    @@ImplNote:
      @@@lang:en
      @@@@:
        In the current implementation, two are equal iff two are 
        equal as reference. 
    @@Param:
      @@@Name: anotherFor
      @@@Type: ManakaiDISForDefinition
      @@@enDesc:
        Another <QUOTE::for> definition to compare.
    @@Return:
      @@@Type:
        DOMMain:boolean
      @@@enDesc:
        Whether two resources are equal or not. 
      @@@PerlDef:
        if (UNIVERSAL::isa ($anotherFor, <ClassName::ManakaiDISForDefinition>)) {
          $r = $self->{uri} eq $anotherFor->{uri};
        } else {
          $r = false;
        }
  
  @Method:
    @@Name: isaURI
    @@Description:
      @@@lang:en
      @@@@:
        Whether this <QUOTE::for> is-a another <QUOTE::for> or not. 
    @@Param:
      @@@Name: superURI
      @@@Type: ForURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          Another <QUOTE::for> URI reference to test. 
    @@Return:
      @@@Type: 
        DOMMain:boolean
      @@@TrueCase:
        @@@@enDesc:
          <P::superURI> is a super-<QUOTE::for> of this <QUOTE::for>. 
      @@@FalseCase:
        @@@@enDesc:
          <P::superURI> is not a super-<QUOTE::for> of this <QUOTE::for>. 
      @@@PerlDef:
        $r = $self->{uri} eq $superURI ? true : $self->{isa}->{$superURI};

  @Attr:
    @@Name: isDefined
    @@Description:
      @@@lang:en
      @@@@:
        Whether this <QUOTE::for> is already defined or not. 
    @@Type:
      DOMMain:boolean
    @@Get:
      @@@TrueCase:
        This <QUOTE::for> is already defined. 
      @@@FalseCase:
        This <QUOTE::for> is not defined. 
      @@@PerlDef:
        $r = $self->{<Q::isDefined>};

  @Attr:
    @@Name: isReferred
    @@Description:
      @@@lang:en
      @@@@:
        Whether this <QUOTE::for> is referred somewhere or not. 
    @@Type: ManakaiDISElement
    @@Get:
      @@@InCase:
        @@@@Type:ManakaiDISElement
        @@@@enDesc:
          This <QUOTE::for> is referred by the element. 
      @@@nullCase:
        This <QUOTE::for> is not referred. 
      @@@PerlDef:
        $r = $self->{<Q::isReferred>};
    @@Set:
      @@@InCase:
        @@@@Type:ManakaiDISElement
        @@@@enDesc:
          This <QUOTE::for> is referred by the element. 
      @@@PerlDef:
        $self->{<Q::isReferred>} = $given if $given;

  @Attr:
    @@Name: definingModule
    @@Description:
      @@@lang:en
      @@@@:
        The <QUOTE::dis> module in which this <QUOTE::for> is defined.
    @@Type: ManakaiDISModuleDefinition
    @@Get:
      @@@Description:
        @@@@lang:en
        @@@@@:
          The module object. 
      @@@nullCase:
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            This <QUOTE::for> is not associated to any module. 
      @@@PerlDef:
        $r = $self->{db}
                  -><M::ManakaiDISDatabase.getResource>
                           ($self->{<Q::definingModule>})
           if defined $self->{<Q::definingModule>};

  @Method:
    @@Name: addISA
    @@enDesc:
      Adds a <QUOTE::for> to the list of super-<QUOTE::for> of this 
      <QUOTE::for>.
    @@Param:
      @@@Name: superFor
      @@@Type: ManakaiDISForDefinition
      @@@enDesc:
        A <QUOTE::for> definition object. 
    @@Return:
      @@@PerlDef:
        my @from = ($self->{uri},
                    grep {$self->{revISA}->{$_}} keys %{$self->{revISA}});
        my @to = ($superFor->{uri},
                  grep {$superFor->{isa}->{$_}} keys %{$superFor->{isa}});
        __DEEP{
          for my $from (@from) {
            for my $to (@to) {
              $self->{db}-><M::ManakaiDISDatabase.getFor>
                                      ($from)->{isa}->{$to} = true;
              $self->{db}-><M::ManakaiDISDatabase.getFor>
                                      ($to)->{revISA}->{$from} = true;
            }
          }
        }__;

##DISForDefinition

ClsDef:
  @ClsQName: ManakaiDISResourceDefinition
  @enDesc:
    <QUOTE::dis> resource definitions. 
  @ClsISA: ManakaiDISPropertyAccessor
  @ClsISA: ManakaiDISExceptionTarget
  
  @Attr:
    @@Name: uri
    @@Type: ResourceURI
    @@Description:
      @@@lang:en
      @@@@:
        The URI reference of this <QUOTE::dis> resource. 
    @@Get:
      @@@PerlDef:
        $r = $self->{uri};

  @Attr:
    @@Name: nameURI
    @@Type: NameURI
    @@enDesc:
      The URI reference of this <QUOTE::dis> resource, without 
      <QUOTE::for> identifier. 
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          This resource does not have its name URI reference. 
      @@@PerlDef:
        $r = $self->{nameURI};

  @Attr:
    @@Name: localName
    @@enDesc:
      The local name of this resource. 
    @@Type:
      DISCore:LocalName::ManakaiDOM:all
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          This resource does not have its local name. 
      @@@PerlDef:
        $r = $self->{localName};

  @Attr:
    @@Name: namespaceURI
    @@Type: AnyURI
    @@enDesc:
      The namespace URI of the name of this resource. 
    @@Get:
      @@@nullCase:
        The name of this resource does not have its namespace 
        or this resource does not have its name. 
      @@@PerlDef:
        $r = $self->{namespaceURI};

  @Attr:
    @@Name: isAnonymous
    @@enDesc:
      Whether this <QUOTE::dis> resource has name or not. 
    @@Type: 
      DOMMain:boolean
    @@Get:
      @@@TrueCase:
        This resource does not have any global unique name. 
        <A::ManakaiDISResourceDefinition.uri> is a temporary URI reference. 
      @@@FalseCase:
        This resource does have its formal name. 
        <A::ManakaiDISResourceDefinition.uri> is a URI reference 
        generated from the name and the <QUOTE::for> URI reference 
        of this resource. 
      @@@PerlDef:
        $r = $self->{<Q::isAnon>};

  @Attr:
    @@Name: forURI
    @@enDesc:
      The <QUOTE::for> URI reference for which this resource is defined. 
    @@Type:ForURI
    @@Get:
      @@@PerlDef:
        $r = $self->{for};

  @Attr:
    @@Name: forpURI
    @@enDesc:
      The <QUOTE::for+> URI references for which this resource is defined. 
    @@Type: ForURIList
    @@Get:
      @@@PerlDef:
        $r = $self->{forp};
  
  @Method:
    @@Name: isSubsetOfURI
    @@Description:
      @@@lang:en
      @@@@:
        Whether this resource is a subset of another resource or not. 
    @@Param:
      @@@Name: superURI
      @@@Type: ResourceURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          Another resource URI reference to test. 
    @@Return:
      @@@Type: 
        DOMMain:boolean
      @@@TrueCase:
        @@@@enDesc:
          <P::superURI> is a super-resource of this resource. 
      @@@FalseCase:
        @@@@enDesc:
          <P::superURI> is not a super-resource of this resource. 
      @@@PerlDef:
        $r = $self->{aliasURI}->{$superURI} || $self->{subOf}->{$superURI};

  @Method:
    @@Name: addSuperResource
    @@enDesc:
      Adds a <QUOTE::dis> resource to the list of super-resource 
      of this <QUOTE::dis> resource. 
    @@Param:
      @@@Name: superRes
      @@@Type: ManakaiDISResourceDefinition
      @@@enDesc:
        A <QUOTE::dis> resource definition object. 
    @@Return:
      @@@PerlDef:
        my @from = ($self->{uri},
                    grep {$self->{supOf}->{$_}} keys %{$self->{supOf}});
        my @to = ($superRes->{uri},
                  grep {$superRes->{subOf}->{$_}} keys %{$superRes->{subOf}});
        __DEEP{
          for my $from (@from) {
            for my $to (@to) {
              $self->{db}-><M::ManakaiDISDatabase.getResource>
                                      ($from)->{subOf}->{$to} = true;
              $self->{db}-><M::ManakaiDISDatabase.getResource>
                                      ($to)->{supOf}->{$from} = true;
            }
          }
        }__;

  @Attr:
    @@Name: isDefined
    @@Description:
      @@@lang:en
      @@@@:
        Whether this resource is already defined or not. 
    @@Type:
      DOMMain:boolean
    @@Get:
      @@@TrueCase:
        This resource is already defined. 
      @@@FalseCase:
        This resource is not defined. 
      @@@PerlDef:
        $r = $self->{<Q::isDefined>};

  @Attr:
    @@Name: isReferred
    @@Description:
      @@@lang:en
      @@@@:
        Whether this resource is referred or not. 
    @@Type: ManakaiDISElement
    @@Get:
      @@@enDesc:
        An element that referres this resource.
      @@@nullCase:
        This resource is not referred. 
      @@@PerlDef:
        $r = $self->{<Q::isReferred>};
    @@Set:
      @@@enDesc:
        An element that referres this resource. 
      @@@PerlDef:
        $self->{<Q::isReferred>} = $given if $given;

  @Attr:
    @@Name: definingModule
    @@Description:
      @@@lang:en
      @@@@:
        The <QUOTE::dis> module in which this resource is defined.
        \
        {NOTE:: Method name should have been <CODE::ownerModule> or some.
        \
        }
    @@Type: ManakaiDISModuleDefinition
    @@Get:
      @@@Description:
        @@@@lang:en
        @@@@@:
          The module object. 
      @@@nullCase:
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            This resource is not associated to any module. 
      @@@PerlDef:
        $r = $self->{db}
                  -><M::ManakaiDISDatabase.getModule>
                           ($self->{<Q::definingModule>})
           if defined $self->{<Q::definingModule>};
   @@Set:
     @@@Description:
       @@@@lang:en
       @@@@@:
         The module object to which the <QUOTE::defining module> is set. 
     @@@PerlDef:
       $self->{<Q::defininingModule>}
                 = $given-><AG::ManakaiDISModuleDefinition.uri>;
   
  @Method:
    @@Name: mergeAsAlias
    @@enDesc:
      Merges another resource definition as an alias of this resource. 
    @@Param:
      @@@Name: aliasResource
      @@@Type: ManakaiDISResourceDefinition
      @@@enDesc:
        A resource to merge.
        \
        {NOTE:: After merging all references to <P::aliasResource> 
                should be discarded.
        \
        }
    @@NodeParam:
    @@Return:
      @@@RaiseException:
        @@@@@:MERGE_ITSELF_ERR
        @@@@@@enDesc:
          An attempt is made to merge this resource itself. 
      @@@PerlDef:
        if ($self eq $aliasResource) {
          __EXCEPTION{MERGE_ITSELF_ERR::
            DIS:uri => {$self->{uri}},
            DIS:sourceNode => {$node},
          }__;
        }
        for my $uri ($aliasResource->{uri}, 
                     grep {$aliasResource->{aliasURI}->{$_}}
                          keys %{$aliasResource->{aliasURI}}) {
          $self->{aliasURI}->{$uri} = true;
          $self->{db}->{resDef}->{$uri} = $self;
          $self->{subOf}->{$uri} = true;
          $self->{supOf}->{$uri} = true;
        }
        for my $uri (grep {$aliasResource->{subOf}->{$_}}
                          keys %{$aliasResource->{subOf}}) {
          $self->{subOf}->{$uri} = true;
        }
        for my $uri (grep {$aliasResource->{supOf}->{$_}}
                          keys %{$aliasResource->{supOf}}) {
          $self->{supOf}->{$uri} = true;
        }
        my @from = grep {$self->{supOf}->{$_}} keys %{$self->{supOf}};
        my @to   = grep {$self->{subOf}->{$_}} keys %{$self->{subOf}};
        __DEEP{
          for my $from (@from) {
            for my $to (@to) {
              $self->{db}-><M::ManakaiDISDatabase.getResource>
                                      ($from)->{subOf}->{$to} = true;
              $self->{db}-><M::ManakaiDISDatabase.getResource>
                                      ($to)->{supOf}->{$from} = true;
            }
          }
        }__;

  @Method:
    @@Name: isTypeURI
    @@enDesc:
      Tests whether this resource is of a type or not. 
    @@Param:
      @@@Name: typeURI
      @@@Type: ResourceURI
      @@@enDesc:
        A type URI reference to test. 
    @@Return:
      @@@Type:
        DOMMain:boolean 
      @@@TrueCase:
        @@@@enDesc:
          This is a <P::typeURI> resource. 
      @@@FalseCase:
        @@@@enDesc:
          This is not a <P::typeURI> resource. 
      @@@PerlDef:
        if ($self->{<Q::rdf:type>}->{$typeURI}) {
          $r = $self->{<Q::rdf:type>}->{$typeURI};
        } else {
          for my $t_type_uri (grep {$self->{<Q::rdf:type>}->{$_}}
                                   keys %{$self->{<Q::rdf:type>}}) {
            my $t_type = $self->{db}-><M::ManakaiDISDatabase.getResource>
                                                              ($t_type_uri);
            if ($t_type-><M::ManakaiDISResourceDefinition.isSubsetOfURI>
                                                              ($typeURI)) {
              $self->{<Q::rdf:type>}->{$typeURI} = $r = true;
              last;
            }
          }
        }

  @Attr:
    @@Name: plName
    @@enDesc:
      The Perl name of this resource. 
    @@Get: 
      @@@Type:
        DISLang:String
      @@@enDesc:
        - <Q::ManakaiDOM:Const>::: Constant function (local) name. 
        \
        - <Q::ManakaiDOM:ConstGroup>::: Export group name (without 
                                        <CHAR::COLON> prefix).
        \
        - <Q::DISLang:Attribute>::: Method name. 
        \
        - <Q::DISLang:Method>::: Method name. 
      @@@nullCase:
        @@@@enDesc:
          Either the type of this resource is not listed above 
          or this Perl constructure is anonymous. 
      @@@RaiseException:
        @@@@@: NO_LOCAL_NAME_ERR
        @@@@enDesc:
          The type of this resource is either 
          <Q::ManakaiDOM:Const> or <Q::ManakaiDOM:ConstGroup> and 
          the local name of this resource is not defined. 
      @@@RaiseException:
        @@@@@: RESERVED_PERL_METHOD_NAME_ERR
        @@@@enDesc:
          The Perl method name constructed from the source 
          result in a reserved name. 
      @@@PerlDef:
        __DEEP{
          if (exists $self->{<Q::dis2pm:name>}) {
            $r = $self->{<Q::dis2pm:name>};
          } elsif ($self-><M::ManakaiDISResourceDefinition.isTypeURI>
                              (<Q::ManakaiDOM:Const>) or
                   $self-><M::ManakaiDISResourceDefinition.isTypeURI>
                              (<Q::ManakaiDOM:ConstGroup>)) {
            $r = $self->{localName};
            unless (defined $r) {
              __UNDEEP{
                __EXCEPTION{NO_LOCAL_NAME_ERR::
                  DIS:sourceNode => {$self->{src}},
                }__;
              }__;
            }
          } elsif ($self-><M::ManakaiDISResourceDefinition.isTypeURI>
                              (<Q::DISLang:Method>) or
                   $self-><M::ManakaiDISResourceDefinition.isTypeURI>
                              (<Q::DISLang:Attribute>)) {
            if (defined $self->{localName}) {
              $r = <ClassM::ManakaiDISImplementation.camelCaseToUnderscoreName>
                                               ($self->{localName});
              if ($self-><M::ManakaiDISPropertyAccessor.getPropertyBoolean>
                                (<Q::ManakaiDOM:isForInternal>, false)) {
                $r = '_' . $r;
              }
              if ({
                    import => 1,
                    unimport => 1,
                    isa => 1,
                    can => 1,
                    new => 1,
                    as_string => 1,
                    stringify => 1,
                    clone => 1,
                  }->{$r} or $r =~ /^___/) {
                __UNDEEP{
                  __EXCEPTION{RESERVED_PERL_METHOD_NAME_ERR::
                    DIS:uri => {$self->{uri}},
                    DIS:soruceNode => {$self->{src}},
                    DIS:generatedName => {$r},
                  }__;
                }__;
              }
            } elsif (my $op_uri = $self-><AG::ManakaiDISResourceDefinition
                                                  .plMethodOperator>) {
                $r = {
                       <Q::ManakaiDOM:MUErrorHandler> => '___report_error',
                       <Q::DISPerl:AsStringMethod> => 'as_string',
                       <Q::DISPerl:AsNewMethod> => 'new',
                       <Q::DISPerl:AsCloneMethod> => 'clone',
                     }->{$op_uri};
                $r = $op_uri if $op_uri =~ /^[A-Z]+$/;
            } else {
              $r = null;
            }
          } else {
            $r = null;
          }
          $self->{<Q::dis2pm:name>} = $r;
        }__;

  @Attr:
    @@Name: plFullyQualifiedName
    @@enDesc:
      The fully-qualified Perl name of this resource. 
    @@Type:
      DISLang:String::ManakaiDOM:all
    @@Get:
      @@@enDesc:
        Fully-qualified name.
        \
        - <Q::ManakaiDOM:Class>::: Class package name. 
        \
        - <Q::ManakaiDOM:IF>::: Interface package name. 
        \
        - <Q::DISPerl:ScalarVariable>::: Variable name (without variable
                                type symbol such as <CODE::$>). 
      @@@nullCase:
        @@@@enDesc:
          Otherwise. 
      @@@NoPerlModuleNameException:
      @@@RaiseException:
        @@@@@: NO_LOCAL_NAME_ERR
        @@@@enDesc:
          The local name of this resource is not defined. 
      @@@PerlDef:
        __DEEP{
          if (exists $self->{<Q::dis2pm:name>}) {
            $r = $self->{<Q::dis2pm:name>};
          } elsif ($self-><M::ManakaiDISResourceDefinition.isTypeURI>
                              (<Q::ManakaiDOM:Class>) or
                   $self-><M::ManakaiDISResourceDefinition.isTypeURI>
                              (<Q::ManakaiDOM:IF>) or
                   $self-><M::ManakaiDISResourceDefinition.isTypeURI>
                              (<Q::DISPerl:ScalarVariable>)) {
            my $an_node = $self->{src}-><AG::ManakaiDISElement.disGetAttribute>
                              (<Q::dis:AppName>, for_arg => $self->{for},
                               forp_arg => $self->{forp},
                               media_type => <Q::lang:Perl>);
            if ($an_node) {
              ## NOTE: "lang:Perl" is fully-qualified name by definition
              $r = $an_node-><AG::swcfg21:SWCFGNode::swcfg21:ForLatest.value>;
            } else {
              unless (defined $self->{localName}) {
                __UNDEEP{
                  __EXCEPTION{NO_LOCAL_NAME_ERR::
                    DIS:sourceNode => {$self->{src}},
                  }__;
                }__;
              }
              if ($self-><M::ManakaiDISResourceDefinition.isTypeURI>
                              (<Q::ManakaiDOM:IF>)) {
                $r = $self-><AG::ManakaiDISResourceDefinition.definingModule>
                          -><M::ManakaiDISModuleDefinition.plInterfaceName>
                   . '::' . $self->{localName};
              } else {
                $r = $self-><AG::ManakaiDISResourceDefinition.definingModule>
                          -><M::ManakaiDISModuleDefinition.plFullyQualifiedName>
                   . '::' . $self->{localName};
              }
            }
          } else {
            $r = null;
          }
          $self->{<Q::dis2pm:name>} = $r;
        }__;

  @Attr:
    @@Name: plMethodOperator
    @@enDesc:
      The operator to overload by this method. 
    @@Type:
      DISLang:String::ManakaiDOM:all
    @@Get:
      @@@enDesc:
        The operator, either Perl <CODE::use operator> operator name
        of manakai operator URI reference. 
      @@@nullCase:
        @@@@enDesc:
          Either this resource does not define a Perl method or 
          this method does not overload any operator. 
      @@@UndeclaredPrefixException:
      @@@RaiseException:
        @@@@@: UNSUPPORTED_MEDIA_TYPE_ERR
        @@@@enDesc:
          Media type of the <Q::dis:Operator> node is not supported. 
      @@@PerlDef:
        __DEEP{
          if (exists $self->{<Q::dis:Operator>}) {
            $r = $self->{<Q::dis:Operator>};
          } else {
            my $op_node = $self->{src}-><M::ManakaiDISElement.disGetAttribute>
                             (<Q::dis:Operator>, for_arg => $self->{for},
                              forp_arg => $self->{forp});
            if ($op_node) {
              if ($op_node-><M::ManakaiDISElement.mediaTypeMatch>
                                  (<Q::lang:Perl>, for_arg => $self->{for},
                                   for_arg => $self->{forp})) {
                $r = $op_node-><AG::swcfg21:SWCFGNode::swcfg21:ForLatest.value>;
              } elsif ($op_node-><M::ManakaiDISElement.mediaTypeMatch>
                                  (<Q::dis:TypeQName>, for_arg => $self->{for},
                                   for_arg => $self->{forp})) {
                $r = $op_node-><AG::ManakaiDISElement.qnameValueURI>;
              } else {
                my $ct_uri = $op_node-><M::ManakaiDISElement.mediaTypeURI>
                                     (for_arg => $self->{for},
                                      forp_arg => $self->{forp});
                __UNDEEP{
                  __EXCEPTION{UNSUPPORTED_MEDIA_TYPE_ERR::
                    DIS:uri => {$ct_uri},
                    DIS:sourceNode => {$op_node},
                  }__;
                }__;
              }
            } else {
              $r = null;
            }
            $self->{<Q::dis:Operator>} = $r;
          }
        }__;

  @Attr:
    @@Name: disDataTypeResource
    @@enDesc:
      <Q::dis:Type> attribute value of this resource. 
    @@Type: ManakaiDISResourceDefinition
    @@Get:
      @@@RaiseException:
        @@@@@:NO_DIS_TYPE_ERR
        @@@@enDesc:
          <Q::dis:Type> attribute is not specified. 
      @@@PerlDef:
        __DEEP{
          if (defined $self->{<Q::dis:Type>}) {
            $r = $self->{<Q::dis:Type>};
          } else {
            $self->{<Q::dis2pm:TypeNode>}
               = $self->{src}-><M::ManakaiDISElement.disGetAttribute>
                                  (<Q::dis:Type>, for_arg => $self->{for},
                                   forp_arg => $self->{forp});
            if ($self->{<Q::dis2pm:TypeNode>}) {
              $r = $self->{<Q::dis:Type>}
                 = $self->{<Q::dis2pm:TypeNode>}
                          -><AG::ManakaiDISElement.qnameValueURI>;
            } else {
              my $pr = $self-><M::ManakaiDISPropertyAccessor
                                       .getPropertyResource>
                                          (<Q::DIS:dynamicParentResource>);
              if ($pr) {
                $r = $pr-><AG::ManakaiDISResourceDefinition
                                       .disDataTypeResource>;
                $self->{<Q::dis2pm:TypeNode>}
                     = $pr->{<Q::dis2pm:TypeNode>};
              } else {  ## No parent
                __UNDEEP{
                  __EXCEPTION{NO_DIS_TYPE_ERR::
                    DIS:sourceNode => {$self->{src}},
                  }__;
                }__;
              }
            }
          }
        }__;

  @Attr:
    @@Name: disDataTypeNode
    @@enDesc:
      <Q::dis:Type> node for this resource. 
    @@Get:
      @@@Type: ManakaiDISElement
      @@@RaiseException:
        @@@@@:NO_DIS_TYPE_ERR
        @@@@enDesc:
          <Q::dis:Type> attribute is not specified.
      @@@PerlDef:
        __DEEP{
          $self-><AG::ManakaiDISResourceDefinition.disDataTypeNode>;
        }__;
        $r = $self->{<Q::dis2pm:TypeNode>};

  @Attr:
    @@Name: disActualDataTypeResource
    @@enDesc:
      <Q::dis:actualType> attribute value of this resource. 
    @@Type: ManakaiDISResourceDefinition
    @@Get:
      @@@RaiseException:
        @@@@@:NO_DIS_TYPE_ERR
        @@@@enDesc:
          <Q::dis:actualType> attribute is not specified, 
          and <Q::dis:Type> attribute, neigher. 
      @@@PerlDef:
        __DEEP{
          if (defined $self->{<Q::dis:actualType>}) {
            $r = $self->{<Q::dis:actualType>};
          } else {
            $self->{<Q::dis2pm:actualTypeNode>}
               = $self->{src}-><M::ManakaiDISElement.disGetAttribute>
                                  (<Q::dis:actualType>, for_arg => $self->{for},
                                   forp_arg => $self->{forp});
            if ($self->{<Q::dis2pm:actualTypeNode>}) {
              $r = $self->{<Q::dis:actualType>}
                 = $self->{<Q::dis2pm:actualTypeNode>}
                        -><AG::ManakaiDISElement.qnameValueURI>;
            } elsif (defined $self->{<Q::dis:Type>}) {
              $r = $self->{<Q::dis:actualType>} = $self->{<Q::dis:Type>};
              $self->{<Q::dis2pm:actualTypeNode>}
                            = $self->{<Q::dis2pm:TypeNode>};
            } else {
              $self->{<Q::dis2pm:actualTypeNode>}
                 = $self->{<Q::dis2pm:TypeNode>}
                 = $self->{src}-><M::ManakaiDISElement.disGetAttribute>
                                  (<Q::dis:Type>, for_arg => $self->{for},
                                   forp_arg => $self->{forp});
              if ($self->{<Q::dis2pm:TypeNode>}) {
                $r = $self->{<Q::dis:actualType>}
                   = $self->{<Q::dis:Type>}
                   = $self->{<Q::dis2pm:TypeNode>}
                          -><AG::ManakaiDISElement.qnameValueURI>;
              } else {
                my $pr = $self-><M::ManakaiDISPropertyAccessor
                                       .getPropertyResource>
                                          (<Q::DIS:dynamicParentResource>);
                if ($pr) {
                  $r = $self->{<Q::dis:actualType>}
                     = $pr-><AG::ManakaiDISResourceDefinition
                                       .disActualDataTypeResource>;
                  $self->{<Q::dis2pm:actualTypeNode>}
                     = $pr->{<Q::dis2pm:actualTypeNode>};
                } else {  ## No parent
                  __UNDEEP{
                    __EXCEPTION{NO_DIS_TYPE_ERR::
                      DIS:sourceNode => {$self->{src}},
                    }__;
                  }__;
                }
              }
            }
          }
        }__;

  @Attr:
    @@Name: disActualDataTypeNode
    @@enDesc:
      <Q::dis:actualType> node for this resource. 
    @@Get:
      @@@Type: ManakaiDISElement
      @@@RaiseException:
        @@@@@:NO_DIS_TYPE_ERR
        @@@@enDesc:
          <Q::dis:actualType> attribute is not specified, 
          and <Q::dis:Type> attribute, neigher. 
      @@@PerlDef:
        __DEEP{
          $self-><AG::ManakaiDISResourceDefinition.disActualDataTypeNode>;
        }__;
        $r = $self->{<Q::dis2pm:actualTypeNode>};

  @IntMethod:
    @@Operator:
      @@@@: <=>
      @@@ContentType:
        lang:Perl
    @@enDesc:
      Which is greater (i.e. the spaceship operator). 
      A resource is less than another if it is loaded by
      <M::ManakaiDISDatabase.loadResource> before another is loaded. 
      Order for non-loaded resource definitions are not defined. 
      \
      {NOTE:: In the current implementation, non-loaded resources 
              are less than any loaded resource and the order in 
              non-loaded resources is unknown. 
      \
      }
    @@Param:
      @@@Name: anotherResource
      @@@Type: ManakaiDISResourceDefinition
      @@@enDesc: Another resource to compare.
    @@Return:
      @@@Type:
        DOMMain:unsigned-long
      @@@PerlDef:
        if (UNIVERSAL::isa ($anotherResource,
                            <ClassName::ManakaiDISResourceDefinition>)) {
          $r = $self->{seq} <=> $anotherResource->{seq};
        } else {
          $r = overload::Overloaded ($self) <=> $anotherResource;
        }

  @Attr:
    @@Name: plCodeFragment
    @@enDesc:
      Perl code definition fragment of this resource. 
    @@Type: MPLCodeFragment
    @@Get:
      @@@enDesc:
        Perl code.
      @@@nullCase:
        @@@@enDesc:
          This node does not have Perl code definition. 
      @@@RaiseException:
        @@@@@:NO_METHOD_RETURN_ERR
        @@@@enDesc:
          This resource is a <Q::DISLang:Method> but it does not 
          have <Q::DISLang:MethodReturn> child-resource. 
      @@@RaiseException:
        @@@@@:NO_ATTR_GET_ERR
        @@@@enDesc:
          This resource is a <Q::DISLang:Attribute> but it does not 
          have <Q::DISLang:AttributeGet> child-resource.
      @@@RaiseException:
        @@@@@:UNSUPPORTED_MEDIA_TYPE_ERR
        @@@@enDesc:
          The media type of <Q::dis:Def> element is not supported.
      @@@PerlDef:
        __DEEP{
          if (exists $self->{<Q::plCodeFragment>}) {
            $r = $self->{<Q::plCodeFragment>};
          } elsif (not $self->{src}) {
            $r = $self->{<Q::plCodeFragment>} = null;
          } elsif ($self-><M::ManakaiDISResourceDefinition.isTypeURI>
                                (<Q::DISLang:MethodReturn>) or
                   $self-><M::ManakaiDISResourceDefinition.isTypeURI>
                                (<Q::DISLang:AttributeGet>) or
                   $self-><M::ManakaiDISResourceDefinition.isTypeURI>
                                (<Q::DISLang:AttrobuteSet>)) {
            my $def = $self->{src}-><M::ManakaiDISElement.disGetAttribute>
                                (<Q::dis:Def>, for_arg => $self->{for},
                                 forp_arg => $self->{forp});
            if ($def-><M::ManakaiDISElement.mediaTypeMatch> (<Q::lang:Perl>)) {
              $r = $self->{<Q::plCodeFragment>}
                 = $self-><M::ManakaiDISResourceDefinition.plImplementation>
                        -><M::MPLImpl.createPerlUnparsedCode>
                      ($def-><AG::swcfg21:SWCFGNode::swcfg21:ForLatest.value>);
              $r-><AS::MPLUnparsedCode.sourceFile>
                         ($self->{src}-><M::swcfg21:SWCFGNode
                                          ::swcfg21:ForLatest.nodePath>
                               (key => [qw/Name QName type Type/]));
              $r-><AS::MPLUnparsedCode.sourceLine> (1);
            } elsif ($def-><M::ManakaiDISElement.mediaTypeMatch>
                                                         (<Q::lang:dis>)) {
              $r = $self->{<Q::plCodeFragment>}
                 = $self-><M::ManakaiDISResourceDefinition.plImplementation>
                        -><M::MPLImpl.createPerlUnparsedCode>
                      ($def-><AG::swcfg21:SWCFGNode::swcfg21:ForLatest.value>);
 ## TODO: implement
            } else {
              my $mt = $def-><M::ManakaiDISElement.mediaTypeURI>
                                   (for_arg => $self->{for},
                                    forp_arg => $self->{forp});
              __UNDEEP{
                __EXCEPTION{UNSUPPORTED_MEDIA_TYPE_ERR::
                  DIS:uri => {$mt},
                  DIS:sourceNode => {$def},
                }__;
              }__;
            } # media type
          } elsif ($self-><M::ManakaiDISResourceDefinition.isTypeURI>
                                (<Q::DISLang:Method>)) {
            my $ret = $self-><M::ManakaiDISResourceDefinition
                            .getChildResourceByType> (<Q::DISLang:MethodReturn>);
            unless ($ret) { 
              __UNDEEP{
                __EXCEPTION{NO_METHOD_RETURN_ERR::
                  DIS:errResource => {$self},
                  DIS:sourceNode => {$self->{src}},
                }__;
              }__;
            }
            $r = $self->{<Q::plCodeFragment>}
               = $self-><M::ManakaiDISResourceDefinition.plImplementation>
                        -><M::MPLImpl.createPerlSub>
                            ($self-><AG::ManakaiDISResourceDefinition.plName>);

            
                 ## TODO: Parameter, sub, ...
            $r-><M::MPLSub.appendCodeFragment>
                     ($ret-><AG::ManakaiDISResourceDefinition.plCodeFragment>);

          } elsif ($self-><M::ManakaiDISResourceDefinition.isTypeURI>
                                (<Q::DISLang:Attribute>)) {  
            my $get = $self-><M::ManakaiDISResourceDefinition
                            .getChildResourceByType> (<Q::DISLang:AttributeGet>);
            unless ($get) { 
              __UNDEEP{
                __EXCEPTION{NO_ATTR_GET_ERR::
                  DIS:errResource => {$self},
                  DIS:sourceNode => {$self->{src}},
                }__;
              }__;
            }
            $r = $self->{<Q::plCodeFragment>}
               = $self-><M::ManakaiDISResourceDefinition.plImplementation>
                        -><M::MPLImpl.createPerlSub>
                            ($self-><AG::ManakaiDISResourceDefinition.plName>);

            
                 ## TODO: Parameter, sub, set, ...
            $r-><M::MPLSub.appendCodeFragment>
                     ($get-><AG::ManakaiDISResourceDefinition.plCodeFragment>);

          } else {
            $r = $self->{<Q::plCodeFragment>} = null;  
          } # rdf:type
        }__;

  @Attr:
    @@Name:plImplementation
    @@enDesc:
      The <Class::PerlCode:ManakaiPerlCodeImplementation> object. 
    @@Type: MPLImpl
    @@Get:
      @@@enDesc:
        The Perl code implementation object. 
      @@@nullCase:
        This resource has no source tree associated. 
      @@@RaiseException:
        @@@@@:NO_PERL_CODE_IMPL_ERR
        @@@@enDesc:
          There is no implementation that implements 
          the <Feature::Util:PerlCode> feature, version <FeatureVer::1.0>. 
      @@@PerlDef:
        if ($self->{src}) {
          __DEEP{
            $r = ($self->{src}-><AG::SWCFGNode.ownerDocument> or
                        $self->{src})-><AG::SWCFGDoc.implementation>
                           -><M::DOMMinImpl.getFeature>
                                   (<Q::Util:PerlCode> => '1.0');
          }__;
          unless (defined $r) {
            __EXCEPTION{NO_PERL_CODE_IMPL_ERR::
              
            }__;
          }
        }

  @Method:
    @@Name: getChildResourceByType
    @@enDesc:
      Gets a static child resource selected by its type. 
    @@Param:
      @@@Name:typeURI
      @@@Type:ResourceURI
      @@@enDesc:
        A URI reference identifying a resource type. 
    @@Return:
      @@@Type: ManakaiDISResourceDefinition
      @@@enDesc:
        The first (by document order) child resource whose 
        type matches with <P::resType>. 
      @@@nullCase:
        @@@@enDesc:
          There is no resource whose type is <P::resType>.
      @@@PerlDef:
        __DEEP{
          for my $cr_uri (@{$self->{<Q::DIS:childResource>}}) {
            my $cr = $self->{db}-><M::ManakaiDISDatabase.getResource>
                                             ($cr_uri);
            if ($cr-><M::ManakaiDISResourceDefinition.isTypeURI> ($typeURI)) {
              $r = $cr;
              last;
            }
          }
        }__;
##DISResourceDefinition

ResourceDef:
  @QName: DOMMinImpl
  @rdf:type:
    ManakaiDOM:IF
  @AliasFor:
    DOMMetaImpl:ManakaiDOMMinimumImplementationIF::ManakaiDOM:ManakaiDOMLatest

ResourceDef:
  @QName: SWCFGNode
  @rdf:type:
    ManakaiDOM:IF
  @AliasFor:
    swcfg21:SWCFGNode::swcfg21:ForLatest

ResourceDef:
  @QName: SWCFGDoc
  @rdf:type:
    ManakaiDOM:IF
  @AliasFor:
    swcfg21:SWCFGDocument::swcfg21:ForLatest

ResourceDef:
  @QName: MPLImpl
  @rdf:type:
    ManakaiDOM:Class
  @AliasFor:
    PerlCode:ManakaiPerlCodeImplementation::ManakaiDOM:Perl

ResourceDef:
  @QName: MPLCodeFragment
  @rdf:type:
    ManakaiDOM:Class
  @AliasFor:
    PerlCode:ManakaiPerlCodeFragment::ManakaiDOM:Perl

ResourceDef:
  @QName: MPLSub
  @rdf:type:
    ManakaiDOM:Class
  @AliasFor:
    PerlCode:ManakaiPerlSub::ManakaiDOM:Perl

ResourceDef:
  @QName: MPLUnparsedCode
  @rdf:type:
    ManakaiDOM:Class
  @AliasFor:
    PerlCode:ManakaiPerlUnparsedCode::ManakaiDOM:Perl

PropDef:
  @QName: plCodeFragment
  @enDesc:
    Cache for <A::ManakaiDISResourceDefinition.plCodeFragment>.

XParamDef:
  @QName: errResource
  @enDesc:
    A resource on which an error has occurred. 

XParamDef:
  @QName: generatedName
  @enDesc:
    A generated name. 

ClsDef:
  @ClsQName: ManakaiDISPropertyAccessor
  @enDesc:
    Accessor methods for resource or module properties. 
  
  @Method:
    @@Name: getPropertyBoolean
    @@enDesc:
      Gets boolean property value. 
    @@PropNameParam:
    @@Param:
      @@@Name:default
      @@@Type:
        DOMMain:boolean::ManakaiDOM:all
      @@@enDesc:
        The default value that is returned if no explicit property 
        value specification found for this resource. 
    @@Return:
      @@@Type:
        DOMMain:boolean::ManakaiDOM:all
      @@@enDesc:
        The property value. 
      @@@PerlDef:
        if (exists $self->{$propName}) {
          $r = defined $self->{$propName} ? $self->{$propName} : $default;
        } elsif ($self->{src}) {
          $r = $self->{src}-><M::ManakaiDISElement.disGetAttribute>
                                ($propName, for_arg => $self->{for},
                                 forp_arg => $self->{forp});
          $self->{$propName} = $r;
          $r = $default unless defined $r;
        } else {
          $r = $default;
        }
        
  @Method:
    @@Name: getPropertyText
    @@enDesc:
      Gets property value text. 
    @@PropNameParam:
    @@Param:
      @@@Name:default
      @@@Type:
        swcfg21:SWCFGString::swcfg21:ForLatest
      @@@enDesc:
        The default value that is returned if no explicit property 
        value specification found for this resource. 
      @@@nullCase:
        @@@@enDesc:
          No default value supplied; <DOM::null> is returned if 
          no value specified. 
    @@Return:
      @@@Type:
        swcfg21:SWCFGString::swcfg21:ForLatest
      @@@enDesc:
        The property value string. 
      @@@nullCase:
        @@@@enDesc:
          No value nor default value has specified. 
      @@@PerlDef:
        if (exists $self->{$propName}) {
          $r = defined $self->{$propName} ? $self->{$propName} : $default;
        } elsif ($self->{src}) {
          $r = $self->{src}-><M::ManakaiDISElement.disGetAttribute>
                                ($propName, for_arg => $self->{for},
                                 forp_arg => $self->{forp});
          if ($r) {
            $r = $self->{$propName}
               = $r-><AG::swcfg21:SWCFGNode::swcfg21:ForLatest.value>;
            $r = $default unless defined $r;
          } else {
            $r = $default;
            $self->{$propName} = null;
          }
        } else {
          $r = $default;
        }
        
  @Method:
    @@Name: getPropertyResource
    @@enDesc:
      Gets property value resource. 
    @@PropNameParam:
    @@NamedParam:
      @@@Name: defaultMediaType
      @@@Type: ResourceURI
      @@@enDesc:
        The URI reference of the default media type which is used 
        when the property value is retrieved from the source tree 
        and the source tree element does not have its <Q::dis:ContentType>
        attribute specified. 
      @@@nullCase:
        @@@@enDesc:
          Defaulted to <Q::dis:TypeQName>.
    @@Return:
      @@@Type: ManakaiDISResourceDefinition
      @@@enDesc:
        The property value resource. 
      @@@nullCase:
        @@@@enDesc:
          No value has specified. 
      @@@UndeclaredPrefixException:
      @@@RaiseException:
        @@@@@:UNSUPPORTED_MEDIA_TYPE_ERR
        @@@@enDesc:
          The media type of the attribute node in the source tree
          corresponding to this resource is not supported. 
      @@@PerlDef:
        if (defined $self->{$propName}) {
          $r = $self->{db}-><M::ManakaiDISDatabase.getResource>
                                                    ($self->{$propName});
        } elsif ($self->{src}) {
          __DEEP{
            $r = $self->{src}-><M::ManakaiDISElement.disGetAttribute>
                                  ($propName, for_arg => $self->{for},
                                   forp_arg => $self->{forp});
            if ($r) {
              $defaultMediaType = <Q::dis:TypeQName>
                                           unless defined $defaultMediaType;
              if ($r-><M::ManakaiDISElement.mediaTypeMatch>
                                   (<Q::dis:TypeQName>, $defaultMediaType,
                                    for_arg => $self->{for},
                                    forp_arg => $self->{forp})) {
                $self->{$propName}
                   = $r-><AG::ManakaiDISElement.qnameValueURI>;
              } elsif ($r-><M::ManakaiDISElement.mediaTypeMatch>
                                   (<Q::dis:TFQNames>, $defaultMediaType,
                                    for_arg => $self->{for},
                                    forp_arg => $self->{forp})) {
                $self->{$propName}
                   = $r-><M::ManakaiDISElement.tfqnamesValueURI>
                             ($self->{src}-><AG::swcfg21:SWCFGNode
                                               ::swcfg21:ForLatest.nodeID>,
                              $self->{for});
              } else {
                my $mt = $r-><M::ManakaiDISElement.mediaTypeURI>
                                   (for_arg => $self->{for},
                                    forp_arg => $self->{forp});
                __UNDEEP{
                  __EXCEPTION{UNSUPPORTED_MEDIA_TYPE_ERR::
                    DIS:uri => {$mt},
                    DIS:sourceNode => {$r},
                  }__;
                }__;
              }
              $r = $self->{db}-><M::ManakaiDISDatabase.getResource>
                                                    ($self->{$propName});
              $r-><M::ManakaiDISResourceDefinition.isReferred> ($self->{src});
            }
          }__;
        }

  @Method:
    @@Name: getPropertyResourceList
    @@enDesc:
      Gets property value resource list. 
    @@PropNameParam:
    @@NamedParam:
      @@@Name: recursiveISA
      @@@Type:
        DOMMain:boolean
      @@@enDesc:
        Whether property resource values of <Q::dis:ISA> resources 
        of this resource should also be included to the returned list or not. 
    @@NamedParam:
      @@@Name: defaultMediaType
      @@@Type: ResourceURI
      @@@enDesc:
        The URI reference of the default media type which is used 
        when the property value is retrieved from the source tree 
        and the source tree element does not have its <Q::dis:ContentType>
        attribute specified. 
      @@@nullCase:
        @@@@enDesc:
          Defaulted to <Q::dis:TypeQName>.
    @@Return:
      @@@Type: ResourceList
      @@@enDesc:
        An array reference of the property value resources. 
        \
        {NOTE:: This list is <QUOTE::dead>.
        \
        }
      @@@UndeclaredPrefixException:
      @@@RaiseException:
        @@@@@:UNSUPPORTED_MEDIA_TYPE_ERR
        @@@@enDesc:
          The media type of the attribute node in the source tree
          corresponding to this resource is not supported. 
      @@@PerlDef:
        $r = [];
        if (defined $self->{$propName}) {
          for my $res_uri (@{ref $self->{$propName} eq 'ARRAY'
                                         ? $self->{$propName} : []}) {
            push @$r,
                 $self->{db}-><M::ManakaiDISDatabase.getResource> ($res_uri);
          }
        } elsif ($self->{src}) {
          __DEEP{
            $self->{$propName} = [];
            $defaultMediaType = <Q::dis:TypeQName>
                                           unless defined $defaultMediaType;
            for my $res_name_node
                    (@{$self->{src}-><M::ManakaiDISElement.disGetAttributeList>
                                  ($propName, for_arg => $self->{for},
                                   forp_arg => $self->{forp})}) {
              my $res_uri;
              if ($res_name_node-><M::ManakaiDISElement.mediaTypeMatch>
                                   (<Q::dis:TypeQName>, $defaultMediaType,
                                    for_arg => $self->{for},
                                    forp_arg => $self->{forp})) {
                $res_uri = $res_name_node-><AG::ManakaiDISElement.qnameValueURI>;
              } elsif ($res_name_node-><M::ManakaiDISElement.mediaTypeMatch>
                                   (<Q::dis:TFQNames>, $defaultMediaType,
                                    for_arg => $self->{for},
                                    forp_arg => $self->{forp})) {
                $res_uri =$res_name_node-><M::ManakaiDISElement.tfqnamesValueURI>
                             ($self->{src}-><AG::swcfg21:SWCFGNode
                                               ::swcfg21:ForLatest.nodeID>,
                              $self->{for});
              } else {
                my $mt = $res_name_node-><M::ManakaiDISElement.mediaTypeURI>
                                   (for_arg => $self->{for},
                                    forp_arg => $self->{forp});
                __UNDEEP{
                  __EXCEPTION{UNSUPPORTED_MEDIA_TYPE_ERR::
                    DIS:uri => {$mt},
                    DIS:sourceNode => {$res_name_node},
                  }__;
                }__;
              }
              push @{$self->{$propName}}, $res_uri;
              my $res = $self->{db}-><M::ManakaiDISDatabase.getResource>
                                                                ($res_uri);
              push @$r, $res;
              $res-><M::ManakaiDISResourceDefinition.isReferred>
                                                         ($res_name_node);
            }
          }__;
        }
        if ($recursiveISA) {
          __DEEP{
            $opt{___recursive_isa_done} ||= {$self->{uri} => true};
            my @p_res = @$r;
            for my $p_res (@p_res) {
              next if $opt{___recursive_isa_done}->{$p_res->{uri}};
              $opt{___recursive_isa_done}->{$p_res->{uri}} = true;
              push @$r, @{$p_res-><M::ManakaiDISPropertyAccessor
                                     .getPropertyResourceList>
                                          (<Q::dis:ISA>, recursive_isa => true,
                         ___recursive_isa_done => $opt{___recursive_isa_done},
                         default_media_type => $defaultMediaType)};
            }
          }__;
        }

  @Method:
    @@Name: addPropertyResourceList
    @@enDesc:
      Adds a resource to a resource-list property value. 
      \
      {ISSUE:: Should an exception be thrown if the property is 
               not of list?
      \
      }
      \
      {NOTE:: If the property is not <QUOTE::get>ten ever, adding 
              an item clears the list --- i.e. the property values 
              in the source tree will be ignored.  Call
              <M::ManakaiDISPropertyAccessor.getPropertyResourceList>
              before adding to avoid this behavior. 
      \
      }
    @@PropNameParam:
    @@Param:
      @@@Name: res
      @@@Type: ManakaiDISResourceDefinition
      @@@enDesc:
        A resource to add. 
    @@Return:
      @@@PerlDef:
        if (ref $self->{$propName} eq 'ARRAY') {
          push @{$self->{$propName}}, $res->{uri};
        } elsif (not defined $self->{$propName}) {
          $self->{$propName} = [$res->{uri}];
        }

ElementTypeBinding:
  @Name: PropNameParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:MethodParameter
    @@Name: propName
    @@Type: ResourceURI
    @@Description:
      @@@lang:en
      @@@@:
        The name of the property. 

##DISPropertyAccessor

PropDef:
  @QName:isAnon
  @Description:
    @@lang:en
    @@@:
      Whether the subject resource is anonymous or not. 
  @Type:
    DOMMain:boolean

PropDef:
  @QName:isDefined
  @Description:
    @@lang:en
    @@@:
      Whether the subject resource is defined or not. 

PropDef:
  @QName:isReferred
  @Description:
    @@lang:en
    @@@:
      Whether the subject resource is referred or not. 
  @Type:
    DOMMain:any

PropDef:
  @QName:definingModule
  @Description:
    @@lang:en
    @@@:
      The <QUOTE::dis> module in which the subject resource is defined. 
  @rdfs:domain:
    DISCore:Module

## -- Datatypes

URITypeDef:
  @QName: AnyURI
  @Description:
    @@lang:en
    @@@:
      Any URI references. 

URITypeDef:
  @QName: FileURI
  @enDesc:
    URI references identifying file. 

URITypeDef:
  @QName: ForURI
  @Description:
    @@lang:en
    @@@:
      <QUOTE::For> URI references. 

DataTypeDef:
  @QName: ForURIList
  @Description:
    @@lang:en
    @@@:
      References to the array containing <QUOTE::for> URI references. 

URITypeDef:
  @QName: ResourceURI
  @Description:
    @@lang:en
    @@@:
      A URI reference for a <QUOTE::dis> resource. 

URITypeDef:
  @QName: MediaTypeURI
  @Description:
    @@lang:en
    @@@:
      Media type URI references. 
  @rdfs:subClassOf: ResourceURI

URITypeDef:
  @QName: ModuleURI
  @enDesc:
    URI references for <QUOET::dis> modules. 
  @rdfs:subClassOf: ResourceURI

URITypeDef:
  @QName: NameURI
  @enDesc:
    URI references identifying a resource. 
  @rdfs:subClassOf: ResourceURI

DataTypeDef:
  @QName: ResourceList
  @enDesc:
    References to array containing resource definition objects.
  @rdfs:subClassOf:
    Perl:ARRAY::ManakaiDOM:all

ElementTypeBinding:
  @Name: DataTypeDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:DataType

ElementTypeBinding:
  @Name: URITypeDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:DataType
    @@rdfs:subClassOf: AnyURI

## -- Exceptions

XParamDef:
  @QName: anotherSourceNode
  @enDesc:
    Another source node in which an error has occurred.  In cases 
    of <QUOTE::already defined> errors, it is the node that 
    defines the resource first. 
  @Type: ManakaiDISNode

ResourceDef:
  @QName: UNDECLARED_NS_PREFIX_ERR
  @For: ForLatest
  @AliasFor: 
    DIS:UNDECLARED_NS_PREFIX_ERR::swcfg21:ForLatest

ExceptionDef:
  @ClsQName: ManakaiDISException
  @enDesc:
    Exceptions for the <QUOTE::dis> operations. 
  @ClsISA:
    ManakaiDOM:ManakaiDOMException::ManakaiDOM:Perl
  @XConstGroupDef:
    @@ClsQName: ManakaiDISExceptionCode
    @@enDesc:
      Exception codes for <Class::ManakaiDISException>. 
    @@XConstDef:
      @@@Name: HIERARCHY_REQUEST_ERR
      @@@Value:3
      @@@enDesc:
        An attempt is made to break the hierarchy. 
      @@@XSubTypeDef:
        @@@@QName: MERGE_ITSELF_ERR
        @@@@enDesc:
          An attempt is made to merge the resource to itself. 
        @@@@XSourceNodeParam:
        @@@@XParam:
          @@@@@QName:uri
          @@@@@enDesc:
            The URI reference of the resource to merge. 
        @@@@enMufDef:
          An attempt is made to merge the resource <%p (name => {<Q::DIS:uri>}
          );> to itself
    @@XConstDef:
      @@@Name: NOT_SUPPORTED_ERR
      @@@Value:9
      @@@enDesc:
        An attempt is made to do something the implementation does not support. 
      @@@XSubTypeDef:
        @@@@QName: UNSUPPORTED_MEDIA_TYPE_ERR
        @@@@enDesc:
          The implementation does not support the media type. 
        @@@@XParam:
          @@@@@QName: uri
          @@@@@enDesc:
            The URI reference of the media type that is not supported. 
        @@@@XSourceNodeParam:
        @@@@enMufDef:
          Media type <%p (name => {<Q::DIS:uri>});> is not supported
      @@@XSubTypeDef:
        @@@@QName: NO_PERL_CODE_IMPL_ERR
        @@@@enDesc:
          There is no implementation that supports the 
          <Feature::Util:PerlCode> feature, version 
          <FeatureVer::1.0>.
    @@XConstDef:
      @@@Name: INVALID_STATE_ERR
      @@@Value:11
      @@@enDesc:
        An attempt is made to use an object that is not (or no longer) usable. 
      @@@XSubTypeDef:
        @@@@QName: NO_ASSOCIATED_DB_ERR
        @@@@enDesc:
          No <QUOTE::dis> database has been associated with this document. 
    @@XConstDef:
      @@@Name: INVALID_SOURCE_ERR
      @@@Value: 200
      @@@enDesc:
        The source input is well-formed but invalid. 
      @@@XSubTypeDef:
        @@@@QName: NO_MODULE_QNAME_ERR
        @@@@enDesc:
          The <Q::dis:Module> element must have its <Q::dis:QName> 
          attribute. 
        @@@@XSourceNodeParam:
      @@@XSubTypeDef:
        @@@@QName: NO_LOCAL_NAME_ERR
        @@@@enDesc:
          The resource does not have a local name. 
        @@@@XSourceNodeParam:
      @@@XSubTypeDef:
        @@@@QName: UNABLE_TO_GET_MODULE_ERR
        @@@@enDesc:
          The implementation is unable to get the module source. 
        @@@@Def:
          @@@@@ContentType:
            lang:muf
          @@@@@lang:en
          @@@@@@:
            Unable to get the module source of <%p (name => {<Q::DIS:uri>});>
        @@@@XParam:
          @@@@@QName: uri
          @@@@@enDesc:
            The URI reference of the module. 
        @@@@XParam:
          @@@@@QName: namespaceURI
          @@@@@enDesc:
            The namespace URI of the module name. 
        @@@@XParam:
          @@@@@QName: localName
          @@@@@enDesc:
            The local name of the module name. 
        @@@@XParam:
          @@@@@QName: for
          @@@@@enDesc:
            The <QUOTE::for> of the module.
      @@@XSubTypeDef:
        @@@@QName: NO_FOR_QNAME_ERR
        @@@@enDesc:
          A <Q::dis:ForDef> element must have <Q::dis:QName> attribute. 
        @@@@XSourceNodeParam:
      @@@XSubTypeDef:
        @@@@QName: FOR_ALREADY_DEFINED_ERR
        @@@@enDesc:
          The <QUOTE::for> named as the same URI reference has 
          already defined. 
        @@@@XSourceNodeParam:
        @@@@XParam:
          @@@@@QName: anotherSourceNode
          @@@@@enDesc:
            The node that defines the <QUOTE::for> URI reference before. 
        @@@@XParam:
          @@@@@Name: uri
          @@@@@enDesc:
            The URI reference of the <QUOTE::for> attempted to define. 
        @@@@enMufDef:
          <QUOTE::For> <%p (name => {<Q::DIS:uri>});> is already defined
      @@@XSubTypeDef:
        @@@@QName: RESOURCE_ALREADY_DEFINED_ERR
        @@@@enDesc:
          The <QUOTE::dis> resource named as the same URI reference has 
          already defined. 
        @@@@XSourceNodeParam:
        @@@@XParam:
          @@@@@QName: anotherSourceNode
          @@@@@enDesc:
            The node that defines the <QUOTE::for> URI reference before. 
        @@@@XParam:
          @@@@@Name: uri
          @@@@@enDesc:
            The URI reference of the resource attempted to define. 
        @@@@enMufDef:
          Resource <%p (name => {<Q::DIS:uri>});> is already defined
      @@@XSubTypeDef:
        @@@@QName: ELEMENT_NOT_ALLOWED_ERR
        @@@@enDesc:
          An element has occured where it is not allowed. 
        @@@@enMufDef:
          Module <%p (name => {<Q::DIS:uri>});>: 
          Element of type <%p (name => {<Q::DIS:elementType>});> 
          is not allowed here
        @@@@XSourceNodeParam:
        @@@@XParam:
          @@@@@QName: elementType
          @@@@@enDesc:
            The expanded element type name of the element. 
        @@@@XParam:
          @@@@@QName: uri
          @@@@@enDesc:
            The URI reference of the module. 
      @@@XSubTypeDef:
        @@@@QName: NO_REQUIRED_ATTR_ERR
        @@@@enDesc:
          A required attribute is not specified.
        @@@@XSourceNodeParam:
        @@@@XParam:
          @@@@@QName: elementType
          @@@@@enDesc:
            The expanded URI reference of the attribute name. 
        @@@@enMufDef:
          Attribute <%p (name => {<Q::DIS:elementType>});> must be specified
      @@@XSubTypeDef:
        @@@@QName: FOR_NOT_DEFINED_ERR
        @@@@enDesc:
          A <QUOTE::for> is referred but not defined. 
        @@@@XSourceNodeParam:
        @@@@XParam:
          @@@@@QName: uri
          @@@@@enDesc:
            The URI reference of the <QUOTE::for> that is not defined.
        @@@@enMufDef:
          <QUOTE::For> <%p (name => {<Q::DIS:uri>});> is not defined
      @@@XSubTypeDef:
        @@@@QName: RESOURCE_NOT_DEFINED_ERR
        @@@@enDesc:
          A <QUOTE::dis> resource is referred but not defined. 
        @@@@XSourceNodeParam:
        @@@@XParam:
          @@@@@QName: uri
          @@@@@enDesc:
            The URI reference of the resource that is not defined.
        @@@@enMufDef:
          Resource <%p (name => {<Q::DIS:uri>});> is not defined
      @@@XSubTypeDef:
        @@@@QName: RESERVED_PERL_METHOD_NAME_ERR
        @@@@enDesc:
          A reserved Perl method name is used. 
        @@@@XParam:
          @@@@@QName:uri
          @@@@@enDesc:
            The URI reference of the method resource. 
        @@@@XSourceNodeParam:
        @@@@XParam:
          @@@@@QName: generatedName
          @@@@@enDesc:
            A reserved method name. 
      @@@XSubTypeDef:
        @@@@QName: NO_DIS_TYPE_ERR
        @@@@enDesc:
          <Q::dis:Type> attribute is not found. 
        @@@@XSourceNodeParam:
      @@@XSubTypeDef:
        @@@@QName: NO_METHOD_RETURN_ERR
        @@@@enDesc:
          A <Q::DISLang:Method> resource does not have any
          <Q::DISLang:MethodReturn> child. 
        @@@@XSourceNodeParam:
      @@@XSubTypeDef:
        @@@@QName: NO_ATTR_GET_ERR
        @@@@enDesc:
          A <Q::DISLang:Attribute> resource does not have any
          <Q::DISLang:AttributeGet> child. 
        @@@@XSourceNodeParam:
##DISException

XParamDef:
  @QName: elementType
  @Type: ResourceURI
  @enDesc:
    The name of the element type. 

XParamDef:
  @QName: uri
  @Type: ResourceURI
  @enDesc:
    The name of the resource, composed from <Q::namespaceURI>, 
    <Q::localName> and <Q::for>. 

XParamDef:
  @QName: localName
  @Type: 
    DISCore:LocalName
  @enDesc:
    The local name of the resource, unique in <Q::namespaceURI> namespace. 

XParamDef:
  @QName: namespaceURI
  @Type: AnyURI
  @enDesc:
    The namespace URI reference of the resource name. 

XParamDef:
  @QName: for
  @Type: ForURI
  @enDesc:
    The <QUOTE::for> URI reference of the resource. 

ElementTypeBinding:
  @Name: XSourceNodeParam
  @ElementType:
    ManakaiDOM:exceptionOrWarningParameter
  @ShadowContent:
    @@QName: sourceNode
    @@Description:
      @@@lang:en
      @@@@:
        The node in which an error has occurred. 

ClsDef:
  @ClsQName: ManakaiDISExceptionTarget
  @enDesc:
    Objects that is able to be the target of an exception. 
  @IntMethod:
    @@Operator:
      @@@@:
        ManakaiDOM:MUErrorHandler
      @@@ContentType:
        dis:TypeQName
    @@Description:
      @@@lang:en
      @@@@:
        This method is a generic error handler; all manakai exceptions 
        and warnings associated to an object are once reported to this method 
        and then delivered to appropriate entities. 
        \
        If the error is an exception (such as <X::DOMCore:DOMException> or 
        <X::ManakaiDOM:ManakaiDOMImplementationException>), it is 
        simply thrown.  If the error is only a warning, it is reported 
        via the <IF::DOMCore:DOMError> interface. 
        \
        See <PerlModule::Message::Util::Error> documentation for more 
        information on the error reporting mechanism.
        \
        {NOTE:: This kind of methods are named as <Perl::___report_error> 
                in the convention of <PerlModule::Message::Util::Error>. 
        \
        }
    @@Param:
      @@@Name:err
      @@@Type: 
        ManakaiDOM:ManakaiDOMExceptionOrWarning::ManakaiDOM:Perl
      @@@Description:
        @@@@lang:en
        @@@@@:
          An exception object that describes what kind of error it is 
          and how it should be recovered. 
          \
          {NOTE:: Exception objects in manakai implementation 
                  inherit the class <PerlModule::Message::Util::Error>, 
                  that in turn inherits <PerlModule::Error>.
          \
          }
    @@Return:
      @@@PerlDef:
          if ($err->isa (<ClassName::ManakaiDOM:ManakaiDOMException
                                   ::ManakaiDOM:Perl>)) {
            $err->throw;
          } else {
            \## TODO: Implement warning reporting
            warn $err->stringify;
          }
##DISExceptionTarget

ForDef:
  @QName:
    DIS:ForIF
ForDef:
  @QName:
    DIS:ForClass

ElementTypeBinding:
  @Name: IFClsDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      @@@@:
        dis:MultipleResource
      @@@ForCheck: !ForClass !ForIF
    @@rdf:type:
      @@@@:
        ManakaiDOM:IF
      @@@ForCheck: ForIF
    @@rdf:type:
      @@@@:
        ManakaiDOM:Class
      @@@ForCheck: ForClass
    @@resourceFor: ForIF
    @@resourceFor:
      @@@@: ForClass
      @@@ForCheck: ForLatest
    @@DOMMain:implementFeature:
      @@@@:CoreFeature10
      @@@ForCheck: ForClass
    @@ForCheck:
      ManakaiDOM:Perl

ElementTypeBinding:
  @Name: ClsDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:Class
    @@AliasFor:
      @@@@:
        ::DIS:ForLatest
      @@@For:
        !=DIS:ForLatest
    @@ForCheck:
      ManakaiDOM:Perl
    @@DOMMain:implementFeature: CoreFeature10

ElementTypeBinding:
  @Name: ExceptionDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:ExceptionClass
    @@AliasFor:
      @@@@:
        ::ForLatest
      @@@For:
        !=ForLatest
    @@ForCheck:
      ManakaiDOM:Perl
    @@DOMMain:implementFeature: CoreFeature10

ElementTypeBinding:
  @Name: ClsQName
  @ElementType:
    dis:QName

ElementTypeBinding:
  @Name: ClsISA
  @ElementType:
    dis:ISA

ElementTypeBinding:
  @Name: Method
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:Method

ElementTypeBinding:
  @Name: IntMethod
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:Method
    @@ManakaiDOM:isForInternal:1

ElementTypeBinding:
  @Name: Attr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:Attribute

ElementTypeBinding:
  @Name: Return
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:MethodReturn

ElementTypeBinding:
  @Name: Get
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:AttributeGet

ElementTypeBinding:
  @Name: Set
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:AttributeSet

ElementTypeBinding:
  @Name: Param
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:MethodParameter

ElementTypeBinding:
  @Name: PerlDef
  @ElementType:
    dis:Def
  @ShadowContent:
    @@ContentType:
      lang:Perl

ElementTypeBinding:
  @Name: disDef
  @ElementType:
    dis:Def
  @ShadowContent:
    @@ContentType:
      lang:dis

ElementTypeBinding:
  @Name: InCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:InCase

ElementTypeBinding:
  @Name: nullCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:InCase
    @@Value:
      @@@is-null:1

ElementTypeBinding:
  @Name: TrueCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:InCase
    @@Value:true
    @@Type:
      DOMMain:boolean


ElementTypeBinding:
  @Name: FalseCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:InCase
    @@Value:false
    @@Type:
      DOMMain:boolean

ElementTypeBinding:
  @Name: enDesc
  @ElementType:
    dis:Description
  @ShadowContent:
    @@lang:en

ElementTypeBinding:
  @Name: PropDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      rdf:Property
    @@AliasFor:
      @@@@:
        ::ManakaiDOM:all
      @@@For:
        !=ManakaiDOM:all

ElementTypeBinding:
  @Name: MethodRedef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:Method
    @@ManakaiDOM:isRedefining:1

ElementTypeBinding:
  @Name: NamedParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:MethodParameter
    @@DISPerl:isNamedParameter:1

ElementTypeBinding:
  @Name: NodeParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:MethodParameter
    @@DISPerl:isNamedParameter:1
    @@Name: node
    @@Type: ManakaiDISNode
    @@Description:
      @@@lang:en
      @@@@:
        The node in which the name has occurred.  It is intended 
        to be reported when an exception had been raised. 
    @@ResourceDef:
      @@@rdf:type:
        ManakaiDOM:InCase
      @@@Value:
        @@@@is-null:1
      @@@Description:
        @@@@lang:en
        @@@@@:
          The source of the name is not a node. 

ElementTypeBinding:
  @Name: ForParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:MethodParameter
    @@DISPerl:isNamedParameter:1
    @@Name: forArg
    @@Type: ForURI
    @@Description:
      @@@lang:en
      @@@@:
        The <QUOTE::for> URI reference. 
    @@ResourceDef:
      @@@rdf:type:
        ManakaiDOM:InCase
      @@@Value:
        @@@@is-null:1
      @@@Description:
        @@@@lang:en
        @@@@@:
          Equivalent to <Q::ManakaiDOM:all>, i.e. <QUOTE::for all>. 

ElementTypeBinding:
  @Name: ForpParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:MethodParameter
    @@DISPerl:isNamedParameter:1
    @@Name: forpArg
    @@Type: ForURIList
    @@Description:
      @@@lang:en
      @@@@:
        An array reference containing additional <QUOTE::for> 
        constraints (<QUOTE::For+> list).
    @@ResourceDef:
      @@@rdf:type:
        ManakaiDOM:InCase
      @@@Value:
        @@@@is-null:1
      @@@Description:
        @@@@lang:en
        @@@@@:
          Equivalent to the empty array reference. 

ElementTypeBinding:
  @Name: MediaTypeParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:MethodParameter
    @@DISPerl:isNamedParameter:1
    @@Name: mediaType
    @@Type: MediaTypeURI
    @@Description:
      @@@lang:en
      @@@@:
        The URI reference identifying a media type. 
    @@ResourceDef:
      @@@rdf:type:
        ManakaiDOM:InCase
      @@@Value:
        @@@@is-null:1
      @@@Description:
        @@@@lang:en
        @@@@@:
          No media type specified. 

ElementTypeBinding:
  @Name: MediaTypeDefaultParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:MethodParameter
    @@DISPerl:isNamedParameter:1
    @@Name: defaultMediaType
    @@Type: MediaTypeURI
    @@Description:
      @@@lang:en
      @@@@:
        The default media type, i.e. the type used when no explicit 
        specification is not found in the source tree. 
    @@ResourceDef:
      @@@rdf:type:
        ManakaiDOM:InCase
      @@@Value:
        @@@@is-null:1
      @@@Description:
        @@@@lang:en
        @@@@@:
          Defaulted to <Q::DOMMain:any>. 

ElementTypeBinding:
  @Name: RaiseException
  @ElementType:
    ManakaiDOM:raises

ElementTypeBinding:
  @Name: UndeclaredPrefixException
  @ElementType:
    ManakaiDOM:raises
  @ShadowContent:
    @@@: UNDECLARED_NS_PREFIX_ERR
    @@Description:
      @@@lang:en
      @@@@:
        The implementation has encounted an undeclared namespace prefix. 

ElementTypeBinding:
  @Name: NoDBException
  @ElementType:
    ManakaiDOM:raises
  @ShadowContent:
    @@@: NO_DB_ASSOCIATED_ERR
    @@Description:
      @@@lang:en
      @@@@:
        No <QUOTE::dis> database is associated to this document. 

ElementTypeBinding:
  @Name: XConstGroupDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:ConstGroup
    @@Type:
      DOMMain:unsigned-short::ManakaiDOM:all
    @@rdfs:subClassOf:
      DOMMain:unsigned-short::ManakaiDOM:all

ElementTypeBinding:
  @Name: XConstDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:Const

ElementTypeBinding:
  @Name: XSubTypeDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:ExceptionOrWarningSubType

ElementTypeBinding:
  @Name: XParam
  @ElementType:
    ManakaiDOM:exceptionOrWarningParameter

ElementTypeBinding:
  @Name: XParamDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: 
      DOMMain:XWParameter
    @@For:
      =ManakaiDOM:all

ElementTypeBinding:
  @Name: enMufDef
  @ElementType:
    dis:Def
  @ShadowContent:
    @@ContentType:
      lang:muf
    @@lang:en

