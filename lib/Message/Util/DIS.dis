Module:
  @QName: Util|DIS
  @FullName:
    @@lang: en
    @@@:
      <QUOTE::DIS> Object Model
  @Namespace:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS#
  
  @Description:
    @@lang:en
    @@@:
      This module provides an object model for <QUOTE::dis> document format.  

  @DISCore:author: DISCore|Wakaba
  @License:
    @@@:
      license:Perl+MPL
    @@Original:
      @@@FullName:
        manakai <CODE::lib/manakai/dis.pl> and <CODE::bin/cdis2pm.pl>
      @@@Year:2004
      @@@DISCore:author: DISCore|Wakaba
  @Date:
    $Date: 2006/11/03 17:53:33 $
  
  @Require:
    @@Module:
      @@@QName: Markup|SuikaWikiConfig21
      @@@WithFor: swcfg21|ForLatest
    @@Module:
      @@@QName: Util|DIS
      @@@WithFor: DIS|ForLatest
    @@Module:
      @@@QName: Util|DIS
      @@@WithFor: DIS|ForEmpty
    @@Module:
      @@@QName: MDOM|DOMFeature
      @@@WithFor: ManakaiDOM|ManakaiDOMLatest
    @@Module:
      @@@QName: DIS|Perl
      @@@WithFor: DIS|ForLatest
    @@Module:
      @@@QName: DIS|Value
      @@@WithFor: DIS|ForLatest
    @@Module:
      @@@QName: MDOM|DOMCore
      @@@WithFor: ManakaiDOM|ManakaiDOMLatest
    @@Module:
      @@@QName: MDOM|TreeStore
      @@@WithFor: ManakaiDOM|ManakaiDOMLatest
  @DefaultFor: DIS|ForLatest

Namespace:
  @c:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#
  @DIS:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS#
  @dis:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#dis--
  @DOMCore:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#
  @DOMLS:
    http://suika.fam.cx/~wakaba/archive/2004/dom/ls#
  @DOMMain:
    http://suika.fam.cx/~wakaba/archive/2004/dom/main#
  @dp:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS#Perl/
  @dv:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS#Value/
  @dx:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#
  @ecore:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/Core/
  @Err:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/
  @f:
    http://suika.fam.cx/~wakaba/archive/2004/dom/feature#
  @fe:
    http://suika.fam.cx/www/2006/feature/
  @idl:
    http://suika.fam.cx/~wakaba/archive/2004/dis/IDL#
  @infoset:
    http://www.w3.org/2001/04/infoset#
  @kwd:
    http://suika.fam.cx/~wakaba/archive/2005/rfc2119/
  @lang:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#
  @license:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/license#
  @ManakaiDOM:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#
  @Markup:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Markup#
  @MDOM:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#ManakaiDOM.
  @MDOMX:
    http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#
  @mn:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/ManakaiNode#
  @rdf:
    http://www.w3.org/1999/02/22-rdf-syntax-ns#
  @rdfs:
    http://www.w3.org/2000/01/rdf-schema#
  @s:
    http://suika.fam.cx/~wakaba/archive/2004/dis/Markup#
  @swcfg21:
    http://suika.fam.cx/~wakaba/archive/2005/swcfg21#
  @tc:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/DOM/TreeCore/
  @td:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/DOM/Document/
  @te:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/DOM/Element/
  @test:
    http://suika.fam.cx/~wakaba/archive/2004/dis/Test#
  @tst:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/DOM/TreeStore/
  @Util:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/

## -- "For" definitions

ForDef:
  @QName: DIS|ForEmpty
  @enDesc:
    For any version
  @ISA: ManakaiDOM|Perl

ForDef:
  @QName: 
    DIS:ForLatest
  @Description:
    @@lang:en
    @@@:
      For latest version of the <Module::Util:DIS> module implementation
  @ISA: DIS|ForEmpty

## -- Module sets

ResourceDef:
  @QName: Util|
  @For: DIS|ForEmpty
  @rdf:type: dis|ModuleGroup
  @FullName:
    @@lang:en
    @@@:
      Manakai support modules
  @DISPerl:packageName:
    Message::Util::
  @DISPerl:interfacePackageName:
    @@@:
      Message::Util::IF::
    @@For: DIS|ForEmpty !DIS|ForLatest
  @DISPerl:interfacePackageName:
    @@@:
      Message::Util::IFLatest::
    @@For: DIS|ForLatest
  @ImplNote:
    @@lang:en
    @@@:
      Resources <Q::Util|> for <Q::ManakaiDOM|all> and for <Q::ManakaiDOM|Perl>
      is defined in module <Module::Util|ManakaiNode>.

## -- Features

ElementTypeBinding:
  @Name: FeatureDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DOMFeature|Feature
    @@ForCheck:
      =ManakaiDOM:all

ElementTypeBinding:
  @Name: FeatureVerDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DOMFeature|Feature

ElementTypeBinding:
  @Name: featureQName
  @ElementType:
    DOMFeature:name
  @ShadowContent:
    @@ContentType: DISCore|QName

FeatureDef:
  @QName: Core
  @FeatureVerDef:
    @@QName: CoreFeature10
    @@Version: 1.0
    @@DOMFeature:instanceOf: Core
    @@FullName:
      @@@lang:en
      @@@@:
        The <QUOTE::dis> object model, version 1.0
    @@Description:
      @@@lang:en
      @@@@:
        The <QUOTE::dis> object model, version 1.0. 
    @@DOMMain:requireFeature: 
      swcfg21:CoreFeature21

## -- Roles

ElementTypeBinding:
  @Name: RoleDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:Role
    @@ForCheck:
      =ManakaiDOM:all

RoleDef:
  @QName: ModuleRole
  @enDesc:
    Any class playing this role may be returned by
    <M::ManakaiDISModuleDefinition.getFeature> method with
    appropriate feature parameters.

RoleDef:
  @QName: ForRole
  @enDesc:
    Any class playing this role may be returned by
    <M::ManakaiDISForDefinition.getFeature> method with
    appropriate feature parameters.

RoleDef:
  @QName: ResourceRole
  @enDesc:
    Any class playing this role may be returned by
    <M::ManakaiDISResourceDefinition.getFeature> method with
    appropriate feature parameters.

RoleDef:
  @QName: ElementRole
  @enDesc:
    Any class playing this role may be returned by
    <M::ManakaiDISElement.getFeature> method with
    appropriate feature parameters.

RoleDef:
  @QName: DatabaseRole
  @enDesc:
    Any class playing this role may be returned by
    <M::ManakaiDISDatabase.getFeature> method with
    appropriate feature parameters.


ElementTypeBinding:
  @Name: IFQName
  @ElementType:
    dis:QName
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForIF

ElementTypeBinding:
  @Name: ClsQName
  @ElementType:
    dis:QName
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: IFISA
  @ElementType:
    dis:ISA
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForIF

ElementTypeBinding:
  @Name: ClsISA
  @ElementType:
    dis:ISA
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: IFClsDef
  @ElementType: 
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      @@@@: dis|MultipleResource
      @@@ForCheck: !ManakaiDOM|ForIF !ManakaiDOM|ForClass
    @@resourceFor: ManakaiDOM|ForIF
    @@resourceFor:
      @@@@: ManakaiDOM|ForClass
      @@@ForCheck: ForEmpty !=ForEmpty
    @@For: ForLatest
    @@For: =ForEmpty

    @@rdf:type:
      @@@@: ManakaiDOM|IF
      @@@ForCheck: ManakaiDOM|ForIF

    @@rdf:type:
      @@@@: ManakaiDOM|Class
      @@@ForCheck: ManakaiDOM|ForClass
    @@Implement:
      @@@@: ||ForEmpty||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ForEmpty
    @@Implement:
      @@@@: ||ForLatest||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ForLatest

    @@DOMMain:implementFeature:
      @@@@: CoreFeature10
      @@@For: ForLatest

ElementTypeBinding:
  @Name: ClsDef
  @ElementType: 
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      @@@@: dis|MultipleResource
      @@@ForCheck: !ManakaiDOM|ForIF !ManakaiDOM|ForClass

    @@resourceFor:
      @@@@: ManakaiDOM|ForClass
      @@@ForCheck: ForEmpty !=ForEmpty
    @@For: ForLatest

    @@rdf:type:
      @@@@: ManakaiDOM|Class
      @@@ForCheck: ManakaiDOM|ForClass

    @@DOMMain:implementFeature:
      @@@@: CoreFeature10
      @@@For: ForLatest

ElementTypeBinding:
  @Name: clsActualType
  @ElementType:
    dis:actualType
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass

## -- SuikaWikiConfig/2.1 extended classes

IFClsDef:
  @IFQName: DISImplementation
  @ClsQName: ManakaiDISImplementation

  @ClsISA:
    swcfg21:ManakaiSWCFGImplementation::swcfg21:ForLatest
  @ClsISA: dp|ManakaiDISImplementationPerl
  @ClsISA: dv|ManakaiDISImplementationValue

  @Description:
    @@lang:en
    @@@:
      A <QUOTE::dis> implementation object. 

  @Method:
    @@Name: createDISDocument
    @@Description:
      @@@lang:en
      @@@@:
        Creates an empty <IF::DISDocument> node.
    @@Return:
      @@@Type: DISDocument
      @@@clsActualType: ManakaiDISDocument
      @@@Description:
        @@@@lang:en
        @@@@@:
          The newly created <QUOTE::dis> document object.
      @@@PerlDef:
        $r = bless $self-><M::swcfg21:SWCFGImplementation::swcfg21:ForLatest
                                              .createSWCFGDocument>,
                   <ClassName::ManakaiDISDocument>;
        $r-><AS::swcfg21:SWCFGDocument::swcfg21:ForLatest
                                        .defaultElementTypeNamespaceURI>
                    (<Q::dis:>);

  @Method:
    @@Name: createDISParser
    @@Description:
      @@@lang:en
      @@@@:
        Creates a <IF::DISParser> object.
    @@Return:
      @@@Type: DISParser
      @@@clsActualType: ManakaiDISParser
      @@@Description:
        @@@@lang:en
        @@@@@: 
          A newly created <QUOTE::dis> parser. 
      @@@PerlDef:
        $r = bless $self-><M::swcfg21:SWCFGImplementation::swcfg21:ForLatest
                                           .createSWCFGParser>,
                   <ClassName::ManakaiDISParser>;

  @Method:
    @@Name: createDISDatabase
    @@Description:
      @@@lang:en
      @@@@:
        Creates a new <QUOTE::dis> database.
    @@Return:
      @@@Type: DISDatabase
      @@@clsActualType: ManakaiDISDatabase
      @@@Description:
        @@@@lang:en
        @@@@@:
          A newly created <QUOTE::dis> parser.
      @@@PerlDef:
        $r = bless {
          forDef => {
            <Q::ManakaiDOM:all> => bless ({
              uri => <Q::ManakaiDOM:all>,
              isa => {<Q::ManakaiDOM:all> => 1},
              revISA => {},
              <H::revision> => 0,
            }, <ClassName::ManakaiDISForDefinition>),
          },
          resDef => {},
          modDef => {},
          seq => 0,
        }, <ClassName::ManakaiDISDatabase>;
        $r->{forDef}->{<Q::ManakaiDOM:all>}->{db} = $r;

  @CODE:
    @@QName: createDISDBForTest
    @@PerlDef:
      $db = <ClassM::ManakaiDISImplementation.createDISDatabase>;

      my $any = $db-><M::DISDatabase.getResource> (<Q::DISCore|AnyResource>);

      my $mod = $db-><M::DISDatabase.getResource> (<Q::DISCore|Module>);
      $mod-><M::DISResource.addSuperResource> ($any);

      my $for = $db-><M::DISDatabase.getResource> (<Q::DISCore|For>);
      $for-><M::DISResource.addSuperResource> ($any);

      my $res = $db-><M::DISDatabase.getResource> (<Q::DISCore|Resource>);
      $res-><M::DISResource.addSuperResource> ($any);

  @Method:
    @@Name: tfurisToURI
    @@Description:
      @@@lang:en
      @@@@:
        Converts a pair of name URI reference and <QUOTE::for> URI reference 
        into a <Q::dis:TFQNames>-expanded URI reference. 
    @@Param:
      @@@Name: typeURI
      @@@Type: NameURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          A URI reference to identify a resource. 
      @@@nullCase:
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            Equivalent to <Q::DOMMain:any> (for historical reason). 
    @@Param:
      @@@Name: forURI
      @@@Type: ForURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          A <QUOTE::for> URI reference. 
      @@@nullCase:
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            Equivalent to <QUOTE::for all>, i.e. <Q::ManakaiDOM:all>. 
    @@Return:
      @@@Type: 
        DISCore:TFURI::ManakaiDOM:all
      @@@Description:
        @@@@lang:en
        @@@@@:
          The <Q::dis:TFQNames>-expanded URI references.  
      @@@PerlDef:
        $typeURI = <Q::DOMMain:any> unless defined $typeURI;
        $forURI = <Q::ManakaiDOM:all> unless defined $forURI;
        __CODE{tfurisToURI:: $turi => $typeURI, $furi => $forURI, $uri => $r}__;

  @ResourceDef:
    @@ForCheck: ManakaiDOM|ForClass
    @@QName: tfurisToURI
    @@rdf:type: DISPerl|BlockCode
    @@enDesc:
        Converts a pair of name URI reference and <QUOTE::for> URI reference 
        into a <Q::dis:TFQNames>-expanded URI reference. 
    @@PerlDef:      
        if ($furi eq <Q::ManakaiDOM:all>) {
          $uri = $turi;
        } else {
          ## NOTE: [RFC 3986]
          ##       fragment    := *(pchar / "/" / "?")
          ##       pchar       := unreserved / pct-encoded / sub-delims / [:@]
          ##       unreserved  := ALPHA / DIGIT / [._~-]
          ##       sub-delims  := [!$&'()*+,;=]
          ## NOTE: [XPointer Framework]
          ##       SchemeData  := *EscapedData
          ##       EscapedData := NormalChar / "^(" / "^)" / "^^"
          ##                    / "(" SchemeData ")"
          ##       NormalChar  := UnicodeChar - [()^]
          my $__turi = $turi;
          my $__furi = $furi;
          for my $__uri ($__turi, $__furi) {
            $__uri =~ s{([^0-9A-Za-z!\$'()*,:;=?\@_./~-])}{sprintf '%%%02X', ord $1}ge;
          }
          $uri = qq<tag:suika.fam.cx,2005-09:$__turi+$__furi>;
        }

  @ResourceDef:
    @@QName: tfpurisToURI
    @@rdf:type: DISPerl|BlockCode
    @@enDesc:
        Converts a set of name URI reference and <QUOTE::for> URI reference 
        and <QUOTE::for+> URI references into a URi reference. 
    @@ForCheck: ManakaiDOM|ForClass
    @@PerlDef:      
        if ($furi eq <Q::ManakaiDOM:all> and @{$forp} == 0) {
          $uri = $turi;
        } elsif (@{$forp}) {
          my $__turi = $turi;
          my $__furi = $furi;
          for my $__uri ($__turi, $__furi) {
            $__uri =~ s{([^0-9A-Za-z!\$'()*,:;=?\@_./~-])}{sprintf '%%%02X', ord $1}ge;
          }
          my @__fp;
          for my $__uri (@{$forp}) {
            my $__fpuri = $__uri;
            $__fpuri =~ s{([^0-9A-Za-z!\$'()*,:;=?\@_./~-])}
                         {sprintf '%%%02X', ord $1}ge;
            push @__fp, $__fpuri;
          }
          $uri = qq<tag:suika.fam.cx,2005-09:$__turi+$__furi+>.join ('+', @__fp);
        } else {
          my $__turi = $turi;
          my $__furi = $furi;
          for my $__uri ($__turi, $__furi) {
            $__uri =~ s{([^0-9A-Za-z!\$'(),*:;=?\@_./~-])}{sprintf '%%%02X', ord $1}ge;
          }
          $uri = qq<tag:suika.fam.cx,2005-09:$__turi+$__furi>;
        }

  @CODE:
    @@QName: composeSubsetURI
    @@PerlDef:
      my $__uri1 = $input1;
      my $__uri2 = $input2;
      for my $__uri ($__uri1, $__uri2) {
        $__uri =~ s{([^0-9A-Za-z!\$'()*,:;=?\@_./~-])}
                   {sprintf '%%%02X', ord $1}ge;
      }
      $output = qq<tag:suika.fam.cx,2006-02:$__uri1+$__uri2>;

  @ImplNote:
    @@lang:en
    @@@:
      {TODO:: IRI support.
      }

  @ResourceDef:
    @@QName: getChildResourceURI
    @@rdf:type: DISPerl|BlockCode
    @@enDesc:
      Gets an anonymous URI reference of a child resource of another 
      resource. 
    @@ForCheck: ManakaiDOM|ForClass
    @@PerlDef:
      my $__parent = $parentURI;
      my $__ln = $localName;
      for my $__uri ($__parent, $__ln) {
        $__uri =~ s{([^0-9A-Za-z!\$'(),*:;=?\@_./~-])}{sprintf '%%%02X', ord $1}ge;
      }
      $result = qq<data:suika.fam.cx,2005-09::$__parent+$__ln>;

  @IntMethod:
    @@Name: camelCaseToUnderscoreName
    @@enDesc:
      Converts a camelCase name to a underscored_name. 
    @@ManakaiDOM:isStatic:1
    @@ForCheck: ManakaiDOM|ForClass
    @@Param:
      @@@Name: camelName
      @@@Type:
        DISLang:String::ManakaiDOM:all
      @@@enDesc:
        The source name. 
    @@Return:
      @@@Type:
        DISLang:String::ManakaiDOM:all
      @@@enDesc:
        The result name. 
      @@@PerlDef:
        $r = $camelName;
        $r =~ s/^([A-Z0-9]+)$/lc $1/ge;
        $r =~ s/([A-Z][A-Z0-9]*)$/"_".lc $1/ge;
        $r =~ s/([A-Z0-9])([A-Z0-9]*)([A-Z0-9])/$1.lc ($2)."_".lc $3/ge;
        $r =~ s/([A-Z])/"_".lc $1/ge;
        $r =~ s/(?=[0-9](?!$))/_/g;
        $r =~ tr/-/_/;

  @DOMFeature:provides: CoreFeature10
##DISImplementation

ElementTypeBinding:
  @Name: CODE
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISPerl|BlockCode
    @@ForCheck: ManakaiDOM|ForClass

IFClsDef:
  @IFQName: DISParser
  @ClsQName: ManakaiDISParser

  @IFISA: swcfg21|SWCFGParser||swcfg21|ForLatest
  @ClsISA:
    swcfg21:ManakaiSWCFGParser::swcfg21:ForLatest

  @Description:
    @@lang:en
    @@@:
      A SuikaWikiConfig/2.1 parser that returns <QUOTE::dis> object. 
  @Method:
    @@Name: parse
    @@Description:
      @@@lang:en
      @@@@:
        Parses a <QUOTE::dis> document and returns it as an object tree. 
    @@Param:
      @@@Name: input
      @@@Type: DISPerl|HASH||ManakaiDOM|all
      @@@Description:
        @@@@lang:en
        @@@@@:
          The input source. 
    @@Return:
      @@@Type: DISDocument
      @@@clsActualType: ManakaiDISDocument
      @@@Description:
        @@@@lang:en
        @@@@@:
          The <QUOTE::dis> document object created from the <P::input>. 
      @@@RaiseException:
        @@@@@:
          swcfg21:SWCFG_PARSE_ERR::swcfg21:ForLatest
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The <IF::swcfg21:SWCFGParser> was unable to load the SuikaWikiConfig 
            document. 
      @@@PerlDef:
        __DEEP{
          $r = $self->SUPER::parse ($input)
                      ## NOTE: Method name directly written
                      #< M::swcfg21:ManakaiSWCFGParser
                      #  ::swcfg21:ForLatest.parse> ($input)
        }__;
        if (defined $r) {
          $r = bless $r, <ClassName::ManakaiDISDocument>;
          $r-><AS::swcfg21:SWCFGDocument::swcfg21:ForLatest
                                        .defaultElementTypeNamespaceURI>
                    (<Q::dis:>);
        }

  @IntMethod:
    @@ForCheck: ManakaiDOM|ForClass
    @@Operator: 
      @@@@: DISPerl|NewMethod
      @@@ContentType: DISCore|QName
    @@ForCheck: ManakaiDOM|ForClass
    @@enDesc:
      Creates a new instance of the <IF::DISParser> interface
      and returns it.

      {NOTE:: This method is compatible with the role <Q::DOMLS:ParserRole>
              so that this class is accessible via the
              <M::DOMLS|DOMImplementationLSExtended.createMLSParser>
              method.
      }
    @@Param:
      @@@Name: impl
      @@@Type: DOMFeature|MinimumImplementation||ManakaiDOM|ManakaiDOMLatest
      @@@enDesc:
        An implementation object.  The <M::DOMFeature|GetFeature.getFeature>
        method with parameter values <Feature::DIS|Core> and
        <FeatureVer::1.0> respectively <kwd:MUST> return
        an object implementing the <IF::DISImplementation> interface.
    @@Param:
      @@@Name: features
      @@@Type: DISLang|String||ManakaiDOM|all
      @@@dis:actualType: DOMFeature|FeaturesString||ManakaiDOM|ManakaiDOMLatest
      @@@enDesc:
        A list of requested features.  In the current implementation
        this parameter is ignored.
    @@Return:
      @@@Type: DOMMain|Object||ManakaiDOM|all
      @@@actualType: ManakaiDISParser
      @@@enDesc: The newly created parser object.
      @@@PerlDef:
        __DEEP{
          $r = $self->SUPER::new
                       ($impl-><M::DOMFeature|GetFeature
                                 ||ManakaiDOM|ManakaiDOMLatest.getFeature>
                           (<Q::swcfg21:Core> => '2.1'),
                        $features);
        }__;
##DISParser

IFClsDef:
  @IFQName: DISNode
  @ClsQName: ManakaiDISNode

  @Description:
    @@lang:en
    @@@:
      <QUOTE::dis> node objects. 
  @ImplNote:
    @@lang:en
    @@@:
      This class does not inherit 
      <Class::swcfg21:ManakaiSWCFGNode::swcfg21:ForLatest>, since 
      inheriting classes such as <Class::ManakaiDISElement> indirectly 
      inherit it. 

  @MethodRedef:
    @@ForCheck: ManakaiDOM|ForClass
    @@Name:lookupNamespacePrefix
    @@Description:
      @@@lang:en
      @@@@:
        Looks up the namespace prefix associated to the given 
        namespace URI.  The default namespaces are ignored. 
    @@Param:
      @@@Name:namespaceURI
      @@@Type: AnyURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          The namespace URI to look for. 
      @@@nullCase:
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The <DOM::null> namespace. 
    @@NamedParam:
      @@@Name: makeNewBinding
      @@@Type: 
        DOMMain:boolean::ManakaiDOM:all
      @@@Description:
        @@@@lang:en
        @@@@@:
          Whether a new namespace prefix should be bound when 
          no namespace URI has been associated yet. 
      @@@TrueCase:
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            New binding is made if no prefix associated. 
      @@@FalseCase:
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            Simply returns the <DOM::null> if no prefix associated. 
    @@Return:
      @@@Type: swcfg21|SWCFGString||swcfg21|ForLatest
      @@@actualType:
        DISCore:NamespacePrefix::ManakaiDOM:all
      @@@Description:
        @@@@lang:en
        @@@@@:
           An associated namespace prefix.  If more than one prefix 
           are associated to the namespace URI, the returned prefix 
           is implementation dependent. 
      @@@nullCase:
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            No associated namespace prefix found. 
      @@@PerlDef:
        $r = null;
        my $od = $self-><AG::swcfg21:SWCFGNode::swcfg21:ForLatest
                                          .ownerDocument> || $self;
        my $binds = $od->{<H::mn:node>}->{<H::swcfg21:nsBinding>};
        if (defined $namespaceURI) {
          FIND: {
            for my $prefix (keys %$binds) {
              if (defined $binds->{$prefix} and
                  $binds->{$prefix} eq $namespaceURI) {
                $r = $prefix;
                last FIND;
              }
            }

            ## From module list
            try {
              my $db = $self-><AG::ManakaiDISNode.ownerDISDocument>
                            -><AG::ManakaiDISDocument.disDatabase>;
              for my $mod_uri (keys %{$db->{modDef}}) {
                my $mod = $db-><M::ManakaiDISDatabase.getModule> ($mod_uri);
                my $mod_ln = $mod-><AG::DISAnyResource.localName>;
                next if exists $binds->{$mod_ln};
                my $ns_uri = $mod-><AG::DIS|DISModule.targetNamespaceURI>;
                $ns_uri = '' unless defined $ns_uri;
                if ($ns_uri eq $namespaceURI) {
                  $r = $mod_ln;
                  last FIND;
                }
              }
            } catch <IF::DISException> with {
              my $err = shift;
              $err->throw
                unless $err->{<Q::MDOMX:subtype>} eq <Q::NO_ASSOCIATED_DB_ERR>;
            };

            last FIND unless $makeNewBinding;
            ## Not found
            if ($namespaceURI =~ /(\w+)$/) {
              my $prefix = $1;
              unless (exists $binds->{$prefix}) {
                $binds->{$prefix} = $namespaceURI;
                $r = $prefix;
                last FIND;
              }
            }
            my $i = 1;
            {
              unless (exists $binds->{'ns'.$i}) {
                $binds->{$r = 'ns'.$i} = $namespaceURI;
                last FIND;
              }
              $i++;
              redo;
            }
          } # FIND
        } else {  ## Null namespace
          FIND: {
            if (exists $binds->{'nu'.'ll'} and not defined $binds->{'nu'.'ll'}) {
              $r = 'nu'.'ll';
              last FIND;
            }
            for my $prefix (keys %$binds) {
              if (not defined $prefix) {
                $r = $prefix;
                last FIND;
              }
            }
            last FIND unless $makeNewBinding;
            ## Not found
            my $i = '';
            {
              unless (exists $binds->{'nu'.'ll'.$i}) {
                $binds->{$r = 'nu'.'ll'.$i} = null;
                last FIND;
              }
              $i++;
              redo;
            }
          }
        }

  @MethodRedef:
    @@ForCheck: ManakaiDOM|ForClass
    @@Name:lookupNamespaceURI
    @@Description:
      @@@lang:en
      @@@@:
        Looks up the namespace URI associated to the given prefix. 
    @@Param:
      @@@Name:prefix
      @@@Type:
        DISCore:NamespacePrefix::ManakaiDOM:all
      @@@Description:
        @@@@lang:en
        @@@@@:
          The namespace URI to look for. 
    @@NamedParam:
      @@@Name: makeNewBinding
      @@@Type:
        DOMMain:boolean::ManakaiDOM:all
      @@@Description:
        @@@@lang:en
        @@@@@:
          Whether a new binding should be created if no namespace URI 
          is associated with the <P::prefix> or not. 
      @@@TrueCase:
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            A new binding to the temporary namespace URI 
            exactly same as <P::prefix> is created 
            if no binding found. 
      @@@FalseCase:
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            No new binding is created if no binding found.  Note that 
            even if no association newly created, this method 
            returns the <DOM::null> value. 
    @@NamedParam:
      @@@Name: raisePrefixException
      @@@Type:
        DOMMain:boolean::ManakaiDOM:all
      @@@enDesc:
        Whehter an exception should be thrown if <P::prefix>
        is not declared or not. 
    @@Return:
      @@@Type: AnyURI
      @@@Description:
        @@@@lang:en
        @@@@@:The associated namespace URI. 
      @@@nullCase:
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            No namespace URI is associated to the prefix or 
            the <DOM::null> namespace is associated. 
      @@@UndeclaredPrefixException:
      @@@PerlDef:
        my $od = $self-><AG::DISNode.ownerDISDocument> || $self;
        my $binds = $od->{<H::mn:node>}->{<H::swcfg21:nsBinding>};
        if (exists $binds->{$prefix}) {
          $r = $binds->{$prefix};
        } else {
          ## From module list
          FIND: {
            if ($od->{<H::mn:node>}->{<H::DIS|disNamespaceResolver>}) {
              $r = $od->{<H::mn:node>}->{<H::DIS|disNamespaceResolver>}
                      ->($prefix);
              last FIND if defined $r;
            }
            try {
              my $db = $od-><AG::DISDocument.disDatabase>;
              for my $mod_uri (keys %{$db->{modDef}}) {
                my $mod = $db-><M::ManakaiDISDatabase.getModule> ($mod_uri);
                if ($mod-><AG::DISAnyResource.localName>
                      eq $prefix) {
                  $r = $mod-><AG::DIS|DISModule.targetNamespaceURI>;
                  last FIND;
                }            
              }
            } catch <IF::DISException> with {
              my $err = shift;
              $err->throw
                unless $err->{<Q::MDOMX:subtype>} eq <Q::NO_ASSOCIATED_DB_ERR>;
            };
            if ($makeNewBinding) {
              $r = $binds->{$prefix} = $prefix;
            } elsif ($raisePrefixException) {
              __EXCEPTION{DIS:UNDECLARED_NS_PREFIX_ERR::
                infoset:prefix => {$prefix},
                MDOMX:param-name => 'prefix',
                DIS:sourceNode => {$self},
              }__;
            } else {
              $r = null;
            }
          } # FIND
        }

  @IntMethod:
    @@ForCheck: ManakaiDOM|ForClass
    @@Name:getNodeReference
    @@Description:
      @@@lang:en
      @@@@:
        Returns a new reference to the node object. 
    @@ManakaiDOM:isStatic:1
    @@Param:
      @@@Name:object
      @@@Type: ManakaiNode|NodeStem||ManakaiDOM|Perl
      @@@Description:
        @@@@lang:en
        @@@@@:
          The node object to be referred. 
    @@Return:
      @@@Type: ManakaiDISNode
      @@@Description:
        @@@@lang:en
        @@@@@:
          A newly created reference.
      @@@PerlDef:
        my $class;
        if ($object->{<H::swcfg21:nodeType>} eq '#element') {
          $class = <ClassName::ManakaiDISElement>;
        } elsif ($object->{<H::swcfg21:nodeType>} eq '#comment') {
          $class = <ClassName::ManakaiDISComment>;
        } elsif ($object->{<H::swcfg21:nodeType>} eq '#document') {
          $class = <ClassName::ManakaiDISDocument>;
        } elsif ($object->{<H::swcfg21:nodeType>} eq '#fragment') {
          $class = <ClassName::ManakaiDISDocumentFragment>;
        } else {
          __ASSERT{DISPerl:invariant::
            msg => {qq[Node type: "$object->{<H::swcfg21:nodeType>}" ].
                    qq[(ref: "@{[ref $object]}")]},
          }__;
        }
        __CODE{ManakaiNode|getNewReference||ManakaiDOM|Perl::
          $object => $object,
          $ref => $r,
          $class => $class,
        }__;
  
  @Attr:
    @@Name:ownerDISDocument
    @@Description:
      @@@lang:en
      @@@@:
        The <QUOTE::dis> document object associated with this node. 
    @@Get:
      @@@Type: DISDocument
      @@@clsActualType: ManakaiDISDocument
      @@@Description:
        @@@@lang:en
        @@@@@:
          The document object associated with this node. 
      @@@nullCase:
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            This node is a document node. 
      @@@PerlDef:
        $r = <ClassM::ManakaiDISNode.getNodeReference>
                ($self->{<H::mn:node>}->{<H::swcfg21:ownerDocument>})
          if $self->{<H::mn:node>}->{<H::swcfg21:ownerDocument>};
##DISNode

IFClsDef:
  @IFQName: NSResolverDIS
  @ClsQName: ManakaiNSResolverDIS


  @Method:
    @@Name: prefixToURI
    @@Description:
      @@@lang:en
      @@@@:
        Converts a namespace prefix into associated URI reference. 
    @@Param:
      @@@Name: prefix
      @@@Type:
        DISCore:NamespacePrefix::ManakaiDOM:all
      @@@Description:
        @@@@lang:en
        @@@@@:
          A namespace prefix to look for. 
      @@@nullCase:
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            Returns the default namespace URI. 
    @@NodeParam:
    @@Return:
      @@@Type: AnyURI
      @@@Description:
        @@@@lang:en
        @@@@@: The URI references associated. 
      @@@UndeclaredPrefixException:
      @@@PerlDef:
        if (defined $prefix) {
          __DEEP{
            $r = $self-><M::SWCFGNode.lookupNamespaceURI> ($prefix);
          }__;
          unless (defined $r) {
            __EXCEPTION{UNDECLARED_NS_PREFIX_ERR::
              infoset:prefix => {$prefix},
              MDOMX:param-name => 'prefix',
              DIS:sourceNode => {$node},
            }__;
          }
        } elsif (defined $self->{<H::mn:node>}
                              ->{<H::DIS|defaultNamespaceURI>}) {
          $r = $self->{<H::mn:node>}->{<H::DIS|defaultNamespaceURI>};
        } else {  ## Default namespace
          __DEEP{
            $r = ($self-><AG::ManakaiDISNode.ownerDISDocument> || $self)
                       -><AG::ManakaiDISDocument.moduleElement>
                       -><AG::ManakaiDISModuleElement.definingNamespaceURI>;
          }__;
        }

  @Method:
    @@Name: qnameToURI
    @@Description:
      @@@lang:en
      @@@@:
        Converts a qualified name (<Q::DISCore:QName>) to 
        an expanded URI reference. 
    @@Param:
      @@@Name: qname
      @@@Type: DISCore|QName||ManakaiDOM|all
      @@@Description:
        @@@@lang:en
        @@@@@:
          A qualified name. 
    @@NodeParam:
    @@NamedParam:
      @@@Name: defaultNamespaceURI
      @@@Type: AnyURI
      @@@enDesc:
        Default namespace URI reference. 
      @@@nullCase:
        @@@@enDesc:
          The default namespace is the namespace defined by the module
          to which this resource belongs.
    @@Return:
      @@@Type: AnyURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          The expanded URI reference. 
      @@@UndeclaredPrefixException:
      @@@PerlDef:
        $qname =~ s/^\s+//; $qname =~ s/\s+$//;
        my ($prefix, $lname) = split /\s*[:|]\s*/, $qname, 2;
        __DEEP{
          if (defined $lname) {
            $r = $self-><M::NSResolverDIS.prefixToURI> ($prefix) . $lname;
          } else {  ## In default namespace
            if (defined $defaultNamespaceURI) {
              $r = $defaultNamespaceURI . $prefix;
            } else {
              $r = $self-><M::NSResolverDIS.prefixToURI> (null) . $prefix;
            }
          }
        }__;

  @Method:
    @@Name: qnameToPair
    @@Description:
      @@@lang:en
      @@@@:
        Converts a qualified name (<Q::DISCore:QName>) to 
        a pair of namespace URI and local name. 
    @@Param:
      @@@Name: qname
      @@@Type: DISCore|QName||ManakaiDOM|all
      @@@Description:
        @@@@lang:en
        @@@@@:
          A qualified name. 
    @@NodeParam:
    @@Return:
      @@@Type:
        DISPerl:ARRAY::ManakaiDOM:all
      @@@Description:
        @@@@lang:en
        @@@@@:
          A list of namespace URI and local name. 
      @@@UndeclaredPrefixException:
      @@@PerlDef:
        $qname =~ s/^\s+//; $qname =~ s/\s+$//;
        my ($prefix, $lname) = split /\s*[:|]\s*/, $qname, 2;
        __DEEP{
          if (defined $lname) {
            $r = [$self-><M::NSResolverDIS.prefixToURI> ($prefix), $lname];
          } else {  ## In default namespace
            $r = [$self-><M::NSResolverDIS.prefixToURI> (null), $prefix];
          }
        }__;

  @Method:
    @@Name: tfqnamesToURI
    @@Description:
      @@@lang:en
      @@@@:
        Converts a <Q::dis:TFQNames>
        into an expanded URI reference. 
    @@Param:
      @@@Name: tfqnames
      @@@Type: 
        dis:TFQNames::ManakaiDOM:all
      @@@Description:
        @@@@lang:en
        @@@@@:
          A <Q::dis:TFQNames> to identify a resource. 
    @@Param:
      @@@Name: defaultTypeURI
      @@@Type: NameURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          A name URI reference used if it is missing from 
          <P::tfqnames>. 
      @@@nullCase:
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            Equivalent to <Q::DOMMain:any>. 
    @@Param:
      @@@Name: defaultForURI
      @@@Type: ForURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          A <QUOTE::for> URI reference used if it is missing from 
          <P::tfqnames>. 
      @@@nullCase:
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            Equivalent to <QUOTE::for all>, i.e. <Q::ManakaiDOM:all>. 
    @@NodeParam:
    @@Return:
      @@@Type: 
        DISCore:TFURI::ManakaiDOM:all
      @@@Description:
        @@@@lang:en
        @@@@@:
          The <Q::dis:TFQNames>-expanded URI references.  
      @@@UndeclaredPrefixException:
      @@@PerlDef:
        my ($typeq, $forq) = split /\s*[:|][:|]\s*/, $tfqnames, 2;
        my ($typeURI, $forURI);
        if (defined $forq) {
          __DEEP{
            $typeURI = $typeq eq ''
                       ? defined $defaultTypeURI ? $defaultTypeURI
                                                 : <Q::DOMMain:any>
                       : $self-><M::NSResolverDIS.qnameToURI> ($typeq, %opt);
          }__;
          if (length $forq) {
            $forURI = $self-><M::NSResolverDIS.qnameToURI> ($forq, %opt);
          } else {
            $forURI = <Q::ManakaiDOM:all>;
          }
        } else {  ## "For" omitted
          __DEEP{
            $typeURI = $typeq eq ''
                       ? defined $defaultTypeURI ? $defaultTypeURI
                                                 : <Q::DOMMain:any>
                       : $self-><M::NSResolverDIS.qnameToURI> ($typeq, %opt);
          }__;
          $forURI = defined $defaultForURI ? $defaultForURI
                                           : <Q::ManakaiDOM:all>;
        }
        __CODE{tfurisToURI:: $turi => $typeURI, $furi => $forURI, $uri => $r}__;

  @Method:
    @@Name: tfpqnamesToURI
    @@Description:
      @@@lang:en
      @@@@:
        Converts a <Q::DISCore:TFPQNames>
        into an expanded URI reference. 
    @@Param:
      @@@Name: tfpqnames
      @@@Type: 
        DISCore:TFPQNames::ManakaiDOM:all
      @@@Description:
        @@@@lang:en
        @@@@@:
          A <Q::DISCore:TFPQNames> to identify a resource. 
    @@Param:
      @@@Name: defaultTypeURI
      @@@Type: NameURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          A name URI reference used if it is missing from 
          <P::tfqnames>. 
      @@@nullCase:
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            Equivalent to <Q::DOMMain:any>. 
    @@Param:
      @@@Name: defaultForURI
      @@@Type: ForURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          A <QUOTE::for> URI reference used if it is missing from 
          <P::tfqnames>. 
      @@@nullCase:
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            Equivalent to <QUOTE::for all>, i.e. <Q::ManakaiDOM:all>. 
    @@NodeParam:
    @@Return:
      @@@Type: 
        DISCore:TFURI::ManakaiDOM:all
      @@@Description:
        @@@@lang:en
        @@@@@:
          The <Q::dis:TFQNames>-expanded URI references.  
      @@@UndeclaredPrefixException:
      @@@PerlDef:
        my ($typeq, $forq, @forpq) = split /\s*[:|][:|]\s*/, $tfpqnames;
        my ($typeURI, $forURI);
        my $forpURI = [];
        undef $forq if defined $forq and $forq eq '+';
        if (defined $forq) {
          __DEEP{
            $typeURI = $typeq eq ''
                       ? defined $defaultTypeURI ? $defaultTypeURI
                                                 : <Q::DOMMain:any>
                       : $self-><M::NSResolverDIS.qnameToURI> ($typeq, %opt);
            if (length $forq) {
              $forURI = $self-><M::NSResolverDIS.qnameToURI> ($forq, %opt);
            } else {
              $forURI = <Q::ManakaiDOM:all>;
            }
          }__;
        } else {  ## "For" omitted
          __DEEP{
            $typeURI = $typeq eq ''
                       ? defined $defaultTypeURI ? $defaultTypeURI
                                                 : <Q::DOMMain:any>
                       : $self-><M::NSResolverDIS.qnameToURI> ($typeq, %opt);
          }__;
          $forURI = defined $defaultForURI ? $defaultForURI
                                           : <Q::ManakaiDOM:all>;
        }
        __DEEP{
          for my $forpq (@forpq) {
            push @$forpURI, $self-><M::NSResolverDIS.qnameToURI>
                                                 ($forpq, %opt);
          }
        }__;
        __CODE{tfpurisToURI:: $turi => $typeURI, $furi => $forURI,
                              $forp => $forpURI,  $uri => $r}__;
##NSResolverDIS

PropDef:
  @QName: defaultNamespaceURI
  @enDesc:
    Default namespace URI for an element.
  @DIS:key: dns

IFClsDef:
  @IFQName: DISElement
  @ClsQName: ManakaiDISElement

  @ClsISA: ManakaiNSResolverDIS
  @ClsISA: ManakaiDISNode
  @ClsISA:
    swcfg21:ManakaiSWCFGElement::swcfg21:ForLatest
  @ClsISA: dp|ManakaiDISElementPerl

  @Description:
    @@lang:en
    @@@:
      <QUOTE::dis> element node objects. 

  @DISLang:role: ElementRole

  @Method:
    @@Name: forMatch
    @@Description:
      @@@lang:en
      @@@@:
        Tests whether this element is for a <QUOTE::for> or not. 
    @@Param:
      @@@Name: forArg
      @@@Type: ForURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          The <QUOTE::For> URI reference to test against. 
    @@Param:
      @@@Name: forpArg
      @@@Type: ForURIList
      @@@Description:
        @@@@lang:en
        @@@@@:
          The <QUOTE::For+> URI references to test against. 
      @@@nullCase:
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            No additional <QUOTE::For> URI reference. 
            Equivalent to an empty array reference. 
    @@NamedParam:
      @@@Name: databaseArg
      @@@Type: DISDatabase
      @@@enDesc:
        A <QUOTE::dis> database.
      @@@nullCase:
        @@@@enDesc:
          The database associated to the document is used.
    @@Return:
      @@@Type:
        DOMMain:boolean::ManakaiDOM:all
      @@@Description:
        @@@@lang:en
        @@@@@:
          Whether this element is for <P::forArg> and <P::forpArg> or not. 
      @@@UndeclaredPrefixException:
      @@@NoDBException:
      @@@PerlDef:
        $forArg = <Q::ManakaiDOM:all> unless defined $forArg;
        $forpArg ||= [];

        FORMATCH: {
          __DEEP{
            my $for_res = ($databaseArg ||=
                           $self-><AG::DISNode.ownerDISDocument>
                                -><AG::DISDocument.disDatabase>)
                                -><M::DISDatabase.getFor> ($forArg);
            my $forp_res = [map {
                                  $databaseArg-><M::DISDatabase.getFor> ($_)
                                } @{$forpArg}];

            my @ce = @{$self-><M::ManakaiDISElement.disAllChildElements>};
            for my $ce (@ce) {
              my $et = $ce-><AG::swcfg21:SWCFGElement::swcfg21:ForLatest
                                                      .expandedURI>;
              if ($et eq <Q::dis:ForCheck>) {
                my $fors = [split /\s+/, $ce-><M::swcfg21:SWCFGNode
                                                ::swcfg21:ForLatest.value>];
                FCs: for my $f (@$fors) {
                  if ($f =~ /^!=(.+)$/) {        ## -- NOT EQUAL TO
                    my $uri = $self-><M::NSResolverDIS.qnameToURI> ($1);
                    my $for = $databaseArg-><M::DISDatabase.getFor> ($uri);
                    $for-><AS::DISAnyResource.isReferred> ($ce);
                    for my $arg_res ($for_res, @{$forp_res}) {
                      if ($arg_res eq $for) {
                        $r = false;
                        last FORMATCH;
                      }
                    }
                  } elsif ($f =~ /^!(.+)$/) {    ## -- NOT ISA
                    my $uri = $self-><M::NSResolverDIS.qnameToURI> ($1);
                    my $for = $databaseArg-><M::DISDatabase.getFor> ($uri);
                    $for-><AS::DISAnyResource.isReferred> ($ce);
                    for my $arg_res ($for_res, @{$forp_res}) {
                      if ($arg_res-><M::DISFor.isaURI> ($uri)) {
                        $r = false;
                        last FORMATCH;
                      }
                    }
                  } elsif ($f =~ /^=(.+)$/) {    ## -- EQUAL TO
                    my $uri = $self-><M::NSResolverDIS.qnameToURI> ($1);
                    my $for = $databaseArg-><M::DISDatabase.getFor> ($uri);
                    $for-><AS::DISAnyResource.isReferred> ($ce);
                    for my $arg_res ($for_res, @{$forp_res}) {
                      if ($arg_res eq $for) {
                        next FCs;
                      }
                    }
                    $r = false;
                    last FORMATCH;
                  } else {                       ## -- ISA
                    my $uri = $self-><M::NSResolverDIS.qnameToURI> ($f);
                    my $for = $databaseArg-><M::DISDatabase.getFor> ($uri);
                    $for-><AS::DISAnyResource.isReferred> ($ce);
                    for my $arg_res ($for_res, @{$forp_res}) {
                      if ($arg_res-><M::DISFor.isaURI> ($uri)) {
                        next FCs;
                      }
                    }
                    $r = false;
                    last FORMATCH;
                  }
                } # FCs
              } # dis:ForCheck
            } # children

            my $has_for = false;
            for my $ce (@ce) {
              if ($ce-><AG::swcfg21:SWCFGElement::swcfg21:ForLatest
                                                     .expandedURI> eq
                  <Q::dis:For>) {
                my $fors = [split /\s+/, $ce-><M::swcfg21:SWCFGNode
                                                ::swcfg21:ForLatest.value>];
                my $ok = true;
                $has_for = true;
                AFOR: for my $f (@$fors) {
                  if ($f =~ /^!=(.+)$/) {         ## -- NOT EQUAL TO
                    my $uri = $self-><M::NSResolverDIS.qnameToURI> ($1);
                    my $for = $databaseArg-><M::DISDatabase.getFor> ($uri);
                    $for-><AS::DISAnyResource.isReferred> ($ce);
                    if ($for eq $for_res) {
                      $ok = false;
                      last AFOR;
                    }
                  } elsif ($f =~ /^!(.+)$/) {     ## -- NOT ISA
                    my $uri = $self-><M::NSResolverDIS.qnameToURI> ($1);
                    my $for = $databaseArg-><M::DISDatabase.getFor> ($uri);
                    $for-><AS::DISAnyResource.isReferred> ($ce);
                    if ($for_res-><M::ManakaiDISForDefinition.isaURI> ($uri)) {
                      $ok = false;
                      last AFOR;
                    }
                  } elsif ($f =~ /^=(.+)$/) {     ## -- EQUAL TO
                    my $uri = $self-><M::NSResolverDIS.qnameToURI> ($1);
                    my $for = $databaseArg-><M::DISDatabase.getFor> ($uri);
                    $for-><AS::DISAnyResource.isReferred> ($ce);
                    unless ($for eq $for_res) {
                      $ok = false;
                      last AFOR;
                    }
                  } else {                        ## -- ISA
                    my $uri = $self-><M::NSResolverDIS.qnameToURI> ($f);
                    my $for = $databaseArg-><M::DISDatabase.getFor> ($uri);
                    $for-><AS::DISAnyResource.isReferred> ($ce);
                    unless ($for_res-><M::ManakaiDISForDefinition.isaURI>($uri)){
                      $ok = false;
                      last AFOR;
                    }
                  }
                } # AFOR
                if ($ok) {
                  $r = true;
                  last FORMATCH;
                }
              } # dis:For
            } # $ce
            $r = $has_for ? false : true;
          }__;
        } # FORMATCH

  @Method:
    @@Name: mediaTypeMatch
    @@Description:
      @@@lang:en
      @@@@:
        Tests whether the content media type of this element matches to 
        a type or not. 
    @@Param:
      @@@Name: mediaType
      @@@Type: MediaTypeURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          A media type URI reference to test against. 
    @@Param:
      @@@Name: defaultMediaType
      @@@Type: MediaTypeURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          The default media type for this element. 
      @@@nullCase:
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            No default type provided.  All <P::mediaType> will match. 
    @@ForParam:
    @@ForpParam:
    @@NamedParam:
      @@@Name: databaseArg
      @@@Type: DISDatabase
      @@@enDesc:
        A <QUOTE::dis> database.
      @@@nullCase:
        @@@@enDesc:
          The database associated to the document is used.
    @@Return:
      @@@Type:
        DOMMain:boolean::ManakaiDOM:all
      @@@Description:
        @@@@lang:en
        @@@@@:
          Whether this element is of <P::mediaType> or not. 
      @@@PerlDef:
        if (defined $mediaType) {
          __DEEP{
            my $ctn = $self-><M::SWCFGNode.getAttributeNS>
                                  (<Q::dis:>, 'ContentType');
            my $ct;
            $ct = $ctn-><AG::DISElement.qnameValueURI> if $ctn;
            $ct = $defaultMediaType unless defined $ct;
            my $res = $self-><AG::ManakaiDISNode.ownerDISDocument>
                                 -><AG::ManakaiDISDocument.disDatabase>
                                 -><M::ManakaiDISDatabase.getResource> ($ct);
            $res-><AS::DISAnyResource.isReferred> ($ctn or $self);
            unless ($res-><M::ManakaiDISResourceDefinition
                                               .isSubsetOfURI> ($mediaType)) {
              $r = false;
            } else {
              $r = true;
            }
          }__;
        } else {
          $r = true;
        }

  @Method:
    @@Name:mediaTypeURI
    @@enDesc:
      The URI reference of the media type of this element. 
    @@Type: MediaTypeURI
    @@NamedParam:
      @@@Name:defaultMediaType
      @@@Type:MediaTypeURI
      @@@enDesc:
        The default media type URI reference. 
      @@@nullCase:
        @@@@enDesc:
          No default is specified. 
    @@ForParam:
    @@ForpParam:
    @@Return:
      @@@enDesc:
        The media type URI reference of this element. 
      @@@nullCase:
        @@@@enDesc:
          This element has no media type information and 
          <P::defaultMediaType> parameter is not provided. 
      @@@UndeclaredPrefixException:
      @@@PerlDef:
          __DEEP{
            $r = $defaultMediaType;
            my $ctn = $self-><M::SWCFGNode.getAttributeNS>
                                (<Q::dis:>, 'ContentType');
            $r = $ctn-><AG::DISElement.qnameValueURI> if $ctn;
          }__;

  @Method:
    @@Name: disGetAttribute
    @@enDesc:
      Gets an attribute node. 
    @@Param:
      @@@Name: attrName
      @@@Type: AnyURI
      @@@enDesc:
        The name expanded URI of the node to retrieve. 
    @@ForParam:
    @@ForpParam:
    @@MediaTypeParam:
    @@MediaTypeDefaultParam:
    @@NamedParam:
      @@@Name: databaseArg
      @@@Type: DISDatabase
      @@@enDesc:
        A <QUOTE::dis> database.
      @@@nullCase:
        @@@@enDesc:
          The database associated to the document is used.
    @@Return:
      @@@Type: DISElement
      @@@clsActualType: ManakaiDISElement
      @@@enDesc:
        The attribute (property) element node. 
      @@@nullCase:
        @@@@enDesc:
          No attribute node found. 
      @@@PerlDef:
        C: for my $c (@{$self-><M::ManakaiDISElement.disChildElements>
                                  (for_arg => $forArg, forp_arg => $forpArg,
                                   database_arg => $databaseArg)}) {
          if ($c-><AG::swcfg21:SWCFGElement::swcfg21:ForLatest
                                    .expandedURI> eq $attrName and
              $c-><M::ManakaiDISElement.mediaTypeMatch>
                                  ($mediaType, $defaultMediaType,
                                   for_arg => $forArg, forp_arg => $forpArg,
                                   database_arg => $databaseArg)) {
            $r = $c;
            last C;
          }
        }

  @Method:
    @@Name: disGetAttributeList
    @@enDesc:
      Gets attribute nodes. 
    @@Param:
      @@@Name: attrName
      @@@Type: AnyURI
      @@@enDesc:
        The name expanded URI of the node to retrieve. 
    @@ForParam:
    @@ForpParam:
    @@MediaTypeParam:
    @@MediaTypeDefaultParam:
    @@NamedParam:
      @@@Name: databaseArg
      @@@Type: DISDatabase
      @@@enDesc:
        A <QUOTE::dis> database.
      @@@nullCase:
        @@@@enDesc:
          The database associated to the document is used.
    @@Return:
      @@@Type: DISElementList
      @@@clsActualType: ManakaiDISElementList
      @@@enDesc:
        The attribute (property) element nodes. 
      @@@PerlDef:
        $r = bless [], <ClassName::ManakaiDISElementList>;
        for my $c (@{$self-><M::ManakaiDISElement.disChildElements>
                                  (for_arg => $forArg, forp_arg => $forpArg,
                                   database_arg => $databaseArg)}) {
          if ($c-><AG::swcfg21:SWCFGElement::swcfg21:ForLatest
                                          .expandedURI> eq $attrName and
              $c-><M::ManakaiDISElement.mediaTypeMatch>
                                  ($mediaType, $defaultMediaType,
                                   for_arg => $forArg, forp_arg => $forpArg,
                                   database_arg => $databaseArg)) {
            push @$r, $c;
          }
        }

  @Method:
    @@Name: disChildElements
    @@enDesc:
      A list of child elements, with <QUOTE::for> check.  
    @@ForParam:
    @@ForpParam:
    @@NamedParam:
      @@@Name: databaseArg
      @@@Type: DISDatabase
      @@@enDesc:
        A <QUOTE::dis> database.
      @@@nullCase:
        @@@@enDesc:
          The database associated to the document is used.
    @@Return:
      @@@Type: DISElementList
      @@@clsActualType: ManakaiDISElementList
      @@@enDesc:
        The current snapshot of child nodes. 
      @@@PerlDef:
        $r = bless [], <ClassName::ManakaiDISElementList>;    
        __DEEP{
          C: for my $cn (@{$self-><AG::swcfg21:SWCFGNode::swcfg21:ForLatest
                                                       .childNodes>}) {
            ## $cn is an #element.
            my $dn;
            __CODE{ManakaiNode|getNewReference||ManakaiDOM|Perl::
              $object => {$cn->{<H::mn:node>}},
              $ref => $dn,
              $class => {<ClassName::ManakaiDISElement>},
            }__;
            next C unless $dn-><M::ManakaiDISElement.forMatch>
                                      ($forArg, $forpArg,
                                       database_arg => $databaseArg);
            push @$r, $dn;
          }
        }__;

  @Method:
    @@Name: disAllChildElements
    @@enDesc:
      A list of child elements, without <QUOTE::for> check.  
    @@Return:
      @@@Type: DISElementList
      @@@clsActualType: ManakaiDISElementList
      @@@enDesc:
        The current snapshot of child nodes. 
      @@@PerlDef:
        $r = bless [], <ClassName::ManakaiDISElementList>;    
        __DEEP{
          for my $cn (@{$self-><AG::swcfg21:SWCFGNode::swcfg21:ForLatest
                                                       .childNodes>}) {
            ## $cn is an #element.
            my $dn;
            __CODE{ManakaiNode|getNewReference||ManakaiDOM|Perl::
              $object => {$cn->{<H::mn:node>}},
              $ref => $dn,
              $class => {<ClassName::ManakaiDISElement>},
            }__;
            push @$r, $dn;
          }
        }__;

  @Attr:
    @@Name: qnameValueURI
    @@enDesc:
      The element value (written as <Q::DISCore:QName>), as URI reference. 
      \
      {NOTE:: What should be if list value?
      \
      }
    @@Get:
      @@@Type:AnyURI
      @@@nullCase:
        @@@@enDesc:
          No value. 
      @@@UndeclaredPrefixException:
      @@@PerlDef:
        __DEEP{
          my $v = $self-><M::swcfg21:SWCFGNode::swcfg21:ForLatest.value>;
          if (defined $v and not ref $v eq 'ARRAY') {
            $r = $self-><M::NSResolverDIS.qnameToURI> ($v, node => $self);
          } else {
            $r = null;
          }
        }__;

  @Attr:
    @@Name: qnameValueLocalName
    @@enDesc:
      The local name part of the element value (assumed as 
      written as <Q::DISCore:QName>). 
      \
      {NOTE:: What should be if list value?
      \
      }
    @@Get:
      @@@Type:
        DISCore:LocalName::ManakaiDOM:all
      @@@nullCase:
        @@@@enDesc:
          No value. 
      @@@PerlDef:
        __DEEP{
          my $v = $self-><M::swcfg21:SWCFGNode::swcfg21:ForLatest.value>;
          if (defined $v and not ref $v eq 'ARRAY') {
            my ($n, $v) = split /\s*[:|]\s*/, $v, 2;
            $r = defined $v ? $v : $n;
          } else {
            $r = null;
          }
        }__;

  @Attr:
    @@Name: qnameValuePrefix
    @@enDesc:
      The prefix part of the element value (assumed as 
      written as <Q::DISCore:QName>). 
      \
      {NOTE:: What should be if list value?
      \
      }
    @@Get:
      @@@Type:
        DISCore:NamespacePrefix::ManakaiDOM:all
      @@@nullCase:
        @@@@enDesc:
          No value. 
      @@@PerlDef:
        __DEEP{
          my $v = $self-><M::swcfg21:SWCFGNode::swcfg21:ForLatest.value>;
          if (defined $v and not ref $v eq 'ARRAY') {
            my ($p, $l) = split /\s*[:|]\s*/, $v, 2;
            $r = defined $l ? $p : null;
          } else {
            $r = null;
          }
        }__;

  @Attr:
    @@Name: qnameValueNamespaceURI
    @@enDesc:
      The namespace URI of the element value (assumed as written 
      in <Q::DISCore:QName>). 
      \
      {NOTE:: What should be if list value?
      \
      }
    @@Get:
      @@@Type:AnyURI
      @@@nullCase:
        @@@@enDesc:
          No value. 
      @@@UndeclaredPrefixException:
      @@@PerlDef:
        __DEEP{
          my $v = $self-><M::swcfg21:SWCFGNode::swcfg21:ForLatest.value>;
          if (defined $v and not ref $v eq 'ARRAY') {
            my ($p, $v) = split /\s*[:|]\s*/, $v, 2;
            $r = $self-><M::NSResolverDIS.prefixToURI>
                                            (defined $v ? $p : null);
          } else {
            $r = null;
          }
        }__;

  @Method:
    @@Name: tfqnamesValueURI
    @@enDesc:
      The element value (written as <Q::dis:TFQNames>),
      as URI reference. 
      \
      {NOTE:: What should be if list value?
      \
      }
    @@Param:
      @@@Name: defaultTypeURI
      @@@Type: NameURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          A name URI reference used if it is missing from 
          <P::tfqnames>. 
      @@@nullCase:
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            Equivalent to <Q::DOMMain:any>. 
    @@Param:
      @@@Name: defaultForURI
      @@@Type: ForURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          A <QUOTE::for> URI reference used if it is missing from 
          <P::tfqnames>. 
      @@@nullCase:
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            Equivalent to <QUOTE::for all>, i.e. <Q::ManakaiDOM:all>. 
    @@ForParam:
    @@ForpParam:
    @@NamedParam:
      @@@Name:databaseArg
      @@@Type:DISDatabase
    @@Return:
      @@@Type:ResourceURI
      @@@nullCase:
        @@@@enDesc:
          No value. 
      @@@UndeclaredPrefixException:
      @@@PerlDef:
        my $v = $self-><M::swcfg21:SWCFGNode::swcfg21:ForLatest.value>;
        if (defined $v and not ref $v eq 'ARRAY') {
          __DEEP{
            if ($self-><M::ManakaiDISElement.mediaTypeMatch>
                                 (<Q::DISCore:TFPQNames>, <Q::DISCore:TFPQNames>,
                                  for_arg => $forArg, forp_arg => $forpArg,
                                  database_arg => $databaseArg)) {
              $r = $self-><M::NSResolverDIS.tfpqnamesToURI>
                                  ($v, $defaultTypeURI, $defaultForURI,
                                   node => $self);
            } else {
              $r = $self-><M::NSResolverDIS.tfqnamesToURI>
                                  ($v, $defaultTypeURI, $defaultForURI,
                                   node => $self);
            }
          }__;
        } else {
          $r = null;
        }

  @Method:
    @@Name: elementTypeMatch
    @@enDesc:
      Returns whether the element type of this element matches 
      with another element type (either the same element type or
      this type is a subtype of another type). 
    @@Param:
      @@@Name: etype
      @@@Type: ResourceURI
      @@@enDesc:
        An element type name URI reference to test. 
    @@NamedParam:
      @@@Name: srinfo
      @@@Type: DISPerl|HASH||ManakaiDOM|all
      @@@enDesc:
        The <CODE::srinfo> hash.
      @@@nullCase:
        @@@@enDesc:
          No <CODE::srinfo>.
    @@Return:
      @@@Type:
        DOMMain:boolean::ManakaiDOM:all
      @@@TrueCase:
        @@@@enDesc:
          Either the element type expanded URI reference of this element is 
          same as <P::etype> or it is a sub-element type of <P::etype>. 
      @@@FalseCase:
        @@@@enDesc:
          This element is not of <P::etype>. 
      @@@NoDBException:
      @@@PerlDef:
        __DEEP{
          my $et = $self-><AG::swcfg21:SWCFGElement::swcfg21:ForLatest
                                                          .expandedURI>;
          my $rdef = $self-><AG::ManakaiDISNode.ownerDISDocument>
                                   -><AG::ManakaiDISDocument.disDatabase>
                                   -><M::ManakaiDISDatabase.getResource> ($et);
          $r = $rdef-><M::DISResource.isSubsetOfURI>
                        ($etype, srinfo => $srinfo);
        }__;

  @Attr:
    @@Name: isResourceElement
    @@enDesc:
      Whether this element defines a resource or not. 
      \
      {NOTE:: An element defines a resource if its element type is 
              <Q::dis:ResourceDef> or its subtype.
      \
      }
    @@Get:
      @@@Type:
        DOMMain:boolean::ManakaiDOM:all
      @@@TrueCase:
        @@@@enDesc:
          This element defines a resource. 
      @@@FalseCase:
        @@@@enDesc:
          This element does not define any resource.
      @@@NoDBException:
      @@@PerlDef:
        __DEEP{
          $r = ($self-><AG::SWCFGElement.expandedURI> eq <Q::dis:ResourceDef>);
        }__;

  @Method:
    @@Name: isPropertyElement
    @@enDesc:
      Whether this element is a property or not. 
      \
      {NOTE:: An element is a property if the resource whose
              URI is equal to the element type name is a property,
              i.e. whose type is <Q::DISSource|Property>.
      }
    @@NamedParam:
      @@@Name: databaseArg
      @@@Type: DIS|DISDatabase
      @@@nullCase:
    @@Return:
      @@@Type:
        DOMMain:boolean::ManakaiDOM:all
      @@@TrueCase:
        @@@@enDesc:
          This element is a property.
      @@@FalseCase:
        @@@@enDesc:
          This element is not a property. 
      @@@NoDBException:
      @@@PerlDef:
        __DEEP{
          my $xn = $self-><AG::SWCFGElement.expandedURI>;
          if ($xn eq <Q::DISCore|resourceType> or $xn eq <Q::rdf:type>) {
            $r = true;
          } else {
            my $rdef = ($databaseArg or
                        $self-><AG::DISNode.ownerDISDocument>
                             -><AG::DISDocument.disDatabase>)
                             -><M::DISDatabase.getResource> ($xn);
            $r = $rdef-><M::DISAnyResource.isTypeURI>
                          (<Q::DISSource|Property>) ||
                 $rdef-><M::DISAnyResource.isTypeURI> (<Q::rdf:Property>);
                              ## TODO: Remove this.
          }
        }__;

  @Method:
     @@Name:  getFeature
     @@Description:
        @@@lang:en
        @@@@:
          Returns a specialized object that implements the specialized 
          interfaces of the specified feature and version.
     @@Param:
        @@@Name:  feature
        @@@Type: swcfg21|SWCFGString||swcfg21|ForLatest
        @@@actualType: DOMFeature|FeatureNameString||ManakaiDOM|ManakaiDOMLatest
        @@@Description:
          @@@@lang:en
          @@@@@:
            A feature name to request.
     @@Param:
        @@@Name:  version
        @@@Type: swcfg21|SWCFGString||swcfg21|ForLatest
        @@@actualType:
          DOMFeature|FeatureVersionString||ManakaiDOM|ManakaiDOMLatest
        @@@Description:
          @@@@lang:en
          @@@@@:
            A feature version number to request.
     @@Return:
        @@@Type:  
          DOMMain:Object::ManakaiDOM:all
        @@@Description:
          @@@@lang:en
          @@@@@:
            An object that implements the specialized APIs of the 
            <P::feature> and <P::version>.
        @@@nullCase:
          @@@@enDesc: 
            There is no object available that implements interfaces 
            associated with the <P::feature> and <P::version>. 
        @@@PerlDef:
            $feature =~ s/^\+//;
            CLASS: for my $class (grep {
              $Message::Util::DIS::ManakaiDISElement::CompatClass{$_}
            } keys %Message::Util::DIS::ManakaiDISElement::CompatClass) {
              if ($Message::DOM::ClassFeature{$class}->{$feature}->{$version}) {
                __CODE{ManakaiNode|getNewReference||ManakaiDOM|Perl::
                  $object => {$self->{<H::mn:node>}},
                  $ref => $r,
                  $class => $class,
                }__;
                last CLASS;
              }
            }

  @Method:
    @@Name: unlinkFromDocument
    @@enDesc:
      Removes any relationship to this node from the owner document tree.
      In addition, namespace bindings are copied from the document.
      The node <kwd:MUST> be a cloned one (or just newly created one)
      so that it does not have any parent-child relationship.
    
      {NOTE:: Once a subtree has removed from the document, the nodes
              belongs to the subtree can't be part of any document anymore.
      }
    @@Param:
      @@@Name: databaseArg
      @@@Type: DISDatabase
      @@@enDesc:
        The <QUOTE::dis> database.
    @@Return:
      @@@PerlDef:
        __DEEP{
          my $ods = $self->{<H::mn:node>}->{<H::swcfg21:ownerDocument>};
          $self->{<H::mn:node>}->{<H::swcfg21:nsBinding>}
            = $self-><M::DISElement.getNamespaceBindingList> ($databaseArg);
          $self->{<H::mn:node>}->{<H::DIS|defaultNamespaceURI>}
            = ${$self-><M::DISElement.getDefaultNamespaceURIRef>};
          my @nodes = ($self->{<H::mn:node>});
          while (defined (my $node = shift @nodes)) {
            CORE::delete $node->{<H::swcfg21:ownerDocument>};
            push @nodes, grep {$_} @{$node->{<H::swcfg21:childNodes>}},
                                   $node->{<H::swcfg21:shadowContent>},
                                   $node->{<H::swcfg21:shadowSibling>};
          }
          $self->{<H::mn:node>}
               -><M::ManakaiNode|NodeStem||ManakaiDOM|Perl.orphanate>;
        }__;

  @Method:
    @@Name: getNamespaceBindingList
    @@enDesc:
      Returns the <QUOTE::live> hash reference of namespace bindings.      
    @@Type: DISPerl|HASH||ManakaiDOM|all
    @@Param:
      @@@Name: databaseArg
      @@@Type: DISDatabase
      @@@enDesc:
        The <QUOTE::dis> database.
    @@Return:
      @@@PerlDef:
        my $ods = $self->{<H::mn:node>}->{<H::swcfg21:ownerDocument>};
        if ($ods->{<H::DIS|allNSBindings>}) {
          $r = $ods->{<H::DIS|allNSBindings>};
        } else {
          if ($databaseArg) {
            for my $mod_uri (keys %{$databaseArg->{modDef}}) {
              my $mod = $databaseArg-><M::DISDatabase.getModule> ($mod_uri);
              $ods->{<H::DIS|allNSBindings>}
                  ->{$mod-><AG::DISAnyResource.localName>}
                = $mod-><AG::DIS|DISModule.targetNamespaceURI>;
            }
          }
          for my $prefix (keys %{$ods->{<H::swcfg21:nsBinding>}}) {
            $ods->{<H::DIS|allNSBindings>}->{$prefix}
                = $ods->{<H::swcfg21:nsBinding>}->{$prefix};
          }
          $r = $ods->{<H::DIS|allNSBindings>};
        }

  @Method:
    @@Name: getDefaultNamespaceURIRef
    @@enDesc: A reference to the URI of the default namespace.
    @@Type: DISPerl|SCALAR||ManakaiDOM|all
    @@Return:
      @@@PerlDef:
        my $ods = $self->{<H::mn:node>}->{<H::swcfg21:ownerDocument>};
        if ($ods->{<H::DIS|defaultNamespaceURI>}) {
          $r = \ ($ods->{<H::DIS|defaultNamespaceURI>});
        } else {
          __DEEP{
            $r = \($ods->{<H::DIS|defaultNamespaceURI>}
               = $self-><AG::DISNode.ownerDISDocument>
                      -><AG::DISDocument.moduleElement>
                      -><AG::DISModuleElement.definingNamespaceURI>);
          }__;
        }


  @Method:
    @@Name: preserveNodePath
    @@enDesc:
      Saves a copy of node path string.
    @@Return:
      @@@PerlDef:
        __DEEP{
          $self-><M::SWCFGNode.flag> (nodePath => $self-><M::SWCFGNode.nodePath>
            (key => [qw/QName Name Type type/]));
        }__;

  @Method:
    @@Operator:
      @@@ContentType: DISCore|QName
      @@@@:
        DISPerl:CloneMethod
    @@Description:
      @@@lang:en
      @@@@:
        Makes a copy of this node.  All child nodes are cloned and
        all flags and options are copied (rather than cloned).
        The new node does not have any parent.
    @@Return:
      @@@Type: DISElement
      @@@Description:
        @@@@lang:en
        @@@@@:
          The cloned node.
          \
          If this node is a document node, then the another document is made.
      @@@PerlDef:
        $r = bless $self->SUPER::clone, <ClassName::ManakaiDISElement>;
##DISElement

PropDef:
  @QName: allNSBindings
  @enDesc:
    Collected set of namespace bindings for a node.

ResourceTypeDef:
  @QName: DIS|AnyMethod
  @enDesc:
    A method or attribute for particular resource types.
  @subsetOf: DISLang|AnyMethod

ResourceTypeDef:
  @QName: DIS|Method
  @enDesc:
    A method for particular resource types.
  @subsetOf: DISLang|Method
  @subsetOf: DIS|AnyMethod

ResourceTypeDef:
  @QName: DIS|Attribute
  @enDesc:
    A attribute for particular resource types.
  @subsetOf: DISLang|Attribute
  @subsetOf: DIS|AnyMethod

RPropDef:
  @QName: DIS|targetType
  @enDesc:
    A resource type for which the method is applied.
  @rdfs:range: DISCore|ResourceType
  @rdfs:domain: DIS|Method
  @dataType: DISCore|QName
  @multipleProperties: DISCore|UnorderedList

ResourceDef:
  @QName: DISString
  @AliasFor: DISLang|String||ManakaiDOM|all
  @For: DIS|ForEmpty

ElementTypeBinding:
  @Name: ResourceTypeDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISCore|ResourceType

IFClsDef:
  @IFQName: DISModuleElement
  @ClsQName: ManakaiDISModuleElement

  @IFISA: DISElement
  @ClsISA: ManakaiDISElement

  @enDesc:
    The <Q::dis:Module> elements. 

  @DISLang:role:
    @@@:
      DISLang:NullRole
    @@DISCore:stopISARecursive:1

  @Attr:
    @@Name: requireElement
    @@enDesc:
      The <Q::dis:Require> child element.  The element is 
      newly created if not exist. 
    @@Type: DISElement
    @@clsActualType: ManakaiDISElement
    @@Get:
      @@@PerlDef:
        __DEEP{
          $r = bless $self-><M::swcfg21:SWCFGNode
                        ::swcfg21:ForLatest.getAttributeNS>
                                   (<Q::dis:>, 'Require', make_new_node => true),
                     <ClassName::ManakaiDISElement>;
        }__;

  @Attr:
    @@Name: defaultForURI
    @@enDesc:
      The value of <Q::dis:DefaultFor> attribute. 
    @@Type: ForURI
    @@Get:
      @@@enDesc:
        The value of <Q::dis:DefaultFor> child element.  If missing, 
        <Q::ManakaiDOM:all> is returned. 
      @@@PerlDef:
        __DEEP{
          my $df = $self-><M::swcfg21:SWCFGNode::swcfg21:ForLatest
                                .getAttributeNS>
                                         (<Q::dis:>, 'DefaultFor');
          if ($df) {
            $r = (bless $df, <ClassName::ManakaiDISElement>)
                 -><AG::DISElement.qnameValueURI>
              || <Q::ManakaiDOM:all>;
          } else {
            $r = <Q::ManakaiDOM:all>;
          }
        }__;
    @@Set:
      @@@PerlDef:
        __DEEP{
          $self-><M::swcfg21:SWCFGNode::swcfg21:ForLatest.setAttributeNS>
                                     (<Q::dis:>, 'DefaultFor' => $given);
        }__;

  @Attr:
    @@Name: definingNamespaceURI
    @@enDesc:
      The value of <Q::dis:Namespace> attribute, i.e. 
      the URI reference of the namespace that this module primary 
      defines.
      \
      {NOTE:: Defining namespace URI is <QUOTE::for> independent. 
      \
      }
    @@Type: AnyURI
    @@Get:
      @@@PerlDef:
        __DEEP{
          my $df = $self-><M::swcfg21:SWCFGNode::swcfg21:ForLatest
                                .getAttributeNS>
                                         (<Q::dis:>, 'Namespace');
          if ($df) {
            $r = $df-><M::swcfg21:SWCFGNode::swcfg21:ForLatest.value>;
          } else {
            __ASSERT{DISPerl:invariant::
              msg => {qq["dis:Namespace" attribute not found]},
            }__;
          }
        }__;
    @@Set:
      @@@PerlDef:
        __DEEP{
          $self-><M::swcfg21:SWCFGNode::swcfg21:ForLatest.setAttributeNS>
                                     (<Q::dis:>, 'Namespace' => $given);
        }__;
##DISModuleElement

IFClsDef:
  @IFQName: DISElementList
  @ClsQName: ManakaiDISElementList

  @enDesc:
    @@lang:en
    @@@:
      Lists of elements. 
      \
      {NOTE:: <Class::ManakaiDISElementList> is <QUOTE::dead>; 
              later changes to the tree does not affect this type of objects. 
      \
      }
##DISElementList

IFClsDef:
  @IFQName: DISComment
  @ClsQName: ManakaiDISComment

  @ClsISA: ManakaiDISNode
  @ClsISA:
    swcfg21:ManakaiSWCFGComment::swcfg21:ForLatest

  @Description:
    @@lang:en
    @@@:
      <QUOTE::dis> comment node objects. 
##DISComment

IFClsDef:
  @IFQName: DISDocumentFragment
  @ClsQName: ManakaiDISDocumentFragment

  @ClsISA: ManakaiDISNode
  @ClsISA:
    swcfg21:ManakaiSWCFGDocumentFragment::swcfg21:ForLatest

  @Description:
    @@lang:en
    @@@:
      <QUOTE::dis> document fragment node objects. 
##DISDocumentFragment

IFClsDef:
  @IFQName: DISDocument
  @ClsQName: ManakaiDISDocument

  @ClsISA: ManakaiDISNode
  @ClsISA:
    swcfg21:ManakaiSWCFGDocument::swcfg21:ForLatest

  @Description:
    @@lang:en
    @@@:
      <QUOTE::dis> document node objects. 

  @Attr:
    @@Name: moduleElement
    @@enDesc:
      The <Q::dis:Module> element in this document.  The element is 
      newly created if not exist. 
    @@Type: DISModuleElement
    @@clsActualType: ManakaiDISModuleElement
    @@Get:
      @@@PerlDef:
        __DEEP{
          $r = $self-><M::swcfg21:SWCFGNode
                        ::swcfg21:ForLatest.getAttributeNS>
                                   (<Q::dis:>, 'Module', make_new_node => true);
        }__;
        $r = bless $r, <ClassName::ManakaiDISModuleElement>;

  @Attr:
    @@Name: disDatabase
    @@enDesc:
      Associated <QUOTE::dis> database. 

    @@Type: DISDatabase
    @@clsActualType: ManakaiDISDatabase
    @@Get:
      @@@NoDBException:
      @@@PerlDef:
        if ($self->{<H::mn:node>}->{<H::DIS|db>}) {
          $r = $self->{<H::mn:node>}->{<H::DIS|db>};
        } else {
          __EXCEPTION{NO_ASSOCIATED_DB_ERR}__;
        }
    @@Set:
      @@@PerlDef:
        $self->{<H::mn:node>}->{<H::DIS|db>} = $given;
        require Scalar::Util;
        Scalar::Util::weaken ($self->{<H::mn:node>}->{<H::DIS|db>});

  @Method:
    @@Name: disChildElements
    @@enDesc:
      A list of child elements, with <QUOTE::for> checks.  
    @@ForParam:
    @@ForpParam:
    @@NamedParam:
      @@@Name: databaseArg
      @@@Type: DISDatabase
      @@@enDesc:
        A <QUOTE::dis> database.
      @@@nullCase:
        @@@@enDesc:
          The database associated to the document is used.
    @@Return:
      @@@Type: DISElementList
      @@@clsActualType: ManakaiDISElementList
      @@@enDesc:
        The current snapshot of child nodes. 
      @@@PerlDef:
        $r = bless [], <ClassName::ManakaiDISElementList>;    
        __DEEP{
          C: for my $cn (@{$self-><AG::swcfg21:SWCFGNode::swcfg21:ForLatest
                                                       .childNodes>}) {
            next C unless $cn-><AG::swcfg21:SWCFGNode::swcfg21:ForLatest
                                              .nodeType> eq '#element';
            my $dn;
            __CODE{ManakaiNode|getNewReference||ManakaiDOM|Perl::
              $object => {$cn->{<H::mn:node>}},
              $ref => $dn,
              $class => {<ClassName::ManakaiDISElement>},
            }__;
            next C unless $dn-><M::ManakaiDISElement.forMatch>
                                              ($forArg, $forpArg,
                                               database_arg => $databaseArg);
            push @$r, $dn;
          }
        }__;

  @Method:
    @@Name: disAllChildElements
    @@enDesc:
      A list of child elements, without <QUOTE::for> checks.  
    @@Return:
      @@@Type: DISElementList
      @@@clsActualType: ManakaiDISElementList
      @@@enDesc:
        The current snapshot of child nodes. 
      @@@PerlDef:
        $r = bless [], <ClassName::ManakaiDISElementList>;    
        __DEEP{
          C: for my $cn (@{$self-><AG::swcfg21:SWCFGNode::swcfg21:ForLatest
                                                       .childNodes>}) {
            next C unless $cn-><AG::swcfg21:SWCFGNode::swcfg21:ForLatest
                                              .nodeType> eq '#element';
            my $dn;
            __CODE{ManakaiNode|getNewReference||ManakaiDOM|Perl::
              $object => {$cn->{<H::mn:node>}},
              $ref => $dn,
              $class => {<ClassName::ManakaiDISElement>},
            }__;
            push @$r, $dn;
          }
        }__;

  @Method:
    @@Name: addNamespaceBinding
    @@Param:
      @@@Name: prefix
      @@@Type: DISLang|String||ManakaiDOM|all
    @@Param:
      @@@Name: namespaceURI
      @@@Type: DISLang|String||ManakaiDOM|all
      @@@nullCase:
    @@Return:
      @@@PerlDef:
        if (defined $namespaceURI) {
          $self->{<H::mn:node>}->{<H::swcfg21:nsBinding>}->{$prefix}
            = $namespaceURI;
        } else {
          CORE::delete $self->{<H::mn:node>}->{<H::swcfg21:nsBinding>}
                            ->{$prefix};
        }

  @Attr:
    @@Name: disNamespaceResolver
    @@enDesc:
      A namespace resolver code that is called by
      <M::swcfg21|SWCFGNode||swcfg21|ForLatest.lookupNamesopaceURI> method
      when in-document namespace binding information is not sufficient.
    @@Type: DISPerl|CODE||ManakaiDOM|Perl
    @@Get:
      @@@PerlDef:
        $r = $self->{<H::mn:node>}->{<H::DIS|disNamespaceResolver>};
    @@Set:
      @@@PerlDef:
        $self->{<H::mn:node>}->{<H::DIS|disNamespaceResolver>} = $given;
##DISDocument

PropDef:
  @QName: DIS|disNamespaceResolver

PropDef:
  @QName: db
  @enDesc:
    Associated <QUOTE::dis> database. 
  @rdfs:domain: ManakaiDISDocument
  @rdfs:range: ManakaiDISDatabase

## -- Definition object database

IFClsDef:
  @IFQName: DISDatabase
  @ClsQName: ManakaiDISDatabase

  @ClsISA: dp|ManakaiDISDatabasePerl

  @enDesc:
    Resource database created from <QUOTE::dis> source data. 

  @DISLang:role: DatabaseRole

  @Method:
    @@Name: getModule
    @@Description:
      @@@lang:en
      @@@@:
        Returns a <QUOTE::dis> module definition. 
    @@Param:
      @@@Name: moduleURI
      @@@Type: ModuleURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          A <QUOTE::dis> module URI reference. 
    @@ForParam:
    @@Return:
      @@@Type: DISModule
      @@@clsActualType: ManakaiDISModuleDefinition
      @@@Description:
        @@@@lang:en
        @@@@@:
          The module definition. 
      @@@PerlDef:
        my $modURI;
        if (defined $forArg) {
          __CODE{tfurisToURI:: $turi => $moduleURI, $furi => $forArg,
                               $uri => $modURI}__;
        } else {
          $modURI = $moduleURI;
        }
        if (defined $self->{modDef}->{$modURI}) {
          $r = $self->{modDef}->{$modURI};
        } else {
          $r = $self->{modDef}->{$modURI}
             = bless {
                 uri => $modURI,
                 db => $self,
                 forp => [],
                 <H::DIS|typeURI> => <Q::DISCore|Module>,
                 <H::DIS|revision> => 0,
               }, <ClassName::ManakaiDISModuleDefinition>;
          require Scalar::Util;
          Scalar::Util::weaken ($r->{db});
          __CODE{DISPerl|HashStringRef||ManakaiDOM|all::
            $result => {$r->{for}},
            $given => {<Q::ManakaiDOM|all>},
          }__;
        }

    @@Test:
      @@@QName: DISDB.getModule.test
      @@@PerlDef:
        my $db;
        __CODE{createDISDBForTest:: $db => $db}__;

        my $res = $db-><M::DISDatabase.getModule> ('about:1');

        $test->id ('is.type.uri');
        $test->assert_true ($res-><M::DISAnyResource.isTypeURI>
                              (<Q::DISCore|Module>));
        $test->assert_true ($res-><M::DISAnyResource.isTypeURI>
                              (<Q::DISCore|AnyResource>));

        $test->id ('revision');
        $test->assert_num_equals
                 (actual_value => $res-><AG::DISAnyResource.revision>,
                  expected_value => 0);

  @Method:
    @@Name: getFor
    @@Description:
      @@@lang:en
      @@@@:
        Returns a <QUOTE::for> definition object. 
    @@Param:
      @@@Name: forURI
      @@@Type: ForURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          A <QUOTE::for> URI reference. 
      @@@nullCase:
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            Defaulted to <Q::ManakaiDOM:all>. 
    @@Return:
      @@@Type: DISFor
      @@@clsActualType: ManakaiDISForDefinition
      @@@PerlDef:
        $forURI = <Q::ManakaiDOM:all> unless defined $forURI;
        if (defined $self->{forDef}->{$forURI}) {
          $r = $self->{forDef}->{$forURI};
        } elsif (defined $self->{<H::DIS|resourceModuleMap>}->{$forURI}) {
          __DEEP{
            $self-><M::dp|ManakaiDISDatabasePerl.plLoadDISDatabaseModule>
              ($self-><M::DIS|DISDatabase.getModule>
                 (${$self->{<H::DIS|resourceModuleMap>}->{$forURI}}));
          }__;
          unless (defined $self->{forDef}->{$forURI}) {
            __EXCEPTION{DIS|RESOURCE_NOT_DEFINED_ERR::
              DIS:uri => {$forURI},
              DIS:moduleURI => {${$self->{<H::DIS|resourceModuleMap>}
                                       ->{$forURI}}},
            }__;
          }
          $r = $self->{forDef}->{$forURI};
        } else {
          $r = $self->{forDef}->{$forURI}
             = bless {
                 uri => $forURI,
                 isa => {<Q::ManakaiDOM:all> => true},
                 revISA => {},
                 db => $self,
                 <H::DIS|typeURI> => <Q::DISCore|For>,
                 <H::DIS|revision> => 0,
               }, <ClassName::ManakaiDISForDefinition>;
          $self->{forDef}->{<Q::ManakaiDOM:all>}->{revISA}->{$forURI} = true;
          require Scalar::Util;
          Scalar::Util::weaken ($r->{db});
        }

    @@Test:
      @@@QName: DISDB.getFor.test
      @@@PerlDef:
        my $db;
        __CODE{createDISDBForTest:: $db => $db}__;

        my $res = $db-><M::DISDatabase.getFor> ('about:1');

        $test->id ('is.type.uri');
        $test->assert_true ($res-><M::DISAnyResource.isTypeURI>
                                    (<Q::DISCore|For>));
        $test->assert_true ($res-><M::DISAnyResource.isTypeURI>
                                    (<Q::DISCore|AnyResource>));

        $test->id ('revision');
        $test->assert_num_equals
                 (actual_value => $res-><AG::DISAnyResource.revision>,
                  expected_value => 0);

  @Method:
    @@Name: getResource
    @@Description:
      @@@lang:en
      @@@@:
        Returns a <QUOTE::dis> resource definition. 
    @@Param:
      @@@Name: resourceURI
      @@@Type: ResourceURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          A <QUOTE::dis> resource URI reference. 
      @@@nullCase:
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            Defaulted to <Q::DOMMain:any>. 
    @@ForParam:
    @@Return:
      @@@Type: DISResource
      @@@clsActualType: ManakaiDISResourceDefinition
      @@@Description:
        @@@@lang:en
        @@@@@:
          The resource definition. 
      @@@RaiseException:
        @@@@@: DIS|RESOURCE_NOT_DEFINED_ERR
        @@@@enDesc:
          The resource should be included in database submodule but
          it is not.
      @@@PerlDef:
        $resourceURI = <Q::DOMMain:any> unless defined $resourceURI;
        my $resURI;
        if (defined $forArg) {
          __CODE{tfurisToURI:: $turi => $resourceURI, $furi => $forArg,
                               $uri => $resURI}__;
        } else {
          $resURI = $resourceURI;
        }

        if (defined $self->{resDef}->{$resURI}) {
          $r = $self->{resDef}->{$resURI};
        } elsif (defined $self->{<H::DIS|resourceModuleMap>}->{$resURI}) {
          __DEEP{
            $self-><M::dp|ManakaiDISDatabasePerl.plLoadDISDatabaseModule>
              ($self-><M::DIS|DISDatabase.getModule>
                 (${$self->{<H::DIS|resourceModuleMap>}->{$resURI}}));
          }__;
          unless (defined $self->{resDef}->{$resURI}) {
            __EXCEPTION{DIS|RESOURCE_NOT_DEFINED_ERR::
              DIS:uri => {$resURI},
              DIS:moduleURI => {${$self->{<H::DIS|resourceModuleMap>}
                                       ->{$resURI}}},
            }__;
          }
          $r = $self->{resDef}->{$resURI};
        } else {
          $r = $self->{resDef}->{$resURI}
             = bless {
                 uri => $resURI,
                 aliasURI => {$resURI => true},
                 db => $self,
                 forp => [],
                 seq => -1,
                 <H::DIS|typeURI> => <Q::DISCore|Resource>,
                 <H::DIS|revision> => 0,
               }, <ClassName::ManakaiDISResourceDefinition>;
          require Scalar::Util;
          Scalar::Util::weaken ($r->{db});
          __CODE{DISPerl|HashStringRef||ManakaiDOM|all::
            $result => {$r->{for}},
            $given => {<Q::ManakaiDOM|all>},
          }__;
        }

    @@Test:
      @@@QName: DISDB.getResource.test
      @@@PerlDef:
        my $db;
        __CODE{createDISDBForTest:: $db => $db}__;

        my $res = $db-><M::DISDatabase.getResource> ('about:1');


        $test->id ('is.type.uri');
        $test->assert_true ($res-><M::DISAnyResource.isTypeURI>
                                    (<Q::DISCore|Resource>));
        $test->assert_true ($res-><M::DISAnyResource.isTypeURI>
                                    (<Q::DISCore|AnyResource>));

        $test->id ('revision');
        $test->assert_num_equals
                 (actual_value => $res-><AG::DISAnyResource.revision>,
                  expected_value => 0);

  @Method:
    @@Name: getAnyResource
    @@enDesc:
      Returns a resource object, either module, <Q::for>, or resource.
    @@Param:
      @@@Name: resourceURI
      @@@Type: ResourceURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          A resource URI.
      @@@nullCase:
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            Defaulted to <Q::DOMMain:any>. 
    @@ForParam:
    @@Return:
      @@@Type: DIS|DISAnyResource
      @@@Description:
        @@@@lang:en
        @@@@@:
          The resource definition. 
      @@@RaiseException:
        @@@@@: DIS|RESOURCE_NOT_DEFINED_ERR
        @@@@enDesc:
          The resource should be included in database submodule but
          it is not.
      @@@PerlDef:
        $resourceURI = <Q::DOMMain:any> unless defined $resourceURI;
        my $resURI;
        if (defined $forArg) {
          __CODE{tfurisToURI:: $turi => $resourceURI, $furi => $forArg,
                               $uri => $resURI}__;
        } else {
          $resURI = $resourceURI;
        }

        if (defined $self->{resDef}->{$resURI}) {
          $r = $self->{resDef}->{$resURI};
        } elsif (defined $self->{modDef}->{$resURI}) {
          $r = $self->{modDef}->{$resURI};
        } elsif (defined $self->{forDef}->{$resURI}) {
          $r = $self->{forDef}->{$resURI};
        } elsif (defined $self->{<H::DIS|resourceModuleMap>}->{$resURI}) {
          __DEEP{
            $self-><M::dp|ManakaiDISDatabasePerl.plLoadDISDatabaseModule>
              ($self-><M::DIS|DISDatabase.getModule>
                 (${$self->{<H::DIS|resourceModuleMap>}->{$resURI}}));
          }__;
          if (defined $self->{resDef}->{$resURI}) {
            $r = $self->{resDef}->{$resURI};
          } elsif (defined $self->{forDef}->{$resURI}) {
            $r = $self->{forDef}->{$resURI};
          } else {
            __EXCEPTION{DIS|RESOURCE_NOT_DEFINED_ERR::
              DIS:uri => {$resURI},
              DIS:moduleURI => {${$self->{<H::DIS|resourceModuleMap>}
                                       ->{$resURI}}},
            }__;
          }
        } else {
          __DEEP{
            $r = $self-><M::DIS|DISDatabase.getResource> ($resURI);
          }__;
        }

  @Method:
    @@Name: getSourceFile
    @@enDesc:
      Gets <QUOTE::dis> source document. 
    @@Param:
      @@@Name: fileName
      @@@Type: FileURI
      @@@enDesc:
        A URI reference identifying a file. 
    @@Return:
      @@@Type: DISDocument
      @@@clsActualType: ManakaiDISDocument
      @@@enDesc:
        The <QUOTE::dis> source document. 
      @@@nullCase:
        @@@@enDesc:
          No document associated with that <P::fileName>. 
      @@@PerlDef:
        $r = $self->{<H::DIS|sourceFile>}->{$fileName};
  @Method:
    @@Name: setSourceFile
    @@enDesc:
      Puts <QUOTE::dis> source document object. 
    @@Param:
      @@@Name: fileName
      @@@Type: FileURI
      @@@enDesc:
        A URI reference identifying a file.  If there is already a 
        source document, then the association has been updated. 
    @@Param:
      @@@Name: doc
      @@@Type: DISDocument
      @@@clsActualType: ManakaiDISDocument
      @@@enDesc:
        The document object to set. 
    @@Return:
      @@@PerlDef:
        $self->{<H::DIS|sourceFile>}->{$fileName} = $doc;

  @Method:
    @@Name: loadModule
    @@enDesc:
      Loads definitions from a <QUOTE::dis> document. 
    @@Param:
      @@@Name: doc
      @@@Type: DISDocument
      @@@clsActualType: ManakaiDISDocument
      @@@enDesc:
        The source <QUOTE::dis> document object.  Its 
        <A::ManakaiDISDocument.disDatabase> must be this database. 
    @@Param:
      @@@Name: resolver
      @@@Type: DISModuleResolver
      @@@enDesc:
        The resolver to convert module name into <QUOTE::dis> document object. 
    @@ForParam:
    @@NamedParam:
      @@@Name: onResourceRead
      @@@Type:
        DISPerl:CODE::ManakaiDOM:all
      @@@enDesc:
        An event handler called when a resource is read.
      @@@nullCase:
        @@@@enDesc:
          No event handler is read.
    @@NamedParam:
      @@@Name: srinfo
      @@@Type: DISPerl|HASH||ManakaiDOM|all
      @@@enDesc:
        A hash returned by <M::DISDatabase.unloadModule>, to
        restore super-resource relationship.
      @@@nullCase:
        @@@@enDesc:
          If it is not the updating.
    @@Return:
      @@@RaiseException:
        @@@@@: NO_MODULE_QNAME_ERR
        @@@@enDesc:
          The <Q::dis:Module> element must have a <Q::dis:QName> attribute. 
      @@@RaiseException:
        @@@@@: UNABLE_TO_GET_MODULE_ERR
        @@@@enDesc:
          The implementation is unable to get a module source. 
      @@@ForDefDupException:
      @@@ForDefNoQNameException:
      @@@ResDefDupException:
      @@@ElementNotAllowedException:
      @@@RaiseException:
        @@@@@:NO_REQUIRED_ATTR_ERR
        @@@@enDesc:
          The <Q::dis:Module> element does not have 
          <Q::dis:Namespace> attribute. 
      @@@PerlDef:
        $resolver = bless $resolver, <ClassName::ManakaiDISModuleResolver>
                      if ref $resolver eq 'CODE'; 
        ## -- Module Name, URI
        $forArg = <Q::ManakaiDOM:all> unless defined $forArg;
        my $mod_node;
        my $mod_name_node;
        __DEEP{
          $mod_node = $doc-><AG::DISDocument.moduleElement>;
          $mod_name_node = $mod_node-><M::SWCFGNode.getAttributeNS>
                                                 (<Q::dis:>, 'QName');
          unless ($mod_name_node) {
            __UNDEEP{
              __EXCEPTION{NO_MODULE_QNAME_ERR::
                DIS:sourceNode => {$mod_node},
              }__;
            }__;
          }
          $mod_name_node = bless $mod_name_node, <ClassName::ManakaiDISElement>
            if $mod_name_node->isa (<ClassName::swcfg21:ManakaiSWCFGElement
                                              ::swcfg21:ForLatest>);
          my $mod_name_uri = $mod_name_node
                                -><AG::DISElement.qnameValueURI>;
          my $mod = $self-><M::DISDatabase.getModule>
                                   ($mod_name_uri, for_arg => $forArg);
        
          unless ($mod-><AG::DISAnyResource.isDefined>) {
            ## -- Initializes Module Definition Object
            my $v = $mod_name_node-><AG::DISElement.qnameValueLocalName>;
            __CODE{DISPerl|HashStringRef||ManakaiDOM|all::
              $result => {$mod->{localName}},
              $given => {$v},
            }__;
            my $ns = $mod_name_node-><AG::DISElement.qnameValueNamespaceURI>;
            __CODE{DISPerl|HashStringRef||ManakaiDOM|all::
              $result => {$mod->{namespaceURI}},
              $given => {$ns},
            }__;
            __CODE{DISPerl|HashStringRef||ManakaiDOM|all::
              $result => {$mod->{for}},
              $given => {$forArg},
            }__;
            $mod->{src} = $mod_node;
            $mod->{<Q::DIS|isDefined>} = true;
            $self-><M::DISDatabase.setSourceFile> ($mod_name_uri => $doc);

            $mod-><AS::DIS|ManakaiDISModuleDefinition.targetNamespaceURI>
                      ($mod_node-><AG::DISModuleElement.definingNamespaceURI>);

            __CODE{dv:createValue::
              $result => {$mod->{<Q::DIS:sourceFile>}},
              $value => {$doc-><M::SWCFGNode.flag> (<Q::swcfg21:fileName>)},
              $base_type => {<Q::DISCore:String>},
              $type => {<Q::DISCore:String>},
              $name => {<Q::DIS:sourceFile>},
            }__;
            __CODE{setRevision:: $resource => $mod}__;
            
            ## -- Loads "for" definition
            my $root_elements
                       = $doc-><M::DISDocument.disAllChildElements>;
            if ($mod-><AG::DISAnyResource.forURI> eq <Q::ManakaiDOM:all>) {
              R: for my $el (@$root_elements) {
                next R unless $el-><AG::SWCFGElement
                                          .expandedURI> eq <Q::dis:ForDef>;
                $self-><M::DISDatabase.loadFor>
                         ($mod, $el, srinfo => $srinfo);
              }
            }

            ## -- Loads "for all"
            my $rmod = $self-><M::DISDatabase.getModule>
                               ($mod_name_uri,
                                for_arg => <Q::ManakaiDOM:all>);
            unless ($rmod-><AG::DISAnyResource.isDefined>) {
              my $rdoc = $resolver-><M::DISModuleResolver.uriToDocument>
                               ($self, $rmod-><AG::DISAnyResource.uri>,
                                $mod-><AG::DISAnyResource.namespaceURI>,
                                $mod-><AG::DISAnyResource.localName>,
                                <Q::ManakaiDOM:all>);
              unless ($rdoc) {
                __UNDEEP{
                  __EXCEPTION{UNABLE_TO_GET_MODULE_ERR::
                    DIS:uri => {$rmod-><AG::DISAnyResource.uri>},
                    DIS:namespaceURI =>
                               {$mod-><AG::DISAnyResource.namespaceURI>},
                    DIS:localName => {$mod-><AG::DISAnyResource.localName>},
                    DIS:for => {<Q::ManakaiDOM:all>},
                    DIS:sourceNode => {$mod-><AG::DISAnyResource.sourceElement>},
                  }__;
                }__;
              }
              $self-><M::DISDatabase.loadModule>
                            ($rdoc, $resolver, for_arg => <Q::ManakaiDOM:all>,
                             on_resource_read => $onResourceRead,
                             srinfo => $srinfo);
            } else { # if "for all" loaded
              $rmod-><M::DIS|DISResourceProp.getPropertyBoolean>
                       (<Q::dis:In>);
              ## Dummy to ensure the module is loaded
            }

            ## -- Loads Required Modules
            ##    NOTE:: "dis:For" is not allowed since "dis:ForDef" is not read
            my $req_node = $mod_node-><AG::DISModuleElement.requireElement>;
            for my $rm (@{$req_node-><M::DISElement.disAllChildElements>}) {
              next unless $rm-><AG::SWCFGElement.expandedURI> eq <Q::dis:Module>;
              my ($uri, $nuri, $ln, $for);
              my $mqn = $rm-><M::SWCFGNode.getAttributeNS> (<Q::dis:>, 'QName');
              if ($mqn) {
                my $mqv = $mqn-><M::SWCFGNode.value>;
                my $mqp = ($mqn->isa (<ClassName::swcfg21:ManakaiSWCFGElement
                                                ::swcfg21:ForLatest>)
                           ? (bless $mqn, <ClassName::ManakaiDISElement>) : $mqn)
                          -><M::NSResolverDIS.qnameToPair> ($mqv, node => $mqn);
                ($nuri, $ln) = @$mqp;
              } else {
                my $mn = $rm-><M::SWCFGNode.getAttributeNS> (<Q::dis:>, 'Name');
                if ($mn) {
                  $nuri = $mod-><AG::DISAnyResource.namespaceURI>;
                  $ln = $mn-><M::SWCFGNode.value>;
                } else {
                  $nuri = $mod-><AG::DISAnyResource.namespaceURI>;
                  $ln = $mod-><AG::DISAnyResource.localName>;
                }
              }
              my $wfn = $rm-><M::SWCFGNode.getAttributeNS>
                                              (<Q::dis:>, 'WithFor');
              if ($wfn) {
                $for = ($wfn->isa (<ClassName::swcfg21:ManakaiSWCFGElement
                                             ::swcfg21:ForLatest>)
                           ? (bless $wfn, <ClassName::ManakaiDISElement>) : $wfn)
                       -><AG::DISElement.qnameValueURI>;
              } else {
                $for = $mod-><AG::DISAnyResource.forURI>;
              }
              my $rmod = $self-><M::DISDatabase.getModule>
                                       ($nuri . $ln, for_arg => $for);
              $mod-><M::DISModule.addReferringModuleURI> ($nuri.$ln);
              unless ($rmod-><AG::DISAnyResource.isDefined>) {
                my $rdoc = $resolver-><M::DISModuleResolver.uriToDocument>
                                       ($self, $rmod-><AG::DISAnyResource.uri>,
                                        $nuri, $ln, $for);
                unless ($rdoc) {
                  __UNDEEP{
                    __EXCEPTION{UNABLE_TO_GET_MODULE_ERR::
                      DIS:uri => {$rmod-><AG::DISAnyResource.uri>},
                      DIS:namespaceURI => {$nuri},
                      DIS:localName => {$ln},
                      DIS:for => {$for},
                      DIS:sourceNode => {$rm},
                    }__;
                  }__;
                }
                $self-><M::DISDatabase.loadModule>
                                       ($rdoc, $resolver, for_arg => $for,
                                        on_resource_read => $onResourceRead,
                                        srinfo => $srinfo);
              }
            } # Child Module elements
            
            ## -- Loads child resources
            $root_elements = $doc-><M::DISDocument.disChildElements>
                                         (for_arg => $forArg,
                                          database_arg => $self);
            for my $el (@$root_elements) {
              if ($el-><AG::DISElement.isResourceElement>) {
                $self-><M::DISDatabase.loadResource>
                                         ($mod, null, null, $el,
                                          for_arg => $forArg,
                                          on_resource_read => $onResourceRead,
                                          srinfo => $srinfo);
              } else {
                my $et = $el-><AG::SWCFGElement.expandedURI>;
                if ({
                         <Q::dis:ForDef> => 1,
                         <Q::dis:Module> => 1,
                         <Q::dis:ImplNote> => 1,
                    }->{$et}) {
                  # 
                } else {
                  __UNDEEP{
                    __EXCEPTION{ELEMENT_NOT_ALLOWED_ERR::
                      DIS:elementType => {$et},
                      DIS:sourceNode => {$el},
                      DIS:uri => {$mod-><AG::anyres.uri>},
                    }__;
                  }__;
                }
              } # element types
            }
            
            my $dn = $mod_node-><M::SWCFGNode.getAttributeNS>
                                           (<Q::dis:>, 'Namespace');
            unless ($dn and defined $dn-><M::SWCFGNode.value>) {
              __UNDEEP{
                __EXCEPTION{NO_REQUIRED_ATTR_ERR::
                  DIS:elementType => {<Q::dis:Namespace>},
                  DIS:sourceNode => {$mod_node},
                }__;
              }__;
            }
          } # Unless this module loaded
        }__; # Deep

  @Method:
    @@Name: loadFor
    @@enDesc:
      Loads definition of a <QUOTE::for> from a <Q::dis:ForDef> element. 
    @@Param:
      @@@Name: mod
      @@@Type: DISModule
      @@@clsActualType: ManakaiDISModuleDefinition
      @@@enDesc:
        The module in which the <QUOTE::for> to load is defined. 
    @@Param:
      @@@Name: el
      @@@Type: DISElement
      @@@enDesc:
        The source <QUOTE::dis> <Q::dis:ForDef> element object. 
    @@NamedParam:
      @@@Name: srinfo
      @@@Type: DISPerl|HASH||ManakaiDOM|all
      @@@enDesc:
        A hash returned by <M::DISDatabase.unloadModule>, to
        restore super-resource relationship.
      @@@nullCase:
        @@@@enDesc:
          If it is not the updating.
    @@Return:
      @@@ForDefDupException:
      @@@ForDefNoQNameException:
      @@@ElementNotAllowedException:
      @@@PerlDef:
        __DEEP{
          my $qn_node = $el-><M::SWCFGNode.getAttributeNS> (<Q::dis:>, 'QName');
          unless ($qn_node) {
            __UNDEEP{
              __EXCEPTION{NO_FOR_QNAME_ERR::
                DIS:sourceNode => {$el},
              }__;
            }__;
          }
          $qn_node = bless $qn_node, <ClassName::ManakaiDISElement>
            if $qn_node->isa (<ClassName::swcfg21:ManakaiSWCFGElement
                                        ::swcfg21:ForLatest>);
          my $qn_uri = $qn_node-><AG::DISElement.qnameValueURI>;
          my $for = $self-><M::DISDatabase.getFor> ($qn_uri);
        
          unless ($for-><AG::DISAnyResource.isDefined>) {
            ## -- Initializes "For" Definition Object
            $for->{src} = $el;
            $for->{<H::DIS|isDefined>} = true;
            $for->{<H::DIS|definingModule>} = \ ($mod->{uri});
            $mod-><M::DISModule.addForResource> ($for);

            for my $ce (@{$el-><M::ManakaiDISElement.disAllChildElements>}) {
              my $xn = $ce-><AG::SWCFGElement.expandedURI>;
              if ($xn eq <Q::dis:ISA> or $xn eq <Q::dis:Implement>) {
                my $sfor = $self-><M::DISDatabase.getFor>
                            ($ce-><AG::DISElement.qnameValueURI>);
                $for-><M::DISFor.addISA> ($sfor);
                $sfor-><AS::DISAnyResource.isReferred> ($ce);
                ## TODO: warn if dis:Implement
              } elsif ({
                         <Q::dis:Description> => 1,
                         <Q::dis:ImplNote> => 1,
                         <Q::dis:FullName> => 1,
                         <Q::dis:QName> => 1,
                       }->{$xn}) {
                # 
              } else {
                __UNDEEP{
                  __EXCEPTION{ELEMENT_NOT_ALLOWED_ERR::
                    DIS:elementType => {$xn},
                    DIS:sourceNode => {$ce},
                    DIS:uri => {$qn_uri},
                  }__;
                }__;
              }
            }

            for (keys %{$srinfo->{for}->{$qn_uri}->{supOf} or {}}) {
              my $subfor = $self-><M::DISDatabase.getFor> ($_);
              $subfor-><M::DISFor.addISA> ($for, srinfo => $srinfo);
            }
            for (keys %{$srinfo->{for}->{$qn_uri}->{subOf} or {}}) {
              my $supfor = $self-><M::DISDatabase.getFor> ($_);
              $for-><M::DISFor.addISA> ($supfor, srinfo => $srinfo);
            }
          } else {
            __UNDEEP{
              __EXCEPTION{FOR_ALREADY_DEFINED_ERR::
                DIS:sourceNode => {$el},
                DIS:anotherSourceNode => {$el},
                DIS:uri => {$qn_uri},
              }__;
            }__;
          } # isDefine?
        }__; # DEEP
        
  @Method:
    @@Name: loadResource
    @@enDesc:
      Loads definition of a <QUOTE::dis> resource from a 
      <Q::dis:ResourceDef> element. 
    @@Param:
      @@@Name: mod
      @@@Type: DISModule
      @@@clsActualType: ManakaiDISModuleDefinition
      @@@enDesc:
        The module in which the resource to load is defined. 
    @@Param:
      @@@Name: parentResource
      @@@Type: DISResource
      @@@clsActualType: ManakaiDISResourceDefinition
      @@@enDesc:
        The (static) parent resource in which the resource to load is defined. 
      @@@nullCase:
        @@@@enDesc:
          The resource to load is a root resource, i.e. <P::el> is 
          a direct child of the document node. 
    @@Param:
      @@@Name: dynParent
      @@@Type: DISResource
      @@@clsActualType: ManakaiDISResourceDefinition
      @@@enDesc:
        The dynamic parent resource of the resource to load. 
      @@@nullCase:
        @@@@enDesc:
          If this resource is a root resource, i.e. <P::el> is
          a direct child of the document node. 
    @@Param:
      @@@Name: el
      @@@Type: DISElement
      @@@clsActualType: ManakaiDISElement
      @@@enDesc:
        The source <QUOTE::dis> <Q::dis:ResourceDef> element object. 
    @@ForParam:
    @@ForpParam:
    @@NamedParam:
      @@@Name: onResourceRead
      @@@Type:
        DISPerl:CODE::ManakaiDOM:all
      @@@enDesc:
        An event handler called when a resource is read.
      @@@nullCase:
        @@@@enDesc:
          No event handler is read.
    @@NamedParam:
      @@@Name: srinfo
      @@@Type: DISPerl|HASH||ManakaiDOM|all
      @@@enDesc:
        A hash returned by <M::DISDatabase.unloadModule>, to
        restore super-resource relationship.
      @@@nullCase:
        @@@@enDesc:
          If it is not the updating.
    @@Return:
      @@@ResDefDupException:
      @@@ElementNotAllowedException:
      @@@RaiseException:
        @@@@@: NO_RDF_TYPE_ERR
        @@@@enDesc:
          There is a resorce that does not have any <Q::rdf:type>
          attribute.
      @@@PerlDef:
        $forArg = <Q::ManakaiDOM:all> unless defined $forArg;
        $forpArg ||= [];
        __DEEP{
          ## -- Node names
          my @res_uri;

          ## Unique resource identifier generated from node id
          my $node_id = $el-><AG::SWCFGNode.nodeIDRef>;
          my $node_uri;
          __CODE{tfpurisToURI:: $turi => {$$node_id}, $furi => $forArg,
                                $forp => $forpArg, $uri => $node_uri}__;

          my $al_node = $el-><M::DISElement.disGetAttribute>
                                      (<Q::dis:AliasFor>, for_arg => $forArg,
                                       forp_arg => $forpArg,
                                       database_arg => $self);
          my $al_canon_uri;
          if ($al_node) {
            $al_canon_uri = $al_node-><M::DISElement.tfqnamesValueURI>
                            ($$node_id, $forArg,
                             for_arg => $forArg,
                             forp_arg => $forpArg,
                             database_arg => $self);
          }

          ## User defined resource identifiers
          my $qn_node = $el-><M::ManakaiDISElement.disGetAttribute>
                                      (<Q::dis:QName>, for_arg => $forArg,
                                       forp_arg => $forpArg, 
                                       database_arg => $self);
          my $res;
          ALD: {
          if ($qn_node) {
            my $qn_uri = $qn_node-><AG::ManakaiDISElement.qnameValueURI>;
            my $qn_urif;
            __CODE{tfurisToURI:: $turi => $qn_uri, $furi => $forArg,
                                 $uri => $qn_urif}__;
            push @res_uri, $qn_urif;
            $res = $self-><M::DISDatabase.getResource> ($qn_urif);
            if ($res-><AG::DISAnyResource.isDefined>) {
              last ALD if defined $al_canon_uri and
                          $res->{aliasURI}->{$al_canon_uri};
              __UNDEEP{
                __EXCEPTION{RESOURCE_ALREADY_DEFINED_ERR::
                  DIS:uri => {$qn_urif},
                  DIS:sourceNode => {$qn_node},
                  DIS:anotherSourceNode => {$res->{src}},
                }__;
              }__;
            }
            my $v = $qn_node-><AG::DIS|DISElement.qnameValueLocalName>;
            __CODE{DISPerl|HashStringRef||ManakaiDOM|all::
              $result => {$res->{localName}},
              $given => {$v},
            }__;
            my $ns = $qn_node-><AG::DIS|DISElement.qnameValueNamespaceURI>;
            __CODE{DISPerl|HashStringRef||ManakaiDOM|all::
              $result => {$res->{namespaceURI}},
              $given => {$ns},
            }__;
          } else { ## Anonymous or local
            my $n_node = $el-><M::ManakaiDISElement.disGetAttribute>
                                      (<Q::dis:Name>, for_arg => $forArg,
                                       forp_arg => $forpArg,
                                       database_arg => $self);
            if ($n_node) {
              if ($parentResource) {
                my $puri = $parentResource->{uri};
                my $ru;
                my $ruf;
                my $ln = $n_node-><M::swcfg21:SWCFGNode
                                    ::swcfg21:ForLatest.value>;
                __CODE{getChildResourceURI:: $parentURI => $puri,
                                             $localName => $ln,
                                             $result => $ru}__;
                __CODE{tfurisToURI:: $turi => $ru, $furi => $forArg,
                                     $uri => $ruf}__;
                push @res_uri, $ruf;
                $res = $self-><M::DISDatabase.getResource> ($ruf);
                my $v = $n_node-><M::SWCFGNode.value>;
                __CODE{DISPerl|HashStringRef||ManakaiDOM|all::
                  $result => {$res->{localName}},
                  $given => {$v},
                }__;
                $res->{<H::DIS|isAnon>} = true;
              } else {  ## Root local name resource
                my $ln = $n_node-><M::SWCFGNode.value>;
                my $ns_uri = $mod-><AG::DISAnyResource.sourceElement>
                                 -><AG::DISModuleElement.definingNamespaceURI>;
                my $qn_uri = $ns_uri . $ln;
                my $qn_urif;
                __CODE{tfurisToURI:: $turi => $qn_uri, $furi => $forArg,
                                     $uri => $qn_urif}__;
                push @res_uri, $qn_urif;
                $res = $self-><M::DISDatabase.getResource> ($qn_urif);
                if ($res-><AG::DISAnyResource.isDefined>) {
                  last ALD if defined $al_canon_uri and
                              $res->{aliasURI}->{$al_canon_uri};
                  __UNDEEP{
                    __EXCEPTION{RESOURCE_ALREADY_DEFINED_ERR::
                      DIS:uri => {$res-><AG::DISAnyResource.uri>},
                      DIS:sourceNode => {$n_node},
                      DIS:anotherSourceNode
                              => {$res-><AG::DISAnyResource.sourceElement>},
                    }__;
                 }__;
                }
                __CODE{DISPerl|HashStringRef||ManakaiDOM|all::
                  $result => {$res->{namespaceURI}},
                  $given => {$ns_uri},
                }__;
                __CODE{DISPerl|HashStringRef||ManakaiDOM|all::
                  $result => {$res->{localName}},
                  $given => {$ln},
                }__;
              }
            } else {
              push @res_uri, $node_uri;
              $res = $self-><M::DISDatabase.getResource> ($node_uri);
              $res->{<H::DIS|isAnon>} = true;
            }
          } # anon
          __CODE{DISPerl|HashStringRef||ManakaiDOM|all::
            $result => {$res->{for}},
            $given => {$forArg},
          }__;
          $res->{forp} = $forpArg;
          $res->{src} = $el;
          $res->{<H::DIS|definingModule>} = \ ($mod->{uri});
          $res-><AS::DIS|ManakaiDISResourceDefinition.parentResource>
            ($parentResource) if $parentResource;
          $res-><AS::DIS|ManakaiDISResourceDefinition.dynamicParentResource>
            ($dynParent) if $dynParent;
          unless ($res->{uri} eq $node_uri) {
            push @res_uri, $node_uri;
            my $nu_res = $self-><M::DISDatabase.getResource> ($node_uri);
            $res-><M::DISResource.mergeAsAlias> ($nu_res);
          }
          $res->{seq} = $self->{seq}++;
          $res-><AS::DISAnyResource.sourceNodeIDRef> ($node_id);
          __CODE{setRevision:: $resource => $res}__;
          $mod-><M::DISModule.addResourceURI> ($_) for @res_uri;
          
          ## -- Alias
          if ($al_node) {
            my $canon_res = $self-><M::DISDatabase.getResource> ($al_canon_uri);
            $canon_res-><AS::DISAnyResource.isReferred> ($al_node);
            $canon_res-><M::DISResource.mergeAsAlias>
                          ($res, node => $al_node, no_equality_check => true);
            $res = $canon_res;
            } else {
              $res->{<H::DIS|isDefined>} = true;
            }
          } # ALD

          ## -- Registers as child
          $parentResource-><M::DIS|ManakaiDISResourceDefinition
                                  .addChildResource> ($res)
             if $parentResource;
          $dynParent-><M::DIS|ManakaiDISResourceDefinition
                                  .addDynamicChildResource> ($res)
             if $dynParent;

          my $is_multires = false;
          my @props;
          my @cres;
          my @ce0 = @{$el-><M::DISElement.disChildElements>
                                    (for_arg => $forArg, forp_arg => $forpArg,
                                     database_arg => $self)};
          my $has_type = $al_node;
          while (@ce0) {
            my $ce = shift @ce0;
            if ($ce-><M::DISElement.elementTypeMatch>
                       (<Q::DISCore|resourceType>, database_arg => $self,
                        srinfo => $srinfo) or
                $ce-><M::DISElement.elementTypeMatch> (<Q::rdf:type>,
                                     database_arg => $self,
                                     srinfo => $srinfo)) {
                       ## TODO: Remove this.
              $has_type = true;
              my $type_uri = $ce-><AG::DISElement.qnameValueURI>;
              my $type = $self-><M::DISDatabase.getResource> ($type_uri);
              $res-><M::DISAnyResource.addTypeURI> ($type_uri,
                                                    srinfo => $srinfo);
              $type-><AS::DISAnyResource.isReferred> ($ce);
              if ($type-><M::DISResource.isSubsetOfURI>
                                               (<Q::dis:MultipleResource>,
                                                srinfo => $srinfo)) {
                $is_multires = true;
              }
            } elsif ($ce-><M::DISElement.elementTypeMatch>
                                                   (<Q::dis:subsetOf>,
                                         database_arg => $self,
                                         srinfo => $srinfo)) {
              my $sres = $self-><M::DISDatabase.getResource>
                                  ($ce-><M::DISElement.tfqnamesValueURI>
                                                    ($$node_id, $forArg,
                                    for_arg => $forArg, forp_arg => $forpArg,
                                    database_arg => $self));
              $res-><M::DISResource.addSuperResource> ($sres, srinfo => $srinfo);
            } elsif ($ce-><AG::DISElement.isResourceElement>) {
              push @cres, $ce;
            } elsif ($ce-><M::DISElement.elementTypeMatch>
                                                  (<Q::dis:dataType>,
                                         database_arg => $self,
                                         srinfo => $srinfo)) {
              my $uri = $ce-><AG::DISElement.qnameValueURI>;
              __CODE{dv:createURI::
                $uri => $uri,
                $result => {$res->{<Q::dis:dataType>}},
                $name => {$ce-><AG::SWCFGElement.expandedURI>},
              }__;
              my $type = $self-><M::DISDatabase.getResource> ($uri);
              $type-><AS::DISAnyResource.isReferred> ($ce);
            } elsif ($ce-><M::DISElement.elementTypeMatch>
                            (<Q::dis:multipleProperties>,
                             database_arg => $self,
                             srinfo => $srinfo)) {
              my $uri = $ce-><AG::DISElement.qnameValueURI>;
              __CODE{dv:createURI::
                $uri => $uri,
                $result => {$res->{<Q::dis:multipleProperties>}},
                $name => {$ce-><AG::SWCFGElement.expandedURI>},
              }__;              
              my $type = $self-><M::DISDatabase.getResource> ($uri);
              $type-><AS::DISAnyResource.isReferred> ($ce);
            } else {
              ## Property and invalid element is not checked, since not
              ## all property definitions has loaded at this stage. 
              push @props, $ce;
            }
          } # @ce0
   
          unless ($has_type) {
            __UNDEEP{__EXCEPTION{NO_RDF_TYPE_ERR::
              DIS:uri => {$res->{uri}},
              DIS:sourceNode => {$el},
            }__}__;
          }

          my $srres = $srinfo->{resource}->{$res-><AG::DISAnyResource.uri>};
          F: for my $auri (keys %{$srres->{aliasURI} or {}}) {
            next F unless $srres->{aliasURI}->{$auri};
            $res->{aliasURI}->{$auri} = true;
            $self->{resDef}->{$auri} = $res;
            A: for (keys %{$res->{subOf} or {}}) {
              next A unless $res->{subOf}->{$_};
              my $s = $self-><M::DISDatabase.getResource> ($_);
              $s->{supOf}->{$auri} = true;
            }
            A: for (keys %{$res->{supOf} or {}}) {
              next A unless $res->{supOf}->{$_};
              my $s = $self-><M::DISDatabase.getResource> ($_);
              $s->{subOf}->{$auri} = true;
            }
          }
          F: for my $suri (keys %{$srres->{supOf} or {}}) {
            next F unless $srres->{supOf}->{$suri};
            my $sres = $self-><M::DISDatabase.getResource> ($suri);
            $sres-><M::DISResource.addSuperResource> ($res, srinfo => $srinfo);
          }
          F: for my $suri (keys %{$srres->{subOf} or {}}) {
            next F unless $srres->{subOf}->{$suri};
            my $sres = $self-><M::DISDatabase.getResource> ($suri);
            $res-><M::DISResource.addSuperResource> ($sres, srinfo => $srinfo);
          }

          ## -- Child resources
          if (not $is_multires and not $al_node) {
            for my $re (@cres) {
              $self-><M::ManakaiDISDatabase.loadResource>
                                     ($mod, $res, $res, $re,
                                      for_arg => $forArg, forp_arg => $forpArg,
                                      on_resource_read => $onResourceRead,
                                      srinfo => $srinfo);
            }
          }

          ## -- Multiple representations
          if ($is_multires) {
            for my $pe (@props) {
              if ($pe-><M::ManakaiDISElement.elementTypeMatch>
                                               (<Q::dis:resourceFor>,
                                         database_arg => $self,
                                         srinfo => $srinfo)) {
                my $for_uri = $pe-><AG::ManakaiDISElement.qnameValueURI>;
                my $for = $self-><M::ManakaiDISDatabase.getFor> ($for_uri);
                $for-><AS::DISAnyResource.isReferred> ($pe);
                $self-><M::ManakaiDISDatabase.loadResource>
                                ($mod, $parentResource, $res, $el,
                                 for_arg => $forArg,
                                 forp_arg => [@{$forpArg}, $for_uri],
                                 on_resource_read => $onResourceRead,
                                 srinfo => $srinfo);
              }
            }
          }
          ($onResourceRead or sub {})->($self, $res);
        }__; # DEEP

  @Method:
    @@Name: readProperties
    @@enDesc:
      Reads property values in the source tree and
      removes the source tree from the database.
    @@NamedParam:
      @@@Name: onResourceRead
      @@@Type:
        DISPerl:CODE::ManakaiDOM:all
      @@@enDesc:
        An event handler called when a resource is read.
      @@@nullCase:
        @@@@enDesc:
          No event handler is read.
    @@NamedParam:
      @@@Name: implementation
      @@@Type: MinImpl
      @@@enDesc:
        The <IF::MinImpl> object to which the database belongs.
        It might be used to create property value objects.
    @@Return:
      @@@RaiseException:
        @@@@@: UNSUPPORTED_ELEMENT_TYPE_ERR
        @@@@enDesc:
          There is an element whose element type is not supported.
      @@@PerlDef:
        __DEEP{
          F: for my $fd (values %{$self->{modDef}},
                         values %{$self->{forDef}},
                         values %{$self->{resDef}}) {
            next F if $fd->isa (<ClassName::ManakaiDISModuleLite>);
            if ($fd-><AG::DISAnyResource.isDefined>) {
              $fd-><M::DISAnyResource.readProperties>
                (on_resource_read => $onResourceRead,
                 implementation => $implementation);
            }
          }
          CORE::delete $self->{<H::DIS|sourceFile>};
        }__;

  @Method:
    @@Name: checkUndefinedResource
    @@enDesc:
      Checks whether there is referred but undefined resource or not. 
    @@Return:
      @@@RaiseException:
        @@@@@: FOR_NOT_DEFINED_ERR
        @@@@enDesc:
          There is a <QUOTE::for> that is referred but not defined.
      @@@RaiseException:
        @@@@@: RESOURCE_NOT_DEFINED_ERR
        @@@@enDesc:
          There is a resource that is referred but not defined.
      @@@PerlDef:
        for my $fd (values %{$self->{forDef}}) {
          if (my $ref = $fd-><AG::DISAnyResource.isReferred> and
              not $fd-><AG::DISAnyResource.isDefined>) {
            __EXCEPTION{FOR_NOT_DEFINED_ERR::
              DIS:uri => {$fd-><AG::DISAnyResource.uri>},
              DIS:sourceNodePath => {$ref},
            }__;
          }
        }
        for my $fd (values %{$self->{resDef}}) {
          if (my $ref = $fd-><AG::DISAnyResource.isReferred> and
              not $fd-><AG::DISAnyResource.isDefined>) {
            __EXCEPTION{RESOURCE_NOT_DEFINED_ERR::
              DIS:uri => {$fd-><AG::DISAnyResource.uri>},
              DIS:sourceNodePath => {$ref},
            }__;
          }
        }

  @Method:
    @@Name: unloadModule
    @@enDesc:
      Removes a module and resources defined in the module
      from the database.
    @@Param:
      @@@Name: module
      @@@Type: DISModule
      @@@enDesc:
        The module to remove.
    @@NamedParam:
      @@@Name: srinfo
      @@@Type: DISPerl|HASH||ManakaiDOM|all
      @@@enDesc:
        A hash returned by <M::DISDatabase.unloadModule>, to
        restore super-resource relationship later.  The hash
        returned by the method is built based on this value.
      @@@nullCase:
        @@@@enDesc:
          If it is not the updating.
    @@Return:
      @@@Type: DISPerl|HASH||ManakaiDOM|all
      @@@enDesc:
        {LI:: <CODE::resource> or <CODE::for>::: 

           {LI:: <VAR::Resource URI>:::

              {LI:: <CODE::supOf>:::

                 - <VAR::Superset URI>::: A <DOM::true> value

                 where <VAR::resource URI> is a URI of the resource
                 (either canonical URI or an alias URI defined within
                 the module) and <VAR::superset URI> is a URI
                 from the list of superset URI of the resource minus
                 the list of alias URIs (including the canonical URI)
                 of the resource.

              }

              {LI:: <CODE::aliasURI>:::

                    - <VAR::Alias URI>::: A <DOM::true> value

                    where <VAR::alias URI> is an alias URI of the resource
                    defined by other module.

              }
           }
        }
      @@@PerlDef:
        __DEEP{
          $r = $srinfo || {};

          ## -- |For|s
          F: for my $for (@{$module-><M::DISModule.getForResourceList>}) {
            my $uri = $for-><AG::DISAnyResource.uri>;
            A: for (%{$for->{ISA} or {}}) {
              next A unless $for->{ISA}->{$_};
              my $sfor = $self-><M::DISDatabase.getFor> ($_);
              next A unless $sfor;
              delete $sfor->{revISA}->{$uri};
            }
            A: for (%{$for->{revISA} or {}}) {
              next A unless $for->{revISA}->{$_};
              my $sfor = $self-><M::DISDatabase.getFor> ($_);
              next A unless $sfor;
              delete $sfor->{ISA}->{$uri};
              $r->{for}->{$uri}->{supOf}->{$_} = true;
            }
            delete $self->{forDef}->{$uri};
            delete $self->{<H::DIS|resourceModuleMap>}->{$uri};
          } # F

          ## -- Resources
          my @res_list = map {
            [$_, $self-><M::DISDatabase.getResource> ($_)]
          } @{$module-><M::DISModule.getResourceURIList>};
          my %res_list = map {$_->[0] => true} @res_list;
          for my $ur (@res_list) {
            my $uri = $ur->[0];
            my $res = $ur->[1];
            my $owner = $res-><AG::DISAnyResource.ownerModule>;
            if (defined $owner and $owner eq $module) {
              ## Non-alias
              my %alias;
              my %sub = %{$res->{supOf} or {}};
              A: for (keys %{$res->{aliasURI} or {}}) {
                next A unless $res->{aliasURI}->{$_};
                $alias{$_} = true;
                delete $sub{$_} if $res->{aliasURI}->{$_};
                $r->{resource}->{$uri}->{supOf} = \%sub;
                unless ($res_list{$_}) {
                  ## Defined by other module
                  $r->{resource}->{$uri}->{aliasURI}->{$_} = true;
                }
              }
              A: for (keys %{$res->{subOf} or {}}) {
                next A unless $res->{aliasURI}->{$_};
                my $sres = $self-><M::DISDatabase.getResource> ($_);
                next A unless $sres;
                delete $res->{supOf}->{$_} for keys %alias;
              }
              A: for (keys %{$res->{supOf} or {}}) {
                next A unless $res->{aliasURI}->{$_};
                my $sres = $self-><M::DISDatabase.getResource> ($_);
                next A unless $sres;
                delete $res->{subOf}->{$_} for keys %alias;
              }
              A: for (keys %alias) {
                delete $self->{resDef}->{$_};
                delete $self->{<H::DIS|resourceModuleMap>}->{$_};
              }
            } else {
              ## Alias
              delete $res->{aliasURI}->{$uri};
              delete $res->{subOf}->{$uri};
              delete $res->{supOf}->{$uri};
              A: for (keys %{$res->{subOf} or {}}) {
                next A unless $res->{subOf}->{$_};
                my $sres = $self-><M::DISDatabase.getResource> ($_);
                next A unless $sres;
                delete $sres->{supOf}->{$uri};
              }
              A: for (keys %{$res->{supOf} or {}}) {
                next A unless $res->{supOf}->{$_};
                my $sres = $self-><M::DISDatabase.getResource> ($_);
                next A unless $sres;
                delete $sres->{subOf}->{$uri};
              }
              delete $self->{resDef}->{$uri};
              delete $self->{<H::DIS|resourceModuleMap>}->{$uri};
            }
          }

          ## -- Keys
          my $v = $module->{<H::dp|plHashKey>};
          K: for my $scope (keys %{$v or {}}) {
            my $ks = $self-><M::DISDatabase.getResource> ($scope);
            L: for my $key (keys %{$v->{$scope} or {}}) {
              next L unless $v->{$scope}->{$key};
              delete $ks->{<H::dp|plHashKey>}->{$key};
            }
          }

          ## -- Module itself
          for (@{$module-><AG::DISAnyResource.uris>}) {
            delete $self->{modDef}->{$_};
          }
        }__;
        
  @Method:
    @@Name: xcrefToResource
    @@enDesc:
      Returns a resource object selected by an exception code
      reference (<Q::dx|XCRef>).
    @@Param:
      @@@Name: xcref
      @@@Type: DISString
      @@@enDesc:
        Exception code to select.
    @@Param:
      @@@Name: contextNode
      @@@Type: NSResolverDIS
      @@@enDesc:
        A context element node.  Namespace prefixes in 
        <P::xcref> are resolved against this node.
    @@ForParam:
    @@NodeParam:
    @@Return:
      @@@Type: 
        DISPerl:ARRAY::ManakaiDOM:all
      @@@enDesc:
        A reference to the array containing two or three 
        resource definitions (<Class::ManakaiDISResourceDefinition>).
        The first (index <CODE::0>) resource is an exception class. 
        The second (index <CODE::1>) resource is an exception code 
        constant.  The third (index <CODE::2>) resource
        is an exception subtype or <DOM::null> if the reference identifies
        no subtype.
      @@@RaiseException:
        @@@@@: RESOURCE_NOT_DEFINED_ERR
        @@@@enDesc:
          The resource identified by the <P::xcref> is not defined
          or not an exception.
      @@@PerlDef:
        my ($q1, $q2, $q3) = split /\s*\.\s*/, $xcref, 3;
        __DEEP{
          if (defined $q3) {
            $r->[2] = $self-><M::ManakaiDISDatabase.getResource>
                         ($contextNode-><M::NSResolverDIS.tfqnamesToURI>
                                          ($q3, null, $forArg, node => $node));
            $r->[1] = $r->[2]-><AG::DIS|DISResource.parentResource>;
          } elsif (defined $q2) {
            if ($q2 =~ /:/) {
              $r->[1] = $self-><M::ManakaiDISDatabase.getResource>
                         ($contextNode-><M::NSResolverDIS.tfqnamesToURI>
                                          ($q2, null, $forArg, node => $node));
            } else {
              $r->[0] = $self-><M::ManakaiDISDatabase.getResource>
                         ($contextNode-><M::NSResolverDIS.tfqnamesToURI>
                                          ($q1, null, $forArg, node => $node));
              $r->[1] = $r->[0]-><M::ManakaiDISResourceDefinition
                                    .getConstResourceByName> ($q2);
            }
          } else {  ## $q1 only
            $r->[2] = $self-><M::ManakaiDISDatabase.getResource>
                         ($contextNode-><M::NSResolverDIS.tfqnamesToURI>
                                          ($q1, null, $forArg, node => $node));
            if ($r->[2]-><M::DISAnyResource.isTypeURI> (<Q::dx:ErrorSubCode>)) {
              $r->[1] = $r->[2]-><AG::DIS|DISResource.parentResource>;
            } else {
              $r->[1] = $r->[2]; CORE::delete $r->[2];
            }
          }

          if ($r->[2] and
              not $r->[2]-><M::DISAnyResource
                      .isTypeURI> (<Q::dx:ErrorSubCode>)) {
            __UNDEEP{__EXCEPTION{RESOURCE_NOT_DEFINED_ERR::
              DIS:uri => {$r->[2]->{uri}},
              DIS:expectedType => {<Q::dx:ErrorSubCode>},
              DIS:sourceNode => {$node},
              DIS:sourceCode => {$xcref},
            }__}__;
          }
          $r->[2]-><AS::DISAnyResource.isReferred>
                                               ($node or $contextNode)
            if $r->[2];
          
          if (not $r->[1] or
              not $r->[1]-><M::DISAnyResource
                      .isTypeURI> (<Q::ManakaiDOM:Const>)) {
            __UNDEEP{__EXCEPTION{RESOURCE_NOT_DEFINED_ERR::
              DIS:uri => {($r->[1] ? $r->[1]-><AG::DIS|DISAnyResource.uri>
                                   : null)},
              DIS:localName => {($r->[1] ? $r->[1]-><AG::DIS|DISAnyResource
                                           .localName> : null)},
              DIS:expectedType => {<Q::ManakaiDOM:Const>},
              DIS:sourceNode => {$node},
              DIS:sourceCode => {$xcref},
            }__}__;
          }
          $r->[1]-><AS::DISAnyResource.isReferred>
                                               ($node or $contextNode);

          unless ($r->[0]) {
            my $cg = $r->[1]-><AG::DIS|DISResource.parentResource>;
            $r->[0] = $cg-><AG::DIS|DISResource.parentResource> if $cg;
          }
          if (not $r->[0] or
              not $r->[0]-><M::DISAnyResource
                    .isTypeURI> (<Q::dx:AnyExceptionAnyClass>)) {
            __UNDEEP{__EXCEPTION{RESOURCE_NOT_DEFINED_ERR::
              DIS:uri => {$r->[0]->{uri}},
              DIS:localName => {$r->[0]-><AG::DIS|DISAnyResource.localName>},
              DIS:expectedType => {<Q::dx:AnyExceptionAnyClass>},
              DIS:sourceNode => {$node},
              DIS:sourceCode => {$xcref},
            }__}__;
          }
          $r->[0]-><AS::DISAnyResource.isReferred>
                                               ($node or $contextNode);
        }__;

  @Method:
     @@Name:  getFeature
     @@Description:
        @@@lang:en
        @@@@:
          Returns a specialized object that implements the specialized 
          interfaces of the specified feature and version.
     @@Param:
        @@@Name:  feature
        @@@Type:
          DISLang:String::ManakaiDOM:all
        @@@actualType:
          ManakaiDOM:ManakaiDOMFeatureName::ManakaiDOM:ManakaiDOMLatest
        @@@Description:
          @@@@lang:en
          @@@@@:
            A feature name to request.
     @@Param:
        @@@Name:  version
        @@@Type:
          DISLang:String::ManakaiDOM:all
        @@@actualType:
          ManakaiDOM:ManakaiDOMFeatureVersion::ManakaiDOM:ManakaiDOMLatest
        @@@Description:
          @@@@lang:en
          @@@@@:
            A feature version number to request.
     @@Return:
        @@@Type: 
          DOMMain:Object::ManakaiDOM:all
        @@@Description:
          @@@@lang:en
          @@@@@:
            An object that implements the specialized APIs of the 
            <P::feature> and <P::version>. 
        @@@nullCase:
          @@@@enDesc: 
            There is no object available that implements interfaces 
            associated with the <P::feature> and <P::version>. 
        @@@PerlDef:
          $feature =~ s/^\+//;
          CLASS: for my $class (grep {
            $Message::Util::DIS::ManakaiDISDatabase::CompatClass{$_}
          } keys %Message::Util::DIS::ManakaiDISDatabase::CompatClass) {
            if ($Message::DOM::ClassFeature{$class}->{$feature}->{$version}) {
              $r = bless {o => $self}, $class;
              last CLASS;
            }
          }

  @Method:
    @@Name: free
    @@enDesc:
      Marks the database, resources in the database, and source
      <QUOTE::dis> document trees in the database as no longer used.
    @@ForCheck: ManakaiDOM|ForClass
    @@Return:
      @@@PerlDef:
        for my $file (values %{$self->{<H::DIS|sourceFile>}}) {
          $file-><M::ManakaiNode|ManakaiNodeRef||ManakaiDOM|Perl.free>
            if $file;
        }
        CORE::delete $self->{modDef};
        CORE::delete $self->{forDef};
        CORE::delete $self->{resDef};

  @Method:
    @@Name: getModuleURIList
    @@enDesc:
      Returns a snapshot list of URIs of modules in the database.
    @@Return:
      @@@Type: DISPerl|ARRAY||ManakaiDOM|all
      @@@enDesc:
        A snapshot list of URIs.
      @@@PerlDef:
        $r = [map {$_-><AG::DIS|DISAnyResource.uri>} values %{$self->{modDef}}];

  @Method:
    @@Name: getAnyResourceURIList
    @@enDesc:
      Returns a snapshot list of URIs of resources in the database.
    @@Return:
      @@@Type: DISPerl|ARRAY||ManakaiDOM|all
      @@@enDesc:
        A snapshot list of URIs.
      @@@PerlDef:
        $r = [keys %{$self->{<H::DIS|resourceModuleMap>}},
              map {$_-><AG::DIS|DISAnyResource.uri>} values %{$self->{modDef}}];

  @IntMethod:
    @@Operator: ManakaiDOM|MUErrorHandler
    @@enDesc:
      When a <IF::ecore|ErrorInterface||ManakaiDOM|Perl> is <Perl::report>ed
      with an <Perl::-object> of <IF::Node>, then this method is invoked.
      
      The method calls the <cfg::error-handler> if the error is of 
      <IF::c|DOMError>.  Otherwise, including the cases of
      <IF::DOMCore|DOMException>s,
      the error is rethrown so that appropriate <Perl::catch> clause
      can catch the error.
    @@enImplNote:
      For implementations which does not have the
      <IF::c|DOMError||ManakaiDOM|ManakaiDOM3> interface, the method
      is defined in the <Class::ManakaiDOM|ManakaiDOMObject> class
      and it is not overridden here.
    @@Param:
      @@@Name: err
      @@@Type: ecore|ErrorInterface||ManakaiDOM|Perl
      @@@enDesc:
        The reported error object.
    @@Return:
      @@@Type: DISPerl|Any||ManakaiDOM|Perl
      @@@enDesc:
        If the <P::err> is a <IF::c|DOMError>, then the return value
        of the error handler.

           {NOTE:: If the error is thrown, the method never returns.
           }
      @@@nullCase:
        @@@@enDesc:
          No error handler.
      @@@PerlDef:
        if ($err->isa (<IFName::c|DOMError||ManakaiDOM|ManakaiDOM>)) {
          __DEEP{
            my $cfg = $self-><AG::DISDatabase.domConfig>;
            my $h = $cfg-><M::DOMConfig.getParameter> ('error-handler');
            $r = $h-><M::DOMCore|DOMErrorHandler||ManakaiDOM|ManakaiDOMLatest
                        .handleError> ($err);
          }__;
        } else {
          $err-><M::ecore|ErrorInterface||ManakaiDOM|Perl.throw>;
        }

  @Attr:
    @@Name: domConfig
    @@enDesc:
      The configuration of the document.
    @@Get:
      @@@Type: DOMConfig
      @@@enDesc: The DOM configuration object.
      @@@PerlDef:
        __CODE{c|getConfigObject||ManakaiDOM|ManakaiDOMLatest::
          $target => $self,
          $targetHash => {$self},
          $targetType => {<IFName::DISDatabase>},
          $result => $r,
        }__;

  @Method:
    @@Name: getModuleResourceList
    @@enDesc:
      Returns a snapshot list of modules contained in the database.
    @@Return:
      @@@Type: ResourceList
      @@@enDesc:
        A snapshot list of the modules.
      @@@PerlDef:
        $r = [map {$self->{modDef}->{$_}}
              grep {defined $self->{modDef}->{$_}}
              keys %{$self->{modDef}}];
##DISDatabase

CParamApp:
  @c:domConfigurationParameter: c|error-handler||ManakaiDOM|ManakaiDOMLatest
  @c:targetType: DISDatabase

ElementTypeBinding:
  @Name: CParamApp
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: c|DOMConfigurationParameterApplication
    @@For: DIS|ForLatest

PropDef:
  @QName: DIS|resourceModuleMap
  @enDesc:
    Resource-module mapping table.
  @DIS:key: rm
  @Type: DISPerl|HASH

PropDef:
  @QName: sourceNodeID
  @enDesc:
    The URI reference of the source node identifier. 
  @rdfs:domain: DIS|DISResource||DIS|ForEmpty
  @DIS:key: snid
  @Type: DISPerl|SCALAR

PropDef:
  @QName: DIS|resource
  @enDesc:    
    Resources defined in a module. 
  @rdfs:range: DIS|DISResource||DIS|ForEmpty
  @rdfs:domain: DIS|DISModule||DIS|ForEmpty
  @DIS:key: mres
  @Type: DISPerl|ARRAY

PropDef:
  @QName: DIS|parentResource
  @enDesc:
    Static parent resource.  No parent for root resources.
  @DIS:key: puri

PropDef:
  @QName: DIS|dynamicParentResource
  @enDesc:
    Dynamic parent resource.   No parent for root resources. 
  @DIS:key: dpuri

PropDef:
  @QName: DIS|childResource
  @enDesc:
    Static child resources.
  @DIS:key: curis

PropDef:
  @QName: DIS|dynamicChildResource
  @enDesc:
    Dynamic child resources.
  @DIS:key: dcuris

PropDef:
  @QName: DIS|key
  @enDesc:
    Property name in resource objects.
  @rdfs:subPropertyOf: DISPerl|propHashKey
  @dataType: DISCore|String
  @multipleProperties: DISCore|Single

ResourceDef:
  @QName: DIS|DISResourceList
  @enDesc:
    A reference to array whose items are resource 
    (<IF::DIS|DISAnyResource||DIS|ForEmpty>) objects.
  @rdfs:subClassOf: DISPerl|ARRAY
  @For: =ManakaiDOM|all
  @rdf:type: DISLang|DataType
  @For: DIS|ForEmpty !=DIS|ForEmpty
  @AliasFor:
    @@@@: ||ManakaiDOM|all
    @@@For: DIS|ForEmpty

ElementTypeBinding:
  @Name: ForDefDupException
  @ElementType:
    ManakaiDOM:raises
  @ShadowContent:
    @@@: FOR_ALREADY_DEFINED_ERR
    @@Description:
      @@@lang:en
      @@@@:
        The <QUOTE::for> is already defined elsewhere. 

ElementTypeBinding:
  @Name: ForDefNoQNameException
  @ElementType:
    ManakaiDOM:raises
  @ShadowContent:
    @@@: NO_FOR_QNAME_ERR
    @@Description:
      @@@lang:en
      @@@@:
        A <Q::dis:ForDef> element must have a <Q::dis:QName> attribute. 

ElementTypeBinding:
  @Name: ResDefDupException
  @ElementType:
    ManakaiDOM:raises
  @ShadowContent:
    @@@: RESOURCE_ALREADY_DEFINED_ERR
    @@Description:
      @@@lang:en
      @@@@:
        The <QUOTE::dis> resource is already defined elsewhere. 

ElementTypeBinding:
  @Name: ElementNotAllowedException
  @ElementType:
    ManakaiDOM:raises
  @ShadowContent:
    @@@: ELEMENT_NOT_ALLOWED_ERR
    @@Description:
      @@@lang:en
      @@@@:
        An element has found where it is not allowed. 

IFClsDef:
  @IFQName: DISModuleResolver
  @ClsQName: ManakaiDISModuleResolver

  @enDesc:
    Objects implementing <IF::DISModuleResolver> interface 
    are used to convert module name into <QUOTE::dis> document object. 
    \
    {NOTE:: It is also acceptable to pass a <Perl::CODE> reference 
            as a method parameter where <IF::DISModuleResolver> is 
            expected.
    \
    }
  @Method:
    @@Name: uriToDocument
    @@enDesc:
      Returns a <QUOTE::dis> document from module name information. 
    @@Param:
      @@@Name: disDB
      @@@Type: DISDatabase
      @@@clsActualType: ManakaiDISDatabase
      @@@enDesc:
        The <QUOTE::dis> database. 
    @@Param:
      @@@Name: moduleURI
      @@@Type: ModuleURI
      @@@enDesc:
        The URI reference of the module. 
        \
        {NOTE:: This parameter is redundant, since it can be 
                composed from other three parameters.
        \
        }
    @@Param:
      @@@Name: moduleNamespaceURI
      @@@Type: AnyURI
      @@@enDesc:
        The namespace URI of the module name. 
    @@Param:
      @@@Name: moduleLocalName
      @@@Type: 
        DISCore:LocalName::ManakaiDOM:all
      @@@enDesc:
        The local name of the module name. 
    @@Param:
      @@@Name: moduleFor
      @@@Type: ForURI
      @@@enDesc:
        The <QUOTE::for> URI reference for which the module is defined. 
    @@Return:
      @@@Type: DISDocument
      @@@clsActualType: ManakaiDISDocument
      @@@enDesc:
        The <QUOTE::dis> document.  It don't have to be a newly created
        object. 
      @@@nullCase:
        @@@@enDesc:
          The method is unable to resolve the reference. 
      @@@PerlDef:
        goto &$self;

  @ResourceDef:
    @@rdf:type: DISLang|InputProcessor
    @@PerlDef:
      $INPUT = bless $INPUT, <ClassName::ManakaiDISModuleResolver>
                 if ref $INPUT eq 'CODE';
##DISModuleResolver

PropDef:
  @QName: sourceFile
  @enDesc:
    Source <QUOTE::dis> documents. 
  @rdfs:domain: DISDatabase
  @rdfs:range: DISDocument

IFClsDef:
  @IFQName: DISAnyResource
  @ClsQName: ManakaiDISAnyResource

  @ClsISA: DOMFeature|ManakaiHasFeatureByGetFeature||ManakaiDOM|ManakaiDOMLatest

  @enDesc:
    {P:: A <IF::DISAnyResource> object represents a resource defined
    in <QUOTE::dis> files.  In <QUOTE::dis> model, resources are
    categorized as:

      - Module::: A <QUOTE::dis> module is a file entity.
                  This kind of objects <kwd:MUST> implement the
                  <IF::DISModule> interface.

      - <QUOTE::For>::: A <QUOTE::for> is a target for which 
                        resources are defined.  This kind of objects
                        <kwd:MUST> implement the <IF::DISFor> interface.
      
      - <QUOTE::dis> Resource::: Something described in <QUOTE::dis>. 
                     This kind of objects <kwd:MUST> implement the
                     <IF::DISModule> interface.

   }

   The objects implementing this interface <kwd:MUST> also implement
   the <IF::GetFeature> interface.

  @Attr:
    @@Name: uri
    @@Type: AnyURI
    @@Description:
      @@@lang:en
      @@@@:
        The URI reference of the resource. 
    @@Get:
      @@@enDesc:
        The representive URI reference of the resource.

        {NOTE:: The URI might be non-persistent if the 
                resource is not assigned a URI in <QUOTE::dis> source file,
                in which case a URI is randomly-generated at the 
                time of object generation.
        }
      @@@PerlDef:
        $r = $self->{uri};

  @Attr:
    @@Name: uriRef
    @@Type: DISPerl|SCALAR||ManakaiDOM|all
    @@enDesc:
      A reference to the URI of the resource.

      {NOTE:: Applications <kwd:MUST-NOT> modify the referenced
              value directly.
      }
    @@Get:
      @@@PerlDef: $r = \ ($self->{uri});
  
  @Attr:
    @@Name: uris
    @@Type:
      DISPerl:Array::ManakaiDOM:all
    @@enDesc:
      A set of URIs that identifies the resource.
    @@Get:
      @@@enDesc:
        A reference to array in which the URIs are contained
        in undefined order.

        {NOTE:: The array is <EM::not> live; it is only a snapshot.
        }

  @Method:
    @@Name: isSameResource
    @@Operator:
      @@@@:eq
      @@@ContentType:
        lang:Perl
    @@enDesc:
      Whether two resources are same or not.  Two resources are
      same if and only if their <A::DISAnyResource.uri> are
      equivalent as strings (i.e. in character-by-character based matching).
    @@Param:
      @@@Name: anotherResource
      @@@Type: DISAnyResource
      @@@enDesc:
        Another resource object to compare.
    @@Return:
      @@@Type:
        DOMMain:boolean::ManakaiDOM:all
      @@@enDesc:
        Whether two resources are same or not. 
      @@@TrueCase:
        @@@@enDesc: Two resources are same.
      @@@FalseCase:
        @@@@enDesc: Two resources are different.
      @@@PerlDef:
        if (UNIVERSAL::isa ($anotherResource,
                            <ClassName::ManakaiDISAnyResource>)) {
          $r = $self->{uri} eq $anotherResource->{uri};
        }

  @Attr:
    @@Name: nameURI
    @@Type: NameURI
    @@enDesc:
      The URI reference of this module, without 
      <QUOTE::for> identifier. 
    @@Get:
      @@@enDesc:
        The name URI of the resource.
      @@@nullCase:
        @@@@enDesc:
          The resource has no name URI.

          {NOTE:: A resource has no URI if and only if the resource
                  has no local name.
          }
      @@@PerlDef:
        if (defined $self->{localName}) {
          $r = defined $self->{namespaceURI}
             ? ${$self->{namespaceURI}} . ${$self->{localName}}
             : ${$self->{localName}};
        }

  @Attr:
    @@Name: localName
    @@enDesc:
      The local name of this module. 

      {NOTE:: <QUOTE::for> resources has no local name.
      }
    @@Type:
      DISCore:LocalName::ManakaiDOM:all
    @@Get:
      @@@PerlDef:
        $r = defined $self->{localName} ? ${$self->{localName}} : null;

  @Attr:
    @@Name: namespaceURI
    @@Type: AnyURI
    @@enDesc:
      The namespace URI of the name of this resource. 
      
      {NOTE:: <QUOTE::for> resources has no namespace URI.
      }
    @@Get:
      @@@PerlDef:
        $r = defined $self->{namespaceURI} ? ${$self->{namespaceURI}} : null;

  @Attr:
    @@Name: forURI
    @@Type: ForURI
    @@enDesc:
      The <QUOTE::for> URI reference for which this module is defined. 
    @@Get:
      @@@PerlDef:
        $r = defined $self->{for} ? ${$self->{for}} : null;

  @Attr:
    @@Name: forpURI
    @@enDesc:
      The <QUOTE::for+> URI references for which this resource is defined. 

      {NOTE:: <QUOTE::for> resources has no <QUOTE::for+> URI.
      }
    @@Type: ForURIList
    @@Get:
      @@@enDesc:
        List of <QUOTE::for> URI references.  Note that this list is
        <QUOTE::dead>.
      @@@PerlDef:
        $r = [@{$self->{forp}}];

  @Method:
    @@Name: isForURI
    @@enDesc:
      Tests whether this resource is defined for a <QUOTE::for>
      or <QUOTE::for+> URI reference or not.
    @@Param:
      @@@Name:forURI
      @@@Type:ForURI
      @@@enDesc:
        A <QUOTE::for> URI reference to test.
    @@Return:
      @@@Type:
        DOMMain:boolean::ManakaiDOM:all
      @@@TrueCase:
        @@@@enDesc:
          This resource is for <P::forURI>.
      @@@FalseCase:
        @@@@enDesc:
          This resource is not for <P::forURI>.
      @@@PerlDef:
        __DEEP{
          C: for my $this_for_uri (${$self->{for}||\''}, @{$self->{forp}||[]}) {
            if ($this_for_uri eq $forURI) { ## Shortcut
              $r = true;
              last C;
            }
            my $this_for = $self-><AG::DISAnyResource.database>
                                -><M::DIS|DISDatabase.getFor>
                                               ($this_for_uri);
            if ($this_for-><M::DIS|DISFor.isaURI> ($forURI)) {
              $r = true;
              last C;
            }
          }
        }__;

  @Attr:
    @@Name: isDefined
    @@Description:
      @@@lang:en
      @@@@:
        Whether this module is defined or not. 
    @@Type:
      DOMMain:boolean::ManakaiDOM:all
    @@Get:
      @@@PerlDef:
        $r = $self->{<H::DIS|isDefined>};
    @@Set:
      @@@PerlDef:
        $self->{<H::DIS|isDefined>} = $given;

  @Attr:
    @@Name: ownerModule
    @@enDesc:
      The module in which the resource is defined.  If the resource
      is a module, the module itself is the attribute value.
    @@Get:
      @@@Type: DISModule
      @@@clsActualType: ManakaiDISModuleDefinition
      @@@enDesc:
        The owner module object.
      @@@nullCase:
        @@@@enDesc:
          The resource is not part of any module since
          its definition is not read (i.e. <A::DISAnyResource.isDefined> is
          <DOM::false>) or since it is created in memory.
      @@@PerlDef:
        $r = $self-><AG::DISAnyResource.database>
                  -><M::DISDatabase.getModule>
                           (${$self->{<H::DIS|definingModule>}})
           if defined $self->{<H::DIS|definingModule>};

  @Attr:
    @@Name: ownerModuleURI
    @@enDesc:
      A URI of the owner module of the resource.
    @@Type: DIS|AnyURI
    @@nullCase:
      @@@enDesc:
        The resource does not belong to any module since the
        resource definition is not read yet or since
        it is created in memory.
    @@Get:
      @@@PerlDef: 
        if (defined $self->{<H::DIS|definingModule>}) {
          $r = ${$self->{<H::DIS|definingModule>}};
        }

  @Attr:
    @@Name: ownerModuleURIRef
    @@enDesc:
      A reference to a URI of the owner module of the resource.
    @@Type: DISPerl|SCALAR||ManakaiDOM|Perl
    @@nullCase:
      @@@enDesc:
        The resource does not belong to any module since the
        resource definition is not read yet or since
        it is created in memory.
    @@Get:
      @@@PerlDef: 
        $r = $self->{<H::DIS|definingModule>};
    @@Set:
      @@@PerlDef:
        $self->{<H::DIS|definingModule>} = $given;

  @Attr:
    @@Name: isReferred
    @@Description:
      @@@lang:en
      @@@@:
        Whether the resource is referenced somewhere or not. 
    @@Type: DISLang|String||ManakaiDOM|all
    @@Get:
      @@@enDesc:
        A node path string that identifies the node from
        which the resource is referenced.
      @@@nullCase:
        The resource is not referred. 
      @@@PerlDef:
        $r = $self->{<H::DIS|isReferred>};
    @@Set:
      @@@enDesc:
        A node path string that identifies the node from
        which the resource is referenced.
      @@@InCase:
        @@@@Type: DISElement
        @@@@enDesc:
          The resource is referenced by the element.  It's node path
          string is set as the attribute value.
      @@@PerlDef:
        if (defined $given) {
          if (ref $given) {
          __DEEP{
            if ($given->isa (<IFName::dv|DVValue>)) {
              $given = $given-><AG::dv|DVValue.sourceNodePath>;
            } else {
              $given = $given-><M::SWCFGNode.flag> ('nodePath') ||
                       $given-><M::SWCFGNode.nodePath>
                          (key => [qw/QName Name type Type/]);
            }
          }__;
          }
          $self->{<H::DIS|isReferred>} = $given;
        }

  @Attr:
    @@Name: sourceNodeID
    @@enDesc:
      The identifier URI reference of the source node. 
    @@enDesc:
      @@@ForCheck: ManakaiDOM|ForClass
      @@@@:
        Modules and <QUOTE::for>s does not have source node identifier
        in the current implementation.
    @@Type: AnyURI
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          The resource is not (yet) associated with any source node.
      @@@PerlDef:
        if (defined $self->{<H::DIS:sourceNodeID>}) {
          $r = ${$self->{<H::DIS:sourceNodeID>}};
        } else {
          $r = null;
        }
    @@Set:
      @@@PerlDef:
        if (defined $given) {
          $self->{<H::DIS:sourceNodeID>} = \$given;
        } else {
          CORE::delete $self->{<H::DIS:sourceNodeID>};
        }

  @Attr:
    @@Name: sourceNodeIDRef
    @@enDesc:
      The identifier URI reference of the source node. 
    @@enDesc:
      @@@ForCheck: ManakaiDOM|ForClass
      @@@@:
        Modules and <QUOTE::for>s does not have source node identifier
        in the current implementation.
    @@Type: DISPerl|SCALAR||ManakaiDOM|all
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          The resource is not (yet) associated with any source node.
      @@@PerlDef:
        $r = $self->{<H::DIS:sourceNodeID>};
    @@Set:
      @@@PerlDef:
        if (defined $given) {
          $self->{<H::DIS:sourceNodeID>} = $given;
        } else {
          CORE::delete $self->{<H::DIS:sourceNodeID>};
        }

  @Attr:
    @@Name: isAnonymous
    @@enDesc:
      Whether the resource has persistent name or not. 
    @@Type: 
      DOMMain:boolean::ManakaiDOM:all
    @@Get:
      @@@TrueCase:
        This resource does <EM::not> have any globally unique name. 
        <A::DISAnyResource.uri> is a temporary URI reference. 
      @@@FalseCase:
        This resource does have its formal name. 
        <A::DISAnyResource.uri> is a URI reference 
        generated from the name and the <QUOTE::for> URI reference 
        of this resource. 
      @@@PerlDef:
        $r = $self->{<H::DIS|isAnon>};
    @@Set:
      @@@PerlDef:
        $self->{<H::DIS|isAnon>} = $given;

  @Attr:
    @@Name: sourceElement
    @@enDesc:
      The source <QUOTE::dis> element node from which this 
      definition is read. 
    @@Get:
      @@@Type: DISElement
      @@@InCase:
        @@@@Type: DISModuleElement
        @@@@enDesc: If this resource is a module.
      @@@PerlDef: $r = $self->{src};
      @@@nullCase:
        @@@@enDesc:
          The definition is not yet read.

  @Attr:
    @@Name: database
    @@enDesc:
      The <QUOTE::dis> database to which the resource belongs.
    @@Type: DISDatabase
    @@Get:
      @@@PerlDef:
        $r = $self->{db};

  @Method:
    @@Name: readProperties
    @@enDesc:
      Reads property values in the source tree and
      removes reference to the source node.
    @@NamedParam:
      @@@Name: onResourceRead
      @@@Type:
        DISPerl:CODE::ManakaiDOM:all
      @@@enDesc:
        An event handler called when a resource is read.
      @@@nullCase:
        @@@@enDesc:
          No event handler is read.
    @@NamedParam:
      @@@Name: implementation
      @@@Type: MinImpl
      @@@enDesc:
        The <IF::MinImpl> object to which the database belongs.
        It might be used to create property value objects.
    @@Return:
      @@@RaiseException:
        @@@@@: UNSUPPORTED_ELEMENT_TYPE_ERR
        @@@@enDesc:
          There is an element whose element type is not supported.
      @@@PerlDef:
        __DEEP{
          if (my $src = $self->{src}) {
            my $for = $self-><AG::DISAnyResource.forURI>;
            my $forp = $self-><AG::DISAnyResource.forpURI>;
            my $db = $self-><AG::DISAnyResource.database>;
            my $factory;
            for my $el (@{$src-><M::DISElement.disChildElements>
                            (for_arg => $for,
                             forp_arg => $forp,
                             database_arg => $db)}) {
              my $xu = $el-><AG::SWCFGElement.expandedURI>;
              if ({
                <Q::dis:AliasFor> => true,
                <Q::dis:ContentType> => true,
                <Q::dis:dataType> => true,
                <Q::dis:For> => true,
                <Q::dis:ForCheck> => true,
                <Q::dis:Name> => true,
                <Q::dis:Namespace> => true,
                <Q::dis:multipleProperties> => true,
                <Q::DISCore|resourceType> => true,
                <Q::rdf:type> => true, ## TODO: Remove this.
                <Q::dis:QName> => true,
                <Q::dis:Require> => true,
                <Q::dis:resourceFor> => true,
              }->{$xu}) {
                #
              } elsif ($el-><M::DISElement.isPropertyElement>
                                                      (database_arg => $db)) {
                my $add_prop;
                $add_prop = sub ($$$) {
                  my ($self, $el, $db) = @_;
                  my $prop = $db-><M::DISDatabase.getResource>
                                ($el-><AG::SWCFGElement.expandedURI>);
                  my $prop_uri = $prop-><AG::DISAnyResource.uri>;
                  my $prop_mult = $prop-><AG::DISResource.multiplePropertiesURI>;
                  my $new_value;
                  my $base_type;
                  my $copy_tree = false;
                  
                  my %mtopt = (for_arg => $for,
                               forp_arg => $forp,
                               default_media_type => $prop-><AG::DISResource
                                                            .defaultLextypeURI>,
                               database_arg => $db);
                  my $new_value_type = $el-><M::DISElement.mediaTypeURI>(%mtopt);

                  if ($el-><M::DISElement.mediaTypeMatch>
                      (<Q::DISCore:QName>, $mtopt{default_media_type}, %mtopt)) {
                    __CODE{dv|createValue::
                      $value => {null},
                      $base_type => {$base_type = <Q::DISCore:QName>},
                      $type => {$new_value_type},
                      $result => $new_value,
                      $name => {$prop_uri},
                    }__;
                    $new_value-><AS::dv|DVQNameValue.localName>
                      ($el-><AG::DISElement.qnameValueLocalName>);
                    $new_value-><AS::dv|DVQNameValue.prefix>
                      (my $prefix = $el-><AG::DISElement.qnameValuePrefix>);
                    if (not defined $prefix) {
                      if ($el-><M::DISElement.mediaTypeMatch>
                                    (<Q::DISCore:LanguageTag>,
                                     $mtopt{default_media_type}, %mtopt)) {
                        $new_value-><AS::dv|DVQNameValue.namespaceURI>
                          ('urn:x-suika-fam-cx:lang:');
                      } elsif ($el-><M::DISElement.mediaTypeMatch>
                                    (<Q::DISCore:ScriptTag>,
                                     $mtopt{default_media_type}, %mtopt)) {
                        $new_value-><AS::dv|DVQNameValue.namespaceURI>
                          ('http://suika.fam.cx/~wakaba/archive/2005/5/script#');
                      } else {
                        $new_value-><AS::dv|DVQNameValue.namespaceURI>
                          ($el-><AG::DISElement.qnameValueNamespaceURI>);
                      }
                    } else {
                      $new_value-><AS::dv|DVQNameValue.namespaceURI>
                        ($el-><AG::DISElement.qnameValueNamespaceURI>);
                    }
                    ## TODO: Check whether defined
                  } elsif ($el-><M::DISElement.mediaTypeMatch>
                       (<Q::dis:TFQNames>, $mtopt{default_media_type}, %mtopt) or
                           $el-><M::DISElement.mediaTypeMatch>
                  (<Q::DISCore:TFPQNames>, $mtopt{default_media_type}, %mtopt)) {
                    __CODE{dv|createURI::
                      $uri => {$el-><M::DISElement.tfqnamesValueURI>
                              ($self-><AG::DISAnyResource.sourceNodeID>,
                               $self-><AG::DISAnyResource.forURI>,
                               for_arg => $self-><AG::DISAnyResource.forURI>,
                               forp_arg => $self-><AG::DISAnyResource.forpURI>,
                               database_arg => $db)},
                      $result => $new_value,
                      $name => {$prop_uri},
                    }__;
                    ## TODO: Check whether defined
                    $new_value_type = <Q::DISCore:URI>;
                  } elsif ($el-><M::DISElement.mediaTypeMatch>
                                     (<Q::lang:Perl>, $mtopt{default_media_type},
                                      %mtopt)) {
                    $el-><M::DISElement.preserveNodePath>;
                    __CODE{dv|createValueRef::
                      $value_ref => {$el-><AG::SWCFGNode.valueRef>},
                      $base_type => {$base_type = <Q::lang:Perl>},
                      $type => {$new_value_type},
                      $result => $new_value,
                      $name => $prop_uri,
                    }__;
                    for my $p (<Q::dis:Type>, <Q::dis:actualType>) {
                      if (UNIVERSAL::isa ($self->{$p},<IFName::dv|DVURIValue>)) {
                        my $v;
                        __CODE{dv|createURI::
                          $uri => {$self->{$p}-><AG::dv|DVURIValue.uri>},
                          $result => $v,
                          $name => $prop_uri,
                        }__;
                        $new_value-><M::dv|DVValue.setProperty> ($p => $v);
                      }
                    }
                    $new_value-><AS::dv|DVNSValue.defaultNamespaceURIRef>
                      ($el-><M::DISElement.getDefaultNamespaceURIRef>);
                    $new_value-><AS::dv|DVNSValue.namespaceBindingList>
                      ($el-><M::DISElement.getNamespaceBindingList> ($db));
                    $new_value-><AS::dv|DVValue.sourceNodePath>
                      ($el-><M::SWCFGNode.flag> ('nodePath'));
                  } elsif ($el-><M::DISElement.mediaTypeMatch>
                                   (<Q::lang:disdoc>, $mtopt{default_media_type},
                                    %mtopt) or
                           $el-><M::DISElement.mediaTypeMatch>
                             (<Q::lang:disdocInline>, $mtopt{default_media_type},
                                    %mtopt) or
                           $el-><M::DISElement.mediaTypeMatch>
                                     (<Q::lang:muf>, $mtopt{default_media_type},
                                      %mtopt) or
                           $el-><M::DISElement.mediaTypeMatch>
                                     (<Q::lang:dpg>, $mtopt{default_media_type},
                                      %mtopt) or
                           $el-><M::DISElement.mediaTypeMatch>
                                     (<Q::lang:tdterr>,
                                      $mtopt{default_media_type},
                                      %mtopt)) {
                    $el-><M::DISElement.preserveNodePath>;
                    __CODE{dv|createValueRef::
                      $value_ref => {$el-><AG::SWCFGNode.valueRef>},
                      $base_type => {$base_type = <Q::lang:disdoc>},
                      $type => $new_value_type,
                      $result => $new_value,
                      $name => $prop_uri,
                    }__;
                    $new_value-><AS::dv|DVNSValue.defaultNamespaceURIRef>
                      ($el-><M::DISElement.getDefaultNamespaceURIRef>);
                    $new_value-><AS::dv|DVNSValue.namespaceBindingList>
                      ($el-><M::DISElement.getNamespaceBindingList> ($db));
                    $new_value-><AS::dv|DVValue.sourceNodePath>
                      ($el-><M::SWCFGNode.flag> ('nodePath'));
                  } elsif ($el-><M::DISElement.mediaTypeMatch>
                             (<Q::dx|XCRef>,
                              $mtopt{default_media_type}, %mtopt)) {
                    my $x = $db-><M::DISDatabase.xcrefToResource>
                                 ($el-><M::SWCFGNode.value>,
                                  $el, node => $el,
                              for_arg => $self-><AG::DIS|DISAnyResource.forURI>);
                    __CODE{dv|createURI::
                      $uri => {($x->[2] or $x->[1] or $x->[0])
                               -><AG::DISAnyResource.uri>},
                      $result => $new_value,
                      $name => $prop_uri,
                    }__;
                    $new_value-><M::dv|DVURIValue.getResource> ($db)
                              -><AS::DISAnyResource.isReferred> ($el);
                    $new_value_type = <Q::DISCore:URI>;
                  } elsif ($el-><M::DISElement.mediaTypeMatch>
                             (<Q::DISLang|MemberRef>,
                              $mtopt{default_media_type}, %mtopt)) {
                    my $v = $el-><M::SWCFGNode.value>;
                    $v =~ s/^\s+//;  $v =~ s/\s+$//;
                    my ($clsq, $mem, $gs) = split /\s*\.\s*/, $v, 3;
                    my $res;
                    if (defined $mem) {
                      my $cls = $db-><M::DISDatabase.getResource>
                                     ($el-><M::DISElement.tfqnamesValueURI>
                              ($clsq, $self-><AG::DISAnyResource.sourceNodeID>,
                               $self-><AG::DISAnyResource.forURI>, node => $el));
                      $cls-><AS::DISAnyResource.isReferred> ($el);
                      $res = $cls-><M::DISResource.getChildResourceByNameAndType>
                                     ($mem, <Q::DISLang:AnyMethod>);
                      unless ($res) {
                        __UNDEEP{__EXCEPTION{DIS|RESOURCE_NOT_DEFINED_ERR::
                          DIS:localName => {$mem},
                          DIS:parentURI => {$cls-><AG::DISAnyResource.uri>},
                          DIS:elementType => {$el-><AG::SWCFGElement
                                                             .expandedURI>},
                          DIS:sourceNode => {$el},
                          DIS:sourceCode => {$v},
                          DIS:expectedType => {
                            defined $gs ? <Q::DISLang:Attribute>
                                        : <Q::DISLang:Method>
                          },
                        }__}__;
                      }
                      if (defined $gs) {
                        $res = $res-><M::DISResource.getChildResourceByType>
                                 ($gs eq 'get' ? <Q::DISLang|AttributeGet>
                                               : <Q::DISLang|AttributeSet>);
                        unless ($res) {
                          __UNDEEP{__EXCEPTION{DIS|RESOURCE_NOT_DEFINED_ERR::
                            DIS:parentURI => {$res-><AG::DISAnyResource.uri>},
                            DIS:elementType => {$el-><AG::SWCFGElement
                                                               .expandedURI>},
                            DIS:sourceNode => {$el},
                            DIS:sourceCode => {$v},
                            DIS:expectedType => {
                              $gs eq 'get' ? <Q::DISLang:AttributeGet>
                                           : <Q::DISLang:AttributeSet>
                            },
                          }__}__;
                        }                        
                      }
                    } else {
                      $res = $db-><M::DISDatabase.getResource>
                                     ($el-><M::DISElement.tfqnamesValueURI>
                              ($clsq, $self-><AG::DISAnyResource.sourceNodeID>,
                               $self-><AG::DISAnyResource.forURI>, node => $el));
                    }
                    $res-><AS::DISAnyResource.isReferred> ($el);
                    __CODE{dv|createURI::
                      $uri => {$el-><AG::DISAnyResource.uri>},
                      $result => $new_value,
                      $name => $prop_uri,
                    }__;
                    $new_value_type = <Q::DISCore:URI>;
                  } elsif ($el-><M::DISElement.mediaTypeMatch>
                                   (<Q::lang|dcmodel>,
                                    $mtopt{default_media_type}, %mtopt)) {
                    unless (defined $factory) {
                      $factory = $implementation
                                   -><M::GetFeature.getFeature>
                                       ('Core' => '3.0')
                                   -><M::DOMImpl.createDocument>;
                    }
                    my $mt = $db-><M::DISDatabase.getResource>
                                    ($el-><M::DISElement.mediaTypeURI>);
                    my $node = $mt-><M::DISAnyResource.parseString>
                                      ($el-><M::SWCFGNode.value>, $el, $factory,
                                       for_arg => $for);
                    __CODE{dv|createXMLValue::
                      $value => $node,
                      $result => $new_value,
                      $name => $prop_uri,
                    }__;
                    $new_value-><AS::dv|DVValue.sourceNodePath>
                      ($el-><M::SWCFGNode.flag> ('nodePath'));
                  } elsif ($el-><M::DISElement.mediaTypeMatch>
                                   (<Q::DISCore:NSString>,
                                    $mtopt{default_media_type}, %mtopt)) {
                    $el-><M::DISElement.preserveNodePath>;
                    __CODE{dv|createValueRef::
                      $value_ref => {$el-><AG::SWCFGNode.valueRef>},
                      $base_type => {$base_type = <Q::DISCore:NSString>},
                      $type => $new_value_type,
                      $result => $new_value,
                      $name => $prop_uri,
                    }__;
                    $new_value-><AS::dv|DVNSValue.defaultNamespaceURIRef>
                      ($el-><M::DISElement.getDefaultNamespaceURIRef>);
                    $new_value-><AS::dv|DVNSValue.namespaceBindingList>
                      ($el-><M::DISElement.getNamespaceBindingList> ($db));
                    $new_value-><AS::dv|DVValue.sourceNodePath>
                      ($el-><M::SWCFGNode.flag> ('nodePath'));
                  } elsif ($el-><M::DISElement.mediaTypeMatch>
                                     (<Q::lang:dis>, $mtopt{default_media_type},
                                      %mtopt)) {
                    $copy_tree = true;
                    $el-><M::DISElement.preserveNodePath>;
                    my $elc = $el->clone;
                    __CODE{dv|createValue::
                      $value => {$elc},
                      $base_type => {$base_type = <Q::lang:dis>},
                      $type => $new_value_type,
                      $result => $new_value,
                      $name => $prop_uri,
                    }__;
                    $elc-><M::DISElement.unlinkFromDocument> ($db);
                  } elsif ($el-><M::DISElement.mediaTypeMatch>
                                     (<Q::DISCore:Integer>,
                                      $mtopt{default_media_type}, %mtopt)) {
                    my $v = $el-><M::SWCFGNode.value>;
                    if ($v =~ /^0x/) {
                      $v = hex $v;
                    } else {
                      $v += 0;
                    }
                    __CODE{dv|createValue::
                      $value => $v,
                      $base_type => {$base_type = <Q::DISCore:Integer>},
                      $type => $new_value_type,
                      $result => $new_value,
                      $name => $prop_uri,
                    }__;
                  } elsif ($el-><M::DISElement.mediaTypeMatch>
                                     (<Q::DISCore:UString>,
                                      $mtopt{default_media_type}, %mtopt)) {
                    my $v = $el-><M::SWCFGNode.value>;
                    $v =~ s/\$\x0D?\x0A//gs;
                    $v =~ s/\$\z//;
                    warn 'String |'.$el-><M::SWCFGNode.value>.'| contains '.
                         'illegal |$| character' if $v =~ /\$(?![uU])/;
                      ## TODO: Use error-handler
                    $v =~ s{\$(u[0-9A-Fa-f]{4}|U[0-9A-Fa-f]{8})}{
                      chr hex substr $1, 1
                    }ge;
                    __CODE{dv|createValue::
                      $value => $v,
                      $base_type => {$base_type = <Q::DISCore:String>},
                      $type => {<Q::DISCore:String>},
                      $result => $new_value,
                      $name => $prop_uri,
                    }__;
                    ## NOTE: Since |type| is set to |DISCore:String|,
                    ##       what subtype of |DISCore:UString| it was originally
                    ##       is not preserved.
                  } else {
                    __CODE{dv|createValue::
                      $value => {$el-><M::SWCFGNode.value>},
                      $base_type => {$base_type = <Q::DISCore:String>},
                      $type => $new_value_type,
                      $result => $new_value,
                      $name => $prop_uri,
                    }__;
                  }

                  unless ($copy_tree) {
                  for my $ce (@{$el-><M::DISElement.disChildElements>
                            (for_arg => $for,
                             forp_arg => $forp,
                             database_arg => $db)}) {
                    my $xu = $ce-><AG::SWCFGElement.expandedURI>;
                    if ({
                      <Q::dis:AliasFor> => true,
                      <Q::dis:For> => true,
                      <Q::dis:ForCheck> => true,
                      <Q::dis:ContentType> => true,
                      <Q::dis:resourceFor> => true,
                    }->{$xu}) {
                      #
                    } elsif ($ce-><M::DISElement.isPropertyElement>
                                        (database_arg => $db)) {
                      my $pr;
                      __DEEP{
                        $pr = $add_prop->($self, $ce, $db);
                      }__;
                      if ($pr->{prop_mult} eq <Q::DISCore|OrderedList>) {
                        my $cpv = $new_value-><M::dv|DVValue.getProperty> ($xu);
                        if (not $cpv) {
                          __CODE{dv|createOrderedList::
                            $result => {$cpv},
                            $type => {$mtopt{default_media_type}},
                            $base_type => {<Q::DISCore:String>},
                          }__;
                          $new_value-><M::dv|DVValue.setProperty> ($xu => $cpv);
                        }
                        $cpv-><M::dv|DVList.addItem> ($pr->{new_value});
                      } elsif ($pr->{prop_mult} eq <Q::DISCore|UnorderedList>) {
                        my $cpv = $new_value-><M::dv|DVValue.getProperty> ($xu);
                        if (not $cpv) {
                          __CODE{dv|createUnorderedList::
                            $result => {$cpv},
                            $type => {$mtopt{default_media_type}},
                            $base_type => {<Q::DISCore:String>},
                          }__;
                          $new_value-><M::dv|DVValue.setProperty> ($xu => $cpv);
                        }
                        $cpv-><M::dv|DVList.addItem> ($pr->{new_value});
                      } else {
                        $new_value-><M::dv|DVValue.setProperty>
                                              ($xu => $pr->{new_value});
                      }
                    } else {
                      __UNDEEP{__EXCEPTION{UNSUPPORTED_ELEMENT_TYPE_ERR::
                        DIS:elementType => {$xu},
                        DIS:sourceNode => {$ce},
                      }__}__;
                    }
                  }} # copy_tree

                  {new_value => $new_value, base_type => $base_type,
                   prop_uri => $prop_uri, prop_mult => $prop_mult,
                   new_value_type => $new_value_type};
                };
                
                my $pr;
                __DEEP{
                  $pr = $add_prop->($self, $el, $db);
                }__;
                if ($pr->{prop_mult} eq <Q::DISCore|OrderedList>) {
                  if (not $self->{$pr->{prop_uri}}) {
                    __CODE{dv|createOrderedList::
                      $result => {$self->{$pr->{prop_uri}}},
                      $type => {$pr->{new_value_type}},
                      $base_type => {$pr->{base_type} || <Q::DISCore:String>},
                    }__;
                  }
                  $self->{$pr->{prop_uri}}-><M::dv|DVList.addItem>
                    ($pr->{new_value});
                } elsif ($pr->{prop_mult} eq <Q::DISCore|UnorderedList>) {
                  if (not $self->{$pr->{prop_uri}}) {
                    __CODE{dv|createUnorderedList::
                      $result => {$self->{$pr->{prop_uri}}},
                      $type => {$pr->{new_value_type}},
                      $base_type => {$pr->{base_type} || <Q::DISCore:String>},
                    }__;
                  }
                  $self->{$pr->{prop_uri}}-><M::dv|DVList.addItem>
                    ($pr->{new_value});
                } else {
                  $self->{$pr->{prop_uri}} = $pr->{new_value};
                }
                
                if ($el-><M::DISElement.elementTypeMatch>
                           (<Q::DISPerl:propHashKey>, database_arg => $db)) {
                  $db-><M::dp|DISDatabasePerl.plAddHashKey>
                           ($xu => $pr->{new_value}-><AG::dv|DVValue.stringValue>
                                => $self);
                }
              } elsif ($el-><AG::DISElement.isResourceElement>) {
                ## TODO: Should rdf:type be validated?
              } else {
                __UNDEEP{__EXCEPTION{UNSUPPORTED_ELEMENT_TYPE_ERR::
                  DIS:elementType => {$xu},
                  DIS:sourceNode => {$el},
                }__}__;
              }
            }
            CORE::delete $self->{src};
            ($onResourceRead or sub () {})->($self, $self);
          }
        }__;

  @Method:
    @@Name: isTypeURI
    @@enDesc:
      Tests whether this resource is of a type or not. 
    @@Param:
      @@@Name: typeURI
      @@@Type: ResourceURI
      @@@enDesc:
        A type URI reference to test. 
    @@Return:
      @@@Type:
        DOMMain:boolean::ManakaiDOM:all 
      @@@TrueCase:
        @@@@enDesc:
          This is a <P::typeURI> resource. 
      @@@FalseCase:
        @@@@enDesc:
          This is not a <P::typeURI> resource. 
      @@@PerlDef:
        __DEEP{
          $r = $self-><AG::DISAnyResource.typeResource>
                    -><M::DISResource.isSubsetOfURI> ($typeURI);
        }__;

  @Attr:
    @@Name: revision
    @@enDesc:
      The revision number of the resource.

      {ISSUE::
        Is it necessary for revision numbers to hold some
        kind of globality?
      }
    @@Type: RevisionNumber
    @@Get:
      @@@PerlDef:
        $r = $self->{<H::DIS|revision>};

  @CODE:
    @@QName: setRevision
    @@enDesc:
      Sets new revision number to a resource.
    @@PerlDef:
      $resource->{<H::DIS|revision>} = time;

  @CODE:
    @@QName: updateRevision
    @@enDesc:
      Updates revision number of a resource.
   
      {ISSUE::
        How revision number should be increased?
      }
    @@PerlDef:
      $resource->{<H::DIS|revision>}++;

  @Method:
    @@Name: getTypeURIList
    @@enDesc:
      Returns a snapshot list of resource type URIs of the resource.
    @@Return:
      @@@Type: URIList
      @@@enDesc:
        A snapshot list of URIs.
      @@@PerlDef:
        __DEEP{
          $r = $self-><AG::DISAnyResource.typeResource>
                    -><M::DISAnyResource.getSuperResourceURIList>;
        }__;

    @@Test:
      @@@QName: DISAnyResource.getTypeURIList.test
      @@@PerlDef:
        my $db;
        __CODE{createDISDBForTest:: $db => $db}__;

        $test->id ('module');
        my $mod1 = $db-><M::DISDatabase.getModule> ('about:module1');
        my %lm1 = map {$_ => true} @{$mod1-><M::DISAnyResource.getTypeURIList>};

        $test->assert_true ($lm1{<Q::DISCore|Module>});
        $test->assert_true ($lm1{<Q::DISCore|AnyResource>});

        $test->id ('for');
        my $for1 = $db-><M::DISDatabase.getFor> ('about:for1');
        my %lf1 = map {$_ => true} @{$for1-><M::DISAnyResource.getTypeURIList>};

        $test->assert_true ($lf1{<Q::DISCore|For>});
        $test->assert_true ($lf1{<Q::DISCore|AnyResource>});

    @@Test:
      @@@QName: DISAnyResource.resource.getTypeURIList.test
      @@@PerlDef:
        my $db;
        __CODE{createDISDBForTest:: $db => $db}__;

        $test->id ('resource');
        my $res1 = $db-><M::DISDatabase.getResource> ('about:resource1');
        my %lr1 = map {$_ => true} @{$res1-><M::DISAnyResource.getTypeURIList>};

        $test->assert_true ($lr1{<Q::DISCore|Resource>});
        $test->assert_true ($lr1{<Q::DISCore|AnyResource>});

  @Method:
    @@ForCheck: ManakaiDOM|ForIF
    @@Name: getSuperResourceURIList
    @@enDesc:
      Returns a snapshot list of super-resources URIs of the resource,
      including canonical and alias URIs of the resource itself.
    @@Return:
      @@@Type: URIList
      @@@enDesc:
        A snapshot list of URIs.

  @Attr:
    @@Name: typeResource
    @@enDesc:
      The most specific type of the resource.
    @@Type: DISResource
    @@Get:
      @@@PerlDef:
        __DEEP{
          $r = $self-><AG::DISAnyResource.database>
                    -><M::DISDatabase.getResource> ($self->{<H::DIS|typeURI>});
        }__;

  @Method:
    @@Name: addTypeURI
    @@enDesc:
      Adds a URI to the list of types of the resource.
    @@Param:
      @@@Name: uri
      @@@Type: AnyResourceURI
      @@@enDesc:
        A URI to add.
    @@NamedParam:
      @@@Name: srinfo
      @@@Type: DISPerl|HASH||ManakaiDOM|all
      @@@enDesc:
        A hash returned by <M::DISDatabase.unloadModule>, to
        restore super-resource relationship.
      @@@nullCase:
        @@@@enDesc:
          If it is not the updating.
    @@Return:
      @@@PerlDef:
        __DEEP{
          my $current_type = $self-><AG::DISAnyResource.typeResource>;
          unless ($current_type-><M::DISResource.isSubsetOfURI>
                                   ($uri, srinfo => $srinfo)) {
            my $db = $self-><AG::DISAnyResource.database>;
            my $res = $db-><M::DISDatabase.getResource> ($uri);
            my $current_uri = $current_type-><AG::DISAnyResource.uri>;
            if ($res-><M::DISResource.isSubsetOfURI>
                        ($current_uri, srinfo => $srinfo)) {
              $self->{<H::DIS|typeURI>} = $uri;
            } else {
              my $new_uri;
              __CODE{composeSubsetURI:: $input1 => $current_uri,
                                        $input2 => $uri,
                                        $output => $new_uri}__;
              my $new_res = $db-><M::DISDatabase.getResource> ($new_uri);
              unless ($new_res-><AG::DISAnyResource.isDefined>) {
                $new_res-><AS::DISAnyResource.isAnonymous> (true);
                $new_res-><AS::DISAnyResource.isDefined> (true);
                $new_res-><M::DISResource.addSuperResource>
                            ($current_type, srinfo => $srinfo);
                $new_res-><M::DISResource.addSuperResource>
                            ($res, srinfo => $srinfo);
              }
              unless ($new_res-><AG::DISAnyResource.ownerModuleURIRef>) {
                $new_res-><AS::DISAnyResource.ownerModuleURIRef>
                            ($res-><AG::DISAnyResource.ownerModuleURIRef>);
              }
              $self->{<H::DIS|typeURI>} = $new_uri;
            }
          }
        }__;

    @@Test:
      @@@QName: DISAnyResource.addTypeURI.test
      @@@PerlDef:
        my $db;
        __CODE{createDISDBForTest:: $db => $db}__;

        my $res = $db-><M::DISDatabase.getResource> ('about:1');
        my $res2 = $db-><M::DISDatabase.getResource> ('about:2');
        $test->id ('initial.resource');
        $test->assert_true
                 ($res-><M::DISAnyResource.isTypeURI> (<Q::DISCore|Resource>));
        $test->id ('initial.anyresource');
        $test->assert_true
                 ($res-><M::DISAnyResource.isTypeURI>
                          (<Q::DISCore|AnyResource>));
        $test->id ('initial.type1');
        $test->assert_false
                 ($res-><M::DISAnyResource.isTypeURI> ('about:type1'));

        $res-><M::DISAnyResource.addTypeURI> ('about:type1');

        $test->id ('added.resource');
        $test->assert_true
                 ($res-><M::DISAnyResource.isTypeURI> (<Q::DISCore|Resource>));
        $test->id ('added.anyresource');
        $test->assert_true
                 ($res-><M::DISAnyResource.isTypeURI>
                          (<Q::DISCore|AnyResource>));
        $test->id ('added.type1');
        $test->assert_true
                 ($res-><M::DISAnyResource.isTypeURI> ('about:type1'));

        $test->id ('added2.resource');
        $test->assert_true
                 ($res2-><M::DISAnyResource.isTypeURI>
                           (<Q::DISCore|Resource>));
        $test->id ('added2.anyresource');
        $test->assert_true
                 ($res2-><M::DISAnyResource.isTypeURI>
                          (<Q::DISCore|AnyResource>));
        $test->id ('added2.type1');
        $test->assert_false
                 ($res2-><M::DISAnyResource.isTypeURI> ('about:type1'));

  @CODE:
    @@QName: getMethodForType
    @@enDesc:
      Returns a method for a particular resource type.
 
      In: <Perl::$type_resource>, <Perl::$method_name>

      Out: <Perl::$method>
    @@PerlDef:
      my $__type_uri = $type_resource-><AG::DISAnyResource.uri>;
      $method = $Message::Util::DIS::Method{$__type_uri}->{$method_name};
      unless ($method) {
        my %__methods;
        for (@{$type_resource-><M::DISAnyResource.getSuperResourceURIList>}) {
          $__methods{$_} = $Message::Util::DIS::Method{$_}->{$method_name}
            if $Message::Util::DIS::Method{$_}->{$method_name};
        }
        my $__db = $type_resource-><AG::DISAnyResource.database>;
        T1: for my $__t1_uri (keys %__methods) {
          next T1 unless $__methods{$__t1_uri};
          my $__t1 = $__db-><M::DISDatabase.getResource> ($__t1_uri);
          T2: for my $__t2_uri (keys %__methods) {
            next T2 if $__t1_uri eq $__t2_uri;
            if ($__t1-><M::DISResource.isSubsetOfURI> ($__t2_uri)) {
              delete $__methods{$__t2_uri};
              next T2;
            }
            if ($Message::Util::DIS::Method{$__t1_uri}->{$method_name}
                  eq $Message::Util::DIS::Method{$__t2_uri}->{$method_name}) {
              delete $__methods{$__t2_uri};
              next T2;
            }
          }
        }
        if (keys %__methods > 1) {
          __c|ERROR{DIS|more-than-one-methods-for-a-type::
            DIS|uri => {$__type_uri},
            DIS|method-name => {$method_name},
            DIS|method-resource-types => {[keys %__methods]},
          }__;
        }
        $Message::Util::DIS::Method{$__type_uri}->{$method_name} =
        $method = $__methods{[keys %__methods]->[0]} if %__methods;
      }

  @IntMethod:
    @@Operator: ManakaiDOM|MUErrorHandler
    @@enDesc:
      When a <IF::ecore|ErrorInterface||ManakaiDOM|Perl> is <Perl::report>ed
      with an <Perl::-object> of <IF::Node>, then this method is invoked.
      
      The method calls the <cfg::error-handler> if the error is of 
      <IF::c|DOMError>.  Otherwise, including the cases of <IF::c|DOMException>s,
      the error is rethrown so that appropriate <Perl::catch> clause
      can catch the error.
    @@enImplNote:
      For implementations which does not have the
      <IF::c|DOMError||ManakaiDOM|ManakaiDOM3> interface, the method
      is defined in the <Class::ManakaiDOM|ManakaiDOMObject> class
      and it is not overridden here.
    @@Param:
      @@@Name: err
      @@@Type: ecore|ErrorInterface||ManakaiDOM|Perl
      @@@enDesc:
        The reported error object.
    @@Return:
      @@@Type: DISPerl|Any||ManakaiDOM|Perl
      @@@enDesc:
        If the <P::err> is a <IF::c|DOMError>, then the return value
        of the error handler.

           {NOTE:: If the error is thrown, the method never returns.
           }
      @@@nullCase:
        @@@@enDesc:
          No error handler.
      @@@PerlDef:
        if ($err->isa (<IFName::c|DOMError||ManakaiDOM|ManakaiDOM>)) {
          __DEEP{
            my $cfg = $self-><AG::DISAnyResource.database>
                           -><AG::DISDatabase.domConfig>;
            my $h = $cfg-><M::DOMConfig.getParameter> ('error-handler');
            $r = $h-><M::DOMCore|DOMErrorHandler||ManakaiDOM|ManakaiDOMLatest
                        .handleError> ($err);
          }__;
        } else {
          $err-><M::ecore|ErrorInterface||ManakaiDOM|Perl.throw>;
        }

  @Method:
    @@Name: getErrorInterfaceResource
    @@enDesc:
      Returns the <Q::ecore|ErrorInterface> resource
      to which the resource belongs.
    @@Return:
      @@@Type: DISAnyResource
      @@@enDesc:
        The interface resource.
      @@@nullCase:
        @@@@enDesc:
          If no resource found.
      @@@PerlDef:
        my $method;
        my $tr = $self-><AG::DISAnyResource.typeResource>;
        __CODE{DIS|getMethodForType::
          $type_resource => $tr,
          $method_name => 'get_error_interface_resource',
          $method => $method,
        }__;
        if ($method) {
          __DEEP{
            $r = $method->(@_);
          }__;
        } else {
          $r = null;
        } 

  @Method:
    @@Name: getErrorCodeResource
    @@enDesc:
      Returns the <Q::dx|ErrorCode> resource
      to which the resource belongs.
    @@Return:
      @@@Type: DISAnyResource
      @@@enDesc:
        The interface resource.
      @@@nullCase:
        @@@@enDesc:
          If no resource found.
      @@@PerlDef:
        my $method;
        my $tr = $self-><AG::DISAnyResource.typeResource>;
        __CODE{DIS|getMethodForType::
          $type_resource => $tr,
          $method_name => 'get_error_code_resource',
          $method => $method,
        }__;
        if ($method) {
          __DEEP{
            $r = $method->(@_);
          }__;
        } else {
          $r = null;
        } 

  @Method:
    @@Name: getDOMConfigurationParameterName
    @@enDesc:
      Returns the name of the DOM configuration parameter represented
      by the resource.
    @@Return:
      @@@Type: DISString
      @@@enDesc:
        The name.
      @@@nullCase:
        @@@@enDesc:
          If it is not a DOM configuration parameter or
          if it is an invalid configuration parameter and
          it has no name.
      @@@PerlDef:
        my $method;
        my $tr = $self-><AG::DISAnyResource.typeResource>;
        __CODE{DIS|getMethodForType::
          $type_resource => $tr,
          $method_name => 'get_dom_configuration_parameter_name',
          $method => $method,
        }__;
        if ($method) {
          __DEEP{
            $r = $method->(@_);
          }__;
        } else {
          $r = null;
        } 

  @Method:
    @@Name: getNodeFromStorage
    @@enDesc:
      Returns a <IF::Node> from the storage associated
      to the resource.
    @@Param:
      @@@Name: key
      @@@Type: DISString
      @@@enDesc:
        A DOM URI that identifies the kind of the node.
    @@Param:
      @@@Name: hash
      @@@Type: DISString
      @@@enDesc:
        A short string that identifies the content of the node
        to retrieve.  If it does not match to the one associated
        to the node in the storage, no node is returned.
    @@Param:
      @@@Name: factory
      @@@Type: Document
      @@@enDesc:
        The document to which the retrieved node belongs.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The retrieved node.
      @@@nullCase:
        @@@@enDesc:
          If no node is found.
      @@@PerlDef:
        require Message::DOM::TreeStore;
        my $mod = $self-><AG::DISAnyResource.ownerModule>;
        $mod-><M::dp|DISModulePerl.plLoadNodeStorage>
            unless defined $mod->{<H::DIS|nodeStorage>};
        my $st = $mod->{<H::DIS|nodeStorage>};
        if (defined $st->{$key} and $st->{$key}->[1] eq $hash) {
          $r = $factory->implementation
                       ->get_feature (<Q::fe|TreeStore>)
                       ->create_node_from_storable_object
                           ($st->{$key}->[0], $factory);
        }

  @Method:
    @@Name: setNodeToStorage
    @@enDesc:
      Saves a copy of the <IF::Node> to the storage.  Exactly
      when the physical storage is updated is implementation dependent.
    @@Param:
      @@@Name: key
      @@@Type: DISString
      @@@enDesc:
        A DOM URI that identifies the kind of the node.
    @@Param:
      @@@Name: hash
      @@@Type: DISString
      @@@enDesc:
        A short string that identifies the content of the node.
        If the <P::node> parameter is set to <DOM::null>, 
        this value is ignored.
    @@Param:
      @@@Name: node
      @@@Type: Node
      @@@enDesc:
        The node to store.  If there is already a node
        with the <P::key>, it is discarded.
      @@@nullCase:
        @@@@enDesc:
          The stored node, if any, is removed from the storage.
    @@Return:
      @@@PerlDef:
        require Message::DOM::TreeStore;
        my $mod = $self-><AG::DISAnyResource.ownerModule>;
        $mod-><M::dp|DISModulePerl.plLoadNodeStorage>
            unless defined $mod->{<H::DIS|nodeStorage>};
        my $st = $mod->{<H::DIS|nodeStorage>};
        if (defined $node) {
          $st->{$key}->[0] = [$node->owner_document
                                   ->implementation
                                   ->get_feature (<Q::fe|TreeStore>)
                                   ->create_storable_object_from_node
                                       ($node), $hash];
        } else {
          delete $st->{$key};
        }
        $mod->{<H::DIS|nodeStorageModified>} = true;

  @Method:
    @@Name: parseString
    @@enDesc:
      Parses a string assuming that this resource is a <Q::DISCore|LexicalType>.
    @@Param:
      @@@Name: s
      @@@Type: DISString
      @@@enDesc:
        The string to parse.
    @@Param:
      @@@Name: ns
      @@@Type: NSResolverDIS
      @@@enDesc:
        The namespace context object.
    @@Param:
      @@@Name: factory
      @@@Type: Document
      @@@enDesc:
        The <IF::Document> node to which the returned <IF::Node> belongs.
    @@ForParam:
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The <IF::Node> object obtained as a result of parsing 
        of <P::s> in the context of <P::ns>.
      @@@nullCase:
        @@@@enDesc:
          If this resource is not a <Q::DISCore|LexicalType>
          or if no parser is found.
      @@@PerlDef:
        my $method;
        __CODE{DIS|getMethodForType::
          $type_resource => $self,
          $method_name => 'parse_string',
          $method => $method,
        }__;
        if ($method) {
          __DEEP{
            $r = $method->(@_);
          }__;
        } else {
          $r = null;
        } 
##DISAnyResource

PropDef:
  @QName: DIS|nodeStorage
  @DIS:key: nst

PropDef:
  @QName: DIS|nodeStorageModified
  @DIS:key: nstmod

ResourceDef:
  @QName: Node
  @AliasFor: tc|Node||ManakaiDOM|ManakaiDOMLatest
  @For: DIS|ForLatest

ResourceDef:
  @QName: Document
  @AliasFor: td|Document||ManakaiDOM|ManakaiDOMLatest
  @For: DIS|ForLatest

ResourceDef:
  @QName: Element
  @AliasFor: te|Element||ManakaiDOM|ManakaiDOMLatest
  @For: DIS|ForLatest

ResourceDef:
  @QName: DOMConfig
  @AliasFor: DOMCore|DOMConfiguration||ManakaiDOM|ManakaiDOMLatest
  @For: DIS|ForLatest

ErrDef:
  @QName: DIS|more-than-one-methods-for-a-type
  @enDesc:
    If more than one different method implementations are defined
    for a resource type.
  @enMufDef:
    Method |%p (name => {<Q::DIS|method-name>});| for
    resource <%p (name => {<Q::DIS|uri>});> has multiple definitions
  @c:severity: DOMCore|SEVERITY_WARNING||ManakaiDOM|ManakaiDOMLatest
  @ecore:hasParameter:
    @@@: DIS|uri
    @@enDesc:
      A URI of the type.
  @ecore:hasParameter:
    @@@: DIS|method-name
    @@enDesc:
      The name of the method.
  @ecore:hasParameter:
    @@@: DIS|method-resource-types
    @@enDesc:
      The snapshot list of types for which methods are defined.

XParamDef:
  @QName: DIS|fileName
  @enDesc:
    The name of the file.

XParamDef:
  @QName: DIS|method-name
  @enDesc:
    The name of the method in question.

XParamDef:
  @QName: DIS|method-resource-types
  @enDesc:
    The snapshot list of types for which methods are defined.

XParamDef:
  @QName: DIS|forURI

ElementTypeBinding:
  @Name: ErrDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DOMCore|DOMErrorType
    @@For: DIS|ForLatest
    @@ecore:textFormatter: ecore|MUErrorFormatter||ManakaiDOM|Perl

URITypeDef:
  @QName: AnyResourceURI
  @enDesc:
    A URI that identifies a <Q::DISCore|AnyResource>.

DataTypeDef:
  @QName: AnyResourceURIList
  @enDesc:
    A snapshot list of URIs that identify <Q::DISCore|AnyResource>s.
  @rdfs:subClassOf: DISPerl|ARRAY

PropDef:
  @QName: DIS|typeURI
  @enDesc:
    The URI of the most specific type of the resource.
  @DIS:key: tu

IFClsDef:
  @IFQName: DISModule
  @ClsQName: ManakaiDISModuleDefinition

  @ClsISA: ManakaiDISPropertyAccessor
  @ClsISA: ManakaiDISPerlModuleDefinition
  @ClsISA: dp|ManakaiDISModulePerl
  @ClsISA: dp|ManakaiDISAnyResourcePerl
  @ClsISA: ManakaiDISAnyResource

  @Implement: GetFeature

  @enDesc:
    <QUOTE::dis> module definitions. 

  @enDesc:
    @@ForCheck: ManakaiDOM|ForIF
    @@@:
      The objects implementing the <IF::DISModule> interface <kwd:MUST>
      also implement the <IF::DISAnyResource> interface.

  @DISLang:role: ModuleRole
  
  @Attr:
    @@ForCheck: ManakaiDOM|ForClass
    @@Name: uris
    @@Type:
      DISPerl:Array::ManakaiDOM:all
    @@enDesc:
      A reference to the snapshot array containing the URI reference
      of the module.
    @@Get:
      @@@PerlDef:
        $r = [$self->{uri}];

  @Attr:
    @@ForCheck: ManakaiDOM|ForClass
    @@Name: ownerModule
    @@ManakaiDOM:isRedefining:1
    @@enDesc:
      This module itself.
    @@Get:
      @@@Type: DISModule
      @@@clsActualType: ManakaiDISModuleDefinition
      @@@nullCase:
        @@@@enDesc:
          The resource is not part of any module since
          its definition is not read (<IF::DISModule.isDefined> is <DOM::false>).
      @@@PerlDef: $r = $self;

  @Method:
    @@ForCheck: ManakaiDOM|ForClass
     @@Name:  getFeature
     @@Description:
        @@@lang:en
        @@@@:
          Returns a specialized object that implements the specialized 
          interfaces of the specified feature and version.
     @@Param:
        @@@Name:  feature
        @@@Type:
          DISLang:String::ManakaiDOM:all
        @@@actualType: DOMFeature|FeatureNameString||ManakaiDOM|ManakaiDOMLatest
        @@@Description:
          @@@@lang:en
          @@@@@:
            A feature name to request.
     @@Param:
        @@@Name:  version
        @@@Type:
          DISLang:String::ManakaiDOM:all
        @@@actualType:
          DOMFeature|FeatureVersionString||ManakaiDOM|ManakaiDOMLatest
        @@@Description:
          @@@@lang:en
          @@@@@:
            A feature version number to request.
     @@Return:
        @@@Type: 
          DOMMain:Object::ManakaiDOM:all
        @@@Description:
          @@@@lang:en
          @@@@@:
            An object that implements the specialized APIs of the 
            <P::feature> and <P::version>. 
        @@@nullCase:
          @@@@enDesc: 
            There is no object available that implements interfaces 
            associated with the <P::feature> and <P::version>. 
        @@@PerlDef:
          $feature =~ s/^\+//;
          CLASS: for my $class (grep {
            $Message::Util::DIS::ManakaiDISModuleDefinition::CompatClass{$_}
          } keys %Message::Util::DIS::ManakaiDISModuleDefinition::CompatClass) {
            if ($Message::DOM::ClassFeature{$class}->{$feature}->{$version}) {
              $r = bless {o => $self}, $class;
              last CLASS;
            }
          }

  @Method:
    @@Name: addResourceList
    @@enDesc:
      Adds a resource to the list of resources belongs to the module.
    @@Param:
      @@@Name: disResource
      @@@Type: DIS|DISResource
      @@@enDesc: The resource to add.
    @@Return:
      @@@PerlDef:
        __DEEP{
          push @{$self->{<H::DIS|resource>}||=[]},
               map {\$_} @{$disResource-><AG::DIS|DISAnyResource.uris>};
        }__;

  @Method:
    @@Name: addResourceURI
    @@enDesc:
      Adds a resource URI to the list of resources belongs to the module.
    @@Param:
      @@@Name: uri
      @@@Type: DISString
      @@@enDesc:
        The URI to add.
    @@Return:
      @@@PerlDef:
        push @{$self->{<H::DIS|resource>}||=[]}, \$uri;

  @Method:
    @@Name: getResourceURIList
    @@enDesc:
      Returns the list of URIs of resources belongs to the module.
    @@Return:
      @@@Type: AnyResourceURIList
      @@@enDesc:
        The snapshot list of URIs.
      @@@PerlDef:
        $r = [map {$$_} @{$self->{<H::DIS|resource>} or []}];

  @Method:
    @@Name: getResourceList
    @@enDesc:
      Returns the list of resources belongs to the module.
    @@Return:
      @@@Type: DIS|ResourceList
      @@@enDesc:
        The current snapshot of children.
      @@@PerlDef:
        __DEEP{
          my $db = $self-><AG::DIS|DISAnyResource.database>;
          $r = [map {
                  $db-><M::DIS|DISDatabase.getResource> ($$_)
                } @{$self->{<H::DIS|resource>}}];
        }__;

  @Method:
    @@Name: addForResource
    @@enDesc:
      Adds a <QUOTE::for> resource to the list of <QUOTE::for>
      resources belongs to the module.
    @@Param:
      @@@Name: disResource
      @@@Type: DISFor
      @@@enDesc: The resource to add.
    @@Return:
      @@@PerlDef:
        __DEEP{
          push @{$self->{<H::DIS|forList>}||=[]},
               $disResource-><AG::DISAnyResource.uriRef>;
        }__;

  @Method:
    @@Name: getForResourceList
    @@enDesc:
      Returns the list of <QUOTE::for> resources belongs to the module.
    @@Return:
      @@@Type: ResourceList
      @@@enDesc:
        The current snapshot list of <QUOTE::for> resources,
        which may or may not contains dupulications.
      @@@PerlDef:
        __DEEP{
          my $db = $self-><AG::DIS|DISAnyResource.database>;
          $r = [map {
                  $db-><M::DIS|DISDatabase.getFor> ($$_)
                } @{$self->{<H::DIS|forList>}}];
        }__;

  @Attr:
    @@Name: targetNamespaceURI
    @@enDesc:
      The default namespace URI of the resources defined in the module.
    @@Type: DIS|AnyURI
    @@Get:
      @@@PerlDef:
        $r = defined $self->{<H::DIS|defaultNamespaceURI>}
             ? ${$self->{<H::DIS|defaultNamespaceURI>}} : null;
    @@Set:
      @@@ForCheck: ManakaiDOM|ForClass
      @@@PerlDef:
        if (defined $given) {
          $self->{<H::DIS|defaultNamespaceURI>} = \$given;
        } else {
          CORE::delete $self->{<H::DIS|defaultNamespaceURI>};
        }

  @CMethod:
    @@Name: getSuperResourceURIList
    @@enDesc:
      Returns a snapshot list of super-resources URIs of the resource,
      including canonical and alias URIs of the resource itself.
    @@Return:
      @@@Type: URIList
      @@@enDesc:
        A snapshot list of URIs.
      @@@PerlDef:
        $r = [$self->{uri}];

    @@Test:
      @@@QName: DISModule.getSuperResourceURIList.test
      @@@PerlDef:
        my $db;
        __CODE{createDISDBForTest:: $db => $db}__;

        my $res = $db-><M::DISDatabase.getModule> ('about:1');

        my %list = map {$_ => true} @{$res-><M::DISAnyResource
                                               .getSuperResourceURIList>};

        $test->assert_true ($list{'about:1'});
        $test->assert_false ($list{'about:2'});

  @Method:
    @@Name: getReferringModuleURIList
    @@enDesc:
      Reurns a snapshot list of the name URIs of modules referenced
      from the module.
    @@Return:
      @@@Type: URIList
      @@@enDesc:
        The snapshot list of URIs.
      @@@PerlDef:
        $r = [grep {$self->{<H::DIS|referringModule>}->{$_}}
              keys %{$self->{<H::DIS|referringModule>} or {}}];

  @Method:
    @@Name: addReferringModuleURI
    @@enDesc:
      Adds a URI to the list of modules referenced from the module.
    @@Param:
      @@@Name: uri
      @@@Type: DISString
      @@@enDesc:
        The URI to add.
    @@Return:
      @@@PerlDef:
        $self->{<H::DIS|referringModule>}->{$uri} = true;
##DISModule

PropDef:
  @QName: DIS|referringModule
  @DIS:key: ref

PropDef:
  @QName: DIS|forList
  @enDesc:
    A list of references to URIs of <QUOTE::for> resources
    belongs to the module.

ClsDef:
  @ClsQName: ManakaiDISModuleLite

  @Implement: GetFeature
  @Implement: DIS|DISResourceProp
  @Implement: dp|DISAnyResourcePerl
  @Implement: dp|DISModulePerl
  @Implement: dp|DISResourcePerlModule

  @enDesc:
    The <Class::ManakaiDISModuleLite> class provides very small
    subset of <Class::ManakaiDISModuleDefinition> class.  If a
    method or attribute which is not implemented by the class, then
    the object is updated to the <Class::ManakaiDISModuleDefinition>
    by reading additional properties from the <QUOTE::dis> database.

  @Attr:
    @@Name: uri
    @@Type: AnyURI
    @@Description:
      @@@lang:en
      @@@@:
        The URI reference of the resource. 
    @@Get:
      @@@enDesc:
        The representive URI reference of the resource.

        {NOTE:: The URI might be non-persistent if the 
                resource is not assigned a URI in <QUOTE::dis> source file,
                in which case a URI is randomly-generated at the 
                time of object generation.
        }
      @@@PerlDef:
        $r = $self->{uri};

  @Attr:
    @@Name: uriRef
    @@Type: DISPerl|SCALAR||ManakaiDOM|all
    @@enDesc:
      A reference to the URI of the resource.

      {NOTE:: Applications <kwd:MUST-NOT> modify the referenced
              value directly.
      }
    @@Get:
      @@@PerlDef: $r = \ ($self->{uri});
  
  @Attr:
    @@ForCheck: ManakaiDOM|ForClass
    @@Name: uris
    @@Type:
      DISPerl:Array::ManakaiDOM:all
    @@enDesc:
      A reference to the snapshot array containing the URI reference
      of the module.
    @@Get:
      @@@PerlDef:
        $r = [$self->{uri}];

  @Method:
    @@Name: isSameResource
    @@Operator:
      @@@@:eq
      @@@ContentType:
        lang:Perl
    @@enDesc:
      Whether two resources are same or not.  Two resources are
      same if and only if their <A::DISAnyResource.uri> are
      equivalent as strings (i.e. in character-by-character based matching).
    @@Param:
      @@@Name: anotherResource
      @@@Type: DISAnyResource
      @@@enDesc:
        Another resource object to compare.
    @@Return:
      @@@Type:
        DOMMain:boolean::ManakaiDOM:all
      @@@enDesc:
        Whether two resources are same or not. 
      @@@TrueCase:
        @@@@enDesc: Two resources are same.
      @@@FalseCase:
        @@@@enDesc: Two resources are different.
      @@@PerlDef:
        if (UNIVERSAL::isa ($anotherResource,
                            <ClassName::ManakaiDISAnyResource>)) {
          $r = $self->{uri} eq $anotherResource->{uri};
        }

  @Attr:
    @@Name: nameURI
    @@Type: NameURI
    @@enDesc:
      The URI reference of this module, without 
      <QUOTE::for> identifier. 
    @@Get:
      @@@enDesc:
        The name URI of the resource.
      @@@nullCase:
        @@@@enDesc:
          The resource has no name URI.

          {NOTE:: A resource has no URI if and only if the resource
                  has no local name.
          }
      @@@PerlDef:
        if (defined $self->{localName}) {
          $r = defined $self->{namespaceURI}
             ? ${$self->{namespaceURI}} . ${$self->{localName}}
             : ${$self->{localName}};
        }

  @Attr:
    @@Name: localName
    @@enDesc:
      The local name of this module. 

      {NOTE:: <QUOTE::for> resources has no local name.
      }
    @@Type:
      DISCore:LocalName::ManakaiDOM:all
    @@Get:
      @@@PerlDef:
        $r = defined $self->{localName} ? ${$self->{localName}} : null;

  @Attr:
    @@Name: namespaceURI
    @@Type: AnyURI
    @@enDesc:
      The namespace URI of the name of this resource. 
      
      {NOTE:: <QUOTE::for> resources has no namespace URI.
      }
    @@Get:
      @@@PerlDef:
        $r = defined $self->{namespaceURI} ? ${$self->{namespaceURI}} : null;

  @Attr:
    @@Name: forURI
    @@Type: ForURI
    @@enDesc:
      The <QUOTE::for> URI reference for which this module is defined. 
    @@Get:
      @@@PerlDef:
        $r = defined $self->{for} ? ${$self->{for}} : null;

  @Attr:
    @@Name: forpURI
    @@enDesc:
      The <QUOTE::for+> URI references for which this resource is defined. 

      {NOTE:: <QUOTE::for> resources has no <QUOTE::for+> URI.
      }
    @@Type: ForURIList
    @@Get:
      @@@enDesc:
        List of <QUOTE::for> URI references.  Note that this list is
        <QUOTE::dead>.
      @@@PerlDef:
        $r = [@{$self->{forp}}];

  @Method:
    @@Name: isForURI
    @@enDesc:
      Tests whether this resource is defined for a <QUOTE::for>
      or <QUOTE::for+> URI reference or not.
    @@Param:
      @@@Name:forURI
      @@@Type:ForURI
      @@@enDesc:
        A <QUOTE::for> URI reference to test.
    @@Return:
      @@@Type:
        DOMMain:boolean::ManakaiDOM:all
      @@@TrueCase:
        @@@@enDesc:
          This resource is for <P::forURI>.
      @@@FalseCase:
        @@@@enDesc:
          This resource is not for <P::forURI>.
      @@@PerlDef:
        __DEEP{
          C: for my $this_for_uri (${$self->{for}||\''}, @{$self->{forp}||[]}) {
            if ($this_for_uri eq $forURI) { ## Shortcut
              $r = true;
              last C;
            }
            my $this_for = $self-><AG::DISAnyResource.database>
                                -><M::DIS|DISDatabase.getFor>
                                               ($this_for_uri);
            if ($this_for-><M::DIS|DISFor.isaURI> ($forURI)) {
              $r = true;
              last C;
            }
          }
        }__;

  @Attr:
    @@Name: isDefined
    @@Description:
      @@@lang:en
      @@@@:
        Whether this module is defined or not. 
    @@Type:
      DOMMain:boolean::ManakaiDOM:all
    @@Get:
      @@@PerlDef:
        $r = $self->{<H::DIS|isDefined>};
    @@Set:
      @@@PerlDef:
        $self->{<H::DIS|isDefined>} = $given;

  @Attr:
    @@ForCheck: ManakaiDOM|ForClass
    @@Name: ownerModule
    @@ManakaiDOM:isRedefining:1
    @@enDesc:
      This module itself.
    @@Get:
      @@@Type: DISModule
      @@@clsActualType: ManakaiDISModuleDefinition
      @@@nullCase:
        @@@@enDesc:
          The resource is not part of any module since
          its definition is not read (<IF::DISModule.isDefined> is <DOM::false>).
      @@@PerlDef: $r = $self;

  @Attr:
    @@Name: ownerModuleURI
    @@enDesc:
      A URI of the owner module of the resource.
    @@Type: DIS|AnyURI
    @@nullCase:
      @@@enDesc:
        The resource does not belong to any module since the
        resource definition is not read yet or since
        it is created in memory.
    @@Get:
      @@@PerlDef: 
        $r = $self->{uri};

  @Attr:
    @@Name: ownerModuleURIRef
    @@enDesc:
      A reference to a URI of the owner module of the resource.
    @@Type: DISPerl|SCALAR||ManakaiDOM|Perl
    @@nullCase:
      @@@enDesc:
        The resource does not belong to any module since the
        resource definition is not read yet or since
        it is created in memory.
    @@Get:
      @@@PerlDef: 
        $r = \ ($self->{uri});
    @@Set:
      @@@PerlDef: # no effect

  @Attr:
    @@Name: database
    @@enDesc:
      The <QUOTE::dis> database to which the resource belongs.
    @@Type: DISDatabase
    @@clsActualType: ManakaiDISDatabase
    @@Get:
      @@@PerlDef:
        $r = $self->{db};

  @Method:
    @@Operator:
      @@@@: AUTOLOAD
      @@@ContentType: lang|Perl
    @@Return:
      @@@PerlDef:
        my $al = our $AUTOLOAD;
        $al =~ s/.+:://;
        if ($al ne 'DESTROY') {

        __DEEP{
          $self-><AG::DIS|DISAnyResource.database>
               -><M::dp|ManakaiDISDatabasePerl.plLoadDISDatabaseModule> ($self);
        }__;        
        if (ref $self eq <ClassName::ManakaiDISModuleLite>) {
          __EXCEPTION{DIS|RESOURCE_NOT_DEFINED_ERR::
            DIS:uri => {$self-><AG::DIS|DISAnyResource.uri>},
            DIS:moduleURI => {$self-><AG::DIS|DISAnyResource.uri>},
          }__;
        }

        my $code = $self->can ($al);
        if ($code) {
          goto &$code;
        } else {
          require Carp;
          local $Carp::CarpLevel = $Error::Depth;
          Carp::croak (qq<Can't locate method "$AUTOLOAD">);
        }

        } # $al

  @Attr:
    @@Name: targetNamespaceURI
    @@enDesc:
      The default namespace URI of the resources defined in the module.
    @@Type: DIS|AnyURI
    @@Get:
      @@@PerlDef:
        $r = defined $self->{<H::DIS|defaultNamespaceURI>}
             ? ${$self->{<H::DIS|defaultNamespaceURI>}} : null;
##DISModuleLite

IFClsDef:
  @IFQName: DISFor
  @ClsQName: ManakaiDISForDefinition

  @ClsISA: dp|ManakaiDISAnyResourcePerl
  @ClsISA: ManakaiDISPropertyAccessor
  @ClsISA: ManakaiDISAnyResource

  @DISLang:role: ForRole

  @Description:
    @@lang:en
    @@@:
      <QUOTE::dis> <QUOTE::for> definitions. 

  @Attr:
    @@ForCheck: ManakaiDOM|ForClass
    @@Name: uris
    @@Type: 
      DISPerl:Array::ManakaiDOM:all
    @@actualType: ForURIList
    @@enDesc:
      A reference to the snapshot array containing the URI reference
      of the <QUOTE::for>.
    @@Get:
      @@@PerlDef:
        $r = [$self->{uri}];

  @Method:
    @@Name: isaURI
    @@Description:
      @@@lang:en
      @@@@:
        Whether this <QUOTE::for> is-a another <QUOTE::for> or not. 
    @@Param:
      @@@Name: superURI
      @@@Type: ForURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          Another <QUOTE::for> URI reference to test. 
    @@Return:
      @@@Type: 
        DOMMain:boolean::ManakaiDOM:all
      @@@TrueCase:
        @@@@enDesc:
          <P::superURI> is a super-<QUOTE::for> of this <QUOTE::for>. 
      @@@FalseCase:
        @@@@enDesc:
          <P::superURI> is not a super-<QUOTE::for> of this <QUOTE::for>. 
      @@@PerlDef:
        $r = $self->{uri} eq $superURI ? true : $self->{isa}->{$superURI};

  @Method:
    @@Name: addISA
    @@enDesc:
      Adds a <QUOTE::for> to the list of super-<QUOTE::for> of this 
      <QUOTE::for>.
    @@Param:
      @@@Name: superFor
      @@@Type: DISFor
      @@@clsActualType: ManakaiDISForDefinition
      @@@enDesc:
        A <QUOTE::for> definition object. 
    @@Return:
      @@@PerlDef:
        my @from = ($self->{uri},
                    grep {$self->{revISA}->{$_}} keys %{$self->{revISA}});
        my @to = ($superFor->{uri},
                  grep {$superFor->{isa}->{$_}} keys %{$superFor->{isa}});
        __DEEP{
          for my $from (@from) {
            for my $to (@to) {
              $self->{db}-><M::ManakaiDISDatabase.getFor>
                                      ($from)->{isa}->{$to} = true;
              $self->{db}-><M::ManakaiDISDatabase.getFor>
                                      ($to)->{revISA}->{$from} = true;
            }
          }
        }__;

  @Method:
     @@Name:  getFeature
     @@Description:
        @@@lang:en
        @@@@:
          Returns a specialized object that implements the specialized 
          interfaces of the specified feature and version.
     @@Param:
        @@@Name:  feature
        @@@Type:
          DISLang:String::ManakaiDOM:all
        @@@actualType:
          ManakaiDOM:ManakaiDOMFeatureName::ManakaiDOM:ManakaiDOMLatest
        @@@Description:
          @@@@lang:en
          @@@@@:
            A feature name to request.
     @@Param:
        @@@Name:  version
        @@@Type:
          DISLang:String::ManakaiDOM:all
        @@@actualType:
          ManakaiDOM:ManakaiDOMFeatureVersion::ManakaiDOM:ManakaiDOMLatest
        @@@Description:
          @@@@lang:en
          @@@@@:
            A feature version number to request.
     @@Return:
        @@@Type: 
          DOMMain:Object::ManakaiDOM:all
        @@@Description:
          @@@@lang:en
          @@@@@:
            An object that implements the specialized APIs of the 
            <P::feature> and <P::version>. 
        @@@nullCase:
          @@@@enDesc: 
            There is no object available that implements interfaces 
            associated with the <P::feature> and <P::version>. 
        @@@PerlDef:
          $feature =~ s/^\+//;
          CLASS: for my $class (grep {
            $Message::Util::DIS::ManakaiDISForDefinition::CompatClass{$_}
          } keys %Message::Util::DIS::ManakaiDISForDefinition::CompatClass) {
            if ($Message::DOM::ClassFeature{$class}->{$feature}->{$version}) {
              $r = bless {o => $self}, $class;
              last CLASS;
            }
          }

  @Attr:
    @@ForCheck: ManakaiDOM|ForClass
    @@Name: forURI
    @@Type: ForURI
    @@enDesc:
      The <QUOTE::for> URI reference for which this module is defined. 
    @@Get:
      @@@InCase:
        @@@@Value:
          @@@@@@: ManakaiDOM|all
          @@@@@ContentType: DISCore|QName
        @@@@enDesc:
          The attribute value is always <Q::ManakaiDOM|all> for a
          <QUOTE::for> resource.
      @@@PerlDef:
        $r = <Q::ManakaiDOM|all>;

  @Attr:
    @@Name: forpURI
    @@enDesc:
      The <QUOTE::for+> URI references for which this resource is defined. 
    @@Type: ForURIList
    @@Get:
      @@@enDesc:
        List of <QUOTE::for> URI references.  Note that this list is
        <QUOTE::dead>.
      @@@InCase:
        @@@@Value:
          @@@@@@: []
          @@@@@ContentType: lang|Perl
        @@@@enDesc:
          The attribute value is always an empty array reference
          for a <QUOTE::for> resource.
      @@@PerlDef: $r = [];

  @Method:
    @@Name: isForURI
    @@enDesc:
      Tests whether this resource is defined for a <QUOTE::for>
      or <QUOTE::for+> URI reference or not.
    @@Param:
      @@@Name:forURI
      @@@Type:ForURI
      @@@enDesc:
        A <QUOTE::for> URI reference to test.
    @@Return:
      @@@Type:
        DOMMain:boolean::ManakaiDOM:all
      @@@TrueCase:
        @@@@enDesc:
          This resource is for <P::forURI>.  The attribute
          always takes this value for <QUOTE::for> resources.
      @@@PerlDef: $r = true;

  @Attr:
    @@ForCheck: ManakaiDOM|ForClass
    @@Name: nameURI
    @@Type: NameURI
    @@enDesc:
      The URI reference of this module, without 
      <QUOTE::for> identifier. 
    @@Get:
      @@@enDesc:
        The attribute value is always equals to
        <A::DISAnyResource.uri> for <QUOTE::for> resources.
      @@@PerlDef: $r = $self->{uri};

  @CMethod:
    @@Name: getSuperResourceURIList
    @@enDesc:
      Returns a snapshot list of super-resources URIs of the resource,
      including canonical and alias URIs of the resource itself.
    @@Return:
      @@@Type: URIList
      @@@enDesc:
        A snapshot list of URIs.
      @@@PerlDef:
        $r = [
               (grep {$self->{isa}->{$_}} keys %{$self->{isa}}),
               (grep {$self->{aliasURI}->{$_}} keys %{$self->{aliasURI}}),
               ($self->{uri}),
             ];

    @@Test:
      @@@QName: DISFor.getSuperResourceURIList.test
      @@@PerlDef:
        my $db;
        __CODE{createDISDBForTest:: $db => $db}__;

        my $res1 = $db-><M::DISDatabase.getFor> ('about:1');

        my %list1 = map {$_ => true} @{$res1-><M::DISAnyResource
                                               .getSuperResourceURIList>};

        $test->assert_true ($list1{'about:1'});
        $test->assert_false ($list1{'about:2'});
        $test->assert_true ($list1{<Q::ManakaiDOM:all>});

        my $res2 = $db-><M::DISDatabase.getFor> ('about:2');
        $res1-><M::DISFor.addISA> ($res2);

        my %list1_2 = map {$_ => true} @{$res1-><M::DISAnyResource
                                               .getSuperResourceURIList>};

        $test->assert_true ($list1_2{'about:1'});
        $test->assert_true ($list1_2{'about:2'});
        $test->assert_true ($list1_2{<Q::ManakaiDOM:all>});

        my %list2 = map {$_ => true} @{$res2-><M::DISAnyResource
                                               .getSuperResourceURIList>};

        $test->assert_false ($list2{'about:1'});
        $test->assert_true ($list2{'about:2'});
        $test->assert_true ($list2{<Q::ManakaiDOM:all>});
##DISFor

IFClsDef:
  @IFQName: DISResource
  @ClsQName: ManakaiDISResourceDefinition

  @ClsISA: ManakaiDISResourceMV
  @ClsISA: dp|ManakaiDISResourcePerl
  @ClsISA: ManakaiDISPerlModuleDefinition
  @ClsISA: dp|ManakaiDISAnyResourcePerl
  @ClsISA: ManakaiDISPropertyAccessor
  @ClsISA: ManakaiDISAnyResource

  @DISLang:role: ResourceRole

  @enDesc:
    <QUOTE::dis> resource definitions. 

  @enDesc:
    @@ForCheck: ManakaiDOM|ForIF    
    @@@:
      The objects implementing the <IF::DISResource> interface
      <kwd:MUST> also implement the <IF::DISAnyResource> interface.

  @Attr:
    @@ForCheck: ManakaiDOM|ForClass
    @@Name: uris
    @@Type: 
      DISPerl:Array::ManakaiDOM:all
    @@enDesc:
      Returns the current <EM::snapshot> of the URI references
      for this resource, including the alias URI references.
    @@Get:
      @@@PerlDef:
        $r = [grep {$self->{aliasURI}->{$_}} keys %{$self->{aliasURI}}];

  @Method:
    @@Name: isSubsetOfURI
    @@Description:
      @@@lang:en
      @@@@:
        Whether this resource is a subset of another resource or not. 
    @@Param:
      @@@Name: superURI
      @@@Type: ResourceURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          Another resource URI reference to test. 
    @@NamedParam:
      @@@Name: srinfo
      @@@Type: DISPerl|HASH||ManakaiDOM|all
      @@@enDesc:
        The <CODE::srinfo> hash.
      @@@nullCase:
        @@@@enDesc:
          No <CODE::srinfo>.
    @@Return:
      @@@Type: 
        DOMMain:boolean::ManakaiDOM:all
      @@@TrueCase:
        @@@@enDesc:
          <P::superURI> is a super-resource of this resource. 
      @@@FalseCase:
        @@@@enDesc:
          <P::superURI> is not a super-resource of this resource. 
      @@@PerlDef:
        $r = $self->{aliasURI}->{$superURI} || $self->{subOf}->{$superURI};
        if (not $r and $srinfo) {
          A: {
            if ($srinfo->{resource}->{$superURI}) {
              for my $this_uri (grep {$self->{aliasURI}->{$_}}
                                keys %{$self->{aliasURI}}) {
                if ($srinfo->{resource}->{$superURI}->{aliasURI}->{$this_uri}) {
                  $r = true;
                  last A;
                }
                if ($srinfo->{resource}->{$superURI}->{supOf}->{$this_uri}) {
                  $r = true;
                  last A;
                }
              }
            }
            for my $this_uri (grep {$self->{aliasURI}->{$_}}
                              keys %{$self->{aliasURI}}) {
              if ($srinfo->{resource}->{$this_uri}) {
                if ($srinfo->{resource}->{$this_uri}->{aliasURI}->{$superURI}) {
                  $r = true;
                  last A;
                }
              }
            }
          } # A
        }

  @Method:
    @@Name: addSuperResource
    @@enDesc:
      Adds a <QUOTE::dis> resource to the list of super-resource 
      of this <QUOTE::dis> resource. 
    @@Param:
      @@@Name: superRes
      @@@Type: DISResource
      @@@clsActualType: ManakaiDISResourceDefinition
      @@@enDesc:
        A <QUOTE::dis> resource definition object. 
    @@NamedParam:
      @@@Name: srinfo
      @@@Type: DISPerl|HASH||ManakaiDOM|all
      @@@enDesc:
        The <CODE::srinfo> hash.
      @@@nullCase:
        @@@@enDesc:
          No <CODE::srinfo>.
    @@Return:
      @@@PerlDef:
        my @from = ($self->{uri},
                    grep {$self->{supOf}->{$_}} keys %{$self->{supOf}||{}});
        my @to = ($superRes->{uri},
                 grep {$superRes->{subOf}->{$_}} keys %{$superRes->{subOf}||{}});
        __DEEP{
          for my $from (@from) {
            for my $to (@to) {
              $self->{db}-><M::ManakaiDISDatabase.getResource>
                                      ($from)->{subOf}->{$to} = true;
              $srinfo->{resource}->{$from}->{subOf}->{$to} = true;
              $self->{db}-><M::ManakaiDISDatabase.getResource>
                                      ($to)->{supOf}->{$from} = true;
              $srinfo->{resource}->{$to}->{supOf}->{$from} = true;
            }
          }
        }__;
   
  @Method:
    @@Name: mergeAsAlias
    @@enDesc:
      Merges another resource definition as an alias of this resource. 
    @@Param:
      @@@Name: aliasResource
      @@@Type: DISResource
      @@@clsActualType: ManakaiDISResourceDefinition
      @@@enDesc:
        A resource to merge.
        \
        {NOTE:: After merging all references to <P::aliasResource> 
                should be discarded.
        \
        }
    @@NodeParam:
    @@NamedParam:
      @@@Name: noEqualityCheck
      @@@Type: idl|boolean||ManakaiDOM|all
      @@@enDesc:
        Don't throw <X::MERGE_ITSELF_ERR> exception.
    @@NamedParam:
      @@@Name: srinfo
      @@@Type: DISPerl|HASH||ManakaiDOM|all
      @@@enDesc:
        The <CODE::srinfo> hash.
      @@@nullCase:
        @@@@enDesc:
          No <CODE::srinfo>.
    @@Return:
      @@@RaiseException:
        @@@@@:MERGE_ITSELF_ERR
        @@@@@@enDesc:
          An attempt is made to merge this resource itself. 
      @@@PerlDef:
        if (not $noEqualityCheck and $self eq $aliasResource) {
          __EXCEPTION{MERGE_ITSELF_ERR::
            DIS:uri => {$self-><AG::DISAnyResource.uri>},
            DIS:sourceNode => {$node},
          }__;
        }
        for my $uri ($aliasResource->{uri}, 
                     grep {$aliasResource->{aliasURI}->{$_}}
                          keys %{$aliasResource->{aliasURI}}) {
          $self->{aliasURI}->{$uri} = true;
          $self->{db}->{resDef}->{$uri} = $self;
          $self->{subOf}->{$uri} = true;
          $self->{supOf}->{$uri} = true;
        }
        for my $uri (grep {$aliasResource->{subOf}->{$_}}
                          keys %{$aliasResource->{subOf}||{}}) {
          $self->{subOf}->{$uri} = true;
        }
        for my $uri (grep {$aliasResource->{supOf}->{$_}}
                          keys %{$aliasResource->{supOf}||{}}) {
          $self->{supOf}->{$uri} = true;
        }
        my @from = grep {$self->{supOf}->{$_}} keys %{$self->{supOf}||{}};
        my @to   = grep {$self->{subOf}->{$_}} keys %{$self->{subOf}||{}};
        __DEEP{
          for my $from (@from) {
            for my $to (@to) {
              $self->{db}-><M::ManakaiDISDatabase.getResource>
                                      ($from)->{subOf}->{$to} = true;
              $srinfo->{resource}->{$from}->{subOf}->{$to} = true;
              $self->{db}-><M::ManakaiDISDatabase.getResource>
                                      ($to)->{supOf}->{$from} = true;
              $srinfo->{resource}->{$to}->{supOf}->{$from} = true;
            }
          }
        }__;

  @Attr:
    @@Name: disDataTypeResource
    @@enDesc:
      The resource referenced by <Q::dis:Type> property.

      = If the resource has the <Q::dis:Type> property, 
        then its value references the data type resource.

      = If the resource has no <Q::dis:Type> property but
        the dynamic parent resource has the <Q::dis:Type> property,
        then its value references the data type resource.
 
      = Otherwise, the resource has no associated data type resoruce;
        this method throws a <X::NO_DIS_TYPE_ERR> exception.
    @@Type: DISResource
    @@clsActualType: ManakaiDISResourceDefinition
    @@Get:
      @@@RaiseException:
        @@@@@:NO_DIS_TYPE_ERR
        @@@@enDesc:
          <Q::dis:Type> attribute is not specified. 
      @@@PerlDef:
        __DEEP{
          if (UNIVERSAL::isa ($self->{<Q::dis:Type>}, <IFName::dv|DVURIValue>)) {
            $r = $self->{<Q::dis:Type>}-><M::dv|DVURIValue.getResource>
                     ($self-><AG::DISAnyResource.database>);
          } else {
            my $pr = $self-><AG::DIS|DISResource.dynamicParentResource>;
            $r = $pr-><AG::DISResource.disDataTypeResource> if $pr;
          }
        }__;
        unless ($r) {
          __EXCEPTION{NO_DIS_TYPE_ERR::
            DIS:uri => {$self-><AG::DISAnyResource.uri>},
            DIS:sourceNode => {$self-><AG::DISAnyResource.sourceElement>},
          }__;
        }

  @Attr:
    @@Name: disDataTypeValue
    @@enDesc:
      The <Q::dis:Type> property value for the resource.
    @@Get:
      @@@Type: dv|DVURIValue
      @@@clsActualType: dv|ManakaiDVURIValue
      @@@RaiseException:
        @@@@@:NO_DIS_TYPE_ERR
        @@@@enDesc:
          <Q::dis:Type> attribute is not specified.
      @@@PerlDef:
        __DEEP{
          if (UNIVERSAL::isa ($self->{<Q::dis:Type>}, <IFName::dv|DVURIValue>)) {
            $r = $self->{<Q::dis:Type>};
          } else {
            my $pr = $self-><AG::DIS|DISResource.dynamicParentResource>;
            $r = $pr-><AG::DISResource.disDataTypeValue> if $pr;
          }
        }__;
        unless ($r) {
          __EXCEPTION{NO_DIS_TYPE_ERR::
            DIS:uri => {$self-><AG::DISAnyResource.uri>},
            DIS:sourceNode => {$self-><AG::DISAnyResource.sourceElement>},
          }__;
        }

  @Attr:
    @@Name: disActualDataTypeResource
    @@enDesc:
      <Q::dis:actualType> attribute value of this resource. 
    @@Type: DISResource
    @@clsActualType: ManakaiDISResourceDefinition
    @@Get:
      @@@RaiseException:
        @@@@@:NO_DIS_TYPE_ERR
        @@@@enDesc:
          <Q::dis:actualType> attribute is not specified, 
          and <Q::dis:Type> attribute, neigher. 
      @@@PerlDef:
        __DEEP{
          if (UNIVERSAL::isa ($self->{<Q::dis:actualType>},
                              <IFName::dv|DVURIValue>)) {
            $r = $self->{<Q::dis:actualType>}-><M::dv|DVURIValue.getResource>
                    ($self-><AG::DISAnyResource.database>);
          } elsif (UNIVERSAL::isa ($self->{<Q::dis:Type>},
                                   <IFName::dv|DVURIValue>)) {
            $r = $self->{<Q::dis:Type>}-><M::dv|DVURIValue.getResource>
                    ($self-><AG::DISAnyResource.database>);
          } else {
            my $pr = $self-><AG::DIS|DISResource.dynamicParentResource>;
            $r = $pr-><AG::DISResource.disActualDataTypeResource> if $pr;
          }
        }__;
        unless ($r) {
          __EXCEPTION{NO_DIS_TYPE_ERR::
            DIS:uri => {$self-><AG::DISAnyResource.uri>},
            DIS:sourceNode => {$self-><AG::DISAnyResource.sourceElement>},
          }__;
        }

  @Attr:
    @@Name: disActualDataTypeValue
    @@enDesc:
      <Q::dis:actualType> node for this resource. 
    @@Get:
      @@@Type: DISElement
      @@@clsActualType: ManakaiDISElement
      @@@RaiseException:
        @@@@@:NO_DIS_TYPE_ERR
        @@@@enDesc:
          <Q::dis:actualType> attribute is not specified, 
          and <Q::dis:Type> attribute, neigher. 
      @@@PerlDef:
        __DEEP{
          if (UNIVERSAL::isa ($self->{<Q::dis:actualType>},
                              <IFName::dv|DVURIValue>)) {
            $r = $self->{<Q::dis:actualType>};
          } elsif (UNIVERSAL::isa ($self->{<Q::dis:Type>},
                                   <IFName::dv|DVURIValue>)) {
            $r = $self->{<Q::dis:Type>};
          } else {
            my $pr = $self-><AG::DIS|DISResource.dynamicParentResource>;
            $r = $pr-><AG::DISResource.disActualDataTypeValue> if $pr;
          }
        }__;
        unless ($r) {
          __EXCEPTION{NO_DIS_TYPE_ERR::
            DIS:uri => {$self-><AG::DISAnyResource.uri>},
            DIS:sourceNode => {$self-><AG::DISAnyResource.sourceElement>},
          }__;
        }

  @IntMethod:
    @@Operator:
      @@@@: <=>
      @@@ContentType:
        lang:Perl
    @@enDesc:
      Compares two resources.  If the first character of the 
      node in the source tree by which the resource is defined
      occures before the other resource's first character, then
      the former resource is <DFN::less> than the later resource.
      If two resources are the same resource, they are <DFN::equal>.
      Otherwise, the former resource is <DFN::greater> than
      the later resource.

      There are two exceptions.  If two resources belongs to
      two different modules, i.e. their <A::DIS|DISAnyResource.ownerModule>s
      are different, the order is not defined.  Also, if
      one of resources is not yet defined, i.e. one's 
      <A::DIS|DISAnyResource.isDefined> takes <DOM::false> value,
      then the order is not defined.  Even in these cases, two
      calls for the method with the same parameter would return
      the same result while the resources are left unchanged.
    @@Param:
      @@@Name: anotherResource
      @@@Type: DISResource
      @@@enDesc: Another resource to compare.
    @@Return:
      @@@Type:
        DOMMain:unsigned-long::ManakaiDOM:all
      @@@PerlDef:
        if (UNIVERSAL::isa ($anotherResource,
                            <ClassName::ManakaiDISResourceDefinition>)) {
          $r = $self->{seq} <=> $anotherResource->{seq};
        } else {
          $r = $self->{uri} <=> $anotherResource;
        }

  @Method:
    @@ForCheck: ManakaiDOM|ForClass
    @@ManakaiDOM:isForInternal:1
    @@Name: addChildResource
    @@enDesc:
      Registers a resource as a static child of the resource.
    @@Param:
      @@@Name: disResource
      @@@Type: DIS|DISResource
      @@@enDesc:
        The resurce to add.
    @@Return:
      @@@PerlDef:
        __DEEP{
          push @{$self->{<H::DIS|childResource>}||=[]},
               $disResource-><AG::DIS|DISAnyResource.uriRef>;
        }__;

  @Method:
    @@ForCheck: ManakaiDOM|ForClass
    @@ManakaiDOM:isForInternal:1
    @@Name: addDynamicChildResource
    @@enDesc:
      Registers a resource as a dynamic child of the resource.
    @@Param:
      @@@Name: disResource
      @@@Type: DIS|DISResource
      @@@enDesc:
        The resurce to add.
    @@Return:
      @@@PerlDef:
        __DEEP{
          push @{$self->{<H::DIS|dynamicChildResource>}||=[]},
               $disResource-><AG::DIS|DISAnyResource.uriRef>;
        }__;

  @Method:
    @@Name: getChildResourceList
    @@enDesc:
      Returns the list of static child resources of the resource.
    @@Return:
      @@@Type: DIS|ResourceList
      @@@enDesc:
        The current snapshot of children.
      @@@PerlDef:
        __DEEP{
          my $db = $self-><AG::DIS|DISAnyResource.database>;
          $r = [map {
                  $db-><M::DIS|DISDatabase.getResource> ($$_)
                } @{$self->{<H::DIS|childResource>}}];
        }__;

  @Method:
    @@Name: getDynamicChildResourceList
    @@enDesc:
      Returns the list of dynamic child resources of the resource.
    @@Return:
      @@@Type: DIS|ResourceList
      @@@enDesc:
        The current snapshot of children.
      @@@PerlDef:
        __DEEP{
          my $db = $self-><AG::DIS|DISAnyResource.database>;
          $r = [map {
                  $db-><M::DIS|DISDatabase.getResource> ($$_)
                } @{$self->{<H::DIS|dynamicChildResource>}}];
        }__;

  @Method:
    @@Name: getChildResourceByType
    @@enDesc:
      Gets a static child resource selected by its type. 
    @@Param:
      @@@Name:typeURI
      @@@Type:ResourceURI
      @@@enDesc:
        A URI reference identifying a resource type. 
    @@ImplNote:
      @@@lang:en
      @@@@:
        {ISSUE:: Some inheritance tracing required for 
        e.g. <Q::DISLang:InputProcessor> and <Q::DOMMain:ReflectGet>?
        }
    @@Return:
      @@@Type: DISResource
      @@@clsActualType: ManakaiDISResourceDefinition
      @@@enDesc:
        The first child resource (in document order) whose 
        type matches with <P::typeURI>. 
      @@@nullCase:
        @@@@enDesc:
          There is no resource whose type is <P::typeURI>.
      @@@PerlDef:
        __DEEP{
          my $db = $self-><AG::DIS|DISAnyResource.database>;
          C: for my $cr_uri (@{$self->{<H::DIS:childResource>}||[]}) {
            my $cr = $db-><M::DIS|DISDatabase.getResource> ($$cr_uri);
            if ($cr-><M::DIS|DISAnyResource.isTypeURI> ($typeURI)) {
              $r = $cr;
              last C;
            }
          }
        }__;

  @Method:
    @@Name: getChildResourceListByType
    @@enDesc:
      Returns a list of child resources of a specific type.
    @@Param:
      @@@Name: typeURI
      @@@Type: DIS|AnyURI
      @@@enDesc:
        A URI of the type.
    @@Return:
      @@@Type: DIS|ResourceList
      @@@enDesc:
        The current snapshot of the child resources of type <P::typeURI>.
      @@@PerlDef:
        __DEEP{
          my $db = $self-><AG::DIS|DISAnyResource.database>;
          $r = [grep {
                  $_-><M::DIS|DISAnyResource.isTypeURI> ($typeURI)
                } map {
                  $db-><M::DIS|DISDatabase.getResource> ($$_)
                } @{$self->{<H::DIS|childResource>}||[]}];
        }__;

  @Method:
    @@Name: getChildResourceByNameAndType
    @@enDesc:
      Gets a static child resource selected by its local name and type. 
    @@Param:
      @@@Name: localName
      @@@Type:
        DISCore:LocalName::ManakaiDOM:all
      @@@enDesc:
        A local name. 
    @@Param:
      @@@Name:typeURI
      @@@Type:ResourceURI
      @@@enDesc:
        A URI reference identifying a resource type. 
    @@Return:
      @@@Type: DISResource
      @@@clsActualType: ManakaiDISResourceDefinition
      @@@enDesc:
        The first (by document order) child resource whose 
        type matches for <P::localName> and <P::typeURI>. 
      @@@nullCase:
        @@@@enDesc:
          There is no resource whose name is <P::localName> and
          whose type is <P::typeURI>.
      @@@PerlDef:
        __DEEP{
          my $db = $self-><AG::DIS|DISAnyResource.database>;
          C: for my $cr_uri (@{$self->{<H::DIS:childResource>}||[]}) {
            my $cr = $db-><M::DIS|DISDatabase.getResource> ($$cr_uri);
            my $ln = $cr-><AG::DIS|DISAnyResource.localName>;
            if (defined $ln and $ln eq $localName and
                $cr-><M::DIS|DISAnyResource.isTypeURI> ($typeURI)) {
              $r = $cr;
              last C;
            }
          }
        }__;

  @Method:
    @@Name: getConstResourceByName
    @@enDesc:
      Gets a constant value resource by its local name. 
    @@Param:
      @@@Name:localName
      @@@Type:
        DISLang:String::ManakaiDOM:all
      @@@enDesc:
        Constant name.
    @@Return:
      @@@Type: DISResource
      @@@clsActualType: ManakaiDISResourceDefinition
      @@@enDesc:
        The constant resource identified by <P::localName>.
      @@@nullCase:
        @@@@enDesc:
          There is no such constant resource.
      @@@PerlDef:
        __DEEP{
          my @constGroup;
          my $db = $self-><AG::DIS|DISAnyResource.database>;
          C: for my $cr_uri (@{$self->{<H::DIS:childResource>}||[]}) {
            my $cr = $db-><M::DIS|DISDatabase.getResource> ($$cr_uri);
            my $ln = $cr-><AG::DIS|DISAnyResource.localName>;
            if ($ln and $ln eq $localName and
                $cr-><M::DIS|DISAnyResource.isTypeURI> (<Q::DISLang:Const>)) {
              $r = $cr;
              last C;
            } elsif ($cr-><M::DIS|DISAnyResource.isTypeURI>
                                (<Q::DISLang:ConstGroup>)) {
              push @constGroup, $cr;
            }
          }
          unless ($r) {
            D: for my $cg (@constGroup) {
              $r = $cg-><M::DIS|DISResource.getChildResourceByNameAndType>
                             ($localName, <Q::DISLang:Const>);
              last D if $r;
            }
          }
        }__;

  @Attr:
    @@Name: parentResource
    @@enDesc:
      The static parent resource of the resource.
    @@Type: DIS|DISResource
    @@nullCase:
      @@@enDesc: No parent resource.
    @@Get:
      @@@PerlDef:
        __DEEP{
          if ($self->{<H::DIS|parentResource>}) {
            $r = $self-><AG::DIS|DISAnyResource.database>
                      -><M::DIS|DISDatabase.getResource>
                            (${$self->{<H::DIS|parentResource>}});
          }
        }__;
    @@Set:
      @@@ForCheck: ManakaiDOM|ForClass
      @@@PerlDef:
        __DEEP{
          if ($given) {
            $self->{<H::DIS|parentResource>}
              = $given-><AG::DIS|DISAnyResource.uriRef>;
          } else {
            CORE::delete $self->{<H::DIS|parentResource>};
          }
        }__;

  @Attr:
    @@Name: dynamicParentResource
    @@enDesc:
      The dynamic parent resource of the resource.
    @@Type: DIS|DISResource
    @@nullCase:
      @@@enDesc: No parent resource.
    @@Get:
      @@@PerlDef:
        __DEEP{
          if ($self->{<H::DIS|dynamicParentResource>}) {
            $r = $self-><AG::DIS|DISAnyResource.database>
                      -><M::DIS|DISDatabase.getResource>
                            (${$self->{<H::DIS|dynamicParentResource>}});
          }
        }__;
    @@Set:
      @@@ForCheck: ManakaiDOM|ForClass
      @@@PerlDef:
        __DEEP{
          if ($given) {
            $self->{<H::DIS|dynamicParentResource>}
              = $given-><AG::DIS|DISAnyResource.uriRef>;
          } else {
            CORE::delete $self->{<H::DIS|dynamicParentResource>};
          }
        }__;

  @Attr:
    @@Name: ownerClassNodeURI
    @@enDesc:
      The node URI reference of the class resource this resource
      belongs to.
    @@Type: ResourceURI
    @@Get:
      @@@enDesc:
        The URI reference of the <Q::ManakaiDOM:Class> resource.
        If this resource is a class, then the URI reference
        of this resource is returned.
      @@@nullCase:
        @@@@enDesc:
          This resource does not belong to any class.
      @@@PerlDef:
        if (exists $self->{<H::DIS:ownerClass>}) {
          $r = $self->{<H::DIS:ownerClass>};
        } else {
          my $res = $self;
          __DEEP{
            RES: {
              if ($res-><M::DISAnyResource.isTypeURI>
                             (<Q::ManakaiDOM:Class>)) {
                $r = $res-><AG::DISAnyResource.sourceNodeID>;
              } else {
                $res = $res-><AG::DIS|DISResource.parentResource>;
                redo RES if $res;
              }
            }
          }__;
          $self->{<H::DIS:ownerClass>} = $r;
        }

  @Attr:
    @@Name: disIsNullValue
    @@enDesc:
      Whether this resource have <DOM::null> value or not. 
      A resource have <DOM::null> value iff it has
      <Q::dis:Value> attribute node that in turn has
      <Q::dis:is-null> attribute whose value set to <DOM::true>.
    @@Type:
      DOMMain:boolean::ManakaiDOM:all
    @@Get:
      @@@PerlDef:
        if ($self->{<Q::dis:Value>}) {
          $r = $self->{<Q::dis:Value>}-><AG::dv|DVValue.isNull>;
        }

  @Attr:
    @@Name: featureNameList
    @@enDesc:
      The list of the names of the feature defined by this resource.

        = If the resource has one or more <Q::dis:AppName> attributes,
          their text values are feature names.

        = If there is no <Q::dis:AppName> attributes but the resource
          is a <Q::DOMFeature:instanceOf> another feature, then 
          the set of the feature names of the resource is equal
          to the one of another feature's feature names.

        {OLI:: If two operation above does not result in one or more
               feature names,

           = and if the resource has a name (the <A::DISAnyResource
             .isAnonymous> attribute returns <DOM::false>), then
             the <A::DISAnyResource.nameURI> of the resource is 
             a feature name.

           = otherwise, i.e. <A::DISAnyResource.isAnonymous> is
             <DOM::true>, then the <A::DISAnyResource.localName>
             of the resource, if non-<DOM::null>, is a feature name.

        }

    @@Type:
      DISPerl:ARRAY::ManakaiDOM:all
    @@Get:
      @@@enDesc:
        A reference to the array containing feature names.
        Note that the order in the array is <EM::not> significant.
        The array might be empty if the resource has no feature name.
        This array is dead.

        {NOTE:: The attribute value array might be non-empty
                even if the resource is not of type <Q::DOMFeature:Feature>
                as far as the algorithm defined above returns
                some feature names.
        }
      @@@RaiseException:
        @@@@@: NO_SOURCE_NODE_ERR
        @@@@enDesc:
          This resource definition does not have associated node 
          in the source tree. 
      @@@PerlDef:
        __DEEP{
          $r = [map {lc} @{$self-><M::DISResourceProp.getPropertyTextList>
                            (<Q::DOMFeature:name>)}];
          unless (@$r) {
            ## TODO: instance feature
            my $pr = $self-><AG::DIS|DISResource.parentResource>;
            if ($pr) {
              if ($pr-><M::DISAnyResource.isTypeURI> (<Q::DOMFeature:Feature>) and
                  not $pr-><AG::DISAnyResource.isAnonymous>) {
                push @$r, @{$pr-><AG::DISResource.featureNameList>};
              }
            }
          }
          unless (@$r) {
            if ($self-><AG::DISAnyResource.isAnonymous>) {
              my $ln = $self-><AG::DISAnyResource.localName>;
              push @$r, lc $ln if defined $ln;
            } else {
              push @$r, lc $self-><AG::DISAnyResource.nameURI>;
            }
          }
        }__;

  @Method:
     @@ForCheck: ManakaiDOM|ForClass
     @@Name:  getFeature
     @@Description:
        @@@lang:en
        @@@@:
          Returns a specialized object that implements the specialized 
          interfaces of the specified feature and version.
     @@Param:
        @@@Name:  feature
        @@@Type:
          DISLang:String::ManakaiDOM:all
        @@@actualType:
          ManakaiDOM:ManakaiDOMFeatureName::ManakaiDOM:ManakaiDOMLatest
        @@@Description:
          @@@@lang:en
          @@@@@:
            A feature name to request.
     @@Param:
        @@@Name:  version
        @@@Type:
          DISLang:String::ManakaiDOM:all
        @@@actualType:
          ManakaiDOM:ManakaiDOMFeatureVersion::ManakaiDOM:ManakaiDOMLatest
        @@@Description:
          @@@@lang:en
          @@@@@:
            A feature version number to request.
     @@Return:
        @@@Type: 
          DOMMain:Object::ManakaiDOM:all
        @@@Description:
          @@@@lang:en
          @@@@@:
            An object that implements the specialized APIs of the 
            <P::feature> and <P::version>. 
        @@@nullCase:
          @@@@enDesc: 
            There is no object available that implements interfaces 
            associated with the <P::feature> and <P::version>. 
        @@@PerlDef:
          $feature =~ s/^\+//;
          CLASS: for my $class (grep {
            $Message::Util::DIS::ManakaiDISResourceDefinition::CompatClass{$_}
          } keys %Message::Util::DIS::ManakaiDISResourceDefinition::CompatClass){
            if ($Message::DOM::ClassFeature{$class}->{$feature}->{$version}) {
              $r = bless {o => $self}, $class;
              last CLASS;
            }
          }

  @Attr:
    @@Name: multiplePropertiesURI
    @@enDesc:
      Whether the property allows multiple occurence of the attribute
      in the <QUOTE::dis> source tree.
    @@Type: DISLang|String||ManakaiDOM|all
    @@Get:
      @@@PerlDef:
        __DEEP{
          if ($self->{<Q::dis|multipleProperties>}) {
            $r = $self->{<Q::dis|multipleProperties>}
                      -><M::dv|DVURIValue.getResource>
                            ($self-><AG::DISAnyResource.database>)
                      -><AG::DISAnyResource.uri>;
          } else {
            $r = <Q::DISCore|OrderedList>;
          }
        }__;

  @Attr:
    @@Name: defaultLextypeURI
    @@enDesc:
      The URI of the default lexical type for the <QUOTE::dis> attribute.
    @@Type: DISLang|String||ManakaiDOM|all
    @@Get:
      @@@PerlDef:
        __DEEP{
          if ($self->{<Q::dis:dataType>}) {
            $r = $self->{<Q::dis:dataType>}
                      -><M::dv|DVURIValue.getResource>
                            ($self-><AG::DISAnyResource.database>)
                      -><AG::DISAnyResource.uri>;
          } else {
            $r = <Q::DISCore|String>;
          }
        }__;

  @CMethod:
    @@Name: getSuperResourceURIList
    @@enDesc:
      Returns a snapshot list of super-resources URIs of the resource,
      including canonical and alias URIs of the resource itself.
    @@Return:
      @@@Type: URIList
      @@@enDesc:
        A snapshot list of URIs.
      @@@PerlDef:
        $r = [
               (grep {$self->{subOf}->{$_}} keys %{$self->{subOf}}),
               (grep {$self->{aliasURI}->{$_}} keys %{$self->{aliasURI}}),
             ];

    @@Test:
      @@@QName: DISResource.getSuperResourceURIList.test
      @@@PerlDef:
        my $db;
        __CODE{createDISDBForTest:: $db => $db}__;

        my $res1 = $db->get_resource ('about:test1');
        my $res2 = $db->get_resource ('about:test2');
        $res1->add_super_resource ($res2);

        my %list1 = map {$_ => true} @{$res1->get_super_resource_uri_list};
        $test->id ('res1.itself');
        $test->assert_true ($list1{'about:test1'});
        $test->id ('res1.res2');
        $test->assert_true ($list1{'about:test2'});

        my %list2 = map {$_ => true} @{$res2->get_super_resource_uri_list};
        $test->id ('res2.itself');
        $test->assert_true ($list2{'about:test2'});
        $test->id ('res2.res1');
        $test->assert_false ($list2{'about:test1'});

  @Method:
    @@ForCheck: ManakaiDOM|ForIF
    @@Name: isTypeURI
    @@enImplNote: For compatibility with old code.
##DISResource

ResourceDef:
  @QName: String
  @AliasFor: DISLang|String||ManakaiDOM|all
  @For: DIS|ForEmpty

ResourceDef:
  @QName: RevisionNumber
  @AliasFor: idl|unsignedLong||ManakaiDOM|all
  @For: DIS|ForEmpty
  @enImplNote:
    {ISSUE::
      Should be <Q::idl|unsignedLongLong||ManakaiDOM|all>?
    }

PropDef:
  @QName: DIS|revision
  @DIS:key: r

ElementTypeBinding:
  @Name: Test
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: test|StandaloneTest
    @@ForCheck: ManakaiDOM|ForClass

DataTypeDef:
  @QName: URIList
  @rdfs:subClassOf: DISPerl|ARRAY||ManakaiDOM|all

IFClsDef:
  @IFQName: DISResourceMV
  @ClsQName: ManakaiDISResourceMV
  
  @enDesc:
    The objects implementing the <IF::DISResourceMV> <kwd:MUST>
    also implement the <IF::DISResource> interface.

  @Attr:
    @@Name: mvLocalName
    @@enDesc:
      The local name of the markup vocabulary element defined by this
      resource.
    @@Type:
      DISLang:String::ManakaiDOM:all
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          Either this resource does not define a markup vocabulary element
          or it does define an element but it does not have a local name.
      @@@PerlDef:
        __DEEP{
          if (UNIVERSAL::isa ($self->{<Q::dis|AppName>},
                              <IFName::dv|DVQNameValue>)) {
            $r = $self->{<Q::dis|AppName>}-><AG::dv|DVQNameValue.localName>;
          } elsif (defined $self->{<Q::dis|AppName>}) {
            $r = $self->{<Q::dis|AppName>}-><AG::dv|DVValue.stringValue>;
          } else {
            $r = $self-><AG::DIS|DISAnyResource.localName>;
          }
        }__;

  @Attr:
    @@Name: mvPrefix
    @@enDesc:
      A typical namespace prefix of the markup vocabulary element defined
      by this resource.
    @@Type:
      DISLang:String::ManakaiDOM:all
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          Either this resource does not define a markup vocabulary element
          or it does define an element but it does not have a namespace URI.
      @@@PerlDef:
        __DEEP{
          if (UNIVERSAL::isa ($self->{<Q::dis|AppName>},
                              <IFName::dv|DVQNameValue>)) {
            $r = $self->{<Q::dis|AppName>}-><AG::dv|DVQNameValue.prefix>;
          }
          unless (defined $r) {
            my $nsuri = $self-><AG::DISResourceMV.mvNamespaceURI>;
            if (defined $nsuri and $nsuri =~ /([A-Za-z]\w*)\W*$/) {
              $r = $1;
            } elsif (defined $nsuri) {
              $r = 'ns';
            }
          }
        }__;

  @Attr:
    @@Name: mvNamespaceURI
    @@enDesc:
      The namespace URI of the markup vocabulary element defined by this
      resource.
    @@Type: AnyURI
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          Either this resource does not define a markup vocabulary element
          or it does define an element but it does not have a namespace URI.
      @@@PerlDef:
        __DEEP{
          if (UNIVERSAL::isa ($self->{<Q::dis|AppName>},
                              <IFName::dv|DVQNameValue>)) {
            $r = $self->{<Q::dis|AppName>}-><AG::dv|DVQNameValue.namespaceURI>;
          } elsif (defined $self->{<Q::dis|AppName>}) {
            $r = null;
          } else {
            $r = $self-><AG::DIS|DISAnyResource.namespaceURI>;
          }
        }__;

  @Attr:
    @@Name: mvOwnerElementResource
    @@enDesc:
      An <QUOTE::owner element> resource of the markup vocabulary
      element defined by this resource.
    @@Type: DISResource
    @@clsActualType: ManakaiDISResourceDefinition
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          Either this resource does not define a markup vocabulary element
          or it does define an element but it does not have an owner.
      @@@PerlDef:
        __DEEP{
          if (exists $self->{<H::DIS:mvOwnerElementURI>}) {
            $r = $self-><AG::DISAnyResource.database>
                      -><M::DISDatabase.getResource>
                                ($self->{<H::DIS:mvOwnerElementURI>})
              if defined $self->{<H::DIS:mvOwnerElementURI>};
          } else {
            $r = $self-><AG::DIS|DISResource.parentResource>;
            undef $r if $r and not $r-><M::DIS|DISAnyResource
                                   .isTypeURI> (<Q::s:AnyOwnerElement>);
            $self->{<H::DIS:mvOwnerElementURI>} = $r-><AG::DISAnyResource.uri>
                if $r;
          }
        }__;
##DISResourceMV

PropDef:
  @QName: mvLocalName
  @enDesc:
    <A::ManakaiDISResourceDefinition.mvLocalName>.

PropDef:
  @QName: mvPrefix
  @enDesc:
    <A::ManakaiDISResourceDefinition.mvPrerix>.

PropDef:
  @QName: mvNamespaceURI
  @enDesc:
    <A::ManakaiDISResourceDefinition.mvNamespaceURI>.

PropDef:
  @QName: mvOwnerElementURI
  @enDesc:
    <A::ManakaiDISResourceDefinition.mvOwnerElementResource>
    (<QUOTE::dis> resource URI reference).

PropDef:
  @QName: ownerClass
  @enDesc:
    The class to which this resource belongs.
  @Type: ResourceURI
  @rdfs:range: 
    rdf:Resource
  @rdfs:domain: 
    ManakaiDOM:Class

ResourceDef:
  @QName: MinImpl
  @AliasFor: f|MinimumImplementation||ManakaiDOM|ManakaiDOMLatest

ResourceDef:
  @QName: GetFeature
  @AliasFor: f|GetFeature||ManakaiDOM|ManakaiDOMLatest

ResourceDef:
  @QName: SWCFGNode
  @AliasFor:
    swcfg21:SWCFGNode::swcfg21:ForLatest
  @For: DIS|ForEmpty

ResourceDef:
  @QName: SWCFGElement
  @AliasFor:
    swcfg21:SWCFGElement::swcfg21:ForLatest
  @For: DIS|ForEmpty

ResourceDef:
  @QName: SWCFGDoc
  @AliasFor:
    swcfg21:SWCFGDocument::swcfg21:ForLatest
  @For: DIS|ForEmpty

ResourceDef:
  @QName: DOMImpl
  @AliasFor: c|DOMImplementation||ManakaiDOM|ManakaiDOMLatest

XParamDef:
  @QName: sourceNodePath
  @enDesc:
    A node path string of the source node.

XParamDef:
  @QName: errResource
  @enDesc:
    A resource on which an error has occurred. 

XParamDef:
  @QName: generatedName
  @enDesc:
    A generated name. 

IFClsDef:
  @IFQName: DISResourceProp
  @ClsQName: ManakaiDISPropertyAccessor

  @enDesc:
    Accessor methods for resource or module properties. 

  @Method:
    @@Name: getPropertyValue
    @@enDesc:
      Returns a property value object.
    @@PropNameParam:
    @@Return:
      @@@Type: dv|DVValue
      @@@enDesc: The property value.
      @@@nullCase:
        @@@@enDesc:
          The property has no value.
      @@@PerlDef:
        if ($self->{$propName}) {
          $r = $self->{$propName}->[0];
        } else {
          my $pr = $self-><AG::DISAnyResource.database>
                        -><M::DISDatabase.getResource> ($propName);
          A: for (grep {$pr->{aliasURI}->{$_} or $pr->{supOf}->{$_}}
                  (keys %{$pr->{aliasURI}}, keys %{$pr->{supOf}||{}})) {
            my $v = $self->{$_};
            if ($v) {
              $r = $v->[0];
              last A;
            }
          }
        }

  @Method:
    @@Name: getPropertyValueList
    @@enDesc:
      Returns a property value objects.
    @@PropNameParam:
    @@Return:
      @@@Type: DISPerl|ARRAY||ManakaiDOM|all
      @@@enDesc: The property value.
      @@@PerlDef:
        my $pr = $self-><AG::DISAnyResource.database>
                      -><M::DISDatabase.getResource> ($propName);
        $r = [map {@$_}
              grep {defined $_}
              map {$self->{$_}}
              grep {$pr->{aliasURI}->{$_} or $pr->{supOf}->{$_}}
              (keys %{$pr->{aliasURI}}, keys %{$pr->{supOf}||{}})];

  @Method:
    @@Name: getPropertyBoolean
    @@enDesc:
      Gets boolean property value. 
    @@PropNameParam:
    @@Param:
      @@@Name:default
      @@@Type:
        DOMMain:boolean::ManakaiDOM:all
      @@@enDesc:
        The default value that is returned if no explicit property 
        value specification found for this resource. 
    @@Return:
      @@@Type:
        DOMMain:boolean::ManakaiDOM:all
      @@@enDesc:
        The property value. 
      @@@PerlDef:
        if (ref $self->{$propName}) {
          $r = $self->{$propName}-><AG::dv|DVValue.value> ? true : false;
          $r = $default unless defined $r;
        } else {
          my $pr = $self-><AG::DISAnyResource.database>
                        -><M::DISDatabase.getResource> ($propName);
          C: {
            for (map {$self->{$_}}
                 grep {$pr->{aliasURI}->{$_} or $pr->{supOf}->{$_}}
                 (keys %{$pr->{aliasURI}}, keys %{$pr->{supOf}||{}})) {
              if (defined $_) {
                $r = $_-><AG::dv|DVValue.value> ? true : false;
                last C;
              }
            }
            $r = $default;
          } # C
        }
        
  @Method:
    @@Name: getPropertyText
    @@enDesc:
      Gets property value text. 
    @@PropNameParam:
    @@Param:
      @@@Name:default
      @@@Type:
        swcfg21:SWCFGString::swcfg21:ForLatest
      @@@enDesc:
        The default value that is returned if no explicit property 
        value specification found for this resource. 
      @@@nullCase:
        @@@@enDesc:
          No default value supplied; <DOM::null> is returned if 
          no value specified. 
    @@Return:
      @@@Type:
        swcfg21:SWCFGString::swcfg21:ForLatest
      @@@enDesc:
        The property value string. 
      @@@nullCase:
        @@@@enDesc:
          No value nor default value has specified. 
      @@@PerlDef:
        if (defined $self->{$propName}) {
          $r = $self->{$propName}-><AG::dv|DVValue.stringValue>;
          $r = $default unless defined $r;
        } else {
          my $pr = $self-><AG::DISAnyResource.database>
                        -><M::DISDatabase.getResource> ($propName);
          C: {
            for (map {$self->{$_}}
                 grep {$pr->{aliasURI}->{$_} or $pr->{supOf}->{$_}}
                 (keys %{$pr->{aliasURI}}, keys %{$pr->{supOf}||{}})) {
              if (defined $_) {
                $r = $_-><AG::dv|DVValue.stringValue>;
                last C;
              }
            }
            $r = $default;
          } # C
        }
        
  @Method:
    @@Name: getPropertyTextList
    @@enDesc:
      Returns a list of property value text. 
    @@PropNameParam:
    @@MediaTypeDefaultParam:
    @@Return:
      @@@Type: DISPerl|ARRAY||ManakaiDOM|all
      @@@enDesc:
        A list of the property value strings. 
      @@@PerlDef:
        my $pr = $self-><AG::DISAnyResource.database>
                      -><M::DISDatabase.getResource> ($propName);
        $r = [map {$_-><AG::dv|DVValue.stringValue>}
              map {@$_}
              grep {$_}
              map {$self->{$_}}
              grep {$pr->{aliasURI}->{$_} or $pr->{supOf}->{$_}}
              (keys %{$pr->{aliasURI}}, keys %{$pr->{supOf}||{}})];

  @Method:
    @@Name: getPropertyResource
    @@enDesc:
      Gets property value resource. 
    @@PropNameParam:
    @@NamedParam:
      @@@Name: defaultMediaType
      @@@Type: ResourceURI
      @@@enDesc:
        The URI reference of the default media type which is used 
        when the property value is retrieved from the source tree 
        and the source tree element does not have its <Q::dis:ContentType>
        attribute specified. 
      @@@nullCase:
        @@@@enDesc:
          Defaulted to <Q::DISCore:QName>.
    @@Return:
      @@@Type: DIS|DISAnyResource
      @@@enDesc:
        The property value resource. 
      @@@nullCase:
        @@@@enDesc:
          No value has specified. 
      @@@UndeclaredPrefixException:
      @@@PerlDef:
        __DEEP{
          my $v = $self-><M::DISResourceProp.getPropertyValue>
                             ($propName);
          if (UNIVERSAL::isa ($v, <IFName::dv|DVURIValue>)) {
            $r = $v-><M::dv|DVURIValue.getResource>
                          ($self-><AG::DISAnyResource.database>);
          }
        }__;

  @Method:
    @@Name: getPropertyResourceList
    @@enDesc:
      Gets property value resource list. 
    @@PropNameParam:
    @@NamedParam:
      @@@Name: recursive
      @@@Type:
        DOMMain:boolean::ManakaiDOM:all
      @@@enDesc:
        Whether property resource values of this resource
        should also be included to the returned list or not.
    @@NamedParam:
      @@@Name: recursiveISA
      @@@Type:
        DOMMain:boolean::ManakaiDOM:all
      @@@enDesc:
        Whether the <Q::dis:ISA> ancestors of the resources
        that are property values should also be included in the returned list
        or not.
      @@@TrueCase:
        @@@@enDesc:
          If a property value is a resource <VAR::R> and 
          the resource <VAR::R> does <P::recursiveISAPropName> <VAR::S>, then
          the resource <VAR::S> is also a value in the list.
      @@@FalseCase:
        @@@@enDesc:
          Only the resources directly specified as property values is returned.
    @@NamedParam:
      @@@Name: recursiveISAPropName
      @@@Type: DISString
      @@@enDesc:
        The URI of the property used when the <P::recursiveISA>
        option is enabled.
      @@@nullCase:
        @@@@enDesc:
          The default value, <Q::dis|ISA>, is used.
    @@NamedParam:
      @@@Name: isaRecursive
      @@@Type:
        DOMMain:boolean::ManakaiDOM:all
      @@@enDesc:
        Whether property resource values of <Q::dis:ISA> resources
        of this resource should also be included to the returned list or not.
      @@@TrueCase:
        @@@@enDesc:
          If this resource does <P::isaRecursivePropName> another resource 
          <VAR::S> and the <VAR::S> resource has a <P::propName>
          property value of <VAR::R>, then the resource <VAR::R>
          is also a value in the list.
      @@@FalseCase:
        @@@@enDesc:
          Only the resource directly specified is the returned.
    @@NamedParam:
      @@@Name: isaRecursivePropName
      @@@Type: DISString
      @@@enDesc:
        The URI of the property used when the <P::isaRecursive>
        option is enabled.
      @@@nullCase:
        @@@@enDesc:
          The default value, <Q::dis|ISA>, is used.
    @@Return:
      @@@Type: ResourceList
      @@@enDesc:
        An array reference of the property value resources. 
        \
        {NOTE:: This list is <QUOTE::dead>.
        \
        }
      @@@UndeclaredPrefixException:
      @@@PerlDef:
        $r = [];
        __DEEP{
          my $v = $self-><M::DISResourceProp.getPropertyValueList> ($propName);
          my $db = $self-><AG::DISAnyResource.database>;
          for my $a (@$v) {
            if ($a->isa (<IFName::dv|DVURIValue>)) {
              push @$r, $a-><M::dv|DVURIValue.getResource> ($db);
            }
            if ($isaRecursive) {
              my $b = $a-><M::dv|DVValue.getProperty>
                               (<Q::DISCore:stopISARecursive>);
              if ($b and $b-><AG::dv|DVValue.value>) {
                $isaRecursive = false;
              }
            }
          }
        }__;

        if ($recursive) {
          __DEEP{
            $opt{___recursive_isa_done} ||= {$self-><AG::anyres.uri> => true};
            my @p_res = @$r;
            for my $p_res (@p_res) {
              my $p_res_uri = $p_res-><AG::anyres.uri>;
              next if $opt{___recursive_isa_done}->{$p_res_uri};
              $opt{___recursive_isa_done}->{$p_res_uri} = true;
              push @$r, @{$p_res-><M::DISResourceProp.getPropertyResourceList>
                                          ($propName, recursive => true,
                                           recursive_isa => $recursiveISA,
                         ___recursive_isa_done => $opt{___recursive_isa_done})};
            }
          }__;
        }
        if ($recursiveISA) {
          __DEEP{
            $recursiveISAPropName = <Q::dis|ISA>
                unless defined $recursiveISAPropName;
            $opt{___recursive_isa_done} ||= {$self-><AG::anyres.uri> => true};
            my @p_res = @$r;
            for my $p_res (@p_res) {
              my $p_res_uri = $p_res-><AG::anyres.uri>;
              next if $opt{___recursive_isa_done}->{$p_res_uri};
              $opt{___recursive_isa_done}->{$p_res_uri} = true;
              push @$r, @{$p_res-><M::DISResourceProp.getPropertyResourceList>
                                          ($recursiveISAPropName, 
                                           recursive => true,
                         ___recursive_isa_done => $opt{___recursive_isa_done})};
            }
          }__;
        }
        if ($isaRecursive) {
          __DEEP{
            $isaRecursivePropName = <Q::dis|ISA>
                unless defined $isaRecursivePropName;
            my $self_uri = $self-><AG::anyres.uri>;
            $opt{___recursive_isa_done} ||= {$self_uri => true};
            $opt{___isa_recursive_done} ||= {$self_uri => true};
            my @p_res = @{$self-><M::DISResourceProp.getPropertyResourceList>
                                      ($isaRecursivePropName, recursive_isa => false,
                                       recursive => false,
                                       default_media_type => <Q::dis:TFQNames>)};
            for my $p_res (@p_res) {
              my $p_res_uri = $p_res-><AG::anyres.uri>;
              next if $opt{___isa_recursive_done}->{$p_res_uri};
              $opt{___isa_recursive_done}->{$p_res_uri} = true;
              push @$r, @{$p_res-><M::DISResourceProp.getPropertyResourceList>
                                          ($propName, recursive_isa => false,
                                           recursive => false,
                                       isa_recursive => true,
                                       ___isa_recursive_done =>
                                                     $opt{___isa_recursive_done})};
            }
          }__;
        }

  @Method:
    @@Name: addPropertyResourceList
    @@enDesc:
      Adds a resource to a resource-list property value. 
      \
      {ISSUE:: Should an exception be thrown if the property is 
               not of list?
      \
      }
      \
      {NOTE:: If the property is not <QUOTE::get>ten ever, adding 
              an item clears the list --- i.e. the property values 
              in the source tree will be ignored.  Call
              <M::ManakaiDISPropertyAccessor.getPropertyResourceList>
              before adding to avoid this behavior. 
      \
      }
    @@PropNameParam:
    @@Param:
      @@@Name: res
      @@@Type: DISResource
      @@@clsActualType: ManakaiDISResourceDefinition
      @@@enDesc:
        A resource to add. 
    @@Return:
      @@@PerlDef:
        if ($self->{$propName}) {
          my $uriv;
          __CODE{dv|createURI::
            $uri => {$res-><AG::DISAnyResource.uri>},
            $result => $uriv,
            $name => $propName,
          }__;
          $self->{$propName}-><M::dv|DVList.addItem> ($uriv);
        } else {
          __CODE{dv|createOrderedList::
            $result => {$self->{$propName}},
            $type => {<Q::DISCore:URI>},
            $base_type => {<Q::DISCore:URI>},
          }__;
          my $uriv;
          __CODE{dv|createURI::
            $uri => {$res-><AG::DISAnyResource.uri>},
            $result => $uriv,
            $name => $propName,
          }__;
          $self->{$propName}-><M::dv|DVList.addItem> ($uriv);
        }

  @Method:
    @@Name: addPropertyResourceUList
    @@plMName: add_property_resource_ulist
    @@enDesc:
      Adds a resource to a resource-list property value. 
      \
      {ISSUE:: Should an exception be thrown if the property is 
               not of list?
      \
      }
      \
      {NOTE:: If the property is not <QUOTE::get>ten ever, adding 
              an item clears the list --- i.e. the property values 
              in the source tree will be ignored.  Call
              <M::ManakaiDISPropertyAccessor.getPropertyResourceList>
              before adding to avoid this behavior. 
      \
      }
    @@PropNameParam:
    @@Param:
      @@@Name: res
      @@@Type: DISResource
      @@@clsActualType: ManakaiDISResourceDefinition
      @@@enDesc:
        A resource to add. 
    @@Return:
      @@@PerlDef:
        if ($self->{$propName}) {
          my $uriv;
          __CODE{dv|createURI::
            $uri => {$res-><AG::DISAnyResource.uri>},
            $result => $uriv,
            $name => $propName,
          }__;
          $self->{$propName}-><M::dv|DVList.addItem> ($uriv);
        } else {
          __CODE{dv|createUnorderedList::
            $result => {$self->{$propName}},
            $type => {<Q::DISCore:URI>},
            $base_type => {<Q::DISCore:URI>},
          }__;
          my $uriv;
          __CODE{dv|createURI::
            $uri => {$res-><AG::DISAnyResource.uri>},
            $result => $uriv,
            $name => $propName,
          }__;
          $self->{$propName}-><M::dv|DVList.addItem> ($uriv);
        }

  @Method:
    @@Name: addPropertyURIUList
    @@plMName: add_peoperty_uri_ulist
    @@enDesc:
      Adds a resource to a resource-list property value. 
      \
      {ISSUE:: Should an exception be thrown if the property is 
               not of list?
      \
      }
      \
      {NOTE:: If the property is not <QUOTE::get>ten ever, adding 
              an item clears the list --- i.e. the property values 
              in the source tree will be ignored.  Call
              <M::ManakaiDISPropertyAccessor.getPropertyResourceList>
              before adding to avoid this behavior. 
      \
      }
    @@PropNameParam:
    @@Param:
      @@@Name: uri
      @@@Type: AnyURI
      @@@enDesc:
        A resource to add. 
    @@Return:
      @@@PerlDef:
        __DEEP{
          if ($self->{$propName}) {
            my $uriv;
            __CODE{dv|createURI::
              $uri => $uri,
              $result => $uriv,
              $name => $propName,
            }__;
            $self->{$propName}-><M::dv|DVList.addItem> ($uriv);
          } else {
            __CODE{dv|createUnorderedList::
              $result => {$self->{$propName}},
              $type => {<Q::DISCore|URI>},
              $base_type => {<Q::DISCore:URI>},
            }__;
            my $uriv;
            __CODE{dv|createURI::
              $uri => $uri,
              $result => $uriv,
              $name => $propName,
            }__;
            $self->{$propName}-><M::dv|DVList.addItem> ($uriv);
          }
        }__;
##DISResourceProp


ElementTypeBinding:
  @Name: TMethods
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType:
      @@@@: dis|MultipleResource
      @@@ForCheck: !ManakaiDOM|ForClass
    @@resourceFor: ManakaiDOM|ForClass
    @@DISCore:resourceType: DISCore|Resource
    @@For: DIS|ForLatest

ElementTypeBinding:
  @Name: TMethod
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass
    @@DISCore:resourceType: DIS|Method

ElementTypeBinding:
  @Name: TAttr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass
    @@DISCore:resourceType: DIS|Attribute


TMethods:
  @TMethod:
    @@Name: getErrorInterfaceResource
    @@DIS:targetType: dx|Interface
    @@Return:
      @@@Type: DISAnyResource
      @@@PerlDef:
        __DEEP{
          $r = $self;
        }__;
##dx:Interface

TMethods:
  @TMethod:
    @@Name: getErrorInterfaceResource
    @@DIS:targetType: DISLang|ConstGroup
    @@Return:
      @@@Type: DISAnyResource
      @@@PerlDef:
        __DEEP{
          my $parent = $self-><AG::DISResource.parentResource>;
          if ($parent and
              $parent-><M::DISAnyResource.isTypeURI> (<Q::Err|ErrorAny>)) {
            $r = $parent;
          }
        }__;
##DISLang:ConstGroup

TMethods:
  @TMethod:
    @@Name: getDOMConfigurationParameterName
    @@DIS:targetType: DOMCore|DOMConfigurationParameter
    @@Return:
      @@@Type: DISString
      @@@PerlDef:
        __DEEP{
          $r = $self-><M::DIS|DISResourceProp.getPropertyText>
                        (<Q::DOMCore:domConfigurationParameterName>);
          unless (defined $r) {
            $r = $self-><AG::DISAnyResource.nameURI>;
          }
          $r = lc $r if defined $r;
        }__;
##DOMCore|DOMConfigurationParameter

TMethods:
  @TMethod:
    @@Name: getDOMConfigurationParameterName
    @@DIS:targetType: DOMCore|DOMConfigurationParameterApplication
    @@Return:
      @@@Type: DISString
      @@@PerlDef:
        __DEEP{
          my $cp = $self-><M::DISResourceProp.getPropertyResource>
                            (<Q::DOMCore:domConfigurationParameter>);
          if (defined $cp) {
            $r = $cp-><M::DIS|DISResourceProp.getPropertyText>
                        (<Q::DOMCore:domConfigurationParameterName>);
            unless (defined $r) {
              $r = $cp-><AG::DISAnyResource.nameURI>;
            }
            $r = lc $r if defined $r;
          } else {
            $r = null; # error
          }
        }__;
##DOMCore|DOMConfigurationParameterApplication

TMethods:
  @TMethod:
    @@Name: getErrorInterfaceResource
    @@DIS:targetType: dx|ErrorCode
    @@Return:
      @@@Type: DISAnyResource
      @@@PerlDef:
        __DEEP{
          my $parent = $self-><AG::DISResource.parentResource>;
          if ($parent) {
            $r = $parent-><M::DISAnyResource.getErrorInterfaceResource>;
          }
        }__;
##dx:ErrorCode

TMethods:
  @TMethod:
    @@Name: getErrorInterfaceResource
    @@DIS:targetType: dx|ErrorSubCode
    @@Return:
      @@@Type: DISAnyResource
      @@@PerlDef:
        __DEEP{
          my $parent = $self-><M::DISAnyResource.getErrorCodeResource>;
          if ($parent) {
            $r = $parent-><M::DISAnyResource.getErrorInterfaceResource>;
          }
        }__;

  @TMethod:
    @@Name: getErrorCodeResource
    @@DIS:targetType: dx|ErrorSubCode
    @@Return:
      @@@Type: DISAnyResource
      @@@PerlDef:
        __DEEP{
          my $parent = $self-><AG::DISResource.parentResource>;
          if ($parent and $parent-><M::DISAnyResource.isTypeURI>
                                     (<Q::dx|ErrorCode>)) {
            $r = $parent;
          }
        }__;
##dx:ErrorSubCode

TMethods:
  @TMethod:
    @@Name: parseString
    @@DIS:targetType: lang|dcmodel
    @@Param:
      @@@Name: s
      @@@Type: DISString
    @@Param:
      @@@Name: ns
      @@@Type: NSResolverDIS
    @@Param:
      @@@Name: factory
      @@@Type: Document
    @@ForParam:
    @@Return:
      @@@Type: Node
      @@@PerlDef:
        __DEEP{
          $s =~ s/^\s+//;
          if ($s =~ s/^([^\s(][^\s+*?]*)\s*//) {
            $r = $factory-><M::Document.createElementNS>
                             (<Q::lang|dcmodel:>, 'terminal');
            my $uri = $ns-><M::NSResolverDIS.tfqnamesToURI>
                             ($1, null, $forArg);
            $r-><AS::Node.textContent> ($uri);
            if ($s =~ s/^([+*?])\s*//) {
              $r-><M::Element.setAttributeNS> (null, 'occurence', $1);
            }
          } else {
            $s =~ s/^\(\s*//;
            $r = $factory-><M::Document.createElementNS>
                             (<Q::lang|dcmodel:>, 'group');
            my $current = $r;
            my $last;
            while (length $s) {
              if ($s =~ s/^([^\s()+*?|,&][^\s)+*?,&]*|[+*?|,&][^\s)+*?,&]+)\s*//) {
                my $el = $factory-><M::Document.createElementNS>
                                     (<Q::lang|dcmodel:>, 'terminal');
                my $uri = $ns-><M::NSResolverDIS.tfqnamesToURI>
                                   ($1, null, $forArg, node => $ns);
                $el-><AS::Node.textContent> ($uri);
                $current-><M::Node.appendChild> ($el);
                $last = $el;
              } elsif ($s =~ s/^([+*?])\s*//) {
                if (defined $last) {
                  $last-><M::Element.setAttributeNS> (null, 'occurence', $1);
                  $last = null;
                }
              } elsif ($s =~ s/^([|,&])\s*//) {
                $current-><M::Element.setAttributeNS> (null, 'connector', $1);
                $last = null;
              } elsif ($s =~ s/^\(\s*//) {
                my $el = $factory-><M::Document.createElementNS>
                                     (<Q::lang|dcmodel:>, 'group');
                $current = $current-><M::Node.appendChild> ($el);
                $last = null;
              } elsif ($s =~ s/^\)\s*//) {
                $last = $current;
                $current = $current-><AG::Node.parentNode>;
                $current = $last unless defined $current; # error
              } else {
                last; # error
              }
            }
          }
        }__;
##lang:dcmodel

ElementTypeBinding:
  @Name: PropNameParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:MethodParameter
    @@Name: propName
    @@Type: ResourceURI
    @@Description:
      @@@lang:en
      @@@@:
        The name of the property. 

PropDef:
  @QName:isAnon
  @Description:
    @@lang:en
    @@@:
      Whether the subject resource is anonymous or not. 
  @Type:
    DOMMain:boolean::ManakaiDOM:all

PropDef:
  @QName:isDefined
  @Description:
    @@lang:en
    @@@:
      Whether the subject resource is defined or not. 

PropDef:
  @QName:isReferred
  @Description:
    @@lang:en
    @@@:
      Whether the subject resource is referred or not. 
  @Type:
    DOMMain:any

PropDef:
  @QName:definingModule
  @Description:
    @@lang:en
    @@@:
      The <QUOTE::dis> module in which the subject resource is defined. 
      \
      {NOTE:: The local name should have been <QUOTE::ownerModule> or some.
      \
      }
  @rdfs:domain:
    DISCore:Module

## -- Datatypes

URITypeDef:
  @QName: AnyURI
  @Description:
    @@lang:en
    @@@:
      Any URI references. 

URITypeDef:
  @QName: FileURI
  @enDesc:
    URI references identifying file. 

URITypeDef:
  @QName: ForURI
  @Description:
    @@lang:en
    @@@:
      <QUOTE::For> URI references. 

DataTypeDef:
  @QName: ForURIList
  @Description:
    @@lang:en
    @@@:
      References to the array containing <QUOTE::for> URI references. 

URITypeDef:
  @QName: ResourceURI
  @Description:
    @@lang:en
    @@@:
      A URI reference for a <QUOTE::dis> resource. 

URITypeDef:
  @QName: MediaTypeURI
  @Description:
    @@lang:en
    @@@:
      Media type URI references. 
  @rdfs:subClassOf: ResourceURI

URITypeDef:
  @QName: ModuleURI
  @enDesc:
    URI references for <QUOTE::dis> modules. 
  @rdfs:subClassOf: ResourceURI

URITypeDef:
  @QName: NameURI
  @enDesc:
    URI references identifying a resource. 
  @rdfs:subClassOf: ResourceURI

DataTypeDef:
  @QName: ResourceList
  @enDesc:
    References to array containing resource definition objects.
  @rdfs:subClassOf:
    DISPerl:ARRAY::ManakaiDOM:all

ElementTypeBinding:
  @Name: DataTypeDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:DataType

ElementTypeBinding:
  @Name: URITypeDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:DataType
    @@rdfs:subClassOf: AnyURI

## -- Exceptions

XParamDef:
  @QName: anotherSourceNode
  @enDesc:
    Another source node in which an error has occurred.  In cases 
    of <QUOTE::already defined> errors, it is the node that 
    defines the resource first. 
  @Type: ManakaiDISNode

ResourceDef:
  @QName: UNDECLARED_NS_PREFIX_ERR
  @For: ForEmpty
  @AliasFor: 
    DIS:UNDECLARED_NS_PREFIX_ERR::swcfg21:ForLatest

ResourceDef:
  @QName: anyres
  @AliasFor: DISAnyResource
  @For: DIS|ForLatest

ResourceDef:
  @rdf:type:
    @@@: dis|MultipleResource
    @@ForCheck: !ManakaiDOM|ForIF !ManakaiDOM|ForClass
  @resourceFor: ManakaiDOM|ForIF
  @resourceFor:
    @@@: ManakaiDOM|ForClass
    @@ForCheck: ForEmpty !=ForEmpty
  @For: ForLatest
  @For: =ForEmpty

  @rdf:type:
    @@@: dx|Interface
    @@ForCheck: ManakaiDOM|ForIF

  @rdf:type:
    @@@: dx|Class
    @@ForCheck: ManakaiDOM|ForClass

  @Implement:
    @@@: ||ForEmpty||ManakaiDOM|ForIF
    @@ContentType: DISCore|TFPQNames
    @@ForCheck: ManakaiDOM|ForClass ForEmpty
  @Implement:
    @@@: ||ForLatest||ManakaiDOM|ForIF
    @@ContentType: DISCore|TFPQNames
    @@ForCheck: ManakaiDOM|ForClass ForLatest
  @dx:implementedBy: ||DIS|ForLatest||ManakaiDOM|ForClass

  @f:implements:
    @@@: CoreFeature10
    @@For: ForLatest

  @ISA:
    @@@: dx|Exception||ManakaiDOM|Perl
    @@ForCheck: ManakaiDOM|ForClass

  @IFQName: DISException
  @ClsQName: ManakaiDISException

  @Description:
    @@lang:en
    @@@:
      Exceptions for the <QUOTE::dis> operations. 

  @ResourceDef:
    @@rdf:type: DISLang|ConstGroup
    @@ForCheck: ManakaiDOM|ForIF !=DIS|ForEmpty

    @@IFQName: DISExceptionCode

    @@rdfs:subClassOf: idl|unsignedShort||ManakaiDOM|all
    @@Type: idl|unsignedShort||ManakaiDOM|all

    @@enDesc:
      Exception codes for <Class::DISException>. 

    @@XConstDef:
      @@@Name: HIERARCHY_REQUEST_ERR
      @@@Value:
        @@@@@:3
        @@@@ContentType: DISCore|Integer
      @@@enDesc:
        An attempt is made to break the hierarchy. 
      @@@XSubTypeDef:
        @@@@QName: MERGE_ITSELF_ERR
        @@@@enDesc:
          An attempt is made to merge the resource to itself. 
        @@@@XSourceNodeParam:
        @@@@XParam:
          @@@@@QName:uri
          @@@@@enDesc:
            The URI reference of the resource to merge. 
        @@@@enMufDef:
          An attempt is made to merge the resource <%p (name => {<Q::DIS:uri>}
          );> to itself
    @@XConstDef:
      @@@Name: NOT_SUPPORTED_ERR
      @@@Value:
        @@@@@:9
        @@@@ContentType: DISCore|Integer
      @@@enDesc:
        An attempt is made to do something the implementation does not support. 
      @@@XSubTypeDef:
        @@@@QName: UNSUPPORTED_MEDIA_TYPE_ERR
        @@@@enDesc:
          The implementation does not support the media type. 
        @@@@XParam:
          @@@@@QName: uri
          @@@@@enDesc:
            The URI reference of the media type that is not supported. 
        @@@@XSourceNodeParam:
        @@@@XParam:
          @@@@@QName:elementType
          @@@@@enDesc:
            The URI reference of the element type of the element
            in which the media type is referenced.
        @@@@enMufDef:
          %p (name => {<Q::DIS:sourceCode>}, prefix => {"}, suffix => {": }
          );%p (name => {<Q::DIS:elementType>}, prefix => { (Element type: <},
          suffix => {>) }
          );Media type <%p (name => {<Q::DIS:uri>});> is not supported
      @@@XSubTypeDef:
        @@@@QName: UNSUPPORTED_ELEMENT_TYPE_ERR
        @@@@enDesc:
          An unsupported type of element is encounted.
        @@@@XSourceNodeParam:
        @@@@XParam:
          @@@@@QName:elementType
          @@@@@enDesc:
            The element type URI reference of the element.
        @@@@enMufDef:
          Element type "%p (name => {<Q::DIS:elementType>});" is not supported
    @@XConstDef:
      @@@Name: INVALID_STATE_ERR
      @@@Value:
        @@@@@:11
        @@@@ContentType: DISCore|Integer
      @@@enDesc:
        An attempt is made to use an object that is not (or no longer) usable. 
      @@@XSubTypeDef:
        @@@@QName: NO_ASSOCIATED_DB_ERR
        @@@@enDesc:
          No <QUOTE::dis> database has been associated with this document. 
    @@XConstDef:
      @@@Name: INVALID_SOURCE_ERR
      @@@Value:
        @@@@@: 501
        @@@@ContentType: DISCore|Integer
      @@@enDesc:
        The source input is well-formed but invalid. 
      @@@XSubTypeDef:
        @@@@QName: NO_MODULE_QNAME_ERR
        @@@@enDesc:
          The <Q::dis:Module> element must have its <Q::dis:QName> 
          attribute. 
        @@@@XSourceNodeParam:
      @@@XSubTypeDef:
        @@@@QName: NO_LOCAL_NAME_ERR
        @@@@enDesc:
          The resource does not have a local name. 
        @@@@XSourceNodeParam:
      @@@XSubTypeDef:
        @@@@QName: UNABLE_TO_GET_MODULE_ERR
        @@@@enDesc:
          The implementation is unable to get the module source. 
        @@@@enMufDef:
            Unable to get the module source of <%p (name => {<Q::DIS:uri>});>
        @@@@XParam:
          @@@@@QName: uri
          @@@@@enDesc:
            The URI reference of the module. 
        @@@@XParam:
          @@@@@QName: namespaceURI
          @@@@@enDesc:
            The namespace URI of the module name. 
        @@@@XParam:
          @@@@@QName: localName
          @@@@@enDesc:
            The local name of the module name. 
        @@@@XParam:
          @@@@@QName: for
          @@@@@enDesc:
            The <QUOTE::for> of the module.
      @@@XSubTypeDef:
        @@@@QName: NO_FOR_QNAME_ERR
        @@@@enDesc:
          A <Q::dis:ForDef> element must have <Q::dis:QName> attribute. 
        @@@@XSourceNodeParam:
      @@@XSubTypeDef:
        @@@@QName: FOR_ALREADY_DEFINED_ERR
        @@@@enDesc:
          The <QUOTE::for> named as the same URI reference has 
          already defined. 
        @@@@XSourceNodeParam:
        @@@@XParam:
          @@@@@QName: anotherSourceNode
          @@@@@enDesc:
            The node that defines the <QUOTE::for> URI reference before. 
        @@@@XParam:
          @@@@@Name: uri
          @@@@@enDesc:
            The URI reference of the <QUOTE::for> attempted to define. 
        @@@@enMufDef:
          <QUOTE::For> <%p (name => {<Q::DIS:uri>});> is already defined
      @@@XSubTypeDef:
        @@@@QName: RESOURCE_ALREADY_DEFINED_ERR
        @@@@enDesc:
          The <QUOTE::dis> resource named as the same URI reference has 
          already defined. 
        @@@@XSourceNodeParam:
        @@@@XParam:
          @@@@@@: anotherSourceNode
          @@@@@enDesc:
            The node that defines the <QUOTE::for> URI reference before. 
        @@@@XParam:
          @@@@@@: uri
          @@@@@enDesc:
            The URI reference of the resource attempted to define. 
        @@@@XParam:
          @@@@@@: moduleURI
          @@@@@enDesc:
            A URI of the module in which the <Q::DIS|uri> resource is
            defined.
        @@@@enMufDef:
          %p (name => {<Q::DIS:moduleURI>}, prefix => {Module <},
          suffix => {>: })
          ;Resource <%p (name => {<Q::DIS:uri>});> is already defined
      @@@XSubTypeDef:
        @@@@QName: ELEMENT_NOT_ALLOWED_ERR
        @@@@enDesc:
          An element has occured where it is not allowed. 
        @@@@enMufDef:
          Module <%p (name => {<Q::DIS:uri>});>: 
          Element of type <%p (name => {<Q::DIS:elementType>});> 
          is not allowed here
        @@@@XSourceNodeParam:
        @@@@XParam:
          @@@@@QName: elementType
          @@@@@enDesc:
            The expanded element type name of the element. 
        @@@@XParam:
          @@@@@QName: uri
          @@@@@enDesc:
            The URI reference of the module. 
      @@@XSubTypeDef:
        @@@@QName: NO_REQUIRED_ATTR_ERR
        @@@@enDesc:
          A required attribute is not specified.
        @@@@XSourceNodeParam:
        @@@@XParam:
          @@@@@QName: elementType
          @@@@@enDesc:
            The expanded URI reference of the attribute name. 
        @@@@enMufDef:
          Attribute <%p (name => {<Q::DIS:elementType>});> must be specified
      @@@XSubTypeDef:
        @@@@QName: FOR_NOT_DEFINED_ERR
        @@@@enDesc:
          A <QUOTE::for> is referred but not defined. 
        @@@@XSourceNodeParam:
        @@@@XParam:
          @@@@@QName: uri
          @@@@@enDesc:
            The URI reference of the <QUOTE::for> that is not defined.
        @@@@enMufDef:
          <QUOTE::For> <%p (name => {<Q::DIS:uri>});> is not defined
      @@@XSubTypeDef:
        @@@@QName: RESOURCE_NOT_DEFINED_ERR
        @@@@enDesc:
          A <QUOTE::dis> resource is referred but not defined 
          or the resource referred does not have the type expected. 
        @@@@XSourceNodeParam:
        @@@@XParam:
          @@@@@@: sourceNodePath
          @@@@@enDesc:
            A node path string of the source node.
        @@@@XParam:
          @@@@@QName: uri
          @@@@@enDesc:
            The URI reference of the resource that is not defined.
        @@@@XParam:
          @@@@@QName: elementType
          @@@@@enDesc:
            <QUOTE::dis> element type (either tree element type
            or preprocessing element type) of the element
            in which a reference to the undefined resource is contained.
        @@@@XParam:
          @@@@@QName:parentURI
          @@@@@enDesc:
            The URI reference of the resource from whose child resources
            a resource is tried to find.
        @@@@XParam:
          @@@@@QName: moduleURI
          @@@@@enDesc:
            The URI of the module in which the resourece should be included.
        @@@@XParam:
          @@@@@QName: localName
          @@@@@enDesc:
            The local name of the undefined resource.
        @@@@XParam:
          @@@@QName: sourceCode
          @@@@enDesc:
            Source code fragment that referres this resource.
        @@@@XParam:
          @@@@@QName:expectedType
          @@@@@enDesc:
            Expected resource type.
        @@@@enMufDef:
           %p (name => {<Q::DIS:moduleURI>}, prefix => {Module <},
               suffix => {>: })
          ;%p (name => {<Q::DIS:sourceNodePath>}, suffix => {: })
          ;%p (name => {<Q::DIS:sourceCode>}, prefix => {"}, suffix => {": })
          ;%p (name => {<Q::DIS:parentURI>}, prefix => {(In <}, suffix => {>) })
          ;Resource%p (name => {<Q::DIS:uri>}, prefix => { <},
          suffix => {>});%p (name => {<Q::DIS:localName>},
          prefix => { "}, suffix => {"}); is not defined or wrong type%p
          (name => {<Q::DIS:expectedType>}, prefix => { (<},
           suffix => {> is expected)});
      @@@XSubTypeDef:
        @@@@QName: NO_SOURCE_NODE_ERR
        @@@@enDesc:
          A resource does not have associated node in the source tree.
        @@@@XSourceNodeParam:
        @@@@XParam:
          @@@@@QName:uri
          @@@@@enDesc:
            The URI reference of the resource.
      @@@XSubTypeDef:
        @@@@QName: RESERVED_PERL_METHOD_NAME_ERR
        @@@@enDesc:
          A reserved Perl method name is used. 
        @@@@XParam:
          @@@@@QName:uri
          @@@@@enDesc:
            The URI reference of the method resource. 
        @@@@XSourceNodeParam:
        @@@@XParam:
          @@@@@QName: generatedName
          @@@@@enDesc:
            A reserved method name. 
      @@@XSubTypeDef:
        @@@@QName: NO_DIS_TYPE_ERR
        @@@@enDesc:
          <Q::dis:Type> attribute is not found. 
        @@@@XSourceNodeParam:
        @@@@enMufDef:
          Resource "%t (name => {<Q::DIS:uri>});" has no "dis:Type" attribute
      @@@XSubTypeDef:
        @@@@QName: NO_METHOD_RETURN_ERR
        @@@@enDesc:
          A <Q::DISLang:Method> resource does not have any
          <Q::DISLang:MethodReturn> child. 
        @@@@XSourceNodeParam:
        @@@@XParam:
          @@@@@QName:errResource
          @@@@@enDesc: The method resource.
        @@@@XParam:
          @@@@@QName:uri
          @@@@@enDesc:
            The URI reference of the method.
        @@@@XParam:
          @@@@@QName:localName
          @@@@@enDesc:
            The local name of the resource.
        @@@@enMufDef:
          Method "%p (name => {<Q::DIS:localName>});" does not have
          "Return" child
      @@@XSubTypeDef:
        @@@@QName: NO_ATTR_GET_ERR
        @@@@enDesc:
          A <Q::DISLang:Attribute> resource does not have any
          <Q::DISLang:AttributeGet> child. 
        @@@@XSourceNodeParam:
      @@@XSubTypeDef:
        @@@@QName:INTERFACE_CLASS_METHOD_ERR
        @@@@enDesc:
          An attempt is made to call a static (class) method
          from an interface.
        @@@@XSourceNodeParam:
        @@@@XParam:
          @@@@@QName:uri
          @@@@@enDesc:
            The URI reference of the interface.
        @@@@XParam:
          @@@@@QName:sourceCode
          @@@@@enDesc:
            Source code fragment that calls a class method.
        @@@@XParam:
          @@@@@QName:elementType
          @@@@@enDesc:
            The element type URI reference of the element
            that calls a method.
      @@@XSubTypeDef:
        @@@@QName: BROKEN_PARAM_SPEC_ERR
        @@@@enDesc:
          A parameter specification is broken.
        @@@@XParam:
          @@@@@QName: sourceCode
          @@@@@enDesc:
            Source code fragment that contains the broken parameter
            specification.
        @@@@XSourceNodeParam:
        @@@@enMufDef:
          %p (name => {<Q::DIS:sourceCode>}, prefix => {"},
          suffix => {": });Broken parameter specification
      @@@XSubTypeDef:
        @@@@QName:PERL_PREPROCESS_NO_ELEMENT_TYPE_ERR
        @@@@enDesc:
          A preprocessing instruction does not have its element 
          type.
        @@@@XSourceNodeParam:
        @@@@XParam:
          @@@@@QName:sourceCode
          @@@@@enDesc:
            Source code fragment.
        @@@@enMufDef:
          %p (name => {<Q::DIS:sourceCode>}, prefix => {"}, 
              suffix => {": });Element type name is not specified
      @@@XSubTypeDef:
        @@@@QName: NO_PERL_PACKAGE_NAME_ERR
        @@@@enDesc:
          No Perl package name is defined for the resource referred.
        @@@@XSourceNodeParam:
        @@@@XParam:
          @@@@@QName:sourceCode
          @@@@@enDesc:
            Source code fragment.
        @@@@XParam:
          @@@@@QName:uri
          @@@@@enDesc:
            THe URI reference of the resource referred.
        @@@@XParam:
          @@@@@QName:elementType
          @@@@@enDesc:
            The element type of Perl preprocessing instruction 
            in which the resource is referred.
        @@@@enMufDef:
          %p (name => {<Q::DIS:uri>}, prefix => {<}, suffix => {>: });Perl 
          package name is not defined
      @@@XSubTypeDef:
        @@@@QName: PERL_PREPROCESS_NO_EXCEPTION_TYPE_ERR
        @@@@enDesc:
          An exception type specification is required.
        @@@@XSourceNodeParam:
        @@@@XSourceCodeParam:
        @@@@XParam:
          @@@@@QName:elementType
          @@@@@enDesc:
            The element type of the preprocessing instruction.
      @@@XSubTypeDef:
        @@@@QName: PERL_PREPROCESS_NO_CODE_NAME_ERR
        @@@@enDesc:
          A code name specification is required.
        @@@@XSourceNodeParam:
        @@@@XSourceCodeParam:
        @@@@XParam:
          @@@@@QName:elementType
          @@@@@enDesc:
            The element type of the preprocessing instruction.
      @@@XSubTypeDef:
        @@@@QName: PERL_CODE_NOT_DEFINED_ERR
        @@@@enDesc:
          The specified resource does not have its Perl definition.
        @@@@XSourceNodeParam:
        @@@@XSourceCodeParam:
        @@@@XParam:
          @@@@@QName:elementType
          @@@@@enDesc:
            The element type of the preprocessing instruction.
        @@@@XParam:
          @@@@@QName:uri
          @@@@@enDesc:
            The URI reference of the resource referred.
        @@@@XParam:
          @@@@@QName:localName
          @@@@@enDesc:
            The local name of the resource referred.
        @@@@enMufDef:
          Resource%p (name => {<Q::DIS:uri>}, prefix => { "}, suffix => {"});
          has no Perl code definition
      @@@XSubTypeDef:
        @@@@QName: PERL_PREPROCESS_NO_METHOD_ERR
        @@@@enDesc:
          A preprocessing instruction which is only allowed in 
          method definitions is used in a code which is not a method.
        @@@@XSourceNodeParam:
        @@@@XSourceCodeParam:
        @@@@XParam:
          @@@@@QName:elementType
          @@@@@enDesc:
            The element type of the preprocessing instruction.
      @@@XSubTypeDef:
        @@@@QName: PERL_PREPROCESS_NO_FOR_ERR
        @@@@enDesc:
          A <QUOTE::for> specification is required.
        @@@@XSourceNodeParam:
        @@@@XSourceCodeParam:
        @@@@XParam:
          @@@@@QName:elementType
          @@@@@enDesc:
            The element type of the preprocessing instruction.
      @@@XSubTypeDef:
        @@@@QName: PERL_PREPROCESS_NO_ASSERT_TYPE_ERR
        @@@@enDesc:
          An assertion type specification is required.
        @@@@XSourceNodeParam:
        @@@@XSourceCodeParam:
        @@@@XParam:
          @@@@@QName:elementType
          @@@@@enDesc:
            The element type of the preprocessing instruction.
      @@@XSubTypeDef:
        @@@@QName: PERL_PREPROCESS_BLOCK_NOT_ALLOWED_ERR
        @@@@enDesc:
          A preprocessing instruction block occurred with 
          element type which does not allow it.
        @@@@XSourceNodeParam:
        @@@@XSourceCodeParam:
        @@@@XParam:
          @@@@@QName:elementType
          @@@@@enDesc:
            The element type of the preprocessing instruction.
      @@@XSubTypeDef:
        @@@@QName: NON_NAMED_PARAMETER_AFTER_NAMED_ERR
        @@@@enDesc:
          A non-named method parameter following
          any named method parameter is occurred.
        @@@@XSourceNodeParam:
        @@@@XParam:
          @@@@@QName:uri
          @@@@@enDesc:
            The URI reference of the non-named method parameter resource.
        @@@@XParam:
          @@@@@QName:localName
          @@@@@enDesc:
            The local name of the non-named method parameter.
      @@@XSubTypeDef:
        @@@@QName:DISPERL_NO_VALUE_ALLOWED_ERR
        @@@@enDesc:
          An element node have a value but the definition
          of that element type does not allow it.
        @@@@XSourceNodeParam:
        @@@@XParam:
          @@@@@QName:elementType
          @@@@@enDesc:
            The element type URI reference of the element.
      @@@XSubTypeDef:
        @@@@QName:NO_CONST_VALUE_ERR
        @@@@enDesc:
          The source element node for a constant value resource 
          does not have <Q::dis:Value> attribute.
        @@@@XSourceNodeParam:
        @@@@XParam:
          @@@@@QName:elemntType
          @@@@@enDesc:
            The element type URI reference of the element from which
            a constant value resource is referred.
        @@@@XParam:
          @@@@@QName:uri
          @@@@@enDesc:
            The resource URI reference of the constant value resource.
        @@@@XParam:
          @@@@@QName:localName
          @@@@@enDesc:
            The local name of the constant value resource.
     @@@XSubTypeDef:
       @@@@QName:NO_ATTR_SET_ERR
       @@@@enDesc:
         An attribute setter is referred but the attribute
         does not define any setter.
       @@@@XSourceNodeParam:
       @@@@XParam:
         @@@@@QName:errResource
         @@@@@enDesc:
           The attribute resource. 
       @@@@XParam:
         @@@@@QName:elementType
         @@@@@enDesc:
           The type of the element by which this attribute
           is referred.
     @@@XSubTypeDef:
       @@@@QName: PERL_SUBROUTINE_ALREADY_DEFINED_ERR
       @@@@enDesc:
         A resource defines a Perl subroutine whose name is 
         same as another subroutine. 
       @@@@XSourceNodeParam:
       @@@@XParam:
         @@@@@QName:uri
         @@@@@enDesc:
           The URI reference of the resource that defines the Perl subroutine. 
       @@@@XParam:
         @@@@@QName:
           PerlCode:localName
         @@@@@enDesc:
           The name of the Perl subroutine. 
     @@@XSubTypeDef:
       @@@@QName: PERL_OPERATOR_ALREADY_OVERLOADED_ERR
       @@@@enDesc:
         A resource is defined to overload a Perl operator which 
         is already overloaded by another resource.
       @@@@XSourceNodeParam:
       @@@@XParam:
         @@@@@QName:uri
         @@@@@enDesc:
           The URI reference of the resource that defines the overloading.
       @@@@XParam:
         @@@@@QName: 
           PerlCode:operator
         @@@@@enDesc:
           The operator. 
     @@@XSubTypeDef:
       @@@@QName: PERL_UNUSED_SUBROUTINE_ERR
       @@@@enDesc:
         A resource defines a Perl subroutine but it is not used.
       @@@@XSourceNodeParam:
       @@@@XParam:
         @@@@@QName:uri
         @@@@@enDesc:
           The URI reference of the resource.
     @@@XSubTypeDef:
       @@@@QName: NO_LICENSE_ATTR_ERR
       @@@@enDesc:
         The <Q::dis:Module> element does not have the
         <Q::dis:License> attribute.
       @@@@XSourceNodeParam:
       @@@@XParam:
         @@@@@QName:uri
         @@@@@enDesc:
           The URI reference of the module.
     @@@XSubTypeDef:
       @@@@QName: UNSUPPORTED_ROLE_ERR
       @@@@enDesc:
         A <Q::dis:Role> is not supported.
       @@@@XSourceNodeParam:
       @@@@XParam:
         @@@@@QName:uri
         @@@@@enDesc:
           The URI reference of the unsupported role.
       @@@@enMufDef:
         Role <%p (name => {<Q::DIS:uri>});> is not supported
     @@@XSubTypeDef:
       @@@@QName: NO_REFLECT_GET_DEFINED_ERR
       @@@@enDesc:
          An attribute is defined to reflect an element attribute
          but no reflecting attribute getter template is defined.
       @@@@XSourceNodeParam:
       @@@@XParam:
         @@@@@QName:uri
         @@@@@enDesc:
           The URI reference of the datatype resource for which
           a getter template should have been defined.
     @@@XSubTypeDef:
       @@@@QName: NO_REFLECT_SET_DEFINED_ERR
       @@@@enDesc:
          An attribute is defined to reflect an element attribute
          but no reflecting attribute setter template is defined.
       @@@@XSourceNodeParam:
       @@@@XParam:
         @@@@@QName:uri
         @@@@@enDesc:
           The URI reference of the datatype resource for which
           a setter template should have been defined.
     @@@XSubTypeDef:
       @@@@QName: NO_END_TAG_ERR
       @@@@enDesc:
         Close tag not found.
       @@@@XSourceNodeParam:
       @@@@XParam:
         @@@@@@: elementType
         @@@@@enDesc:
           The type URI reference of the element that is not closed.
       @@@@XParam:
         @@@@@@: sourceCode
         @@@@@enDesc:
           The source code fragment near the position where
           an end tag is required.
       @@@@enMufDef:
         End tag for element "%p (name => {<Q::DIS:elementType>});"
         is required%p (name => {<Q::DIS:sourceCode>},
         prefix => { (}, suffix => {)});
      @@@XSubTypeDef:
        @@@@QName: NO_RDF_TYPE_ERR
        @@@@enDesc:
          There is a resource definition element that does
          not have any <Q::rdf:type> attribute.
        @@@@XSourceNodeParam:
        @@@@XParam:
          @@@@@@: uri
          @@@@@enDesc:
            The URI of the resource which does not have <Q::rdf:type>.
        @@@@enMufDef:
          Resource%p (name => {<Q::DIS:uri>}, prefix => { "},
          suffix => {"}); does not have "rdf:type" attribute
      @@@XSubTypeDef:
        @@@@QName: PERL_HASH_KEY_ALREADY_DEFINED_ERR
        @@@@enDesc:
          A hash key is already defined.
        @@@@XSourceNodeParam:
        @@@@XParam:
          @@@@@@:uri
          @@@@@enDesc:
            The URI of the resource tried to register.
        @@@@XParam:
          @@@@@@:anotherURI
          @@@@@enDesc:
            The URI of the already registered resource.
        @@@@XParam:
          @@@@@@:hashKeyName
          @@@@@enDesc:
            Hash key.
        @@@@XParam:
          @@@@@@:hashKeyScope
          @@@@@enDesc:
            Hash key scope.
        @@@@enMufDef:
          <%p (name => {<Q::DIS:uri>});>:
          Hash key "%p (name => {<Q::DIS:hashKeyName>});" in
          <%p (mame => {<Q::DIS:hashKeyScope>});> is already
          defined for <%p (name => {<Q::DIS:anotherURI>});>
      @@@XSubTypeDef:
        @@@@QName: DIS|NO_EXCEPTION_CLASS_ERR
        @@@@enDesc:
          The exception interface has no class that implements the interface.
        @@@@enMufDef:
          Exception interface <%p (name => {<Q::DIS:uri>});>:
          There is no class that implements this interface
        @@@@XParam:
          @@@@@@: DIS|uri
          @@@@@enDesc:
            The URI of the interface.
  @ImplNote:
    @@lang:en
    @@@:
      ISSUE: Too many subtypes for a type!  New type should be added?

  @Attr:
    @@Name: text
    @@enDesc:
      The description of the error, in <LANG::i-default> language.
    @@enImplNote:
      See <A::dx|Exception.text> for super definition.
    @@Type: DISLang|String
    @@Get:
      @@@PerlDef:
        $r = $self->SUPER::text;
        if (defined $self->{<H::DIS:uri>}) {
          $r = '<' . $self->{<H::DIS:uri>} . '>: ' . $r;
        }
        if (defined $self->{<H::DIS:sourceNode>}) {
          $r = 'Node ' . $self->{<H::DIS:sourceNode>}-><M::SWCFGNode.nodePath>
                          . ': ' . $r;
        }
##DISException

ElementTypeBinding:
  @Name: enImplNote
  @ElementType:
    dis:ImplNote
  @ShadowContent:
    @@lang:en

XParamDef:
  @QName: hashKeyName
  @Type: DISLang|String
  @enDesc:
    See <M::dp|DISDatabasePerl.plAddHashKey>.

XParamDef:
  @QName: hashKeyScope
  @Type: AnyURI
  @enDesc:
    See <M::dp|DISDatabasePerl.plAddHashKey>.

XParamDef:
  @QName: anotherURI
  @Type: ResourceURI
  @enDesc:
    A URI of another related resource.

XParamDef:
  @QName:expectedType
  @Type: ResourceURI
  @enDesc:
    Expected resource type URI reference.

XParamDef:
  @QName: sourceCode
  @Type:
    DISLang:String::ManakaiDOM:all
  @enDesc:
    The source code fragment in which an error occurred.

XParamDef:
  @QName: elementType
  @Type: ResourceURI
  @enDesc:
    The name of the element type. 

XParamDef:
  @QName: uri
  @Type: ResourceURI
  @enDesc:
    The name of the resource, composed from <Q::namespaceURI>, 
    <Q::localName> and <Q::for>. 

XParamDef:
  @QName: localName
  @Type: 
    DISCore:LocalName::ManakaiDOM:all
  @enDesc:
    The local name of the resource, unique in <Q::namespaceURI> namespace. 

XParamDef:
  @QName: namespaceURI
  @Type: AnyURI
  @enDesc:
    The namespace URI reference of the resource name. 

XParamDef:
  @QName: for
  @Type: ForURI
  @enDesc:
    The <QUOTE::for> URI reference of the resource. 

ElementTypeBinding:
  @Name: XSourceNodeParam
  @ElementType:
    ecore:hasParameter
  @ShadowContent:
    @@QName: sourceNode
    @@Description:
      @@@lang:en
      @@@@:
        The node in which an error has occurred. 

ElementTypeBinding:
  @Name: XSourceCodeParam
  @ElementType:
    ecore:hasParameter
  @ShadowContent:
    @@QName: sourceCode
    @@Description:
      @@@lang:en
      @@@@:
        The source code in which an error has occurred. 

ElementTypeBinding:
  @Name: plMName
  @ElementType:
    DISPerl:methodName
  @ShadowContent:
    @@ContentType: lang|Perl
    @@For: ManakaiDOM|Perl

ElementTypeBinding:
  @Name: plCName
  @ElementType:
    DISPerl:exportTagName
  @ShadowContent:
    @@ContentType: lang|Perl
    @@For: ManakaiDOM|Perl

ElementTypeBinding:
  @Name: Method
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:Method
    @@For: !=ForEmpty

ElementTypeBinding:
  @Name: CMethod
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:Method
    @@ForCheck: !=ForEmpty ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: IntMethod
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:Method
    @@ManakaiDOM:isForInternal:1
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: Attr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:Attribute
    @@For: !=ForEmpty

ElementTypeBinding:
  @Name: CAttr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:Attribute
    @@ForCheck: !=ForEmpty ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: Return
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:MethodReturn

ElementTypeBinding:
  @Name: Get
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:AttributeGet

ElementTypeBinding:
  @Name: Set
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:AttributeSet

ElementTypeBinding:
  @Name: Param
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:MethodParameter

ElementTypeBinding:
  @Name: PerlDef
  @ElementType:
    dis:Def
  @ShadowContent:
    @@ContentType:
      lang:Perl

ElementTypeBinding:
  @Name: InCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:InCase

ElementTypeBinding:
  @Name: nullCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:InCase
    @@Value:
      @@@is-null:1
      @@@ContentType: DISCore|String

ElementTypeBinding:
  @Name: TrueCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:InCase
    @@Value:
      @@@@: 1
      @@@ContentType: DISCore|Boolean
    @@Type:
      DOMMain:boolean::ManakaiDOM:all

ElementTypeBinding:
  @Name: FalseCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:InCase
    @@Value:
      @@@@: 0
      @@@ContentType: DISCore|Boolean
    @@Type:
      DOMMain:boolean::ManakaiDOM:all

ElementTypeBinding:
  @Name: enDesc
  @ElementType:
    dis:Description
  @ShadowContent:
    @@lang:en

ElementTypeBinding:
  @Name: PropDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISCore|Property
    @@For: =ManakaiDOM|all

ElementTypeBinding:
  @Name: RPropDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISSource|ResourceProperty
    @@For: =ManakaiDOM|all

ElementTypeBinding:
  @Name: MethodRedef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:Method

ElementTypeBinding:
  @Name: NamedParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:MethodParameter
    @@DISPerl:isNamedParameter:1

ElementTypeBinding:
  @Name: NodeParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:MethodParameter
    @@DISPerl:isNamedParameter:1
    @@Name: node
    @@Type: DISNode
    @@actualType:
      @@@@: ManakaiDISNode
      @@@ForCheck: ManakaiDOM|ForClass
    @@Description:
      @@@lang:en
      @@@@:
        The node in which the name has occurred.  It is intended 
        to be reported when an exception had been raised. 
    @@ResourceDef:
      @@@rdf:type:
        ManakaiDOM:InCase
      @@@Value:
        @@@@is-null:1
        @@@@ContentType: DISCore|String
      @@@Description:
        @@@@lang:en
        @@@@@:
          The source of the name is not a node. 

ElementTypeBinding:
  @Name: ForParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:MethodParameter
    @@DISPerl:isNamedParameter:1
    @@Name: forArg
    @@Type: ForURI
    @@Description:
      @@@lang:en
      @@@@:
        The <QUOTE::for> URI reference. 
    @@ResourceDef:
      @@@rdf:type:
        ManakaiDOM:InCase
      @@@Value:
        @@@@is-null:1
        @@@@ContentType: DISCore|String
      @@@Description:
        @@@@lang:en
        @@@@@:
          Equivalent to <Q::ManakaiDOM:all>, i.e. <QUOTE::for all>. 

ElementTypeBinding:
  @Name: ForpParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:MethodParameter
    @@DISPerl:isNamedParameter:1
    @@Name: forpArg
    @@Type: ForURIList
    @@Description:
      @@@lang:en
      @@@@:
        An array reference containing additional <QUOTE::for> 
        constraints (<QUOTE::For+> list).
    @@ResourceDef:
      @@@rdf:type:
        ManakaiDOM:InCase
      @@@Value:
        @@@@is-null:1
        @@@@ContentType: DISCore|String
      @@@Description:
        @@@@lang:en
        @@@@@:
          Equivalent to the empty array reference. 

ElementTypeBinding:
  @Name: MediaTypeParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:MethodParameter
    @@DISPerl:isNamedParameter:1
    @@Name: mediaType
    @@Type: MediaTypeURI
    @@Description:
      @@@lang:en
      @@@@:
        The URI reference identifying a media type. 
    @@ResourceDef:
      @@@rdf:type:
        ManakaiDOM:InCase
      @@@Value:
        @@@@is-null:1
        @@@@ContentType: DISCore|String
      @@@Description:
        @@@@lang:en
        @@@@@:
          No media type specified. 

ElementTypeBinding:
  @Name: MediaTypeDefaultParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:MethodParameter
    @@DISPerl:isNamedParameter:1
    @@Name: defaultMediaType
    @@Type: MediaTypeURI
    @@Description:
      @@@lang:en
      @@@@:
        The default media type, i.e. the type used when no explicit 
        specification is not found in the source tree. 
    @@ResourceDef:
      @@@rdf:type:
        ManakaiDOM:InCase
      @@@Value:
        @@@@is-null:1
        @@@@ContentType: DISCore|String
      @@@Description:
        @@@@lang:en
        @@@@@:
          Defaulted to <Q::DOMMain:any>. 

ElementTypeBinding:
  @Name: RaiseException
  @ElementType:
    ManakaiDOM:raises

ElementTypeBinding:
  @Name: UndeclaredPrefixException
  @ElementType:
    ManakaiDOM:raises
  @ShadowContent:
    @@@: UNDECLARED_NS_PREFIX_ERR
    @@Description:
      @@@lang:en
      @@@@:
        The implementation has encounted an undeclared namespace prefix. 

ElementTypeBinding:
  @Name: NoDBException
  @ElementType:
    ManakaiDOM:raises
  @ShadowContent:
    @@@: NO_ASSOCIATED_DB_ERR
    @@Description:
      @@@lang:en
      @@@@:
        No <QUOTE::dis> database is associated to this document. 

ElementTypeBinding:
  @Name: XConstDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: dx|ErrorCode

ElementTypeBinding:
  @Name: XSubTypeDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: dx|ErrorSubCode

ElementTypeBinding:
  @Name: XParam
  @ElementType:
    ecore:hasParameter

ElementTypeBinding:
  @Name: XParamDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: ecore|Parameter
    @@For: =ManakaiDOM|all

XParamDef:
  @QName: DIS|moduleURI
  @enDesc:
    A URI of the module in which the resource is defined.

ElementTypeBinding:
  @Name: enMufDef
  @ElementType:
    ecore:defaultMessage
  @ShadowContent:
    @@ContentType:
      lang:muf
    @@lang:en
