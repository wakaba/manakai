Module:
  @QName:
    Util:DIS
  @FullName:
    @@lang: en
    @@@:
      <QUOTE::DIS> Object Model
  @Namespace:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS#
  
  @Description:
    @@lang:en
    @@@:
      This module provides an object model for <QUOTE::dis> document format.  

  @Author:
    @@FullName: Wakaba
    @@Mail: w@suika.fam.cx
  @License:
    @@@:
      license:Perl+MPL
    @@Original:
      @@@FullName:
        manakai <CODE::lib/manakai/dis.pl> and <CODE::bin/cdis2pm.pl>
      @@@Year:2004
      @@@Author:
        @@@@FullName:Wakaba
        @@@@Mail:w@suika.fam.cx
  @Date:
    @@@:
      $Date: 2005/09/17 15:03:03 $
    @@ContentType:
      dis:Date.RCS
  
  @Require:
    @@Module:
      @@@Name: SuikaWikiConfig21
      @@@QName:
        Markup:SuikaWikiConfig21
      @@@WithFor:
        swcfg21:ForLatest
    @@Module:
      @@@Name: DIS
      @@@WithFor: 
        DIS:ForLatest
    @@Module:
      @@@Name: DIS
      @@@WithFor:
        DIS:ForEmpty
    @@Module:
      @@@Name: PerlCode
      @@@WithFor:
        ManakaiDOM:Perl
    @@Module:
      @@@QName: MDOM|DOMFeature
      @@@WithFor: ManakaiDOM|all
    @@Module:
      @@@QName: DIS|Perl
      @@@WithFor: DIS|ForLatest
    @@Module:
      @@@QName: DIS|Value
      @@@WithFor: DIS|ForLatest

  @DefaultFor: 
    DIS:ForLatest

Namespace:
  @DIS:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS#
  @dis:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#dis--
  @dis2pm:
    http://suika.fam.cx/~wakaba/archive/2004/11/8/dis2pm#
  @DISlib:
    http://suika.fam.cx/~wakaba/archive/2004/dis/
  @disPerl:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#dis--Perl--
  @DOMCore:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#
  @DOMException:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#
  @DOMLS:
    http://suika.fam.cx/~wakaba/archive/2004/dom/ls#
  @DOMMain:
    http://suika.fam.cx/~wakaba/archive/2004/dom/main#
  @DOMMetaImpl:
    http://suika.fam.cx/~wakaba/archive/2004/dom/meta#
  @dp:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS#Perl/
  @dv:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS#Value/
  @ecore:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/Core/
  @infoset:
    http://www.w3.org/2001/04/infoset#
  @kwd:
    http://suika.fam.cx/~wakaba/archive/2005/rfc2119/
  @lang:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#
  @license:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/license#
  @ManakaiDOM:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#
  @Markup:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Markup#
  @MDOM:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#ManakaiDOM.
  @MDOMX:
    http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#
  @null:
    http://suika.fam.cx/~wakaba/-temp/2003/09/27/null
  @owl:
    http://www.w3.org/2002/07/owl#
  @Perl:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#Perl--
  @rdf:
    http://www.w3.org/1999/02/22-rdf-syntax-ns#
  @rdfs:
    http://www.w3.org/2000/01/rdf-schema#
  @s:
    http://suika.fam.cx/~wakaba/archive/2004/dis/Markup#
  @swcfg21:
    http://suika.fam.cx/~wakaba/archive/2005/swcfg21#
  @TreeCore:\
  @Util:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/

## -- "For" definitions

ForDef:
  @QName: 
    DIS:ForLatest
  @Description:
    @@lang:en
    @@@:
      For latest version of the <Module::Util:DIS> module implementation
  @ISA: DIS|ForEmpty

## -- Submodules


ResourceDef:
  @QName:
    DIS:
  @rdf:type:
    dis:ModuleGroup
  @FullName:
    @@lang:en
    @@@:
      <QUOTE::dis> modules
  @AppName:
    @@@:
      Message::Util::IF::
    @@ForCheck: 
      ManakaiDOM:ForIF
  @AppName:
    Message::Util::DIS::
  @DISPerl:interfacePackage:
    Message::Util::IF::
  @DISPerl:classPackage:
    Message::Util::DIS::

## -- Features

ElementTypeBinding:
  @Name: FeatureDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DOMMain:DOMFeature
    @@ForCheck:
      ManakaiDOM:all

ElementTypeBinding:
  @Name: FeatureVerDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DOMMain:DOMFeature

ElementTypeBinding:
  @Name: featureQName
  @ElementType:
    dis:AppName
  @ShadowContent:
    @@ContentType:
      dis:TypeQName

FeatureDef:
  @QName: Core
  @FeatureVerDef:
    @@QName: CoreFeature10
    @@Version: 1.0
    @@DOMMetaImpl:instanceFeatureOf: Core
    @@FullName:
      @@@lang:en
      @@@@:
        The <QUOTE::dis> object model, version 1.0
    @@Description:
      @@@lang:en
      @@@@:
        The <QUOTE::dis> object model, version 1.0. 
    @@DOMMain:requireFeature: 
      swcfg21:CoreFeature21

## -- Roles

ElementTypeBinding:
  @Name: RoleDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:Role
    @@ForCheck:
      =ManakaiDOM:all

RoleDef:
  @QName: ModuleRole
  @enDesc:
    Any class playing this role may be returned by
    <M::ManakaiDISModuleDefinition.getFeature> method with
    appropriate feature parameters.

RoleDef:
  @QName: ForRole
  @enDesc:
    Any class playing this role may be returned by
    <M::ManakaiDISForDefinition.getFeature> method with
    appropriate feature parameters.

RoleDef:
  @QName: ResourceRole
  @enDesc:
    Any class playing this role may be returned by
    <M::ManakaiDISResourceDefinition.getFeature> method with
    appropriate feature parameters.

RoleDef:
  @QName: ElementRole
  @enDesc:
    Any class playing this role may be returned by
    <M::ManakaiDISElement.getFeature> method with
    appropriate feature parameters.

RoleDef:
  @QName: DatabaseRole
  @enDesc:
    Any class playing this role may be returned by
    <M::ManakaiDISDatabase.getFeature> method with
    appropriate feature parameters.


ElementTypeBinding:
  @Name: IFQName
  @ElementType:
    dis:QName
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForIF

ElementTypeBinding:
  @Name: ClsQName
  @ElementType:
    dis:QName
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: IFISA
  @ElementType:
    dis:ISA
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForIF

ElementTypeBinding:
  @Name: ClsISA
  @ElementType:
    dis:ISA
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: IFClsDef
  @ElementType: 
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      @@@@: dis|MultipleResource
      @@@ForCheck: !ManakaiDOM|ForIF !ManakaiDOM|ForClass
    @@resourceFor: ManakaiDOM|ForIF
    @@resourceFor:
      @@@@: ManakaiDOM|ForClass
      @@@ForCheck: ForEmpty !=ForEmpty
    @@For: ForLatest
    @@For: =ForEmpty

    @@rdf:type:
      @@@@: ManakaiDOM|IF
      @@@ForCheck: ManakaiDOM|ForIF

    @@rdf:type:
      @@@@: ManakaiDOM|Class
      @@@ForCheck: ManakaiDOM|ForClass
    @@Implement:
      @@@@: ||ForEmpty||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ForEmpty
    @@Implement:
      @@@@: ||ForLatest||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ForLatest

    @@DOMMain:implementFeature:
      @@@@: CoreFeature10
      @@@For: ForLatest

ElementTypeBinding:
  @Name: ClsDef
  @ElementType: 
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      @@@@: dis|MultipleResource
      @@@ForCheck: !ManakaiDOM|ForIF !ManakaiDOM|ForClass

    @@resourceFor:
      @@@@: ManakaiDOM|ForClass
      @@@ForCheck: ForEmpty !=ForEmpty
    @@For: ForLatest

    @@rdf:type:
      @@@@: ManakaiDOM|Class
      @@@ForCheck: ManakaiDOM|ForClass

    @@DOMMain:implementFeature:
      @@@@: CoreFeature10
      @@@For: ForLatest

ElementTypeBinding:
  @Name: clsActualType
  @ElementType:
    dis:actualType
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass

## -- SuikaWikiConfig/2.1 extended classes

IFClsDef:
  @IFQName: DISImplementation
  @ClsQName: ManakaiDISImplementation

  @ClsISA:
    swcfg21:ManakaiSWCFGImplementation::swcfg21:ForLatest
  @ClsISA: dp|ManakaiDISImplementationPerl
  @ClsISA: dv|ManakaiDISImplementationValue

  @Description:
    @@lang:en
    @@@:
      A <QUOTE::dis> implementation object. 

  @Method:
    @@Name: createDISDocument
    @@Description:
      @@@lang:en
      @@@@:
        Creates an empty <IF::DISDocument> node.
    @@Return:
      @@@Type: DISDocument
      @@@clsActualType: ManakaiDISDocument
      @@@Description:
        @@@@lang:en
        @@@@@:
          The newly created <QUOTE::dis> document object.
      @@@PerlDef:
        $r = bless $self-><M::swcfg21:SWCFGImplementation::swcfg21:ForLatest
                                              .createSWCFGDocument>,
                   <ClassName::ManakaiDISDocument>;
        $r-><AS::swcfg21:SWCFGDocument::swcfg21:ForLatest
                                        .defaultElementTypeNamespaceURI>
                    (<Q::dis:>);

  @Method:
    @@Name: createDISParser
    @@Description:
      @@@lang:en
      @@@@:
        Creates a <IF::DISParser> object.
    @@Return:
      @@@Type: DISParser
      @@@clsActualType: ManakaiDISParser
      @@@Description:
        @@@@lang:en
        @@@@@: 
          A newly created <QUOTE::dis> parser. 
      @@@PerlDef:
        $r = bless $self-><M::swcfg21:SWCFGImplementation::swcfg21:ForLatest
                                           .createSWCFGParser>,
                   <ClassName::ManakaiDISParser>;

  @Method:
    @@Name: createDISDatabase
    @@Description:
      @@@lang:en
      @@@@:
        Creates a new <QUOTE::dis> database.
    @@Return:
      @@@Type: DISDatabase
      @@@clsActualType: ManakaiDISDatabase
      @@@Description:
        @@@@lang:en
        @@@@@:
          A newly created <QUOTE::dis> parser.
      @@@PerlDef:
        $r = bless {
          forDef => {
            <Q::ManakaiDOM:all> => bless ({
              uri => <Q::ManakaiDOM:all>,
              isa => {<Q::ManakaiDOM:all> => 1},
              revISA => {},
            }, <ClassName::ManakaiDISForDefinition>),
          },
          resDef => {},
          modDef => {},
          seq => 0,
        }, <ClassName::ManakaiDISDatabase>;
        $r->{forDef}->{<Q::ManakaiDOM:all>}->{db} = $r;

  @Method:
    @@Name: tfurisToURI
    @@Description:
      @@@lang:en
      @@@@:
        Converts a pair of name URI reference and <QUOTE::for> URI reference 
        into a <Q::dis:TFQNames>-expanded URI reference. 
    @@Param:
      @@@Name: typeURI
      @@@Type: NameURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          A URI reference to identify a resource. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            Equivalent to <Q::DOMMain:any> (for historical reason). 
    @@Param:
      @@@Name: forURI
      @@@Type: ForURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          A <QUOTE::for> URI reference. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            Equivalent to <QUOTE::for all>, i.e. <Q::ManakaiDOM:all>. 
    @@Return:
      @@@Type: 
        DISCore:TFURI::ManakaiDOM:all
      @@@Description:
        @@@@lang:en
        @@@@@:
          The <Q::dis:TFQNames>-expanded URI references.  
      @@@PerlDef:
        $typeURI = <Q::DOMMain:any> unless defined $typeURI;
        $forURI = <Q::ManakaiDOM:all> unless defined $forURI;
        __CODE{tfurisToURI:: $turi => $typeURI, $furi => $forURI, $uri => $r}__;

  @ResourceDef:
    @@ForCheck: ManakaiDOM|ForClass
    @@QName: tfurisToURI
    @@rdf:type:
      dis2pm:BlockCode
    @@enDesc:
        Converts a pair of name URI reference and <QUOTE::for> URI reference 
        into a <Q::dis:TFQNames>-expanded URI reference. 
    @@PerlDef:      
        if ($furi eq <Q::ManakaiDOM:all>) {
          $uri = $turi;
        } else {
          ## NOTE: [RFC 3986]
          ##       fragment    := *(pchar / "/" / "?")
          ##       pchar       := unreserved / pct-encoded / sub-delims / [:@]
          ##       unreserved  := ALPHA / DIGIT / [._~-]
          ##       sub-delims  := [!$&'()*+,;=]
          ## NOTE: [XPointer Framework]
          ##       SchemeData  := *EscapedData
          ##       EscapedData := NormalChar / "^(" / "^)" / "^^"
          ##                    / "(" SchemeData ")"
          ##       NormalChar  := UnicodeChar - [()^]
          my $__turi = $turi;
          my $__furi = $furi;
          for my $__uri ($__turi, $__furi) {
            $__uri =~ s{([^0-9A-Za-z:;?=_./-])}{sprintf '%%%02X', ord $1}ge;
          }
          $uri = qq<data:,200411tf#xmlns(t=data:,200411tf%23)>.
                                qq<t:tf($__turi,$__furi)>;
        }

  @ResourceDef:
    @@QName: tfpurisToURI
    @@rdf:type:
      dis2pm:BlockCode
    @@enDesc:
        Converts a set of name URI reference and <QUOTE::for> URI reference 
        and <QUOTE::for+> URI references into a URi reference. 
    @@ForCheck: ManakaiDOM|ForClass
    @@PerlDef:      
        if ($furi eq <Q::ManakaiDOM:all> and @{$forp} == 0) {
          $uri = $turi;
        } elsif (@{$forp}) {
          my $__turi = $turi;
          my $__furi = $furi;
          for my $__uri ($__turi, $__furi) {
            $__uri =~ s{([^0-9A-Za-z:;?=_./~!&+-])}{sprintf '%%%02X', ord $1}ge;
          }
          my @__fp;
          for my $__uri (@{$forp}) {
            my $__fpuri = $__uri;
            $__fpuri =~ s{([^0-9A-Za-z:;?=_./~!&+-])}
                         {sprintf '%%%02X', ord $1}ge;
            push @__fp, $__fpuri;
          }
          $uri = qq<data:,200411tf#xmlns(t=data:,200411tf%23)>.
                               qq<t:tfp($__turi,$__furi,>.join (',', @__fp).q<)>;
        } else {
          my $__turi = $turi;
          my $__furi = $furi;
          for my $__uri ($__turi, $__furi) {
            $__uri =~ s{([^0-9A-Za-z:;?=_./-])}{sprintf '%%%02X', ord $1}ge;
          }
          $uri = qq<data:,200411tf#xmlns(t=data:,200411tf%23)>.
                                qq<t:tf($__turi,$__furi)>;
        }

  @ImplNote:
    @@lang:en
    @@@:
      {TODO:: IRI support.
      }

  @ResourceDef:
    @@QName: getChildResourceURI
    @@rdf:type: 
      dis2pm:BlockCode
    @@enDesc:
      Gets an anonymous URI reference of a child resource of another 
      resource. 
    @@ForCheck: ManakaiDOM|ForClass
    @@PerlDef:
      my $__parent = $parentURI;
      my $__ln = $localName;
      for my $__uri ($__parent, $__ln) {
        $__uri =~ s{([^0-9A-Za-z:;?=_./~!&+-])}{sprintf '%%%02X', ord $1}ge;
      }
      $result = q<data:,200411tf#xmlns(t=data:,200411tf%23)>.
                              qq<t:child($__parent,$__ln)>;

  @IntMethod:
    @@Name: camelCaseToUnderscoreName
    @@enDesc:
      Converts a camelCase name to a underscored_name. 
    @@ManakaiDOM:isStatic:1
    @@ForCheck: ManakaiDOM|ForClass
    @@Param:
      @@@Name: camelName
      @@@Type:
        DISLang:String::ManakaiDOM:all
      @@@enDesc:
        The source name. 
    @@Return:
      @@@Type:
        DISLang:String::ManakaiDOM:all
      @@@enDesc:
        The result name. 
      @@@PerlDef:
        $r = $camelName;
        $r =~ s/^([A-Z0-9]+)$/lc $1/ge;
        $r =~ s/([A-Z][A-Z0-9]*)$/"_".lc $1/ge;
        $r =~ s/([A-Z0-9])([A-Z0-9]*)([A-Z0-9])/$1.lc ($2)."_".lc $3/ge;
        $r =~ s/([A-Z])/"_".lc $1/ge;
        $r =~ s/(?=[0-9](?!$))/_/g;

  @DOMMetaImpl:provideFeature: CoreFeature10
##DISImplementation

IFClsDef:
  @IFQName: DISParser
  @ClsQName: ManakaiDISParser

  @IFISA: swcfg21|SWCFGParser||swcfg21|ForLatest
  @ClsISA:
    swcfg21:ManakaiSWCFGParser::swcfg21:ForLatest

  @Description:
    @@lang:en
    @@@:
      A SuikaWikiConfig/2.1 parser that returns <QUOTE::dis> object. 
  @Method:
    @@Name: parse
    @@Description:
      @@@lang:en
      @@@@:
        Parses a <QUOTE::dis> document and returns it as an object tree. 
    @@Param:
      @@@Name: input
      @@@Type:
        DOMLS:LSInput::ManakaiDOM:ManakaiDOMLatest
      @@@Description:
        @@@@lang:en
        @@@@@:
          The input source. 
    @@Return:
      @@@Type: DISDocument
      @@@clsActualType: ManakaiDISDocument
      @@@Description:
        @@@@lang:en
        @@@@@:
          The <QUOTE::dis> document object created from the <P::input>. 
      @@@RaiseException:
        @@@@@:
          swcfg21:SWCFG_PARSE_ERR::swcfg21:ForLatest
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The <IF::swcfg21:SWCFGParser> was unable to load the SuikaWikiConfig 
            document. 
      @@@PerlDef:
        __DEEP{
          $r = $self->SUPER::parse ($input)
                      ## NOTE: Method name directly written
                      #< M::swcfg21:ManakaiSWCFGParser
                      #  ::swcfg21:ForLatest.parse> ($input)
        }__;
        if (defined $r) {
          $r = bless $r, <ClassName::ManakaiDISDocument>;
          $r-><AS::swcfg21:SWCFGDocument::swcfg21:ForLatest
                                        .defaultElementTypeNamespaceURI>
                    (<Q::dis:>);
        }
##DISParser

IFClsDef:
  @IFQName: DISNode
  @ClsQName: ManakaiDISNode

  @Description:
    @@lang:en
    @@@:
      <QUOTE::dis> node objects. 
  @ImplNote:
    @@lang:en
    @@@:
      This class does not inherit 
      <Class::swcfg21:ManakaiSWCFGNode::swcfg21:ForLatest>, since 
      inheriting classes such as <Class::ManakaiDISElement> indirectly 
      inherit it. 

  @MethodRedef:
    @@ForCheck: ManakaiDOM|ForClass
    @@Name:lookupNamespacePrefix
    @@Description:
      @@@lang:en
      @@@@:
        Looks up the namespace prefix associated to the given 
        namespace URI.  The default namespaces are ignored. 
    @@Param:
      @@@Name:namespaceURI
      @@@Type: AnyURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          The namespace URI to look for. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The <DOM::null> namespace. 
    @@NamedParam:
      @@@Name: makeNewBinding
      @@@Type: 
        DOMMain:boolean::ManakaiDOM:all
      @@@Description:
        @@@@lang:en
        @@@@@:
          Whether a new namespace prefix should be bound when 
          no namespace URI has been associated yet. 
      @@@InCase:
        @@@@Value:true
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            New binding is made if no prefix associated. 
      @@@InCase:
        @@@@Value:false
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            Simply returns the <DOM::null> if no prefix associated. 
    @@Return:
      @@@Type: swcfg21|SWCFGString||swcfg21|ForLatest
      @@@actualType:
        DISCore:NamespacePrefix::ManakaiDOM:all
      @@@Description:
        @@@@lang:en
        @@@@@:
           An associated namespace prefix.  If more than one prefix 
           are associated to the namespace URI, the returned prefix 
           is implementation dependent. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            No associated namespace prefix found. 
      @@@PerlDef:
        $r = null;
        my $od = $self-><AG::swcfg21:SWCFGNode::swcfg21:ForLatest
                                          .ownerDocument> || $self;
        my $binds = $od->{<Q::TreeCore:node>}->{<Q::swcfg21:nsBinding>};
        if (defined $namespaceURI) {
          FIND: {
            for my $prefix (keys %$binds) {
              if (defined $binds->{$prefix} and
                  $binds->{$prefix} eq $namespaceURI) {
                $r = $prefix;
                last FIND;
              }
            }

            ## From module list
            try {
              my $db = $self-><AG::ManakaiDISNode.ownerDISDocument>
                            -><AG::ManakaiDISDocument.disDatabase>;
              for my $mod_uri (keys %{$db->{modDef}}) {
                my $mod = $db-><M::ManakaiDISDatabase.getModule> ($mod_uri);
                my $mod_ln = $mod-><AG::DISAnyResource.localName>;
                next if exists $binds->{$mod_ln};
                my $ns_uri = $mod-><M::DISResourceProp
                                            .getPropertyText>
                                                 (<Q::dis:Namespace>, '');
                if ($ns_uri eq $namespaceURI) {
                  $r = $mod_ln;
                  last FIND;
                }
              }
            } catch <IF::DISException> with {
              my $err = shift;
              $err->throw
                unless $err->{<Q::MDOMX:subtype>} eq <Q::NO_ASSOCIATED_DB_ERR>;
            };

            last FIND unless $makeNewBinding;
            ## Not found
            if ($namespaceURI =~ /(\w+)$/) {
              my $prefix = $1;
              unless (exists $binds->{$prefix}) {
                $binds->{$prefix} = $namespaceURI;
                $r = $prefix;
                last FIND;
              }
            }
            my $i = 1;
            {
              unless (exists $binds->{'ns'.$i}) {
                $binds->{$r = 'ns'.$i} = $namespaceURI;
                last FIND;
              }
              $i++;
              redo;
            }
          } # FIND
        } else {  ## Null namespace
          FIND: {
            if (exists $binds->{'nu'.'ll'} and not defined $binds->{'nu'.'ll'}) {
              $r = 'nu'.'ll';
              last FIND;
            }
            for my $prefix (keys %$binds) {
              if (not defined $prefix) {
                $r = $prefix;
                last FIND;
              }
            }
            last FIND unless $makeNewBinding;
            ## Not found
            my $i = '';
            {
              unless (exists $binds->{'nu'.'ll'.$i}) {
                $binds->{$r = 'nu'.'ll'.$i} = null;
                last FIND;
              }
              $i++;
              redo;
            }
          }
        }

  @MethodRedef:
    @@ForCheck: ManakaiDOM|ForClass
    @@Name:lookupNamespaceURI
    @@Description:
      @@@lang:en
      @@@@:
        Looks up the namespace URI associated to the given prefix. 
    @@Param:
      @@@Name:prefix
      @@@Type:
        DISCore:NamespacePrefix::ManakaiDOM:all
      @@@Description:
        @@@@lang:en
        @@@@@:
          The namespace URI to look for. 
    @@NamedParam:
      @@@Name: makeNewBinding
      @@@Type:
        DOMMain:boolean::ManakaiDOM:all
      @@@Description:
        @@@@lang:en
        @@@@@:
          Whether a new binding should be created if no namespace URI 
          is associated with the <P::prefix> or not. 
      @@@InCase:
        @@@@Value:true
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            A new binding to the temporary namespace URI 
            exactly same as <P::prefix> is created 
            if no binding found. 
      @@@InCase:
        @@@@Value:false
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            No new binding is created if no binding found.  Note that 
            even if no association newly created, this method 
            returns the <DOM::null> value. 
    @@NamedParam:
      @@@Name: raisePrefixException
      @@@Type:
        DOMMain:boolean::ManakaiDOM:all
      @@@enDesc:
        Whehter an exception should be thrown if <P::prefix>
        is not declared or not. 
    @@Return:
      @@@Type: AnyURI
      @@@Description:
        @@@@lang:en
        @@@@@:The associated namespace URI. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            No namespace URI is associated to the prefix or 
            the <DOM::null> namespace is associated. 
      @@@UndeclaredPrefixException:
      @@@PerlDef:
        my $od = $self-><AG::swcfg21:SWCFGNode::swcfg21:ForLatest
                                               .ownerDocument> || $self;
        my $binds = $od->{<Q::TreeCore:node>}->{<Q::swcfg21:nsBinding>};
        if (exists $binds->{$prefix}) {
          $r = $binds->{$prefix};
        } else {
          ## From module list
          FIND: {
            try {
              my $db = $self-><AG::ManakaiDISNode.ownerDISDocument>
                            -><AG::ManakaiDISDocument.disDatabase>;
              for my $mod_uri (keys %{$db->{modDef}}) {
                my $mod = $db-><M::ManakaiDISDatabase.getModule> ($mod_uri);
                if ($mod-><AG::DISAnyResource.localName>
                      eq $prefix) {
                  $r = $mod-><M::DISResourceProp.getPropertyText>
                                                   (<Q::dis:Namespace>, null);
                  last FIND;
                }            
              }
            } catch <IF::DISException> with {
              my $err = shift;
              $err->throw
                unless $err->{<Q::MDOMX:subtype>} eq <Q::NO_ASSOCIATED_DB_ERR>;
            };
            if ($makeNewBinding) {
              $r = $binds->{$prefix} = $prefix;
            } elsif ($raisePrefixException) {
              __EXCEPTION{DIS:UNDECLARED_NS_PREFIX_ERR::
                infoset:prefix => {$prefix},
                MDOMX:param-name => 'prefix',
                DIS:sourceNode => {$self},
              }__;
            } else {
              $r = null;
            }
          } # FIND
        }

  @IntMethod:
    @@ForCheck: ManakaiDOM|ForClass
    @@Name:getNodeReference
    @@Description:
      @@@lang:en
      @@@@:
        Returns a new reference to the node object. 
    @@ManakaiDOM:isStatic:1
    @@Param:
      @@@Name:object
      @@@Type: ManakaiNode|NodeStem||ManakaiDOM|Perl
      @@@Description:
        @@@@lang:en
        @@@@@:
          The node object to be referred. 
    @@Return:
      @@@Type: ManakaiDISNode
      @@@Description:
        @@@@lang:en
        @@@@@:
          A newly created reference.
      @@@PerlDef:
        my $class;
        if ($object->{<Q::swcfg21:nodeType>} eq '#element') {
          $class = <ClassName::ManakaiDISElement>;
        } elsif ($object->{<Q::swcfg21:nodeType>} eq '#comment') {
          $class = <ClassName::ManakaiDISComment>;
        } elsif ($object->{<Q::swcfg21:nodeType>} eq '#document') {
          $class = <ClassName::ManakaiDISDocument>;
        } elsif ($object->{<Q::swcfg21:nodeType>} eq '#fragment') {
          $class = <ClassName::ManakaiDISDocumentFragment>;
        } else {
          __ASSERT{DISPerl:invariant::
            msg => {qq[Node type: "$object->{<Q::swcfg21:nodeType>}" ].
                    qq[(ref: "@{[ref $object]}")]},
          }__;
        }
        __CODE{ManakaiNode|getNewReference||ManakaiDOM|Perl::
          $object => $object,
          $ref => $r,
          $class => $class,
        }__;
  
  @Attr:
    @@Name:ownerDISDocument
    @@Description:
      @@@lang:en
      @@@@:
        The <QUOTE::dis> document object associated with this node. 
    @@Get:
      @@@Type: DISDocument
      @@@clsActualType: ManakaiDISDocument
      @@@Description:
        @@@@lang:en
        @@@@@:
          The document object associated with this node. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            This node is a document node. 
      @@@PerlDef:
        $r = <ClassM::ManakaiDISNode.getNodeReference>
                ($self->{<Q::TreeCore:node>}->{<Q::swcfg21:ownerDocument>})
          if $self->{<Q::TreeCore:node>}->{<Q::swcfg21:ownerDocument>};
##DISNode

IFClsDef:
  @IFQName: NSResolverDIS
  @ClsQName: ManakaiNSResolverDIS


  @Method:
    @@Name: prefixToURI
    @@Description:
      @@@lang:en
      @@@@:
        Converts a namespace prefix into associated URI reference. 
    @@Param:
      @@@Name: prefix
      @@@Type:
        DISCore:NamespacePrefix::ManakaiDOM:all
      @@@Description:
        @@@@lang:en
        @@@@@:
          A namespace prefix to look for. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            Returns the default namespace URI. 
    @@NodeParam:
    @@Return:
      @@@Type: AnyURI
      @@@Description:
        @@@@lang:en
        @@@@@: The URI references associated. 
      @@@UndeclaredPrefixException:
      @@@PerlDef:
        if (defined $prefix) {
          __DEEP{
            $r = $self-><M::SWCFGNode.lookupNamespaceURI> ($prefix);
          }__;
          unless (defined $r) {
            __EXCEPTION{UNDECLARED_NS_PREFIX_ERR::
              infoset:prefix => {$prefix},
              MDOMX:param-name => 'prefix',
              DIS:sourceNode => {$node},
            }__;
          }
        } elsif (defined $self->{<Q::TreeCore:node>}
                              ->{<Q::DIS|defaultNamespaceURI>}) {
          $r = $self->{<Q::TreeCore:node>}->{<Q::DIS|defaultNamespaceURI>};
        } else {  ## Default namespace
          __DEEP{
            $r = ($self-><AG::ManakaiDISNode.ownerDISDocument> || $self)
                       -><AG::ManakaiDISDocument.moduleElement>
                       -><AG::ManakaiDISModuleElement.definingNamespaceURI>;
          }__;
        }

  @Method:
    @@Name: qnameToURI
    @@Description:
      @@@lang:en
      @@@@:
        Converts a qualified name (<Q::dis:TypeQName>) to 
        an expanded URI reference. 
    @@Param:
      @@@Name: qname
      @@@Type:
        dis:TypeQName::ManakaiDOM:all
      @@@Description:
        @@@@lang:en
        @@@@@:
          A qualified name. 
    @@NodeParam:
    @@NamedParam:
      @@@Name: defaultNamespaceURI
      @@@Type: AnyURI
      @@@enDesc:
        Default namespace URI reference. 
      @@@nullCase:
        @@@@enDesc:
          The default namespace is the namespace defined by the module
          to which this resource belongs.
    @@Return:
      @@@Type: AnyURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          The expanded URI reference. 
      @@@UndeclaredPrefixException:
      @@@PerlDef:
        $qname =~ s/^\s+//; $qname =~ s/\s+$//;
        my ($prefix, $lname) = split /\s*[:|]\s*/, $qname, 2;
        __DEEP{
          if (defined $lname) {
            $r = $self-><M::NSResolverDIS.prefixToURI> ($prefix) . $lname;
          } else {  ## In default namespace
            if (defined $defaultNamespaceURI) {
              $r = $defaultNamespaceURI . $prefix;
            } else {
              $r = $self-><M::NSResolverDIS.prefixToURI> (null) . $prefix;
            }
          }
        }__;

  @Method:
    @@Name: qnameToPair
    @@Description:
      @@@lang:en
      @@@@:
        Converts a qualified name (<Q::dis:TypeQName>) to 
        a pair of namespace URI and local name. 
    @@Param:
      @@@Name: qname
      @@@Type:
        dis:TypeQName::ManakaiDOM:all
      @@@Description:
        @@@@lang:en
        @@@@@:
          A qualified name. 
    @@NodeParam:
    @@Return:
      @@@Type:
        Perl:ARRAY::ManakaiDOM:all
      @@@Description:
        @@@@lang:en
        @@@@@:
          A list of namespace URI and local name. 
      @@@UndeclaredPrefixException:
      @@@PerlDef:
        $qname =~ s/^\s+//; $qname =~ s/\s+$//;
        my ($prefix, $lname) = split /\s*[:|]\s*/, $qname, 2;
        __DEEP{
          if (defined $lname) {
            $r = [$self-><M::NSResolverDIS.prefixToURI> ($prefix), $lname];
          } else {  ## In default namespace
            $r = [$self-><M::NSResolverDIS.prefixToURI> (null), $prefix];
          }
        }__;

  @Method:
    @@Name: tfqnamesToURI
    @@Description:
      @@@lang:en
      @@@@:
        Converts a <Q::dis:TFQNames>
        into an expanded URI reference. 
    @@Param:
      @@@Name: tfqnames
      @@@Type: 
        dis:TFQNames::ManakaiDOM:all
      @@@Description:
        @@@@lang:en
        @@@@@:
          A <Q::dis:TFQNames> to identify a resource. 
    @@Param:
      @@@Name: defaultTypeURI
      @@@Type: NameURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          A name URI reference used if it is missing from 
          <P::tfqnames>. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            Equivalent to <Q::DOMMain:any>. 
    @@Param:
      @@@Name: defaultForURI
      @@@Type: ForURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          A <QUOTE::for> URI reference used if it is missing from 
          <P::tfqnames>. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            Equivalent to <QUOTE::for all>, i.e. <Q::ManakaiDOM:all>. 
    @@NodeParam:
    @@Return:
      @@@Type: 
        DISCore:TFURI::ManakaiDOM:all
      @@@Description:
        @@@@lang:en
        @@@@@:
          The <Q::dis:TFQNames>-expanded URI references.  
      @@@UndeclaredPrefixException:
      @@@PerlDef:
        my ($typeq, $forq) = split /\s*[:|][:|]\s*/, $tfqnames, 2;
        my ($typeURI, $forURI);
        if (defined $forq) {
          __DEEP{
            $typeURI = $typeq eq ''
                       ? defined $defaultTypeURI ? $defaultTypeURI
                                                 : <Q::DOMMain:any>
                       : $self-><M::NSResolverDIS.qnameToURI> ($typeq, %opt);
          }__;
          if (length $forq) {
            $forURI = $self-><M::NSResolverDIS.qnameToURI> ($forq, %opt);
          } else {
            $forURI = <Q::ManakaiDOM:all>;
          }
        } else {  ## "For" omitted
          __DEEP{
            $typeURI = $typeq eq ''
                       ? defined $defaultTypeURI ? $defaultTypeURI
                                                 : <Q::DOMMain:any>
                       : $self-><M::NSResolverDIS.qnameToURI> ($typeq, %opt);
          }__;
          $forURI = defined $defaultForURI ? $defaultForURI
                                           : <Q::ManakaiDOM:all>;
        }
        __CODE{tfurisToURI:: $turi => $typeURI, $furi => $forURI, $uri => $r}__;

  @Method:
    @@Name: tfpqnamesToURI
    @@Description:
      @@@lang:en
      @@@@:
        Converts a <Q::DISCore:TFPQNames>
        into an expanded URI reference. 
    @@Param:
      @@@Name: tfpqnames
      @@@Type: 
        DISCore:TFPQNames::ManakaiDOM:all
      @@@Description:
        @@@@lang:en
        @@@@@:
          A <Q::DISCore:TFPQNames> to identify a resource. 
    @@Param:
      @@@Name: defaultTypeURI
      @@@Type: NameURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          A name URI reference used if it is missing from 
          <P::tfqnames>. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            Equivalent to <Q::DOMMain:any>. 
    @@Param:
      @@@Name: defaultForURI
      @@@Type: ForURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          A <QUOTE::for> URI reference used if it is missing from 
          <P::tfqnames>. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            Equivalent to <QUOTE::for all>, i.e. <Q::ManakaiDOM:all>. 
    @@NodeParam:
    @@Return:
      @@@Type: 
        DISCore:TFURI::ManakaiDOM:all
      @@@Description:
        @@@@lang:en
        @@@@@:
          The <Q::dis:TFQNames>-expanded URI references.  
      @@@UndeclaredPrefixException:
      @@@PerlDef:
        my ($typeq, $forq, @forpq) = split /\s*[:|][:|]\s*/, $tfpqnames;
        my ($typeURI, $forURI);
        my $forpURI = [];
        undef $forq if defined $forq and $forq eq '+';
        if (defined $forq) {
          __DEEP{
            $typeURI = $typeq eq ''
                       ? defined $defaultTypeURI ? $defaultTypeURI
                                                 : <Q::DOMMain:any>
                       : $self-><M::NSResolverDIS.qnameToURI> ($typeq, %opt);
            if (length $forq) {
              $forURI = $self-><M::NSResolverDIS.qnameToURI> ($forq, %opt);
            } else {
              $forURI = <Q::ManakaiDOM:all>;
            }
          }__;
        } else {  ## "For" omitted
          __DEEP{
            $typeURI = $typeq eq ''
                       ? defined $defaultTypeURI ? $defaultTypeURI
                                                 : <Q::DOMMain:any>
                       : $self-><M::NSResolverDIS.qnameToURI> ($typeq, %opt);
          }__;
          $forURI = defined $defaultForURI ? $defaultForURI
                                           : <Q::ManakaiDOM:all>;
        }
        __DEEP{
          for my $forpq (@forpq) {
            push @$forpURI, $self-><M::NSResolverDIS.qnameToURI>
                                                 ($forpq, %opt);
          }
        }__;
        __CODE{tfpurisToURI:: $turi => $typeURI, $furi => $forURI,
                              $forp => $forpURI,  $uri => $r}__;
##NSResolverDIS

PropDef:
  @QName: defaultNamespaceURI
  @enDesc:
    Default namespace URI for an element.

IFClsDef:
  @IFQName: DISElement
  @ClsQName: ManakaiDISElement

  @ClsISA: ManakaiNSResolverDIS
  @ClsISA: ManakaiDISNode
  @ClsISA:
    swcfg21:ManakaiSWCFGElement::swcfg21:ForLatest
  @ClsISA: dp|ManakaiDISElementPerl

  @Description:
    @@lang:en
    @@@:
      <QUOTE::dis> element node objects. 

  @DISLang:role: ElementRole

  @Method:
    @@Name: forMatch
    @@Description:
      @@@lang:en
      @@@@:
        Tests whether this element is for a <QUOTE::for> or not. 
    @@Param:
      @@@Name: forArg
      @@@Type: ForURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          The <QUOTE::For> URI reference to test against. 
    @@Param:
      @@@Name: forpArg
      @@@Type: ForURIList
      @@@Description:
        @@@@lang:en
        @@@@@:
          The <QUOTE::For+> URI references to test against. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            No additional <QUOTE::For> URI reference. 
            Equivalent to an empty array reference. 
    @@Return:
      @@@Type:
        DOMMain:boolean::ManakaiDOM:all
      @@@Description:
        @@@@lang:en
        @@@@@:
          Whether this element is for <P::forArg> and <P::forpArg> or not. 
      @@@UndeclaredPrefixException:
      @@@NoDBException:
      @@@PerlDef:
        $forArg = <Q::ManakaiDOM:all> unless defined $forArg;
        $forpArg ||= [];

        FORMATCH: {
          __DEEP{
            my $for_res = $self-><AG::ManakaiDISNode.ownerDISDocument>
                                   -><AG::ManakaiDISDocument.disDatabase>
                                   -><M::ManakaiDISDatabase.getFor> ($forArg);
            my $forp_res = [map {
                                  $self-><AG::ManakaiDISNode.ownerDISDocument>
                                       -><AG::ManakaiDISDocument.disDatabase>
                                       -><M::ManakaiDISDatabase.getFor> ($_)
                                } @{$forpArg}];

            my @ce = @{$self-><M::ManakaiDISElement.disAllChildElements>};
            for my $ce (@ce) {
              my $et = $ce-><AG::swcfg21:SWCFGElement::swcfg21:ForLatest
                                                      .expandedURI>;
              if ($et eq <Q::dis:ForCheck>) {
                my $fors = [split /\s+/, $ce-><M::swcfg21:SWCFGNode
                                                ::swcfg21:ForLatest.value>];
                FCs: for my $f (@$fors) {
                  if ($f =~ /^!=(.+)$/) {        ## -- NOT EQUAL TO
                    my $uri = $self-><M::NSResolverDIS.qnameToURI> ($1);
                    my $for = $self-><AG::ManakaiDISNode.ownerDISDocument>
                                   -><AG::ManakaiDISDocument.disDatabase>
                                   -><M::ManakaiDISDatabase.getFor> ($uri);
                    $for-><AS::DISAnyResource.isReferred> ($ce);
                    for my $arg_res ($for_res, @{$forp_res}) {
                      if ($arg_res eq $for) {
                        $r = false;
                        last FORMATCH;
                      }
                    }
                  } elsif ($f =~ /^!(.+)$/) {    ## -- NOT ISA
                    my $uri = $self-><M::NSResolverDIS.qnameToURI> ($1);
                    my $for = $self-><AG::ManakaiDISNode.ownerDISDocument>
                                   -><AG::ManakaiDISDocument.disDatabase>
                                   -><M::ManakaiDISDatabase.getFor> ($uri);
                    $for-><AS::DISAnyResource.isReferred> ($ce);
                    for my $arg_res ($for_res, @{$forp_res}) {
                      if ($arg_res-><M::DISFor.isaURI> ($uri)) {
                        $r = false;
                        last FORMATCH;
                      }
                    }
                  } elsif ($f =~ /^=(.+)$/) {    ## -- EQUAL TO
                    my $uri = $self-><M::NSResolverDIS.qnameToURI> ($1);
                    my $for = $self-><AG::ManakaiDISNode.ownerDISDocument>
                                   -><AG::ManakaiDISDocument.disDatabase>
                                   -><M::ManakaiDISDatabase.getFor> ($uri);
                    $for-><AS::DISAnyResource.isReferred> ($ce);
                    for my $arg_res ($for_res, @{$forp_res}) {
                      if ($arg_res eq $for) {
                        next FCs;
                      }
                    }
                    $r = false;
                    last FORMATCH;
                  } else {                       ## -- ISA
                    my $uri = $self-><M::NSResolverDIS.qnameToURI> ($f);
                    my $for = $self-><AG::ManakaiDISNode.ownerDISDocument>
                                   -><AG::ManakaiDISDocument.disDatabase>
                                   -><M::ManakaiDISDatabase.getFor> ($uri);
                    $for-><AS::DISAnyResource.isReferred> ($ce);
                    for my $arg_res ($for_res, @{$forp_res}) {
                      if ($arg_res-><M::DISFor.isaURI> ($uri)) {
                        next FCs;
                      }
                    }
                    $r = false;
                    last FORMATCH;
                  }
                } # FCs
              } # dis:ForCheck
            } # children

            my $has_for = false;
            for my $ce (@ce) {
              if ($ce-><AG::swcfg21:SWCFGElement::swcfg21:ForLatest
                                                     .expandedURI> eq
                  <Q::dis:For>) {
                my $fors = [split /\s+/, $ce-><M::swcfg21:SWCFGNode
                                                ::swcfg21:ForLatest.value>];
                my $ok = true;
                $has_for = true;
                AFOR: for my $f (@$fors) {
                  if ($f =~ /^!=(.+)$/) {         ## -- NOT EQUAL TO
                    my $uri = $self-><M::NSResolverDIS.qnameToURI> ($1);
                    my $for = $self-><AG::ManakaiDISNode.ownerDISDocument>
                                   -><AG::ManakaiDISDocument.disDatabase>
                                   -><M::ManakaiDISDatabase.getFor> ($uri);
                    $for-><AS::DISAnyResource.isReferred> ($ce);
                    if ($for eq $for_res) {
                      $ok = false;
                      last AFOR;
                    }
                  } elsif ($f =~ /^!(.+)$/) {     ## -- NOT ISA
                    my $uri = $self-><M::NSResolverDIS.qnameToURI> ($1);
                    my $for = $self-><AG::ManakaiDISNode.ownerDISDocument>
                                   -><AG::ManakaiDISDocument.disDatabase>
                                   -><M::ManakaiDISDatabase.getFor> ($uri);
                    $for-><AS::DISAnyResource.isReferred> ($ce);
                    if ($for_res-><M::ManakaiDISForDefinition.isaURI> ($uri)) {
                      $ok = false;
                      last AFOR;
                    }
                  } elsif ($f =~ /^=(.+)$/) {     ## -- EQUAL TO
                    my $uri = $self-><M::NSResolverDIS.qnameToURI> ($1);
                    my $for = $self-><AG::ManakaiDISNode.ownerDISDocument>
                                   -><AG::ManakaiDISDocument.disDatabase>
                                   -><M::ManakaiDISDatabase.getFor> ($uri);
                    $for-><AS::DISAnyResource.isReferred> ($ce);
                    unless ($for eq $for_res) {
                      $ok = false;
                      last AFOR;
                    }
                  } else {                        ## -- ISA
                    my $uri = $self-><M::NSResolverDIS.qnameToURI> ($f);
                    my $for = $self-><AG::ManakaiDISNode.ownerDISDocument>
                                   -><AG::ManakaiDISDocument.disDatabase>
                                   -><M::ManakaiDISDatabase.getFor> ($uri);
                    $for-><AS::DISAnyResource.isReferred> ($ce);
                    unless ($for_res-><M::ManakaiDISForDefinition.isaURI>($uri)){
                      $ok = false;
                      last AFOR;
                    }
                  }
                } # AFOR
                if ($ok) {
                  $r = true;
                  last FORMATCH;
                }
              } # dis:For
            } # $ce
            $r = $has_for ? false : true;
          }__;
        } # FORMATCH

  @Method:
    @@Name: mediaTypeMatch
    @@Description:
      @@@lang:en
      @@@@:
        Tests whether the content media type of this element matches to 
        a type or not. 
    @@Param:
      @@@Name: mediaType
      @@@Type: MediaTypeURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          A media type URI reference to test against. 
    @@Param:
      @@@Name: defaultMediaType
      @@@Type: MediaTypeURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          The default media type for this element. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            No default type provided.  All <P::mediaType> will match. 
    @@ForParam:
    @@ForpParam:
    @@Return:
      @@@Type:
        DOMMain:boolean::ManakaiDOM:all
      @@@Description:
        @@@@lang:en
        @@@@@:
          Whether this element is of <P::mediaType> or not. 
      @@@PerlDef:
        if (defined $mediaType) {
          __DEEP{
            my $ctn = $self-><M::ManakaiDISElement.disGetAttribute>
                                  (<Q::dis:ContentType>, for_arg => $forArg,
                                   forp_arg => $forpArg);
            my $ct;
            $ct = $ctn-><AG::DISElement.qnameValueURI> if $ctn;
            $ct = $defaultMediaType unless defined $ct;
            my $res = $self-><AG::ManakaiDISNode.ownerDISDocument>
                                 -><AG::ManakaiDISDocument.disDatabase>
                                 -><M::ManakaiDISDatabase.getResource> ($ct);
            $res-><AS::DISAnyResource.isReferred> ($ctn or $self);
            unless ($res-><M::ManakaiDISResourceDefinition
                                               .isSubsetOfURI> ($mediaType)) {
              $r = false;
            } else {
              $r = true;
            }
          }__;
        } else {
          $r = true;
        }

  @Method:
    @@Name:mediaTypeURI
    @@enDesc:
      The URI reference of the media type of this element. 
    @@Type: MediaTypeURI
    @@NamedParam:
      @@@Name:defaultMediaType
      @@@Type:MediaTypeURI
      @@@enDesc:
        The default media type URI reference. 
      @@@nullCase:
        @@@@enDesc:
          No default is specified. 
    @@ForParam:
    @@ForpParam:
    @@Return:
      @@@enDesc:
        The media type URI reference of this element. 
      @@@nullCase:
        @@@@enDesc:
          This element has no media type information and 
          <P::defaultMediaType> parameter is not provided. 
      @@@UndeclaredPrefixException:
      @@@PerlDef:
          __DEEP{
            $r = $defaultMediaType;
            my $ctn = $self-><M::ManakaiDISElement.disGetAttribute>
                                (<Q::dis:ContentType>, for_arg => $forArg,
                                 forp_arg => $forpArg);
            $r = $ctn-><AG::DISElement.qnameValueURI> if $ctn;
          }__;

  @Method:
    @@Name: disGetAttribute
    @@enDesc:
      Gets an attribute node. 
    @@Param:
      @@@Name: attrName
      @@@Type: AnyURI
      @@@enDesc:
        The name expanded URI of the node to retrieve. 
    @@ForParam:
    @@ForpParam:
    @@MediaTypeParam:
    @@MediaTypeDefaultParam:
    @@Return:
      @@@Type: DISElement
      @@@clsActualType: ManakaiDISElement
      @@@enDesc:
        The attribute (property) element node. 
      @@@nullCase:
        @@@@enDesc:
          No attribute node found. 
      @@@PerlDef:
        C: for my $c (@{$self-><M::ManakaiDISElement.disChildElements>
                                  (for_arg => $forArg, forp_arg => $forpArg)}) {
          if ($c-><AG::swcfg21:SWCFGElement::swcfg21:ForLatest
                                    .expandedURI> eq $attrName and
              $c-><M::ManakaiDISElement.mediaTypeMatch>
                                  ($mediaType, $defaultMediaType,
                                   for_arg => $forArg, forp_arg => $forpArg)) {
            $r = $c;
            last C;
          }
        }

  @Method:
    @@Name: disGetAttributeList
    @@enDesc:
      Gets attribute nodes. 
    @@Param:
      @@@Name: attrName
      @@@Type: AnyURI
      @@@enDesc:
        The name expanded URI of the node to retrieve. 
    @@ForParam:
    @@ForpParam:
    @@MediaTypeParam:
    @@MediaTypeDefaultParam:
    @@Return:
      @@@Type: DISElementList
      @@@clsActualType: ManakaiDISElementList
      @@@enDesc:
        The attribute (property) element nodes. 
      @@@PerlDef:
        $r = bless [], <ClassName::ManakaiDISElementList>;
        for my $c (@{$self-><M::ManakaiDISElement.disChildElements>
                                  (for_arg => $forArg, forp_arg => $forpArg)}) {
          if ($c-><AG::swcfg21:SWCFGElement::swcfg21:ForLatest
                                          .expandedURI> eq $attrName and
              $c-><M::ManakaiDISElement.mediaTypeMatch>
                                  ($mediaType, $defaultMediaType,
                                   for_arg => $forArg, forp_arg => $forpArg)) {
            push @$r, $c;
          }
        }

  @Method:
    @@Name: disChildElements
    @@enDesc:
      A list of child elements, with <QUOTE::for> check.  
    @@ForParam:
    @@ForpParam:
    @@Return:
      @@@Type: DISElementList
      @@@clsActualType: ManakaiDISElementList
      @@@enDesc:
        The current snapshot of child nodes. 
      @@@PerlDef:
        $r = bless [], <ClassName::ManakaiDISElementList>;    
        __DEEP{
          C: for my $cn (@{$self-><AG::swcfg21:SWCFGNode::swcfg21:ForLatest
                                                       .childNodes>}) {
            ## $cn is an #element.
            my $dn;
            __CODE{ManakaiNode|getNewReference||ManakaiDOM|Perl::
              $object => {$cn->{<Q::TreeCore:node>}},
              $ref => $dn,
              $class => {<ClassName::ManakaiDISElement>},
            }__;
            next C unless $dn-><M::ManakaiDISElement.forMatch>
                                      ($forArg, $forpArg);
            push @$r, $dn;
          }
        }__;

  @Method:
    @@Name: disAllChildElements
    @@enDesc:
      A list of child elements, without <QUOTE::for> check.  
    @@Return:
      @@@Type: DISElementList
      @@@clsActualType: ManakaiDISElementList
      @@@enDesc:
        The current snapshot of child nodes. 
      @@@PerlDef:
        $r = bless [], <ClassName::ManakaiDISElementList>;    
        __DEEP{
          for my $cn (@{$self-><AG::swcfg21:SWCFGNode::swcfg21:ForLatest
                                                       .childNodes>}) {
            ## $cn is an #element.
            my $dn;
            __CODE{ManakaiNode|getNewReference||ManakaiDOM|Perl::
              $object => {$cn->{<Q::TreeCore:node>}},
              $ref => $dn,
              $class => {<ClassName::ManakaiDISElement>},
            }__;
            push @$r, $dn;
          }
        }__;

  @Attr:
    @@Name: qnameValueURI
    @@enDesc:
      The element value (written as <Q::dis:TypeQName>), as URI reference. 
      \
      {NOTE:: What should be if list value?
      \
      }
    @@Get:
      @@@Type:AnyURI
      @@@nullCase:
        @@@@enDesc:
          No value. 
      @@@UndeclaredPrefixException:
      @@@PerlDef:
        __DEEP{
          my $v = $self-><M::swcfg21:SWCFGNode::swcfg21:ForLatest.value>;
          if (defined $v and not ref $v eq 'ARRAY') {
            $r = $self-><M::NSResolverDIS.qnameToURI> ($v, node => $self);
          } else {
            $r = null;
          }
        }__;

  @Attr:
    @@Name: qnameValueLocalName
    @@enDesc:
      The local name part of the element value (assumed as 
      written as <Q::dis:TypeQName>). 
      \
      {NOTE:: What should be if list value?
      \
      }
    @@Get:
      @@@Type:
        DISCore:LocalName::ManakaiDOM:all
      @@@nullCase:
        @@@@enDesc:
          No value. 
      @@@PerlDef:
        __DEEP{
          my $v = $self-><M::swcfg21:SWCFGNode::swcfg21:ForLatest.value>;
          if (defined $v and not ref $v eq 'ARRAY') {
            my ($n, $v) = split /\s*[:|]\s*/, $v, 2;
            $r = defined $v ? $v : $n;
          } else {
            $r = null;
          }
        }__;

  @Attr:
    @@Name: qnameValuePrefix
    @@enDesc:
      The prefix part of the element value (assumed as 
      written as <Q::dis:TypeQName>). 
      \
      {NOTE:: What should be if list value?
      \
      }
    @@Get:
      @@@Type:
        DISCore:NamespacePrefix::ManakaiDOM:all
      @@@nullCase:
        @@@@enDesc:
          No value. 
      @@@PerlDef:
        __DEEP{
          my $v = $self-><M::swcfg21:SWCFGNode::swcfg21:ForLatest.value>;
          if (defined $v and not ref $v eq 'ARRAY') {
            my ($p, $l) = split /\s*[:|]\s*/, $v, 2;
            $r = defined $l ? $p : null;
          } else {
            $r = null;
          }
        }__;

  @Attr:
    @@Name: qnameValueNamespaceURI
    @@enDesc:
      The namespace URI of the element value (assumed as written 
      in <Q::dis:TypeQName>). 
      \
      {NOTE:: What should be if list value?
      \
      }
    @@Get:
      @@@Type:AnyURI
      @@@nullCase:
        @@@@enDesc:
          No value. 
      @@@UndeclaredPrefixException:
      @@@PerlDef:
        __DEEP{
          my $v = $self-><M::swcfg21:SWCFGNode::swcfg21:ForLatest.value>;
          if (defined $v and not ref $v eq 'ARRAY') {
            my ($p, $v) = split /\s*[:|]\s*/, $v, 2;
            $r = $self-><M::NSResolverDIS.prefixToURI>
                                            (defined $v ? $p : null);
          } else {
            $r = null;
          }
        }__;

  @Method:
    @@Name: tfqnamesValueURI
    @@enDesc:
      The element value (written as <Q::dis:TFQNames>),
      as URI reference. 
      \
      {NOTE:: What should be if list value?
      \
      }
    @@Param:
      @@@Name: defaultTypeURI
      @@@Type: NameURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          A name URI reference used if it is missing from 
          <P::tfqnames>. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            Equivalent to <Q::DOMMain:any>. 
    @@Param:
      @@@Name: defaultForURI
      @@@Type: ForURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          A <QUOTE::for> URI reference used if it is missing from 
          <P::tfqnames>. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            Equivalent to <QUOTE::for all>, i.e. <Q::ManakaiDOM:all>. 
    @@ForParam:
    @@ForpParam:
    @@Return:
      @@@Type:ResourceURI
      @@@nullCase:
        @@@@enDesc:
          No value. 
      @@@UndeclaredPrefixException:
      @@@PerlDef:
        my $v = $self-><M::swcfg21:SWCFGNode::swcfg21:ForLatest.value>;
        if (defined $v and not ref $v eq 'ARRAY') {
          __DEEP{
            if ($self-><M::ManakaiDISElement.mediaTypeMatch>
                                 (<Q::DISCore:TFPQNames>, <Q::DISCore:TFPQNames>,
                                  for_arg => $forArg, forp_arg => $forpArg)) {
              $r = $self-><M::NSResolverDIS.tfpqnamesToURI>
                                  ($v, $defaultTypeURI, $defaultForURI,
                                   node => $self);
            } else {
              $r = $self-><M::NSResolverDIS.tfqnamesToURI>
                                  ($v, $defaultTypeURI, $defaultForURI,
                                   node => $self);
            }
          }__;
        } else {
          $r = null;
        }

  @Method:
    @@Name: elementTypeMatch
    @@enDesc:
      Returns whether the element type of this element matches 
      with another element type (either the same element type or
      this type is a subtype of another type). 
    @@Param:
      @@@Name: etype
      @@@Type: ResourceURI
      @@@enDesc:
        An element type name URI reference to test. 
    @@Return:
      @@@Type:
        DOMMain:boolean::ManakaiDOM:all
      @@@TrueCase:
        @@@@enDesc:
          Either the element type expanded URI reference of this element is 
          same as <P::etype> or it is a sub-element type of <P::etype>. 
      @@@FalseCase:
        @@@@enDesc:
          This element is not of <P::etype>. 
      @@@NoDBException:
      @@@PerlDef:
        __DEEP{
          my $et = $self-><AG::swcfg21:SWCFGElement::swcfg21:ForLatest
                                                          .expandedURI>;
          my $rdef = $self-><AG::ManakaiDISNode.ownerDISDocument>
                                   -><AG::ManakaiDISDocument.disDatabase>
                                   -><M::ManakaiDISDatabase.getResource> ($et);
          $r = $rdef-><M::ManakaiDISResourceDefinition.isSubsetOfURI> ($etype);
        }__;

  @Attr:
    @@Name: isResourceElement
    @@enDesc:
      Whether this element defines a resource or not. 
      \
      {NOTE:: An element defines a resource if its element type is 
              <Q::dis:ResourceDef> or its subtype.
      \
      }
    @@Get:
      @@@Type:
        DOMMain:boolean::ManakaiDOM:all
      @@@TrueCase:
        @@@@enDesc:
          This element defines a resource. 
      @@@FalseCase:
        @@@@enDesc:
          This element does not define any resource.
      @@@NoDBException:
      @@@PerlDef:
        __DEEP{
          $r = $self-><M::ManakaiDISElement.elementTypeMatch>
                                                (<Q::dis:ResourceDef>);
        }__;

  @Attr:
    @@Name: isPropertyElement
    @@enDesc:
      Whether this element is a property or not. 
      \
      {NOTE:: An element is a property if its element type is
              <Q::rdf:type> or if its element type's <Q::rdf:type> 
              property is <Q::rdf:Property> or is <Q::dis:subsetOf> 
              <Q::rdf:Property>. 
      \
      }
    @@Get:
      @@@Type:
        DOMMain:boolean::ManakaiDOM:all
      @@@TrueCase:
        @@@@enDesc:
          This element is a property.
      @@@FalseCase:
        @@@@enDesc:
          This element is not a property. 
      @@@NoDBException:
      @@@PerlDef:
        __DEEP{
          my $xn = $self-><AG::SWCFGElement.expandedURI>;
          if ($xn eq <Q::rdf:type>) {
            $r = true;
          } else {
            my $rdef = $self-><AG::DISNode.ownerDISDocument>
                            -><AG::DISDocument.disDatabase>
                            -><M::DISDatabase.getResource> ($xn);
            $r = $rdef-><M::DISResource.isTypeURI> (<Q::rdf:Property>);
          }
        }__;

  @Method:
     @@Name:  getFeature
     @@Description:
        @@@lang:en
        @@@@:
          Returns a specialized object that implements the specialized 
          interfaces of the specified feature and version.
     @@Param:
        @@@Name:  feature
        @@@Type: swcfg21|SWCFGString||swcfg21|ForLatest
        @@@actualType: DOMFeature|FeatureNameString||ManakaiDOM|ManakaiDOMLatest
        @@@Description:
          @@@@lang:en
          @@@@@:
            A feature name to request.
     @@Param:
        @@@Name:  version
        @@@Type: swcfg21|SWCFGString||swcfg21|ForLatest
        @@@actualType:
          DOMFeature|FeatureVersionString||ManakaiDOM|ManakaiDOMLatest
        @@@Description:
          @@@@lang:en
          @@@@@:
            A feature version number to request.
     @@Return:
        @@@Type:  
          DOMMain:Object::ManakaiDOM:all
        @@@Description:
          @@@@lang:en
          @@@@@:
            An object that implements the specialized APIs of the 
            <P::feature> and <P::version>.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@@: 
            There is no object available that implements interfaces 
            associated with the <P::feature> and <P::version>. 
        @@@PerlDef:
            $feature =~ s/^\+//;
            CLASS: for my $class (grep {
              $Message::Util::DIS::ManakaiDISElement::CompatClass{$_}
            } keys %Message::Util::DIS::ManakaiDISElement::CompatClass) {
              if ($Message::DOM::ClassFeature{$class}->{$feature}->{$version}) {
                __CODE{ManakaiNode|getNewReference||ManakaiDOM|Perl::
                  $object => {$self->{<Q::TreeCore:node>}},
                  $ref => $r,
                  $class => $class,
                }__;
                last CLASS;
              }
            }

  @Method:
    @@Name: unlinkFromDocument
    @@enDesc:
      Removes any relationship to this node from the owner document tree.
      In addition, namespace bindings are copied from the document.
      The node <kwd:MUST> be a cloned one (or just newly created one)
      so that it does not have any parent-child relationship.
    
      {NOTE:: Once a subtree has removed from the document, the nodes
              belongs to the subtree can't be part of any document anymore.
      }
    @@Return:
      @@@PerlDef:
        __DEEP{
          my $db;
          try {
            $db = $self-><AG::ManakaiDISNode.ownerDISDocument>
                       -><AG::ManakaiDISDocument.disDatabase>;
          } catch <IF::DISException> with {
            my $err = shift;
            $err->throw
              unless $err->{<Q::MDOMX:subtype>} eq <Q::NO_ASSOCIATED_DB_ERR>;
          };
          $self->{<Q::TreeCore:node>}->{<Q::DIS|defaultNamespaceURI>}
            = $self-><AG::ManakaiDISNode.ownerDISDocument>
                   -><AG::ManakaiDISDocument.moduleElement>
                   -><AG::ManakaiDISModuleElement.definingNamespaceURI>;
          my $ods = $self->{<Q::TreeCore:node>}->{<Q::swcfg21:ownerDocument>};
          CORE::delete $self->{<Q::TreeCore:node>}->{<Q::swcfg21:ownerDocument>};
          $self->{<Q::TreeCore:node>}-><M::ManakaiNode|NodeStem||ManakaiDOM|Perl
               .orphanate>;
          if ($db) {
            for my $mod_uri (keys %{$db->{modDef}}) {
              my $mod = $db-><M::DISDatabase.getModule> ($mod_uri);
              $self->{<Q::TreeCore:node>}->{<Q::swcfg21:nsBinding>}
                   ->{$mod-><AG::DISAnyResource.localName>}
                = $mod-><M::DISResourceProp.getPropertyText>
                    (<Q::dis:Namespace>, null);
            }
          }
          for my $prefix (keys %{$ods->{<Q::swcfg21:nsBinding>}}) {
            $self->{<Q::TreeCore:node>}->{<Q::swcfg21:nsBinding>}->{$prefix}
              = $ods->{<Q::swcfg21:nsBinding>}->{$prefix};
          }
        }__;

  @Method:
    @@Name: preserveNodePath
    @@enDesc:
      Saves a copy of node path string.
    @@Return:
      @@@PerlDef:
        __DEEP{
          $self-><M::SWCFGNode.flag> (nodePath => $self-><M::SWCFGNode.nodePath>
            (key => [qw/QName Name Type type/]));
        }__;

  @Method:
    @@Operator:
      @@@ContentType:
        dis:TypeQName
      @@@@:
        DISPerl:CloneMethod
    @@Description:
      @@@lang:en
      @@@@:
        Makes a copy of this node.  All child nodes are cloned and
        all flags and options are copied (rather than cloned).
        The new node does not have any parent.
    @@Return:
      @@@Type: DISElement
      @@@Description:
        @@@@lang:en
        @@@@@:
          The cloned node.
          \
          If this node is a document node, then the another document is made.
      @@@PerlDef:
        $r = bless $self->SUPER::clone, <ClassName::ManakaiDISElement>;
##DISElement

IFClsDef:
  @IFQName: DISModuleElement
  @ClsQName: ManakaiDISModuleElement

  @IFISA: DISElement
  @ClsISA: ManakaiDISElement

  @enDesc:
    The <Q::dis:Module> elements. 

  @DISLang:role:
    @@@:
      DISLang:NullRole
    @@DISCore:stopISARecursive:1

  @Attr:
    @@Name: requireElement
    @@enDesc:
      The <Q::dis:Require> child element.  The element is 
      newly created if not exist. 
    @@Type: DISElement
    @@clsActualType: ManakaiDISElement
    @@Get:
      @@@PerlDef:
        __DEEP{
          $r = bless $self-><M::swcfg21:SWCFGNode
                        ::swcfg21:ForLatest.getAttributeNS>
                                   (<Q::dis:>, 'Require', make_new_node => true),
                     <ClassName::ManakaiDISElement>;
        }__;

  @Attr:
    @@Name: defaultForURI
    @@enDesc:
      The value of <Q::dis:DefaultFor> attribute. 
    @@Type: ForURI
    @@Get:
      @@@enDesc:
        The value of <Q::dis:DefaultFor> child element.  If missing, 
        <Q::ManakaiDOM:all> is returned. 
      @@@PerlDef:
        __DEEP{
          my $df = $self-><M::swcfg21:SWCFGNode::swcfg21:ForLatest
                                .getAttributeNS>
                                         (<Q::dis:>, 'DefaultFor');
          if ($df) {
            $r = (bless $df, <ClassName::ManakaiDISElement>)
                 -><AG::DISElement.qnameValueURI>
              || <Q::ManakaiDOM:all>;
          } else {
            $r = <Q::ManakaiDOM:all>;
          }
        }__;
    @@Set:
      @@@PerlDef:
        __DEEP{
          $self-><M::swcfg21:SWCFGNode::swcfg21:ForLatest.setAttributeNS>
                                     (<Q::dis:>, 'DefaultFor' => $given);
        }__;

  @Attr:
    @@Name: definingNamespaceURI
    @@enDesc:
      The value of <Q::dis:Namespace> attribute, i.e. 
      the URI reference of the namespace that this module primary 
      defines.
      \
      {NOTE:: Defining namespace URI is <QUOTE::for> independent. 
      \
      }
    @@Type: AnyURI
    @@Get:
      @@@PerlDef:
        __DEEP{
          my $df = $self-><M::swcfg21:SWCFGNode::swcfg21:ForLatest
                                .getAttributeNS>
                                         (<Q::dis:>, 'Namespace');
          if ($df) {
            $r = $df-><M::swcfg21:SWCFGNode::swcfg21:ForLatest.value>;
          } else {
            __ASSERT{DISPerl:invariant::
              msg => {qq["dis:Namespace" attribute not found]},
            }__;
          }
        }__;
    @@Set:
      @@@PerlDef:
        __DEEP{
          $self-><M::swcfg21:SWCFGNode::swcfg21:ForLatest.setAttributeNS>
                                     (<Q::dis:>, 'Namespace' => $given);
        }__;
##DISModuleElement

IFClsDef:
  @IFQName: DISElementList
  @ClsQName: ManakaiDISElementList

  @enDesc:
    @@lang:en
    @@@:
      Lists of elements. 
      \
      {NOTE:: <Class::ManakaiDISElementList> is <QUOTE::dead>; 
              later changes to the tree does not affect this type of objects. 
      \
      }
##DISElementList

IFClsDef:
  @IFQName: DISComment
  @ClsQName: ManakaiDISComment

  @ClsISA: ManakaiDISNode
  @ClsISA:
    swcfg21:ManakaiSWCFGComment::swcfg21:ForLatest

  @Description:
    @@lang:en
    @@@:
      <QUOTE::dis> comment node objects. 
##DISComment

IFClsDef:
  @IFQName: DISDocumentFragment
  @ClsQName: ManakaiDISDocumentFragment

  @ClsISA: ManakaiDISNode
  @ClsISA:
    swcfg21:ManakaiSWCFGDocumentFragment::swcfg21:ForLatest

  @Description:
    @@lang:en
    @@@:
      <QUOTE::dis> document fragment node objects. 
##DISDocumentFragment

IFClsDef:
  @IFQName: DISDocument
  @ClsQName: ManakaiDISDocument

  @ClsISA: ManakaiDISNode
  @ClsISA:
    swcfg21:ManakaiSWCFGDocument::swcfg21:ForLatest

  @Description:
    @@lang:en
    @@@:
      <QUOTE::dis> document node objects. 

  @Attr:
    @@Name: moduleElement
    @@enDesc:
      The <Q::dis:Module> element in this document.  The element is 
      newly created if not exist. 
    @@Type: DISModuleElement
    @@clsActualType: ManakaiDISModuleElement
    @@Get:
      @@@PerlDef:
        __DEEP{
          $r = $self-><M::swcfg21:SWCFGNode
                        ::swcfg21:ForLatest.getAttributeNS>
                                   (<Q::dis:>, 'Module', make_new_node => true);
        }__;
        $r = bless $r, <ClassName::ManakaiDISModuleElement>;

  @Attr:
    @@Name: disDatabase
    @@enDesc:
      Associated <QUOTE::dis> database. 

    @@Type: DISDatabase
    @@clsActualType: ManakaiDISDatabase
    @@Get:
      @@@NoDBException:
      @@@PerlDef:
        if ($self->{<Q::TreeCore:node>}->{<Q::db>}) {
          $r = $self->{<Q::TreeCore:node>}->{<Q::db>};
        } else {
          __EXCEPTION{NO_ASSOCIATED_DB_ERR}__;
        }
    @@Set:
      @@@PerlDef:
        $self->{<Q::TreeCore:node>}->{<Q::db>} = $given;
        require Scalar::Util;
        Scalar::Util::weaken ($self->{<Q::TreeCore:node>}->{<Q::db>});

  @Method:
    @@Name: disChildElements
    @@enDesc:
      A list of child elements, with <QUOTE::for> checks.  
    @@ForParam:
    @@ForpParam:
    @@Return:
      @@@Type: DISElementList
      @@@clsActualType: ManakaiDISElementList
      @@@enDesc:
        The current snapshot of child nodes. 
      @@@PerlDef:
        $r = bless [], <ClassName::ManakaiDISElementList>;    
        __DEEP{
          C: for my $cn (@{$self-><AG::swcfg21:SWCFGNode::swcfg21:ForLatest
                                                       .childNodes>}) {
            next C unless $cn-><AG::swcfg21:SWCFGNode::swcfg21:ForLatest
                                              .nodeType> eq '#element';
            my $dn;
            __CODE{ManakaiNode|getNewReference||ManakaiDOM|Perl::
              $object => {$cn->{<Q::TreeCore:node>}},
              $ref => $dn,
              $class => {<ClassName::ManakaiDISElement>},
            }__;
            next C unless $dn-><M::ManakaiDISElement.forMatch>
                                              ($forArg, $forpArg);
            push @$r, $dn;
          }
        }__;

  @Method:
    @@Name: disAllChildElements
    @@enDesc:
      A list of child elements, without <QUOTE::for> checks.  
    @@Return:
      @@@Type: DISElementList
      @@@clsActualType: ManakaiDISElementList
      @@@enDesc:
        The current snapshot of child nodes. 
      @@@PerlDef:
        $r = bless [], <ClassName::ManakaiDISElementList>;    
        __DEEP{
          C: for my $cn (@{$self-><AG::swcfg21:SWCFGNode::swcfg21:ForLatest
                                                       .childNodes>}) {
            next C unless $cn-><AG::swcfg21:SWCFGNode::swcfg21:ForLatest
                                              .nodeType> eq '#element';
            my $dn;
            __CODE{ManakaiNode|getNewReference||ManakaiDOM|Perl::
              $object => {$cn->{<Q::TreeCore:node>}},
              $ref => $dn,
              $class => {<ClassName::ManakaiDISElement>},
            }__;
            push @$r, $dn;
          }
        }__;
##DISDocument

PropDef:
  @QName: db
  @enDesc:
    Associated <QUOTE::dis> database. 
  @rdfs:domain: ManakaiDISDocument
  @rdfs:range: ManakaiDISDatabase

## -- Definition object database

IFClsDef:
  @IFQName: DISDatabase
  @ClsQName: ManakaiDISDatabase

  @ClsISA: dp|ManakaiDISDatabasePerl
  @ClsISA: ManakaiDISExceptionTarget

  @enDesc:
    Resource database created from <QUOTE::dis> source data. 

  @DISLang:role: DatabaseRole

  @Method:
    @@Name: getModule
    @@Description:
      @@@lang:en
      @@@@:
        Returns a <QUOTE::dis> module definition. 
    @@Param:
      @@@Name: moduleURI
      @@@Type: ModuleURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          A <QUOTE::dis> module URI reference. 
    @@ForParam:
    @@Return:
      @@@Type: DISModule
      @@@clsActualType: ManakaiDISModuleDefinition
      @@@Description:
        @@@@lang:en
        @@@@@:
          The module definition. 
      @@@PerlDef:
        my $modURI;
        if (defined $forArg) {
          __CODE{tfurisToURI:: $turi => $moduleURI, $furi => $forArg,
                               $uri => $modURI}__;
        } else {
          $modURI = $moduleURI;
        }
        if (defined $self->{modDef}->{$modURI}) {
          $r = $self->{modDef}->{$modURI};
        } else {
          $r = $self->{modDef}->{$modURI}
             = bless {
                 uri => $modURI,
                 db => $self,
                 for => <Q::ManakaiDOM:all>,
                 forp => [],
               }, <ClassName::ManakaiDISModuleDefinition>;
          require Scalar::Util;
          Scalar::Util::weaken ($r->{db});
        }

  @Method:
    @@Name: getFor
    @@Description:
      @@@lang:en
      @@@@:
        Returns a <QUOTE::for> definition object. 
    @@Param:
      @@@Name: forURI
      @@@Type: ForURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          A <QUOTE::for> URI reference. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            Defaulted to <Q::ManakaiDOM:all>. 
    @@Return:
      @@@Type: DISFor
      @@@clsActualType: ManakaiDISForDefinition
      @@@PerlDef:
        $forURI = <Q::ManakaiDOM:all> unless defined $forURI;
        if (defined $self->{forDef}->{$forURI}) {
          $r = $self->{forDef}->{$forURI};
        } else {
          $r = $self->{forDef}->{$forURI}
             = bless {
                 uri => $forURI,
                 isa => {<Q::ManakaiDOM:all> => true},
                 revISA => {},
                 db => $self,
               }, <ClassName::ManakaiDISForDefinition>;
          $self->{forDef}->{<Q::ManakaiDOM:all>}->{revISA}->{$forURI} = true;
          require Scalar::Util;
          Scalar::Util::weaken ($r->{db});
        }

  @Method:
    @@Name: getResource
    @@Description:
      @@@lang:en
      @@@@:
        Returns a <QUOTE::dis> resource definition. 
    @@Param:
      @@@Name: resourceURI
      @@@Type: ResourceURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          A <QUOTE::dis> resource URI reference. 
      @@@nullCase:
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            Defaulted to <Q::DOMMain:any>. 
    @@ForParam:
    @@Return:
      @@@Type: DISResource
      @@@clsActualType: ManakaiDISResourceDefinition
      @@@Description:
        @@@@lang:en
        @@@@@:
          The resource definition. 
      @@@PerlDef:
        $resourceURI = <Q::DOMMain:any> unless defined $resourceURI;
        my $resURI;
        if (defined $forArg) {
          __CODE{tfurisToURI:: $turi => $resourceURI, $furi => $forArg,
                               $uri => $resURI}__;
        } else {
          $resURI = $resourceURI;
        }
        if (defined $self->{resDef}->{$resURI}) {
          $r = $self->{resDef}->{$resURI};
        } else {
          $r = $self->{resDef}->{$resURI}
             = bless {
                 uri => $resURI,
                 aliasURI => {$resURI => true},
                 subOf => {},
                 supOf => {},
                 db => $self,
                 for => <Q::ManakaiDOM:all>,
                 forp => [],
                 seq => -1,
               }, <ClassName::ManakaiDISResourceDefinition>;
          require Scalar::Util;
          Scalar::Util::weaken ($r->{db});
        }

  @Method:
    @@Name: getSourceFile
    @@enDesc:
      Gets <QUOTE::dis> source document. 
    @@Param:
      @@@Name: fileName
      @@@Type: FileURI
      @@@enDesc:
        A URI reference identifying a file. 
    @@Return:
      @@@Type: DISDocument
      @@@clsActualType: ManakaiDISDocument
      @@@enDesc:
        The <QUOTE::dis> source document. 
      @@@nullCase:
        @@@@enDesc:
          No document associated with that <P::fileName>. 
      @@@PerlDef:
        $r = $self->{<Q::sourceFile>}->{$fileName};
  @Method:
    @@Name: setSourceFile
    @@enDesc:
      Puts <QUOTE::dis> source document object. 
    @@Param:
      @@@Name: fileName
      @@@Type: FileURI
      @@@enDesc:
        A URI reference identifying a file.  If there is already a 
        source document, then the association has been updated. 
    @@Param:
      @@@Name: doc
      @@@Type: DISDocument
      @@@clsActualType: ManakaiDISDocument
      @@@enDesc:
        The document object to set. 
    @@Return:
      @@@PerlDef:
        $self->{<Q::sourceFile>}->{$fileName} = $doc;

  @Method:
    @@Name: loadModule
    @@enDesc:
      Loads definitions from a <QUOTE::dis> document. 
    @@Param:
      @@@Name: doc
      @@@Type: DISDocument
      @@@clsActualType: ManakaiDISDocument
      @@@enDesc:
        The source <QUOTE::dis> document object.  Its 
        <A::ManakaiDISDocument.disDatabase> must be this database. 
    @@Param:
      @@@Name: resolver
      @@@Type: DISModuleResolver
      @@@enDesc:
        The resolver to convert module name into <QUOTE::dis> document object. 
    @@ForParam:
    @@NamedParam:
      @@@Name: onResourceRead
      @@@Type:
        Perl:CODE::ManakaiDOM:all
      @@@enDesc:
        An event handler called when a resource is read.
      @@@nullCase:
        @@@@enDesc:
          No event handler is read.
    @@Return:
      @@@RaiseException:
        @@@@@: NO_MODULE_QNAME_ERR
        @@@@enDesc:
          The <Q::dis:Module> element must have a <Q::dis:QName> attribute. 
      @@@RaiseException:
        @@@@@: UNABLE_TO_GET_MODULE_ERR
        @@@@enDesc:
          The implementation is unable to get a module source. 
      @@@ForDefDupException:
      @@@ForDefNoQNameException:
      @@@ResDefDupException:
      @@@ElementNotAllowedException:
      @@@RaiseException:
        @@@@@:NO_REQUIRED_ATTR_ERR
        @@@@enDesc:
          The <Q::dis:Module> element does not have 
          <Q::dis:Namespace> attribute. 
      @@@PerlDef:
        $resolver = bless $resolver, <ClassName::ManakaiDISModuleResolver>
                      if ref $resolver eq 'CODE'; 
        ## -- Module Name, URI
        $forArg = <Q::ManakaiDOM:all> unless defined $forArg;
        my $mod_node;
        my $mod_name_node;
        __DEEP{
          $mod_node = $doc-><AG::DISDocument.moduleElement>;
          $mod_name_node = $mod_node-><M::SWCFGNode.getAttributeNS>
                                                 (<Q::dis:>, 'QName');
          unless ($mod_name_node) {
            __UNDEEP{
              __EXCEPTION{NO_MODULE_QNAME_ERR::
                DIS:sourceNode => {$mod_node},
              }__;
            }__;
          }
          $mod_name_node = bless $mod_name_node, <ClassName::ManakaiDISElement>;
          my $mod_name_uri = $mod_name_node
                                -><AG::DISElement.qnameValueURI>;
          my $mod = $self-><M::DISDatabase.getModule>
                                   ($mod_name_uri, for_arg => $forArg);
        
          unless ($mod-><AG::DISAnyResource.isDefined>) {
            ## -- Initializes Module Definition Object
            $mod->{nameURI} = $mod_name_uri;
            $mod->{localName} = $mod_name_node-><AG::DISElement
                                                       .qnameValueLocalName>;
            $mod->{namespaceURI} = $mod_name_node-><AG::DISElement
                                                       .qnameValueNamespaceURI>;
            $mod->{for} = $forArg;
            $mod->{src} = $mod_node;
            $mod->{<Q::DIS|isDefined>} = true;
            $self-><M::DISDatabase.setSourceFile> ($mod->{nameURI} => $doc);

            __CODE{dv:createURI::
              $uri => {$mod_node-><AG::DISModuleElement.definingNamespaceURI>},
              $result => {$mod->{<Q::dis:Namespace>}},
            }__;

            __CODE{dv:createValue::
              $result => {$mod->{<Q::DIS:sourceFile>}},
              $value => {$mod_node-><AG::SWCFGNode.ownerDocument>
                           -><M::SWCFGNode.flag> (<Q::swcfg21:fileName>)},
              $base_type => {<Q::DISCore:String>},
              $type => {<Q::DISCore:String>},
            }__;
            
            ## -- Loads "for" definition
            my $root_elements
                       = $doc-><M::DISDocument.disAllChildElements>;
            if ($mod-><AG::DISAnyResource.forURI> eq <Q::ManakaiDOM:all>) {
              R: for my $el (@$root_elements) {
                next R unless $el-><AG::SWCFGElement
                                          .expandedURI> eq <Q::dis:ForDef>;
                $self-><M::DISDatabase.loadFor> ($mod, $el);
              }
            }

            ## -- Loads "for all"
            my $rmod = $self-><M::DISDatabase.getModule>
                               ($mod-><AG::DISAnyResource.nameURI>,
                                for_arg => <Q::ManakaiDOM:all>);
            unless ($rmod-><AG::DISAnyResource.isDefined>) {
              my $rdoc = $resolver-><M::DISModuleResolver.uriToDocument>
                               ($self, $rmod-><AG::DISAnyResource.uri>,
                                $mod-><AG::DISAnyResource.namespaceURI>,
                                $mod-><AG::DISAnyResource.localName>,
                                <Q::ManakaiDOM:all>);
              unless ($rdoc) {
                __UNDEEP{
                  __EXCEPTION{UNABLE_TO_GET_MODULE_ERR::
                    DIS:uri => {$rmod-><AG::DISAnyResource.uri>},
                    DIS:namespaceURI =>
                               {$mod-><AG::DISAnyResource.namespaceURI>},
                    DIS:localName => {$mod-><AG::DISAnyResource.localName>},
                    DIS:for => {<Q::ManakaiDOM:all>},
                    DIS:sourceNode => {$mod-><AG::DISAnyResource.sourceElement>},
                  }__;
                }__;
              }
              $self-><M::DISDatabase.loadModule>
                            ($rdoc, $resolver, for_arg => <Q::ManakaiDOM:all>,
                             on_resource_read => $onResourceRead);
            } # Unless "for all" loaded

            ## -- Loads Required Modules
            ##    NOTE:: "dis:For" is not allowed since "dis:ForDef" is not read
            my $req_node = $mod_node-><AG::DISModuleElement.requireElement>;
            for my $rm (@{$req_node-><M::DISElement.disAllChildElements>}) {
              next unless $rm-><AG::SWCFGElement.expandedURI> eq <Q::dis:Module>;
              my ($uri, $nuri, $ln, $for);
              my $mqn = $rm-><M::SWCFGNode.getAttributeNS> (<Q::dis:>, 'QName');
              if ($mqn) {
                my $mqv = $mqn-><M::SWCFGNode.value>;
                my $mqp = (bless $mqn, <ClassName::ManakaiDISElement>)
                          -><M::NSResolverDIS.qnameToPair> ($mqv, node => $mqn);
                ($nuri, $ln) = @$mqp;
              } else {
                my $mn = $rm-><M::SWCFGNode.getAttributeNS> (<Q::dis:>, 'Name');
                if ($mn) {
                  $nuri = $mod-><AG::DISAnyResource.namespaceURI>;
                  $ln = $mn-><M::SWCFGNode.value>;
                } else {
                  $nuri = $mod-><AG::DISAnyResource.namespaceURI>;
                  $ln = $mod-><AG::DISAnyResource.localName>;
                }
              }
              my $wfn = $rm-><M::SWCFGNode.getAttributeNS>
                                              (<Q::dis:>, 'WithFor');
              if ($wfn) {
                $for = (bless $wfn, <ClassName::ManakaiDISElement>)
                       -><AG::DISElement.qnameValueURI>;
              } else {
                $for = $mod-><AG::DISAnyResource.forURI>;
              }
              my $rmod = $self-><M::DISDatabase.getModule>
                                       ($nuri . $ln, for_arg => $for);
              unless ($rmod-><AG::DISAnyResource.isDefined>) {
                my $rdoc = $resolver-><M::DISModuleResolver.uriToDocument>
                                       ($self, $rmod-><AG::DISAnyResource.uri>,
                                        $nuri, $ln, $for);
                unless ($rdoc) {
                  __UNDEEP{
                    __EXCEPTION{UNABLE_TO_GET_MODULE_ERR::
                      DIS:uri => {$rmod-><AG::DISAnyResource.uri>},
                      DIS:namespaceURI => {$nuri},
                      DIS:localName => {$ln},
                      DIS:for => {$for},
                      DIS:sourceNode => {$rm},
                    }__;
                  }__;
                }
                $self-><M::DISDatabase.loadModule>
                                       ($rdoc, $resolver, for_arg => $for,
                                        on_resource_read => $onResourceRead);
              }
            } # Child Module elements
            
            ## -- Loads child resources
            $root_elements = $doc-><M::DISDocument.disChildElements>
                                         (for_arg => $forArg);
            for my $el (@$root_elements) {
              if ($el-><AG::DISElement.isResourceElement>) {
                $self-><M::DISDatabase.loadResource>
                                         ($mod, null, null, $el,
                                          for_arg => $forArg,
                                          on_resource_read => $onResourceRead);
              } else {
                my $et = $el-><AG::SWCFGElement.expandedURI>;
                if ({
                         <Q::dis:ForDef> => 1,
                         <Q::dis:Module> => 1,
                         <Q::dis:ImplNote> => 1,
                    }->{$et}) {
                  # 
                } else {
                  __UNDEEP{
                    __EXCEPTION{ELEMENT_NOT_ALLOWED_ERR::
                      DIS:elementType => {$et},
                      DIS:sourceNode => {$el},
                      DIS:uri => {$mod->{uri}},
                    }__;
                  }__;
                }
              } # element types
            }
            
            my $dn = $mod_node-><M::SWCFGNode.getAttributeNS>
                                           (<Q::dis:>, 'Namespace');
            unless ($dn and defined $dn-><M::SWCFGNode.value>) {
              __UNDEEP{
                __EXCEPTION{NO_REQUIRED_ATTR_ERR::
                  DIS:elementType => {<Q::dis:Namespace>},
                  DIS:sourceNode => {$mod_node},
                }__;
              }__;
            }
          } # Unless this module loaded
        }__; # Deep

  @Method:
    @@Name: loadFor
    @@enDesc:
      Loads definition of a <QUOTE::for> from a <Q::dis:ForDef> element. 
    @@Param:
      @@@Name: mod
      @@@Type: DISModule
      @@@clsActualType: ManakaiDISModuleDefinition
      @@@enDesc:
        The module in which the <QUOTE::for> to load is defined. 
    @@Param:
      @@@Name: el
      @@@Type: DISElement
      @@@enDesc:
        The source <QUOTE::dis> <Q::dis:ForDef> element object. 
    @@Return:
      @@@ForDefDupException:
      @@@ForDefNoQNameException:
      @@@ElementNotAllowedException:
      @@@PerlDef:
        __DEEP{
          my $qn_node = $el-><M::SWCFGNode.getAttributeNS> (<Q::dis:>, 'QName');
          unless ($qn_node) {
            __UNDEEP{
              __EXCEPTION{NO_FOR_QNAME_ERR::
                DIS:sourceNode => {$el},
              }__;
            }__;
          }
          $qn_node = bless $qn_node, <ClassName::ManakaiDISElement>;
          my $qn_uri = $qn_node-><AG::DISElement.qnameValueURI>;
          my $for = $self-><M::DISDatabase.getFor> ($qn_uri);
        
          unless ($for-><AG::DISAnyResource.isDefined>) {
            ## -- Initializes "For" Definition Object
            $for->{src} = $el;
            $for->{<Q::DIS|isDefined>} = true;
            $for->{<Q::DIS|definingModule>} = $mod-><AG::DISAnyResource.uri>;

            for my $ce (@{$el-><M::ManakaiDISElement.disAllChildElements>}) {
              my $xn = $ce-><AG::SWCFGElement.expandedURI>;
              if ($xn eq <Q::dis:ISA> or $xn eq <Q::dis:Implement>) {
                my $sfor = $self-><M::DISDatabase.getFor>
                            ($ce-><AG::DISElement.qnameValueURI>);
                $for-><M::DISFor.addISA> ($sfor);
                $sfor-><AS::DISAnyResource.isReferred> ($ce);
                ## TODO: warn if dis:Implement
              } elsif ({
                         <Q::dis:Description> => 1,
                         <Q::dis:ImplNote> => 1,
                         <Q::dis:FullName> => 1,
                         <Q::dis:QName> => 1,
                       }->{$xn}) {
                # 
              } else {
                __UNDEEP{
                  __EXCEPTION{ELEMENT_NOT_ALLOWED_ERR::
                    DIS:elementType => {$xn},
                    DIS:sourceNode => {$ce},
                    DIS:uri => {$qn_uri},
                  }__;
                }__;
              }
            }
          } else {
            __UNDEEP{
              __EXCEPTION{FOR_ALREADY_DEFINED_ERR::
                DIS:sourceNode => {$el},
                DIS:anotherSourceNode => {$el},
                DIS:uri => {$qn_uri},
              }__;
            }__;
          } # isDefine?
        }__; # DEEP
        
  @Method:
    @@Name: loadResource
    @@enDesc:
      Loads definition of a <QUOTE::dis> resource from a 
      <Q::dis:ResourceDef> element. 
    @@Param:
      @@@Name: mod
      @@@Type: DISModule
      @@@clsActualType: ManakaiDISModuleDefinition
      @@@enDesc:
        The module in which the resource to load is defined. 
    @@Param:
      @@@Name: parentResource
      @@@Type: DISResource
      @@@clsActualType: ManakaiDISResourceDefinition
      @@@enDesc:
        The (static) parent resource in which the resource to load is defined. 
      @@@nullCase:
        @@@@enDesc:
          The resource to load is a root resource, i.e. <P::el> is 
          a direct child of the document node. 
    @@Param:
      @@@Name: dynParent
      @@@Type: DISResource
      @@@clsActualType: ManakaiDISResourceDefinition
      @@@enDesc:
        The dynamic parent resource of the resource to load. 
      @@@nullCase:
        @@@@enDesc:
          If this resource is a root resource, i.e. <P::el> is
          a direct child of the document node. 
    @@Param:
      @@@Name: el
      @@@Type: DISElement
      @@@clsActualType: ManakaiDISElement
      @@@enDesc:
        The source <QUOTE::dis> <Q::dis:ResourceDef> element object. 
    @@ForParam:
    @@ForpParam:
    @@NamedParam:
      @@@Name: onResourceRead
      @@@Type:
        Perl:CODE::ManakaiDOM:all
      @@@enDesc:
        An event handler called when a resource is read.
      @@@nullCase:
        @@@@enDesc:
          No event handler is read.
    @@Return:
      @@@ResDefDupException:
      @@@ElementNotAllowedException:
      @@@PerlDef:
        $forArg = <Q::ManakaiDOM:all> unless defined $forArg;
        $forpArg ||= [];
        __DEEP{
          ## -- Node names

          ## Unique resource identifier generated from node id
          my $node_id = $el-><AG::SWCFGNode.nodeID>;
          my $node_uri;
          __CODE{tfpurisToURI:: $turi => $node_id, $furi => $forArg,
                                $forp => $forpArg, $uri => $node_uri}__;

          ## User defined resource identifiers
          my $qn_node = $el-><M::ManakaiDISElement.disGetAttribute>
                                      (<Q::dis:QName>, for_arg => $forArg,
                                       forp_arg => $forpArg);
          my $res;
          if ($qn_node) {
            my $qn_uri = $qn_node-><AG::ManakaiDISElement.qnameValueURI>;
            $res = $self-><M::ManakaiDISDatabase.getResource>
                                ($qn_uri, for_arg => $forArg);
            if ($res-><AG::DISAnyResource.isDefined>) {
              __UNDEEP{
                __EXCEPTION{RESOURCE_ALREADY_DEFINED_ERR::
                  DIS:uri => {$res->{uri}},
                  DIS:sourceNode => {$qn_node},
                  DIS:anotherSourceNode => {$res->{src}},
                }__;
              }__;
            }
            $res->{nameURI} = $qn_uri;
            $res->{localName} = $qn_node-><AG::ManakaiDISElement
                                                       .qnameValueLocalName>;
            $res->{namespaceURI} = $qn_node-><AG::ManakaiDISElement
                                                       .qnameValueNamespaceURI>;
          } else { ## Anonymous or local
            my $n_node = $el-><M::ManakaiDISElement.disGetAttribute>
                                      (<Q::dis:Name>, for_arg => $forArg,
                                       forp_arg => $forpArg);
            if ($n_node) {
              if ($parentResource) {
                my $puri = $parentResource->{uri};
                my $ru;
                my $ln = $n_node-><M::swcfg21:SWCFGNode
                                    ::swcfg21:ForLatest.value>;
                __CODE{getChildResourceURI:: $parentURI => $puri,
                                             $localName => $ln,
                                             $result => $ru}__;
                $res = $self-><M::ManakaiDISDatabase.getResource>
                                    ($ru, for_arg => $forArg);
                $res->{nameURI} = $ru;
                $res->{localName} = $n_node-><M::SWCFGNode.value>;
                $res->{<Q::DIS|isAnon>} = true;
              } else {  ## Root local name resource
                my $ln = $n_node-><M::SWCFGNode.value>;
                my $ns_uri = $mod-><AG::DISAnyResource.sourceElement>
                                 -><AG::DISModuleElement.definingNamespaceURI>;
                my $qn_uri = $ns_uri . $ln;
                $res = $self-><M::ManakaiDISDatabase.getResource>
                                    ($qn_uri, for_arg => $forArg);
                if ($res-><AG::DISAnyResource.isDefined>) {
                  __UNDEEP{
                    __EXCEPTION{RESOURCE_ALREADY_DEFINED_ERR::
                      DIS:uri => {$res-><AG::DISAnyResource.uri>},
                      DIS:sourceNode => {$n_node},
                      DIS:anotherSourceNode
                              => {$res-><AG::DISAnyResource.sourceElement>},
                    }__;
                 }__;
                }
                $res->{nameURI} = $qn_uri;
                $res->{namespaceURI} = $ns_uri;
                $res->{localName} = $ln;
              }
            } else {
              $res = $self-><M::DISDatabase.getResource> ($node_uri);
              $res->{<Q::DIS|isAnon>} = true;
            }
          } # anon
          $res->{for} = $forArg;
          $res->{forp} = $forpArg;
          $res->{src} = $el;
          $res->{<Q::DIS|definingModule>} = $mod->{uri};
          $mod-><M::ManakaiDISPropertyAccessor.addPropertyResourceList>
                                            (<Q::DIS:resource>, $res);
          if ($parentResource) {
            __CODE{dv|createURI::
              $result => {$res->{<Q::dis2pm:parentResource>}},
              $uri => {$parentResource-><AG::DISAnyResource.uri>},
            }__;
          }
          if ($dynParent) {
            __CODE{dv|createURI::
              $result => {$res->{<Q::DIS|dynamicParentResource>}},
              $uri => {$dynParent-><AG::DISAnyResource.uri>},
            }__;
          }
          unless ($res->{uri} eq $node_uri) {
            my $nu_res = $self-><M::DISDatabase.getResource> ($node_uri);
            $res-><M::DISResource.mergeAsAlias> ($nu_res);
          }
          $res->{<Q::DIS|isDefined>} = true;
          $res->{seq} = $self->{seq}++;
          $res->{<Q::DIS|sourceNodeID>} = $node_id;
          
          ## -- Alias
          my $al_node = $el-><M::DISElement.disGetAttribute>
                                      (<Q::dis:AliasFor>, for_arg => $forArg,
                                       forp_arg => $forpArg);
          if ($al_node) {
            my $canon_uri = $al_node-><M::DISElement.tfqnamesValueURI>
                                                           ($node_id, $forArg,
                                    for_arg => $self->{for},
                                    forp_arg => $self->{forp});
            my $canon_res = $self-><M::DISDatabase.getResource> ($canon_uri);
            $canon_res-><AS::DISAnyResource.isReferred> ($al_node);
            $canon_res-><M::DISResource.mergeAsAlias> ($res, node => $al_node);
            $res = $canon_res;
          }

          ## -- Registers as child
          $parentResource-><M::DISResourceProp.addPropertyResourceList>
                                      (<Q::DIS:childResource>, $res)
             if $parentResource;
          $dynParent-><M::DISResourceProp.addPropertyResourceList>
                                      (<Q::DIS:dynamicChildResource>, $res)
             if $dynParent;

          my $is_multires = false;
          my @props;
          my @cres;
          my @ce0 = @{$el-><M::DISElement.disChildElements>
                                    (for_arg => $forArg, forp_arg => $forpArg)};
          while (@ce0) {
            my $ce = shift @ce0;
            if ($ce-><M::DISElement.elementTypeMatch> (<Q::rdf:type>)) {
              my $type_uri = $ce-><AG::DISElement.qnameValueURI>;
              my $type = $self-><M::DISDatabase.getResource> ($type_uri);
              $res-><M::DISResourceProp.addPropertyResourceUList>
                                               (<Q::rdf:type>, $type);
              $type-><AS::DISAnyResource.isReferred> ($ce);
              if ($type-><M::DISResource.isSubsetOfURI>
                                               (<Q::dis:MultipleResource>)) {
                $is_multires = true;
              }
            } elsif ($ce-><M::DISElement.elementTypeMatch>
                                                   (<Q::dis:subsetOf>)) {
              my $sres = $self-><M::DISDatabase.getResource>
                                  ($ce-><M::DISElement.tfqnamesValueURI>
                                                    ($node_id, $forArg,
                                    for_arg => $forArg, forp_arg => $forpArg));
              $res-><M::DISResource.addSuperResource> ($sres);
            } elsif ($ce-><AG::DISElement.isResourceElement>) {
              push @cres, $ce;
            } elsif ($ce-><M::DISElement.elementTypeMatch>
                                                  (<Q::dis:dataType>)) {
              my $uri = $ce-><AG::DISElement.qnameValueURI>;
              __CODE{dv:createURI::
                $uri => $uri,
                $result => {$res->{<Q::dis:dataType>}},
              }__;
              my $type = $self-><M::DISDatabase.getResource> ($uri);
              $type-><AS::DISAnyResource.isReferred> ($ce);
            } elsif ($ce-><M::DISElement.elementTypeMatch>
                                  (<Q::dis:multipleProperties>)) {
              my $uri = $ce-><AG::DISElement.qnameValueURI>;
              __CODE{dv:createURI::
                $uri => $uri,
                $result => {$res->{<Q::dis:multipleProperties>}},
              }__;              
              my $type = $self-><M::DISDatabase.getResource> ($uri);
              $type-><AS::DISAnyResource.isReferred> ($ce);
            } else {
              ## Property and invalid element is not checked, since not
              ## all property definitions has loaded at this stage. 
              push @props, $ce;
            }
          } # @ce0
   
          ## -- Child resources
          unless ($is_multires) {
            for my $re (@cres) {
              unless ($al_node) {
                $self-><M::ManakaiDISDatabase.loadResource>
                                     ($mod, $res, $res, $re,
                                      for_arg => $forArg, forp_arg => $forpArg,
                                      on_resource_read => $onResourceRead);
              } else {
                my $ac = $re-><M::ManakaiDISElement.disGetAttribute>
                                    (<Q::dis:aliasChild>, for_arg => $forArg,
                                     forp_arg => $forpArg);
                if ($ac and $ac-><M::SWCFGNode.value>) {
                  $self-><M::ManakaiDISDatabase.loadResource>
                                     ($mod, $res, $res, $re,
                                      for_arg => $forArg, forp_arg => $forpArg,
                                      on_resource_read => $onResourceRead);
                }
              }
            }
          }

          ## -- Multiple representations
          if ($is_multires) {
            for my $pe (@props) {
              if ($pe-><M::ManakaiDISElement.elementTypeMatch>
                                               (<Q::dis:resourceFor>)) {
                my $for_uri = $pe-><AG::ManakaiDISElement.qnameValueURI>;
                my $for = $self-><M::ManakaiDISDatabase.getFor> ($for_uri);
                $for-><AS::DISAnyResource.isReferred> ($pe);
                $self-><M::ManakaiDISDatabase.loadResource>
                                ($mod, $parentResource, $res, $el,
                                 for_arg => $forArg,
                                 forp_arg => [@{$forpArg}, $for_uri],
                                 on_resource_read => $onResourceRead);
              }
            }
          }
          ($onResourceRead or sub {})->($self, $res);
        }__; # DEEP

  @Method:
    @@Name: readProperties
    @@enDesc:
      Reads property values in the source tree and
      removes the source tree from the database.
    @@NamedParam:
      @@@Name: onResourceRead
      @@@Type:
        Perl:CODE::ManakaiDOM:all
      @@@enDesc:
        An event handler called when a resource is read.
      @@@nullCase:
        @@@@enDesc:
          No event handler is read.
    @@Return:
      @@@RaiseException:
        @@@@@: UNSUPPORTED_ELEMENT_TYPE_ERR
        @@@@enDesc:
          There is an element whose element type is not supported.
      @@@PerlDef:
        __DEEP{
          for my $fd (values %{$self->{modDef}},
                      values %{$self->{forDef}},
                      values %{$self->{resDef}}) {
            if ($fd-><AG::DISAnyResource.isDefined>) {
              $fd-><M::DISAnyResource.readProperties>
                (on_resource_read => $onResourceRead);
            }
          }
          CORE::delete $self->{<Q::DIS|sourceFile>};
        }__;

  @Method:
    @@Name: checkUndefinedResource
    @@enDesc:
      Checks whether there is referred but undefined resource or not. 
    @@Return:
      @@@RaiseException:
        @@@@@: FOR_NOT_DEFINED_ERR
        @@@@enDesc:
          There is a <QUOTE::for> that is referred but not defined.
      @@@RaiseException:
        @@@@@: RESOURCE_NOT_DEFINED_ERR
        @@@@enDesc:
          There is a resource that is referred but not defined.
      @@@PerlDef:
        for my $fd (values %{$self->{forDef}}) {
          if (my $ref = $fd-><AG::DISAnyResource.isReferred> and
              not $fd-><AG::DISAnyResource.isDefined>) {
            __EXCEPTION{FOR_NOT_DEFINED_ERR::
              DIS:uri => {$fd-><AG::DISAnyResource.uri>},
              DIS:sourceNodePath => {$ref},
            }__;
          }
        }
        for my $fd (values %{$self->{resDef}}) {
          if (my $ref = $fd-><AG::DISAnyResource.isReferred> and
              not $fd-><AG::DISAnyResource.isDefined>) {
            __EXCEPTION{RESOURCE_NOT_DEFINED_ERR::
              DIS:uri => {$fd-><AG::DISAnyResource.uri>},
              DIS:sourceNodePath => {$ref},
            }__;
          }
        }
        
  @Method:
    @@Name: xcrefToResource
    @@enDesc:
      Returns a resource object selected by an exception code
      reference (<Q::DOMMain:XCodeRef>).
    @@Param:
      @@@Name: xcref
      @@@Type:
        DOMMain:XCodeRef::ManakaiDOM:all
      @@@enDesc:
        Exception code to select.
    @@Param:
      @@@Name: contextNode
      @@@Type: DISElement
      @@@enDesc:
        A context element node.  Namespace prefixes in 
        <P::xcref> are resolved against this node.
    @@ForParam:
    @@NodeParam:
    @@Return:
      @@@Type: 
        Perl:ARRAY::ManakaiDOM:all
      @@@enDesc:
        A reference to the array containing two or three 
        resource definitions (<Class::ManakaiDISResourceDefinition>).
        The first (index <CODE::0>) resource is an exception class. 
        The second (index <CODE::1>) resource is an exception code 
        constant.  The third (index <CODE::2>) resource
        is an exception subtype or <DOM::null> if the reference identifies
        no subtype.
      @@@RaiseException:
        @@@@@: RESOURCE_NOT_DEFINED_ERR
        @@@@enDesc:
          The resource identified by the <P::xcref> is not defined
          or not an exception.
      @@@PerlDef:
        my ($q1, $q2, $q3) = split /\s*\.\s*/, $xcref, 3;
        __DEEP{
          if (defined $q3) {
            $r->[2] = $self-><M::ManakaiDISDatabase.getResource>
                         ($contextNode-><M::NSResolverDIS.tfqnamesToURI>
                                          ($q3, null, $forArg, node => $node));
            $r->[1] = $r->[2]-><M::ManakaiDISPropertyAccessor
                                       .getPropertyResource>
                                          (<Q::dis2pm:parentResource>);
          } elsif (defined $q2) {
            if ($q2 =~ /:/) {
              $r->[1] = $self-><M::ManakaiDISDatabase.getResource>
                         ($contextNode-><M::NSResolverDIS.tfqnamesToURI>
                                          ($q2, null, $forArg, node => $node));
            } else {
              $r->[0] = $self-><M::ManakaiDISDatabase.getResource>
                         ($contextNode-><M::NSResolverDIS.tfqnamesToURI>
                                          ($q1, null, $forArg, node => $node));
              $r->[1] = $r->[0]-><M::ManakaiDISResourceDefinition
                                    .getConstResourceByName> ($q2);
            }
          } else {  ## $q1 only
            $r->[2] = $self-><M::ManakaiDISDatabase.getResource>
                         ($contextNode-><M::NSResolverDIS.tfqnamesToURI>
                                          ($q1, null, $forArg, node => $node));
            if ($r->[2]-><M::ManakaiDISResourceDefinition
                      .isTypeURI> (<Q::ManakaiDOM:ExceptionOrWarningSubType>)) {
              $r->[1] = $r->[2]-><M::ManakaiDISPropertyAccessor
                                       .getPropertyResource>
                                          (<Q::dis2pm:parentResource>);
            } else {
              $r->[1] = $r->[2]; CORE::delete $r->[2];
            }
          }

          if ($r->[2] and
              not $r->[2]-><M::ManakaiDISResourceDefinition
                      .isTypeURI> (<Q::ManakaiDOM:ExceptionOrWarningSubType>)) {
            __UNDEEP{__EXCEPTION{RESOURCE_NOT_DEFINED_ERR::
              DIS:uri => {$r->[2]->{uri}},
              DIS:expectedType => {<Q::ManakaiDOM:ExceptionOrWarningSubType>},
              DIS:sourceNode => {$node},
              DIS:sourceCode => {$xcref},
            }__}__;
          }
          $r->[2]-><AS::DISAnyResource.isReferred>
                                               ($node or $contextNode)
            if $r->[2];
          
          if (not $r->[1] or
              not $r->[1]-><M::ManakaiDISResourceDefinition
                      .isTypeURI> (<Q::ManakaiDOM:Const>)) {
            __UNDEEP{__EXCEPTION{RESOURCE_NOT_DEFINED_ERR::
              DIS:uri => {$r->[1]->{uri}},
              DIS:localName => {$r->[1]->{localName}},
              DIS:expectedType => {<Q::ManakaiDOM:Const>},
              DIS:sourceNode => {$node},
              DIS:sourceCode => {$xcref},
            }__}__;
          }
          $r->[1]-><AS::DISAnyResource.isReferred>
                                               ($node or $contextNode);

          unless ($r->[0]) {
            my $cg = $r->[1]-><M::ManakaiDISPropertyAccessor
                                       .getPropertyResource>
                                          (<Q::dis2pm:parentResource>);
            $r->[0] = $cg-><M::ManakaiDISPropertyAccessor
                                       .getPropertyResource>
                                          (<Q::dis2pm:parentResource>) if $cg;
          }
          if (not $r->[0] or
              not $r->[0]-><M::ManakaiDISResourceDefinition
                    .isTypeURI> (<Q::DOMException:AnyExceptionAnyClass>)) {
            __UNDEEP{__EXCEPTION{RESOURCE_NOT_DEFINED_ERR::
              DIS:uri => {$r->[0]->{uri}},
              DIS:localName => {$r->[0]->{localName}},
              DIS:expectedType => {<Q::DOMException:AnyExceptionAnyClass>},
              DIS:sourceNode => {$node},
              DIS:sourceCode => {$xcref},
            }__}__;
          }
          $r->[0]-><AS::DISAnyResource.isReferred>
                                               ($node or $contextNode);
        }__;

  @Method:
     @@Name:  getFeature
     @@Description:
        @@@lang:en
        @@@@:
          Returns a specialized object that implements the specialized 
          interfaces of the specified feature and version.
     @@Param:
        @@@Name:  feature
        @@@Type:
          DISLang:String::ManakaiDOM:all
        @@@actualType:
          ManakaiDOM:ManakaiDOMFeatureName::ManakaiDOM:ManakaiDOMLatest
        @@@Description:
          @@@@lang:en
          @@@@@:
            A feature name to request.
     @@Param:
        @@@Name:  version
        @@@Type:
          DISLang:String::ManakaiDOM:all
        @@@actualType:
          ManakaiDOM:ManakaiDOMFeatureVersion::ManakaiDOM:ManakaiDOMLatest
        @@@Description:
          @@@@lang:en
          @@@@@:
            A feature version number to request.
     @@Return:
        @@@Type: 
          DOMMain:Object::ManakaiDOM:all
        @@@Description:
          @@@@lang:en
          @@@@@:
            An object that implements the specialized APIs of the 
            <P::feature> and <P::version>. 
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@@: 
            There is no object available that implements interfaces 
            associated with the <P::feature> and <P::version>. 
        @@@PerlDef:
          $feature =~ s/^\+//;
          CLASS: for my $class (grep {
            $Message::Util::DIS::ManakaiDISDatabase::CompatClass{$_}
          } keys %Message::Util::DIS::ManakaiDISDatabase::CompatClass) {
            if ($Message::DOM::ClassFeature{$class}->{$feature}->{$version}) {
              $r = bless {o => $self}, $class;
              last CLASS;
            }
          }

  @Method:
    @@Name: free
    @@enDesc:
      Marks the database, resources in the database, and source
      <QUOTE::dis> document trees in the database as no longer used.
    @@ForCheck: ManakaiDOM|ForClass
    @@Return:
      @@@PerlDef:
        for my $file (values %{$self->{<Q::sourceFile>}}) {
          $file-><M::ManakaiNode|ManakaiNodeRef||ManakaiDOM|Perl.free>
            if $file;
        }
        CORE::delete $self->{modDef};
        CORE::delete $self->{forDef};
        CORE::delete $self->{resDef};
##DISDatabase

PropDef:
  @QName: sourceNodeID
  @enDesc:
    The URI reference of the source node identifier. 
  @rdfs:domain: ManakaiDISResourceDefinition

PropDef:
  @QName: resource
  @enDesc:
    Resources defined in a module. 
  @rdfs:range: ManakaiDISResourceDefinition
  @rdfs:domain: ManakaiDISModuleDefinition

PropDef:
  @QName:
    dis2pm:parentResource
  @enDesc:
    Static parent resource.  No parent for root resources.

PropDef:
  @QName: dynamicParentResource
  @enDesc:
    Dynamic parent resource.   No parent for root resources. 

PropDef:
  @QName: childResource
  @enDesc:
    Static child resources.

PropDef:
  @QName: dynamicChildResource
  @enDesc:
    Dynamic child resources.

ElementTypeBinding:
  @Name: ForDefDupException
  @ElementType:
    ManakaiDOM:raises
  @ShadowContent:
    @@@: FOR_ALREADY_DEFINED_ERR
    @@Description:
      @@@lang:en
      @@@@:
        The <QUOTE::for> is already defined elsewhere. 

ElementTypeBinding:
  @Name: ForDefNoQNameException
  @ElementType:
    ManakaiDOM:raises
  @ShadowContent:
    @@@: NO_FOR_QNAME_ERR
    @@Description:
      @@@lang:en
      @@@@:
        A <Q::dis:ForDef> element must have a <Q::dis:QName> attribute. 

ElementTypeBinding:
  @Name: ResDefDupException
  @ElementType:
    ManakaiDOM:raises
  @ShadowContent:
    @@@: RESOURCE_ALREADY_DEFINED_ERR
    @@Description:
      @@@lang:en
      @@@@:
        The <QUOTE::dis> resource is already defined elsewhere. 

ElementTypeBinding:
  @Name: ElementNotAllowedException
  @ElementType:
    ManakaiDOM:raises
  @ShadowContent:
    @@@: ELEMENT_NOT_ALLOWED_ERR
    @@Description:
      @@@lang:en
      @@@@:
        An element has found where it is not allowed. 

IFClsDef:
  @IFQName: DISModuleResolver
  @ClsQName: ManakaiDISModuleResolver

  @enDesc:
    Objects implementing <IF::DISModuleResolver> interface 
    are used to convert module name into <QUOTE::dis> document object. 
    \
    {NOTE:: It is also acceptable to pass a <Perl::CODE> reference 
            as a method parameter where <IF::DISModuleResolver> is 
            expected.
    \
    }
  @Method:
    @@Name: uriToDocument
    @@enDesc:
      Returns a <QUOTE::dis> document from module name information. 
    @@Param:
      @@@Name: disDB
      @@@Type: DISDatabase
      @@@clsActualType: ManakaiDISDatabase
      @@@enDesc:
        The <QUOTE::dis> database. 
    @@Param:
      @@@Name: moduleURI
      @@@Type: ModuleURI
      @@@enDesc:
        The URI reference of the module. 
        \
        {NOTE:: This parameter is redundant, since it can be 
                composed from other three parameters.
        \
        }
    @@Param:
      @@@Name: moduleNamespaceURI
      @@@Type: AnyURI
      @@@enDesc:
        The namespace URI of the module name. 
    @@Param:
      @@@Name: moduleLocalName
      @@@Type: 
        DISCore:LocalName::ManakaiDOM:all
      @@@enDesc:
        The local name of the module name. 
    @@Param:
      @@@Name: moduleFor
      @@@Type: ForURI
      @@@enDesc:
        The <QUOTE::for> URI reference for which the module is defined. 
    @@Return:
      @@@Type: DISDocument
      @@@clsActualType: ManakaiDISDocument
      @@@enDesc:
        The <QUOTE::dis> document.  It don't have to be a newly created
        object. 
      @@@nullCase:
        @@@@enDesc:
          The method is unable to resolve the reference. 
      @@@PerlDef:
        $r = $self->(@_);

  @ResourceDef:
    @@rdf:type: DISLang|InputProcessor
    @@PerlDef:
      $INPUT = bless $INPUT, <ClassName::ManakaiDISModuleResolver>
                 if ref $INPUT eq 'CODE';
##DISModuleResolver

PropDef:
  @QName: sourceFile
  @enDesc:
    Source <QUOTE::dis> documents. 
  @rdfs:domain: DISDatabase
  @rdfs:range: DISDocument

IFClsDef:
  @IFQName: DISAnyResource
  @ClsQName: ManakaiDISAnyResource

  @enDesc:
    {P:: A <IF::DISAnyResource> object represents a resource defined
    in <QUOTE::dis> files.  In <QUOTE::dis> model, resources are
    categorized as:

      - Module::: A <QUOTE::dis> module is a file entity.
                  This kind of objects <kwd:MUST> implement the
                  <IF::DISModule> interface.

      - <QUOTE::For>::: A <QUOTE::for> is a target for which 
                        resources are defined.  This kind of objects
                        <kwd:MUST> implement the <IF::DISFor> interface.
      
      - <QUOTE::dis> Resource::: Something described in <QUOTE::dis>. 
                     This kind of objects <kwd:MUST> implement the
                     <IF::DISModule> interface.

   }

   The objects implementing this interface <kwd:MUST> also implement
   the <IF::DOMMinImpl> interface.

  @Attr:
    @@Name: uri
    @@Type: AnyURI
    @@Description:
      @@@lang:en
      @@@@:
        The URI reference of the resource. 
    @@Get:
      @@@enDesc:
        The representive URI reference of the resource.

        {NOTE:: The URI might be non-persistent if the 
                resource is not assigned a URI in <QUOTE::dis> source file,
                in which case a URI is randomly-generated at the 
                time of object generation.
        }
      @@@PerlDef:
        $r = $self->{uri};
  
  @Attr:
    @@Name: uris
    @@Type:
      Perl:Array::ManakaiDOM:all
    @@enDesc:
      A set of URIs that identifies the resource.
    @@Get:
      @@@enDesc:
        A reference to array in which the URIs are contained
        in undefined order.

        {NOTE:: The array is <EM::not> live; it is only a snapshot.
        }

  @Method:
    @@Name: isSameResource
    @@Operator:
      @@@@:eq
      @@@ContentType:
        lang:Perl
    @@enDesc:
      Whether two resources are same or not.  Two resources are
      same if and only if their <A::DISAnyResource.uri> are
      equivalent as strings (i.e. in character-by-character based matching).
    @@Param:
      @@@Name: anotherResource
      @@@Type: DISAnyResource
      @@@enDesc:
        Another resource object to compare.
    @@Return:
      @@@Type:
        DOMMain:boolean::ManakaiDOM:all
      @@@enDesc:
        Whether two resources are same or not. 
      @@@TrueCase:
        @@@@enDesc: Two resources are same.
      @@@FalseCase:
        @@@@enDesc: Two resources are different.
      @@@PerlDef:
        if (UNIVERSAL::isa ($anotherResource,
                            <ClassName::ManakaiDISAnyResource>)) {
          $r = $self->{uri} eq $anotherResource->{uri};
        }

  @Attr:
    @@Name: nameURI
    @@Type: NameURI
    @@enDesc:
      The URI reference of this module, without 
      <QUOTE::for> identifier. 
    @@Get:
      @@@PerlDef:
        $r = $self->{nameURI};

  @Attr:
    @@Name: localName
    @@enDesc:
      The local name of this module. 

      {NOTE:: <QUOTE::for> resources has no local name.
      }
    @@Type:
      DISCore:LocalName::ManakaiDOM:all
    @@Get:
      @@@PerlDef:
        $r = $self->{localName};

  @Attr:
    @@Name: namespaceURI
    @@Type: AnyURI
    @@enDesc:
      The namespace URI of the name of this resource. 
      
      {NOTE:: <QUOTE::for> resources has no namespace URI.
      }
    @@Get:
      @@@PerlDef:
        $r = $self->{namespaceURI};

  @Attr:
    @@Name: forURI
    @@Type: ForURI
    @@enDesc:
      The <QUOTE::for> URI reference for which this module is defined. 
    @@Get:
      @@@PerlDef:
        $r = $self->{for};

  @Attr:
    @@Name: forpURI
    @@enDesc:
      The <QUOTE::for+> URI references for which this resource is defined. 

      {NOTE:: <QUOTE::for> resources has no <QUOTE::for+> URI.
      }
    @@Type: ForURIList
    @@Get:
      @@@enDesc:
        List of <QUOTE::for> URI references.  Note that this list is
        <QUOTE::dead>.
      @@@PerlDef:
        $r = [@{$self->{forp}}];

  @Method:
    @@Name: isForURI
    @@enDesc:
      Tests whether this resource is defined for a <QUOTE::for>
      or <QUOTE::for+> URI reference or not.
    @@Param:
      @@@Name:forURI
      @@@Type:ForURI
      @@@enDesc:
        A <QUOTE::for> URI reference to test.
    @@Return:
      @@@Type:
        DOMMain:boolean::ManakaiDOM:all
      @@@TrueCase:
        @@@@enDesc:
          This resource is for <P::forURI>.
      @@@FalseCase:
        @@@@enDesc:
          This resource is not for <P::forURI>.
      @@@PerlDef:
        __DEEP{
          C: for my $this_for_uri ($self->{for}, @{$self->{forp}}) {
            if ($this_for_uri eq $forURI) { ## Shortcut
              $r = true;
              last C;
            }
            my $this_for = $self->{db}-><M::DIS|DISDatabase.getFor>
                                               ($this_for_uri);
            if ($this_for-><M::DIS|DISFor.isaURI> ($forURI)) {
              $r = true;
              last C;
            }
          }
        }__;

  @Attr:
    @@Name: isDefined
    @@Description:
      @@@lang:en
      @@@@:
        Whether this module is defined or not. 
    @@Type:
      DOMMain:boolean::ManakaiDOM:all
    @@Get:
      @@@PerlDef:
        $r = $self->{<Q::DIS|isDefined>};

  @Attr:
    @@Name: ownerModule
    @@enDesc:
      The module in which the resource is defined.  If the resource
      is a module, the module itself is the attribute value.
    @@Get:
      @@@Type: DISModule
      @@@clsActualType: ManakaiDISModuleDefinition
      @@@enDesc:
        The owner module object.
      @@@nullCase:
        @@@@enDesc:
          The resource is not part of any module since
          its definition is not read (i.e. <A::DISAnyResource.isDefined> is
          <DOM::false>).
      @@@PerlDef:
        $r = $self->{db}
                  -><M::DISDatabase.getModule>
                           ($self->{<Q::DIS|definingModule>})
           if defined $self->{<Q::DIS|definingModule>};

  @Method:
    @@ForCheck: ManakaiDOM|ForClass
    @@Name:  hasFeature
    @@enDesc:
      Returns whether a specific feature is implemented by theobject or not.
    @@Param:
        @@@Name:  feature
        @@@Type:
          DISLang:String::ManakaiDOM:all
        @@@actualType: DOMFeature|FeatureNameString||ManakaiDOM|ManakaiDOMLatest
        @@@Description:
          @@@@lang:en
          @@@@@:
            A feature name to request.
     @@Param:
        @@@Name:  version
        @@@Type:
          DISLang:String::ManakaiDOM:all
        @@@actualType:
          DOMFeature|FeatureVersionString||ManakaiDOM|ManakaiDOMLatest
        @@@Description:
          @@@@lang:en
          @@@@@:
            A feature version number to request.
     @@Return:
        @@@Type: 
          DOMMain:boolean::ManakaiDOM:all
        @@@enDesc: Whether the feature is implemented or not.
        @@@TrueCase:
          @@@@enDesc: The feature is implemented.
        @@@FalseCase:
          @@@@enDesc:
            The feature is <EM::not> implemented.
        @@@PerlDef:
          __DEEP{
            $r = $self-><M::DOMMinImpl.getFeature> ($feature, $version)
               ? true : false;
          }__;

  @Attr:
    @@Name: isReferred
    @@Description:
      @@@lang:en
      @@@@:
        Whether the resource is referenced somewhere or not. 
    @@Type: DISLang|String||ManakaiDOM|all
    @@Get:
      @@@enDesc:
        A node path string that identifies the node from
        which the resource is referenced.
      @@@nullCase:
        The resource is not referred. 
      @@@PerlDef:
        $r = $self->{<Q::DIS|isReferred>};
    @@Set:
      @@@enDesc:
        A node path string that identifies the node from
        which the resource is referenced.
      @@@InCase:
        @@@@Type: DISElement
        @@@@enDesc:
          The resource is referenced by the element.  It's node path
          string is set as the attribute value.
      @@@PerlDef:
        if (defined $given) {
          if (ref $given) {
            $given = $given-><M::SWCFGNode.flag> ('nodePath') ||
                     $given-><M::SWCFGNode.nodePath>
                          (key => [qw/QName Name type Type AppName/]);
          }
          $self->{<Q::DIS|isReferred>} = $given;
        }

  @Attr:
    @@Name: sourceNodeID
    @@enDesc:
      The identifier URI reference of the source node. 
    @@enDesc:
      @@@ForCheck: ManakaiDOM|ForClass
      @@@@:
        Modules and <QUOTE::for>s does not have source node identifier
        in the current implementation.
    @@Type: AnyURI
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          The resource is not (yet) associated with any source node.
      @@@PerlDef:
        $r = $self->{<Q::DIS:sourceNodeID>};
    @@Set:
      @@@PerlDef:
        $self->{<Q::DIS:sourceNodeID>} = $given;

  @Attr:
    @@Name: isAnonymous
    @@enDesc:
      Whether the resource has persistent name or not. 
    @@Type: 
      DOMMain:boolean::ManakaiDOM:all
    @@Get:
      @@@TrueCase:
        This resource does <EM::not> have any globally unique name. 
        <A::DISAnyResource.uri> is a temporary URI reference. 
      @@@FalseCase:
        This resource does have its formal name. 
        <A::DISAnyResource.uri> is a URI reference 
        generated from the name and the <QUOTE::for> URI reference 
        of this resource. 
      @@@PerlDef:
        $r = $self->{<Q::isAnon>};

  @Attr:
    @@Name: sourceElement
    @@enDesc:
      The source <QUOTE::dis> element node from which this 
      definition is read. 
    @@Get:
      @@@Type: DISElement
      @@@clsActualType: ManakaiDISElement
      @@@InCase:
        @@@@Type: DISModuleElement
        @@@@clsActualType: ManakaiDISModuleElement
        @@@@enDesc: If this resource is a module.
      @@@PerlDef: $r = $self->{src};
      @@@nullCase:
        @@@@enDesc:
          The definition is not yet read.

  @Attr:
    @@Name: database
    @@enDesc:
      The <QUOTE::dis> database to which the resource belongs.
    @@Type: DISDatabase
    @@clsActualType: ManakaiDISDatabase
    @@Get:
      @@@PerlDef:
        $r = $self->{db};

  @Method:
    @@Name: readProperties
    @@enDesc:
      Reads property values in the source tree and
      removes reference to the source node.
    @@NamedParam:
      @@@Name: onResourceRead
      @@@Type:
        Perl:CODE::ManakaiDOM:all
      @@@enDesc:
        An event handler called when a resource is read.
      @@@nullCase:
        @@@@enDesc:
          No event handler is read.
    @@Return:
      @@@RaiseException:
        @@@@@: UNSUPPORTED_ELEMENT_TYPE_ERR
        @@@@enDesc:
          There is an element whose element type is not supported.
      @@@PerlDef:
        __DEEP{
          if (my $src = $self->{src}) {
            for my $el (@{$src-><M::DISElement.disChildElements>
                            (for_arg => $self-><AG::DISAnyResource.forURI>,
                             forp_arg => $self-><AG::DISAnyResource.forpURI>)}) {
              my $xu = $el-><AG::SWCFGElement.expandedURI>;
              if ({
                <Q::dis:AliasFor> => true,
                <Q::dis:ContentType> => true,
                <Q::dis:dataType> => true,
                <Q::dis:For> => true,
                <Q::dis:ForCheck> => true,
                <Q::dis:Name> => true,
                <Q::dis:Namespace> => true,
                <Q::dis:multipleProperties> => true,
                <Q::rdf:type> => true,
                <Q::dis:QName> => true,
                <Q::dis:Require> => true,
                <Q::dis:resourceFor> => true,
              }->{$xu}) {
                #
              } elsif ($el-><AG::DISElement.isPropertyElement>) {
                my $add_prop;
                $add_prop = sub ($$$) {
                  my ($self, $el, $db) = @_;
                  my $prop = $db-><M::DISDatabase.getResource>
                                ($el-><AG::SWCFGElement.expandedURI>);
                  my $prop_uri = $prop-><AG::DISAnyResource.uri>;
                  my $prop_mult = $prop-><AG::DISResource.multiplePropertiesURI>;
                  my $new_value;
                  my $base_type;
                  my $copy_tree = false;
                  
                  my %mtopt = (for_arg => $self-><AG::DISAnyResource.forURI>,
                               forp_arg => $self-><AG::DISAnyResource.forpURI>,
                               default_media_type => $prop-><AG::DISResource
                                                            .defaultLextypeURI>);
                  if ($el-><M::DISElement.mediaTypeMatch>
                      (<Q::dis:TypeQName>, $mtopt{default_media_type}, %mtopt)) {
                    __CODE{dv|createValue::
                      $value => {null},
                      $base_type => {$base_type = <Q::dis:TypeQName>},
                      $type => {$el-><M::DISElement.mediaTypeURI> (%mtopt)},
                      $result => $new_value,
                    }__;
                    $new_value-><AS::dv|DVQNameValue.localName>
                      ($el-><AG::DISElement.qnameValueLocalName>);
                    $new_value-><AS::dv|DVQNameValue.namespaceURI>
                      ($el-><AG::DISElement.qnameValueNamespaceURI>);
                    $new_value-><AS::dv|DVQNameValue.prefix>
                      ($el-><AG::DISElement.qnameValuePrefix>);
                    ## TODO: Check whether defined
                  } elsif ($el-><M::DISElement.mediaTypeMatch>
                       (<Q::dis:TFQNames>, $mtopt{default_media_type}, %mtopt) or
                           $el-><M::DISElement.mediaTypeMatch>
                  (<Q::DISCore:TFPQNames>, $mtopt{default_media_type}, %mtopt)) {
                    __CODE{dv|createURI::
                      $uri => {$el-><M::DISElement.tfqnamesValueURI>
                              ($self-><AG::DISAnyResource.sourceNodeID>,
                               $self-><AG::DISAnyResource.forURI>,
                               for_arg => $self-><AG::DISAnyResource.forURI>,
                               forp_arg => $self-><AG::DISAnyResource.forpURI>)},
                      $result => $new_value,
                    }__;
                    ## TODO: Check whether defined
                  } elsif ($el-><M::DISElement.mediaTypeMatch>
                                     (<Q::lang:Perl>, $mtopt{default_media_type},
                                      %mtopt) or
                           $el-><M::DISElement.mediaTypeMatch>
                                     (<Q::lang:dis>, $mtopt{default_media_type},
                                      %mtopt) or
                           $el-><M::DISElement.mediaTypeMatch>
                                     (<Q::lang:muf>, $mtopt{default_media_type},
                                      %mtopt)) {
                    $copy_tree = true;
                    $el-><M::DISElement.preserveNodePath>;
                    my $elc = $el->clone;
                    __CODE{dv|createValue::
                      $value => {$elc},
                      $base_type => {$base_type = <Q::lang:dis>},
                      $type => {$el-><M::DISElement.mediaTypeURI> (%mtopt)},
                      $result => $new_value,
                    }__;
                    for my $p (<Q::dis:Type>, <Q::dis:actualType>) {
                      if (UNIVERSAL::isa ($self->{$p},<IFName::dv|DVURIValue>)) {
                        my $v;
                        __CODE{dv|createURI::
                          $uri => {$self->{$p}-><AG::dv|DVURIValue.uri>},
                          $result => $v,
                        }__;
                        $new_value-><M::dv|DVValue.setProperty> ($p => $v);
                      }
                    }
                    $elc-><M::DISElement.unlinkFromDocument>;
                  } elsif ($el-><M::DISElement.mediaTypeMatch>
                                   (<Q::lang:disdoc>, $mtopt{default_media_type},
                                    %mtopt) or
                           $el-><M::DISElement.mediaTypeMatch>
                             (<Q::lang:disdocInline>, $mtopt{default_media_type},
                                    %mtopt)) {
                    $el-><M::DISElement.preserveNodePath>;
                    my $elc = $el->clone;
                    __CODE{dv|createValue::
                      $value => {$elc},
                      $base_type => {$base_type = <Q::lang:disdoc>},
                      $type => {$el-><M::DISElement.mediaTypeURI> (%mtopt)},
                      $result => $new_value,
                    }__;
                    $elc-><M::DISElement.unlinkFromDocument>;
                  } else {
                    __CODE{dv|createValue::
                      $value => {$el-><M::SWCFGNode.value>},
                      $base_type => {$base_type = <Q::DISCore:String>},
                      $type => {$el-><M::DISElement.mediaTypeURI> (%mtopt)},
                      $result => $new_value,
                    }__;
                  }

                  unless ($copy_tree) {
                  for my $ce (@{$el-><M::DISElement.disChildElements>
                            (for_arg => $self-><AG::DISAnyResource.forURI>,
                             forp_arg => $self-><AG::DISAnyResource.forpURI>)}) {
                    my $xu = $ce-><AG::SWCFGElement.expandedURI>;
                    if ({
                      <Q::dis:AliasFor> => true,
                      <Q::dis:For> => true,
                      <Q::dis:ForCheck> => true,
                      <Q::dis:ContentType> => true,
                      <Q::dis:resourceFor> => true,
                    }->{$xu}) {
                      #
                    } elsif ($ce-><AG::DISElement.isPropertyElement>) {
                      my $pr;
                      __DEEP{
                        $pr = $add_prop->($self, $ce, $db);
                      }__;
                      if ($pr->{prop_mult} eq <Q::DISCore|OrderedList>) {
                        my $cpv = $new_value-><M::dv|DVValue.getProperty> ($xu);
                        if (not $cpv) {
                          __CODE{dv|createOrderedList::
                            $result => {$cpv},
                            $type => {$mtopt{default_media_type}},
                            $base_type => {<Q::DISCore:String>},
                          }__;
                          $new_value-><M::dv|DVValue.setProperty> ($xu => $cpv);
                        }
                        $cpv-><M::dv|DVList.addItem> ($pr->{new_value});
                      } elsif ($pr->{prop_mult} eq <Q::DISCore|UnorderedList>) {
                        my $cpv = $new_value-><M::dv|DVValue.getProperty> ($xu);
                        if (not $cpv) {
                          __CODE{dv|createUnorderedList::
                            $result => {$cpv},
                            $type => {$mtopt{default_media_type}},
                            $base_type => {<Q::DISCore:String>},
                          }__;
                          $new_value-><M::dv|DVValue.setProperty> ($xu => $cpv);
                        }
                        $cpv-><M::dv|DVList.addItem> ($pr->{new_value});
                      } else {
                        $new_value-><M::dv|DVValue.setProperty>
                                              ($xu => $pr->{new_value});
                      }
                    } else {
                      __UNDEEP{__EXCEPTION{UNSUPPORTED_ELEMENT_TYPE_ERR::
                        DIS:elementType => {$xu},
                        DIS:sourceNode => {$ce},
                      }__}__;
                    }
                  }} # copy_tree

                  {new_value => $new_value, base_type => $base_type,
                   prop_uri => $prop_uri, prop_mult => $prop_mult};
                };
                
                my $pr;
                __DEEP{
                  $pr = $add_prop->($self, $el,
                                    $self-><AG::DISAnyResource.database>);
                }__;
                if ($pr->{prop_mult} eq <Q::DISCore|OrderedList>) {
                  if (not $self->{$pr->{prop_uri}}) {
                    __CODE{dv|createOrderedList::
                      $result => {$self->{$pr->{prop_uri}}},
                      $type => {$pr->{new_value}-><AG::dv|DVValue.dataType>},
                      $base_type => {$pr->{base_type} || <Q::DISCore:String>},
                    }__;
                  }
                  $self->{$pr->{prop_uri}}-><M::dv|DVList.addItem>
                    ($pr->{new_value});
                } elsif ($pr->{prop_mult} eq <Q::DISCore|UnorderedList>) {
                  if (not $self->{$pr->{prop_uri}}) {
                    __CODE{dv|createUnorderedList::
                      $result => {$self->{$pr->{prop_uri}}},
                      $type => {$pr->{new_value}-><AG::dv|DVValue.dataType>},
                      $base_type => {$pr->{base_type} || <Q::DISCore:String>},
                    }__;
                  }
                  $self->{$pr->{prop_uri}}-><M::dv|DVList.addItem>
                    ($pr->{new_value});
                } else {
                  $self->{$pr->{prop_uri}} = $pr->{new_value};
                }
              } elsif ($el-><AG::DISElement.isResourceElement>) {
                ## TODO: Should rdf:type be validated?
              } else {
                __UNDEEP{__EXCEPTION{UNSUPPORTED_ELEMENT_TYPE_ERR::
                  DIS:elementType => {$xu},
                  DIS:sourceNode => {$el},
                }__}__;
              }
            }
            CORE::delete $self->{src};
            ($onResourceRead or sub () {})->($self, $self);
          }
        }__;
##DISAnyResource

IFClsDef:
  @IFQName: DISModule
  @ClsQName: ManakaiDISModuleDefinition

  @ClsISA: ManakaiDISPropertyAccessor
  @ClsISA: ManakaiDISExceptionTarget
  @ClsISA: ManakaiDISPerlModuleDefinition
  @ClsISA: dp|ManakaiDISModulePerl
  @ClsISA: dp|ManakaiDISAnyResourcePerl
  @ClsISA: ManakaiDISAnyResource

  @Implement: DOMMinImpl

  @enDesc:
    <QUOTE::dis> module definitions. 

  @enDesc:
    @@ForCheck: ManakaiDOM|ForIF
    @@@:
      The objects implementing the <IF::DISModule> interface <kwd:MUST>
      also implement the <IF::DISAnyResource> interface.

  @DISLang:role: ModuleRole
  
  @Attr:
    @@ForCheck: ManakaiDOM|ForClass
    @@Name: uris
    @@Type:
      Perl:Array::ManakaiDOM:all
    @@enDesc:
      A reference to the snapshot array containing the URI reference
      of the module.
    @@Get:
      @@@PerlDef:
        $r = [$self->{uri}];

  @Attr:
    @@ForCheck: ManakaiDOM|ForClass
    @@Name: ownerModule
    @@ManakaiDOM:isRedefining:1
    @@enDesc:
      This module itself.
    @@Get:
      @@@Type: DISModule
      @@@clsActualType: ManakaiDISModuleDefinition
      @@@nullCase:
        @@@@enDesc:
          The resource is not part of any module since
          its definition is not read (<IF::DISModule.isDefined> is <DOM::false>).
      @@@PerlDef: $r = $self;

  @Method:
    @@ForCheck: ManakaiDOM|ForClass
     @@Name:  getFeature
     @@Description:
        @@@lang:en
        @@@@:
          Returns a specialized object that implements the specialized 
          interfaces of the specified feature and version.
     @@Param:
        @@@Name:  feature
        @@@Type:
          DISLang:String::ManakaiDOM:all
        @@@actualType: DOMFeature|FeatureNameString||ManakaiDOM|ManakaiDOMLatest
        @@@Description:
          @@@@lang:en
          @@@@@:
            A feature name to request.
     @@Param:
        @@@Name:  version
        @@@Type:
          DISLang:String::ManakaiDOM:all
        @@@actualType:
          DOMFeature|FeatureVersionString||ManakaiDOM|ManakaiDOMLatest
        @@@Description:
          @@@@lang:en
          @@@@@:
            A feature version number to request.
     @@Return:
        @@@Type: 
          DOMMain:Object::ManakaiDOM:all
        @@@Description:
          @@@@lang:en
          @@@@@:
            An object that implements the specialized APIs of the 
            <P::feature> and <P::version>. 
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@@: 
            There is no object available that implements interfaces 
            associated with the <P::feature> and <P::version>. 
        @@@PerlDef:
          $feature =~ s/^\+//;
          CLASS: for my $class (grep {
            $Message::Util::DIS::ManakaiDISModuleDefinition::CompatClass{$_}
          } keys %Message::Util::DIS::ManakaiDISModuleDefinition::CompatClass) {
            if ($Message::DOM::ClassFeature{$class}->{$feature}->{$version}) {
              $r = bless {o => $self}, $class;
              last CLASS;
            }
          }

  @Attr:
    @@Name: isAnonymous
    @@enDesc:
      Whether the resource has persistent name or not. 
    @@Type: 
      DOMMain:boolean::ManakaiDOM:all
    @@ForCheck: ManakaiDOM|ForClass
    @@Get:
      @@@TrueCase:
        @@@@enDesc:
          A module <kwd:MUST> have a name.
      @@@PerlDef: $r = true;
##DISModule

IFClsDef:
  @IFQName: DISFor
  @ClsQName: ManakaiDISForDefinition

  @ClsISA: dp|ManakaiDISAnyResourcePerl
  @ClsISA: ManakaiDISAnyResource
  @ClsISA: ManakaiDISExceptionTarget

  @DISLang:role: ForRole

  @Description:
    @@lang:en
    @@@:
      <QUOTE::dis> <QUOTE::for> definitions. 

  @Attr:
    @@ForCheck: ManakaiDOM|ForClass
    @@Name: uris
    @@Type: 
      Perl:Array::ManakaiDOM:all
    @@actualType: ForURIList
    @@enDesc:
      A reference to the snapshot array containing the URI reference
      of the <QUOTE::for>.
    @@Get:
      @@@PerlDef:
        $r = [$self->{uri}];

  @Method:
    @@Name: isaURI
    @@Description:
      @@@lang:en
      @@@@:
        Whether this <QUOTE::for> is-a another <QUOTE::for> or not. 
    @@Param:
      @@@Name: superURI
      @@@Type: ForURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          Another <QUOTE::for> URI reference to test. 
    @@Return:
      @@@Type: 
        DOMMain:boolean::ManakaiDOM:all
      @@@TrueCase:
        @@@@enDesc:
          <P::superURI> is a super-<QUOTE::for> of this <QUOTE::for>. 
      @@@FalseCase:
        @@@@enDesc:
          <P::superURI> is not a super-<QUOTE::for> of this <QUOTE::for>. 
      @@@PerlDef:
        $r = $self->{uri} eq $superURI ? true : $self->{isa}->{$superURI};

  @Method:
    @@Name: addISA
    @@enDesc:
      Adds a <QUOTE::for> to the list of super-<QUOTE::for> of this 
      <QUOTE::for>.
    @@Param:
      @@@Name: superFor
      @@@Type: DISFor
      @@@clsActualType: ManakaiDISForDefinition
      @@@enDesc:
        A <QUOTE::for> definition object. 
    @@Return:
      @@@PerlDef:
        my @from = ($self->{uri},
                    grep {$self->{revISA}->{$_}} keys %{$self->{revISA}});
        my @to = ($superFor->{uri},
                  grep {$superFor->{isa}->{$_}} keys %{$superFor->{isa}});
        __DEEP{
          for my $from (@from) {
            for my $to (@to) {
              $self->{db}-><M::ManakaiDISDatabase.getFor>
                                      ($from)->{isa}->{$to} = true;
              $self->{db}-><M::ManakaiDISDatabase.getFor>
                                      ($to)->{revISA}->{$from} = true;
            }
          }
        }__;

  @Method:
     @@Name:  getFeature
     @@Description:
        @@@lang:en
        @@@@:
          Returns a specialized object that implements the specialized 
          interfaces of the specified feature and version.
     @@Param:
        @@@Name:  feature
        @@@Type:
          DISLang:String::ManakaiDOM:all
        @@@actualType:
          ManakaiDOM:ManakaiDOMFeatureName::ManakaiDOM:ManakaiDOMLatest
        @@@Description:
          @@@@lang:en
          @@@@@:
            A feature name to request.
     @@Param:
        @@@Name:  version
        @@@Type:
          DISLang:String::ManakaiDOM:all
        @@@actualType:
          ManakaiDOM:ManakaiDOMFeatureVersion::ManakaiDOM:ManakaiDOMLatest
        @@@Description:
          @@@@lang:en
          @@@@@:
            A feature version number to request.
     @@Return:
        @@@Type: 
          DOMMain:Object::ManakaiDOM:all
        @@@Description:
          @@@@lang:en
          @@@@@:
            An object that implements the specialized APIs of the 
            <P::feature> and <P::version>. 
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@@: 
            There is no object available that implements interfaces 
            associated with the <P::feature> and <P::version>. 
        @@@PerlDef:
          $feature =~ s/^\+//;
          CLASS: for my $class (grep {
            $Message::Util::DIS::ManakaiDISForDefinition::CompatClass{$_}
          } keys %Message::Util::DIS::ManakaiDISForDefinition::CompatClass) {
            if ($Message::DOM::ClassFeature{$class}->{$feature}->{$version}) {
              $r = bless {o => $self}, $class;
              last CLASS;
            }
          }

  @Attr:
    @@Name: isAnonymous
    @@enDesc:
      Whether the resource has persistent name or not. 
    @@Type: 
      DOMMain:boolean::ManakaiDOM:all
    @@ForCheck: ManakaiDOM|ForClass
    @@Get:
      @@@TrueCase:
        @@@@enDesc:
          A <QUOTE::for> <kwd:MUST> have a name.
      @@@PerlDef: $r = true;

  @Attr:
    @@ForCheck: ManakaiDOM|ForClass
    @@Name: forURI
    @@Type: ForURI
    @@enDesc:
      The <QUOTE::for> URI reference for which this module is defined. 
    @@Get:
      @@@InCase:
        @@@@Value:
          @@@@@@: ManakaiDOM|all
          @@@@@ContentType: dis|TypeQName
        @@@@enDesc:
          The attribute value is always <Q::ManakaiDOM|all> for a
          <QUOTE::for> resource.
      @@@PerlDef:
        $r = <Q::ManakaiDOM|all>;

  @Attr:
    @@Name: forpURI
    @@enDesc:
      The <QUOTE::for+> URI references for which this resource is defined. 
    @@Type: ForURIList
    @@Get:
      @@@enDesc:
        List of <QUOTE::for> URI references.  Note that this list is
        <QUOTE::dead>.
      @@@InCase:
        @@@@Value:
          @@@@@@: []
          @@@@@ContentType: lang|Perl
        @@@@enDesc:
          The attribute value is always an empty array reference
          for a <QUOTE::for> resource.
      @@@PerlDef: $r = [];

  @Method:
    @@Name: isForURI
    @@enDesc:
      Tests whether this resource is defined for a <QUOTE::for>
      or <QUOTE::for+> URI reference or not.
    @@Param:
      @@@Name:forURI
      @@@Type:ForURI
      @@@enDesc:
        A <QUOTE::for> URI reference to test.
    @@Return:
      @@@Type:
        DOMMain:boolean::ManakaiDOM:all
      @@@TrueCase:
        @@@@enDesc:
          This resource is for <P::forURI>.  The attribute
          always takes this value for <QUOTE::for> resources.
      @@@PerlDef: $r = true;

  @Attr:
    @@ForCheck: ManakaiDOM|ForClass
    @@Name: nameURI
    @@Type: NameURI
    @@enDesc:
      The URI reference of this module, without 
      <QUOTE::for> identifier. 
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          The attribute value is always <DOM::null> for <QUOTE::for>
          resources.
      @@@PerlDef:
##DISFor

PropDef:
  @QName: isFeatureImplemented
  @enDesc:
    The list of whether a feature is implemented or not. 

ResourceDef:
  @QName: PLFile
  @AliasFor:
    PerlCode:ManakaiPerlFile::ManakaiDOM:Perl
  @rdf:type:
    rdfs:Class

IFClsDef:
  @IFQName: DISResource
  @ClsQName: ManakaiDISResourceDefinition

  @ClsISA: ManakaiDISResourceMV
  @ClsISA: dp|ManakaiDISResourcePerl
  @ClsISA: ManakaiDISPerlModuleDefinition
  @ClsISA: dp|ManakaiDISAnyResourcePerl
  @ClsISA: ManakaiDISPropertyAccessor
  @ClsISA: ManakaiDISAnyResource
  @ClsISA: ManakaiDISExceptionTarget

  @DISLang:role: ResourceRole

  @enDesc:
    <QUOTE::dis> resource definitions. 

  @enDesc:
    @@ForCheck: ManakaiDOM|ForIF    
    @@@:
      The objects implementing the <IF::DISResource> interface
      <kwd:MUST> also implement the <IF::DISAnyResource> interface.

  @Attr:
    @@ForCheck: ManakaiDOM|ForClass
    @@Name: uris
    @@Type: 
      Perl:Array::ManakaiDOM:all
    @@enDesc:
      Returns the current <EM::snapshot> of the URI references
      for this resource, including the alias URI references.
    @@Get:
      @@@PerlDef:
        $r = [grep {$self->{aliasURI}->{$_}} keys %{$self->{aliasURI}}];

  @Method:
    @@Name: isSubsetOfURI
    @@Description:
      @@@lang:en
      @@@@:
        Whether this resource is a subset of another resource or not. 
    @@Param:
      @@@Name: superURI
      @@@Type: ResourceURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          Another resource URI reference to test. 
    @@Return:
      @@@Type: 
        DOMMain:boolean::ManakaiDOM:all
      @@@TrueCase:
        @@@@enDesc:
          <P::superURI> is a super-resource of this resource. 
      @@@FalseCase:
        @@@@enDesc:
          <P::superURI> is not a super-resource of this resource. 
      @@@PerlDef:
        $r = $self->{aliasURI}->{$superURI} || $self->{subOf}->{$superURI};

  @Method:
    @@Name: addSuperResource
    @@enDesc:
      Adds a <QUOTE::dis> resource to the list of super-resource 
      of this <QUOTE::dis> resource. 
    @@Param:
      @@@Name: superRes
      @@@Type: DISResource
      @@@clsActualType: ManakaiDISResourceDefinition
      @@@enDesc:
        A <QUOTE::dis> resource definition object. 
    @@Return:
      @@@PerlDef:
        my @from = ($self->{uri},
                    grep {$self->{supOf}->{$_}} keys %{$self->{supOf}});
        my @to = ($superRes->{uri},
                  grep {$superRes->{subOf}->{$_}} keys %{$superRes->{subOf}});
        __DEEP{
          for my $from (@from) {
            for my $to (@to) {
              $self->{db}-><M::ManakaiDISDatabase.getResource>
                                      ($from)->{subOf}->{$to} = true;
              $self->{db}-><M::ManakaiDISDatabase.getResource>
                                      ($to)->{supOf}->{$from} = true;
            }
          }
        }__;
   
  @Method:
    @@Name: mergeAsAlias
    @@enDesc:
      Merges another resource definition as an alias of this resource. 
    @@Param:
      @@@Name: aliasResource
      @@@Type: DISResource
      @@@clsActualType: ManakaiDISResourceDefinition
      @@@enDesc:
        A resource to merge.
        \
        {NOTE:: After merging all references to <P::aliasResource> 
                should be discarded.
        \
        }
    @@NodeParam:
    @@Return:
      @@@RaiseException:
        @@@@@:MERGE_ITSELF_ERR
        @@@@@@enDesc:
          An attempt is made to merge this resource itself. 
      @@@PerlDef:
        if ($self eq $aliasResource) {
          __EXCEPTION{MERGE_ITSELF_ERR::
            DIS:uri => {$self->{uri}},
            DIS:sourceNode => {$node},
          }__;
        }
        for my $uri ($aliasResource->{uri}, 
                     grep {$aliasResource->{aliasURI}->{$_}}
                          keys %{$aliasResource->{aliasURI}}) {
          $self->{aliasURI}->{$uri} = true;
          $self->{db}->{resDef}->{$uri} = $self;
          $self->{subOf}->{$uri} = true;
          $self->{supOf}->{$uri} = true;
        }
        for my $uri (grep {$aliasResource->{subOf}->{$_}}
                          keys %{$aliasResource->{subOf}}) {
          $self->{subOf}->{$uri} = true;
        }
        for my $uri (grep {$aliasResource->{supOf}->{$_}}
                          keys %{$aliasResource->{supOf}}) {
          $self->{supOf}->{$uri} = true;
        }
        my @from = grep {$self->{supOf}->{$_}} keys %{$self->{supOf}};
        my @to   = grep {$self->{subOf}->{$_}} keys %{$self->{subOf}};
        __DEEP{
          for my $from (@from) {
            for my $to (@to) {
              $self->{db}-><M::ManakaiDISDatabase.getResource>
                                      ($from)->{subOf}->{$to} = true;
              $self->{db}-><M::ManakaiDISDatabase.getResource>
                                      ($to)->{supOf}->{$from} = true;
            }
          }
        }__;

  @Method:
    @@Name: isTypeURI
    @@enDesc:
      Tests whether this resource is of a type or not. 
    @@Param:
      @@@Name: typeURI
      @@@Type: ResourceURI
      @@@enDesc:
        A type URI reference to test. 
    @@Return:
      @@@Type:
        DOMMain:boolean::ManakaiDOM:all 
      @@@TrueCase:
        @@@@enDesc:
          This is a <P::typeURI> resource. 
      @@@FalseCase:
        @@@@enDesc:
          This is not a <P::typeURI> resource. 
      @@@PerlDef:
        if (not $self->{<Q::rdf:type>}) {
          #
        } elsif ($self->{<Q::rdf:type>}->{$typeURI}) {
          $r = true;
        } else {
          __DEEP{
            C: for my $t_type_uri (grep {$self->{<Q::rdf:type>}->{$_}}
                                        keys %{$self->{<Q::rdf:type>}}) {
              my $t_type = $self-><AG::DISAnyResource.database>
                                -><M::DISDatabase.getResource> ($t_type_uri);
              if ($t_type-><M::DISResource.isSubsetOfURI> ($typeURI)) {
                $self-><M::DISResourceProp.addPropertyURIUList>
                                            (<Q::rdf:type>, $typeURI);
                $r = true;
                last C;
              }
            }
          }__;
        }

  @Attr:
    @@Name: disDataTypeResource
    @@enDesc:
      The resource referenced by <Q::dis:Type> property.

      = If the resource has the <Q::dis:Type> property, 
        then its value references the data type resource.

      = If the resource has no <Q::dis:Type> property but
        the dynamic parent resource has the <Q::dis:Type> property,
        then its value references the data type resource.
 
      = Otherwise, the resource has no associated data type resoruce;
        this method throws a <X::NO_DIS_TYPE_ERR> exception.
    @@Type: DISResource
    @@clsActualType: ManakaiDISResourceDefinition
    @@Get:
      @@@RaiseException:
        @@@@@:NO_DIS_TYPE_ERR
        @@@@enDesc:
          <Q::dis:Type> attribute is not specified. 
      @@@PerlDef:
        __DEEP{
          if (UNIVERSAL::isa ($self->{<Q::dis:Type>}, <IFName::dv|DVURIValue>)) {
            $r = $self->{<Q::dis:Type>}-><M::dv|DVURIValue.getResource>
                     ($self-><AG::DISAnyResource.database>);
          } else {
            my $pr = $self-><M::DISResourceProp.getPropertyResource>
                                  (<Q::DIS|dynamicParentResource>);
            $r = $pr-><AG::DISResource.disDataTypeResource> if $pr;
          }
        }__;
        unless ($r) {
          __EXCEPTION{NO_DIS_TYPE_ERR::
            DIS:uri => {$self-><AG::DISAnyResource.uri>},
            DIS:sourceNode => {$self-><AG::DISAnyResource.sourceElement>},
          }__;
        }

  @Attr:
    @@Name: disDataTypeValue
    @@enDesc:
      The <Q::dis:Type> property value for the resource.
    @@Get:
      @@@Type: dv|DVURIValue
      @@@clsActualType: dv|ManakaiDVURIValue
      @@@RaiseException:
        @@@@@:NO_DIS_TYPE_ERR
        @@@@enDesc:
          <Q::dis:Type> attribute is not specified.
      @@@PerlDef:
        __DEEP{
          if (UNIVERSAL::isa ($self->{<Q::dis:Type>}, <IFName::dv|DVURIValue>)) {
            $r = $self->{<Q::dis:Type>};
          } else {
            my $pr = $self-><M::DISResourceProp.getPropertyResource>
                                  (<Q::DIS|dynamicParentResource>);
            $r = $pr-><AG::DISResource.disDataTypeValue> if $pr;
          }
        }__;
        unless ($r) {
          __EXCEPTION{NO_DIS_TYPE_ERR::
            DIS:uri => {$self-><AG::DISAnyResource.uri>},
            DIS:sourceNode => {$self-><AG::DISAnyResource.sourceElement>},
          }__;
        }

  @Attr:
    @@Name: disActualDataTypeResource
    @@enDesc:
      <Q::dis:actualType> attribute value of this resource. 
    @@Type: DISResource
    @@clsActualType: ManakaiDISResourceDefinition
    @@Get:
      @@@RaiseException:
        @@@@@:NO_DIS_TYPE_ERR
        @@@@enDesc:
          <Q::dis:actualType> attribute is not specified, 
          and <Q::dis:Type> attribute, neigher. 
      @@@PerlDef:
        __DEEP{
          if (UNIVERSAL::isa ($self->{<Q::dis:actualType>},
                              <IFName::dv|DVURIValue>)) {
            $r = $self->{<Q::dis:actualType>}-><M::dv|DVURIValue.getResource>
                    ($self-><AG::DISAnyResource.database>);
          } elsif (UNIVERSAL::isa ($self->{<Q::dis:Type>},
                                   <IFName::dv|DVURIValue>)) {
            $r = $self->{<Q::dis:Type>}-><M::dv|DVURIValue.getResource>
                    ($self-><AG::DISAnyResource.database>);
          } else {
            my $pr = $self-><M::DISResourceProp.getPropertyResource>
                                  (<Q::DIS|dynamicParentResource>);
            $r = $pr-><AG::DISResource.disActualDataTypeResource> if $pr;
          }
        }__;
        unless ($r) {
          __EXCEPTION{NO_DIS_TYPE_ERR::
            DIS:uri => {$self-><AG::DISAnyResource.uri>},
            DIS:sourceNode => {$self-><AG::DISAnyResource.sourceElement>},
          }__;
        }

  @Attr:
    @@Name: disActualDataTypeValue
    @@enDesc:
      <Q::dis:actualType> node for this resource. 
    @@Get:
      @@@Type: DISElement
      @@@clsActualType: ManakaiDISElement
      @@@RaiseException:
        @@@@@:NO_DIS_TYPE_ERR
        @@@@enDesc:
          <Q::dis:actualType> attribute is not specified, 
          and <Q::dis:Type> attribute, neigher. 
      @@@PerlDef:
        __DEEP{
          if (UNIVERSAL::isa ($self->{<Q::dis:actualType>},
                              <IFName::dv|DVURIValue>)) {
            $r = $self->{<Q::dis:actualType>};
          } elsif (UNIVERSAL::isa ($self->{<Q::dis:Type>},
                                   <IFName::dv|DVURIValue>)) {
            $r = $self->{<Q::dis:Type>};
          } else {
            my $pr = $self-><M::DISResourceProp.getPropertyResource>
                                  (<Q::DIS|dynamicParentResource>);
            $r = $pr-><AG::DISResource.disActualDataTypeValue> if $pr;
          }
        }__;
        unless ($r) {
          __EXCEPTION{NO_DIS_TYPE_ERR::
            DIS:uri => {$self-><AG::DISAnyResource.uri>},
            DIS:sourceNode => {$self-><AG::DISAnyResource.sourceElement>},
          }__;
        }

  @IntMethod:
    @@Operator:
      @@@@: <=>
      @@@ContentType:
        lang:Perl
    @@enDesc:
      Which is greater (i.e. the spaceship operator). 
      A resource is less than another if it is loaded by
      <M::ManakaiDISDatabase.loadResource> before another is loaded. 
      Order for non-loaded resource definitions are not defined. 
      \
      {NOTE:: In the current implementation, non-loaded resources 
              are less than any loaded resource and the order in 
              non-loaded resources is unknown. 
      \
      }
    @@Param:
      @@@Name: anotherResource
      @@@Type: DISResource
      @@@enDesc: Another resource to compare.
    @@Return:
      @@@Type:
        DOMMain:unsigned-long::ManakaiDOM:all
      @@@PerlDef:
        if (UNIVERSAL::isa ($anotherResource,
                            <ClassName::ManakaiDISResourceDefinition>)) {
          $r = $self->{seq} <=> $anotherResource->{seq};
        } else {
          $r = overload::Overloaded ($self) <=> $anotherResource;
        }

  @Method:
    @@Name: getChildResourceByType
    @@enDesc:
      Gets a static child resource selected by its type. 
    @@Param:
      @@@Name:typeURI
      @@@Type:ResourceURI
      @@@enDesc:
        A URI reference identifying a resource type. 
    @@ImplNote:
      @@@lang:en
      @@@@:
        ISSUE: Some inheritance tracing required for 
        e.g. <Q::DISLang:InputProcessor> and <Q::DOMMain:ReflectGet>?
    @@Return:
      @@@Type: DISResource
      @@@clsActualType: ManakaiDISResourceDefinition
      @@@enDesc:
        The first child resource (in document order) whose 
        type matches with <P::typeURI>. 
      @@@nullCase:
        @@@@enDesc:
          There is no resource whose type is <P::typeURI>.
      @@@PerlDef:
        __DEEP{
          for my $cr_uri (map {
                            $_-><AG::dv|DVURIValue.uri>
                          } @{$self->{<Q::DIS:childResource>}}) {
            my $cr = $self->{db}-><M::ManakaiDISDatabase.getResource>
                                             ($cr_uri);
            if ($cr-><M::ManakaiDISResourceDefinition.isTypeURI> ($typeURI)) {
              $r = $cr;
              last;
            }
          }
        }__;

  @Method:
    @@Name: getChildResourceByNameAndType
    @@enDesc:
      Gets a static child resource selected by its local name and type. 
    @@Param:
      @@@Name: localName
      @@@Type:
        DISCore:LocalName::ManakaiDOM:all
      @@@enDesc:
        A local name. 
    @@Param:
      @@@Name:typeURI
      @@@Type:ResourceURI
      @@@enDesc:
        A URI reference identifying a resource type. 
    @@Return:
      @@@Type: DISResource
      @@@clsActualType: ManakaiDISResourceDefinition
      @@@enDesc:
        The first (by document order) child resource whose 
        type matches for <P::localName> and <P::typeURI>. 
      @@@nullCase:
        @@@@enDesc:
          There is no resource whose name is <P::localName> and
          whose type is <P::typeURI>.
      @@@PerlDef:
        __DEEP{
          for my $cr_uri (map {
                            $_-><AG::dv|DVURIValue.uri>
                          } @{$self->{<Q::DIS:childResource>}}) {
            my $cr = $self->{db}-><M::ManakaiDISDatabase.getResource>
                                             ($cr_uri);
            my $ln = $cr-><AG::DISAnyResource.localName>;
            if (defined $ln and $ln eq $localName and
                $cr-><M::ManakaiDISResourceDefinition.isTypeURI> ($typeURI)) {
              $r = $cr;
              last;
            }
          }
        }__;

  @Method:
    @@Name: getConstResourceByName
    @@enDesc:
      Gets a constant value resource by its local name. 
    @@Param:
      @@@Name:localName
      @@@Type:
        DISLang:String::ManakaiDOM:all
      @@@enDesc:
        Constant name.
    @@Return:
      @@@Type: DISResource
      @@@clsActualType: ManakaiDISResourceDefinition
      @@@enDesc:
        The constant resource identified by <P::localName>.
      @@@nullCase:
        @@@@enDesc:
          There is no such constant resource.
      @@@PerlDef:
        __DEEP{
          my @constGroup;
          for my $cr_uri (map {
                            $_-><AG::dv|DVURIValue.uri>
                          } @{$self->{<Q::DIS:childResource>}}) {
            my $cr = $self->{db}-><M::ManakaiDISDatabase.getResource>
                                             ($cr_uri);
            my $ln = $cr-><AG::DISAnyResource.localName>;
            if ($ln and $ln eq $localName and
                $cr-><M::ManakaiDISResourceDefinition.isTypeURI>
                         (<Q::ManakaiDOM:Const>)) {
              $r = $cr;
              last;
            } elsif ($cr-><M::ManakaiDISResourceDefinition.isTypeURI>
                                (<Q::ManakaiDOM:ConstGroup>)) {
              push @constGroup, $cr;
            }
          }
          unless ($r) {
            for my $cg (@constGroup) {
              $r = $cg-><M::ManakaiDISResourceDefinition
                                .getChildResourceByNameAndType>
                             ($localName, <Q::ManakaiDOM:Const>);
              last if $r;
            }
          }
        }__;

  @Attr:
    @@Name: ownerClassNodeURI
    @@enDesc:
      The node URI reference of the class resource this resource
      belongs to.
    @@Type: ResourceURI
    @@Get:
      @@@enDesc:
        The URI reference of the <Q::ManakaiDOM:Class> resource.
        If this resource is a class, then the URI reference
        of this resource is returned.
      @@@nullCase:
        @@@@enDesc:
          This resource does not belong to any class.
      @@@PerlDef:
        if (exists $self->{<Q::DIS:ownerClass>}) {
          $r = $self->{<Q::DIS:ownerClass>};
        } else {
          my $res = $self;
          __DEEP{
            RES: {
              if ($res-><M::ManakaiDISResourceDefinition.isTypeURI>
                             (<Q::ManakaiDOM:Class>)) {
                $r = $res-><AG::DISAnyResource.sourceNodeID>;
              } else {
                $res = $res-><M::ManakaiDISPropertyAccessor
                              .getPropertyResource> (<Q::dis2pm:parentResource>);
                redo RES if $res;
              }
            }
          }__;
          $self->{<Q::DIS:ownerClass>} = $r;
        }

  @Attr:
    @@Name: disIsNullValue
    @@enDesc:
      Whether this resource have <DOM::null> value or not. 
      A resource have <DOM::null> value iff it has
      <Q::dis:Value> attribute node that in turn has
      <Q::dis:is-null> attribute whose value set to <DOM::true>.
    @@Type:
      DOMMain:boolean::ManakaiDOM:all
    @@Get:
      @@@PerlDef:
        if ($self->{prop}->{<Q::dis:Value>}) {
          $r = $self->{prop}->{<Q::dis:Value>}-><AG::dv|DVValue.isNull>;
        } elsif ($self->{src}) {
          __DEEP{
            my $val = $self->{src}-><M::DISElement.disGetAttribute>
                              (<Q::dis:Value>,
                               for_arg => $self-><AG::DISAnyResource.forURI>,
                               forp_arg => $self-><AG::DISAnyResource.forpURI>);
            if ($val) {
              my $isnull = $val-><M::DISElement.disGetAttribute>
                              (<Q::dis:is-null>,
                               for_arg => $self-><AG::DISAnyResource.forURI>,
                               forp_arg => $self-><AG::DISAnyResource.forpURI>);
              if ($isnull and $isnull-><M::SWCFGNode.value>) {
                $r = true;
              }
            }
          }__;
        }

  @Method:
    @@Name: isFeatureProvided
    @@enDesc:
      Whether a feature is provided by this resource or not.
      Note that the feature is actually available (implemented)
      or not is other thing (use <M::ManakaiDISPerlModuleDefinition
      .plIsFeatureImplemented> instead).
    @@Param:
      @@@Name: featureResourceURI
      @@@Type: ResourceURI
      @@@enDesc:
        The URI reference of the resource definition for the feature to test.
    @@Return:
      @@@Type:
        DOMMain:boolean::ManakaiDOM:all
      @@@enDesc:
        Whether the feature is provided or not.
      @@@PerlDef:
      __DEEP{
        my @f = @{$self-><M::ManakaiDISPropertyAccessor
                               .getPropertyResourceList>
                                  (<Q::DOMMain:implementFeature>,
                                   isa_recursive => true,
                                   default_media_type => <Q::dis:TypeQName>)};
        if (@f) {
          for my $f (@f) {
            if ($f-><M::ManakaiDISResourceDefinition.isSubsetOfURI>
                         ($featureResourceURI)) {
              $r = true;
              last;
            }
          }
        } else {
          my $parent = $self-><M::ManakaiDISPropertyAccessor
                                 .getPropertyResource>
                                   (<Q::dis2pm:parentResource>);
          $r = $parent-><M::ManakaiDISResourceDefinition.isFeatureProvided>
                                   ($featureResourceURI)
            if $parent;
        }
      }__;

  @Attr:
    @@Name: featureNameList
    @@enDesc:
      The list of the names of the feature defined by this resource.

        = If the resource has one or more <Q::dis:AppName> attributes,
          their text values are feature names.

        = If there is no <Q::dis:AppName> attributes but the resource
          is a <Q::DOMFeature:instanceOf> another feature, then 
          the set of the feature names of the resource is equal
          to the one of another feature's feature names.

        {OLI:: If two operation above does not result in one or more
               feature names,

           = and if the resource has a name (the <A::DISAnyResource
             .isAnonymous> attribute returns <DOM::false>), then
             the <A::DISAnyResource.nameURI> of the resource is 
             a feature name.

           = otherwise, i.e. <A::DISAnyResource.isAnonymous> is
             <DOM::true>, then the <A::DISAnyResource.localName>
             of the resource, if non-<DOM::null>, is a feature name.

        }

    @@Type:
      Perl:ARRAY::ManakaiDOM:all
    @@Get:
      @@@enDesc:
        A reference to the array containing feature names.
        Note that the order in the array is <EM::not> significant.
        The array might be empty if the resource has no feature name.
        This array is dead.

        {NOTE:: The attribute value array might be non-empty
                even if the resource is not of type <Q::DOMFeature:Feature>
                as far as the algorithm defined above returns
                some feature names.
        }
      @@@RaiseException:
        @@@@@:UNSUPPORTED_MEDIA_TYPE_ERR
        @@@@enDesc:
          There is an <Q::dis:AppName> attribute whose media 
          type is not supported.
      @@@RaiseException:
        @@@@@: NO_SOURCE_NODE_ERR
        @@@@enDesc:
          This resource definition does not have associated node 
          in the source tree. 
      @@@PerlDef:
        unless ($self->{src}) {
          __EXCEPTION{NO_SOURCE_NODE_ERR::
            DIS:uri => {$self->{uri}},
          }__;
        }
        __DEEP{
          $r = map {lc} @{$self-><M::DISResourceProp.getPropertyTextList>
                            (<Q::dis:AppName>,
                             default_media_type => <Q::dis:String>)};
          unless (@$r) {
            ## TODO: instance feature
            my $pr = $self-><M::DISResourceProp
                              .getPropertyResource> (<Q::dis2pm:parentResource>);
            if ($pr) {
              if ($pr-><M::DISResource.isTypeURI>
                            (<Q::DOMMain:DOMFeature>) and
                  not $pr-><AG::DISAnyResource.isAnonymous>) {
                push @$r, @{$pr-><AG::DISResource.featureNameList>};
              }
            }
          }
          unless (@$r) {
            if ($self-><AG::DISAnyResource.isAnonymous>) {
              my $ln = $self-><AG::DISAnyResource.localName>;
              push @$r, lc $ln if defined $ln;
            } else {
              push @$r, lc $self-><AG::DISAnyResource.nameURI>;
            }
          }
        }__;

  @Method:
     @@ForCheck: ManakaiDOM|ForClass
     @@Name:  getFeature
     @@Description:
        @@@lang:en
        @@@@:
          Returns a specialized object that implements the specialized 
          interfaces of the specified feature and version.
     @@Param:
        @@@Name:  feature
        @@@Type:
          DISLang:String::ManakaiDOM:all
        @@@actualType:
          ManakaiDOM:ManakaiDOMFeatureName::ManakaiDOM:ManakaiDOMLatest
        @@@Description:
          @@@@lang:en
          @@@@@:
            A feature name to request.
     @@Param:
        @@@Name:  version
        @@@Type:
          DISLang:String::ManakaiDOM:all
        @@@actualType:
          ManakaiDOM:ManakaiDOMFeatureVersion::ManakaiDOM:ManakaiDOMLatest
        @@@Description:
          @@@@lang:en
          @@@@@:
            A feature version number to request.
     @@Return:
        @@@Type: 
          DOMMain:Object::ManakaiDOM:all
        @@@Description:
          @@@@lang:en
          @@@@@:
            An object that implements the specialized APIs of the 
            <P::feature> and <P::version>. 
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@@: 
            There is no object available that implements interfaces 
            associated with the <P::feature> and <P::version>. 
        @@@PerlDef:
          $feature =~ s/^\+//;
          CLASS: for my $class (grep {
            $Message::Util::DIS::ManakaiDISResourceDefinition::CompatClass{$_}
          } keys %Message::Util::DIS::ManakaiDISResourceDefinition::CompatClass){
            if ($Message::DOM::ClassFeature{$class}->{$feature}->{$version}) {
              $r = bless {o => $self}, $class;
              last CLASS;
            }
          }

  @Attr:
    @@Name: multiplePropertiesURI
    @@enDesc:
      Whether the property allows multiple occurence of the attribute
      in the <QUOTE::dis> source tree.
    @@Type: DISLang|String||ManakaiDOM|all
    @@Get:
      @@@PerlDef:
        __DEEP{
          if ($self->{<Q::dis|multipleProperties>}) {
            $r = $self->{<Q::dis|multipleProperties>}
                      -><M::dv|DVURIValue.getResource>
                            ($self-><AG::DISAnyResource.database>)
                      -><AG::DISAnyResource.uri>;
          } else {
            $r = <Q::DISCore|OrderedList>;
          }
        }__;

  @Attr:
    @@Name: defaultLextypeURI
    @@enDesc:
      The URI of the default lexical type for the <QUOTE::dis> attribute.
    @@Type: DISLang|String||ManakaiDOM|all
    @@Get:
      @@@PerlDef:
        __DEEP{
          if ($self->{<Q::dis:dataType>}) {
            $r = $self->{<Q::dis:dataType>}
                      -><M::dv|DVURIValue.getResource>
                            ($self-><AG::DISAnyResource.database>)
                      -><AG::DISAnyResource.uri>;
          } else {
            $r = <Q::DISCore|String>;
          }
        }__;
##DISResource

IFClsDef:
  @IFQName: DISResourceMV
  @ClsQName: ManakaiDISResourceMV
  
  @enDesc:
    The objects implementing the <IF::DISResourceMV> <kwd:MUST>
    also implement the <IF::DISResource> interface.

  @Attr:
    @@Name: mvLocalName
    @@enDesc:
      The local name of the markup vocabulary element defined by this
      resource.
    @@Type:
      DISLang:String::ManakaiDOM:all
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          Either this resource does not define a markup vocabulary element
          or it does define an element but it does not have a local name.
      @@@PerlDef:
        __DEEP{
          if (UNIVERSAL::isa ($self->{<Q::dis|AppName>},
                              <IFName::dv|DVQNameValue>)) {
            $r = $self->{<Q::dis|AppName>}-><AG::dv|DVQNameValue.localName>;
          } elsif (exists $self->{<Q::mvLocalName>}) {
            $r = $self->{<Q::mvLocalName>};
          } elsif ($self->{src}) {
            my $node = $self->{src}-><M::ManakaiDISElement.disGetAttribute>
                        (<Q::dis:AppName>, 
                         for_arg => $self->{for},
                         forp_arg => $self->{forp},
                         media_type => <Q::dis:TypeQName>,
                         default_media_type => <Q::dis:TypeQName>);
            if ($node) {
              $r = $self->{<Q::mvLocalName>}
                 = $node-><AG::ManakaiDISElement.qnameValueLocalName>;
            } else {
              $r = $self->{<Q::mvLocalName>} = $self->{localName};
            }
          } else {
            $r = $self->{<Q::mvLocalName>} = $self->{localName};
          }
        }__;

  @Attr:
    @@Name: mvPrefix
    @@enDesc:
      A typical namespace prefix of the markup vocabulary element defined
      by this resource.
    @@Type:
      DISLang:String::ManakaiDOM:all
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          Either this resource does not define a markup vocabulary element
          or it does define an element but it does not have a namespace URI.
      @@@PerlDef:
        __DEEP{
          if (UNIVERSAL::isa ($self->{<Q::dis|AppName>},
                              <IFName::dv|DVQNameValue>)) {
            $r = $self->{<Q::dis|AppName>}-><AG::dv|DVQNameValue.prefix>;
          } elsif (exists $self->{<Q::mvPrefix>}) {
            $r = $self->{<Q::mvPrefix>};
          } elsif ($self->{src}) {
            my $node = $self->{src}-><M::ManakaiDISElement.disGetAttribute>
                        (<Q::dis:AppName>, 
                         for_arg => $self->{for},
                         forp_arg => $self->{forp},
                         media_type => <Q::dis:TypeQName>,
                         default_media_type => <Q::dis:TypeQName>);
            if ($node) {
              $r = $self->{<Q::mvPrefix>}
                 = $node-><AG::ManakaiDISElement.qnameValuePrefix>;
            } else {
              $r = $self->{<Q::mvPrefix>} = null;
            }
          } else {
            $r = $self->{<Q::mvPrefix>} = null;
          }
          unless (defined $r) {
            my $nsuri = $self-><AG::DISResourceMV.mvNamespaceURI>;
            if (defined $nsuri and $nsuri =~ /([A-Za-z]\w*)\W*$/) {
              $r = $self->{<Q::mvPrefix>} = $1;
            } elsif (defined $nsuri) {
              $r = $self->{<Q::mvPrefix>} = 'ns';
            }
          }
        }__;

  @Attr:
    @@Name: mvNamespaceURI
    @@enDesc:
      The namespace URI of the markup vocabulary element defined by this
      resource.
    @@Type: AnyURI
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          Either this resource does not define a markup vocabulary element
          or it does define an element but it does not have a namespace URI.
      @@@PerlDef:
        __DEEP{
          if (UNIVERSAL::isa ($self->{<Q::dis|AppName>},
                              <IFName::dv|DVQNameValue>)) {
            $r = $self->{<Q::dis|AppName>}-><AG::dv|DVQNameValue.namespaceURI>;
          } elsif (exists $self->{<Q::mvNamespaceURI>}) {
            $r = $self->{<Q::mvNamespaceURI>};
          } elsif ($self->{src}) {
            my $node = $self->{src}-><M::ManakaiDISElement.disGetAttribute>
                        (<Q::dis:AppName>, 
                         for_arg => $self->{for},
                         forp_arg => $self->{forp},
                         media_type => <Q::dis:TypeQName>,
                         default_media_type => <Q::dis:TypeQName>);
            if ($node) {
              $r = $self->{<Q::mvNamespaceURI>}
                 = $node-><AG::ManakaiDISElement.qnameValueNamespaceURI>;
            } else {
              $r = $self->{<Q::mvNamespaceURI>} = $self->{namespaceURI};
            }
          } else {
            $r = $self->{<Q::mvNamespaceURI>} = $self->{namespaceURI};
          }
        }__;

  @Attr:
    @@Name: mvOwnerElementResource
    @@enDesc:
      An <QUOTE::owner element> resource of the markup vocabulary
      element defined by this resource.
    @@Type: DISResource
    @@clsActualType: ManakaiDISResourceDefinition
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          Either this resource does not define a markup vocabulary element
          or it does define an element but it does not have an owner.
      @@@PerlDef:
        __DEEP{
          if (exists $self->{<Q::DIS:mvOwnerElementURI>}) {
            $r = $self->{db}-><M::ManakaiDISDatabase.getResource>
                                ($self->{<Q::DIS:mvOwnerElementURI>})
              if defined $self->{<Q::DIS:mvOwnerElementURI>};
          } elsif (defined $self->{<Q::dis2pm:parentResource>}) {
            $r = $self->{db}-><M::ManakaiDISDatabase.getResource>
                                ($self->{<Q::dis2pm:parentResource>});
            undef $r unless $r-><M::ManakaiDISResourceDefinition
                                   .isTypeURI> (<Q::s:AnyOwnerElement>);
            $self->{<Q::DIS:mvOwnerElementURI>} = $r->{uri} if $r;
          }
        }__;
##DISResourceMV

PropDef:
  @QName: mvLocalName
  @enDesc:
    <A::ManakaiDISResourceDefinition.mvLocalName>.

PropDef:
  @QName: mvPrefix
  @enDesc:
    <A::ManakaiDISResourceDefinition.mvPrerix>.

PropDef:
  @QName: mvNamespaceURI
  @enDesc:
    <A::ManakaiDISResourceDefinition.mvNamespaceURI>.

PropDef:
  @QName: mvOwnerElementURI
  @enDesc:
    <A::ManakaiDISResourceDefinition.mvOwnerElementResource>
    (<QUOTE::dis> resource URI reference).

PropDef:
  @QName: plFullyQualifiedName
  @enDesc:
    Fully qualified name.

PropDef:
  @QName:plDefined
  @enDesc:
    Whether a Perl definition for this resource is implemented or not.

PropDef:
  @QName: ownerClass
  @enDesc:
    The class to which this resource belongs.
  @Type: ResourceURI
  @rdfs:range: 
    rdf:Resource
  @rdfs:domain: 
    ManakaiDOM:Class

ResourceDef:
  @QName: DOMMinImpl
  @rdf:type:
    ManakaiDOM:IF
  @AliasFor:
    DOMFeature:GetFeature::ManakaiDOM:ManakaiDOMLatest

ResourceDef:
  @QName: PLPack
  @rdf:type:
    ManakaiDOM:Class
  @AliasFor:
    PerlCode:ManakaiPerlPackageScope::ManakaiDOM:Perl

ResourceDef:
  @QName: SWCFGNode
  @rdf:type:
    ManakaiDOM:IF
  @AliasFor:
    swcfg21:SWCFGNode::swcfg21:ForLatest

ResourceDef:
  @QName: SWCFGElement
  @AliasFor:
    swcfg21:SWCFGElement::swcfg21:ForLatest

ResourceDef:
  @QName: SWCFGDoc
  @rdf:type:
    ManakaiDOM:IF
  @AliasFor:
    swcfg21:SWCFGDocument::swcfg21:ForLatest

ResourceDef:
  @QName: MPLImpl
  @rdf:type:
    ManakaiDOM:Class
  @AliasFor:
    PerlCode:ManakaiPerlCodeImplementation::ManakaiDOM:Perl

ResourceDef:
  @QName: MPLCodeFragment
  @rdf:type:
    ManakaiDOM:Class
  @AliasFor:
    PerlCode:ManakaiPerlCodeFragment::ManakaiDOM:Perl

ResourceDef:
  @QName: PLInCon
  @rdf:type:
    ManakaiDOM:Class
  @AliasFor:
    PerlCode:ManakaiPerlInlineContainer::ManakaiDOM:Perl

ResourceDef:
  @QName: PLBlockCon
  @rdf:type:
    ManakaiDOM:Class
  @AliasFor:
    PerlCode:ManakaiPerlStatementContainer::ManakaiDOM:Perl

ResourceDef:
  @QName: PLAnyCon
  @rdf:type:
    ManakaiDOM:Class
  @AliasFor:
    PerlCode:ManakaiPerlAnyContainer::ManakaiDOM:Perl

ResourceDef:
  @QName: MPLSS
  @rdf:type:
    ManakaiDOM:Class
  @AliasFor:
    PerlCode:ManakaiPerlStatementContainer::ManakaiDOM:Perl

ResourceDef:
  @QName: MPLSub
  @rdf:type:
    ManakaiDOM:Class
  @AliasFor:
    PerlCode:ManakaiPerlSub::ManakaiDOM:Perl

ResourceDef:
  @QName: MPLUnparsedCode
  @rdf:type:
    ManakaiDOM:Class
  @AliasFor:
    PerlCode:ManakaiPerlUnparsedCode::ManakaiDOM:Perl

PropDef:
  @QName: plCodeFragment
  @enDesc:
    Cache for <A::ManakaiDISResourceDefinition.plCodeFragment>.

XParamDef:
  @QName: sourceNodePath
  @enDesc:
    A node path string of the source node.

XParamDef:
  @QName: errResource
  @enDesc:
    A resource on which an error has occurred. 

XParamDef:
  @QName: generatedName
  @enDesc:
    A generated name. 

IFClsDef:
  @IFQName: DISResourceProp
  @ClsQName: ManakaiDISPropertyAccessor

  @enDesc:
    Accessor methods for resource or module properties. 

  @Method:
    @@Name: getPropertyValue
    @@enDesc:
      Returns a property value object.
    @@PropNameParam:
    @@Return:
      @@@Type: dv|DVValue
      @@@enDesc: The property value.
      @@@nullCase:
        @@@@enDesc:
          The property has no value.
      @@@PerlDef:
        $r = $self->{$propName};

  @Method:
    @@Name: getPropertyValueList
    @@enDesc:
      Returns a property value objects.
    @@PropNameParam:
    @@Return:
      @@@Type: Perl|ARRAY||ManakaiDOM|all
      @@@enDesc: The property value.
      @@@PerlDef:
        my $pr = $self-><AG::DISAnyResource.database>
                      -><M::DISDatabase.getResource> ($propName);
        $r = [map {@$_}
              grep {$_}
              map {$self->{$_}}
              grep {$pr->{aliasURI}->{$_} or $pr->{subOf}->{$_}}
              (keys %{$pr->{aliasURI}}, keys %{$pr->{subOf}})];

  @Method:
    @@Name: getPropertyBoolean
    @@enDesc:
      Gets boolean property value. 
    @@PropNameParam:
    @@Param:
      @@@Name:default
      @@@Type:
        DOMMain:boolean::ManakaiDOM:all
      @@@enDesc:
        The default value that is returned if no explicit property 
        value specification found for this resource. 
    @@Return:
      @@@Type:
        DOMMain:boolean::ManakaiDOM:all
      @@@enDesc:
        The property value. 
      @@@PerlDef:
        if (ref $self->{$propName}) {
          $r = $self->{$propName}-><AG::dv|DVValue.value> ? true : false;
          $r = $default unless defined $r;
        } else {
          my $pr = $self-><AG::DISAnyResource.database>
                        -><M::DISDatabase.getResource> ($propName);
          C: {
            for (map {$self->{$_}}
                 grep {$pr->{aliasURI}->{$_} or $pr->{subOf}->{$_}}
                 (keys %{$pr->{aliasURI}}, keys %{$pr->{subOf}})) {
              if (defined $_) {
                $r = $_-><AG::dv|DVValue.value> ? true : false;
                last C;
              }
            }
            $r = $default;
          } # C
        }
        
  @Method:
    @@Name: getPropertyText
    @@enDesc:
      Gets property value text. 
    @@PropNameParam:
    @@Param:
      @@@Name:default
      @@@Type:
        swcfg21:SWCFGString::swcfg21:ForLatest
      @@@enDesc:
        The default value that is returned if no explicit property 
        value specification found for this resource. 
      @@@nullCase:
        @@@@enDesc:
          No default value supplied; <DOM::null> is returned if 
          no value specified. 
    @@Return:
      @@@Type:
        swcfg21:SWCFGString::swcfg21:ForLatest
      @@@enDesc:
        The property value string. 
      @@@nullCase:
        @@@@enDesc:
          No value nor default value has specified. 
      @@@PerlDef:
        if (defined $self->{$propName}) {
          $r = $self->{$propName}-><AG::dv|DVValue.stringValue>;
          $r = $default unless defined $r;
        } else {
          my $pr = $self-><AG::DISAnyResource.database>
                        -><M::DISDatabase.getResource> ($propName);
          C: {
            for (map {$self->{$_}}
                 grep {$pr->{aliasURI}->{$_} or $pr->{subOf}->{$_}}
                 (keys %{$pr->{aliasURI}}, keys %{$pr->{subOf}})) {
              if (defined $_) {
                $r = $_-><AG::dv|DVValue.stringValue>;
                last C;
              }
            }
            $r = $default;
          } # C
        }
        
  @Method:
    @@Name: getPropertyTextList
    @@enDesc:
      Returns a list of property value text. 
    @@PropNameParam:
    @@MediaTypeDefaultParam:
    @@Return:
      @@@Type: Perl|ARRAY||ManakaiDOM|all
      @@@enDesc:
        A list of the property value strings. 
      @@@RaiseException:
        @@@@@:UNSUPPORTED_MEDIA_TYPE_ERR
        @@@@enDesc:
          There is an attribute whose media
          type is not supported.
      @@@PerlDef:
        my $pr = $self-><AG::DISAnyResource.database>
                      -><M::DISDatabase.getResource> ($propName);
        $r = [map {$_-><AG::dv|DVValue.stringValue>}
              map {@$_}
              grep {$_}
              map {$self->{$_}}
              grep {$pr->{aliasURI}->{$_} or $pr->{subOf}->{$_}}
              (keys %{$pr->{aliasURI}}, keys %{$pr->{subOf}})];

  @Method:
    @@Name: getPropertyResource
    @@enDesc:
      Gets property value resource. 
    @@PropNameParam:
    @@NamedParam:
      @@@Name: defaultMediaType
      @@@Type: ResourceURI
      @@@enDesc:
        The URI reference of the default media type which is used 
        when the property value is retrieved from the source tree 
        and the source tree element does not have its <Q::dis:ContentType>
        attribute specified. 
      @@@nullCase:
        @@@@enDesc:
          Defaulted to <Q::dis:TypeQName>.
    @@Return:
      @@@Type: DISResource
      @@@clsActualType: ManakaiDISResourceDefinition
      @@@enDesc:
        The property value resource. 
      @@@nullCase:
        @@@@enDesc:
          No value has specified. 
      @@@UndeclaredPrefixException:
      @@@RaiseException:
        @@@@@:UNSUPPORTED_MEDIA_TYPE_ERR
        @@@@enDesc:
          The media type of the attribute node in the source tree
          corresponding to this resource is not supported. 
      @@@PerlDef:
        __DEEP{
          my $v = $self-><M::DISResourceProp.getPropertyValue>
                             ($propName);
          if (UNIVERSAL::isa ($v, <IFName::dv|DVURIValue>)) {
            $r = $v-><M::dv|DVURIValue.getResource>
                          ($self-><AG::DISAnyResource.database>);
          }
        }__;

  @Method:
    @@Name: getPropertyResourceList
    @@enDesc:
      Gets property value resource list. 
    @@PropNameParam:
    @@NamedParam:
      @@@Name: recursive
      @@@Type:
        DOMMain:boolean::ManakaiDOM:all
      @@@enDesc:
        Whether property resource values of this resource
        should also be included to the returned list or not.
    @@NamedParam:
      @@@Name: recursiveISA
      @@@Type:
        DOMMain:boolean::ManakaiDOM:all
      @@@enDesc:
        Whether the <Q::dis:ISA> ancestors of the resources
        that are property values should also be included in the returned list
        or not.
      @@@TrueCase:
        @@@@enDesc:
          If a property value is a resource <VAR::R> and 
          the resource <VAR::R> <Q::dis:ISA>'s (or inherits) <VAR::S>, then
          the resource <VAR::S> is also a value in the list.
      @@@FalseCase:
        @@@@enDesc:
          Only the resources directly specified as property values is returned.
    @@NamedParam:
      @@@Name: isaRecursive
      @@@Type:
        DOMMain:boolean::ManakaiDOM:all
      @@@enDesc:
        Whether property resource values of <Q::dis:ISA> resources
        of this resource should also be included to the returned list or not.
      @@@TrueCase:
        @@@@enDesc:
          If this resource <Q::dis:ISA>'s (or inherits) another resource 
          <VAR::S> and the <VAR::S> resource has a <P::propName>
          property value of <VAR::R>, then the resource <VAR::R>
          is also a value in the list.
      @@@FalseCase:
        @@@@enDesc:
          Only the resource directly specified is the returned.
    @@NamedParam:
      @@@Name: defaultMediaType
      @@@Type: ResourceURI
      @@@enDesc:
        The URI reference of the default media type which is used 
        when the property value is retrieved from the source tree 
        and the source tree element does not have its <Q::dis:ContentType>
        attribute specified. 
      @@@nullCase:
        @@@@enDesc:
          Defaulted to <Q::dis:TypeQName>.
    @@Return:
      @@@Type: ResourceList
      @@@enDesc:
        An array reference of the property value resources. 
        \
        {NOTE:: This list is <QUOTE::dead>.
        \
        }
      @@@UndeclaredPrefixException:
      @@@RaiseException:
        @@@@@:UNSUPPORTED_MEDIA_TYPE_ERR
        @@@@enDesc:
          The media type of the attribute node in the source tree
          corresponding to this resource is not supported. 
      @@@PerlDef:
        $r = [];
        __DEEP{
          my $v = $self-><M::DISResourceProp.getPropertyValueList> ($propName);
          my $db = $self-><AG::DISAnyResource.database>;
          for my $a (@$v) {
            if ($a->isa (<IFName::dv|DVURIValue>)) {
              push @$r, $a-><M::dv|DVURIValue.getResource> ($db);
            }
            if ($isaRecursive) {
              my $b = $a-><M::dv|DVValue.getProperty>
                               (<Q::DISCore:stopISARecursive>);
              if ($b and $b-><AG::dv|DVValue.value>) {
                $isaRecursive = false;
              }
            }
          }
        }__;

        if ($recursive) {
          __DEEP{
            $opt{___recursive_isa_done} ||= {$self->{uri} => true};
            my @p_res = @$r;
            for my $p_res (@p_res) {
              next if $opt{___recursive_isa_done}->{$p_res->{uri}};
              $opt{___recursive_isa_done}->{$p_res->{uri}} = true;
              push @$r, @{$p_res-><M::DISResourceProp.getPropertyResourceList>
                                          ($propName, recursive => true,
                                           recursive_isa => $recursiveISA,
                         ___recursive_isa_done => $opt{___recursive_isa_done},
                         default_media_type => $defaultMediaType)};
            }
          }__;
        }
        if ($recursiveISA) {
          __DEEP{
            $opt{___recursive_isa_done} ||= {$self->{uri} => true};
            my @p_res = @$r;
            for my $p_res (@p_res) {
              next if $opt{___recursive_isa_done}->{$p_res->{uri}};
              $opt{___recursive_isa_done}->{$p_res->{uri}} = true;
              push @$r, @{$p_res-><M::DISResourceProp.getPropertyResourceList>
                                          (<Q::dis:ISA>, 
                                           recursive => true,
                         ___recursive_isa_done => $opt{___recursive_isa_done},
                         default_media_type => $defaultMediaType)};
            }
          }__;
        }
        if ($isaRecursive) {
          __DEEP{
            $opt{___recursive_isa_done} ||= {$self->{uri} => true};
            $opt{___isa_recursive_done} ||= {$self->{uri} => true};
            my @p_res = @{$self-><M::DISResourceProp.getPropertyResourceList>
                                      (<Q::dis:ISA>, recursive_isa => false,
                                       recursive => false,
                                       default_media_type => <Q::dis:TFQNames>)};
            for my $p_res (@p_res) {
              next if $opt{___isa_recursive_done}->{$p_res->{uri}};
              $opt{___isa_recursive_done}->{$p_res->{uri}} = true;
              push @$r, @{$p_res-><M::DISResourceProp.getPropertyResourceList>
                                          ($propName, recursive_isa => false,
                                           recursive => false,
                                       isa_recursive => true,
                                       ___isa_recursive_done =>
                                                     $opt{___isa_recursive_done},
                                       default_media_type => $defaultMediaType)};
            }
          }__;
        }

  @Method:
    @@Name: addPropertyResourceList
    @@enDesc:
      Adds a resource to a resource-list property value. 
      \
      {ISSUE:: Should an exception be thrown if the property is 
               not of list?
      \
      }
      \
      {NOTE:: If the property is not <QUOTE::get>ten ever, adding 
              an item clears the list --- i.e. the property values 
              in the source tree will be ignored.  Call
              <M::ManakaiDISPropertyAccessor.getPropertyResourceList>
              before adding to avoid this behavior. 
      \
      }
    @@PropNameParam:
    @@Param:
      @@@Name: res
      @@@Type: DISResource
      @@@clsActualType: ManakaiDISResourceDefinition
      @@@enDesc:
        A resource to add. 
    @@Return:
      @@@PerlDef:
        if ($self->{$propName}) {
          my $uriv;
          __CODE{dv|createURI::
            $uri => {$res-><AG::DISAnyResource.uri>},
            $result => $uriv,
          }__;
          $self->{$propName}-><M::dv|DVList.addItem> ($uriv);
        } else {
          __CODE{dv|createOrderedList::
            $result => {$self->{$propName}},
            $type => {<Q::DISCore:URI>},
            $base_type => {<Q::DISCore:URI>},
          }__;
          my $uriv;
          __CODE{dv|createURI::
            $uri => {$res-><AG::DISAnyResource.uri>},
            $result => $uriv,
          }__;
          $self->{$propName}-><M::dv|DVList.addItem> ($uriv);
        }

  @Method:
    @@Name: addPropertyResourceUList
    @@PerlName: add_property_resource_ulist
    @@enDesc:
      Adds a resource to a resource-list property value. 
      \
      {ISSUE:: Should an exception be thrown if the property is 
               not of list?
      \
      }
      \
      {NOTE:: If the property is not <QUOTE::get>ten ever, adding 
              an item clears the list --- i.e. the property values 
              in the source tree will be ignored.  Call
              <M::ManakaiDISPropertyAccessor.getPropertyResourceList>
              before adding to avoid this behavior. 
      \
      }
    @@PropNameParam:
    @@Param:
      @@@Name: res
      @@@Type: DISResource
      @@@clsActualType: ManakaiDISResourceDefinition
      @@@enDesc:
        A resource to add. 
    @@Return:
      @@@PerlDef:
        if ($self->{$propName}) {
          my $uriv;
          __CODE{dv|createURI::
            $uri => {$res-><AG::DISAnyResource.uri>},
            $result => $uriv,
          }__;
          $self->{$propName}-><M::dv|DVList.addItem> ($uriv);
        } else {
          __CODE{dv|createUnorderedList::
            $result => {$self->{$propName}},
            $type => {<Q::DISCore:URI>},
            $base_type => {<Q::DISCore:URI>},
          }__;
          my $uriv;
          __CODE{dv|createURI::
            $uri => {$res-><AG::DISAnyResource.uri>},
            $result => $uriv,
          }__;
          $self->{$propName}-><M::dv|DVList.addItem> ($uriv);
        }

  @Method:
    @@Name: addPropertyURIUList
    @@PerlName: add_peoperty_uri_ulist
    @@enDesc:
      Adds a resource to a resource-list property value. 
      \
      {ISSUE:: Should an exception be thrown if the property is 
               not of list?
      \
      }
      \
      {NOTE:: If the property is not <QUOTE::get>ten ever, adding 
              an item clears the list --- i.e. the property values 
              in the source tree will be ignored.  Call
              <M::ManakaiDISPropertyAccessor.getPropertyResourceList>
              before adding to avoid this behavior. 
      \
      }
    @@PropNameParam:
    @@Param:
      @@@Name: uri
      @@@Type: AnyURI
      @@@enDesc:
        A resource to add. 
    @@Return:
      @@@PerlDef:
        __DEEP{
          if ($self->{$propName}) {
            my $uriv;
            __CODE{dv|createURI::
              $uri => $uri,
              $result => $uriv,
            }__;
            $self->{$propName}-><M::dv|DVList.addItem> ($uriv);
          } else {
            __CODE{dv|createUnorderedList::
              $result => {$self->{$propName}},
              $type => {<Q::DISCore|URI>},
              $base_type => {<Q::DISCore:URI>},
            }__;
            my $uriv;
            __CODE{dv|createURI::
              $uri => $uri,
              $result => $uriv,
            }__;
            $self->{$propName}-><M::dv|DVList.addItem> ($uriv);
          }
        }__;
##DISResourceProp

ElementTypeBinding:
  @Name: PropNameParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:MethodParameter
    @@Name: propName
    @@Type: ResourceURI
    @@Description:
      @@@lang:en
      @@@@:
        The name of the property. 

PropDef:
  @QName:isAnon
  @Description:
    @@lang:en
    @@@:
      Whether the subject resource is anonymous or not. 
  @Type:
    DOMMain:boolean::ManakaiDOM:all

PropDef:
  @QName:isDefined
  @Description:
    @@lang:en
    @@@:
      Whether the subject resource is defined or not. 

PropDef:
  @QName:isReferred
  @Description:
    @@lang:en
    @@@:
      Whether the subject resource is referred or not. 
  @Type:
    DOMMain:any

PropDef:
  @QName:definingModule
  @Description:
    @@lang:en
    @@@:
      The <QUOTE::dis> module in which the subject resource is defined. 
      \
      {NOTE:: The local name should have been <QUOTE::ownerModule> or some.
      \
      }
  @rdfs:domain:
    DISCore:Module

## -- Datatypes

URITypeDef:
  @QName: AnyURI
  @Description:
    @@lang:en
    @@@:
      Any URI references. 

URITypeDef:
  @QName: FileURI
  @enDesc:
    URI references identifying file. 

URITypeDef:
  @QName: ForURI
  @Description:
    @@lang:en
    @@@:
      <QUOTE::For> URI references. 

DataTypeDef:
  @QName: ForURIList
  @Description:
    @@lang:en
    @@@:
      References to the array containing <QUOTE::for> URI references. 

URITypeDef:
  @QName: ResourceURI
  @Description:
    @@lang:en
    @@@:
      A URI reference for a <QUOTE::dis> resource. 

URITypeDef:
  @QName: MediaTypeURI
  @Description:
    @@lang:en
    @@@:
      Media type URI references. 
  @rdfs:subClassOf: ResourceURI

URITypeDef:
  @QName: ModuleURI
  @enDesc:
    URI references for <QUOTE::dis> modules. 
  @rdfs:subClassOf: ResourceURI

URITypeDef:
  @QName: NameURI
  @enDesc:
    URI references identifying a resource. 
  @rdfs:subClassOf: ResourceURI

DataTypeDef:
  @QName: ResourceList
  @enDesc:
    References to array containing resource definition objects.
  @rdfs:subClassOf:
    Perl:ARRAY::ManakaiDOM:all

ElementTypeBinding:
  @Name: DataTypeDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:DataType

ElementTypeBinding:
  @Name: URITypeDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:DataType
    @@rdfs:subClassOf: AnyURI

## -- Exceptions

XParamDef:
  @QName: anotherSourceNode
  @enDesc:
    Another source node in which an error has occurred.  In cases 
    of <QUOTE::already defined> errors, it is the node that 
    defines the resource first. 
  @Type: ManakaiDISNode

ResourceDef:
  @QName: UNDECLARED_NS_PREFIX_ERR
  @For: ForLatest
  @AliasFor: 
    DIS:UNDECLARED_NS_PREFIX_ERR::swcfg21:ForLatest

ResourceDef:
  @rdf:type:
    @@@: dis|MultipleResource
    @@ForCheck: !ManakaiDOM|ForIF !ManakaiDOM|ForClass
  @resourceFor: ManakaiDOM|ForIF
  @resourceFor:
    @@@: ManakaiDOM|ForClass
    @@ForCheck: ForEmpty !=ForEmpty
  @For: ForLatest
  @For: =ForEmpty

  @rdf:type:
    @@@: ManakaiDOM|ExceptionIF
    @@ForCheck: ManakaiDOM|ForIF

  @rdf:type:
    @@@: ManakaiDOM|ExceptionClass
    @@ForCheck: ManakaiDOM|ForClass

  @Implement:
    @@@: ||ForEmpty||ManakaiDOM|ForIF
    @@ContentType: DISCore|TFPQNames
    @@ForCheck: ManakaiDOM|ForClass ForEmpty
  @Implement:
    @@@: ||ForLatest||ManakaiDOM|ForIF
    @@ContentType: DISCore|TFPQNames
    @@ForCheck: ManakaiDOM|ForClass ForLatest

  @DOMMain:implementFeature:
    @@@: CoreFeature10
    @@For: ForLatest

  @Implement:
    @@@: DOMMain|ManakaiDOMExceptionIF||ManakaiDOM|Perl
    @@ForCheck: ManakaiDOM|ForClass

  @ISA:
    @@@: ManakaiDOM|ManakaiDOMException||ManakaiDOM|Perl
    @@ForCheck: ManakaiDOM|ForClass

  @IFQName: DISException
  @ClsQName: ManakaiDISException

  @Description:
    @@lang:en
    @@@:
      Exceptions for the <QUOTE::dis> operations. 

  @ResourceDef:
    @@rdf:type: ManakaiDOM|ConstGroup
    @@ForCheck: !=ForEmpty

    @@IFQName: DISExceptionCode
    @@ClsQName: ManakaiDISExceptionCode
    @@PerlName: DISExceptionCode

    @@rdfs:subClassOf:
      DOMMain:unsigned-short::ManakaiDOM:all
    @@Type:
      DOMMain:unsigned-short::ManakaiDOM:all

    @@enDesc:
      Exception codes for <Class::ManakaiDISException>. 

    @@XConstDef:
      @@@Name: HIERARCHY_REQUEST_ERR
      @@@Value:3
      @@@enDesc:
        An attempt is made to break the hierarchy. 
      @@@XSubTypeDef:
        @@@@QName: MERGE_ITSELF_ERR
        @@@@enDesc:
          An attempt is made to merge the resource to itself. 
        @@@@XSourceNodeParam:
        @@@@XParam:
          @@@@@QName:uri
          @@@@@enDesc:
            The URI reference of the resource to merge. 
        @@@@enMufDef:
          An attempt is made to merge the resource <%p (name => {<Q::DIS:uri>}
          );> to itself
    @@XConstDef:
      @@@Name: NOT_SUPPORTED_ERR
      @@@Value:9
      @@@enDesc:
        An attempt is made to do something the implementation does not support. 
      @@@XSubTypeDef:
        @@@@QName: UNSUPPORTED_MEDIA_TYPE_ERR
        @@@@enDesc:
          The implementation does not support the media type. 
        @@@@XParam:
          @@@@@QName: uri
          @@@@@enDesc:
            The URI reference of the media type that is not supported. 
        @@@@XSourceNodeParam:
        @@@@XParam:
          @@@@@QName:elementType
          @@@@@enDesc:
            The URI reference of the element type of the element
            in which the media type is referenced.
        @@@@enMufDef:
          %p (name => {<Q::DIS:sourceCode>}, prefix => {"}, suffix => {": }
          );%p (name => {<Q::DIS:elementType>}, prefix => { (Element type: <},
          suffix => {>) }
          );Media type <%p (name => {<Q::DIS:uri>});> is not supported
      @@@XSubTypeDef:
        @@@@QName: UNSUPPORTED_ELEMENT_TYPE_ERR
        @@@@enDesc:
          An unsupported type of element is encounted.
        @@@@XSourceNodeParam:
        @@@@XParam:
          @@@@@QName:elementType
          @@@@@enDesc:
            The element type URI reference of the element.
        @@@@enMufDef:
          Element type "%p (name => {<Q::DIS:elementType>});" is not supported
      @@@XSubTypeDef:
        @@@@QName: NO_PERL_CODE_IMPL_ERR
        @@@@enDesc:
          There is no implementation that supports the 
          <Feature::Util:PerlCode> feature, version 
          <FeatureVer::1.0>.
    @@XConstDef:
      @@@Name: INVALID_STATE_ERR
      @@@Value:11
      @@@enDesc:
        An attempt is made to use an object that is not (or no longer) usable. 
      @@@XSubTypeDef:
        @@@@QName: NO_ASSOCIATED_DB_ERR
        @@@@enDesc:
          No <QUOTE::dis> database has been associated with this document. 
    @@XConstDef:
      @@@Name: INVALID_SOURCE_ERR
      @@@Value: 200
      @@@enDesc:
        The source input is well-formed but invalid. 
      @@@XSubTypeDef:
        @@@@QName: NO_MODULE_QNAME_ERR
        @@@@enDesc:
          The <Q::dis:Module> element must have its <Q::dis:QName> 
          attribute. 
        @@@@XSourceNodeParam:
      @@@XSubTypeDef:
        @@@@QName: NO_LOCAL_NAME_ERR
        @@@@enDesc:
          The resource does not have a local name. 
        @@@@XSourceNodeParam:
      @@@XSubTypeDef:
        @@@@QName: UNABLE_TO_GET_MODULE_ERR
        @@@@enDesc:
          The implementation is unable to get the module source. 
        @@@@Def:
          @@@@@ContentType:
            lang:muf
          @@@@@lang:en
          @@@@@@:
            Unable to get the module source of <%p (name => {<Q::DIS:uri>});>
        @@@@XParam:
          @@@@@QName: uri
          @@@@@enDesc:
            The URI reference of the module. 
        @@@@XParam:
          @@@@@QName: namespaceURI
          @@@@@enDesc:
            The namespace URI of the module name. 
        @@@@XParam:
          @@@@@QName: localName
          @@@@@enDesc:
            The local name of the module name. 
        @@@@XParam:
          @@@@@QName: for
          @@@@@enDesc:
            The <QUOTE::for> of the module.
      @@@XSubTypeDef:
        @@@@QName: NO_FOR_QNAME_ERR
        @@@@enDesc:
          A <Q::dis:ForDef> element must have <Q::dis:QName> attribute. 
        @@@@XSourceNodeParam:
      @@@XSubTypeDef:
        @@@@QName: FOR_ALREADY_DEFINED_ERR
        @@@@enDesc:
          The <QUOTE::for> named as the same URI reference has 
          already defined. 
        @@@@XSourceNodeParam:
        @@@@XParam:
          @@@@@QName: anotherSourceNode
          @@@@@enDesc:
            The node that defines the <QUOTE::for> URI reference before. 
        @@@@XParam:
          @@@@@Name: uri
          @@@@@enDesc:
            The URI reference of the <QUOTE::for> attempted to define. 
        @@@@enMufDef:
          <QUOTE::For> <%p (name => {<Q::DIS:uri>});> is already defined
      @@@XSubTypeDef:
        @@@@QName: RESOURCE_ALREADY_DEFINED_ERR
        @@@@enDesc:
          The <QUOTE::dis> resource named as the same URI reference has 
          already defined. 
        @@@@XSourceNodeParam:
        @@@@XParam:
          @@@@@QName: anotherSourceNode
          @@@@@enDesc:
            The node that defines the <QUOTE::for> URI reference before. 
        @@@@XParam:
          @@@@@Name: uri
          @@@@@enDesc:
            The URI reference of the resource attempted to define. 
        @@@@enMufDef:
          Resource <%p (name => {<Q::DIS:uri>});> is already defined
      @@@XSubTypeDef:
        @@@@QName: ELEMENT_NOT_ALLOWED_ERR
        @@@@enDesc:
          An element has occured where it is not allowed. 
        @@@@enMufDef:
          Module <%p (name => {<Q::DIS:uri>});>: 
          Element of type <%p (name => {<Q::DIS:elementType>});> 
          is not allowed here
        @@@@XSourceNodeParam:
        @@@@XParam:
          @@@@@QName: elementType
          @@@@@enDesc:
            The expanded element type name of the element. 
        @@@@XParam:
          @@@@@QName: uri
          @@@@@enDesc:
            The URI reference of the module. 
      @@@XSubTypeDef:
        @@@@QName: NO_REQUIRED_ATTR_ERR
        @@@@enDesc:
          A required attribute is not specified.
        @@@@XSourceNodeParam:
        @@@@XParam:
          @@@@@QName: elementType
          @@@@@enDesc:
            The expanded URI reference of the attribute name. 
        @@@@enMufDef:
          Attribute <%p (name => {<Q::DIS:elementType>});> must be specified
      @@@XSubTypeDef:
        @@@@QName: FOR_NOT_DEFINED_ERR
        @@@@enDesc:
          A <QUOTE::for> is referred but not defined. 
        @@@@XSourceNodeParam:
        @@@@XParam:
          @@@@@QName: uri
          @@@@@enDesc:
            The URI reference of the <QUOTE::for> that is not defined.
        @@@@enMufDef:
          <QUOTE::For> <%p (name => {<Q::DIS:uri>});> is not defined
      @@@XSubTypeDef:
        @@@@QName: RESOURCE_NOT_DEFINED_ERR
        @@@@enDesc:
          A <QUOTE::dis> resource is referred but not defined 
          or the resource referred does not have the type expected. 
        @@@@XSourceNodeParam:
        @@@@XParam:
          @@@@@@: sourceNodePath
          @@@@@enDesc:
            A node path string of the source node.
        @@@@XParam:
          @@@@@QName: uri
          @@@@@enDesc:
            The URI reference of the resource that is not defined.
        @@@@XParam:
          @@@@@QName: elementType
          @@@@@enDesc:
            <QUOTE::dis> element type (either tree element type
            or preprocessing element type) of the element
            in which a reference to the undefined resource is contained.
        @@@@XParam:
          @@@@@QName:parentURI
          @@@@@enDesc:
            The URI reference of the resource from whose child resources
            a resource is tried to find.
        @@@@XParam:
          @@@@@QName: localName
          @@@@@enDesc:
            The local name of the undefined resource.
        @@@@XParam:
          @@@@QName: sourceCode
          @@@@enDesc:
            Source code fragment that referres this resource.
        @@@@XParam:
          @@@@@QName:expectedType
          @@@@@enDesc:
            Expected resource type.
        @@@@enMufDef:
          %p (name => {<Q::DIS:sourceNodePath>}, suffix => {: });
          %p (name => {<Q::DIS:sourceCode>}, prefix => {"}, suffix => {": });
          %p (name => {<Q::DIS:parentURI>}, prefix => {(In <}, suffix => {>) });
          Resource%p (name => {<Q::DIS:uri>}, prefix => { <},
          suffix => {>});%p (name => {<Q::DIS:localName>},
          prefix => { "}, suffix => {"}); is not defined or wrong type%p
          (name => {<Q::DIS:expectedType>}, prefix => { (<},
           suffix => {> is expected)});
      @@@XSubTypeDef:
        @@@@QName: NO_SOURCE_NODE_ERR
        @@@@enDesc:
          A resource does not have associated node in the source tree.
        @@@@XSourceNodeParam:
        @@@@XParam:
          @@@@@QName:uri
          @@@@@enDesc:
            The URI reference of the resource.
      @@@XSubTypeDef:
        @@@@QName: RESERVED_PERL_METHOD_NAME_ERR
        @@@@enDesc:
          A reserved Perl method name is used. 
        @@@@XParam:
          @@@@@QName:uri
          @@@@@enDesc:
            The URI reference of the method resource. 
        @@@@XSourceNodeParam:
        @@@@XParam:
          @@@@@QName: generatedName
          @@@@@enDesc:
            A reserved method name. 
      @@@XSubTypeDef:
        @@@@QName: NO_DIS_TYPE_ERR
        @@@@enDesc:
          <Q::dis:Type> attribute is not found. 
        @@@@XSourceNodeParam:
        @@@@enMufDef:
          Resource "%t (name => {<Q::DIS:uri>});" has no "dis:Type" attribute
      @@@XSubTypeDef:
        @@@@QName: NO_METHOD_RETURN_ERR
        @@@@enDesc:
          A <Q::DISLang:Method> resource does not have any
          <Q::DISLang:MethodReturn> child. 
        @@@@XSourceNodeParam:
        @@@@XParam:
          @@@@@QName:errResource
          @@@@@enDesc: The method resource.
        @@@@XParam:
          @@@@@QName:uri
          @@@@@enDesc:
            The URI reference of the method.
        @@@@XParam:
          @@@@@QName:localName
          @@@@@enDesc:
            The local name of the resource.
        @@@@enMufDef:
          Method "%p (name => {<Q::DIS:localName>});" does not have
          "Return" child
      @@@XSubTypeDef:
        @@@@QName: NO_ATTR_GET_ERR
        @@@@enDesc:
          A <Q::DISLang:Attribute> resource does not have any
          <Q::DISLang:AttributeGet> child. 
        @@@@XSourceNodeParam:
      @@@XSubTypeDef:
        @@@@QName:INTERFACE_CLASS_METHOD_ERR
        @@@@enDesc:
          An attempt is made to call a static (class) method
          from an interface.
        @@@@XSourceNodeParam:
        @@@@XParam:
          @@@@@QName:uri
          @@@@@enDesc:
            The URI reference of the interface.
        @@@@XParam:
          @@@@@QName:sourceCode
          @@@@@enDesc:
            Source code fragment that calls a class method.
        @@@@XParam:
          @@@@@QName:elementType
          @@@@@enDesc:
            The element type URI reference of the element
            that calls a method.
      @@@XSubTypeDef:
        @@@@QName: BROKEN_PARAM_SPEC_ERR
        @@@@enDesc:
          A parameter specification is broken.
        @@@@XParam:
          @@@@@QName: sourceCode
          @@@@@enDesc:
            Source code fragment that contains the broken parameter
            specification.
        @@@@XSourceNodeParam:
        @@@@enMufDef:
          %p (name => {<Q::DIS:sourceCode>}, prefix => {"},
          suffix => {": });Broken parameter specification
      @@@XSubTypeDef:
        @@@@QName:PERL_PREPROCESS_NO_ELEMENT_TYPE_ERR
        @@@@enDesc:
          A preprocessing instruction does not have its element 
          type.
        @@@@XSourceNodeParam:
        @@@@XParam:
          @@@@@QName:sourceCode
          @@@@@enDesc:
            Source code fragment.
        @@@@enMufDef:
          %p (name => {<Q::DIS:sourceCode>}, prefix => {"}, 
              suffix => {": });Element type name is not specified
      @@@XSubTypeDef:
        @@@@QName: NO_PERL_PACKAGE_NAME_ERR
        @@@@enDesc:
          No Perl package name is defined for the resource referred.
        @@@@XSourceNodeParam:
        @@@@XParam:
          @@@@@QName:sourceCode
          @@@@@enDesc:
            Source code fragment.
        @@@@XParam:
          @@@@@QName:uri
          @@@@@enDesc:
            THe URI reference of the resource referred.
        @@@@XParam:
          @@@@@QName:elementType
          @@@@@enDesc:
            The element type of Perl preprocessing instruction 
            in which the resource is referred.
        @@@@enMufDef:
          %p (name => {<Q::DIS:uri>}, prefix => {<}, suffix => {>: });Perl 
          package name is not defined
      @@@XSubTypeDef:
        @@@@QName: PERL_PREPROCESS_NO_EXCEPTION_TYPE_ERR
        @@@@enDesc:
          An exception type specification is required.
        @@@@XSourceNodeParam:
        @@@@XSourceCodeParam:
        @@@@XParam:
          @@@@@QName:elementType
          @@@@@enDesc:
            The element type of the preprocessing instruction.
      @@@XSubTypeDef:
        @@@@QName: PERL_PREPROCESS_NO_CODE_NAME_ERR
        @@@@enDesc:
          A code name specification is required.
        @@@@XSourceNodeParam:
        @@@@XSourceCodeParam:
        @@@@XParam:
          @@@@@QName:elementType
          @@@@@enDesc:
            The element type of the preprocessing instruction.
      @@@XSubTypeDef:
        @@@@QName: PERL_CODE_NOT_DEFINED_ERR
        @@@@enDesc:
          The specified resource does not have its Perl definition.
        @@@@XSourceNodeParam:
        @@@@XSourceCodeParam:
        @@@@XParam:
          @@@@@QName:elementType
          @@@@@enDesc:
            The element type of the preprocessing instruction.
        @@@@XParam:
          @@@@@QName:uri
          @@@@@enDesc:
            The URI reference of the resource referred.
        @@@@XParam:
          @@@@@QName:localName
          @@@@@enDesc:
            The local name of the resource referred.
      @@@XSubTypeDef:
        @@@@QName: PERL_PREPROCESS_NO_METHOD_ERR
        @@@@enDesc:
          A preprocessing instruction which is only allowed in 
          method definitions is used in a code which is not a method.
        @@@@XSourceNodeParam:
        @@@@XSourceCodeParam:
        @@@@XParam:
          @@@@@QName:elementType
          @@@@@enDesc:
            The element type of the preprocessing instruction.
      @@@XSubTypeDef:
        @@@@QName: PERL_PREPROCESS_NO_FOR_ERR
        @@@@enDesc:
          A <QUOTE::for> specification is required.
        @@@@XSourceNodeParam:
        @@@@XSourceCodeParam:
        @@@@XParam:
          @@@@@QName:elementType
          @@@@@enDesc:
            The element type of the preprocessing instruction.
      @@@XSubTypeDef:
        @@@@QName: PERL_PREPROCESS_NO_ASSERT_TYPE_ERR
        @@@@enDesc:
          An assertion type specification is required.
        @@@@XSourceNodeParam:
        @@@@XSourceCodeParam:
        @@@@XParam:
          @@@@@QName:elementType
          @@@@@enDesc:
            The element type of the preprocessing instruction.
      @@@XSubTypeDef:
        @@@@QName: PERL_PREPROCESS_BLOCK_NOT_ALLOWED_ERR
        @@@@enDesc:
          A preprocessing instruction block occurred with 
          element type which does not allow it.
        @@@@XSourceNodeParam:
        @@@@XSourceCodeParam:
        @@@@XParam:
          @@@@@QName:elementType
          @@@@@enDesc:
            The element type of the preprocessing instruction.
      @@@XSubTypeDef:
        @@@@QName: NON_NAMED_PARAMETER_AFTER_NAMED_ERR
        @@@@enDesc:
          A non-named method parameter following
          any named method parameter is occurred.
        @@@@XSourceNodeParam:
        @@@@XParam:
          @@@@@QName:uri
          @@@@@enDesc:
            The URI reference of the non-named method parameter resource.
        @@@@XParam:
          @@@@@QName:localName
          @@@@@enDesc:
            The local name of the non-named method parameter.
      @@@XSubTypeDef:
        @@@@QName:DISPERL_NO_VALUE_ALLOWED_ERR
        @@@@enDesc:
          An element node have a value but the definition
          of that element type does not allow it.
        @@@@XSourceNodeParam:
        @@@@XParam:
          @@@@@QName:elementType
          @@@@@enDesc:
            The element type URI reference of the element.
      @@@XSubTypeDef:
        @@@@QName:NO_CONST_VALUE_ERR
        @@@@enDesc:
          The source element node for a constant value resource 
          does not have <Q::dis:Value> attribute.
        @@@@XSourceNodeParam:
        @@@@XParam:
          @@@@@QName:elemntType
          @@@@@enDesc:
            The element type URI reference of the element from which
            a constant value resource is referred.
        @@@@XParam:
          @@@@@QName:uri
          @@@@@enDesc:
            The resource URI reference of the constant value resource.
        @@@@XParam:
          @@@@@QName:localName
          @@@@@enDesc:
            The local name of the constant value resource.
     @@@XSubTypeDef:
       @@@@QName:NO_ATTR_SET_ERR
       @@@@enDesc:
         An attribute setter is referred but the attribute
         does not define any setter.
       @@@@XSourceNodeParam:
       @@@@XParam:
         @@@@@QName:errResource
         @@@@@enDesc:
           The attribute resource. 
       @@@@XParam:
         @@@@@QName:elementType
         @@@@@enDesc:
           The type of the element by which this attribute
           is referred.
     @@@XSubTypeDef:
       @@@@QName: PERL_SUBROUTINE_ALREADY_DEFINED_ERR
       @@@@enDesc:
         A resource defines a Perl subroutine whose name is 
         same as another subroutine. 
       @@@@XSourceNodeParam:
       @@@@XParam:
         @@@@@QName:uri
         @@@@@enDesc:
           The URI reference of the resource that defines the Perl subroutine. 
       @@@@XParam:
         @@@@@QName:
           PerlCode:localName
         @@@@@enDesc:
           The name of the Perl subroutine. 
     @@@XSubTypeDef:
       @@@@QName: PERL_OPERATOR_ALREADY_OVERLOADED_ERR
       @@@@enDesc:
         A resource is defined to overload a Perl operator which 
         is already overloaded by another resource.
       @@@@XSourceNodeParam:
       @@@@XParam:
         @@@@@QName:uri
         @@@@@enDesc:
           The URI reference of the resource that defines the overloading.
       @@@@XParam:
         @@@@@QName: 
           PerlCode:operator
         @@@@@enDesc:
           The operator. 
     @@@XSubTypeDef:
       @@@@QName: PERL_UNUSED_SUBROUTINE_ERR
       @@@@enDesc:
         A resource defines a Perl subroutine but it is not used.
       @@@@XSourceNodeParam:
       @@@@XParam:
         @@@@@QName:uri
         @@@@@enDesc:
           The URI reference of the resource.
     @@@XSubTypeDef:
       @@@@QName: NO_LICENSE_ATTR_ERR
       @@@@enDesc:
         The <Q::dis:Module> element does not have the
         <Q::dis:License> attribute.
       @@@@XSourceNodeParam:
       @@@@XParam:
         @@@@@QName:uri
         @@@@@enDesc:
           The URI reference of the module.
     @@@XSubTypeDef:
       @@@@QName: UNSUPPORTED_ROLE_ERR
       @@@@enDesc:
         A <Q::dis:Role> is not supported.
       @@@@XSourceNodeParam:
       @@@@XParam:
         @@@@@QName:uri
         @@@@@enDesc:
           The URI reference of the unsupported role.
       @@@@enMufDef:
         Role <%p (name => {<Q::DIS:uri>});> is not supported
     @@@XSubTypeDef:
       @@@@QName: NO_REFLECT_GET_DEFINED_ERR
       @@@@enDesc:
          An attribute is defined to reflect an element attribute
          but no reflecting attribute getter template is defined.
       @@@@XSourceNodeParam:
       @@@@XParam:
         @@@@@QName:uri
         @@@@@enDesc:
           The URI reference of the datatype resource for which
           a getter template should have been defined.
     @@@XSubTypeDef:
       @@@@QName: NO_REFLECT_SET_DEFINED_ERR
       @@@@enDesc:
          An attribute is defined to reflect an element attribute
          but no reflecting attribute setter template is defined.
       @@@@XSourceNodeParam:
       @@@@XParam:
         @@@@@QName:uri
         @@@@@enDesc:
           The URI reference of the datatype resource for which
           a setter template should have been defined.
     @@@XSubTypeDef:
       @@@@QName: NO_END_TAG_ERR
       @@@@enDesc:
         Close tag not found.
       @@@@XSourceNodeParam:
       @@@@XParam:
         @@@@QName: elementType
         @@@@enDesc:
           The type URI reference of the element that is not closed.
       @@@@XParam:
         @@@@QName: sourceCode
         @@@@enDesc:
           The source code fragment near the position where
           an end tag is required.
       @@@@enMufDef:
         End tag for element "%p (name => {<Q::DIS:elementType>});"
         is required%p (name => {<Q::DIS:sourceCode>},
         prefix => { (}, suffix => {)});
  @ImplNote:
    @@lang:en
    @@@:
      ISSUE: Too many subtypes for a type!  New type should be added?
##DISException

XParamDef:
  @QName:expectedType
  @Type: ResourceURI
  @enDesc:
    Expected resource type URI reference.

XParamDef:
  @QName: sourceCode
  @Type:
    DISLang:String::ManakaiDOM:all
  @enDesc:
    The source code fragment in which an error occurred.

XParamDef:
  @QName: elementType
  @Type: ResourceURI
  @enDesc:
    The name of the element type. 

XParamDef:
  @QName: uri
  @Type: ResourceURI
  @enDesc:
    The name of the resource, composed from <Q::namespaceURI>, 
    <Q::localName> and <Q::for>. 

XParamDef:
  @QName: localName
  @Type: 
    DISCore:LocalName::ManakaiDOM:all
  @enDesc:
    The local name of the resource, unique in <Q::namespaceURI> namespace. 

XParamDef:
  @QName: namespaceURI
  @Type: AnyURI
  @enDesc:
    The namespace URI reference of the resource name. 

XParamDef:
  @QName: for
  @Type: ForURI
  @enDesc:
    The <QUOTE::for> URI reference of the resource. 

ElementTypeBinding:
  @Name: XSourceNodeParam
  @ElementType:
    ManakaiDOM:exceptionOrWarningParameter
  @ShadowContent:
    @@QName: sourceNode
    @@Description:
      @@@lang:en
      @@@@:
        The node in which an error has occurred. 

ElementTypeBinding:
  @Name: XSourceCodeParam
  @ElementType:
    ManakaiDOM:exceptionOrWarningParameter
  @ShadowContent:
    @@QName: sourceCode
    @@Description:
      @@@lang:en
      @@@@:
        The source code in which an error has occurred. 

ClsDef:
  @ClsQName: ManakaiDISExceptionTarget

  @Implement: ecore|MUErrorTarget||ManakaiDOM|Perl

  @enDesc:
    Objects that is able to be the target of an exception. 

  @IntMethod:
    @@Operator:
      @@@@:
        ManakaiDOM:MUErrorHandler
      @@@ContentType:
        dis:TypeQName
    @@Description:
      @@@lang:en
      @@@@:
        This method is a generic error handler; all manakai exceptions 
        and warnings associated to an object are once reported to this method 
        and then delivered to appropriate entities. 
        \
        If the error is an exception (such as <X::DOMCore:DOMException> or 
        <X::ManakaiDOM:ManakaiDOMImplementationException>), it is 
        simply thrown.  If the error is only a warning, it is reported 
        via the <IF::DOMCore:DOMError> interface. 
        \
        See <PerlModule::Message::Util::Error> documentation for more 
        information on the error reporting mechanism.
        \
        {NOTE:: This kind of methods are named as <Perl::___report_error> 
                in the convention of <PerlModule::Message::Util::Error>. 
        \
        }
    @@Param:
      @@@Name:err
      @@@Type: 
        ManakaiDOM:ManakaiDOMExceptionOrWarning::ManakaiDOM:Perl
      @@@Description:
        @@@@lang:en
        @@@@@:
          An exception object that describes what kind of error it is 
          and how it should be recovered. 
          \
          {NOTE:: Exception objects in manakai implementation 
                  inherit the class <PerlModule::Message::Util::Error>, 
                  that in turn inherits <PerlModule::Error>.
          \
          }
    @@Return:
      @@@PerlDef:
          if ($err->isa (<ClassName::ManakaiDOM:ManakaiDOMException
                                   ::ManakaiDOM:Perl>)) {
            $err->throw;
          } else {
            \## TODO: Implement warning reporting
            warn $err->stringify;
          }
##DISExceptionTarget


ElementTypeBinding:
  @Name: PerlName
  @ElementType:
    dis:AppName
  @ShadowContent:
    @@ContentType: lang|Perl
    @@For: ManakaiDOM|Perl

ElementTypeBinding:
  @Name: Method
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:Method

ElementTypeBinding:
  @Name: IntMethod
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:Method
    @@ManakaiDOM:isForInternal:1

ElementTypeBinding:
  @Name: Attr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:Attribute

ElementTypeBinding:
  @Name: Return
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:MethodReturn

ElementTypeBinding:
  @Name: Get
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:AttributeGet

ElementTypeBinding:
  @Name: Set
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:AttributeSet

ElementTypeBinding:
  @Name: Param
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:MethodParameter

ElementTypeBinding:
  @Name: PerlDef
  @ElementType:
    dis:Def
  @ShadowContent:
    @@ContentType:
      lang:Perl

ElementTypeBinding:
  @Name: disDef
  @ElementType:
    dis:Def
  @ShadowContent:
    @@ContentType:
      lang:dis

ElementTypeBinding:
  @Name: InCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:InCase

ElementTypeBinding:
  @Name: nullCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:InCase
    @@Value:
      @@@is-null:1

ElementTypeBinding:
  @Name: TrueCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:InCase
    @@Value:true
    @@Type:
      DOMMain:boolean::ManakaiDOM:all


ElementTypeBinding:
  @Name: FalseCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:InCase
    @@Value:false
    @@Type:
      DOMMain:boolean::ManakaiDOM:all

ElementTypeBinding:
  @Name: enDesc
  @ElementType:
    dis:Description
  @ShadowContent:
    @@lang:en

ElementTypeBinding:
  @Name: PropDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      rdf:Property
    @@AliasFor:
      @@@@:
        ::ManakaiDOM:all
      @@@For:
        !=ManakaiDOM:all

ElementTypeBinding:
  @Name: MethodRedef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:Method
    @@ManakaiDOM:isRedefining:1

ElementTypeBinding:
  @Name: NamedParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:MethodParameter
    @@DISPerl:isNamedParameter:1

ElementTypeBinding:
  @Name: NodeParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:MethodParameter
    @@DISPerl:isNamedParameter:1
    @@Name: node
    @@Type: DISNode
    @@actualType:
      @@@@: ManakaiDISNode
      @@@ForCheck: ManakaiDOM|ForClass
    @@Description:
      @@@lang:en
      @@@@:
        The node in which the name has occurred.  It is intended 
        to be reported when an exception had been raised. 
    @@ResourceDef:
      @@@rdf:type:
        ManakaiDOM:InCase
      @@@Value:
        @@@@is-null:1
      @@@Description:
        @@@@lang:en
        @@@@@:
          The source of the name is not a node. 

ElementTypeBinding:
  @Name: ForParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:MethodParameter
    @@DISPerl:isNamedParameter:1
    @@Name: forArg
    @@Type: ForURI
    @@Description:
      @@@lang:en
      @@@@:
        The <QUOTE::for> URI reference. 
    @@ResourceDef:
      @@@rdf:type:
        ManakaiDOM:InCase
      @@@Value:
        @@@@is-null:1
      @@@Description:
        @@@@lang:en
        @@@@@:
          Equivalent to <Q::ManakaiDOM:all>, i.e. <QUOTE::for all>. 

ElementTypeBinding:
  @Name: ForpParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:MethodParameter
    @@DISPerl:isNamedParameter:1
    @@Name: forpArg
    @@Type: ForURIList
    @@Description:
      @@@lang:en
      @@@@:
        An array reference containing additional <QUOTE::for> 
        constraints (<QUOTE::For+> list).
    @@ResourceDef:
      @@@rdf:type:
        ManakaiDOM:InCase
      @@@Value:
        @@@@is-null:1
      @@@Description:
        @@@@lang:en
        @@@@@:
          Equivalent to the empty array reference. 

ElementTypeBinding:
  @Name: MediaTypeParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:MethodParameter
    @@DISPerl:isNamedParameter:1
    @@Name: mediaType
    @@Type: MediaTypeURI
    @@Description:
      @@@lang:en
      @@@@:
        The URI reference identifying a media type. 
    @@ResourceDef:
      @@@rdf:type:
        ManakaiDOM:InCase
      @@@Value:
        @@@@is-null:1
      @@@Description:
        @@@@lang:en
        @@@@@:
          No media type specified. 

ElementTypeBinding:
  @Name: MediaTypeDefaultParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:MethodParameter
    @@DISPerl:isNamedParameter:1
    @@Name: defaultMediaType
    @@Type: MediaTypeURI
    @@Description:
      @@@lang:en
      @@@@:
        The default media type, i.e. the type used when no explicit 
        specification is not found in the source tree. 
    @@ResourceDef:
      @@@rdf:type:
        ManakaiDOM:InCase
      @@@Value:
        @@@@is-null:1
      @@@Description:
        @@@@lang:en
        @@@@@:
          Defaulted to <Q::DOMMain:any>. 

ElementTypeBinding:
  @Name: RaiseException
  @ElementType:
    ManakaiDOM:raises

ElementTypeBinding:
  @Name: UndeclaredPrefixException
  @ElementType:
    ManakaiDOM:raises
  @ShadowContent:
    @@@: UNDECLARED_NS_PREFIX_ERR
    @@Description:
      @@@lang:en
      @@@@:
        The implementation has encounted an undeclared namespace prefix. 

ElementTypeBinding:
  @Name: NoDBException
  @ElementType:
    ManakaiDOM:raises
  @ShadowContent:
    @@@: NO_ASSOCIATED_DB_ERR
    @@Description:
      @@@lang:en
      @@@@:
        No <QUOTE::dis> database is associated to this document. 

ElementTypeBinding:
  @Name: XConstDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:Const

ElementTypeBinding:
  @Name: XSubTypeDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:ExceptionOrWarningSubType
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: XParam
  @ElementType:
    ManakaiDOM:exceptionOrWarningParameter

ElementTypeBinding:
  @Name: XParamDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: 
      DOMMain:XWParameter
    @@For:
      =ManakaiDOM:all

ElementTypeBinding:
  @Name: enMufDef
  @ElementType:
    dis:Def
  @ShadowContent:
    @@ContentType:
      lang:muf
    @@lang:en


