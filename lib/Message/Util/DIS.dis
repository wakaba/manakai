Module:
  @QName:
    Util:DIS
  @FullName:
    @@lang: en
    @@@:
      <QUOTE::DIS> Object Model
  @Namespace:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS#
  
  @Description:
    @@lang:en
    @@@:
      This module provides an object model for <QUOTE::dis> document format.  

  @Author:
    @@FullName: Wakaba
    @@Mail: w@suika.fam.cx
  @License:
    @@@:
      license:Perl+MPL
    @@Original:
      @@@FullName:
        manakai <CODE::lib/manakai/dis.pl> and <CODE::bin/cdis2pm.pl>
      @@@Year:2004
      @@@Author:
        @@@@FullName:Wakaba
        @@@@Mail:w@suika.fam.cx
  @Date:
    @@@:
      $Date: 2005/04/29 14:55:52 $
    @@ContentType:
      dis:Date.RCS
  
  @Require:
    @@Module:
      @@@Name: SuikaWikiConfig21
      @@@QName:
        Markup:SuikaWikiConfig21
      @@@WithFor:
        swcfg21:ForLatest
    @@Module:
      @@@Name: DIS
      @@@WithFor: 
        DIS:ForLatest
    @@Module:
      @@@Name: PerlCode
      @@@WithFor:
        ManakaiDOM:Perl

  @DefaultFor: 
    DIS:ForLatest

Namespace:
  @DIS:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS#
  @dis:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#dis--
  @dis2pm:
    http://suika.fam.cx/~wakaba/archive/2004/11/8/dis2pm#
  @DISlib:
    http://suika.fam.cx/~wakaba/archive/2004/dis/
  @disPerl:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#dis--Perl--
  @DOMCore:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#
  @DOMLS:
    http://suika.fam.cx/~wakaba/archive/2004/dom/ls#
  @DOMMain:
    http://suika.fam.cx/~wakaba/archive/2004/dom/main#
  @infoset:
    http://www.w3.org/2001/04/infoset#
  @lang:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#
  @license:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/license#
  @ManakaiDOM:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#
  @Markup:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Markup#
  @MDOMX:
    http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#
  @owl:
    http://www.w3.org/2002/07/owl#
  @Perl:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#Perl--
  @rdf:
    http://www.w3.org/1999/02/22-rdf-syntax-ns#
  @rdfs:
    http://www.w3.org/2000/01/rdf-schema#
  @swcfg21:
    http://suika.fam.cx/~wakaba/archive/2005/swcfg21#
  @TreeCore:\
  @Util:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/

## -- "For" definitions

ForDef:
  @QName: 
    DIS:ForLatest
  @Description:
    @@lang:en
    @@@:
      For latest version of the <Module::Util:DIS> module implementation
  @ISA:
    ManakaiDOM:Perl

## -- Features

ElementTypeBinding:
  @Name: FeatureDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DOMMain:DOMFeature
    @@ForCheck:
      ManakaiDOM:all

ElementTypeBinding:
  @Name: FeatureVerDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DOMMain:DOMFeature

ElementTypeBinding:
  @Name: featureQName
  @ElementType:
    dis:AppName
  @ShadowContent:
    @@ContentType:
      dis:TypeQName

FeatureDef:
  @QName: Core
  @FeatureVerDef:
    @@QName: CoreFeature10
    @@Version: 1.0
    @@DOMMetaImpl:instanceFeatureOf: Core
    @@FullName:
      @@@lang:en
      @@@@:
        The <QUOTE::dis> object model, version 1.0
    @@Description:
      @@@lang:en
      @@@@:
        The <QUOTE::dis> object model, version 1.0. 
    @@DOMMain:requireFeature: 
      swcfg21:CoreFeature21

## -- SuikaWikiConfig/2.1 extended classes

ClsDef:
  @ClsQName: ManakaiDISImplementation
  @ClsISA:
    swcfg21:ManakaiSWCFGImplementation::swcfg21:ForLatest
  @Description:
    @@lang:en
    @@@:
      A <QUOTE::dis> implementation object. 

  @Method:
    @@Name: createDISDocument
    @@Description:
      @@@lang:en
      @@@@:
        Creates an empty <Class::ManakaiDISDocument> object. 
    @@Return:
      @@@Type:ManakaiDISDocument
      @@@Description:
        @@@@lang:en
        @@@@@:
          The newly created <QUOTE::dis> document object.
      @@@PerlDef:
        $r = $self-><M::swcfg21:SWCFGImplementation::swcfg21:ForLatest
                                              .createSWCFGDocument>;
        $r-><AS::swcfg21:SWCFGDocument::swcfg21:ForLatest
                                        .defaultElementTypeNamespaceURI>
                    (<Q::dis:>);

  @Method:
    @@Name: createDISParser
    @@Description:
      @@@lang:en
      @@@@:
        Creates a <Class::ManakaiDISParser> object. 
    @@Return:
      @@@Type: ManakaiDISParser
      @@@Description:
        @@@@lang:en
        @@@@@: 
          A newly created <QUOTE::dis> parser. 
      @@@PerlDef:
        $r = bless $self-><M::swcfg21:SWCFGImplementation::swcfg21:ForLatest
                                           .createSWCFGParser>,
                   <ClassName::ManakaiDISParser>;

  @Method:
    @@Name: createDISDatabase
    @@Description:
      @@@lang:en
      @@@@:
        Creates a new <QUOTE::dis> database.
    @@Return:
      @@@Type:ManakaiDISDatabase
      @@@Description:
        @@@@lang:en
        @@@@@:
          A newly created <QUOTE::dis> parser.
      @@@PerlDef:
        $r = bless {
          forDef => {
            <Q::ManakaiDOM:all> => bless ({
              uri => <Q::ManakaiDOM:all>,
              isa => {<Q::ManakaiDOM:all> => 1},
              revISA => {},
            }, <ClassName::ManakaiDISForDefinition>),
          },
          resDef => {},
          modDef => {},
          seq => 0,
        }, <ClassName::ManakaiDISDatabase>;

  @Method:
    @@Name: tfurisToURI
    @@Description:
      @@@lang:en
      @@@@:
        Converts a pair of name URI reference and <QUOTE::for> URI reference 
        into a <TYPE::dis:TFQNames>-expanded URI reference. 
    @@Param:
      @@@Name: typeURI
      @@@Type: NameURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          A URI reference to identify a resource. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            Equivalent to <Q::DOMMain:any> (for historical reason). 
    @@Param:
      @@@Name: forURI
      @@@Type: ForURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          A <QUOTE::for> URI reference. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            Equivalent to <QUOTE::for all>, i.e. <Q::ManakaiDOM:all>. 
    @@Return:
      @@@Type: 
        DISCore:TFURI::ManakaiDOM:all
      @@@Description:
        @@@@lang:en
        @@@@@:
          The <TYPE::dis:TFQNames>-expanded URI references.  
      @@@PerlDef:
        $typeURI = <Q::DOMMain:any> unless defined $typeURI;
        $forURI = <Q::ManakaiDOM:all> unless defined $forURI;
        __CODE{tfurisToURI:: $turi => $typeURI, $furi => $forURI, $uri => $r}__;

  @ResourceDef:
    @@QName: tfurisToURI
    @@rdf:type:
      dis2pm:BlockCode
    @@enDesc:
        Converts a pair of name URI reference and <QUOTE::for> URI reference 
        into a <TYPE::dis:TFQNames>-expanded URI reference. 
    @@PerlDef:      
        if ($furi eq <Q::ManakaiDOM:all>) {
          $uri = $turi;
        } else {
          ## NOTE: [RFC 3986]
          ##       fragment    := *(pchar / "/" / "?")
          ##       pchar       := unreserved / pct-encoded / sub-delims / [:@]
          ##       unreserved  := ALPHA / DIGIT / [._~-]
          ##       sub-delims  := [!$&'()*+,;=]
          ## NOTE: [XPointer Framework]
          ##       SchemeData  := *EscapedData
          ##       EscapedData := NormalChar / "^(" / "^)" / "^^"
          ##                    / "(" SchemeData ")"
          ##       NormalChar  := UnicodeChar - [()^]
          my $__turi = $turi;
          my $__furi = $furi;
          for my $__uri ($__turi, $__furi) {
            $__uri =~ s{([^0-9A-Za-z:;?=_./-])}{sprintf '%%%02X', ord $1}ge;
          }
          $uri = qq<data:,200411tf#xmlns(t=data:,200411tf%23)>.
                                qq<t:tf($__turi,$__furi)>;
        }

  @ResourceDef:
    @@QName: tfpurisToURI
    @@rdf:type:
      dis2pm:BlockCode
    @@enDesc:
        Converts a set of name URI reference and <QUOTE::for> URI reference 
        and <QUOTE::for+> URI references into a URi reference. 
    @@PerlDef:      
        if ($furi eq <Q::ManakaiDOM:all> and @{$forp} == 0) {
          $uri = $turi;
        } elsif (@{$forp}) {
          my $__turi = $turi;
          my $__furi = $furi;
          for my $__uri ($__turi, $__furi) {
            $__uri =~ s{([^0-9A-Za-z:;?=_./~!&+-])}{sprintf '%%%02X', ord $1}ge;
          }
          my @__fp;
          for my $__uri (@{$forp}) {
            my $__fpuri = $__uri;
            $__fpuri =~ s{([^0-9A-Za-z:;?=_./~!&+-])}
                         {sprintf '%%%02X', ord $1}ge;
            push @__fp, $__fpuri;
          }
          $uri = qq<data:,200411tf#xmlns(t=data:,200411tf%23)>.
                               qq<t:tfp($__turi,$__furi,>.join (',', @__fp).q<)>;
        } else {
          my $__turi = $turi;
          my $__furi = $furi;
          for my $__uri ($__turi, $__furi) {
            $__uri =~ s{([^0-9A-Za-z:;?=_./-])}{sprintf '%%%02X', ord $1}ge;
          }
          $uri = qq<data:,200411tf#xmlns(t=data:,200411tf%23)>.
                                qq<t:tf($__turi,$__furi)>;
        }

  @ResourceDef:
    @@QName: getChildResourceURI
    @@rdf:type: 
      dis2pm:BlockCode
    @@enDesc:
      Gets an anonymous URI reference of a child resource of another 
      resource. 
    @@PerlDef:
      my $__parent = $parentURI;
      my $__ln = $localName;
      for my $__uri ($__parent, $__ln) {
        $__uri =~ s{([^0-9A-Za-z:;?=_./~!&+-])}{sprintf '%%%02X', ord $1}ge;
      }
      $result = q<data:,200411tf#xmlns(t=data:,200411tf%23)>.
                              qq<t:child($__parent,$__ln)>;

  @IntMethod:
    @@Name: camelCaseToUnderscoreName
    @@enDesc:
      Converts a camelCase name to a underscored_name. 
    @@ManakaiDOM:isStatic:1
    @@Param:
      @@@Name: camelName
      @@@Type:
        DISLang:String::ManakaiDOM:all
      @@@enDesc:
        The source name. 
    @@Return:
      @@@Type:
        DISLang:String::ManakaiDOM:all
      @@@enDesc:
        The result name. 
      @@@PerlDef:
        $r = $camelName;
        $r =~ s/^([A-Z0-9]+)$/lc $1/ge;
        $r =~ s/([A-Z][A-Z0-9]*)$/"_".lc $1/ge;
        $r =~ s/([A-Z0-9])([A-Z0-9]*)([A-Z0-9])/$1.lc ($2)."_".lc $3/ge;
        $r =~ s/([A-Z])/"_".lc $1/ge;
        $r =~ s/(?=[0-9](?!$))/_/g;

  @Method:
    @@Name: plLoadDISDatabase
    @@enDesc:
      Loads a database from a file that was saved by 
      <M::ManakaiDISDatabase.plStore>. 
      \
      {NOTE:: <QUOTE::dis> documents restored from external file
              would have different <A::ManakaiDISDocument.implementation> 
              than this <Class::ManakaiDISImplementation>, even if 
              it has been created by this implementation
              and stored in the same session. 
      \
      }
    @@Param:
      @@@Name:fileName
      @@@Type: 
        DISLang:String::ManakaiDOM:all
      @@@enDesc:
        An environment-dependent file name. 
    @@Return:
      @@@Type: ManakaiDISDatabase
      @@@SimpleException:
      @@@PerlDef:
        use Storable qw/retrieve/;
        local $Carp::CarpLevel = $Carp::CarpLevel + 1;
        $r = retrieve $fileName;

        ## Restores weak references
        require Scalar::Util;
        for my $doc (values %{$r->{<Q::DIS:sourceFile>}}) {
          Scalar::Util::weaken ($doc->{<Q::TreeCore:node>}->{<Q::DIS:db>});
        }
        for my $def (values %{$r->{modDef}},
                     values %{$r->{forDef}},
                     values %{$r->{resDef}}) {
          Scalar::Util::weaken ($def->{db});
        }

  @DOMMetaImpl:provideFeature: CoreFeature10
##DISImplementation

ElementTypeBinding:
  @Name: SimpleException
  @ElementType:
    dis:Description
  @ShadowContent:
    @@lang:en
    @@@:
      - Exception of type <PerlModule::Error::Simple>::: 
             I/O error or other error reported by <PerlModule::Storable>. 

## TODO: Formal description required for simple exception

ClsDef:
  @ClsQName: ManakaiDISParser
  @ClsISA:
    swcfg21:ManakaiSWCFGParser::swcfg21:ForLatest
  @Description:
    @@lang:en
    @@@:
      A SuikaWikiConfig/2.1 parser that returns <QUOTE::dis> object. 
  @Method:
    @@Name: parse
    @@Description:
      @@@lang:en
      @@@@:
        Parses a <QUOTE::dis> document and returns it as an object tree. 
    @@Param:
      @@@Name: input
      @@@Type:
        DOMLS:LSInput::ManakaiDOM:ManakaiDOM3
      @@@Description:
        @@@@lang:en
        @@@@@:
          The input source. 
    @@Return:
      @@@Type: ManakaiDISDocument
      @@@Description:
        @@@@lang:en
        @@@@@:
          The <QUOTE::dis> document object created from the <P::input>. 
      @@@RaiseException:
        @@@@@:
          swcfg21:SWCFG_PARSE_ERR
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The <IF::swcfg21:SWCFGParser> was unable to load the SuikaWikiConfig 
            document. 
      @@@PerlDef:
        __DEEP{
          $r = $self-><M::swcfg21:ManakaiSWCFGParser
                        ::swcfg21:ForLatest.parse> ($input);
        }__;
        if (defined $r) {
          $r = bless $r, <ClassName::ManakaiDISDocument>;
          $r-><AS::swcfg21:SWCFGDocument::swcfg21:ForLatest
                                        .defaultElementTypeNamespaceURI>
                    (<Q::dis:>);
        }
##DISParser

ClsDef:
  @ClsQName: ManakaiDISNode
  @Description:
    @@lang:en
    @@@:
      <QUOTE::dis> node objects. 
  @ImplNote:
    @@lang:en
    @@@:
      This class does not inherit 
      <Class::swcfg21:ManakaiSWCFGNode::swcfg21:ForLatest>, since 
      inheriting classes such as <Class::ManakaiDISElement> indirectly 
      inherit it. 

  @MethodRedef:
    @@Name:lookupNamespacePrefix
    @@Description:
      @@@lang:en
      @@@@:
        Looks up the namespace prefix associated to the given 
        namespace URI.  The default namespaces are ignored. 
    @@Param:
      @@@Name:namespaceURI
      @@@Type: AnyURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          The namespace URI to look for. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The <DOM::null> namespace. 
    @@NamedParam:
      @@@Name: makeNewBinding
      @@@Type: 
        DOMMain:boolean::ManakaiDOM:all
      @@@Description:
        @@@@lang:en
        @@@@@:
          Whether a new namespace prefix should be bound when 
          no namespace URI has been associated yet. 
      @@@InCase:
        @@@@Value:true
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            New binding is made if no prefix associated. 
      @@@InCase:
        @@@@Value:false
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            Simply returns the <DOM::null> if no prefix associated. 
    @@Return:
      @@@Type:
        DISCore:NamespacePrefix::ManakaiDOM:all
      @@@Description:
        @@@@lang:en
        @@@@@:
           An associated namespace prefix.  If more than one prefix 
           are associated to the namespace URI, the returned prefix 
           is implementation dependent. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            No associated namespace prefix found. 
      @@@PerlDef:
        $r = null;
        my $od = $self-><AG::swcfg21:SWCFGNode::swcfg21:ForLatest
                                          .ownerDocument> || $self;
        my $binds = $od->{<Q::TreeCore:node>}->{<Q::swcfg21:nsBinding>};
        if (defined $namespaceURI) {
          FIND: {
            for my $prefix (keys %$binds) {
              if (defined $binds->{$prefix} and
                  $binds->{$prefix} eq $namespaceURI) {
                $r = $prefix;
                last FIND;
              }
            }

            ## From module list
            try {
              my $db = $self-><AG::ManakaiDISNode.ownerDISDocument>
                            -><AG::ManakaiDISDocument.disDatabase>;
              for my $mod_uri (keys %{$db->{modDef}}) {
                my $mod = $db-><M::ManakaiDISDatabase.getModule> ($mod_uri);
                my $mod_ln = $mod-><AG::ManakaiDISModuleDefinition.localName>;
                next if exists $binds->{$mod_ln};
                my $ns_uri = $mod-><M::ManakaiDISPropertyAccessor
                                            .getPropertyText>
                                                 (<Q::dis:Namespace>, '');
                if ($ns_uri eq $namespaceURI) {
                  $r = $mod_ln;
                  last FIND;
                }
              }
            } catch <Class::ManakaiDISException> with {
              my $err = shift;
              $err->throw
                unless $err->{<Q::MDOMX:subtype>} eq <Q::NO_DB_ASSOCIATED_ERR>;
            };

            last FIND unless $makeNewBinding;
            ## Not found
            if ($namespaceURI =~ /(\w+)$/) {
              my $prefix = $1;
              unless (exists $binds->{$prefix}) {
                $binds->{$prefix} = $namespaceURI;
                $r = $prefix;
                last FIND;
              }
            }
            my $i = 1;
            {
              unless (exists $binds->{'ns'.$i}) {
                $binds->{$r = 'ns'.$i} = $namespaceURI;
                last FIND;
              }
              $i++;
              redo;
            }
          } # FIND
        } else {  ## Null namespace
          FIND: {
            if (exists $binds->{'nu'.'ll'} and not defined $binds->{'nu'.'ll'}) {
              $r = 'nu'.'ll';
              last FIND;
            }
            for my $prefix (keys %$binds) {
              if (not defined $prefix) {
                $r = $prefix;
                last FIND;
              }
            }
            last FIND unless $makeNewBinding;
            ## Not found
            my $i = '';
            {
              unless (exists $binds->{'nu'.'ll'.$i}) {
                $binds->{$r = 'nu'.'ll'.$i} = null;
                last FIND;
              }
              $i++;
              redo;
            }
          }
        }

  @MethodRedef:
    @@Name:lookupNamespaceURI
    @@Description:
      @@@lang:en
      @@@@:
        Looks up the namespace URI associated to the given prefix. 
    @@Param:
      @@@Name:prefix
      @@@Type:
        DISCore:NamespacePrefix::ManakaiDOM:all
      @@@Description:
        @@@@lang:en
        @@@@@:
          The namespace URI to look for. 
    @@NamedParam:
      @@@Name: makeNewBinding
      @@@Type:
        DOMMain:boolean::ManakaiDOM:all
      @@@Description:
        @@@@lang:en
        @@@@@:
          Whether a new binding should be created if no namespace URI 
          is associated with the <P::prefix> or not. 
      @@@InCase:
        @@@@Value:true
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            A new binding to the temporary namespace URI 
            exactly same as <P::prefix> is created 
            if no binding found. 
      @@@InCase:
        @@@@Value:false
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            No new binding is created if no binding found.  Note that 
            even if no association newly created, this method 
            returns the <DOM::null> value. 
    @@NamedParam:
      @@@Name: raisePrefixException
      @@@Type:
        DOMMain:boolean::ManakaiDOM:all
      @@@enDesc:
        Whehter an exception should be thrown if <P::prefix>
        is not declared or not. 
    @@Return:
      @@@Type: AnyURI
      @@@Description:
        @@@@lang:en
        @@@@@:The associated namespace URI. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            No namespace URI is associated to the prefix or 
            the <DOM::null> namespace is associated. 
      @@@UndeclaredPrefixException:
      @@@PerlDef:
        my $od = $self-><AG::swcfg21:SWCFGNode::swcfg21:ForLatest
                                               .ownerDocument> || $self;
        my $binds = $od->{<Q::TreeCore:node>}->{<Q::swcfg21:nsBinding>};
        if (exists $binds->{$prefix}) {
          $r = $binds->{$prefix};
        } else {
          ## From module list
          FIND: {
            try {
              my $db = $self-><AG::ManakaiDISNode.ownerDISDocument>
                            -><AG::ManakaiDISDocument.disDatabase>;
              for my $mod_uri (keys %{$db->{modDef}}) {
                my $mod = $db-><M::ManakaiDISDatabase.getModule> ($mod_uri);
                if ($mod-><AG::ManakaiDISModuleDefinition.localName>
                      eq $prefix) {
                  $r = $mod-><M::ManakaiDISPropertyAccessor
                                              .getPropertyText>
                                                   (<Q::dis:Namespace>, null);
                  last FIND;
                }            
              }
            } catch <Class::ManakaiDISException> with {
              my $err = shift;
              $err->throw
                unless $err->{<Q::MDOMX:subtype>} eq <Q::NO_DB_ASSOCIATED_ERR>;
            };
            if ($makeNewBinding) {
              $r = $binds->{$prefix} = $prefix;
            } elsif ($raisePrefixException) {
              __EXCEPTION{DIS:UNDECLARED_NS_PREFIX_ERR::
                infoset:prefix => {$prefix},
                MDOMX:param-name => 'prefix',
                DIS:sourceNode => {$self},
              }__;
            } else {
              $r = null;
            }
          } # FIND
        }

  @IntMethod:
    @@Name:getNodeReference
    @@Description:
      @@@lang:en
      @@@@:
        Returns a new reference to the node object. 
    @@ManakaiDOM:isStatic:1
    @@Param:
      @@@Name:object
      @@@Type:
        ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl
      @@@Description:
        @@@@lang:en
        @@@@@:
          The node object to be referred. 
    @@Return:
      @@@Type: ManakaiDISNode
      @@@Description:
        @@@@lang:en
        @@@@@:
          A newly created reference.
      @@@PerlDef:
        my $class;
        if ($object->{<Q::swcfg21:nodeType>} eq '#element') {
          $class = <ClassName::ManakaiDISElement>;
        } elsif ($object->{<Q::swcfg21:nodeType>} eq '#comment') {
          $class = <ClassName::ManakaiDISComment>;
        } elsif ($object->{<Q::swcfg21:nodeType>} eq '#document') {
          $class = <ClassName::ManakaiDISDocument>;
        } elsif ($object->{<Q::swcfg21:nodeType>} eq '#fragment') {
          $class = <ClassName::ManakaiDISDocumentFragment>;
        } else {
          __ASSERT{DISPerl:invariant::
            msg => {qq[Node type: "$object->{<Q::swcfg21:nodeType>}" ].
                    qq[(ref: "@{[ref $object]}")]},
          }__;
        }
        $r = $object-><M::ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl
                                  .newReference> ($class);
  
  @Attr:
    @@Name:ownerDISDocument
    @@Description:
      @@@lang:en
      @@@@:
        The <QUOTE::dis> document object associated with this node. 
    @@Get:
      @@@Type:ManakaiDISDocument
      @@@Description:
        @@@@lang:en
        @@@@@:
          The document object associated with this node. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            This node is a document node. 
      @@@PerlDef:
        $r = <ClassM::ManakaiDISNode.getNodeReference>
                ($self->{<Q::TreeCore:node>}->{<Q::swcfg21:ownerDocument>})
          if $self->{<Q::TreeCore:node>}->{<Q::swcfg21:ownerDocument>};
##DISNode

ClsDef:
  @ClsQName: ManakaiDISElement
  @ClsISA: ManakaiDISNode
  @ClsISA:
    swcfg21:ManakaiSWCFGElement::swcfg21:ForLatest
  @Description:
    @@lang:en
    @@@:
      <QUOTE::dis> element node objects. 

  @Method:
    @@Name: forMatch
    @@Description:
      @@@lang:en
      @@@@:
        Tests whether this element is for a <QUOTE::for> or not. 
    @@Param:
      @@@Name: forArg
      @@@Type: ForURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          The <QUOTE::For> URI reference to test against. 
    @@Param:
      @@@Name: forpArg
      @@@Type: ForURIList
      @@@Description:
        @@@@lang:en
        @@@@@:
          The <QUOTE::For+> URI references to test against. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            No additional <QUOTE::For> URI reference. 
            Equivalent to an empty array reference. 
    @@Return:
      @@@Type:
        DOMMain:boolean::ManakaiDOM:all
      @@@Description:
        @@@@lang:en
        @@@@@:
          Whether this element is for <P::forArg> and <P::forpArg> or not. 
      @@@UndeclaredPrefixException:
      @@@NoDBException:
      @@@PerlDef:
        $forArg = <Q::ManakaiDOM:all> unless defined $forArg;
        $forpArg ||= [];

        FORMATCH: {
          __DEEP{
            my $for_res = $self-><AG::ManakaiDISNode.ownerDISDocument>
                                   -><AG::ManakaiDISDocument.disDatabase>
                                   -><M::ManakaiDISDatabase.getFor> ($forArg);
            my $forp_res = [map {
                                  $self-><AG::ManakaiDISNode.ownerDISDocument>
                                       -><AG::ManakaiDISDocument.disDatabase>
                                       -><M::ManakaiDISDatabase.getFor> ($_)
                                } @{$forpArg}];

            my @ce = @{$self-><M::ManakaiDISElement.disAllChildElements>};
            for my $ce (@ce) {
              my $et = $ce-><AG::swcfg21:SWCFGElement::swcfg21:ForLatest
                                                      .expandedURI>;
              if ($et eq <Q::dis:ForCheck>) {
                my $fors = [split /\s+/, $ce-><M::swcfg21:SWCFGNode
                                                ::swcfg21:ForLatest.value>];
                FCs: for my $f (@$fors) {
                  if ($f =~ /^!=(.+)$/) {        ## -- NOT EQUAL TO
                    my $uri = $self-><M::ManakaiDISElement.qnameToURI> ($1);
                    my $for = $self-><AG::ManakaiDISNode.ownerDISDocument>
                                   -><AG::ManakaiDISDocument.disDatabase>
                                   -><M::ManakaiDISDatabase.getFor> ($uri);
                    $for-><AS::ManakaiDISForDefinition.isReferred> ($ce);
                    for my $arg_res ($for_res, @{$forp_res}) {
                      if ($arg_res eq $for) {
                        $r = false;
                        last FORMATCH;
                      }
                    }
                  } elsif ($f =~ /^!(.+)$/) {    ## -- NOT ISA
                    my $uri = $self-><M::ManakaiDISElement.qnameToURI> ($1);
                    my $for = $self-><AG::ManakaiDISNode.ownerDISDocument>
                                   -><AG::ManakaiDISDocument.disDatabase>
                                   -><M::ManakaiDISDatabase.getFor> ($uri);
                    $for-><AS::ManakaiDISForDefinition.isReferred> ($ce);
                    for my $arg_res ($for_res, @{$forp_res}) {
                      if ($arg_res-><M::ManakaiDISForDefinition.isaURI> ($uri)) {
                        $r = false;
                        last FORMATCH;
                      }
                    }
                  } elsif ($f =~ /^=(.+)$/) {    ## -- EQUAL TO
                    my $uri = $self-><M::ManakaiDISElement.qnameToURI> ($1);
                    my $for = $self-><AG::ManakaiDISNode.ownerDISDocument>
                                   -><AG::ManakaiDISDocument.disDatabase>
                                   -><M::ManakaiDISDatabase.getFor> ($uri);
                    $for-><AS::ManakaiDISForDefinition.isReferred> ($ce);
                    for my $arg_res ($for_res, @{$forp_res}) {
                      if ($arg_res eq $for) {
                        next FCs;
                      }
                    }
                    $r = false;
                    last FORMATCH;
                  } else {                       ## -- ISA
                    my $uri = $self-><M::ManakaiDISElement.qnameToURI> ($f);
                    my $for = $self-><AG::ManakaiDISNode.ownerDISDocument>
                                   -><AG::ManakaiDISDocument.disDatabase>
                                   -><M::ManakaiDISDatabase.getFor> ($uri);
                    $for-><AS::ManakaiDISForDefinition.isReferred> ($ce);
                    for my $arg_res ($for_res, @{$forp_res}) {
                      if ($arg_res-><M::ManakaiDISForDefinition.isaURI> ($uri)) {
                        next FCs;
                      }
                    }
                    $r = false;
                    last FORMATCH;
                  }
                } # FCs
              } # dis:ForCheck
            } # children

            my $has_for = false;
            for my $ce (@ce) {
              if ($ce-><AG::swcfg21:SWCFGElement::swcfg21:ForLatest
                                                     .expandedURI> eq
                  <Q::dis:For>) {
                my $fors = [split /\s+/, $ce-><M::swcfg21:SWCFGNode
                                                ::swcfg21:ForLatest.value>];
                my $ok = true;
                $has_for = true;
                AFOR: for my $f (@$fors) {
                  if ($f =~ /^!=(.+)$/) {         ## -- NOT EQUAL TO
                    my $uri = $self-><M::ManakaiDISElement.qnameToURI> ($1);
                    my $for = $self-><AG::ManakaiDISNode.ownerDISDocument>
                                   -><AG::ManakaiDISDocument.disDatabase>
                                   -><M::ManakaiDISDatabase.getFor> ($uri);
                    $for-><AS::ManakaiDISForDefinition.isReferred> ($ce);
                    if ($for eq $for_res) {
                      $ok = false;
                      last AFOR;
                    }
                  } elsif ($f =~ /^!(.+)$/) {     ## -- NOT ISA
                    my $uri = $self-><M::ManakaiDISElement.qnameToURI> ($1);
                    my $for = $self-><AG::ManakaiDISNode.ownerDISDocument>
                                   -><AG::ManakaiDISDocument.disDatabase>
                                   -><M::ManakaiDISDatabase.getFor> ($uri);
                    $for-><AS::ManakaiDISForDefinition.isReferred> ($ce);
                    if ($for_res-><M::ManakaiDISForDefinition.isaURI> ($uri)) {
                      $ok = false;
                      last AFOR;
                    }
                  } elsif ($f =~ /^=(.+)$/) {     ## -- EQUAL TO
                    my $uri = $self-><M::ManakaiDISElement.qnameToURI> ($1);
                    my $for = $self-><AG::ManakaiDISNode.ownerDISDocument>
                                   -><AG::ManakaiDISDocument.disDatabase>
                                   -><M::ManakaiDISDatabase.getFor> ($uri);
                    $for-><AS::ManakaiDISForDefinition.isReferred> ($ce);
                    unless ($for eq $for_res) {
                      $ok = false;
                      last AFOR;
                    }
                  } else {                        ## -- ISA
                    my $uri = $self-><M::ManakaiDISElement.qnameToURI> ($f);
                    my $for = $self-><AG::ManakaiDISNode.ownerDISDocument>
                                   -><AG::ManakaiDISDocument.disDatabase>
                                   -><M::ManakaiDISDatabase.getFor> ($uri);
                    $for-><AS::ManakaiDISForDefinition.isReferred> ($ce);
                    unless ($for_res-><M::ManakaiDISForDefinition.isaURI>($uri)){
                      $ok = false;
                      last AFOR;
                    }
                  }
                } # AFOR
                if ($ok) {
                  $r = true;
                  last FORMATCH;
                }
              } # dis:For
            } # $ce
            $r = $has_for ? false : true;
          }__;
        } # FORMATCH

  @Method:
    @@Name: mediaTypeMatch
    @@Description:
      @@@lang:en
      @@@@:
        Tests whether the content media type of this element matches to 
        a type or not. 
    @@Param:
      @@@Name: mediaType
      @@@Type: MediaTypeURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          A media type URI reference to test against. 
    @@Param:
      @@@Name: defaultMediaType
      @@@Type: MediaTypeURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          The default media type for this element. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            No default type provided.  All <P::mediaType> will match. 
    @@ForParam:
    @@ForpParam:
    @@Return:
      @@@Type:
        DOMMain:boolean::ManakaiDOM:all
      @@@Description:
        @@@@lang:en
        @@@@@:
          Whether this element is of <P::mediaType> or not. 
      @@@PerlDef:
        if (defined $mediaType) {
          __DEEP{
            my $ctn = $self-><M::ManakaiDISElement.disGetAttribute>
                                  (<Q::dis:ContentType>, for_arg => $forArg,
                                   forp_arg => $forpArg);
            my $ct;
            $ct = $ctn-><AG::ManakaiDISElement.qnameValueURI> if $ctn;
            $ct = $defaultMediaType unless defined $ct;
            my $res = $self-><AG::ManakaiDISNode.ownerDISDocument>
                                 -><AG::ManakaiDISDocument.disDatabase>
                                 -><M::ManakaiDISDatabase.getResource> ($ct);
            $res-><AS::ManakaiDISResourceDefinition.isReferred> ($ctn or $self);
            unless ($res-><M::ManakaiDISResourceDefinition
                                               .isSubsetOfURI> ($mediaType)) {
              $r = false;
            } else {
              $r = true;
            }
          }__;
        } else {
          $r = true;
        }

  @Method:
    @@Name:mediaTypeURI
    @@enDesc:
      The URI reference of the media type of this element. 
    @@Type: MediaTypeURI
    @@NamedParam:
      @@@Name:defaultMediaType
      @@@Type:MediaTypeURI
      @@@enDesc:
        The default media type URI reference. 
      @@@nullCase:
        @@@@enDesc:
          No default is specified. 
    @@ForParam:
    @@ForpParam:
    @@Return:
      @@@enDesc:
        The media type URI reference of this element. 
      @@@nullCase:
        @@@@enDesc:
          This element has no media type information and 
          <P::defaultMediaType> parameter is not provided. 
      @@@UndeclaredPrefixException:
      @@@PerlDef:
          __DEEP{
            my $ctn = $self-><M::ManakaiDISElement.disGetAttribute>
                                (<Q::dis:ContentType>, for_arg => $forArg,
                                 forp_arg => $forpArg);
            $r = $ctn-><AG::ManakaiDISElement.qnameValueURI> if $ctn;
          }__;

  @Method:
    @@Name: prefixToURI
    @@Description:
      @@@lang:en
      @@@@:
        Converts a namespace prefix into associated URI reference. 
    @@Param:
      @@@Name: prefix
      @@@Type:
        DISCore:NamespacePrefix::ManakaiDOM:all
      @@@Description:
        @@@@lang:en
        @@@@@:
          A namespace prefix to look for. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            Returns the default namespace URI. 
    @@NodeParam:
    @@Return:
      @@@Type: AnyURI
      @@@Description:
        @@@@lang:en
        @@@@@: The URI references associated. 
      @@@UndeclaredPrefixException:
      @@@PerlDef:
        if (defined $prefix) {
          __DEEP{
            $r = $self-><M::swcfg21:SWCFGNode::swcfg21:ForLatest
                                       .lookupNamespaceURI> ($prefix);
          }__;
          unless (defined $r) {
            __EXCEPTION{UNDECLARED_NS_PREFIX_ERR::
              infoset:prefix => {$prefix},
              MDOMX:param-name => 'prefix',
              DIS:sourceNode => {$node},
            }__;
          }
        } else {  ## Default namespace
          __DEEP{
            $r = ($self-><AG::ManakaiDISNode.ownerDISDocument> || $self)
                       -><AG::ManakaiDISDocument.moduleElement>
                       -><AG::ManakaiDISModuleElement.definingNamespaceURI>;
          }__;
        }

  @Method:
    @@QName: qnameToURI
    @@Description:
      @@@lang:en
      @@@@:
        Converts a qualified name (<TYPE::dis:TypeQName>) to 
        an expanded URI reference. 
    @@Param:
      @@@Name: qname
      @@@Type:
        dis:TypeQName::ManakaiDOM:all
      @@@Description:
        @@@@lang:en
        @@@@@:
          A qualified name. 
    @@NodeParam:
    @@NamedParam:
      @@@Name: defaultNamespaceURI
      @@@Type: AnyURI
      @@@enDesc:
        Default namespace URI reference. 
      @@@nullCase:
        @@@@enDesc:
          The default namespace is the namespace defined by the module
          to which this resource belongs.
    @@Return:
      @@@Type: AnyURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          The expanded URI reference. 
      @@@UndeclaredPrefixException:
      @@@PerlDef:
        $qname =~ s/^\s+//; $qname =~ s/\s+$//;
        my ($prefix, $lname) = split /\s*[:|]\s*/, $qname, 2;
        __DEEP{
          if (defined $lname) {
            $r = $self-><M::ManakaiDISElement.prefixToURI> ($prefix) . $lname;
          } else {  ## In default namespace
            if (defined $defaultNamespaceURI) {
              $r = $defaultNamespaceURI . $prefix;
            } else {
              $r = $self-><M::ManakaiDISElement.prefixToURI> (null) . $prefix;
            }
          }
        }__;

  @Method:
    @@QName: qnameToPair
    @@Description:
      @@@lang:en
      @@@@:
        Converts a qualified name (<TYPE::dis:TypeQName>) to 
        a pair of namespace URI and local name. 
    @@Param:
      @@@Name: qname
      @@@Type:
        dis:TypeQName::ManakaiDOM:all
      @@@Description:
        @@@@lang:en
        @@@@@:
          A qualified name. 
    @@NodeParam:
    @@Return:
      @@@Type:
        Perl:ARRAY::ManakaiDOM:all
      @@@Description:
        @@@@lang:en
        @@@@@:
          A list of namespace URI and local name. 
      @@@UndeclaredPrefixException:
      @@@PerlDef:
        $qname =~ s/^\s+//; $qname =~ s/\s+$//;
        my ($prefix, $lname) = split /\s*[:|]\s*/, $qname, 2;
        __DEEP{
          if (defined $lname) {
            $r = [$self-><M::ManakaiDISElement.prefixToURI> ($prefix), $lname];
          } else {  ## In default namespace
            $r = [$self-><M::ManakaiDISElement.prefixToURI> (null), $prefix];
          }
        }__;

  @Method:
    @@Name: tfqnamesToURI
    @@Description:
      @@@lang:en
      @@@@:
        Converts a <TYPE::dis:TFQNames>
        into an expanded URI reference. 
    @@Param:
      @@@Name: tfqnames
      @@@Type: 
        dis:TFQNames::ManakaiDOM:all
      @@@Description:
        @@@@lang:en
        @@@@@:
          A <TYPE::dis:TFQNames> to identify a resource. 
    @@Param:
      @@@Name: defaultTypeURI
      @@@Type: NameURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          A name URI reference used if it is missing from 
          <P::tfqnames>. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            Equivalent to <Q::DOMMain:any>. 
    @@Param:
      @@@Name: defaultForURI
      @@@Type: ForURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          A <QUOTE::for> URI reference used if it is missing from 
          <P::tfqnames>. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            Equivalent to <QUOTE::for all>, i.e. <Q::ManakaiDOM:all>. 
    @@NodeParam:
    @@Return:
      @@@Type: 
        DISCore:TFURI::ManakaiDOM:all
      @@@Description:
        @@@@lang:en
        @@@@@:
          The <TYPE::dis:TFQNames>-expanded URI references.  
      @@@UndeclaredPrefixException:
      @@@PerlDef:
        my ($typeq, $forq) = split /\s*[:|][:|]\s*/, $tfqnames, 2;
        my ($typeURI, $forURI);
        if (defined $forq) {
          __DEEP{
            $typeURI = $typeq eq ''
                       ? defined $defaultTypeURI ? $defaultTypeURI
                                                 : <Q::DOMMain:any>
                       : $self-><M::ManakaiDISElement.qnameToURI> ($typeq, %opt);
          }__;
          if (length $forq) {
            $forURI = $self-><M::ManakaiDISElement.qnameToURI> ($forq, %opt);
          } else {
            $forURI = <Q::ManakaiDOM:all>;
          }
        } else {  ## "For" omitted
          __DEEP{
            $typeURI = $typeq eq ''
                       ? defined $defaultTypeURI ? $defaultTypeURI
                                                 : <Q::DOMMain:any>
                       : $self-><M::ManakaiDISElement.qnameToURI> ($typeq, %opt);
          }__;
          $forURI = defined $defaultForURI ? $defaultForURI
                                           : <Q::ManakaiDOM:all>;
        }
        __CODE{tfurisToURI:: $turi => $typeURI, $furi => $forURI, $uri => $r}__;

  @Method:
    @@Name: disGetAttribute
    @@enDesc:
      Gets an attribute node. 
    @@Param:
      @@@Name: attrName
      @@@Type: AnyURI
      @@@enDesc:
        The name expanded URI of the node to retrieve. 
    @@ForParam:
    @@ForpParam:
    @@MediaTypeParam:
    @@MediaTypeDefaultParam:
    @@Return:
      @@@Type: ManakaiDISElement
      @@@enDesc:
        The attribute (property) element node. 
      @@@nullCase:
        @@@@enDesc:
          No attribute node found. 
      @@@PerlDef:
        for my $c (@{$self-><M::ManakaiDISElement.disChildElements>
                                  (for_arg => $forArg, forp_arg => $forpArg)}) {
          if ($c-><AG::swcfg21:SWCFGElement::swcfg21:ForLatest
                                    .expandedURI> eq $attrName and
              $c-><M::ManakaiDISElement.mediaTypeMatch>
                                  ($mediaType, $defaultMediaType,
                                   for_arg => $forArg, forp_arg => $forpArg)) {
            $r = $c;
            last;
          }
        }

  @Method:
    @@Name: disGetAttributeList
    @@enDesc:
      Gets attribute nodes. 
    @@Param:
      @@@Name: attrName
      @@@Type: AnyURI
      @@@enDesc:
        The name expanded URI of the node to retrieve. 
    @@ForParam:
    @@ForpParam:
    @@MediaTypeParam:
    @@MediaTypeDefaultParam:
    @@Return:
      @@@Type: ManakaiDISElementList
      @@@enDesc:
        The attribute (property) element nodes. 
      @@@PerlDef:
        $r = bless [], <ClassName::ManakaiDISElementList>;
        for my $c (@{$self-><M::ManakaiDISElement.disChildElements>
                                  (for_arg => $forArg, forp_arg => $forpArg)}) {
          if ($c-><AG::swcfg21:SWCFGElement::swcfg21:ForLatest
                                          .expandedURI> eq $attrName and
              $c-><M::ManakaiDISElement.mediaTypeMatch>
                                  ($mediaType, $defaultMediaType,
                                   for_arg => $forArg, forp_arg => $forpArg)) {
            push @$r, $c;
          }
        }

  @Method:
    @@Name: disChildElements
    @@enDesc:
      A list of child elements, with <QUOTE::for> check.  
    @@ForParam:
    @@ForpParam:
    @@Return:
      @@@Type: ManakaiDISElementList
      @@@enDesc:
        The current snapshot of child nodes. 
      @@@PerlDef:
        $r = bless [], <ClassName::ManakaiDISElementList>;    
        __DEEP{
          for my $cn (@{$self-><AG::swcfg21:SWCFGNode::swcfg21:ForLatest
                                                       .childNodes>}) {
            ## $cn is an #element.
            my $dn = $cn->{<Q::TreeCore:node>}
                        -><M::ManakaiDOM:ManakaiDOMNodeObject
                            ::ManakaiDOM:Perl.newReference>
                                      (<ClassName::ManakaiDISElement>);
            next unless $dn-><M::ManakaiDISElement.forMatch> ($forArg, $forpArg);
            push @$r, $dn;
          }
        }__;

  @Method:
    @@Name: disAllChildElements
    @@enDesc:
      A list of child elements, without <QUOTE::for> check.  
    @@Return:
      @@@Type: ManakaiDISElementList
      @@@enDesc:
        The current snapshot of child nodes. 
      @@@PerlDef:
        $r = bless [], <ClassName::ManakaiDISElementList>;    
        __DEEP{
          for my $cn (@{$self-><AG::swcfg21:SWCFGNode::swcfg21:ForLatest
                                                       .childNodes>}) {
            ## $cn is an #element.
            my $dn = $cn->{<Q::TreeCore:node>}
                        -><M::ManakaiDOM:ManakaiDOMNodeObject
                            ::ManakaiDOM:Perl.newReference>
                                      (<ClassName::ManakaiDISElement>);
            push @$r, $dn;
          }
        }__;

  @Attr:
    @@Name: qnameValueURI
    @@enDesc:
      The element value (written as <TYPE::dis:TypeQName>), as URI reference. 
      \
      {NOTE:: What should be if list value?
      \
      }
    @@Get:
      @@@Type:AnyURI
      @@@nullCase:
        @@@@enDesc:
          No value. 
      @@@UndeclaredPrefixException:
      @@@PerlDef:
        __DEEP{
          my $v = $self-><M::swcfg21:SWCFGNode::swcfg21:ForLatest.value>;
          if (defined $v and not ref $v eq 'ARRAY') {
            $r = $self-><M::ManakaiDISElement.qnameToURI> ($v, node => $self);
          } else {
            $r = null;
          }
        }__;

  @Attr:
    @@Name: qnameValueLocalName
    @@enDesc:
      The local name part of the element value (assumed as 
      written as <TYPE::dis:TypeQName>). 
      \
      {NOTE:: What should be if list value?
      \
      }
    @@Get:
      @@@Type:
        DISCore:LocalName::ManakaiDOM:all
      @@@nullCase:
        @@@@enDesc:
          No value. 
      @@@PerlDef:
        __DEEP{
          my $v = $self-><M::swcfg21:SWCFGNode::swcfg21:ForLatest.value>;
          if (defined $v and not ref $v eq 'ARRAY') {
            my ($n, $v) = split /\s*[:|]\s*/, $v, 2;
            $r = defined $v ? $v : $n;
          } else {
            $r = null;
          }
        }__;

  @Attr:
    @@Name: qnameValueNamespaceURI
    @@enDesc:
      The namespace URI of the element value (assumed as written 
      in <TYPE::dis:TypeQName>). 
      \
      {NOTE:: What should be if list value?
      \
      }
    @@Get:
      @@@Type:AnyURI
      @@@nullCase:
        @@@@enDesc:
          No value. 
      @@@UndeclaredPrefixException:
      @@@PerlDef:
        __DEEP{
          my $v = $self-><M::swcfg21:SWCFGNode::swcfg21:ForLatest.value>;
          if (defined $v and not ref $v eq 'ARRAY') {
            my ($p, $v) = split /\s*[:|]\s*/, $v, 2;
            $r = $self-><M::ManakaiDISElement.prefixToURI>
                                            (defined $v ? $p : null);
          } else {
            $r = null;
          }
        }__;

  @Method:
    @@Name: tfqnamesValueURI
    @@enDesc:
      The element value (written as <TYPE::dis:TFQNames>),
      as URI reference. 
      \
      {NOTE:: What should be if list value?
      \
      }
    @@Param:
      @@@Name: defaultTypeURI
      @@@Type: NameURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          A name URI reference used if it is missing from 
          <P::tfqnames>. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            Equivalent to <Q::DOMMain:any>. 
    @@Param:
      @@@Name: defaultForURI
      @@@Type: ForURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          A <QUOTE::for> URI reference used if it is missing from 
          <P::tfqnames>. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            Equivalent to <QUOTE::for all>, i.e. <Q::ManakaiDOM:all>. 
    @@Return:
      @@@Type:ResourceURI
      @@@nullCase:
        @@@@enDesc:
          No value. 
      @@@UndeclaredPrefixException:
      @@@PerlDef:
        my $v = $self-><M::swcfg21:SWCFGNode::swcfg21:ForLatest.value>;
        if (defined $v and not ref $v eq 'ARRAY') {
          __DEEP{
            $r = $self-><M::ManakaiDISElement.tfqnamesToURI>
                                  ($v, $defaultTypeURI, $defaultForURI);
          }__;
        } else {
          $r = null;
        }

  @Method:
    @@Name: elementTypeMatch
    @@enDesc:
      Returns whether the element type of this element matches 
      with another element type (either the same element type or
      this type is a subtype of another type). 
    @@Param:
      @@@Name: etype
      @@@Type: ResourceURI
      @@@enDesc:
        An element type name URI reference to test. 
    @@Return:
      @@@Type:
        DOMMain:boolean::ManakaiDOM:all
      @@@TrueCase:
        @@@@enDesc:
          Either the element type expanded URI reference of this element is 
          same as <P::etype> or it is a sub-element type of <P::etype>. 
      @@@FalseCase:
        @@@@enDesc:
          This element is not of <P::etype>. 
      @@@NoDBException:
      @@@PerlDef:
        __DEEP{
          my $et = $self-><AG::swcfg21:SWCFGElement::swcfg21:ForLatest
                                                          .expandedURI>;
          my $rdef = $self-><AG::ManakaiDISNode.ownerDISDocument>
                                   -><AG::ManakaiDISDocument.disDatabase>
                                   -><M::ManakaiDISDatabase.getResource> ($et);
          $r = $rdef-><M::ManakaiDISResourceDefinition.isSubsetOfURI> ($etype);
        }__;

  @Attr:
    @@Name: isResourceElement
    @@enDesc:
      Whether this element defines a resource or not. 
      \
      {NOTE:: An element defines a resource if its element type is 
              <Q::dis:ResourceDef> or its subtype.
      \
      }
    @@Get:
      @@@Type:
        DOMMain:boolean::ManakaiDOM:all
      @@@TrueCase:
        @@@@enDesc:
          This element defines a resource. 
      @@@FalseCase:
        @@@@enDesc:
          This element does not define any resource.
      @@@NoDBException:
      @@@PerlDef:
        __DEEP{
          $r = $self-><M::ManakaiDISElement.elementTypeMatch>
                                                (<Q::dis:ResourceDef>);
        }__;

  @Attr:
    @@Name: isPropertyElement
    @@enDesc:
      Whether this element is a property or not. 
      \
      {NOTE:: An element is a property if its element type is
              <Q::rdf:type> or if its element type's <Q::rdf:type> 
              property is <Q::rdf:Property> or is <Q::dis:subsetOf> 
              <Q::rdf:Property>. 
      \
      }
    @@Get:
      @@@Type:
        DOMMain:boolean::ManakaiDOM:all
      @@@TrueCase:
        @@@@enDesc:
          This element is a property.
      @@@FalseCase:
        @@@@enDesc:
          This element is not a property. 
      @@@NoDBException:
      @@@PerlDef:
        __DEEP{
          my $xn = $self-><AG::swcfg21:SWCFGElement::swcfg21:ForLatest
                                                            .expandedURI>;
          if ($xn eq <Q::rdf:type>) {
            $r = true;
          } else {
            my $rdef = $self-><AG::ManakaiDISNode.ownerDISDocument>
                                   -><AG::ManakaiDISDocument.disDatabase>
                                   -><M::ManakaiDISDatabase.getResource> ($xn);
            $r = $rdef-><M::ManakaiDISResourceDefinition.isTypeURI>
                                                           (<Q::rdf:Resource>);
          }
        }__;

  @Attr:
    @@Name: plImplementation
    @@enDesc:
      The <Class::PerlCode:ManakaiPerlCodeImplementation::ManakaiDOM:Perl>
      object.
    @@Type:
      PerlCode:ManakaiPerlCodeImplementation::ManakaiDOM:Perl
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          There is no implementation that supports the feature
          <Feature::Util:PerlCode> version <FeatureVer:1.0>.
      @@@PerlDef:
            $r = ($self-><AG::SWCFGNode.ownerDocument> or
                        $self)-><AG::SWCFGDoc.implementation>
                           -><M::DOMMinImpl.getFeature>
                                   (<Q::Util:PerlCode> => '1.0');

  @Method:
    @@Name: plValueCodeFragment
    @@enDesc:
      A Perl code fragment for value attribute.
    @@Param:
      @@@Name: attrURI
      @@@Type: AnyURI
      @@@enDesc:
        The URI reference name of an attribute.
      @@@nullCase:
        @@@@enDesc:
          This node itself is used.
    @@Param:
      @@@Name: disResource
      @@@Type: ManakaiDISResourceDefinition
      @@@enDesc:
        The <QUOTE::dis> resource object against which a value is evaluated.
    @@ForParam:
    @@ForpParam:
    @@NamedParam:
      @@@Name:dataTypeURI
      @@@Type:
        ResourceURI
      @@@enDesc:
        The URI reference of a data type.  It is used to convert
        untyped value and to define default value if <P::useDefaultValue>
        is set to <DOM::true>.
      @@@nullCase:
        @@@@enDesc: 
          No data type.  If the value is untyped, it is treated 
          as if <Q::DISCore:String>.
    @@NamedParam:
      @@@Name:useDefaultValue
      @@@Type:
        DOMMain:boolean::ManakaiDOM:all
      @@@enDesc:
        Whether some default value should be provided if possible or not.
    @@Type:
      MPLCodeFragment
    @@Return:
      @@@enDesc:
        Perl code fragment object for value attribute.
      @@@nullCase:
        @@@@enDesc:
          There is no <P::attrURI> attribute.
      @@@UndeclaredPrefixException:
      @@@RaiseException:
        @@@@@:NO_PERL_CODE_IMPL_ERR
        @@@@enDesc:
          There is no implementation that implements
          the <Feature::Util:PerlCode> feature, version <FeatureVer::1.0>.
      @@@PerlDef:
        __DEEP{
          my $dataType;
          my $vnode = defined $attrURI
                      ? $self-><M::ManakaiDISElement.disGetAttribute>
                                           ($attrURI,
                                            for_arg => $forArg,
                                            forp_arg => $forpArg)
                      : $self;
          my $plimpl = $self-><AG::ManakaiDISElement.plImplementation>;
          if ($vnode) {
            unless ($plimpl) {
              __UNDEEP{__EXCEPTION{NO_PERL_CODE_IMPL_ERR}__}__;
            }
            my $isnull = $vnode-><M::ManakaiDISElement.disGetAttribute>
                                           (<Q::dis:is-null>,
                                            for_arg => $forArg,
                                            forp_arg => $forpArg);
            if ($isnull and $isnull-><M::SWCFGNode.value>) {
              $r = $plimpl-><M::MPLImpl.createPerlAtom> ('null');
            } else {
              my $vnode_type_uri = $vnode-><M::ManakaiDISElement.mediaTypeURI>;
              my $vnode_value = $vnode-><M::SWCFGNode.value>;
              if ($vnode_type_uri) {
                my $vnode_type = $disResource->{db}
                                     -><M::ManakaiDISDatabase.getResource>
                                                      ($vnode_type_uri);
                if ($vnode_type-><M::ManakaiDISResourceDefinition.isSubsetOfURI>
                                        (<Q::dis:Boolean>)) {
                  $r = $plimpl-><M::MPLImpl.createPerlAtom>
                                        ($vnode_value ? true : false);
                } elsif ($vnode_type-><M::ManakaiDISResourceDefinition
                                             .isSubsetOfURI>
                                        (<Q::dis:TypeQName>)) {
                  $r = $plimpl-><M::MPLImpl.createPerlStringLiteral>
                                    ($vnode-><M::ManakaiDISElement
                                               .qnameToURI> ($vnode_value,
                                                             node => $vnode));
                } elsif ($vnode_type-><M::ManakaiDISResourceDefinition
                                .isSubsetOfURI> (<Q::lang:Perl>)) {
                  $r = $disResource-><M::ManakaiDISResourceDefinition
                             .plPreprocessPerlStatement>
                                           ($vnode_value,
                                            node => $self,
                                            contains_statements => false);
                } else { ## DISCore:String or some
                  $r = $plimpl-><M::MPLImpl.createPerlStringLiteral>
                                                       ($vnode_value);
                }
              } elsif ($dataTypeURI) {
                $dataType ||= $disResource->{db}
                                          -><M::ManakaiDISDatabase.getResource>
                                              ($dataTypeURI);
                if ($dataType-><M::ManakaiDISResourceDefinition.isSubsetOfURI>
                                              (<Q::DISIDL:AnyRealNumber>)) {
                  $r = $plimpl-><M::MPLImpl.createPerlAtom> (0 + $vnode_value);
                } else { ## DOMMain:DOMString or some
                  $r = $plimpl-><M::MPLImpl.createPerlStringLiteral>
                                                       ($vnode_value);
                }
              } else {  ## Untyped
                $r = $plimpl-><M::MPLImpl.createPerlStringLiteral>($vnode_value);
              }
            }
          } # has value

          if (not $r and $useDefaultValue) {
            $dataType ||= $disResource->{db}-><M::ManakaiDISDatabase.getResource>
                                              ($dataTypeURI);
            if ($dataType-><M::ManakaiDISResourceDefinition.isSubsetOfURI>
                                              (<Q::DISLang:String>)) {
              $r = $plimpl-><M::MPLImpl.createPerlStringLiteral> ('');
            } elsif ($dataType-><M::ManakaiDISResourceDefinition.isSubsetOfURI>
                                              (<Q::DOMMain:boolean>) or
                     $dataType-><M::ManakaiDISResourceDefinition.isSubsetOfURI>
                                              (<Q::DISIDL:AnyRealNumber>)) {
              $r = $plimpl-><M::MPLImpl.createPerlAtom> ('0');
            } elsif ($dataType-><M::ManakaiDISResourceDefinition.isSubsetOfURI>
                                              (<Q::Perl:ARRAY>)) {
              $r = $plimpl-><M::MPLImpl.createPerlAtom> ('[]');
            } elsif ($dataType-><M::ManakaiDISResourceDefinition.isSubsetOfURI>
                                              (<Q::Perl:hash>)) {
              $r = $plimpl-><M::MPLImpl.createPerlAtom> ('{}');
            }
          }
        }__;

  @Method:
    @@Name:plCodeFragment
    @@enDesc:
      Converts <Q::lang:dis> into Perl code.
    @@Param:
      @@@Name:disResource
      @@@Type:ManakaiDISResourceDefinition
      @@@enDesc:
        A <QUOTE::dis> resource with which code is evaluated.
    @@ForParam:
    @@ForpParam:
    @@NamedParam:
      @@@Name:containsStatements
      @@@Type:
        DOMMain:boolean::ManakaiDOM:all
      @@@enDesc:
        Whether the code is block-level or inline-level.
    @@Return:
      @@@Type: MPLCodeFragment
      @@@enDesc:
        Perl code converted from this node.
      @@@disPerlException:
      @@@PerlDef:
        __DEEP{
          my $plimpl = $self-><AG::ManakaiDISElement.plImplementation>;
          my $et = $self-><AG::swcfg21:SWCFGElement::swcfg21:ForLatest
                              .expandedURI>;
          if ($et eq <Q::dis:Def>) {
            my $value = $self-><M::SWCFGNode.value>;
            if (defined $value) {
              __UNDEEP{__EXCEPTION{DISPERL_NO_VALUE_ALLOWED_ERR::
                DIS:sourceNode => {$self},
                DIS:elementType => {$et},
              }__}__;
            }
            $r = $plimpl-><M::MPLImpl.createPerlBlockContainer>;
            for my $c (@{$self-><M::ManakaiDISElement.disChildElements>
                                  (for_arg => $forArg, forp_arg => $forpArg)}) {
              my $ccode = $c-><M::ManakaiDISElement.plCodeFragment>
                                  ($disResource,
                                   for_arg => $forArg, forp_arg => $forpArg);
              $r-><M::PLBlockCon.appendCodeFragment> ($ccode) if $ccode;
            }
          } elsif ({
            <Q::DISLang:constValue> => true,
            <Q::DISPerl:cloneCode> => true,
          }->{$et}) {
            my ($qname, $const_name, $on) = split /\s*\.\s*/,
                                             $self-><M::SWCFGNode.value>, 3;
            my $uri = $self-><M::ManakaiDISElement.tfqnamesToURI>
                                      ($qname,
                                       $disResource->
                                         <AG::ManakaiDISResourceDefinition.uri>,
                                       $forArg, node => $self);
            my $const;
            if (defined $const_name) {
              my $owner = $disResource->{db}-><M::ManakaiDISDatabase.getResource>
                                      ($uri);
              $owner-><AS::ManakaiDISResourceDefinition.isReferred> ($self);
              if ($et eq <Q::DISLang:constValue>) {
                $const = $owner-><M::ManakaiDISResourceDefinition
                                         .getConstResourceByName> ($const_name);
                unless (defined $const) {
                  __UNDEEP{__EXCEPTION{RESOURCE_NOT_DEFINED_ERR::
                    DIS:localName => {$const_name},
                    DIS:sourceNode => {$self},
                    DIS:elementType => {$et},
                    DIS:expectedType => {<Q::ManakaiDOM:Const>},
                  }__}__;
                }
              } else {
                $const = $owner-><M::ManakaiDISResourceDefinition
                                         .getChildResourceByNameAndType>
                                          ($const_name, <Q::DISLang:AnyMethod>);
                unless (defined $const) {
                  __UNDEEP{__EXCEPTION{RESOURCE_NOT_DEFINED_ERR::
                    DIS:localName => {$const_name},
                    DIS:sourceNode => {$self},
                    DIS:elementType => {$et},
                    DIS:expectedType => {<Q::DISLang:AnyMethod>},
                  }__}__;
                }
              }
            } else {
              $const = $disResource->{db}-><M::ManakaiDISDatabase.getResource>
                                      ($uri);
            }
            if ($const-><M::ManakaiDISResourceDefinition.isTypeURI>
                                      (<Q::ManakaiDOM:Const>)) {
              $const-><AS::ManakaiDISResourceDefinition.isReferred> ($self);

              my $data_type = $const-><AG::ManakaiDISResourceDefinition
                                       .disActualDataTypeResource>;
              my $val = $const->{src}-><M::ManakaiDISElement
                                            .plValueCodeFragment>
                            (<Q::dis:Value>, $disResource,
                             for_arg => $forArg,
                             forp_arg => $forpArg,
                             data_type_uri => $data_type
                                    -><AG::ManakaiDISResourceDefinition.uri>);
              unless (defined $val) {
                __UNDEEP{__EXCEPTION{NO_CONST_VALUE_ERR::
                  DIS:uri => {$const->{uri}},
                  DIS:localName => {$const->{localName}},
                  DIS:sourceNode => {$const->{src}},
                  DIS:elementType => {$et},
                }__}__;
              }
            
              if ($containsStatements) {
                $r = $plimpl-><M::MPLImpl.createPerlStatement>;
                my $rvar = $plimpl-><M::MPLImpl.createPerlVariable>
                                                 ('$', null, 'r');
                $r-><M::PLAnyCon.appendNewAssignment> ($rvar => $val);
              } else {
                $r = $val;
              }
            } elsif ($const-><M::ManakaiDISResourceDefinition.isTypeURI>
                                 (<Q::DISLang:AnyMethod>)) {
              my $ret = $const-><M::ManakaiDISResourceDefinition
                                  .getChildResourceByType>
                                 ($const-><M::ManakaiDISResourceDefinition
                                        .isTypeURI> (<Q::DISLang:Method>)
                                  ? <Q::DISLang:MethodReturn>
                                  : ($on and $on eq 'set')
                                    ? <Q::DISLang:AttributeSet>
                                    : <Q::DISLang:AttributeGet>);
              unless ($ret) { 
                __UNDEEP{
                  if ($const-><M::ManakaiDISResourceDefinition
                                        .isTypeURI> (<Q::DISLang:Method>)) {
                    __EXCEPTION{NO_METHOD_RETURN_ERR::
                      DIS:errResource => {$const},
                      DIS:sourceNode => {$const->{src}},
                      DIS:elementType => {$et},
                      DIS:uri => {$const->{uri}},
                      DIS:localName => {$const->{localName}},
                    }__;
                  } elsif ($on and $on eq 'set') {
                    __EXCEPTION{NO_ATTR_SET_ERR::
                      DIS:errResource => {$const},
                      DIS:sourceNode => {$const->{src}},
                      DIS:elementType => {$et},
                    }__;
                  } else {
                    __EXCEPTION{NO_ATTR_GET_ERR::
                      DIS:errResource => {$const},
                      DIS:sourceNode => {$const->{src}},
                      DIS:elementType => {$et},
                    }__;
                  }
                }__; # UNDEEP
              }
              $r = $ret-><AG::ManakaiDISResourceDefinition.plCodeFragment>;
            } else {
              if ($et eq <Q::DISLang:constValue>) {
                __UNDEEP{__EXCEPTION{RESOURCE_NOT_DEFINED_ERR::
                  DIS:uri => {$const->{uri}},
                  DIS:localName => {$const->{localName}},
                  DIS:sourceNode => {$self->{src}},
                  DIS:expectedType => {<Q::ManakaiDOM:Const>},
                }__}__;
              } else {  # DISPerl:cloneCode
                __UNDEEP{__EXCEPTION{RESOURCE_NOT_DEFINED_ERR::
                  DIS:uri => {$const->{uri}},
                  DIS:localName => {$const->{localName}},
                  DIS:sourceNode => {$self->{src}},
                  DIS:expectedType => {<Q::DISLang:AnyMethod>},
                }__}__;
              }
            }
          } elsif ($et eq <Q::DISLang:value>) {
            my $val = $self-><M::ManakaiDISElement
                                          .plValueCodeFragment>
                            (null, $disResource,
                             for_arg => $forArg,
                             forp_arg => $forpArg);
            $r = $plimpl-><M::MPLImpl.createPerlStatement>;
            my $rvar = $plimpl-><M::MPLImpl.createPerlVariable>
                                                 ('$', null, 'r');
            $r-><M::PLAnyCon.appendNewAssignment> ($rvar => $val);
          } elsif ({
            <Q::dis:GetProp> => true,
            <Q::dis:GetPropNode> => true,
            <Q::swcfg21:GetPropNode> => true,
          }->{$et}) {
            my $prop_uri = $self-><AG::ManakaiDISElement.qnameValueURI>;
            $disResource->{db}
                     -><M::ManakaiDISDatabase.getResource> ($prop_uri)
                     -><AS::ManakaiDISResourceDefinition.isReferred> ($self);
            $r = $plimpl-><M::MPLImpl.createPerlStatement>;
            my $val = $plimpl-><M::MPLImpl.createPerlInlineContainer>;
            $val-><M::PLInCon.appendCode> ('$self->{node}->{');
            $val-><M::PLAnyCon.appendStringLiteral> ($prop_uri);
            $val-><M::PLInCon.appendCode> ('}');
            my $rvar = $plimpl-><M::MPLImpl.createPerlVariable>
                                               ('$', null, 'r');
            $r-><M::PLAnyCon.appendNewAssignment> ($rvar => $val);
            
            if ({<Q::dis:GetPropNode> => true,
                 <Q::swcfg21:GetPropNode> => true}->{$et}) {
              my $q = $plimpl-><M::MPLImpl.createPerlBlockContainer>;
              $q-><M::PLBlockCon.appendCodeFragment> ($r);
              $q-><M::PLBlockCon.appendNewIf>
                       ($plimpl-><M::MPLImpl.createPerlInlineUnparsedCode>
                                                     ('defined $r'),
                        my $qt = $plimpl-><M::MPLImpl.createPerlBlockContainer>);
              $qt-><M::PLBlockCon.appendStatement>
                 -><M::PLAnyCon.appendNewAssignment>
                       ($rvar->clone => my $qtr = $plimpl-><M::MPLImpl
                                                    .createPerlInlineContainer>);
              my $cls = $disResource->{db}-><M::ManakaiDISDatabase
                           .getResource> ({
                             <Q::dis:GetPropNode> => <Q::DOMCore:ManakaiDOMNode>,
                             <Q::swcfg21:GetPropNode> =>
                                                   <Q::swcfg21:ManakaiSWCFGNode>,
                           }->{$et}, for_arg => $forArg);
              $cls-><AS::ManakaiDISResourceDefinition.isReferred> ($self);
              $qtr-><M::PLInCon.appendCode>
                       ($cls-><AG::ManakaiDISResourceDefinition
                         .plFullyQualifiedName> . q[->_get_node_reference ($r)]);
              $r = $q;
            }
          } elsif ($et eq <Q::dis:SetProp>) {
            my $prop_uri = $self-><AG::ManakaiDISElement.qnameValueURI>;
            $disResource->{db}
                     -><M::ManakaiDISDatabase.getResource> ($prop_uri)
                     -><AS::ManakaiDISResourceDefinition.isReferred> ($self);
            $r = $plimpl-><M::MPLImpl.createPerlStatement>;
            my $val = $plimpl-><M::MPLImpl.createPerlInlineContainer>;
            $val-><M::PLInCon.appendCode> ('$self->{node}->{');
            $val-><M::PLAnyCon.appendStringLiteral> ($prop_uri);
            $val-><M::PLInCon.appendCode> ('}');
            my $rvar = $plimpl-><M::MPLImpl.createPerlVariable>
                                               ('$', null, 'given');
            $r-><M::PLAnyCon.appendNewAssignment> ($val => $rvar);
            my $chk = $self-><M::ManakaiDISElement.disGetAttribute>
                                           (<Q::dis:CheckReadOnly>);
            if ($chk and $chk-><M::SWCFGNode.value>) {
              my $q = $plimpl-><M::MPLImpl.createPerlIf>;
                       (my $qc = $plimpl-><M::MPLImpl.createPerlInlineContainer>,
                        my $qt = $plimpl-><M::MPLImpl.createPerlBlockContainer>);
              $qc-><M::PLInCon.appendCode> ('$self->{node}->{');
              $qc-><M::PLAnyCon.appendStringLiteral> (<Q::DOMCore:read-only>);
              $qc-><M::PLInCon.appendCode> ('}');

              my $for_uri = $disResource-><M::ManakaiDISDatabase.getFor>
                               ($forArg)-><M::ManakaiDISForDefinition.isaURI>
                               (<Q::ManakaiDOM:ManakaiDOM1>)
                            ? $forArg : <Q::ManakaiDOM:ManakaiDOMLatest>;
              my $cls = $self->{db}-><M::ManakaiDISDatabase.getResource>
                                                (<Q::DOMCore:DOMException>,
                                                       for_arg => $for_uri);
              my $const = $self->{db}-><M::ManakaiDISDatabase.getResource>
                                 (<Q::DOMCore:NO_MODIFICATION_ALLOWED_ERR>,
                                                       for_arg => $for_uri);
              my $subtype = $self->{db}-><M::ManakaiDISDatabase.getResource>
                                                    (<Q::MDOMX:NOMOD_THIS>,
                                                       for_arg => $for_uri);
              $_-><AS::ManakaiDISResourceDefinition.isReferred>
                               ($self) for $cls, $const, $subtype;
              my $context_param = $disResource-><M::ManakaiDISResourceDefinition
                                        .plGetContextParameter>;
              $disResource-><M::ManakaiDISResourceDefinition
                            .plAppendThrow>
                               ($qt, $cls, $const, $subtype,
                                {%$context_param});
              $r = $q;
            } # Read-only checking
          } elsif ($et eq <Q::DOMMain:raiseException>) {
            my ($cls, $const, $subtype)
                = @{$disResource->{db}-><M::ManakaiDISDatabase.xcrefToResource>
                                         ($self-><M::SWCFGNode.value>,
                                          $self,
                                          node => $self,
                                          for_arg => $forArg)};
            my $context_param = $disResource-><M::ManakaiDISResourceDefinition
                                        .plGetContextParameter>;
            $disResource-><M::ManakaiDISResourceDefinition
                            .plAppendThrow>
                            ($r = $plimpl-><M::MPLImpl.createPerlBlockContainer>,
                             $cls, $const, $subtype,
                             {%$context_param});
          } elsif ({
            <Q::dis:ContentType> => true,
            <Q::dis:For> => true, <Q::dis:ForCheck> => true,
            <Q::dis:ImplNote> => true,
            <Q::DISLang:nop> => true,
          }->{$et}) {
            #
          } else {
            __UNDEEP{__EXCEPTION{UNSUPPORTED_ELEMENT_TYPE_ERR::
              DIS:sourceNode => {$self},
              DIS:elementType => {$et},
            }__}__;
          }
        }__; # DEEP
##DISElement

ElementTypeBinding:
  @Name: disPerlException
  @ElementType:
    ManakaiDOM:raises
  @ShadowContent:
    @@@: DISPERL_NO_VALUE_ALLOWED_ERR
    @@Description:
      @@@lang:en
      @@@@:
        An element value is specified where it is not allowed.
  @ShadowSibling:
    @@ManakaiDOM:raises:
      @@@@: RESOURCE_NOT_DEFINED_ERR
      @@@Description:
        @@@@lang:en
        @@@@@:
          An undefined resource is referred or a referred resource
          is defined but have different type than the one expected.
    @@ManakaiDOM:raises:
      @@@@: NO_CONST_VALUE_ERR
      @@@Description:
        @@@@lang:en
        @@@@@:
          A constant value definition does not have its <Q::dis:Value>
          attribute.
    @@ManakaiDOM:raises:
      @@@@: NO_METHOD_RETURN_ERR
      @@@Description:
        @@@@lang:en
        @@@@@:
          A method definition does not have a <Q::DISLang:MethodReturn>
          child resource.
    @@ManakaiDOM:raises:
      @@@@: NO_ATTR_GET_ERR
      @@@Description:
        @@@@lang:en
        @@@@@:
          An attribute definition does not have a <Q::DISLang:AttributeGet>
          child resource.
    @@ManakaiDOM:raises:
      @@@@: NO_ATTR_SET_ERR
      @@@Description:
        @@@@lang:en
        @@@@@:
          An attribute setter is referred but the attribute definition
          does not have <Q::DISLang:AttributeSet> child resource.
    @@ManakaiDOM:raises:
      @@@@: UNSUPPORTED_ELEMENT_TYPE_ERR
      @@@Description:
        @@@@lang:en
        @@@@@:
          An unsupported type of element has appeared.


ClsDef:
  @ClsQName: ManakaiDISModuleElement
  @ClsISA: ManakaiDISElement
  @enDesc:
    The <Q::dis:Module> elements. 

  @Attr:
    @@Name: requireElement
    @@enDesc:
      The <Q::dis:Require> child element.  The element is 
      newly created if not exist. 
    @@Type: ManakaiDISElement
    @@Get:
      @@@PerlDef:
        __DEEP{
          $r = $self-><M::swcfg21:SWCFGNode
                        ::swcfg21:ForLatest.getAttributeNS>
                                   (<Q::dis:>, 'Require', make_new_node => true);
        }__;

  @Attr:
    @@Name: defaultForURI
    @@enDesc:
      The value of <Q::dis:DefaultFor> attribute. 
    @@Type: ForURI
    @@Get:
      @@@enDesc:
        The value of <Q::dis:DefaultFor> child element.  If missing, 
        <Q::ManakaiDOM:all> is returned. 
      @@@PerlDef:
        __DEEP{
          my $df = $self-><M::swcfg21:SWCFGNode::swcfg21:ForLatest
                                .getAttributeNS>
                                         (<Q::dis:>, 'DefaultFor');
          if ($df) {
            $r = $df-><AG::ManakaiDISElement.qnameValueURI>
              || <Q::ManakaiDOM:all>;
          } else {
            $r = <Q::ManakaiDOM:all>;
          }
        }__;
    @@Set:
      @@@PerlDef:
        __DEEP{
          $self-><M::swcfg21:SWCFGNode::swcfg21:ForLatest.setAttributeNS>
                                     (<Q::dis:>, 'DefaultFor' => $given);
        }__;

  @Attr:
    @@Name: definingNamespaceURI
    @@enDesc:
      The value of <Q::dis:NamespaceURI> attribute, i.e. 
      the URI reference of the namespace that this module primary 
      defines.
      \
      {NOTE:: Defining namespace URI is <QUOTE::for> independent. 
      \
      }
    @@Type: AnyURI
    @@Get:
      @@@PerlDef:
        __DEEP{
          my $df = $self-><M::swcfg21:SWCFGNode::swcfg21:ForLatest
                                .getAttributeNS>
                                         (<Q::dis:>, 'Namespace');
          if ($df) {
            $r = $df-><M::swcfg21:SWCFGNode::swcfg21:ForLatest.value>;
          } else {
            __ASSERT{DISPerl:invariant::
              msg => {qq["dis:Namespace" attribute not found]},
            }__;
          }
        }__;
    @@Set:
      @@@PerlDef:
        __DEEP{
          $self-><M::swcfg21:SWCFGNode::swcfg21:ForLatest.setAttributeNS>
                                     (<Q::dis:>, 'Namespace' => $given);
        }__;
##DISModuleElement

ClsDef:
  @ClsQName: ManakaiDISElementList
  @enDesc:
    @@lang:en
    @@@:
      Lists of elements. 
      \
      {NOTE:: <Class::ManakaiDISElementList> is <QUOTE::dead>; 
              later changes to the tree does not affect this type of objects. 
      \
      }
##DISElementList

ClsDef:
  @ClsQName: ManakaiDISComment
  @ClsISA: ManakaiDISNode
  @ClsISA:
    swcfg21:ManakaiSWCFGComment::swcfg21:ForLatest
  @Description:
    @@lang:en
    @@@:
      <QUOTE::dis> comment node objects. 
##DISComment

ClsDef:
  @ClsQName: ManakaiDISDocumentFragment
  @ClsISA: ManakaiDISNode
  @ClsISA:
    swcfg21:ManakaiSWCFGDocumentFragment::swcfg21:ForLatest
  @Description:
    @@lang:en
    @@@:
      <QUOTE::dis> document fragment node objects. 
##DISDocumentFragment

ClsDef:
  @ClsQName: ManakaiDISDocument
  @ClsISA: ManakaiDISNode
  @ClsISA:
    swcfg21:ManakaiSWCFGDocument::swcfg21:ForLatest
  @Description:
    @@lang:en
    @@@:
      <QUOTE::dis> document node objects. 

  @Attr:
    @@Name: moduleElement
    @@enDesc:
      The <Q::dis:Module> element in this document.  The element is 
      newly created if not exist. 
    @@Type: ManakaiDISModuleElement
    @@Get:
      @@@PerlDef:
        __DEEP{
          $r = $self-><M::swcfg21:SWCFGNode
                        ::swcfg21:ForLatest.getAttributeNS>
                                   (<Q::dis:>, 'Module', make_new_node => true);
        }__;
        $r = bless $r, <ClassName::ManakaiDISModuleElement>;

  @Attr:
    @@Name: disDatabase
    @@enDesc:
      Associated <QUOTE::dis> database. 

    @@Type: ManakaiDISDatabase
    @@Get:
      @@@NoDBException:
      @@@PerlDef:
        if ($self->{<Q::TreeCore:node>}->{<Q::db>}) {
          $r = $self->{<Q::TreeCore:node>}->{<Q::db>};
        } else {
          __EXCEPTION{NO_ASSOCIATED_DB_ERR}__;
        }
    @@Set:
      @@@PerlDef:
        $self->{<Q::TreeCore:node>}->{<Q::db>} = $given;
        require Scalar::Util;
        Scalar::Util::weaken ($self->{<Q::TreeCore:node>}->{<Q::db>});

  @Method:
    @@Name: disChildElements
    @@enDesc:
      A list of child elements, with <QUOTE::for> checks.  
    @@ForParam:
    @@ForpParam:
    @@Return:
      @@@Type: ManakaiDISElementList
      @@@enDesc:
        The current snapshot of child nodes. 
      @@@PerlDef:
        $r = bless [], <ClassName::ManakaiDISElementList>;    
        __DEEP{
          for my $cn (@{$self-><AG::swcfg21:SWCFGNode::swcfg21:ForLatest
                                                       .childNodes>}) {
            next unless $cn-><AG::swcfg21:SWCFGNode::swcfg21:ForLatest
                                              .nodeType> eq '#element';
            my $dn = $cn->{<Q::TreeCore:node>}
                        -><M::ManakaiDOM:ManakaiDOMNodeObject
                            ::ManakaiDOM:Perl.newReference>
                                      (<ClassName::ManakaiDISElement>);
            next unless $dn-><M::ManakaiDISElement.forMatch> ($forArg, $forpArg);
            push @$r, $dn;
          }
        }__;

  @Method:
    @@Name: disAllChildElements
    @@enDesc:
      A list of child elements, without <QUOTE::for> checks.  
    @@Return:
      @@@Type: ManakaiDISElementList
      @@@enDesc:
        The current snapshot of child nodes. 
      @@@PerlDef:
        $r = bless [], <ClassName::ManakaiDISElementList>;    
        __DEEP{
          for my $cn (@{$self-><AG::swcfg21:SWCFGNode::swcfg21:ForLatest
                                                       .childNodes>}) {
            next unless $cn-><AG::swcfg21:SWCFGNode::swcfg21:ForLatest
                                              .nodeType> eq '#element';
            my $dn = $cn->{<Q::TreeCore:node>}
                        -><M::ManakaiDOM:ManakaiDOMNodeObject
                            ::ManakaiDOM:Perl.newReference>
                                      (<ClassName::ManakaiDISElement>);
            push @$r, $dn;
          }
        }__;
##DISDocument

PropDef:
  @QName: db
  @enDesc:
    Associated <QUOTE::dis> database. 
  @rdfs:domain: ManakaiDISDocument
  @rdfs:range: ManakaiDISDatabase

## -- Definition object database

ClsDef:
  @ClsQName: ManakaiDISDatabase
  @enDesc:
    Resource database created from <QUOTE::dis> source data. 
  @ClsISA: ManakaiDISExceptionTarget

  @Method:
    @@Name: getModule
    @@Description:
      @@@lang:en
      @@@@:
        Returns a <QUOTE::dis> module definition. 
    @@Param:
      @@@Name: moduleURI
      @@@Type: ModuleURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          A <QUOTE::dis> module URI reference. 
    @@ForParam:
    @@Return:
      @@@Type: ManakaiDISModuleDefinition
      @@@Description:
        @@@@lang:en
        @@@@@:
          The module definition. 
      @@@PerlDef:
        my $modURI;
        if (defined $forArg) {
          __CODE{tfurisToURI:: $turi => $moduleURI, $furi => $forArg,
                               $uri => $modURI}__;
        } else {
          $modURI = $moduleURI;
        }
        if (defined $self->{modDef}->{$modURI}) {
          $r = $self->{modDef}->{$modURI};
        } else {
          $r = $self->{modDef}->{$modURI}
             = bless {
                 uri => $modURI,
                 db => $self,
                 for => <Q::ManakaiDOM:all>,
                 forp => [],
               }, <ClassName::ManakaiDISModuleDefinition>;
          require Scalar::Util;
          Scalar::Util::weaken ($r->{db});
        }

  @Method:
    @@Name: getFor
    @@Description:
      @@@lang:en
      @@@@:
        Returns a <QUOTE::for> definition object. 
    @@Param:
      @@@Name: forURI
      @@@Type: ForURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          A <QUOTE::for> URI reference. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            Defaulted to <Q::ManakaiDOM:all>. 
    @@Return:
      @@@Type: ManakaiDISForDefinition
      @@@PerlDef:
        $forURI = <Q::ManakaiDOM:all> unless defined $forURI;
        if (defined $self->{forDef}->{$forURI}) {
          $r = $self->{forDef}->{$forURI};
        } else {
          $r = $self->{forDef}->{$forURI}
             = bless {
                 uri => $forURI,
                 isa => {<Q::ManakaiDOM:all> => true},
                 revISA => {},
                 db => $self,
               }, <ClassName::ManakaiDISForDefinition>;
          $self->{forDef}->{<Q::ManakaiDOM:all>}->{revISA}->{$forURI} = true;
          require Scalar::Util;
          Scalar::Util::weaken ($r->{db});
        }

  @Method:
    @@Name: getResource
    @@Description:
      @@@lang:en
      @@@@:
        Returns a <QUOTE::dis> resource definition. 
    @@Param:
      @@@Name: resourceURI
      @@@Type: ResourceURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          A <QUOTE::dis> resource URI reference. 
      @@@nullCase:
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            Defaulted to <Q::DOMMain:any>. 
    @@ForParam:
    @@Return:
      @@@Type: ManakaiDISResourceDefinition
      @@@Description:
        @@@@lang:en
        @@@@@:
          The resource definition. 
      @@@PerlDef:
        $resourceURI = <Q::DOMMain:any> unless defined $resourceURI;
        my $resURI;
        if (defined $forArg) {
          __CODE{tfurisToURI:: $turi => $resourceURI, $furi => $forArg,
                               $uri => $resURI}__;
        } else {
          $resURI = $resourceURI;
        }
        if (defined $self->{resDef}->{$resURI}) {
          $r = $self->{resDef}->{$resURI};
        } else {
          $r = $self->{resDef}->{$resURI}
             = bless {
                 uri => $resURI,
                 aliasURI => {$resURI => true},
                 subOf => {},
                 supOf => {},
                 db => $self,
                 for => <Q::ManakaiDOM:all>,
                 forp => [],
                 seq => -1,
               }, <ClassName::ManakaiDISResourceDefinition>;
          require Scalar::Util;
          Scalar::Util::weaken ($r->{db});
        }

  @Method:
    @@Name: getSourceFile
    @@enDesc:
      Gets <QUOTE::dis> source document. 
    @@Param:
      @@@Name: fileName
      @@@Type: FileURI
      @@@enDesc:
        A URI reference identifying a file. 
    @@Return:
      @@@Type: ManakaiDISDocument
      @@@enDesc:
        The <QUOTE::dis> source document. 
      @@@nullCase:
        @@@@enDesc:
          No document associated with that <P::fileName>. 
      @@@PerlDef:
        $r = $self->{<Q::sourceFile>}->{$fileName};
  @Method:
    @@Name: setSourceFile
    @@enDesc:
      Puts <QUOTE::dis> source document object. 
    @@Param:
      @@@Name: fileName
      @@@Type: FileURI
      @@@enDesc:
        A URI reference identifying a file.  If there is already a 
        source document, then the association has been updated. 
    @@Param:
      @@@Name: doc
      @@@Type: ManakaiDISDocument
      @@@enDesc:
        The document object to set. 
    @@Return:
      @@@PerlDef:
        $self->{<Q::sourceFile>}->{$fileName} = $doc;

  @Method:
    @@Name: loadModule
    @@enDesc:
      Loads definitions from a <QUOTE::dis> document. 
    @@Param:
      @@@Name: doc
      @@@Type:ManakaiDISDocument
      @@@enDesc:
        The source <QUOTE::dis> document object.  Its 
        <A::ManakaiDISDocument.disDatabase> must be this database. 
    @@Param:
      @@@Name: resolver
      @@@Type: DISModuleResolver
      @@@enDesc:
        The resolver to convert module name into <QUOTE::dis> document object. 
    @@ForParam:
    @@Return:
      @@@RaiseException:
        @@@@@: NO_MODULE_QNAME_ERR
        @@@@enDesc:
          The <Q::dis:Module> element must have a <Q::dis:QName> attribute. 
      @@@RaiseException:
        @@@@@: UNABLE_TO_GET_MODULE_ERR
        @@@@enDesc:
          The implementation is unable to get a module source. 
      @@@ForDefDupException:
      @@@ForDefNoQNameException:
      @@@ResDefDupException:
      @@@ElementNotAllowedException:
      @@@RaiseException:
        @@@@@:NO_REQUIRED_ATTR_ERR
        @@@@enDesc:
          The <Q::dis:Module> element does not have 
          <Q::dis:Namespace> attribute. 
      @@@PerlDef:
        $resolver = bless $resolver, <ClassName::ManakaiDISModuleResolver>
                      if ref $resolver eq 'CODE'; 
        ## -- Module Name, URI
        $forArg = <Q::ManakaiDOM:all> unless defined $forArg;
        my $mod_node;
        my $mod_name_node;
        __DEEP{
          $mod_node = $doc-><AG::ManakaiDISDocument.moduleElement>;
          $mod_name_node = $mod_node-><M::swcfg21:SWCFGNode
                                        ::swcfg21:ForLatest.getAttributeNS>
                                                 (<Q::dis:>, 'QName');
          unless ($mod_name_node) {
            __UNDEEP{
              __EXCEPTION{NO_MODULE_QNAME_ERR::
                DIS:sourceNode => {$mod_node},
              }__;
            }__;
          }
          my $mod_name_uri = $mod_name_node
                                -><AG::ManakaiDISElement.qnameValueURI>;
          my $mod = $self-><M::ManakaiDISDatabase.getModule>
                                   ($mod_name_uri, for_arg => $forArg);
        
          unless ($mod-><AG::ManakaiDISModuleDefinition.isDefined>) {
            ## -- Initializes Module Definition Object
            $mod->{nameURI} = $mod_name_uri;
            $mod->{localName} = $mod_name_node-><AG::ManakaiDISElement
                                                       .qnameValueLocalName>;
            $mod->{namespaceURI} = $mod_name_node-><AG::ManakaiDISElement
                                                       .qnameValueNamespaceURI>;
            $mod->{for} = $forArg;
            $mod->{src} = $mod_node;
            $mod->{<Q::isDefined>} = true;
            $self-><M::ManakaiDISDatabase.setSourceFile>
                                        ($mod->{nameURI} => $doc);

            $mod->{<Q::DIS:sourceFile>}
              = $mod->{src}
                    -><AG::swcfg21:SWCFGNode::swcfg21:ForLatest.ownerDocument>
                    -><M::swcfg21:SWCFGNode::swcfg21:ForLatest.flag>
                                         (<Q::swcfg21:fileName>);
            
            ## -- Loads "for" definition
            my $root_elements
                       = $doc-><M::ManakaiDISDocument.disAllChildElements>;
            if ($mod->{for} eq <Q::ManakaiDOM:all>) {
              for my $el (@$root_elements) {
                next unless $el-><AG::swcfg21:SWCFGElement::swcfg21:ForLatest
                                          .expandedURI> eq <Q::dis:ForDef>;
                $self-><M::ManakaiDISDatabase.loadFor> ($mod, $el);
              }
            }

            ## -- Loads "for all"
            my $rmod = $self-><M::ManakaiDISDatabase.getModule>
                               ($mod->{nameURI}, for_arg => <Q::ManakaiDOM:all>);
            unless ($rmod-><AG::ManakaiDISModuleDefinition.isDefined>) {
              my $rdoc = $resolver-><M::ManakaiDISModuleResolver.uriToDocument>
                               ($self, $rmod->{uri}, $mod->{namespaceURI},
                                $mod->{localName}, <Q::ManakaiDOM:all>);
              unless ($rdoc) {
                __UNDEEP{
                  __EXCEPTION{UNABLE_TO_GET_MODULE_ERR::
                    DIS:uri => {$rmod->{uri}},
                    DIS:namespaceURI => {$mod->{namespaceURI}},
                    DIS:localName => {$mod->{localName}},
                    DIS:for => {<Q::ManakaiDOM:all>},
                    DIS:sourceNode => {$mod->{src}},
                  }__;
                }__;
              }
              $self-><M::ManakaiDISDatabase.loadModule>
                            ($rdoc, $resolver, for_arg => <Q::ManakaiDOM:all>);
            } # Unless "for all" loaded

            ## -- Loads Required Modules
            ##    NOTE:: "dis:For" is not allowed since "dis:ForDef" is not read
            my $req_node = $mod_node-><AG::ManakaiDISModuleElement
                                                          .requireElement>;
            for my $rm (@{$req_node-><M::ManakaiDISElement
                                                    .disAllChildElements>}) {
              next unless $rm-><AG::swcfg21:SWCFGElement::swcfg21:ForLatest
                                               .expandedURI> eq <Q::dis:Module>;
              my ($uri, $nuri, $ln, $for);
              my $mqn = $rm-><M::swcfg21:SWCFGNode::swcfg21:ForLatest
                                      .getAttributeNS> (<Q::dis:>, 'QName');
              if ($mqn) {
                my $mqv = $mqn-><M::swcfg21:SWCFGNode::swcfg21:ForLatest
                                                                   .value>;
                my $mqp = $mqn-><M::ManakaiDISElement.qnameToPair>
                                                       ($mqv, node => $mqn);
                ($nuri, $ln) = @$mqp;
              } else {
                my $mn = $rm-><M::swcfg21:SWCFGNode::swcfg21:ForLatest
                                      .getAttributeNS> (<Q::dis:>, 'Name');
                if ($mn) {
                  $nuri = $mod->{namespaceURI};
                  $ln = $mn-><M::swcfg21:SWCFGNode::swcfg21:ForLatest.value>;
                } else {
                  $nuri = $mod->{namespaceURI};
                  $ln = $mod->{localName};
                }
              }
              my $wfn = $rm-><M::swcfg21:SWCFGNode::swcfg21:ForLatest
                                      .getAttributeNS> (<Q::dis:>, 'WithFor');
              if ($wfn) {
                $for = $wfn-><AG::ManakaiDISElement.qnameValueURI>;
              } else {
                $for = $mod->{for};
              }
              my $rmod = $self-><M::ManakaiDISDatabase.getModule>
                                       ($nuri . $ln, for_arg => $for);
              unless ($rmod-><AG::ManakaiDISModuleDefinition.isDefined>) {
                my $rdoc = $resolver-><M::ManakaiDISModuleResolver.uriToDocument>
                                       ($self, $rmod->{uri}, $nuri, $ln, $for);
                unless ($rdoc) {
                  __UNDEEP{
                    __EXCEPTION{UNABLE_TO_GET_MODULE_ERR::
                      DIS:uri => {$rmod->{uri}},
                      DIS:namespaceURI => {$nuri},
                      DIS:localName => {$ln},
                      DIS:for => {$for},
                      DIS:sourceNode => {$rm},
                    }__;
                  }__;
                }
                $self-><M::ManakaiDISDatabase.loadModule>
                                       ($rdoc, $resolver, for_arg => $for);
              }
            } # Child Module elements
            
            ## -- Loads child resources
            $root_elements = $doc-><M::ManakaiDISDocument.disChildElements>
                                         (for_arg => $forArg);
            for my $el (@$root_elements) {
              if ($el-><AG::ManakaiDISElement.isResourceElement>) {
                $self-><M::ManakaiDISDatabase.loadResource>
                                         ($mod, null, null, $el,
                                          for_arg => $forArg);
              } else {
                my $et = $el-><AG::swcfg21:SWCFGElement::swcfg21:ForLatest
                                                               .expandedURI>;
                if ({
                         <Q::dis:ForDef> => 1,
                         <Q::dis:Module> => 1,
                         <Q::dis:ImplNote> => 1,
                    }->{$et}) {
                  # 
                } else {
                  __UNDEEP{
                    __EXCEPTION{ELEMENT_NOT_ALLOWED_ERR::
                      DIS:elementType => {$et},
                      DIS:sourceNode => {$el},
                      DIS:uri => {$mod->{uri}},
                    }__;
                  }__;
                }
              } # element types
            }
            
            my $dn = $mod_node-><M::swcfg21:SWCFGNode::swcfg21:ForLatest
                                .getAttributeNS>
                                         (<Q::dis:>, 'Namespace');
            unless ($dn and defined $dn-><M::swcfg21:SWCFGNode
                                           ::swcfg21:ForLatest.value>) {
              __UNDEEP{
                __EXCEPTION{NO_REQUIRED_ATTR_ERR::
                  DIS:elementType => {<Q::dis:Namespace>},
                  DIS:sourceNode => {$mod_node},
                }__;
              }__;
            }
          } # Unless this module loaded
        }__; # Deep

  @Method:
    @@Name: loadFor
    @@enDesc:
      Loads definition of a <QUOTE::for> from a <Q::dis:ForDef> element. 
    @@Param:
      @@@Name: mod
      @@@Type: ManakaiDISModuleDefinition
      @@@enDesc:
        The module in which the <QUOTE::for> to load is defined. 
    @@Param:
      @@@Name: el
      @@@Type:ManakaiDISElement
      @@@enDesc:
        The source <QUOTE::dis> <Q::dis:ForDef> element object. 
    @@Return:
      @@@ForDefDupException:
      @@@ForDefNoQNameException:
      @@@ElementNotAllowedException:
      @@@PerlDef:
        __DEEP{
          my $qn_node = $el-><M::swcfg21:SWCFGNode
                                        ::swcfg21:ForLatest.getAttributeNS>
                                                 (<Q::dis:>, 'QName');
          unless ($qn_node) {
            __UNDEEP{
              __EXCEPTION{NO_FOR_QNAME_ERR::
                DIS:sourceNode => {$qn_node},
              }__;
            }__;
          }
          my $qn_uri = $qn_node-><AG::ManakaiDISElement.qnameValueURI>;
          my $for = $self-><M::ManakaiDISDatabase.getFor> ($qn_uri);
        
          unless ($for-><AG::ManakaiDISForDefinition.isDefined>) {
            ## -- Initializes "For" Definition Object
            $for->{src} = $el;
            $for->{<Q::isDefined>} = true;
            $for->{<Q::definingModule>} = $mod->{uri};

            for my $ce (@{$el-><M::ManakaiDISElement.disAllChildElements>}) {
              my $xn = $ce-><AG::swcfg21:SWCFGElement::swcfg21:ForLatest
                                                       .expandedURI>;
              if ($xn eq <Q::dis:ISA> or $xn eq <Q::dis:Implement>) {
                my $sfor = $self-><M::ManakaiDISDatabase.getFor>
                            ($ce-><AG::ManakaiDISElement.qnameValueURI>);
                $for-><M::ManakaiDISForDefinition.addISA> ($sfor);
                $sfor-><AS::ManakaiDISForDefinition.isReferred> ($ce);
                ## TODO: warn if dis:Implement
              } elsif ({
                         <Q::dis:Description> => 1,
                         <Q::dis:ImplNote> => 1,
                         <Q::dis:FullName> => 1,
                         <Q::dis:QName> => 1,
                       }->{$xn}) {
                # 
              } else {
                __UNDEEP{
                  __EXCEPTION{ELEMENT_NOT_ALLOWED_ERR::
                    DIS:elementType => {$xn},
                    DIS:sourceNode => {$ce},
                    DIS:uri => {$mod->{uri}},
                  }__;
                }__;
              }
            }
          } else {
            __UNDEEP{
              __EXCEPTION{FOR_ALREADY_DEFINED_ERR::
                DIS:sourceNode => {$el},
                DIS:anotherSourceNode => {$for->{src}},
              }__;
            }__;
          } # isDefine?
        }__; # DEEP
        
  @Method:
    @@Name: loadResource
    @@enDesc:
      Loads definition of a <QUOTE::dis> resource from a 
      <Q::dis:ResourceDef> element. 
    @@Param:
      @@@Name: mod
      @@@Type: ManakaiDISModuleDefinition
      @@@enDesc:
        The module in which the resource to load is defined. 
    @@Param:
      @@@Name: parentResource
      @@@Type: ManakaiDISResourceDefinition
      @@@enDesc:
        The (static) parent resource in which the resource to load is defined. 
      @@@nullCase:
        @@@@enDesc:
          The resource to load is a root resource, i.e. <P::el> is 
          a direct child of the document node. 
    @@Param:
      @@@Name: dynParent
      @@@Type: ManakaiDISResourceDefinition
      @@@enDesc:
        The dynamic parent resource of the resource to load. 
      @@@nullCase:
        @@@@enDesc:
          If this resource is a root resource, i.e. <P::el> is
          a direct child of the document node. 
    @@Param:
      @@@Name: el
      @@@Type:ManakaiDISElement
      @@@enDesc:
        The source <QUOTE::dis> <Q::dis:ResourceDef> element object. 
    @@ForParam:
    @@ForpParam:
    @@Return:
      @@@ResDefDupException:
      @@@ElementNotAllowedException:
      @@@PerlDef:
        $forArg = <Q::ManakaiDOM:all> unless defined $forArg;
        $forpArg ||= [];
        __DEEP{
          ## -- Node names

          ## Unique resource identifier generated from node id
          my $node_id = $el-><AG::swcfg21:SWCFGNode::swcfg21:ForLatest.nodeID>;
          my $node_uri;
          __CODE{tfpurisToURI:: $turi => $node_id, $furi => $forArg,
                                $forp => $forpArg, $uri => $node_uri}__;

          ## User defined resource identifiers
          my $qn_node = $el-><M::ManakaiDISElement.disGetAttribute>
                                      (<Q::dis:QName>, for_arg => $forArg,
                                       forp_arg => $forpArg);
          my $res;
          if ($qn_node) {
            my $qn_uri = $qn_node-><AG::ManakaiDISElement.qnameValueURI>;
            $res = $self-><M::ManakaiDISDatabase.getResource>
                                ($qn_uri, for_arg => $forArg);
            if ($res-><AG::ManakaiDISForDefinition.isDefined>) {
              __UNDEEP{
                __EXCEPTION{RESOURCE_ALREADY_DEFINED_ERR::
                  DIS:uri => {$res->{uri}},
                  DIS:sourceNode => {$qn_node},
                  DIS:anotherSourceNode => {$res->{src}},
                }__;
              }__;
            }
            $res->{nameURI} = $qn_uri;
            $res->{localName} = $qn_node-><AG::ManakaiDISElement
                                                       .qnameValueLocalName>;
            $res->{namespaceURI} = $qn_node-><AG::ManakaiDISElement
                                                       .qnameValueNamespaceURI>;
          } else { ## Anonymous or local
            my $n_node = $el-><M::ManakaiDISElement.disGetAttribute>
                                      (<Q::dis:Name>, for_arg => $forArg,
                                       forp_arg => $forpArg);
            if ($n_node) {
              if ($parentResource) {
                my $puri = $parentResource->{uri};
                my $ru;
                my $ln = $n_node-><M::swcfg21:SWCFGNode
                                    ::swcfg21:ForLatest.value>;
                __CODE{getChildResourceURI:: $parentURI => $puri,
                                             $localName => $ln,
                                             $result => $ru}__;
                $res = $self-><M::ManakaiDISDatabase.getResource>
                                    ($ru, for_arg => $forArg);
                $res->{nameURI} = $ru;
                $res->{localName} = $n_node-><M::swcfg21:SWCFGNode
                                               ::swcfg21:ForLatest.value>;
                $res->{<Q::isAnon>} = true;
              } else {  ## Root local name resource
                my $ln = $n_node-><M::swcfg21:SWCFGNode
                                                ::swcfg21:ForLatest.value>;
                my $ns_uri = $mod-><M::ManakaiDISPropertyAccessor
                                            .getPropertyText>
                                                 (<Q::dis:Namespace>, null);
                my $qn_uri = $ns_uri . $ln;
                $res = $self-><M::ManakaiDISDatabase.getResource>
                                    ($qn_uri, for_arg => $forArg);
                if ($res-><AG::ManakaiDISForDefinition.isDefined>) {
                  __UNDEEP{
                    __EXCEPTION{RESOURCE_ALREADY_DEFINED_ERR::
                      DIS:uri => {$res->{uri}},
                      DIS:sourceNode => {$n_node},
                      DIS:anotherSourceNode => {$res->{src}},
                    }__;
                 }__;
                }
                $res->{nameURI} = $qn_uri;
                $res->{namespaceURI} = $ns_uri;
                $res->{localName} = $ln;
              }
            } else {
              $res = $self-><M::ManakaiDISDatabase.getResource> ($node_uri);
              $res->{<Q::isAnon>} = true;
            }
          } # anon
          $res->{for} = $forArg;
          $res->{forp} = $forpArg;
          $res->{src} = $el;
          $res->{<Q::definingModule>} = $mod->{uri};
          $mod-><M::ManakaiDISPropertyAccessor.addPropertyResourceList>
                                            (<Q::DIS:resource>, $res);
          $res->{<Q::dis2pm:parentResource>}
             = $parentResource ? $parentResource->{uri} : null;
          $res->{<Q::dynamicParentResource>}
             = $dynParent ? $dynParent->{uri} : null;
          unless ($res->{uri} eq $node_uri) {
            my $nu_res = $self-><M::ManakaiDISDatabase.getResource> ($node_uri);
            $res-><M::ManakaiDISResourceDefinition.mergeAsAlias> ($nu_res);
          }
          $res->{<Q::isDefined>} = true;
          $res->{seq} = $self->{seq}++;
          
          ## -- Alias
          my $al_node = $el-><M::ManakaiDISElement.disGetAttribute>
                                      (<Q::dis:AliasFor>, for_arg => $forArg,
                                       forp_arg => $forpArg);
          if ($al_node) {
            my $canon_uri = $al_node-><M::ManakaiDISElement.tfqnamesValueURI>
                                                           ($node_id, $forArg);
            my $canon_res = $self-><M::ManakaiDISDatabase.getResource>
                                                           ($canon_uri);
            $canon_res-><AS::ManakaiDISResourceDefinition.isReferred> ($al_node);
            $canon_res-><M::ManakaiDISResourceDefinition.mergeAsAlias>
                                      ($res, node => $al_node);
            $res = $canon_res;
          }

          ## -- Registers as child
          $parentResource-><M::ManakaiDISPropertyAccessor
                                    .addPropertyResourceList>
                                      (<Q::DIS:childResource>, $res)
             if $parentResource;
          $dynParent-><M::ManakaiDISPropertyAccessor
                                    .addPropertyResourceList>
                                      (<Q::DIS:dynamicChildResource>, $res)
             if $dynParent;

          my $is_multires = false;
          my @props;
          my @cres;
          my @ce0 = @{$el-><M::ManakaiDISElement.disChildElements>
                                    (for_arg => $forArg, forp_arg => $forpArg)};
          while (@ce0) {
            my $ce = shift @ce0;
            if ($ce-><M::ManakaiDISElement.elementTypeMatch> (<Q::rdf:type>)) {
              my $type_uri = $ce-><AG::ManakaiDISElement.qnameValueURI>;
              $res->{<Q::rdf:type>}->{$type_uri} = true;
              my $type = $self-><M::ManakaiDISDatabase.getResource> ($type_uri);
              $type-><AS::ManakaiDISResourceDefinition.isReferred> ($ce);
              if ($type-><M::ManakaiDISResourceDefinition.isSubsetOfURI>
                                               (<Q::dis:MultipleResource>)) {
                $is_multires = true;
              }
            } elsif ($ce-><M::ManakaiDISElement.elementTypeMatch>
                                                   (<Q::dis:subsetOf>)) {
              my $sres = $self-><M::ManakaiDISDatabase.getResource>
                                  ($ce-><M::ManakaiDISElement.tfqnamesValueURI>
                                                    ($node_id, $forArg));
              $res-><M::ManakaiDISResourceDefinition.addSuperResource> ($sres);
            } elsif ($ce-><AG::ManakaiDISElement.isResourceElement>) {
              push @cres, $ce;
            } else {
              ## Property and invalid element is not checked, since not
              ## all property definitions has loaded at this stage. 
              push @props, $ce;
            }
          } # @ce0
   
          ## -- Child resources
          unless ($is_multires) {
            for my $re (@cres) {
              unless ($al_node) {
                $self-><M::ManakaiDISDatabase.loadResource>
                                     ($mod, $res, $res, $re,
                                      for_arg => $forArg, forp_arg => $forpArg);
              } else {
                my $ac = $re-><M::ManakaiDISElement.disGetAttribute>
                                    (<Q::dis:aliasChild>, for_arg => $forArg,
                                     forp_arg => $forpArg);
                if ($ac and $ac-><M::swcfg21:SWCFGNode
                                   ::swcfg21:ForLatest.value>) {
                  $self-><M::ManakaiDISDatabase.loadResource>
                                     ($mod, $res, $res, $re,
                                      for_arg => $forArg, forp_arg => $forpArg);
                }
              }
            }
          }

          ## -- Multiple representations
          if ($is_multires) {
            for my $pe (@props) {
              if ($pe-><M::ManakaiDISElement.elementTypeMatch>
                                               (<Q::dis:resourceFor>)) {
                my $for_uri = $pe-><AG::ManakaiDISElement.qnameValueURI>;
                my $for = $self-><M::ManakaiDISDatabase.getFor> ($for_uri);
                $for-><AS::ManakaiDISForDefinition.isReferred> ($pe);
                $self-><M::ManakaiDISDatabase.loadResource>
                                ($mod, $parentResource, $res, $el,
                                 for_arg => $forArg,
                                 forp_arg => [@{$forpArg}, $for_uri]);
              }
            }
          }
        }__; # DEEP

  @Method:
    @@Name: checkUndefinedResource
    @@enDesc:
      Checks whether there is referred but undefined resource or not. 
    @@Return:
      @@@RaiseException:
        @@@@@: FOR_NOT_DEFINED_ERR
        @@@@enDesc:
          There is a <QUOTE::for> that is referred but not defined.
      @@@RaiseException:
        @@@@@: RESOURCE_NOT_DEFINED_ERR
        @@@@enDesc:
          There is a resource that is referred but not defined.
      @@@PerlDef:
        for my $fd (values %{$self->{forDef}}) {
          if (my $ref = $fd-><AG::ManakaiDISForDefinition.isReferred> and
              not $fd-><AG::ManakaiDISForDefinition.isDefined>) {
            __EXCEPTION{FOR_NOT_DEFINED_ERR::
              DIS:uri => {$fd->{uri}},
              DIS:sourceNode => {$ref},
            }__;
          }
        }
        for my $fd (values %{$self->{resDef}}) {
          if (my $ref = $fd-><AG::ManakaiDISResourceDefinition.isReferred> and
              not $fd-><AG::ManakaiDISResourceDefinition.isDefined>) {
            __EXCEPTION{RESOURCE_NOT_DEFINED_ERR::
              DIS:uri => {$fd->{uri}},
              DIS:sourceNode => {$ref},
            }__;
          }
        }
        

  @Method:
    @@Name: plStore
    @@enDesc:
      Saves this database to an external file. 
      \
      {NOTE:: Saved files can be loaded by 
              <M::ManakaiDISImplementation.plLoadDISDatabase>.
      \
      }
    @@Param:
      @@@Name: fileName
      @@@Type:
        DISLang:String::ManakaiDOM:all
      @@@enDesc:
        An environment-dependent file name of external database to save. 
        \
        {NOTE:: If there is already a file named as <P::fileName>, then 
                it is overwritten. 
        \
        }
    @@Return:
      @@@SimpleException:
      @@@PerlDef:
        use Storable qw/nstore/;
        local $Carp::CarpLevel = $Carp::CarpLevel + 1;
        nstore $self, $fileName;

  @Method:
    @@Name: xcrefToResource
    @@enDesc:
      Returns a resource object selected by an exception code
      reference (<Q::DOMMain:XCodeRef>).
    @@Param:
      @@@Name: xcref
      @@@Type:
        DOMMain:XCodeRef::ManakaiDOM:all
      @@@enDesc:
        Exception code to select.
    @@Param:
      @@@Name: contextNode
      @@@Type: ManakaiDISElement
      @@@enDesc:
        A context element node.  Namespace prefixes in 
        <P::xcref> are resolved against this node.
    @@ForParam:
    @@NodeParam:
    @@Return:
      @@@Type: 
        Perl:ARRAY::ManakaiDOM:all
      @@@enDesc:
        A reference to the array containing two or three 
        resource definitions (<Class::ManakaiDISResourceDefinition>).
        The first (index <CODE::0>) resource is an exception class. 
        The second (index <CODE::1>) resource is an exception code 
        constant.  The third (index <CODE::2>) resource
        is an exception subtype or <DOM::null> if the reference identifies
        no subtype.
      @@@RaiseException:
        @@@@@: RESOURCE_NOT_DEFINED_ERR
        @@@@enDesc:
          The resource identified by the <P::xcref> is not defined
          or not an exception.
      @@@PerlDef:
        my ($q1, $q2, $q3) = split /\s*\.\s*/, $xcref, 3;
        my $r = [];
        __DEEP{
          if (defined $q3) {
            $r->[2] = $self-><M::ManakaiDISDatabase.getResource>
                         ($contextNode-><M::ManakaiDISElement.tfqnamesToURI>
                                          ($q3, null, $forArg, node => $node));
            $r->[1] = $r->[2]-><M::ManakaiDISPropertyAccessor
                                       .getPropertyResource>
                                          (<Q::dis2pm:parentResource>);
          } elsif (defined $q2) {
            if ($q2 =~ /:/) {
              $r->[1] = $self-><M::ManakaiDISDatabase.getResource>
                         ($contextNode-><M::ManakaiDISElement.tfqnamesToURI>
                                          ($q2, null, $forArg, node => $node));
            } else {
              $r->[0] = $self-><M::ManakaiDISDatabase.getResource>
                         ($contextNode-><M::ManakaiDISElement.tfqnamesToURI>
                                          ($q1, null, $forArg, node => $node));
              $r->[1] = $r->[0]-><M::ManakaiDISResourceDefinition
                                    .getConstResourceByName> ($q2);
            }
          } else {  ## $q1 only
            $r->[2] = $self-><M::ManakaiDISDatabase.getResource>
                         ($contextNode-><M::ManakaiDISElement.tfqnamesToURI>
                                          ($q1, null, $forArg, node => $node));
            if ($r->[2]-><M::ManakaiDISResourceDefinition
                      .isTypeURI> (<Q::ManakaiDOM:ExceptionOrWarningSubType>)) {
              $r->[1] = $r->[2]-><M::ManakaiDISPropertyAccessor
                                       .getPropertyResource>
                                          (<Q::dis2pm:parentResource>);
            } else {
              $r->[1] = $r->[2]; CORE::delete $r->[2];
            }
          }

          if ($r->[2] and
              not $r->[2]-><M::ManakaiDISResourceDefinition
                      .isTypeURI> (<Q::ManakaiDOM:ExceptionOrWarningSubType>)) {
            __UNDEEP{__EXCEPTION{RESOURCE_NOT_DEFINED_ERR::
              DIS:uri => {$r->[2]->{uri}},
              DIS:expectedType => {<Q::ManakaiDOM:ExceptionOrWarningSubType>},
              DIS:sourceNode => {$node},
              DIS:sourceCode => {$xcref},
            }__}__;
          }
          $r->[2]-><AS::ManakaiDISResourceDefinition.isReferred>
                                               ($node or $contextNode)
            if $r->[2];
          
          if (not $r->[1] or
              not $r->[1]-><M::ManakaiDISResourceDefinition
                      .isTypeURI> (<Q::ManakaiDOM:Const>)) {
            __UNDEEP{__EXCEPTION{RESOURCE_NOT_DEFINED_ERR::
              DIS:uri => {$r->[1]->{uri}},
              DIS:localName => {$r->[1]->{localName}},
              DIS:expectedType => {<Q::ManakaiDOM:Const>},
              DIS:sourceNode => {$node},
              DIS:sourceCode => {$xcref},
            }__}__;
          }
          $r->[1]-><AS::ManakaiDISResourceDefinition.isReferred>
                                               ($node or $contextNode);

          unless ($r->[0]) {
            my $cg = $r->[1]-><M::ManakaiDISPropertyAccessor
                                       .getPropertyResource>
                                          (<Q::dis2pm:parentResource>);
            $r->[0] = $cg-><M::ManakaiDISPropertyAccessor
                                       .getPropertyResource>
                                          (<Q::dis2pm:parentResource>) if $cg;
          }
          if (not $r->[0] or
              not $r->[0]-><M::ManakaiDISResourceDefinition
                    .isTypeURI> (<Q::DOMException:AnyExceptionClass>)) {
            __UNDEEP{__EXCEPTION{RESOURCE_NOT_DEFINED_ERR::
              DIS:uri => {$r->[0]->{uri}},
              DIS:localName => {$r->[0]->{localName}},
              DIS:expectedType => {<Q::DOMException:AnyExceptionClass>},
              DIS:sourceNode => {$node},
              DIS:sourceCode => {$xcref},
            }__}__;
          }
          $r->[0]-><AS::ManakaiDISResourceDefinition.isReferred>
                                               ($node or $contextNode);
        }__;
##DISDatabase

PropDef:
  @QName: resource
  @enDesc:
    Resources defined in a module. 
  @rdfs:range: ManakaiDISResourceDefinition
  @rdfs:domain: ManakaiDISModuleDefinition

PropDef:
  @QName:
    dis2pm:parentResource
  @enDesc:
    Static parent resource.  No parent for root resources.

PropDef:
  @QName: dynamicParentResource
  @enDesc:
    Dynamic parent resource.   No parent for root resources. 

PropDef:
  @QName: childResource
  @enDesc:
    Static child resources.

PropDef:
  @QName: dynamicChildResource
  @enDesc:
    Dynamic child resources.

ElementTypeBinding:
  @Name: ForDefDupException
  @ElementType:
    ManakaiDOM:raises
  @ShadowContent:
    @@@: FOR_ALREADY_DEFINED_ERR
    @@Description:
      @@@lang:en
      @@@@:
        The <QUOTE::for> is already defined elsewhere. 

ElementTypeBinding:
  @Name: ForDefNoQNameException
  @ElementType:
    ManakaiDOM:raises
  @ShadowContent:
    @@@: NO_FOR_QNAME_ERR
    @@Description:
      @@@lang:en
      @@@@:
        A <Q::dis:ForDef> element must have a <Q::dis:QName> attribute. 

ElementTypeBinding:
  @Name: ResDefDupException
  @ElementType:
    ManakaiDOM:raises
  @ShadowContent:
    @@@: RESOURCE_ALREADY_DEFINED_ERR
    @@Description:
      @@@lang:en
      @@@@:
        The <QUOTE::dis> resource is already defined elsewhere. 

ElementTypeBinding:
  @Name: ElementNotAllowedException
  @ElementType:
    ManakaiDOM:raises
  @ShadowContent:
    @@@: ELEMENT_NOT_ALLOWED_ERR
    @@Description:
      @@@lang:en
      @@@@:
        An element has found where it is not allowed. 

IFClsDef:
  @QName:
    @@@: DISModuleResolver
    @@ForCheck: ForIF
  @QName:
    @@@: ManakaiDISModuleResolver
    @@ForCheck: ForClass
  @enDesc:
    Objects implementing <IF::DISModuleResolver> interface 
    are used to convert module name into <QUOTE::dis> document object. 
    \
    {NOTE:: It is also acceptable to pass a <Perl::CODE> reference 
            as a method parameter where <IF::DISModuleResolver> is 
            expected.
    \
    }
  @Method:
    @@Name: uriToDocument
    @@enDesc:
      Returns a <QUOTE::dis> document from module name information. 
    @@Param:
      @@@Name: disDB
      @@@Type: ManakaiDISDatabase
      @@@enDesc:
        The <QUOTE::dis> database. 
    @@Param:
      @@@Name: moduleURI
      @@@Type: ModuleURI
      @@@enDesc:
        The URI reference of the module. 
        \
        {NOTE:: This parameter is redundant, since it can be 
                composed from other three parameters.
        \
        }
    @@Param:
      @@@Name: moduleNamespaceURI
      @@@Type: AnyURI
      @@@enDesc:
        The namespace URI of the module name. 
    @@Param:
      @@@Name: moduleLocalName
      @@@Type: 
        DISCore:LocalName::ManakaiDOM:all
      @@@enDesc:
        The local name of the module name. 
    @@Param:
      @@@Name: moduleFor
      @@@Type: ForURI
      @@@enDesc:
        The <QUOTE::for> URI reference for which the module is defined. 
    @@Return:
      @@@Type: ManakaiDISDocument
      @@@enDesc:
        The <QUOTE::dis> document.  It don't have to be a newly created
        object. 
      @@@nullCase:
        @@@@enDesc:
          The method is unable to resolve the reference. 
      @@@PerlDef:
        $r = $self->(@_);
  @ManakaiDOM:inputNormalizer:
    @@ContentType:
      lang:Perl
    @@@:
      $INPUT = bless $INPUT, <ClassName::ManakaiDISModuleResolver>
                 if ref $INPUT eq 'CODE';
    @@ImplNote:
      @@@lang:en
      @@@@:
        <FILE::cdis2pm.pl> does not support non-datatype input normalizers yet.
##DISModuleResolver

PropDef:
  @QName: sourceFile
  @enDesc:
    Source <QUOTE::dis> documents. 
  @rdfs:domain: ManakaiDISDatabase
  @rdfs:range: ManakaiDISDocument

ClsDef:
  @ClsQName: ManakaiDISModuleDefinition
  @enDesc:
    <QUOTE::dis> module definitions. 
  @ClsISA: ManakaiDISPropertyAccessor
  @ClsISA: ManakaiDISExceptionTarget
  @ClsISA: ManakaiDISPerlModuleDefinition
  
  @Attr:
    @@Name: uri
    @@Type: ModuleURI
    @@Description:
      @@@lang:en
      @@@@:
        The URI reference of this <QUOTE::dis> module. 
    @@Get:
      @@@PerlDef:
        $r = $self->{uri};

  @IntMethod:
    @@Operator:
      @@@@:eq
      @@@ContentType:
        lang:Perl
    @@enDesc:
      Whether two <QUOTE::dis> module definitions are equal or not. 
      Two <QUOTE::dis> module definitions are equal iff their canonical
      URI references are literally (in character-by-character) equivalent.
    @@Param:
      @@@Name: anotherModule
      @@@Type: ManakaiDISModuleDefinition
      @@@enDesc:
        Another <QUOTE::dis> module definition to compare.
    @@Return:
      @@@Type:
        DOMMain:boolean::ManakaiDOM:all
      @@@enDesc:
        Whether two resources are equal or not. 
      @@@PerlDef:
        if (UNIVERSAL::isa ($anotherModule,
                            <ClassName::ManakaiDISModuleDefinition>)) {
          $r = $self->{uri} eq $anotherModule->{uri};
        } else {
          $r = false;
        }

  @Attr:
    @@Name: nameURI
    @@Type: NameURI
    @@enDesc:
      The URI reference of this module, without 
      <QUOTE::for> identifier. 
    @@Get:
      @@@PerlDef:
        $r = $self->{nameURI};

  @Attr:
    @@Name: localName
    @@enDesc:
      The local name of this module. 
    @@Type:
      DISCore:LocalName::ManakaiDOM:all
    @@Get:
      @@@PerlDef:
        $r = $self->{localName};

  @Attr:
    @@Name: namespaceURI
    @@Type: AnyURI
    @@enDesc:
      The namespace URI of the name of this resource. 
    @@Get:
      @@@PerlDef:
        $r = $self->{namespaceURI};

  @Attr:
    @@Name: forURI
    @@Type: ForURI
    @@enDesc:
      The <QUOTE::for> URI reference for which this module is defined. 
    @@Get:
      @@@PerlDef:
        $r = $self->{for};

  @Attr:
    @@Name: isDefined
    @@Description:
      @@@lang:en
      @@@@:
        Whether this module is defined or not. 
    @@Type:
      DOMMain:boolean::ManakaiDOM:all
    @@Get:
      @@@PerlDef:
        $r = $self->{<Q::isDefined>};

  @Attr:
    @@Name: plFullyQualifiedName
    @@enDesc:
      The fully-qualified Perl class package name. 
    @@Type:
      Perl:package-name::ManakaiDOM:all
    @@Get:
      @@@NoPerlModuleNameException:
      @@@PerlDef:
        __DEEP{
          my $mg = $self->{db}-><M::ManakaiDISDatabase.getResource>
                                              ($self->{namespaceURI});
          unless ($self-><AG::ManakaiDISResourceDefinition.isDefined>) {
            __UNDEEP{
              __EXCEPTION{RESOURCE_NOT_DEFINED_ERR::
                DIS:uri => {$self->{namespaceURI}},
                DIS:sourceNode => {$self->{src}},
              }__;
            }__;
          }
          my $an = $mg->{src}-><M::ManakaiDISElement.disGetAttribute>
                                     (<Q::dis:AppName>, for_arg => $self->{for},
                                      media_type => <Q::lang:Perl>,
                                      default_media_type => <Q::lang:Perl>);
          if ($an) {
            $r = $an-><M::swcfg21:SWCFGNode::swcfg21:ForLatest.value>;
            $r =~ s/::$//g;
            $r .= '::' . $self->{localName};
            my $sf = $an-><M::ManakaiDISElement.disGetAttribute>
                                 (<Q::ManakaiDOM:moduleSuffix>,
                                  for_arg => $self->{for},
                                  media_type => <Q::lang:Perl>,
                                  default_media_type => <Q::lang:Perl>);
            if ($sf) {
              $r .= $sf-><M::swcfg21:SWCFGNode::swcfg21:ForLatest.value>;
            }
          } else {
            $r = ($mg->{localName} || 'main') . '::' . $self->{localName};
          }
        }__;

  @Attr:
    @@Name: plInterfaceName
    @@enDesc:
      The fully-qualified Perl interface package name. 
    @@Type:
      Perl:package-name::ManakaiDOM:all
    @@Get:
      @@@NoPerlModuleNameException:
      @@@PerlDef:
        __DEEP{
          my $mg = $self->{db}-><M::ManakaiDISDatabase.getResource>
                                              ($self->{namespaceURI});
          unless ($self-><AG::ManakaiDISResourceDefinition.isDefined>) {
            __UNDEEP{
              __EXCEPTION{RESOURCE_NOT_DEFINED_ERR::
                DIS:uri => {$self->{namespaceURI}},
                DIS:sourceNode => {$self->{src}},
              }__;
            }__;
          }
          my $an = $mg->{src}-><M::ManakaiDISElement.disGetAttribute>
                                     (<Q::dis:AppName>, for_arg => $self->{for},
                                      forp_arg => [<Q::ManakaiDOM:ForIF>],
                                      media_type => <Q::lang:Perl>,
                                      default_media_type => <Q::lang:Perl>);
          if ($an) {
            $r = $an-><M::swcfg21:SWCFGNode::swcfg21:ForLatest.value>;
            $r =~ s/::$//g;
            my $sf = $an-><M::ManakaiDISElement.disGetAttribute>
                                 (<Q::ManakaiDOM:moduleSuffix>,
                                  for_arg => $self->{for},
                                  forp_arg => [<Q::ManakaiDOM:ForIF>],
                                  media_type => <Q::lang:Perl>,
                                  default_media_type => <Q::lang:Perl>);
            if ($sf) {
              $r .= $sf-><M::swcfg21:SWCFGNode::swcfg21:ForLatest.value>;
            }
          } else {
            $r = $self-><AG::ManakaiDISModuleDefinition.plFullyQualifiedName>;
          }
        }__;

  @Attr:
    @@Name: ownerModule
    @@ManakaiDOM:isRedefining:1
    @@enDesc:
      This module itself.
    @@Get:
      @@@Type: ManakaiDISModuleDefinition
      @@@PerlDef: $r = $self;
##DISModuleDefinition

ElementTypeBinding:
  @Name: NoPerlModuleNameException
  @ElementType:
    ManakaiDOM:raises
  @ShadowContent:
    @@@: RESOURCE_NOT_DEFINED_ERR
    @@Description:
      @@@lang:en
      @@@@:
        The module group corresponding to the namespace URI
        of this module is not defined. 

ClsDef:
  @ClsQName: ManakaiDISForDefinition
  @Description:
    @@lang:en
    @@@:
      <QUOTE::dis> <QUOTE::for> definitions. 
  @ClsISA: ManakaiDISExceptionTarget
  
  @Attr:
    @@Name: uri
    @@Type: ForURI
    @@Description:
      @@@lang:en
      @@@@:
        The URI reference of this <QUOTE::for>. 
    @@Get:
      @@@PerlDef:
        $r = $self->{uri};

  @IntMethod:
    @@Operator:
      @@@@:eq
      @@@ContentType:
        lang:Perl
    @@enDesc:
      Whether two <QUOTE::for> definitions are equal or not. 
      Two <QUOTE::for> definitions are equal iff one's URI reference 
      is one of another's URI reference. 
      \
      {NOTE:: Aliases for <QUOTE::for> is not allowed.
      \
      }
    @@ImplNote:
      @@@lang:en
      @@@@:
        In the current implementation, two are equal iff two are 
        equal as reference. 
    @@Param:
      @@@Name: anotherFor
      @@@Type: ManakaiDISForDefinition
      @@@enDesc:
        Another <QUOTE::for> definition to compare.
    @@Return:
      @@@Type:
        DOMMain:boolean::ManakaiDOM:all
      @@@enDesc:
        Whether two resources are equal or not. 
      @@@PerlDef:
        if (UNIVERSAL::isa ($anotherFor, <ClassName::ManakaiDISForDefinition>)) {
          $r = $self->{uri} eq $anotherFor->{uri};
        } else {
          $r = false;
        }
  
  @Method:
    @@Name: isaURI
    @@Description:
      @@@lang:en
      @@@@:
        Whether this <QUOTE::for> is-a another <QUOTE::for> or not. 
    @@Param:
      @@@Name: superURI
      @@@Type: ForURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          Another <QUOTE::for> URI reference to test. 
    @@Return:
      @@@Type: 
        DOMMain:boolean::ManakaiDOM:all
      @@@TrueCase:
        @@@@enDesc:
          <P::superURI> is a super-<QUOTE::for> of this <QUOTE::for>. 
      @@@FalseCase:
        @@@@enDesc:
          <P::superURI> is not a super-<QUOTE::for> of this <QUOTE::for>. 
      @@@PerlDef:
        $r = $self->{uri} eq $superURI ? true : $self->{isa}->{$superURI};

  @Attr:
    @@Name: isDefined
    @@Description:
      @@@lang:en
      @@@@:
        Whether this <QUOTE::for> is already defined or not. 
    @@Type:
      DOMMain:boolean::ManakaiDOM:all
    @@Get:
      @@@TrueCase:
        This <QUOTE::for> is already defined. 
      @@@FalseCase:
        This <QUOTE::for> is not defined. 
      @@@PerlDef:
        $r = $self->{<Q::isDefined>};

  @Attr:
    @@Name: isReferred
    @@Description:
      @@@lang:en
      @@@@:
        Whether this <QUOTE::for> is referred somewhere or not. 
    @@Type: ManakaiDISElement
    @@Get:
      @@@InCase:
        @@@@Type:ManakaiDISElement
        @@@@enDesc:
          This <QUOTE::for> is referred by the element. 
      @@@nullCase:
        This <QUOTE::for> is not referred. 
      @@@PerlDef:
        $r = $self->{<Q::isReferred>};
    @@Set:
      @@@InCase:
        @@@@Type:ManakaiDISElement
        @@@@enDesc:
          This <QUOTE::for> is referred by the element. 
      @@@PerlDef:
        $self->{<Q::isReferred>} = $given if $given;

  @Attr:
    @@Name: ownerModule
    @@ManakaiDOM:isRedefining:1
    @@Description:
      @@@lang:en
      @@@@:
        The <QUOTE::dis> module in which this <QUOTE::for> is defined.
    @@Type: ManakaiDISModuleDefinition
    @@Get:
      @@@Description:
        @@@@lang:en
        @@@@@:
          The module object. 
      @@@nullCase:
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            This <QUOTE::for> is not associated to any module. 
      @@@PerlDef:
        $r = $self->{db}
                  -><M::ManakaiDISDatabase.getResource>
                           ($self->{<Q::definingModule>})
           if defined $self->{<Q::definingModule>};

  @Method:
    @@Name: addISA
    @@enDesc:
      Adds a <QUOTE::for> to the list of super-<QUOTE::for> of this 
      <QUOTE::for>.
    @@Param:
      @@@Name: superFor
      @@@Type: ManakaiDISForDefinition
      @@@enDesc:
        A <QUOTE::for> definition object. 
    @@Return:
      @@@PerlDef:
        my @from = ($self->{uri},
                    grep {$self->{revISA}->{$_}} keys %{$self->{revISA}});
        my @to = ($superFor->{uri},
                  grep {$superFor->{isa}->{$_}} keys %{$superFor->{isa}});
        __DEEP{
          for my $from (@from) {
            for my $to (@to) {
              $self->{db}-><M::ManakaiDISDatabase.getFor>
                                      ($from)->{isa}->{$to} = true;
              $self->{db}-><M::ManakaiDISDatabase.getFor>
                                      ($to)->{revISA}->{$from} = true;
            }
          }
        }__;

##DISForDefinition

ClsDef:
  @ClsQName: ManakaiDISPerlModuleDefinition
  @enDesc:
    A class inherited by classes whose object might (but not necessarily) define
    a Perl module. 
  @ImplNote:
    @@lang:en
    @@@:
      Any object whose class inheriting this class must also inherit
      the <Class::ManakaiDISPropertyAccessor> class.
  
  @Method:
    @@Name: plGeneratePerlModuleFile
    @@enDesc:
      Generates a Perl file object. 
    @@Return:
      @@@Type: PLFile
      @@@enDesc:
        A Perl file object generated from this resource.
      @@@RaiseException:
        @@@@@:NO_LICENSE_ATTR_ERR
        @@@@enDesc:
          The <Q::dis:Module> element does not have the
          <Q::dis:License> attribute.
      @@@NoPerlModuleNameException:
      @@@RaiseException:
        @@@@@:RESOURCE_NOT_DEFINED_ERR
        @@@@enDesc:
          A feature referred from this module is not defined.
      @@@PerlDef:
        __DEEP{
          $r = $self-><AG::ManakaiDISPropertyAccessor.plImplementation>
                    -><M::MPLImpl.createPerlFile>;

          ## -- Source information
          $r-><AS::PLFile.sourceFile>
                 ($self-><M::ManakaiDISPropertyAccessor.getPropertyText>
                                (<Q::DIS:sourceFile>, ''));
          $r-><AS::PLFile.sourceModule> ($self->{nameURI});
          $r-><AS::PLFile.sourceFor> ($self->{for});
          
          ## -- License information
          my $ownermod = $self-><AG::ManakaiDISPropertyAccessor.ownerModule>;
          my $license = $ownermod-><M::ManakaiDISPropertyAccessor
                                     .getPropertyResource> (<Q::dis:License>);
          unless ($license) {
            __UNDEEP{__EXCEPTION{NO_LICENSE_ATTR_ERR::
              DIS:sourceNode => {$ownermod->{src}},
              DIS:uri => {$ownermod->{uri}},
            }__}__;
          }
          $r-><AS::PLFile.licenseURI>
                            ($license-><AG::ManakaiDISResourceDefinition.uri>);

          ## -- Classes
          ## TODO: Custom module construction support
          for my $cls (@{$self-><M::ManakaiDISPropertyAccessor
                                   .getPropertyResourceList>
                                              (<Q::DIS:resource>)}) {
            if ($cls-><AG::ManakaiDISResourceDefinition.ownerModule>
                   eq $ownermod) {
              if ($cls-><M::ManakaiDISResourceDefinition.isTypeURI>
                              (<Q::ManakaiDOM:Class>)) {
                ## -- Subroutines and variables
                my $pack = $cls-><AG::ManakaiDISResourceDefinition
                                     .plCodeFragment>;
                $r-><M::PLFile.appendPackage> ($pack);
                my $pack_name = $cls-><AG::ManakaiDISResourceDefinition
                                          .plFullyQualifiedName>;

                ## -- Features
                my %feature;
                for my $el (@{$cls->{src}
                                  -><M::ManakaiDISElement.disChildElements>
                                      (for_arg => $self->{for},
                                       forp_arg => $self->{forp})}) {
                  next unless $el-><AG::swcfg21:SWCFGElement::swcfg21:ForLatest
                                .expandedURI> eq <Q::DOMMetaImpl:provideFeature>;
                  my $furi = $el-><AG::ManakaiDISElement.qnameValueURI>;
                  my $f = $self->{db}-><M::ManakaiDISDatabase.getResource>
                                                                   ($furi);
                  unless ($f-><AS::ManakaiDISResourceDefinition.isDefined>) {
                    __UNDEEP{__EXCEPTION{RESOURCE_NOT_DEFINED_ERR::
                      DIS:sourceNode => {$el},
                      DIS:uri => {$furi},
                      DIS:expectedType => {<Q::DOMMain:DOMFeature>},
                    }__}__;
                  }
                  for my $s ($f, @{$f-><M::ManakaiDISPropertyAccessor
                                    .getPropertyResourceList>
                                   (<Q::DOMMetaImpl:extendFeature>,
                                    recursive => true,
                                    default_media_type => <Q::dis:TypeQName>)}) {
                    $feature{$s-><AG::ManakaiDISResourceDefinition.uri>}
                         = [$s, $el];
                  }
                }
                for my $f (values %feature) {
                  my @fname = @{$f->[0]-><AG::ManakaiDISResourceDefinition
                                        .featureNameList>};
                  my $fver = $f->[0]-><M::ManakaiDISPropertyAccessor
                                        .getPropertyText>
                                        (<Q::dis:Version>, null);
                  next unless defined $fver;
                  my $fi = $self-><M::ManakaiDISPerlModuleDefinition
                        .plIsFeatureImplemented> ($f->[0]->{uri}) ? true : false;
                  my @ec = @{$f->[1]-><M::ManakaiDISElement.disChildElements>
                                    (for_arg => $self->{for},
                                     forp_arg => $self->{forp})};
                  if (@ec) {
                    for my $ec (@ec) {
                      next unless $ec-><AG::swcfg21:SWCFGElement
                                          ::swcfg21:ForLatest
                               .expandedURI> eq <Q::DOMMetaImpl:providedThrough>;
                      my $curi = $ec-><M::ManakaiDISElement.tfqnamesValueURI>
                                    ($self->{nameURI}, $self->{for});
                      my $c = $self->{db}-><M::ManakaiDISDatabase.getResource>
                                                                    ($curi);
                      $c-><AS::ManakaiDISResourceDefinition.isReferred> ($ec);
                      my $cp = $c-><AG::ManakaiDISResourceDefinition
                                       .plFullyQualifiedName>;
                      for my $fname (@fname) {
                        $r-><M::PLBlockCon.appendStatement>
                          ('$' . $cp . '::ProvideFeature{q<' .
                           $fname . '>}->{q<' . $fver . '>} ||= '.$fi);
                        $r-><M::PLBlockCon.appendStatement>
                          ('$' . $cp . '::ProvideFeature{q<' .
                           $fname . '>}->{q<>} = 1');
                      }
                    }
                  } else {  ## No DOMMetaImpl:ProvidedThrough attribute
                    for my $fname (@fname) {
                      $r-><M::PLBlockCon.appendStatement>
                        ('$' . $pack_name . '::ProvideFeature{q<' .
                         $fname . '>}->{q<' . $fver . '>} ||= '.$fi);
                      $r-><M::PLBlockCon.appendStatement>
                        ('$' . $pack_name . '::ProvideFeature{q<' .
                         $fname . '>}->{q<>} = 1');
                    }
                  }
                }
              } elsif ($cls-><M::ManakaiDISResourceDefinition.isTypeURI>
                              (<Q::DISPerl:ScalarVariable>) and
                       not $cls-><M::ManakaiDISPropertyAccessor
                           .getPropertyResource> (<Q::dis2pm:parentResource>)) {
                $r-><M::PLBlockCon.appendCodeFragment>
                      ($cls-><AG::ManakaiDISResourceDefinition.plCodeFragment>);
              }
            }
          }

          ## -- Require'ing external modules
          ## TODO: Custom module construction support
          my $thismod_name = $self-><AG::ManakaiDISModuleDefinition
                                                     .plFullyQualifiedName>;
          for my $uri (@{$r-><M::MPLCodeFragment.disGetRequireURIList>}) {
            my $mod = $self->{db}-><M::ManakaiDISDatabase.getResource> ($uri)
                           -><AG::ManakaiDISResourceDefinition.ownerModule>;
            next unless $mod;
            my $pack = $mod-><AG::ManakaiDISModuleDefinition
                                                     .plFullyQualifiedName>;
            $r-><M::PLFile.addRequirePerlModuleName> ($pack)
              unless $pack eq $thismod_name;
          }


        }__;

  @Method:
    @@Name: plIsFeatureImplemented
    @@enDesc
      Returns whether a feature is implemented by this module
      or resource or not. 
      \
      {NOTE:: For modules, tests for features not provided
              by the modules will return <DOM::true>.  For 
              resources, if it does not provides the support
              for the feature, then this method will return <DOM::true>.
      \
      }
      \
      {NOTE:: Feature inheritances are not taken into account.
      \
      }
    @@Param:
      @@@Name:featureResourceURI
      @@@Type: ResourceURI
      @@@enDesc:
        The URI reference of the resource definition for 
        the feature to test.
    @@Return:
      @@@Type:
        DOMMain:boolean::ManakaiDOM:all
      @@@enDesc:
        Whether the feature is implemented or not.
      @@@PerlDef:
      __DEEP{
        if (defined $self->{<Q::DIS:isFeatureImplemented>}
                         ->{$featureResourceURI}) {
          $r = $self->{<Q::DIS:isFeatureImplemented>}
                         ->{$featureResourceURI};
        } elsif ($self->isa (<ClassName::ManakaiDISModuleDefinition>)) {
          $r = true;
          for my $cls (@{$self-><M::ManakaiDISPropertyAccessor
                                   .getPropertyResourceList>
                                      (<Q::DIS:resource>)}) {
            if ($cls-><M::ManakaiDISResourceDefinition.isTypeURI>
                                      (<Q::ManakaiDOM:Class>)) {
              unless ($cls-><M::ManakaiDISPerlModuleDefinition
                               .plIsFeatureImplemented>
                                      ($featureResourceURI)) {
                $r = false;
                last;
              }
            }                
            ## NOTE: DISPerl:ScalarVariable's are always implemented
          }
          $self->{<Q::DIS:isFeatureImplemented>}
                         ->{$featureResourceURI} = $r;
        } else { ## Resource definition
          ## TODO: Custom module definition
          if ($self-><M::ManakaiDISResourceDefinition.isFeatureProvided>
                              ($featureResourceURI)) {
            if ($self-><M::ManakaiDISResourceDefinition.isTypeURI>
                              (<Q::DISLang:MethodReturn>) or
                $self-><M::ManakaiDISResourceDefinition.isTypeURI>
                              (<Q::DISLang:AttributeGet>) or
                $self-><M::ManakaiDISResourceDefinition.isTypeURI>
                              (<Q::DISLang:AttributeSet>)) {
              my $def = $self->{src}-><M::ManakaiDISElement.disGetAttribute>
                                (<Q::dis:Def>, for_arg => $self->{for},
                                 forp_arg => $self->{forp});
              $r = $def ? true : false;
            } else {
              $r = true;
              for my $res (@{$self-><M::ManakaiDISPropertyAccessor
                                     .getPropertyResourceList>
                              (<Q::DIS:childResource>)}) {
                if ($res-><M::ManakaiDISResourceDefinition.isTypeURI>
                              (<Q::DISLang:AnyMethod>)) {
                  unless ($res-><M::ManakaiDISPerlModuleDefinition
                                 .plIsFeatureImplemented>
                              ($featureResourceURI)) {
                    $r = false;
                    last;
                  }
                }
              } # for
            } # self.type
          } else {
            $r = true;
          }
          $self->{<Q::DIS:isFeatureImplemented>}->{$featureResourceURI} = $r;
        }
      }__;

##DISPerlModuleDefinition

PropDef:
  @QName: isFeatureImplemented
  @enDesc:
    The list of whether a feature is implemented or not. 

ResourceDef:
  @QName: PLFile
  @AliasFor:
    PerlCode:ManakaiPerlFile::ManakaiDOM:Perl
  @rdf:type:
    rdfs:Class

ClsDef:
  @ClsQName: ManakaiDISResourceDefinition
  @enDesc:
    <QUOTE::dis> resource definitions. 
  @ClsISA: ManakaiDISPropertyAccessor
  @ClsISA: ManakaiDISExceptionTarget
  @ClsISA: ManakaiDISPerlModuleDefinition

  @IntMethod:
    @@Operator:
      @@@@:eq
      @@@ContentType:
        lang:Perl
    @@enDesc:
      Whether two <QUOTE::dis> resource definitions are equal or not. 
      Two resource definitions are equal iff one's <A::.uri> is
      literally equal to another's <A::.uri>.
    @@Param:
      @@@Name: anotherResource
      @@@Type: ManakaiDISResourceDefinition
      @@@enDesc:
        Another resource definition to compare.
    @@Return:
      @@@Type:
        DOMMain:boolean::ManakaiDOM:all
      @@@enDesc:
        Whether two resources are equal or not. 
      @@@PerlDef:
        if (UNIVERSAL::isa ($anotherResource,
                            <ClassName::ManakaiDISResourceDefinition>)) {
          $r = $self->{uri} eq $anotherResource->{uri};
        } else {
          $r = false;
        }
  
  @Attr:
    @@Name: uri
    @@Type: ResourceURI
    @@Description:
      @@@lang:en
      @@@@:
        The URI reference of this <QUOTE::dis> resource. 
    @@Get:
      @@@PerlDef:
        $r = $self->{uri};

  @Attr:
    @@Name: nameURI
    @@Type: NameURI
    @@enDesc:
      The URI reference of this <QUOTE::dis> resource, without 
      <QUOTE::for> identifier. 
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          This resource does not have its name URI reference. 
      @@@PerlDef:
        $r = $self->{nameURI};

  @Attr:
    @@Name: localName
    @@enDesc:
      The local name of this resource. 
    @@Type:
      DISCore:LocalName::ManakaiDOM:all
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          This resource does not have its local name. 
      @@@PerlDef:
        $r = $self->{localName};

  @Attr:
    @@Name: namespaceURI
    @@Type: AnyURI
    @@enDesc:
      The namespace URI of the name of this resource. 
    @@Get:
      @@@nullCase:
        The name of this resource does not have its namespace 
        or this resource does not have its name. 
      @@@PerlDef:
        $r = $self->{namespaceURI};

  @Attr:
    @@Name: isAnonymous
    @@enDesc:
      Whether this <QUOTE::dis> resource has name or not. 
    @@Type: 
      DOMMain:boolean::ManakaiDOM:all
    @@Get:
      @@@TrueCase:
        This resource does not have any global unique name. 
        <A::ManakaiDISResourceDefinition.uri> is a temporary URI reference. 
      @@@FalseCase:
        This resource does have its formal name. 
        <A::ManakaiDISResourceDefinition.uri> is a URI reference 
        generated from the name and the <QUOTE::for> URI reference 
        of this resource. 
      @@@PerlDef:
        $r = $self->{<Q::isAnon>};

  @Attr:
    @@Name: forURI
    @@enDesc:
      The <QUOTE::for> URI reference for which this resource is defined. 
    @@Type:ForURI
    @@Get:
      @@@PerlDef:
        $r = $self->{for};

  @Attr:
    @@Name: forpURI
    @@enDesc:
      The <QUOTE::for+> URI references for which this resource is defined. 
    @@Type: ForURIList
    @@Get:
      @@@enDesc:
        List of <QUOTE::for> URI references.  Note that this list is
        <QUOTE::dead>.
      @@@PerlDef:
        $r = [@{$self->{forp}}];

  @Method:
    @@Name: isForURI
    @@enDesc:
      Tests whether this resource is defined for a <QUOTE::for>
      or <QUOTE::for+> URI reference or not.
    @@Param:
      @@@Name:forURI
      @@@Type:ForURI
      @@@enDesc:
        A <QUOTE::for> URI reference to test.
    @@Return:
      @@@Type:
        DOMMain:boolean::ManakaiDOM:all
      @@@TrueCase:
        @@@@enDesc:
          This resource is for <P::forURI>.
      @@@FalseCase:
        @@@@enDesc:
          This resource is not for <P::forURI>.
      @@@PerlDef:
        __DEEP{
          for my $this_for_uri ($self->{for}, @{$self->{forp}}) {
            if ($this_for_uri eq $forURI) { ## Shortcut
              $r = true;
              last;
            }
            my $this_for = $self->{db}-><M::ManakaiDISDatabase.getFor>
                                               ($this_for_uri);
            if ($this_for-><M::ManakaiDISForDefinition.isaURI> ($forURI)) {
              $r = true;
              last;
            }
          }
        }__;
  
  @Method:
    @@Name: isSubsetOfURI
    @@Description:
      @@@lang:en
      @@@@:
        Whether this resource is a subset of another resource or not. 
    @@Param:
      @@@Name: superURI
      @@@Type: ResourceURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          Another resource URI reference to test. 
    @@Return:
      @@@Type: 
        DOMMain:boolean::ManakaiDOM:all
      @@@TrueCase:
        @@@@enDesc:
          <P::superURI> is a super-resource of this resource. 
      @@@FalseCase:
        @@@@enDesc:
          <P::superURI> is not a super-resource of this resource. 
      @@@PerlDef:
        $r = $self->{aliasURI}->{$superURI} || $self->{subOf}->{$superURI};

  @Method:
    @@Name: addSuperResource
    @@enDesc:
      Adds a <QUOTE::dis> resource to the list of super-resource 
      of this <QUOTE::dis> resource. 
    @@Param:
      @@@Name: superRes
      @@@Type: ManakaiDISResourceDefinition
      @@@enDesc:
        A <QUOTE::dis> resource definition object. 
    @@Return:
      @@@PerlDef:
        my @from = ($self->{uri},
                    grep {$self->{supOf}->{$_}} keys %{$self->{supOf}});
        my @to = ($superRes->{uri},
                  grep {$superRes->{subOf}->{$_}} keys %{$superRes->{subOf}});
        __DEEP{
          for my $from (@from) {
            for my $to (@to) {
              $self->{db}-><M::ManakaiDISDatabase.getResource>
                                      ($from)->{subOf}->{$to} = true;
              $self->{db}-><M::ManakaiDISDatabase.getResource>
                                      ($to)->{supOf}->{$from} = true;
            }
          }
        }__;

  @Attr:
    @@Name: isDefined
    @@Description:
      @@@lang:en
      @@@@:
        Whether this resource is already defined or not. 
    @@Type:
      DOMMain:boolean::ManakaiDOM:all
    @@Get:
      @@@TrueCase:
        This resource is already defined. 
      @@@FalseCase:
        This resource is not defined. 
      @@@PerlDef:
        $r = $self->{<Q::isDefined>};

  @Attr:
    @@Name: isReferred
    @@Description:
      @@@lang:en
      @@@@:
        Whether this resource is referred or not. 
    @@Type: ManakaiDISElement
    @@Get:
      @@@enDesc:
        An element that referres this resource.
      @@@nullCase:
        This resource is not referred. 
      @@@PerlDef:
        $r = $self->{<Q::isReferred>};
    @@Set:
      @@@enDesc:
        An element that referres this resource. 
      @@@PerlDef:
        $self->{<Q::isReferred>} = $given if $given;

  @Attr:
    @@Name: ownerModule
    @@ManakaiDOM:isRedefining:1
    @@Description:
      @@@lang:en
      @@@@:
        The <QUOTE::dis> module in which this resource is defined.
    @@Type: ManakaiDISModuleDefinition
    @@Get:
      @@@Description:
        @@@@lang:en
        @@@@@:
          The module object. 
      @@@nullCase:
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            This resource is not associated to any module. 
      @@@PerlDef:
        $r = $self->{db}
                  -><M::ManakaiDISDatabase.getModule>
                           ($self->{<Q::definingModule>})
           if defined $self->{<Q::definingModule>};
   
  @Method:
    @@Name: mergeAsAlias
    @@enDesc:
      Merges another resource definition as an alias of this resource. 
    @@Param:
      @@@Name: aliasResource
      @@@Type: ManakaiDISResourceDefinition
      @@@enDesc:
        A resource to merge.
        \
        {NOTE:: After merging all references to <P::aliasResource> 
                should be discarded.
        \
        }
    @@NodeParam:
    @@Return:
      @@@RaiseException:
        @@@@@:MERGE_ITSELF_ERR
        @@@@@@enDesc:
          An attempt is made to merge this resource itself. 
      @@@PerlDef:
        if ($self eq $aliasResource) {
          __EXCEPTION{MERGE_ITSELF_ERR::
            DIS:uri => {$self->{uri}},
            DIS:sourceNode => {$node},
          }__;
        }
        for my $uri ($aliasResource->{uri}, 
                     grep {$aliasResource->{aliasURI}->{$_}}
                          keys %{$aliasResource->{aliasURI}}) {
          $self->{aliasURI}->{$uri} = true;
          $self->{db}->{resDef}->{$uri} = $self;
          $self->{subOf}->{$uri} = true;
          $self->{supOf}->{$uri} = true;
        }
        for my $uri (grep {$aliasResource->{subOf}->{$_}}
                          keys %{$aliasResource->{subOf}}) {
          $self->{subOf}->{$uri} = true;
        }
        for my $uri (grep {$aliasResource->{supOf}->{$_}}
                          keys %{$aliasResource->{supOf}}) {
          $self->{supOf}->{$uri} = true;
        }
        my @from = grep {$self->{supOf}->{$_}} keys %{$self->{supOf}};
        my @to   = grep {$self->{subOf}->{$_}} keys %{$self->{subOf}};
        __DEEP{
          for my $from (@from) {
            for my $to (@to) {
              $self->{db}-><M::ManakaiDISDatabase.getResource>
                                      ($from)->{subOf}->{$to} = true;
              $self->{db}-><M::ManakaiDISDatabase.getResource>
                                      ($to)->{supOf}->{$from} = true;
            }
          }
        }__;

  @Method:
    @@Name: isTypeURI
    @@enDesc:
      Tests whether this resource is of a type or not. 
    @@Param:
      @@@Name: typeURI
      @@@Type: ResourceURI
      @@@enDesc:
        A type URI reference to test. 
    @@Return:
      @@@Type:
        DOMMain:boolean::ManakaiDOM:all 
      @@@TrueCase:
        @@@@enDesc:
          This is a <P::typeURI> resource. 
      @@@FalseCase:
        @@@@enDesc:
          This is not a <P::typeURI> resource. 
      @@@PerlDef:
        if ($self->{<Q::rdf:type>}->{$typeURI}) {
          $r = $self->{<Q::rdf:type>}->{$typeURI};
        } else {
          for my $t_type_uri (grep {$self->{<Q::rdf:type>}->{$_}}
                                   keys %{$self->{<Q::rdf:type>}}) {
            my $t_type = $self->{db}-><M::ManakaiDISDatabase.getResource>
                                                              ($t_type_uri);
            if ($t_type-><M::ManakaiDISResourceDefinition.isSubsetOfURI>
                                                              ($typeURI)) {
              $self->{<Q::rdf:type>}->{$typeURI} = $r = true;
              last;
            }
          }
        }

  @Attr:
    @@Name: plName
    @@enDesc:
      The Perl name of this resource. 
    @@Get: 
      @@@Type:
        DISLang:String::ManakaiDOM:all
      @@@enDesc:
        - <Q::ManakaiDOM:Const>::: Constant function (local) name. 
        \
        - <Q::ManakaiDOM:ConstGroup>::: Export group name (without 
                                        <CHAR::COLON> prefix).
        \
        - <Q::DISLang:Attribute>::: Method name. 
        \
        - <Q::DISLang:Method>::: Method name. 
      @@@nullCase:
        @@@@enDesc:
          Either the type of this resource is not listed above 
          or this Perl constructure is anonymous. 
      @@@RaiseException:
        @@@@@: NO_LOCAL_NAME_ERR
        @@@@enDesc:
          The type of this resource is either 
          <Q::ManakaiDOM:Const> or <Q::ManakaiDOM:ConstGroup> and 
          the local name of this resource is not defined. 
      @@@RaiseException:
        @@@@@: RESERVED_PERL_METHOD_NAME_ERR
        @@@@enDesc:
          The Perl method name constructed from the source 
          result in a reserved name. 
      @@@PerlDef:
        __DEEP{
          if (exists $self->{<Q::dis2pm:name>}) {
            $r = $self->{<Q::dis2pm:name>};
          } elsif ($self-><M::ManakaiDISResourceDefinition.isTypeURI>
                              (<Q::ManakaiDOM:Const>) or
                   $self-><M::ManakaiDISResourceDefinition.isTypeURI>
                              (<Q::ManakaiDOM:ConstGroup>)) {
            $r = uc $self->{localName};
            unless (defined $r) {
              __UNDEEP{
                __EXCEPTION{NO_LOCAL_NAME_ERR::
                  DIS:uri => {$self->{uri}},
                  DIS:sourceNode => {$self->{src}},
                }__;
              }__;
            }
            if ($r =~ /^_/ or $r =~ /_$/) {
              __UNDEEP{
                __EXCEPTION{RESERVED_PERL_METHOD_NAME_ERR::
                  DIS:uri => {$self->{uri}},
                  DIS:localName => {$self->{localName}},
                  DIS:soruceNode => {$self->{src}},
                  DIS:generatedName => {$r},
                }__;
              }__;
            }
          } elsif ($self-><M::ManakaiDISResourceDefinition.isTypeURI>
                              (<Q::DISLang:Method>) or
                   $self-><M::ManakaiDISResourceDefinition.isTypeURI>
                              (<Q::DISLang:Attribute>)) {
            if (defined $self->{localName}) {
              $r = <ClassM::ManakaiDISImplementation.camelCaseToUnderscoreName>
                                               ($self->{localName});
              if ($self-><M::ManakaiDISPropertyAccessor.getPropertyBoolean>
                                (<Q::ManakaiDOM:isForInternal>, false)) {
                $r = '_' . $r;
              }
              if ({
                    import => 1,
                    unimport => 1,
                    isa => 1,
                    can => 1,
                    new => 1,
                    as_string => 1,
                    stringify => 1,
                    clone => 1,
                  }->{$r} or $r =~ /^___/) {
                __UNDEEP{
                  __EXCEPTION{RESERVED_PERL_METHOD_NAME_ERR::
                    DIS:uri => {$self->{uri}},
                    DIS:soruceNode => {$self->{src}},
                    DIS:generatedName => {$r},
                  }__;
                }__;
              }
            } elsif (my $op_uri = $self-><AG::ManakaiDISResourceDefinition
                                                  .plMethodOperator>) {
                $r = {
                       <Q::ManakaiDOM:MUErrorHandler> => '___report_error',
                       <Q::DISPerl:AsStringMethod> => 'as_string',
                       <Q::DISPerl:NewMethod> => 'new',
                       <Q::DISPerl:CloneMethod> => 'clone',
                     }->{$op_uri};
                $r = $op_uri if $op_uri =~ /^[A-Z]+$/;
            } else {
              $r = null;
            }
          } else {
            $r = null;
          }
          $self->{<Q::dis2pm:name>} = $r;
        }__;

  @Attr:
    @@Name: plFullyQualifiedName
    @@enDesc:
      The fully-qualified Perl name of this resource. 
    @@Type:
      DISLang:String::ManakaiDOM:all
    @@Get:
      @@@enDesc:
        Fully-qualified name.
        \
        - <Q::ManakaiDOM:Class>::: Class package name. 
        \
        - <Q::ManakaiDOM:IF>::: Interface package name. 
        \
        - <Q::DISPerl:ScalarVariable>::: Variable name (without variable
                                type symbol such as <CODE::$>). 
      @@@nullCase:
        @@@@enDesc:
          Otherwise. 
      @@@NoPerlModuleNameException:
      @@@RaiseException:
        @@@@@: NO_LOCAL_NAME_ERR
        @@@@enDesc:
          The local name of this resource is not defined. 
      @@@PerlDef:
        __DEEP{
          if (exists $self->{<Q::dis2pm:name>}) {
            $r = $self->{<Q::dis2pm:name>};
          } elsif ($self-><M::ManakaiDISResourceDefinition.isTypeURI>
                              (<Q::ManakaiDOM:Class>) or
                   $self-><M::ManakaiDISResourceDefinition.isTypeURI>
                              (<Q::ManakaiDOM:IF>) or
                   $self-><M::ManakaiDISResourceDefinition.isTypeURI>
                              (<Q::DISPerl:ScalarVariable>)) {
            my $an_node = $self->{src}-><M::ManakaiDISElement.disGetAttribute>
                              (<Q::dis:AppName>, for_arg => $self->{for},
                               forp_arg => $self->{forp},
                               media_type => <Q::lang:Perl>);
            if ($an_node) {
              ## NOTE: "lang:Perl" is fully-qualified name by definition
              $r = $an_node-><M::swcfg21:SWCFGNode::swcfg21:ForLatest.value>;
            } else {
              unless (defined $self->{localName}) {
                __UNDEEP{
                  __EXCEPTION{NO_LOCAL_NAME_ERR::
                    DIS:sourceNode => {$self->{src}},
                  }__;
                }__;
              }
              if ($self-><M::ManakaiDISResourceDefinition.isTypeURI>
                              (<Q::ManakaiDOM:IF>)) {
                $r = $self-><AG::ManakaiDISResourceDefinition.ownerModule>
                          -><AG::ManakaiDISModuleDefinition.plInterfaceName>
                   . '::' . $self->{localName};
              } else {
                $r = $self-><AG::ManakaiDISResourceDefinition.ownerModule>
                          -><AG::ManakaiDISModuleDefinition.plFullyQualifiedName>
                   . '::' . $self->{localName};
              }
            }
          } else {
            $r = null;
          }
          $self->{<Q::dis2pm:name>} = $r;
        }__;

  @Attr:
    @@Name: plVariableName
    @@enDesc:
      The Perl variable name with prefix.
    @@Type:
      lang:Perl::ManakaiDOM:all
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          This resource does not define any Perl variable.
      @@@PerlDef:
        my $pnm_node = $self->{src}-><M::ManakaiDISElement.disGetAttribute>
                                (<Q::dis:AppName>, 
                                 for_arg => $self->{for},
                                 forp_arg => $self->{forp},
                                 media_type => <Q::lang:Perl>,
                                 default_media_type => <Q::lang:Perl>);
        $r = $pnm_node ? $pnm_node-><M::SWCFGNode.value> : $self->{localName};
        if (defined $r) {
          __DEEP{
            if ($self-><M::ManakaiDISPropertyAccessor.getPropertyBoolean>
                                 (<Q::DISPerl:isNamedParameter>, false)) {
              $r = '$opt{' . 
                   <ClassM::ManakaiDISImplementation.camelCaseToUnderscoreName>
                                                       ($r) .
                   '}';
            } else {
              my $dt = $self-><AG::ManakaiDISResourceDefinition
                                 .disActualDataTypeResource>;
              if ($dt-><M::ManakaiDISResourceDefinition.isSubsetOfURI>
                                                       (<Q::Perl:Array>)) {
                $r = '@' . $r;
              } elsif ($dt-><M::ManakaiDISResourceDefinition.isSubsetOfURI>
                                                       (<Q::Perl:Hash>)) {
                $r = '%' . $r;
              } else {
                $r = '$' . $r;
              }
            }
          }__;
        }

  @Attr:
    @@Name: plPrototype
    @@enDesc:
      The Perl parameter prototype character.
    @@Type:
      lang:Perl::ManakaiDOM:all
    @@Get:
      @@@PerlDef:
          __DEEP{
            my $dt = $self-><AG::ManakaiDISResourceDefinition
                                 .disActualDataTypeResource>;
            if ($dt-><M::ManakaiDISResourceDefinition.isSubsetOfURI>
                                                       (<Q::Perl:Array>)) {
              $r = '@' . $r;
            } elsif ($dt-><M::ManakaiDISResourceDefinition.isSubsetOfURI>
                                                       (<Q::Perl:Hash>)) {
              $r = '%' . $r;
            } else {
              $r = '$' . $r;
            }
          }__;

  @Attr:
    @@Name: plMethodOperator
    @@enDesc:
      The operator to overload by this method. 
    @@Type:
      DISLang:String::ManakaiDOM:all
    @@Get:
      @@@enDesc:
        The operator, either Perl <CODE::use operator> operator name
        of manakai operator URI reference. 
      @@@nullCase:
        @@@@enDesc:
          Either this resource does not define a Perl method or 
          this method does not overload any operator. 
      @@@UndeclaredPrefixException:
      @@@RaiseException:
        @@@@@: UNSUPPORTED_MEDIA_TYPE_ERR
        @@@@enDesc:
          Media type of the <Q::dis:Operator> node is not supported. 
      @@@PerlDef:
        __DEEP{
          if (exists $self->{<Q::dis:Operator>}) {
            $r = $self->{<Q::dis:Operator>};
          } else {
            my $op_node = $self->{src}-><M::ManakaiDISElement.disGetAttribute>
                             (<Q::dis:Operator>, for_arg => $self->{for},
                              forp_arg => $self->{forp});
            if ($op_node) {
              if ($op_node-><M::ManakaiDISElement.mediaTypeMatch>
                                  (<Q::lang:Perl>, for_arg => $self->{for},
                                   for_arg => $self->{forp})) {
                $r = $op_node-><M::swcfg21:SWCFGNode::swcfg21:ForLatest.value>;
              } elsif ($op_node-><M::ManakaiDISElement.mediaTypeMatch>
                                  (<Q::dis:TypeQName>, for_arg => $self->{for},
                                   for_arg => $self->{forp})) {
                $r = $op_node-><AG::ManakaiDISElement.qnameValueURI>;
              } else {
                my $ct_uri = $op_node-><M::ManakaiDISElement.mediaTypeURI>
                                     (for_arg => $self->{for},
                                      forp_arg => $self->{forp});
                __UNDEEP{
                  __EXCEPTION{UNSUPPORTED_MEDIA_TYPE_ERR::
                    DIS:uri => {$ct_uri},
                    DIS:sourceNode => {$op_node},
                  }__;
                }__;
              }
            } else {
              $r = null;
            }
            $self->{<Q::dis:Operator>} = $r;
          }
        }__;

  @Attr:
    @@Name: disDataTypeResource
    @@enDesc:
      <Q::dis:Type> attribute value of this resource. 
    @@Type: ManakaiDISResourceDefinition
    @@Get:
      @@@RaiseException:
        @@@@@:NO_DIS_TYPE_ERR
        @@@@enDesc:
          <Q::dis:Type> attribute is not specified. 
      @@@PerlDef:
        __DEEP{
          if (defined $self->{<Q::dis:Type>}) {
            $r = $self->{db}-><M::ManakaiDISDatabase.getResource>
                                               ($self->{<Q::dis:Type>});
          } else {
            $self->{<Q::dis2pm:TypeNode>}
               = $self->{src}-><M::ManakaiDISElement.disGetAttribute>
                                  (<Q::dis:Type>, for_arg => $self->{for},
                                   forp_arg => $self->{forp});
            if ($self->{<Q::dis2pm:TypeNode>}) {
              $r = $self->{<Q::dis:Type>}
                 = $self->{<Q::dis2pm:TypeNode>}
                          -><M::ManakaiDISElement.tfqnamesValueURI>
                                  (null, $self->{for});
              $r = $self->{db}-><M::ManakaiDISDatabase.getResource> ($r);
              $r-><AS::ManakaiDISResourceDefinition.isReferred>
                                 ($self->{<Q::dis2pm:TypeNode>});
            } else {
              my $pr = $self-><M::ManakaiDISPropertyAccessor
                                       .getPropertyResource>
                                          (<Q::DIS:dynamicParentResource>);
              if ($pr) {
                $r = $pr-><AG::ManakaiDISResourceDefinition
                                       .disDataTypeResource>;
                $self->{<Q::dis2pm:TypeNode>}
                     = $pr->{<Q::dis2pm:TypeNode>};
                $self->{<Q::dis:Type>}
                     = $r-><AG::ManakaiDISResourceDefinition.uri>;
              } else {  ## No parent
                __UNDEEP{
                  __EXCEPTION{NO_DIS_TYPE_ERR::
                    DIS:sourceNode => {$self->{src}},
                  }__;
                }__;
              }
            }
          }
        }__;

  @Attr:
    @@Name: disDataTypeNode
    @@enDesc:
      <Q::dis:Type> node for this resource. 
    @@Get:
      @@@Type: ManakaiDISElement
      @@@RaiseException:
        @@@@@:NO_DIS_TYPE_ERR
        @@@@enDesc:
          <Q::dis:Type> attribute is not specified.
      @@@PerlDef:
        __DEEP{
          $self-><AG::ManakaiDISResourceDefinition.disDataTypeResource>;
        }__;
        $r = $self->{<Q::dis2pm:TypeNode>};

  @Attr:
    @@Name: disActualDataTypeResource
    @@enDesc:
      <Q::dis:actualType> attribute value of this resource. 
    @@Type: ManakaiDISResourceDefinition
    @@Get:
      @@@RaiseException:
        @@@@@:NO_DIS_TYPE_ERR
        @@@@enDesc:
          <Q::dis:actualType> attribute is not specified, 
          and <Q::dis:Type> attribute, neigher. 
      @@@PerlDef:
        __DEEP{
          if (defined $self->{<Q::dis:actualType>}) {
            $r = $self->{db}-><M::ManakaiDISDatabase.getResource>
                                          ($self->{<Q::dis:actualType>});
          } else {
            $self->{<Q::dis2pm:actualTypeNode>}
               = $self->{src}-><M::ManakaiDISElement.disGetAttribute>
                                  (<Q::dis:actualType>, for_arg => $self->{for},
                                   forp_arg => $self->{forp});
            if ($self->{<Q::dis2pm:actualTypeNode>}) {
              $r = $self->{<Q::dis:actualType>}
                 = $self->{<Q::dis2pm:actualTypeNode>}
                        -><M::ManakaiDISElement.tfqnamesValueURI>
                                  (null, $self->{for});
              $r = $self->{db}-><M::ManakaiDISDatabase.getResource> ($r);
              $r-><AS::ManakaiDISResourceDefinition.isReferred>
                                 ($self->{<Q::dis2pm:actualTypeNode>});
            } elsif (defined $self->{<Q::dis:Type>}) {
              $r = $self->{<Q::dis:actualType>} = $self->{<Q::dis:Type>};
              $self->{<Q::dis2pm:actualTypeNode>}
                            = $self->{<Q::dis2pm:TypeNode>};
              $r = $self->{db}-><M::ManakaiDISDatabase.getResource> ($r);
            } else {
              $self->{<Q::dis2pm:actualTypeNode>}
                 = $self->{<Q::dis2pm:TypeNode>}
                 = $self->{src}-><M::ManakaiDISElement.disGetAttribute>
                                  (<Q::dis:Type>, for_arg => $self->{for},
                                   forp_arg => $self->{forp});
              if ($self->{<Q::dis2pm:TypeNode>}) {
                $r = $self->{<Q::dis:actualType>}
                   = $self->{<Q::dis:Type>}
                   = $self->{<Q::dis2pm:TypeNode>}
                          -><M::ManakaiDISElement.tfqnamesValueURI>
                                  (null, $self->{for});
                $r = $self->{db}-><M::ManakaiDISDatabase.getResource> ($r);
                $r-><AS::ManakaiDISResourceDefinition.isReferred>
                                 ($self->{<Q::dis2pm:actualTypeNode>});
              } else {
                my $pr = $self-><M::ManakaiDISPropertyAccessor
                                       .getPropertyResource>
                                          (<Q::DIS:dynamicParentResource>);
                if ($pr) {
                  $r = $pr-><AG::ManakaiDISResourceDefinition
                                       .disActualDataTypeResource>;
                  $self->{<Q::dis2pm:actualTypeNode>}
                     = $pr->{<Q::dis2pm:actualTypeNode>};
                  $self->{<Q::dis:actualType>}
                      = $r-><AG::ManakaiDISResourceDefinition.uri>;
                } else {  ## No parent
                  __UNDEEP{
                    __EXCEPTION{NO_DIS_TYPE_ERR::
                      DIS:sourceNode => {$self->{src}},
                    }__;
                  }__;
                }
              }
            }
          }
        }__;

  @Attr:
    @@Name: disActualDataTypeNode
    @@enDesc:
      <Q::dis:actualType> node for this resource. 
    @@Get:
      @@@Type: ManakaiDISElement
      @@@RaiseException:
        @@@@@:NO_DIS_TYPE_ERR
        @@@@enDesc:
          <Q::dis:actualType> attribute is not specified, 
          and <Q::dis:Type> attribute, neigher. 
      @@@PerlDef:
        __DEEP{
          $self-><AG::ManakaiDISResourceDefinition.disActualDataTypeResource>;
        }__;
        $r = $self->{<Q::dis2pm:actualTypeNode>};

  @IntMethod:
    @@Operator:
      @@@@: <=>
      @@@ContentType:
        lang:Perl
    @@enDesc:
      Which is greater (i.e. the spaceship operator). 
      A resource is less than another if it is loaded by
      <M::ManakaiDISDatabase.loadResource> before another is loaded. 
      Order for non-loaded resource definitions are not defined. 
      \
      {NOTE:: In the current implementation, non-loaded resources 
              are less than any loaded resource and the order in 
              non-loaded resources is unknown. 
      \
      }
    @@Param:
      @@@Name: anotherResource
      @@@Type: ManakaiDISResourceDefinition
      @@@enDesc: Another resource to compare.
    @@Return:
      @@@Type:
        DOMMain:unsigned-long::ManakaiDOM:all
      @@@PerlDef:
        if (UNIVERSAL::isa ($anotherResource,
                            <ClassName::ManakaiDISResourceDefinition>)) {
          $r = $self->{seq} <=> $anotherResource->{seq};
        } else {
          $r = overload::Overloaded ($self) <=> $anotherResource;
        }

  @Attr:
    @@Name: plCodeFragment
    @@enDesc:
      Perl code definition fragment of this resource. 
    @@Type: MPLCodeFragment
    @@Get:
      @@@enDesc:
        Perl code.
      @@@nullCase:
        @@@@enDesc:
          This node does not have Perl code definition. 
      @@@RaiseException:
        @@@@@:NO_METHOD_RETURN_ERR
        @@@@enDesc:
          This resource is a <Q::DISLang:Method> but it does not 
          have <Q::DISLang:MethodReturn> child-resource. 
      @@@RaiseException:
        @@@@@:NO_ATTR_GET_ERR
        @@@@enDesc:
          This resource is a <Q::DISLang:Attribute> but it does not 
          have <Q::DISLang:AttributeGet> child-resource.
      @@@RaiseException:
        @@@@@:UNSUPPORTED_MEDIA_TYPE_ERR
        @@@@enDesc:
          The media type of <Q::dis:Def> element is not supported.
      @@@RaiseException:
        @@@@@: NON_NAMED_PARAMETER_AFTER_NAMED_ERR
        @@@@enDesc:
          A non-named method paarameter is defined after
          a named method parameter appeared.
      @@@disPerlException:
      @@@InlineElementException:
      @@@BlockElementException:
      @@@RaiseException:
        @@@@@:PERL_SUBROUTINE_ALREADY_DEFINED_ERR
        @@@@enDesc:
          A resource defines a Perl subroutine whose name is
          same as the name of another subroutine. 
      @@@RaiseException:
        @@@@@:PERL_OPERATOR_ALREADY_OVERLOADED_ERR
        @@@@enDesc:
          A resource is defined to overload an operator 
          that is also defined to be overloaded by another resource.
      @@@RaiseException:
        @@@@@:PERL_UNUSED_SUBROUTINE_ERR
        @@@@enDesc:
          A resource defines a Perl subroutine which is not
          used anywhere.
      @@@PerlDef:
        __DEEP{
          if (exists $self->{<Q::plCodeFragment>}) {
            $r = $self->{<Q::plCodeFragment>};
          } elsif (not $self->{src}) {
            $r = $self->{<Q::plCodeFragment>} = null;
          } elsif ($self-><M::ManakaiDISResourceDefinition.isTypeURI>
                                (<Q::DISLang:MethodReturn>) or
                   $self-><M::ManakaiDISResourceDefinition.isTypeURI>
                                (<Q::DISLang:AttributeGet>) or
                   $self-><M::ManakaiDISResourceDefinition.isTypeURI>
                                (<Q::DISLang:AttributeSet>) or
                   $self-><M::ManakaiDISResourceDefinition.isTypeURI>
                                (<Q::dis2pm:BlockCode>) or
                   $self-><M::ManakaiDISResourceDefinition.isTypeURI>
                                (<Q::dis2pm:InlineCode>) or
                   $self-><M::ManakaiDISResourceDefinition.isTypeURI>
                                (<Q::DISLang:InputProcessor>)) {
            $self->{<Q::plCodeFragment>} = null;  ## To avoid loop
            my $def = $self->{src}-><M::ManakaiDISElement.disGetAttribute>
                                (<Q::dis:Def>, for_arg => $self->{for},
                                 forp_arg => $self->{forp});
            my $is_inline = $self-><M::ManakaiDISResourceDefinition.isTypeURI>
                                (<Q::dis2pm:InlineCode>) ? true : false;
            unless ($def) {
              $r = null;
            } elsif ($def-><M::ManakaiDISElement.mediaTypeMatch>
                                                         (<Q::lang:Perl>)) {
              my $source_code = $def-><M::swcfg21:SWCFGNode
                                        ::swcfg21:ForLatest.value>; 
              $r = $self->{<Q::plCodeFragment>}
                 = $is_inline
                     ? $self-><M::ManakaiDISResourceDefinition
                             .plPreprocessPerlStatement>
                                           ($source_code,
                                            node => $def,
                                            contains_statements => false)
                     : $self-><M::ManakaiDISResourceDefinition
                             .plPreprocessPerlCode> ($source_code,
                                                     node => $def);
            } elsif ($def-><M::ManakaiDISElement.mediaTypeMatch>
                                                         (<Q::lang:dis>)) {
              $r = $self->{<Q::plCodeFragment>}
                 = $def-><M::ManakaiDISElement.plCodeFragment>
                            ($self, for_arg => $self->{for},
                             forp_arg => $self->{forp},
                             contains_statements => not $is_inline); 
            } else {
              my $mt = $def-><M::ManakaiDISElement.mediaTypeURI>
                                   (for_arg => $self->{for},
                                    forp_arg => $self->{forp});
              __UNDEEP{
                __EXCEPTION{UNSUPPORTED_MEDIA_TYPE_ERR::
                  DIS:uri => {$mt},
                  DIS:sourceNode => {$def},
                }__;
              }__;
            } # media type
          } elsif ($self-><M::ManakaiDISResourceDefinition.isTypeURI>
                                (<Q::DISLang:Method>)) {
            $self->{<Q::plCodeFragment>} = null;  ## To avoid loop
            my $ret = $self-><M::ManakaiDISResourceDefinition
                            .getChildResourceByType> (<Q::DISLang:MethodReturn>);
            unless ($ret) { 
              __UNDEEP{
                __EXCEPTION{NO_METHOD_RETURN_ERR::
                  DIS:errResource => {$self},
                  DIS:sourceNode => {$self->{src}},
                  DIS:uri => {$self->{uri}},
                  DIS:localName => {$self->{localName}},
                }__;
              }__;
            }
            my $plimpl = $self-><AG::ManakaiDISPropertyAccessor
                                                       .plImplementation>;
            $r = $self->{<Q::plCodeFragment>}
               = $plimpl-><M::MPLImpl.createPerlSub>
                            ($self-><AG::ManakaiDISResourceDefinition.plName>);
            
            ## Method parameters
            my $params = $self-><M::ManakaiDISPropertyAccessor
                                   .getPropertyResourceList>
                                        (<Q::DIS:childResource>);
            my @param_variables;
            my @named_param_variables;
            my $prototype = '$';
            my $is_optional_param = false;
            my $is_named_param = false;
            for my $param (@$params) {
              next unless $param-><M::ManakaiDISResourceDefinition.isTypeURI>
                                        (<Q::DISLang:MethodParameter>);
              unless ($is_named_param) {
                if ($param-><M::ManakaiDISPropertyAccessor.getPropertyBoolean>
                                 (<Q::DISPerl:isNamedParameter>, false)) {
                  $is_named_param = true;
                  $is_optional_param = true;
                  push @param_variables, ['%opt'];
                  $prototype .= '%';
                } else {  ## Non-named parameter
                  push @param_variables, [
                    $param-><AG::ManakaiDISResourceDefinition.plVariableName>,
                  ];
                  if ($param-><AG::ManakaiDISResourceDefinition.plIsNullable>) {
                    $prototype .= ';' unless $is_optional_param;
                    $is_optional_param = true;
                  }
                  $prototype .= $param-><AG::ManakaiDISResourceDefinition
                                                   .plPrototype>;
                  my $param_processor
                        = $param-><M::ManakaiDISResourceDefinition
                                                 .plGetMethodInputNormalizer>;
                  if ($param_processor) {
                    $param_variables[-1]->[1]
                        = $param_processor-><AG::ManakaiDISResourceDefinition
                                                 .plCodeFragment>->clone;
                    $param_variables[-1]->[1]
                                   -><M::MPLCodeFragment.replaceVariable>
                                         ('$INPUT' => $param_variables[-1]->[0]);
                  }
                }
              } else { ## Named parameter
                unless ($param-><M::ManakaiDISPropertyAccessor
                                   .getPropertyBoolean>
                                      (<Q::DISPerl:isNamedParameter>, false)) {
                  __UNDEEP{__EXCEPTION{NON_NAMED_PARAMETER_AFTER_NAMED_ERR::
                    DIS:sourceNode => {$param->{src}},
                    DIS:uri => {$param->{uri}},
                    DIS:localName => {$param->{localName}},
                  }__}__;
                }
              }
              if ($is_named_param) {
                push @named_param_variables, [
                  $param-><AG::ManakaiDISResourceDefinition.plVariableName>,
                  null,
                  '$' . $param-><AG::ManakaiDISResourceDefinition.localName>,
                ];
                my $param_processor
                        = $param-><M::ManakaiDISResourceDefinition
                                                 .plGetMethodInputNormalizer>;
                if ($param_processor) {
                  $named_param_variables[-1]->[1]
                        = $param_processor-><AG::ManakaiDISResourceDefinition
                                                 .plCodeFragment>->clone;
                  $named_param_variables[-1]->[1]
                                   -><M::MPLCodeFragment.replaceVariable>
                                         ('$INPUT' => $param_variables[-1]->[0]);
                }
              }
            } # %$params
            
            $r-><AS::MPLSub.prototype> ($prototype);
            $r-><M::MPLSS.appendCodeFragment>
                   ($plimpl-><M::MPLImpl.createPerlStatement>
                          ('my (' . join (', ', '$self',
                             map {$_->[0]} @param_variables) . ') = @_'));
            for my $p (@param_variables, @named_param_variables) {
              if ($p->[1]) {  ## Input processor
                $r-><M::MPLSS.appendCodeFragment> ($p->[1]);
              }
            }
 
            ## TODO: in/out
            
            ## Return value
            my $data_type;
            try {
              $data_type = $ret-><AG::ManakaiDISResourceDefinition
                                     .disActualDataTypeResource>;
            } catch <Class::ManakaiDISException> with {
              my $err = shift;
              if ($err->{<Q::MDOMX:subtype>} ne <Q::NO_DIS_TYPE_ERR>) {
                $err->throw;
              }
            };

            if ($data_type) {
              my $def = $ret->{src}-><M::ManakaiDISElement
                                          .plValueCodeFragment>
                            (<Q::dis:DefaultValue>, $self,
                             for_arg => $self->{for},
                             forp_arg => $self->{forp},
                             use_default_value => true,
                             data_type_uri => $data_type
                                    -><AG::ManakaiDISResourceDefinition.uri>);
              my $rs = $plimpl-><M::MPLImpl.createPerlStatement>;
              my $rvar = $plimpl-><M::MPLImpl.createPerlVariable>
                                               ('$', null, 'r');
              $rvar-><AS::PerlCode:ManakaiPerlVariable::ManakaiDOM:Perl
                               .variableScope> ('my');
              if ($def) {
                $rs-><M::PLAnyCon.appendNewAssignment> ($rvar => $def);
              } else {
                $rs-><M::PLInCon.appendCodeFragment> ($rvar);
              }
              $r-><M::MPLSS.appendCodeFragment> ($rs);
            }

            my $code = $ret-><AG::ManakaiDISResourceDefinition.plCodeFragment>;
            if ($code) {
              for my $np (@named_param_variables) {
                $code-><M::MPLCodeFragment.replaceVariable>
                             ($np->[2] => $np->[0]);
              }
              $r-><M::MPLSS.appendCodeFragment> ($code);

              $ret->{<Q::DIS:plDefined>} = true;
              $self->{<Q::DIS:plDefined>} = true;
            } else {  ## Method code not defined
              my $cls = $self->{db}-><M::ManakaiDISDatabase.getResource>
                                              (<Q::DOMException:CoreException>,
                                               for_arg => <Q::ManakaiDOM:Perl>);
              my $const = $self->{db}-><M::ManakaiDISDatabase.getResource>
                                          (<Q::DOMException:NOT_SUPPROTED_ERR>,
                                               for_arg => <Q::ManakaiDOM:Perl>);
              my $subtype = $self->{db}-><M::ManakaiDISDatabase.getResource>
                                  (<Q::MDOMX:MDOM_IMPL_METHOD_NOT_IMPLEMENTED>,
                                               for_arg => <Q::ManakaiDOM:Perl>);
              $_-><AS::ManakaiDISResourceDefinition.isReferred>
                               ($ret->{src}) for $cls, $const, $subtype;
              my $context_param = $ret-><M::ManakaiDISResourceDefinition
                                             .plGetContextParameter>;
              $self-><M::ManakaiDISResourceDefinition
                            .plAppendThrow>
                               ($r, $cls, $const, $subtype,
                                {%$context_param});
              $ret->{<Q::DIS:plDefined>} = false;
              $self->{<Q::DIS:plDefined>} = false;
            }

            if ($data_type) {
              $r-><M::MPLSS.appendCodeFragment>
                     ($plimpl-><M::MPLImpl.createPerlVariable>
                                               ('$', null, 'r'));
            }
          } elsif ($self-><M::ManakaiDISResourceDefinition.isTypeURI>
                                (<Q::DISLang:Attribute>)) {  
            $self->{<Q::plCodeFragment>} = null;  ## To avoid loop
            my $get = $self-><M::ManakaiDISResourceDefinition
                            .getChildResourceByType> (<Q::DISLang:AttributeGet>);
            unless ($get) { 
              __UNDEEP{
                __EXCEPTION{NO_ATTR_GET_ERR::
                  DIS:errResource => {$self},
                  DIS:sourceNode => {$self->{src}},
                }__;
              }__;
            }
            my $plimpl = $self-><AG::ManakaiDISPropertyAccessor
                                                       .plImplementation>;
            my $data_type = $get-><AG::ManakaiDISResourceDefinition
                                      .disActualDataTypeResource>;
            my $get_code = $plimpl-><M::MPLImpl.createPerlBlockContainer>;
            $get_code-><M::PLBlockCon.appendStatement> (q<my ($self) = @_>);
            my $code = $get-><AG::ManakaiDISResourceDefinition.plCodeFragment>;
            if ($code) {
              ## Default value
              my $def = $get->{src}-><M::ManakaiDISElement
                                        .plValueCodeFragment>
                            (<Q::dis:DefaultValue>, $self,
                             for_arg => $self->{for},
                             forp_arg => $self->{forp},
                             use_default_value => true,
                             data_type_uri => $data_type
                                    -><AG::ManakaiDISResourceDefinition.uri>);
              my $rs = $plimpl-><M::MPLImpl.createPerlStatement>;
              my $rvar = $plimpl-><M::MPLImpl.createPerlVariable>
                                               ('$', null, 'r');
              $rvar-><AS::PerlCode:ManakaiPerlVariable::ManakaiDOM:Perl
                                 .variableScope> ('my');
              if ($def) {
                $rs-><M::PLAnyCon.appendNewAssignment> ($rvar => $def);
              } else {
                $rs-><M::PLInCon.appendCodeFragment> ($rvar);
              }
              $get_code-><M::PLBlockCon.appendCodeFragment> ($rs);

              ## Main code
              $get_code-><M::PLBlockCon.appendCodeFragment> ($code);

              ## Return value
              $get_code-><M::PLBlockCon.appendStatement> (q<$r>);

              $get->{<Q::DIS:plDefined>} = true;
            } else {  ## Getter code not defined
              my $cls = $self->{db}-><M::ManakaiDISDatabase.getResource>
                                              (<Q::DOMException:CoreException>,
                                               for_arg => <Q::ManakaiDOM:Perl>);
              my $const = $self->{db}-><M::ManakaiDISDatabase.getResource>
                                          (<Q::DOMException:NOT_SUPPROTED_ERR>,
                                               for_arg => <Q::ManakaiDOM:Perl>);
              my $subtype = $self->{db}-><M::ManakaiDISDatabase.getResource>
                                    (<Q::MDOMX:MDOM_IMPL_ATTR_NOT_IMPLEMENTED>,
                                               for_arg => <Q::ManakaiDOM:Perl>);
              $_-><AS::ManakaiDISResourceDefinition.isReferred>
                               ($get->{src}) for $cls, $const, $subtype;
              my $context_param = $get-><M::ManakaiDISResourceDefinition
                                        .plGetContextParameter>;
              $self-><M::ManakaiDISResourceDefinition
                            .plAppendThrow>
                               ($get_code, $cls, $const, $subtype,
                                {%$context_param});
              $get->{<Q::DIS:plDefined>} = false;
              $self->{<Q::DIS:plDefined>} = false;
            }

            my $set = $self-><M::ManakaiDISResourceDefinition
                            .getChildResourceByType> (<Q::DISLang:AttributeSet>);
            my $set_code = $plimpl-><M::MPLImpl.createPerlBlockContainer>;
            if ($set) {
              my $data_type = $set-><AG::ManakaiDISResourceDefinition
                                       .disActualDataTypeResource>;
              my $code = $set-><AG::ManakaiDISResourceDefinition.plCodeFragment>;
              if ($code) {
                ## Input
                $set_code-><M::PLBlockCon.appendStatement>
                              (q<my ($self, $given) = @_>);
                my $param_processor
                        = $set-><M::ManakaiDISResourceDefinition
                                                 .plGetMethodInputNormalizer>;
                if ($param_processor) {
                  my $pcode = $param_processor-><AG::ManakaiDISResourceDefinition
                                                    .plCodeFragment>->clone;
                  $pcode-><M::MPLCodeFragment.replaceVariable>
                                                   ('$INPUT' => '$given');
                  $set_code-><M::PLBlockCon.appendCodeFragment> ($pcode);
                }

                ## Main code
                $set_code-><M::PLBlockCon.appendCodeFragment> ($code);

                $set->{<Q::DIS:plDefined>} = true;
                $self->{<Q::DIS:plDefined>} = $get->{<Q::DIS:plDefined>};
              } else { ## Setter code not defined
                $set_code-><M::PLBlockCon.appendStatement> (q<my ($self) = @_>);
                my $cls = $self->{db}-><M::ManakaiDISDatabase.getResource>
                                              (<Q::DOMException:CoreException>,
                                               for_arg => <Q::ManakaiDOM:Perl>);
                my $const = $self->{db}-><M::ManakaiDISDatabase.getResource>
                                          (<Q::DOMException:NOT_SUPPROTED_ERR>,
                                               for_arg => <Q::ManakaiDOM:Perl>);
                my $subtype = $self->{db}-><M::ManakaiDISDatabase.getResource>
                                    (<Q::MDOMX:MDOM_IMPL_ATTR_NOT_IMPLEMENTED>,
                                               for_arg => <Q::ManakaiDOM:Perl>);
                $_-><AS::ManakaiDISResourceDefinition.isReferred>
                               ($set->{src}) for $cls, $const, $subtype;
                my $context_param = $get-><M::ManakaiDISResourceDefinition
                                             .plGetContextParameter>;
                $self-><M::ManakaiDISResourceDefinition
                            .plAppendThrow>
                               ($set_code, $cls, $const, $subtype,
                                {%$context_param});
              }
              $set->{<Q::DIS:plDefined>} = false;
              $self->{<Q::DIS:plDefined>} = false;
            } else {  ## No attribute setter
              $set_code-><M::PLBlockCon.appendStatement> (q<my ($self) = @_>);
              my $cls = $self->{db}-><M::ManakaiDISDatabase.getResource>
                                              (<Q::DOMException:CoreException>,
                                               for_arg => <Q::ManakaiDOM:Perl>);
              my $const = $self->{db}-><M::ManakaiDISDatabase.getResource>
                                (<Q::DOMException:NO_MODIFICATION_ALLOWED_ERR>,
                                               for_arg => <Q::ManakaiDOM:Perl>);
              my $subtype = $self->{db}-><M::ManakaiDISDatabase.getResource>
                                    (<Q::DOMException:READ_ONLY_ATTRIBUTE_ERR>,
                                               for_arg => <Q::ManakaiDOM:Perl>);
              $_-><AS::ManakaiDISResourceDefinition.isReferred>
                               ($self->{src}) for $cls, $const, $subtype;
              my $context_param = $get-><M::ManakaiDISResourceDefinition
                                        .plGetContextParameter>;
              $self-><M::ManakaiDISResourceDefinition
                            .plAppendThrow>
                               ($set_code, $cls, $const, $subtype,
                                {%$context_param});
              $self->{<Q::DIS:plDefined>} = $get->{<Q::DIS:plDefined>};
            }

            $r = $self->{<Q::plCodeFragment>}
               = $plimpl-><M::MPLImpl.createPerlSub>
                            ($self-><AG::ManakaiDISResourceDefinition.plName>);
            $r-><AS::MPLSub.prototype> (q<$;$>);

            ## TODO: Don't output "if" if non-debug build
            
            $r-><M::PLBlockCon.appendNewIf>
                     ($plimpl-><M::MPLImpl.createPerlInlineUnparsedCode>
                                        (q<@_ == 1>),
                      $get_code,
                      $set_code);
          } elsif ($self-><M::ManakaiDISResourceDefinition.isTypeURI>
                              (<Q::ManakaiDOM:Const>)) {
            my $data_type = $self-><AG::ManakaiDISResourceDefinition
                                       .disActualDataTypeResource>;
            my $value = $self->{src}
                             -><M::ManakaiDISElement.plValueCodeFragment>
                              (<Q::dis:Value>, $self,
                               for_arg => $self->{for},
                               forp_arg => $self->{forp},
                               data_type_uri => $data_type
                                    -><AG::ManakaiDISResourceDefinition.uri>);
            my $plimpl = $self-><AG::ManakaiDISPropertyAccessor
                                                       .plImplementation>;
            $r = $plimpl-><M::MPLImpl.createPerlSub>
                            ($self-><AG::ManakaiDISResourceDefinition.plName>);
            $r-><M::PLBlockCon.appendCodeFragment> ($value);
            $r-><AS::MPLSub.prototype> ('');
          } elsif ($self-><M::ManakaiDISResourceDefinition.isTypeURI>
                              (<Q::ManakaiDOM:Class>)) {
            my $plimpl = $self-><AG::ManakaiDISPropertyAccessor
                                                       .plImplementation>;
            $r = $plimpl-><M::MPLImpl.createPerlPackage>
                              ($self-><AG::ManakaiDISResourceDefinition
                                         .plFullyQualifiedName>);
            ## This class inherits...
            for my $scls (@{$self-><M::ManakaiDISPropertyAccessor
                                         .getPropertyResourceList>
                                    (<Q::dis:ISA>,
                                     default_media_type => <Q::dis:TFQNames>)}) {
              my $spack_name = $scls-><AG::ManakaiDISResourceDefinition
                                         .plFullyQualifiedName>;
              if (defined $spack_name) {
                $r-><M::PLPack.addISAPackage> ($spack_name);
              }
              $self-><M::ManakaiDISResourceDefinition.plAddRequireResource>
                          ($scls => $r);
            }
            ## This class implements...
            for my $scls (@{$self-><M::ManakaiDISPropertyAccessor
                                         .getPropertyResourceList>
                                    (<Q::dis:Implement>, recursive_isa => true,
                                     default_media_type => <Q::dis:TFQNames>)}) {
              my $spack_name = $scls-><AG::ManakaiDISResourceDefinition
                                         .plFullyQualifiedName>;
              if (defined $spack_name) {
                $r-><M::PLPack.addImplementPackage> ($spack_name);
              }
            }
    
            ## Class members
            my @cr = @{$self-><M::ManakaiDISPropertyAccessor
                                         .getPropertyResourceList>
                                    (<Q::DIS:childResource>)};
            my @const;
            for my $cr (@cr) {
              if ($cr-><M::ManakaiDISResourceDefinition.isTypeURI>
                                    (<Q::DISLang:Method>) or
                  $cr-><M::ManakaiDISResourceDefinition.isTypeURI>
                                    (<Q::DISLang:Attribute>)) {
                my $is_attr = $cr-><M::ManakaiDISResourceDefinition.isTypeURI>
                                    (<Q::DISLang:Attribute>) ? true : false;
                my $pname = $cr-><AG::ManakaiDISResourceDefinition.plName>;
                my $op = $cr-><AG::ManakaiDISResourceDefinition
                                  .plMethodOperator>;
                my $psub = $cr-><AG::ManakaiDISResourceDefinition
                                  .plCodeFragment>;
                if (defined $pname) {
                  if ($r-><M::PLPack.getSub> ($pname)) {
                    __UNDEEP{__EXCEPTION{PERL_SUBROUTINE_ALREADY_DEFINED_ERR::
                      PerlCode:localName => {$pname},
                      DIS:uri => {$cr->{uri}},
                      DIS:sourceNode => {$cr->{src}},
                    }__}__;
                  }
                  $r-><M::PLPack.setSub> ($pname => $psub);
          
                  if (defined $op and not $cr-><AG::ManakaiDISResourceDefinition
                                                   .isAnonymous>) {
                    if ($op =~ /^[A-Z]+$/) {
                      if ($r-><M::PLPack.getSubAliasName> ($op)) {
                        __UNDEEP{__EXCEPTION{
                          PERL_SUBROUTINE_ALREADY_DEFINED_ERR::
                            PerlCode:localName => {$op},
                            DIS:uri => {$cr->{uri}},
                            DIS:sourceNode => {$cr->{src}},
                        }__}__;
                      }
                      $r-><M::PLPack.setSubAliasName> ($op => $pname);
                    } else {
                      if ($r-><M::PLPack.getOverloadMethodName> ($op)) {
                        __UNDEEP{__EXCEPTION{
                          PERL_OPERATOR_ALREADY_OVERLOADED_ERR::
                            PerlCode:operator => {$op},
                            DIS:uri => {$cr->{uri}},
                            DIS:sourceNode => {$cr->{src}},
                        }__}__;
                      }
                      $r-><M::PLPack.setOverloadMethodName> ($op => $pname);
                    }
                  }
                } elsif (defined $op) {
                  $r-><M::PLPack.setOverloadSub> ($op => $psub);
                } else {
                  __UNDEEP{__EXCEPTION{PERL_UNUSED_SUBROUTINE_ERR::
                    DIS:uri => {$cr->{uri}},
                    DIS:sourceNode => {$cr->{src}},
                  }__}__;
                }
              } elsif ($cr-><M::ManakaiDISResourceDefinition.isTypeURI>
                                (<Q::ManakaiDOM:ConstGroup>)) {
                for my $gcr (@{$cr-><M::ManakaiDISPropertyAccessor
                                         .getPropertyResourceList>
                                    (<Q::DIS:childResource>)}) {
                  if ($gcr-><M::ManakaiDISResourceDefinition.isTypeURI>
                                (<Q::ManakaiDOM:Const>)) {
                    my $sub = $gcr-><AG::ManakaiDISResourceDefinition
                                        .plCodeFragment>;
                    if ($r-><M::PLPack.getSub> ($sub-><AG::MPLSub.localName>)) {
                      __UNDEEP{__EXCEPTION{
                          PERL_SUBROUTINE_ALREADY_DEFINED_ERR::
                            PerlCode:localName => {$sub-><AG::MPLSub.localName>},
                            DIS:uri => {$gcr->{uri}},
                            DIS:sourceNode => {$gcr->{src}},
                      }__}__;
                    }
                    $r-><M::PLPack.setSub>
                             ($sub-><AG::MPLSub.localName> => $sub);
                    push @const, $gcr;
                  }
                }
              } elsif ($cr-><M::ManakaiDISResourceDefinition.isTypeURI>
                                (<Q::ManakaiDOM:Const>)) {
                my $sub = $cr-><AG::ManakaiDISResourceDefinition.plCodeFragment>;
                if ($r-><M::PLPack.getSub> ($sub-><AG::MPLSub.localName>)) {
                  __UNDEEP{__EXCEPTION{
                          PERL_SUBROUTINE_ALREADY_DEFINED_ERR::
                            PerlCode:localName => {$sub-><AG::MPLSub.localName>},
                            DIS:uri => {$cr->{uri}},
                            DIS:sourceNode => {$cr->{src}},
                  }__}__;
                }
                $r-><M::PLPack.setSub> ($sub-><AG::MPLSub.localName> => $sub);
                push @const, $cr;
              } elsif ($cr-><M::ManakaiDISResourceDefinition.isTypeURI>
                                (<Q::DISPerl:ScalarVariable>)) {
                my $varn = $cr-><AG::ManakaiDISResourceDefinition
                                                           .plVariableName>;
                my $var = $plimpl-><M::MPLImpl.createPerlVariable>
                                                       (null, null, $varn);
                my $data_type = $cr-><AG::ManakaiDISResourceDefinition
                                           .disActualDataTypeResource>;
                my $value = $cr->{src}
                             -><M::ManakaiDISElement.plValueCodeFragment>
                              (<Q::dis:DefaultValue>, $cr,
                               for_arg => $cr->{for},
                               forp_arg => $cr->{forp},
                               use_default_value => true,
                               data_type_uri => $data_type
                                    -><AG::ManakaiDISResourceDefinition.uri>);
                if ($cr-><M::ManakaiDISPropertyAccessor.getPropertyBoolean>
                              (<Q::DISPerl:defaultValueHasSelfReference>)) {
                  $r-><M::PLBlockCon.appendStatement>
                    -><M::PLBlockCon.appendCodeFragment> (my $v = $var->clone);
                  $v-><AS::PerlCode:ManakaiPerlVariable::ManakaiDOM:Perl
                                                     .variableScope> ('our');
                } else {
                  $var-><AS::PerlCode:ManakaiPerlVariable::ManakaiDOM:Perl
                                                     .variableScope> ('our');
                }
                $r-><M::PLBlockCon.appendStatement>
                  -><M::PLAnyCon.appendNewAssignment> ($var => $value);
              } # Type of child resources
            }

            if ($self-><M::ManakaiDISResourceDefinition.isTypeURI>
                             (<Q::DOMException:AnyExceptionClass>)) {
              my $err_def = $plimpl-><M::MPLImpl.createPerlSub> ('___error_def');
              $err_def-><AS::MPLSub.prototype> ('');
              $err_def-><M::PLBlockCon.appendCode>
                 ($plimpl-><M::MPLImpl.perlList>
                   ([{
                       map {
                         $_-><AG::ManakaiDISResourceDefinition.plName> => {
                           <Q::DOMCore:code> => 0 + $_
                             -><AG::ManakaiDISResourceDefinition.plCodeFragment>,
                           description => $_
                       -><AG::ManakaiDISResourceDefinition.plMufDescriptionText>,
#                           ($_->{ExpandedURI q< DOMCore:severity>}
#                              ? (ExpandedURI q< DOMCore:severity>
#                                      => $_->{ExpandedURI q< DOMCore:severity>},
#                                 ExpandedURI q< DOMCore:type>
#                                       => $_->{ExpandedURI q< DOMCore:type>})
#                                    : ()),
                           <Q::MDOMX:subtype> => {
                             map {
                               $_-><AG::ManakaiDISResourceDefinition.nameURI>
                               => {
                                 description => $_
                       -><AG::ManakaiDISResourceDefinition.plMufDescriptionText>,
#                                 ($_->{ExpandedURI q< DOMCore:severity>}
#                                    ? (ExpandedURI q< DOMCore:severity>
#                                      => $_->{ExpandedURI q< DOMCore:severity>},
#                                       ExpandedURI q< DOMCore:type>
#                                       => $_->{ExpandedURI q< DOMCore:type>})
#                                    : ()),
                               },
                             } grep {
                               $_-><M::ManakaiDISResourceDefinition.isTypeURI>
                                    (<Q::ManakaiDOM:ExceptionOrWarningSubType>)
                             } @{$_-><M::ManakaiDISPropertyAccessor
                                         .getPropertyResourceList>
                                    (<Q::DIS:childResource>)}
                           },
                         },
                       } @const
                    }]));
              $r-><M::PLPack.setSub> (___error_def => $err_def);
            }
          } elsif ($self-><M::ManakaiDISResourceDefinition.isTypeURI>
                                     (<Q::DISPerl:ScalarVariable>)) {
            my $plimpl = $self-><AG::ManakaiDISPropertyAccessor
                                                       .plImplementation>;
            my $varn = $self-><AG::ManakaiDISResourceDefinition.plVariableName>;
            my $var = $plimpl-><M::MPLImpl.createPerlVariable>
                                                       (null, null, $varn);
            my $data_type = $self-><AG::ManakaiDISResourceDefinition
                                       .disActualDataTypeResource>;
            my $value = $self->{src}
                             -><M::ManakaiDISElement.plValueCodeFragment>
                              (<Q::dis:DefaultValue>, $self,
                               for_arg => $self->{for},
                               forp_arg => $self->{forp},
                               use_default_value => true,
                               data_type_uri => $data_type
                                    -><AG::ManakaiDISResourceDefinition.uri>);
            $r = $plimpl-><M::MPLImpl.createPerlStatement>;
            $r-><M::PLAnyCon.appendNewAssignment> ($var => $value);
          } else {  ## Not supported
            $r = $self->{<Q::plCodeFragment>} = null;
          } # rdf:type
        }__;

  @Method:
    @@Name: getChildResourceByType
    @@enDesc:
      Gets a static child resource selected by its type. 
    @@Param:
      @@@Name:typeURI
      @@@Type:ResourceURI
      @@@enDesc:
        A URI reference identifying a resource type. 
    @@Return:
      @@@Type: ManakaiDISResourceDefinition
      @@@enDesc:
        The first (by document order) child resource whose 
        type matches with <P::resType>. 
      @@@nullCase:
        @@@@enDesc:
          There is no resource whose type is <P::resType>.
      @@@PerlDef:
        __DEEP{
          for my $cr_uri (@{$self->{<Q::DIS:childResource>}}) {
            my $cr = $self->{db}-><M::ManakaiDISDatabase.getResource>
                                             ($cr_uri);
            if ($cr-><M::ManakaiDISResourceDefinition.isTypeURI> ($typeURI)) {
              $r = $cr;
              last;
            }
          }
        }__;

  @Method:
    @@Name: getChildResourceByNameAndType
    @@enDesc:
      Gets a static child resource selected by its local name and type. 
    @@Param:
      @@@Name: localName
      @@@Type:
        DISCore:LocalName::ManakaiDOM:all
      @@@enDesc:
        A local name. 
    @@Param:
      @@@Name:typeURI
      @@@Type:ResourceURI
      @@@enDesc:
        A URI reference identifying a resource type. 
    @@Return:
      @@@Type: ManakaiDISResourceDefinition
      @@@enDesc:
        The first (by document order) child resource whose 
        type matches for <P::localName> and <P::resType>. 
      @@@nullCase:
        @@@@enDesc:
          There is no resource whose name is <P::localName> and
          whose type is <P::resType>.
      @@@PerlDef:
        __DEEP{
          for my $cr_uri (@{$self->{<Q::DIS:childResource>}}) {
            my $cr = $self->{db}-><M::ManakaiDISDatabase.getResource>
                                             ($cr_uri);
            my $ln = $cr-><AG::ManakaiDISResourceDefinition.localName>;
            if (defined $ln and $ln eq $localName and
                $cr-><M::ManakaiDISResourceDefinition.isTypeURI> ($typeURI)) {
              $r = $cr;
              last;
            }
          }
        }__;

  @Method:
    @@Name: getConstResourceByName
    @@enDesc:
      Gets a constant value resource by its local name. 
    @@Param:
      @@@Name:localName
      @@@Type:
        DISLang:String::ManakaiDOM:all
      @@@enDesc:
        Constant name.
    @@Return:
      @@@Type: ManakaiDISResourceDefinition
      @@@enDesc:
        The constant resource identified by <P::localName>.
      @@@nullCase:
        @@@@enDesc:
          There is no such constant resource.
      @@@PerlDef:
        __DEEP{
          my @constGroup;
          for my $cr_uri (@{$self->{<Q::DIS:childResource>}}) {
            my $cr = $self->{db}-><M::ManakaiDISDatabase.getResource>
                                             ($cr_uri);
            my $ln = $cr-><AG::ManakaiDISResourceDefinition.localName>;
            if ($ln and $ln eq $localName and
                $cr-><M::ManakaiDISResourceDefinition.isTypeURI>
                         (<Q::ManakaiDOM:Const>)) {
              $r = $cr;
              last;
            } elsif ($cr-><M::ManakaiDISResourceDefinition.isTypeURI>
                                (<Q::ManakaiDOM:ConstGroup>)) {
              push @constGroup, $cr;
            }
          }
          unless ($r) {
            for my $cg (@constGroup) {
              $r = $cg-><M::ManakaiDISResourceDefinition
                                .getChildResourceByNameAndType>
                             ($localName, <Q::ManakaiDOM:Const>);
              last if $r;
            }
          }
        }__;

  @ResourceDef:
    @@Name: RegQNameChar
    @@enDesc:
      A regular expression character class for <Q::dis:TypeQName>
      character. 
    @@rdf:type:
      DISPerl:ScalarVariable
    @@DefaultValue:
      @@@@: qr/[^\s<>"'\\\[\]\{\},=\$\@%]/
      @@@ContentType:
        lang:Perl
    @@Type:
      DOMMain:any::ManakaiDOM:all

  @ResourceDef:
    @@Name: RegBlockContent
    @@enDesc:
      A regular expression for a block.
    @@rdf:type:
      DISPerl:ScalarVariable
    @@Type:
      DOMMain:any::ManakaiDOM:all
    @@DefaultValue:
      @@@@:
        qr/(?>[^{}\\]*)(?>(?>[^{}\\]+|\\.|\{(??{$RegBlockContent})\})*)/
      @@@ContentType:
        lang:Perl
    @@DISPerl:defaultValueHasSelfReference:1

  @Method:
    @@Name: plPreprocessPerlCode
    @@enDesc:
      Preprocesses a Perl block-level code fragment. 
    @@Param:
      @@@Name:codeArg
      @@@Type:
        lang:Perl::ManakaiDOM:all
      @@@enDesc:
        A Perl block-level code (statements and/or blocks).
    @@NodeParam:
    @@NamedParam:
      @@@Name:methodResource
      @@@Type:ManakaiDISResourceDefinition
      @@@enDesc:
        The resource definition of the Perl method to which
        the <P::codeArg> belongs.
      @@@nullCase:
        @@@@enDesc:
          The <P::codeArg> does not belong to any method.
    @@NamedParam:
      @@@Name:sourceFile
      @@@Type:
        DISLang:String::ManakaiDOM:all
      @@@enDesc:
        The source file name of the <P::codeArg>.
      @@@nullCase:
        @@@@enDesc:
          No source file information available.
    @@NamedParam:
      @@@Name:sourceLine
      @@@Type:
        DOMMain:unsigned-long::ManakaiDOM:all
      @@@enDesc:
        The line number in the <P::sourceFile> from which
        the <P::codeArg> begins.
      @@@nullCase:
        @@@@enDesc:
          No source file information available.
    @@Return:
      @@@Type: 
        lang:Perl::ManakaiDOM:all
      @@@enDesc:
        Preprocessed Perl code. 
      @@@BlockElementException:
      @@@InlineElementException:
      @@@PerlDef:
        unless ($self->{src}) {
          __EXCEPTION{NO_SOURCE_NODE_ERR::
            DIS:uri => {$self->{uri}},
          }__;
        }
        __DEEP{
          our $RegQNameChar;
          our $RegBlockContent;
          my $plimpl = $self-><AG::ManakaiDISPropertyAccessor.plImplementation>;
          $r = $plimpl-><M::MPLImpl.createPerlBlock>;
          if (defined $sourceLine) {
            $r-><AS::PLBlockCon.sourceFile> ($sourceFile);
            $r-><AS::PLBlockCon.sourceLine> ($sourceLine);
            $r-><AS::PLBlockCon.currentSourceFile> ($sourceFile);
            $r-><AS::PLBlockCon.currentSourceLine> ($sourceLine);
          } elsif ($node) {
            my $np = $node-><M::swcfg21:SWCFGNode::swcfg21:ForLatest.nodePath>
                      (key => [qw/Name QName Type type/]);
            $r-><AS::PLBlockCon.currentSourceFile> ($np);
            $r-><AS::PLBlockCon.currentSourceLine> (1);
            $r-><AS::PLBlockCon.sourceFile> ($np);
            $r-><AS::PLBlockCon.sourceLine> (1);
          }
          
          for my $source_code (split /\b(_ _(?:(?!_ _)$RegQNameChar)+
                                           (?:\{$RegBlockContent\})?
                                         _ _)\b/x, $codeArg) {
            ## Block-level element
            if ($source_code =~ /_\_\z/ and
                $source_code =~ s/^_\_((?:(?!_\_)$RegQNameChar)+)//) {
              my $et = $self->{src}
                            -><M::ManakaiDISElement.qnameToURI>
                                     ($1,
                                      node => $node,
                                      default_namespace_uri => <Q::disPerl:>);
              if ($source_code =~ s/^\{//) {
                $source_code =~ s/\}__\z//;
              } else {
                $source_code = '';
              }

#  ## ISSUE: __FILE__ & __LINE__ will break if multiline substition happens.

              if ($et eq <Q::disPerl:DEEP> or $et eq <Q::disPerl:UNDEEP>) {
                my $block = $r-><M::PLBlockCon.appendBlock>;
                $block-><M::PLBlockCon.appendStatement>
                              ('local $Error::Depth = $Error::Depth '.
                               ($et eq <Q::disPerl:DEEP> ? '+' : '-').
                               ' 1');
                $block-><M::PLBlockCon.appendCodeFragment>
                          ($self-><M::ManakaiDISResourceDefinition
                                    .plPreprocessPerlCode>
                                       ($source_code, node => $node,
                                        method_resource => $methodResource,
                                        source_file => $r-><AG::PLBlockCon
                                                          .currentSourceFile>,
                                        source_line => $r-><AG::PLBlockCon
                                                          .currentSourceLine>));
                $r-><M::PLBlockCon.skipLines> ($source_code);
              } elsif ({
                <Q::disPerl:EXCEPTION> => 1,
                <Q::disPerl:WARNING> => 1,
              }->{$et}) {
                $r-><M::PLBlockCon.skipLines> ($source_code);
                if ($source_code =~ s/^((?:(?!::).)+)(::\s*)?//s) {
                  my ($cls, $const, $subtype)
                    = @{$self->{db}-><M::ManakaiDISDatabase.xcrefToResource>
                                         ($1, $self->{src},
                                          node => $node,
                                          for_arg => $self->{for})};
                  my $param = $self-><M::ManakaiDISResourceDefinition
                                        .plParsePreprocessParameter>
                                         ($source_code, node => $node);
                  my $context_param
                            = $self-><M::ManakaiDISResourceDefinition
                                        .plGetContextParameter>;

                  $self-><M::ManakaiDISResourceDefinition
                            .plAppendThrow>
                               ($r, $cls, $const, $subtype,
                                {%$param, %$context_param});
                } else {
                  __UNDEEP{__EXCEPTION{PERL_PREPROCESS_NO_EXCEPTION_TYPE_ERR::
                    DIS:sourceNode => {$node},
                    DIS:sourceCode => {$source_code},
                    DIS:elementType => {$et},
                  }__}__;
                }
              } elsif ($et eq <Q::disPerl:CODE>) {
                $r-><M::PLBlockCon.skipLines> ($source_code);
                  my $code_name;
                  $source_code =~ s/^\s+//;
                  if ($source_code =~ s/^((?>(?!::).)+)//s) {
                    $code_name = $1;
                  } else {
                    __UNDEEP{
                      __EXCEPTION{PERL_PREPROCESS_NO_CODE_NAME_ERR::
                        DIS:sourceCode => {$source_code},
                        DIS:sourceNode => {$node},
                        DIS:elementType => {$et},
                      }__;
                    }__;
                  }
                  $source_code =~ s/^::\s*//;
                  my $param = $self-><M::ManakaiDISResourceDefinition
                                        .plParsePreprocessParameter>
                                           ($source_code, node => $node);
                  my $code_uri = $self->{src}-><M::ManakaiDISElement
                                           .tfqnamesToURI>
                                           ($code_name, null, $self->{for},
                                            node => $node);
                  my $code = $self->{db}-><M::ManakaiDISDatabase.getResource>
                                           ($code_uri);
                  $code-><AS::ManakaiDISResourceDefinition.isReferred>
                                           ($node || $self->{src});
                  unless ($code-><M::ManakaiDISResourceDefinition.isTypeURI>
                                           (<Q::dis2pm:BlockCode>)) {
                    __UNDEEP{__EXCEPTION{RESOURCE_NOT_DEFINED_ERR::
                      DIS:uri => {$code_uri},
                      DIS:sourceNode => {$node},
                      DIS:sourceCode => {$source_code},
                      DIS:expectedType => {<Q::dis2pm:BlockCode>},
                    }__;}__;
                  }
                  my $pc = $code-><AG::ManakaiDISResourceDefinition
                                       .plCodeFragment>->clone;
                  unless (defined $pc) {
                    __UNDEEP{__EXCEPTION{PERL_CODE_NOT_DEFINED_ERR::
                      DIS:sourceNode => {$node},
                      DIS:sourceCode => {$source_code},
                      DIS:uri => {$code_uri},
                    }__}__;
                  }
                  for my $var (grep {/^\$/} keys %$param) {
                    my $value;
                    if ($param->{$var}->{type} eq 'variable') {
                      $value = $plimpl-><M::MPLImpl.createPerlVariable>
                                          ('$', null, $param->{$var}->{value});
                    } elsif ($param->{$var}->{type} eq 'code') {
                      $value = $self-><M::ManakaiDISResourceDefinition
                                         .plPreprocessPerlStatement>
                                            ($param->{$var}->{value},
                                             contains_statements => false);
                    } else {
                      $value = $plimpl-><M::MPLImpl.createPerlStringLiteral>
                                          ($param->{$var}->{value});
                    }
                    $pc-><M::MPLCodeFragment.replaceVariable>
                                          ($var => $value);
                  }
                  $r-><M::PLBlockCon.appendCodeFragment> ($pc);
                } elsif ($et eq <Q::ManakaiDOM:InputNormalize>) {
                  $r-><M::PLBlockCon.skipLines> ($source_code);
                  unless ($methodResource) {
                    __UNDEEP{__EXCEPTION{PERL_PREPROCESS_NO_METHOD_ERR::
                      DIS:sourceNode => {$node},
                      DIS:sourceCode => {$source_code},
                      DIS:elementType => {$et},
                    }__}__;
                  }
                  my $param = $methodResource
                                -><M::ManakaiDISResourceDefinition
                                     .getChildResourceByNameAndType>
                                    ($source_code, <Q::DISLang:MethodParameter>);
                  unless ($param) {
                    __UNDEEP{__EXCEPTION{RESOURCE_NOT_DEFINED_ERR::
                      DIS:sourceNode => {$node},
                      DIS:sourceCode => {$source_code},
                      DIS:elementType => {$et},
                      DIS:localName => {$source_code},
                      DIS:expectedType => {<Q::DISLang:MethodParameter>},
                    }__}__;
                  }
                  my $norm = $param-><M::ManakaiDISResourceDefinition
                                        .plGetMethodInputNormalizer>;
                  if ($norm) {
                    my $norm_code = $norm-><AG::ManakaiDISResourceDefinition
                                               .plCodeFragment>->clone;
                    $norm_code-><M::MPLCodeFragment.replaceVariable>
                       ('$INPUT' => $param-><AG::ManakaiDISResourceDefinition
                                                .plVariableName>);
                    $r-><M::PLBlockCon.appendCodeFragment> ($norm_code);
                  }
                } elsif ($et eq <Q::disPerl:FOR>) {
                  if ($source_code =~ s/^(((?>(?!::).)*)::\s*)//) {
                    $r-><M::PLBlockCon.skipLines> ($1);
                    V: for (split /\s*\|\s*/, $2) {
                      my $for_uri = $self->{src}
                                         -><M::ManakaiDISElement.qnameToURI>
                                              ($_, node => $node);
                      if ($self-><M::ManakaiDISResourceDefinition
                                    .isForURI> ($for_uri)) {
                        $r-><M::PLBlockCon.appendCodeFragment>
                            ($self-><M::ManakaiDISResourceDefinition
                                  .plPreprocessPerlCode>
                                     ($source_code, node => $node,
                                      method_resource => $methodResource,
                                      source_file => $r-><AG::PLBlockCon.
                                                       currentSourceFile>,
                                      source_line => $r-><AG::PLBlockCon.
                                                       currentSourceLine>));
                        last V;
                      }
                    } # V
                    $r-><M::PLBlockCon.skipLines> ($source_code);
                  } else {
                    __UNDEEP{__EXCEPTION{PERL_PREPROCESS_NO_FOR_ERR::
                      DIS:sourceNode => {$node},
                      DIS:sourceCode => {$source_code},
                      DIS:elementType => {$et},
                    }__}__;
                  }
                } elsif ($et eq <Q::disPerl:ASSERT>) {
                  $r-><M::PLBlockCon.skipLines> ($source_code);
                  my $assert_type;
                  if ($source_code =~ s/^\s*($RegQNameChar+)\s*::\s*//o) {
                    $assert_type = $self->{src}
                                        -><M::ManakaiDISElement.qnameToURI>
                                             ($1, node => $node);
                  } else {
                    __UNDEEP{__EXCEPTION{PERL_PREPROCESS_NO_ASSERT_TYPE_ERR::
                      DIS:sourceNode => {$node},
                      DIS:sourceCode => {$source_code},
                      DIS:elementType => {$et},
                    }__}__;
                  }
                  # if output assertion then
 =pod
                    my $assert_block = $r-><M::PLBlockCon.appendBlock>;
                  
                    my $param = $self-><M::ManakaiDISResourceDefinition
                                          .plParsePreprocessParameter>
                                           ($source_code, node => $node);
                    my $context_param
                            = $self-><M::ManakaiDISResourceDefinition
                                        .plGetContextParameter>;

                    if ($assert_type eq <Q::DISPerl:isPositive>) {

        $pre = perl_statement
                 perl_assign
                   'my $asActual' =>
                          '('.perl_code ($param->{actual}, %opt).')';
        $cond = '$asActual > 0';
        $xparam->{ExpandedURI q<DOMMain:expectedLabel>} = 'a positive value';
        $xparam->{ExpandedURI q<DOMMain:actualValue>}
                                 = perl_code_literal q<$asActual>;
      } elsif ($atype eq ExpandedURI q<DISPerl:invariant>) {
        $cond = '0';
        $xparam->{ExpandedURI q<DOMMain:expectedLabel>} = $param->{msg};
        $xparam->{ExpandedURI q<DOMMain:actualValue>} = '(invariant)';
      } else {
        valid_err (q[Assertion type <].$atype.q[> is not supported],
                   node => $opt{node});
      }

        $r = $pre . perl_if
               $cond,
               undef,


                  my $cls = $self->{db}-><M::ManakaiDISDatabase.getResource>
                                   (<Q::DOMException:CoreException>);
                  my $const = $self->{db}-><M::ManakaiDISDatabase.getResource>
                                   (<Q::MDOMX:MDOM_DEBUG_BUG>);
                  my $subtype = $self->{db}-><M::ManakaiDISDatabase.getResource>
                                   (<Q::DOMMain:ASSERTION_ERR>);
                  $_-><AS::ManakaiDISResourceDefinition.isReferred>
                          ($node || $self->{src}) for $cls, $const, $subtype;
                  $self-><M::ManakaiDISResourceDefinition
                            .plAppendThrow>
                               ($assert_block, $cls, $const, $subtype,
                                {%$param, %$context_param,
                                 <Q::DOMMain:assertionType> => {
                                   type => 'quoted', value => $assert_type,
                                 },
                                 <Q::DOMMain:traceText> => {
                                   type => 'code',
                                   value => q<(sprintf 'at %s line %s%s%s',
                                               __FILE__, __LINE__, "\n\t",
                                               Carp::longmess ())>,
                                 }});

  =cut

                } elsif ({
                  <Q::disPerl:FILE> => 1,
                  <Q::disPerl:LINE> => 1,
                  <Q::disPerl:PACKAGE> => 1,
                }->{$et}) {
                  $r-><M::PLAnyCon.appendAtom>
                        ('__'.{
                                 <Q::disPerl:FILE> => 'FILE',
                                 <Q::disPerl:LINE> => 'LINE',
                                 <Q::disPerl:PACKAGE> => 'PACKAGE',
                              }->{$et}.'__');
                  if (length $source_code) {
                    __UNDEEP{__EXCEPTION{PERL_PREPROCESS_BLOCK_NOT_ALLOWED_ERR::
                      DIS:sourceNode => {$node},
                      DIS:sourceCode => {$source_code},
                      DIS:elementType => {$et},
                    }__}__;
                  }
                } else {
                  __UNDEEP{__EXCEPTION{UNSUPPORTED_ELEMENT_TYPE_ERR::
                    DIS:sourceNode => {$node},
                    DIS:sourceCode => {$source_code},
                    DIS:elementType => {$et},
                  }__}__;
                }
              } else {  ## Other than block-level element
                $r-><M::PLBlockCon.appendCodeFragment>
                       ($self-><M::ManakaiDISResourceDefinition
                             .plPreprocessPerlStatement>
                                 ($source_code, contains_statements => true,
                                  source_file => $r-><AG::PLBlockCon
                                                        .currentSourceFile>,
                                  source_line => $r-><AG::PLBlockCon
                                                        .currentSourceLine>));
                $r-><M::PLBlockCon.skipLines> ($source_code);
              }
            } # for
          }__; # DEEP


  ## Checks \p character classes
#  while ($s =~ /\\p{([^{}]+)}/gs) {
#    my $name = $1;
#    $State->{ExpandedURI q<dis2pm:Package>}
#          ->{$State->{ExpandedURI q<dis2pm:currentPackage>}}
#          ->{ExpandedURI q<dis2pm:requiredCharClass>}
#          ->{$name} ||= $opt{node} || 1;
#  }

      
  @Method:
    @@Name: plPreprocessPerlStatement
    @@enDesc:
      Preprocesses a Perl inline code fragment
      (code fragment smaller than statement). 
    @@Param:
      @@@Name:codeArg
      @@@Type:
        lang:Perl::ManakaiDOM:all
      @@@enDesc:
        A Perl code fragment.
    @@NodeParam:
    @@NamedParam:
      @@@Name:containsStatements
      @@@Type:
        DOMMain:boolean::ManakaiDOM:all
      @@@enDesc:
        Whether one or more statements might be contained
        in <P::codeArg> or not.
    @@NamedParam:
      @@@Name:sourceFile
      @@@Type:
        DISLang:String::ManakaiDOM:all
      @@@enDesc:
        The source file name of the <P::codeArg>.
      @@@nullCase:
        @@@@enDesc:
          No source file information available.
    @@NamedParam:
      @@@Name:sourceLine
      @@@Type:
        DOMMain:unsigned-long::ManakaiDOM:all
      @@@enDesc:
        The line number in the <P::sourceFile> from which
        the <P::codeArg> begins.
      @@@nullCase:
        @@@@enDesc:
          No source file information available.
    @@Return:
      @@@Type:MPLCodeFragment
      @@@enDesc:
        Preprocessed Perl code.
      @@@InCase:
        @@@@Type:
          PerlCode:ManakaiPerlBlock::ManakaiDOM:Perl
        @@@@enDesc:
          If <P::containsStatements> is <DOM::false>.
      @@@InCase:
        @@@@Type:
          PerlCode:ManakaiPerlInlineContainer::ManakaiDOM:Perl
        @@@@enDesc:
          If <P::containsStatements> is <DOM::true>.
      @@@InlineElementException:
      @@@PerlDef:
        unless ($self->{src}) {
          __EXCEPTION{NO_SOURCE_NODE_ERR::
            DIS:uri => {$self->{uri}},
          }__;
        }
        __DEEP{
          our $RegQNameChar;
          my $plimpl = $self-><AG::ManakaiDISPropertyAccessor.plImplementation>;
          if ($containsStatements) {
            $r = $plimpl-><M::MPLImpl.createPerlBlockContainer>;
            if (defined $sourceLine) {
              $r-><AS::PLBlockCon.sourceFile> ($sourceFile);
              $r-><AS::PLBlockCon.sourceLine> ($sourceLine);
              $r-><AS::PLBlockCon.currentSourceFile> ($sourceFile);
              $r-><AS::PLBlockCon.currentSourceLine> ($sourceLine);
            } elsif ($node) {
              my $np = $node-><M::swcfg21:SWCFGNode::swcfg21:ForLatest.nodePath>
                        (key => [qw/Name QName Type type/]);
              $r-><AS::PLBlockCon.sourceFile> ($np);
              $r-><AS::PLBlockCon.sourceLine> (1);
              $r-><AS::PLBlockCon.currentSourceFile> ($np);
              $r-><AS::PLBlockCon.currentSourceLine> (1);
            }
          } else {
            $r = $plimpl-><M::MPLImpl.createPerlInlineContainer>;
          }
          for my $source_code (split /(?<![\^\?qwr])(\x3C$RegQNameChar[^<>]+>
                                                     )/ox, $codeArg) {
            if ($source_code =~ s/^\x3C//) {
              $source_code =~ s/>$//;
              if ($source_code =~ /=$/) {
              ## TODO: Warning
              #  valid_warn qq<Inline element "\x3C$source_code>" ends with a "=" - >.
              #              q{should "=" be used place of "=>"?};
              }
              if ($source_code =~ s/^(.+?):://) {
                my $et = $self->{src}
                              -><M::ManakaiDISElement.qnameToURI>
                                     ($1,
                                      node => $node,
                                      default_namespace_uri => <Q::disPerl:>);
                if ($et eq <Q::disPerl:Q>) {          ## QName constant
                  $r-><M::PLAnyCon.appendStringLiteral>
                              ($self->{src}
                                    -><M::ManakaiDISElement.qnameToURI>
                                           ($source_code, node => $node));
                } elsif ({
                  <Q::disPerl:M> => 1,
                  <Q::disPerl:ClassM> => 1,
                  <Q::disPerl:AG> => 1,
                  <Q::disPerl:AS> => 1,
                }->{$et}) {     ## Method call
                  my ($class_qname, $method_qname)
                         = split /\s*\.\s*/, $source_code, 2;
                  my $class_uri
                         = $self->{src}
                                -><M::ManakaiDISElement.tfqnamesToURI>
                                       ($class_qname,
                                        $self-><AG::ManakaiDISResourceDefinition
                                                     .ownerClassURI>,
                                        $self->{for},
                                        node => $node);
                  my $class = $self->{db}-><M::ManakaiDISDatabase.getResource>
                                                   ($class_uri);
                  unless ($class-><AG::ManakaiDISResourceDefinition
                                        .isDefined>) {
                    __UNDEEP{__EXCEPTION{RESOURCE_NOT_DEFINED_ERR::
                      DIS:sourceNode => {$node},
                      DIS:sourceCode => {$source_code},
                      DIS:uri => {$class_uri},
                      DIS:elementType => {$et},
                      DIS:expectedType => {<Q::DISLang:AnyClass>},
                    }__}__;
                  }
                  $class-><AS::ManakaiDISResourceDefinition.isReferred>
                                                   ($node || $self->{src});
                  if ($et eq <Q::disPerl::ClassM> and
                      $class-><M::ManakaiDISResourceDefinition.isTypeURI>
                                     (<Q::ManakaiDOM:IF>)) {
                    __UNDEEP{
                      __EXCEPTION{INTERFACE_CLASS_METHOD_ERR::
                        DIS:uri => {$class_uri},
                        DIS:elementType => {$et},
                        DIS:sourceNode => {$node || $self->{src}},
                        DIS:sourceCode => {$source_code},
                        DIS:expectedType => {<Q::ManakaiDOM:IF>},
                      }__;
                    }__;
                  }
                  unless ($class-><M::ManakaiDISResourceDefinition.isTypeURI>
                                         (<Q::ManakaiDOM:IF>)) {
                    $self-><M::ManakaiDISResourceDefinition.plAddRequireResource>
                                         ($class => $r);
                  }
                  my $method = $class-><M::ManakaiDISResourceDefinition
                                         .getChildResourceByNameAndType>
                                    ($method_qname,
                                     {
                                       <Q::disPerl:AG> => <Q::DISLang:Attribute>,
                                       <Q::disPerl:AS> => <Q::DISLang:Attribute>,
                                     }->{$et} || <Q::DISLang:Method>);
                  if (not $method or
                      not $method-><AG::ManakaiDISResourceDefinition
                                                           .isDefined>) {
                    __UNDEEP{
                      __EXCEPTION{RESOURCE_NOT_DEFINED_ERR::
                        DIS:localName => {$method_qname},
                        DIS:elementType => {$et},
                        DIS:sourceNode => {$node || $self->{src}},
                        DIS:sourceCode => {$source_code},
                        DIS:expectedType => {{
                                       <Q::disPerl:AG> => <Q::DISLang:Attribute>,
                                       <Q::disPerl:AS> => <Q::DISLang:Attribute>,
                                     }->{$et} || <Q::DISLang:Method>},
                      }__;
                    }__;
                  }
                  my $class_name = '';
                  if ($et eq <Q::disPerl:ClassM>) {
                    $class_name = $class-><AG::ManakaiDISResourceDefinition
                                              .plFullyQualifiedName> . '->';
                  }
                  my $method_name = $method-><AG::ManakaiDISResourceDefinition
                                                 .plName>;
                  $r-><M::PLAnyCon.appendBare>
                                           ($class_name . $method_name);
                } elsif ({
                  <Q::disPerl:Class> => 1,
                  <Q::disPerl:ClassName> => 1,
                  <Q::disPerl:IF> => 1,
                  <Q::disPerl:IFName> => 1,
                }->{$et}) {                            ## Perl package name
                  my $class_uri
                         = $self->{src}
                                -><M::ManakaiDISElement.tfqnamesToURI>
                                       ($source_code,
                                        $self-><AG::ManakaiDISResourceDefinition
                                                     .ownerClassURI>,
                                        $self->{for},
                                        node => $node);
                  my $class = $self->{db}-><M::ManakaiDISDatabase.getResource>
                                                   ($class_uri);
                  $class-><AS::ManakaiDISResourceDefinition.isReferred>
                                                   ($node || $self->{src});
                  my $pack = $class-><AG::ManakaiDISResourceDefinition
                                                  .plFullyQualifiedName>;
                  unless ($pack) {
                    __UNDEEP{__EXCEPTION{NO_PERL_PACKAGE_NAME_ERR::
                      DIS:sourceNode => {$node || $self->{src}},
                      DIS:sourceCode => {$source_code},
                      DIS:uri => {$class_uri},
                      DIS:elementType => {$et},
                    }__}__;
                  }
                  if ({
                    <Q::disPerl:ClassName> => 1,
                    <Q::disPerl:IFName> => 1,
                  }->{$et}) {
                    $r-><M::PLAnyCon.appendStringLiteral> ($pack);
                  } else {
                    $r-><M::PLAnyCon.appendBare> ($pack);
                  }
                } elsif ($et eq <Q::disPerl:Code>) { ## Inline code
                  my $code_name;
                  $source_code =~ s/^\s+//;
                  if ($source_code =~ s/^((?>(?!::).)+)//s) {
                    $code_name = $1;
                  } else {
                    __UNDEEP{
                      __EXCEPTION{PERL_PREPROCESS_NO_CODE_NAME_ERR::
                        DIS:sourceCode => {$source_code},
                        DIS:sourceNode => {$node || $self->{src}},
                      }__;
                    }__;
                  }
                  $source_code =~ s/^::\s*//;
                  my $param = $self-><M::ManakaiDISResourceDefinition
                                        .plParsePreprocessParameter>
                                           ($source_code, node => $node);
                  my $code_uri = $self->{src}-><M::ManakaiDISElement
                                           .tfqnamesToURI>
                                           ($code_name, null, $self->{for},
                                            node => $node);
                  my $code = $self->{db}-><M::ManakaiDISDatabase.getResource>
                                           ($code_uri);
                  $code-><AS::ManakaiDISResourceDefinition.isReferred>
                                           ($node || $self->{src});
                  unless ($code-><M::ManakaiDISResourceDefinition.isTypeURI>
                                           (<Q::dis2pm:InlineCode>)) {
                    __UNDEEP{__EXCEPTION{RESOURCE_NOT_DEFINED_ERR::
                      DIS:uri => {$code_uri},
                      DIS:sourceNode => {$node || $self->{src}},
                      DIS:sourceCode => {$source_code},
                      DIS:expectedType => {<Q::dis2pm:InlineCode>},
                    }__;}__;
                  }
                  my $pc = $code-><AG::ManakaiDISResourceDefinition
                                       .plCodeFragment>->clone;
                  unless (defined $pc) {
                    __UNDEEP{__EXCEPTION{PERL_CODE_NOT_DEFINED_ERR::
                      DIS:sourceNode => {$node || $self->{src}},
                      DIS:sourceCode => {$source_code},
                      DIS:uri => {$code_uri},
                    }__}__;
                  }
                  for my $var (grep {/^\$/} keys %$param) {
                    my $value;
                    if ($param->{$var}->{type} eq 'variable') {
                      $value = $plimpl-><M::MPLImpl.createPerlVariable>
                                          ('$', null, $param->{$var}->{value});
                    } elsif ($param->{$var}->{type} eq 'code') {
                      $value = $self-><M::ManakaiDISResourceDefinition
                                         .plPreprocessPerlStatement>
                                            ($param->{$var}->{value},
                                             contains_statements => false);
                    } else {
                      $value = $plimpl-><M::MPLImpl.createPerlStringLiteral>
                                          ($param->{$var}->{value});
                    }
                    $pc-><M::MPLCodeFragment.replaceVariable>
                                          ($var => $value);
                  }
                  $r-><M::PLInCon.appendCodeFragment> ($pc);
                } elsif ($et eq <Q::disPerl:C>) {
                  my ($class_qname, $const_name) = split /\./, $source_code, 2;
                  my $class_uri
                         = $self->{src}
                                -><M::ManakaiDISElement.tfqnamesToURI>
                                       ($class_qname,
                                        $self-><AG::ManakaiDISResourceDefinition
                                                     .ownerClassURI>,
                                        $self->{for},
                                        node => $node);
                  my $class = $self->{db}-><M::ManakaiDISDatabase.getResource>
                                                   ($class_uri);
                  $class-><AS::ManakaiDISResourceDefinition.isReferred>
                                                   ($node || $self->{src});
                  my $const = $class-><M::ManakaiDISResourceDefinition
                                         .getConstResourceByName> ($const_name);
                  unless (defined $const) {
                    __UNDEEP{__EXCEPTION{RESOURCE_NOT_DEFINED_ERR::
                      DIS:sourceNode => {$node || $self->{src}},
                      DIS:sourceCode => {$source_code},
                      DIS:localName => {$const_name},
                      DIS:expectedType => {<Q::ManakaiDOM:Const>},
                    }__}__;
                  }
                  my $pc = $const-><AG::ManakaiDISResourceDefinition
                                       .plCodeFragment>->clone;
                  unless (defined $pc) {
                    __UNDEEP{__EXCEPTION{PERL_CODE_NOT_DEFINED_ERR::
                      DIS:sourceNode => {$node || $self->{src}},
                      DIS:sourceCode => {$source_code},
                      DIS:localName => {$const_name},
                    }__}__;
                  }
                  $r-><M::PLInCon.appendCodeFragment> ($pc);
                } else {
                  __UNDEEP{__EXCEPTION{UNSUPPORTED_ELEMENT_TYPE_ERR::
                    DIS:elementType => {$et},
                    DIS:sourceNode => {$node || $self->{src}},
                    DIS:sourceCode => {$source_code},
                  }__}__;
                }
              } else {
                __UNDEEP{__EXCEPTION{PERL_PREPROCESS_NO_ELEMENT_TYPE_ERR::
                  DIS:sourceNode => {$node || $self->{src}},
                  DIS:sourceCode => {$source_code},
                  DIS:expectedType => {<Q::ManakaiDOM:ConstGroup>},
                }__}__;
              }
            } else {
              for my $source_code (split /\b( t r u e \b|
                                              f a l s e \b|
                                              n u l l \b|
                                              t r y \s* \{)/x, $source_code) {
                if ({
                  'tr'.'ue' => true,
                  'fal'.'se' => true,
                  'nu'.'ll' => true,
                }->{$source_code}) {
                  $r-><M::PLAnyCon.appendAtom> ({
                    'tr'.'ue' => 1,
                    'fal'.'se' => 0,
                    'nu'.'ll' => 'undef',
                  }->{$source_code});
                } elsif ($source_code =~ /^t r y \s* \x7B$/x) {
                  $r-><M::PLInCon.appendCode> ('tr'.
                       'y '."\x7B".'local $Error::Depth = $Error::Depth + 3;');
                  $r-><M::MPLCodeFragment.addUsePerlModuleName>
                                                    ('Message::Util::Error');
                } else {
                  $r-><M::PLInCon.appendCode> ($source_code);
                }
              }
            } # Inline instruction or not
          } # for
        }__; # DEEP

  @Attr:
    @@Name: ownerClassURI
    @@enDesc:
      The URI reference of the class resource this resource
      belongs to.
    @@Type: ResourceURI
    @@Get:
      @@@enDesc:
        The URI reference of the <TYPE::ManakaiDOM:Class> resource.
        If this resource is a class, then the URI reference
        of this resource is returned.
      @@@nullCase:
        @@@@enDesc:
          This resource does not belong to any class.
      @@@PerlDef:
        if (exists $self->{<Q::DIS:ownerClass>}) {
          $r = $self->{<Q::DIS:ownerClass>};
        } else {
          my $res = $self;
          __DEEP{
            {
              if ($res-><M::ManakaiDISResourceDefinition.isTypeURI>
                             (<Q::ManakaiDOM:Class>)) {
                $r = $res->{uri};
              } else {
                $res = $res-><M::ManakaiDISPropertyAccessor
                              .getPropertyResource> (<Q::dis2pm:parentResource>);
                redo if $res;
              }
            }
          }__;
          $self->{<Q::DIS:ownerClass>} = $r;
        }
  
  @IntMethod:
    @@Name: plParsePreprocessParameter
    @@enDesc:
      Parses a parameter specification in preprocessing instruction
      and return it as a hash reference.
      \
      {NOTE:: The callee have to ensure that this resource has its 
              <CODE::src> before the call to this method.
      \
      }
    @@Param:
      @@@Name: paramSpec
      @@@Type:
        DISLang:String::ManakaiDOM:all
      @@@enDesc:
        A parameter specification to parse.
    @@NodeParam:
    @@Return:
      @@@Type:
        Perl:hash::ManakaiDOM:all
      @@@enDesc:
        Hash containing parameters.  Each hash value is also 
        a hash reference, containing two keys <CODE::type> 
        (its value is either <CODE::bare>, <CODE::quoted>,
         <CODE::code> or <CODE::variable>) and
        <CODE::value>.
      @@@RaiseException:
        @@@@@:BROKEN_PARAM_SPEC_ERR
        @@@@enDesc:
          The <P::paramSpec> is not well-formed.
      @@@PerlDef:
        our $RegQNameChar;
        our $RegBlockContent;
        $r = {};
        while ($paramSpec =~ s/^
          ## Parameter name
          (\$? $RegQNameChar+)\s*
  
          (?: =>? \s*
               ## ">" is now optional for inline element (">" is delimiter)

          ## Parameter value
          (
            ## Variable or Bare string
   \           \$? $RegQNameChar+
            |
            ## Quoted string
               '(?>[^'\\]*)' ## ISSUE: escape mechanism required?
            |
            ## Code
   \           \{$RegBlockContent\}
   
          )

          \s*)?

        (?:,\s*|$)//ox) {

        my ($n, $v) = ($1, $2);
        if (defined $v) {
          if ($v =~ /^'/) {
            $v = {type => 'quoted',
                  value => substr ($v, 1, length ($v) - 2)};
          } elsif ($v =~ /^\{/) {
            $v = {type => 'code', value => substr ($v, 1, length ($v) - 2)};
          } elsif ($v =~ /^\$/) {
            $v = {type => 'variable', value => substr $v, 1};
          } else {
            $v = {type => 'bare', value => $v};
          }
        } else {
          $v = {type => 'boolean', value => true};
        }
    
        if ($n =~ /^\$/) {
          $r->{$n} = $v;
        } else {
          __DEEP{
            $r->{$self->{src}-><M::ManakaiDISElement.qnameToURI>
                                 ($n, node => $node || $self->{src})} = $v;
          }__;
        }
      } # while

      if (length $paramSpec) {
        __EXCEPTION{BROKEN_PARAM_SPEC_ERR::
          DIS:sourceCode => {$paramSpec},
          DIS:sourceNode => {$node || $self->{src}},
        }__;
      }

  @IntMethod:
    @@Name: plGetContextParameter
    @@enDesc:
      Returns contextual parameters which describes the <QUOTE::location>
      of this resource.
    @@Return:
      @@@Type:
        Perl:hash::ManakaiDOM:all
      @@@enDesc:
        Hash of parameters as <M::.plParsePreprocessParameter> returns.
      @@@PerlDef:
        $r = {};
        __DEEP{
          if ($self-><M::ManakaiDISResourceDefinition.isTypeURI>
                       (<Q::DISLang:MethodReturn>)) {
            my $method = $self-><M::ManakaiDISPropertyAccessor
                              .getPropertyResource> (<Q::dis2pm:parentResource>);
            $r->{<Q::MDOMX:method>}
               = {type => 'quoted',
                  value => $method-><AG::ManakaiDISResourceDefinition.plName>};
            my $class = $method-><M::ManakaiDISPropertyAccessor
                              .getPropertyResource> (<Q::dis2pm:parentResource>);
            $r->{<Q::MDOMX:class>}
               = {type => 'quoted',
                  value => $class-><AG::ManakaiDISResourceDefinition
                                       .plFullyQualifiedName>};
          } elsif ($self-><M::ManakaiDISResourceDefinition.isTypeURI>
                       (<Q::DISLang:AttributeGet>)) {
            my $attr = $self-><M::ManakaiDISPropertyAccessor
                              .getPropertyResource> (<Q::dis2pm:parentResource>);
            $r->{<Q::MDOMX:attr>}
               = {type => 'quoted',
                  value => $attr-><AG::ManakaiDISResourceDefinition.plName>};
            my $class = $attr-><M::ManakaiDISPropertyAccessor
                              .getPropertyResource> (<Q::dis2pm:parentResource>);
            $r->{<Q::MDOMX:class>}
               = {type => 'quoted',
                  value => $class-><AG::ManakaiDISResourceDefinition
                                       .plFullyQualifiedName>};
            $r->{<Q::MDOMX:on>} = {type => 'quoted', value => 'get'};
          } elsif ($self-><M::ManakaiDISResourceDefinition.isTypeURI>
                       (<Q::DISLang:AttributeSet>)) {
            my $attr = $self-><M::ManakaiDISPropertyAccessor
                              .getPropertyResource> (<Q::dis2pm:parentResource>);
            $r->{<Q::MDOMX:attr>}
               = {type => 'quoted',
                  value => $attr-><AG::ManakaiDISResourceDefinition.plName>};
            my $class = $attr-><M::ManakaiDISPropertyAccessor
                              .getPropertyResource> (<Q::dis2pm:parentResource>);
            $r->{<Q::MDOMX:class>}
               = {type => 'quoted',
                  value => $class-><AG::ManakaiDISResourceDefinition
                                       .plFullyQualifiedName>};
            $r->{<Q::MDOMX:on>} = {type => 'quoted', value => 'set'};
          } else {
            $r->{<Q::MDOMX:resourceURI>} = {type => 'quoted',
                                            value => $self->{uri}};
          }
        }__;

  @Method:
    @@Name: plGetMethodInputNormalizer
    @@enDesc:
      Returns an input processor.  This method assumes that 
      this resource is a method parameter (<Q::DISLang:MethodParameter>)
      or an attribute setter (<Q::DISLang:AttributeSet>).
    @@Return:
      @@@Type:ManakaiDISResourceDefinition
      @@@enDesc:
        A <Q::DISLang:InputProcessor> corresponding to 
        the parameter defined by this resource.
        \
        {NOTE:: <Q::ManakaiDOM:inputNormalize> property is 
                obsolete in favor of <Q::DISLang:InputProcessor>;
                this method does not support the former.
        \
        }
      @@@nullCase:
        @@@@enDesc:
          No input processor found.
      @@@PerlDef:
        my $type;
        try {
          $type = $self-><AG::ManakaiDISResourceDefinition
                             .disActualDataTypeResource>;
          #$type_node = $self->< AG::ManakaiDISResourceDefinition
          #                        .disActualDataTypeNode>;
        } catch <Class::ManakaiDISException> with {
          my $err = shift;
          unless ($err->{<Q::MDOMX:subtype>} eq <Q::DIS:NO_DIS_TYPE_ERR>) {
            $err->throw;
          }
        };
        if ($type) {
          __DEEP{
            $r = $type-><M::ManakaiDISResourceDefinition.getChildResourceByType>
                                                   (<Q::DISLang:InputProcessor>);
          }__;
        }

  @IntMethod:
    @@Name: plAppendThrow
    @@enDesc:
      Appends a <Perl::report> method call statement for exception reporting.
    @@Param:
      @@@Name: parentNode
      @@@enDesc:
        The parent Perl code node to which a new statement is appended.
      @@@Type: PLBlockCon
    @@Param:
      @@@Name: xclass
      @@@Type: ManakaiDISResourceDefinition
      @@@enDesc:
        An exception class.
    @@Param:
      @@@Name: xcode
      @@@Type: ManakaiDISResourceDefinition
      @@@enDesc:
        An exception code constant.
    @@Param:
      @@@Name: xsubtype
      @@@Type: ManakaiDISResourceDefinition
      @@@enDesc:
        An exception subtype.
      @@@nullCase:
        @@@@enDesc:
          No subtype.
    @@Param:
      @@@Name: xparam
      @@@Type:
        Perl:hash::ManakaiDOM:all
      @@@enDesc:
        A hash containing parameters passed to the <Perl:report> method. 
        A hash key is to be a parameter name.  Hash values 
        should also be hashes.  A hash value hash has two values: 
        <CODE::type> and <CODE::value>.  A <CODE::value>
        value is a parameter value.  If <CODE::type> is 
        <CODE::code>, then <CODE::value> is assumed as a Perl code fragment.
        Otherwise, <CODE::value> is quoted to be interpreted as a string as is.
    @@Return:
      @@@RaiseException:
        @@@@@: RESOURCE_NOT_DEFINED_ERR
        @@@@enDesc:
          Either <P::xclass>, <P::xcode> or <P::xsubtype>
          is not defined.
      @@@PerlDef:
        my $statement = $parentNode-><M::PLBlockCon.appendStatement>
          ('report '.
           $xclass-><AG::ManakaiDISResourceDefinition.plFullyQualifiedName>.
           ' -object => $self');
        my $xclass_module = $xclass-><AG::ManakaiDISResourceDefinition
                                            .ownerModule>;
        unless ($xclass-><AG::ManakaiDISResourceDefinition.isDefined> or
                not $xclass_module) {
          __EXCEPTION{RESOURCE_NOT_DEFINED_ERR::
            DIS:sourceNode => {$self->{src}},
            DIS:uri => {$xclass->{uri}},
            DIS:localName => {$xclass->{localName}},
            DIS:expectedType => {<Q::DOMException:AnyExceptionClass>},
          }__;
        }
        $xclass_module-><AS::ManakaiDISResourceDefinition
                                                   .isReferred> ($self->{src});
        $self-><M::ManakaiDISResourceDefinition.plAddRequireResource>
                               ($xclass_module => $statement);
        $xparam->{-type} = {type => 'quoted',
                            value => $xcode-><AG::ManakaiDISResourceDefinition
                                                  .plName>};
        $xparam->{<Q::MDOMX:subtype>} = {type => 'quoted',
                                         value => $xsubtype->{nameURI}}
          if $xsubtype;
        for my $name (keys %$xparam) {
          my $pname = $name;
          $pname =~ s/(['\\])/\\$1/g;
          $pname = qq<'$pname'>;
          $statement-><M::PLInCon.appendCode>
                           (', ' . $pname . ' => ');
          if ($xparam->{$name}->{type} eq 'code') {
            if (ref $xparam->{$name}->{value}) {
              $statement-><M::PLInCon.appendCodeFragment>
                           ($xparam->{$name}->{value});
            } else {
              $statement-><M::PLInCon.appendCodeFragment>
                       ($self-><M::ManakaiDISResourceDefinition
                                  .plPreprocessPerlStatement>
                                     ($xparam->{$name}->{value}));
            }
          } else {  ## String as is
            $statement-><M::PLAnyCon.appendStringLiteral>
                           ($xparam->{$name}->{value});
          }
        }

  @Attr:
    @@Name: plIsNullable
    @@enDesc:
      Whether this resource is <QUOTE::nullable> or not. 
      <QUOTE::Nullability> is defined for method parameters, 
      method returns, attribute getters and attribute setters.
    @@Type:
      DOMMain:boolean::ManakaiDOM:all
    @@Get:
      @@@RaiseException:
        @@@@@:NO_DIS_TYPE_ERR
        @@@@enDesc:
          There is a <Q::ManakaiDOM:InCase> child resource 
          that does not have <Q::dis:Type> attribute.
      @@@PerlDef:
        __DEEP{
          for my $incase (@{$self-><M::ManakaiDISPropertyAccessor
                                     .getPropertyResourceList>
                                        (<Q::DIS:childResource>)}) {
            next unless $incase-><M::ManakaiDISResourceDefinition.isTypeURI>
                                        (<Q::ManakaiDOM:InCase>);
            if ($incase-><AG::ManakaiDISResourceDefinition.disIsNullValue> or
                $incase-><AG::ManakaiDISResourceDefinition
                                             .disActualDataTypeResource>
                            -><M::ManakaiDISResourceDefinition
                                     .isSubsetOfURI> (<Q::DOMMain:boolean>)) {
              $r = true;
              last;
            }
          }
        }__;

  @Attr:
    @@Name: disIsNullValue
    @@enDesc:
      Whether this resource have <DOM::null> value or not. 
      A resource have <DOM::null> value iff it has
      <Q::dis:Value> attribute node that in turn has
      <Q::dis:is-null> attribute whose value set to <DOM::true>.
    @@Type:
      DOMMain:boolean::ManakaiDOM:all
    @@Get:
      @@@PerlDef:
        if ($self->{src}) {
          __DEEP{
            my $val = $self->{src}-><M::ManakaiDISElement.disGetAttribute>
                                           (<Q::dis:Value>,
                                            for_arg => $self->{for},
                                            forp_arg => $self->{forp});
            if ($val) {
              my $isnull = $val-><M::ManakaiDISElement.disGetAttribute>
                                           (<Q::dis:is-null>,
                                            for_arg => $self->{for},
                                            forp_arg => $self->{forp});
              if ($isnull and $isnull-><M::swcfg21:SWCFGNode::swcfg21:ForLatest
                                           .value>) {
                $r = true;
              }
            }
          }__;
        }

  @Attr:
    @@Name:plIsDefined
    @@enDesc:
      Whether a Perl implementation for this resource is available or not.
    @@Type:
      DOMMain:boolean::ManakaiDOM:all
    @@Get:
      @@@TrueCase:
        @@@@enDesc:
          This resource has its Perl definition and it is implemented.
      @@@FalseCase:
        @@@@enDesc:
          Either this resource does not have any Perl definition
          or it does have but it is not implemented yet.
      @@@PerlDef:
        if (exists $self->{<Q::TreeCore:node>}->{<Q::DIS:plDefined>}) {
          $r = $self->{<Q::TreeCore:node>}->{<Q::DIS:plDefined>};
        } else {
          __DEEP{
            my $typeuri = {
              <Q::ManakaiDOM:Class> => [
                <Q::DISLang:Method>, <Q::DISLang:Attribute>,
              ],
              <Q::DISLang:Method> => [
                <Q::DISLang:MethodReturn>,
              ],
              <Q::DISLang:Attribute> => [
                <Q::DISLang:AttributeGet>, <Q::DISLang::AttributeSet>,
              ],
            };
            OUTMOST:
            for my $mytype (keys %$typeuri) {
              if ($self-><M::ManakaiDISResourceDefinition.isTypeURI> ($mytype)) {
                for my $ctype ($typeuri->{$mytype}) {
                  for my $cres (@{$self-><M::ManakaiDISPropertyAccessor
                                            .getPropertyResourceList>
                                          (<Q::DIS:childResource>)}) {
                    if ($cres-><M::ManakaiDISResourceDefinition.isTypeURI>
                                                                 ($ctype)) {
                      unless ($cres-><AG::ManakaiDISResourceDefinition
                                         .plIsDefined>) {
                        $r = false; last OUTMOST;
                      }
                    }
                  }
                  next OUTMOST;
                }
              }
            } # OUTMOST
          }__;
          $self->{<Q::TreeCore:node>}->{<Q::DIS:plDefined>} = $r;
        }
  
  @IntMethod:
    @@Name: plAddRequireResource
    @@enDesc:
      Adds a resource to the list of resources that should
      be <Perl::require>d from a Perl code fragment.
    @@Param:
      @@@Name: resourceArg
      @@@Type: ManakaiDISResourceDefinition
      @@@enDesc:
        A resource that is <Perl::require>d by <P::codeArg>.
    @@Param:
      @@@Name: codeArg
      @@@Type: MPLCodeFragment
      @@@enDesc:
        A code fragment.  <P::resourceArg> is added to the
        list of <Perl::require>d resources of this code fragment.
    @@Return:
      @@@PerlDef:
        __DEEP{
          $codeArg-><M::MPLCodeFragment.disAddRequireURI>
                      ($resourceArg-><AG::ManakaiDISResourceDefinition.uri>);
        }__;

  @Attr:
    @@ManakaiDOM:isForInternal:1
    @@Name: plMufDescriptionText
    @@enDesc:
      {TODO:: Formal documentation-access API required.
      \
      }
    @@Get:
      @@@Type:
        DISLang:String::ManakaiDOM:all
      @@@PerlDef:
        __DEEP{
          my $muf = $self->{src}-><M::ManakaiDISElement.disGetAttribute>
                             (<Q::dis:Def>, for_arg => $self->{for},
                              forp_arg => $self->{forp},
                              media_type => <Q::lang:muf>);
          if ($muf) {
            $r = $muf-><M::SWCFGNode.value>;
            $r =~ s/<Q::([^<>]+)>/$self->{src}-><M::ManakaiDISElement.
                                     qnameToURI> ($1, node => $muf)/ge;
            $r =~ s/\s+/ /g;
            $r =~ s/^ //;
            $r =~ s/ $//;
          } else {
            my $desc = $self->{src}-><M::ManakaiDISElement.disGetAttribute>
                             (<Q::dis:Description>, for_arg => $self->{for},
                              forp_arg => $self->{forp},
                              media_type => <Q::lang:disdoc>,
                              default_media_type => <Q::lang:disdoc>);
            if ($desc) {
              $r = $desc-><M::SWCFGNode.value>;
              $r =~ s/\s+/ /g;
              $r =~ s/^ //;
              $r =~ s/ $//;
              $r =~ s/%/%percent;/g;
            }
          }
        }__;
      @@@ImplNote:
        @@@@lang:en
        @@@@@: Currently only common-used patterns are supported.

  @Method:
    @@Name: isFeatureProvided
    @@enDesc:
      Whether a feature is provided by this resource or not.
      Note that the feature is actually available (implemented)
      or not is other thing (use <M::ManakaiDISPerlModuleDefinition
      .plIsFeatureImplemented> instead).
    @@Param:
      @@@Name: featureResourceURI
      @@@Type: ResourceURI
      @@@enDesc:
        The URI reference of the resource definition for the feature to test.
    @@Return:
      @@@Type:
        DOMMain:boolean::ManakaiDOM:all
      @@@enDesc:
        Whether the feature is provided or not.
      @@@PerlDef:
      __DEEP{
        my @f = @{$self-><M::ManakaiDISPropertyAccessor
                               .getPropertyResourceList>
                                  (<Q::DOMMain:implementFeature>,
                                   recursive_isa => true,
                                   default_media_type => <Q::dis:TypeQName>)};
        if (@f) {
          for my $f (@f) {
            if ($f-><M::ManakaiDISResourceDefinition.isSubsetOfURI>
                         ($featureResourceURI)) {
              $r = true;
              last;
            }
          }
        } else {
          my $parent = $self-><M::ManakaiDISPropertyAccessor
                                 .getPropertyResource>
                                   (<Q::dis2pm:parentResource>);
          $r = $parent-><M::ManakaiDISResourceDefinition.isFeatureProvided>
                                   ($featureResourceURI)
            if $parent;
        }
      }__;

  @Attr:
    @@Name: featureNameList
    @@enDesc:
      The list of the names of the feature defined by this resource.
    @@Type:
      Perl:ARRAY::ManakaiDOM:all
    @@Get:
      @@@RaiseException:
        @@@@@:UNSUPPORTED_MEDIA_TYPE_ERR
        @@@@enDesc:
          There is an <Q::dis:AppName> attribute whose media 
          type is not supported.
      @@@RaiseException:
        @@@@@: NO_SOURCE_NODE_ERR
        @@@@enDesc:
          This resource definition does not have associated node 
          in the source tree. 
      @@@PerlDef:
        unless ($self->{src}) {
          __EXCEPTION{NO_SOURCE_NODE_ERR::
            DIS:uri => {$self->{uri}},
          }__;
        }
        __DEEP{
          for my $ce (@{$self->{src}-><M::ManakaiDISElement.disChildElements>
                            (for_arg => $self->{for},
                             forp_arg => $self->{forp})}) {
            if ($ce-><AG::swcfg21:SWCFGElement::swcfg21:ForLatest.expandedURI>
                     eq <Q::dis:AppName>) {
              if ($ce-><M::ManakaiDISElement.mediaTypeMatch>
                            (<Q::dis:TypeQName>,
                             for_arg => $self->{for},
                             forp_arg => $self->{forp},
                             default_media_type => <Q::dis:String>)) {
                push @$r, lc $ce-><AG::ManakaiDISElement.qnameValueURI>;
              } elsif ($ce-><M::ManakaiDISElement.mediaTypeMatch>
                            (<Q::dis:String>,
                             for_arg => $self->{for},
                             forp_arg => $self->{forp},
                             default_media_type => <Q::dis:String>)) {
                push @$r, lc $ce-><M::SWCFGNode.value>;
              } else {
                my $mt = $ce-><M::ManakaiDISElement.mediaTypeURI>
                                   (for_arg => $self->{for},
                                    forp_arg => $self->{forp});
                __UNDEEP{
                  __EXCEPTION{UNSUPPORTED_MEDIA_TYPE_ERR::
                    DIS:uri => {$mt},
                    DIS:sourceNode => {$ce},
                  }__;
                }__;
              }
            }
          }
          unless (@$r) {
            if ($self-><AG::ManakaiDISResourceDefinition.isAnonymous>) {
              my $ln = $self-><AG::ManakaiDISResourceDefinition.localName>;
              push @$r, $ln if defined $ln;
            } else {
              push @$r, $self-><AG::ManakaiDISResourceDefinition.nameURI>;
            }
          }
        }__;
##DISResourceDefinition

PropDef:
  @QName:plDefined
  @enDesc:
    Whether a Perl definition for this resource is implemented or not.

ElementTypeBinding:
  @Name: BlockElementException
  @ElementType:
    ManakaiDOM:raises
  @ShadowContent:
    @@@: PERL_PREPROCESS_NO_EXCEPTION_TYPE_ERR
    @@Description:
      @@@lang:en
      @@@@:
        An exception type specification is required but not specified.
  @ShadowSibling:
    @@ManakaiDOM:raises:
      @@@@: PERL_PREPROCESS_NO_CODE_NAME_ERR
      @@@Description:
        @@@@lang:en
        @@@@@:
          A code qualified name is required but not specified.
    @@ManakaiDOM:raises:
      @@@@: RESOURCE_NOT_DEFINED_ERR
      @@@Description:
        @@@@lang:en
        @@@@@:
          A referred resource is not defined or has different type.
    @@ManakaiDOM:raises:
      @@@@: PERL_CODE_NOT_DEFINED_ERR
      @@@Description:
        @@@@lang:en
        @@@@@:
          A referred resource does not have its Perl definition.
    @@ManakaiDOM:raises:
      @@@@: PERL_PREPROCESS_NO_METHOD_ERR
      @@@Description:
        @@@@lang:en
        @@@@@:
          A preprocessing instruction which is allowed only in 
          methods is embeded in a context which is not in any method.
    @@ManakaiDOM:raises:
      @@@@: PERL_PREPROCESS_NO_FOR_ERR
      @@@Description:
        @@@@lang:en
        @@@@@:
          A <QUOTE::for> qualified name is required but not specified.
    @@ManakaiDOM:raises:
      @@@@: PERL_PREPROCESS_NO_ASSERT_TYPE_ERR
      @@@Description:
        @@@@lang:en
        @@@@@:
          An assertion type qualified name is required but not specified.
    @@ManakaiDOM:raises:
      @@@@: PERL_PREPROCESS_BLOCK_NOT_ALLOWED_ERR
      @@@Description:
        @@@@lang:en
        @@@@@:
          A preprocessing instruction block is specified 
          but not allowed for this element type.

ElementTypeBinding:
  @Name: InlineElementException
  @ElementType:
    ManakaiDOM:raises
  @ShadowContent: 
    @@@: NO_SOURCE_NODE_ERR
    @@Description:
      @@@lang:en
      @@@@:
        This resource definition does not have associated node 
        in the source tree. 
  @ShadowSibling:
    @@ManakaiDOM:raises:
      @@@@: INTERFACE_CLASS_METHOD_ERR
      @@@Description:
        @@@@lang:en
        @@@@@:
          An attempt is made to call a class (static) method
          via an interface, not class. 
    @@ManakaiDOM:raises:
      @@@@: RESOURCE_NOT_DEFINED_ERR
      @@@Description:
        @@@@lang:en
        @@@@@:
          A package, method or attribute is not defined or not 
          a resoure of that type.
    @@ManakaiDOM:raises:
      @@@@: NO_LOCAL_NAME_ERR
      @@@Description:
        @@@@lang:en
        @@@@@:
          A referred resource does not have its local name so
          that it is impossible to refer it by name.
    @@ManakaiDOM:raises:
      @@@@: RESERVED_PERL_METHOD_NAME_ERR
      @@@Description:
        @@@@lang:en
        @@@@@:
          A referred method has its name reserved for special-purpose. 
    @@ManakaiDOM:raises:
      @@@@: BROKEN_PARAM_SPEC_ERR
      @@@Description:
        @@@@lang:en
        @@@@@:
          A parameter specification is not well-formed.
    @@ManakaiDOM:raises:
      @@@@: PERL_PREPROCESS_NO_CODE_NAME_ERR
      @@@Description:
        @@@@lang:en
        @@@@@:
          A preprocessing instruction does not contain
          Perl code fragment name. 
    @@ManakaiDOM:raises:
      @@@@: PERL_CODE_NOT_DEFINED_ERR
      @@@Description:
        @@@@lang:en
        @@@@@:
          The referred resource does not have its Perl definition.
    @@ManakaiDOM:raises:
      @@@@: PERL_PREPROCESS_NO_ELEMENT_TYPE_ERR
      @@@Description:
        @@@@lang:en
        @@@@@:
          A preprocessing instruction does not contain its element type name.
    @@ManakaiDOM:raises:
      @@@@: UNSUPPORTED_ELEMENT_TYPE_ERR
      @@@Description:
        @@@@lang:en
        @@@@@:
          An unknown element type is encounted.
    @@ManakaiDOM:raises:
      @@@@: NO_PERL_PACKAGE_NAME_ERR
      @@@Description:
        @@@@lang:en
        @@@@@:
          No Perl package name is defined for a class or interface.

PropDef:
  @QName: ownerClass
  @enDesc:
    The class to which this resource belongs.
  @Type: ResourceURI
  @rdfs:range: 
    rdf:Resource
  @rdfs:domain: 
    ManakaiDOM:Class

ResourceDef:
  @QName: DOMMinImpl
  @rdf:type:
    ManakaiDOM:IF
  @AliasFor:
    DOMMetaImpl:ManakaiDOMMinimumImplementationIF::ManakaiDOM:ManakaiDOMLatest

ResourceDef:
  @QName: PLPack
  @rdf:type:
    ManakaiDOM:Class
  @AliasFor:
    PerlCode:ManakaiPerlPackageScope::ManakaiDOM:Perl

ResourceDef:
  @QName: SWCFGNode
  @rdf:type:
    ManakaiDOM:IF
  @AliasFor:
    swcfg21:SWCFGNode::swcfg21:ForLatest

ResourceDef:
  @QName: SWCFGDoc
  @rdf:type:
    ManakaiDOM:IF
  @AliasFor:
    swcfg21:SWCFGDocument::swcfg21:ForLatest

ResourceDef:
  @QName: MPLImpl
  @rdf:type:
    ManakaiDOM:Class
  @AliasFor:
    PerlCode:ManakaiPerlCodeImplementation::ManakaiDOM:Perl

ResourceDef:
  @QName: MPLCodeFragment
  @rdf:type:
    ManakaiDOM:Class
  @AliasFor:
    PerlCode:ManakaiPerlCodeFragment::ManakaiDOM:Perl

ResourceDef:
  @QName: PLInCon
  @rdf:type:
    ManakaiDOM:Class
  @AliasFor:
    PerlCode:ManakaiPerlInlineContainer::ManakaiDOM:Perl

ResourceDef:
  @QName: PLBlockCon
  @rdf:type:
    ManakaiDOM:Class
  @AliasFor:
    PerlCode:ManakaiPerlStatementContainer::ManakaiDOM:Perl

ResourceDef:
  @QName: PLAnyCon
  @rdf:type:
    ManakaiDOM:Class
  @AliasFor:
    PerlCode:ManakaiPerlAnyContainer::ManakaiDOM:Perl

ResourceDef:
  @QName: MPLSS
  @rdf:type:
    ManakaiDOM:Class
  @AliasFor:
    PerlCode:ManakaiPerlStatementContainer::ManakaiDOM:Perl

ResourceDef:
  @QName: MPLSub
  @rdf:type:
    ManakaiDOM:Class
  @AliasFor:
    PerlCode:ManakaiPerlSub::ManakaiDOM:Perl

ResourceDef:
  @QName: MPLUnparsedCode
  @rdf:type:
    ManakaiDOM:Class
  @AliasFor:
    PerlCode:ManakaiPerlUnparsedCode::ManakaiDOM:Perl

PropDef:
  @QName: plCodeFragment
  @enDesc:
    Cache for <A::ManakaiDISResourceDefinition.plCodeFragment>.

XParamDef:
  @QName: errResource
  @enDesc:
    A resource on which an error has occurred. 

XParamDef:
  @QName: generatedName
  @enDesc:
    A generated name. 

ClsDef:
  @ClsQName: ManakaiDISPropertyAccessor
  @enDesc:
    Accessor methods for resource or module properties. 
  
  @Attr:
    @@Name:plImplementation
    @@enDesc:
      The <Class::PerlCode:ManakaiPerlCodeImplementation> object. 
    @@Type: MPLImpl
    @@Get:
      @@@enDesc:
        The Perl code implementation object. 
      @@@nullCase:
        This resource has no source tree associated. 
      @@@RaiseException:
        @@@@@:NO_PERL_CODE_IMPL_ERR
        @@@@enDesc:
          There is no implementation that implements 
          the <Feature::Util:PerlCode> feature, version <FeatureVer::1.0>. 
      @@@PerlDef:
        if ($self->{src}) {
          __DEEP{
            $r = ($self->{src}-><AG::SWCFGNode.ownerDocument> or
                        $self->{src})-><AG::SWCFGDoc.implementation>
                           -><M::DOMMinImpl.getFeature>
                                   (<Q::Util:PerlCode> => '1.0');
          }__;
          unless (defined $r) {
            __EXCEPTION{NO_PERL_CODE_IMPL_ERR::
              
            }__;
          }
        }

  @Attr:
    @@Name: ownerModule
    @@enDesc:
      The <QUOTE::dis> module in which this object is defined. 
      For a <QUOTE::dis> module object, the module itself is the
      <QUOTE::owner>.
    @@Get:
      @@@Type: ManakaiDISModuleDefinition
      @@@PerlDef: $r = $self;

  @Attr:
    @@Name: sourceElement
    @@enDesc:
      The source <QUOTE::dis> element node from which this 
      definition is read. 
    @@Get:
      @@@Type: ManakaiDISElement
      @@@InCase:
        @@@@Type: ManakaiDISModuleElement
        @@@@enDesc: If this resource is a module.
      @@@PerlDef: $r = $self->{src};
      @@@nullCase:
        @@@@enDesc:
          The definition is not yet read.

  @Method:
    @@Name: getPropertyBoolean
    @@enDesc:
      Gets boolean property value. 
    @@PropNameParam:
    @@Param:
      @@@Name:default
      @@@Type:
        DOMMain:boolean::ManakaiDOM:all
      @@@enDesc:
        The default value that is returned if no explicit property 
        value specification found for this resource. 
    @@Return:
      @@@Type:
        DOMMain:boolean::ManakaiDOM:all
      @@@enDesc:
        The property value. 
      @@@PerlDef:
        if (exists $self->{$propName}) {
          $r = defined $self->{$propName} ? $self->{$propName} : $default;
        } elsif ($self->{src}) {
          my $attr_node = $self->{src}-><M::ManakaiDISElement.disGetAttribute>
                                ($propName, for_arg => $self->{for},
                                 forp_arg => $self->{forp});
          $r = $self->{$propName} = ($attr_node
                                  ? ($attr_node-><M::SWCFGNode.value>
                                       ? true : false)
                                  : null);
          $r = $default unless defined $r;
        } else {
          $r = $default;
        }
        
  @Method:
    @@Name: getPropertyText
    @@enDesc:
      Gets property value text. 
    @@PropNameParam:
    @@Param:
      @@@Name:default
      @@@Type:
        swcfg21:SWCFGString::swcfg21:ForLatest
      @@@enDesc:
        The default value that is returned if no explicit property 
        value specification found for this resource. 
      @@@nullCase:
        @@@@enDesc:
          No default value supplied; <DOM::null> is returned if 
          no value specified. 
    @@Return:
      @@@Type:
        swcfg21:SWCFGString::swcfg21:ForLatest
      @@@enDesc:
        The property value string. 
      @@@nullCase:
        @@@@enDesc:
          No value nor default value has specified. 
      @@@PerlDef:
        if (exists $self->{$propName}) {
          $r = defined $self->{$propName} ? $self->{$propName} : $default;
        } elsif ($self->{src}) {
          $r = $self->{src}-><M::ManakaiDISElement.disGetAttribute>
                                ($propName, for_arg => $self->{for},
                                 forp_arg => $self->{forp});
          if ($r) {
            $r = $self->{$propName}
               = $r-><M::swcfg21:SWCFGNode::swcfg21:ForLatest.value>;
            $r = $default unless defined $r;
          } else {
            $r = $default;
            $self->{$propName} = null;
          }
        } else {
          $r = $default;
        }
        
  @Method:
    @@Name: getPropertyResource
    @@enDesc:
      Gets property value resource. 
    @@PropNameParam:
    @@NamedParam:
      @@@Name: defaultMediaType
      @@@Type: ResourceURI
      @@@enDesc:
        The URI reference of the default media type which is used 
        when the property value is retrieved from the source tree 
        and the source tree element does not have its <Q::dis:ContentType>
        attribute specified. 
      @@@nullCase:
        @@@@enDesc:
          Defaulted to <Q::dis:TypeQName>.
    @@Return:
      @@@Type: ManakaiDISResourceDefinition
      @@@enDesc:
        The property value resource. 
      @@@nullCase:
        @@@@enDesc:
          No value has specified. 
      @@@UndeclaredPrefixException:
      @@@RaiseException:
        @@@@@:UNSUPPORTED_MEDIA_TYPE_ERR
        @@@@enDesc:
          The media type of the attribute node in the source tree
          corresponding to this resource is not supported. 
      @@@PerlDef:
        if (defined $self->{$propName}) {
          $r = $self->{db}-><M::ManakaiDISDatabase.getResource>
                                                    ($self->{$propName});
        } elsif ($self->{src}) {
          __DEEP{
            $r = $self->{src}-><M::ManakaiDISElement.disGetAttribute>
                                  ($propName, for_arg => $self->{for},
                                   forp_arg => $self->{forp});
            if ($r) {
              $defaultMediaType = <Q::dis:TypeQName>
                                           unless defined $defaultMediaType;
              if ($r-><M::ManakaiDISElement.mediaTypeMatch>
                                   (<Q::dis:TypeQName>, $defaultMediaType,
                                    for_arg => $self->{for},
                                    forp_arg => $self->{forp})) {
                $self->{$propName}
                   = $r-><AG::ManakaiDISElement.qnameValueURI>;
              } elsif ($r-><M::ManakaiDISElement.mediaTypeMatch>
                                   (<Q::dis:TFQNames>, $defaultMediaType,
                                    for_arg => $self->{for},
                                    forp_arg => $self->{forp})) {
                $self->{$propName}
                   = $r-><M::ManakaiDISElement.tfqnamesValueURI>
                             ($self->{src}-><AG::swcfg21:SWCFGNode
                                               ::swcfg21:ForLatest.nodeID>,
                              $self->{for});
              } else {
                my $mt = $r-><M::ManakaiDISElement.mediaTypeURI>
                                   (for_arg => $self->{for},
                                    forp_arg => $self->{forp});
                __UNDEEP{
                  __EXCEPTION{UNSUPPORTED_MEDIA_TYPE_ERR::
                    DIS:uri => {$mt},
                    DIS:sourceNode => {$r},
                  }__;
                }__;
              }
              $r = $self->{db}-><M::ManakaiDISDatabase.getResource>
                                                    ($self->{$propName});
              $r-><AS::ManakaiDISResourceDefinition.isReferred> ($self->{src});
            }
          }__;
        }

  @Method:
    @@Name: getPropertyResourceList
    @@enDesc:
      Gets property value resource list. 
    @@PropNameParam:
    @@NamedParam:
      @@@Name: recursive
      @@@Type:
        DOMMain:boolean::ManakaiDOM:all
      @@@enDesc:
        Whether property resource values of this resource
        should also be included to the returned list or not.
    @@NamedParam:
      @@@Name: recursiveISA
      @@@Type:
        DOMMain:boolean::ManakaiDOM:all
      @@@enDesc:
        Whether property resource values of <Q::dis:ISA> resources 
        of this resource should also be included to the returned list or not. 
    @@NamedParam:
      @@@Name: defaultMediaType
      @@@Type: ResourceURI
      @@@enDesc:
        The URI reference of the default media type which is used 
        when the property value is retrieved from the source tree 
        and the source tree element does not have its <Q::dis:ContentType>
        attribute specified. 
      @@@nullCase:
        @@@@enDesc:
          Defaulted to <Q::dis:TypeQName>.
    @@Return:
      @@@Type: ResourceList
      @@@enDesc:
        An array reference of the property value resources. 
        \
        {NOTE:: This list is <QUOTE::dead>.
        \
        }
      @@@UndeclaredPrefixException:
      @@@RaiseException:
        @@@@@:UNSUPPORTED_MEDIA_TYPE_ERR
        @@@@enDesc:
          The media type of the attribute node in the source tree
          corresponding to this resource is not supported. 
      @@@PerlDef:
        $r = [];
        if (defined $self->{$propName}) {
          for my $res_uri (@{ref $self->{$propName} eq 'ARRAY'
                                         ? $self->{$propName} : []}) {
            push @$r,
                 $self->{db}-><M::ManakaiDISDatabase.getResource> ($res_uri);
          }
        } elsif ($self->{src}) {
          __DEEP{
            $self->{$propName} = [];
            $defaultMediaType = <Q::dis:TypeQName>
                                           unless defined $defaultMediaType;
            for my $res_name_node
                    (@{$self->{src}-><M::ManakaiDISElement.disGetAttributeList>
                                  ($propName, for_arg => $self->{for},
                                   forp_arg => $self->{forp})}) {
              my $res_uri;
              if ($res_name_node-><M::ManakaiDISElement.mediaTypeMatch>
                                   (<Q::dis:TypeQName>, $defaultMediaType,
                                    for_arg => $self->{for},
                                    forp_arg => $self->{forp})) {
                $res_uri = $res_name_node-><AG::ManakaiDISElement.qnameValueURI>;
              } elsif ($res_name_node-><M::ManakaiDISElement.mediaTypeMatch>
                                   (<Q::dis:TFQNames>, $defaultMediaType,
                                    for_arg => $self->{for},
                                    forp_arg => $self->{forp})) {
                $res_uri =$res_name_node-><M::ManakaiDISElement.tfqnamesValueURI>
                             ($self->{src}-><AG::swcfg21:SWCFGNode
                                               ::swcfg21:ForLatest.nodeID>,
                              $self->{for});
              } else {
                my $mt = $res_name_node-><M::ManakaiDISElement.mediaTypeURI>
                                   (for_arg => $self->{for},
                                    forp_arg => $self->{forp});
                __UNDEEP{
                  __EXCEPTION{UNSUPPORTED_MEDIA_TYPE_ERR::
                    DIS:uri => {$mt},
                    DIS:sourceNode => {$res_name_node},
                  }__;
                }__;
              }
              push @{$self->{$propName}}, $res_uri;
              my $res = $self->{db}-><M::ManakaiDISDatabase.getResource>
                                                                ($res_uri);
              push @$r, $res;
              $res-><AS::ManakaiDISResourceDefinition.isReferred>
                                                         ($res_name_node);
            }
          }__;
        }
        if ($recursive) {
          __DEEP{
            $opt{___recursive_isa_done} ||= {$self->{uri} => true};
            my @p_res = @$r;
            for my $p_res (@p_res) {
              next if $opt{___recursive_isa_done}->{$p_res->{uri}};
              $opt{___recursive_isa_done}->{$p_res->{uri}} = true;
              push @$r, @{$p_res-><M::ManakaiDISPropertyAccessor
                                     .getPropertyResourceList>
                                          ($propName, recursive => true,
                                           recursive_isa => $recursiveISA,
                         ___recursive_isa_done => $opt{___recursive_isa_done},
                         default_media_type => $defaultMediaType)};
            }
          }__;
        }
        if ($recursiveISA) {
          __DEEP{
            $opt{___recursive_isa_done} ||= {$self->{uri} => true};
            my @p_res = @$r;
            for my $p_res (@p_res) {
              next if $opt{___recursive_isa_done}->{$p_res->{uri}};
              $opt{___recursive_isa_done}->{$p_res->{uri}} = true;
              push @$r, @{$p_res-><M::ManakaiDISPropertyAccessor
                                     .getPropertyResourceList>
                                          (<Q::dis:ISA>, recursive_isa => true,
                                           recursive => $recursive,
                         ___recursive_isa_done => $opt{___recursive_isa_done},
                         default_media_type => $defaultMediaType)};
            }
          }__;
        }

  @Method:
    @@Name: addPropertyResourceList
    @@enDesc:
      Adds a resource to a resource-list property value. 
      \
      {ISSUE:: Should an exception be thrown if the property is 
               not of list?
      \
      }
      \
      {NOTE:: If the property is not <QUOTE::get>ten ever, adding 
              an item clears the list --- i.e. the property values 
              in the source tree will be ignored.  Call
              <M::ManakaiDISPropertyAccessor.getPropertyResourceList>
              before adding to avoid this behavior. 
      \
      }
    @@PropNameParam:
    @@Param:
      @@@Name: res
      @@@Type: ManakaiDISResourceDefinition
      @@@enDesc:
        A resource to add. 
    @@Return:
      @@@PerlDef:
        if (ref $self->{$propName} eq 'ARRAY') {
          push @{$self->{$propName}}, $res->{uri};
        } elsif (not defined $self->{$propName}) {
          $self->{$propName} = [$res->{uri}];
        }

ElementTypeBinding:
  @Name: PropNameParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:MethodParameter
    @@Name: propName
    @@Type: ResourceURI
    @@Description:
      @@@lang:en
      @@@@:
        The name of the property. 

##DISPropertyAccessor

PropDef:
  @QName:isAnon
  @Description:
    @@lang:en
    @@@:
      Whether the subject resource is anonymous or not. 
  @Type:
    DOMMain:boolean::ManakaiDOM:all

PropDef:
  @QName:isDefined
  @Description:
    @@lang:en
    @@@:
      Whether the subject resource is defined or not. 

PropDef:
  @QName:isReferred
  @Description:
    @@lang:en
    @@@:
      Whether the subject resource is referred or not. 
  @Type:
    DOMMain:any

PropDef:
  @QName:definingModule
  @Description:
    @@lang:en
    @@@:
      The <QUOTE::dis> module in which the subject resource is defined. 
      \
      {NOTE:: The local name should have been <QUOTE::ownerModule> or some.
      \
      }
  @rdfs:domain:
    DISCore:Module

## -- Datatypes

URITypeDef:
  @QName: AnyURI
  @Description:
    @@lang:en
    @@@:
      Any URI references. 

URITypeDef:
  @QName: FileURI
  @enDesc:
    URI references identifying file. 

URITypeDef:
  @QName: ForURI
  @Description:
    @@lang:en
    @@@:
      <QUOTE::For> URI references. 

DataTypeDef:
  @QName: ForURIList
  @Description:
    @@lang:en
    @@@:
      References to the array containing <QUOTE::for> URI references. 

URITypeDef:
  @QName: ResourceURI
  @Description:
    @@lang:en
    @@@:
      A URI reference for a <QUOTE::dis> resource. 

URITypeDef:
  @QName: MediaTypeURI
  @Description:
    @@lang:en
    @@@:
      Media type URI references. 
  @rdfs:subClassOf: ResourceURI

URITypeDef:
  @QName: ModuleURI
  @enDesc:
    URI references for <QUOET::dis> modules. 
  @rdfs:subClassOf: ResourceURI

URITypeDef:
  @QName: NameURI
  @enDesc:
    URI references identifying a resource. 
  @rdfs:subClassOf: ResourceURI

DataTypeDef:
  @QName: ResourceList
  @enDesc:
    References to array containing resource definition objects.
  @rdfs:subClassOf:
    Perl:ARRAY::ManakaiDOM:all

ElementTypeBinding:
  @Name: DataTypeDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:DataType

ElementTypeBinding:
  @Name: URITypeDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:DataType
    @@rdfs:subClassOf: AnyURI

## -- Exceptions

XParamDef:
  @QName: anotherSourceNode
  @enDesc:
    Another source node in which an error has occurred.  In cases 
    of <QUOTE::already defined> errors, it is the node that 
    defines the resource first. 
  @Type: ManakaiDISNode

ResourceDef:
  @QName: UNDECLARED_NS_PREFIX_ERR
  @For: ForLatest
  @AliasFor: 
    DIS:UNDECLARED_NS_PREFIX_ERR::swcfg21:ForLatest

ExceptionDef:
  @ClsQName: ManakaiDISException
  @enDesc:
    Exceptions for the <QUOTE::dis> operations. 
  @ClsISA:
    ManakaiDOM:ManakaiDOMException::ManakaiDOM:Perl
  @XConstGroupDef:
    @@ClsQName: ManakaiDISExceptionCode
    @@enDesc:
      Exception codes for <Class::ManakaiDISException>. 
    @@XConstDef:
      @@@Name: HIERARCHY_REQUEST_ERR
      @@@Value:3
      @@@enDesc:
        An attempt is made to break the hierarchy. 
      @@@XSubTypeDef:
        @@@@QName: MERGE_ITSELF_ERR
        @@@@enDesc:
          An attempt is made to merge the resource to itself. 
        @@@@XSourceNodeParam:
        @@@@XParam:
          @@@@@QName:uri
          @@@@@enDesc:
            The URI reference of the resource to merge. 
        @@@@enMufDef:
          An attempt is made to merge the resource <%p (name => {<Q::DIS:uri>}
          );> to itself
    @@XConstDef:
      @@@Name: NOT_SUPPORTED_ERR
      @@@Value:9
      @@@enDesc:
        An attempt is made to do something the implementation does not support. 
      @@@XSubTypeDef:
        @@@@QName: UNSUPPORTED_MEDIA_TYPE_ERR
        @@@@enDesc:
          The implementation does not support the media type. 
        @@@@XParam:
          @@@@@QName: uri
          @@@@@enDesc:
            The URI reference of the media type that is not supported. 
        @@@@XSourceNodeParam:
        @@@@enMufDef:
          Media type <%p (name => {<Q::DIS:uri>});> is not supported
      @@@XSubTypeDef:
        @@@@QName: UNSUPPORTED_ELEMENT_TYPE_ERR
        @@@@enDesc:
          An unsupported type of element is encounted.
        @@@@XSourceNodeParam:
        @@@@XParam:
          @@@@@QName:elementType
          @@@@@enDesc:
            The element type URI reference of the element.
        @@@@enMufDef:
          Element type "%p (name => {<Q::DIS:elementType>});" is not supported
      @@@XSubTypeDef:
        @@@@QName: NO_PERL_CODE_IMPL_ERR
        @@@@enDesc:
          There is no implementation that supports the 
          <Feature::Util:PerlCode> feature, version 
          <FeatureVer::1.0>.
    @@XConstDef:
      @@@Name: INVALID_STATE_ERR
      @@@Value:11
      @@@enDesc:
        An attempt is made to use an object that is not (or no longer) usable. 
      @@@XSubTypeDef:
        @@@@QName: NO_ASSOCIATED_DB_ERR
        @@@@enDesc:
          No <QUOTE::dis> database has been associated with this document. 
    @@XConstDef:
      @@@Name: INVALID_SOURCE_ERR
      @@@Value: 200
      @@@enDesc:
        The source input is well-formed but invalid. 
      @@@XSubTypeDef:
        @@@@QName: NO_MODULE_QNAME_ERR
        @@@@enDesc:
          The <Q::dis:Module> element must have its <Q::dis:QName> 
          attribute. 
        @@@@XSourceNodeParam:
      @@@XSubTypeDef:
        @@@@QName: NO_LOCAL_NAME_ERR
        @@@@enDesc:
          The resource does not have a local name. 
        @@@@XSourceNodeParam:
      @@@XSubTypeDef:
        @@@@QName: UNABLE_TO_GET_MODULE_ERR
        @@@@enDesc:
          The implementation is unable to get the module source. 
        @@@@Def:
          @@@@@ContentType:
            lang:muf
          @@@@@lang:en
          @@@@@@:
            Unable to get the module source of <%p (name => {<Q::DIS:uri>});>
        @@@@XParam:
          @@@@@QName: uri
          @@@@@enDesc:
            The URI reference of the module. 
        @@@@XParam:
          @@@@@QName: namespaceURI
          @@@@@enDesc:
            The namespace URI of the module name. 
        @@@@XParam:
          @@@@@QName: localName
          @@@@@enDesc:
            The local name of the module name. 
        @@@@XParam:
          @@@@@QName: for
          @@@@@enDesc:
            The <QUOTE::for> of the module.
      @@@XSubTypeDef:
        @@@@QName: NO_FOR_QNAME_ERR
        @@@@enDesc:
          A <Q::dis:ForDef> element must have <Q::dis:QName> attribute. 
        @@@@XSourceNodeParam:
      @@@XSubTypeDef:
        @@@@QName: FOR_ALREADY_DEFINED_ERR
        @@@@enDesc:
          The <QUOTE::for> named as the same URI reference has 
          already defined. 
        @@@@XSourceNodeParam:
        @@@@XParam:
          @@@@@QName: anotherSourceNode
          @@@@@enDesc:
            The node that defines the <QUOTE::for> URI reference before. 
        @@@@XParam:
          @@@@@Name: uri
          @@@@@enDesc:
            The URI reference of the <QUOTE::for> attempted to define. 
        @@@@enMufDef:
          <QUOTE::For> <%p (name => {<Q::DIS:uri>});> is already defined
      @@@XSubTypeDef:
        @@@@QName: RESOURCE_ALREADY_DEFINED_ERR
        @@@@enDesc:
          The <QUOTE::dis> resource named as the same URI reference has 
          already defined. 
        @@@@XSourceNodeParam:
        @@@@XParam:
          @@@@@QName: anotherSourceNode
          @@@@@enDesc:
            The node that defines the <QUOTE::for> URI reference before. 
        @@@@XParam:
          @@@@@Name: uri
          @@@@@enDesc:
            The URI reference of the resource attempted to define. 
        @@@@enMufDef:
          Resource <%p (name => {<Q::DIS:uri>});> is already defined
      @@@XSubTypeDef:
        @@@@QName: ELEMENT_NOT_ALLOWED_ERR
        @@@@enDesc:
          An element has occured where it is not allowed. 
        @@@@enMufDef:
          Module <%p (name => {<Q::DIS:uri>});>: 
          Element of type <%p (name => {<Q::DIS:elementType>});> 
          is not allowed here
        @@@@XSourceNodeParam:
        @@@@XParam:
          @@@@@QName: elementType
          @@@@@enDesc:
            The expanded element type name of the element. 
        @@@@XParam:
          @@@@@QName: uri
          @@@@@enDesc:
            The URI reference of the module. 
      @@@XSubTypeDef:
        @@@@QName: NO_REQUIRED_ATTR_ERR
        @@@@enDesc:
          A required attribute is not specified.
        @@@@XSourceNodeParam:
        @@@@XParam:
          @@@@@QName: elementType
          @@@@@enDesc:
            The expanded URI reference of the attribute name. 
        @@@@enMufDef:
          Attribute <%p (name => {<Q::DIS:elementType>});> must be specified
      @@@XSubTypeDef:
        @@@@QName: FOR_NOT_DEFINED_ERR
        @@@@enDesc:
          A <QUOTE::for> is referred but not defined. 
        @@@@XSourceNodeParam:
        @@@@XParam:
          @@@@@QName: uri
          @@@@@enDesc:
            The URI reference of the <QUOTE::for> that is not defined.
        @@@@enMufDef:
          <QUOTE::For> <%p (name => {<Q::DIS:uri>});> is not defined
      @@@XSubTypeDef:
        @@@@QName: RESOURCE_NOT_DEFINED_ERR
        @@@@enDesc:
          A <QUOTE::dis> resource is referred but not defined 
          or the resource referred does not have the type expected. 
        @@@@XSourceNodeParam:
        @@@@XParam:
          @@@@@QName: uri
          @@@@@enDesc:
            The URI reference of the resource that is not defined.
        @@@@XParam:
          @@@@@QName: elementType
          @@@@@enDesc:
            <QUOTE::dis> element type (either tree element type
            or preprocessing element type) of the element
            in which a reference to the undefined resource is contained.
        @@@@XParam:
          @@@@@QName: localName
          @@@@@enDesc:
            The local name of the undefined resource.
        @@@@XParam:
          @@@@QName: sourceCode
          @@@@enDesc:
            Source code fragment that referres this resource.
        @@@@XParam:
          @@@@@QName:expectedType
          @@@@@enDesc:
            Expected resource type.
        @@@@enMufDef:
          %p (name => {<Q::DIS:sourceCode>}, prefix => {"}, suffix => {": });
          Resource%p (name => {<Q::DIS:uri>}, prefix => { <},
          suffix => {>});%p (name => {<Q::DIS:localName>},
          prefix => { "}, suffix => {"}); is not defined or wrong type%p
          (name => {<Q::DIS:expectedType>}, prefix => { (<},
           suffix => {> is expected)});
      @@@XSubTypeDef:
        @@@@QName: NO_SOURCE_NODE_ERR
        @@@@enDesc:
          A resource does not have associated node in the source tree.
        @@@@XSourceNodeParam:
        @@@@XParam:
          @@@@@QName:uri
          @@@@@enDesc:
            The URI reference of the resource.
      @@@XSubTypeDef:
        @@@@QName: RESERVED_PERL_METHOD_NAME_ERR
        @@@@enDesc:
          A reserved Perl method name is used. 
        @@@@XParam:
          @@@@@QName:uri
          @@@@@enDesc:
            The URI reference of the method resource. 
        @@@@XSourceNodeParam:
        @@@@XParam:
          @@@@@QName: generatedName
          @@@@@enDesc:
            A reserved method name. 
      @@@XSubTypeDef:
        @@@@QName: NO_DIS_TYPE_ERR
        @@@@enDesc:
          <Q::dis:Type> attribute is not found. 
        @@@@XSourceNodeParam:
      @@@XSubTypeDef:
        @@@@QName: NO_METHOD_RETURN_ERR
        @@@@enDesc:
          A <Q::DISLang:Method> resource does not have any
          <Q::DISLang:MethodReturn> child. 
        @@@@XSourceNodeParam:
        @@@@XParam:
          @@@@@QName:errResource
          @@@@@enDesc: The method resource.
        @@@@XParam:
          @@@@@QName:uri
          @@@@@enDesc:
            The URI reference of the method.
        @@@@XParam:
          @@@@@QName:localName
          @@@@@enDesc:
            The local name of the resource.
        @@@@enMufDef:
          Method "%p (name => {<Q::DIS:localName>});" does not have
          "Return" child
      @@@XSubTypeDef:
        @@@@QName: NO_ATTR_GET_ERR
        @@@@enDesc:
          A <Q::DISLang:Attribute> resource does not have any
          <Q::DISLang:AttributeGet> child. 
        @@@@XSourceNodeParam:
      @@@XSubTypeDef:
        @@@@QName:INTERFACE_CLASS_METHOD_ERR
        @@@@enDesc:
          An attempt is made to call a static (class) method
          from an interface.
        @@@@XSourceNodeParam:
        @@@@XParam:
          @@@@@QName:uri
          @@@@@enDesc:
            The URI reference of the interface.
        @@@@XParam:
          @@@@@QName:sourceCode
          @@@@@enDesc:
            Source code fragment that calls a class method.
        @@@@XParam:
          @@@@@QName:elementType
          @@@@@enDesc:
            The element type URI reference of the element
            that calls a method.
      @@@XSubTypeDef:
        @@@@QName: BROKEN_PARAM_SPEC_ERR
        @@@@enDesc:
          A parameter specification is broken.
        @@@@XParam:
          @@@@@QName: sourceCode
          @@@@@enDesc:
            Source code fragment that contains the broken parameter
            specification.
        @@@@XSourceNodeParam:
        @@@@enMufDef:
          %p (name => {<Q::DIS:sourceCode>}, prefix => {"},
          suffix => {": });Broken parameter specification
      @@@XSubTypeDef:
        @@@@QName:PERL_PREPROCESS_NO_ELEMENT_TYPE_ERR
        @@@@enDesc:
          A preprocessing instruction does not have its element 
          type.
        @@@@XSourceNodeParam:
        @@@@XParam:
          @@@@@QName:sourceCode
          @@@@@enDesc:
            Source code fragment.
        @@@@enMufDef:
          %p (name => {<Q::DIS:sourceCode>}, prefix => {"}, 
              suffix => {": });Element type name is not specified
      @@@XSubTypeDef:
        @@@@QName: NO_PERL_PACKAGE_NAME_ERR
        @@@@enDesc:
          No Perl package name is defined for the resource referred.
        @@@@XSourceNodeParam:
        @@@@XParam:
          @@@@@QName:sourceCode
          @@@@@enDesc:
            Source code fragment.
        @@@@XParam:
          @@@@@QName:uri
          @@@@@enDesc:
            THe URI reference of the resource referred.
        @@@@XParam:
          @@@@@QName:elementType
          @@@@@enDesc:
            The element type of Perl preprocessing instruction 
            in which the resource is referred.
        @@@@enMufDef:
          %p (name => {<Q::DIS:uri>}, prefix => {<}, suffix => {>: });Perl 
          package name is not defined
      @@@XSubTypeDef:
        @@@@QName: PERL_PREPROCESS_NO_EXCEPTION_TYPE_ERR
        @@@@enDesc:
          An exception type specification is required.
        @@@@XSourceNodeParam:
        @@@@XSourceCodeParam:
        @@@@XParam:
          @@@@@QName:elementType
          @@@@@enDesc:
            The element type of the preprocessing instruction.
      @@@XSubTypeDef:
        @@@@QName: PERL_PREPROCESS_NO_CODE_NAME_ERR
        @@@@enDesc:
          A code name specification is required.
        @@@@XSourceNodeParam:
        @@@@XSourceCodeParam:
        @@@@XParam:
          @@@@@QName:elementType
          @@@@@enDesc:
            The element type of the preprocessing instruction.
      @@@XSubTypeDef:
        @@@@QName: PERL_CODE_NOT_DEFINED_ERR
        @@@@enDesc:
          The specified resource does not have its Perl definition.
        @@@@XSourceNodeParam:
        @@@@XSourceCodeParam:
        @@@@XParam:
          @@@@@QName:elementType
          @@@@@enDesc:
            The element type of the preprocessing instruction.
        @@@@XParam:
          @@@@@QName:uri
          @@@@@enDesc:
            The URI reference of the resource referred.
        @@@@XParam:
          @@@@@QName:localName
          @@@@@enDesc:
            The local name of the resource referred.
      @@@XSubTypeDef:
        @@@@QName: PERL_PREPROCESS_NO_METHOD_ERR
        @@@@enDesc:
          A preprocessing instruction which is only allowed in 
          method definitions is used in a code which is not a method.
        @@@@XSourceNodeParam:
        @@@@XSourceCodeParam:
        @@@@XParam:
          @@@@@QName:elementType
          @@@@@enDesc:
            The element type of the preprocessing instruction.
      @@@XSubTypeDef:
        @@@@QName: PERL_PREPROCESS_NO_FOR_ERR
        @@@@enDesc:
          A <QUOTE::for> specification is required.
        @@@@XSourceNodeParam:
        @@@@XSourceCodeParam:
        @@@@XParam:
          @@@@@QName:elementType
          @@@@@enDesc:
            The element type of the preprocessing instruction.
      @@@XSubTypeDef:
        @@@@QName: PERL_PREPROCESS_NO_ASSERT_TYPE_ERR
        @@@@enDesc:
          An assertion type specification is required.
        @@@@XSourceNodeParam:
        @@@@XSourceCodeParam:
        @@@@XParam:
          @@@@@QName:elementType
          @@@@@enDesc:
            The element type of the preprocessing instruction.
      @@@XSubTypeDef:
        @@@@QName: PERL_PREPROCESS_BLOCK_NOT_ALLOWED_ERR
        @@@@enDesc:
          A preprocessing instruction block occurred with 
          element type which does not allow it.
        @@@@XSourceNodeParam:
        @@@@XSourceCodeParam:
        @@@@XParam:
          @@@@@QName:elementType
          @@@@@enDesc:
            The element type of the preprocessing instruction.
      @@@XSubTypeDef:
        @@@@QName: NON_NAMED_PARAMETER_AFTER_NAMED_ERR
        @@@@enDesc:
          A non-named method parameter following
          any named method parameter is occurred.
        @@@@XSourceNodeParam:
        @@@@XParam:
          @@@@@QName:uri
          @@@@@enDesc:
            The URI reference of the non-named method parameter resource.
        @@@@XParam:
          @@@@@QName:localName
          @@@@@enDesc:
            The local name of the non-named method parameter.
      @@@XSubTypeDef:
        @@@@QName:DISPERL_NO_VALUE_ALLOWED_ERR
        @@@@enDesc:
          An element node have a value but the definition
          of that element type does not allow it.
        @@@@XSourceNodeParam:
        @@@@XParam:
          @@@@@QName:elementType
          @@@@@enDesc:
            The element type URI reference of the element.
      @@@XSubTypeDef:
        @@@@QName:NO_CONST_VALUE_ERR
        @@@@enDesc:
          The source element node for a constant value resource 
          does not have <Q::dis:Value> attribute.
        @@@@XSourceNodeParam:
        @@@@XParam:
          @@@@@QName:elemntType
          @@@@@enDesc:
            The element type URI reference of the element from which
            a constant value resource is referred.
        @@@@XParam:
          @@@@@QName:uri
          @@@@@enDesc:
            The resource URI reference of the constant value resource.
        @@@@XParam:
          @@@@@QName:localName
          @@@@@enDesc:
            The local name of the constant value resource.
     @@@XSubTypeDef:
       @@@@QName:NO_ATTR_SET_ERR
       @@@@enDesc:
         An attribute setter is referred but the attribute
         does not define any setter.
       @@@@XSourceNodeParam:
       @@@@XParam:
         @@@@@QName:errResource
         @@@@@enDesc:
           The attribute resource. 
       @@@@XParam:
         @@@@@QName:elementType
         @@@@@enDesc:
           The type of the element by which this attribute
           is referred.
     @@@XSubTypeDef:
       @@@@QName: PERL_SUBROUTINE_ALREADY_DEFINED_ERR
       @@@@enDesc:
         A resource defines a Perl subroutine whose name is 
         same as another subroutine. 
       @@@@XSourceNodeParam:
       @@@@XParam:
         @@@@@QName:uri
         @@@@@enDesc:
           The URI reference of the resource that defines the Perl subroutine. 
       @@@@XParam:
         @@@@@QName:
           PerlCode:localName
         @@@@@enDesc:
           The name of the Perl subroutine. 
     @@@XSubTypeDef:
       @@@@QName: PERL_OPERATOR_ALREADY_OVERLOADED_ERR
       @@@@enDesc:
         A resource is defined to overload a Perl operator which 
         is already overloaded by another resource.
       @@@@XSourceNodeParam:
       @@@@XParam:
         @@@@@QName:uri
         @@@@@enDesc:
           The URI reference of the resource that defines the overloading.
       @@@@XParam:
         @@@@@QName: 
           PerlCode:operator
         @@@@@enDesc:
           The operator. 
     @@@XSubTypeDef:
       @@@@QName: PERL_UNUSED_SUBROUTINE_ERR
       @@@@enDesc:
         A resource defines a Perl subroutine but it is not used.
       @@@@XSourceNodeParam:
       @@@@XParam:
         @@@@@QName:uri
         @@@@@enDesc:
           The URI reference of the resource.
     @@@XSubTypeDef:
       @@@@QName: NO_LICENSE_ATTR_ERR
       @@@@enDesc:
         The <Q::dis:Module> element does not have the
         <Q::dis:License> attribute.
       @@@@XSourceNodeParam:
       @@@@XParam:
         @@@@@QName:uri
         @@@@@enDesc:
           The URI reference of the module.
##DISException

XParamDef:
  @QName:expectedType
  @Type: ResourceURI
  @enDesc:
    Expected resource type URI reference.

XParamDef:
  @QName: sourceCode
  @Type:
    DISLang:String::ManakaiDOM:all
  @enDesc:
    The source code fragment in which an error occurred.

XParamDef:
  @QName: elementType
  @Type: ResourceURI
  @enDesc:
    The name of the element type. 

XParamDef:
  @QName: uri
  @Type: ResourceURI
  @enDesc:
    The name of the resource, composed from <Q::namespaceURI>, 
    <Q::localName> and <Q::for>. 

XParamDef:
  @QName: localName
  @Type: 
    DISCore:LocalName::ManakaiDOM:all
  @enDesc:
    The local name of the resource, unique in <Q::namespaceURI> namespace. 

XParamDef:
  @QName: namespaceURI
  @Type: AnyURI
  @enDesc:
    The namespace URI reference of the resource name. 

XParamDef:
  @QName: for
  @Type: ForURI
  @enDesc:
    The <QUOTE::for> URI reference of the resource. 

ElementTypeBinding:
  @Name: XSourceNodeParam
  @ElementType:
    ManakaiDOM:exceptionOrWarningParameter
  @ShadowContent:
    @@QName: sourceNode
    @@Description:
      @@@lang:en
      @@@@:
        The node in which an error has occurred. 

ElementTypeBinding:
  @Name: XSourceCodeParam
  @ElementType:
    ManakaiDOM:exceptionOrWarningParameter
  @ShadowContent:
    @@QName: sourceCode
    @@Description:
      @@@lang:en
      @@@@:
        The source code in which an error has occurred. 

ClsDef:
  @ClsQName: ManakaiDISExceptionTarget
  @enDesc:
    Objects that is able to be the target of an exception. 
  @IntMethod:
    @@Operator:
      @@@@:
        ManakaiDOM:MUErrorHandler
      @@@ContentType:
        dis:TypeQName
    @@Description:
      @@@lang:en
      @@@@:
        This method is a generic error handler; all manakai exceptions 
        and warnings associated to an object are once reported to this method 
        and then delivered to appropriate entities. 
        \
        If the error is an exception (such as <X::DOMCore:DOMException> or 
        <X::ManakaiDOM:ManakaiDOMImplementationException>), it is 
        simply thrown.  If the error is only a warning, it is reported 
        via the <IF::DOMCore:DOMError> interface. 
        \
        See <PerlModule::Message::Util::Error> documentation for more 
        information on the error reporting mechanism.
        \
        {NOTE:: This kind of methods are named as <Perl::___report_error> 
                in the convention of <PerlModule::Message::Util::Error>. 
        \
        }
    @@Param:
      @@@Name:err
      @@@Type: 
        ManakaiDOM:ManakaiDOMExceptionOrWarning::ManakaiDOM:Perl
      @@@Description:
        @@@@lang:en
        @@@@@:
          An exception object that describes what kind of error it is 
          and how it should be recovered. 
          \
          {NOTE:: Exception objects in manakai implementation 
                  inherit the class <PerlModule::Message::Util::Error>, 
                  that in turn inherits <PerlModule::Error>.
          \
          }
    @@Return:
      @@@PerlDef:
          if ($err->isa (<ClassName::ManakaiDOM:ManakaiDOMException
                                   ::ManakaiDOM:Perl>)) {
            $err->throw;
          } else {
            \## TODO: Implement warning reporting
            warn $err->stringify;
          }
##DISExceptionTarget

ForDef:
  @QName:
    DIS:ForIF
ForDef:
  @QName:
    DIS:ForClass

ElementTypeBinding:
  @Name: IFClsDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      @@@@:
        dis:MultipleResource
      @@@ForCheck: !ForClass !ForIF
    @@rdf:type:
      @@@@:
        ManakaiDOM:IF
      @@@ForCheck: ForIF
    @@rdf:type:
      @@@@:
        ManakaiDOM:Class
      @@@ForCheck: ForClass
    @@resourceFor: ForIF
    @@resourceFor:
      @@@@: ForClass
      @@@ForCheck: ForLatest
    @@DOMMain:implementFeature:
      @@@@:CoreFeature10
      @@@ForCheck: ForClass
    @@ForCheck:
      ManakaiDOM:Perl

ElementTypeBinding:
  @Name: ClsDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:Class
    @@AliasFor:
      @@@@:
        ::DIS:ForLatest
      @@@For:
        !=DIS:ForLatest
    @@ForCheck:
      ManakaiDOM:Perl
    @@DOMMain:implementFeature: CoreFeature10

ElementTypeBinding:
  @Name: ExceptionDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:ExceptionClass
    @@AliasFor:
      @@@@:
        ::ForLatest
      @@@For:
        !=ForLatest
    @@ForCheck:
      ManakaiDOM:Perl
    @@DOMMain:implementFeature: CoreFeature10

ElementTypeBinding:
  @Name: ClsQName
  @ElementType:
    dis:QName

ElementTypeBinding:
  @Name: ClsISA
  @ElementType:
    dis:ISA

ElementTypeBinding:
  @Name: Method
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:Method

ElementTypeBinding:
  @Name: IntMethod
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:Method
    @@ManakaiDOM:isForInternal:1

ElementTypeBinding:
  @Name: Attr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:Attribute

ElementTypeBinding:
  @Name: Return
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:MethodReturn

ElementTypeBinding:
  @Name: Get
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:AttributeGet

ElementTypeBinding:
  @Name: Set
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:AttributeSet

ElementTypeBinding:
  @Name: Param
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:MethodParameter

ElementTypeBinding:
  @Name: PerlDef
  @ElementType:
    dis:Def
  @ShadowContent:
    @@ContentType:
      lang:Perl

ElementTypeBinding:
  @Name: disDef
  @ElementType:
    dis:Def
  @ShadowContent:
    @@ContentType:
      lang:dis

ElementTypeBinding:
  @Name: InCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:InCase

ElementTypeBinding:
  @Name: nullCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:InCase
    @@Value:
      @@@is-null:1

ElementTypeBinding:
  @Name: TrueCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:InCase
    @@Value:true
    @@Type:
      DOMMain:boolean::ManakaiDOM:all


ElementTypeBinding:
  @Name: FalseCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:InCase
    @@Value:false
    @@Type:
      DOMMain:boolean::ManakaiDOM:all

ElementTypeBinding:
  @Name: enDesc
  @ElementType:
    dis:Description
  @ShadowContent:
    @@lang:en

ElementTypeBinding:
  @Name: PropDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      rdf:Property
    @@AliasFor:
      @@@@:
        ::ManakaiDOM:all
      @@@For:
        !=ManakaiDOM:all

ElementTypeBinding:
  @Name: MethodRedef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:Method
    @@ManakaiDOM:isRedefining:1

ElementTypeBinding:
  @Name: NamedParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:MethodParameter
    @@DISPerl:isNamedParameter:1

ElementTypeBinding:
  @Name: NodeParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:MethodParameter
    @@DISPerl:isNamedParameter:1
    @@Name: node
    @@Type: ManakaiDISNode
    @@Description:
      @@@lang:en
      @@@@:
        The node in which the name has occurred.  It is intended 
        to be reported when an exception had been raised. 
    @@ResourceDef:
      @@@rdf:type:
        ManakaiDOM:InCase
      @@@Value:
        @@@@is-null:1
      @@@Description:
        @@@@lang:en
        @@@@@:
          The source of the name is not a node. 

ElementTypeBinding:
  @Name: ForParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:MethodParameter
    @@DISPerl:isNamedParameter:1
    @@Name: forArg
    @@Type: ForURI
    @@Description:
      @@@lang:en
      @@@@:
        The <QUOTE::for> URI reference. 
    @@ResourceDef:
      @@@rdf:type:
        ManakaiDOM:InCase
      @@@Value:
        @@@@is-null:1
      @@@Description:
        @@@@lang:en
        @@@@@:
          Equivalent to <Q::ManakaiDOM:all>, i.e. <QUOTE::for all>. 

ElementTypeBinding:
  @Name: ForpParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:MethodParameter
    @@DISPerl:isNamedParameter:1
    @@Name: forpArg
    @@Type: ForURIList
    @@Description:
      @@@lang:en
      @@@@:
        An array reference containing additional <QUOTE::for> 
        constraints (<QUOTE::For+> list).
    @@ResourceDef:
      @@@rdf:type:
        ManakaiDOM:InCase
      @@@Value:
        @@@@is-null:1
      @@@Description:
        @@@@lang:en
        @@@@@:
          Equivalent to the empty array reference. 

ElementTypeBinding:
  @Name: MediaTypeParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:MethodParameter
    @@DISPerl:isNamedParameter:1
    @@Name: mediaType
    @@Type: MediaTypeURI
    @@Description:
      @@@lang:en
      @@@@:
        The URI reference identifying a media type. 
    @@ResourceDef:
      @@@rdf:type:
        ManakaiDOM:InCase
      @@@Value:
        @@@@is-null:1
      @@@Description:
        @@@@lang:en
        @@@@@:
          No media type specified. 

ElementTypeBinding:
  @Name: MediaTypeDefaultParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:MethodParameter
    @@DISPerl:isNamedParameter:1
    @@Name: defaultMediaType
    @@Type: MediaTypeURI
    @@Description:
      @@@lang:en
      @@@@:
        The default media type, i.e. the type used when no explicit 
        specification is not found in the source tree. 
    @@ResourceDef:
      @@@rdf:type:
        ManakaiDOM:InCase
      @@@Value:
        @@@@is-null:1
      @@@Description:
        @@@@lang:en
        @@@@@:
          Defaulted to <Q::DOMMain:any>. 

ElementTypeBinding:
  @Name: RaiseException
  @ElementType:
    ManakaiDOM:raises

ElementTypeBinding:
  @Name: UndeclaredPrefixException
  @ElementType:
    ManakaiDOM:raises
  @ShadowContent:
    @@@: UNDECLARED_NS_PREFIX_ERR
    @@Description:
      @@@lang:en
      @@@@:
        The implementation has encounted an undeclared namespace prefix. 

ElementTypeBinding:
  @Name: NoDBException
  @ElementType:
    ManakaiDOM:raises
  @ShadowContent:
    @@@: NO_DB_ASSOCIATED_ERR
    @@Description:
      @@@lang:en
      @@@@:
        No <QUOTE::dis> database is associated to this document. 

ElementTypeBinding:
  @Name: XConstGroupDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:ConstGroup
    @@Type:
      DOMMain:unsigned-short::ManakaiDOM:all
    @@rdfs:subClassOf:
      DOMMain:unsigned-short::ManakaiDOM:all

ElementTypeBinding:
  @Name: XConstDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:Const

ElementTypeBinding:
  @Name: XSubTypeDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:ExceptionOrWarningSubType

ElementTypeBinding:
  @Name: XParam
  @ElementType:
    ManakaiDOM:exceptionOrWarningParameter

ElementTypeBinding:
  @Name: XParamDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: 
      DOMMain:XWParameter
    @@For:
      =ManakaiDOM:all

ElementTypeBinding:
  @Name: enMufDef
  @ElementType:
    dis:Def
  @ShadowContent:
    @@ContentType:
      lang:muf
    @@lang:en

ResourceDef:
  @QName:
    lang:muf
  @rdf:type:
    rdfs:Class
  @ImplNote:
    @@lang:en
    @@@:
      Should be moved to some other module.

