Module:
  @QName:
    Util:DIS
  @FullName:
    @@lang: en
    @@@:
      <QUOTE::DIS> Object Model
  @Namespace:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS#
  
  @Description:
    @@lang:en
    @@@:
      This module provides an object model for <QUITE::dis> document format.  

  @Author:
    @@FullName: Wakaba
    @@Mail: w@suika.fam.cx
  @License:
    @@@:
      license:Perl+MPL
    @@Original:
      @@@FullName:
        manakai <CODE::lib/manakai/dis.pl>
      @@@Year:2004
      @@@Author:
        @@@@FullName:Wakaba
        @@@@Mail:w@suika.fam.cx
  @Date:
    @@@:
      $Date: 2005/02/22 08:21:00 $
    @@ContentType:
      dis:Date.RCS
  
  @Require:
    @@Module:
      @@@Name: SuikaWikiConfig21
      @@@WithFor:
        ManakaiDOM:Perl
  @defaultFor: ForLatest

Namespace:
  @DIS:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS#
  @dis:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#dis--
  @dis2pm:
    http://suika.fam.cx/~wakaba/archive/2004/11/8/dis2pm#
  @lang:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#
  @license:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/license#
  @ManakaiDOM:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#
  @owl:
    http://www.w3.org/2002/07/owl#
  @Perl:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#Perl--
  @rdf:
    http://www.w3.org/1999/02/22-rdf-syntax-ns#
  @rdfs:
    http://www.w3.org/2000/01/rdf-schema#
  @TreeCore:\
  @Util:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/

## -- "For" definitions

ForDef:
  @QName: 
    DIS:ForLatest
  @Description:
    @@lang:en
    @@@:
      For latest version of the <Module::Util:DIS> module implementation
  @ISA:
    ManakaiDOM:Perl

## -- Features

ElementTypeBinding:
  @Name: FeatureDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DOMMain:DOMFeature
    @@AliasFor:
      @@@@:
        ::ManakaiDOM:all
      @@@For:
        !=ManakaiDOM:all

ElementTypeBinding:
  @Name: FeatureVerDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DOMMain:DOMFeature

ElementTypeBinding:
  @Name: featureQName
  @ElementType:
    dis:AppName
  @ShadowContent:
    @@ContentType:
      dis:TypeQName

FeatureDef:
  @QName: Core
  @FeatureVerDef:
    @@QName: CoreFeature10
    @@Version: 1.0
    @@ISA: Core
    @@FullName:
      @@@lang:en
      @@@@:
        The <QUOTE::dis> object model, version 1.0
    @@Description:
      @@@lang:en
      @@@@:
        The <QUOTE::dis> object model, version 1.0. 
    @@DOMMain:requireFeature: 
      swcfg21:CoreFeature21

## -- SuikaWikiConfig/2.1 extended classes

ClsDef:
  @ClsQName: ManakaiDISImplementation
  @ClsISA:
    swcfg21:SWCFGImplementation
  @Description:
    @@lang:en
    @@@:
      A <QUOTE::dis> implementation object. 

  @Method:
    @@Name: createDISDocument
    @@Description:
      @@@lang:en
      @@@@:
        Creates an empty <Class::ManakaiDISDocument> object. 
    @@Return:
      @@@Type:ManakaiDISDocument
      @@@Description:
        @@@@lang:en
        @@@@@:
          The newly created <QUOTE::dis> document object.
      @@@PerlDef:
        $r = $self-><M::swcfg21:SWCFGImplementation.createSWCFGDocument>;
        $r-><AS::swcfg21:SWCFGDocument.defaultElementTypeNamespaceURI>
                    (<Q::dis:>);

  @Method:
    @@Name: createDISParser
    @@Description:
      @@@lang:en
      @@@@:
        Creates a <Class::ManakaiDISParser> object. 
    @@Return:
      @@@Type: ManakaiDISParser
      @@@Description:
        @@@@lang:en
        @@@@@: 
          A newly created <QUOTE::dis> parser. 
      @@@PerlDef:
        $r = bless $self-><M::swcfg21:SWCFGImplementation.createParser>,
                   <ClassName::ManakaiDISParser>;

  @Method:
    @@Name: createDISDatabase
    @@Description:
      @@@lang:en
      @@@@:
        Creates a new <QUOTE::dis> database.
    @@Return:
      @@@Type:ManakaiDISDatabase
      @@Description:
        @@@lang:en
        @@@@:
          A newly created <QUOTE::dis> parser.
      @@PerlDef:
        $r = bless {
          forDef => {
            <Q::ManakaiDOM:all> => {
              uri => <Q::ManakaiDOM:all>,
              isa => {<Q::ManakaiDOM:all> => 1},
              revISA => {},
            },
          },
          resDef => {},
        }, <CassName::ManakaiDISDatabase>;

##DISImplementation

ClsDef:
  @ClsQName: ManakaiDISParser
  @ClsISA:
    swcfg21:SWCFGParser
  @Description:
    @@lang:en
    @@@:
      A SuikaWikiConfig/2.1 parser that returns <QUOTE::dis> object. 
  @Method:
    @Name: parse
    @Description:
      @@lang:en
      @@@:
        Parses a <QUOTE::dis> document and returns it as an object tree. 
    @Param:
      @@Name: input
      @@Type:
        DOMLS:LSInput
      @@Description:
        @@@lang:en
        @@@@:
          The input source. 
    @Return:
      @@Type: DISDocument
      @@Description:
        @@@lang:en
        @@@@:
          The <QUOTE::dis> document object created from the <P::input>. 
      @@@RaiseException:
        @@@@@:
          swcfg21:SWCFG_PARSE_ERR
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The <IF::swcfg21:SWCFGParser> was unable to load the SuikaWikiConfig 
            document. 
      @@@PerlDef:
        __DEEP{
          $r = $self-><M::swcfg21:ManakaiSWCFGParser.parse> ($input);
        }__;
        if (defined $r) {
          $r = bless $r, <ClassName::ManakaiDISDocument>;
        }
##DISParser

ClsDef:
  @ClsQName: ManakaiDISNode
  @ClsISA:
    swcfg21:ManakaiSWCFGNode
  @Description:
    @@lang:en
    @@@:
      <QUOTE::dis> node objects. 

  @MethodRedef:
    @@Name:lookupNamespacePrefix
    @@Description:
      @@@lang:en
      @@@@:
        Looks up the namespace prefix associated to the given 
        namespace URI.  The default namespaces are ignored. 
    @@Param:
      @@@Name:namespaceURI
      @@@Type:
        swcfg21:SWCFGString
      @@@Description:
        @@@@lang:en
        @@@@@:
          The namespace URI to look for. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The <DOM::null> namespace. 
    @@NamedParam:
      @@@Name: makeNewBinding
      @@@Type: 
        DOMMain:boolean
      @@@Description:
        @@@@lang:en
        @@@@@:
          Whether a new namespace prefix should be bound when 
          no namespace URI has been associated yet. 
      @@@InCase:
        @@@@Value:true
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            New binding is made if no prefix associated. 
      @@@InCase:
        @@@@Value:false
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            Simply returns the <DOM::null> if no prefix associated. 
    @@Return:
      @@@Type:
        swcfg21:SWCFGString
      @@@Description:
        @@@@lang:en
        @@@@@:
           An associated namespace prefix.  If more than one prefix 
           are associated to the namespace URI, the returned prefix 
           is implementation dependent. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Type:
          swcfg21:SWCFGString
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            No associated namespace prefix found. 
      @@@PerlDef:
        $r = null;
        my $od = $self-><AG::swcfg21:SWCFGNode.ownerDocument> || $self;
        my $binds = $od->{<Q::TreeCore:node>}->{<Q::nsBinding>};
        if (defined $namespaceURI) {
          FIND: {
            for my $prefix (keys %$binds) {
              if (defined $binds->{$prefix} and
                  $binds->{$prefix} eq $namespaceURI) {
                $r = $prefix;
                last FIND;
              }
            }
            last FIND unless $makeNewBinding;
            ## Not found
            if ($namespaceURI =~ /(\w+)$/) {
              my $prefix = $1;
              unless (exists $binds->{$prefix}) {
                $binds->{$prefix} = $namespaceURI;
                $r = $prefix;
                last FIND;
              }
            }
            my $i = 1;
            {
              unless (exists $binds->{'ns'.$i}) {
                $binds->{$r = 'ns'.$i} = $namespaceURI;
                last FIND;
              }
              $i++;
              redo;
            }
          } # FIND
        } else {  ## Null namespace
          FIND: {
            if (exists $binds->{'nu'.'ll'} and not defined $binds->{'nu'.'ll'}) {
              $r = 'nu'.'ll';
              last FIND;
            }
            for my $prefix (keys %$binds) {
              if (not defined $prefix) {
                $r = $prefix;
                last FIND;
              }
            }
            last FIND unless $makeNewBinding;
            ## Not found
            my $i = '';
            {
              unless (exists $binds->{'nu'.'ll'.$i}) {
                $binds->{$r = 'nu'.'ll'.$i} = null;
                last FIND;
              }
              $i++;
              redo;
            }
          }
        }
        ## TODO: Module ns support

  @MethodRedef:
    @@Name:lookupNamespaceURI
    @@Description:
      @@@lang:en
      @@@@:
        Looks up the namespace URI associated to the given prefix. 
    @@Param:
      @@@Name:prefix
      @@@Type:
        swcfg21:SWCFGString
      @@@Description:
        @@@@lang:en
        @@@@@:
          The namespace URI to look for. 
    @@NamedParam:
      @@@Name: makeNewBinding
      @@@Type:
        DOMMain:boolean
      @@@Description:
        @@@@lang:en
        @@@@@:
          Whether a new binding should be created if no namespace URI 
          is associated with the <P::prefix> or not. 
      @@@InCase:
        @@@@Value:true
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            A new binding to the temporary namespace URI 
            exactly same as <P::prefix> is created 
            if no binding found. 
      @@@InCase:
        @@@@Value:false
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            No new binding is created if no binding found.  Note that 
            even if no association newly created, this method 
            returns the <DOM::null> value. 
    @@Return:
      @@@Type:
        swcfg21:SWCFGString
      @@@Description:
        @@@@lang:en
        @@@@@:The associated namespace URI. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Type:
          swcfg21:SWCFGString
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            No namespace prefix is associated to the prefix or 
            the <DOM::null> namespace is associated. 
      @@@PerlDef:
        my $od = $self-><AG::swcfg21:SWCFGNode.ownerDocument> || $self;
        my $binds = $od->{<Q::TreeCore:node>}->{<Q::nsBinding>};
        if (exists $binds->{$prefix}) {
          $r = $binds->{$prefix};
        } elsif ($makeNewBinding) {
          $r = $binds->{$prefix} = $prefix;
        } else {
          $r = null;
        }
        ## TODO: Module ns support

  @IntMethod:
    @@Name:getNodeReference
    @@Description:
      @@@lang:en
      @@@@:
        Returns a new reference to the node object. 
    @@ManakaiDOM:isStatic:1
    @@Param:
      @@@Name:object
      @@@Type:
        ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl
      @@@Description:
        @@@@lang:en
        @@@@@:
          The node object to be referred. 
    @@Return:
      @@@Type: ManakaiDISNode
      @@@Description:
        @@@@lang:en
        @@@@@:
          A newly created reference.
      @@@PerlDef:
        my $class;
        if ($object->{<Q::nodeType>} eq '#element') {
          $class = <ClassName::ManakaiDISElement>;
        } elsif ($object->{<Q::nodeType>} eq '#comment') {
          $class = <ClassName::ManakaiDISComment>;
        } elsif ($object->{<Q::nodeType>} eq '#document') {
          $class = <ClassName::ManakaiDISDocument>;
        } elsif ($object->{<Q::nodeType>} eq '#fragment') {
          $class = <ClassName::ManakaiDISDocumentFragment>;
        } else {
          __ASSERT{DISPerl:invariant::
            msg => {qq[Node type: "$object->{<Q::nodeType>}" ].
                    qq[(ref: "@{[ref $object]}")]},
          }__;
        }
        $r = $object-><M::ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl
                                  .newReference> ($class);
  
  @Attr:
    @@Name:ownerDISDocument
    @@NewIn21:
    @@Description:
      @@@lang:en
      @@@@:
        The <QUOTE::dis> document object associated with this node. 
    @@Get:
      @@@Type:DISDocument
      @@@Description:
        @@@@lang:en
        @@@@@:
          The document object associated with this node. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Type:DISDocument
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            This node is a document node. 
      @@@PerlDef:
        $r = <ClassM::ManakaiDISNode.getNodeReference>
                ($self->{<Q::TreeCore:node>}->{<Q::DOMCore:ownerDocument>})
          if $self->{<Q::TreeCore:node>}->{<Q::DOMCore:ownerDocument>};
##DISNode

ClsDef:
  @ClsQName: ManakaiDISElement
  @ClsISA:
    swcfg21:ManakaiSWCFGElement
  @ClsISA: ManakaiDISNode
  @Description:
    @@lang:en
    @@@:
      <QUOTE::dis> element node objects. 

  @Method:
    @@Name: forMatch
    @@Description:
      @@@lang:en
      @@@@:
        Tests whether this element is for a <QUOTE::for> or not. 
    @@Param:
      @@@Name: forArg
      @@@Type: ForURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          The <QUOTE::For> URI reference to test against. 
    @@Param:
      @@@Name: forpArg
      @@@Type: ForURIList
      @@@Description:
        @@@@lang:en
        @@@@@:
          The <QUOTE::For+> URI references to test against. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            No additional <QUOTE::For> URI reference. 
    @@Return:
      @@@Type:
        DOMMain:boolean
      @@@Description:
        @@@@lang:en
        @@@@@:
          Whether this element is for <P::forArg> and <P::forpArg> or not. 
      @@@UndeclaredPrefixException:
      @@@NoDBException:
      @@@PerlDef:
        $for_arg = <Q::ManakaiDOM:all> unless defined $for_arg;
        $forp_arg ||= [];

        FORMATCH: {
          __DEEP{
            my @ce = @{$self-><AG::ManakaiDISElement.disChildElements>};
            for my $ce (@ce) {
              my $et = $ce-><AG::swcfg21:SWCFGElement.expandedURI>;
              if ($et eq <Q::dis:ForCheck>) {
                my $for = [split /\s+/, $ce-><AG::swcfg21:SWCFGNode.value>];
                FCs: for my $f (@$for) {
                  if ($f =~ /^!=(.+)$/) {        ## -- NOT EQUAL TO
                    my $uri = $self-><AG::ManakaiDISElement.qnameToURI> ($1);
                    my $f = $self-><AG::ManakaiDISNode.ownerDISDocument>
                                 -><AG::ManakaiDISDocument.disDatabase>
                                 -><M::ManakaiDISDatabase.getFor> ($uri);
                    $f-><AG::ManakaiDISForDefinition.isReferred> ($ce);
                    for my $arg_uri ($for_arg, @{$forp_arg}) {
                      if ($uri eq $arg_uri) {
                        $r = false;
                        last FORMATCH;
                      }
                    }
                  } elsif ($f =~ /^!(.+)$/) {    ## -- NOT ISA
                    my $uri = $self-><AG::ManakaiDISElement.qnameToURI> ($1);
                    my $f = $self-><AG::ManakaiDISNode.ownerDISDocument>
                                 -><AG::ManakaiDISDocument.disDatabase>
                                 -><M::ManakaiDISDatabase.getFor> ($uri);
                    $f-><AG::ManakaiDISForDefinition.isReferred> ($ce);
                    for my $arg_uri ($for_arg, @{$forp_arg}) {
                      if ($f-><M::ManakaiDISForDefinition.isaURI> ($arg_uri)) {
                        $r = false;
                        last FORMATCH;
                      }
                    }
                  } elsif ($f =~ /^=(.+)$/) {    ## -- EQUAL TO
                    my $uri = $self-><AG::ManakaiDISElement.qnameToURI> ($1);
                    my $f = $self-><AG::ManakaiDISNode.ownerDISDocument>
                                 -><AG::ManakaiDISDocument.disDatabase>
                                 -><M::ManakaiDISDatabase.getFor> ($uri);
                    $f-><AG::ManakaiDISForDefinition.isReferred> ($ce);
                    for my $arg_uri ($for_arg, @{$forp_arg}) {
                      if ($arg_uri eq $uri) {
                        next FCs;
                      }
                    }
                    $r = false;
                    last FORMATCH;
                  } else {                       ## -- ISA
                    my $uri = $self-><AG::ManakaiDISElement.qnameToURI> ($1);
                    my $f = $self-><AG::ManakaiDISNode.ownerDISDocument>
                                 -><AG::ManakaiDISDocument.disDatabase>
                                 -><M::ManakaiDISDatabase.getFor> ($uri);
                    $f-><AG::ManakaiDISForDefinition.isReferred> ($ce);
                    for my $arg_uri ($for_arg, @{$forp_arg}) {
                      if ($f-><M::ManakaiDISForDefinition.isaURI> ($arg_uri)) {
                        next FCs;
                      }
                    }
                    $r = false;
                    last FORMATCH;
                  }
                } # FCs
              } # dis:ForCheck
            } # children

            my $has_for = false;
            for my $ce (@ce) {
              if ($self-><AG::swcfg21:SWCFGElement.expandedURI> eq
                  <Q::dis:For>) {
                my $for = [split /\s+/, $ce-><AG::swcfg21:SWCFGNode.value>];
                my $ok = true;
                $has_for = true;
                AFOR: for my $f (@$for) {
                  if ($f =~ /^!=(.+)$/) {         ## -- NOT EQUAL TO
                    my $uri = $self-><AG::ManakaiDISElement.qnameToURI> ($1);
                    my $f = $self-><AG::ManakaiDISNode.ownerDISDocument>
                                 -><AG::ManakaiDISDocument.disDatabase>
                                 -><M::ManakaiDISDatabase.getFor> ($uri);
                    $f-><AG::ManakaiDISForDefinition.isReferred> ($ce);
                    if ($uri eq $for_arg) {
                      $ok = false;
                      last AFOR;
                    }
                  } elsif ($f =~ /^!(.+)$/) {     ## -- NOT ISA
                    my $uri = $self-><AG::ManakaiDISElement.qnameToURI> ($1);
                    my $f = $self-><AG::ManakaiDISNode.ownerDISDocument>
                                 -><AG::ManakaiDISDocument.disDatabase>
                                 -><M::ManakaiDISDatabase.getFor> ($uri);
                    $f-><AG::ManakaiDISForDefinition.isReferred> ($ce);
                    if ($f-><M::ManakaiDISForDefinition.isaURI> ($for_arg)) {
                      $ok = false;
                      last AFOR;
                    }
                  } elsif ($f =~ /^=(.+)$/) {     ## -- EQUAL TO
                    my $uri = $self-><AG::ManakaiDISElement.qnameToURI> ($1);
                    my $f = $self-><AG::ManakaiDISNode.ownerDISDocument>
                                 -><AG::ManakaiDISDocument.disDatabase>
                                 -><M::ManakaiDISDatabase.getFor> ($uri);
                    $f-><AG::ManakaiDISForDefinition.isReferred> ($ce);
                    unless ($uri eq $for_arg) {
                      $ok = false;
                      last AFOR;
                    }
                  } else {                        ## -- ISA
                    my $uri = $self-><AG::ManakaiDISElement.qnameToURI> ($1);
                    my $f = $self-><AG::ManakaiDISNode.ownerDISDocument>
                                 -><AG::ManakaiDISDocument.disDatabase>
                                 -><M::ManakaiDISDatabase.getFor> ($uri);
                    $f-><AG::ManakaiDISForDefinition.isReferred> ($ce);
                    unless ($f-><M::ManakaiDISForDefinition.isaURI> ($for_arg)) {
                      $ok = false;
                      last AFOR;
                    }
                  }
                } # AFOR
              } # dis:For
              if ($ok) {
                $r = true;
                last FORMATCH;
              }
            } # $ce
            $r = $has_for ? false : true;
          }__;
        } # FORMATCH

  @Method:
    @@Name: mediaTypeMatch
    @@Description:
      @@@lang:en
      @@@@:
        Tests whether the content media type of this element matches to 
        a type or not. 
    @@Param:
      @@@Name: mediaType
      @@@Type: MediaTypeURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          A media type URI reference to test against. 
    @@Param:
      @@@Name: mediaTypeDefault
      @@@Type: MediaTypeURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          The default media type for this element. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            No default type provided.  All <P::mediaType> will match. 
    @@Return:
      @@@Type:
        DOMMain:boolean
      @@@Description:
        @@@@lang:en
        @@@@@:
          Whether this element is of <P::mediaType> or not. 
      @@@PerlDef:
        if (defined $mediaType) {
          __DEEP{
            my $ctn = $self-><M::ManakaiDISElement.disGetAttribute>
                                               (<Q::dis:ContentType>);
            my $ct;
            $ct = $ctn-><AG::ManakaiDISElement.qnameValueURI> if $ctn;
            $ct = $defaultMediaType unless defined $ct;
            my $res = $self-><AG::ManakaiDISNode.ownerDISDocument>
                                 -><AG::ManakaiDISDocument.disDatabase>
                                 -><M::ManakaiDISDatabase.getResource> ($ct);
            $res-><AS::ManakaiDISResourceDefinition.isReferred> ($ctn or $self);
            unless ($res-><M::ManakaiDISResourceDefinition.subsetOfURI> ($ct)) {
              $r = false;
            } else {
              $r = true;
            }
          }__;
        } else {
          $r = true;
        }

  @Method:
    @@Name: prefixToURI
    @@Description:
      @@@lang:en
      @@@@:
        Converts a namespace prefix into associated URI reference. 
    @@Param:
      @@@Name: prefix
      @@@Type:
        swcfg21:SWCFGString
      @@@Description:
        @@@@lang:en
        @@@@@:
          A namespace prefix to look for. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            Returns the default namespace URI. 
    @@NodeParam:
    @@Return:
      @@@Type:
        swcfg21:SWCFGString
      @@@Description:
        @@@@lang:en
        @@@@@: The URI references associated. 
      @@@UndeclaredPrefixException:
      @@@PerlDef:
        if (defined $param) {
          __DEEP{
            $r = $self-><M::swcfg21:SWCFGNode.lookupNamespaceURI> ($prefix);
          }__;
          unless (defined $r) {
            __EXCEPTION{UNDECLARED_NS_PREFIX_ERR::
              infoset:prefix => {$prefix},
              MDOMX:param-name => 'prefix',
              DIS:sourceNode => {$node},
            }__;
          }
        } else {
          ## TODO: default namespace
        }

  @Method:
    @@QName: qnameToURI
    @@Description:
      @@@lang:en
      @@@@:
        Converts a qualified name (<TYPE::dis:TypeQName>) to 
        an expanded URI reference. 
    @@Param:
      @@@Name: qname
      @@@Type:
        dis:TypeQName
      @@@Description:
        @@@@lang:en
        @@@@@:
          A qualified name. 
    @@NodeParam:
    @@Return:
      @@@Type: AnyURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          The expanded URI reference. 
      @@@UndeclaredPrefixException:
      @@@PerlDef:
        $qname =~ s/^\s+//; $qname =~ s/\s+$//;
        my ($prefix, $lname) = split /:/, $qname;
        __DEEP{
          if (defined $lname) {
            $r = $self-><M::ManakaiDISElement.prefixToURI> ($prefix) . $lname;
          } else {  ## In default namespace
            $r = $self-><M::ManakaiDISElement.prefixToURI> (null) . $prefix;
          }
        }

  @Method:
    @@QName: qnameToPair
    @@Description:
      @@@lang:en
      @@@@:
        Converts a qualified name (<TYPE::dis:TypeQName>) to 
        a pair of namespace URI and local name. 
    @@Param:
      @@@Name: qname
      @@@Type:
        dis:TypeQName
      @@@Description:
        @@@@lang:en
        @@@@@:
          A qualified name. 
    @@NodeParam:
    @@Return:
      @@@Type:
        Perl:ARRAY
      @@@Description:
        @@@@lang:en
        @@@@@:
          A list of namespace URI and local name. 
      @@@UndeclaredPrefixException:
      @@@PerlDef:
        $qname =~ s/^\s+//; $qname =~ s/\s+$//;
        my ($prefix, $lname) = split /:/, $qname;
        __DEEP{
          if (defined $lname) {
            $r = [$self-><M::ManakaiDISElement.prefixToURI> ($prefix), $lname];
          } else {  ## In default namespace
            $r = [$self-><M::ManakaiDISElement.prefixToURI> (null), $prefix];
          }
        }

  @Method:
    @@Name: typeforqnamesToURI
    @@Description:
      @@@lang:en
      @@@@:
        Converts a <TYPE::dis:TypeForQNames>
        into an expanded URI reference. 
    @@Param:
      @@@Name: tfqnames
      @@@Type: 
        dis:TypeForQNames
      @@@Description:
        @@@@lang:en
        @@@@@:
          A <TYPE::dis:TypeForQNames> to identify a resource. 
    @@Param:
      @@@Name: defaultTypeURI
      @@@Type: NameURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          A name URI reference used if it is missing from 
          <P::tfqnames>. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            Equivalent to <Q::DOMMain:any>. 
    @@Param:
      @@@Name: defaultForURI
      @@@Type: ForURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          A <QUOTE::for> URI reference used if it is missing from 
          <P::tfqnames>. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            Equivalent to <QUOTE::for all>, i.e. <Q::ManakaiDOM:all>. 
    @@NodeParam:
    @@Return:
      @@@Type: 
        DISCore:TypeForURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          The <TYPE::dis:TypeForQNames>-expanded URI references.  
      @@@UndeclaredPrefixException:
      @@@PerlDef:
        my ($typeq, $forq) = split /\s*::\s*/, $tfqnames, 2;
        my ($typeURI, $forURI);
        if (defined $forq) {
          __DEEP{
            $typeURI = $typeq eq ''
                       ? defined $defaultTypeURI ? $defaultTypeURI
                                                 : <Q::DOMMain:any>
                       : $self-><M::ManakaiDISElement.qnameToURI> ($typeq, %opt);
          }__;
          if (length $forq) {
            $forURI = $self-><M::ManakaiDISElement.qnameToURI> ($forq, %opt);
          } else {
            $forURI = <Q::ManakaiDOM:all>;
          }
        } else {  ## "For" omitted
          __DEEP{
            $typeURI = $typeq eq ''
                       ? defined $defaultTypeURI ? $defaultTypeURI
                                                 : <Q::DOMMain:any>
                       : $self-><M::ManakaiDISElement.qnameToURI> ($typeq, %opt);
          }__;
          $for = defined $defaultForURI ? $defaultForURI : <Q::ManakaiDOM:all>;
        }
        __DEEP{
          $r = $self-><AG::swcfg21:SWCFGNode.ownerDocument>
                    -><AG::swcfg21:SWCFGDocument.implementation>
                    -><M::DISImplementation.typeforqnamesToURI>
                                                  ($typeURI, $forURI);
        }__;

  @Method:
    @@Name: disGetAttribute
    @@enDesc:
      Gets an attribute node. 
    @@Param:
      @@@Name: attrName
      @@@Type: AnyURI
      @@@enDesc:
        The name expanded URI of the node to retrieve. 
    @@ForParam:
    @@ForpParam:
    @@MediaTypeParam:
    @@MediaTypeDefaultParam:
    @@Return:
      @@@Type: ManakaiDISElement
      @@@enDesc:
        The attribute (property) element node. 
      @@@nullCase:
        @@@@enDesc:
          No attribute node found. 
      @@@PerlDef:
        for my $c (@{$self->{src}-><AG::ManakaiDISElement.disChildElements>}) {
          if ($c-><AG::DISElement.expandedURI> eq $attrName and
              $c-><AG::ManakaiDISElement.forMatch> ($forArg, $forpArg) and
              $c-><AG::ManakaiDISElement.mediaTypeMatch>
                                         ($mediaType, $mediaTypeDefault)) {
            $r = $c;
            last;
          }
        }

  @Method:
    @@Name: disGetAttributeList
    @@enDesc:
      Gets attribute nodes. 
    @@AttrNameParam:
    @@ForParam:
    @@ForpParam:
    @@MediaTypeParam:
    @@MediaTypeDefaultParam:
    @@Return:
      @@@Type: ManakaiDISElementList
      @@@enDesc:
        The attribute (property) element nodes. 
      @@@PerlDef:
        $r = bless [], <ClassName::ManakaiDISElementList>;
        for my $c (@{$self->{src}-><AG::ManakaiDISElement.disChildElements>}) {
          if ($c-><AG::DISElement.expandedURI> eq $attrName and
              $c-><AG::ManakaiDISElement.forMatch> ($forArg, $forpArg) and
              $c-><AG::ManakaiDISElement.mediaTypeMatch>
                                         ($mediaType, $mediaTypeDefault)) {
            push @$r, $c;
          }
        }

  @Attr:
    @@Name: disChildElements
    @@Type: ManakaiDISElementList
    @@enDesc:
      A list of child elements.  
    @@Get:
      @@@enDesc:
        The current snapshot of child nodes. 
      @@@PerlDef:
        $r = bless [@{$self-><AG::swcfg21:SWCFGElement.childNodes>}],
                   <ClassName::ManakaiDISElementList>;    

  @Attr:
    @@Name: qnameValueURI
    @@enDesc:
      The element value (written as <TYPE::dis:TypeQName>), as URI reference. 
      \
      {NOTE:: What should be if list value?
      \
      }
    @@Get:
      @@@Type:AnyURI
      @@@nullCase:
        @@@@enDesc:
          No value. 
      @@@UndeclaredPrefixException:
      @@@GetProp:
        my $v = $self-><AG::swcfg21:SWCFGNode.value>;
        if (defined $v and not ref $v eq 'ARRAY') {
          __DEEP{
            $r = $self-><AG::ManakaiDISElement.qnameToURI> ($v);
          }__;
        } else {
          $r = null;
        }

  @Attr:
    @@Name: typeforqnamesValueURI
    @@enDesc:
      The element value (written as <TYPE::dis:TypeForQNames>),
      as URI reference. 
      \
      {NOTE:: What should be if list value?
      \
      }
    @@Get:
      @@@Type:ResourceURI
      @@@nullCase:
        @@@@enDesc:
          No value. 
      @@@UndeclaredPrefixException:
      @@@GetProp:
        my $v = $self-><AG::swcfg21:SWCFGNode.value>;
        if (defined $v and not ref $v eq 'ARRAY') {
          __DEEP{
            $r = $self-><AG::ManakaiDISElement.typeforqnamesToURI> ($v);
          }__;
        } else {
          $r = null;
        }
##DISElement

ClsDef:
  @ClsQName: ManakaiDISElementList
  @enDesc:
    @@lang:en
    @@@:
      Lists of elements. 
      \
      {NOTE:: <Class::ManakaiDISElementList> is <QUOTE::dead>; 
              later changes to the tree does not affect this type of objects. 
      \
      }
##DISElementList

ClsDef:
  @ClsQName: ManakaiDISComment
  @ClsISA:
    swcfg21:ManakaiSWCFGComment
  @ClsISA: ManakaiDISNode
  @Description:
    @@lang:en
    @@@:
      <QUOTE::dis> comment node objects. 
##DISComment

ClsDef:
  @ClsQName: ManakaiDISDocumentFragment
  @ClsISA:
    swcfg21:ManakaiSWCFGDocumentFragment
  @ClsISA: ManakaiDISNode
  @Description:
    @@lang:en
    @@@:
      <QUOTE::dis> document fragment node objects. 
##DISDocumentFragment

ClsDef:
  @ClsQName: ManakaiDISDocument
  @ClsISA:
    swcfg21:ManakaiSWCFGDocument
  @ClsISA: ManakaiDISNode
  @Description:
    @@lang:en
    @@@:
      <QUOTE::dis> document node objects. 

  @Attr:
    @@Name: disDatabase
    @@enDesc:
      Associated <QUOTE::dis> database. 

    @@Type: ManakaiDISDatabase
    @@Get:
      @@@NoDBException:
      @@@PerlDef:
        if ($self->{<Q::TreeCore:node>}->{<Q::db>}) {
          $self = $self->{<Q::TreeCore:node>}->{<Q::db>};
        } else {
          __EXCEPTION{NO_ASSOCIATED_DB_ERR}__;
        }
    @@Set:
      @@@PerlDef:
        $self->{<Q::TreeCore:node>}->{<Q::db>} = $given;
        require Scalar::Util;
        Scalar::Util::weaken ($self->{<Q::TreeCore:node>}->{<Q::db>});
##DISDocument

PropDef:
  @QName: db
  @enDesc:
    Associated <QUOTE::dis> database. 
  @rdfs:domain: ManakaiDISDocument
  @rdfs:range: ManakaiDISDatabase

## -- Definition object database

ClsDef:
  @ClsQName: ManakaiDISDatabase
  @enDesc:
    Resource database created from <QUOTE::dis> source data. 

  @Method:
    @@Name: typeforurisToURI
    @@Description:
      @@@lang:en
      @@@@:
        Converts a pair of name URI reference and <QUOTE::for> URI reference 
        into a <TYPE::dis:TypeForQNames>-expanded URI reference. 
    @@Param:
      @@@Name: typeURI
      @@@Type: NameURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          A URI reference to identify a resource. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            Equivalent to <Q::DOMMain:any> (for historical reason). 
    @@Param:
      @@@Name: forURI
      @@@Type: ForURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          A <QUOTE::for> URI reference. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            Equivalent to <QUOTE::for all>, i.e. <Q::ManakaiDOM:all>. 
    @@Return:
      @@@Type: 
        DISCore:TypeForURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          The <TYPE::dis:TypeForQNames>-expanded URI references.  
      @@@PerlDef:
        $typeURI = <Q::DOMMain:any> unless defined $typeURI;
        $forURI = <Q::ManakaiDOM:all> unless defined $forURI;
        if ($forURI eq <Q::ManakaiDOM:all>) {
          $r = $typeURI;
        } else {
          ## NOTE: [RFC 3986]
          ##       fragment    := *(pchar / "/" / "?")
          ##       pchar       := unreserved / pct-encoded / sub-delims / [:@]
          ##       unreserved  := ALPHA / DIGIT / [._~-]
          ##       sub-delims  := [!$&'()*+,;=]
          ## NOTE: [XPointer Framework]
          ##       SchemeData  := *EscapedData
          ##       EscapedData := NormalChar / "^(" / "^)" / "^^"
          ##                    / "(" SchemeData ")"
          ##       NormalChar  := UnicodeChar - [()^]
          for my $uri ($typeURI, $forURI) {
            $uri =~ s{([^0-9A-Za-z:;?=_./-])}{sprintf '%%%02X', ord $1}ge;
          }
          $r =qq<data:,200411tf#xmlns(t=data:,200411tf%23)>.
                             qq<t:tf($typeURI,$forURI)>;
        }

  @Method:
    @@Name: getModule
    @@Description:
      @@@lang:en
      @@@@:
        Returns a <QUOTE::dis> module definition. 
    @@Param:
      @@@Name: modURI
      @@@Type: ModuleURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          A <QUOTE::dis> module URI reference. 
    @@Return:
      @@@Type: ManakaiDISModuleDefinition
      @@@Description:
        @@@@lang:en
        @@@@@:
          The module definition. 
      @@@PerlDef:
        if (defined $self->{modDef}->{$modURI}) {
          $r = $self->{modDef}->{$modURI};
        } else {
          $r = $self->{modDef}->{$modURI}
             = bless {
                 uri => $modURI,
                 db => $self,
                 for => <Q::ManakaiDOM:all>,
                 forp => [],
               }, <ClassName::ManakaiDISModuleDefinition>;
          require Scalar::Util;
          Scalar::Util::weaken ($r->{db});
        }

  @Method:
    @@Name: getFor
    @@Description:
      @@@lang:en
      @@@@:
        Returns a <QUOTE::for> definition object. 
    @@Param:
      @@@Name: forURI
      @@@Type: ForURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          A <QUOTE::for> URI reference. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            Defaulted to <Q::ManakaiDOM:all>. 
    @@Return:
      @@@Type: ManakaiDISForDefinition
      @@@PerlDef:
        $forURI = <Q::ManakaiDOM:all> unless defined $forURI;
        if (defined $self->{forDef}->{$forURI}) {
          $r = $self->{forDef}->{$forURI};
        } else {
          $r = $self->{forDef}->{$forURI}
             = bless {
                 uri => $forURI,
                 isa => {<Q::ManakaiDOM:all> => true},
                 revISA => {},
                 db => $self,
               }, <ClassName::ManakaiDISForDefinition>;
          $self->{forDef}->{<Q::ManakaiDOM:all>}->{revISA}->{$forURI} = true;
          require Scalar::Util;
          Scalar::Util::weaken ($r->{db});
        }

  @Method:
    @@Name: getResource
    @@Description:
      @@@lang:en
      @@@@:
        Returns a <QUOTE::dis> resource definition. 
    @@Param:
      @@@Name: resURI
      @@@Type: ResourceURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          A <QUOTE::dis> resource URI reference. 
      @@@InCase:
        @@@@nullValue:
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            Defaulted to <Q::DOMMain:any>. 
    @@Return:
      @@@Type: ManakaiDISResourceDefinition
      @@@Description:
        @@@@lang:en
        @@@@@:
          The resource definition. 
      @@@PerlDef:
        $resURI = <Q::DOMMain:any> unless defined $resURI;
        if (defined $self->{resDef}->{$resURI}) {
          $r = $self->{resDef}->{$resURI};
        } else {
          $r = $self->{resDef}->{$resURI}
             = bless {
                 uri => $resURI,
                 subOf => {},
                 supOf => {},
                 db => $self,
                 for => <Q::ManakaiDOM:all>,
                 forp => [],
               }, <ClassName::ManakaiDISResourceDefinition>;
          require Scalar::Util;
          Scalar::Util::weaken ($r->{db});
        }
##DISDatabase

ClsDef:
  @ClsQName: ManakaiDISModuleDefinition
  @enDesc:
    <QUOTE::dis> module definitions. 
  @ClsISA: ManakaiDISPropertyAccessor
  
  @Attr:
    @@Name: uri
    @@Type: ModuleURI
    @@Description:
      @@@lang:en
      @@@@:
        The URI reference of this <QUOTE::dis> module. 
    @@Get:
      @@@PerlDef:
        $r = $self->{uri};

  @Attr:
    @@Name: nameURI
    @@Type: NameURI
    @@enDesc:
      The URI reference of this module, without 
      <QUOTE::for> identifier. 
    @@Get:
      @@@PropDef:
        $r = $self->{uri};

  @Attr:
    @@Name: localName
    @@enDesc:
      The local name of this module. 
    @@Type:
      DISCore:localName
    @@Get:
      @@@PerlDef:
        $r = $self->{localName};

  @Attr:
    @@Name: namespaceURI
    @@Type: AnyURI
    @@enDesc:
      The namespace URI of the name of this resource. 
    @@Get:
      @@@PerlDef:
        $r = $self->{namespaceURI};

  @Attr:
    @@Name: forURI
    @@Type: ForURI
    @@enDesc:
      The <QUOTE::for> URI reference for which this module is defined. 
    @@Get:
      @@@PerlDef:
        $r = $self->{for};

  @Attr:
    @@Name: isDefined
    @@Description:
      @@@lang:en
      @@@@:
        Whether this module is defined or not. 
    @@Type:
      DOMMain:boolean
    @@Get:
      @@@PerlDef:
        $r = $self->{<Q::isDefined>};

  ## TODO: exception handler
##DISModuleDefinition

ClsDef:
  @ClsQName: ManakaiDISForDefinition
  @Description:
    @@lang:en
    @@@:
      <QUOTE::dis> <QUOTE::for> definitions. 
  
  @Attr:
    @@Name: uri
    @@Type: ForURI
    @@Description:
      @@@lang:en
      @@@@:
        The URI reference of this <QUOTE::for>. 
    @@Get:
      @@@PerlDef:
        $r = $self->{uri};
  
  @Method:
    @@Name: isaURI
    @@Description:
      @@@lang:en
      @@@@:
        Whether this <QUOTE::for> is-a another <QUOTE::for> or not. 
    @@Param:
      @@@Name: superURI
      @@@Type: ForURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          Another <QUOTE::for> URI reference to test. 
    @@Return:
      @@@Type: 
        DOMMain:boolean
      @@@TrueCase:
        @@@@enDesc:
          <P::superURI> is a super-<QUOTE::for> of this <QUOTE::for>. 
      @@@FalseCase:
        @@@@enDesc:
          <P::superURI> is not a super-<QUOTE::for> of this <QUOTE::for>. 
      @@@PerlDef:
        $r = $self->{uri} eq $superURI ? true : $self->{isa}->{$superURI};

  @Attr:
    @@Name: isDefined
    @@Description:
      @@@lang:en
      @@@@:
        Whether this <QUOTE::for> is already defined or not. 
    @@Type:
      DOMMain:boolean
    @@Get:
      @@@TrueCase:
        This <QUOTE::for> is already defined. 
      @@@FalseCase:
        This <QUOTE::for> is not defined. 
      @@@PerlDef:
        $r = $self->{<Q::isDefined>};

  @Attr:
    @@Name: isReferred
    @@Description:
      @@@lang:en
      @@@@:
        Whether this <QUOTE::for> is referred somewhere or not. 
    @@Type:
      DOMMain:any
    @@Get:
      @@@InCase:
        @@@@Type:ManakaiDISElement
        @@@@enDesc:
          This <QUOTE::for> is referred by the element. 
      @@@nullCase:
        This <QUOTE::for> is not referred. 
      @@@PerlDef:
        $r = $self->{<Q::isReferred>};
    @@Set:
      @@@InCase:
        @@@@Type:ManakaiDISElement
        @@@@enDesc:
          This <QUOTE::for> is referred by the element. 
      @@@PerlDef:
        $self->{<Q::isReferred>} = true if $given;

  @Attr:
    @@Name: definingModule
    @@Description:
      @@@lang:en
      @@@@:
        The <QUOTE::dis> module in which this <QUOTE::for> is defined.
    @@Type: ManakaiDISModuleDefinition
    @@Get:
      @@@Description:
        @@@@lang:en
        @@@@@:
          The module object. 
      @@@NullCase:
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            This <QUOTE::for> is not associated to any module. 
      @@@PerlDef:
        $r = $self->{db}
                  -><M::ManakaiDISDatabase.getResource>
                           ($self->{<Q::definingModule>})
           if defined $self->{<Q::definingModule>};
  
  @Method:
    @@Name: readDefinition
    @@enDesc:
      Reads <QUOTE::for> definition and sets attributes. 
    @@Param:
      @@@Name: forDefElement
      @@@Type: ManakaiDISElement
      @@@Description:
        @@@@lang:en
        @@@@@:
          A <CODE::ForDef> element containing definition of this <QUOTE::for>. 
    @@Return:
      @@@RaiseException:
        @@@@@:FOR_ALREADY_DEFINED_ERR
        @@@@Description:
          @@@@@lang:en
          @@@@@@: 
            The <QUOTE::for> definition for this <QUOTE::for> is already read. 
      @@@PerlDef:
        if ($self->{<Q::isDefined>}) {
          __EXCEPTION{FOR_ALREADY_DEFINED_ERR}__;
        }
        ## TODO: 
        $self->{<Q::isDefined>} = true;

  ## TODO: exception handler
##DISForDefinition

ClsDef:
  @ClsQName: ManakaiDISResourceDefinition
  @enDesc:
    <QUOTE::dis> resource definitions. 
  @ClsISA: ManakaiDISPropertyAccessor
  
  @Attr:
    @@Name: uri
    @@Type: ResourceURI
    @@Description:
      @@@lang:en
      @@@@:
        The URI reference of this <QUOTE::dis> resource. 
    @@Get:
      @@@PerlDef:
        $r = $self->{uri};

  @Attr:
    @@Name: nameURI
    @@Type: NameURI
    @@enDesc:
      The URI reference of this <QUOTE::dis> resource, without 
      <QUOTE::for> identifier. 
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          This resource does not have its name URI reference. 
      @@@PropDef:
        $r = $self->{uri};

  @Attr:
    @@Name: localName
    @@enDesc:
      The local name of this resource. 
    @@Type:
      DISCore:localName
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          This resource does not have its local name. 
      @@@PerlDef:
        $r = $self->{localName};

  @Attr:
    @@Name: namespaceURI
    @@Type: AnyURI
    @@enDesc:
      The namespace URI of the name of this resource. 
    @@Get:
      @@@nullCase:
        The name of this resource does not have its namespace 
        or this resource does not have its name. 
      @@@PerlDef:
        $r = $self->{namespaceURI};

  @Attr:
    @@Name: isAnonymous
    @@enDesc:
      Whether this <QUOTE::dis> resource has name or not. 
    @@Type: 
      DOMMain:boolean
    @@Get:
      @@@TrueCase:
        This resource does not have any global unique name. 
        <A::ManakaiDISResourceDefinition.uri> is a temporary URI reference. 
      @@@FalseCase:
        This resource does have its formal name. 
        <A::ManakaiDISResourceDefinition.uri> is a URI reference 
        generated from the name and the <QUOTE::for> URI reference 
        of this resource. 
      @@@PerlDef:
        $r = $self->{<Q::isAnon>};

  @Attr:
    @@Name: forURI
    @@enDesc:
      The <QUOTE::for> URI reference for which this resource is defined. 
    @@Type:ForURI
    @@Get:
      @@@PerlDef:
        $r = $self->{for};

  @Attr:
    @@Name: forpURI
    @@enDesc:
      The <QUOTE::for+> URI references for which this resource is defined. 
    @@Type: ForURIList
    @@Get:
      @@@PropDef:
        $r = $self->{forp};
  
  @Method:
    @@Name: subsetOfURI
    @@Description:
      @@@lang:en
      @@@@:
        Whether this resource is a subset of another resource or not. 
    @@Param:
      @@@Name: superURI
      @@@Type: ResourceURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          Another resource URI reference to test. 
    @@Return:
      @@@Type: 
        DOMMain:boolean
      @@@TrueCase:
        @@@@enDesc:
          <P::superURI> is a super-resource of this resource. 
      @@@FalseCase:
        @@@@enDesc:
          <P::superURI> is not a super-resource of this resource. 
      @@@PerlDef:
        $r = $superURI eq $self->{uri} ? true : $self->{subOf}->{$superURI};

  @Attr:
    @@Name: isDefined
    @@Description:
      @@@lang:en
      @@@@:
        Whether this resource is already defined or not. 
    @@Type:
      DOMMain:boolean
    @@Get:
      @@@TrueCase:
        This resource is already defined. 
      @@@FalseCase:
        This resource is not defined. 
      @@@PerlDef:
        $r = $self->{<Q::isDefined>};

  @Attr:
    @@Name: isReferred
    @@Description:
      @@@lang:en
      @@@@:
        Whether this resource is referred or not. 
    @@Type:
      DOMMain:any
    @@Get:
      @@@InCase:
        @@@@Type:ManakaiDISElement
        @@@@enDesc:
          This resource is referred by the element. 
      @@@nullCase:
        This resource is not referred. 
      @@@PerlDef:
        $r = $self->{<Q::isReferred>};
    @@Set:
      @@@InCase:
        @@@@Type:ManakaiDISElement
        @@@@enDesc:
          This resource is referred by this element. 
      @@@PerlDef:
        $self->{<Q::isReferred>} = $given if $given;

  @Attr:
    @@Name: definingModule
    @@Description:
      @@@lang:en
      @@@@:
        The <QUOTE::dis> module in which this resource is defined.
    @@Type: ManakaiDISModuleDefinition
    @@Get:
      @@@Description:
        @@@@lang:en
        @@@@@:
          The module object. 
      @@@NullCase:
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            This resource is not associated to any module. 
      @@@PerlDef:
        $r = $self->{db}
                  -><M::ManakaiDISDatabase.getModule>
                           ($self->{<Q::definingModule>})
           if defined $self->{<Q::definingModule>};
   @@Set:
     @@@Description:
       @@@@lang:en
       @@@@@:
         The module object to which the <QUOTE::defining module> is set. 
     @@@PerlDef:
       $self->{<Q::defininingModule>}
                 = $given-><AG::ManakaiDISModuleDefinition.uri>;
   

  ## TODO: exception handler
##DISResourceDefinition

ClsDef:
  @ClsQName: ManakaiDISPropertyAccessor
  @enDescription:
    Accessor methods for resource or module properties. 
  
  @Method:
    @@Name: getPropertyText
    @@enDesc:
      Gets property value text. 
    @@PropNameParam:
    @@Param:
      @@@Name:default
      @@@Type:
        swcfg21:SWCFGString
      @@@enDesc:
        The default value that is returned if no explicit property 
        value specification found for this resource. 
      @@@nullCase:
        @@@@enDesc:
          No default value supplied; <DOM::null> is returned if 
          no value specified. 
    @@Return:
      @@@Type:
        swcfg21:SWCFGString
      @@@enDesc:
        The property value string. 
      @@@nullCase:
        @@@@enDesc:
          No value nor default value has specified. 
      @@@PerlDef:
        if (exists $self->{$propName}) {
          $r = defined $self->{$propName} ? $self->{$propName} : $default;
        } elsif ($self->{src}) {
          $r = $self->{src}-><M::ManakaiDISElement.disGetAttribute>
                                ($propName, for_arg => $self->{for},
                                 forp_arg => $self->{forp});
          $self->{$propName} = $r;
          $r = $default unless defined $r;
        } else {
          $r = $default;
        }
        
  @Method:
    @@Name: getPropertyResource
    @@enDesc:
      Gets property value resource. 
    @@PropNameParam:
    @@Return:
      @@@Type: ManakaiDISResourceDefinition
      @@@enDesc:
        The property value resource. 
      @@@nullCase:
        @@@@enDesc:
          No value has specified. 
      @@@PerlDef:
        if (defined $self->{$propName}) {
          $r = $self->{db}-><M::ManakaiDISDatabase.getResource>
                                             ($self->{$propName});
        } else {
          $r = null;
        }

  @Method:
    @@Name: addPropertyResourceList
    @@enDesc:
      Adds a resource to a resource-list property value. 
      \
      {ISSUE:: Should an exception be thrown if the property is 
               not of list?
      \
      }
    @@PropNameParam:
    @@Param:
      @@@Name: res
      @@@Type: ManakaiDISResourceDefinition
      @@@enDesc:
        A resource to add. 
    @@Return:
      @@@PerlDef:
        if (ref $self->{$propName} eq 'ARRAY') {
          push @{$self->{$propName}}, $res->{uri};
        } elsif (not defined $self->{$propName}) {
          $self->{$propName} = [$res->{uri}];
        }

##DISPropertyAccessor

PropDef:
  @QName:isAnon
  @Description:
    @@lang:en
    @@@:
      Whether the subject resource is anonymous or not. 
  @Type:
    DOMMain:boolean

PropDef:
  @QName:isDefined
  @Description:
    @@lang:en
    @@@:
      Whether the subject resource is defined or not. 

PropDef:
  @Qname:isReferred
  @Description:
    @@lang:en
    @@@:
      Whether the subject resource is referred or not. 
  @Type:
    DOMMain:any

PropDef:
  @QName:definingModule
  @Description:
    @@lang:en
    @@@:
      The <QUOTE::dis> module in which the subject resource is defined. 
  @rdfs:domain:
    DISCore:Module

## -- Datatypes

URITypeDef:
  @QName: ForURI
  @Description:
    @@lang:en
    @@@:
      <QUOTE::For> URI references. 

DataTypeDef:
  @QName: ForURIList
  @Description:
    @@lang:en
    @@@:
      References to the array containing <QUOTE::for> URI references. 

URITypeDef:
  @QName: MediaTypeURI
  @Description:
    @@lang:en
    @@@:
      Media type URI references. 

## -- Exceptions

XParamDef:
  @QName: sourceNode
  @Description:
    @@lang:en
    @@@:
      The node from which the string has come. 
  @Type: DISNode
