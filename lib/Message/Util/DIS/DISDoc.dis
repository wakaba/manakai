Module:
  @QName:
    DIS:DISDoc
  @FullName:
    @@lang: en
    @@@:
      <QUOTE::disdoc> Documentation Support Module
  @Namespace:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS#DISDoc/
  
  @Description:
    @@lang:en
    @@@:
      This module provides an object model for <QUOTE::disdoc>
      documentation format.  

  @Author:
    @@FullName: Wakaba
    @@Mail: w@suika.fam.cx
  @License:
    @@@:
      license:Perl+MPL
    @@Original:
      @@@FullName:
        manakai <CODE::lib/manakai/dis.pl>
      @@@Year:2004
      @@@Author:
        @@@@FullName:Wakaba
        @@@@Mail:w@suika.fam.cx
  @Date:
    @@@:
      $Date: 2005/08/18 12:50:49 $
    @@ContentType:
      dis:Date.RCS
  
  @Require:
    @@Module:
      @@@QName: Util|DIS
      @@@WithFor: 
        DIS:ForLatest
    @@Module:
      @@@QName: MDOM|DOMHTML
      @@@WithFor: ManakaiDOM|ManakaiDOMLatest

  @DefaultFor: 
    DIS:ForLatest

Namespace:
  @dd:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS#DISDoc/
  @ddel:
    http://suika.fam.cx/~wakaba/archive/2005/disdoc#
  @DIS:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS#
  @dis:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#dis--
  @dis2pm:
    http://suika.fam.cx/~wakaba/archive/2004/11/8/dis2pm#
  @DISlib:
    http://suika.fam.cx/~wakaba/archive/2004/dis/
  @disPerl:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#dis--Perl--
  @DOMCore:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#
  @DOMException:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#
  @DOMLS:
    http://suika.fam.cx/~wakaba/archive/2004/dom/ls#
  @DOMMain:
    http://suika.fam.cx/~wakaba/archive/2004/dom/main#
  @html3:
    urn:x-suika-fam-cx:markup:ietf:html:3:draft:00:
  @html5:
    http://www.w3.org/1999/xhtml
  @ilang:
    urn:x-suika-fam-cx:lang:
  @infoset:
    http://www.w3.org/2001/04/infoset#
  @lang:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#
  @license:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/license#
  @ManakaiDOM:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#
  @Markup:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Markup#
  @MDOM:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#ManakaiDOM.
  @MDOMX:
    http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#
  @nl:
    http://suika.fam.cx/~wakaba/archive/2004/dis/NaturalLanguage#
  @owl:
    http://www.w3.org/2002/07/owl#
  @Perl:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#Perl--
  @rdf:
    http://www.w3.org/1999/02/22-rdf-syntax-ns#
  @rdfs:
    http://www.w3.org/2000/01/rdf-schema#
  @s:
    http://suika.fam.cx/~wakaba/archive/2004/dis/Markup#
  @script:
    http://suika.fam.cx/~wakaba/archive/2005/5/script#
  @sw010:
    urn:x-suika-fam-cx:markup:suikawiki:0:10:
  @swcfg21:
    http://suika.fam.cx/~wakaba/archive/2005/swcfg21#
  @TreeCore:\
  @Util:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/
  @xhtml1:
    http://www.w3.org/1999/xhtml
  @xhtml2:
    http://www.w3.org/2002/06/xhtml2/
  @xml:
    http://www.w3.org/XML/1998/namespace
  @xmlns:
    http://www.w3.org/2000/xmlns/
  @xsi:
    http://www.w3.org/2001/XMLSchema-instance

## -- Features

ElementTypeBinding:
  @Name: FeatureDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DOMMain:DOMFeature
    @@ForCheck:
      ManakaiDOM:all

ElementTypeBinding:
  @Name: FeatureVerDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DOMMain:DOMFeature

ElementTypeBinding:
  @Name: featureQName
  @ElementType:
    dis:AppName
  @ShadowContent:
    @@ContentType:
      dis:TypeQName

FeatureDef:
  @QName: DIS|Doc
  @FeatureVerDef:
    @@QName: DIS|Doc20
    @@Version: 2.0
    @@DOMMetaImpl:instanceFeatureOf: DIS|Doc
    @@DOMMain:requireFeature: DIS|CoreFeature10
    @@FullName:
      @@@lang:en
      @@@@:
        <QUOTE::disdoc> version 2.0

FeatureDef:
  @QName: DIS|HTML
  @FeatureVerDef:
    @@QName: DIS|HTML20
    @@Version: 2.0
    @@DOMMetaImpl:instanceFeatureOf: DIS|HTML
    @@DOMMain:requireFeature: DIS|Doc20
    @@FullName:
      @@@@:
        <QUOTE::disdoc> version 2.0 with HTML output
      @@@lang:en

ElementTypeBinding:
  @Name: enDesc
  @ElementType: 
    dis:Description
  @ShadowContent: 
    @@lang:en

ElementTypeBinding:
  @Name: IFClassDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      @@@@: dis|MultipleResource
      @@@ForCheck: !ManakaiDOM|ForIF !ManakaiDOM|ForClass
    @@resourceFor: ManakaiDOM|ForIF
    @@resourceFor: ManakaiDOM|ForClass

    @@rdf:type:
      @@@@: ManakaiDOM|IF
      @@@ForCheck: ManakaiDOM|ForIF

    @@rdf:type:
      @@@@: ManakaiDOM|Class
      @@@ForCheck: ManakaiDOM|ForClass
    @@Implement:
      @@@@: ||+||ManakaiDOM|ForIF
      @@@ForCheck: ManakaiDOM|ForClass
      @@@ContentType: DISCore|TFPQNames

    @@DOMMain:implementFeature: DIS|Doc20
    @@DOMMain:implementFeature: DIS|HTML20

ElementTypeBinding:
  @Name: IFDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      @@@@: dis|MultipleResource
      @@@ForCheck: !ManakaiDOM|ForIF !ManakaiDOM|ForClass
    @@resourceFor: ManakaiDOM|ForIF

    @@rdf:type:
      @@@@: ManakaiDOM|IF
      @@@ForCheck: ManakaiDOM|ForIF

ElementTypeBinding:
  @Name: IFQName
  @ElementType:
    dis:QName
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForIF

ElementTypeBinding:
  @Name: ClsQName
  @ElementType:
    dis:QName
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: IFISA
  @ElementType:
    dis:ISA
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForIF

ElementTypeBinding:
  @Name: ClsISA
  @ElementType:
    dis:ISA
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: Method
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Method

ElementTypeBinding:
  @Name: Return
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|MethodReturn

ElementTypeBinding:
  @Name: Param
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|MethodParameter

## -- disdoc Implementation Interface

IFClassDef:
  @IFQName: DISImplementationDISDoc
  @ClsQName: ManakaiDISImplementationDISDoc
  
  @ClsISA: DIS|ManakaiDISImplementation

  @enDesc:
    This interface provides factory methods to create
    <QUOTE::disdoc>-related objects.

  @Method:
    @@Name: createDISDocNegotiationCondition
    @@PerlName: create_disdoc_negotiation_condition
    @@enDesc:
      Creates a new <IF::DISDocNegotiationCondition> object and 
      returns it.
    @@Return:
      @@@Type: DISDocNegotiationCondition
      @@@actualType: ManakaiDISDocNegotiationCondition
      @@@enDesc:
        A newly created negotiation condition object.
      @@@PerlDef:
        $r = bless {}, <ClassName::ManakaiDISDocNegotiationCondition>;
##DISImplementationDISDoc

ElementTypeBinding:
  @Name: PerlDef
  @ElementType:
    dis:Def
  @ShadowContent:
    @@ContentType: lang|Perl

ElementTypeBinding:
  @Name: disDef
  @ElementType:
    dis:Def
  @ShadowContent:
    @@ContentType: lang|dis

ElementTypeBinding:
  @Name: PropDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: rdf|Property

## -- disdoc Extended Interfaces for dis Database Objects

IFClassDef:
  @IFQName: DISAnyResourceDISDoc
  @ClsQName: ManakaiDISAnyResourceDISDoc

  @enDesc:
    This interface provides an access to <QUOTE::disdoc>
    methods from <QUOTE::dis> resource, module or <QUOTE::for> definition.

  @Method:
    @@Name: getFullName
    @@enDesc:
      Returns a copy of (human readable) full name. 
    @@OwnerDocArg:
    @@NegoParam:
    @@Return:
      @@@Type: DocumentFragment
      @@@enDesc:
        A DOM node containing full name. 
      @@@nullCase:
        @@@@enDesc:
          No full name for this resource.
      @@@PerlDef:
        __DEEP{
          if ($self->{o}->{src}) {
            my $fn = $self->{o}->{src}
                          -><M::DIS:ManakaiDISElement.disGetAttribute>
                                 (<Q::dis:FullName>,
                                  for_arg => $self->{o}->{for},
                                  forp_arg => $self->{o}->{forp});
            if ($fn) {
              $r = $fn-><M::DIS:ManakaiDISElement.getFeature> (<Q::DIS:Doc>)
                      -><M::ManakaiDISElementDISDoc.getDISDocTree>
                              ($ownerDocumentArg, <Q::lang:disdocInline>,
                               for_arg => $self->{o}->{for},
                               forp_arg => $self->{o}->{forp});
            }
          }
        }__;

  @Method:
    @@Name: getDescription
    @@enDesc:
      Returns a copy of (human readable) description.
    @@OwnerDocArg:
    @@NegoParam:
    @@Param:
      @@@Name: withImplNote
      @@@enDesc:
        Whether should implementor's notes also be returned or not.
      @@@Type: DOMMain|boolean||ManakaiDOM|all
      @@@trueCase:
        @@@@enDesc:
          Implementor's notes will also be part of the returned value.
      @@@falseCase:
        @@@@enDesc:
          The result will not contains any implementor's notes.
    @@Return:
      @@@Type: DocumentFragment
      @@@enDesc:
        A DOM node containing description.
        If this node has no description, an empty <IF::DocumentFragment>
        is returned.
      @@@PerlDef:
        __DEEP{
          $r = $ownerDocumentArg-><M::Document.createDocumentFragment>;
          if ($self->{o}->{src}) {
            my @el = ([]); # $el[0] is dummy
            my %el;
            for my $c (@{$self->{o}->{src}
                              -><M::DIS:ManakaiDISElement.disChildElements>
                                  (for_arg => $self->{o}->{for},
                                   forp_arg => $self->{o}->{forp})}) {
              if ($c-><M::DIS:ManakaiDISElement.elementTypeMatch>
                                  (<Q::dis:Description>) or
                  ($withImplNote and
                   $c-><M::DIS:ManakaiDISElement.elementTypeMatch>
                                  (<Q::dis:ImplNote>))) {
                my $d = $c-><M::DIS:ManakaiDISElement.getFeature> (<Q::DIS:Doc>);
                my $id = $d-><M::ManakaiDISElementDISDoc.documentationGroupId>
                                  (for_arg => $self->{o}->{for},
                                   forp_arg => $self->{o}->{forp});
                if ($el{$id}) {
                  push @{$el[$el{$id}]}, $d;
                } else {
                  $el{$id} = @el;
                  push @el, [$d];
                }
              }
            } # children

            shift @el; # Discard dummy item
            for my $els (@el) {
              my $el = defined $condition
                       ? $condition-><M::ManakaiDISDocNegotiationCondition
                                      .selectDISElement> ($els)
                       : $els->[0];
              next unless $el;
              my $elr = $el-><M::ManakaiDISElementDISDoc.getDISDocTree>
                              ($ownerDocumentArg, <Q::lang:disdoc>,
                               for_arg => $self->{o}->{for},
                               forp_arg => $self->{o}->{forp});
              $r-><M::Node.appendChild> ($elr) if $elr;
            } # groups
          }
        }__;
##DISAnyResourceDoc

IFClassDef:
  @IFQName: DISResourceDISDoc
  @ClsQName: ManakaiDISResourceDISDoc

  @IFISA: DISAnyResourceDISDoc
  @ClsISA: ManakaiDISAnyResourceDISDoc

  @DISLang:role: DIS|ResourceRole

  @enDesc:
    This interface provides an access to <QUOTE::disdoc>
    methods from <QUOTE::dis> resource definition.
    \
    This interface can be obtained
    from the object implementing
    <Class::DIS:ManakaiDISResourceDefinition> class
    by calling the <M::DIS:ManakaiDISResourceDefinition
    .getFeature> method with the <P::feature> parameter
    set to <Feature::DIS|Doc>.

  @Method:
    @@Name: getLabel
    @@enDesc:
      Returns a copy of (human readable) label.
    @@OwnerDocArg:
    @@NegoParam:
    @@Return:
      @@@Type: DocumentFragment
      @@@enDesc:
        A DOM node containing label.
      @@@nullCase:
        @@@@enDesc:
          No label for this resource.
        __DEEP{
          if ($self->{o}->{src}) {
            my $fn = $self->{o}->{src}
                          -><M::DIS:ManakaiDISElement.disGetAttribute>
                                 (<Q::dis:Label>,
                                  for_arg => $self->{o}->{for},
                                  forp_arg => $self->{o}->{forp});
            if ($fn) {
              $r = $fn-><M::DIS:ManakaiDISElement.getFeature> (<Q::DIS:Doc>)
                      -><M::ManakaiDISElementDISDoc.getDISDocTree>
                              ($ownerDocumentArg, <Q::lang:disdocInline>,
                               for_arg => $self->{o}->{for},
                               forp_arg => $self->{o}->{forp});
            }
          }
        }__;
##DISResourceDISDoc

IFClassDef:
  @IFQName: DISModuleDISDoc
  @ClsQName: ManakaiDISModuleDISDoc

  @IFISA: DISAnyResourceDISDoc
  @ClsISA: ManakaiDISAnyResourceDISDoc

  @DISLang:role: DIS|ModuleRole

  @enDesc:
    This interface provides an access to <QUOTE::disdoc>
    methods from <QUOTE::dis> module definition.
    \
    This interface can be obtained
    from the object implementing
    <Class::DIS:ManakaiDISModuleDefinition> class
    by calling the <M::DIS:ManakaiDISModuleDefinition
    .getFeature> method with the <P::feature> parameter
    set to <Feature::DIS|Doc>.
##DISModuleDISDoc

IFClassDef:
  @IFQName: DISForDISDoc
  @ClsQName: ManakaiDISForDISDoc

  @IFISA: DISAnyResourceDISDoc
  @ClsISA: ManakaiDISAnyResourceDISDoc

  @DISLang:role: DIS|ForRole

  @enDesc:
    This interface provides an access to <QUOTE::disdoc>
    methods from <QUOTE::dis> <QUOTE::for> definition.
    \
    This interface can be obtained
    from the object implementing
    <Class::DIS:ManakaiDISForDefinition> class
    by calling the <M::DIS:ManakaiDISForDefinition
    .getFeature> method with the <P::feature> parameter
    set to <Feature::DIS|Doc>.
##DISForDISDoc

ElementTypeBinding:
  @Name: nullCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: ManakaiDOM|InCase
    @@Value:
      @@@is-null:1

ElementTypeBinding:
  @Name: NegoParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|MethodParameter
    @@Name: condition
    @@Type: DISDocNegotiationCondition
    @@Description:
      @@@lang:en
      @@@@: A condition object for negotiation.
    @@ResourceDef:
      @@@@rdf:type: ManakaiDOM|InCase
      @@@@Value:
        @@@@@is-null:1
      @@@@Description:
        @@@@@lang:en
        @@@@@@: No negotiation.

ElementTypeBinding:
  @Name: OwnerDocArg
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|MethodParameter
    @@Name: ownerDocumentArg
    @@Type: Document
    @@Description:
      @@@lang:en
      @@@@:
        A DOM <IF::DOMCore:Document> object that is used to
        construct the tree.  It is set to the <A::DOMCore:Node.ownerDocument>
        of the result nodes.

## -- disdoc Extended Interface for dis Object Model

IFClassDef:
  @IFQName: DISElementDISDoc
  @ClsQName: ManakaiDISElementDISDoc

  @ClsISA: DIS|ManakaiDISElement

  @IFISA: DISDocNamespaceResolver
  @Implement: DISDocNamespaceResolver

  @enDesc:
    <QUOTE::disdoc> interface for <QUOTE::dis> elements.
    \
    This interface can be obtained from a <Class::DIS:ManakaiDISElement>
    class by <M::DIS|ManakaiDISElement.getFeature> method
    with the parameter of <Feature::DIS|Doc>.
    
  @Method:
    @@Name: languageURI
    @@enDesc:
      The natural language URI reference for the content
      of this element.
    @@Type: DIS|AnyURI
    @@Param:
      @@@Name: defaultLangURI
      @@@Type: DIS|AnyURI
      @@@enDesc:
        The language tag URI reference of the default language.
        It is considered as the element language if the element
        does not have the language information.
      @@@nullCase:
        @@@@enDesc:
          No default language information.
    @@ForParam:
    @@ForpParam:
    @@Return:
      @@@enDesc:
        The natural language URI referemce.
      @@@nullCase:
        @@@@enDesc:
          No language tag for this element and <P::defaultLangURI>
          parameter is not specified. 
      @@@PerlDef:
      __DEEP{
        my $lang = $self-><M::DIS:ManakaiDISElement.disGetAttribute>
                       (<Q::dis:lang>, for_arg => $forArg, forp_arg => $forpArg);
        if ($lang) {
          my $v = $lang-><M::swcfg21:SWCFGNode::swcfg21:ForLatest.value>;
          if (defined $v and not ref $v eq 'ARRAY') {
            $r = $lang-><M::DIS|ManakaiDISElement.qnameToURI>
                             ($v, node => $self,
                              default_namespace_uri => <Q::ilang:>);
          } else {
            $r = $defaultLangURI;
          }
        } else {
          $r = $defaultLangURI;
        }
      }__;
    @@ImplNote:
      @@@lang:en
      @@@@:
        {NOTE:: Currently language tag does not inherit.  Should it
                inherit?
        \
        }

  @Method:
    @@Name: scriptURI
    @@enDesc:
      The script (writing system) URI reference for the content
      of this element.
    @@Type: DIS|AnyURI
    @@Param:
      @@@Name: defaultScriptURI
      @@@Type: DIS|AnyURI
      @@@enDesc:
        The script tag URI reference of the default script.
        It is considered as the element script if the element
        does not have the script information.
      @@@nullCase:
        @@@@enDesc:
          No default script information.
    @@ForParam:
    @@ForpParam:
    @@Return:
      @@@enDesc:
        The natural script URI referemce.
      @@@nullCase:
        @@@@enDesc:
          No script tag for this element and <P::defaultScriptURI>
          parameter is not specified. 
      @@@PerlDef:
      __DEEP{
        my $lang = $self-><M::DIS:ManakaiDISElement.disGetAttribute>
                     (<Q::dis:script>, for_arg => $forArg, forp_arg => $forpArg);
        if ($lang) {
          my $v = $lang-><M::swcfg21:SWCFGNode::swcfg21:ForLatest.value>;
          if (defined $v and not ref $v eq 'ARRAY') {
            $r = $lang-><M::DIS|ManakaiDISElement.qnameToURI>
                             ($v, node => $self,
                              default_namespace_uri => <Q::script:>);
          } else {
            $r = $defaultScriptURI;
          }
        } else {
          $r = $defaultScriptURI;
        }
      }__;

  @Method:
    @@Name: languageMatch
    @@enDesc:
      Whether a language matches to the language of this element or not.
      \
      {NOTE:: A language matches to the language of this element 
              if the language is a subclass of the element language.
      \
      }
    @@Param:
      @@@Name: langURI
      @@@Type: DIS|AnyURI
      @@@enDesc:
        The language tag URI reference of the language to compare. 
    @@Param:
      @@@Name: defaultLangURI
      @@@Type: DIS|AnyURI
      @@@enDesc:
        The language tag URI reference of the default language.
        It is considered as the element language if the element
        does not have the language information.
      @@@nullCase:
        @@@@enDesc: No default language.
    @@ForParam:
    @@ForpParam:
    @@Return:
      @@@Type: DOMMain|boolean||ManakaiDOM|all
      @@@enDesc:
        Whether the <P::langURI> matches to the language of this element. 
      @@@PerlDef:
        if (defined $langURI) {
          __DEEP{
            my $ct = $self-><M::ManakaiDISElementDISDoc.languageURI>
                                  ($defaultLangURI, for_arg => $forArg,
                                   forp_arg => $forpArg);
            $ct = $defaultLangURI unless defined $ct;
            unless (defined $ct) {
              $r = false;
            } else {
              my $res = $self-><AG::DIS|ManakaiDISNode.ownerDISDocument>
                                 -><AG::DIS|ManakaiDISDocument.disDatabase>
                                 -><M::DIS|ManakaiDISDatabase.getResource> ($ct);
              $res-><AS::DIS|ManakaiDISResourceDefinition.isReferred> ($self);
              unless ($res-><M::DIS:ManakaiDISResourceDefinition
                                               .isSubsetOfURI> ($langURI)) {
                $r = false;
              } else {
                $r = true;
              }
            }
          }__;
        } else {
          $r = true;
        }

  @Method:
    @@Name: scriptMatch
    @@enDesc:
      Whether a script (writing system) matches to the script
      of this element or not.
      \
      {NOTE:: A script matches to the script of this element 
              if the script is a subclass of the element script.
      \
      }
    @@Param:
      @@@Name: scriptURI
      @@@Type: DIS|AnyURI
      @@@enDesc:
        The script tag URI reference of the script to compare. 
    @@Param:
      @@@Name: defaultScriptURI
      @@@Type: DIS|AnyURI
      @@@enDesc:
        The script tag URI reference of the default script.
        It is considered as the element script if the element
        does not have the script information.
      @@@nullCase:
        @@@@enDesc:
          No default script information.
    @@ForParam:
    @@ForpParam:
    @@Return:
      @@@Type: DOMMain|boolean||ManakaiDOM|all
      @@@enDesc:
        Whether the <P::scriptURI> matches to the script of this element.
      @@@PerlDef:
        if (defined $scriptURI) {
          __DEEP{
            my $ct = $self-><M::ManakaiDISElementDISDoc.scriptURI>
                                  ($defaultScriptURI, for_arg => $forArg,
                                   forp_arg => $forpArg);
            $ct = $defaultScriptURI unless defined $ct;
            unless (defined $ct) {
              $r = false;
            } else {
              my $res = $self-><AG::DIS|ManakaiDISNode.ownerDISDocument>
                                 -><AG::DIS|ManakaiDISDocument.disDatabase>
                                 -><M::DIS|ManakaiDISDatabase.getResource> ($ct);
              $res-><AS::DIS|ManakaiDISResourceDefinition.isReferred> ($self);
              unless ($res-><M::DIS:ManakaiDISResourceDefinition
                                               .isSubsetOfURI> ($scriptURI)) {
                $r = false;
              } else {
                $r = true;
              }
            }
          }__;
        } else {
          $r = true;
        }

  @Method:
    @@Name: getDISDocTree
    @@PerlName: get_disdoc_tree
    @@enDesc:
      Returns a copy of XML tree representation of the <QUOTE::disdoc>
      content of this element.
    @@OwnerDocArg:
    @@Param:
      @@@Name: defaultMediaType
      @@@Type: DIS|AnyURI
      @@@enDesc:
        The default media type of the element.
      @@@nullCase:
        @@@@enDesc:
          The <QUOTE::disdoc> documentation language, i.e. <Q::lang:disdoc>,
          is the default of the default.
    @@ForParam:
    @@ForpParam:
    @@Return:
      @@@Type: DocumentFragment
      @@@enDesc:
        A DOM tree generated from the content.
      @@@nullCase:
        @@@@enDesc:
          This element does not contain a documentation.
      @@@PerlDef:
        __DEEP{
          my $ctu = $self-><M::DIS:ManakaiDISElement.mediaTypeURI>
                                (default_media_type => $defaultMediaType,
                                 for_arg => $forArg,
                                 forp_arg => $forpArg);
          my $ct = $self-><AG::DIS|ManakaiDISNode.ownerDISDocument>
                                -><AG::DIS|ManakaiDISDocument.disDatabase>
                                -><M::DIS|ManakaiDISDatabase.getResource> ($ctu);
          if ($ct-><M::DIS:ManakaiDISResourceDefinition.isSubsetOfURI>
                                (<Q::lang:disdoc>)) {
            my $doc = $ownerDocumentArg-><M::Node.getFeature> (<Q::DIS|Doc>);
            $r = $doc-><M::ManakaiDOMDocumentDISDoc.parseDISDocText>
                         ($self, $self-><M::SWCFGNode.value>,
                          node => $self,
                          language_uri => $self-><M::ManakaiDISElementDISDoc
                             .languageURI> (null, for_arg => $forArg,
                                            forp_arg => $forpArg),
                          script_uri => $self-><M::ManakaiDISElementDISDoc
                             .scriptURI> (null, for_arg => $forArg,
                                            forp_arg => $forpArg));
          } elsif ($ct-><M::DIS:ManakaiDISResourceDefinition.isSubsetOfURI>
                                (<Q::lang:disdocInline>)) {
            my $doc = $ownerDocumentArg-><M::Node.getFeature> (<Q::DIS|Doc>);
            $r = $doc-><M::ManakaiDOMDocumentDISDoc.parseDISDocInlineText>
                             ($self, $self-><M::SWCFGNode.value>,
                          node => $self,
                          language_uri => $self-><M::ManakaiDISElementDISDoc
                             .languageURI> (null, for_arg => $forArg,
                                            forp_arg => $forpArg),
                          script_uri => $self-><M::ManakaiDISElementDISDoc
                             .scriptURI> (null, for_arg => $forArg,
                                            forp_arg => $forpArg));
          }
        }__;

  @Method:
    @@Name: documentationGroupId
    @@enDesc:
      An identifier that identifies a set of documentation
      elements such as of <Q::dis:Description>. 
      \
      {NOTE:: Documentation child elements of an element
              is considered as zero or more sets of 
              documentation element groups; each group
              has an identifier unique (only) in the scope
              of those groups (uniqueness among elements
              in another hierarchy is not guaranted). 
      \
      }
    @@Type: DIS|AnyURI
    @@ForParam:
    @@ForpParam:
    @@ImplNote:
      @@@lang:en
      @@@@:
        If a child element has a <Q::dd:id> attribute whose
        value is <DOM::true>,
        the identifier is composed from that value and
        the element type.  Otherwise, the identifier is
        its element type.
    @@Return:
      @@@enDesc:
        An opaque identifier value.
      @@@PerlDef:
        __DEEP{
          my $eturi = $self-><AG::swcfg21:SWCFGElement::swcfg21:ForLatest
                                  .expandedURI>;
          my $ddid = $self-><M::DIS|ManakaiDISElement.disGetAttribute>
                                  (<Q::dd:id>, for_arg => $forArg, 
                                   forp_arg => $forpArg);
          my $ddidv = $ddid ? $ddid-><M::SWCFGNode.value> : 0;
          if ($ddidv) {
            for my $__uri ($ddidv, $eturi) {
              $__uri =~ s{([^0-9A-Za-z:;?=_.~/-])}{sprintf '%%%02X', ord $1}ge;
            }
            $r = qq<data:,200411tf#xmlns(t=data:,200411tf%23)>.
                                qq<t:id($eturi,$ddidv)>;      
          }
        }__;

  @ImplNote:
    @@lang:en
    @@@:
      <M::.lookupNamespaceURI> method is defined in 
      <Class::DIS:ManakaiDISElement>.

  @Attr:
    @@ForCheck: ManakaiDOM|ForClass
    @@Name: defaultDISDocNamespaceURI
    @@PerlName: default_disdoc_namespace_uri
    @@enDesc:
      The default namespace URI for <QUOTE::disdoc> contents.
      It is defined by the <Q::dis:Namespace> attribute
      of the <Q::dis:Module> top-level element.
    @@Type: DIS|AnyURI
    @@Get:
      @@@PerlDef:
          __DEEP{
            $r = ($self-><AG::DIS|ManakaiDISNode.ownerDISDocument> || $self)
                       -><AG::DIS|ManakaiDISDocument.moduleElement>
                       -><AG::DIS|ManakaiDISModuleElement.definingNamespaceURI>;
          }__;

  @Attr:
    @@ForCheck: ManakaiDOM|ForClass
    @@Name: defaultDISDocElementNamespaceURI
    @@PerlName: default_disdoc_element_namespace_uri
    @@enDesc:
      The default namespace URI for <QUOTE::disdoc> element types.
    @@Type: DIS|AnyURI
    @@Get:
      @@@enDesc:
        Always <URIQ::ddel:>.
      @@@Def:
        @@@@ContentType: lang|dis
        @@@@DISLang:value:
          @@@@@@: ddel|
          @@@@@ContentType: dis|TypeQName
##DISElementDISDoc

PropDef:
  @QName: dd|id
  @enDesc:
    Group identifier without element type information. 

ElementTypeBinding:
  @Name: ForParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:MethodParameter
    @@DISPerl:isNamedParameter:1
    @@Name: forArg
    @@Type: DIS|ForURI
    @@Description:
      @@@lang:en
      @@@@:
        The <QUOTE::for> URI reference. 
    @@ResourceDef:
      @@@rdf:type:
        ManakaiDOM:InCase
      @@@Value:
        @@@@is-null:1
      @@@Description:
        @@@@lang:en
        @@@@@:
          Equivalent to <Q::ManakaiDOM:all>, i.e. <QUOTE::for all>. 

ElementTypeBinding:
  @Name: ForpParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:MethodParameter
    @@DISPerl:isNamedParameter:1
    @@Name: forpArg
    @@Type: DIS|ForURIList
    @@Description:
      @@@lang:en
      @@@@:
        An array reference containing additional <QUOTE::for> 
        constraints (<QUOTE::For+> list).
    @@ResourceDef:
      @@@rdf:type:
        ManakaiDOM:InCase
      @@@Value:
        @@@@is-null:1
      @@@Description:
        @@@@lang:en
        @@@@@:
          Equivalent to the empty array reference. 

ResourceDef:
  @QName: Document
  @AliasFor: DOMCore|Document||ManakaiDOM|ManakaiDOMLatest

ElementTypeBinding:
  @Name: Attr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Attribute

ElementTypeBinding:
  @Name: Get
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|AttributeGet

ElementTypeBinding:
  @Name: Set
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|AttributeSet

ResourceDef:
  @QName: disdocBlocks
  @AliasFor: lang|disdoc||ManakaiDOM|all

ResourceDef:
  @QName: SWCFGNode
  @AliasFor: swcfg21|SWCFGNode||swcfg21|ForLatest

ResourceDef:
  @QName: disdocInline
  @AliasFor: lang|disdocInline||ManakaiDOM|all

## -- disdoc Extended Interfaces for DOM Objects

IFClassDef:
  @IFQName: DocumentDISDoc
  @ClsQName: ManakaiDOMDocumentDISDoc

  @ClsISA: DOMCore|ManakaiDOMDocument||ManakaiDOM|ManakaiDOMLatest

  @DOMMetaImpl:provideFeature:
    @@@: DIS|Doc20
    @@DOMMetaImpl:providedThrough: DIS|ManakaiDISImplementation

  @enDesc:
    This interface provides a set of methods to parse <QUOTE::disdoc>
    formatted texts and creates DOM trees.
    \
    This interface must be implemented by objects which
    implement the <IF::DOMCore:Document> interface if 
    the DOM implementation supports the <Feature::DIS|Doc>. 
    This interface can be obtained from a <IF::DOMCore:Document>
    object via <M::DOMCore:Document.getFeature> method
    with the parameter of <Feature::DIS|Doc>.

  @Method:
    @@Name: parseDISDocText
    @@PerlName: parse_disdoc_text
    @@enDesc:
      Parses a <QUOTE::disdoc> formatted text in the block-level context.
    @@Param:
      @@@Name: namespaceContext
      @@@Type: DISDocNamespaceResolver
      @@@enDesc:
        A node or something used to resolve namespace prefix.
    @@Param:
      @@@Name: sourceText
      @@@Type: disdocBlocks
      @@@enDesc:
        A <QUOTE::disdoc> block-level fragment.
    @@NamedParam:
      @@@Name: node
      @@@Type: DIS|ManakaiDISElement
      @@@enDesc:
        A <QUOTE::dis> element in which the <P::sourceText>
        is contained.  This information is used to report errors
        and to get resources for languages and scripts.
      @@@nullCase:
        @@@@enDesc: No source node.
    @@NamedParam:
      @@@Name: languageURI
      @@@Type: DIS|AnyURI
      @@@enDesc:
        The language information of the context in which the <P::sourceText>
        is contained.
      @@@nullCase:
        @@@@enDesc: No language information.
    @@NamedParam:
      @@@Name: scriptURI
      @@@Type: DIS|AnyURI
      @@@enDesc:
        The script information of the context in which the <P::sourceText>
        is contained.
      @@@nullCase:
        @@@@enDesc: No script information.
    @@Return:
      @@@Type: DocumentFragment
      @@@enDesc:
        <QUOTE::disdoc> tree constructed from <P::sourceText>.
      @@@PrefixException:
      @@@RaiseException:
        @@@@@:DIS|NO_END_TAG_ERR
        @@@@enDesc:
          An end tag is not found where it is required.
      @@@RaiseException:
        @@@@@:DOMCore|DOMException.INVALID_CHARACTER_ERR
        @@@@enDesc:
          An illegular element type name is specified.
      @@@RaiseException:
        @@@@@:DOMCore|DOMException.NAMESPACE_ERR
        @@@@enDesc:
          An illegular element type name is specified.
      @@@PerlDef:
      __DEEP{
        my $ownerDocumentArg = $self;
        $sourceText =~ s/\x0D\x0A/\x0A/g;
        $sourceText =~ tr/\x0D/\x0A/;
        my @s = split /\x0A[\x09\x20]*(?:(?:\x0A[\x09\x20]*)+|(?=[\{\}]))/x,
                      $sourceText;
        $r = $ownerDocumentArg-><M::Document.createDocumentFragment>;

        my $root = $r-><M::Node.appendChild>
                            ($ownerDocumentArg-><M::Document.createElementNS>
                                                  (<Q::ddel:>, 'disdocBlocks'));
        if ($node) {
          my $db = $node-><AG::DIS|ManakaiDISNode.ownerDISDocument>
                        -><AG::DIS|ManakaiDISDocument.disDatabase>;
          if (defined $languageURI) {
            my $lang = $db-><M::DIS|ManakaiDISDatabase
                               .getResource> ($languageURI);
            my $tag = $lang-><M::DIS|ManakaiDISPropertyAccessor
                                .getPropertyText> (<Q::nl:ietfPreferredTag>) ||
                      $lang-><M::DIS|ManakaiDISPropertyAccessor
                                .getPropertyText> (<Q::nl:ietfTag>);
            if ($tag) {
              $root-><M::Element.setAttributeNS> (<Q::xml:>, 'xml:lang' => $tag);
            } else {
              $root-><M::Element.setAttributeNS> (<Q::xml:>, 'xml:lang' => '');
              $root-><M::Element.setAttributeNS> (<Q::script:>, 'script:lang'
                                                            => $languageURI);
            }
          }
        } elsif (defined $languageURI) {
          $root-><M::Element.setAttributeNS> (<Q::xml:>, 'xml:lang' => '');
          $root-><M::Element.setAttributeNS> (<Q::script:>, 'script:lang'
                                                              => $languageURI);
        }
        if (defined $scriptURI) {
          $root-><M::Element.setAttributeNS> (<Q::script:>, 'script:script'
                                                              => $scriptURI);
        }
        $root-><M::Element.setAttributeNS>
                           (<Q::ddel:>, 'ddel:mmParsed' => true);
        $root-><M::Element.setAttributeNS>
                           (<Q::ddel:>, 'ddel:tag' => 'entity');

        my $current = $root;
        for my $s (@s) {
          if ($s =~ s/^\{([0-9A-Za-z:|._\@^\s-]+?)::\s*//x) { ## Start tag
            my ($type, $lang, $script) = split /\s*\@\s*/, $1, 3;
            my ($etype, $ltype) = split /\s*\^\^\s*/, $type, 2;
            my ($nsp, $ln, $ns) = split /\s*[:|]\s*/, $etype, 2;
            if (defined $ln) {
              $ns = $namespaceContext-><M::DISDocNamespaceResolver
                                           .lookupNamespaceURI> ($nsp);
              unless (defined $ns) {
                __UNDEEP{__EXCEPTION{DIS:UNDECLARED_NS_PREFIX_ERR::
                  infoset:prefix => {$nsp},
                  DIS:sourceNode => {$node},
                }__}__;
              }
              $nsp .= ':';
            } else {
              $ln = $nsp;
              $ns = $namespaceContext-><AG::DISDocNamespaceResolver
                                           .defaultDISDocElementNamespaceURI>;
              $nsp = '';
            }
            my $ltypenode;
            if (defined $ltype) {
              my ($lnsp, $lln, $lns) = split /\s*[:|]\s*/, $ltype, 2;
              if (defined $lln) {
                $lns = $namespaceContext-><M::DISDocNamespaceResolver
                                             .lookupNamespaceURI> ($lnsp);
                unless (defined $lns) {
                  __UNDEEP{__EXCEPTION{DIS:UNDECLARED_NS_PREFIX_ERR::
                    infoset:prefix => {$lnsp},
                    DIS:sourceNode => {$node},
                  }__}__;
                }
              } else {
                $lln = $lnsp;
                $lns = $namespaceContext-><AG::DISDocNamespaceResolver
                                             .defaultDISDocElementNamespaceURI>;
              }
              $ltypenode = $ownerDocumentArg-><M::Document.createAttributeNS>
                             (<Q::ddel:>, 'ddel:lexType');
              $ltypenode-><AS::Node.textContent> ($lns.$lln);
            }
            my $this;
            if ($ns eq <Q::ddel:> and ($ln eq 'LI' or $ln eq 'OLI')) {
              unless ($current-><AG::Node.namespaceURI> eq <Q::html5:> and
                  {ul => true,
                   ol => true}->{$current-><AG::Node.localName>}) {
                $current = $current-><M::Node.appendChild>
                              ($ownerDocumentArg-><M::Document.createElementNS>
                                  (<Q::html5:>, 
                                   {LI => 'ul',
                                    OLI => 'ol'}->{$ln} || 'ul'));
                $current-><M::Element.setAttributeNS>
                                  (<Q::ddel:>, 'ddel:tag' => 'implied');
              }
              $this = $current = $current-><M::Node.appendChild>
                  ($ownerDocumentArg-><M::Document.createElementNS>
                              (<Q::html5:>, 'li'));
              $current-><M::Element.setAttributeNS>
                            (<Q::ddel:>, 'ddel:ordered' => true) if $ln eq 'OLI';
              $current-><M::Element.setAttributeNS>
                              (<Q::ddel:>, 'ddel:mmParsed' => true);
              $current-><M::Element.setAttributeNS>
                              (<Q::ddel:>, 'ddel:tag' => 'block');
              if ($s =~ s/^(.*)::://s) {
                my $m = $current-><M::Node.appendChild>
                     ($ownerDocumentArg-><M::Document.createElementNS>
                                  (<Q::ddel:>, 'ddel:listMarker'));
                $m-><M::Node.appendChild>
                         ($self-><M::DocumentDISDoc.parseDISDocInlineText>
                           ($namespaceContext, $1,
                            node => $node, language_uri => null,
                            script_uri => null));
                $m-><M::Element.setAttributeNS>
                              (<Q::ddel:>, 'ddel:tag' => 'implied');
              }
              $current = $current-><M::Node.appendChild>
                     ($ownerDocumentArg-><M::Document.createElementNS>
                                  (<Q::ddel:>, 'ddel:listContent'));
              $current-><M::Node.appendChild>
                       ($self-><M::DocumentDISDoc.parseDISDocInlineText>
                         ($namespaceContext, $s,
                          node => $node, language_uri => null,
                          script_uri => null));
              $current-><M::Element.setAttributeNS>
                              (<Q::ddel:>, 'ddel:tag' => 'implied');
            } else {
              if ($current-><AG::Node.namespaceURI> eq <Q::html5:> and
                  ($current-><AG::Node.localName> eq 'ul' or
                   $current-><AG::Node.localName> eq 'li') and
                  $current-><M::Element.getAttributeNS>
                                          (<Q::ddel:>, 'tag') eq 'implied') {
                $current = $current-><AG::Node.parentNode>;
              }
              $this = $current = $current-><M::Node.appendChild>
                  ($ownerDocumentArg-><M::Document.createElementNS>
                              ({
                                 <Q::ddel:NOTE> => <Q::html3:>,
                                 <Q::ddel:P> => <Q::html5:>,
                               }->{$ns.$ln} || $ns,
                               {
                                 <Q::ddel:NOTE> => 'H3:note',
                                 <Q::ddel:P> => 'p',
                               }->{$ln.$ln} || $nsp.$ln));
              $current-><M::Element.setAttributeNS>
                              (<Q::ddel:>, 'ddel:tag' => 'block');
              $current-><M::Node.appendChild>
                     ($self-><M::DocumentDISDoc.parseDISDocInlineText>
                       ($namespaceContext, $s,
                        node => $node, language_uri => null,
                        script_uri => null));
            }
            if ($ltypenode) {
              $this-><M::Element.setAttributeNodeNS> ($ltypenode);
            }
            if ($lang) {
              my ($nsp, $ln, $ns) = split /\s*[:|]\s*/, $lang, 2;
              if (defined $ln) {
                $ns = $namespaceContext-><M::DISDocNamespaceResolver
                                           .lookupNamespaceURI> ($nsp);
                unless (defined $ns) {
                  __UNDEEP{__EXCEPTION{DIS:UNDECLARED_NS_PREFIX_ERR::
                    infoset:prefix => {$nsp},
                    DIS:sourceNode => {$node},
                  }__}__;
                }
              } else {
                $ln = $nsp;
                $ns = <Q::ilang:>;
              }
              if ($ns eq <Q::ilang:>) {
                $this-><M::Element.setAttributeNS>
                                 (<Q::xml:>, 'xml:lang' => $ln);
              } else {
                $this-><M::Element.setAttributeNS> (<Q::xml:>, 'xml:lang' => '');
                $this-><M::Element.setAttributeNS>
                                 (<Q::script:>, 'script:lang' => $ns.$ln);
              }
            }
            if ($script) {
              my ($nsp, $ln, $ns) = split /\s*[:|]\s*/, $script, 2;
              if (defined $ln) {
                $ns = $namespaceContext-><M::DISDocNamespaceResolver
                                           .lookupNamespaceURI> ($nsp);
                unless (defined $ns) {
                  __UNDEEP{__EXCEPTION{DIS:UNDECLARED_NS_PREFIX_ERR::
                    infoset:prefix => {$nsp},
                    DIS:sourceNode => {$node},
                  }__}__;
                }
              } else {
                $ln = $nsp;
                $ns = <Q::script:>;
              }
              $this-><M::Element.setAttributeNS>
                                 (<Q::script:>, 'script:script' => $ns.$ln);
            }
          } elsif ($s =~ /^\s*\}\s*$/) { ## End tag
            while ($current-><M::Element.getAttributeNS>
                                      (<Q::ddel:>, 'tag') eq 'implied') {
              $current = $current-><AG::Node.parentNode>;
            }
            if ($current-><M::Element.getAttributeNS>
                                          (<Q::ddel:>, 'tag') eq 'entity') {
              ## Broken end tag
              $current-><M::Node.appendChild>
                          ($ownerDocumentArg-><M::Document.createTextNode> ($s));
            } else {
              $current = $current-><AG::Node.parentNode>;
            }
          } elsif ($s =~ s/^\s*([-=])\s*//) { ## List
            my $marker = $1;
            unless ($current-><AG::Node.namespaceURI> eq <Q::html5:> and
                    {ul => true,
                     ol => true}->{$current-><AG::Node.localName>}) {
              $current = $current-><M::Node.appendChild>
                              ($ownerDocumentArg-><M::Document.createElementNS>
                                  (<Q::html5:>, 
                                   {'-' => 'ul',
                                    '=' => 'ol'}->{$marker} || 'ul'));
              $current-><M::Element.setAttributeNS>
                                  (<Q::ddel:>, 'ddel:tag' => 'implied');
            }
            my $li = $current-><M::Node.appendChild>
                          ($ownerDocumentArg-><M::Document.createElementNS>
                             (<Q::html5:>, 'li'));
            $li-><M::Element.setAttributeNS>
                          (<Q::ddel:>, 'ddel:ordered' => true) if $marker eq '=';
            $li-><M::Element.setAttributeNS>
                                (<Q::ddel:>, 'ddel:tag' => 'implied');
            $li-><M::Element.setAttributeNS>
                                (<Q::ddel:>, 'ddel:mmParsed' => true);
            if ($s =~ s/^(.*)::://s) {
              my $m = $li-><M::Node.appendChild>
                     ($ownerDocumentArg-><M::Document.createElementNS>
                                  (<Q::ddel:>, 'ddel:listMarker'));
              $m-><M::Node.appendChild>
                         ($self-><M::DocumentDISDoc.parseDISDocInlineText>
                           ($namespaceContext, $1,
                            node => $node, language_uri => null,
                            script_uri => null));
              $m-><M::Element.setAttributeNS>
                              (<Q::ddel:>, 'ddel:tag' => 'implied');
            }
            my $lc = $li-><M::Node.appendChild>
                     ($ownerDocumentArg-><M::Document.createElementNS>
                                  (<Q::ddel:>, 'ddel:listContent'));
            $lc-><M::Node.appendChild>
                       ($self-><M::DocumentDISDoc.parseDISDocInlineText>
                         ($namespaceContext, $s,
                          node => $node, language_uri => null,
                          script_uri => null));
            $lc-><M::Element.setAttributeNS>
                              (<Q::ddel:>, 'ddel:tag' => 'implied');
          } else {
            ## /^\s*[^\w\s<]/ is reserved for future extensions
            if ($current-><AG::Node.namespaceURI> eq <Q::html5:> and
                ($current-><AG::Node.localName> eq 'ul' or
                 $current-><AG::Node.localName> eq 'li') and
                $current-><M::Element.getAttributeNS>
                                          (<Q::ddel:>, 'tag') eq 'implied') {
              $current = $current-><AG::Node.parentNode>;
            }
            my $p = $current-><M::Node.appendChild>
                          ($ownerDocumentArg-><M::Document.createElementNS>
                             (<Q::html5:>, 'p'));
            $p-><M::Element.setAttributeNS>
                                (<Q::ddel:>, 'ddel:tag' => 'implied');
            $p-><M::Node.appendChild>
                       ($self-><M::DocumentDISDoc.parseDISDocInlineText>
                         ($namespaceContext, $s,
                          node => $node, language_uri => null,
                          script_uri => null));
          }
        } # for

        while ($current-><M::Element.getAttributeNS>
                                          (<Q::ddel:>, 'tag') eq 'implied') {
          $current = $current-><AG::Node.parentNode>;
        }

        unless ($current eq $root) {
          __UNDEEP{__EXCEPTION{DIS|NO_END_TAG_ERR::
            DIS:elementType => {$current-><AG::Element.namespaceURI> .
                                $current-><AG::Element.localName>},
            DIS:sourceNode => {$node},
            DIS:sourceCode => {$sourceText},
          }__}__;
        }
      }__;

  @Method:
    @@Name: parseDISDocInlineText
    @@PerlName: parse_disdoc_inline_text
    @@enDesc:
      Parses a <QUOTE::disdoc> formatted text in the inline-level context.
    @@Param:
      @@@Name: namespaceContext
      @@@Type: DISDocNamespaceResolver
      @@@enDesc:
        A node or something used to resolve namespace prefix.
    @@Param:
      @@@Name: sourceText
      @@@Type: lang|disdocInline||ManakaiDOM|all
      @@@enDesc:
        A <QUOTE::disdoc> inline-level fragment.
    @@NamedParam:
      @@@Name: node
      @@@Type: DIS|ManakaiDISElement
      @@@enDesc:
        A <QUOTE::dis> element in which the <P::sourceText>
        is contained.  This information is used to report errors.
      @@@nullCase:
        @@@@enDesc: No source node.
    @@NamedParam:
      @@@Name: languageURI
      @@@Type: DIS|AnyURI
      @@@enDesc:
        The language information of the context in which the <P::sourceText>
        is contained.
      @@@nullCase:
        @@@@enDesc: No language information.
    @@NamedParam:
      @@@Name: scriptURI
      @@@Type: DIS|AnyURI
      @@@enDesc:
        The script information of the context in which the <P::sourceText>
        is contained.
      @@@nullCase:
        @@@@enDesc: No script information.
    @@NamedParam:
      @@@Name: defaultNameURI
      @@@Type: DIS|AnyURI
      @@@enDesc:
        The default <QUOTE::name URI> used to interpret <Q::dis:TFQNames>.
      @@@nullCase:
        @@@@enDesc: No default name.
    @@NamedParam:
      @@@Name: defaultForURI
      @@@Type: DIS|AnyURI
      @@@enDesc:
        The default <QUOTE::for URI> used to interpret <Q::dis:TFQNames>.
      @@@nullCase:
        @@@@enDesc:
          No default <QUOTE::for>.
    @@Return:
      @@@Type: DocumentFragment
      @@@enDesc:
        <QUOTE::disdoc> tree constructed from <P::sourceText>.
      @@@RaiseException:
        @@@@@:DIS|NO_END_TAG_ERR
        @@@@enDesc:
          An end tag is not found where it is required.
      @@@RaiseException:
        @@@@@:DOMCore|DOMException.INVALID_CHARACTER_ERR
        @@@@enDesc:
          An illegular element type name is specified.
      @@@RaiseException:
        @@@@@:DOMCore|DOMException.NAMESPACE_ERR
        @@@@enDesc:
          An illegular element type name is specified.
      @@@PrefixException:
      @@@PerlDef:
        $sourceText =~ s/^\s+//;
        $sourceText =~ s/\s+$//;
        my $ownerDocumentArg = $self;

        ## Container
        my $root = $r = $ownerDocumentArg-><M::Document.createDocumentFragment>;
        my $current = $r;

        ## Language
        if (defined $languageURI or defined $scriptURI) {
          $root = $current = $r-><M::Node.appendChild>
                             ($ownerDocumentArg-><M::Document.createElementNS>
                                 (<Q::ddel:>, 'disdocInline'));
          $root-><M::Element.setAttributeNS>
                           (<Q::ddel:>, 'ddel:tag' => 'entity');
        }
        if ($node) {
          my $db = $node-><AG::DIS|ManakaiDISNode.ownerDISDocument>
                        -><AG::DIS|ManakaiDISDocument.disDatabase>;
          if (defined $languageURI) {
            my $lang = $db-><M::DIS|ManakaiDISDatabase
                               .getResource> ($languageURI);
            my $tag = $lang-><M::DIS|ManakaiDISPropertyAccessor
                                .getPropertyText> (<Q::nl:ietfPreferredTag>) ||
                      $lang-><M::DIS|ManakaiDISPropertyAccessor
                                .getPropertyText> (<Q::nl:ietfTag>);
            if ($tag) {
              $current-><M::Element.setAttributeNS>
                             (<Q::xml:>, 'xml:lang' => $tag);
            } else {
              $current-><M::Element.setAttributeNS> (<Q::xml:>, 'xml:lang'=> '');
              $current-><M::Element.setAttributeNS> (<Q::script:>, 'script:lang'
                                                            => $languageURI);
            }
          }
        } elsif (defined $languageURI) {
          $current-><M::Element.setAttributeNS> (<Q::xml:>, 'xml:lang' => '');
          $current-><M::Element.setAttributeNS> (<Q::script:>, 'script:lang'
                                                              => $languageURI);
        }
        if (defined $scriptURI) {
          $current-><M::Element.setAttributeNS> (<Q::script:>, 'script:script'
                                                              => $scriptURI);
        }
        
        __DEEP{
          my @lextype = ('');
          while (CORE::length $sourceText) {
            if ($sourceText =~ s/^([^<>]+)//) {
              $current-><M::Node.appendChild>
                          ($ownerDocumentArg-><M::Document.createTextNode> ($1));
            } elsif ($sourceText =~ s/^<\s*(lt|gt|[{}:=-]|SP)\s*>//) {
              $current-><M::Node.appendChild>
                          ($ownerDocumentArg-><M::Document.createTextNode>
                             ({
                                lt => '<', gt => '>', 'SP' => ' ',
                                '{' => '{', '}' => '}', ':' => ':',
                                '=' => '=', '-' => '-',
                              }->{$1}));
            } elsif ($sourceText =~ s/^<([0-9A-Za-z_.:|\@\s-]+?)(?:::|(?=>))//) {
              my ($type, $lang, $script) = split /\s*\@\s*/, $1, 3;
              my ($etype, $ltype) = split /\s*\^\^\s*/, $type, 2;

              my ($nsp, $ln, $ns) = split /\s*[:|]\s*/, $etype, 2;
              if (defined $ln) {
                $ns = $namespaceContext-><M::DISDocNamespaceResolver
                                           .lookupNamespaceURI> ($nsp);
                unless (defined $ns) {
                  __UNDEEP{__EXCEPTION{DIS:UNDECLARED_NS_PREFIX_ERR::
                    infoset:prefix => {$nsp},
                    DIS:sourceNode => {$node},
                  }__}__;
                }
                $nsp .= ':';
              } else {
                $ln = $nsp;
                $ns = $namespaceContext-><AG::DISDocNamespaceResolver
                                           .defaultDISDocElementNamespaceURI>;
                $nsp = '';
              }

              $current = $current-><M::Node.appendChild>
                            ($ownerDocumentArg-><M::Document.createElementNS>
                                ({
                                   <Q::ddel:CITE> => <Q::html5:>,
                                   <Q::ddel:CODE> => <Q::html5:>,
                                   <Q::ddel:DFN> => <Q::html5:>,
                                   <Q::ddel:EM> => <Q::html5:>,
                                   <Q::ddel:KEY> => <Q::sw010:>,
                                   <Q::ddel:QUOTE> => <Q::html5:>,
                                   <Q::ddel:SRC> => <Q::sw010:>,
                                 }->{$ns.$ln} || $ns,
                                 {
                                   <Q::ddel:CITE> => 'cite',
                                   <Q::ddel:CODE> => 'code',
                                   <Q::ddel:DFN> => 'dfn',
                                   <Q::ddel:EM> => 'em',
                                   <Q::ddel:KEY> => 'key',
                                   <Q::ddel:QUOTE> => 'q',
                                   <Q::ddel:SRC> => 'src',
                                 }->{$ns.$ln} || $nsp.$ln));
              
              if (defined $ltype) {
                my ($lnsp, $lln, $lns) = split /\s*[:|]\s*/, $ltype, 2;
                if (defined $lln) {
                  $lns = $namespaceContext-><M::DISDocNamespaceResolver
                                               .lookupNamespaceURI> ($lnsp);
                  unless (defined $lns) {
                    __UNDEEP{__EXCEPTION{DIS:UNDECLARED_NS_PREFIX_ERR::
                      infoset:prefix => {$lnsp},
                      DIS:sourceNode => {$node},
                    }__}__;
                  }
                } else {
                  $lln = $lnsp;
                  $lns = $namespaceContext-><AG::DISDocNamespaceResolver
                                             .defaultDISDocElementNamespaceURI>;
                }
                push @lextype, $lns.$lln;
                $current-><M::Element.setAttributeNS>
                               (<Q::ddel:>, 'ddel:lexType' => $lextype[-1]);
              } else { # No explicit lextype
                push @lextype, {
                  <Q::ddel:A> => <Q::DISPerl:MemRef>,
                  <Q::ddel:CP> => <Q::DISCore:NCNameOrQName>,
                  <Q::ddel:ERR> => <Q::DISCore:NCNameOrQName>,
                  <Q::ddel:EV> => <Q::DISCore:NCNameOrQName>,
                  <Q::ddel:IF> => <Q::dis:TFQNames>,
                  <Q::ddel:Feature> => <Q::DISCore:NCNameOrQName>,
                  <Q::ddel:M> => <Q::DISPerl:MemRef>,
                  <Q::ddel:Q> => <Q::dis:TypeQName>,
                  <Q::ddel:TYPE> => <Q::dis:TFQNames>,
                  <Q::ddel:WARN> => <Q::DOMMain:XCodeRef>,
                  <Q::ddel:X> => <Q::DOMMain:XCodeRef>,
                  <Q::ddel:XA> => <Q::DISCore:NCNameOrQName>,
                  <Q::ddel:XE> => <Q::DISCore:NCNameOrQName>,
                }->{$ns.$ln} || '';
                if ($lextype[-1] ne '') {
                  $current-><M::Element.setAttributeNS>
                               (<Q::ddel:>, 'ddel:lexType' => $lextype[-1]);
                  $current-><M::Element.setAttributeNS>
                               (<Q::ddel:>, 'ddel:lexTypeImplied' => true);
                }
              }

              if ($lang) {
                my ($nsp, $ln, $ns) = split /\s*[:|]\s*/, $lang, 2;
                if (defined $ln) {
                  $ns = $namespaceContext-><M::DISDocNamespaceResolver
                                             .lookupNamespaceURI> ($nsp);
                  unless (defined $ns) {
                    __UNDEEP{__EXCEPTION{DIS:UNDECLARED_NS_PREFIX_ERR::
                      infoset:prefix => {$nsp},
                      DIS:sourceNode => {$node},
                    }__}__;
                  }
                } else {
                  $ln = $nsp;
                  $ns = <Q::ilang:>;
                }
                if ($ns eq <Q::ilang:>) {
                  $current-><M::Element.setAttributeNS>
                                   (<Q::xml:>, 'xml:lang' => $ln);
                } else {
                  $current-><M::Element.setAttributeNS>
                                   (<Q::xml:>, 'xml:lang' => '');
                  $current-><M::Element.setAttributeNS>
                                   (<Q::script:>, 'script:lang' => $ns.$ln);
                }
              }
              if ($script) {
                my ($nsp, $ln, $ns) = split /\s*[:|]\s*/, $script, 2;
                if (defined $ln) {
                  $ns = $namespaceContext-><M::DISDocNamespaceResolver
                                             .lookupNamespaceURI> ($nsp);
                  unless (defined $ns) {
                    __UNDEEP{__EXCEPTION{DIS:UNDECLARED_NS_PREFIX_ERR::
                      infoset:prefix => {$nsp},
                      DIS:sourceNode => {$node},
                    }__}__;
                  }
                } else {
                  $ln = $nsp;
                  $ns = <Q::script:>;
                }
                $current-><M::Element.setAttributeNS>
                                   (<Q::script:>, 'script:script' => $ns.$ln);
              }
            } elsif ($sourceText =~ s/^>//) { ## End tag
              if ($current-><AG::Node.nodeType> != <C::Node.ELEMENT_NODE> or
                  $current-><M::Element.getAttributeNS>
                                (<Q::ddel:>, 'tag') eq 'entity') {
                ## Illegal end tag
                $current-><M::Node.appendChild>
                         ($ownerDocumentArg-><M::Document.createTextNode> ('>'));
                next; # while
              }
              my $lextype = pop @lextype;
              if ($lextype eq <Q::dis:TypeQName> or
                  $lextype eq <Q::DISCore:NCNameOrQName>) {
                __CODE{qnameToElement::
                  $container => $current,
                  $useDefaultNamespace => {$lextype eq <Q::dis:TypeQName>},
                  $newParent => $current,
                  $ownerDocument => $ownerDocumentArg,
                  $namespaceContext => $namespaceContext,
                }__;
                $current-><M::Element.setAttributeNS>
                                  (<Q::ddel:>, 'ddel:mmParsed' => true);
              } elsif ($lextype eq <Q::dis:TFQNames>) {
                __CODE{tfqnamesToElement::
                  $container => $current,
                  $newParent => $current,
                  $namespaceContext => $namespaceContext,
                  $ownerDocument => $ownerDocumentArg,
                  $defaultNameURI => $defaultNameURI,
                  $defaultForURI => $defaultForURI,
                }__;
                $current-><M::Element.setAttributeNS>
                                  (<Q::ddel:>, 'ddel:mmParsed' => true);
              } elsif ($lextype eq <Q::DISPerl:MemRef>) {
                my $__mr; 
                __CODE{splitElementContentByString::
                  $container => $current,
                  $result => $__mr,
                  $split_pattern => {qr/\s*\.\s*/},
                  $split_text => '.',
                  $max => 2,
                }__;
                if (@$__mr == 2) {
                  $current-><AS::Node.textContent> ('.');
                  $current-><M::Node.insertBefore>
                     (my $__cn = $ownerDocumentArg-><M::Document.createElementNS>
                                   (<Q::ddel:>, 'ddel:name'),
                      $current-><AG::Node.firstChild>);
                  $__cn-><M::Element.setAttributeNS>
                                (<Q::ddel:>, 'ddel:tag' => 'dataTag');
                  for my $__el (@{$__mr->[0]}) {
                    $__cn-><M::Node.appendChild> ($__el);
                  }
                  __CODE{tfqnamesToElement::
                    $container => $__cn,
                    $newParent => $__cn,
                    $defaultNameURI => $defaultNameURI,
                    $defaultForURI => $defaultForURI,
                    $namespaceContext => $namespaceContext,
                    $ownerDocument => $ownerDocumentArg,
                  }__;

                  $current-><M::Node.appendChild>
                    (my $__cn2 = $ownerDocumentArg-><M::Document.createElementNS>
                                   (<Q::ddel:>, 'ddel:name'));
                  $__cn2-><M::Element.setAttributeNS>
                                (<Q::ddel:>, 'ddel:tag' => 'dataTag');
                  for my $__el (@{$__mr->[1]}) {
                    $__cn2-><M::Node.appendChild> ($__el);
                  }
                  if ($__cn2-><AG::Node.textContent> =~ /[:|]/) {
                    __CODE{tfqnamesToElement::
                      $container => $__cn2,
                      $newParent => $__cn2,
                      $defaultNameURI => $defaultNameURI,
                      $defaultForURI => $defaultForURI,
                      $namespaceContext => $namespaceContext,
                      $ownerDocument => $ownerDocumentArg,
                    }__;
                  } else {
                    $__cn2-><M::Node.appendChild>
                   (my $__cn2n = $ownerDocumentArg-><M::Document.createElementNS>
                                   (<Q::ddel:>, 'ddel:localName'));
                    $__cn2n-><M::Element.setAttributeNS>
                                (<Q::ddel:>, 'ddel:tag' => 'dataTag');
                    for my $__el (@{$__mr->[1]}) {
                      $__cn2n-><M::Node.appendChild> ($__el);
                    }
                    $__cn2-><M::Element.setAttributeNS>
                                (<Q::xmlns:>, 'xmlns' => '');
                  }
                } else {  ## Only a resource TFQNames
                  $current-><M::Node.insertBefore>
                    (my $__cn = $ownerDocumentArg-><M::Document.createElementNS>
                                   (<Q::ddel:>, 'ddel:name'),
                       $__mr->[0]->[0]);
                  $__cn-><M::Element.setAttributeNS>
                                (<Q::ddel:>, 'ddel:tag' => 'dataTag');
                  for my $__el (map {@$_} @$__mr) {
                    $__cn-><M::Node.appendChild> ($__el);
                  }
                  __CODE{tfqnamesToElement::
                    $container => $__cn,
                    $newParent => $__cn,
                    $defaultNameURI => $defaultNameURI,
                    $defaultForURI => $defaultForURI,
                    $namespaceContext => $namespaceContext,
                    $ownerDocument => $ownerDocumentArg,
                  }__;
                }
                $current-><M::Element.setAttributeNS>
                                  (<Q::ddel:>, 'ddel:mmParsed' => true);
              } elsif ($lextype eq <Q::DOMMain:XCodeRef>) {
                my $__mr; 
                __CODE{splitElementContentByString::
                  $container => $current,
                  $result => $__mr,
                  $split_pattern => {qr/\s*\.\s*/},
                  $split_text => '.',
                  $max => 3,
                }__;
                if (@$__mr == 2 or @$__mr == 3) {
                  $current-><AS::Node.textContent> ('.');
                  $current-><M::Node.insertBefore>
                     (my $__cn = $ownerDocumentArg-><M::Document.createElementNS>
                                   (<Q::ddel:>, 'ddel:name'),
                      $current-><AG::Node.firstChild>);
                  $__cn-><M::Element.setAttributeNS>
                                (<Q::ddel:>, 'ddel:tag' => 'dataTag');
                  for my $__el (@{$__mr->[0]}) {
                    $__cn-><M::Node.appendChild> ($__el);
                  }
                  __CODE{tfqnamesToElement::
                    $container => $__cn,
                    $newParent => $__cn,
                    $defaultNameURI => $defaultNameURI,
                    $defaultForURI => $defaultForURI,
                    $namespaceContext => $namespaceContext,
                    $ownerDocument => $ownerDocumentArg,
                  }__;

                  $current-><M::Node.appendChild>
                    (my $__cn2 = $ownerDocumentArg-><M::Document.createElementNS>
                                   (<Q::ddel:>, 'ddel:name'));
                  $__cn2-><M::Element.setAttributeNS>
                                (<Q::ddel:>, 'ddel:tag' => 'dataTag');
                  for my $__el (@{$__mr->[1]}) {
                    $__cn2-><M::Node.appendChild> ($__el);
                  }
                  if ($__cn2-><AG::Node.textContent> =~ /[:|]/) {
                    __CODE{tfqnamesToElement::
                      $container => $__cn2,
                      $newParent => $__cn2,
                      $defaultNameURI => $defaultNameURI,
                      $defaultForURI => $defaultForURI,
                      $namespaceContext => $namespaceContext,
                      $ownerDocument => $ownerDocumentArg,
                    }__;
                  } else {
                    $__cn2-><M::Node.appendChild>
                   (my $__cn2n = $ownerDocumentArg-><M::Document.createElementNS>
                                   (<Q::ddel:>, 'ddel:localName'));
                    $__cn2n-><M::Element.setAttributeNS>
                                (<Q::ddel:>, 'ddel:tag' => 'dataTag');
                    for my $__el (@{$__mr->[1]}) {
                      $__cn2n-><M::Node.appendChild> ($__el);
                    }
                    $__cn2-><M::Element.setAttributeNS>
                                (<Q::xmlns:>, 'xmlns' => '');
                  }

                  if (@$__mr == 3) {
                    $current-><M::Node.appendChild>
                     (my $__cn = $ownerDocumentArg-><M::Document.createElementNS>
                                   (<Q::ddel:>, 'ddel:name'));
                    $__cn-><M::Element.setAttributeNS>
                                (<Q::ddel:>, 'ddel:tag' => 'dataTag');
                    for my $__el (@{$__mr->[2]}) {
                      $__cn-><M::Node.appendChild> ($__el);
                    }
                    __CODE{tfqnamesToElement::
                      $container => $__cn,
                      $newParent => $__cn,
                      $defaultNameURI => $defaultNameURI,
                      $defaultForURI => $defaultForURI,
                      $namespaceContext => $namespaceContext,
                      $ownerDocument => $ownerDocumentArg,
                    }__;
                  }
                } else { ## @__mr == 1
                  $current-><M::Node.insertBefore>
                     (my $__cn = $ownerDocumentArg-><M::Document.createElementNS>
                                   (<Q::ddel:>, 'ddel:name'),
                       $__mr->[0]->[0]);
                  $__cn-><M::Element.setAttributeNS>
                                (<Q::ddel:>, 'ddel:tag' => 'dataTag');
                  for my $__el (map {@$_} @$__mr) {
                    $__cn-><M::Node.appendChild> ($__el);
                  }
                  __CODE{tfqnamesToElement::
                    $container => $__cn,
                    $newParent => $__cn,
                    $defaultNameURI => $defaultNameURI,
                    $defaultForURI => $defaultForURI,
                    $namespaceContext => $namespaceContext,
                    $ownerDocument => $ownerDocumentArg,
                  }__;
                }
                $current-><M::Element.setAttributeNS>
                                  (<Q::ddel:>, 'ddel:mmParsed' => true);
              } elsif ($lextype eq <Q::DISCore:NamespacePrefix>) {
                my $pfx = $current-><AG::Node.textContent>;
                my $ns = $namespaceContext-><M::DISDocNamespaceResolver
                                             .lookupNamespaceURI> ($pfx);
                if (defined $ns and length $ns) {
                  $current-><M::Element.setAttributeNS>
                                      (<Q::xmlns:>, 'xmlns:'.$pfx => $ns);
                }
                $current-><M::Element.setAttributeNS>
                                  (<Q::ddel:>, 'ddel:mmParsed' => true);
              } # lextype

              unless ($current eq $r) {
                $current = $current-><AG::Node.parentNode>;
              } else {  ## Illegular
                $current-><M::Node.appendChild>
                        ($ownerDocumentArg-><M::Document.createTextNode> ('>'));
              }
            } elsif ($sourceText =~ s/^(.)//s) { ## Illegular "<" and ">"
              $current-><M::Node.appendChild>
                          ($ownerDocumentArg-><M::Document.createTextNode>
                              ($1));
            }
          } # while

          unless ($current eq $root) {
            __UNDEEP{__EXCEPTION{DIS|NO_END_TAG_ERR::
              DIS:elementType => {$current-><AG::Element.namespaceURI> .
                                  $current-><AG::Element.localName>},
              DIS:sourceNode => {$node},
            }__}__;
          }
        }__;

  @ResourceDef:
    @@ForCheck: ManakaiDOM|ForClass
    @@rdf:type: dis2pm|BlockCode
    @@QName: qnameToElement
    @@enDesc:
      Converts a <Q::dis:TypeQName> to its tree representation.
      \
      Parameter: <Perl::$container>, <Perl::$namespaceContext>,
                 <Perl::$ownerDocument>, <Perl::$useDefaultNamespace>,
                 <Perl::$newParent>.
    @@PerlDef:
      my $__q;
      __CODE{splitElementContentByString::
        $container => $container,
        $split_pattern => {qr/\s*[:|]\s*/},
        $split_text => ':',
        $max => 2,
        $result => $__q,
      }__;
      my $__ln = $ownerDocument-><M::Document.createElementNS>
                                (<Q::ddel:>, 'ddel:localName');
      $__ln-><M::Element.setAttributeNS>
                                (<Q::ddel:>, 'ddel:tag' => 'dataTag');
      if (@$__q != 2) {  ## No prefix
        $newParent-><M::Node.insertBefore> ($__ln, $__q->[0]->[0]);
        for my $__el (map {@$_} @$__q) {
          $__ln-><M::Node.appendChild> ($__el);
        }

        my $__ns = $useDefaultNamespace
                               ? $namespaceContext-><AG::DISDocNamespaceResolver
                                             .defaultDISDocNamespaceURI>
                               : '';
        $__ns = '' unless defined $__ns;
        $newParent-><M::Element.setAttributeNS>
                                  (<Q::xmlns:>, xmlns => '');
      } else {  ## With prefix
        $newParent-><AS::Node.textContent> (':');
        $newParent-><M::Node.insertBefore>
                       (my $__pn = $ownerDocument-><M::Document.createElementNS>
                           (<Q::ddel:>, 'ddel:prefix'),
                        $newParent-><AG::Node.firstChild>);
        $newParent-><M::Node.appendChild> ($__ln);
        $__pn-><M::Element.setAttributeNS>
                           (<Q::ddel:>, 'ddel:tag' => 'dataTag');
        for my $__el (@{$__q->[0]}) {
          $__pn-><M::Node.appendChild> ($__el);
        }

        for my $__el (@{$__q->[1]}) {
          $__ln-><M::Node.appendChild> ($__el);
        }
             
        my $__pfx = $__pn-><AS::Node.textContent>;
        my $__ns = $namespaceContext-><M::DISDocNamespaceResolver
                                             .lookupNamespaceURI> ($__pfx);
        $__ns = '' unless defined $__ns;
        $__pn-><M::Element.setAttributeNS>
                                   (<Q::xmlns:>, 'xmlns:'.$__pfx => $__ns);
        unless ($__ns eq '') {
          $ownerDocument-><AS::Document.xmlVersion> ('1.1')
               if $ownerDocument-><AG::Document.xmlVersion> eq '1.0';
        }
      }

  @ResourceDef:
    @@ForCheck: ManakaiDOM|ForClass
    @@rdf:type: dis2pm|BlockCode
    @@QName: tfqnamesToElement
    @@enDesc:
      Splits an element content which is a <Q::dis:TFQNames>
      into a set of elements.
      \
      Parameters: $container, $namespaceContext, $ownerDocument,
        $defaultNameURI, $defaultForURI,
        $newParent.  $newParent must be equal to the $container.
    @@PerlDef:
      my $__tf;
      __CODE{splitElementContentByString::
        $container => $container,
        $split_pattern => {qr/\s*[:|][:|]\s*/},
        $split_text => '::',
        $max => 2,
        $result => $__tf,
      }__;
      if (@$__tf == 2) {
        $newParent-><AS::Node.textContent> ('::');
        $newParent-><M::Node.insertBefore>
                      (my $__tqn = $ownerDocument-><M::Document.createElementNS>
                                   (<Q::ddel:>, 'ddel:nameQName'),
                       $newParent-><AG::Node.firstChild>);
        $__tqn-><M::Element.setAttributeNS>
                                (<Q::ddel:>, 'ddel:tag' => 'dataTag');
        for my $__el (@{$__tf->[0]}) {
          $__tqn-><M::Node.appendChild> ($__el);
        }
        if (length $__tqn-><AG::Node.textContent>) {
          __CODE{qnameToElement::
            $container => $__tqn,
            $ownerDocument => $ownerDocument,
            $namespaceContext => $namespaceContext,
            $useDefaultNamespace => {true},
            $newParent => $__tqn,
          }__;
        } else {
          ## TODO: xsd:nil ?
          $__tqn-><M::Element.setAttributeNS>
                          (<Q::ddel:>,
                           'ddel:defaultURI' => defined $defaultNameURI
                                                ? $defaultNameURI : '');
        }

        $newParent-><M::Node.appendChild>
                      (my $__fqn = $ownerDocument-><M::Document.createElementNS>
                                   (<Q::ddel:>, 'ddel:forQName'));
        $__fqn-><M::Element.setAttributeNS>
                                (<Q::ddel:>, 'ddel:tag' => 'dataTag');
        for my $__el (@{$__tf->[1]}) {
          $__fqn-><M::Node.appendChild> ($__el);
        }
        if (length $__fqn-><AG::Node.textContent>) {
          __CODE{qnameToElement::
            $container => $__fqn,
            $ownerDocument => $ownerDocument,
            $namespaceContext => $namespaceContext,
            $useDefaultNamespace => {true},
            $newParent => $__fqn,
          }__;
        } else {
          $__fqn-><M::Element.setAttributeNS>
                     (<Q::ddel:>, 'ddel:defaultURI' => <Q::ManakaiDOM:all>);
        }
      } else {  ## No "for" URI
        $newParent-><M::Node.insertBefore>
                      (my $__tqn = $ownerDocument-><M::Document.createElementNS>
                                   (<Q::ddel:>, 'ddel:nameQName'),
                       $__tf->[0]->[0]);
        $__tqn-><M::Element.setAttributeNS>
                                (<Q::ddel:>, 'ddel:tag' => 'dataTag');
        for my $__el (map {@$_} @$__tf) {
          $__tqn-><M::Node.appendChild> ($__el);
        }
        if (length $__tqn-><AG::Node.textContent>) {
          __CODE{qnameToElement::
            $container => $__tqn,
            $ownerDocument => $ownerDocument,
            $namespaceContext => $namespaceContext,
            $useDefaultNamespace => {true},
            $newParent => $__tqn,
          }__;
        } else {
          ## TODO: xsd:nil ?
          $__tqn-><M::Element.setAttributeNS>
                          (<Q::ddel:>,
                           'ddel:defaultURI' => defined $defaultNameURI
                                                ? $defaultNameURI : '');
        }
                  
        $newParent-><M::Node.appendChild>
                      (my $__fqn = $ownerDocument-><M::Document.createElementNS>
                                   (<Q::ddel:>, 'ddel:forQName'));
        $__fqn-><M::Element.setAttributeNS>
                                (<Q::ddel:>, 'ddel:tag' => 'implied');
        ## TODO: xsd:nil ?
        $__fqn-><M::Element.setAttributeNS>
                          (<Q::ddel:>,
                           'ddel:defaultURI' => defined $defaultForURI
                                                ? $defaultForURI : '');
      }


  @ResourceDef:
    @@ForCheck: ManakaiDOM|ForClass
    @@rdf:type: dis2pm|BlockCode
    @@QName: splitElementContentByString
    @@enDesc:
      Splits a set of element content nodes by a string,
      which should be occurred in text nodes that are direct
      children of the container element.
      \
      Parameters: $container, $split_pattern, $split_text, $max, 
        $result (destructive).
    @@PerlDef:
      my $__containerChildren = $container-><AG::Node.childNodes>;
      my $__containerLength = $__containerChildren-><AG::NodeList.length>;
      if ($__containerLength == 1) {
        my $__childNode = $__containerChildren-><M::NodeList.item> (0);
        if ($__childNode-><AG::Node.nodeType> == <C::Node.TEXT_NODE>) {
          my @__data = split $split_pattern,
                             $__childNode-><AG::Node.textContent>,
                             $max;
          if (@__data > 1) {
            my $__od = $__childNode-><AG::Node.ownerDocument>;
            $__childNode-><AS::Node.textContent> (shift @__data);
            $result = [[$__childNode]];
            for my $__data (@__data) {
              $container-><M::Node.insertBefore>
                             ($__od-><M::Document.createTextNode> ($split_text),
                              my $__xs = $container-><AG::Node.firstChild>);
              push @$result, [$container-><M::Node.insertBefore>
                                ($__od-><M::Document.createTextNode> ($__data),
                                 $__xs)];
            }
          } else {
            $result = [[$__childNode]];
          }
        } else {  ## The only child is not a text node
          $result = [[$__childNode]];
        }
      } else {  ## There are multiple children
        $result = [[]];
        my $__max = $max;
        my $__od = $container-><AG::Node.ownerDocument>;
        my @__containerChildrenSnapshot;
        for (my $__i = 0; $__i < $__containerLength; $__i++) {
          push @__containerChildrenSnapshot,
               $__containerChildren-><M::NodeList.item> ($__i);
        }
        for my $__childNode (@__containerChildrenSnapshot) {
          if ($__max > 0 and
              $__childNode-><AG::Node.nodeType> == <C::Node.TEXT_NODE>) {
            my @__data = split $split_pattern,
                               $__childNode-><AG::Node.textContent>,
                               $__max;
            if (@__data > 1) {
              $__childNode-><AS::Node.textContent> (shift @__data);
              push @{$result->[-1]}, $__childNode;
              $__max--;
              for my $__data (@__data) {
                $container-><M::Node.insertBefore>
                             ($__od-><M::Document.createTextNode> ($split_text),
                              $__containerChildrenSnapshot[0]);
                push @$result, [$container-><M::Node.insertBefore>
                                ($__od-><M::Document.createTextNode> ($__data),
                                 $__containerChildrenSnapshot[0])];
                $__max--;
              }
            } else {
              push @{$result->[-1]}, $__childNode;
            }
          } else {  ## This child is not a text node
            push @{$result->[-1]}, $__childNode;
          }
        }
        if (@{$result->[-1]} == 0) {
          pop @{$result->[-1]};
        }
      }
##DocumentDISDoc

ElementTypeBinding:
  @Name: PerlName
  @ElementType:
    dis:AppName
  @ShadowContent:
    @@ContentType: lang|Perl

ElementTypeBinding:
  @Name: PrefixException
  @ElementType:
    ManakaiDOM:raises
  @ShadowContent:
    @@@: UNDECLARED_NS_PREFIX_ERR
    @@Description:
      @@@lang:en
      @@@@:
        A namespace prefix is not declared.

ElementTypeBinding:
  @Name: RaiseException
  @ElementType:
    ManakaiDOM:raises

ResourceDef:
  @QName: Element
  @AliasFor: DOMCore|Element||ManakaiDOM|ManakaiDOMLatest

ResourceDef:
  @QName: DocumentFragment
  @AliasFor: DOMCore|DocumentFragment||ManakaiDOM|ManakaiDOMLatest

ResourceDef:
  @QName: UNDECLARED_NS_PREFIX_ERR
  @AliasFor:
    DIS:UNDECLARED_NS_PREFIX_ERR::swcfg21:ForLatest

## -- disdoc Utility Interfaces

IFClassDef:
  @IFQName: DISDocNegotiationCondition
  @ClsQName: ManakaiDISDocNegotiationCondition

  @Method:
    @@Name: selectDISElement
    @@enDesc:
      Selects a <QUOTE::dis> element by this condition.
    @@Param:
      @@@Name: elements
      @@@Type: Perl|ARRAY||ManakaiDOM|all
      @@@enDesc:
        A reference to array whose items are <QUOTE::dis> elements.
    @@Return:
      @@@Type: DIS|ManakaiDISElement
      @@@enDesc:
        A <QUOTE::dis> element choosen from <P::element>.
      @@@nullCase:
        @@@@enDesc:
          No appropaiate element.
      @@@PerlDef:
        $r = $elements->[0];
      @@@ImplNote:
        @@@@lang:en
        @@@@@:
          {TODO:: Implementation required.
          \
          }

  @ImplNote:
    @@lang:en
    @@@:
      Attributes and/or methods such as Accept-Language is required.
##DISDocNegotiationCondition

IFDef:
  @IFQName: DISDocNamespaceResolver

  @enDesc:
    A namespace resolver interface for <QUOTE::disdoc>. 
    Objects implementing this interface must provide
    lookup functions from namespace prefix or default namespace
    to corresponding namespace URI reference.

  @Attr:
    @@Name: defaultDISDocNamespaceURI
    @@PerlName: default_disdoc_namespace_uri
    @@enDesc:
      The default namespace URI for <QUOTE::disdoc> contents.
    @@Type: DIS|AnyURI
    @@Get: 

  @Attr:
    @@Name: defaultDISDocElementNamespaceURI
    @@PerlName: default_disdoc_element_namespace_uri
    @@enDesc:
      The default namespace URI for <QUOTE::disdoc> element types.
    @@Type: DIS|AnyURI
    @@Get:
 
  @Method:
    @@Name: lookupNamespaceURI
    @@enDesc:
      Looks up the namespace URI associated to the given prefix.
    @@Param:
      @@@Name:prefix
      @@@Type:
        DISCore:NamespacePrefix::ManakaiDOM:all
      @@@Description:
        @@@@lang:en
        @@@@@:
          The namespace URI to look for.
    @@Return:
      @@@Type: DIS|AnyURI
      @@@Description:
        @@@@lang:en
        @@@@@:The associated namespace URI.
      @@@nullCase:
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            No namespace URI is associated to the prefix or
            the <DOM::null> namespace is associated.
      @@@PrefixException:
##DISDocNamespaceResolver


ElementTypeBinding:
  @Name: NamedParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:MethodParameter
    @@DISPerl:isNamedParameter:1

ResourceDef:
  @QName: Node
  @AliasFor: DOMCore|Node||ManakaiDOM|ManakaiDOMLatest

ResourceDef:
  @QName: NodeList
  @AliasFor: DOMCore|NodeList||ManakaiDOM|ManakaiDOMLatest

