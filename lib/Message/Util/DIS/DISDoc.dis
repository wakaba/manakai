Module:
  @QName:
    DIS:DISDoc
  @FullName:
    @@lang: en
    @@@:
      <QUOTE::disdoc> Documentation Support Module
  @Namespace:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS#DISDoc/
  
  @Description:
    @@lang:en
    @@@:
      This module provides an object model for <QUOTE::disdoc>
      documentation format.  

  @Author:
    @@FullName: Wakaba
    @@Mail: w@suika.fam.cx
  @License:
    @@@:
      license:Perl+MPL
    @@Original:
      @@@FullName:
        manakai <CODE::lib/manakai/dis.pl>
      @@@Year:2004
      @@@Author:
        @@@@FullName:Wakaba
        @@@@Mail:w@suika.fam.cx
  @Date:
    @@@:
      $Date: 2005/05/28 13:38:45 $
    @@ContentType:
      dis:Date.RCS
  
  @Require:
    @@Module:
      @@@QName: Util|DIS
      @@@WithFor: 
        DIS:ForLatest
    @@Module:
      @@@QName: MDOM|DOMHTML
      @@@WithFor: ManakaiDOM|ManakaiDOMLatest

  @DefaultFor: 
    DIS:ForLatest

Namespace:
  @dd:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS#DISDoc/
  @ddel:
    http://suika.fam.cx/~wakaba/archive/2005/disdoc#
  @DIS:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS#
  @dis:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#dis--
  @dis2pm:
    http://suika.fam.cx/~wakaba/archive/2004/11/8/dis2pm#
  @DISlib:
    http://suika.fam.cx/~wakaba/archive/2004/dis/
  @disPerl:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#dis--Perl--
  @DOMCore:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#
  @DOMException:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#
  @DOMLS:
    http://suika.fam.cx/~wakaba/archive/2004/dom/ls#
  @DOMMain:
    http://suika.fam.cx/~wakaba/archive/2004/dom/main#
  @html3:
    urn:x-suika-fam-cx:markup:ietf:html:3:draft:00:
  @html5:
    http://www.w3.org/1999/xhtml
  @ilang:
    urn:x-suika-fam-cx:lang:
  @infoset:
    http://www.w3.org/2001/04/infoset#
  @lang:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#
  @license:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/license#
  @ManakaiDOM:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#
  @Markup:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Markup#
  @MDOM:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#ManakaiDOM.
  @MDOMX:
    http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#
  @nl:
    http://suika.fam.cx/~wakaba/archive/2004/dis/NaturalLanguage#
  @owl:
    http://www.w3.org/2002/07/owl#
  @Perl:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#Perl--
  @rdf:
    http://www.w3.org/1999/02/22-rdf-syntax-ns#
  @rdfs:
    http://www.w3.org/2000/01/rdf-schema#
  @s:
    http://suika.fam.cx/~wakaba/archive/2004/dis/Markup#
  @script:
    http://suika.fam.cx/~wakaba/archive/2005/5/script#
  @sw010:
    urn:x-suika-fam-cx:markup:suikawiki:0:10:
  @swcfg21:
    http://suika.fam.cx/~wakaba/archive/2005/swcfg21#
  @TreeCore:\
  @Util:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/
  @xhtml1:
    http://www.w3.org/1999/xhtml
  @xhtml2:
    http://www.w3.org/2002/06/xhtml2
  @xml:
    http://www.w3.org/XML/1998/namespace

## -- Features

ElementTypeBinding:
  @Name: FeatureDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DOMMain:DOMFeature
    @@ForCheck:
      ManakaiDOM:all

ElementTypeBinding:
  @Name: FeatureVerDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DOMMain:DOMFeature

ElementTypeBinding:
  @Name: featureQName
  @ElementType:
    dis:AppName
  @ShadowContent:
    @@ContentType:
      dis:TypeQName

FeatureDef:
  @QName: DIS|Doc
  @FeatureVerDef:
    @@QName: DIS|Doc20
    @@Version: 2.0
    @@DOMMetaImpl:instanceFeatureOf: DIS|Doc
    @@DOMMain:requireFeature: DIS|CoreFeature10
    @@FullName:
      @@@lang:en
      @@@@:
        <QUOTE::disdoc> version 2.0

FeatureDef:
  @QName: DIS|HTML
  @FeatureVerDef:
    @@QName: DIS|HTML20
    @@Version: 2.0
    @@DOMMetaImpl:instanceFeatureOf: DIS|HTML
    @@DOMMain:requireFeature: DIS|Doc20
    @@FullName:
      @@@@:
        <QUOTE::disdoc> version 2.0 with HTML output
      @@@lang:en

ElementTypeBinding:
  @Name: enDesc
  @ElementType: 
    dis:Description
  @ShadowContent: 
    @@lang:en

ElementTypeBinding:
  @Name: IFClassDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      @@@@: dis|MultipleResource
      @@@ForCheck: !ManakaiDOM|ForIF !ManakaiDOM|ForClass
    @@resourceFor: ManakaiDOM|ForIF
    @@resourceFor: ManakaiDOM|ForClass

    @@rdf:type:
      @@@@: ManakaiDOM|IF
      @@@ForCheck: ManakaiDOM|ForIF

    @@rdf:type:
      @@@@: ManakaiDOM|Class
      @@@ForCheck: ManakaiDOM|ForClass
    @@Implement:
      @@@@: ||+||ManakaiDOM|ForIF
      @@@ForCheck: ManakaiDOM|ForClass
      @@@ContentType: DISCore|TFPQNames

    @@DOMMain:implementFeature: DIS|Doc20
    @@DOMMain:implementFeature: DIS|HTML20

ElementTypeBinding:
  @Name: IFDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      @@@@: dis|MultipleResource
      @@@ForCheck: !ManakaiDOM|ForIF !ManakaiDOM|ForClass
    @@resourceFor: ManakaiDOM|ForIF

    @@rdf:type:
      @@@@: ManakaiDOM|IF
      @@@ForCheck: ManakaiDOM|ForIF

ElementTypeBinding:
  @Name: IFQName
  @ElementType:
    dis:QName
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForIF

ElementTypeBinding:
  @Name: ClsQName
  @ElementType:
    dis:QName
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: IFISA
  @ElementType:
    dis:ISA
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForIF

ElementTypeBinding:
  @Name: ClsISA
  @ElementType:
    dis:ISA
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: Method
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Method

ElementTypeBinding:
  @Name: Return
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|MethodReturn

ElementTypeBinding:
  @Name: Param
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|MethodParameter

## -- disdoc Implementation Interface

IFClassDef:
  @IFQName: DISImplementationDISDoc
  @ClsQName: ManakaiDISImplementationDISDoc
  
  @ClsISA: DIS|ManakaiDISImplementation

  @enDesc:
    This interface provides factory methods to create
    <QUOTE::disdoc>-related objects.

  @Method:
    @@Name: createDISDocNegotiationCondition
    @@PerlName: create_disdoc_negotiation_condition
    @@enDesc:
      Creates a new <IF::DISDocNegotiationCondition> object and 
      returns it.
    @@Return:
      @@@Type: DISDocNegotiationCondition
      @@@actualType: ManakaiDISDocNegotiationCondition
      @@@enDesc:
        A newly created negotiation condition object.
      @@@PerlDef:
        $r = bless {}, <ClassName::ManakaiDISDocNegotiationCondition>;
##DISImplementationDISDoc

ElementTypeBinding:
  @Name: PerlDef
  @ElementType:
    dis:Def
  @ShadowContent:
    @@ContentType: lang|Perl

ElementTypeBinding:
  @Name: disDef
  @ElementType:
    dis:Def
  @ShadowContent:
    @@ContentType: lang|dis

ElementTypeBinding:
  @Name: PropDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: rdf|Property

## -- disdoc Extended Interfaces for dis Database Objects

IFClassDef:
  @IFQName: DISAnyResourceDISDoc
  @ClsQName: ManakaiDISAnyResourceDISDoc

  @enDesc:
    This interface provides an access to <QUOTE::disdoc>
    methods from <QUOTE::dis> resource, module or <QUOTE::for> definition.

  @Method:
    @@Name: getFullName
    @@enDesc:
      Returns a copy of (human readable) full name. 
    @@OwnerDocArg:
    @@NegoParam:
    @@Return:
      @@@Type: DocumentFragment
      @@@enDesc:
        A DOM node containing full name. 
      @@@nullCase:
        @@@@enDesc:
          No full name for this resource.
      @@@PerlDef:
        __DEEP{
          if ($self->{o}->{src}) {
            my $fn = $self->{o}->{src}
                          -><M::DIS:ManakaiDISElement.disGetAttribute>
                                 (<Q::dis:FullName>,
                                  for_arg => $self->{o}->{for},
                                  forp_arg => $self->{o}->{forp});
            if ($fn) {
              $r = $fn-><M::DIS:ManakaiDISElement.getFeature> (<Q::DIS:Doc>)
                      -><M::ManakaiDISElementDISDoc.getDISDocTree>
                              ($ownerDocumentArg, <Q::lang:disdocInline>);
            }
          }
        }__;

  @Method:
    @@Name: getDescription
    @@enDesc:
      Returns a copy of (human readable) description.
    @@OwnerDocArg:
    @@NegoParam:
    @@Param:
      @@@Name: withImplNote
      @@@enDesc:
        Whether should implementor's notes also be returned or not.
      @@@Type: DOMMain|boolean||ManakaiDOM|all
      @@@trueCase:
        @@@@enDesc:
          Implementor's notes will also be part of the returned value.
      @@@falseCase:
        @@@@enDesc:
          The result will not contains any implementor's notes.
    @@Return:
      @@@Type: DocumentFragment
      @@@enDesc:
        A DOM node containing label.
      @@@nullCase:
        @@@@enDesc:
          No label for this resource.
      @@@PerlDef:
        __DEEP{
          if ($self->{o}->{src}) {
            my @el = ([]); # $el[0] is dummy
            my %el;
            for my $c (@{$self->{o}->{src}
                              -><M::DIS:ManakaiDISElement.disChildElements>
                                  (for_arg => $self->{o}->{for},
                                   forp_arg => $self->{o}->{forp})}) {
              if ($c-><M::DIS:ManakaiDISElement.elementTypeMatch>
                                  (<Q::dis:Description>) or
                  ($withImplNote and
                   $c-><M::DIS:ManakaiDISElement.elementTypeMatch>
                                  (<Q::dis:ImplNote>))) {
                my $d = $c-><M::DIS:ManakaiDISElement.getFeature> (<Q::DIS:Doc>);
                my $id = $d-><M::ManakaiDISElementDISDoc.documentationGroupId>
                                  (for_arg => $self->{o}->{for},
                                   forp_arg => $self->{o}->{forp});
                if ($el{$id}) {
                  push @{$el[$el{$id}]}, $d;
                } else {
                  $el{$id} = @el;
                  push @el, [$d];
                }
              }
            } # children

            shift @el; # Discard dummy item
            for my $els (@el) {
              my $el = $condition-><M::ManakaiDISDocNegotiationCondition
                                      .selectDISElement> ($els);
              next unless $el;
              my $elr = $el-><M::ManakaiDISElementDISDoc.getDISDocTree>
                              ($ownerDocumentArg, <Q::lang:disdoc>);
              if ($elr) {
                if ($r) {
                  $r-><M::DOMCore:Node||ManakaiDOM|ManakaiDOMLatest
                         .appendChild> ($elr);
                } else {
                  $r = $elr;
                }
              }
            } # groups
          }
        }__;
##DISAnyResourceDoc

IFClassDef:
  @IFQName: DISResourceDISDoc
  @ClsQName: ManakaiDISResourceDISDoc

  @IFISA: DISAnyResourceDISDoc
  @ClsISA: ManakaiDISAnyResourceDISDoc

  @DISLang:role: DIS|ResourceRole

  @enDesc:
    This interface provides an access to <QUOTE::disdoc>
    methods from <QUOTE::dis> resource definition.
    \
    This interface can be obtained
    from the object implementing
    <Class::DIS:ManakaiDISResourceDefinition> class
    by calling the <M::DIS:ManakaiDISResourceDefinition
    .getFeature> method with the <P::feature> parameter
    set to <Feature::DIS|Doc>.

  @Method:
    @@Name: getLabel
    @@enDesc:
      Returns a copy of (human readable) label.
    @@OwnerDocArg:
    @@NegoParam:
    @@Return:
      @@@Type: DocumentFragment
      @@@enDesc:
        A DOM node containing label.
      @@@nullCase:
        @@@@enDesc:
          No label for this resource.
        __DEEP{
          if ($self->{o}->{src}) {
            my $fn = $self->{o}->{src}
                          -><M::DIS:ManakaiDISElement.disGetAttribute>
                                 (<Q::dis:Label>,
                                  for_arg => $self->{o}->{for},
                                  forp_arg => $self->{o}->{forp});
            if ($fn) {
              $r = $fn-><M::DIS:ManakaiDISElement.getFeature> (<Q::DIS:Doc>)
                      -><M::ManakaiDISElementDISDoc.getDISDocTree>
                              ($ownerDocumentArg, <Q::lang:disdocInline>);
            }
          }
        }__;
##DISResourceDISDoc

IFClassDef:
  @IFQName: DISModuleDISDoc
  @ClsQName: ManakaiDISModuleDISDoc

  @IFISA: DISAnyResourceDISDoc
  @ClsISA: ManakaiDISAnyResourceDISDoc

  @DISLang:role: DIS|ModuleRole

  @enDesc:
    This interface provides an access to <QUOTE::disdoc>
    methods from <QUOTE::dis> module definition.
    \
    This interface can be obtained
    from the object implementing
    <Class::DIS:ManakaiDISModuleDefinition> class
    by calling the <M::DIS:ManakaiDISModuleDefinition
    .getFeature> method with the <P::feature> parameter
    set to <Feature::DIS|Doc>.
##DISModuleDISDoc

IFClassDef:
  @IFQName: DISForDISDoc
  @ClsQName: ManakaiDISForDISDoc

  @IFISA: DISAnyResourceDISDoc
  @ClsISA: ManakaiDISAnyResourceDISDoc

  @DISLang:role: DIS|ForRole

  @enDesc:
    This interface provides an access to <QUOTE::disdoc>
    methods from <QUOTE::dis> <QUOTE::for> definition.
    \
    This interface can be obtained
    from the object implementing
    <Class::DIS:ManakaiDISForDefinition> class
    by calling the <M::DIS:ManakaiDISForDefinition
    .getFeature> method with the <P::feature> parameter
    set to <Feature::DIS|Doc>.
##DISForDISDoc

ElementTypeBinding:
  @Name: nullCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: ManakaiDOM|InCase
    @@Value:
      @@@is-null:1

ElementTypeBinding:
  @Name: NegoParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|MethodParameter
    @@Name: condition
    @@Type: DISDocNegotiationCondition
    @@Description:
      @@@lang:en
      @@@@: A condition object for negotiation.
    @@ResourceDef:
      @@@@rdf:type: ManakaiDOM|InCase
      @@@@Value:
        @@@@@is-null:1
      @@@@Description:
        @@@@@lang:en
        @@@@@@: No negotiation.

ElementTypeBinding:
  @Name: OwnerDocArg
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|MethodParameter
    @@Name: ownerDocumentArg
    @@Type: Document
    @@Description:
      @@@lang:en
      @@@@:
        A DOM <IF::DOMCore:Document> object that is used to
        construct the tree.  It is set to the <A::DOMCore:Node.ownerDocument>
        of the result nodes.

## -- disdoc Extended Interface for dis Object Model

IFClassDef:
  @IFQName: DISElementDISDoc
  @ClsQName: ManakaiDISElementDISDoc

  @ClsISA: DIS|ManakaiDISElement

  @IFISA: DISDocNamespaceResolver
  @Implement: DISDocNamespaceResolver

  @enDesc:
    <QUOTE::disdoc> interface for <QUOTE::dis> elements.
    \
    This interface can be obtained from a <Class::DIS:ManakaiDISElement>
    class by <M::DIS|ManakaiDISElement.getFeature> method
    with the parameter of <Feature::DIS|Doc>.
    
  @Method:
    @@Name: languageURI
    @@enDesc:
      The natural language URI reference for the content
      of this element.
    @@Type: DIS|AnyURI
    @@Param:
      @@Name: defaultLangURI
      @@Type: DIS|AnyURI
      @@enDesc:
        The language tag URI reference of the default language.
        It is considered as the element language if the element
        does not have the language information.
      @@nullCase:
        @@@enDesc:
          No default language information.
    @@ForParam:
    @@ForpParam:
    @@Return:
      @@@enDesc:
        The natural language URI referemce.
      @@@nullCase:
        @@@@enDesc:
          No language tag for this element and <P::defaultLangURI>
          parameter is not specified. 
      @@@PerlDef:
      __DEEP{
        my $lang = $self-><M::DIS:ManakaiDISElement.disGetAttribute>
                       (<Q::dis:lang>, for_arg => $forArg, forp_arg => $forpArg);
        if ($lang) {
          my $v = $lang-><M::swcfg21:SWCFGNode::swcfg21:ForLatest.value>;
          if (defined $v and not ref $v eq 'ARRAY') {
            $r = $lang-><M::DIS|ManakaiDISElement.qnameToURI>
                             ($v, node => $self,
                              default_namespace_uri => <Q::ilang:>);
          } else {
            $r = $defaultLangURI;
          }
        } else {
          $r = $defaultLangURI;
        }
      }__;
    @@ImplNote:
      @@@lang:en
      @@@@:
        {NOTE:: Currently language tag does not inherit.  Should it
                inherit?
        \
        }

  @Method:
    @@Name: scriptURI
    @@enDesc:
      The script (writing system) URI reference for the content
      of this element.
    @@Type: DIS|AnyURI
    @@Param:
      @@Name: defaultScriptURI
      @@Type: DIS|AnyURI
      @@enDesc:
        The script tag URI reference of the default script.
        It is considered as the element script if the element
        does not have the script information.
      @@nullCase:
        @@@enDesc:
          No default script information.
    @@ForParam:
    @@ForpParam:
    @@Return:
      @@@enDesc:
        The natural script URI referemce.
      @@@nullCase:
        @@@@enDesc:
          No script tag for this element and <P::defaultScriptURI>
          parameter is not specified. 
      @@@PerlDef:
      __DEEP{
        my $lang = $self-><M::DIS:ManakaiDISElement.disGetAttribute>
                     (<Q::dis:script>, for_arg => $forArg, forp_arg => $forpArg);
        if ($lang) {
          my $v = $lang-><M::swcfg21:SWCFGNode::swcfg21:ForLatest.value>;
          if (defined $v and not ref $v eq 'ARRAY') {
            $r = $lang-><M::DIS|ManakaiDISElement.qnameToURI>
                             ($v, node => $self,
                              default_namespace_uri => <Q::script:>);
          } else {
            $r = $defaultScriptURI;
          }
        } else {
          $r = $defaultScriptURI;
        }
      }__;

  @Method:
    @@Name: languageMatch
    @@enDesc:
      Whether a language matches to the language of this element or not.
      \
      {NOTE:: A language matches to the language of this element 
              if the language is a subclass of the element language.
      \
      }
    @@Param:
      @@Name: langURI
      @@Type: DIS|AnyURI
      @@enDesc:
        The language tag URI reference of the language to compare. 
    @@Param:
      @@Name: defaultLangURI
      @@Type: DIS|AnyURI
      @@enDesc:
        The language tag URI reference of the default language.
        It is considered as the element language if the element
        does not have the language information.
      @@nullCase:
        @@@enDesc: No default language.
    @@ForParam:
    @@ForpParam:
    @@Return:
      @@Type: DOMMain|boolean||ManakaiDOM|all
      @@enDesc:
        Whether the <P::langURI> matches to the language of this element. 
      @@PerlDef:
        if (defined $langURI) {
          __DEEP{
            my $ct = $self-><M::ManakaiDISElementDISDoc.languageURI>
                                  ($defaultLangURI, for_arg => $forArg,
                                   forp_arg => $forpArg);
            $ct = $defaultLangURI unless defined $ct;
            unless (defined $ct) {
              $r = false;
            } else {
              my $res = $self-><AG::DIS|ManakaiDISNode.ownerDISDocument>
                                 -><AG::DIS|ManakaiDISDocument.disDatabase>
                                 -><M::DIS|ManakaiDISDatabase.getResource> ($ct);
              $res-><AS::DIS|ManakaiDISResourceDefinition.isReferred> ($self);
              unless ($res-><M::ManakaiDISResourceDefinition
                                               .isSubsetOfURI> ($langURI)) {
                $r = false;
              } else {
                $r = true;
              }
            }
          }__;
        } else {
          $r = true;
        }

  @Method:
    @@Name: scriptMatch
    @@enDesc:
      Whether a script (writing system) matches to the script
      of this element or not.
      \
      {NOTE:: A script matches to the script of this element 
              if the script is a subclass of the element script.
      \
      }
    @@Param:
      @@Name: scriptURI
      @@Type: DIS|AnyURI
      @@enDesc:
        The script tag URI reference of the script to compare. 
    @@Param:
      @@Name: defaultScriptURI
      @@Type: DIS|AnyURI
      @@enDesc:
        The script tag URI reference of the default script.
        It is considered as the element script if the element
        does not have the script information.
      @@nullCase:
        @@@enDesc:
          No default script information.
    @@ForParam:
    @@ForpParam:
    @@Return:
      @@Type: DOMMain|boolean||ManakaiDOM|all
      @@enDesc:
        Whether the <P::scriptURI> matches to the script of this element.
      @@PerlDef:
        if (defined $scriptURI) {
          __DEEP{
            my $ct = $self-><M::ManakaiDISElementDISDoc.scriptURI>
                                  ($defaultScriptURI, for_arg => $forArg,
                                   forp_arg => $forpArg);
            $ct = $defaultScriptURI unless defined $ct;
            unless (defined $ct) {
              $r = false;
            } else {
              my $res = $self-><AG::DIS|ManakaiDISNode.ownerDISDocument>
                                 -><AG::DIS|ManakaiDISDocument.disDatabase>
                                 -><M::DIS|ManakaiDISDatabase.getResource> ($ct);
              $res-><AS::DIS|ManakaiDISResourceDefinition.isReferred> ($self);
              unless ($res-><M::ManakaiDISResourceDefinition
                                               .isSubsetOfURI> ($scriptURI)) {
                $r = false;
              } else {
                $r = true;
              }
            }
          }__;
        } else {
          $r = true;
        }

  @Method:
    @@Name: getDISDocTree
    @@PerlName: get_disdoc_tree
    @@enDesc:
      Returns a copy of XML tree representation of the <QUOTE::disdoc>
      content of this element.
    @@OwnerDocArg:
    @@Param:
      @@@Name: defaultMediaType
      @@@Type: DIS|AnyURI
      @@@enDesc:
        The default media type of the element.
      @@@nullCase:
        @@@@enDesc:
          The <QUOTE::disdoc> documentation language, i.e. <Q::lang:disdoc>,
          is the default of the default.
    @@Return:
      @@@Type: DocumentFragment
      @@@enDesc:
        A DOM tree generated from the content.
      @@@nullCase:
        @@@@enDesc:
          This element does not contain a documentation.
      @@@PerlDef:
        __DEEP{
          my $ctu = $self-><M::DIS:ManakaiDISElement.mediaTypeURI>
                                ($defaultMediaType, for_arg => $forArg,
                                 forp_arg => $forpArg);
          my $ct = $self-><AG::DIS|ManakaiDISNode.ownerDISDocument>
                                -><AG::DIS|ManakaiDISDocument.disDatabase>
                                -><M::DIS|ManakaiDISDatabase.getResource> ($ctu);
          if ($ct-><M::DIS:ManakaiDISResourceDefinition.isSubsetOfURI>
                                (<Q::lang:disdoc>)) {
            my $doc = $ownerDocumentArg-><M::Node.getFeature> (<Q::DIS|Doc>);
            $r = $doc-><M::ManakaiDOMDocumentDISDoc.parseDISDocText>
                         ($self-><M::SWCFGNode.value>,
                          node => $self,
                          language_uri => $self-><M::ManakaiDISElementDISDoc
                             .languageURI> (null, for_arg => $forArg,
                                            forp_arg => $forpArg),
                          script_uri => $self-><M::ManakaiDISElementDISDoc
                             .scriptURI> (null, for_arg => $forArg,
                                            forp_arg => $forpArg));
          } elsif ($ct-><M::DIS:ManakaiDISResourceDefinition.isSubsetOfURI>
                                (<Q::lang:disdocInline>)) {
            my $doc = $ownerDocumentArg-><M::Node.getFeature> (<Q::DIS|Doc>);
            $r = $doc-><M::ManakaiDOMDocumentDISDoc.parseDISDocInlineText>
                             ($self-><M::SWCFGNode.value>,
                          node => $self,
                          language_uri => $self-><M::ManakaiDISElementDISDoc
                             .languageURI> (null, for_arg => $forArg,
                                            forp_arg => $forpArg),
                          script_uri => $self-><M::ManakaiDISElementDISDoc
                             .scriptURI> (null, for_arg => $forArg,
                                            forp_arg => $forpArg));
          }
        }__;

  @Method:
    @@Name: documentationGroupId
    @@enDesc:
      An identifier that identifies a set of documentation
      elements such as of <Q::dis:Description>. 
      \
      {NOTE:: Documentation child elements of an element
              is considered as zero or more sets of 
              documentation element groups; each group
              has an identifier unique (only) in the scope
              of those groups (uniqueness among elements
              in another hierarchy is not guaranted). 
      \
      }
    @@Type: DIS|AnyURI
    @@ForParam:
    @@ForpParam:
    @@ImplNote:
      @@@lang:en
      @@@@:
        If a child element has a <Q::dd:id> attribute whose
        value is <DOM::true>,
        the identifier is composed from that value and
        the element type.  Otherwise, the identifier is
        its element type.
    @@Return:
      @@@enDesc:
        An opaque identifier value.
      @@@PerlDef:
        __DEEP{
          my $eturi = $self-><AG::swcfg21:SWCFGElement::swcfg21:ForLatest
                                  .expandedURI>;
          my $ddid = $self-><M::DIS|ManakaiDISElement.disGetAttribute>
                                  (<Q::dd:id>, for_arg => $forArg, 
                                   forp_arg => $forpArg);
          my $ddidv = $ddid ? $ddidv-><M::SWCFGNode.value> : 0;
          if ($ddidv) {
            for my $__uri ($ddidv, $eturi) {
              $__uri =~ s{([^0-9A-Za-z:;?=_.~/-])}{sprintf '%%%02X', ord $1}ge;
            }
            $r = qq<data:,200411tf#xmlns(t=data:,200411tf%23)>.
                                qq<t:id($eturi,$ddidv)>;      
          }
        }__;

  @ImplNote:
    @@lang:en
    @@@:
      <M::.lookupNamespaceURI> method is defined in 
      <Class::DIS:ManakaiDISElement>.

  @Attr:
    @@ForCheck: ManakaiDOM|ForClass
    @@Name: defaultDISDocNamespaceURI
    @@PerlName: default_disdoc_namespace_uri
    @@enDesc:
      The default namespace URI for <QUOTE::disdoc> contents.
      It is defined by the <Q::dis:Namespace> attribute
      of the <Q::dis:Module> top-level element.
    @@Type: DIS|AnyURI
    @@Get:
      @@@PerlDef:
          __DEEP{
            $r = ($self-><AG::DIS|ManakaiDISNode.ownerDISDocument> || $self)
                       -><AG::DIS|ManakaiDISDocument.moduleElement>
                       -><AG::DIS|ManakaiDISModuleElement.definingNamespaceURI>;
          }__;

  @Attr:
    @@ForCheck: ManakaiDOM|ForClass
    @@Name: defaultDISDocElementNamespaceURI
    @@PerlName: default_disdoc_element_namespace_uri
    @@enDesc:
      The default namespace URI for <QUOTE::disdoc> element types.
    @@Type: DIS|AnyURI
    @@Get:
      @@@enDesc:
        Always <URIQ::ddel:>.
      @@@Def:
        @@@@ContentType: lang|dis
        @@@@DISLang:value:
          @@@@@@: ddel|
          @@@@@ContentType: dis|TypeQName
##DISElementDISDoc

PropDef:
  @QName: dd|id
  @enDesc:
    Group identifier without element type information. 

ElementTypeBinding:
  @Name: ForParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:MethodParameter
    @@DISPerl:isNamedParameter:1
    @@Name: forArg
    @@Type: DIS|ForURI
    @@Description:
      @@@lang:en
      @@@@:
        The <QUOTE::for> URI reference. 
    @@ResourceDef:
      @@@rdf:type:
        ManakaiDOM:InCase
      @@@Value:
        @@@@is-null:1
      @@@Description:
        @@@@lang:en
        @@@@@:
          Equivalent to <Q::ManakaiDOM:all>, i.e. <QUOTE::for all>. 

ElementTypeBinding:
  @Name: ForpParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:MethodParameter
    @@DISPerl:isNamedParameter:1
    @@Name: forpArg
    @@Type: DIS|ForURIList
    @@Description:
      @@@lang:en
      @@@@:
        An array reference containing additional <QUOTE::for> 
        constraints (<QUOTE::For+> list).
    @@ResourceDef:
      @@@rdf:type:
        ManakaiDOM:InCase
      @@@Value:
        @@@@is-null:1
      @@@Description:
        @@@@lang:en
        @@@@@:
          Equivalent to the empty array reference. 

ResourceDef:
  @QName: Document
  @AliasFor: DOMCore|Document||ManakaiDOM|ManakaiDOMLatest

ElementTypeBinding:
  @Name: Attr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Attribute

ElementTypeBinding:
  @Name: Get
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|AttributeGet

ElementTypeBinding:
  @Name: Set
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|AttributeSet

ResourceDef:
  @QName: disdocBlocks
  @AliasFor: lang|disdoc||ManakaiDOM|all

ResourceDef:
  @QName: SWCFGNode
  @AliasFor: swcfg21|SWCFGNode||swcfg21|ForLatest

ResourceDef:
  @QName: disdocInline
  @AliasFor: lang|disdocInline||ManakaiDOM|all

## -- disdoc Extended Interfaces for DOM Objects

IFClassDef:
  @IFQName: DocumentDISDoc
  @ClsQName: ManakaiDOMDocumentDISDoc

  @DOMMetaImpl:provideFeature:
    @@@: DIS|Doc20
    @@DOMMetaImpl:providedThrough: DIS|ManakaiDISImplementation

  @enDesc:
    This interface provides a set of methods to parse <QUOTE::disdoc>
    formatted texts and creates DOM trees.
    \
    This interface must be implemented by objects which
    implement the <IF::DOMCore:Document> interface if 
    the DOM implementation supports the <Feature::DIS|Doc>. 
    This interface can be obtained from a <IF::DOMCore:Document>
    object via <M::DOMCore:Document.getFeature> method
    with the parameter of <Feature::DIS|Doc>.

  @Method:
    @@Name: parseDISDocText
    @@PerlName: parse_disdoc_text
    @@enDesc:
      Parses a <QUOTE::disdoc> formatted text in the block-level context.
    @@Param:
      @@@Name: namespaceContext
      @@@Type: DISDocNamespaceResolver
      @@@enDesc:
        A node or something used to resolve namespace prefix.
    @@Param:
      @@@Name: sourceText
      @@@Type: disdocBlocks
      @@@enDesc:
        A <QUOTE::disdoc> block-level fragment.
    @@NamedParam:
      @@@Name: node
      @@@Type: DIS|ManakaiDISElement
      @@@enDesc:
        A <QUOTE::dis> element in which the <P::sourceText>
        is contained.  This information is used to report errors
        and to get resources for languages and scripts.
      @@@nullCase:
        @@@@enDesc: No source node.
    @@NamedParam:
      @@@Name: languageURI
      @@@Type: DIS|AnyURI
      @@@enDesc:
        The language information of the context in which the <P::sourceText>
        is contained.
      @@@nullCase:
        @@@@enDesc: No language information.
    @@NamedParam:
      @@@Name: scriptURI
      @@@Type: DIS|AnyURI
      @@@enDesc:
        The script information of the context in which the <P::sourceText>
        is contained.
      @@@nullCase:
        @@@@enDesc: No script information.
    @@Return:
      @@@Type: DocumentFragment
      @@@enDesc:
        <QUOTE::disdoc> tree constructed from <P::sourceText>.
      @@@PrefixException:
      @@@RaiseException:
        @@@@@:DIS|NO_END_TAG_ERR
        @@@@enDesc:
          An end tag is not found where it is required.
      @@@RaiseException:
        @@@@@:DOMCore|DOMException.INVALID_CHARACTER_ERR
        @@@@enDesc:
          An illegular element type name is specified.
      @@@RaiseException:
        @@@@@:DOMCore|DOMException.NAMESPACE_ERR
        @@@@enDesc:
          An illegular element type name is specified.
      @@@PerlDef:
      __DEEP{
        $sourceText =~ s/\x0D\x0A/\x0A/g;
        $sourceText =~ tr/\x0D/\x0A/;
        my @s = split /\x0A[\x09\x20]*(?:(?:\x0A[\x09\x20]*)+|(?=[\{\}]))/x,
                      $sourceText;
        $r = $ownerDocumentArg-><M::Document.createDocumentFragment>;

        my $root = $r-><M::Node.appendChild>
                            ($ownerDocumentArg-><M::Document.createElementNS>
                                                     (<Q::xhtml1:>, 'div'));
        $root-><M::Element.setAttributeNS> (null, class => 'disdoc-blocks');
        if ($node) {
          my $db = $node-><AG::DIS|ManakaiDISNode.ownerDISDocument>
                        -><AG::DIS|ManakaiDISDocument.disDatabase>;
          if (defined $languageURI) {
            my $lang = $db-><M::DIS|ManakaiDISDatabase
                               .getResource> ($languageURI);
            my $tag = $lang-><M::DIS|ManakaiDISPropertyAccessor
                                .getPropertyText> (<Q::nl:ietfPreferredTag>) ||
                      $lang-><M::DIS|ManakaiDISPropertyAccessor
                                .getPropertyText> (<Q::nl:ietfTag>);
            if ($tag) {
              $root-><M::Element.setAttributeNS> (<Q::xml:>, 'xml:lang' => $tag);
            } else {
              $root-><M::Element.setAttributeNS> (<Q::script:>, 'script:lang'
                                                            => $languageURI);
            }
          }
          if (defined $scriptURI) {
            $root-><M::Element.setAttributeNS> (<Q::script:>, 'script:script'
                                                              => $scriptURI);
          }
        }
        $root-><M::Element.setAttributeNS>
                           (<Q::ddel:>, 'ddel:mmParsed' => true);

        my $current = $root;
        my @lextype = ('');
        for my $s (@s) {
          if ($s =~ s/^\{([0-9A-Za-z:|._\@^\s-]+)::\s*//x) { ## Start tag
            my ($type, $lang, $script) = split /\s*\@\s*/, $1, 3;
            my ($etype, $ltype) = split /\s*^^\s*/, $type, 2;
            my ($nsp, $ln, $ns) = split /\s*[:|]\s*/, $etype, 2;
            if (defined $ln) {
              $ns = $namespaceContext-><M::DISDocNamespaceContext
                                           .lookupNamespaceURI> ($nsp);
              unless (defined $ns) {
                __UNDEEP{__EXCEPTION{DIS:UNDECLARED_NS_PREFIX_ERR::
                  infoset:prefix => {$nsp},
                  DIS:sourceNode => {$node},
                }__}__;
              }
            } else {
              $ln = $nsp;
              $ns = $namespaceContext-><AG::DISDocNamespaceContext
                                           .defaultDISDocElementNamespaceURI>;
            }
            if (defined $ltype) {
              my ($lnsp, $lln, $lns) = split /\s*[:|]\s*/, $ltype, 2;
              if (defined $lln) {
                $lns = $namespaceContext-><M::DISDocNamespaceContext
                                             .lookupNamespaceURI> ($lnsp);
                unless (defined $lns) {
                  __UNDEEP{__EXCEPTION{DIS:UNDECLARED_NS_PREFIX_ERR::
                    infoset:prefix => {$lnsp},
                    DIS:sourceNode => {$node},
                  }__}__;
                }
              } else {
                $lln = $lnsp;
                $lns = $namespaceContext-><AG::DISDocNamespaceContext
                                             .defaultDISDocElementNamespaceURI>;
              }
              push @lextype, $lns.$lln;
              $current-><M::Element.setAttributeNS>
                             (<Q::ddel:>, 'ddel:lexType' => $lextype[-1]);
            } else { # No explicit lextype
              push @lextype, {
              }->{$ns.$ln} || '';
            }
            my $this;
            if ($ns eq <Q::ddel:> and ($ln eq 'LI' or $ln eq 'OLI')) {
              unless ($current-><AG::Node.namespaceURI> eq <Q::xhtml2:> and
                  {ul => true,
                   ol => true}->{$current-><AG::Node.localName>}) {
                $current = $current-><M::Node.appendChild>
                              ($ownerDocumentArg-><M::Document.createElementNS>
                                  (<Q::xhtml2:>, 
                                   {LI => 'ul',
                                    OLI => 'ol'}->{$ln} || 'ul'));
                $current-><M::Element.setAttributeNS>
                                  (<Q::ddel:>, 'ddel:tag' => 'implied');
              }
              $this = $current = $current-><M::Node.appendChild>
                  ($ownerDocumentArg-><M::Document.createElementNS>
                              (<Q::xhtml2:>, 'li'));
              $current-><M::Element.setAttributeNS>
                            (<Q::ddel:>, 'ddel:ordered' => true) if $ln eq 'OLI';
              $current-><M::Element.setAttributeNS>
                              (<Q::ddel:>, 'ddel:mmParsed' => true);
              $current-><M::Element.setAttributeNS>
                              (<Q::ddel:>, 'ddel:tag' => 'block');
              if ($s =~ s/^(.*)::://s) {
                my $m = $current-><M::Node.appendChild>
                     ($ownerDocumentArg-><M::Document.createElementNS>
                                  (<Q::ddel:>, 'ddel:listMarker'))
                $m-><M::Node.appendChild>
                         ($self-><M::DocumentDISDoc.parseDISDocInlineText>
                           ($ownerDocumentArg, $namespaceContext, $1,
                            node => $node, language_uri => null,
                            script_uri => null));
                $m-><M::Element.setAttributeNS>
                              (<Q::ddel:>, 'ddel:tag' => 'implied');
              }
              $current = $current-><M::Node.appendChild>
                     ($ownerDocumentArg-><M::Document.createElementNS>
                                  (<Q::ddel:>, 'ddel:listContent'))
                      -><M::Node.appendChild>
                       ($self-><M::DocumentDISDoc.parseDISDocInlineText>
                         ($ownerDocumentArg, $namespaceContext, $s,
                          node => $node, language_uri => null,
                          script_uri => null));
              $current-><M::Element.setAttributeNS>
                              (<Q::ddel:>, 'ddel:tag' => 'implied');
            } else {
              if ($current-><AG::Node.namespaceURI> eq <Q::xhtml2:> and
                  ($current-><AG::Node.localName> eq 'ul' or
                   $current-><AG::Node.localName> eq 'li') and
                  $current-><M::Node.getAttributeNS>
                                          (<Q::ddel:>, 'tag') eq 'implied') {
                $current = $current-><AG::Node.parentNode>;
              }
              $this = $current = $current-><M::Node.appendChild>
                  ($ownerDocumentArg-><M::Document.createElementNS>
                              ({
                                 <Q::ddel:NOTE> => <Q::html3:>,
                                 <Q::ddel:P> => <Q::xhtml2:>,
                               }->{$ns.$ln} || $ns,
                               {
                                 <Q::ddel:NOTE> => 'note',
                                 <Q::ddel:P> => 'p',
                               }->{$ln.$ln} || $ln));
              $current-><M::Element.setAttributeNS>
                              (<Q::ddel:>, 'ddel:tag' => 'block');
              $current-><M::Node.appendChild>
                     ($self-><M::DocumentDISDoc.parseDISDocInlineText>
                       ($ownerDocumentArg, $namespaceContext, $s,
                        node => $node, language_uri => null,
                        script_uri => null));
            }
            if ($lang) {
              my ($nsp, $ln, $ns) = split /\s*[:|]\s*/, $lang, 2;
              if (defined $ln) {
                $ns = $namespaceContext-><M::DISDocNamespaceContext
                                           .lookupNamespaceURI> ($nsp);
                unless (defined $ns) {
                  __UNDEEP{__EXCEPTION{DIS:UNDECLARED_NS_PREFIX_ERR::
                    infoset:prefix => {$nsp},
                    DIS:sourceNode => {$node},
                  }__}__;
                }
              } else {
                $ln = $nsp;
                $ns = <Q::ilang:>;
              }
              if ($ns eq <Q::ilang:>) {
                $this-><M::Element.setAttributeNS>
                                 (<Q::xml:>, 'xml:lang' => $ln);
              } else {
                $this-><M::Element.setAttributeNS>
                                 (<Q::script:>, 'script:lang' => $ln);
              }
            }
            if ($script) {
              my ($nsp, $ln, $ns) = split /\s*[:|]\s*/, $script, 2;
              if (defined $ln) {
                $ns = $namespaceContext-><M::DISDocNamespaceContext
                                           .lookupNamespaceURI> ($nsp);
                unless (defined $ns) {
                  __UNDEEP{__EXCEPTION{DIS:UNDECLARED_NS_PREFIX_ERR::
                    infoset:prefix => {$nsp},
                    DIS:sourceNode => {$node},
                  }__}__;
                }
              } else {
                $ln = $nsp;
                $ns = <Q::script:>;
              }
              $this-><M::Element.setAttributeNS>
                                 (<Q::script:>, 'script:script' => $ln);
            }
          } elsif ($s =~ /^\s*\}\s*$/) { ## End tag
            while ($current-><M::Element.getAttributeNS>
                                      (<Q::ddel:>, 'tag') eq 'implied') {
              $current = $current-><AG::Node.parentNode>;
            }
            $current = $current-><AG::Node.parentNode>;
          } elsif ($s =~ s/^\s*([-=])\s*//) { ## List
            my $marker = $1;
            unless ($current-><AG::Node.namespaceURI> eq <Q::xhtml2:> and
                    {ul => true,
                     ol => true}->{$current-><AG::Node.localName>}) {
              $current = $current-><M::Node.appendChild>
                              ($ownerDocumentArg-><M::Document.createElementNS>
                                  (<Q::xhtml2:>, 
                                   {'-' => 'ul',
                                    '=' => 'ol'}->{$marker} || 'ul'));
              $current-><M::Element.setAttributeNS>
                                  (<Q::ddel:>, 'ddel:tag' => 'implied');
            }
            my $li = $current-><M::Node.appendChild>
                          ($ownerDocumentArg-><M::Document.createElementNS>
                             (<Q::xhtml2:>, 'li'));
            $li-><M::Element.setAttributeNS>
                          (<Q::ddel:>, 'ddel:ordered' => true) if $marker eq '=';
            $li-><M::Node.setAttributeNS>
                                (<Q::ddel:>, 'ddel:tag' => 'implied');
            $li-><M::Node.setAttributeNS>
                                (<Q::ddel:>, 'ddel:mmParsed' => true);
            if ($s =~ s/^(.*)::://s) {
              my $m = $li-><M::Node.appendChild>
                     ($ownerDocumentArg-><M::Document.createElementNS>
                                  (<Q::ddel:>, 'ddel:listMarker'))
              $m-><M::Node.appendChild>
                         ($self-><M::DocumentDISDoc.parseDISDocInlineText>
                           ($ownerDocumentArg, $namespaceContext, $1,
                            node => $node, language_uri => null,
                            script_uri => null));
              $m-><M::Element.setAttributeNS>
                              (<Q::ddel:>, 'ddel:tag' => 'implied');
            }
            $li = $li-><M::Node.appendChild>
                     ($ownerDocumentArg-><M::Document.createElementNS>
                                  (<Q::ddel:>, 'ddel:listContent'))
                   -><M::Node.appendChild>
                       ($self-><M::DocumentDISDoc.parseDISDocInlineText>
                         ($ownerDocumentArg, $namespaceContext, $s,
                          node => $node, language_uri => null,
                          script_uri => null));
            $li-><M::Element.setAttributeNS>
                              (<Q::ddel:>, 'ddel:tag' => 'implied');
          } else {
            ## /^\s*[^\w\s<]/ is reserved for future extensions
            if ($current-><AG::Node.namespaceURI> eq <Q::xhtml2:> and
                ($current-><AG::Node.localName> eq 'ul' or
                 $current-><AG::Node.localName> eq 'li') and
                $current-><M::Node.getAttributeNS>
                                          (<Q::ddel:>, 'tag') eq 'implied') {
              $current = $current-><AG::Node.parentNode>;
            }
            my $p = $current-><M::Node.appendChild>
                          ($ownerDocumentArg-><M::Document.createElementNS>
                             (<Q::xhtml2:>, 'p'));
            $p-><M::Node.setAttributeNS>
                                (<Q::ddel:>, 'ddel:tag' => 'implied');
            $o-><M::Node.appendChild>
                       ($self-><M::DocumentDISDoc.parseDISDocInlineText>
                         ($ownerDocumentArg, $namespaceContext, $s,
                          node => $node, language_uri => null,
                          script_uri => null));
          }
        } # for

        while ($current-><M::Node.getAttributeNS>
                                          (<Q::ddel:>, 'tag') eq 'implied') {
          $current = $current-><AG::Node.parentNode>;
        }
      }__;

      unless ($current eq $root) {
        __EXCEPTION{DIS|NO_END_TAG_ERR::
          DIS:elementType => {$current-><AG::Element.namespaceURI> .
                              $current-><AG::Element.localName>},
          DIS:sourceNode => {$node},
          DIS:sourceCode => {$sourceText},
        }__;
      }

  @Method:
    @@Name: parseDISDocInlineText
    @@PerlName: parse_disdoc_inline_text
    @@enDesc:
      Parses a <QUOTE::disdoc> formatted text in the inline-level context.
    @@OwnerDocArg:
    @@Param:
      @@@Name: namespaceContext
      @@@Type: DISDocNamespaceResolver
      @@@enDesc:
        A node or something used to resolve namespace prefix.
    @@Param:
      @@@Name: sourceText
      @@@Type: lang|disdocInline||ManakaiDOM|all
      @@@enDesc:
        A <QUOTE::disdoc> inline-level fragment.
    @@NamedParam:
      @@@Name: node
      @@@Type: DIS|ManakaiDISElement
      @@@enDesc:
        A <QUOTE::dis> element in which the <P::sourceText>
        is contained.  This information is used to report errors.
      @@@nullCase:
        @@@@enDesc: No source node.
    @@NamedParam:
      @@@Name: languageURI
      @@@Type: DIS|AnyURI
      @@@enDesc:
        The language information of the context in which the <P::sourceText>
        is contained.
      @@@nullCase:
        @@@@enDesc: No language information.
    @@NamedParam:
      @@@Name: scriptURI
      @@@Type: DIS|AnyURI
      @@@enDesc:
        The script information of the context in which the <P::sourceText>
        is contained.
      @@@nullCase:
        @@@@enDesc: No script information.
    @@Return:
      @@@Type: DocumentFragment
      @@@enDesc:
        <QUOTE::disdoc> tree constructed from <P::sourceText>.
      @@@RaiseException:
        @@@@@:DIS|NO_END_TAG_ERR
        @@@@enDesc:
          An end tag is not found where it is required.
      @@@RaiseException:
        @@@@@:DOMCore|DOMException.INVALID_CHARACTER_ERR
        @@@@enDesc:
          An illegular element type name is specified.
      @@@RaiseException:
        @@@@@:DOMCore|DOMException.NAMESPACE_ERR
        @@@@enDesc:
          An illegular element type name is specified.
      @@@PrefixException:
      @@@PerlDef:
        $sourceText =~ s/^\s+//;
        $sourceText =~ s/\s+$//;

        ## Container
        $r = $ownerDocumentArg-><M::Document.createDocumentFragment>;
        my $current = $r;

        ## Language
        if ($node) {
          my $db = $node-><AG::DIS|ManakaiDISNode.ownerDISDocument>
                        -><AG::DIS|ManakaiDISDocument.disDatabase>;
          if (defined $languageURI or defined $scriptURI) {
            $current = $r-><M::Node.appendChild>
                             ($ownerDocumentArg-><M::Document.createElementNS>
                                 (<Q::xhtml2:>, 'div'));
            $current-><M::Element.setAttributeNS>
                             (null, class => 'disdoc-inline');
          }
          if (defined $languageURI) {
            my $lang = $db-><M::DIS|ManakaiDISDatabase
                               .getResource> ($languageURI);
            my $tag = $lang-><M::DIS|ManakaiDISPropertyAccessor
                                .getPropertyText> (<Q::nl:ietfPreferredTag>) ||
                      $lang-><M::DIS|ManakaiDISPropertyAccessor
                                .getPropertyText> (<Q::nl:ietfTag>);
            if ($tag) {
              $current-><M::Element.setAttributeNS>
                             (<Q::xml:>, 'xml:lang' => $tag);
            } else {
              $current-><M::Element.setAttributeNS> (<Q::script:>, 'script:lang'
                                                            => $languageURI);
            }
          }
          if (defined $scriptURI) {
            $current-><M::Element.setAttributeNS> (<Q::script:>, 'script:script'
                                                              => $scriptURI);
          }
        }
        
        __DEEP{
          while (CORE::length $sourceText) {
            if ($sourceText =~ s/^([^<>]+)//) {
              $current-><M::Node.appendChild>
                          ($ownerDocumentArg-><M::Document.createTextNode> ($1));
            } elsif ($sourceText =~ s/^<\s*(lt|gt|[{}:=-]|SP)\s*>//) {
              $current-><M::Node.appendChild>
                          ($ownerDocumentArg-><M::Document.createTextNode>
                             ({
                                lt => '<', gt => '>', 'SP' => ' ',
                                '{' => '{', '}' => '}', ':' => ':',
                                '=' => '=', '-' => '-',
                              }->{$1}));
            } elsif ($sourceText =~ s/^<([0-9A-Za-z_.:|\@\s-]+):://) {
              my ($type, $lang, $script) = split /\s*\@\s*/, $1, 3;
              my ($etype, $ltype) = split /\s*^^\s*/, $type, 2;

              my ($nsp, $ln, $ns) = split /\s*[:|]\s*/, $etype, 2;
              if (defined $ns) {
                $ns = $namespaceContext-><M::DISDocNamespaceContext
                                           .lookupNamespaceURI> ($nsp);
                unless (defined $ns) {
                  __UNDEEP{__EXCEPTION{DIS:UNDECLARED_NS_PREFIX_ERR::
                    infoset:prefix => {$nsp},
                    DIS:sourceNode => {$node},
                  }__}__;
                }
              } else {
                $ln = $nsp;
                $ns = $namespaceContext-><AG::DISDocNamespaceContext
                                           .defaultDISDocElementNamespaceURI>;
              }

              $current = $current-><M::Node.appendChild>
                            ($ownerDocumentArg-><M::Document.createElementNS>
                                ({
                                   <Q::ddel:CITE> => <Q::html5:>,
                                   <Q::ddel:CODE> => <Q::html5:>,
                                   <Q::ddel:DFN> => <Q::html5:>,
                                   <Q::ddel:EM> => <Q::html5:>,
                                   <Q::ddel:KEY> => <Q::sw010:>,
                                   <Q::ddel:QUOTE> => <Q::html5:>,
                                   <Q::ddel:SRC> => <Q::sw010:>,
                                 }->{$ns.$ln} || $ns,
                                 {
                                   <Q::ddel:CITE> => 'cite',
                                   <Q::ddel:CODE> => 'code',
                                   <Q::ddel:DFN> => 'dfn',
                                   <Q::ddel:EM> => 'em',
                                   <Q::ddel:KEY> => 'key',
                                   <Q::ddel:QUOTE> => 'q',
                                   <Q::ddel:SRC> => 'src',
                                 }->{$ns.$ln} || $ln));
              
              if (defined $ltype) {
                my ($lnsp, $lln, $lns) = split /\s*[:|]\s*/, $ltype, 2;
                if (defined $lln) {
                  $lns = $namespaceContext-><M::DISDocNamespaceContext
                                               .lookupNamespaceURI> ($lnsp);
                  unless (defined $lns) {
                    __UNDEEP{__EXCEPTION{DIS:UNDECLARED_NS_PREFIX_ERR::
                      infoset:prefix => {$lnsp},
                      DIS:sourceNode => {$node},
                    }__}__;
                  }
                } else {
                  $lln = $lnsp;
                  $lns = $namespaceContext-><AG::DISDocNamespaceContext
                                             .defaultDISDocElementNamespaceURI>;
                }
                push @lextype, $lns.$lln;
                $current-><M::Element.setAttributeNS>
                               (<Q::ddel:>, 'ddel:lexType' => $lextype[-1]);
              } else { # No explicit lextype
                push @lextype, {
                  <Q::ddel:A> => <Q::DISPerl:MemRef>,
                  <Q::ddel:CP> => <Q::DISCore:NCNameOrQName>,
                  <Q::ddel:ERR> => <Q::DISCore:NCNameOrQName>,
                  <Q::ddel:EV> => <Q::DISCore:NCNameOrQName>,
                  <Q::ddel:IF> => <Q::dis:TFQNames>,
                  <Q::ddel:Feature> => <Q::DISCore:NCNameOrQName>,
                  <Q::ddel:M> => <Q::DISPerl:MemRef>,
                  <Q::ddel:Q> => <Q::dis:TypeQName>,
                  <Q::ddel:TYPE> => <Q::dis:TFQNames>,
                  <Q::ddel:WARN> => <Q::DOMMain:XCodeRef>,
                  <Q::ddel:X> => <Q::DOMMain:XCodeRef>,
                  <Q::ddel:XA> => <Q::DISCore:NCNameOrQName>,
                  <Q::ddel:XE> => <Q::DISCore:NCNameOrQName>,
                }->{$ns.$ln} || '';
              }

              if ($lang) {
                my ($nsp, $ln, $ns) = split /\s*[:|]\s*/, $lang, 2;
                if (defined $ln) {
                  $ns = $namespaceContext-><M::DISDocNamespaceContext
                                             .lookupNamespaceURI> ($nsp);
                  unless (defined $ns) {
                    __UNDEEP{__EXCEPTION{DIS:UNDECLARED_NS_PREFIX_ERR::
                      infoset:prefix => {$nsp},
                      DIS:sourceNode => {$node},
                    }__}__;
                  }
                } else {
                  $ln = $nsp;
                  $ns = <Q::ilang:>;
                }
                if ($ns eq <Q::ilang:>) {
                  $this-><M::Element.setAttributeNS>
                                   (<Q::xml:>, 'xml:lang' => $ln);
                } else {
                  $this-><M::Element.setAttributeNS>
                                   (<Q::script:>, 'script:lang' => $ln);
                }
              }
              if ($script) {
                my ($nsp, $ln, $ns) = split /\s*[:|]\s*/, $script, 2;
                if (defined $ln) {
                  $ns = $namespaceContext-><M::DISDocNamespaceContext
                                             .lookupNamespaceURI> ($nsp);
                  unless (defined $ns) {
                    __UNDEEP{__EXCEPTION{DIS:UNDECLARED_NS_PREFIX_ERR::
                      infoset:prefix => {$nsp},
                      DIS:sourceNode => {$node},
                    }__}__;
                  }
                } else {
                  $ln = $nsp;
                  $ns = <Q::script:>;
                }
                $this-><M::Element.setAttributeNS>
                                   (<Q::script:>, 'script:script' => $ln);
              }
            } elsif ($sourceText =~ s/^>//) { ## End tag
              unless ($current eq $r) {
                $current = $current-><AG::Node.parentNode>;
              } else {  ## Illegular
                $current-><M::Node.appendChild>
                        ($ownerDocumentArg-><M::Document.createTextNode> ('>'));
              }
            ## TODO: lextype parsing
            } elsif ($sourceText =~ s/^(.)//s) { ## Illegular "<" and ">"
              $current-><M::Node.appendChild>
                          ($ownerDocumentArg-><M::Document.createTextNode>
                              ($1));
            }
          } # while
        }__;

      unless ($current eq $root) {
        __EXCEPTION{DIS|NO_END_TAG_ERR::
          DIS:elementType => {$current-><AG::Element.namespaceURI> .
                              $current-><AG::Element.localName>},
          DIS:sourceNode => {$node},
        }__;
      }
##DocumentDISDoc

ElementTypeBinding:
  @Name: PerlName
  @ElementType:
    dis:AppName
  @ShadowContent:
    @@ContentType: lang|Perl

ElementTypeBinding:
  @Name: PrefixException
  @ElementType:
    ManakaiDOM:raises
  @ShadowContent:
    @@@: UNDECLARED_NS_PREFIX_ERR
    @@Description:
      @@@lang:en
      @@@@:
        A namespace prefix is not declared.

ElementTypeBinding:
  @Name: RaiseException
  @ElementType:
    ManakaiDOM:raises

ResourceDef:
  @QName: Element
  @AliasFor: DOMCore|Element||ManakaiDOM|ManakaiDOMLatest

ResourceDef:
  @QName: DocumentFragment
  @AliasFor: DOMCore|DocumentFragment||ManakaiDOM|ManakaiDOMLatest

ResourceDef:
  @QName: UNDECLARED_NS_PREFIX_ERR
  @AliasFor:
    DIS:UNDECLARED_NS_PREFIX_ERR::swcfg21:ForLatest

## -- disdoc Utility Interfaces

IFClassDef:
  @IFQName: DISDocNegotiationCondition
  @ClsQName: ManakaiDISDocNegotiationCondition

  @Method:
    @@Name: selectDISElement
    @@enDesc:
      Selects a <QUOTE::dis> element by this condition.
    @@Param:
      @@@Name: elements
      @@@Type: Perl|ARRAY||ManakaiDOM|all
      @@@enDesc:
        A reference to array whose items are <QUOTE::dis> elements.
    @@Return:
      @@@Type: DIS|ManakaiDISElement
      @@@enDesc:
        A <QUOTE::dis> element choosen from <P::element>.
      @@@nullCase:
        @@@@enDesc:
          No appropaiate element.
      @@@PerlDef:
        $r = $elements->[0];
      @@@ImplNote:
        @@@@lang:en
        @@@@@:
          {TODO:: Implementation required.
          \
          }

  @ImplNote:
    @@lang:en
    @@@:
      Attributes and/or methods such as Accept-Language is required.
##DISDocNegotiationCondition

IFDef:
  @IFQName: DISDocNamespaceResolver

  @enDesc:
    A namespace resolver interface for <QUOTE::disdoc>. 
    Objects implementing this interface must provide
    lookup functions from namespace prefix or default namespace
    to corresponding namespace URI reference.

  @Attr:
    @@Name: defaultDISDocNamespaceURI
    @@PerlName: default_disdoc_namespace_uri
    @@enDesc:
      The default namespace URI for <QUOTE::disdoc> contents.
    @@Type: DIS|AnyURI
    @@Get: 

  @Attr:
    @@Name: defaultDISDocElementNamespaceURI
    @@PerlName: default_disdoc_element_namespace_uri
    @@enDesc:
      The default namespace URI for <QUOTE::disdoc> element types.
    @@Type: DIS|AnyURI
    @@Get:
 
  @Method:
    @@Name: lookupNamespaceURI
    @@enDesc:
      Looks up the namespace URI associated to the given prefix.
    @@Param:
      @@@Name:prefix
      @@@Type:
        DISCore:NamespacePrefix::ManakaiDOM:all
      @@@Description:
        @@@@lang:en
        @@@@@:
          The namespace URI to look for.
    @@Return:
      @@@Type: DIS|AnyURI
      @@@Description:
        @@@@lang:en
        @@@@@:The associated namespace URI.
      @@@nullCase:
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            No namespace URI is associated to the prefix or
            the <DOM::null> namespace is associated.
      @@@PrefixException:
##DISDocNamespaceResolver


ElementTypeBinding:
  @Name: NamedParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:MethodParameter
    @@DISPerl:isNamedParameter:1

ResourceDef:
  @QName: Node
  @AliasFor: DOMCore|Node||ManakaiDOM|ManakaiDOMLatest
