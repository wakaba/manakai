#!/usr/bin/perl 
## This file is automatically generated
## 	at 2005-12-20T11:57:31+00:00,
## 	from file "lib/Message/Util/DIS/DPG.dis",
## 	module <http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS#DPG>,
## 	for <http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#ManakaiDOMLatest>.
## Don't edit by hand!
use strict;
require Message::DOM::Tree;
package Message::Util::DIS::DPG;
our $VERSION = 20051220.1157;
package Message::Util::IF::DPGDocument;
our $VERSION = 20051220.1157;
package Message::Util::DIS::DPG::ManakaiDPGDocument;
our $VERSION = 20051220.1157;
push our @ISA, 'Message::DOM::Tree::ManakaiDOMDocument', 'Message::DOM::IFLatest::Document', 'Message::DOM::IFLatest::Node', 'Message::Util::IF::DPGDocument';
$Message::DOM::ImplFeature{q<Message::DOM::DOMCore::ManakaiDOMImplementation>}->{q<http://suika.fam.cx/~wakaba/archive/2005/manakai/util/dis#dpg>}->{q<1.0>} ||= 1;
$Message::DOM::ImplFeature{q<Message::DOM::DOMCore::ManakaiDOMImplementation>}->{q<http://suika.fam.cx/~wakaba/archive/2005/manakai/util/dis#dpg>}->{q<>} = 1;
$Message::DOM::ImplFeature{q<Message::Util::DIS::DPG::ManakaiDPGDocument>}->{q<http://suika.fam.cx/~wakaba/archive/2005/manakai/util/dis#dpg>}->{q<1.0>} ||= 1;
$Message::DOM::ImplFeature{q<Message::Util::DIS::DPG::ManakaiDPGDocument>}->{q<http://suika.fam.cx/~wakaba/archive/2005/manakai/util/dis#dpg>}->{q<>} = 1;
$Message::DOM::ClassFeature{q<Message::Util::DIS::DPG::ManakaiDPGDocument>} = {'', {'', '1'}, 'core', {'', '1', '1.0', '1', '2.0', '1', '3.0', '1'}, 'http://suika.fam.cx/~wakaba/archive/2005/manakai/util/dis#dpg', {'', '1', '1.0', '1'}, 'xml', {'', '1', '1.0', '1', '2.0', '1', '3.0', '1'}, 'xmlversion', {'', '1', '1.0', '1', '1.1', '1'}};
$Message::DOM::ClassPoint{q<Message::Util::DIS::DPG::ManakaiDPGDocument>} = 23.2;
$Message::DOM::ManakaiDOMDocument::CompatClassET{q<http://suika.fam.cx/~wakaba/archive/2005/11/pg/>}->{q<rules>}->{q<Message::Util::DIS::DPG::ManakaiDPGDocument>} = 1;
$Message::Util::ManakaiNode::ManakaiNodeRef::Prop{q<Message::Util::DIS::DPG::ManakaiDPGDocument>} = {'o', ['parent'], 's', ['http://suika.fam.cx/~wakaba/archive/2004/dom/views#view', 'child'], 'x', ['od']};
package Message::Util::IF::DPGElement;
our $VERSION = 20051220.1157;
package Message::Util::DIS::DPG::ManakaiDPGElement;
our $VERSION = 20051220.1157;
push our @ISA, 'Message::DOM::Tree::ManakaiDOMElement', 'Message::DOM::IFLatest::Element', 'Message::DOM::IFLatest::Node', 'Message::Util::IF::DPGElement';
$Message::DOM::ClassFeature{q<Message::Util::DIS::DPG::ManakaiDPGElement>} = {'', {'', '1'}, 'core', {'', '1', '1.0', '1', '2.0', '1', '3.0', '1'}, 'http://suika.fam.cx/~wakaba/archive/2005/manakai/util/dis#dpg', {'', '1', '1.0', '1'}, 'xml', {'', '1', '1.0', '1', '2.0', '1', '3.0', '1'}, 'xmlversion', {'', '1', '1.0', '1', '1.1', '1'}};
$Message::DOM::ClassPoint{q<Message::Util::DIS::DPG::ManakaiDPGElement>} = 23.2;
$Message::DOM::ManakaiDOMElement::CompatClass{q<Message::Util::DIS::DPG::ManakaiDPGElement>} = 1;
$Message::Util::ManakaiNode::ManakaiNodeRef::Prop{q<Message::Util::DIS::DPG::ManakaiDPGElement>} = {'o', ['parent'], 's', ['child'], 's2', ['attr'], 'x', ['od']};
package Message::Util::IF::DPGElementAttribute;
our $VERSION = 20051220.1157;
package Message::Util::DIS::DPG::ManakaiDPGElementAttribute;
our $VERSION = 20051220.1157;
push our @ISA, 'Message::Util::IF::DPGElementAttribute';
sub dpg_get_attribute ($$) {
my ($self, $attrName) = @_;
my $r = '';

{


{

local $Error::Depth = $Error::Depth + 1;

{



  $r = 
undef
;
  no warnings "uninitialized";
  C: for my $child (@{$self->
child_nodes
}) {
    if ($child->
namespace_uri
.$child->
local_name eq
        

'http://suika.fam.cx/~wakaba/archive/2005/11/pg/attributeSpecification'
) {
      if ($child->
get_attribute_ns
 (
undef
, 'name') eq
          $attrName) {
        $r = $child->
get_attribute_ns
 (
undef
, 'value');
        last C;
      }
    }
  }



;}


;}

;


;}
$r}
$Message::DOM::ClassFeature{q<Message::Util::DIS::DPG::ManakaiDPGElementAttribute>} = {'http://suika.fam.cx/~wakaba/archive/2005/manakai/util/dis#dpg', {'', '1', '1.0', '1'}};
$Message::DOM::ClassPoint{q<Message::Util::DIS::DPG::ManakaiDPGElementAttribute>} = 1;
package Message::Util::IF::DPGRulesElement;
our $VERSION = 20051220.1157;
package Message::Util::DIS::DPG::ManakaiDPGRulesElement;
our $VERSION = 20051220.1157;
push our @ISA, 'Message::Util::DIS::DPG::ManakaiDPGElement', 'Message::DOM::IFLatest::Element', 'Message::DOM::IFLatest::Node', 'Message::Util::IF::DPGElement', 'Message::Util::IF::DPGRulesElement';
sub pl_code_fragment ($$;%) {
my ($self, $codeDocument, %opt) = @_;
my $r;

{


{

local $Error::Depth = $Error::Depth + 1;

{


  no 
warnings 'uninitialized';

  $r = $codeDocument->
create_document_fragment
;

  ## --- Range operations
  
    my $or_range = sub ($$) {
my ($r1, $r2) = @_;
my @r1 = @$r1;
my @r2 = @$r2;
my ($c1, $c2);
my $r = [];
while (@r1 or @r2 or $c1 or $c2) {
$c1 ||= shift @r1;
$c2 ||= shift @r2;
if (not $c1) {
push @$r, $c2, @r2;
undef $c2;
      @r2 = ();
} elsif (not $c2) {
push @$r, $c1, @r1;
undef $c1;
      @r1 = ();
} else {
($c1, $c2) = ($c2, $c1) if $c1->[0] > $c2->[0];
if ($c1->[1] <= $c2->[0]) {
  push @$r, $c1;
  undef $c1;
} else {
  $c2 = [$c1->[0], $c2->[1]];
  undef $c1;
}
}
}
return $r;
};

my $add_range = sub ($$;$) {
my ($range, $s, $e) = @_;
return $or_range->($range, [[$s, defined $e ? $e : $s]]);
};

my $negate_range = sub ($) {
my $range = shift;
my $r = [];
push @$r, [0, $range->[0]->[0] - 1] if $range->[0]->[0] > 0;
for my $i (1..$#$range) {
push @$r, [$range->[$i - 1]->[1] + 1, $range->[$i]->[0] - 1];
}
push @$r, [$range->[$#$range]->[1] + 1, "Inf"] unless $range->[$#$range]->[1] eq "Inf";
return $r;
};

my $and_minus_ranges = sub ($$) {
my (@ra, @rab, @rb);
my @rangea = @{$_[0]};
my @rangeb = @{$_[1]};
my $rangea;
my $rangeb;
while (@rangea or @rangeb or $rangea or $rangeb) {
$rangea ||= shift @rangea;
$rangeb ||= shift @rangeb;
if (not $rangea) {
push @rb, $rangeb, @rangeb;
last;
} elsif (not $rangeb) {
push @ra, $rangea, @rangea;
last;
} else {
if ($rangea->[0] < $rangeb->[0]) {
  if ($rangea->[1] ne 'Inf' and
      $rangea->[1] < $rangeb->[0]) { ## [a .. a] .. [b ..
    push @ra, $rangea;
    $rangea = undef;
  } elsif ($rangea->[1] eq 'Inf') {
    if ($rangeb->[1] eq 'Inf') {  ## [a .. [b ..
      push @ra, [$rangea->[0], $rangeb->[0] - 1];
      push @rab, $rangeb;
      last;
    } else {                      ## [a .. [b .. b] ..
      push @ra, [$rangea->[0], $rangeb->[0] - 1];
      push @rab, $rangeb;
      $rangea = [$rangeb->[1] + 1, 'Inf'];
      $rangeb = undef;
    }
  } else {                      
    if ($rangeb->[1] eq 'Inf') {  ## [a .. [b .. a] ..
      push @ra, [$rangea->[0], $rangeb->[0] - 1];
      push @rab, [$rangeb->[0], $rangea->[1]];
      $rangeb = [$rangea->[1] + 1, 'Inf'];
      $rangea = undef;
    } else {
      if ($rangea->[1] < $rangeb->[1]) { ## [a .. [b .. a] .. b]
        push @ra, [$rangea->[0], $rangeb->[0] - 1];
        push @rab, [$rangeb->[0], $rangea->[1]];
        $rangeb = [$rangea->[1] + 1, $rangeb->[1]];
        $rangea = undef;
      } elsif ($rangea->[1] > $rangeb->[1]) { ## [a .. [b .. b] .. a]
        push @ra, [$rangea->[0], $rangeb->[0] - 1];
        push @rab, $rangeb;
        $rangea = [$rangeb->[1] + 1, $rangea->[1]];
        $rangeb = undef;
      } else {                            ## [a .. [b .. ab]]
        push @ra, [$rangea->[0], $rangeb->[0] - 1];
        push @rab, $rangeb;
        $rangea = $rangeb = undef;
      }
    }
  }
} elsif ($rangea->[0] > $rangeb->[0]) {
  if ($rangeb->[1] ne 'Inf' and
      $rangeb->[1] < $rangea->[0]) { ## [b .. b] .. [a ..
    push @rb, $rangeb;
    $rangeb = undef;
  } elsif ($rangea->[1] eq 'Inf') {
    if ($rangeb->[1] eq 'Inf') {  ## [b .. [a ..
      push @rb, [$rangeb->[0], $rangea->[0] - 1];
      push @rab, $rangea;
      last;
    } else {                      ## [b .. [a .. b] ..
      push @rb, [$rangeb->[0], $rangea->[0] - 1];
      push @rab, [$rangea->[0], $rangeb->[1]];
      $rangea = [$rangeb->[1] + 1, 'Inf'];
      $rangeb = undef;
    }
  } else {                      
    if ($rangeb->[1] eq 'Inf') {  ## [b .. [a .. a] ..
      push @rb, [$rangeb->[0], $rangea->[0] - 1, -7];
      push @rab, $rangea;
      $rangeb = [$rangea->[1] + 1, 'Inf'];
      $rangea = undef;
    } else {
      if ($rangea->[1] < $rangeb->[1]) { ## [b .. [a .. a] .. b]
        push @rb, [$rangeb->[0], $rangea->[0] - 1,-3];
        push @rab, $rangea;
        $rangeb = [$rangea->[1] + 1, $rangeb->[1]];
        $rangea = undef;
      } elsif ($rangea->[1] > $rangeb->[1]) { ## [b .. [a .. b] .. a]
        push @rb, [$rangeb->[0], $rangea->[0] - 1,-4];
        push @rab, [$rangea->[0], $rangeb->[1],-5];
        $rangea = [$rangeb->[1] + 1, $rangea->[1]];
        $rangeb = undef;
      } else {                            ## [b .. [a .. ab]]
        push @rb, [$rangeb->[0], $rangea->[0] - 1,-6];
        push @rab, $rangea;
        $rangea = $rangeb = undef;
      }
    }
  }
} else {
  if ($rangea->[1] eq 'Inf') {  
    if ($rangeb->[1] eq 'Inf') {          ## [[ab ..
      push @rab, $rangea;
      last;
    } else {                              ## [[ab .. b] ..
      push @rab, $rangeb;
      $rangea = [$rangeb->[1] + 1, 'Inf'];
      $rangeb = undef;
    }
  } else {
    if ($rangeb->[1] eq 'Inf') {          ## [[ab .. a] ..
      push @rab, $rangea;
      $rangeb = [$rangea->[1] + 1, 'Inf'];
      $rangea = undef;
    } else {
      if ($rangea->[1] < $rangeb->[1]) {  ## [[ab .. a] .. b]
        push @rab, $rangea;
        $rangeb = [$rangea->[1] + 1, $rangeb->[1]];
        $rangea = undef;
      } elsif ($rangea->[1] > $rangeb->[1]) { ## [[ab .. b] .. a]
        push @rab, $rangeb;
        $rangea = [$rangeb->[1] + 1, $rangea->[1]];
        $rangeb = undef;
      } else {                            ## [[ab .. ab]]
        push @rab, $rangea;
        $rangea = $rangeb = undef;
      }
    }
  }
}
}
}
return (\@ra, \@rab, \@rb);
};


  ## --- Tokenizer preparation
    ## TODO: Multiple tokenizer support required

  my $tokenizer = $codeDocument->create_perl_sub ('_shift_token');
  $r->
append_child
 ($tokenizer);
  $tokenizer->prototype ('$');
my $tokenizer_param = $tokenizer->append_statement
                          ->append_new_pc_expression ('=');
$tokenizer_param->append_new_pc_variable ('$', undef, 'self')
          ->variable_scope ('my');
$tokenizer_param->append_new_pc_function_call (undef, 'shift');
my $if_stack = $tokenizer->append_new_pc_choose
                   ->append_new_pc_when;
my $stack_array = $if_stack->condition->append_new_pc_dereference ('@');
for ($stack_array->append_new_pc_expression ('->')) {
$_->append_new_pc_variable ('$', undef, 'self');
$_->append_bare ('{token}');
}
$if_stack->block
   ->append_statement
   ->append_new_pc_function_call (undef, 'return')
   ->append_new_pc_function_call (undef, 'shift')
   ->append_child ($stack_array->clone_node (1));

  ## --- For each child elements (rule or lexmode)...

  my %rules;       # defined parser rules
  my %root_rules;  # defined |standalone| parser rules

  B: for my $cel (@{$self->
child_nodes
}) {
    my $xuri = $cel->namespace_uri . $cel->local_name;

    ## -- Rule element - adds reference to hash
    if ($xuri eq 
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/rule'
) {
      my $name = $cel->get_attribute_ns (undef, 'name');
      $rules{$name} = {source => $cel, param => []};
      $root_rules{$name} = 1
        if $cel->
dpg_get_attribute
 ('standalone');

      ## Creates a list of parameters
      C: for my $paramspec (@{$cel->child_nodes}) {
        next C unless $paramspec->namespace_uri eq 
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
;
        next C unless $paramspec->local_name eq 'parameterDeclaration';
        push @{$rules{$name}->{param}},
             $paramspec->get_attribute_ns (undef, 'name');
      }

    ## -- Lexmode element - generate tokenizer
    } elsif ($xuri eq 
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/lexmode'
) {
      ## TODO: Multiple lexmode support

my %token = ($;.'initial' => {
name => $;.'initial',
next_token => [],
});

my $copy_state = sub ($$) {
my ($original_name, $new_prefix) = @_;
my @copy = ($original_name.$;.'0');
my @cs;
while (@copy) {
  my $cname = shift @copy;
  next if $token{$new_prefix, $cname};
  my $original = $token{$cname};
  $token{$new_prefix, $cname} = my $new = {
    name => $new_prefix.$;.$cname,
    next_state => [],
  };
  for my $nxt (@{$original->{next_state}}) {
    push @{$new->{next_state}}, [$nxt->[0], $new_prefix.$;.$nxt->[1]];
    push @copy, $nxt->[1];
  }
  if ($original->{accept}) {
    push @cs, $new;
  }
} # @copy
return @cs;
}; # copy_state

for my $tel (grep {$_->node_type == $_->ELEMENT_NODE} @{$cel->child_nodes}) {
my $xuri = $tel->namespace_uri . $tel->local_name;
if ($xuri eq 
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/lAssignmentStatement'
) {
  my $sname = $tel->get_attribute_ns (undef, 'name');
  my $i = 0;
  if ($token{$sname, $i}) {
    die qq<"$sname" is already defined>;
    ## TODO: exception
  }
  my $s0 = $token{$sname, $i} = {
    name => $sname.$;.$i,
    next_state => [],
  };
  my @current_state = ($s0);
  my $ignore = $tel->
dpg_get_attribute
 ('ignore');
  my $value = $tel->
dpg_get_attribute
 ('value');
  for my $lel (grep {$_->node_type == $_->ELEMENT_NODE} @{$tel->child_nodes}) {
    my $xuri = $lel->namespace_uri . $lel->local_name;
    if ($xuri eq 
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/charClass'
) {
      my $range = [];
      for my $mel (grep {$_->node_type == $_->ELEMENT_NODE} @{$lel->child_nodes}) {
        my $xuri = $mel->namespace_uri . $mel->local_name;
        if ($xuri eq 
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/string'
) {
          $range = $add_range->($range, ord $mel->text_content);
        } elsif ($xuri eq 
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/charRange'
) {
          $range = $add_range->($range, $mel->get_attribute_ns (undef, 'start'),
                                        $mel->get_attribute_ns (undef, 'end'));
        }
      }
      if ($lel->get_attribute_ns (undef, 'negative')) {
        $range = $negate_range->($range);
      }
      
      my $new_s = {
        name => $sname.$;.(++$i),
        next_state => [],
      };
      my $v = $lel->get_attribute_ns (undef, 'occurence');
      if ($v eq 'zeromore') {
        $token{$new_s->{name}} = $new_s;
        push @{$new_s->{next_state}}, [$range, $new_s->{name}];
        for my $s (@current_state) {
          push @{$s->{next_state}}, [$range, $new_s->{name}];
        }
        push @current_state, $new_s;
      } elsif ($v eq 'zeroone') {
        $token{$new_s->{name}} = $new_s;
        for my $s (@current_state) {
          push @{$s->{next_state}}, [$range, $new_s->{name}];
        }
        push @current_state, $new_s;
      } elsif ($v eq 'onemore') {
        $token{$new_s->{name}} = $new_s;
        push @{$new_s->{next_state}}, [$range, $new_s->{name}];
        for my $s (@current_state) {
          push @{$s->{next_state}}, [$range, $new_s->{name}];
        }
            @current_state = ($new_s);
      } else { # one
        $token{$new_s->{name}} = $new_s;
        for my $s (@current_state) {
          push @{$s->{next_state}}, [$range, $new_s->{name}];
        }
            @current_state = ($new_s);
      }
    } elsif ($xuri eq 
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/lRuleRef'
) {
      my $rrulename = $lel->get_attribute_ns (undef, 'name');
      if ($token{$rrulename, 0}) {
        my @cs = $copy_state->($rrulename => $sname);
        for my $s (@current_state) {
          push @{$s->{next_state}}, @{$token{$sname, $rrulename, 0}->{next_state}};
        }
            @current_state = @cs;
      } else {
        die "$rrulename is not defined";
        ## TODO: exception
      }
    }
  }
  push @{$token{$;.'initial'}->{next_state}}, @{$s0->{next_state}};
  for my $s (@current_state) {
    $s->{accept} = $sname;
    $s->{ignore} = $ignore if $ignore;
    $s->{value} = $value if $value;
  }
}
}

my %dfa;
my $make_dfa_state;
$make_dfa_state = sub (@) {
my (@src_name) = @_;
my @src = map {$token{$_}} @src_name;
my $next_state = [[[], [$;.'dummy']]];

my @rsb = map {@{$_->{next_state}}} @src;
for my $rsb (@rsb) {
  my $new_next_state = [];
  RSA: for my $rsa (@$next_state) {
    if (not $rsb) {
      push @$new_next_state, $rsa if @{$rsa->[0]};
      next RSA;
    }
    my ($ra, $rab, $rb) = $and_minus_ranges->($rsa->[0], $rsb->[0]);
    push @$new_next_state, [$ra, $rsa->[1]] if @$ra;
    push @$new_next_state, [$rab, [sort {$a cmp $b} @{$rsa->[1]}, $rsb->[1]]] if @$rab;
    if (@$rb) {
      $rsb = [$rb, $rsb->[1]];
    } else {
      $rsb = undef;
    }
  } # RSA
  if ($rsb) {
    push @$new_next_state, [$rsb->[0], [$rsb->[1]]];
  }
  $next_state = $new_next_state;
}

my $state_name = join $;.$;, @src_name;
$dfa{$state_name} = {
  name => $state_name,
  next_state => @rsb ? $next_state : [],
};

for (@src) {
  if ($_->{accept}) {
    $dfa{$state_name}->{accept} = $_->{accept};
    $dfa{$state_name}->{value} = 1 if $_->{value};
  }
  $dfa{$state_name}->{ignore} = 1 if $_->{ignore};
}
};
my @req_state = ([$;.'initial']);
while (@req_state) {
my $req_state = shift @req_state;
my $req_state_name = join $;.$;, @$req_state;
next if $dfa{$req_state_name};
$make_dfa_state->(@$req_state);
for (@{$dfa{$req_state_name}->{next_state}}) {
  push @req_state, $_->[1];
}
}

my $escape_state_name = sub ($) {
my $s = shift;
$s =~ s/([\W_])/sprintf '_%08X', ord $1/ge;
$s =~ s/_0000001C/__/g;
return $s;
};

for ($tokenizer->append_statement
             ->append_new_pc_expression ('=')) {
$_->append_new_pc_variable ('$', undef, 'ch')
  ->variable_scope ('my');
$_->append_new_pc_number_literal (-2);
}

my %ancestor_state;
my $state_to_code;
$state_to_code = sub ($$%) {
my ($parent, $state_name, %opt) = @_;
$ancestor_state{$state_name} = 1;

my $state_block = $parent->append_new_pc_block;
my $estate_name = $escape_state_name->($state_name);
$state_block->label ('S'.$estate_name);
my $state_select;

if ($opt{outermost}) {
  $state_block->append_statement
              ->append_new_pc_variable ('@', undef, 'ch')
              ->variable_scope ('my');
}

if (@{$dfa{$state_name}->{next_state}}) {
  my $spush = $state_block->append_statement;
  for ($spush->append_new_pc_function_call (undef, 'push')
             ->append_new_pc_expression (',')) {
    $_->append_new_pc_variable ('@', undef, 'ch');
    $_->append_new_pc_variable ('$', undef, 'ch');
  }
  $state_block->parent_node->insert_before ($spush, $state_block)
    unless $opt{outermost};
      ## NOTE: This statement must be placed before the named block;
      ##       otherwise token value cannot be correctly returned
      ##       when |redo|ne.  An exception is the outermost state.
  
  for my $as ($state_block->append_statement
                          ->append_new_pc_expression ('=')) {
    $as->append_new_pc_variable ('$', undef, 'ch')
       ->variable_scope ('my');
    for ($as->append_new_pc_expression ('->')) {
      $_->append_new_pc_variable ('$', undef, 'self');
      $_->append_atom ('_shift_char');
    }
  }

  $state_select = $state_block->append_new_pc_choose;
  for my $rs (@{$dfa{$state_name}->{next_state}}) {
    my $when = $state_select->append_new_pc_when;
  
    my $cond = $when->condition;
    my $cond_and = $cond->append_new_pc_expression ('or');
    for my $range (@{$rs->[0]}) {
      if ($range->[0] == $range->[1]) {
        my $match = $cond_and->append_new_pc_expression ('==');
        $match->append_new_pc_variable ('$', undef, 'ch');
        $match->append_new_pc_number_literal ($range->[0]);
      } else {
        my $x_range = $cond_and->append_new_pc_expression ('and');
        my $x_range_s = $x_range->append_new_pc_expression ('<=');
        $x_range_s->append_new_pc_number_literal ($range->[0]);
        $x_range_s->append_new_pc_variable ('$', undef, 'ch');
        unless ($range->[1] eq 'Inf') {
          my $x_range_e = $x_range->append_new_pc_expression ('<=');
          $x_range_e->append_new_pc_variable ('$', undef, 'ch');
          $x_range_e->append_new_pc_number_literal ($range->[1]);
        }
      }
    }
  
    my $when_block = $when->block;
    my $next_state_name = join $;.$;, @{$rs->[1]};
    if ($ancestor_state{$next_state_name}) {
      $when_block->append_child ($spush->clone_node (1));
      $when_block->append_statement
                 ->append_new_pc_function_call (undef, 'redo')
                 ->append_new_pc_variable
                     ('', undef, 'S'.$escape_state_name->($next_state_name));
    } else {
      $state_to_code->($when_block, $next_state_name, outermost => 0);
    }
  } # for next_state
}

if ($dfa{$state_name}->{accept}) {
  if ($state_select) {
    for ($state_select->append_new_pc_otherwise->block) {
      my $push_ap = $_->append_statement
                      ->append_new_pc_function_call
                                  (undef, 'unshift')
                      ->append_new_pc_expression (',');
      for ($push_ap->append_new_pc_dereference ('@')
                   ->append_new_pc_expression ('->')) {
        $_->append_new_pc_variable ('$', undef, 'self');
        $_->append_bare ('{char}');
      }
      $push_ap->append_new_pc_variable ('$', undef, 'ch');
      for ($_->append_statement->append_new_pc_expression ('=')) {
        $_->append_new_pc_variable ('$', undef, 'ch');
        $_->append_new_pc_number_literal (-2);
      }
    }
  }
  my $accept_code_parent = $state_block;
  unless ($dfa{$state_name}->{ignore}) {
    my %value;
    if ($dfa{$state_name}->{value}) {
      ## Removes dummy item
      $accept_code_parent->append_statement
                         ->append_new_pc_function_call (undef, 'shift')
                         ->append_new_pc_variable ('@', undef, 'ch');
      for ($accept_code_parent->append_statement
                              ->append_new_pc_expression ('=')) {
        $_->append_new_pc_variable ('$', undef, 'token_val')
          ->variable_scope ('my');
        $_->append_string_literal ('');
      }
      for ($accept_code_parent->append_new_pc_choose
                              ->append_new_pc_when) {
        for ($_->condition->append_new_pc_expression ('>')) {
          $_->append_new_pc_variable ('$', undef, 'ch');
          $_->append_new_pc_number_literal (-1);
        }
        for ($_->block->append_statement
                      ->append_new_pc_function_call (undef, 'push')
                      ->append_new_pc_expression (',')) {
          $_->append_new_pc_variable ('@', undef, 'ch');
          $_->append_new_pc_variable ('$', undef, 'ch');
        }
      }
      for ($accept_code_parent->append_new_pc_while) {
        $_->condition->append_new_pc_variable ('@', undef, 'ch');
        for ($_->block->append_statement
                      ->append_new_pc_expression ('.=')) {
          $_->append_new_pc_variable ('$', undef, 'token_val');
          $_->append_new_pc_function_call (undef, 'chr')
            ->append_new_pc_function_call (undef, 'shift')
            ->append_new_pc_variable ('@', undef, 'ch');
        }
      }
      $value{value} = $accept_code_parent->append_new_pc_variable
                                             ('$', undef, 'token_val');
    }
    $accept_code_parent->append_statement
               ->append_new_pc_function_call (undef, 'return')
               ->append_new_pc_literal ({
                   type => $dfa{$state_name}->{accept},
                   %value,
                 });
  } else {
    $accept_code_parent->append_statement
               ->append_new_pc_function_call (undef, 'redo')
               ->append_new_pc_variable
                   ('', undef, 'S'.$escape_state_name->($;.'initial'));
  }
} elsif ($opt{outermost}) {
  if ($state_select) {
  for ($state_select->append_new_pc_when) {
    for ($_->condition->append_new_pc_expression ('==')) {
      $_->append_new_pc_variable ('$', undef, 'ch');
      $_->append_new_pc_number_literal (-1);
    }
    $_->block->append_statement
             ->append_new_pc_function_call (undef, 'return')
             ->append_new_pc_literal ({
                 type => '#EOF',
               });
  }}
  my $chr_ch = $codeDocument
                 ->create_pc_function_call (undef, 'chr');
  $chr_ch->append_new_pc_variable ('$', undef, 'ch');
  $state_block->append_statement
              ->append_new_pc_function_call (undef, 'return')
              ->append_new_pc_literal ({
                  type => '#INVALID',
                  value => $chr_ch,
                });
} else {
  my $push_ap = $state_block->append_statement
                            ->append_new_pc_function_call
                                  (undef, 'unshift')
                            ->append_new_pc_expression (',');
  for ($push_ap->append_new_pc_dereference ('@')
               ->append_new_pc_expression ('->')) {
    $_->append_new_pc_variable ('$', undef, 'self');
    $_->append_bare ('{char}');
  }
  $push_ap->append_new_pc_variable ('$', undef, 'ch');
}

$ancestor_state{$state_name} = 0;
}; # $state_to_code
      $state_to_code->($tokenizer, $;.'initial', outermost => 1);

    } # xuri
  } # B


  ## --- Generates parser methods

  # Template for 'get next token' statements
my $next_token_code = $codeDocument->create_pc_statement;
for ($next_token_code->append_new_pc_expression ('=')) {
$_->append_new_pc_variable ('$', undef, 'token');
for ($_->append_new_pc_expression ('->')) {
$_->append_new_pc_variable ('$', undef, 'self');
$_->append_bare ('_shift_token');
}
}

  
my $block_id = 0;
my $rstatement_to_code;
my $rexpression_to_code;
$rstatement_to_code = sub ($$$) {
my ($parent, $statement, $next_token_required) = @_;
my $xuri = $statement->namespace_uri . $statement->local_name;
if ($xuri eq 
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/matchStatement'
) {
my $match_parent = $parent;
my $match_occur = $statement->get_attribute_ns (undef, 'occurence');


if ($match_occur eq 'onemore') {
$match_parent = $match_parent->append_new_pc_block;
for ($match_parent->append_statement->append_new_pc_expression ('=')) {
  $_->append_new_pc_variable ('$', undef, 'has_content')
    ->variable_scope ('my');
  $_->append_new_pc_number_literal (0);
}
}

my $match_block_id = 0;
if ($match_occur eq 'zeromore' or $match_occur eq 'onemore') {
$match_parent = $match_parent->append_new_pc_block;
$match_parent->label ('MATCH_' . ($match_block_id = ++$block_id));
}

my $match_choose = $match_parent->append_new_pc_choose;
my $token_type_var = $codeDocument->create_pc_expression ('->');
$token_type_var->append_new_pc_variable ('$', undef, 'token');
$token_type_var->append_bare ('{type}');
my $has_sep;
C: for my $child (@{$statement->child_nodes}) {
next C unless $child->node_type == $child->ELEMENT_NODE;
my $xuri = $child->namespace_uri . $child->local_name;
if ($xuri eq 
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/matchBlock'
) {
  my $token_name = $child->get_attribute_ns (undef, 'token');
  my $is_sep = $child->
dpg_get_attribute

                                            ('separator');
  my $token_parent;
  unless ($is_sep) {
    for ($match_choose->append_new_pc_when) {
      for ($_->condition->append_new_pc_expression ('eq')) {
        $_->append_child ($token_type_var->clone_node (1));
        $_->append_string_literal ($token_name);
      }
      $token_parent = $_->block;
    }
    if ($match_occur eq 'onemore') {
      for ($token_parent->append_statement->append_new_pc_expression ('=')) {
        $_->append_new_pc_variable ('$', undef, 'has_content');
        $_->append_new_pc_number_literal (1);
      }
    }
  } else { # separator
    $has_sep = 1;
    for ($match_parent->append_new_pc_choose) {
      for ($_->append_new_pc_when) {
        for ($_->condition->append_new_pc_expression ('eq')) {
          $_->append_child ($token_type_var->clone_node (1));
          $_->append_string_literal ($token_name);
        }
        $token_parent = $_->block;
      }
      for ($_->append_new_pc_otherwise->block) {
        $_->append_statement
          ->append_new_pc_function_call (undef, 'last')
          ->append_new_pc_variable ('', undef, 'MATCH_'.$match_block_id);
      }
    }
  }
  
  ## Child statements
  $next_token_required = 1;
  D: for my $child (@{$child->child_nodes}) {
    next D unless $child->node_type == $child->ELEMENT_NODE;
    $next_token_required = $rstatement_to_code->($token_parent, $child,
                                                 $next_token_required);
  }
  
  if ($next_token_required) {
    $token_parent->append_child ($next_token_code->clone_node (1));
    $next_token_required = 0;
  }

  if ($is_sep and
      ($match_occur eq 'zeromore' or $match_occur eq 'onemore')) {
    $token_parent->
append_statement

          ->
append_new_pc_function_call

                         (
undef
, 'redo')
          ->
append_new_pc_variable

                         ('', 
undef
, 'MATCH_'.$match_block_id);
  }

}
} # pc:matchStatement children

if (not $match_occur or $match_occur eq 'onemore') {
my $err_block = $match_choose->append_new_pc_otherwise->block;
if ($match_occur eq 'onemore') {
  $err_block = $err_block->append_new_pc_choose->append_new_pc_when->block;
  for ($err_block->parent_node->condition->append_new_pc_expression ('==')) {
    $_->append_new_pc_variable ('$', undef, 'has_content');
    $_->append_new_pc_number_literal (0);
  }
}
## TODO: Error reporting
$err_block->append_statement ('die');
}

if (not $has_sep and ($match_occur eq 'zeromore' or $match_occur eq 'onemore')) {
for ($match_choose->append_new_pc_otherwise->block) {
        
  $_->append_statement
                   ->append_new_pc_function_call (undef, 'last')
                   ->append_new_pc_variable ('', undef, 'MATCH_'.$match_block_id);
}
$match_parent->append_statement
             ->append_new_pc_function_call (undef, 'redo')
             ->append_new_pc_variable ('', undef, 'MATCH_'.$match_block_id);
}

return 0; # next_token_required == 0

    } elsif ($xuri eq 
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/embedStatement'
) {
      my $lang = $statement->get_attribute_ns (undef, 'type');
      if ($lang eq 'lang:Perl') {## TODO: lang URI
        my %param;
        my $source;
        C: for my $child (@{$statement->child_nodes}) {
          next C unless $child->node_type == $child->ELEMENT_NODE;
          my $xuri = $child->
namespace_uri

                   . $child->
local_name
;
          if ($xuri eq 
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/parameterSpecification'
) {
            $param{$child->
get_attribute_ns
 (undef, 'name')}
              = $child;
          } elsif ($xuri eq 
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/embedBlock'
) {
            $source = $child->
text_content
;
          }
        }

        my $plcode = $opt{dis_resource}->
pl_preprocess_perl_code

                         ($source, namespace_context => $opt{context_object});

        my $dparent = $parent->
owner_document

                           ->
create_pc_expression
 (',');
        for (keys %param) {
          $rexpression_to_code->($dparent, $param{$_});
          $plcode->
replace_variable

            ('$'.$_ => $dparent->
last_child
);
        }

        $parent->
append_code_fragment
 ($plcode);
        return $next_token_required;
      } else {
        die qq<Lexical content type <$lang> is not supported>;
        ## TODO: exception
      }

} elsif ($xuri eq 
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/myStatement'
) {
$parent->append_statement
     ->append_new_pc_variable
         ('$', undef, $statement->get_attribute_ns (undef, 'name'))
     ->variable_scope ('my');
      return $next_token_required;

} elsif ($xuri eq 
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/ruleRefStatement'
) {
my $rule_name = $statement->get_attribute_ns (undef, 'name');
if ($rules{$rule_name}) {
if ($root_rules{$rule_name}) {
  unless ($next_token_required) {
    for ($parent->append_statement
                ->append_new_pc_function_call (undef, 'push')
                ->append_new_pc_expression (',')) {
      for ($_->append_new_pc_dereference ('@')
             ->append_new_pc_expression ('->')) {
        $_->append_new_pc_variable ('$', undef, 'self');
        $_->append_bare ('{token}');
      }
      $_->append_new_pc_variable ('$', undef, 'token');
    }
  }

  
  my $param_spec_list;
  for ($parent->append_statement->append_new_pc_apply) {
    for ($_->append_new_pc_expression ('->')) {
      $_->append_new_pc_variable ('$', undef, 'self');
      $_->append_bare ('_parse_' . $rule_name);
    }
    $param_spec_list = $_->append_new_pc_expression (',');
  }
  
  my %param;
  C: for my $child (@{$statement->child_nodes}) {
    next C unless $child->node_type == $child->ELEMENT_NODE;
    if ($child->namespace_uri . $child->local_name eq
        
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/parameterSpecification'
) {
      $param{$child->get_attribute_ns (undef, 'name')} = $child;
    }
  }
  
  for my $param_name (@{$rules{$rule_name}->{param}}) {
    if ($param{$param_name}) {
      $rexpression_to_code->($param_spec_list, $param{$param_name});
    } else {
      $param_spec_list->append_atom ('undef');
    }
  }
  
  return 1; # next_token_required == 1
} else { # not a standalone rule
  my $block;
  unless ($rules{$rule_name}->{code}->[$next_token_required += 0]) {
    $block = $parent->append_new_pc_block;
    $rules{$rule_name}->{code}->[$next_token_required]
      = [$block, $next_token_required]; # prevent infinite loop
    my $o_next_token_required = $next_token_required;
    
    ## Child statements
    C: for my $child (@{$rules{$rule_name}->{source}->child_nodes}) {
      next C unless $child->node_type == $child->ELEMENT_NODE;
      $next_token_required = $rstatement_to_code->($block, $child,
                                                   $next_token_required);
    }
    $rules{$rule_name}->{code}->[$o_next_token_required]
      = [$block->clone_node (1), $next_token_required];
  } else {
    $block = $parent->append_child
               ($rules{$rule_name}->{code}->[$next_token_required]->[0]
                                  ->clone_node (1));
    $next_token_required
      = $rules{$rule_name}->{code}->[$next_token_required]->[1];
  }
  
  my %param;
  C: for my $child (@{$statement->child_nodes}) {
    next C unless $child->node_type == $child->ELEMENT_NODE;
    if ($child->namespace_uri . $child->local_name eq
        
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/parameterSpecification'
) {
      $param{$child->get_attribute_ns (undef, 'name')} = $child;
    }
  }
  
  my $block_first = $block->first_child;
  for my $param_name (reverse @{$rules{$rule_name}->{param}}) {
    $block_first = $block->insert_before
                     ($codeDocument->create_pc_statement, $block_first);
    for ($block_first->append_new_pc_expression ('=')) {
      $_->append_new_pc_variable ('$', undef, $param_name)
        ->variable_scope ('my');
      if ($param{$param_name}) {
        $rexpression_to_code->($_, $param{$param_name});
      } else {
        $_->append_atom ('undef');
      }
    }
  }
  
  return $next_token_required;
}
} elsif ($rule_name eq 'builtin:nestedBlockAsText') {
my %param = (start_by_open => not $next_token_required,
             open => '{', close => '}');

C: for my $child (@{$statement->child_nodes}) {
  next C unless $child->node_type == $child->ELEMENT_NODE;
  if ($child->namespace_uri . $child->local_name eq
      
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/parameterSpecification'
) {
    $param{$child->get_attribute_ns (undef, 'name')} = $child;
  }
}
  
for ($parent->append_statement->append_new_pc_apply) {
  for ($_->append_new_pc_expression ('->')) {
    $_->append_new_pc_variable ('$', undef, 'self');
    $_->append_bare ('_parse_nested_block_as_text');
  }
  my $param_spec_list = $_->append_new_pc_expression (',');
  for my $param_name (qw/doc parent open close start_by_open/) {
    if (ref $param{$param_name}) {
      $rexpression_to_code->($param_spec_list, $param{$param_name});
    } else {
      $param_spec_list->append_new_pc_literal ($param{$param_name});
    }
  }
}

return 1; # $next_token_required == 1
} else {
die qq<Rule "$rule_name" is not defined>;
## TODO: exception
}



} elsif ($xuri eq 
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/assignmentStatement'
) {
my $assign = $parent->append_statement->append_new_pc_expression ('=');
my $lvalue = $statement->first_child;
if ($lvalue->namespace_uri . $lvalue->local_name eq 
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/memberRef'
) {
my $context = $assign->append_new_pc_expression ('->');
C: for my $child (@{$lvalue->child_nodes}) {
  my $xuri = $child->namespace_uri . $child->local_name;
  if ($xuri eq 
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/variable'
) {
    $context->append_new_pc_variable
      ('$', undef, $child->get_attribute_ns (undef, 'name'));
  } elsif ($xuri eq 
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/member'
) {
    $context->append_bare ('{'.$child->get_attribute_ns (undef, 'name').'}');
  }
}
}
      return $next_token_required;

} elsif ($xuri eq 
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/codeBlock'
) {
D: for my $child (@{$statement->child_nodes}) {
next D unless $child->node_type == $child->ELEMENT_NODE;
my $xuri = $child->namespace_uri . $child->local_name;
if ($xuri eq 
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/matchStatement'
) {
  if ($next_token_required) {
    $parent->append_child ($next_token_code->clone_node (1));
    $next_token_required = 
0
;
  }
}
$next_token_required = $rstatement_to_code->($parent, $child, $next_token_required);
}
return $next_token_required;
} else {
return $next_token_required;
} # xuri
}; # rstatement_to_code



$rexpression_to_code = sub ($$) {
my ($parent, $source_parent) = @_;
$parent = $parent->append_new_pc_expression (',');
C: for my $child (@{$source_parent->child_nodes}) {
next C unless $child->node_type == $child->ELEMENT_NODE;
my $xuri = $child->namespace_uri . $child->local_name;
if ($xuri eq 
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/memberRef'
) {
my $context = $parent->append_new_pc_expression ('->');
D: for my $child (@{$child->child_nodes}) {
  next D unless $child->node_type == $child->ELEMENT_NODE;
  my $xuri = $child->namespace_uri . $child->local_name;
  if ($xuri eq 
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/variable'
) {
    $context->append_new_pc_variable
      ('$', undef, $child->get_attribute_ns (undef, 'name'));
  } elsif ($xuri eq 
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/member'
) {
    $context->append_bare ('{'.$child->get_attribute_ns (undef, 'name').'}');
  }
}
} elsif ($xuri eq 
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/string'
) {
$parent->append_string_literal ($child->text_content);
}
}
}; # rexpression_to_code

for my $rule_name (keys %root_rules) {
my $rule_sub = $codeDocument->create_perl_sub ('_parse_' . $rule_name);
$r->
append_child
 ($rule_sub);

    my $params_s = $rule_sub->append_statement;
    my @params = ('$self');
    my $proto = '$';

$rule_sub->append_statement->append_new_pc_variable ('$', undef, 'token')
                       ->variable_scope ('my');

my $next_token_required = 1;
C: for my $child (@{$rules{$rule_name}->{source}->child_nodes}) {
next C unless $child->node_type == $child->ELEMENT_NODE;
      if ($child->
namespace_uri
 . $child->
local_name
            eq 

'http://suika.fam.cx/~wakaba/archive/2005/11/pg/parameterDeclaration'
) {
        push @params, '$'.$child->
get_attribute_ns

                            (
undef
, 'name');
        $proto .= '$';
      } else {
        $next_token_required
          = $rstatement_to_code->($rule_sub, $child,
                                  $next_token_required);
      }
}

    $params_s->append_code ('my ('.join (', ', @params).') = @_');
    $rule_sub->prototype ($proto);

unless ($next_token_required) {
for ($rule_sub->append_statement
            ->append_new_pc_function_call (undef, 'push')
            ->append_new_pc_expression (',')) {
for ($_->append_new_pc_dereference ('@')
       ->append_new_pc_expression ('->')) {
  $_->append_new_pc_variable ('$', undef, 'self');
  $_->append_bare ('{token}');
}
$_->append_new_pc_variable ('$', undef, 'token');
}
}
  
} # for %root_rules




;}


;}

;


;}
$r}
$Message::DOM::ClassFeature{q<Message::Util::DIS::DPG::ManakaiDPGRulesElement>} = {'', {'', '1'}, 'core', {'', '1', '1.0', '1', '2.0', '1', '3.0', '1'}, 'http://suika.fam.cx/~wakaba/archive/2005/manakai/util/dis#dpg', {'', '1', '1.0', '1'}, 'xml', {'', '1', '1.0', '1', '2.0', '1', '3.0', '1'}, 'xmlversion', {'', '1', '1.0', '1', '1.1', '1'}};
$Message::DOM::ClassPoint{q<Message::Util::DIS::DPG::ManakaiDPGRulesElement>} = 24.2;
$Message::DOM::ManakaiDOMElement::CompatClassET{q<http://suika.fam.cx/~wakaba/archive/2005/11/pg/>}->{q<rules>}->{q<Message::Util::DIS::DPG::ManakaiDPGRulesElement>} = 1;
$Message::Util::ManakaiNode::ManakaiNodeRef::Prop{q<Message::Util::DIS::DPG::ManakaiDPGRulesElement>} = {'o', ['parent'], 's', ['child'], 's2', ['attr'], 'x', ['od']};
package Message::Util::IF::DPGRuleElement;
our $VERSION = 20051220.1157;
package Message::Util::DIS::DPG::ManakaiDPGRuleElement;
our $VERSION = 20051220.1157;
push our @ISA, 'Message::Util::DIS::DPG::ManakaiDPGElement', 'Message::Util::DIS::DPG::ManakaiDPGElementAttribute', 'Message::DOM::IFLatest::Element', 'Message::DOM::IFLatest::Node', 'Message::Util::IF::DPGElement', 'Message::Util::IF::DPGElementAttribute', 'Message::Util::IF::DPGRuleElement';
$Message::DOM::ClassFeature{q<Message::Util::DIS::DPG::ManakaiDPGRuleElement>} = {'', {'', '1'}, 'core', {'', '1', '1.0', '1', '2.0', '1', '3.0', '1'}, 'http://suika.fam.cx/~wakaba/archive/2005/manakai/util/dis#dpg', {'', '1', '1.0', '1'}, 'xml', {'', '1', '1.0', '1', '2.0', '1', '3.0', '1'}, 'xmlversion', {'', '1', '1.0', '1', '1.1', '1'}};
$Message::DOM::ClassPoint{q<Message::Util::DIS::DPG::ManakaiDPGRuleElement>} = 25.2;
$Message::DOM::ManakaiDOMElement::CompatClassET{q<http://suika.fam.cx/~wakaba/archive/2005/11/pg/>}->{q<rule>}->{q<Message::Util::DIS::DPG::ManakaiDPGRuleElement>} = 1;
$Message::Util::ManakaiNode::ManakaiNodeRef::Prop{q<Message::Util::DIS::DPG::ManakaiDPGRuleElement>} = {'o', ['parent'], 's', ['child'], 's2', ['attr'], 'x', ['od']};
package Message::Util::IF::DPGMatchBlockElement;
our $VERSION = 20051220.1157;
package Message::Util::DIS::DPG::ManakaiDPGMatchBlockElement;
our $VERSION = 20051220.1157;
push our @ISA, 'Message::Util::DIS::DPG::ManakaiDPGElement', 'Message::Util::DIS::DPG::ManakaiDPGElementAttribute', 'Message::DOM::IFLatest::Element', 'Message::DOM::IFLatest::Node', 'Message::Util::IF::DPGElement', 'Message::Util::IF::DPGElementAttribute', 'Message::Util::IF::DPGMatchBlockElement';
$Message::DOM::ClassFeature{q<Message::Util::DIS::DPG::ManakaiDPGMatchBlockElement>} = {'', {'', '1'}, 'core', {'', '1', '1.0', '1', '2.0', '1', '3.0', '1'}, 'http://suika.fam.cx/~wakaba/archive/2005/manakai/util/dis#dpg', {'', '1', '1.0', '1'}, 'xml', {'', '1', '1.0', '1', '2.0', '1', '3.0', '1'}, 'xmlversion', {'', '1', '1.0', '1', '1.1', '1'}};
$Message::DOM::ClassPoint{q<Message::Util::DIS::DPG::ManakaiDPGMatchBlockElement>} = 25.2;
$Message::DOM::ManakaiDOMElement::CompatClassET{q<http://suika.fam.cx/~wakaba/archive/2005/11/pg/>}->{q<matchBlock>}->{q<Message::Util::DIS::DPG::ManakaiDPGMatchBlockElement>} = 1;
$Message::Util::ManakaiNode::ManakaiNodeRef::Prop{q<Message::Util::DIS::DPG::ManakaiDPGMatchBlockElement>} = {'o', ['parent'], 's', ['child'], 's2', ['attr'], 'x', ['od']};
package Message::Util::IF::DPGLexmodeElement;
our $VERSION = 20051220.1157;
package Message::Util::DIS::DPG::ManakaiDPGLexmodeElement;
our $VERSION = 20051220.1157;
push our @ISA, 'Message::Util::DIS::DPG::ManakaiDPGElement', 'Message::Util::DIS::DPG::ManakaiDPGElementAttribute', 'Message::DOM::IFLatest::Element', 'Message::DOM::IFLatest::Node', 'Message::Util::IF::DPGElement', 'Message::Util::IF::DPGElementAttribute', 'Message::Util::IF::DPGLexmodeElement';
$Message::DOM::ClassFeature{q<Message::Util::DIS::DPG::ManakaiDPGLexmodeElement>} = {'', {'', '1'}, 'core', {'', '1', '1.0', '1', '2.0', '1', '3.0', '1'}, 'http://suika.fam.cx/~wakaba/archive/2005/manakai/util/dis#dpg', {'', '1', '1.0', '1'}, 'xml', {'', '1', '1.0', '1', '2.0', '1', '3.0', '1'}, 'xmlversion', {'', '1', '1.0', '1', '1.1', '1'}};
$Message::DOM::ClassPoint{q<Message::Util::DIS::DPG::ManakaiDPGLexmodeElement>} = 25.2;
$Message::DOM::ManakaiDOMElement::CompatClassET{q<http://suika.fam.cx/~wakaba/archive/2005/11/pg/>}->{q<lexmode>}->{q<Message::Util::DIS::DPG::ManakaiDPGLexmodeElement>} = 1;
$Message::Util::ManakaiNode::ManakaiNodeRef::Prop{q<Message::Util::DIS::DPG::ManakaiDPGLexmodeElement>} = {'o', ['parent'], 's', ['child'], 's2', ['attr'], 'x', ['od']};
package Message::Util::IF::DPGLAssignmentStatementElement;
our $VERSION = 20051220.1157;
package Message::Util::DIS::DPG::ManakaiDPGLAssignmentStatementElement;
our $VERSION = 20051220.1157;
push our @ISA, 'Message::Util::DIS::DPG::ManakaiDPGElement', 'Message::Util::DIS::DPG::ManakaiDPGElementAttribute', 'Message::DOM::IFLatest::Element', 'Message::DOM::IFLatest::Node', 'Message::Util::IF::DPGElement', 'Message::Util::IF::DPGElementAttribute', 'Message::Util::IF::DPGLAssignmentStatementElement';
$Message::DOM::ClassFeature{q<Message::Util::DIS::DPG::ManakaiDPGLAssignmentStatementElement>} = {'', {'', '1'}, 'core', {'', '1', '1.0', '1', '2.0', '1', '3.0', '1'}, 'http://suika.fam.cx/~wakaba/archive/2005/manakai/util/dis#dpg', {'', '1', '1.0', '1'}, 'xml', {'', '1', '1.0', '1', '2.0', '1', '3.0', '1'}, 'xmlversion', {'', '1', '1.0', '1', '1.1', '1'}};
$Message::DOM::ClassPoint{q<Message::Util::DIS::DPG::ManakaiDPGLAssignmentStatementElement>} = 25.2;
$Message::DOM::ManakaiDOMElement::CompatClassET{q<http://suika.fam.cx/~wakaba/archive/2005/11/pg/>}->{q<lAssignmentStatement>}->{q<Message::Util::DIS::DPG::ManakaiDPGLAssignmentStatementElement>} = 1;
$Message::Util::ManakaiNode::ManakaiNodeRef::Prop{q<Message::Util::DIS::DPG::ManakaiDPGLAssignmentStatementElement>} = {'o', ['parent'], 's', ['child'], 's2', ['attr'], 'x', ['od']};
package Message::Util::IF::DPGParser;
our $VERSION = 20051220.1157;
package Message::Util::DIS::DPG::ManakaiDPGParser;
our $VERSION = 20051220.1157;
push our @ISA, 'Message::Util::IF::DPGParser';
sub new ($$$) {
my ($self, $impl, $features) = @_;

{

if 
(CORE::defined $features) {
  if (CORE::ref ($features) eq 'HASH') {
    my $new = {};
    for my $fname (keys %{$features}) {
      if (CORE::ref ($features->{$fname}) eq 'HASH') {
        my $lfname = lc $fname;
        for my $fver (keys %{$features->{$fname}}) {
          $new->{$lfname}->{$fver} = $features->{$fname}->{$fver};
        }
      } else {
        $new->{lc $fname} = {(CORE::defined $features->{$fname}
                                ? $features->{$fname} : '') => 1};
      }
    }
    $features = $new;
  } else {
    my @f = split /\s+/, $features;
    $features = {};
    while (@f) {
      my $name = lc shift @f;
      if (@f and $f[0] =~ /^[\d\.]+$/) {
        $features->{$name}->{shift @f} = 1;
      } else {
        $features->{$name}->{''} = 1;
      }
    }
  }
} else {
  $features = {};
}


;}
my $r;

{


$r = bless {
  
'impl'

    => $impl->
get_feature

         (
'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS#DPG'
 => ''),
}, $self;


;}
$r}
sub parse_string ($$$) {
my ($self, $sourceText, $namespaceContext) = @_;
my $r;

{


$self->{char} = [];
$self->{token} = [];
$self->{source} = $sourceText;


{

local $Error::Depth = $Error::Depth + 1;

{



  $r = $self->_parse_Rules ($self->{
'impl'
});



;}


;}

;


;}
$r}
sub _shift_char ($) {
my ($self) = @_;
my $r = 0;

{

if 
(@{$self->{char}}) {
  $r = shift @{$self->{char}};
} else {
  my $char = substr ($self->{source}, pos ($self->{source}), 1);
  pos ($self->{source})++;

  if (length $char) {
    $r = ord $char;
  } else {
    $r = -1;
  }
}


;}
$r}
sub _parse_nested_block_as_text ($$$) {
my ($self, $doc, $parent) = @_;

{

my 
$nest_count = 1; # already opened
my $s = '';


{

local $Error::Depth = $Error::Depth + 1;

{


  C: 
while ((my $ch = $self->
_shift_char
) > -1) {
    if ($ch == 0x007B) {
      $s .= '{'; # }
      $nest_count++;
    } elsif ($ch == 0x007D) {
      if (--$nest_count == 0) {
        last C;
      } elsif ($nest_count < 0) {
        $nest_count = 0;
      }
      $s .= chr $ch;
    } else {
      $s .= chr $ch;
    }
  }

  if (length $s) {
    my $el = $doc->
create_element_ns

                (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'embedBlock');
    $el->
text_content
 ($s);
    $parent->
append_child
 ($el);
  }



;}


;}

;


;}
}
sub _shift_token ($) {
my $self = shift ();
if (@{$self->{token}}) 
{

return shift (@{$self->{token}});


}
my $ch = -2;

S__initial:
{

my @ch;
push (@ch, $ch);
my $ch = $self->_shift_char;
if (((9 <= $ch) and ($ch <= 13)) or ($ch == 32)) 
{

push (@ch, $ch);

SWSP__1:
{

my $ch = $self->_shift_char;
if (((9 <= $ch) and ($ch <= 13)) or ($ch == 32)) 
{

push (@ch, $ch);
redo SWSP__1;


}
else 
{

unshift (@{$self->{char}}, $ch);
$ch = -2;


}
redo S__initial;


}
# SWSP__1


}
elsif ($ch == 59) 
{

push (@ch, $ch);

SCOMMENT__1____SEMICOLON__1:
{

my $ch = $self->_shift_char;
if ($ch == 59) 
{

push (@ch, $ch);

SCOMMENT__2:
{

my $ch = $self->_shift_char;
if (((0 <= $ch) and ($ch <= 9)) or 14 <= $ch) 
{

push (@ch, $ch);

SCOMMENT__3:
{

my $ch = $self->_shift_char;
if (((0 <= $ch) and ($ch <= 9)) or 14 <= $ch) 
{

push (@ch, $ch);
redo SCOMMENT__3;


}
elsif ((10 <= $ch) and ($ch <= 13)) 
{

push (@ch, $ch);

SCOMMENT__4:
{

my $ch = $self->_shift_char;
if ((10 <= $ch) and ($ch <= 13)) 
{

push (@ch, $ch);
redo SCOMMENT__4;


}
else 
{

unshift (@{$self->{char}}, $ch);
$ch = -2;


}
redo S__initial;


}
# SCOMMENT__4


}
else 
{

unshift (@{$self->{char}}, $ch);
$ch = -2;


}
redo S__initial;


}
# SCOMMENT__3


}
elsif ((10 <= $ch) and ($ch <= 13)) 
{

push (@ch, $ch);

SCOMMENT__4:
{

my $ch = $self->_shift_char;
if ((10 <= $ch) and ($ch <= 13)) 
{

push (@ch, $ch);
redo SCOMMENT__4;


}
else 
{

unshift (@{$self->{char}}, $ch);
$ch = -2;


}
redo S__initial;


}
# SCOMMENT__4


}
else 
{

unshift (@{$self->{char}}, $ch);
$ch = -2;


}
redo S__initial;


}
# SCOMMENT__2


}
else 
{

unshift (@{$self->{char}}, $ch);
$ch = -2;


}
return {'type', 'SEMICOLON'};


}
# SCOMMENT__1____SEMICOLON__1


}
elsif (($ch == 45) or ((65 <= $ch) and ($ch <= 84)) or ((86 <= $ch) and ($ch <= 90)) or ($ch == 95) or ((97 <= $ch) and ($ch <= 107)) or ((110 <= $ch) and ($ch <= 113)) or ((115 <= $ch) and ($ch <= 116)) or ((118 <= $ch) and ($ch <= 122))) 
{

push (@ch, $ch);

SNAME__1:
{

my $ch = $self->_shift_char;
if (($ch == 45) or ((48 <= $ch) and ($ch <= 57)) or ($ch == 58) or ((65 <= $ch) and ($ch <= 90)) or ($ch == 95) or ((97 <= $ch) and ($ch <= 122))) 
{

push (@ch, $ch);

SNAME__2:
{

my $ch = $self->_shift_char;
if (($ch == 45) or ((48 <= $ch) and ($ch <= 57)) or ($ch == 58) or ((65 <= $ch) and ($ch <= 90)) or ($ch == 95) or ((97 <= $ch) and ($ch <= 122))) 
{

push (@ch, $ch);
redo SNAME__2;


}
else 
{

unshift (@{$self->{char}}, $ch);
$ch = -2;


}
shift (@ch);
my $token_val = '';
if ($ch > -1) 
{

push (@ch, $ch);


}
while (@ch) 
{

$token_val .= chr (shift (@ch));


}
return {'type', 'NAME', 'value', $token_val};


}
# SNAME__2


}
else 
{

unshift (@{$self->{char}}, $ch);
$ch = -2;


}
shift (@ch);
my $token_val = '';
if ($ch > -1) 
{

push (@ch, $ch);


}
while (@ch) 
{

$token_val .= chr (shift (@ch));


}
return {'type', 'NAME', 'value', $token_val};


}
# SNAME__1


}
elsif ($ch == 108) 
{

push (@ch, $ch);

SNAME__1____lEXMODE__1:
{

my $ch = $self->_shift_char;
if (($ch == 45) or ((48 <= $ch) and ($ch <= 57)) or ($ch == 58) or ((65 <= $ch) and ($ch <= 90)) or ($ch == 95) or ((97 <= $ch) and ($ch <= 100)) or ((102 <= $ch) and ($ch <= 122))) 
{

push (@ch, $ch);

SNAME__2:
{

my $ch = $self->_shift_char;
if (($ch == 45) or ((48 <= $ch) and ($ch <= 57)) or ($ch == 58) or ((65 <= $ch) and ($ch <= 90)) or ($ch == 95) or ((97 <= $ch) and ($ch <= 122))) 
{

push (@ch, $ch);
redo SNAME__2;


}
else 
{

unshift (@{$self->{char}}, $ch);
$ch = -2;


}
shift (@ch);
my $token_val = '';
if ($ch > -1) 
{

push (@ch, $ch);


}
while (@ch) 
{

$token_val .= chr (shift (@ch));


}
return {'type', 'NAME', 'value', $token_val};


}
# SNAME__2


}
elsif ($ch == 101) 
{

push (@ch, $ch);

SNAME__2____lEXMODE__2:
{

my $ch = $self->_shift_char;
if (($ch == 45) or ((48 <= $ch) and ($ch <= 57)) or ($ch == 58) or ((65 <= $ch) and ($ch <= 90)) or ($ch == 95) or ((97 <= $ch) and ($ch <= 119)) or ((121 <= $ch) and ($ch <= 122))) 
{

push (@ch, $ch);

SNAME__2:
{

my $ch = $self->_shift_char;
if (($ch == 45) or ((48 <= $ch) and ($ch <= 57)) or ($ch == 58) or ((65 <= $ch) and ($ch <= 90)) or ($ch == 95) or ((97 <= $ch) and ($ch <= 122))) 
{

push (@ch, $ch);
redo SNAME__2;


}
else 
{

unshift (@{$self->{char}}, $ch);
$ch = -2;


}
shift (@ch);
my $token_val = '';
if ($ch > -1) 
{

push (@ch, $ch);


}
while (@ch) 
{

$token_val .= chr (shift (@ch));


}
return {'type', 'NAME', 'value', $token_val};


}
# SNAME__2


}
elsif ($ch == 120) 
{

push (@ch, $ch);

SNAME__2____lEXMODE__3:
{

my $ch = $self->_shift_char;
if (($ch == 45) or ((48 <= $ch) and ($ch <= 57)) or ($ch == 58) or ((65 <= $ch) and ($ch <= 90)) or ($ch == 95) or ((97 <= $ch) and ($ch <= 108)) or ((110 <= $ch) and ($ch <= 122))) 
{

push (@ch, $ch);

SNAME__2:
{

my $ch = $self->_shift_char;
if (($ch == 45) or ((48 <= $ch) and ($ch <= 57)) or ($ch == 58) or ((65 <= $ch) and ($ch <= 90)) or ($ch == 95) or ((97 <= $ch) and ($ch <= 122))) 
{

push (@ch, $ch);
redo SNAME__2;


}
else 
{

unshift (@{$self->{char}}, $ch);
$ch = -2;


}
shift (@ch);
my $token_val = '';
if ($ch > -1) 
{

push (@ch, $ch);


}
while (@ch) 
{

$token_val .= chr (shift (@ch));


}
return {'type', 'NAME', 'value', $token_val};


}
# SNAME__2


}
elsif ($ch == 109) 
{

push (@ch, $ch);

SNAME__2____lEXMODE__4:
{

my $ch = $self->_shift_char;
if (($ch == 45) or ((48 <= $ch) and ($ch <= 57)) or ($ch == 58) or ((65 <= $ch) and ($ch <= 90)) or ($ch == 95) or ((97 <= $ch) and ($ch <= 110)) or ((112 <= $ch) and ($ch <= 122))) 
{

push (@ch, $ch);

SNAME__2:
{

my $ch = $self->_shift_char;
if (($ch == 45) or ((48 <= $ch) and ($ch <= 57)) or ($ch == 58) or ((65 <= $ch) and ($ch <= 90)) or ($ch == 95) or ((97 <= $ch) and ($ch <= 122))) 
{

push (@ch, $ch);
redo SNAME__2;


}
else 
{

unshift (@{$self->{char}}, $ch);
$ch = -2;


}
shift (@ch);
my $token_val = '';
if ($ch > -1) 
{

push (@ch, $ch);


}
while (@ch) 
{

$token_val .= chr (shift (@ch));


}
return {'type', 'NAME', 'value', $token_val};


}
# SNAME__2


}
elsif ($ch == 111) 
{

push (@ch, $ch);

SNAME__2____lEXMODE__5:
{

my $ch = $self->_shift_char;
if (($ch == 45) or ((48 <= $ch) and ($ch <= 57)) or ($ch == 58) or ((65 <= $ch) and ($ch <= 90)) or ($ch == 95) or ((97 <= $ch) and ($ch <= 99)) or ((101 <= $ch) and ($ch <= 122))) 
{

push (@ch, $ch);

SNAME__2:
{

my $ch = $self->_shift_char;
if (($ch == 45) or ((48 <= $ch) and ($ch <= 57)) or ($ch == 58) or ((65 <= $ch) and ($ch <= 90)) or ($ch == 95) or ((97 <= $ch) and ($ch <= 122))) 
{

push (@ch, $ch);
redo SNAME__2;


}
else 
{

unshift (@{$self->{char}}, $ch);
$ch = -2;


}
shift (@ch);
my $token_val = '';
if ($ch > -1) 
{

push (@ch, $ch);


}
while (@ch) 
{

$token_val .= chr (shift (@ch));


}
return {'type', 'NAME', 'value', $token_val};


}
# SNAME__2


}
elsif ($ch == 100) 
{

push (@ch, $ch);

SNAME__2____lEXMODE__6:
{

my $ch = $self->_shift_char;
if (($ch == 45) or ((48 <= $ch) and ($ch <= 57)) or ($ch == 58) or ((65 <= $ch) and ($ch <= 90)) or ($ch == 95) or ((97 <= $ch) and ($ch <= 100)) or ((102 <= $ch) and ($ch <= 122))) 
{

push (@ch, $ch);

SNAME__2:
{

my $ch = $self->_shift_char;
if (($ch == 45) or ((48 <= $ch) and ($ch <= 57)) or ($ch == 58) or ((65 <= $ch) and ($ch <= 90)) or ($ch == 95) or ((97 <= $ch) and ($ch <= 122))) 
{

push (@ch, $ch);
redo SNAME__2;


}
else 
{

unshift (@{$self->{char}}, $ch);
$ch = -2;


}
shift (@ch);
my $token_val = '';
if ($ch > -1) 
{

push (@ch, $ch);


}
while (@ch) 
{

$token_val .= chr (shift (@ch));


}
return {'type', 'NAME', 'value', $token_val};


}
# SNAME__2


}
elsif ($ch == 101) 
{

push (@ch, $ch);

SNAME__2____lEXMODE__7:
{

my $ch = $self->_shift_char;
if (($ch == 45) or ((48 <= $ch) and ($ch <= 57)) or ($ch == 58) or ((65 <= $ch) and ($ch <= 90)) or ($ch == 95) or ((97 <= $ch) and ($ch <= 122))) 
{

push (@ch, $ch);

SNAME__2:
{

my $ch = $self->_shift_char;
if (($ch == 45) or ((48 <= $ch) and ($ch <= 57)) or ($ch == 58) or ((65 <= $ch) and ($ch <= 90)) or ($ch == 95) or ((97 <= $ch) and ($ch <= 122))) 
{

push (@ch, $ch);
redo SNAME__2;


}
else 
{

unshift (@{$self->{char}}, $ch);
$ch = -2;


}
shift (@ch);
my $token_val = '';
if ($ch > -1) 
{

push (@ch, $ch);


}
while (@ch) 
{

$token_val .= chr (shift (@ch));


}
return {'type', 'NAME', 'value', $token_val};


}
# SNAME__2


}
else 
{

unshift (@{$self->{char}}, $ch);
$ch = -2;


}
shift (@ch);
my $token_val = '';
if ($ch > -1) 
{

push (@ch, $ch);


}
while (@ch) 
{

$token_val .= chr (shift (@ch));


}
return {'type', 'lEXMODE', 'value', $token_val};


}
# SNAME__2____lEXMODE__7


}
else 
{

unshift (@{$self->{char}}, $ch);
$ch = -2;


}
shift (@ch);
my $token_val = '';
if ($ch > -1) 
{

push (@ch, $ch);


}
while (@ch) 
{

$token_val .= chr (shift (@ch));


}
return {'type', 'NAME', 'value', $token_val};


}
# SNAME__2____lEXMODE__6


}
else 
{

unshift (@{$self->{char}}, $ch);
$ch = -2;


}
shift (@ch);
my $token_val = '';
if ($ch > -1) 
{

push (@ch, $ch);


}
while (@ch) 
{

$token_val .= chr (shift (@ch));


}
return {'type', 'NAME', 'value', $token_val};


}
# SNAME__2____lEXMODE__5


}
else 
{

unshift (@{$self->{char}}, $ch);
$ch = -2;


}
shift (@ch);
my $token_val = '';
if ($ch > -1) 
{

push (@ch, $ch);


}
while (@ch) 
{

$token_val .= chr (shift (@ch));


}
return {'type', 'NAME', 'value', $token_val};


}
# SNAME__2____lEXMODE__4


}
else 
{

unshift (@{$self->{char}}, $ch);
$ch = -2;


}
shift (@ch);
my $token_val = '';
if ($ch > -1) 
{

push (@ch, $ch);


}
while (@ch) 
{

$token_val .= chr (shift (@ch));


}
return {'type', 'NAME', 'value', $token_val};


}
# SNAME__2____lEXMODE__3


}
else 
{

unshift (@{$self->{char}}, $ch);
$ch = -2;


}
shift (@ch);
my $token_val = '';
if ($ch > -1) 
{

push (@ch, $ch);


}
while (@ch) 
{

$token_val .= chr (shift (@ch));


}
return {'type', 'NAME', 'value', $token_val};


}
# SNAME__2____lEXMODE__2


}
else 
{

unshift (@{$self->{char}}, $ch);
$ch = -2;


}
shift (@ch);
my $token_val = '';
if ($ch > -1) 
{

push (@ch, $ch);


}
while (@ch) 
{

$token_val .= chr (shift (@ch));


}
return {'type', 'NAME', 'value', $token_val};


}
# SNAME__1____lEXMODE__1


}
elsif ($ch == 114) 
{

push (@ch, $ch);

SNAME__1____RULE__1:
{

my $ch = $self->_shift_char;
if (($ch == 45) or ((48 <= $ch) and ($ch <= 57)) or ($ch == 58) or ((65 <= $ch) and ($ch <= 90)) or ($ch == 95) or ((97 <= $ch) and ($ch <= 116)) or ((118 <= $ch) and ($ch <= 122))) 
{

push (@ch, $ch);

SNAME__2:
{

my $ch = $self->_shift_char;
if (($ch == 45) or ((48 <= $ch) and ($ch <= 57)) or ($ch == 58) or ((65 <= $ch) and ($ch <= 90)) or ($ch == 95) or ((97 <= $ch) and ($ch <= 122))) 
{

push (@ch, $ch);
redo SNAME__2;


}
else 
{

unshift (@{$self->{char}}, $ch);
$ch = -2;


}
shift (@ch);
my $token_val = '';
if ($ch > -1) 
{

push (@ch, $ch);


}
while (@ch) 
{

$token_val .= chr (shift (@ch));


}
return {'type', 'NAME', 'value', $token_val};


}
# SNAME__2


}
elsif ($ch == 117) 
{

push (@ch, $ch);

SNAME__2____RULE__2:
{

my $ch = $self->_shift_char;
if (($ch == 45) or ((48 <= $ch) and ($ch <= 57)) or ($ch == 58) or ((65 <= $ch) and ($ch <= 90)) or ($ch == 95) or ((97 <= $ch) and ($ch <= 107)) or ((109 <= $ch) and ($ch <= 122))) 
{

push (@ch, $ch);

SNAME__2:
{

my $ch = $self->_shift_char;
if (($ch == 45) or ((48 <= $ch) and ($ch <= 57)) or ($ch == 58) or ((65 <= $ch) and ($ch <= 90)) or ($ch == 95) or ((97 <= $ch) and ($ch <= 122))) 
{

push (@ch, $ch);
redo SNAME__2;


}
else 
{

unshift (@{$self->{char}}, $ch);
$ch = -2;


}
shift (@ch);
my $token_val = '';
if ($ch > -1) 
{

push (@ch, $ch);


}
while (@ch) 
{

$token_val .= chr (shift (@ch));


}
return {'type', 'NAME', 'value', $token_val};


}
# SNAME__2


}
elsif ($ch == 108) 
{

push (@ch, $ch);

SNAME__2____RULE__3:
{

my $ch = $self->_shift_char;
if (($ch == 45) or ((48 <= $ch) and ($ch <= 57)) or ($ch == 58) or ((65 <= $ch) and ($ch <= 90)) or ($ch == 95) or ((97 <= $ch) and ($ch <= 100)) or ((102 <= $ch) and ($ch <= 122))) 
{

push (@ch, $ch);

SNAME__2:
{

my $ch = $self->_shift_char;
if (($ch == 45) or ((48 <= $ch) and ($ch <= 57)) or ($ch == 58) or ((65 <= $ch) and ($ch <= 90)) or ($ch == 95) or ((97 <= $ch) and ($ch <= 122))) 
{

push (@ch, $ch);
redo SNAME__2;


}
else 
{

unshift (@{$self->{char}}, $ch);
$ch = -2;


}
shift (@ch);
my $token_val = '';
if ($ch > -1) 
{

push (@ch, $ch);


}
while (@ch) 
{

$token_val .= chr (shift (@ch));


}
return {'type', 'NAME', 'value', $token_val};


}
# SNAME__2


}
elsif ($ch == 101) 
{

push (@ch, $ch);

SNAME__2____RULE__4:
{

my $ch = $self->_shift_char;
if (($ch == 45) or ((48 <= $ch) and ($ch <= 57)) or ($ch == 58) or ((65 <= $ch) and ($ch <= 90)) or ($ch == 95) or ((97 <= $ch) and ($ch <= 122))) 
{

push (@ch, $ch);

SNAME__2:
{

my $ch = $self->_shift_char;
if (($ch == 45) or ((48 <= $ch) and ($ch <= 57)) or ($ch == 58) or ((65 <= $ch) and ($ch <= 90)) or ($ch == 95) or ((97 <= $ch) and ($ch <= 122))) 
{

push (@ch, $ch);
redo SNAME__2;


}
else 
{

unshift (@{$self->{char}}, $ch);
$ch = -2;


}
shift (@ch);
my $token_val = '';
if ($ch > -1) 
{

push (@ch, $ch);


}
while (@ch) 
{

$token_val .= chr (shift (@ch));


}
return {'type', 'NAME', 'value', $token_val};


}
# SNAME__2


}
else 
{

unshift (@{$self->{char}}, $ch);
$ch = -2;


}
shift (@ch);
my $token_val = '';
if ($ch > -1) 
{

push (@ch, $ch);


}
while (@ch) 
{

$token_val .= chr (shift (@ch));


}
return {'type', 'RULE', 'value', $token_val};


}
# SNAME__2____RULE__4


}
else 
{

unshift (@{$self->{char}}, $ch);
$ch = -2;


}
shift (@ch);
my $token_val = '';
if ($ch > -1) 
{

push (@ch, $ch);


}
while (@ch) 
{

$token_val .= chr (shift (@ch));


}
return {'type', 'NAME', 'value', $token_val};


}
# SNAME__2____RULE__3


}
else 
{

unshift (@{$self->{char}}, $ch);
$ch = -2;


}
shift (@ch);
my $token_val = '';
if ($ch > -1) 
{

push (@ch, $ch);


}
while (@ch) 
{

$token_val .= chr (shift (@ch));


}
return {'type', 'NAME', 'value', $token_val};


}
# SNAME__2____RULE__2


}
else 
{

unshift (@{$self->{char}}, $ch);
$ch = -2;


}
shift (@ch);
my $token_val = '';
if ($ch > -1) 
{

push (@ch, $ch);


}
while (@ch) 
{

$token_val .= chr (shift (@ch));


}
return {'type', 'NAME', 'value', $token_val};


}
# SNAME__1____RULE__1


}
elsif ($ch == 109) 
{

push (@ch, $ch);

SNAME__1____mY__1:
{

my $ch = $self->_shift_char;
if (($ch == 45) or ((48 <= $ch) and ($ch <= 57)) or ($ch == 58) or ((65 <= $ch) and ($ch <= 90)) or ($ch == 95) or ((97 <= $ch) and ($ch <= 120)) or ($ch == 122)) 
{

push (@ch, $ch);

SNAME__2:
{

my $ch = $self->_shift_char;
if (($ch == 45) or ((48 <= $ch) and ($ch <= 57)) or ($ch == 58) or ((65 <= $ch) and ($ch <= 90)) or ($ch == 95) or ((97 <= $ch) and ($ch <= 122))) 
{

push (@ch, $ch);
redo SNAME__2;


}
else 
{

unshift (@{$self->{char}}, $ch);
$ch = -2;


}
shift (@ch);
my $token_val = '';
if ($ch > -1) 
{

push (@ch, $ch);


}
while (@ch) 
{

$token_val .= chr (shift (@ch));


}
return {'type', 'NAME', 'value', $token_val};


}
# SNAME__2


}
elsif ($ch == 121) 
{

push (@ch, $ch);

SNAME__2____mY__2:
{

my $ch = $self->_shift_char;
if (($ch == 45) or ((48 <= $ch) and ($ch <= 57)) or ($ch == 58) or ((65 <= $ch) and ($ch <= 90)) or ($ch == 95) or ((97 <= $ch) and ($ch <= 122))) 
{

push (@ch, $ch);

SNAME__2:
{

my $ch = $self->_shift_char;
if (($ch == 45) or ((48 <= $ch) and ($ch <= 57)) or ($ch == 58) or ((65 <= $ch) and ($ch <= 90)) or ($ch == 95) or ((97 <= $ch) and ($ch <= 122))) 
{

push (@ch, $ch);
redo SNAME__2;


}
else 
{

unshift (@{$self->{char}}, $ch);
$ch = -2;


}
shift (@ch);
my $token_val = '';
if ($ch > -1) 
{

push (@ch, $ch);


}
while (@ch) 
{

$token_val .= chr (shift (@ch));


}
return {'type', 'NAME', 'value', $token_val};


}
# SNAME__2


}
else 
{

unshift (@{$self->{char}}, $ch);
$ch = -2;


}
shift (@ch);
my $token_val = '';
if ($ch > -1) 
{

push (@ch, $ch);


}
while (@ch) 
{

$token_val .= chr (shift (@ch));


}
return {'type', 'mY', 'value', $token_val};


}
# SNAME__2____mY__2


}
else 
{

unshift (@{$self->{char}}, $ch);
$ch = -2;


}
shift (@ch);
my $token_val = '';
if ($ch > -1) 
{

push (@ch, $ch);


}
while (@ch) 
{

$token_val .= chr (shift (@ch));


}
return {'type', 'NAME', 'value', $token_val};


}
# SNAME__1____mY__1


}
elsif (($ch == 85) or ($ch == 117)) 
{

push (@ch, $ch);

SCHAR__1____NAME__1:
{

my $ch = $self->_shift_char;
if ($ch == 43) 
{

push (@ch, $ch);

SCHAR__2:
{

my $ch = $self->_shift_char;
if (((48 <= $ch) and ($ch <= 57)) or ((65 <= $ch) and ($ch <= 70)) or ((97 <= $ch) and ($ch <= 102))) 
{

push (@ch, $ch);

SCHAR__3:
{

my $ch = $self->_shift_char;
if (((48 <= $ch) and ($ch <= 57)) or ((65 <= $ch) and ($ch <= 70)) or ((97 <= $ch) and ($ch <= 102))) 
{

push (@ch, $ch);

SCHAR__4:
{

my $ch = $self->_shift_char;
if (((48 <= $ch) and ($ch <= 57)) or ((65 <= $ch) and ($ch <= 70)) or ((97 <= $ch) and ($ch <= 102))) 
{

push (@ch, $ch);

SCHAR__5:
{

my $ch = $self->_shift_char;
if (((48 <= $ch) and ($ch <= 57)) or ((65 <= $ch) and ($ch <= 70)) or ((97 <= $ch) and ($ch <= 102))) 
{

push (@ch, $ch);

SCHAR__6:
{

my $ch = $self->_shift_char;
if (((48 <= $ch) and ($ch <= 57)) or ((65 <= $ch) and ($ch <= 70)) or ((97 <= $ch) and ($ch <= 102))) 
{

push (@ch, $ch);
redo SCHAR__6;


}
else 
{

unshift (@{$self->{char}}, $ch);
$ch = -2;


}
shift (@ch);
my $token_val = '';
if ($ch > -1) 
{

push (@ch, $ch);


}
while (@ch) 
{

$token_val .= chr (shift (@ch));


}
return {'type', 'CHAR', 'value', $token_val};


}
# SCHAR__6


}
unshift (@{$self->{char}}, $ch);


}
# SCHAR__5


}
unshift (@{$self->{char}}, $ch);


}
# SCHAR__4


}
unshift (@{$self->{char}}, $ch);


}
# SCHAR__3


}
unshift (@{$self->{char}}, $ch);


}
# SCHAR__2


}
elsif (($ch == 45) or ((48 <= $ch) and ($ch <= 57)) or ($ch == 58) or ((65 <= $ch) and ($ch <= 90)) or ($ch == 95) or ((97 <= $ch) and ($ch <= 122))) 
{

push (@ch, $ch);

SNAME__2:
{

my $ch = $self->_shift_char;
if (($ch == 45) or ((48 <= $ch) and ($ch <= 57)) or ($ch == 58) or ((65 <= $ch) and ($ch <= 90)) or ($ch == 95) or ((97 <= $ch) and ($ch <= 122))) 
{

push (@ch, $ch);
redo SNAME__2;


}
else 
{

unshift (@{$self->{char}}, $ch);
$ch = -2;


}
shift (@ch);
my $token_val = '';
if ($ch > -1) 
{

push (@ch, $ch);


}
while (@ch) 
{

$token_val .= chr (shift (@ch));


}
return {'type', 'NAME', 'value', $token_val};


}
# SNAME__2


}
else 
{

unshift (@{$self->{char}}, $ch);
$ch = -2;


}
shift (@ch);
my $token_val = '';
if ($ch > -1) 
{

push (@ch, $ch);


}
while (@ch) 
{

$token_val .= chr (shift (@ch));


}
return {'type', 'NAME', 'value', $token_val};


}
# SCHAR__1____NAME__1


}
elsif ($ch == 36) 
{

push (@ch, $ch);

SVARIABLE__1:
{

my $ch = $self->_shift_char;
if (($ch == 45) or ((65 <= $ch) and ($ch <= 90)) or ($ch == 95) or ((97 <= $ch) and ($ch <= 122))) 
{

push (@ch, $ch);

SVARIABLE__NAME__1:
{

my $ch = $self->_shift_char;
if (($ch == 45) or ((48 <= $ch) and ($ch <= 57)) or ($ch == 58) or ((65 <= $ch) and ($ch <= 90)) or ($ch == 95) or ((97 <= $ch) and ($ch <= 122))) 
{

push (@ch, $ch);

SVARIABLE__NAME__2:
{

my $ch = $self->_shift_char;
if (($ch == 45) or ((48 <= $ch) and ($ch <= 57)) or ($ch == 58) or ((65 <= $ch) and ($ch <= 90)) or ($ch == 95) or ((97 <= $ch) and ($ch <= 122))) 
{

push (@ch, $ch);
redo SVARIABLE__NAME__2;


}
else 
{

unshift (@{$self->{char}}, $ch);
$ch = -2;


}
shift (@ch);
my $token_val = '';
if ($ch > -1) 
{

push (@ch, $ch);


}
while (@ch) 
{

$token_val .= chr (shift (@ch));


}
return {'type', 'VARIABLE', 'value', $token_val};


}
# SVARIABLE__NAME__2


}
else 
{

unshift (@{$self->{char}}, $ch);
$ch = -2;


}
shift (@ch);
my $token_val = '';
if ($ch > -1) 
{

push (@ch, $ch);


}
while (@ch) 
{

$token_val .= chr (shift (@ch));


}
return {'type', 'VARIABLE', 'value', $token_val};


}
# SVARIABLE__NAME__1


}
unshift (@{$self->{char}}, $ch);


}
# SVARIABLE__1


}
elsif ($ch == 38) 
{

push (@ch, $ch);

SRULEREF__1:
{

my $ch = $self->_shift_char;
if (($ch == 45) or ((65 <= $ch) and ($ch <= 90)) or ($ch == 95) or ((97 <= $ch) and ($ch <= 122))) 
{

push (@ch, $ch);

SRULEREF__NAME__1:
{

my $ch = $self->_shift_char;
if (($ch == 45) or ((48 <= $ch) and ($ch <= 57)) or ($ch == 58) or ((65 <= $ch) and ($ch <= 90)) or ($ch == 95) or ((97 <= $ch) and ($ch <= 122))) 
{

push (@ch, $ch);

SRULEREF__NAME__2:
{

my $ch = $self->_shift_char;
if (($ch == 45) or ((48 <= $ch) and ($ch <= 57)) or ($ch == 58) or ((65 <= $ch) and ($ch <= 90)) or ($ch == 95) or ((97 <= $ch) and ($ch <= 122))) 
{

push (@ch, $ch);
redo SRULEREF__NAME__2;


}
else 
{

unshift (@{$self->{char}}, $ch);
$ch = -2;


}
shift (@ch);
my $token_val = '';
if ($ch > -1) 
{

push (@ch, $ch);


}
while (@ch) 
{

$token_val .= chr (shift (@ch));


}
return {'type', 'RULEREF', 'value', $token_val};


}
# SRULEREF__NAME__2


}
else 
{

unshift (@{$self->{char}}, $ch);
$ch = -2;


}
shift (@ch);
my $token_val = '';
if ($ch > -1) 
{

push (@ch, $ch);


}
while (@ch) 
{

$token_val .= chr (shift (@ch));


}
return {'type', 'RULEREF', 'value', $token_val};


}
# SRULEREF__NAME__1


}
unshift (@{$self->{char}}, $ch);


}
# SRULEREF__1


}
elsif ($ch == 39) 
{

push (@ch, $ch);

SSTRING__1:
{

my $ch = $self->_shift_char;
if (((0 <= $ch) and ($ch <= 38)) or ((40 <= $ch) and ($ch <= 91)) or 93 <= $ch) 
{

push (@ch, $ch);

SSTRING__2:
{

my $ch = $self->_shift_char;
if (((0 <= $ch) and ($ch <= 38)) or ((40 <= $ch) and ($ch <= 91)) or 93 <= $ch) 
{

push (@ch, $ch);
redo SSTRING__2;


}
elsif ($ch == 39) 
{


SSTRING__3:
{

shift (@ch);
my $token_val = '';
if ($ch > -1) 
{

push (@ch, $ch);


}
while (@ch) 
{

$token_val .= chr (shift (@ch));


}
return {'type', 'STRING', 'value', $token_val};


}
# SSTRING__3


}
unshift (@{$self->{char}}, $ch);


}
# SSTRING__2


}
elsif ($ch == 39) 
{


SSTRING__3:
{

shift (@ch);
my $token_val = '';
if ($ch > -1) 
{

push (@ch, $ch);


}
while (@ch) 
{

$token_val .= chr (shift (@ch));


}
return {'type', 'STRING', 'value', $token_val};


}
# SSTRING__3


}
unshift (@{$self->{char}}, $ch);


}
# SSTRING__1


}
elsif ($ch == 44) 
{


SCOMMA__1:
{

return {'type', 'COMMA'};


}
# SCOMMA__1


}
elsif ($ch == 61) 
{

push (@ch, $ch);

SASSIGN__1____REPLACE__1:
{

my $ch = $self->_shift_char;
if ($ch == 62) 
{


SREPLACE__2:
{

return {'type', 'REPLACE'};


}
# SREPLACE__2


}
else 
{

unshift (@{$self->{char}}, $ch);
$ch = -2;


}
return {'type', 'ASSIGN'};


}
# SASSIGN__1____REPLACE__1


}
elsif ($ch == 58) 
{

push (@ch, $ch);

SCOLON__1____DEFINE__1:
{

my $ch = $self->_shift_char;
if ($ch == 61) 
{


SDEFINE__2:
{

return {'type', 'DEFINE'};


}
# SDEFINE__2


}
else 
{

unshift (@{$self->{char}}, $ch);
$ch = -2;


}
return {'type', 'COLON'};


}
# SCOLON__1____DEFINE__1


}
elsif ($ch == 40) 
{


SLPAREN__1:
{

return {'type', 'LPAREN'};


}
# SLPAREN__1


}
elsif ($ch == 41) 
{


SRPAREN__1:
{

return {'type', 'RPAREN'};


}
# SRPAREN__1


}
elsif ($ch == 123) 
{


SLBRACE__1:
{

return {'type', 'LBRACE'};


}
# SLBRACE__1


}
elsif ($ch == 125) 
{


SRBRACE__1:
{

return {'type', 'RBRACE'};


}
# SRBRACE__1


}
elsif ($ch == 91) 
{

push (@ch, $ch);

SCLSOPEN__1____NCLSOPEN__1:
{

my $ch = $self->_shift_char;
if ($ch == 94) 
{


SNCLSOPEN__2:
{

return {'type', 'NCLSOPEN'};


}
# SNCLSOPEN__2


}
else 
{

unshift (@{$self->{char}}, $ch);
$ch = -2;


}
return {'type', 'CLSOPEN'};


}
# SCLSOPEN__1____NCLSOPEN__1


}
elsif ($ch == 93) 
{


SCLSCLOSE__1:
{

return {'type', 'CLSCLOSE'};


}
# SCLSCLOSE__1


}
elsif ($ch == 42) 
{


SZEROMORE__1:
{

return {'type', 'ZEROMORE'};


}
# SZEROMORE__1


}
elsif ($ch == 43) 
{


SONEMORE__1:
{

return {'type', 'ONEMORE'};


}
# SONEMORE__1


}
elsif ($ch == 63) 
{


SZEROONE__1:
{

return {'type', 'ZEROONE'};


}
# SZEROONE__1


}
elsif ($ch == 126) 
{


SMATCH__1:
{

return {'type', 'MATCH'};


}
# SMATCH__1


}
elsif ($ch == 46) 
{

push (@ch, $ch);

SDOT__1____RANGE__1:
{

my $ch = $self->_shift_char;
if ($ch == 46) 
{


SRANGE__2:
{

return {'type', 'RANGE'};


}
# SRANGE__2


}
else 
{

unshift (@{$self->{char}}, $ch);
$ch = -2;


}
return {'type', 'DOT'};


}
# SDOT__1____RANGE__1


}
elsif ($ch == -1) 
{

return {'type', '#EOF'};


}
return {'type', '#INVALID', 'value', chr ($ch)};


}
# S__initial
}
sub _parse_CodeBlock ($$$) {
my ($self, $doc, $parent) = @_;
my $token;
$token = $self->_shift_token;
if ($token->{type} eq 'LBRACE') 
{

$token = $self->_shift_token;


}
else 
{

die;


}
my $block;

{



    $block = $doc->
create_element_ns
 (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'codeBlock');
    $parent->
append_child
 ($block);
  


;}

MATCH_1:
{

if ($token->{type} eq 'MATCH') 
{

my $match;

{



      $match = $doc->
create_element_ns
 (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'matchStatement');
      $block->
append_child
 ($match);
    


;}
$token = $self->_shift_token;
if ($token->{type} eq 'ZEROMORE') 
{


{



          $match->
set_attribute_ns
 (
undef
, 'occurence', 'zeromore');
        


;}
$token = $self->_shift_token;


}
elsif ($token->{type} eq 'ONEMORE') 
{


{



          $match->
set_attribute_ns
 (
undef
, 'occurence', 'onemore');
        


;}
$token = $self->_shift_token;


}
elsif ($token->{type} eq 'ZEROONE') 
{


{



          $match->
set_attribute_ns
 (
undef
, 'occurence', 'zeroone');
        


;}
$token = $self->_shift_token;


}

{

my $has_content = 0;

MATCH_2:
{

if ($token->{type} eq 'LPAREN') 
{

$has_content = 1;
my $match_block;

{



          $match_block = $doc->
create_element_ns
 (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'matchBlock');
          $match->
append_child
 ($match_block);
        


;}
$token = $self->_shift_token;
if ($token->{type} eq 'NAME') 
{


{



            $match_block->
set_attribute_ns
 (
undef
, 'token', $token->{value});
          


;}
$token = $self->_shift_token;


}
else 
{

die;


}
if ($token->{type} eq 'RPAREN') 
{

$token = $self->_shift_token;


}
else 
{

die;


}

{

my $doc = $doc;
my $parent = $match_block;

MATCH_3:
{

if ($token->{type} eq 'COLON') 
{

$token = $self->_shift_token;
if ($token->{type} eq 'NAME') 
{

my $ael;

{



        $ael = $doc->
create_element_ns

                          (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'attributeSpecification');
        $ael->
set_attribute_ns
 (
undef
, 'name', $token->{value});
        $ael->
set_attribute_ns
 (
undef
, 'value', '1');
        $parent->
append_child
 ($ael);
      


;}
$token = $self->_shift_token;
if ($token->{type} eq 'ZEROMORE') 
{


{



          $ael->
set_attribute_ns
 (
undef
, 'occurence', 'zeromore');
        


;}
$token = $self->_shift_token;


}
elsif ($token->{type} eq 'ONEMORE') 
{


{



          $ael->
set_attribute_ns
 (
undef
, 'occurence', 'onemore');
        


;}
$token = $self->_shift_token;


}
elsif ($token->{type} eq 'ZEROONE') 
{


{



          $ael->
set_attribute_ns
 (
undef
, 'occurence', 'zeroone');
        


;}
$token = $self->_shift_token;


}


}
else 
{

die;


}


}
else 
{

last MATCH_3;


}
redo MATCH_3;


}
# MATCH_3


}
push (@{$self->{token}}, $token);
$self->_parse_CodeBlock ($doc, $match_block);
$token = $self->_shift_token;


}
else 
{

if ($has_content == 0) 
{

die;


}
last MATCH_2;


}
redo MATCH_2;


}
# MATCH_2


}


}
elsif ($token->{type} eq 'NAME') 
{

my $embed;

{



      ## TODO: Expand QName
      $embed = $doc->
create_element_ns
 (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'embedStatement');
      $embed->
set_attribute_ns
 (
undef
, 'type', $token->{value});
      $block->
append_child
 ($embed);
    


;}

{

my $doc = $doc;
my $parent = $embed;
$token = $self->_shift_token;
if ($token->{type} eq 'LPAREN') 
{

$token = $self->_shift_token;

MATCH_4:
{

if ($token->{type} eq 'VARIABLE') 
{

my $param;

{



        $param = $doc->
create_element_ns
 (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'parameterSpecification');
        $parent->
append_child
 ($param);
        $param->
set_attribute_ns
 (
undef
, 'name', substr ($token->{value}, 1));
      


;}
$token = $self->_shift_token;
if ($token->{type} eq 'REPLACE') 
{

$token = $self->_shift_token;


}
else 
{

die;


}

{

my $doc = $doc;
my $parent = $param;
if ($token->{type} eq 'STRING') 
{


{


      my 
$str = $doc->
create_element_ns
 (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'string');
      $str->
text_content
 (substr ($token->{value}, 1, length ($token->{value}) - 2));
      $parent->
append_child
 ($str);
    


;}
$token = $self->_shift_token;


}
elsif ($token->{type} eq 'VARIABLE') 
{

my $memref;

{



      $memref = $doc->
create_element_ns
 (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'memberRef');
      my $var = $doc->
create_element_ns
 (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'variable');
      $var->
set_attribute_ns
 (
undef
, 'name', substr ($token->{value}, 1));
      $memref->
append_child
 ($var);
      $parent->
append_child
 ($memref);
    


;}
$token = $self->_shift_token;

MATCH_5:
{

if ($token->{type} eq 'DOT') 
{

$token = $self->_shift_token;
if ($token->{type} eq 'NAME') 
{


{


          my 
$mem = $doc->
create_element_ns
 (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'member');
          $mem->
set_attribute_ns
 (
undef
, 'name', $token->{value});
          $memref->
append_child
 ($mem);
        


;}
$token = $self->_shift_token;


}
else 
{

die;


}


}
else 
{

last MATCH_5;


}
redo MATCH_5;


}
# MATCH_5


}
else 
{

die;


}


}


}
if ($token->{type} eq 'COMMA') 
{

$token = $self->_shift_token;
redo MATCH_4;


}
else 
{

last MATCH_4;


}


}
# MATCH_4
if ($token->{type} eq 'RPAREN') 
{

$token = $self->_shift_token;


}
else 
{

die;


}


}


}
$self->_parse_nested_block_as_text ($doc, $embed, '{', '}', '');
$token = $self->_shift_token;


}
elsif ($token->{type} eq 'RULEREF') 
{

my $ruleref;

{



      $ruleref = $doc->
create_element_ns
 (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'ruleRefStatement');
      $ruleref->
set_attribute_ns
 (
undef
, 'name', substr ($token->{value}, 1));
      $block->
append_child
 ($ruleref);
    


;}

{

my $doc = $doc;
my $parent = $ruleref;
$token = $self->_shift_token;
if ($token->{type} eq 'LPAREN') 
{

$token = $self->_shift_token;

MATCH_4:
{

if ($token->{type} eq 'VARIABLE') 
{

my $param;

{



        $param = $doc->
create_element_ns
 (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'parameterSpecification');
        $parent->
append_child
 ($param);
        $param->
set_attribute_ns
 (
undef
, 'name', substr ($token->{value}, 1));
      


;}
$token = $self->_shift_token;
if ($token->{type} eq 'REPLACE') 
{

$token = $self->_shift_token;


}
else 
{

die;


}

{

my $doc = $doc;
my $parent = $param;
if ($token->{type} eq 'STRING') 
{


{


      my 
$str = $doc->
create_element_ns
 (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'string');
      $str->
text_content
 (substr ($token->{value}, 1, length ($token->{value}) - 2));
      $parent->
append_child
 ($str);
    


;}
$token = $self->_shift_token;


}
elsif ($token->{type} eq 'VARIABLE') 
{

my $memref;

{



      $memref = $doc->
create_element_ns
 (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'memberRef');
      my $var = $doc->
create_element_ns
 (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'variable');
      $var->
set_attribute_ns
 (
undef
, 'name', substr ($token->{value}, 1));
      $memref->
append_child
 ($var);
      $parent->
append_child
 ($memref);
    


;}
$token = $self->_shift_token;

MATCH_5:
{

if ($token->{type} eq 'DOT') 
{

$token = $self->_shift_token;
if ($token->{type} eq 'NAME') 
{


{


          my 
$mem = $doc->
create_element_ns
 (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'member');
          $mem->
set_attribute_ns
 (
undef
, 'name', $token->{value});
          $memref->
append_child
 ($mem);
        


;}
$token = $self->_shift_token;


}
else 
{

die;


}


}
else 
{

last MATCH_5;


}
redo MATCH_5;


}
# MATCH_5


}
else 
{

die;


}


}


}
if ($token->{type} eq 'COMMA') 
{

$token = $self->_shift_token;
redo MATCH_4;


}
else 
{

last MATCH_4;


}


}
# MATCH_4
if ($token->{type} eq 'RPAREN') 
{

$token = $self->_shift_token;


}
else 
{

die;


}


}


}
$token = $self->_shift_token;
if ($token->{type} eq 'SEMICOLON') 
{

$token = $self->_shift_token;


}
else 
{

die;


}


}
elsif ($token->{type} eq 'VARIABLE') 
{

my $assign;
my $lvalue;

{



      $assign = $doc->
create_element_ns
 (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'assignmentStatement');
      $lvalue = $doc->
create_element_ns
 (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'memberRef');
      my $var = $doc->
create_element_ns
 (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'variable');
      $var->
set_attribute_ns
 (
undef
, 'name', substr ($token->{value}, 1));
      $lvalue->
append_child
 ($var);
      $assign->
append_child
 ($lvalue);
      $block->
append_child
 ($assign);
    


;}
$token = $self->_shift_token;

MATCH_6:
{

if ($token->{type} eq 'DOT') 
{

$token = $self->_shift_token;
if ($token->{type} eq 'NAME') 
{


{


          my 
$mem = $doc->
create_element_ns
 (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'member');
          $mem->
set_attribute_ns
 (
undef
, 'name', $token->{value});
          $lvalue->
append_child
 ($mem);
        


;}
$token = $self->_shift_token;


}
else 
{

die;


}


}
else 
{

last MATCH_6;


}
redo MATCH_6;


}
# MATCH_6
if ($token->{type} eq 'ASSIGN') 
{

$token = $self->_shift_token;


}
else 
{

die;


}

{

my $doc = $doc;
my $parent = $assign;
if ($token->{type} eq 'STRING') 
{


{


      my 
$str = $doc->
create_element_ns
 (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'string');
      $str->
text_content
 (substr ($token->{value}, 1, length ($token->{value}) - 2));
      $parent->
append_child
 ($str);
    


;}
$token = $self->_shift_token;


}
elsif ($token->{type} eq 'VARIABLE') 
{

my $memref;

{



      $memref = $doc->
create_element_ns
 (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'memberRef');
      my $var = $doc->
create_element_ns
 (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'variable');
      $var->
set_attribute_ns
 (
undef
, 'name', substr ($token->{value}, 1));
      $memref->
append_child
 ($var);
      $parent->
append_child
 ($memref);
    


;}
$token = $self->_shift_token;

MATCH_5:
{

if ($token->{type} eq 'DOT') 
{

$token = $self->_shift_token;
if ($token->{type} eq 'NAME') 
{


{


          my 
$mem = $doc->
create_element_ns
 (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'member');
          $mem->
set_attribute_ns
 (
undef
, 'name', $token->{value});
          $memref->
append_child
 ($mem);
        


;}
$token = $self->_shift_token;


}
else 
{

die;


}


}
else 
{

last MATCH_5;


}
redo MATCH_5;


}
# MATCH_5


}
else 
{

die;


}


}
if ($token->{type} eq 'SEMICOLON') 
{

$token = $self->_shift_token;


}
else 
{

die;


}


}
elsif ($token->{type} eq 'mY') 
{

$token = $self->_shift_token;
if ($token->{type} eq 'VARIABLE') 
{

my $my;

{



        $my = $doc->
create_element_ns
 (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'myStatement');
        $my->
set_attribute_ns
 (
undef
, 'name', substr ($token->{value}, 1));
        $block->
append_child
 ($my);
      


;}
$token = $self->_shift_token;


}
else 
{

die;


}
if ($token->{type} eq 'SEMICOLON') 
{

$token = $self->_shift_token;


}
else 
{

die;


}


}
else 
{

last MATCH_1;


}
redo MATCH_1;


}
# MATCH_1
if ($token->{type} eq 'RBRACE') 
{

$token = $self->_shift_token;


}
else 
{

die;


}
push (@{$self->{token}}, $token);
}
sub _parse_Rules ($$) {
my ($self, $impl) = @_;
my $token;
my $doc;
my $docel;

{



    $doc = $impl->
create_document

                    (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'rules');
    $docel = $doc->
document_element
;
  


;}
$token = $self->_shift_token;

MATCH_7:
{

if ($token->{type} eq 'RULE') 
{


{

my $doc = $doc;
my $parent = $docel;
my $el;

{



    $el = $doc->
create_element_ns
 (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'rule');
    $parent->
append_child
 ($el);
  


;}
$token = $self->_shift_token;
if ($token->{type} eq 'NAME') 
{


{



      $el->
set_attribute_ns
 (
undef
, 'name', $token->{value});
    


;}
$token = $self->_shift_token;


}
else 
{

die;


}
if ($token->{type} eq 'LPAREN') 
{

$token = $self->_shift_token;

MATCH_8:
{

if ($token->{type} eq 'VARIABLE') 
{


{


        my 
$pel = $doc->
create_element_ns

                          (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'parameterDeclaration');
        $pel->
set_attribute_ns
 (
undef
, 'name', substr ($token->{value}, 1));
        $el->
append_child
 ($pel);
      


;}
$token = $self->_shift_token;


}
if ($token->{type} eq 'COMMA') 
{

$token = $self->_shift_token;
redo MATCH_8;


}
else 
{

last MATCH_8;


}


}
# MATCH_8
if ($token->{type} eq 'RPAREN') 
{

$token = $self->_shift_token;


}
else 
{

die;


}


}

{

my $doc = $doc;
my $parent = $el;

MATCH_3:
{

if ($token->{type} eq 'COLON') 
{

$token = $self->_shift_token;
if ($token->{type} eq 'NAME') 
{

my $ael;

{



        $ael = $doc->
create_element_ns

                          (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'attributeSpecification');
        $ael->
set_attribute_ns
 (
undef
, 'name', $token->{value});
        $ael->
set_attribute_ns
 (
undef
, 'value', '1');
        $parent->
append_child
 ($ael);
      


;}
$token = $self->_shift_token;
if ($token->{type} eq 'ZEROMORE') 
{


{



          $ael->
set_attribute_ns
 (
undef
, 'occurence', 'zeromore');
        


;}
$token = $self->_shift_token;


}
elsif ($token->{type} eq 'ONEMORE') 
{


{



          $ael->
set_attribute_ns
 (
undef
, 'occurence', 'onemore');
        


;}
$token = $self->_shift_token;


}
elsif ($token->{type} eq 'ZEROONE') 
{


{



          $ael->
set_attribute_ns
 (
undef
, 'occurence', 'zeroone');
        


;}
$token = $self->_shift_token;


}


}
else 
{

die;


}


}
else 
{

last MATCH_3;


}
redo MATCH_3;


}
# MATCH_3


}
push (@{$self->{token}}, $token);
$self->_parse_CodeBlock ($doc, $el);


}
$token = $self->_shift_token;


}
elsif ($token->{type} eq 'lEXMODE') 
{


{

my $doc = $doc;
my $parent = $docel;
my $el;

{



    $el = $doc->
create_element_ns
 (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'lexmode');
    $parent->
append_child
 ($el);
  


;}
$token = $self->_shift_token;
if ($token->{type} eq 'NAME') 
{


{



      $el->
set_attribute_ns
 (
undef
, 'name', $token->{value});
    


;}
$token = $self->_shift_token;


}
else 
{

die;


}

{

my $doc = $doc;
my $parent = $el;

MATCH_3:
{

if ($token->{type} eq 'COLON') 
{

$token = $self->_shift_token;
if ($token->{type} eq 'NAME') 
{

my $ael;

{



        $ael = $doc->
create_element_ns

                          (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'attributeSpecification');
        $ael->
set_attribute_ns
 (
undef
, 'name', $token->{value});
        $ael->
set_attribute_ns
 (
undef
, 'value', '1');
        $parent->
append_child
 ($ael);
      


;}
$token = $self->_shift_token;
if ($token->{type} eq 'ZEROMORE') 
{


{



          $ael->
set_attribute_ns
 (
undef
, 'occurence', 'zeromore');
        


;}
$token = $self->_shift_token;


}
elsif ($token->{type} eq 'ONEMORE') 
{


{



          $ael->
set_attribute_ns
 (
undef
, 'occurence', 'onemore');
        


;}
$token = $self->_shift_token;


}
elsif ($token->{type} eq 'ZEROONE') 
{


{



          $ael->
set_attribute_ns
 (
undef
, 'occurence', 'zeroone');
        


;}
$token = $self->_shift_token;


}


}
else 
{

die;


}


}
else 
{

last MATCH_3;


}
redo MATCH_3;


}
# MATCH_3


}
if ($token->{type} eq 'LBRACE') 
{

$token = $self->_shift_token;


}
else 
{

die;


}

MATCH_9:
{

if ($token->{type} eq 'NAME') 
{

my $lassign;

{



      $lassign = $doc->
create_element_ns
 (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'lAssignmentStatement');
      $lassign->
set_attribute_ns
 (
undef
, 'name', $token->{value});
      $el->
append_child
 ($lassign);
    


;}

{

my $doc = $doc;
my $parent = $lassign;
$token = $self->_shift_token;

MATCH_10:
{

if ($token->{type} eq 'COLON') 
{

$token = $self->_shift_token;
if ($token->{type} eq 'NAME') 
{

my $ael;

{



        $ael = $doc->
create_element_ns

                          (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'attributeSpecification');
        $ael->
set_attribute_ns
 (
undef
, 'name', $token->{value});
        $ael->
set_attribute_ns
 (
undef
, 'value', '1');
        $parent->
append_child
 ($ael);
      


;}
$token = $self->_shift_token;
if ($token->{type} eq 'ZEROMORE') 
{


{



          $ael->
set_attribute_ns
 (
undef
, 'occurence', 'zeromore');
        


;}
$token = $self->_shift_token;


}
elsif ($token->{type} eq 'ONEMORE') 
{


{



          $ael->
set_attribute_ns
 (
undef
, 'occurence', 'onemore');
        


;}
$token = $self->_shift_token;


}
elsif ($token->{type} eq 'ZEROONE') 
{


{



          $ael->
set_attribute_ns
 (
undef
, 'occurence', 'zeroone');
        


;}
$token = $self->_shift_token;


}


}
else 
{

die;


}


}
else 
{

last MATCH_10;


}
redo MATCH_10;


}
# MATCH_10


}
if ($token->{type} eq 'DEFINE') 
{

$token = $self->_shift_token;


}
else 
{

die;


}

MATCH_11:
{

if ($token->{type} eq 'CLSOPEN') 
{

my $cls;

{



        $cls = $doc->
create_element_ns
 (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'charClass');
        $lassign->
append_child
 ($cls);
      


;}

{

my $doc = $doc;
my $parent = $cls;
$token = $self->_shift_token;

{

my $has_content = 0;

MATCH_12:
{

if ($token->{type} eq 'STRING') 
{

$has_content = 1;

{


      my 
$str = $doc->
create_element_ns
 (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'string');
      $str->
text_content
 (substr ($token->{value}, 1, length ($token->{value}) - 2));
      $parent->
append_child
 ($str);
    


;}
$token = $self->_shift_token;


}
elsif ($token->{type} eq 'CHAR') 
{

$has_content = 1;
my $char;

{



      $char = $doc->
create_element_ns
 (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'charRange');
      my $code = $token->{value};
      $code =~ s/^U\+/0x/;
      $char->
set_attribute_ns
 (
undef
, 'start', hex $code);
      $char->
set_attribute_ns
 (
undef
, 'end', hex $code);
      $parent->
append_child
 ($char);
    


;}
$token = $self->_shift_token;
if ($token->{type} eq 'RANGE') 
{

$token = $self->_shift_token;
if ($token->{type} eq 'CHAR') 
{


{


          my 
$code = $token->{value};
          $code =~ s/^U\+/0x/;
          $char->
set_attribute_ns
 (
undef
, 'end', hex $code);
        


;}
$token = $self->_shift_token;


}
else 
{

die;


}


}


}
else 
{

if ($has_content == 0) 
{

die;


}
last MATCH_12;


}
redo MATCH_12;


}
# MATCH_12


}
if ($token->{type} eq 'CLSCLOSE') 
{

$token = $self->_shift_token;


}
else 
{

die;


}
if ($token->{type} eq 'ZEROMORE') 
{


{



      $parent->
set_attribute_ns
 (
undef
, 'occurence', 'zeromore');
    


;}
$token = $self->_shift_token;


}
elsif ($token->{type} eq 'ONEMORE') 
{


{



      $parent->
set_attribute_ns
 (
undef
, 'occurence', 'onemore');
    


;}
$token = $self->_shift_token;


}
elsif ($token->{type} eq 'ZEROONE') 
{


{



      $parent->
set_attribute_ns
 (
undef
, 'occurence', 'zeroone');
    


;}
$token = $self->_shift_token;


}


}


}
elsif ($token->{type} eq 'NCLSOPEN') 
{

my $cls;

{



        $cls = $doc->
create_element_ns
 (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'charClass');
        $cls->
set_attribute_ns
 (
undef
, 'negative', '1');
        $lassign->
append_child
 ($cls);
      


;}

{

my $doc = $doc;
my $parent = $cls;
$token = $self->_shift_token;

{

my $has_content = 0;

MATCH_12:
{

if ($token->{type} eq 'STRING') 
{

$has_content = 1;

{


      my 
$str = $doc->
create_element_ns
 (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'string');
      $str->
text_content
 (substr ($token->{value}, 1, length ($token->{value}) - 2));
      $parent->
append_child
 ($str);
    


;}
$token = $self->_shift_token;


}
elsif ($token->{type} eq 'CHAR') 
{

$has_content = 1;
my $char;

{



      $char = $doc->
create_element_ns
 (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'charRange');
      my $code = $token->{value};
      $code =~ s/^U\+/0x/;
      $char->
set_attribute_ns
 (
undef
, 'start', hex $code);
      $char->
set_attribute_ns
 (
undef
, 'end', hex $code);
      $parent->
append_child
 ($char);
    


;}
$token = $self->_shift_token;
if ($token->{type} eq 'RANGE') 
{

$token = $self->_shift_token;
if ($token->{type} eq 'CHAR') 
{


{


          my 
$code = $token->{value};
          $code =~ s/^U\+/0x/;
          $char->
set_attribute_ns
 (
undef
, 'end', hex $code);
        


;}
$token = $self->_shift_token;


}
else 
{

die;


}


}


}
else 
{

if ($has_content == 0) 
{

die;


}
last MATCH_12;


}
redo MATCH_12;


}
# MATCH_12


}
if ($token->{type} eq 'CLSCLOSE') 
{

$token = $self->_shift_token;


}
else 
{

die;


}
if ($token->{type} eq 'ZEROMORE') 
{


{



      $parent->
set_attribute_ns
 (
undef
, 'occurence', 'zeromore');
    


;}
$token = $self->_shift_token;


}
elsif ($token->{type} eq 'ONEMORE') 
{


{



      $parent->
set_attribute_ns
 (
undef
, 'occurence', 'onemore');
    


;}
$token = $self->_shift_token;


}
elsif ($token->{type} eq 'ZEROONE') 
{


{



      $parent->
set_attribute_ns
 (
undef
, 'occurence', 'zeroone');
    


;}
$token = $self->_shift_token;


}


}
$token = $self->_shift_token;


}
elsif ($token->{type} eq 'NAME') 
{


{


        my 
$lname = $doc->
create_element_ns
 (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'lRuleRef');
        $lname->
set_attribute_ns
 (
undef
, 'name', $token->{value});
        $lassign->
append_child
 ($lname);
      


;}
$token = $self->_shift_token;


}
else 
{

last MATCH_11;


}
redo MATCH_11;


}
# MATCH_11
if ($token->{type} eq 'SEMICOLON') 
{

$token = $self->_shift_token;


}
else 
{

die;


}


}
else 
{

last MATCH_9;


}
redo MATCH_9;


}
# MATCH_9
if ($token->{type} eq 'RBRACE') 
{

$token = $self->_shift_token;


}
else 
{

die;


}


}


}
else 
{

last MATCH_7;


}
redo MATCH_7;


}
# MATCH_7
if ($token->{type} eq '#EOF') 
{

$token = $self->_shift_token;


}
else 
{

die;


}
push (@{$self->{token}}, $token);
return $doc;
}
$Message::DOM::ClassFeature{q<Message::Util::DIS::DPG::ManakaiDPGParser>} = {'http://suika.fam.cx/~wakaba/archive/2005/manakai/util/dis#dpg', {'', '1', '1.0', '1'}};
$Message::DOM::ClassPoint{q<Message::Util::DIS::DPG::ManakaiDPGParser>} = 1;
$Message::DOM::DOMLS::ParserClass{q<Message::Util::DIS::DPG::ManakaiDPGParser>} = 1;
for ($Message::DOM::IFLatest::Document::, $Message::DOM::IFLatest::Element::, $Message::DOM::IFLatest::Node::){}
## License: <http://suika.fam.cx/~wakaba/archive/2004/8/18/license#Perl+MPL>
1;
