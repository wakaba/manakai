#!/usr/bin/perl 
## This file is automatically generated
## 	at 2006-04-01T06:04:39+00:00,
## 	from file "DIS/DPG.dis",
## 	module <http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS#DPG>,
## 	for <http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#ManakaiDOMLatest>.
## Don't edit by hand!
use strict;
require Message::DOM::DOMCore;
require Message::DOM::TreeCore;
require Message::Util::Error;
require Message::Util::Error::DOMException;
package Message::Util::DIS::DPG;
our $VERSION = 20060401.0604;
$Message::DOM::DOMCore::ManakaiDOMConfiguration{'Message::Util::IF::DPGParser'}->{'error-handler'} = {'checker',
sub ($$$) {
my ($self, $name, $value) = @_;

{


$name = lc $name;


;}

{


$value = bless $value, 
'Message::DOM::DOMCore::ManakaiDOMErrorHandler'
  if 
ref $value eq 'CODE';


;}
my $r = 0;

{


$r = UNIVERSAL::isa ($value, 
'Message::DOM::IFLatest::DOMErrorHandler'
);


;}
$r}
,
'get_default',
sub ($$) {
my ($self, $name) = @_;

{


$name = lc $name;


;}
my $r;

{


$r = sub {
  my (undef, $err) = @_;
  CORE::warn $err;
  return ($err->
severity
 !=
          
3
);
};


;}

{


$r = bless $r, 
'Message::DOM::DOMCore::ManakaiDOMErrorHandler'
  if 
ref $r eq 'CODE';


;}
$r}
,
'iname',
'onerr',
'otype',
'Message::DOM::IFLatest::DOMErrorHandler',
'setter',
sub ($$$) {
my ($self, $name, $value) = @_;

{


$name = lc $name;


;}

{


$value = bless $value, 
'Message::DOM::DOMCore::ManakaiDOMErrorHandler'
  if 
ref $value eq 'CODE';


;}

{


$self->[1]->{
'onerr'
} = $value;


;}
}
,
'type',
'object'};
$Message::DOM::DOMCore::ManakaiDOMError::Def{'http://suika.fam.cx/~wakaba/archive/2005/11/pg/bad-token-error'} = {'description',
'Token |%dpg-error-token-type;|%dpg-error-token-value (prefix => { (|}, suffix => {|)}); is not allowed %dpg-error-lines (prefix => {(|}, suffix => {|)});',
'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/Core/textFormatter',
'Message::Util::DIS::DPG::ManakaiDPGExceptionFormatter',
'sev',
'3',
't',
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/bad-token-error'};
$Message::DOM::DOMCore::ManakaiDOMError::Def{'http://suika.fam.cx/~wakaba/archive/2005/11/pg/unique-lexmode-name-error'} = {'description',
'|lexmode| |%p (name => {http://suika.fam.cx/~wakaba/archive/2005/11/pg/name});| is already defined',
'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/Core/textFormatter',
'Message::Util::DIS::DPG::ManakaiDPGExceptionFormatter',
'sev',
'2',
't',
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/unique-lexmode-name-error'};
$Message::DOM::DOMCore::ManakaiDOMError::Def{'http://suika.fam.cx/~wakaba/archive/2005/11/pg/rule-not-defined-error'} = {'description',
'|rule| |%p (name => {http://suika.fam.cx/~wakaba/archive/2005/11/pg/name});| is not defined',
'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/Core/textFormatter',
'Message::Util::DIS::DPG::ManakaiDPGExceptionFormatter',
'sev',
'2',
't',
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/rule-not-defined-error'};
$Message::DOM::DOMCore::ManakaiDOMError::Def{'http://suika.fam.cx/~wakaba/archive/2005/11/pg/lexmode-not-defined-error'} = {'description',
'|lexmode| |%p (name => {http://suika.fam.cx/~wakaba/archive/2005/11/pg/name});| is not defined',
'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/Core/textFormatter',
'Message::Util::DIS::DPG::ManakaiDPGExceptionFormatter',
'sev',
'2',
't',
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/lexmode-not-defined-error'};
sub PARSE_ERR ();
sub VALIDITY_ERR ();
sub AUTOLOAD {


        my $al = our $AUTOLOAD;
        $al =~ s/.+:://;
        if ({'PARSE_ERR',
'Message::Util::IF::DPGException::PARSE_ERR',
'VALIDITY_ERR',
'Message::Util::IF::DPGException::VALIDITY_ERR'}->{$al}) {
          no strict 'refs';
          *{$AUTOLOAD} = \&{{'PARSE_ERR',
'Message::Util::IF::DPGException::PARSE_ERR',
'VALIDITY_ERR',
'Message::Util::IF::DPGException::VALIDITY_ERR'}->{$al}};
          goto &{$AUTOLOAD};
        } else {
          require Carp;
          Carp::croak (qq<Can't locate method "$AUTOLOAD">);
        }
      
}
sub import {


        my $self = shift;
        if (@_) {
          local $Exporter::ExportLevel = $Exporter::ExportLevel + 1;
          $self->SUPER::import (@_);
          for (grep {not /\W/} @_) {
            eval qq{$_};
          }
        }
      
}
our %EXPORT_TAG = ('DPGExceptionCode',
['PARSE_ERR',
'VALIDITY_ERR']);
our @EXPORT_OK = ('PARSE_ERR',
'VALIDITY_ERR');
use Exporter; push our @ISA, 'Exporter';
package Message::Util::IF::DPGDocument;
our $VERSION = 20060401.0604;
package Message::Util::DIS::DPG::ManakaiDPGDocument;
our $VERSION = 20060401.0604;
push our @ISA, 'Message::DOM::TreeCore::ManakaiDOMDocument',
'Message::DOM::IFLatest::Document',
'Message::DOM::IFLatest::Node',
'Message::Util::IF::DPGDocument';
$Message::DOM::ImplFeature{q<Message::DOM::DOMCore::ManakaiDOMImplementation>}->{q<http://suika.fam.cx/~wakaba/archive/2005/manakai/util/dis#dpg>}->{q<1.0>} ||= 1;
$Message::DOM::ImplFeature{q<Message::DOM::DOMCore::ManakaiDOMImplementation>}->{q<http://suika.fam.cx/~wakaba/archive/2005/manakai/util/dis#dpg>}->{q<>} = 1;
$Message::DOM::DOMFeature::ClassInfo->{q<Message::Util::DIS::DPG::ManakaiDPGDocument>}->{has_feature} = {'core',
{'',
'1',
'1.0',
'1',
'2.0',
'1',
'3.0',
'1'},
'http://suika.fam.cx/~wakaba/archive/2005/manakai/util/dis#dpg',
{'',
'1',
'1.0',
'1'},
'xml',
{'',
'1',
'1.0',
'1',
'2.0',
'1',
'3.0',
'1'},
'xmlversion',
{'',
'1',
'1.0',
'1',
'1.1',
'1'}};
$Message::DOM::ClassPoint{q<Message::Util::DIS::DPG::ManakaiDPGDocument>} = 15.1;
$Message::DOM::DOMFeature::ClassInfo->{q<Message::DOM::TreeCore::ManakaiDOMDocument>}->{compat_class_by_type}->{q<http://suika.fam.cx/~wakaba/archive/2005/11/pg/>}->{q<rules>}->{q<Message::Util::DIS::DPG::ManakaiDPGDocument>} = 1;
$Message::Util::Grove::ClassProp{q<Message::Util::DIS::DPG::ManakaiDPGDocument>} = {'s1a',
['child'],
'v1h',
['do'],
'w0',
['impl']};
package Message::Util::IF::DPGElement;
our $VERSION = 20060401.0604;
package Message::Util::DIS::DPG::ManakaiDPGElement;
our $VERSION = 20060401.0604;
push our @ISA, 'Message::DOM::TreeCore::ManakaiDOMElement',
'Message::DOM::IFLatest::Element',
'Message::DOM::IFLatest::Node',
'Message::Util::IF::DPGElement';
$Message::DOM::DOMFeature::ClassInfo->{q<Message::Util::DIS::DPG::ManakaiDPGElement>}->{has_feature} = {'core',
{'',
'1',
'1.0',
'1',
'2.0',
'1',
'3.0',
'1'},
'http://suika.fam.cx/~wakaba/archive/2005/manakai/util/dis#dpg',
{'',
'1',
'1.0',
'1'},
'xml',
{'',
'1',
'1.0',
'1',
'2.0',
'1',
'3.0',
'1'},
'xmlversion',
{'',
'1',
'1.0',
'1',
'1.1',
'1'}};
$Message::DOM::ClassPoint{q<Message::Util::DIS::DPG::ManakaiDPGElement>} = 15.1;
$Message::DOM::DOMFeature::ClassInfo->{q<Message::DOM::TreeCore::ManakaiDOMElement>}->{compat_class_by_type}->{q<>}->{q<*>}->{q<Message::Util::DIS::DPG::ManakaiDPGElement>} = 1;
$Message::Util::Grove::ClassProp{q<Message::Util::DIS::DPG::ManakaiDPGElement>} = {'o0',
['parent'],
's1a',
['child'],
's2hh',
['attr'],
'w0',
['od']};
package Message::Util::IF::DPGElementAttribute;
our $VERSION = 20060401.0604;
package Message::Util::DIS::DPG::ManakaiDPGElementAttribute;
our $VERSION = 20060401.0604;
push our @ISA, 'Message::Util::IF::DPGElementAttribute';
sub dpg_get_attribute ($$) {
my ($self, $attrName) = @_;
my $r = '';

{


{

local $Error::Depth = $Error::Depth + 1;

{



  $r = 
undef
;
  no warnings "uninitialized";
  C: for my $child (@{$self->
child_nodes
}) {
    if ($child->
namespace_uri
.$child->
local_name eq
        

'http://suika.fam.cx/~wakaba/archive/2005/11/pg/attributeSpecification'
) {
      if ($child->
get_attribute_ns
 (
undef
, 'name') eq
          $attrName) {
        $r = $child->
get_attribute_ns
 (
undef
, 'value');
        last C;
      }
    }
  }



;}


;}

;


;}
$r}
sub dpg_get_attribute_list ($$) {
my ($self, $attrName) = @_;
my $r = [];

{


{

local $Error::Depth = $Error::Depth + 1;

{


  no 
warnings "uninitialized";
  C: for my $child (@{$self->
child_nodes
}) {
    if ($child->
namespace_uri
.$child->
local_name eq
        

'http://suika.fam.cx/~wakaba/archive/2005/11/pg/attributeSpecification'
) {
      if ($child->
get_attribute_ns
 (
undef
, 'name') eq
          $attrName) {
        push @$r,
             $child->
get_attribute_ns
 (
undef
, 'value');
      }
    }
  }



;}


;}

;


;}
$r}
$Message::DOM::DOMFeature::ClassInfo->{q<Message::Util::DIS::DPG::ManakaiDPGElementAttribute>}->{has_feature} = {'http://suika.fam.cx/~wakaba/archive/2005/manakai/util/dis#dpg',
{'',
'1',
'1.0',
'1'}};
$Message::DOM::ClassPoint{q<Message::Util::DIS::DPG::ManakaiDPGElementAttribute>} = 1;
package Message::Util::IF::DPGRulesElement;
our $VERSION = 20060401.0604;
package Message::Util::DIS::DPG::ManakaiDPGRulesElement;
our $VERSION = 20060401.0604;
push our @ISA, 'Message::Util::DIS::DPG::ManakaiDPGElement',
'Message::DOM::IFLatest::Element',
'Message::DOM::IFLatest::Node',
'Message::Util::IF::DPGElement',
'Message::Util::IF::DPGRulesElement';
sub pl_code_fragment ($$;%) {
my ($self, $codeDocument, %opt) = @_;
my $r;

{


{

local $Error::Depth = $Error::Depth + 1;

{


  no 
warnings 'uninitialized';

  $r = $codeDocument->
create_document_fragment
;

  ## --- Range operations
  
    my $or_range = sub ($$) {
my ($r1, $r2) = @_;
my @r1 = @$r1;
my @r2 = @$r2;
my ($c1, $c2);
my $r = [];
while (@r1 or @r2 or $c1 or $c2) {
$c1 ||= shift @r1;
$c2 ||= shift @r2;
if (not $c1) {
push @$r, $c2, @r2;
undef $c2;
      @r2 = ();
} elsif (not $c2) {
push @$r, $c1, @r1;
undef $c1;
      @r1 = ();
} else {
($c1, $c2) = ($c2, $c1) if $c1->[0] > $c2->[0];
if ($c1->[1] < $c2->[0]) {
  push @$r, $c1;
  undef $c1;
} else {
  $c2 = [$c1->[0], $c2->[1]];
  undef $c1;
}
}
}
return $r;
};

my $add_range = sub ($$;$) {
my ($range, $s, $e) = @_;
return $or_range->($range, [[$s, defined $e ? $e : $s]]);
};

my $negate_range = sub ($) {
my $range = shift;
my $r = [];
push @$r, [0, $range->[0]->[0] - 1] if $range->[0]->[0] > 0;
for my $i (1..$#$range) {
push @$r, [$range->[$i - 1]->[1] + 1, $range->[$i]->[0] - 1];
}
push @$r, [$range->[$#$range]->[1] + 1, "Inf"] unless $range->[$#$range]->[1] eq "Inf";
return $r;
};

    my $merge_adjacent_range = sub ($) {
      my $range = shift;
      my $r = [];
      push @$r, $range->[0] if @$range;
      for my $i (1..$#$range) {
        if ($r->[-1]->[1] + 1 == $range->[$i]->[0]) {
          $r->[-1] = [$r->[-1]->[0], $range->[$i]->[1]];
        } else {
          push @$r, $range->[$i];
        }
      }
      return $r;
    }; # merge_adjacent_range

my $and_minus_ranges = sub ($$) {
my (@ra, @rab, @rb);
my @rangea = @{$_[0]};
my @rangeb = @{$_[1]};
my $rangea;
my $rangeb;
while (@rangea or @rangeb or $rangea or $rangeb) {
$rangea ||= shift @rangea;
$rangeb ||= shift @rangeb;
if (not $rangea) {
push @rb, $rangeb, @rangeb;
last;
} elsif (not $rangeb) {
push @ra, $rangea, @rangea;
last;
} else {
if ($rangea->[0] < $rangeb->[0]) {
  if ($rangea->[1] ne 'Inf' and
      $rangea->[1] < $rangeb->[0]) { ## [a .. a] .. [b ..
    push @ra, $rangea;
    $rangea = undef;
  } elsif ($rangea->[1] eq 'Inf') {
    if ($rangeb->[1] eq 'Inf') {  ## [a .. [b ..
      push @ra, [$rangea->[0], $rangeb->[0] - 1];
      push @rab, $rangeb;
      last;
    } else {                      ## [a .. [b .. b] ..
      push @ra, [$rangea->[0], $rangeb->[0] - 1];
      push @rab, $rangeb;
      $rangea = [$rangeb->[1] + 1, 'Inf'];
      $rangeb = undef;
    }
  } else {                      
    if ($rangeb->[1] eq 'Inf') {  ## [a .. [b .. a] ..
      push @ra, [$rangea->[0], $rangeb->[0] - 1];
      push @rab, [$rangeb->[0], $rangea->[1]];
      $rangeb = [$rangea->[1] + 1, 'Inf'];
      $rangea = undef;
    } else {
      if ($rangea->[1] < $rangeb->[1]) { ## [a .. [b .. a] .. b]
        push @ra, [$rangea->[0], $rangeb->[0] - 1];
        push @rab, [$rangeb->[0], $rangea->[1]];
        $rangeb = [$rangea->[1] + 1, $rangeb->[1]];
        $rangea = undef;
      } elsif ($rangea->[1] > $rangeb->[1]) { ## [a .. [b .. b] .. a]
        push @ra, [$rangea->[0], $rangeb->[0] - 1];
        push @rab, $rangeb;
        $rangea = [$rangeb->[1] + 1, $rangea->[1]];
        $rangeb = undef;
      } else {                            ## [a .. [b .. ab]]
        push @ra, [$rangea->[0], $rangeb->[0] - 1];
        push @rab, $rangeb;
        $rangea = $rangeb = undef;
      }
    }
  }
} elsif ($rangea->[0] > $rangeb->[0]) {
  if ($rangeb->[1] ne 'Inf' and
      $rangeb->[1] < $rangea->[0]) { ## [b .. b] .. [a ..
    push @rb, $rangeb;
    $rangeb = undef;
  } elsif ($rangea->[1] eq 'Inf') {
    if ($rangeb->[1] eq 'Inf') {  ## [b .. [a ..
      push @rb, [$rangeb->[0], $rangea->[0] - 1];
      push @rab, $rangea;
      last;
    } else {                      ## [b .. [a .. b] ..
      push @rb, [$rangeb->[0], $rangea->[0] - 1];
      push @rab, [$rangea->[0], $rangeb->[1]];
      $rangea = [$rangeb->[1] + 1, 'Inf'];
      $rangeb = undef;
    }
  } else {                      
    if ($rangeb->[1] eq 'Inf') {  ## [b .. [a .. a] ..
      push @rb, [$rangeb->[0], $rangea->[0] - 1, -7];
      push @rab, $rangea;
      $rangeb = [$rangea->[1] + 1, 'Inf'];
      $rangea = undef;
    } else {
      if ($rangea->[1] < $rangeb->[1]) { ## [b .. [a .. a] .. b]
        push @rb, [$rangeb->[0], $rangea->[0] - 1,-3];
        push @rab, $rangea;
        $rangeb = [$rangea->[1] + 1, $rangeb->[1]];
        $rangea = undef;
      } elsif ($rangea->[1] > $rangeb->[1]) { ## [b .. [a .. b] .. a]
        push @rb, [$rangeb->[0], $rangea->[0] - 1,-4];
        push @rab, [$rangea->[0], $rangeb->[1],-5];
        $rangea = [$rangeb->[1] + 1, $rangea->[1]];
        $rangeb = undef;
      } else {                            ## [b .. [a .. ab]]
        push @rb, [$rangeb->[0], $rangea->[0] - 1,-6];
        push @rab, $rangea;
        $rangea = $rangeb = undef;
      }
    }
  }
} else {
  if ($rangea->[1] eq 'Inf') {  
    if ($rangeb->[1] eq 'Inf') {          ## [[ab ..
      push @rab, $rangea;
      last;
    } else {                              ## [[ab .. b] ..
      push @rab, $rangeb;
      $rangea = [$rangeb->[1] + 1, 'Inf'];
      $rangeb = undef;
    }
  } else {
    if ($rangeb->[1] eq 'Inf') {          ## [[ab .. a] ..
      push @rab, $rangea;
      $rangeb = [$rangea->[1] + 1, 'Inf'];
      $rangea = undef;
    } else {
      if ($rangea->[1] < $rangeb->[1]) {  ## [[ab .. a] .. b]
        push @rab, $rangea;
        $rangeb = [$rangea->[1] + 1, $rangeb->[1]];
        $rangea = undef;
      } elsif ($rangea->[1] > $rangeb->[1]) { ## [[ab .. b] .. a]
        push @rab, $rangeb;
        $rangea = [$rangeb->[1] + 1, $rangea->[1]];
        $rangeb = undef;
      } else {                            ## [[ab .. ab]]
        push @rab, $rangea;
        $rangea = $rangeb = undef;
      }
    }
  }
}
}
}
return (\@ra, \@rab, \@rb);
};

  ## --- State operations

  ## Copy a set of states.  This is used to resolve
  ## references in |lAssignmentStatement|.
  my $copy_state = sub ($$$) {
    my ($token, $original_name, $new_prefix) = @_;
    my @copy = ($original_name.$;.'0');
    my @cs;
    while (@copy) {
      my $cname = shift @copy;
      next if $token->{$new_prefix, $cname};
      my $original = $token->{$cname};
      $token->{$new_prefix, $cname} = my $new = {
        name => $new_prefix.$;.$cname,
        next_state => [],
      };
      for my $nxt (@{$original->{next_state}}) {
        push @{$new->{next_state}},
             [$nxt->[0], $new_prefix.$;.$nxt->[1]];
        push @copy, $nxt->[1];
      }
      if ($original->{accept}) {
        push @cs, $new;
      }
    } # @copy
    return @cs;
  }; # copy_state

  my $array_uniq = sub ($) {
    my $array = shift;
    my %array = map {$_ => 
1
} @$array;
    return [keys %array];
  }; # array_uniq

  ## Makes a DFA state from a set of NFA states
  my $make_dfa_state = sub ($@) {
    my ($token, $dfa, @src_name) = @_;
    my @src = map {$token->{$_}} @src_name;
    my $next_state = [[[], [$;.'dummy']]];

    my @rsb = map {@{$_->{next_state}}} @src;
    for my $rsb (@rsb) {
      my $new_next_state = [];
      RSA: for my $rsa (@$next_state) {
        if (not $rsb) {
          push @$new_next_state, $rsa if @{$rsa->[0]};
          next RSA;
        }
        my ($ra, $rab, $rb) = $and_minus_ranges->($rsa->[0], $rsb->[0]);
        push @$new_next_state, [$ra, $rsa->[1]] if @$ra;
        push @$new_next_state,
             [$rab,
              $array_uniq->([sort {$a cmp $b} @{$rsa->[1]},
                                              $rsb->[1]]),
             ] if @$rab;
        if (@$rb) {
          $rsb = [$rb, $rsb->[1]];
        } else {
          $rsb = undef;
        }
      } # RSA
      if ($rsb) {
        push @$new_next_state, [$rsb->[0], [$rsb->[1]]];
      }
      $next_state = $new_next_state;
    }

    my $state_name = join $;.$;, @src_name;
    $dfa->{$state_name} = {
      name => $state_name,
      next_state => @rsb ? $next_state : [],
    };

    for (@src) {
      if ($_->{accept}) {
        $dfa->{$state_name}->{accept} = $_->{accept};
        $dfa->{$state_name}->{value} = 1 if $_->{value};
      }
      $dfa->{$state_name}->{ignore} = 1 if $_->{ignore};
    }
  }; # make_dfa_state

  ## Converts an internal state name to a Perl name
  my $escape_state_name = sub ($) {
    my $s = shift;
    $s =~ s/([\W_])/sprintf '_%08X', ord $1/ge;
    $s =~ s/_0000001C/__/g;
    return $s;
  }; # escape_state_name

  ## Converts a DFA state into Perl lexer code
  my %ancestor_state;
  my $state_to_code;
  $state_to_code = sub ($$$$%) {
    my ($dfa, $parent, $state_name, $factory, %opt) = @_;
    $ancestor_state{$state_name} = 1;

    if ($opt{outermost} and defined $opt{default_token_name}) {
      $parent->
append_statement

             ->
append_new_pc_variable

                 ('@', 
undef
, 'dch')
             ->
variable_scope
 ('my');
    }

my $state_block = $parent->append_new_pc_block;
my $estate_name = $escape_state_name->($state_name);
$state_block->label ('S'.$estate_name);
my $state_select;

    if ($opt{outermost}) {
      $state_block
         ->
append_statement

         ->
append_new_pc_variable

             ('@', 
undef
, 'ch')
         ->
variable_scope
 ('my');
    }

if (@{$dfa->{$state_name}->{next_state}}) {
  my $spush = $state_block->append_statement;
  for ($spush->append_new_pc_function_call (undef, 'push')
             ->append_new_pc_expression (',')) {
    $_->append_new_pc_variable ('@', undef, 'ch');
    $_->append_new_pc_variable ('$', undef, 'ch');
  }
  $state_block->parent_node->insert_before ($spush, $state_block)
    unless $opt{outermost};
      ## NOTE: This statement must be placed before the named block;
      ##       otherwise token value cannot be correctly returned
      ##       when |redo|ne.  An exception is the outermost state.
  
  for my $as ($state_block->append_statement
                          ->append_new_pc_expression ('=')) {
    $as->append_new_pc_variable ('$', undef, 'ch')
       ->variable_scope ('my');
    for ($as->append_new_pc_expression ('->')) {
      $_->append_new_pc_variable ('$', undef, 'self');
      $_->append_atom ('_shift_char');
    }
  }

  $state_select = $state_block->append_new_pc_choose;
  for my $rs (@{$dfa->{$state_name}->{next_state}}) {
    my $when = $state_select->append_new_pc_when;
  
    my $cond = $when->condition;
    my $cond_and = $cond->append_new_pc_expression ('or');
    for my $range (@{$rs->[0]}) {
      if ($range->[0] == $range->[1]) {
        my $match = $cond_and->append_new_pc_expression ('==');
        $match->append_new_pc_variable ('$', undef, 'ch');
        $match->append_new_pc_number_literal ($range->[0]);
      } else {
        my $x_range = $cond_and->append_new_pc_expression ('and');
        my $x_range_s = $x_range->append_new_pc_expression ('<=');
        $x_range_s->append_new_pc_number_literal ($range->[0]);
        $x_range_s->append_new_pc_variable ('$', undef, 'ch');
        unless ($range->[1] eq 'Inf') {
          my $x_range_e = $x_range->append_new_pc_expression ('<=');
          $x_range_e->append_new_pc_variable ('$', undef, 'ch');
          $x_range_e->append_new_pc_number_literal ($range->[1]);
        }
      }
    }
  
    my $when_block = $when->block;
    my $next_state_name = join $;.$;, @{$rs->[1]};
    if ($ancestor_state{$next_state_name}) {
      $when_block->append_child ($spush->clone_node (1));
      $when_block->append_statement
                 ->append_new_pc_function_call (undef, 'redo')
                 ->append_new_pc_variable
                     ('', undef, 'S'.$escape_state_name->($next_state_name));
    } else {
              

{

local $Error::Depth = $Error::Depth + 1;

{



                $state_to_code
                  ->($dfa, $when_block, $next_state_name, $factory,
                     %opt, outermost => 0);
                ## "If match, then |return|s"
              


;}


;}

;
              
              if ($dfa->{$state_name}->{accept}) {
                ## "If doesn't match, then |unshift|s |ch|"
                for ($when_block
                         ->
append_statement

                         ->
append_new_pc_function_call

                               (
undef
, 'unshift')
                         ->
append_new_pc_expression

                               (',')) {
                  for ($_->
append_new_pc_dereference
 ('@')
                         ->
append_new_pc_expression
 ('->')) {
                    $_->
append_new_pc_variable

                          ('$', 
undef
, 'self');
                    $_->
append_bare
 ('{char}');
                  }
                  $_->
append_new_pc_variable

                            ('$', 
undef
, 'ch');
                }
              } # If this state is "accept"
    }
  } # for next_state
}

if ($dfa->{$state_name}->{accept}) {
  if ($state_select) {
    for ($state_select->append_new_pc_otherwise->block) {
      my $push_ap = $_->append_statement
                      ->append_new_pc_function_call
                                  (undef, 'unshift')
                      ->append_new_pc_expression (',');
      for ($push_ap->append_new_pc_dereference ('@')
                   ->append_new_pc_expression ('->')) {
        $_->append_new_pc_variable ('$', undef, 'self');
        $_->append_bare ('{char}');
      }
      $push_ap->append_new_pc_variable ('$', undef, 'ch');
      for ($_->append_statement->append_new_pc_expression ('=')) {
        $_->append_new_pc_variable ('$', undef, 'ch');
        $_->append_new_pc_number_literal (-2);
      }
    }
  }
  my $accept_code_parent = $state_block;
  unless ($dfa->{$state_name}->{ignore}) {
    my %value;
    if ($dfa->{$state_name}->{value}) {
      ## Removes dummy item
      $accept_code_parent->append_statement
                         ->append_new_pc_function_call (undef, 'shift')
                         ->append_new_pc_variable ('@', undef, 'ch');
      for ($accept_code_parent->append_statement
                              ->append_new_pc_expression ('=')) {
        $_->append_new_pc_variable ('$', undef, 'token_val')
          ->variable_scope ('my');
        $_->append_string_literal ('');
      }
      for ($accept_code_parent->append_new_pc_choose
                              ->append_new_pc_when) {
        for ($_->condition->append_new_pc_expression ('>')) {
          $_->append_new_pc_variable ('$', undef, 'ch');
          $_->append_new_pc_number_literal (-1);
        }
        for ($_->block->append_statement
                      ->append_new_pc_function_call (undef, 'push')
                      ->append_new_pc_expression (',')) {
                  if (@{$dfa->{$state_name}->{next_state}}) {
                    for ($_
                         ->
append_new_pc_dereference

                            ('@')
                         ->
append_new_pc_expression

                            ('->')) {
                      $_->
append_new_pc_variable

                            ('$', 
undef
, 'self');
                      $_->
append_bare
 ('{char}');
                    }
                    $_->
append_new_pc_function_call

                          (
undef
, 'pop')
                      ->
append_new_pc_variable

                          ('@', 
undef
, 'ch');
                  } else {
                    $_->
append_new_pc_variable

                          ('@', 
undef
, 'ch');
                    $_->
append_new_pc_variable

                          ('$', 
undef
, 'ch');
                  }
        }
      }
              for ($accept_code_parent
                     ->
append_new_pc_while
) {
                $_->
condition

                  ->
append_new_pc_variable

                      ('@', 
undef
, 'ch');
                for ($_->
block

                       ->
append_statement

                       ->
append_new_pc_expression

                           ('.=')) {
                  $_->
append_new_pc_variable

                        ('$', 
undef
, 'token_val');
                  $_->
append_new_pc_function_call

                        (
undef
, 'chr')
                    ->
append_new_pc_function_call

                        (
undef
, 'shift')
                    ->
append_new_pc_variable

                        ('@', 
undef
, 'ch');
                }
              }
      $value{value} = $accept_code_parent->append_new_pc_variable
                                             ('$', undef, 'token_val');
            }
            if (defined $opt{default_token_name}) {
              for ($accept_code_parent
                     ->
append_new_pc_choose
) {
                for ($_->
append_new_pc_when
) {
                  $_->
condition

                    ->
append_new_pc_variable

                        ('@', 
undef
, 'dch');
                  for ($_->
block
) {
                    for ($_->
append_statement

                           ->
append_new_pc_function_call

                               (
undef
, 'unshift')
                           ->
append_new_pc_expression

                               (',')) {
                      for ($_->
append_new_pc_dereference
 ('@')
                             ->
append_new_pc_expression
 ('->')) {
                        $_->
append_new_pc_variable

                              ('$', 
undef
, 'self');
                        $_->
append_bare

                              ('{token}');
                      }
                      my $ld = $factory
                                 ->
create_pc_expression

                                     ('+');
                      $ld->
append_atom
 (0);
                      $ld->
append_new_pc_variable

                             ('@', 
undef
, 'dch');
                      $_->
append_new_pc_literal
 ({
                               type => $dfa->{$state_name}->{accept},
                               %value,
                               location => $factory
                                    ->
create_pc_variable

                                        ('$', 
undef
, 'location'),
                               location_d => $ld,
                             });
                    }

                    my $v
                      = $factory->
create_pc_variable

                                    ('$', 
undef
, 'token_val');
                    $_->
append_statement

                      ->
append_child

                          ($v->
clone_node
 (
1
))
                      ->
variable_scope
 ('my');
                    for ($_->
append_new_pc_while
) {
                      $_->
condition

                        ->
append_new_pc_variable

                            ('@', 
undef
, 'dch');
                      for ($_->
block

                             ->
append_statement

                             ->
append_new_pc_expression

                                 ('.=')) {
                        $_->
append_child

                              ($v->
clone_node
 (
1
));
                        $_->
append_new_pc_function_call

                              (
undef
, 'chr')
                          ->
append_new_pc_function_call

                              (
undef
, 'shift')
                          ->
append_new_pc_variable

                              ('@', 
undef
, 'dch');
                      }
                    }
                    $_->
append_statement

                      ->
append_new_pc_function_call

                          (
undef
, 'return')
                      ->
append_new_pc_literal
 ({
                            type => $opt{default_token_name},
                            value => $v,
                            location => $factory
                                    ->
create_pc_variable

                                        ('$', 
undef
, 'location'),
                          });
                  }
                }
                for ($_->
append_new_pc_otherwise

                       ->
block
) {
                  $_->
append_statement

                    ->
append_new_pc_function_call

                        (
undef
, 'return')
                    ->
append_new_pc_literal
 ({
                           type => $dfa->{$state_name}->{accept},
                           location => $factory
                                    ->
create_pc_variable

                                        ('$', 
undef
, 'location'),
                           %value,
                         });
                }
              }
            } else {
              $accept_code_parent
                ->
append_statement

                ->
append_new_pc_function_call

                    (
undef
, 'return')
                ->
append_new_pc_literal
 ({
                       type => $dfa->{$state_name}->{accept},
                       location => $factory
                                    ->
create_pc_variable

                                        ('$', 
undef
, 'location'),
                       %value,
                     });
            }
  } else {
    $accept_code_parent->append_statement
               ->append_new_pc_function_call (undef, 'redo')
               ->append_new_pc_variable
                   ('', undef, 'S'.$escape_state_name->($;.'initial'));
  }
} elsif ($opt{outermost}) {
  if ($state_select) {
  for ($state_select->append_new_pc_when) {
    for ($_->condition->append_new_pc_expression ('==')) {
      $_->append_new_pc_variable ('$', undef, 'ch');
      $_->append_new_pc_number_literal (-1);
    }
              my $block = $_->
block
;
              if (defined $opt{default_token_name}) {
                for ($block
                       ->
append_new_pc_choose
) {
                  for ($_->
append_new_pc_when
) {
                    $_->
condition

                      ->
append_new_pc_variable

                          ('@', 
undef
, 'dch');
                    for ($_->
block
) {
                      for ($_->
append_statement

                             ->
append_new_pc_function_call

                                 (
undef
, 'unshift')
                             ->
append_new_pc_expression

                                 (',')) {
                        for ($_->
append_new_pc_dereference
 ('@')
                               ->
append_new_pc_expression
 ('->')) {
                          $_->
append_new_pc_variable

                                ('$', 
undef
, 'self');
                          $_->
append_bare

                                ('{token}');
                        }
                        my $ld = $factory
                                 ->
create_pc_expression

                                     ('+');
                        $ld->
append_atom
 (0);
                        $ld->
append_new_pc_variable

                             ('@', 
undef
, 'dch');
                        $_->
append_new_pc_literal
 ({
                                 type => '#EOF',
                                 location => $factory
                                    ->
create_pc_variable

                                        ('$', 
undef
, 'location'),
                                 location_d => $ld,
                               });
                      }

                      my $v
                        = $factory->
create_pc_variable

                                      ('$', 
undef
, 'token_val');
                      $_->
append_statement

                        ->
append_child

                            ($v->
clone_node
 (
1
))
                        ->
variable_scope
 ('my');
                      for ($_->
append_new_pc_while
) {
                        $_->
condition

                          ->
append_new_pc_variable

                              ('@', 
undef
, 'dch');
                        for ($_->
block

                               ->
append_statement

                               ->
append_new_pc_expression

                                   ('.=')) {
                          $_->
append_child

                                ($v->
clone_node
 (
1
));
                          $_->
append_new_pc_function_call

                                (
undef
, 'chr')
                            ->
append_new_pc_function_call

                                (
undef
, 'shift')
                            ->
append_new_pc_variable

                                ('@', 
undef
, 'dch');
                        }
                      }
                      $_->
append_statement

                        ->
append_new_pc_function_call

                            (
undef
, 'return')
                        ->
append_new_pc_literal
 ({
                              type => $opt{default_token_name},
                              value => $v,
                              location => $factory
                                    ->
create_pc_variable

                                        ('$', 
undef
, 'location'),
                            });
                    }
                  }
                  for ($_->
append_new_pc_otherwise

                         ->
block
) {
                    $_->
append_statement

                      ->
append_new_pc_function_call

                          (
undef
, 'return')
                      ->
append_new_pc_literal
 ({
                            type => '#EOF',
                            location => $factory
                                    ->
create_pc_variable

                                        ('$', 
undef
, 'location'),
                          });
                  }
                }
              } else { # no default token
                $block->
append_statement

                      ->
append_new_pc_function_call

                          (
undef
, 'return')
                      ->
append_new_pc_literal
 ({
                            type => '#EOF',
                            location => $factory
                                    ->
create_pc_variable

                                        ('$', 
undef
, 'location'),
                          });
              }
            }
          }
          if (defined $opt{default_token_name}) {
            for ($state_block
                   ->
append_statement

                   ->
append_new_pc_function_call

                            (
undef
, 'push')
                   ->
append_new_pc_expression

                            (',')) {
              $_->
append_new_pc_variable

                    ('@', 
undef
, 'dch');
              $_->
append_new_pc_variable

                    ('$', 
undef
, 'ch');
            }
            $state_block->
append_statement

                        ->
append_new_pc_function_call

                            (
undef
, 'redo')
                        ->
append_new_pc_variable

                            ('', 
undef
, 'S'.$estate_name);
          } else {
            my $chr_ch
              = $factory->
create_pc_function_call

                            (
undef
, 'chr');
            $chr_ch->
append_new_pc_variable

                       ('$', 
undef
, 'ch');
            $state_block->
append_statement

                        ->
append_new_pc_function_call

                            (
undef
, 'return')
                        ->
append_new_pc_literal
 ({
                              type => '#INVALID',
                              value => $chr_ch,
                              location => $factory
                                    ->
create_pc_variable

                                        ('$', 
undef
, 'location'),
                            });
          }
} else {
  my $push_ap = $state_block->append_statement
                            ->append_new_pc_function_call
                                  (undef, 'unshift')
                            ->append_new_pc_expression (',');
  for ($push_ap->append_new_pc_dereference ('@')
               ->append_new_pc_expression ('->')) {
    $_->append_new_pc_variable ('$', undef, 'self');
    $_->append_bare ('{char}');
  }
  $push_ap->append_new_pc_variable ('$', undef, 'ch');
}

    $ancestor_state{$state_name} = 0;
  }; # $state_to_code


  ## --- Tokenizer method template
  my $tokenizer
    = $codeDocument->
create_perl_sub
 (
undef
);
  $tokenizer->prototype ('$');
my $tokenizer_param = $tokenizer->append_statement
                          ->append_new_pc_expression ('=');
$tokenizer_param->append_new_pc_variable ('$', undef, 'self')
          ->variable_scope ('my');
$tokenizer_param->append_new_pc_function_call (undef, 'shift');
my $if_stack = $tokenizer->append_new_pc_choose
                   ->append_new_pc_when;
my $stack_array = $if_stack->condition->append_new_pc_dereference ('@');
for ($stack_array->append_new_pc_expression ('->')) {
$_->append_new_pc_variable ('$', undef, 'self');
$_->append_bare ('{token}');
}
$if_stack->block
   ->append_statement
   ->append_new_pc_function_call (undef, 'return')
   ->append_new_pc_function_call (undef, 'shift')
   ->append_child ($stack_array->clone_node (1));

  ## --- For each child elements (rule or lexmode)...
  my %lexmodes;    # defined tokenizers
  my $initial_lexmode;
  my $root_lexmode_number = 0;
  my %rules;       # defined parser rules
  my %root_rules;  # defined |standalone| parser rules
  my %external_rules; # defined |external| parser rules
  my %token_error;
  my $default_token_error;

  B: for my $cel (@{$self->
child_nodes
}) {
    my $xuri = $cel->namespace_uri . $cel->local_name;

    ## -- Rule element - adds reference to hash
    if ($xuri eq 
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/rule'
) {
      my $name = $cel->get_attribute_ns (undef, 'name');
      $rules{$name} = {source => $cel, param => []};
      $external_rules{$name} = 
1
        if 
$cel->
get_attribute_ns
 (
undef
, 'isExternal');
      $root_rules{$name}
        = $cel->
dpg_get_attribute
 ('perl-name')
        || $name
        if $cel->
dpg_get_attribute

                   ('standalone') or
           $cel->
dpg_get_attribute

                   ('recursive') or
           $external_rules{$name};

      ## Creates a list of parameters
      C: for my $paramspec (@{$cel->child_nodes}) {
        next C unless $paramspec->namespace_uri eq 
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
;
        next C unless $paramspec->local_name eq 'parameterDeclaration';
        push @{$rules{$name}->{param}},
             $paramspec->get_attribute_ns (undef, 'name');
      }

    ## -- Token error element - error handling code
    } elsif ($xuri eq 
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/tokenError'
) {
      my $name = $cel->
get_attribute_ns
 (
undef
, 'name');
      $token_error{$name} = {
        source => $cel,
        param => [],
      };
      if ($cel->
dpg_get_attribute
 ('default')) {
        $default_token_error = $name;
      }

      ## Creates a list of parameters
      C: for my $paramspec (@{$cel->child_nodes}) {
        next C unless $paramspec->namespace_uri eq 
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
;
        next C unless $paramspec->local_name eq 'parameterDeclaration';
        push @{$token_error{$name}->{param}},
             $paramspec->
get_attribute_ns
 (
undef
, 'name');
      }

    ## -- Lexmode element - generate tokenizer
    } elsif ($xuri eq 
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/lexmode'
) {
      my $name = $cel->
get_attribute_ns
 (
undef
, 'name');
      if ($lexmodes{$name}) {
        

{

local $Error::Depth = $Error::Depth - 1;

{

report Message::DOM::DOMCore::ManakaiDOMError -object => $self, '-type' => 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/unique-lexmode-name-error', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'pl_code_fragment', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::Util::DIS::DPG::ManakaiDPGRulesElement', 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/element' => $cel, 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/name' => $name;


;}


;}

;
      }

      my $supermodes
        = $cel->
dpg_get_attribute_list

                  ('extends');

      my $default_token_name;
      my %token;
      $lexmodes{$name} = \%token;
      for my $rname (@$supermodes) {
        unless ($lexmodes{$rname}) {
          

{

local $Error::Depth = $Error::Depth - 1;

{

report Message::DOM::DOMCore::ManakaiDOMError -object => $self, '-type' => 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/lexmode-not-defined-error', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'pl_code_fragment', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::Util::DIS::DPG::ManakaiDPGRulesElement', 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/element' => $cel, 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/name' => $rname;


;}


;}

;
        } else {
          %token = (%token, %{$lexmodes{$rname}});
        }
      }
      $token{$;.'initial'} = {
        name => $;.'initial',
        next_state => [
          map {@{$lexmodes{$_}->{$;.'initial'}->{next_state}}
          } @$supermodes
        ],
      };

for my $tel (grep {$_->node_type == $_->ELEMENT_NODE} @{$cel->child_nodes}) {
my $xuri = $tel->namespace_uri . $tel->local_name;
if ($xuri eq 
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/lAssignmentStatement'
) {
  my $sname = $tel->get_attribute_ns (undef, 'name');
  my $is_variable = $tel->
get_attribute_ns

                            (
undef
, 'isVariable');
  $sname = '$' . $sname if $is_variable;
  my $i = 0;
  if ($token{$sname, $i}) {
    die qq<"$sname" is already defined>;
    ## TODO: exception
  }
  my $s0 = $token{$sname, $i} = {
    name => $sname.$;.$i,
    next_state => [],
  };
  my @current_state = ($s0);
  my $ignore = $tel->
dpg_get_attribute
 ('ignore');
  my $value = $tel->
dpg_get_attribute
 ('value');
  for my $lel (grep {$_->node_type == $_->ELEMENT_NODE} @{$tel->child_nodes}) {
    my $xuri = $lel->namespace_uri . $lel->local_name;
    if ($xuri eq 
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/charClass' or 
$xuri eq 
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/anyChar'
) {
      my $range = [];
      if ($xuri eq 
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/charClass'
) {
        for my $mel (grep {$_->node_type == $_->ELEMENT_NODE} @{$lel->child_nodes}) {
          my $xuri = $mel->namespace_uri . $mel->local_name;
          if ($xuri eq 
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/string'
) {
            $range = $add_range->($range, ord $mel->text_content);
          } elsif ($xuri eq 
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/charRange'
) {
            $range = $add_range->($range, $mel->get_attribute_ns (undef, 'start'),
                                        $mel->get_attribute_ns (undef, 'end'));
          }
        }
        $range = $merge_adjacent_range->($range);
        if ($lel->get_attribute_ns (undef, 'negative')) {
          $range = $negate_range->($range);
        }
      } else { # pg:anyChar
        $range = [0, 'Inf'];
      }
      
      my $new_s = {
        name => $sname.$;.(++$i),
        next_state => [],
      };
      my $v = $lel->get_attribute_ns (undef, 'occurence');
      if ($v eq 'zeromore') {
        $token{$new_s->{name}} = $new_s;
        push @{$new_s->{next_state}}, [$range, $new_s->{name}];
        for my $s (@current_state) {
          push @{$s->{next_state}}, [$range, $new_s->{name}];
        }
        push @current_state, $new_s;
      } elsif ($v eq 'zeroone') {
        $token{$new_s->{name}} = $new_s;
        for my $s (@current_state) {
          push @{$s->{next_state}}, [$range, $new_s->{name}];
        }
        push @current_state, $new_s;
      } elsif ($v eq 'onemore') {
        $token{$new_s->{name}} = $new_s;
        push @{$new_s->{next_state}}, [$range, $new_s->{name}];
        for my $s (@current_state) {
          push @{$s->{next_state}}, [$range, $new_s->{name}];
        }
            @current_state = ($new_s);
      } else { # one
        $token{$new_s->{name}} = $new_s;
        for my $s (@current_state) {
          push @{$s->{next_state}}, [$range, $new_s->{name}];
        }
            @current_state = ($new_s);
      }
    } elsif ($xuri eq 
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/lVariableRef'
) {
      my $rrulename = '$'.$lel->get_attribute_ns (undef, 'name');
      my @new_current_state;
      if ($token{$rrulename, 0}) {
            @new_current_state
          = $copy_state->(\%token, $rrulename => $sname.$;.(++$i));
      } else {
        die "$rrulename is not defined";
        ## TODO: exception
      } 
      my $v = $lel->get_attribute_ns (undef, 'occurence');
      if ($v eq 'zeromore') {
        for my $s (@current_state, @new_current_state) {
          push @{$s->{next_state}},
                   @{$token{$sname, $i, $rrulename, 0}->{next_state}};
        }
        push @current_state, @new_current_state;
      } elsif ($v eq 'zeroone') {
        for my $s (@current_state) {
          push @{$s->{next_state}},
                   @{$token{$sname, $i, $rrulename, 0}->{next_state}};
        }
        push @current_state, @new_current_state;
      } elsif ($v eq 'onemore') {
        for my $s (@current_state, @new_current_state) {
          push @{$s->{next_state}},
                   @{$token{$sname, $i, $rrulename, 0}->{next_state}};
        }
            @current_state = @new_current_state;
      } else { # one
        for my $s (@current_state) {
          push @{$s->{next_state}},
                   @{$token{$sname, $i, $rrulename, 0}->{next_state}};
        }
            @current_state = @new_current_state;
      }
    } # $xuri
  } # $lel
  push @{$token{$;.'initial'}->{next_state}}, @{$s0->{next_state}}
    unless $is_variable;
  for my $s (@current_state) {
    $s->{accept} = $sname;
    $s->{ignore} = $ignore if $ignore;
    $s->{value} = $value if $value;
  }
        } elsif ($xuri eq 
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/lQDefaultTokenStatement'
) {
          $default_token_name
            = $tel->
get_attribute_ns
 (
undef
, 'name');
        } # xuri
      }

      next B unless $cel->
dpg_get_attribute

                             ('standalone') or
                    $initial_lexmode eq $name;
      $root_lexmode_number++;

my %dfa;
my @req_state = ([$;.'initial']);
while (@req_state) {
my $req_state = shift @req_state;
my $req_state_name = join $;.$;, @$req_state;
next if $dfa{$req_state_name};
$make_dfa_state->(\%token, \%dfa, @$req_state);
for (@{$dfa{$req_state_name}->{next_state}}) {
  push @req_state, $_->[1];
}
}

      my $scan_sub = $tokenizer->
clone_node
 (
1
);
      $scan_sub->
add_perl_name
 ('_scan_'.$name);
      for ($scan_sub->
append_statement

             ->append_new_pc_expression ('=')) {
$_->append_new_pc_variable ('$', undef, 'ch')
  ->variable_scope ('my');
$_->append_new_pc_number_literal (-2);
}

      ## Set the scanner as initial one if desired
      if ($cel->
dpg_get_attribute
 ('initial')) {
        $initial_lexmode = $scan_sub;
      } else {
        $initial_lexmode ||= $scan_sub;
      }

      ## "Copies current location information"
      for ($scan_sub->
append_statement

                    ->
append_new_pc_expression

                        ('=')) {
        $_->
append_new_pc_variable

              ('$', 
undef
, 'location')
          ->
variable_scope
 ('my');
        $_->
append_bare

              ('{%{$self->{location}},
                 char_d => 0+@{$self->{char}}}');
      }

      

{

local $Error::Depth = $Error::Depth + 1;

{



        $state_to_code->(\%dfa, $scan_sub, $;.'initial',
                         $codeDocument, outermost => 1,
                         default_token_name => $default_token_name);
      


;}


;}

;
      $r->
append_child
 ($scan_sub);
    } # xuri
  } # B

  $state_to_code = 
undef
;


  ## --- Generates parser methods

  ## Template for 'get next token' statements
  my $next_token_code = $codeDocument->create_pc_statement;
  for ($next_token_code->append_new_pc_expression ('=')) {
    $_->append_new_pc_variable ('$', undef, 'token');
    for ($_->append_new_pc_expression ('->')) {
      $_->append_new_pc_variable ('$', undef, 'self');
      if ($root_lexmode_number > 1) {
        $_->
append_bare
 ('{scanner}');
        $_->
append_bare
 ('($self)');
      } elsif ($root_lexmode_number > 0) {
        $_->
append_bare

              ($initial_lexmode->
pc_local_name
);
      } else {
        $_->
append_bare
 ('_shift_token');
      }
    }
  }

  ## Error handling code
  unless ($default_token_error) {
    $default_token_error = $;.'default-token-error';
    my $root = $codeDocument->
create_pc_block
;
    for ($root->
append_statement

              ->
append_new_pc_function_call

                  (
undef
, 'die')
              ->
append_new_pc_expression
 ('->')) {
      $_->
append_new_pc_variable

                  ('$', 
undef
, 'token');
      $_->
append_bare
 ('{type}');
    }
    $token_error{$default_token_error} = {
      code => $root,
      param => [],
    };
  }

  ## Converts an expression in rule block into Perl expression
  my $match_block_ids = {};
  my $rexpression_to_code = sub ($$;%) {
    my ($parent, $source_parent, %opt) = @_;
$parent = $parent->append_new_pc_expression (',');
C: for my $child (@{$source_parent->child_nodes}) {
next C unless $child->node_type == $child->ELEMENT_NODE;
my $xuri = $child->namespace_uri . $child->local_name;
if ($xuri eq 
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/memberRef'
) {
my $context = $parent->append_new_pc_expression ('->');
D: for my $child (@{$child->child_nodes}) {
  next D unless $child->node_type == $child->ELEMENT_NODE;
  my $xuri = $child->namespace_uri . $child->local_name;
  if ($xuri eq 
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/variable'
) {
    $context->append_new_pc_variable
      ('$', undef, $child->get_attribute_ns (undef, 'name'));
  } elsif ($xuri eq 
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/member'
) {
    $context->append_bare ('{'.$child->get_attribute_ns (undef, 'name').'}');
  }
}
} elsif ($xuri eq 
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/string'
) {
$parent->append_string_literal ($child->text_content);
      } # xuri
    }
  }; # rexpression_to_code

  ## Converts a statement in rule block into Perl code
  my $block_id = 0;
  my $rstatement_to_code;
  $rstatement_to_code = sub ($$$$$$;%) {
    my ($parent, $statement, $next_token_required, $rules, $root_rules,
        $factory, %opt) = @_;
    my $xuri = $statement->namespace_uri . $statement->local_name;
    if ($xuri eq 
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/matchStatement'
) {
      my $match_parent = $parent;
      my $match_occur = $statement->
get_attribute_ns

                                      (
undef
, 'occurence');
if ($match_occur eq 'onemore') {
$match_parent = $match_parent->append_new_pc_block;
for ($match_parent->append_statement->append_new_pc_expression ('=')) {
  $_->append_new_pc_variable ('$', undef, 'has_content')
    ->variable_scope ('my');
  $_->append_new_pc_number_literal (0);
}
}

my $match_block_id = 0;
if ($match_occur eq 'zeromore' or $match_occur eq 'onemore') {
$match_parent = $match_parent->append_new_pc_block;
$match_parent->label ('MATCH_' . ($match_block_id = ++$block_id));
        my $bname
          = $statement
              ->
dpg_get_attribute
 ('name');
        $match_block_ids->{$bname} = $match_block_id if $bname;
}

my $match_choose = $match_parent->append_new_pc_choose;
my $token_type_var = $factory->create_pc_expression ('->');
$token_type_var->append_new_pc_variable ('$', undef, 'token');
$token_type_var->append_bare ('{type}');
my $has_sep;       ## There is a :separator block
my $has_sep_term;  ## There is a :separator:terminator? block
C: for my $child (@{$statement->child_nodes}) {
next C unless $child->node_type == $child->ELEMENT_NODE;
my $xuri = $child->namespace_uri . $child->local_name;
if ($xuri eq 
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/matchBlock'
) {
  my $token_name = $child->get_attribute_ns (undef, 'token');
  if ($child->
get_attribute_ns
 (
undef
, 'isReservedToken')) {
    $token_name = '#' . $token_name;
  }

  my $cond = $factory->
create_pc_expression
 ('eq');
  $cond->
append_child

           ($token_type_var->
clone_node
 (
1
));
  $cond->
append_string_literal
 ($token_name);
  if ($child->
get_attribute_ns
 (
undef
, 'valueOperation') eq
      '==') {
    for ($factory->
create_pc_expression
 ('and')) {
      $_->
append_child
 ($cond);
      for ($_->
append_new_pc_expression
 ('eq')) {
        for ($_->
append_new_pc_expression
 ('->')) {
          $_->
append_new_pc_variable

            ('$', 
undef
, 'token');
          $_->
append_bare
 ('{value}');
        }
        $_->
append_string_literal

          ($child->
get_attribute_ns
 (
undef
, 'value'));
      }
      $cond = $_;
    }
  }
  
  my $is_sep = $child->
dpg_get_attribute

                                            ('separator');
  my $token_parent;
  unless ($is_sep) {
    for ($match_choose->append_new_pc_when) {
      $_->
condition

        ->
append_child
 ($cond);
      $token_parent = $_->block;
    }
    if ($match_occur eq 'onemore') {
      for ($token_parent->append_statement->append_new_pc_expression ('=')) {
        $_->append_new_pc_variable ('$', undef, 'has_content');
        $_->append_new_pc_number_literal (1);
      }
    }
  } else { # separator
    $has_sep = 1;
            if ($child->
dpg_get_attribute

                                                     ('terminator')) {
              ## BUG: |?| occurence not checked.
              $has_sep_term = 
1
;
            }
    for ($match_parent->append_new_pc_choose) {
      for ($_->append_new_pc_when) {
        $_->
condition

          ->
append_child
 ($cond);
        $token_parent = $_->block;
      }
      for ($_->append_new_pc_otherwise->block) {
        $_->append_statement
          ->append_new_pc_function_call (undef, 'last')
          ->append_new_pc_variable ('', undef, 'MATCH_'.$match_block_id);
      }
    }
  }
  
          ## Child statements
          $next_token_required = 1;
          D: for my $child (@{$child->
child_nodes
}) {
            next D unless $child->
node_type
 ==
                          
1
;
            

{

local $Error::Depth = $Error::Depth + 1;

{



              ($next_token_required, undef)
                = $rstatement_to_code
                    ->($token_parent, $child, $next_token_required,
                       $rules, $root_rules, $factory, %opt);
            


;}


;}

;
          }
  
  if ($next_token_required) {
    $token_parent->append_child ($next_token_code->clone_node (1));
    $next_token_required = 0;
  }

  if ($is_sep and
      ($match_occur eq 'zeromore' or $match_occur eq 'onemore')) {
    $token_parent->
append_statement

          ->
append_new_pc_function_call

                         (
undef
, 'redo')
          ->
append_new_pc_variable

                         ('', 
undef
, 'MATCH_'.$match_block_id);
  }

} elsif ($xuri eq 
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/matchElseBlock'
) {
  my $token_parent
    = $match_choose->
append_new_pc_otherwise

                   ->
block
;
  
  ## Child statements
  $next_token_required = 
0
;
  D: for my $child (@{$child->child_nodes}) {
    next D unless $child->node_type == $child->ELEMENT_NODE;
    

{

local $Error::Depth = $Error::Depth + 1;

{



      ($next_token_required, undef)
        = $rstatement_to_code
            ->($token_parent, $child, $next_token_required,
               $rules, $root_rules, $factory, %opt);
    


;}


;}

;
    ## NOTE: |pg:matchElseBlock| should not contain
    ##       any statement which affects on |next_token_required|
    ##       status; its result is undefined.
  }

  ## NOTE: Interaction between |pg:matchElseBlock| and
  ##       occurences other than |zeroone| is unknown.
} # $xuri
} # pc:matchStatement children

if (not $match_occur or $match_occur eq 'onemore') {
my $err_block = $match_choose->append_new_pc_otherwise->block;
if ($match_occur eq 'onemore') {
  $err_block = $err_block->append_new_pc_choose->append_new_pc_when->block;
  for ($err_block->parent_node->condition->append_new_pc_expression ('==')) {
    $_->append_new_pc_variable ('$', undef, 'has_content');
    $_->append_new_pc_number_literal (0);
  }
}

        if ($has_sep_term) { ## :separator :terminator?
          $err_block->
append_statement

                    ->
append_new_pc_function_call

                        (
undef
, 'last')
                    ->
append_new_pc_variable

                        ('', 
undef
, 'MATCH_'.$match_block_id);
        } else {
          my $terr_name = $default_token_error;
          unless ($token_error{$terr_name}->{code}) {
            ## Child statements
            $token_error{$terr_name}->{code}
              = $factory->
create_pc_block
;
            C: for my $child (@{$token_error{$terr_name}->{source}
                                      ->
child_nodes
}) {
              next C unless $child->
node_type
 ==
                            
1
;
              

{

local $Error::Depth = $Error::Depth + 1;

{



                $rstatement_to_code
                  ->($token_error{$terr_name}->{code}, $child, 
1
,
                     $rules, $root_rules, $factory, %opt);
              


;}


;}

;
            }
          }
          $err_block->
append_child

                        ($token_error{$terr_name}->{code}
                                      ->
clone_node
 (
1
));
  
          my %param;
          C: for my $child (@{$statement->
child_nodes
}) {
            if ($child->
namespace_uri
 .
                $child->
local_name eq
                

'http://suika.fam.cx/~wakaba/archive/2005/11/pg/parameterSpecification'
) {
              $param{$child->
get_attribute_ns

                               (
undef
, 'name')} = $child;
            }
          }
  
          my $block_first = $err_block->
first_child
;
          for my $param_name (reverse @{$token_error{$terr_name}
                                              ->{param}}) {
            $block_first = $err_block->
insert_before

                     ($factory->
create_pc_statement
,
                      $block_first);
            for ($block_first->
append_new_pc_expression
 ('=')) {
              $_->
append_new_pc_variable

                        ('$', 
undef
, $param_name)
                ->
variable_scope
 ('my');
              if ($param{$param_name}) {
                $rexpression_to_code->($_, $param{$param_name});
              } else {
                $_->
append_atom
 ('undef');
              }
            }
          }
        } # no has_sep_term
      }

if (not $has_sep and ($match_occur eq 'zeromore' or $match_occur eq 'onemore')) {
for ($match_choose->append_new_pc_otherwise->block) {
        
                 $_->
append_statement

                   ->
append_new_pc_function_call

                       (
undef
, 'last')
                   ->
append_new_pc_variable

                       ('', 
undef
, 'MATCH_'.$match_block_id);
}
$match_parent->append_statement
             ->append_new_pc_function_call (undef, 'redo')
             ->append_new_pc_variable ('', undef, 'MATCH_'.$match_block_id);
}

      return 0; # next_token_required == 0

    } elsif ($xuri eq 
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/embedStatement'
) {
      my $lang = $statement->get_attribute_ns (undef, 'type');
      if ($lang eq 
'http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#Perl'
) {
        my %param;
        my $source;
        C: for my $child (@{$statement->child_nodes}) {
          next C unless $child->node_type == $child->ELEMENT_NODE;
          my $xuri = $child->
namespace_uri

                   . $child->
local_name
;
          if ($xuri eq 
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/parameterSpecification'
) {
            $param{$child->
get_attribute_ns
 (undef, 'name')}
              = $child;
          } elsif ($xuri eq 
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/embedBlock'
) {
            $source = $child->
text_content
;
          }
        }

        my $plcode = $opt{dis_resource}
                       ->
pl_preprocess_perl_code

                         ($source,
                          namespace_context => $opt{ns_context});

        my $dparent = $parent->
owner_document

                           ->
create_pc_expression
 (',');
        for (keys %param) {
          $rexpression_to_code
            ->($dparent, $param{$_},
               dis_resource => $opt{dis_resource},
               match_block_id => $opt{match_block_id});
          $plcode->
replace_variable

            ('$'.$_ => $dparent->
last_child
);
        }

        $parent->
append_code_fragment
 ($plcode);
        return $next_token_required;
      } else {
        die qq<Lexical content type <$lang> is not supported>;
        ## TODO: exception
      }

    } elsif ($xuri eq 
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/myStatement'
) {
      my $name = $statement->
get_attribute_ns
 (
undef
, 'name');
      $parent->
append_statement

             ->
append_new_pc_variable

                 ('$', 
undef
, $name)
             ->
variable_scope
 ('my');

      return $next_token_required;

} elsif ($xuri eq 
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/ruleRefStatement'
) {
my $rule_name = $statement->get_attribute_ns (undef, 'name');
if ($rules->{$rule_name}) {
if ($root_rules->{$rule_name}) {
          if (not $next_token_required or
              $statement->
dpg_get_attribute

                            ('unshift-current-token')) {
            for ($parent->
append_statement

                        ->
append_new_pc_function_call

                            (
undef
, 'unshift')
                        ->
append_new_pc_expression

                            (',')) {
              for ($_->
append_new_pc_dereference

                         ('@')
                     ->
append_new_pc_expression

                         ('->')) {
                $_->
append_new_pc_variable

                      ('$', 
undef
, 'self');
                $_->
append_bare
 ('{token}');
              }
              $_->
append_new_pc_variable

                    ('$', 
undef
, 'token');
            }
          }

  
  my $param_spec_list;
  for ($parent->append_statement->append_new_pc_apply) {
    for ($_->append_new_pc_expression ('->')) {
      $_->append_new_pc_variable ('$', undef, 'self');
      $_->append_bare ('_parse_' . $root_rules->{$rule_name});
    }
    $param_spec_list = $_->append_new_pc_expression (',');
  }
  
  my %param;
  C: for my $child (@{$statement->child_nodes}) {
    next C unless $child->node_type == $child->ELEMENT_NODE;
    if ($child->namespace_uri . $child->local_name eq
        
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/parameterSpecification'
) {
      $param{$child->get_attribute_ns (undef, 'name')} = $child;
    }
  }
  
  for my $param_name (@{$rules->{$rule_name}->{param}}) {
    if ($param{$param_name}) {
      $rexpression_to_code->($param_spec_list, $param{$param_name});
    } else {
      $param_spec_list->append_atom ('undef');
    }
  }
  
          return 1; # next_token_required == 1
        } else { # not a standalone rule
          my $block;
          $next_token_required = 
0
            if 
$statement->
dpg_get_attribute

                             ('unshift-current-token');
          unless ($rules->{$rule_name}->{code}
                        ->[$next_token_required += 0]) {
            $block = $parent->
append_new_pc_block
;
            $rules->{$rule_name}->{code}->[$next_token_required]
              = [$block, $next_token_required]; # prevent infinite loop
            my $o_next_token_required = $next_token_required;
    
            ## Child statements
            C: for my $child (@{$rules->{$rule_name}->{source}
                                      ->
child_nodes
}) {
              next C unless $child->
node_type
 ==
                            
1
;
              

{

local $Error::Depth = $Error::Depth + 1;

{



                ($next_token_required, undef)
                  = $rstatement_to_code
                      ->($block, $child,
                         $next_token_required,
                         $rules, $root_rules, $factory, %opt);
              


;}


;}

;
            }
            $rules->{$rule_name}->{code}->[$o_next_token_required]
              = [$block->
clone_node
 (
1
),
                 $next_token_required];
          } else {
            $block = $parent->
append_child

               ($rules->{$rule_name}->{code}
                      ->[$next_token_required]->[0]
                      ->
clone_node
 (
1
));
            $next_token_required
              = $rules->{$rule_name}->{code}
                      ->[$next_token_required]->[1];
          }
  
          my %param;
          C: for my $child (@{$statement->
child_nodes
}) {
            if ($child->
namespace_uri
 .
                $child->
local_name eq
                

'http://suika.fam.cx/~wakaba/archive/2005/11/pg/parameterSpecification'
) {
              $param{$child->
get_attribute_ns

                               (
undef
, 'name')} = $child;
            }
          }
  
          my $block_first = $block->
first_child
;
          for my $param_name (reverse @{$rules->{$rule_name}
                                              ->{param}}) {
            $block_first = $block->
insert_before

                     ($factory->
create_pc_statement
,
                      $block_first);
            for ($block_first->
append_new_pc_expression
 ('=')) {
              $_->
append_new_pc_variable

                        ('$', 
undef
, $param_name)
                ->
variable_scope
 ('my');
              if ($param{$param_name}) {
                $rexpression_to_code->($_, $param{$param_name});
              } else {
                $_->
append_atom
 ('undef');
              }
            }
          }
    
          return $next_token_required;
        }

        return 1; # $next_token_required == 1
      } else {
        

{

local $Error::Depth = $Error::Depth - 1;

{


          my 
$continue = 
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, '-type' => 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/rule-not-defined-error', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'pl_code_fragment', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::Util::DIS::DPG::ManakaiDPGRulesElement', 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/element' => $statement, 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/name' => $rule_name;

;
          unless ($continue) {
            
report Message::Util::DIS::DPG::ManakaiDPGException -object => $self, '-type' => 'VALIDITY_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'pl_code_fragment', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::Util::DIS::DPG::ManakaiDPGRulesElement';

;
          }
        


;}


;}

;
      }

    } elsif ($xuri eq 
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/qLexmodeStatement'
) {
      for ($parent->
append_statement

                  ->
append_new_pc_expression

                      ('=')) {
        for ($_->
append_new_pc_expression

                   ('->')) {
          $_->
append_new_pc_variable

                ('$', 
undef
, 'self');
          $_->
append_bare
 ('{scanner}');
        }
        for ($_->
append_new_pc_apply
) {
          for ($_->
append_new_pc_expression

                     ('->')) {
            $_->
append_new_pc_variable

                  ('$', 
undef
, 'self');
            $_->
append_bare
 ('can');
          }
          $_->
append_string_literal

                ('_scan_'.
                 $statement->
get_attribute_ns

                               (
undef
, 'name'));
        }
      }
      return $next_token_required;
             ## ISSUE: Is this correct? Or 1?

    } elsif ($xuri eq 
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/qRequiresNextTokenStatement'
) {
      return 
1
;

} elsif ($xuri eq 
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/assignmentStatement'
) {
my $assign = $parent->append_statement->append_new_pc_expression ('=');
my $lvalue = $statement->first_child;
if ($lvalue->namespace_uri . $lvalue->local_name eq 
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/memberRef'
) {
my $context = $assign->append_new_pc_expression ('->');
C: for my $child (@{$lvalue->child_nodes}) {
  my $xuri = $child->namespace_uri . $child->local_name;
  if ($xuri eq 
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/variable'
) {
    $context->append_new_pc_variable
      ('$', undef, $child->get_attribute_ns (undef, 'name'));
  } elsif ($xuri eq 
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/member'
) {
    $context->append_bare ('{'.$child->get_attribute_ns (undef, 'name').'}');
  }
}
}
      return $next_token_required;

    } elsif ($xuri eq 
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/ifTrueStatement'
) {
      for ($parent->
append_new_pc_choose

                  ->
append_new_pc_when
) {
        $_->
condition

          ->
append_new_pc_variable

              ('$', 
undef
, $statement->
get_attribute_ns

                                        (
undef
, 'name'));
        ## Child statements
        my $parent = $_->
block
;
        D: for my $child (@{$statement->
child_nodes
}) {
          next D unless $child->
node_type
 ==
                        
1
;
          

{

local $Error::Depth = $Error::Depth + 1;

{



            ($next_token_required, undef)
                = $rstatement_to_code
                    ->($parent, $child, $next_token_required,
                       $rules, $root_rules, $factory, %opt);
          


;}


;}

;
        }
      }
      return $next_token_required; ## ISSUE: Correct?

    } elsif ($xuri eq 
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/returnStatement'
) {
      ## ISSUE: |return| variable does not work with return
      ##        statements.
      unless ($next_token_required) {
            for ($parent->
append_statement

                        ->
append_new_pc_function_call

                            (
undef
, 'unshift')
                        ->
append_new_pc_expression

                            (',')) {
              for ($_->
append_new_pc_dereference

                         ('@')
                     ->
append_new_pc_expression

                         ('->')) {
                $_->
append_new_pc_variable

                      ('$', 
undef
, 'self');
                $_->
append_bare
 ('{token}');
              }
              $_->
append_new_pc_variable

                    ('$', 
undef
, 'token');
            }
      }
      $parent->
append_statement

             ->
append_new_pc_function_call

                 (
undef
, 'return');
      return $next_token_required;

    } elsif ($xuri eq 
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/codeBlock'
) {
      my $return;
D: for my $child (@{$statement->child_nodes}) {
next D unless $child->node_type == $child->ELEMENT_NODE;
my $xuri = $child->namespace_uri . $child->local_name;
if ($xuri eq 
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/matchStatement'
) {
  if ($next_token_required) {
    $parent->append_child ($next_token_code->clone_node (1));
    $next_token_required = 
0
;
  }
        } elsif ($xuri eq 
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/myStatement'
) {
          if ($child->
dpg_get_attribute

               ('return')) {
            $return = $child->
get_attribute_ns
 (
undef
, 'name');
          }
        }
        

{

local $Error::Depth = $Error::Depth + 1;

{



          ($next_token_required, undef)
            = $rstatement_to_code
                ->($parent, $child,
                   $next_token_required,
                   $rules, $root_rules, $factory, %opt);
        


;}


;}

;
      }
      return ($next_token_required, $return);

    } else {
      ## ISSUE: Can unsupported elements safely ignored?
      return $next_token_required;
    } # xuri
  }; # rstatement_to_code

  ## -- Converts each |standalone| rules into Perl code
  for my $rule_name (grep {not $external_rules{$_}} keys %root_rules) {
    my $rule_sub = $codeDocument->
create_perl_sub

                              ('_parse_'.$root_rules{$rule_name});
    $r->
append_child
 ($rule_sub);

    my $params_s = $rule_sub->append_statement;
    my @params = ('$self');
    my $proto = '$';

$rule_sub->append_statement->append_new_pc_variable ('$', undef, 'token')
                       ->variable_scope ('my');

    my $return;
my $next_token_required = 1;
C: for my $child (@{$rules{$rule_name}->{source}->child_nodes}) {
next C unless $child->node_type == $child->ELEMENT_NODE;
      if ($child->
namespace_uri
 . $child->
local_name
            eq 

'http://suika.fam.cx/~wakaba/archive/2005/11/pg/parameterDeclaration'
) {
        push @params, '$'.$child->
get_attribute_ns

                            (
undef
, 'name');
        $proto .= '$';
      } else {
        my $rv;
        

{

local $Error::Depth = $Error::Depth + 1;

{



          ($next_token_required, $rv)
            = $rstatement_to_code
                ->($rule_sub, $child,
                   $next_token_required, \%rules, \%root_rules,
                   $codeDocument, dis_resource => $opt{dis_resource},
                   ns_context => $opt{context_object});
        


;}


;}

;
        $return ||= $rv;
      }
}

    $params_s->append_code ('my ('.join (', ', @params).') = @_');
    $rule_sub->prototype ($proto);

unless ($next_token_required) {
for ($rule_sub->append_statement
            ->append_new_pc_function_call (undef, 'unshift')
            ->append_new_pc_expression (',')) {
for ($_->append_new_pc_dereference ('@')
       ->append_new_pc_expression ('->')) {
  $_->append_new_pc_variable ('$', undef, 'self');
  $_->append_bare ('{token}');
}
$_->append_new_pc_variable ('$', undef, 'token');
}
}

    if ($return) {
      $rule_sub->
append_statement

               ->
append_new_pc_function_call

                   (
undef
, 'return')
               ->
append_new_pc_variable

                   ('$', 
undef
, $return);
    }
  
  } # for %root_rules

  $rstatement_to_code = 
undef
;




;}


;}

;


;}
$r}
$Message::DOM::DOMFeature::ClassInfo->{q<Message::Util::DIS::DPG::ManakaiDPGRulesElement>}->{has_feature} = {'core',
{'',
'1',
'1.0',
'1',
'2.0',
'1',
'3.0',
'1'},
'http://suika.fam.cx/~wakaba/archive/2005/manakai/util/dis#dpg',
{'',
'1',
'1.0',
'1'},
'xml',
{'',
'1',
'1.0',
'1',
'2.0',
'1',
'3.0',
'1'},
'xmlversion',
{'',
'1',
'1.0',
'1',
'1.1',
'1'}};
$Message::DOM::ClassPoint{q<Message::Util::DIS::DPG::ManakaiDPGRulesElement>} = 15.1;
$Message::DOM::DOMFeature::ClassInfo->{q<Message::DOM::TreeCore::ManakaiDOMElement>}->{compat_class_by_type}->{q<http://suika.fam.cx/~wakaba/archive/2005/11/pg/>}->{q<rules>}->{q<Message::Util::DIS::DPG::ManakaiDPGRulesElement>} = 1;
$Message::Util::Grove::ClassProp{q<Message::Util::DIS::DPG::ManakaiDPGRulesElement>} = {'o0',
['parent'],
's1a',
['child'],
's2hh',
['attr'],
'w0',
['od']};
package Message::Util::IF::DPGRuleElement;
our $VERSION = 20060401.0604;
package Message::Util::DIS::DPG::ManakaiDPGRuleElement;
our $VERSION = 20060401.0604;
push our @ISA, 'Message::Util::DIS::DPG::ManakaiDPGElement',
'Message::Util::DIS::DPG::ManakaiDPGElementAttribute',
'Message::DOM::IFLatest::Element',
'Message::DOM::IFLatest::Node',
'Message::Util::IF::DPGElement',
'Message::Util::IF::DPGElementAttribute',
'Message::Util::IF::DPGRuleElement';
$Message::DOM::DOMFeature::ClassInfo->{q<Message::Util::DIS::DPG::ManakaiDPGRuleElement>}->{has_feature} = {'core',
{'',
'1',
'1.0',
'1',
'2.0',
'1',
'3.0',
'1'},
'http://suika.fam.cx/~wakaba/archive/2005/manakai/util/dis#dpg',
{'',
'1',
'1.0',
'1'},
'xml',
{'',
'1',
'1.0',
'1',
'2.0',
'1',
'3.0',
'1'},
'xmlversion',
{'',
'1',
'1.0',
'1',
'1.1',
'1'}};
$Message::DOM::ClassPoint{q<Message::Util::DIS::DPG::ManakaiDPGRuleElement>} = 15.1;
$Message::DOM::DOMFeature::ClassInfo->{q<Message::DOM::TreeCore::ManakaiDOMElement>}->{compat_class_by_type}->{q<http://suika.fam.cx/~wakaba/archive/2005/11/pg/>}->{q<rule>}->{q<Message::Util::DIS::DPG::ManakaiDPGRuleElement>} = 1;
$Message::Util::Grove::ClassProp{q<Message::Util::DIS::DPG::ManakaiDPGRuleElement>} = {'o0',
['parent'],
's1a',
['child'],
's2hh',
['attr'],
'w0',
['od']};
package Message::Util::IF::DPGMatchStatementElement;
our $VERSION = 20060401.0604;
package Message::Util::DIS::DPG::ManakaiDPGMatchStatementElement;
our $VERSION = 20060401.0604;
push our @ISA, 'Message::Util::DIS::DPG::ManakaiDPGElement',
'Message::Util::DIS::DPG::ManakaiDPGElementAttribute',
'Message::DOM::IFLatest::Element',
'Message::DOM::IFLatest::Node',
'Message::Util::IF::DPGElement',
'Message::Util::IF::DPGElementAttribute',
'Message::Util::IF::DPGMatchStatementElement';
$Message::DOM::DOMFeature::ClassInfo->{q<Message::Util::DIS::DPG::ManakaiDPGMatchStatementElement>}->{has_feature} = {'core',
{'',
'1',
'1.0',
'1',
'2.0',
'1',
'3.0',
'1'},
'http://suika.fam.cx/~wakaba/archive/2005/manakai/util/dis#dpg',
{'',
'1',
'1.0',
'1'},
'xml',
{'',
'1',
'1.0',
'1',
'2.0',
'1',
'3.0',
'1'},
'xmlversion',
{'',
'1',
'1.0',
'1',
'1.1',
'1'}};
$Message::DOM::ClassPoint{q<Message::Util::DIS::DPG::ManakaiDPGMatchStatementElement>} = 15.1;
$Message::DOM::DOMFeature::ClassInfo->{q<Message::DOM::TreeCore::ManakaiDOMElement>}->{compat_class_by_type}->{q<http://suika.fam.cx/~wakaba/archive/2005/11/pg/>}->{q<matchStatement>}->{q<Message::Util::DIS::DPG::ManakaiDPGMatchStatementElement>} = 1;
$Message::Util::Grove::ClassProp{q<Message::Util::DIS::DPG::ManakaiDPGMatchStatementElement>} = {'o0',
['parent'],
's1a',
['child'],
's2hh',
['attr'],
'w0',
['od']};
package Message::Util::IF::DPGMatchBlockElement;
our $VERSION = 20060401.0604;
package Message::Util::DIS::DPG::ManakaiDPGMatchBlockElement;
our $VERSION = 20060401.0604;
push our @ISA, 'Message::Util::DIS::DPG::ManakaiDPGElement',
'Message::Util::DIS::DPG::ManakaiDPGElementAttribute',
'Message::DOM::IFLatest::Element',
'Message::DOM::IFLatest::Node',
'Message::Util::IF::DPGElement',
'Message::Util::IF::DPGElementAttribute',
'Message::Util::IF::DPGMatchBlockElement';
$Message::DOM::DOMFeature::ClassInfo->{q<Message::Util::DIS::DPG::ManakaiDPGMatchBlockElement>}->{has_feature} = {'core',
{'',
'1',
'1.0',
'1',
'2.0',
'1',
'3.0',
'1'},
'http://suika.fam.cx/~wakaba/archive/2005/manakai/util/dis#dpg',
{'',
'1',
'1.0',
'1'},
'xml',
{'',
'1',
'1.0',
'1',
'2.0',
'1',
'3.0',
'1'},
'xmlversion',
{'',
'1',
'1.0',
'1',
'1.1',
'1'}};
$Message::DOM::ClassPoint{q<Message::Util::DIS::DPG::ManakaiDPGMatchBlockElement>} = 15.1;
$Message::DOM::DOMFeature::ClassInfo->{q<Message::DOM::TreeCore::ManakaiDOMElement>}->{compat_class_by_type}->{q<http://suika.fam.cx/~wakaba/archive/2005/11/pg/>}->{q<matchBlock>}->{q<Message::Util::DIS::DPG::ManakaiDPGMatchBlockElement>} = 1;
$Message::Util::Grove::ClassProp{q<Message::Util::DIS::DPG::ManakaiDPGMatchBlockElement>} = {'o0',
['parent'],
's1a',
['child'],
's2hh',
['attr'],
'w0',
['od']};
package Message::Util::IF::DPGMatchElseBlockElement;
our $VERSION = 20060401.0604;
package Message::Util::DIS::DPG::ManakaiDPGMatchElseBlockElement;
our $VERSION = 20060401.0604;
push our @ISA, 'Message::Util::DIS::DPG::ManakaiDPGElement',
'Message::Util::DIS::DPG::ManakaiDPGElementAttribute',
'Message::DOM::IFLatest::Element',
'Message::DOM::IFLatest::Node',
'Message::Util::IF::DPGElement',
'Message::Util::IF::DPGElementAttribute',
'Message::Util::IF::DPGMatchElseBlockElement';
$Message::DOM::DOMFeature::ClassInfo->{q<Message::Util::DIS::DPG::ManakaiDPGMatchElseBlockElement>}->{has_feature} = {'core',
{'',
'1',
'1.0',
'1',
'2.0',
'1',
'3.0',
'1'},
'http://suika.fam.cx/~wakaba/archive/2005/manakai/util/dis#dpg',
{'',
'1',
'1.0',
'1'},
'xml',
{'',
'1',
'1.0',
'1',
'2.0',
'1',
'3.0',
'1'},
'xmlversion',
{'',
'1',
'1.0',
'1',
'1.1',
'1'}};
$Message::DOM::ClassPoint{q<Message::Util::DIS::DPG::ManakaiDPGMatchElseBlockElement>} = 15.1;
$Message::DOM::DOMFeature::ClassInfo->{q<Message::DOM::TreeCore::ManakaiDOMElement>}->{compat_class_by_type}->{q<http://suika.fam.cx/~wakaba/archive/2005/11/pg/>}->{q<matchElseBlock>}->{q<Message::Util::DIS::DPG::ManakaiDPGMatchElseBlockElement>} = 1;
$Message::Util::Grove::ClassProp{q<Message::Util::DIS::DPG::ManakaiDPGMatchElseBlockElement>} = {'o0',
['parent'],
's1a',
['child'],
's2hh',
['attr'],
'w0',
['od']};
package Message::Util::IF::DPGMyStatementElement;
our $VERSION = 20060401.0604;
package Message::Util::DIS::DPG::ManakaiDPGMyStatementElement;
our $VERSION = 20060401.0604;
push our @ISA, 'Message::Util::DIS::DPG::ManakaiDPGElement',
'Message::Util::DIS::DPG::ManakaiDPGElementAttribute',
'Message::DOM::IFLatest::Element',
'Message::DOM::IFLatest::Node',
'Message::Util::IF::DPGElement',
'Message::Util::IF::DPGElementAttribute',
'Message::Util::IF::DPGMyStatementElement';
$Message::DOM::DOMFeature::ClassInfo->{q<Message::Util::DIS::DPG::ManakaiDPGMyStatementElement>}->{has_feature} = {'core',
{'',
'1',
'1.0',
'1',
'2.0',
'1',
'3.0',
'1'},
'http://suika.fam.cx/~wakaba/archive/2005/manakai/util/dis#dpg',
{'',
'1',
'1.0',
'1'},
'xml',
{'',
'1',
'1.0',
'1',
'2.0',
'1',
'3.0',
'1'},
'xmlversion',
{'',
'1',
'1.0',
'1',
'1.1',
'1'}};
$Message::DOM::ClassPoint{q<Message::Util::DIS::DPG::ManakaiDPGMyStatementElement>} = 15.1;
$Message::DOM::DOMFeature::ClassInfo->{q<Message::DOM::TreeCore::ManakaiDOMElement>}->{compat_class_by_type}->{q<http://suika.fam.cx/~wakaba/archive/2005/11/pg/>}->{q<myStatement>}->{q<Message::Util::DIS::DPG::ManakaiDPGMyStatementElement>} = 1;
$Message::Util::Grove::ClassProp{q<Message::Util::DIS::DPG::ManakaiDPGMyStatementElement>} = {'o0',
['parent'],
's1a',
['child'],
's2hh',
['attr'],
'w0',
['od']};
package Message::Util::IF::DPGEmbedStatementElement;
our $VERSION = 20060401.0604;
package Message::Util::DIS::DPG::ManakaiDPGEmbedStatementElement;
our $VERSION = 20060401.0604;
push our @ISA, 'Message::Util::DIS::DPG::ManakaiDPGElement',
'Message::Util::DIS::DPG::ManakaiDPGElementAttribute',
'Message::DOM::IFLatest::Element',
'Message::DOM::IFLatest::Node',
'Message::Util::IF::DPGElement',
'Message::Util::IF::DPGElementAttribute',
'Message::Util::IF::DPGEmbedStatementElement';
$Message::DOM::DOMFeature::ClassInfo->{q<Message::Util::DIS::DPG::ManakaiDPGEmbedStatementElement>}->{has_feature} = {'core',
{'',
'1',
'1.0',
'1',
'2.0',
'1',
'3.0',
'1'},
'http://suika.fam.cx/~wakaba/archive/2005/manakai/util/dis#dpg',
{'',
'1',
'1.0',
'1'},
'xml',
{'',
'1',
'1.0',
'1',
'2.0',
'1',
'3.0',
'1'},
'xmlversion',
{'',
'1',
'1.0',
'1',
'1.1',
'1'}};
$Message::DOM::ClassPoint{q<Message::Util::DIS::DPG::ManakaiDPGEmbedStatementElement>} = 15.1;
$Message::DOM::DOMFeature::ClassInfo->{q<Message::DOM::TreeCore::ManakaiDOMElement>}->{compat_class_by_type}->{q<http://suika.fam.cx/~wakaba/archive/2005/11/pg/>}->{q<embedStatement>}->{q<Message::Util::DIS::DPG::ManakaiDPGEmbedStatementElement>} = 1;
$Message::Util::Grove::ClassProp{q<Message::Util::DIS::DPG::ManakaiDPGEmbedStatementElement>} = {'o0',
['parent'],
's1a',
['child'],
's2hh',
['attr'],
'w0',
['od']};
package Message::Util::IF::DPGRuleRefStatementElement;
our $VERSION = 20060401.0604;
package Message::Util::DIS::DPG::ManakaiDPGRuleRefStatementElement;
our $VERSION = 20060401.0604;
push our @ISA, 'Message::Util::DIS::DPG::ManakaiDPGElement',
'Message::Util::DIS::DPG::ManakaiDPGElementAttribute',
'Message::DOM::IFLatest::Element',
'Message::DOM::IFLatest::Node',
'Message::Util::IF::DPGElement',
'Message::Util::IF::DPGElementAttribute',
'Message::Util::IF::DPGRuleRefStatementElement';
$Message::DOM::DOMFeature::ClassInfo->{q<Message::Util::DIS::DPG::ManakaiDPGRuleRefStatementElement>}->{has_feature} = {'core',
{'',
'1',
'1.0',
'1',
'2.0',
'1',
'3.0',
'1'},
'http://suika.fam.cx/~wakaba/archive/2005/manakai/util/dis#dpg',
{'',
'1',
'1.0',
'1'},
'xml',
{'',
'1',
'1.0',
'1',
'2.0',
'1',
'3.0',
'1'},
'xmlversion',
{'',
'1',
'1.0',
'1',
'1.1',
'1'}};
$Message::DOM::ClassPoint{q<Message::Util::DIS::DPG::ManakaiDPGRuleRefStatementElement>} = 15.1;
$Message::DOM::DOMFeature::ClassInfo->{q<Message::DOM::TreeCore::ManakaiDOMElement>}->{compat_class_by_type}->{q<http://suika.fam.cx/~wakaba/archive/2005/11/pg/>}->{q<ruleRefStatement>}->{q<Message::Util::DIS::DPG::ManakaiDPGRuleRefStatementElement>} = 1;
$Message::Util::Grove::ClassProp{q<Message::Util::DIS::DPG::ManakaiDPGRuleRefStatementElement>} = {'o0',
['parent'],
's1a',
['child'],
's2hh',
['attr'],
'w0',
['od']};
package Message::Util::IF::DPGLexmodeElement;
our $VERSION = 20060401.0604;
package Message::Util::DIS::DPG::ManakaiDPGLexmodeElement;
our $VERSION = 20060401.0604;
push our @ISA, 'Message::Util::DIS::DPG::ManakaiDPGElement',
'Message::Util::DIS::DPG::ManakaiDPGElementAttribute',
'Message::DOM::IFLatest::Element',
'Message::DOM::IFLatest::Node',
'Message::Util::IF::DPGElement',
'Message::Util::IF::DPGElementAttribute',
'Message::Util::IF::DPGLexmodeElement';
$Message::DOM::DOMFeature::ClassInfo->{q<Message::Util::DIS::DPG::ManakaiDPGLexmodeElement>}->{has_feature} = {'core',
{'',
'1',
'1.0',
'1',
'2.0',
'1',
'3.0',
'1'},
'http://suika.fam.cx/~wakaba/archive/2005/manakai/util/dis#dpg',
{'',
'1',
'1.0',
'1'},
'xml',
{'',
'1',
'1.0',
'1',
'2.0',
'1',
'3.0',
'1'},
'xmlversion',
{'',
'1',
'1.0',
'1',
'1.1',
'1'}};
$Message::DOM::ClassPoint{q<Message::Util::DIS::DPG::ManakaiDPGLexmodeElement>} = 15.1;
$Message::DOM::DOMFeature::ClassInfo->{q<Message::DOM::TreeCore::ManakaiDOMElement>}->{compat_class_by_type}->{q<http://suika.fam.cx/~wakaba/archive/2005/11/pg/>}->{q<lexmode>}->{q<Message::Util::DIS::DPG::ManakaiDPGLexmodeElement>} = 1;
$Message::Util::Grove::ClassProp{q<Message::Util::DIS::DPG::ManakaiDPGLexmodeElement>} = {'o0',
['parent'],
's1a',
['child'],
's2hh',
['attr'],
'w0',
['od']};
package Message::Util::IF::DPGLAssignmentStatementElement;
our $VERSION = 20060401.0604;
package Message::Util::DIS::DPG::ManakaiDPGLAssignmentStatementElement;
our $VERSION = 20060401.0604;
push our @ISA, 'Message::Util::DIS::DPG::ManakaiDPGElement',
'Message::Util::DIS::DPG::ManakaiDPGElementAttribute',
'Message::DOM::IFLatest::Element',
'Message::DOM::IFLatest::Node',
'Message::Util::IF::DPGElement',
'Message::Util::IF::DPGElementAttribute',
'Message::Util::IF::DPGLAssignmentStatementElement';
$Message::DOM::DOMFeature::ClassInfo->{q<Message::Util::DIS::DPG::ManakaiDPGLAssignmentStatementElement>}->{has_feature} = {'core',
{'',
'1',
'1.0',
'1',
'2.0',
'1',
'3.0',
'1'},
'http://suika.fam.cx/~wakaba/archive/2005/manakai/util/dis#dpg',
{'',
'1',
'1.0',
'1'},
'xml',
{'',
'1',
'1.0',
'1',
'2.0',
'1',
'3.0',
'1'},
'xmlversion',
{'',
'1',
'1.0',
'1',
'1.1',
'1'}};
$Message::DOM::ClassPoint{q<Message::Util::DIS::DPG::ManakaiDPGLAssignmentStatementElement>} = 15.1;
$Message::DOM::DOMFeature::ClassInfo->{q<Message::DOM::TreeCore::ManakaiDOMElement>}->{compat_class_by_type}->{q<http://suika.fam.cx/~wakaba/archive/2005/11/pg/>}->{q<lAssignmentStatement>}->{q<Message::Util::DIS::DPG::ManakaiDPGLAssignmentStatementElement>} = 1;
$Message::Util::Grove::ClassProp{q<Message::Util::DIS::DPG::ManakaiDPGLAssignmentStatementElement>} = {'o0',
['parent'],
's1a',
['child'],
's2hh',
['attr'],
'w0',
['od']};
package Message::Util::IF::DPGLQDefaultTokenStatementElement;
our $VERSION = 20060401.0604;
package Message::Util::DIS::DPG::ManakaiDPGLQDefaultTokenStatementElement;
our $VERSION = 20060401.0604;
push our @ISA, 'Message::Util::DIS::DPG::ManakaiDPGElement',
'Message::Util::DIS::DPG::ManakaiDPGElementAttribute',
'Message::DOM::IFLatest::Element',
'Message::DOM::IFLatest::Node',
'Message::Util::IF::DPGElement',
'Message::Util::IF::DPGElementAttribute',
'Message::Util::IF::DPGLQDefaultTokenStatementElement';
$Message::DOM::DOMFeature::ClassInfo->{q<Message::Util::DIS::DPG::ManakaiDPGLQDefaultTokenStatementElement>}->{has_feature} = {'core',
{'',
'1',
'1.0',
'1',
'2.0',
'1',
'3.0',
'1'},
'http://suika.fam.cx/~wakaba/archive/2005/manakai/util/dis#dpg',
{'',
'1',
'1.0',
'1'},
'xml',
{'',
'1',
'1.0',
'1',
'2.0',
'1',
'3.0',
'1'},
'xmlversion',
{'',
'1',
'1.0',
'1',
'1.1',
'1'}};
$Message::DOM::ClassPoint{q<Message::Util::DIS::DPG::ManakaiDPGLQDefaultTokenStatementElement>} = 15.1;
$Message::DOM::DOMFeature::ClassInfo->{q<Message::DOM::TreeCore::ManakaiDOMElement>}->{compat_class_by_type}->{q<http://suika.fam.cx/~wakaba/archive/2005/11/pg/>}->{q<lQDefaultTokenStatement>}->{q<Message::Util::DIS::DPG::ManakaiDPGLQDefaultTokenStatementElement>} = 1;
$Message::Util::Grove::ClassProp{q<Message::Util::DIS::DPG::ManakaiDPGLQDefaultTokenStatementElement>} = {'o0',
['parent'],
's1a',
['child'],
's2hh',
['attr'],
'w0',
['od']};
package Message::Util::IF::DPGTokenErrorElement;
our $VERSION = 20060401.0604;
package Message::Util::DIS::DPG::ManakaiDPGTokenErrorElement;
our $VERSION = 20060401.0604;
push our @ISA, 'Message::Util::DIS::DPG::ManakaiDPGElement',
'Message::Util::DIS::DPG::ManakaiDPGElementAttribute',
'Message::DOM::IFLatest::Element',
'Message::DOM::IFLatest::Node',
'Message::Util::IF::DPGElement',
'Message::Util::IF::DPGElementAttribute',
'Message::Util::IF::DPGTokenErrorElement';
$Message::DOM::DOMFeature::ClassInfo->{q<Message::Util::DIS::DPG::ManakaiDPGTokenErrorElement>}->{has_feature} = {'core',
{'',
'1',
'1.0',
'1',
'2.0',
'1',
'3.0',
'1'},
'http://suika.fam.cx/~wakaba/archive/2005/manakai/util/dis#dpg',
{'',
'1',
'1.0',
'1'},
'xml',
{'',
'1',
'1.0',
'1',
'2.0',
'1',
'3.0',
'1'},
'xmlversion',
{'',
'1',
'1.0',
'1',
'1.1',
'1'}};
$Message::DOM::ClassPoint{q<Message::Util::DIS::DPG::ManakaiDPGTokenErrorElement>} = 15.1;
$Message::DOM::DOMFeature::ClassInfo->{q<Message::DOM::TreeCore::ManakaiDOMElement>}->{compat_class_by_type}->{q<http://suika.fam.cx/~wakaba/archive/2005/11/pg/>}->{q<tokenError>}->{q<Message::Util::DIS::DPG::ManakaiDPGTokenErrorElement>} = 1;
$Message::Util::Grove::ClassProp{q<Message::Util::DIS::DPG::ManakaiDPGTokenErrorElement>} = {'o0',
['parent'],
's1a',
['child'],
's2hh',
['attr'],
'w0',
['od']};
package Message::Util::IF::DPGParser;
our $VERSION = 20060401.0604;
package Message::Util::DIS::DPG::ManakaiDPGParser;
our $VERSION = 20060401.0604;
push our @ISA, 'Message::Util::Error::MUErrorTarget',
'Message::Util::IF::DPGParser';
sub dom_config ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r;

{


{


$r = bless [$self, $self, 'Message::Util::IF::DPGParser'],
                
'Message::DOM::DOMCore::ManakaiDOMConfiguration'
;


;}

;


;}
$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::Util::DIS::DPG::ManakaiDPGParser', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'dom_config';
}
}
sub new ($$$) {
my ($self, $impl, $features) = @_;

{


{

if 
(CORE::defined $features) {
  if (CORE::ref ($features) eq 'HASH') {
    my $__new = {};
    for my $__fname (keys %{$features}) {
      if (CORE::ref ($features->{$__fname}) eq 'HASH') {
        my $__lfname = lc $__fname;
        for my $__fver (keys %{$features->{$__fname}}) {
          $__new->{$__lfname}->{$__fver} = $features->{$__fname}->{$__fver};
        }
      } elsif (CORE::ref ($features->{$__fname}) eq 'ARRAY') {
        my $__lfname = lc $__fname;
        for my $__fver (@{$features->{$__fname}}) {
          $__new->{$__lfname}->{$__fver} = 
1
;
        }
      } else {
        $__new->{lc $__fname} = {(CORE::defined $features->{$__fname}
                                ? $features->{$__fname} : '') => 
1
};
      }
    }
    $features = $__new;
  } else {
    my @__f = split /\s+/, $features;
    my $__new = {};
    while (@__f) {
      my $__name = lc shift @__f;
      if (@__f and $__f[0] =~ /^[\d\.]+$/) {
        $__new->{$__name}->{shift @__f} = 1;
      } else {
        $__new->{$__name}->{''} = 1;
      }
    }
    $features = $__new;
  }
} else {
  $features = {};
}


;}

;


;}
my $r;

{


$r = bless {
  
'impl'

    => $impl->
get_feature

         (
'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS#DPG'
 => ''),
}, $self;


;}
$r}
sub parse_string ($$$) {
my ($self, $sourceText, $namespaceContext) = @_;
my $r;

{


$self->{char} = [];
$self->{token} = [];
$self->{source} = $sourceText;
$self->{nsresolver} = $namespaceContext;
$self->{location} = {};


{

local $Error::Depth = $Error::Depth + 1;

{



  $r = $self->_parse_Rules ($self->{
'impl'
});



;}


;}

;


;}
$r}
sub _shift_char ($) {
my ($self) = @_;
my $r = 0;

{

if 
(@{$self->{char}}) {
  $r = shift @{$self->{char}};
} else {
  my $char = substr ($self->{source}, pos ($self->{source}), 1);
  pos ($self->{source})++;

  if (length $char) {
    $r = ord $char;
  } else {
    $r = -1;
  }
}


;}
$r}
sub _parse_embed_block ($$$) {
my ($self, $doc, $parent) = @_;

{

my 
$token = $self->_scan_default;
if ($token->{type} eq 'LBRACE') {
  my $nest_count = 1; # already opened
  my $s = '';
  

{

local $Error::Depth = $Error::Depth + 1;

{


    C: 
while ((my $ch = $self->
_shift_char
) > -1) {
      if ($ch == 0x007B) {
        $s .= '{'; # }
        $nest_count++;
      } elsif ($ch == 0x007D) {
        if (--$nest_count == 0) {
          last C;
        } elsif ($nest_count < 0) {
          $nest_count = 0;
        }
        $s .= chr $ch;
      } else {
        $s .= chr $ch;
      }
    }

    if (length $s) {
      my $el = $doc->
create_element_ns

                (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'embedBlock');
      $el->
text_content
 ($s);
      $parent->
append_child
 ($el);
    }
  


;}


;}

;
} else {
  unshift @{$self->{token}}, $token;
}


;}
}
sub ___report_error ($$) {
my ($self, $err) = @_;
my $r;

{

if 
($err->isa (
'Message::DOM::IF::DOMError'
)) {
  

{

local $Error::Depth = $Error::Depth + 1;

{


    A: 
{
      my $cfg = $self->
dom_config
;
      my $h = $cfg->
get_parameter

                       ('error-handler');
      $r = $h->
handle_error
 ($err);
    } # A
  


;}


;}

;
} else {
  $err->
throw
;
}


;}
$r}
sub _scan_default ($) {
my $self = shift ();
if (@{$self->{token}}) 
{

return shift (@{$self->{token}});


}
my $ch = -2;
my $location = {%{$self->{location}},
                 char_d => 0+@{$self->{char}}};

S__initial:
{

my @ch;
push (@ch, $ch);
my $ch = $self->_shift_char;
if (((9 <= $ch) and ($ch <= 13)) or ($ch == 32)) 
{

push (@ch, $ch);

SWSP__1:
{

my $ch = $self->_shift_char;
if (((9 <= $ch) and ($ch <= 13)) or ($ch == 32)) 
{

push (@ch, $ch);
redo SWSP__1;


}
else 
{

unshift (@{$self->{char}}, $ch);
$ch = -2;


}
redo S__initial;


}
# SWSP__1


}
elsif ($ch == 59) 
{

push (@ch, $ch);

SSEMICOLON__1____COMMENT__1:
{

my $ch = $self->_shift_char;
if ($ch == 59) 
{

push (@ch, $ch);

SCOMMENT__2:
{

my $ch = $self->_shift_char;
if (((0 <= $ch) and ($ch <= 9)) or 14 <= $ch) 
{

push (@ch, $ch);

SCOMMENT__3:
{

my $ch = $self->_shift_char;
if (((0 <= $ch) and ($ch <= 9)) or 14 <= $ch) 
{

push (@ch, $ch);
redo SCOMMENT__3;


}
elsif ((10 <= $ch) and ($ch <= 13)) 
{

push (@ch, $ch);

SCOMMENT__4:
{

my $ch = $self->_shift_char;
if ((10 <= $ch) and ($ch <= 13)) 
{

push (@ch, $ch);
redo SCOMMENT__4;


}
else 
{

unshift (@{$self->{char}}, $ch);
$ch = -2;


}
redo S__initial;


}
# SCOMMENT__4
unshift (@{$self->{char}}, $ch);


}
else 
{

unshift (@{$self->{char}}, $ch);
$ch = -2;


}
redo S__initial;


}
# SCOMMENT__3
unshift (@{$self->{char}}, $ch);


}
elsif ((10 <= $ch) and ($ch <= 13)) 
{

push (@ch, $ch);

SCOMMENT__4:
{

my $ch = $self->_shift_char;
if ((10 <= $ch) and ($ch <= 13)) 
{

push (@ch, $ch);
redo SCOMMENT__4;


}
else 
{

unshift (@{$self->{char}}, $ch);
$ch = -2;


}
redo S__initial;


}
# SCOMMENT__4
unshift (@{$self->{char}}, $ch);


}
else 
{

unshift (@{$self->{char}}, $ch);
$ch = -2;


}
redo S__initial;


}
# SCOMMENT__2
unshift (@{$self->{char}}, $ch);


}
else 
{

unshift (@{$self->{char}}, $ch);
$ch = -2;


}
return {'location',
$location,
'type',
'SEMICOLON'};


}
# SSEMICOLON__1____COMMENT__1


}
elsif ($ch == 47) 
{

push (@ch, $ch);

SCommentLine__1____CommentPhrase__1:
{

my $ch = $self->_shift_char;
if ($ch == 47) 
{

push (@ch, $ch);

SCommentLine__2:
{

my $ch = $self->_shift_char;
if (((0 <= $ch) and ($ch <= 9)) or 14 <= $ch) 
{

push (@ch, $ch);

SCommentLine__3:
{

my $ch = $self->_shift_char;
if (((0 <= $ch) and ($ch <= 9)) or 14 <= $ch) 
{

push (@ch, $ch);
redo SCommentLine__3;


}
elsif ((10 <= $ch) and ($ch <= 13)) 
{

push (@ch, $ch);

SCommentLine__4:
{

my $ch = $self->_shift_char;
if ((10 <= $ch) and ($ch <= 13)) 
{

push (@ch, $ch);
redo SCommentLine__4;


}
else 
{

unshift (@{$self->{char}}, $ch);
$ch = -2;


}
redo S__initial;


}
# SCommentLine__4
unshift (@{$self->{char}}, $ch);


}
else 
{

unshift (@{$self->{char}}, $ch);
$ch = -2;


}
redo S__initial;


}
# SCommentLine__3
unshift (@{$self->{char}}, $ch);


}
elsif ((10 <= $ch) and ($ch <= 13)) 
{

push (@ch, $ch);

SCommentLine__4:
{

my $ch = $self->_shift_char;
if ((10 <= $ch) and ($ch <= 13)) 
{

push (@ch, $ch);
redo SCommentLine__4;


}
else 
{

unshift (@{$self->{char}}, $ch);
$ch = -2;


}
redo S__initial;


}
# SCommentLine__4
unshift (@{$self->{char}}, $ch);


}
else 
{

unshift (@{$self->{char}}, $ch);
$ch = -2;


}
redo S__initial;


}
# SCommentLine__2


}
elsif ($ch == 42) 
{

push (@ch, $ch);

SCommentPhrase__2:
{

my $ch = $self->_shift_char;
if (((0 <= $ch) and ($ch <= 41)) or 43 <= $ch) 
{

push (@ch, $ch);

SCommentPhrase__3:
{

my $ch = $self->_shift_char;
if (((0 <= $ch) and ($ch <= 41)) or 43 <= $ch) 
{

push (@ch, $ch);
redo SCommentPhrase__3;


}
elsif ($ch == 42) 
{

push (@ch, $ch);

SCommentPhrase__4:
{

my $ch = $self->_shift_char;
if ($ch == 42) 
{

push (@ch, $ch);
redo SCommentPhrase__4;


}
elsif (((0 <= $ch) and ($ch <= 41)) or ((43 <= $ch) and ($ch <= 46)) or 48 <= $ch) 
{

push (@ch, $ch);

SCommentPhrase__5___00000024CommentPhrase0__1:
{

my $ch = $self->_shift_char;
if (((0 <= $ch) and ($ch <= 41)) or 43 <= $ch) 
{

push (@ch, $ch);

SCommentPhrase__5___00000024CommentPhrase0__2:
{

my $ch = $self->_shift_char;
if (((0 <= $ch) and ($ch <= 41)) or 43 <= $ch) 
{

push (@ch, $ch);
redo SCommentPhrase__5___00000024CommentPhrase0__2;


}
elsif ($ch == 42) 
{

push (@ch, $ch);

SCommentPhrase__5___00000024CommentPhrase0__3:
{

my $ch = $self->_shift_char;
if ($ch == 42) 
{

push (@ch, $ch);
redo SCommentPhrase__5___00000024CommentPhrase0__3;


}
elsif (((0 <= $ch) and ($ch <= 41)) or ((43 <= $ch) and ($ch <= 46)) or 48 <= $ch) 
{

push (@ch, $ch);
redo SCommentPhrase__5___00000024CommentPhrase0__1;


}
elsif ($ch == 47) 
{


SCommentPhrase__6:
{

redo S__initial;


}
# SCommentPhrase__6


}
unshift (@{$self->{char}}, $ch);


}
# SCommentPhrase__5___00000024CommentPhrase0__3


}
unshift (@{$self->{char}}, $ch);


}
# SCommentPhrase__5___00000024CommentPhrase0__2


}
elsif ($ch == 42) 
{

push (@ch, $ch);

SCommentPhrase__5___00000024CommentPhrase0__3:
{

my $ch = $self->_shift_char;
if ($ch == 42) 
{

push (@ch, $ch);
redo SCommentPhrase__5___00000024CommentPhrase0__3;


}
elsif (((0 <= $ch) and ($ch <= 41)) or ((43 <= $ch) and ($ch <= 46)) or 48 <= $ch) 
{

push (@ch, $ch);
redo SCommentPhrase__5___00000024CommentPhrase0__1;


}
elsif ($ch == 47) 
{


SCommentPhrase__6:
{

redo S__initial;


}
# SCommentPhrase__6


}
unshift (@{$self->{char}}, $ch);


}
# SCommentPhrase__5___00000024CommentPhrase0__3


}
unshift (@{$self->{char}}, $ch);


}
# SCommentPhrase__5___00000024CommentPhrase0__1


}
elsif ($ch == 47) 
{


SCommentPhrase__6:
{

redo S__initial;


}
# SCommentPhrase__6


}
unshift (@{$self->{char}}, $ch);


}
# SCommentPhrase__4


}
unshift (@{$self->{char}}, $ch);


}
# SCommentPhrase__3


}
elsif ($ch == 42) 
{

push (@ch, $ch);

SCommentPhrase__4:
{

my $ch = $self->_shift_char;
if ($ch == 42) 
{

push (@ch, $ch);
redo SCommentPhrase__4;


}
elsif (((0 <= $ch) and ($ch <= 41)) or ((43 <= $ch) and ($ch <= 46)) or 48 <= $ch) 
{

push (@ch, $ch);

SCommentPhrase__5___00000024CommentPhrase0__1:
{

my $ch = $self->_shift_char;
if (((0 <= $ch) and ($ch <= 41)) or 43 <= $ch) 
{

push (@ch, $ch);

SCommentPhrase__5___00000024CommentPhrase0__2:
{

my $ch = $self->_shift_char;
if (((0 <= $ch) and ($ch <= 41)) or 43 <= $ch) 
{

push (@ch, $ch);
redo SCommentPhrase__5___00000024CommentPhrase0__2;


}
elsif ($ch == 42) 
{

push (@ch, $ch);

SCommentPhrase__5___00000024CommentPhrase0__3:
{

my $ch = $self->_shift_char;
if ($ch == 42) 
{

push (@ch, $ch);
redo SCommentPhrase__5___00000024CommentPhrase0__3;


}
elsif (((0 <= $ch) and ($ch <= 41)) or ((43 <= $ch) and ($ch <= 46)) or 48 <= $ch) 
{

push (@ch, $ch);
redo SCommentPhrase__5___00000024CommentPhrase0__1;


}
elsif ($ch == 47) 
{


SCommentPhrase__6:
{

redo S__initial;


}
# SCommentPhrase__6


}
unshift (@{$self->{char}}, $ch);


}
# SCommentPhrase__5___00000024CommentPhrase0__3


}
unshift (@{$self->{char}}, $ch);


}
# SCommentPhrase__5___00000024CommentPhrase0__2


}
elsif ($ch == 42) 
{

push (@ch, $ch);

SCommentPhrase__5___00000024CommentPhrase0__3:
{

my $ch = $self->_shift_char;
if ($ch == 42) 
{

push (@ch, $ch);
redo SCommentPhrase__5___00000024CommentPhrase0__3;


}
elsif (((0 <= $ch) and ($ch <= 41)) or ((43 <= $ch) and ($ch <= 46)) or 48 <= $ch) 
{

push (@ch, $ch);
redo SCommentPhrase__5___00000024CommentPhrase0__1;


}
elsif ($ch == 47) 
{


SCommentPhrase__6:
{

redo S__initial;


}
# SCommentPhrase__6


}
unshift (@{$self->{char}}, $ch);


}
# SCommentPhrase__5___00000024CommentPhrase0__3


}
unshift (@{$self->{char}}, $ch);


}
# SCommentPhrase__5___00000024CommentPhrase0__1


}
elsif ($ch == 47) 
{


SCommentPhrase__6:
{

redo S__initial;


}
# SCommentPhrase__6


}
unshift (@{$self->{char}}, $ch);


}
# SCommentPhrase__4


}
unshift (@{$self->{char}}, $ch);


}
# SCommentPhrase__2


}
unshift (@{$self->{char}}, $ch);


}
# SCommentLine__1____CommentPhrase__1


}
elsif (($ch == 45) or ((65 <= $ch) and ($ch <= 84)) or ((86 <= $ch) and ($ch <= 90)) or ($ch == 95) or ((97 <= $ch) and ($ch <= 116)) or ((118 <= $ch) and ($ch <= 122))) 
{

push (@ch, $ch);

SNAME__1___00000024name__1:
{

my $ch = $self->_shift_char;
if (($ch == 45) or ((48 <= $ch) and ($ch <= 58)) or ((65 <= $ch) and ($ch <= 90)) or ($ch == 95) or ((97 <= $ch) and ($ch <= 122))) 
{

push (@ch, $ch);

SNAME__1___00000024name__2:
{

my $ch = $self->_shift_char;
if (($ch == 45) or ((48 <= $ch) and ($ch <= 58)) or ((65 <= $ch) and ($ch <= 90)) or ($ch == 95) or ((97 <= $ch) and ($ch <= 122))) 
{

push (@ch, $ch);
redo SNAME__1___00000024name__2;


}
else 
{

unshift (@{$self->{char}}, $ch);
$ch = -2;


}
shift (@ch);
my $token_val = '';
if ($ch > -1) 
{

push (@{$self->{char}}, pop (@ch));


}
while (@ch) 
{

$token_val .= chr (shift (@ch));


}
return {'location',
$location,
'type',
'NAME',
'value',
$token_val};


}
# SNAME__1___00000024name__2
unshift (@{$self->{char}}, $ch);


}
else 
{

unshift (@{$self->{char}}, $ch);
$ch = -2;


}
shift (@ch);
my $token_val = '';
if ($ch > -1) 
{

push (@{$self->{char}}, pop (@ch));


}
while (@ch) 
{

$token_val .= chr (shift (@ch));


}
return {'location',
$location,
'type',
'NAME',
'value',
$token_val};


}
# SNAME__1___00000024name__1


}
elsif (($ch == 85) or ($ch == 117)) 
{

push (@ch, $ch);

SNAME__1___00000024name__1____CHAR__1:
{

my $ch = $self->_shift_char;
if (($ch == 45) or ((48 <= $ch) and ($ch <= 58)) or ((65 <= $ch) and ($ch <= 90)) or ($ch == 95) or ((97 <= $ch) and ($ch <= 122))) 
{

push (@ch, $ch);

SNAME__1___00000024name__2:
{

my $ch = $self->_shift_char;
if (($ch == 45) or ((48 <= $ch) and ($ch <= 58)) or ((65 <= $ch) and ($ch <= 90)) or ($ch == 95) or ((97 <= $ch) and ($ch <= 122))) 
{

push (@ch, $ch);
redo SNAME__1___00000024name__2;


}
else 
{

unshift (@{$self->{char}}, $ch);
$ch = -2;


}
shift (@ch);
my $token_val = '';
if ($ch > -1) 
{

push (@{$self->{char}}, pop (@ch));


}
while (@ch) 
{

$token_val .= chr (shift (@ch));


}
return {'location',
$location,
'type',
'NAME',
'value',
$token_val};


}
# SNAME__1___00000024name__2
unshift (@{$self->{char}}, $ch);


}
elsif ($ch == 43) 
{

push (@ch, $ch);

SCHAR__2:
{

my $ch = $self->_shift_char;
if (((48 <= $ch) and ($ch <= 57)) or ((65 <= $ch) and ($ch <= 70)) or ((97 <= $ch) and ($ch <= 102))) 
{

push (@ch, $ch);

SCHAR__3___00000024hexdigit__1:
{

my $ch = $self->_shift_char;
if (((48 <= $ch) and ($ch <= 57)) or ((65 <= $ch) and ($ch <= 70)) or ((97 <= $ch) and ($ch <= 102))) 
{

push (@ch, $ch);

SCHAR__4___00000024hexdigit__1:
{

my $ch = $self->_shift_char;
if (((48 <= $ch) and ($ch <= 57)) or ((65 <= $ch) and ($ch <= 70)) or ((97 <= $ch) and ($ch <= 102))) 
{

push (@ch, $ch);

SCHAR__5___00000024hexdigit__1:
{

my $ch = $self->_shift_char;
if (((48 <= $ch) and ($ch <= 57)) or ((65 <= $ch) and ($ch <= 70)) or ((97 <= $ch) and ($ch <= 102))) 
{

push (@ch, $ch);

SCHAR__6___00000024hexdigit__1:
{

my $ch = $self->_shift_char;
if (((48 <= $ch) and ($ch <= 57)) or ((65 <= $ch) and ($ch <= 70)) or ((97 <= $ch) and ($ch <= 102))) 
{

push (@ch, $ch);
redo SCHAR__6___00000024hexdigit__1;


}
else 
{

unshift (@{$self->{char}}, $ch);
$ch = -2;


}
shift (@ch);
my $token_val = '';
if ($ch > -1) 
{

push (@{$self->{char}}, pop (@ch));


}
while (@ch) 
{

$token_val .= chr (shift (@ch));


}
return {'location',
$location,
'type',
'CHAR',
'value',
$token_val};


}
# SCHAR__6___00000024hexdigit__1


}
unshift (@{$self->{char}}, $ch);


}
# SCHAR__5___00000024hexdigit__1


}
unshift (@{$self->{char}}, $ch);


}
# SCHAR__4___00000024hexdigit__1


}
unshift (@{$self->{char}}, $ch);


}
# SCHAR__3___00000024hexdigit__1


}
unshift (@{$self->{char}}, $ch);


}
# SCHAR__2
unshift (@{$self->{char}}, $ch);


}
else 
{

unshift (@{$self->{char}}, $ch);
$ch = -2;


}
shift (@ch);
my $token_val = '';
if ($ch > -1) 
{

push (@{$self->{char}}, pop (@ch));


}
while (@ch) 
{

$token_val .= chr (shift (@ch));


}
return {'location',
$location,
'type',
'NAME',
'value',
$token_val};


}
# SNAME__1___00000024name__1____CHAR__1


}
elsif ($ch == 36) 
{

push (@ch, $ch);

SVARIABLE__1:
{

my $ch = $self->_shift_char;
if (($ch == 45) or ((65 <= $ch) and ($ch <= 90)) or ($ch == 95) or ((97 <= $ch) and ($ch <= 122))) 
{

push (@ch, $ch);

SVARIABLE__2___00000024name__1:
{

my $ch = $self->_shift_char;
if (($ch == 45) or ((48 <= $ch) and ($ch <= 58)) or ((65 <= $ch) and ($ch <= 90)) or ($ch == 95) or ((97 <= $ch) and ($ch <= 122))) 
{

push (@ch, $ch);

SVARIABLE__2___00000024name__2:
{

my $ch = $self->_shift_char;
if (($ch == 45) or ((48 <= $ch) and ($ch <= 58)) or ((65 <= $ch) and ($ch <= 90)) or ($ch == 95) or ((97 <= $ch) and ($ch <= 122))) 
{

push (@ch, $ch);
redo SVARIABLE__2___00000024name__2;


}
else 
{

unshift (@{$self->{char}}, $ch);
$ch = -2;


}
shift (@ch);
my $token_val = '';
if ($ch > -1) 
{

push (@{$self->{char}}, pop (@ch));


}
while (@ch) 
{

$token_val .= chr (shift (@ch));


}
return {'location',
$location,
'type',
'VARIABLE',
'value',
$token_val};


}
# SVARIABLE__2___00000024name__2
unshift (@{$self->{char}}, $ch);


}
else 
{

unshift (@{$self->{char}}, $ch);
$ch = -2;


}
shift (@ch);
my $token_val = '';
if ($ch > -1) 
{

push (@{$self->{char}}, pop (@ch));


}
while (@ch) 
{

$token_val .= chr (shift (@ch));


}
return {'location',
$location,
'type',
'VARIABLE',
'value',
$token_val};


}
# SVARIABLE__2___00000024name__1


}
unshift (@{$self->{char}}, $ch);


}
# SVARIABLE__1


}
elsif ($ch == 38) 
{

push (@ch, $ch);

SRULEREF__1:
{

my $ch = $self->_shift_char;
if (($ch == 45) or ((65 <= $ch) and ($ch <= 90)) or ($ch == 95) or ((97 <= $ch) and ($ch <= 122))) 
{

push (@ch, $ch);

SRULEREF__2___00000024name__1:
{

my $ch = $self->_shift_char;
if (($ch == 45) or ((48 <= $ch) and ($ch <= 58)) or ((65 <= $ch) and ($ch <= 90)) or ($ch == 95) or ((97 <= $ch) and ($ch <= 122))) 
{

push (@ch, $ch);

SRULEREF__2___00000024name__2:
{

my $ch = $self->_shift_char;
if (($ch == 45) or ((48 <= $ch) and ($ch <= 58)) or ((65 <= $ch) and ($ch <= 90)) or ($ch == 95) or ((97 <= $ch) and ($ch <= 122))) 
{

push (@ch, $ch);
redo SRULEREF__2___00000024name__2;


}
else 
{

unshift (@{$self->{char}}, $ch);
$ch = -2;


}
shift (@ch);
my $token_val = '';
if ($ch > -1) 
{

push (@{$self->{char}}, pop (@ch));


}
while (@ch) 
{

$token_val .= chr (shift (@ch));


}
return {'location',
$location,
'type',
'RULEREF',
'value',
$token_val};


}
# SRULEREF__2___00000024name__2
unshift (@{$self->{char}}, $ch);


}
else 
{

unshift (@{$self->{char}}, $ch);
$ch = -2;


}
shift (@ch);
my $token_val = '';
if ($ch > -1) 
{

push (@{$self->{char}}, pop (@ch));


}
while (@ch) 
{

$token_val .= chr (shift (@ch));


}
return {'location',
$location,
'type',
'RULEREF',
'value',
$token_val};


}
# SRULEREF__2___00000024name__1


}
unshift (@{$self->{char}}, $ch);


}
# SRULEREF__1


}
elsif ($ch == 63) 
{

push (@ch, $ch);

SZEROONE__1____QKEYWORD__1:
{

my $ch = $self->_shift_char;
if (($ch == 45) or ((65 <= $ch) and ($ch <= 90)) or ($ch == 95) or ((97 <= $ch) and ($ch <= 122))) 
{

push (@ch, $ch);

SQKEYWORD__2___00000024name__1:
{

my $ch = $self->_shift_char;
if (($ch == 45) or ((48 <= $ch) and ($ch <= 58)) or ((65 <= $ch) and ($ch <= 90)) or ($ch == 95) or ((97 <= $ch) and ($ch <= 122))) 
{

push (@ch, $ch);

SQKEYWORD__2___00000024name__2:
{

my $ch = $self->_shift_char;
if (($ch == 45) or ((48 <= $ch) and ($ch <= 58)) or ((65 <= $ch) and ($ch <= 90)) or ($ch == 95) or ((97 <= $ch) and ($ch <= 122))) 
{

push (@ch, $ch);
redo SQKEYWORD__2___00000024name__2;


}
else 
{

unshift (@{$self->{char}}, $ch);
$ch = -2;


}
shift (@ch);
my $token_val = '';
if ($ch > -1) 
{

push (@{$self->{char}}, pop (@ch));


}
while (@ch) 
{

$token_val .= chr (shift (@ch));


}
return {'location',
$location,
'type',
'QKEYWORD',
'value',
$token_val};


}
# SQKEYWORD__2___00000024name__2
unshift (@{$self->{char}}, $ch);


}
else 
{

unshift (@{$self->{char}}, $ch);
$ch = -2;


}
shift (@ch);
my $token_val = '';
if ($ch > -1) 
{

push (@{$self->{char}}, pop (@ch));


}
while (@ch) 
{

$token_val .= chr (shift (@ch));


}
return {'location',
$location,
'type',
'QKEYWORD',
'value',
$token_val};


}
# SQKEYWORD__2___00000024name__1
unshift (@{$self->{char}}, $ch);


}
else 
{

unshift (@{$self->{char}}, $ch);
$ch = -2;


}
return {'location',
$location,
'type',
'ZEROONE'};


}
# SZEROONE__1____QKEYWORD__1


}
elsif ($ch == 39) 
{

push (@ch, $ch);

SSTRING__1:
{

my $ch = $self->_shift_char;
if (((0 <= $ch) and ($ch <= 38)) or ((40 <= $ch) and ($ch <= 91)) or 93 <= $ch) 
{

push (@ch, $ch);

SSTRING__2:
{

my $ch = $self->_shift_char;
if (((0 <= $ch) and ($ch <= 38)) or ((40 <= $ch) and ($ch <= 91)) or 93 <= $ch) 
{

push (@ch, $ch);
redo SSTRING__2;


}
elsif ($ch == 39) 
{


SSTRING__3:
{

shift (@ch);
my $token_val = '';
if ($ch > -1) 
{

push (@ch, $ch);


}
while (@ch) 
{

$token_val .= chr (shift (@ch));


}
return {'location',
$location,
'type',
'STRING',
'value',
$token_val};


}
# SSTRING__3


}
unshift (@{$self->{char}}, $ch);


}
# SSTRING__2


}
elsif ($ch == 39) 
{


SSTRING__3:
{

shift (@ch);
my $token_val = '';
if ($ch > -1) 
{

push (@ch, $ch);


}
while (@ch) 
{

$token_val .= chr (shift (@ch));


}
return {'location',
$location,
'type',
'STRING',
'value',
$token_val};


}
# SSTRING__3


}
unshift (@{$self->{char}}, $ch);


}
# SSTRING__1


}
elsif ($ch == 44) 
{


SCOMMA__1:
{

return {'location',
$location,
'type',
'COMMA'};


}
# SCOMMA__1


}
elsif ($ch == 61) 
{

push (@ch, $ch);

SASSIGN__1____REPLACE__1____EQUALS__1:
{

my $ch = $self->_shift_char;
if ($ch == 62) 
{


SREPLACE__2:
{

return {'location',
$location,
'type',
'REPLACE'};


}
# SREPLACE__2
unshift (@{$self->{char}}, $ch);


}
elsif ($ch == 61) 
{


SEQUALS__2:
{

return {'location',
$location,
'type',
'EQUALS'};


}
# SEQUALS__2
unshift (@{$self->{char}}, $ch);


}
else 
{

unshift (@{$self->{char}}, $ch);
$ch = -2;


}
return {'location',
$location,
'type',
'ASSIGN'};


}
# SASSIGN__1____REPLACE__1____EQUALS__1


}
elsif ($ch == 58) 
{

push (@ch, $ch);

SCOLON__1____DEFINE__1:
{

my $ch = $self->_shift_char;
if ($ch == 61) 
{


SDEFINE__2:
{

return {'location',
$location,
'type',
'DEFINE'};


}
# SDEFINE__2
unshift (@{$self->{char}}, $ch);


}
else 
{

unshift (@{$self->{char}}, $ch);
$ch = -2;


}
return {'location',
$location,
'type',
'COLON'};


}
# SCOLON__1____DEFINE__1


}
elsif ($ch == 40) 
{


SLPAREN__1:
{

return {'location',
$location,
'type',
'LPAREN'};


}
# SLPAREN__1


}
elsif ($ch == 41) 
{


SRPAREN__1:
{

return {'location',
$location,
'type',
'RPAREN'};


}
# SRPAREN__1


}
elsif ($ch == 123) 
{


SLBRACE__1:
{

return {'location',
$location,
'type',
'LBRACE'};


}
# SLBRACE__1


}
elsif ($ch == 125) 
{


SRBRACE__1:
{

return {'location',
$location,
'type',
'RBRACE'};


}
# SRBRACE__1


}
elsif ($ch == 91) 
{

push (@ch, $ch);

SCLSOPEN__1____NCLSOPEN__1:
{

my $ch = $self->_shift_char;
if ($ch == 94) 
{


SNCLSOPEN__2:
{

return {'location',
$location,
'type',
'NCLSOPEN'};


}
# SNCLSOPEN__2
unshift (@{$self->{char}}, $ch);


}
else 
{

unshift (@{$self->{char}}, $ch);
$ch = -2;


}
return {'location',
$location,
'type',
'CLSOPEN'};


}
# SCLSOPEN__1____NCLSOPEN__1


}
elsif ($ch == 93) 
{


SCLSCLOSE__1:
{

return {'location',
$location,
'type',
'CLSCLOSE'};


}
# SCLSCLOSE__1


}
elsif ($ch == 42) 
{


SZEROMORE__1:
{

return {'location',
$location,
'type',
'ZEROMORE'};


}
# SZEROMORE__1


}
elsif ($ch == 43) 
{


SONEMORE__1:
{

return {'location',
$location,
'type',
'ONEMORE'};


}
# SONEMORE__1


}
elsif ($ch == 126) 
{


SMATCH__1:
{

return {'location',
$location,
'type',
'MATCH'};


}
# SMATCH__1


}
elsif ($ch == 46) 
{

push (@ch, $ch);

SDOT__1____RANGE__1:
{

my $ch = $self->_shift_char;
if ($ch == 46) 
{


SRANGE__2:
{

return {'location',
$location,
'type',
'RANGE'};


}
# SRANGE__2
unshift (@{$self->{char}}, $ch);


}
else 
{

unshift (@{$self->{char}}, $ch);
$ch = -2;


}
return {'location',
$location,
'type',
'DOT'};


}
# SDOT__1____RANGE__1


}
elsif ($ch == 35) 
{


SRNI__1:
{

return {'location',
$location,
'type',
'RNI'};


}
# SRNI__1


}
elsif ($ch == 60) 
{


SLANGLE__1:
{

return {'location',
$location,
'type',
'LANGLE'};


}
# SLANGLE__1


}
elsif ($ch == 62) 
{


SRANGLE__1:
{

return {'location',
$location,
'type',
'RANGLE'};


}
# SRANGLE__1


}
elsif ($ch == -1) 
{

return {'location',
$location,
'type',
'#EOF'};


}
return {'location',
$location,
'type',
'#INVALID',
'value',
chr ($ch)};


}
# S__initial
}
sub _parse__CodeBlock ($$$) {
my ($self, $doc, $parent) = @_;
my $token;
my $block;

{



    $block = $doc->
create_element_ns
 (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'codeBlock');
    $parent->
append_child
 ($block);
  


;}
$token = $self->_scan_default;

MATCH_1:
{

if ($token->{type} eq 'MATCH') 
{

my $match;

{



      $match = $doc->
create_element_ns

                       (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'matchStatement');
      $block->
append_child
 ($match);
    


;}

{

my $parent = $match;
$token = $self->_scan_default;
if ($token->{type} eq 'ZEROMORE') 
{


{



      $parent->
set_attribute_ns

                   (
undef
, 'occurence', 'zeromore');
    


;}
$token = $self->_scan_default;


}
elsif ($token->{type} eq 'ONEMORE') 
{


{



      $parent->
set_attribute_ns

                   (
undef
, 'occurence', 'onemore');
    


;}
$token = $self->_scan_default;


}
elsif ($token->{type} eq 'ZEROONE') 
{


{



      $parent->
set_attribute_ns
 
                   (
undef
, 'occurence', 'zeroone');
    


;}
$token = $self->_scan_default;


}


}

{

my $doc = $doc;
my $parent = $match;

MATCH_2:
{

if ($token->{type} eq 'COLON') 
{

$token = $self->_scan_default;
if ($token->{type} eq 'NAME') 
{

my $ael;

{



        $ael = $doc->
create_element_ns

                        (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'attributeSpecification');
        $ael->
set_attribute_ns
 (
undef
, 'name', $token->{value});
        $ael->
set_attribute_ns
 (
undef
, 'value', '1');
        $parent->
append_child
 ($ael);
      


;}

{

my $parent = $ael;
$token = $self->_scan_default;
if ($token->{type} eq 'ZEROMORE') 
{


{



      $parent->
set_attribute_ns

                   (
undef
, 'occurence', 'zeromore');
    


;}
$token = $self->_scan_default;


}
elsif ($token->{type} eq 'ONEMORE') 
{


{



      $parent->
set_attribute_ns

                   (
undef
, 'occurence', 'onemore');
    


;}
$token = $self->_scan_default;


}
elsif ($token->{type} eq 'ZEROONE') 
{


{



      $parent->
set_attribute_ns
 
                   (
undef
, 'occurence', 'zeroone');
    


;}
$token = $self->_scan_default;


}


}
if ($token->{type} eq 'REPLACE') 
{

$token = $self->_scan_default;
if ($token->{type} eq 'STRING') 
{


{



            $ael->
set_attribute_ns

                    (
undef
, 'value',
                     substr ($token->{value}, 1, length ($token->{value}) - 2));
          


;}
$token = $self->_scan_default;


}
elsif ($token->{type} eq 'NAME') 
{


{



            $ael->
set_attribute_ns

                    (
undef
, 'value', $token->{value});
          


;}
$token = $self->_scan_default;


}
else 
{


{


{


    my 
$location = {
      utf32_offset => pos ($self->{source}),
    };
    my $continue = 
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, 'loc' => $location, '-type' => 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/bad-token-error', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest', 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token' => $token, 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/source-text' => \($self->{source});

;
    unless ($continue) {
      
report Message::Util::DIS::DPG::ManakaiDPGException -object => $self, '-type' => 'PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;
    }
    $self->{has_error} = 
1
;
  


;}


}


}


}


}
else 
{


{


{


    my 
$location = {
      utf32_offset => pos ($self->{source}),
    };
    my $continue = 
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, 'loc' => $location, '-type' => 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/bad-token-error', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest', 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token' => $token, 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/source-text' => \($self->{source});

;
    unless ($continue) {
      
report Message::Util::DIS::DPG::ManakaiDPGException -object => $self, '-type' => 'PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;
    }
    $self->{has_error} = 
1
;
  


;}


}


}


}
else 
{

last MATCH_2;


}
redo MATCH_2;


}
# MATCH_2


}

{

my $has_content = 0;

MATCH_3:
{

if ($token->{type} eq 'LPAREN') 
{

$has_content = 1;
my $match_block;

{



        $match_block = $doc->
create_element_ns
 (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'matchBlock');
        $match->
append_child
 ($match_block);
      


;}
$token = $self->_scan_default;
if ($token->{type} eq 'RNI') 
{


{



            $match_block->
set_attribute_ns

                               (
undef
, 'isReservedToken' => '1');
          


;}
$token = $self->_scan_default;


}
if ($token->{type} eq 'NAME') 
{


{



            $match_block->
set_attribute_ns

                               (
undef
, 'token', $token->{value});
          


;}
$token = $self->_scan_default;


}
else 
{


{


{


    my 
$location = {
      utf32_offset => pos ($self->{source}),
    };
    my $continue = 
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, 'loc' => $location, '-type' => 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/bad-token-error', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest', 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token' => $token, 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/source-text' => \($self->{source});

;
    unless ($continue) {
      
report Message::Util::DIS::DPG::ManakaiDPGException -object => $self, '-type' => 'PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;
    }
    $self->{has_error} = 
1
;
  


;}


}


}
if ($token->{type} eq 'EQUALS') 
{

$token = $self->_scan_default;
if ($token->{type} eq 'STRING') 
{


{



              $match_block->
set_attribute_ns

                               (
undef
, 'valueOperation', '==');
              $match_block->
set_attribute_ns

                               (
undef
, 'value',
                                substr ($token->{value}, 1, length ($token->{value}) - 2));
            


;}
$token = $self->_scan_default;


}
else 
{


{


{


    my 
$location = {
      utf32_offset => pos ($self->{source}),
    };
    my $continue = 
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, 'loc' => $location, '-type' => 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/bad-token-error', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest', 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token' => $token, 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/source-text' => \($self->{source});

;
    unless ($continue) {
      
report Message::Util::DIS::DPG::ManakaiDPGException -object => $self, '-type' => 'PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;
    }
    $self->{has_error} = 
1
;
  


;}


}


}


}
if ($token->{type} eq 'RPAREN') 
{

$token = $self->_scan_default;


}
else 
{


{


{


    my 
$location = {
      utf32_offset => pos ($self->{source}),
    };
    my $continue = 
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, 'loc' => $location, '-type' => 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/bad-token-error', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest', 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token' => $token, 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/source-text' => \($self->{source});

;
    unless ($continue) {
      
report Message::Util::DIS::DPG::ManakaiDPGException -object => $self, '-type' => 'PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;
    }
    $self->{has_error} = 
1
;
  


;}


}


}

{

my $doc = $doc;
my $parent = $match_block;

MATCH_2:
{

if ($token->{type} eq 'COLON') 
{

$token = $self->_scan_default;
if ($token->{type} eq 'NAME') 
{

my $ael;

{



        $ael = $doc->
create_element_ns

                        (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'attributeSpecification');
        $ael->
set_attribute_ns
 (
undef
, 'name', $token->{value});
        $ael->
set_attribute_ns
 (
undef
, 'value', '1');
        $parent->
append_child
 ($ael);
      


;}

{

my $parent = $ael;
$token = $self->_scan_default;
if ($token->{type} eq 'ZEROMORE') 
{


{



      $parent->
set_attribute_ns

                   (
undef
, 'occurence', 'zeromore');
    


;}
$token = $self->_scan_default;


}
elsif ($token->{type} eq 'ONEMORE') 
{


{



      $parent->
set_attribute_ns

                   (
undef
, 'occurence', 'onemore');
    


;}
$token = $self->_scan_default;


}
elsif ($token->{type} eq 'ZEROONE') 
{


{



      $parent->
set_attribute_ns
 
                   (
undef
, 'occurence', 'zeroone');
    


;}
$token = $self->_scan_default;


}


}
if ($token->{type} eq 'REPLACE') 
{

$token = $self->_scan_default;
if ($token->{type} eq 'STRING') 
{


{



            $ael->
set_attribute_ns

                    (
undef
, 'value',
                     substr ($token->{value}, 1, length ($token->{value}) - 2));
          


;}
$token = $self->_scan_default;


}
elsif ($token->{type} eq 'NAME') 
{


{



            $ael->
set_attribute_ns

                    (
undef
, 'value', $token->{value});
          


;}
$token = $self->_scan_default;


}
else 
{


{


{


    my 
$location = {
      utf32_offset => pos ($self->{source}),
    };
    my $continue = 
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, 'loc' => $location, '-type' => 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/bad-token-error', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest', 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token' => $token, 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/source-text' => \($self->{source});

;
    unless ($continue) {
      
report Message::Util::DIS::DPG::ManakaiDPGException -object => $self, '-type' => 'PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;
    }
    $self->{has_error} = 
1
;
  


;}


}


}


}


}
else 
{


{


{


    my 
$location = {
      utf32_offset => pos ($self->{source}),
    };
    my $continue = 
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, 'loc' => $location, '-type' => 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/bad-token-error', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest', 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token' => $token, 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/source-text' => \($self->{source});

;
    unless ($continue) {
      
report Message::Util::DIS::DPG::ManakaiDPGException -object => $self, '-type' => 'PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;
    }
    $self->{has_error} = 
1
;
  


;}


}


}


}
else 
{

last MATCH_2;


}
redo MATCH_2;


}
# MATCH_2


}
if ($token->{type} eq 'LBRACE') 
{

$self->_parse__CodeBlock ($doc, $match_block);
$token = $self->_scan_default;


}
else 
{


{


{


    my 
$location = {
      utf32_offset => pos ($self->{source}),
    };
    my $continue = 
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, 'loc' => $location, '-type' => 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/bad-token-error', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest', 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token' => $token, 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/source-text' => \($self->{source});

;
    unless ($continue) {
      
report Message::Util::DIS::DPG::ManakaiDPGException -object => $self, '-type' => 'PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;
    }
    $self->{has_error} = 
1
;
  


;}


}


}


}
else 
{

if ($has_content == 0) 
{


{


{


    my 
$location = {
      utf32_offset => pos ($self->{source}),
    };
    my $continue = 
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, 'loc' => $location, '-type' => 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/bad-token-error', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest', 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token' => $token, 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/source-text' => \($self->{source});

;
    unless ($continue) {
      
report Message::Util::DIS::DPG::ManakaiDPGException -object => $self, '-type' => 'PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;
    }
    $self->{has_error} = 
1
;
  


;}


}


}
last MATCH_3;


}
redo MATCH_3;


}
# MATCH_3


}
if (($token->{type} eq 'NAME') and ($token->{value} eq 'else')) 
{

my $match_block;

{



        $match_block = $doc->
create_element_ns

                               (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'matchElseBlock');
        $match->
append_child
 ($match_block);
      


;}

{

my $doc = $doc;
my $parent = $match_block;
$token = $self->_scan_default;

MATCH_4:
{

if ($token->{type} eq 'COLON') 
{

$token = $self->_scan_default;
if ($token->{type} eq 'NAME') 
{

my $ael;

{



        $ael = $doc->
create_element_ns

                        (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'attributeSpecification');
        $ael->
set_attribute_ns
 (
undef
, 'name', $token->{value});
        $ael->
set_attribute_ns
 (
undef
, 'value', '1');
        $parent->
append_child
 ($ael);
      


;}

{

my $parent = $ael;
$token = $self->_scan_default;
if ($token->{type} eq 'ZEROMORE') 
{


{



      $parent->
set_attribute_ns

                   (
undef
, 'occurence', 'zeromore');
    


;}
$token = $self->_scan_default;


}
elsif ($token->{type} eq 'ONEMORE') 
{


{



      $parent->
set_attribute_ns

                   (
undef
, 'occurence', 'onemore');
    


;}
$token = $self->_scan_default;


}
elsif ($token->{type} eq 'ZEROONE') 
{


{



      $parent->
set_attribute_ns
 
                   (
undef
, 'occurence', 'zeroone');
    


;}
$token = $self->_scan_default;


}


}
if ($token->{type} eq 'REPLACE') 
{

$token = $self->_scan_default;
if ($token->{type} eq 'STRING') 
{


{



            $ael->
set_attribute_ns

                    (
undef
, 'value',
                     substr ($token->{value}, 1, length ($token->{value}) - 2));
          


;}
$token = $self->_scan_default;


}
elsif ($token->{type} eq 'NAME') 
{


{



            $ael->
set_attribute_ns

                    (
undef
, 'value', $token->{value});
          


;}
$token = $self->_scan_default;


}
else 
{


{


{


    my 
$location = {
      utf32_offset => pos ($self->{source}),
    };
    my $continue = 
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, 'loc' => $location, '-type' => 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/bad-token-error', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest', 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token' => $token, 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/source-text' => \($self->{source});

;
    unless ($continue) {
      
report Message::Util::DIS::DPG::ManakaiDPGException -object => $self, '-type' => 'PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;
    }
    $self->{has_error} = 
1
;
  


;}


}


}


}


}
else 
{


{


{


    my 
$location = {
      utf32_offset => pos ($self->{source}),
    };
    my $continue = 
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, 'loc' => $location, '-type' => 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/bad-token-error', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest', 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token' => $token, 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/source-text' => \($self->{source});

;
    unless ($continue) {
      
report Message::Util::DIS::DPG::ManakaiDPGException -object => $self, '-type' => 'PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;
    }
    $self->{has_error} = 
1
;
  


;}


}


}


}
else 
{

last MATCH_4;


}
redo MATCH_4;


}
# MATCH_4


}
if ($token->{type} eq 'LBRACE') 
{

$self->_parse__CodeBlock ($doc, $match_block);
$token = $self->_scan_default;


}
else 
{


{


{


    my 
$location = {
      utf32_offset => pos ($self->{source}),
    };
    my $continue = 
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, 'loc' => $location, '-type' => 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/bad-token-error', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest', 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token' => $token, 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/source-text' => \($self->{source});

;
    unless ($continue) {
      
report Message::Util::DIS::DPG::ManakaiDPGException -object => $self, '-type' => 'PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;
    }
    $self->{has_error} = 
1
;
  


;}


}


}


}


}
elsif (($token->{type} eq 'NAME') and ($token->{value} eq 'my')) 
{

$token = $self->_scan_default;
if ($token->{type} eq 'VARIABLE') 
{

my $my;

{



        $my = $doc->
create_element_ns
 (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'myStatement');
        $my->
set_attribute_ns
 (
undef
, 'name', substr ($token->{value}, 1));
        $block->
append_child
 ($my);
      


;}

{

my $doc = $doc;
my $parent = $my;
$token = $self->_scan_default;

MATCH_4:
{

if ($token->{type} eq 'COLON') 
{

$token = $self->_scan_default;
if ($token->{type} eq 'NAME') 
{

my $ael;

{



        $ael = $doc->
create_element_ns

                        (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'attributeSpecification');
        $ael->
set_attribute_ns
 (
undef
, 'name', $token->{value});
        $ael->
set_attribute_ns
 (
undef
, 'value', '1');
        $parent->
append_child
 ($ael);
      


;}

{

my $parent = $ael;
$token = $self->_scan_default;
if ($token->{type} eq 'ZEROMORE') 
{


{



      $parent->
set_attribute_ns

                   (
undef
, 'occurence', 'zeromore');
    


;}
$token = $self->_scan_default;


}
elsif ($token->{type} eq 'ONEMORE') 
{


{



      $parent->
set_attribute_ns

                   (
undef
, 'occurence', 'onemore');
    


;}
$token = $self->_scan_default;


}
elsif ($token->{type} eq 'ZEROONE') 
{


{



      $parent->
set_attribute_ns
 
                   (
undef
, 'occurence', 'zeroone');
    


;}
$token = $self->_scan_default;


}


}
if ($token->{type} eq 'REPLACE') 
{

$token = $self->_scan_default;
if ($token->{type} eq 'STRING') 
{


{



            $ael->
set_attribute_ns

                    (
undef
, 'value',
                     substr ($token->{value}, 1, length ($token->{value}) - 2));
          


;}
$token = $self->_scan_default;


}
elsif ($token->{type} eq 'NAME') 
{


{



            $ael->
set_attribute_ns

                    (
undef
, 'value', $token->{value});
          


;}
$token = $self->_scan_default;


}
else 
{


{


{


    my 
$location = {
      utf32_offset => pos ($self->{source}),
    };
    my $continue = 
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, 'loc' => $location, '-type' => 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/bad-token-error', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest', 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token' => $token, 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/source-text' => \($self->{source});

;
    unless ($continue) {
      
report Message::Util::DIS::DPG::ManakaiDPGException -object => $self, '-type' => 'PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;
    }
    $self->{has_error} = 
1
;
  


;}


}


}


}


}
else 
{


{


{


    my 
$location = {
      utf32_offset => pos ($self->{source}),
    };
    my $continue = 
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, 'loc' => $location, '-type' => 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/bad-token-error', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest', 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token' => $token, 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/source-text' => \($self->{source});

;
    unless ($continue) {
      
report Message::Util::DIS::DPG::ManakaiDPGException -object => $self, '-type' => 'PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;
    }
    $self->{has_error} = 
1
;
  


;}


}


}


}
else 
{

last MATCH_4;


}
redo MATCH_4;


}
# MATCH_4


}


}
else 
{


{


{


    my 
$location = {
      utf32_offset => pos ($self->{source}),
    };
    my $continue = 
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, 'loc' => $location, '-type' => 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/bad-token-error', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest', 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token' => $token, 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/source-text' => \($self->{source});

;
    unless ($continue) {
      
report Message::Util::DIS::DPG::ManakaiDPGException -object => $self, '-type' => 'PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;
    }
    $self->{has_error} = 
1
;
  


;}


}


}
if ($token->{type} eq 'SEMICOLON') 
{

$token = $self->_scan_default;


}
else 
{


{


{


    my 
$location = {
      utf32_offset => pos ($self->{source}),
    };
    my $continue = 
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, 'loc' => $location, '-type' => 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/bad-token-error', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest', 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token' => $token, 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/source-text' => \($self->{source});

;
    unless ($continue) {
      
report Message::Util::DIS::DPG::ManakaiDPGException -object => $self, '-type' => 'PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;
    }
    $self->{has_error} = 
1
;
  


;}


}


}


}
elsif (($token->{type} eq 'NAME') and ($token->{value} eq 'if-true')) 
{

my $ift;

{



      $ift = $doc->
create_element_ns

                        (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'ifTrueStatement');
      $block->
append_child
 ($ift);
    


;}
$token = $self->_scan_default;
if ($token->{type} eq 'LPAREN') 
{

$token = $self->_scan_default;
if ($token->{type} eq 'VARIABLE') 
{


{



          $ift->
set_attribute_ns

                  (
undef
, 'name', substr ($token->{value}, 1));
        


;}
$token = $self->_scan_default;


}
else 
{


{


{


    my 
$location = {
      utf32_offset => pos ($self->{source}),
    };
    my $continue = 
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, 'loc' => $location, '-type' => 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/bad-token-error', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest', 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token' => $token, 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/source-text' => \($self->{source});

;
    unless ($continue) {
      
report Message::Util::DIS::DPG::ManakaiDPGException -object => $self, '-type' => 'PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;
    }
    $self->{has_error} = 
1
;
  


;}


}


}
if ($token->{type} eq 'RPAREN') 
{

$token = $self->_scan_default;


}
else 
{


{


{


    my 
$location = {
      utf32_offset => pos ($self->{source}),
    };
    my $continue = 
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, 'loc' => $location, '-type' => 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/bad-token-error', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest', 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token' => $token, 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/source-text' => \($self->{source});

;
    unless ($continue) {
      
report Message::Util::DIS::DPG::ManakaiDPGException -object => $self, '-type' => 'PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;
    }
    $self->{has_error} = 
1
;
  


;}


}


}


}
else 
{


{


{


    my 
$location = {
      utf32_offset => pos ($self->{source}),
    };
    my $continue = 
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, 'loc' => $location, '-type' => 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/bad-token-error', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest', 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token' => $token, 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/source-text' => \($self->{source});

;
    unless ($continue) {
      
report Message::Util::DIS::DPG::ManakaiDPGException -object => $self, '-type' => 'PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;
    }
    $self->{has_error} = 
1
;
  


;}


}


}

{

my $doc = $doc;
my $parent = $ift;

MATCH_2:
{

if ($token->{type} eq 'COLON') 
{

$token = $self->_scan_default;
if ($token->{type} eq 'NAME') 
{

my $ael;

{



        $ael = $doc->
create_element_ns

                        (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'attributeSpecification');
        $ael->
set_attribute_ns
 (
undef
, 'name', $token->{value});
        $ael->
set_attribute_ns
 (
undef
, 'value', '1');
        $parent->
append_child
 ($ael);
      


;}

{

my $parent = $ael;
$token = $self->_scan_default;
if ($token->{type} eq 'ZEROMORE') 
{


{



      $parent->
set_attribute_ns

                   (
undef
, 'occurence', 'zeromore');
    


;}
$token = $self->_scan_default;


}
elsif ($token->{type} eq 'ONEMORE') 
{


{



      $parent->
set_attribute_ns

                   (
undef
, 'occurence', 'onemore');
    


;}
$token = $self->_scan_default;


}
elsif ($token->{type} eq 'ZEROONE') 
{


{



      $parent->
set_attribute_ns
 
                   (
undef
, 'occurence', 'zeroone');
    


;}
$token = $self->_scan_default;


}


}
if ($token->{type} eq 'REPLACE') 
{

$token = $self->_scan_default;
if ($token->{type} eq 'STRING') 
{


{



            $ael->
set_attribute_ns

                    (
undef
, 'value',
                     substr ($token->{value}, 1, length ($token->{value}) - 2));
          


;}
$token = $self->_scan_default;


}
elsif ($token->{type} eq 'NAME') 
{


{



            $ael->
set_attribute_ns

                    (
undef
, 'value', $token->{value});
          


;}
$token = $self->_scan_default;


}
else 
{


{


{


    my 
$location = {
      utf32_offset => pos ($self->{source}),
    };
    my $continue = 
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, 'loc' => $location, '-type' => 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/bad-token-error', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest', 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token' => $token, 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/source-text' => \($self->{source});

;
    unless ($continue) {
      
report Message::Util::DIS::DPG::ManakaiDPGException -object => $self, '-type' => 'PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;
    }
    $self->{has_error} = 
1
;
  


;}


}


}


}


}
else 
{


{


{


    my 
$location = {
      utf32_offset => pos ($self->{source}),
    };
    my $continue = 
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, 'loc' => $location, '-type' => 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/bad-token-error', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest', 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token' => $token, 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/source-text' => \($self->{source});

;
    unless ($continue) {
      
report Message::Util::DIS::DPG::ManakaiDPGException -object => $self, '-type' => 'PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;
    }
    $self->{has_error} = 
1
;
  


;}


}


}


}
else 
{

last MATCH_2;


}
redo MATCH_2;


}
# MATCH_2


}
if ($token->{type} eq 'LBRACE') 
{

$self->_parse__CodeBlock ($doc, $ift);
$token = $self->_scan_default;


}
else 
{


{


{


    my 
$location = {
      utf32_offset => pos ($self->{source}),
    };
    my $continue = 
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, 'loc' => $location, '-type' => 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/bad-token-error', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest', 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token' => $token, 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/source-text' => \($self->{source});

;
    unless ($continue) {
      
report Message::Util::DIS::DPG::ManakaiDPGException -object => $self, '-type' => 'PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;
    }
    $self->{has_error} = 
1
;
  


;}


}


}


}
elsif (($token->{type} eq 'NAME') and ($token->{value} eq 'return')) 
{


{


      my 
$ret = $doc->
create_element_ns

                        (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'returnStatement');
      $block->
append_child
 ($ret);
    


;}
$token = $self->_scan_default;
if ($token->{type} eq 'SEMICOLON') 
{

$token = $self->_scan_default;


}
else 
{


{


{


    my 
$location = {
      utf32_offset => pos ($self->{source}),
    };
    my $continue = 
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, 'loc' => $location, '-type' => 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/bad-token-error', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest', 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token' => $token, 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/source-text' => \($self->{source});

;
    unless ($continue) {
      
report Message::Util::DIS::DPG::ManakaiDPGException -object => $self, '-type' => 'PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;
    }
    $self->{has_error} = 
1
;
  


;}


}


}


}
elsif ($token->{type} eq 'NAME') 
{

my $embed;

{


      my 
($prefix, $lname) = split /:/, $token->{value};
      ($prefix, $lname) = (
undef
, $prefix) unless defined $lname;
      my $nsuri = $self->{nsresolver}
                       ->
prefix_to_uri
 ($prefix);
      $embed = $doc->
create_element_ns

                           (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'embedStatement');
      $embed->
set_attribute_ns
 (
undef
, 'type', $nsuri.$lname);
      $block->
append_child
 ($embed);
    


;}

{

my $doc = $doc;
my $parent = $embed;
$token = $self->_scan_default;
if ($token->{type} eq 'LPAREN') 
{

$token = $self->_scan_default;

MATCH_5:
{

if ($token->{type} eq 'VARIABLE') 
{

my $param;

{



        $param = $doc->
create_element_ns

                         (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'parameterSpecification');
        $parent->
append_child
 ($param);
        $param->
set_attribute_ns

                  (
undef
, 'name', substr ($token->{value}, 1));
      


;}
$token = $self->_scan_default;
if ($token->{type} eq 'REPLACE') 
{

$token = $self->_scan_default;


}
else 
{


{


{


    my 
$location = {
      utf32_offset => pos ($self->{source}),
    };
    my $continue = 
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, 'loc' => $location, '-type' => 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/bad-token-error', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest', 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token' => $token, 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/source-text' => \($self->{source});

;
    unless ($continue) {
      
report Message::Util::DIS::DPG::ManakaiDPGException -object => $self, '-type' => 'PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;
    }
    $self->{has_error} = 
1
;
  


;}


}


}

{

my $doc = $doc;
my $parent = $param;
if ($token->{type} eq 'STRING') 
{


{


      my 
$str = $doc->
create_element_ns
 (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'string');
      $str->
text_content

              (substr ($token->{value}, 1, length ($token->{value}) - 2));
      $parent->
append_child
 ($str);
    


;}
$token = $self->_scan_default;


}
elsif ($token->{type} eq 'VARIABLE') 
{

my $memref;

{



      $memref = $doc->
create_element_ns

                          (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'memberRef');
      my $var = $doc->
create_element_ns

                          (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'variable');
      $var->
set_attribute_ns

                (
undef
, 'name', substr ($token->{value}, 1));
      $memref->
append_child
 ($var);
      $parent->
append_child
 ($memref);
    


;}
$token = $self->_scan_default;

MATCH_6:
{

if ($token->{type} eq 'DOT') 
{

$token = $self->_scan_default;
if ($token->{type} eq 'NAME') 
{


{


          my 
$mem = $doc->
create_element_ns

                            (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'member');
          $mem->
set_attribute_ns
 (
undef
, 'name', $token->{value});
          $memref->
append_child
 ($mem);
        


;}
$token = $self->_scan_default;


}
else 
{


{


{


    my 
$location = {
      utf32_offset => pos ($self->{source}),
    };
    my $continue = 
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, 'loc' => $location, '-type' => 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/bad-token-error', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest', 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token' => $token, 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/source-text' => \($self->{source});

;
    unless ($continue) {
      
report Message::Util::DIS::DPG::ManakaiDPGException -object => $self, '-type' => 'PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;
    }
    $self->{has_error} = 
1
;
  


;}


}


}


}
else 
{

last MATCH_6;


}
redo MATCH_6;


}
# MATCH_6


}
else 
{


{


{


    my 
$location = {
      utf32_offset => pos ($self->{source}),
    };
    my $continue = 
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, 'loc' => $location, '-type' => 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/bad-token-error', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest', 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token' => $token, 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/source-text' => \($self->{source});

;
    unless ($continue) {
      
report Message::Util::DIS::DPG::ManakaiDPGException -object => $self, '-type' => 'PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;
    }
    $self->{has_error} = 
1
;
  


;}


}


}


}


}
if ($token->{type} eq 'COMMA') 
{

$token = $self->_scan_default;
redo MATCH_5;


}
else 
{

last MATCH_5;


}


}
# MATCH_5
if ($token->{type} eq 'RPAREN') 
{

$token = $self->_scan_default;


}
else 
{


{


{


    my 
$location = {
      utf32_offset => pos ($self->{source}),
    };
    my $continue = 
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, 'loc' => $location, '-type' => 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/bad-token-error', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest', 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token' => $token, 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/source-text' => \($self->{source});

;
    unless ($continue) {
      
report Message::Util::DIS::DPG::ManakaiDPGException -object => $self, '-type' => 'PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;
    }
    $self->{has_error} = 
1
;
  


;}


}


}


}


}

{

my $doc = $doc;
my $parent = $embed;

MATCH_2:
{

if ($token->{type} eq 'COLON') 
{

$token = $self->_scan_default;
if ($token->{type} eq 'NAME') 
{

my $ael;

{



        $ael = $doc->
create_element_ns

                        (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'attributeSpecification');
        $ael->
set_attribute_ns
 (
undef
, 'name', $token->{value});
        $ael->
set_attribute_ns
 (
undef
, 'value', '1');
        $parent->
append_child
 ($ael);
      


;}

{

my $parent = $ael;
$token = $self->_scan_default;
if ($token->{type} eq 'ZEROMORE') 
{


{



      $parent->
set_attribute_ns

                   (
undef
, 'occurence', 'zeromore');
    


;}
$token = $self->_scan_default;


}
elsif ($token->{type} eq 'ONEMORE') 
{


{



      $parent->
set_attribute_ns

                   (
undef
, 'occurence', 'onemore');
    


;}
$token = $self->_scan_default;


}
elsif ($token->{type} eq 'ZEROONE') 
{


{



      $parent->
set_attribute_ns
 
                   (
undef
, 'occurence', 'zeroone');
    


;}
$token = $self->_scan_default;


}


}
if ($token->{type} eq 'REPLACE') 
{

$token = $self->_scan_default;
if ($token->{type} eq 'STRING') 
{


{



            $ael->
set_attribute_ns

                    (
undef
, 'value',
                     substr ($token->{value}, 1, length ($token->{value}) - 2));
          


;}
$token = $self->_scan_default;


}
elsif ($token->{type} eq 'NAME') 
{


{



            $ael->
set_attribute_ns

                    (
undef
, 'value', $token->{value});
          


;}
$token = $self->_scan_default;


}
else 
{


{


{


    my 
$location = {
      utf32_offset => pos ($self->{source}),
    };
    my $continue = 
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, 'loc' => $location, '-type' => 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/bad-token-error', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest', 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token' => $token, 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/source-text' => \($self->{source});

;
    unless ($continue) {
      
report Message::Util::DIS::DPG::ManakaiDPGException -object => $self, '-type' => 'PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;
    }
    $self->{has_error} = 
1
;
  


;}


}


}


}


}
else 
{


{


{


    my 
$location = {
      utf32_offset => pos ($self->{source}),
    };
    my $continue = 
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, 'loc' => $location, '-type' => 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/bad-token-error', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest', 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token' => $token, 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/source-text' => \($self->{source});

;
    unless ($continue) {
      
report Message::Util::DIS::DPG::ManakaiDPGException -object => $self, '-type' => 'PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;
    }
    $self->{has_error} = 
1
;
  


;}


}


}


}
else 
{

last MATCH_2;


}
redo MATCH_2;


}
# MATCH_2


}
unshift (@{$self->{token}}, $token);
$self->_parse_embed_block ($doc, $embed);
$token = $self->_scan_default;


}
elsif ($token->{type} eq 'RULEREF') 
{

my $ruleref;

{



    $ruleref = $doc->
create_element_ns
 (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'ruleRefStatement');
    $ruleref->
set_attribute_ns
 (
undef
, 'name', substr ($token->{value}, 1));
    $block->
append_child
 ($ruleref);
  


;}

{

my $doc = $doc;
my $parent = $ruleref;
$token = $self->_scan_default;
if ($token->{type} eq 'LPAREN') 
{

$token = $self->_scan_default;

MATCH_5:
{

if ($token->{type} eq 'VARIABLE') 
{

my $param;

{



        $param = $doc->
create_element_ns

                         (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'parameterSpecification');
        $parent->
append_child
 ($param);
        $param->
set_attribute_ns

                  (
undef
, 'name', substr ($token->{value}, 1));
      


;}
$token = $self->_scan_default;
if ($token->{type} eq 'REPLACE') 
{

$token = $self->_scan_default;


}
else 
{


{


{


    my 
$location = {
      utf32_offset => pos ($self->{source}),
    };
    my $continue = 
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, 'loc' => $location, '-type' => 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/bad-token-error', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest', 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token' => $token, 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/source-text' => \($self->{source});

;
    unless ($continue) {
      
report Message::Util::DIS::DPG::ManakaiDPGException -object => $self, '-type' => 'PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;
    }
    $self->{has_error} = 
1
;
  


;}


}


}

{

my $doc = $doc;
my $parent = $param;
if ($token->{type} eq 'STRING') 
{


{


      my 
$str = $doc->
create_element_ns
 (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'string');
      $str->
text_content

              (substr ($token->{value}, 1, length ($token->{value}) - 2));
      $parent->
append_child
 ($str);
    


;}
$token = $self->_scan_default;


}
elsif ($token->{type} eq 'VARIABLE') 
{

my $memref;

{



      $memref = $doc->
create_element_ns

                          (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'memberRef');
      my $var = $doc->
create_element_ns

                          (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'variable');
      $var->
set_attribute_ns

                (
undef
, 'name', substr ($token->{value}, 1));
      $memref->
append_child
 ($var);
      $parent->
append_child
 ($memref);
    


;}
$token = $self->_scan_default;

MATCH_6:
{

if ($token->{type} eq 'DOT') 
{

$token = $self->_scan_default;
if ($token->{type} eq 'NAME') 
{


{


          my 
$mem = $doc->
create_element_ns

                            (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'member');
          $mem->
set_attribute_ns
 (
undef
, 'name', $token->{value});
          $memref->
append_child
 ($mem);
        


;}
$token = $self->_scan_default;


}
else 
{


{


{


    my 
$location = {
      utf32_offset => pos ($self->{source}),
    };
    my $continue = 
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, 'loc' => $location, '-type' => 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/bad-token-error', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest', 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token' => $token, 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/source-text' => \($self->{source});

;
    unless ($continue) {
      
report Message::Util::DIS::DPG::ManakaiDPGException -object => $self, '-type' => 'PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;
    }
    $self->{has_error} = 
1
;
  


;}


}


}


}
else 
{

last MATCH_6;


}
redo MATCH_6;


}
# MATCH_6


}
else 
{


{


{


    my 
$location = {
      utf32_offset => pos ($self->{source}),
    };
    my $continue = 
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, 'loc' => $location, '-type' => 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/bad-token-error', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest', 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token' => $token, 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/source-text' => \($self->{source});

;
    unless ($continue) {
      
report Message::Util::DIS::DPG::ManakaiDPGException -object => $self, '-type' => 'PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;
    }
    $self->{has_error} = 
1
;
  


;}


}


}


}


}
if ($token->{type} eq 'COMMA') 
{

$token = $self->_scan_default;
redo MATCH_5;


}
else 
{

last MATCH_5;


}


}
# MATCH_5
if ($token->{type} eq 'RPAREN') 
{

$token = $self->_scan_default;


}
else 
{


{


{


    my 
$location = {
      utf32_offset => pos ($self->{source}),
    };
    my $continue = 
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, 'loc' => $location, '-type' => 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/bad-token-error', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest', 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token' => $token, 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/source-text' => \($self->{source});

;
    unless ($continue) {
      
report Message::Util::DIS::DPG::ManakaiDPGException -object => $self, '-type' => 'PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;
    }
    $self->{has_error} = 
1
;
  


;}


}


}


}


}

{

my $doc = $doc;
my $parent = $ruleref;

MATCH_2:
{

if ($token->{type} eq 'COLON') 
{

$token = $self->_scan_default;
if ($token->{type} eq 'NAME') 
{

my $ael;

{



        $ael = $doc->
create_element_ns

                        (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'attributeSpecification');
        $ael->
set_attribute_ns
 (
undef
, 'name', $token->{value});
        $ael->
set_attribute_ns
 (
undef
, 'value', '1');
        $parent->
append_child
 ($ael);
      


;}

{

my $parent = $ael;
$token = $self->_scan_default;
if ($token->{type} eq 'ZEROMORE') 
{


{



      $parent->
set_attribute_ns

                   (
undef
, 'occurence', 'zeromore');
    


;}
$token = $self->_scan_default;


}
elsif ($token->{type} eq 'ONEMORE') 
{


{



      $parent->
set_attribute_ns

                   (
undef
, 'occurence', 'onemore');
    


;}
$token = $self->_scan_default;


}
elsif ($token->{type} eq 'ZEROONE') 
{


{



      $parent->
set_attribute_ns
 
                   (
undef
, 'occurence', 'zeroone');
    


;}
$token = $self->_scan_default;


}


}
if ($token->{type} eq 'REPLACE') 
{

$token = $self->_scan_default;
if ($token->{type} eq 'STRING') 
{


{



            $ael->
set_attribute_ns

                    (
undef
, 'value',
                     substr ($token->{value}, 1, length ($token->{value}) - 2));
          


;}
$token = $self->_scan_default;


}
elsif ($token->{type} eq 'NAME') 
{


{



            $ael->
set_attribute_ns

                    (
undef
, 'value', $token->{value});
          


;}
$token = $self->_scan_default;


}
else 
{


{


{


    my 
$location = {
      utf32_offset => pos ($self->{source}),
    };
    my $continue = 
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, 'loc' => $location, '-type' => 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/bad-token-error', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest', 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token' => $token, 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/source-text' => \($self->{source});

;
    unless ($continue) {
      
report Message::Util::DIS::DPG::ManakaiDPGException -object => $self, '-type' => 'PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;
    }
    $self->{has_error} = 
1
;
  


;}


}


}


}


}
else 
{


{


{


    my 
$location = {
      utf32_offset => pos ($self->{source}),
    };
    my $continue = 
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, 'loc' => $location, '-type' => 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/bad-token-error', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest', 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token' => $token, 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/source-text' => \($self->{source});

;
    unless ($continue) {
      
report Message::Util::DIS::DPG::ManakaiDPGException -object => $self, '-type' => 'PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;
    }
    $self->{has_error} = 
1
;
  


;}


}


}


}
else 
{

last MATCH_2;


}
redo MATCH_2;


}
# MATCH_2


}
if ($token->{type} eq 'SEMICOLON') 
{

$token = $self->_scan_default;


}
else 
{


{


{


    my 
$location = {
      utf32_offset => pos ($self->{source}),
    };
    my $continue = 
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, 'loc' => $location, '-type' => 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/bad-token-error', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest', 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token' => $token, 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/source-text' => \($self->{source});

;
    unless ($continue) {
      
report Message::Util::DIS::DPG::ManakaiDPGException -object => $self, '-type' => 'PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;
    }
    $self->{has_error} = 
1
;
  


;}


}


}


}
elsif (($token->{type} eq 'QKEYWORD') and ($token->{value} eq '?lexmode')) 
{

$token = $self->_scan_default;
if ($token->{type} eq 'NAME') 
{


{


          my 
$lm = $doc->
create_element_ns

                     (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'qLexmodeStatement');
          $lm->
set_attribute_ns
 (
undef
, 'name', $token->{value});
          $block->
append_child
 ($lm);
        


;}
$token = $self->_scan_default;


}
elsif ($token->{type} eq 'STRING') 
{


{


          my 
$lm = $doc->
create_element_ns

                     (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'qLexmodeStatement');
          $lm->
set_attribute_ns

                     (
undef
, 'name',
                      substr ($token->{value}, 1, length ($token->{value}) - 2));
          $block->
append_child
 ($lm);
        


;}
$token = $self->_scan_default;


}
else 
{


{


{


    my 
$location = {
      utf32_offset => pos ($self->{source}),
    };
    my $continue = 
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, 'loc' => $location, '-type' => 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/bad-token-error', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest', 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token' => $token, 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/source-text' => \($self->{source});

;
    unless ($continue) {
      
report Message::Util::DIS::DPG::ManakaiDPGException -object => $self, '-type' => 'PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;
    }
    $self->{has_error} = 
1
;
  


;}


}


}
if ($token->{type} eq 'SEMICOLON') 
{

$token = $self->_scan_default;


}
else 
{


{


{


    my 
$location = {
      utf32_offset => pos ($self->{source}),
    };
    my $continue = 
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, 'loc' => $location, '-type' => 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/bad-token-error', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest', 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token' => $token, 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/source-text' => \($self->{source});

;
    unless ($continue) {
      
report Message::Util::DIS::DPG::ManakaiDPGException -object => $self, '-type' => 'PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;
    }
    $self->{has_error} = 
1
;
  


;}


}


}


}
elsif (($token->{type} eq 'QKEYWORD') and ($token->{value} eq '?requires-next-token')) 
{


{


        my 
$lm = $doc->
create_element_ns

                     (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'qRequiresNextTokenStatement');
        $block->
append_child
 ($lm);
      


;}
$token = $self->_scan_default;
if ($token->{type} eq 'SEMICOLON') 
{

$token = $self->_scan_default;


}
else 
{


{


{


    my 
$location = {
      utf32_offset => pos ($self->{source}),
    };
    my $continue = 
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, 'loc' => $location, '-type' => 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/bad-token-error', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest', 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token' => $token, 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/source-text' => \($self->{source});

;
    unless ($continue) {
      
report Message::Util::DIS::DPG::ManakaiDPGException -object => $self, '-type' => 'PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;
    }
    $self->{has_error} = 
1
;
  


;}


}


}


}
elsif ($token->{type} eq 'VARIABLE') 
{

my $assign;
my $lvalue;

{



    $assign = $doc->
create_element_ns
 (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'assignmentStatement');
    $lvalue = $doc->
create_element_ns
 (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'memberRef');
    my $var = $doc->
create_element_ns
 (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'variable');
    $var->
set_attribute_ns
 (
undef
, 'name', substr ($token->{value}, 1));
    $lvalue->
append_child
 ($var);
    $assign->
append_child
 ($lvalue);
    $block->
append_child
 ($assign);
  


;}
$token = $self->_scan_default;

MATCH_7:
{

if ($token->{type} eq 'DOT') 
{

$token = $self->_scan_default;
if ($token->{type} eq 'NAME') 
{


{


        my 
$mem = $doc->
create_element_ns
 (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'member');
        $mem->
set_attribute_ns
 (
undef
, 'name', $token->{value});
        $lvalue->
append_child
 ($mem);
      


;}
$token = $self->_scan_default;


}
else 
{


{


{


    my 
$location = {
      utf32_offset => pos ($self->{source}),
    };
    my $continue = 
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, 'loc' => $location, '-type' => 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/bad-token-error', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest', 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token' => $token, 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/source-text' => \($self->{source});

;
    unless ($continue) {
      
report Message::Util::DIS::DPG::ManakaiDPGException -object => $self, '-type' => 'PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;
    }
    $self->{has_error} = 
1
;
  


;}


}


}


}
else 
{

last MATCH_7;


}
redo MATCH_7;


}
# MATCH_7
if ($token->{type} eq 'ASSIGN') 
{

$token = $self->_scan_default;


}
else 
{


{


{


    my 
$location = {
      utf32_offset => pos ($self->{source}),
    };
    my $continue = 
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, 'loc' => $location, '-type' => 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/bad-token-error', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest', 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token' => $token, 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/source-text' => \($self->{source});

;
    unless ($continue) {
      
report Message::Util::DIS::DPG::ManakaiDPGException -object => $self, '-type' => 'PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;
    }
    $self->{has_error} = 
1
;
  


;}


}


}

{

my $doc = $doc;
my $parent = $assign;
if ($token->{type} eq 'STRING') 
{


{


      my 
$str = $doc->
create_element_ns
 (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'string');
      $str->
text_content

              (substr ($token->{value}, 1, length ($token->{value}) - 2));
      $parent->
append_child
 ($str);
    


;}
$token = $self->_scan_default;


}
elsif ($token->{type} eq 'VARIABLE') 
{

my $memref;

{



      $memref = $doc->
create_element_ns

                          (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'memberRef');
      my $var = $doc->
create_element_ns

                          (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'variable');
      $var->
set_attribute_ns

                (
undef
, 'name', substr ($token->{value}, 1));
      $memref->
append_child
 ($var);
      $parent->
append_child
 ($memref);
    


;}
$token = $self->_scan_default;

MATCH_6:
{

if ($token->{type} eq 'DOT') 
{

$token = $self->_scan_default;
if ($token->{type} eq 'NAME') 
{


{


          my 
$mem = $doc->
create_element_ns

                            (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'member');
          $mem->
set_attribute_ns
 (
undef
, 'name', $token->{value});
          $memref->
append_child
 ($mem);
        


;}
$token = $self->_scan_default;


}
else 
{


{


{


    my 
$location = {
      utf32_offset => pos ($self->{source}),
    };
    my $continue = 
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, 'loc' => $location, '-type' => 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/bad-token-error', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest', 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token' => $token, 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/source-text' => \($self->{source});

;
    unless ($continue) {
      
report Message::Util::DIS::DPG::ManakaiDPGException -object => $self, '-type' => 'PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;
    }
    $self->{has_error} = 
1
;
  


;}


}


}


}
else 
{

last MATCH_6;


}
redo MATCH_6;


}
# MATCH_6


}
else 
{


{


{


    my 
$location = {
      utf32_offset => pos ($self->{source}),
    };
    my $continue = 
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, 'loc' => $location, '-type' => 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/bad-token-error', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest', 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token' => $token, 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/source-text' => \($self->{source});

;
    unless ($continue) {
      
report Message::Util::DIS::DPG::ManakaiDPGException -object => $self, '-type' => 'PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;
    }
    $self->{has_error} = 
1
;
  


;}


}


}


}
if ($token->{type} eq 'SEMICOLON') 
{

$token = $self->_scan_default;


}
else 
{


{


{


    my 
$location = {
      utf32_offset => pos ($self->{source}),
    };
    my $continue = 
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, 'loc' => $location, '-type' => 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/bad-token-error', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest', 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token' => $token, 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/source-text' => \($self->{source});

;
    unless ($continue) {
      
report Message::Util::DIS::DPG::ManakaiDPGException -object => $self, '-type' => 'PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;
    }
    $self->{has_error} = 
1
;
  


;}


}


}


}
else 
{

last MATCH_1;


}
redo MATCH_1;


}
# MATCH_1
if ($token->{type} eq 'RBRACE') 
{

$token = $self->_scan_default;


}
else 
{


{


{


    my 
$location = {
      utf32_offset => pos ($self->{source}),
    };
    my $continue = 
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, 'loc' => $location, '-type' => 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/bad-token-error', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest', 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token' => $token, 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/source-text' => \($self->{source});

;
    unless ($continue) {
      
report Message::Util::DIS::DPG::ManakaiDPGException -object => $self, '-type' => 'PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;
    }
    $self->{has_error} = 
1
;
  


;}


}


}
unshift (@{$self->{token}}, $token);
}
sub _parse_Rules ($$) {
my ($self, $impl) = @_;
my $token;
my $doc;
my $docel;

{



    $doc = $impl->
create_document

                  (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'rules');
    $doc->
strict_error_checking
 (
0
);
    $docel = $doc->
document_element
;
  


;}
$token = $self->_scan_default;

MATCH_8:
{

if (($token->{type} eq 'NAME') and ($token->{value} eq 'rule')) 
{


{

my $doc = $doc;
my $parent = $docel;
my $el;

{



    $el = $doc->
create_element_ns
 (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'rule');
    $parent->
append_child
 ($el);
  


;}
$token = $self->_scan_default;
if ($token->{type} eq 'NAME') 
{


{



      $el->
set_attribute_ns
 (
undef
, 'name', $token->{value});
    


;}
$token = $self->_scan_default;


}
else 
{


{


{


    my 
$location = {
      utf32_offset => pos ($self->{source}),
    };
    my $continue = 
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, 'loc' => $location, '-type' => 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/bad-token-error', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest', 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token' => $token, 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/source-text' => \($self->{source});

;
    unless ($continue) {
      
report Message::Util::DIS::DPG::ManakaiDPGException -object => $self, '-type' => 'PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;
    }
    $self->{has_error} = 
1
;
  


;}


}


}

{

my $doc = $doc;
my $parent = $el;
if ($token->{type} eq 'LPAREN') 
{

$token = $self->_scan_default;

MATCH_9:
{

if ($token->{type} eq 'VARIABLE') 
{


{


        my 
$pel = $doc->
create_element_ns

                          (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'parameterDeclaration');
        $pel->
set_attribute_ns

                (
undef
, 'name', substr ($token->{value}, 1));
        $parent->
append_child
 ($pel);
      


;}
$token = $self->_scan_default;


}
if ($token->{type} eq 'COMMA') 
{

$token = $self->_scan_default;
redo MATCH_9;


}
else 
{

last MATCH_9;


}


}
# MATCH_9
if ($token->{type} eq 'RPAREN') 
{

$token = $self->_scan_default;


}
else 
{


{


{


    my 
$location = {
      utf32_offset => pos ($self->{source}),
    };
    my $continue = 
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, 'loc' => $location, '-type' => 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/bad-token-error', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest', 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token' => $token, 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/source-text' => \($self->{source});

;
    unless ($continue) {
      
report Message::Util::DIS::DPG::ManakaiDPGException -object => $self, '-type' => 'PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;
    }
    $self->{has_error} = 
1
;
  


;}


}


}


}


}

{

my $doc = $doc;
my $parent = $el;

MATCH_2:
{

if ($token->{type} eq 'COLON') 
{

$token = $self->_scan_default;
if ($token->{type} eq 'NAME') 
{

my $ael;

{



        $ael = $doc->
create_element_ns

                        (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'attributeSpecification');
        $ael->
set_attribute_ns
 (
undef
, 'name', $token->{value});
        $ael->
set_attribute_ns
 (
undef
, 'value', '1');
        $parent->
append_child
 ($ael);
      


;}

{

my $parent = $ael;
$token = $self->_scan_default;
if ($token->{type} eq 'ZEROMORE') 
{


{



      $parent->
set_attribute_ns

                   (
undef
, 'occurence', 'zeromore');
    


;}
$token = $self->_scan_default;


}
elsif ($token->{type} eq 'ONEMORE') 
{


{



      $parent->
set_attribute_ns

                   (
undef
, 'occurence', 'onemore');
    


;}
$token = $self->_scan_default;


}
elsif ($token->{type} eq 'ZEROONE') 
{


{



      $parent->
set_attribute_ns
 
                   (
undef
, 'occurence', 'zeroone');
    


;}
$token = $self->_scan_default;


}


}
if ($token->{type} eq 'REPLACE') 
{

$token = $self->_scan_default;
if ($token->{type} eq 'STRING') 
{


{



            $ael->
set_attribute_ns

                    (
undef
, 'value',
                     substr ($token->{value}, 1, length ($token->{value}) - 2));
          


;}
$token = $self->_scan_default;


}
elsif ($token->{type} eq 'NAME') 
{


{



            $ael->
set_attribute_ns

                    (
undef
, 'value', $token->{value});
          


;}
$token = $self->_scan_default;


}
else 
{


{


{


    my 
$location = {
      utf32_offset => pos ($self->{source}),
    };
    my $continue = 
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, 'loc' => $location, '-type' => 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/bad-token-error', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest', 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token' => $token, 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/source-text' => \($self->{source});

;
    unless ($continue) {
      
report Message::Util::DIS::DPG::ManakaiDPGException -object => $self, '-type' => 'PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;
    }
    $self->{has_error} = 
1
;
  


;}


}


}


}


}
else 
{


{


{


    my 
$location = {
      utf32_offset => pos ($self->{source}),
    };
    my $continue = 
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, 'loc' => $location, '-type' => 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/bad-token-error', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest', 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token' => $token, 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/source-text' => \($self->{source});

;
    unless ($continue) {
      
report Message::Util::DIS::DPG::ManakaiDPGException -object => $self, '-type' => 'PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;
    }
    $self->{has_error} = 
1
;
  


;}


}


}


}
else 
{

last MATCH_2;


}
redo MATCH_2;


}
# MATCH_2


}
if ($token->{type} eq 'LBRACE') 
{

$self->_parse__CodeBlock ($doc, $el);
$token = $self->_scan_default;


}
elsif ($token->{type} eq 'LANGLE') 
{

$token = $self->_scan_default;
if (($token->{type} eq 'NAME') and ($token->{value} eq 'external')) 
{


{



        $el->
set_attribute_ns
 (
undef
, 'isExternal', '1');
      


;}
$token = $self->_scan_default;
if ($token->{type} eq 'RANGLE') 
{

$token = $self->_scan_default;


}
else 
{


{


{


    my 
$location = {
      utf32_offset => pos ($self->{source}),
    };
    my $continue = 
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, 'loc' => $location, '-type' => 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/bad-token-error', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest', 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token' => $token, 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/source-text' => \($self->{source});

;
    unless ($continue) {
      
report Message::Util::DIS::DPG::ManakaiDPGException -object => $self, '-type' => 'PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;
    }
    $self->{has_error} = 
1
;
  


;}


}


}
if ($token->{type} eq 'SEMICOLON') 
{

$token = $self->_scan_default;


}
else 
{


{


{


    my 
$location = {
      utf32_offset => pos ($self->{source}),
    };
    my $continue = 
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, 'loc' => $location, '-type' => 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/bad-token-error', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest', 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token' => $token, 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/source-text' => \($self->{source});

;
    unless ($continue) {
      
report Message::Util::DIS::DPG::ManakaiDPGException -object => $self, '-type' => 'PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;
    }
    $self->{has_error} = 
1
;
  


;}


}


}


}
else 
{


{


{


    my 
$location = {
      utf32_offset => pos ($self->{source}),
    };
    my $continue = 
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, 'loc' => $location, '-type' => 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/bad-token-error', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest', 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token' => $token, 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/source-text' => \($self->{source});

;
    unless ($continue) {
      
report Message::Util::DIS::DPG::ManakaiDPGException -object => $self, '-type' => 'PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;
    }
    $self->{has_error} = 
1
;
  


;}


}


}


}
else 
{


{


{


    my 
$location = {
      utf32_offset => pos ($self->{source}),
    };
    my $continue = 
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, 'loc' => $location, '-type' => 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/bad-token-error', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest', 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token' => $token, 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/source-text' => \($self->{source});

;
    unless ($continue) {
      
report Message::Util::DIS::DPG::ManakaiDPGException -object => $self, '-type' => 'PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;
    }
    $self->{has_error} = 
1
;
  


;}


}


}


}


}
elsif (($token->{type} eq 'NAME') and ($token->{value} eq 'lexmode')) 
{


{

my $doc = $doc;
my $parent = $docel;
my $el;

{



    $el = $doc->
create_element_ns
 (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'lexmode');
    $parent->
append_child
 ($el);
  


;}
$token = $self->_scan_default;
if ($token->{type} eq 'NAME') 
{


{



      $el->
set_attribute_ns
 (
undef
, 'name', $token->{value});
    


;}
$token = $self->_scan_default;


}
else 
{


{


{


    my 
$location = {
      utf32_offset => pos ($self->{source}),
    };
    my $continue = 
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, 'loc' => $location, '-type' => 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/bad-token-error', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest', 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token' => $token, 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/source-text' => \($self->{source});

;
    unless ($continue) {
      
report Message::Util::DIS::DPG::ManakaiDPGException -object => $self, '-type' => 'PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;
    }
    $self->{has_error} = 
1
;
  


;}


}


}

{

my $doc = $doc;
my $parent = $el;

MATCH_2:
{

if ($token->{type} eq 'COLON') 
{

$token = $self->_scan_default;
if ($token->{type} eq 'NAME') 
{

my $ael;

{



        $ael = $doc->
create_element_ns

                        (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'attributeSpecification');
        $ael->
set_attribute_ns
 (
undef
, 'name', $token->{value});
        $ael->
set_attribute_ns
 (
undef
, 'value', '1');
        $parent->
append_child
 ($ael);
      


;}

{

my $parent = $ael;
$token = $self->_scan_default;
if ($token->{type} eq 'ZEROMORE') 
{


{



      $parent->
set_attribute_ns

                   (
undef
, 'occurence', 'zeromore');
    


;}
$token = $self->_scan_default;


}
elsif ($token->{type} eq 'ONEMORE') 
{


{



      $parent->
set_attribute_ns

                   (
undef
, 'occurence', 'onemore');
    


;}
$token = $self->_scan_default;


}
elsif ($token->{type} eq 'ZEROONE') 
{


{



      $parent->
set_attribute_ns
 
                   (
undef
, 'occurence', 'zeroone');
    


;}
$token = $self->_scan_default;


}


}
if ($token->{type} eq 'REPLACE') 
{

$token = $self->_scan_default;
if ($token->{type} eq 'STRING') 
{


{



            $ael->
set_attribute_ns

                    (
undef
, 'value',
                     substr ($token->{value}, 1, length ($token->{value}) - 2));
          


;}
$token = $self->_scan_default;


}
elsif ($token->{type} eq 'NAME') 
{


{



            $ael->
set_attribute_ns

                    (
undef
, 'value', $token->{value});
          


;}
$token = $self->_scan_default;


}
else 
{


{


{


    my 
$location = {
      utf32_offset => pos ($self->{source}),
    };
    my $continue = 
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, 'loc' => $location, '-type' => 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/bad-token-error', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest', 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token' => $token, 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/source-text' => \($self->{source});

;
    unless ($continue) {
      
report Message::Util::DIS::DPG::ManakaiDPGException -object => $self, '-type' => 'PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;
    }
    $self->{has_error} = 
1
;
  


;}


}


}


}


}
else 
{


{


{


    my 
$location = {
      utf32_offset => pos ($self->{source}),
    };
    my $continue = 
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, 'loc' => $location, '-type' => 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/bad-token-error', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest', 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token' => $token, 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/source-text' => \($self->{source});

;
    unless ($continue) {
      
report Message::Util::DIS::DPG::ManakaiDPGException -object => $self, '-type' => 'PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;
    }
    $self->{has_error} = 
1
;
  


;}


}


}


}
else 
{

last MATCH_2;


}
redo MATCH_2;


}
# MATCH_2


}
if ($token->{type} eq 'LBRACE') 
{

$token = $self->_scan_default;


}
else 
{


{


{


    my 
$location = {
      utf32_offset => pos ($self->{source}),
    };
    my $continue = 
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, 'loc' => $location, '-type' => 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/bad-token-error', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest', 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token' => $token, 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/source-text' => \($self->{source});

;
    unless ($continue) {
      
report Message::Util::DIS::DPG::ManakaiDPGException -object => $self, '-type' => 'PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;
    }
    $self->{has_error} = 
1
;
  


;}


}


}

MATCH_10:
{

if ($token->{type} eq 'NAME') 
{

my $lassign;

{



      $lassign = $doc->
create_element_ns

                         (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'lAssignmentStatement');
      $lassign->
set_attribute_ns
 (
undef
, 'name', $token->{value});
      $el->
append_child
 ($lassign);
    


;}

{

my $doc = $doc;
my $parent = $lassign;
$token = $self->_scan_default;

MATCH_4:
{

if ($token->{type} eq 'COLON') 
{

$token = $self->_scan_default;
if ($token->{type} eq 'NAME') 
{

my $ael;

{



        $ael = $doc->
create_element_ns

                        (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'attributeSpecification');
        $ael->
set_attribute_ns
 (
undef
, 'name', $token->{value});
        $ael->
set_attribute_ns
 (
undef
, 'value', '1');
        $parent->
append_child
 ($ael);
      


;}

{

my $parent = $ael;
$token = $self->_scan_default;
if ($token->{type} eq 'ZEROMORE') 
{


{



      $parent->
set_attribute_ns

                   (
undef
, 'occurence', 'zeromore');
    


;}
$token = $self->_scan_default;


}
elsif ($token->{type} eq 'ONEMORE') 
{


{



      $parent->
set_attribute_ns

                   (
undef
, 'occurence', 'onemore');
    


;}
$token = $self->_scan_default;


}
elsif ($token->{type} eq 'ZEROONE') 
{


{



      $parent->
set_attribute_ns
 
                   (
undef
, 'occurence', 'zeroone');
    


;}
$token = $self->_scan_default;


}


}
if ($token->{type} eq 'REPLACE') 
{

$token = $self->_scan_default;
if ($token->{type} eq 'STRING') 
{


{



            $ael->
set_attribute_ns

                    (
undef
, 'value',
                     substr ($token->{value}, 1, length ($token->{value}) - 2));
          


;}
$token = $self->_scan_default;


}
elsif ($token->{type} eq 'NAME') 
{


{



            $ael->
set_attribute_ns

                    (
undef
, 'value', $token->{value});
          


;}
$token = $self->_scan_default;


}
else 
{


{


{


    my 
$location = {
      utf32_offset => pos ($self->{source}),
    };
    my $continue = 
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, 'loc' => $location, '-type' => 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/bad-token-error', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest', 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token' => $token, 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/source-text' => \($self->{source});

;
    unless ($continue) {
      
report Message::Util::DIS::DPG::ManakaiDPGException -object => $self, '-type' => 'PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;
    }
    $self->{has_error} = 
1
;
  


;}


}


}


}


}
else 
{


{


{


    my 
$location = {
      utf32_offset => pos ($self->{source}),
    };
    my $continue = 
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, 'loc' => $location, '-type' => 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/bad-token-error', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest', 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token' => $token, 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/source-text' => \($self->{source});

;
    unless ($continue) {
      
report Message::Util::DIS::DPG::ManakaiDPGException -object => $self, '-type' => 'PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;
    }
    $self->{has_error} = 
1
;
  


;}


}


}


}
else 
{

last MATCH_4;


}
redo MATCH_4;


}
# MATCH_4


}
if ($token->{type} eq 'DEFINE') 
{

$token = $self->_scan_default;


}
else 
{


{


{


    my 
$location = {
      utf32_offset => pos ($self->{source}),
    };
    my $continue = 
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, 'loc' => $location, '-type' => 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/bad-token-error', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest', 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token' => $token, 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/source-text' => \($self->{source});

;
    unless ($continue) {
      
report Message::Util::DIS::DPG::ManakaiDPGException -object => $self, '-type' => 'PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;
    }
    $self->{has_error} = 
1
;
  


;}


}


}

{

my $doc = $doc;
my $parent = $lassign;

MATCH_11:
{

if ($token->{type} eq 'CLSOPEN') 
{

my $cls;

{



      $cls = $doc->
create_element_ns

                       (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'charClass');
      $lassign->
append_child
 ($cls);
    


;}

{

my $doc = $doc;
my $parent = $cls;
$token = $self->_scan_default;

{

my $has_content = 0;

MATCH_12:
{

if ($token->{type} eq 'STRING') 
{

$has_content = 1;

{


      my 
$str = $doc->
create_element_ns
 (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'string');
      $str->
text_content

              (substr ($token->{value}, 1, length ($token->{value}) - 2));
      $parent->
append_child
 ($str);
    


;}
$token = $self->_scan_default;


}
elsif ($token->{type} eq 'CHAR') 
{

$has_content = 1;
my $char;

{



      $char = $doc->
create_element_ns
 (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'charRange');
      my $code = $token->{value};
      $code =~ s/^U\+/0x/;
      $char->
set_attribute_ns
 (
undef
, 'start', hex $code);
      $char->
set_attribute_ns
 (
undef
, 'end', hex $code);
      $parent->
append_child
 ($char);
    


;}
$token = $self->_scan_default;
if ($token->{type} eq 'RANGE') 
{

$token = $self->_scan_default;
if ($token->{type} eq 'CHAR') 
{


{


          my 
$code = $token->{value};
          $code =~ s/^U\+/0x/;
          $char->
set_attribute_ns
 (
undef
, 'end', hex $code);
        


;}
$token = $self->_scan_default;


}
else 
{


{


{


    my 
$location = {
      utf32_offset => pos ($self->{source}),
    };
    my $continue = 
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, 'loc' => $location, '-type' => 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/bad-token-error', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest', 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token' => $token, 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/source-text' => \($self->{source});

;
    unless ($continue) {
      
report Message::Util::DIS::DPG::ManakaiDPGException -object => $self, '-type' => 'PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;
    }
    $self->{has_error} = 
1
;
  


;}


}


}


}


}
else 
{

if ($has_content == 0) 
{


{


{


    my 
$location = {
      utf32_offset => pos ($self->{source}),
    };
    my $continue = 
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, 'loc' => $location, '-type' => 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/bad-token-error', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest', 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token' => $token, 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/source-text' => \($self->{source});

;
    unless ($continue) {
      
report Message::Util::DIS::DPG::ManakaiDPGException -object => $self, '-type' => 'PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;
    }
    $self->{has_error} = 
1
;
  


;}


}


}
last MATCH_12;


}
redo MATCH_12;


}
# MATCH_12


}
if ($token->{type} eq 'CLSCLOSE') 
{

$token = $self->_scan_default;


}
else 
{


{


{


    my 
$location = {
      utf32_offset => pos ($self->{source}),
    };
    my $continue = 
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, 'loc' => $location, '-type' => 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/bad-token-error', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest', 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token' => $token, 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/source-text' => \($self->{source});

;
    unless ($continue) {
      
report Message::Util::DIS::DPG::ManakaiDPGException -object => $self, '-type' => 'PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;
    }
    $self->{has_error} = 
1
;
  


;}


}


}

{

my $parent = $parent;
if ($token->{type} eq 'ZEROMORE') 
{


{



      $parent->
set_attribute_ns

                   (
undef
, 'occurence', 'zeromore');
    


;}
$token = $self->_scan_default;


}
elsif ($token->{type} eq 'ONEMORE') 
{


{



      $parent->
set_attribute_ns

                   (
undef
, 'occurence', 'onemore');
    


;}
$token = $self->_scan_default;


}
elsif ($token->{type} eq 'ZEROONE') 
{


{



      $parent->
set_attribute_ns
 
                   (
undef
, 'occurence', 'zeroone');
    


;}
$token = $self->_scan_default;


}


}


}


}
elsif ($token->{type} eq 'NCLSOPEN') 
{

my $cls;

{



      $cls = $doc->
create_element_ns

                       (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'charClass');
      $cls->
set_attribute_ns
 (
undef
, 'negative', '1');
      $lassign->
append_child
 ($cls);
    


;}

{

my $doc = $doc;
my $parent = $cls;
$token = $self->_scan_default;

{

my $has_content = 0;

MATCH_12:
{

if ($token->{type} eq 'STRING') 
{

$has_content = 1;

{


      my 
$str = $doc->
create_element_ns
 (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'string');
      $str->
text_content

              (substr ($token->{value}, 1, length ($token->{value}) - 2));
      $parent->
append_child
 ($str);
    


;}
$token = $self->_scan_default;


}
elsif ($token->{type} eq 'CHAR') 
{

$has_content = 1;
my $char;

{



      $char = $doc->
create_element_ns
 (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'charRange');
      my $code = $token->{value};
      $code =~ s/^U\+/0x/;
      $char->
set_attribute_ns
 (
undef
, 'start', hex $code);
      $char->
set_attribute_ns
 (
undef
, 'end', hex $code);
      $parent->
append_child
 ($char);
    


;}
$token = $self->_scan_default;
if ($token->{type} eq 'RANGE') 
{

$token = $self->_scan_default;
if ($token->{type} eq 'CHAR') 
{


{


          my 
$code = $token->{value};
          $code =~ s/^U\+/0x/;
          $char->
set_attribute_ns
 (
undef
, 'end', hex $code);
        


;}
$token = $self->_scan_default;


}
else 
{


{


{


    my 
$location = {
      utf32_offset => pos ($self->{source}),
    };
    my $continue = 
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, 'loc' => $location, '-type' => 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/bad-token-error', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest', 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token' => $token, 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/source-text' => \($self->{source});

;
    unless ($continue) {
      
report Message::Util::DIS::DPG::ManakaiDPGException -object => $self, '-type' => 'PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;
    }
    $self->{has_error} = 
1
;
  


;}


}


}


}


}
else 
{

if ($has_content == 0) 
{


{


{


    my 
$location = {
      utf32_offset => pos ($self->{source}),
    };
    my $continue = 
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, 'loc' => $location, '-type' => 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/bad-token-error', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest', 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token' => $token, 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/source-text' => \($self->{source});

;
    unless ($continue) {
      
report Message::Util::DIS::DPG::ManakaiDPGException -object => $self, '-type' => 'PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;
    }
    $self->{has_error} = 
1
;
  


;}


}


}
last MATCH_12;


}
redo MATCH_12;


}
# MATCH_12


}
if ($token->{type} eq 'CLSCLOSE') 
{

$token = $self->_scan_default;


}
else 
{


{


{


    my 
$location = {
      utf32_offset => pos ($self->{source}),
    };
    my $continue = 
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, 'loc' => $location, '-type' => 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/bad-token-error', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest', 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token' => $token, 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/source-text' => \($self->{source});

;
    unless ($continue) {
      
report Message::Util::DIS::DPG::ManakaiDPGException -object => $self, '-type' => 'PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;
    }
    $self->{has_error} = 
1
;
  


;}


}


}

{

my $parent = $parent;
if ($token->{type} eq 'ZEROMORE') 
{


{



      $parent->
set_attribute_ns

                   (
undef
, 'occurence', 'zeromore');
    


;}
$token = $self->_scan_default;


}
elsif ($token->{type} eq 'ONEMORE') 
{


{



      $parent->
set_attribute_ns

                   (
undef
, 'occurence', 'onemore');
    


;}
$token = $self->_scan_default;


}
elsif ($token->{type} eq 'ZEROONE') 
{


{



      $parent->
set_attribute_ns
 
                   (
undef
, 'occurence', 'zeroone');
    


;}
$token = $self->_scan_default;


}


}


}


}
elsif ($token->{type} eq 'DOT') 
{

my $cls;

{



      $cls = $doc->
create_element_ns
 (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'anyChar');
      $lassign->
append_child
 ($cls);
    


;}

{

my $parent = $cls;
$token = $self->_scan_default;
if ($token->{type} eq 'ZEROMORE') 
{


{



      $parent->
set_attribute_ns

                   (
undef
, 'occurence', 'zeromore');
    


;}
$token = $self->_scan_default;


}
elsif ($token->{type} eq 'ONEMORE') 
{


{



      $parent->
set_attribute_ns

                   (
undef
, 'occurence', 'onemore');
    


;}
$token = $self->_scan_default;


}
elsif ($token->{type} eq 'ZEROONE') 
{


{



      $parent->
set_attribute_ns
 
                   (
undef
, 'occurence', 'zeroone');
    


;}
$token = $self->_scan_default;


}


}


}
elsif ($token->{type} eq 'VARIABLE') 
{

my $lname;

{



      $lname = $doc->
create_element_ns

                            (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'lVariableRef');
      $lname->
set_attribute_ns

                            (
undef
, 'name', substr ($token->{value}, 1));
      $lassign->
append_child
 ($lname);
    


;}

{

my $parent = $lname;
$token = $self->_scan_default;
if ($token->{type} eq 'ZEROMORE') 
{


{



      $parent->
set_attribute_ns

                   (
undef
, 'occurence', 'zeromore');
    


;}
$token = $self->_scan_default;


}
elsif ($token->{type} eq 'ONEMORE') 
{


{



      $parent->
set_attribute_ns

                   (
undef
, 'occurence', 'onemore');
    


;}
$token = $self->_scan_default;


}
elsif ($token->{type} eq 'ZEROONE') 
{


{



      $parent->
set_attribute_ns
 
                   (
undef
, 'occurence', 'zeroone');
    


;}
$token = $self->_scan_default;


}


}


}
else 
{

last MATCH_11;


}
redo MATCH_11;


}
# MATCH_11


}
if ($token->{type} eq 'SEMICOLON') 
{

$token = $self->_scan_default;


}
else 
{


{


{


    my 
$location = {
      utf32_offset => pos ($self->{source}),
    };
    my $continue = 
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, 'loc' => $location, '-type' => 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/bad-token-error', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest', 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token' => $token, 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/source-text' => \($self->{source});

;
    unless ($continue) {
      
report Message::Util::DIS::DPG::ManakaiDPGException -object => $self, '-type' => 'PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;
    }
    $self->{has_error} = 
1
;
  


;}


}


}


}
elsif ($token->{type} eq 'VARIABLE') 
{

my $lassign;

{



      $lassign = $doc->
create_element_ns

                         (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'lAssignmentStatement');
      $lassign->
set_attribute_ns

                         (
undef
, 'name', substr ($token->{value}, 1));
      $lassign->
set_attribute_ns
 (
undef
, 'isVariable', '1');
      $el->
append_child
 ($lassign);
    


;}

{

my $doc = $doc;
my $parent = $lassign;
$token = $self->_scan_default;

MATCH_4:
{

if ($token->{type} eq 'COLON') 
{

$token = $self->_scan_default;
if ($token->{type} eq 'NAME') 
{

my $ael;

{



        $ael = $doc->
create_element_ns

                        (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'attributeSpecification');
        $ael->
set_attribute_ns
 (
undef
, 'name', $token->{value});
        $ael->
set_attribute_ns
 (
undef
, 'value', '1');
        $parent->
append_child
 ($ael);
      


;}

{

my $parent = $ael;
$token = $self->_scan_default;
if ($token->{type} eq 'ZEROMORE') 
{


{



      $parent->
set_attribute_ns

                   (
undef
, 'occurence', 'zeromore');
    


;}
$token = $self->_scan_default;


}
elsif ($token->{type} eq 'ONEMORE') 
{


{



      $parent->
set_attribute_ns

                   (
undef
, 'occurence', 'onemore');
    


;}
$token = $self->_scan_default;


}
elsif ($token->{type} eq 'ZEROONE') 
{


{



      $parent->
set_attribute_ns
 
                   (
undef
, 'occurence', 'zeroone');
    


;}
$token = $self->_scan_default;


}


}
if ($token->{type} eq 'REPLACE') 
{

$token = $self->_scan_default;
if ($token->{type} eq 'STRING') 
{


{



            $ael->
set_attribute_ns

                    (
undef
, 'value',
                     substr ($token->{value}, 1, length ($token->{value}) - 2));
          


;}
$token = $self->_scan_default;


}
elsif ($token->{type} eq 'NAME') 
{


{



            $ael->
set_attribute_ns

                    (
undef
, 'value', $token->{value});
          


;}
$token = $self->_scan_default;


}
else 
{


{


{


    my 
$location = {
      utf32_offset => pos ($self->{source}),
    };
    my $continue = 
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, 'loc' => $location, '-type' => 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/bad-token-error', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest', 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token' => $token, 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/source-text' => \($self->{source});

;
    unless ($continue) {
      
report Message::Util::DIS::DPG::ManakaiDPGException -object => $self, '-type' => 'PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;
    }
    $self->{has_error} = 
1
;
  


;}


}


}


}


}
else 
{


{


{


    my 
$location = {
      utf32_offset => pos ($self->{source}),
    };
    my $continue = 
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, 'loc' => $location, '-type' => 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/bad-token-error', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest', 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token' => $token, 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/source-text' => \($self->{source});

;
    unless ($continue) {
      
report Message::Util::DIS::DPG::ManakaiDPGException -object => $self, '-type' => 'PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;
    }
    $self->{has_error} = 
1
;
  


;}


}


}


}
else 
{

last MATCH_4;


}
redo MATCH_4;


}
# MATCH_4


}
if ($token->{type} eq 'DEFINE') 
{

$token = $self->_scan_default;


}
else 
{


{


{


    my 
$location = {
      utf32_offset => pos ($self->{source}),
    };
    my $continue = 
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, 'loc' => $location, '-type' => 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/bad-token-error', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest', 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token' => $token, 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/source-text' => \($self->{source});

;
    unless ($continue) {
      
report Message::Util::DIS::DPG::ManakaiDPGException -object => $self, '-type' => 'PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;
    }
    $self->{has_error} = 
1
;
  


;}


}


}

{

my $doc = $doc;
my $parent = $lassign;

MATCH_11:
{

if ($token->{type} eq 'CLSOPEN') 
{

my $cls;

{



      $cls = $doc->
create_element_ns

                       (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'charClass');
      $lassign->
append_child
 ($cls);
    


;}

{

my $doc = $doc;
my $parent = $cls;
$token = $self->_scan_default;

{

my $has_content = 0;

MATCH_12:
{

if ($token->{type} eq 'STRING') 
{

$has_content = 1;

{


      my 
$str = $doc->
create_element_ns
 (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'string');
      $str->
text_content

              (substr ($token->{value}, 1, length ($token->{value}) - 2));
      $parent->
append_child
 ($str);
    


;}
$token = $self->_scan_default;


}
elsif ($token->{type} eq 'CHAR') 
{

$has_content = 1;
my $char;

{



      $char = $doc->
create_element_ns
 (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'charRange');
      my $code = $token->{value};
      $code =~ s/^U\+/0x/;
      $char->
set_attribute_ns
 (
undef
, 'start', hex $code);
      $char->
set_attribute_ns
 (
undef
, 'end', hex $code);
      $parent->
append_child
 ($char);
    


;}
$token = $self->_scan_default;
if ($token->{type} eq 'RANGE') 
{

$token = $self->_scan_default;
if ($token->{type} eq 'CHAR') 
{


{


          my 
$code = $token->{value};
          $code =~ s/^U\+/0x/;
          $char->
set_attribute_ns
 (
undef
, 'end', hex $code);
        


;}
$token = $self->_scan_default;


}
else 
{


{


{


    my 
$location = {
      utf32_offset => pos ($self->{source}),
    };
    my $continue = 
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, 'loc' => $location, '-type' => 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/bad-token-error', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest', 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token' => $token, 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/source-text' => \($self->{source});

;
    unless ($continue) {
      
report Message::Util::DIS::DPG::ManakaiDPGException -object => $self, '-type' => 'PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;
    }
    $self->{has_error} = 
1
;
  


;}


}


}


}


}
else 
{

if ($has_content == 0) 
{


{


{


    my 
$location = {
      utf32_offset => pos ($self->{source}),
    };
    my $continue = 
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, 'loc' => $location, '-type' => 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/bad-token-error', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest', 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token' => $token, 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/source-text' => \($self->{source});

;
    unless ($continue) {
      
report Message::Util::DIS::DPG::ManakaiDPGException -object => $self, '-type' => 'PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;
    }
    $self->{has_error} = 
1
;
  


;}


}


}
last MATCH_12;


}
redo MATCH_12;


}
# MATCH_12


}
if ($token->{type} eq 'CLSCLOSE') 
{

$token = $self->_scan_default;


}
else 
{


{


{


    my 
$location = {
      utf32_offset => pos ($self->{source}),
    };
    my $continue = 
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, 'loc' => $location, '-type' => 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/bad-token-error', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest', 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token' => $token, 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/source-text' => \($self->{source});

;
    unless ($continue) {
      
report Message::Util::DIS::DPG::ManakaiDPGException -object => $self, '-type' => 'PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;
    }
    $self->{has_error} = 
1
;
  


;}


}


}

{

my $parent = $parent;
if ($token->{type} eq 'ZEROMORE') 
{


{



      $parent->
set_attribute_ns

                   (
undef
, 'occurence', 'zeromore');
    


;}
$token = $self->_scan_default;


}
elsif ($token->{type} eq 'ONEMORE') 
{


{



      $parent->
set_attribute_ns

                   (
undef
, 'occurence', 'onemore');
    


;}
$token = $self->_scan_default;


}
elsif ($token->{type} eq 'ZEROONE') 
{


{



      $parent->
set_attribute_ns
 
                   (
undef
, 'occurence', 'zeroone');
    


;}
$token = $self->_scan_default;


}


}


}


}
elsif ($token->{type} eq 'NCLSOPEN') 
{

my $cls;

{



      $cls = $doc->
create_element_ns

                       (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'charClass');
      $cls->
set_attribute_ns
 (
undef
, 'negative', '1');
      $lassign->
append_child
 ($cls);
    


;}

{

my $doc = $doc;
my $parent = $cls;
$token = $self->_scan_default;

{

my $has_content = 0;

MATCH_12:
{

if ($token->{type} eq 'STRING') 
{

$has_content = 1;

{


      my 
$str = $doc->
create_element_ns
 (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'string');
      $str->
text_content

              (substr ($token->{value}, 1, length ($token->{value}) - 2));
      $parent->
append_child
 ($str);
    


;}
$token = $self->_scan_default;


}
elsif ($token->{type} eq 'CHAR') 
{

$has_content = 1;
my $char;

{



      $char = $doc->
create_element_ns
 (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'charRange');
      my $code = $token->{value};
      $code =~ s/^U\+/0x/;
      $char->
set_attribute_ns
 (
undef
, 'start', hex $code);
      $char->
set_attribute_ns
 (
undef
, 'end', hex $code);
      $parent->
append_child
 ($char);
    


;}
$token = $self->_scan_default;
if ($token->{type} eq 'RANGE') 
{

$token = $self->_scan_default;
if ($token->{type} eq 'CHAR') 
{


{


          my 
$code = $token->{value};
          $code =~ s/^U\+/0x/;
          $char->
set_attribute_ns
 (
undef
, 'end', hex $code);
        


;}
$token = $self->_scan_default;


}
else 
{


{


{


    my 
$location = {
      utf32_offset => pos ($self->{source}),
    };
    my $continue = 
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, 'loc' => $location, '-type' => 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/bad-token-error', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest', 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token' => $token, 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/source-text' => \($self->{source});

;
    unless ($continue) {
      
report Message::Util::DIS::DPG::ManakaiDPGException -object => $self, '-type' => 'PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;
    }
    $self->{has_error} = 
1
;
  


;}


}


}


}


}
else 
{

if ($has_content == 0) 
{


{


{


    my 
$location = {
      utf32_offset => pos ($self->{source}),
    };
    my $continue = 
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, 'loc' => $location, '-type' => 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/bad-token-error', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest', 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token' => $token, 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/source-text' => \($self->{source});

;
    unless ($continue) {
      
report Message::Util::DIS::DPG::ManakaiDPGException -object => $self, '-type' => 'PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;
    }
    $self->{has_error} = 
1
;
  


;}


}


}
last MATCH_12;


}
redo MATCH_12;


}
# MATCH_12


}
if ($token->{type} eq 'CLSCLOSE') 
{

$token = $self->_scan_default;


}
else 
{


{


{


    my 
$location = {
      utf32_offset => pos ($self->{source}),
    };
    my $continue = 
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, 'loc' => $location, '-type' => 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/bad-token-error', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest', 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token' => $token, 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/source-text' => \($self->{source});

;
    unless ($continue) {
      
report Message::Util::DIS::DPG::ManakaiDPGException -object => $self, '-type' => 'PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;
    }
    $self->{has_error} = 
1
;
  


;}


}


}

{

my $parent = $parent;
if ($token->{type} eq 'ZEROMORE') 
{


{



      $parent->
set_attribute_ns

                   (
undef
, 'occurence', 'zeromore');
    


;}
$token = $self->_scan_default;


}
elsif ($token->{type} eq 'ONEMORE') 
{


{



      $parent->
set_attribute_ns

                   (
undef
, 'occurence', 'onemore');
    


;}
$token = $self->_scan_default;


}
elsif ($token->{type} eq 'ZEROONE') 
{


{



      $parent->
set_attribute_ns
 
                   (
undef
, 'occurence', 'zeroone');
    


;}
$token = $self->_scan_default;


}


}


}


}
elsif ($token->{type} eq 'DOT') 
{

my $cls;

{



      $cls = $doc->
create_element_ns
 (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'anyChar');
      $lassign->
append_child
 ($cls);
    


;}

{

my $parent = $cls;
$token = $self->_scan_default;
if ($token->{type} eq 'ZEROMORE') 
{


{



      $parent->
set_attribute_ns

                   (
undef
, 'occurence', 'zeromore');
    


;}
$token = $self->_scan_default;


}
elsif ($token->{type} eq 'ONEMORE') 
{


{



      $parent->
set_attribute_ns

                   (
undef
, 'occurence', 'onemore');
    


;}
$token = $self->_scan_default;


}
elsif ($token->{type} eq 'ZEROONE') 
{


{



      $parent->
set_attribute_ns
 
                   (
undef
, 'occurence', 'zeroone');
    


;}
$token = $self->_scan_default;


}


}


}
elsif ($token->{type} eq 'VARIABLE') 
{

my $lname;

{



      $lname = $doc->
create_element_ns

                            (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'lVariableRef');
      $lname->
set_attribute_ns

                            (
undef
, 'name', substr ($token->{value}, 1));
      $lassign->
append_child
 ($lname);
    


;}

{

my $parent = $lname;
$token = $self->_scan_default;
if ($token->{type} eq 'ZEROMORE') 
{


{



      $parent->
set_attribute_ns

                   (
undef
, 'occurence', 'zeromore');
    


;}
$token = $self->_scan_default;


}
elsif ($token->{type} eq 'ONEMORE') 
{


{



      $parent->
set_attribute_ns

                   (
undef
, 'occurence', 'onemore');
    


;}
$token = $self->_scan_default;


}
elsif ($token->{type} eq 'ZEROONE') 
{


{



      $parent->
set_attribute_ns
 
                   (
undef
, 'occurence', 'zeroone');
    


;}
$token = $self->_scan_default;


}


}


}
else 
{

last MATCH_11;


}
redo MATCH_11;


}
# MATCH_11


}
if ($token->{type} eq 'SEMICOLON') 
{

$token = $self->_scan_default;


}
else 
{


{


{


    my 
$location = {
      utf32_offset => pos ($self->{source}),
    };
    my $continue = 
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, 'loc' => $location, '-type' => 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/bad-token-error', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest', 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token' => $token, 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/source-text' => \($self->{source});

;
    unless ($continue) {
      
report Message::Util::DIS::DPG::ManakaiDPGException -object => $self, '-type' => 'PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;
    }
    $self->{has_error} = 
1
;
  


;}


}


}


}
elsif (($token->{type} eq 'QKEYWORD') and ($token->{value} eq '?default-token')) 
{

my $ldef;
$token = $self->_scan_default;
if ($token->{type} eq 'NAME') 
{


{



        $ldef = $doc->
create_element_ns

                           (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'lQDefaultTokenStatement');
        $ldef->
set_attribute_ns
 (
undef
, 'name', $token->{value});
        $el->
append_child
 ($ldef);
      


;}
$token = $self->_scan_default;


}
else 
{


{


{


    my 
$location = {
      utf32_offset => pos ($self->{source}),
    };
    my $continue = 
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, 'loc' => $location, '-type' => 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/bad-token-error', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest', 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token' => $token, 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/source-text' => \($self->{source});

;
    unless ($continue) {
      
report Message::Util::DIS::DPG::ManakaiDPGException -object => $self, '-type' => 'PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;
    }
    $self->{has_error} = 
1
;
  


;}


}


}

{

my $doc = $doc;
my $parent = $ldef;

MATCH_2:
{

if ($token->{type} eq 'COLON') 
{

$token = $self->_scan_default;
if ($token->{type} eq 'NAME') 
{

my $ael;

{



        $ael = $doc->
create_element_ns

                        (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'attributeSpecification');
        $ael->
set_attribute_ns
 (
undef
, 'name', $token->{value});
        $ael->
set_attribute_ns
 (
undef
, 'value', '1');
        $parent->
append_child
 ($ael);
      


;}

{

my $parent = $ael;
$token = $self->_scan_default;
if ($token->{type} eq 'ZEROMORE') 
{


{



      $parent->
set_attribute_ns

                   (
undef
, 'occurence', 'zeromore');
    


;}
$token = $self->_scan_default;


}
elsif ($token->{type} eq 'ONEMORE') 
{


{



      $parent->
set_attribute_ns

                   (
undef
, 'occurence', 'onemore');
    


;}
$token = $self->_scan_default;


}
elsif ($token->{type} eq 'ZEROONE') 
{


{



      $parent->
set_attribute_ns
 
                   (
undef
, 'occurence', 'zeroone');
    


;}
$token = $self->_scan_default;


}


}
if ($token->{type} eq 'REPLACE') 
{

$token = $self->_scan_default;
if ($token->{type} eq 'STRING') 
{


{



            $ael->
set_attribute_ns

                    (
undef
, 'value',
                     substr ($token->{value}, 1, length ($token->{value}) - 2));
          


;}
$token = $self->_scan_default;


}
elsif ($token->{type} eq 'NAME') 
{


{



            $ael->
set_attribute_ns

                    (
undef
, 'value', $token->{value});
          


;}
$token = $self->_scan_default;


}
else 
{


{


{


    my 
$location = {
      utf32_offset => pos ($self->{source}),
    };
    my $continue = 
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, 'loc' => $location, '-type' => 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/bad-token-error', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest', 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token' => $token, 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/source-text' => \($self->{source});

;
    unless ($continue) {
      
report Message::Util::DIS::DPG::ManakaiDPGException -object => $self, '-type' => 'PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;
    }
    $self->{has_error} = 
1
;
  


;}


}


}


}


}
else 
{


{


{


    my 
$location = {
      utf32_offset => pos ($self->{source}),
    };
    my $continue = 
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, 'loc' => $location, '-type' => 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/bad-token-error', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest', 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token' => $token, 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/source-text' => \($self->{source});

;
    unless ($continue) {
      
report Message::Util::DIS::DPG::ManakaiDPGException -object => $self, '-type' => 'PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;
    }
    $self->{has_error} = 
1
;
  


;}


}


}


}
else 
{

last MATCH_2;


}
redo MATCH_2;


}
# MATCH_2


}
if ($token->{type} eq 'SEMICOLON') 
{

$token = $self->_scan_default;


}
else 
{


{


{


    my 
$location = {
      utf32_offset => pos ($self->{source}),
    };
    my $continue = 
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, 'loc' => $location, '-type' => 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/bad-token-error', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest', 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token' => $token, 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/source-text' => \($self->{source});

;
    unless ($continue) {
      
report Message::Util::DIS::DPG::ManakaiDPGException -object => $self, '-type' => 'PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;
    }
    $self->{has_error} = 
1
;
  


;}


}


}


}
else 
{

last MATCH_10;


}
redo MATCH_10;


}
# MATCH_10
if ($token->{type} eq 'RBRACE') 
{

$token = $self->_scan_default;


}
else 
{


{


{


    my 
$location = {
      utf32_offset => pos ($self->{source}),
    };
    my $continue = 
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, 'loc' => $location, '-type' => 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/bad-token-error', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest', 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token' => $token, 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/source-text' => \($self->{source});

;
    unless ($continue) {
      
report Message::Util::DIS::DPG::ManakaiDPGException -object => $self, '-type' => 'PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;
    }
    $self->{has_error} = 
1
;
  


;}


}


}


}


}
elsif (($token->{type} eq 'NAME') and ($token->{value} eq 'token-error')) 
{


{

my $doc = $doc;
my $parent = $docel;
my $el;
$token = $self->_scan_default;
if ($token->{type} eq 'NAME') 
{


{



      $el = $doc->
create_element_ns
 (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'tokenError');
      $el->
set_attribute_ns
 (
undef
, 'name', $token->{value});
      $parent->
append_child
 ($el);
    


;}
$token = $self->_scan_default;


}
else 
{


{


{


    my 
$location = {
      utf32_offset => pos ($self->{source}),
    };
    my $continue = 
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, 'loc' => $location, '-type' => 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/bad-token-error', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest', 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token' => $token, 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/source-text' => \($self->{source});

;
    unless ($continue) {
      
report Message::Util::DIS::DPG::ManakaiDPGException -object => $self, '-type' => 'PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;
    }
    $self->{has_error} = 
1
;
  


;}


}


}

{

my $doc = $doc;
my $parent = $el;
if ($token->{type} eq 'LPAREN') 
{

$token = $self->_scan_default;

MATCH_9:
{

if ($token->{type} eq 'VARIABLE') 
{


{


        my 
$pel = $doc->
create_element_ns

                          (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'parameterDeclaration');
        $pel->
set_attribute_ns

                (
undef
, 'name', substr ($token->{value}, 1));
        $parent->
append_child
 ($pel);
      


;}
$token = $self->_scan_default;


}
if ($token->{type} eq 'COMMA') 
{

$token = $self->_scan_default;
redo MATCH_9;


}
else 
{

last MATCH_9;


}


}
# MATCH_9
if ($token->{type} eq 'RPAREN') 
{

$token = $self->_scan_default;


}
else 
{


{


{


    my 
$location = {
      utf32_offset => pos ($self->{source}),
    };
    my $continue = 
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, 'loc' => $location, '-type' => 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/bad-token-error', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest', 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token' => $token, 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/source-text' => \($self->{source});

;
    unless ($continue) {
      
report Message::Util::DIS::DPG::ManakaiDPGException -object => $self, '-type' => 'PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;
    }
    $self->{has_error} = 
1
;
  


;}


}


}


}


}

{

my $doc = $doc;
my $parent = $el;

MATCH_2:
{

if ($token->{type} eq 'COLON') 
{

$token = $self->_scan_default;
if ($token->{type} eq 'NAME') 
{

my $ael;

{



        $ael = $doc->
create_element_ns

                        (
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/'
, 'attributeSpecification');
        $ael->
set_attribute_ns
 (
undef
, 'name', $token->{value});
        $ael->
set_attribute_ns
 (
undef
, 'value', '1');
        $parent->
append_child
 ($ael);
      


;}

{

my $parent = $ael;
$token = $self->_scan_default;
if ($token->{type} eq 'ZEROMORE') 
{


{



      $parent->
set_attribute_ns

                   (
undef
, 'occurence', 'zeromore');
    


;}
$token = $self->_scan_default;


}
elsif ($token->{type} eq 'ONEMORE') 
{


{



      $parent->
set_attribute_ns

                   (
undef
, 'occurence', 'onemore');
    


;}
$token = $self->_scan_default;


}
elsif ($token->{type} eq 'ZEROONE') 
{


{



      $parent->
set_attribute_ns
 
                   (
undef
, 'occurence', 'zeroone');
    


;}
$token = $self->_scan_default;


}


}
if ($token->{type} eq 'REPLACE') 
{

$token = $self->_scan_default;
if ($token->{type} eq 'STRING') 
{


{



            $ael->
set_attribute_ns

                    (
undef
, 'value',
                     substr ($token->{value}, 1, length ($token->{value}) - 2));
          


;}
$token = $self->_scan_default;


}
elsif ($token->{type} eq 'NAME') 
{


{



            $ael->
set_attribute_ns

                    (
undef
, 'value', $token->{value});
          


;}
$token = $self->_scan_default;


}
else 
{


{


{


    my 
$location = {
      utf32_offset => pos ($self->{source}),
    };
    my $continue = 
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, 'loc' => $location, '-type' => 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/bad-token-error', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest', 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token' => $token, 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/source-text' => \($self->{source});

;
    unless ($continue) {
      
report Message::Util::DIS::DPG::ManakaiDPGException -object => $self, '-type' => 'PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;
    }
    $self->{has_error} = 
1
;
  


;}


}


}


}


}
else 
{


{


{


    my 
$location = {
      utf32_offset => pos ($self->{source}),
    };
    my $continue = 
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, 'loc' => $location, '-type' => 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/bad-token-error', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest', 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token' => $token, 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/source-text' => \($self->{source});

;
    unless ($continue) {
      
report Message::Util::DIS::DPG::ManakaiDPGException -object => $self, '-type' => 'PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;
    }
    $self->{has_error} = 
1
;
  


;}


}


}


}
else 
{

last MATCH_2;


}
redo MATCH_2;


}
# MATCH_2


}
if ($token->{type} eq 'LBRACE') 
{

$self->_parse__CodeBlock ($doc, $el);
$token = $self->_scan_default;


}
else 
{


{


{


    my 
$location = {
      utf32_offset => pos ($self->{source}),
    };
    my $continue = 
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, 'loc' => $location, '-type' => 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/bad-token-error', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest', 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token' => $token, 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/source-text' => \($self->{source});

;
    unless ($continue) {
      
report Message::Util::DIS::DPG::ManakaiDPGException -object => $self, '-type' => 'PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;
    }
    $self->{has_error} = 
1
;
  


;}


}


}


}


}
else 
{

last MATCH_8;


}
redo MATCH_8;


}
# MATCH_8
if ($token->{type} eq '#EOF') 
{

$token = $self->_scan_default;


}
else 
{


{


{


    my 
$location = {
      utf32_offset => pos ($self->{source}),
    };
    my $continue = 
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, 'loc' => $location, '-type' => 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/bad-token-error', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest', 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token' => $token, 'http://suika.fam.cx/~wakaba/archive/2005/11/pg/source-text' => \($self->{source});

;
    unless ($continue) {
      
report Message::Util::DIS::DPG::ManakaiDPGException -object => $self, '-type' => 'PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;
    }
    $self->{has_error} = 
1
;
  


;}


}


}

{


    if 
($self->{has_error}) {
      
report Message::Util::DIS::DPG::ManakaiDPGException -object => $self, '-type' => 'PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS%23DPG/ManakaiDPGParser+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;
    }
  


;}
unshift (@{$self->{token}}, $token);
return $doc;
}
$Message::DOM::DOMFeature::ClassInfo->{q<Message::Util::DIS::DPG::ManakaiDPGParser>}->{has_feature} = {'http://suika.fam.cx/~wakaba/archive/2005/manakai/util/dis#dpg',
{'',
'1',
'1.0',
'1'}};
$Message::DOM::ClassPoint{q<Message::Util::DIS::DPG::ManakaiDPGParser>} = 1;
$Message::DOM::DOMLS::ParserClass{q<Message::Util::DIS::DPG::ManakaiDPGParser>} = 1;
package Message::Util::IF::DPGException;
our $VERSION = 20060401.0605;
push our @ISA, 'Message::Util::Error';

sub ___error_def () {
  \%Message::Util::IF::DPGException::ErrorDef
}

sub PARSE_ERR () {
81}
$Message::Util::IF::DPGException::ErrorDef{'PARSE_ERR'} = {'description',
'An attempt was made to load a DPG document and the processing has been stopped.',
'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#code',
'81'};
sub VALIDITY_ERR () {
10083}
$Message::Util::IF::DPGException::ErrorDef{'VALIDITY_ERR'} = {'description',
'An attempt was made to process an invalid DPG document and the processing has been stopped.',
'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#code',
'10083'};
package Message::Util::DIS::DPG::ManakaiDPGException;
our $VERSION = 20060401.0605;
push our @ISA, 'Message::Util::Error::DOMException::Exception',
'Message::Util::IF::DPGException';
sub _FORMATTER_PACKAGE_ {
'Message::Util::DIS::DPG::ManakaiDPGExceptionFormatter'}
$Message::DOM::DOMFeature::ClassInfo->{q<Message::Util::DIS::DPG::ManakaiDPGException>}->{has_feature} = {'http://suika.fam.cx/~wakaba/archive/2005/manakai/util/dis#dpg',
{'',
'1',
'1.0',
'1'}};
$Message::DOM::ClassPoint{q<Message::Util::DIS::DPG::ManakaiDPGException>} = 1;
package Message::Util::IF::DPGExceptionFormatter;
our $VERSION = 20060401.0605;
package Message::Util::DIS::DPG::ManakaiDPGExceptionFormatter;
our $VERSION = 20060401.0605;
push our @ISA, 'Message::Util::Error::formatter',
'Message::Util::IF::DPGExceptionFormatter';
sub ___rule_def {
{'dpg_error_lines',
{'after',
sub ($$$$) {
my ($self, $name, $p, $o) = @_;

{

my 
$pos = $o->
location

            ->
utf32_offset
;
if ($pos > -1) {
  my $src = $o->{
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/source-text'
};
  my $start = $pos;
  $start = rindex ($$src, "\x0A", $start - 1) for 0..2;
  $start++;
  my $end = $pos;
  $end = index ($$src, "\x0A", $end + 1) for 0..2;
  $end = length $$src if $end < 0;
  $p->{-result} = substr $$src, $start, $end - $start;
}


;}
}
},
'dpg_error_token_type',
{'after',
sub ($$$$) {
my ($self, $name, $p, $o) = @_;

{


$p->{-result} = $o->{
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token'
}->{type}
  if defined $o->{
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token'
}->{type};


;}
}
},
'dpg_error_token_value',
{'after',
sub ($$$$) {
my ($self, $name, $p, $o) = @_;

{


$p->{-result} = $o->{
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token'
}->{value}
  if defined $o->{
'http://suika.fam.cx/~wakaba/archive/2005/11/pg/error-token'
}->{value};


;}
}
}};
}
$Message::DOM::DOMFeature::ClassInfo->{q<Message::Util::DIS::DPG::ManakaiDPGExceptionFormatter>}->{has_feature} = {'http://suika.fam.cx/~wakaba/archive/2005/manakai/util/dis#dpg',
{'',
'1',
'1.0',
'1'}};
$Message::DOM::ClassPoint{q<Message::Util::DIS::DPG::ManakaiDPGExceptionFormatter>} = 1;
for ($Message::DOM::IFLatest::Document::, $Message::DOM::IFLatest::Element::, $Message::DOM::IFLatest::Node::, $Message::Util::Error::MUErrorTarget::){}
## License: <http://suika.fam.cx/~wakaba/archive/2004/8/18/license#Perl+MPL>
1;
