Module:
  @QName:
    DIS:DNLite
  @FullName:
    @@lang: en
    @@@:
      Simplified <QUOTE::dis> Node Module
  @Namespace:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS#DNLite/
  
  @Description:
    @@lang:en
    @@@:
      This module provides a simplified implementation of
      <QUOTE::dis> node object model.

  @DISCore:author: DISCore|Wakaba
  @License:
    license:Perl+MPL
  @Date:
    $Date: 2006/12/31 09:12:01 $
  
  @Require:
    @@Module:
      @@@QName: Util|DIS
    @@Module:
      @@@QName: DIS|common
    @@Module:
      @@@QName: DIS|Perl

Namespace:
  @c:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#
  @DIS:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS#
  @dis:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#dis--
  @DOMMain:
    http://suika.fam.cx/~wakaba/archive/2004/dom/main#
  @domperl:
    http://suika.fam.cx/~wakaba/archive/2006/dom/perl/
  @dp:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS#Perl/
  @dx:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#
  @f:
    http://suika.fam.cx/~wakaba/archive/2004/dom/feature#
  @infoset:
    http://www.w3.org/2001/04/infoset#
  @kwd:
    http://suika.fam.cx/~wakaba/archive/2005/rfc2119/
  @lang:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#
  @license:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/license#
  @ManakaiDOM:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#
  @MDOM:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#ManakaiDOM.
  @MDOMX:
    http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#
  @mn:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/ManakaiNode#
  @pl:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#Perl--
  @rdf:
    http://www.w3.org/1999/02/22-rdf-syntax-ns#
  @swcfg21:
    http://suika.fam.cx/~wakaba/archive/2005/swcfg21#
  @test:
    http://suika.fam.cx/~wakaba/archive/2004/dis/Test#
  @Util:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/

## -- Features

ElementTypeBinding:
  @Name: FeatureDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: f|Feature

ElementTypeBinding:
  @Name: FeatureVerDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: f|Feature

ElementTypeBinding:
  @Name: featureQName
  @ElementType:
    f:name
  @ShadowContent:
    @@ContentType: DISCore|QName

FeatureDef:
  @QName: DIS|DNLite
  @FeatureVerDef:
    @@QName: DIS|DNLite10
    @@f:version: 1.0
    @@f:instanceOf: DIS|DNLite
    @@f:requires: DIS|CoreFeature10
    @@FullName:
      @@@lang:en
      @@@@:
        <QUOTE::dis> Simplified Node Module version 1.0

ElementTypeBinding:
  @Name: enDesc
  @ElementType: 
    dis:Description
  @ShadowContent: 
    @@lang:en

ElementTypeBinding:
  @Name: IFClsDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      @@@@: dis|MultipleResource
      @@@ForCheck: !ManakaiDOM|ForIF !ManakaiDOM|ForClass
    @@resourceFor: ManakaiDOM|ForIF
    @@resourceFor: ManakaiDOM|ForClass

    @@rdf:type:
      @@@@: ManakaiDOM|IF
      @@@ForCheck: ManakaiDOM|ForIF

    @@rdf:type:
      @@@@: ManakaiDOM|Class
      @@@ForCheck: ManakaiDOM|ForClass
    @@Implement:
      @@@@: ||+||ManakaiDOM|ForIF
      @@@ForCheck: ManakaiDOM|ForClass
      @@@ContentType: DISCore|TFPQNames

    @@f:implements: DIS|DNLite10

ElementTypeBinding:
  @Name: IFDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      @@@@: dis|MultipleResource
      @@@ForCheck: !ManakaiDOM|ForIF !ManakaiDOM|ForClass
    @@resourceFor: ManakaiDOM|ForIF

    @@rdf:type:
      @@@@: ManakaiDOM|IF
      @@@ForCheck: ManakaiDOM|ForIF

    @@f:implements: DIS|DNLite10

ElementTypeBinding:
  @Name: ClsDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      @@@@: dis|MultipleResource
      @@@ForCheck: !ManakaiDOM|ForIF !ManakaiDOM|ForClass
    @@resourceFor: ManakaiDOM|ForClass

    @@rdf:type:
      @@@@: ManakaiDOM|Class
      @@@ForCheck: ManakaiDOM|ForClass

    @@f:implements: DIS|DNLite10

ElementTypeBinding:
  @Name: IFQName
  @ElementType:
    dis:QName
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForIF

ElementTypeBinding:
  @Name: ClsQName
  @ElementType:
    dis:QName
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: IFISA
  @ElementType:
    dis:ISA
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForIF

ElementTypeBinding:
  @Name: ClsISA
  @ElementType:
    dis:ISA
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: Method
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Method

ElementTypeBinding:
  @Name: Return
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|MethodReturn

ElementTypeBinding:
  @Name: Param
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|MethodParameter

ElementTypeBinding:
  @Name: Attr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Attribute

ElementTypeBinding:
  @Name: Get
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|AttributeGet

ElementTypeBinding:
  @Name: Set
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|AttributeSet

## -- Implementation

IFClsDef:
  @IFQName: DISImplementationDNLite
  @ClsQName: ManakaiDISImplementationDNLite

  @domperl:implementedByObjectsOf:
    c|DOMImplementation
  @domperl:classImplementedByObjectsOf:
    c|ManakaiDOMImplementation

  @enDesc:
    The object implementing the <IF::DISImplementationDNLite>
    interface <kwd:MUST> also implement the <IF::DIS|DISImplementation>
    interface.

  @Method:
    @@Name: convertDISDocumentToDNLDocument
    @@Param:
      @@@Name: originalDocument
      @@@Type: DDoc
      @@@enDesc:
        The original node.
    @@NamedParam:
      @@@Name: databaseArg
      @@@Type: DIS|DISDatabase
      @@@nullCase:
    @@NamedParam:
      @@@Name: baseNamespaceBinding
      @@@Type: DISPerl|HASH
      @@@enDesc:
        A base set of namespace bindings.
      @@@nullCase:
        @@@@enDesc:
          Empty.
    @@Return:
      @@@Type: DNLDocument
      @@@caType: ManakaiDNLDocument
      @@@enDesc:
        The newly created node.
      @@@PerlDef:
        my $cn;
        $cn = sub ($$$;$) {
          my ($self, $db, $source_node => $result_parent) = @_;
          __DEEP{
            my $xu = $source_node-><AG::SEl.expandedURI>;
            if ($xu eq <Q::dis:ForCheck>) {
              for my $q (grep {length $_}
                         split /\s+/, $source_node-><M::SNode.value>) {
                my $p = '<=';
                $p = $1 if $q =~ s/^(!(?:=|<=)?|=|<=)//;
                $p = '!<=' if $p eq '!';
                my $uri = $source_node-><M::DIS|NSResolverDIS.qnameToURI> ($q);
                ##       super(A)   A   sub(A)  B
                ## <A                     v
                ## <=A              v     v
                ## !<=A     v                   v
                ## =A               v
                ## !=A      v             v     v
                ## XA     
                $result_parent->{forp}->{$uri} = {
                  '' => {$p => $p},
                  '<=' => {$p => $p, '!<=' => 'X', '!=' => '<'},
                  '!<=' => {'<=' => 'X', '!<=' => '!<=', '<' => 'X',
                            '=' => 'X', '!=' => '!<='},
                  '=' => {$p => 'X', '<=' => '=', '=' => '='},
                  '!=' => {$p => $p, '<=' => '<', '=' => 'X'},
                  'X' => {$p => 'X'},
                }->{$result_parent->{forp}->{$uri} or ''}->{$p};
                $db-><M::DIS|DISDatabase.getFor> ($uri)
                   -><AS::DIS|DISAnyResource.isReferred> ($source_node);
              }
            } elsif ($xu eq <Q::dis:ContentType>) {
              $result_parent->{mt} = $source_node-><AG::DEl.qnameValueURI>;
              $db-><M::DIS|DISDatabase.getResource> ($result_parent->{mt})
                 -><AS::DIS|DISAnyResource.isReferred> ($source_node);
            } else {
              my $np;
              my $a = bless {
                ns => $result_parent->{ns},
                defaultNS => $result_parent->{defaultNS},
                parentNodePath => [@{$result_parent->{parentNodePath}},
                                     $result_parent->{nodePath}],
                nodePath => \$np,
              }, <ClassName::ManakaiDNLElement>;
              push @{$result_parent->{child}||=[]}, $a;
              __CODE{DISPerl|HashStringRef::
                $result => {$a->{uri}},
                $given => {$xu},
              }__;
              for ($source_node-><AG::SNode.valueRef>) {
                $a->{value} = $_ if defined $_;
              }
              $a->{nodeID} = $source_node-><AG::SNode.nodeIDRef>
                if ${$a->{uri}} eq <Q::dis:ResourceDef>;
              my $source_childs = $source_node-><AG::SNode.childNodes>;
              for (my $i = 0;
                   $i < $source_childs-><AG::swcfg21:SWCFGChildNodeList
                                           .length>; $i++) {
                my $source_child = $source_childs
                                     -><M::swcfg21:SWCFGChildNodeList
                                         .item> ($i);
                $cn->($self, $db, $source_child => $a);
              }
              $np = $source_node-><AG::SEl.realQualifiedName>;
              CEL: for my $cel (@{$a->{child}||[]}) {
                ET: for my $et (
                  [<Q::dis:QName> => 'QName'],
                  [<Q::dis:Name> => 'Name'],
                  [<Q::dis:Type> => 'Type'],
                  [<Q::rdf:type> => 'type'],
                ) {
                  if (${$cel->{uri}} eq $et->[0]) {
                    $np .= '[@'.$et->[1].'='.
                           (defined $cel->{value} ? ${$cel->{value}} : '').']';
                    next CEL;
                  }
                } # ET
              } # CEL
            }
            return;
          }__;
        };
        __DEEP{
          $r = bless {
            ns => {%{$baseNamespaceBinding or {}},
                   %{$originalDocument->{<H::mn:node>}
                                   ->{<H::swcfg21:nsBinding>}}},
            defaultNS => \($originalDocument-><AG::DDoc.moduleElement>
                              -><AG::DIS|DISModuleElement.definingNamespaceURI>),
            fileName => $originalDocument->{<H::mn:node>}
                                         ->{<H::swcfg21:flag>}
                                         ->{<Q::swcfg21:fileName>},
            parentNodePath => [\''],
          }, <ClassName::ManakaiDNLDocument>;
          $r->{nodePath} = \ ('document ('.$r->{fileName}.')');
          if ($originalDocument->{<H::mn:node>}->{<H::DIS|db>}) {
            $r-><AS::DNLDocument.disDatabase>
                   ($originalDocument->{<H::mn:node>}->{<H::DIS|db>});
          }
          for my $source_child (@{$originalDocument-><AG::SNode.childNodes>}) {
            $cn->($self, $databaseArg, $source_child => $r)
              if $source_child-><AG::SNode.nodeType> eq '#element';
          }
        }__;
##DISImplementationDNLite

ResourceDef:
  @QName: SNode
  @AliasFor: swcfg21|SWCFGNode

ResourceDef:
  @QName: SEl
  @AliasFor: swcfg21|SWCFGElement

ResourceDef:
  @QName: DNode
  @AliasFor: DIS|DISNode

ResourceDef:
  @QName: DDoc
  @AliasFor: DIS|DISDocument

ResourceDef:
  @QName: DEl
  @AliasFor: DIS|DISElement

ElementTypeBinding:
  @Name: caType
  @ElementType:
    dis:actualType
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass

## -- Any Value

IFClsDef:
  @IFQName: DNLNode
  @ClsQName: ManakaiDNLNode

  @IFISA: DIS|NSResolverDIS
  @ClsISA: DIS|ManakaiNSResolverDIS

  @ClsISA:
    dx:ManakaiDefaultExceptionHandler

  @Attr:
    @@Name: childNodes
    @@Get:
      @@@Type: pl|ARRAY
      @@@enDesc:
        The list of child elements.

        {NOTE:: Applications <kwd:MUST-NOT> try to modify the list directly.
        }
      @@@PerlDef:
        $r = $self->{child} || [];

  @Method:
    @@Operator:
      @@@@: DISPerl|CloneMethod
      @@@ContentType: dis|TypeQName
    @@Return:
      @@@Type: DNLNode
      @@@PerlDef:
        $r = bless {%$self}, ref $self;
        __DEEP{
          if ($self->{child}) {
            $r->{child} = [];
            for my $child (@{$self->{child}}) {
              push @{$r->{child}}, $child->clone;
            }
          }
        }__;

  @Method:
    @@Name: lookupNamespaceURI
    @@Param:
      @@@Name: prefix
      @@@Type: DISString
      @@@nullCase:
        @@@@enDesc:
          The default namespace.
    @@Return:
      @@@Type: DISString
      @@@nullCase:
        @@@@enDesc: No namespace.
      @@@PerlDef:
        if (defined $prefix) {
          $r = $self->{ns}->{$prefix};
          if (not defined $r and $self->{ns}->{'###db'}) {
            my $db = $self->{ns}->{'###db'};
            FIND: for my $mod_uri (keys %{$db->{modDef}}) {
              my $mod = $db-><M::DIS|DISDatabase.getModule> ($mod_uri);
              if ($mod-><AG::DIS|DISAnyResource.localName> eq $prefix) {
                $r = $mod-><AG::DIS|DISModule.targetNamespaceURI>;
                last FIND;
              }
            }
          }
        } else {
          $r = ${$self->{defaultNS}};
        }

  @Attr:
    @@Name: nodeID
    @@Get:
      @@@Type: DISString
      @@@nullCase:
        @@@@enDesc: No node identifier.
      @@@PerlDef:
        $r = defined $self->{nodeID} ? ${$self->{nodeID}} : null;

  @Attr:
    @@Name: nodeIDRef
    @@Get:
      @@@Type: DISPerl|SCALAR
      @@@nullCase:
        @@@@enDesc: No node identifier.
      @@@PerlDef: $r = $self->{nodeID};

  @Method:
    @@Name: nodePath
    @@Param:
      @@@Name: key
      @@@DISPerl:isNamedParameter:1
      @@@Type: DOMMain|any
      @@@enDesc: Ignored.
    @@Return:
      @@@Type: DISString
      @@@PerlDef:
        $r = join '/', map {$$_} (@{$self->{parentNodePath}}, $self->{nodePath});

  @Attr:
    @@Name: nodeType
    @@Type: DISString
    @@Get:
      @@@PerlDef: $r = '#element';

  @Attr:
    @@Name: ownerDocument
    @@Type: DNLDocument
    @@Get: 
      @@@nullCase:
        @@@@enDesc:
          Always <DOM::null>.
      @@@PerlDef:

  @Method:
    @@Name: disChildElements
    @@enDesc:
      A list of child elements, with <QUOTE::for> checks.
    @@ForpParam:
    @@NamedParam:
      @@@Name: databaseArg
      @@@Type: DIS|DISDatabase
    @@Return:
      @@@Type: pl|ARRAY
      @@@enDesc:
        The current snapshot of child nodes.
      @@@PerlDef:
        $r = [];
        __DEEP{
          for my $cn (@{$self->{child}||[]}) {
            if ($cn-><M::DNLElement.forMatch> (undef, $forpArg,
                                               database_arg => $databaseArg)) {
              push @$r, $cn;
            }
          }
        }__;

  @Method:
    @@Name: disAllChildElements
    @@Return:
      @@@Type: pl|ARRAY
      @@@PerlDef:
        $r = [@{$self->{child}||[]}];

  @Method:
    @@Name: getAttributeNS
    @@Param:
      @@@Name: namespaceURI
      @@@Type: DISString
    @@Param:
      @@@Name: localName
      @@@Type: DISString
    @@Return:
      @@@Type: DNLElement
      @@@nullCase:
        @@@@enDesc: No such attribute.
      @@@PerlDef:
        my $nm = $namespaceURI . $localName;
        C: for my $cn (@{$self->{child}||[]}) {
          if (${$cn->{uri}} eq $nm) {
            $r = $cn;
            last C;
          }
        }

  @Method:
    @@Name: flag
    @@enDesc:
      Returns a flag value.
    @@Param:
      @@@Name: name
      @@@Type: DISString
      @@@enDesc:
        Either <Q::swcfg21:fileName> or <CODE::nodePath>.
    @@Return:
      @@@Type: DISString
      @@@PerlDef:
        if ($name eq 'nodePath') {
          __DEEP{
            $r = $self-><M::DNLNode.nodePath>;
          }__;
        } else {
          $r = $self->{fileName};
        }

  @Method:
    @@Name: value
    @@Type: DISString
    @@Return:
      @@@nullCase:
        @@@@enDesc: No value.
      @@@PerlDef:
        $r = defined $self->{value} ? ${$self->{value}} : null;

  @Method:
    @@Name: valueRef
    @@Type: DISPerl|SCALAR
    @@Return:
      @@@nullCase:
        @@@@enDesc: No value.
      @@@PerlDef: $r = $self->{value};

  @Attr:
    @@Name: ownerDISDocument
    @@Type: DNLDocument
    @@nullCase:
      @@@enDesc:
        Always <DOM::null>.
    @@Get:
      @@@PerlDef:

  @Method:
    @@Name: prefixToURI
    @@Param:
      @@@Name: prefix
      @@@Type: DISString
      @@@nullCase:
        @@@@enDesc:
          The default namespace.
    @@NodeParam:
    @@Return:
      @@@Type: DISString
      @@@Description:
        @@@@lang:en
        @@@@@: The URI references associated. 
      @@@UndeclaredPrefixException:
      @@@PerlDef:
        __DEEP{
          $r = $self-><M::DNLNode.lookupNamespaceURI> ($prefix);
        }__;
        unless (defined $r) {
          __EXCEPTION{DIS|UNDECLARED_NS_PREFIX_ERR::
            infoset:prefix => {$prefix},
            DIS:sourceNode => {$node},
            MDOMX:param-name => 'prefix',
          }__;
        }

  @Attr:
    @@Name: qnameValueURI
    @@Type: DISString
    @@Get:
      @@@UndeclaredPrefixException:
      @@@nullCase:
        @@@@enDesc: No value.
      @@@PerlDef:
        __DEEP{
          if (defined $self->{value}) {
            $r = $self-><M::DIS|NSResolverDIS.qnameToURI> (${$self->{value}});
          } else {
            $r = null;
          }
        }__;

  @Attr:
    @@Name: qnameValueLocalName
    @@Type: DISString
    @@Get:
      @@@PerlDef:
        __DEEP{
          my $v = $self-><M::SNode.value>;
          if (defined $v and not ref $v eq 'ARRAY') {
            my ($n, $v) = split /\s*[:|]\s*/, $v, 2;
            $r = defined $v ? $v : $n;
          } else {
            $r = null;
          }
        }__;

  @Attr:
    @@Name: qnameValuePrefix
    @@enDesc:
      The prefix part of the element value (assumed as 
      written as <Q::dis:TypeQName>). 
      \
      {NOTE:: What should be if list value?
      \
      }
    @@Get:
      @@@Type:
        DISCore:NamespacePrefix
      @@@nullCase:
        @@@@enDesc:
          No value. 
      @@@PerlDef:
        __DEEP{
          my $v = $self-><M::SNode.value>;
          if (defined $v and not ref $v eq 'ARRAY') {
            my ($p, $l) = split /\s*[:|]\s*/, $v, 2;
            $r = defined $l ? $p : null;
          } else {
            $r = null;
          }
        }__;

  @Attr:
    @@Name: qnameValueNamespaceURI
    @@enDesc:
      The namespace URI of the element value (assumed as written 
      in <Q::dis:TypeQName>). 
      \
      {NOTE:: What should be if list value?
      \
      }
    @@Get:
      @@@Type: DIS|AnyURI
      @@@nullCase:
        @@@@enDesc:
          No value. 
      @@@UndeclaredPrefixException:
      @@@PerlDef:
        __DEEP{
          my $v = $self-><M::SNode.value>;
          if (defined $v and not ref $v eq 'ARRAY') {
            my ($p, $v) = split /\s*[:|]\s*/, $v, 2;
            $r = $self-><M::DIS|NSResolverDIS.prefixToURI>
                                            (defined $v ? $p : null);
          } else {
            $r = null;
          }
        }__;

  @Method:
    @@Name: tfqnamesValueURI
    @@enDesc:
      The element value (written as <Q::dis:TFQNames>),
      as URI reference. 
      \
      {NOTE:: What should be if list value?
      \
      }
    @@Param:
      @@@Name: defaultTypeURI
      @@@Type: DIS|NameURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          A name URI reference used if it is missing from 
          <P::tfqnames>. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            Equivalent to <Q::DOMMain:any>. 
    @@Return:
      @@@Type: DIS|ResourceURI
      @@@nullCase:
        @@@@enDesc:
          No value. 
      @@@UndeclaredPrefixException:
      @@@PerlDef:
        my $v = $self-><M::SNode.value>;
        if (defined $v and not ref $v eq 'ARRAY') {
          __DEEP{
            $r = $self-><M::DIS|NSResolverDIS.tfpqnamesToURI>
                                  ($v, $defaultTypeURI,
                                   node => $self);
          }__;
        } else {
          $r = null;
        }

  @Method:
    @@Name: elementTypeMatch
    @@enDesc:
      Returns whether the element type of this element matches 
      with another element type (either the same element type or
      this type is a subtype of another type). 
    @@Param:
      @@@Name: etype
      @@@Type: DIS|ResourceURI
      @@@enDesc:
        An element type name URI reference to test. 
    @@NamedParam:
      @@@Name: databaseArg
      @@@Type: DIS|DISDatabase
    @@NamedParam:
      @@@Name: srinfo
      @@@Type: DISPerl|HASH
      @@@enDesc:
        The <CODE::srinfo> hash.
      @@@nullCase:
        @@@@enDesc:
          No <CODE::srinfo>.
    @@Return:
      @@@Type:
        DOMMain:boolean
      @@@TrueCase:
        @@@@enDesc:
          Either the element type expanded URI reference of this element is 
          same as <P::etype> or it is a sub-element type of <P::etype>. 
      @@@FalseCase:
        @@@@enDesc:
          This element is not of <P::etype>. 
      @@@NoDBException:
      @@@PerlDef:
        __DEEP{
          my $et = $self-><AG::SEl.expandedURI>;
          my $rdef = $databaseArg-><M::DIS|DISDatabase.getResource> ($et);
          $r = $rdef-><M::DIS|DISResource.isSubsetOfURI>
                        ($etype, srinfo => $srinfo);
        }__;

  @Attr:
    @@Name: isResourceElement
    @@enDesc:
      Whether this element defines a resource or not. 
      \
      {NOTE:: An element defines a resource if its element type is 
              <Q::dis:ResourceDef> or its subtype.
      \
      }
    @@Get:
      @@@Type:
        DOMMain:boolean
      @@@TrueCase:
        @@@@enDesc:
          This element defines a resource. 
      @@@FalseCase:
        @@@@enDesc:
          This element does not define any resource.
      @@@NoDBException:
      @@@PerlDef:
        __DEEP{
          $r = (${$self->{uri}} eq <Q::dis:ResourceDef>);
        }__;

  @Method:
    @@Name: isPropertyElement
    @@enDesc:
      Whether this element is a property or not. 
      \
      {NOTE:: An element is a property if the resource whose
              URI is equal to the element type name is a property,
              i.e. whose type is <Q::DISSource|Property>.
      }
    @@NamedParam:
      @@@Name: databaseArg
      @@@Type: DIS|DISDatabase
    @@Return:
      @@@Type:
        DOMMain:boolean
      @@@TrueCase:
        @@@@enDesc:
          This element is a property.
      @@@FalseCase:
        @@@@enDesc:
          This element is not a property. 
      @@@NoDBException:
      @@@PerlDef:
        __DEEP{
          my $xn = $self-><AG::SEl.expandedURI>;
          if ($xn eq <Q::DISCore|resourceType> or $xn eq <Q::rdf:type>) {
            $r = true;
          } else {
            my $rdef = $databaseArg-><M::DIS|DISDatabase.getResource> ($xn);
            $r = $rdef-><M::DIS|DISAnyResource.isTypeURI>
                          (<Q::DISSource|Property>) ||
                 $rdef-><M::DIS|DISAnyResource.isTypeURI> (<Q::rdf:Property>);
                       ## TODO: Remove this.
          }
        }__;

  @Method:
    @@Name: unlinkFromDocument
    @@enDesc:
      Removes any relationship to this node from the owner document tree.
      In addition, namespace bindings are copied from the document.
      The node <kwd:MUST> be a cloned one (or just newly created one)
      so that it does not have any parent-child relationship.
    
      {NOTE:: Once a subtree has removed from the document, the nodes
              belongs to the subtree can't be part of any document anymore.
      }
    @@Param:
      @@@Name: databaseArg
      @@@Type: DIS|DISDatabase
      @@@enDesc:
        The <QUOTE::dis> database.
    @@Return:
      @@@PerlDef:
        __DEEP{
          if ($self->{ns}->{'###db'}) {
            $databaseArg ||= $self->{ns}->{'###db'};
            CORE::delete $self->{ns}->{'###db'};
            if ($databaseArg) {
              for my $mod_uri (keys %{$databaseArg->{modDef}}) {
                my $mod = $databaseArg-><M::DIS|DISDatabase.getModule>
                                                ($mod_uri);
                my $prefix = $mod-><AG::DIS|DISAnyResource.localName>;
                $self->{ns}->{$prefix}
                  = $mod-><AG::DIS|DISModule.targetNamespaceURI>
                  unless defined $self->{ns}->{$prefix};
              }
            }
          }
        }__;

  @Method:
    @@Name: preserveNodePath
    @@Return:
      @@@PerlDef:

  @Method:
    @@Name: free
    @@Return:
      @@@PerlDef:

  @Method:
    @@Name: addNamespaceBinding
    @@Param:
      @@@Name: prefix
      @@@Type: DISString
    @@Param:
      @@@Name: namespaceURI
      @@@Type: DISString
      @@@nullCase:
    @@Return:
      @@@PerlDef:
        if (defined $namespaceURI) {
          $self->{ns}->{$prefix} = $namespaceURI;
        } else {
          CORE::delete $self->{ns}->{$prefix};
        }

  @Method:
    @@Name: getDefaultNamespaceURIRef
    @@enDesc: A reference to the URI of the default namespace.
    @@Type: DISPerl|SCALAR
    @@nullCase:
      @@@enDesc: No namespace.
    @@Return:
      @@@PerlDef:
        $r = $self->{defaultNS};

  @Method:
    @@Name: getNamespaceBindingList
    @@enDesc:
      Returns the <QUOTE::live> hash reference of namespace bindings.      
    @@Type: DISPerl|HASH
    @@Param:
      @@@Name: databaseArg
      @@@Type: DIS|DISDatabase
      @@@enDesc:
        The <QUOTE::dis> database.
    @@Return:
      @@@PerlDef:
        __DEEP{
          if ($self->{ns}->{'###db'}) {
            $databaseArg ||= $self->{ns}->{'###db'};
            CORE::delete $self->{ns}->{'###db'};
            if ($databaseArg) {
              for my $mod_uri (keys %{$databaseArg->{modDef}}) {
                my $mod = $databaseArg-><M::DIS|DISDatabase.getModule>
                                                ($mod_uri);
                my $prefix = $mod-><AG::DIS|DISAnyResource.localName>;
                $self->{ns}->{$prefix}
                  = $mod-><AG::DIS|DISModule.targetNamespaceURI>
                  unless defined $self->{ns}->{$prefix};
              }
            }
          }
        }__;
        $r = $self->{ns};
##DNLNode

ElementTypeBinding:
  @Name: IntMethod
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:Method
    @@ManakaiDOM:isForInternal:1
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: UndeclaredPrefixException
  @ElementType:
    ManakaiDOM:raises
  @ShadowContent:
    @@@: DIS|UNDECLARED_NS_PREFIX_ERR
    @@Description:
      @@@lang:en
      @@@@:
        The implementation has encounted an undeclared namespace prefix. 

IFClsDef:
  @IFQName: DNLDocument
  @ClsQName: ManakaiDNLDocument

  @IFISA: DNLNode
  @ClsISA: ManakaiDNLNode

  @Attr:
    @@Name: nodeType
    @@Type: DISString
    @@Get:
      @@@PerlDef: $r = '#document';

  @Attr:
    @@Name: moduleElement
    @@Get:
      @@@Type: DNLElement
      @@@PerlDef:
        M: for my $n (@{$self->{child}||[]}) {
          if (${$n->{uri}} eq <Q::dis:Module>) {
            $r = $n;
            last M;
          }
        }

  @Attr:
    @@Name: disDatabase
    @@Type: DIS|DISDatabase
    @@Get:
      @@@ManakaiDOM:raises:
        @@@@@: DIS|NO_ASSOCIATED_DB_ERR
      @@@PerlDef:
        $r = $self->{db} or do {
          __EXCEPTION{DIS|NO_ASSOCIATED_DB_ERR}__;
        };
    @@Set:
      @@@PerlDef:
        if (defined $given) {
          $self->{db} = $given;
          $self->{ns}->{'###db'} = $given;
          require Scalar::Util;
          Scalar::Util::weaken ($self->{db});
          Scalar::Util::weaken ($self->{ns}->{'###db'});
        } else {
          CORE::delete $self->{db};
          CORE::delete $self->{ns}->{'###db'};
        }
##DNLDocument

IFClsDef:
  @IFQName: DNLElement
  @ClsQName: ManakaiDNLElement

  @IFISA: DNLNode
  @ClsISA: ManakaiDNLNode

  @ClsISA: dp|ManakaiDISElementPerl

  @Method:
    @@Name: preserveNodePath
    @@Return:
      @@@PerlDef:

  @Attr:
    @@Name: requireElement
    @@Get:
      @@@Type: DNLElement
      @@@PerlDef:
        M: for my $n (@{$self->{child}||[]}) {
          if (${$n->{uri}} eq <Q::dis:Require>) {
            $r = $n;
            last M;
          }
        }

  @Attr:
    @@Name: definingNamespaceURI
    @@Get:
      @@@Type: DISString
      @@@PerlDef:
        M: for my $n (@{$self->{child}||[]}) {
          if (${$n->{uri}} eq <Q::dis:Namespace>) {
            $r = ${$n->{value}} if defined $n->{value};
            last M;
          }
        }

  @Method:
    @@Name: forMatch
    @@Description:
      @@@lang:en
      @@@@:
        Tests whether this element is for a <QUOTE::for> or not. 
    @@Param:
      @@@Name: forArg
      @@@Type: DIS|ForURI
      @@@enDesc:
        This parameter <kwd:MUST> be ignored.
    @@Param:
      @@@Name: forpArg
      @@@Type: DIS|ForURIList
      @@@Description:
        @@@@lang:en
        @@@@@:
          The <QUOTE::For+> URI references to test against. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            No additional <QUOTE::For> URI reference. 
            Equivalent to an empty array reference. 
    @@NamedParam:
      @@@Name: databaseArg
      @@@Type: DIS|DISDatabase
      @@@enDesc:
        A <QUOTE::dis> database.
      @@@nullCase:
        @@@@enDesc:
          The database associated to the document is used.
    @@Return:
      @@@Type:
        DOMMain:boolean
      @@@Description:
        @@@@lang:en
        @@@@@:
          Whether this element is for <P::forpArg> or not. 
      @@@UndeclaredPrefixException:
      @@@NoDBException:
      @@@PerlDef:
        $forpArg ||= [];

        FORMATCH: {
          __DEEP{
            my $for_res = $databaseArg->get_for (<Q::ManakaiDOM|all>);
            my $forp_res = [map {
                                  $databaseArg-><M::DIS|DISDatabase.getFor> ($_)
                                } @{$forpArg}];

            FCs: for my $uri (keys %{$self->{forp}||{}}) {
              my $p = $self->{forp}->{$uri};
              if ($p eq '<=') {
                for my $arg_res ($for_res, @{$forp_res}) {
                  if ($arg_res-><M::DIS|DISFor.isaURI> ($uri)) {
                    next FCs;
                  }
                }
                last FORMATCH;
              } elsif ($p eq '<') {
                my $for = $databaseArg-><M::DIS|DISDatabase.getFor> ($uri);
                for my $arg_res ($for_res, @{$forp_res}) {
                  if (not ($arg_res eq $for) and
                      $arg_res-><M::DIS|DISFor.isaURI> ($uri)) {
                    next FCs;
                  }
                }
                last FORMATCH;
              } elsif ($p eq '!<=') {
                for my $arg_res ($for_res, @{$forp_res}) {
                  if ($arg_res-><M::DIS|DISFor.isaURI> ($uri)) {
                    last FORMATCH;
                  }
                }
              } elsif ($p eq '=') {
                my $for = $databaseArg-><M::DIS|DISDatabase.getFor> ($uri);
                for my $arg_res ($for_res, @{$forp_res}) {
                  if ($arg_res eq $for) {
                    next FCs;
                  }
                }
                last FORMATCH;
              } elsif ($p eq '!=') {
                my $for = $databaseArg-><M::DIS|DISDatabase.getFor> ($uri);
                for my $arg_res ($for_res, @{$forp_res}) {
                  if ($arg_res eq $for) {
                    last FORMATCH;
                  }
                }
              }
            } # FCs

            $r = 1;
          }__;
        } # FORMATCH

    @@Test:
      @@@QName: DNLiteElement.forMatch.test
      @@@PerlDef:
        my $impl = <Class::c|ManakaiDOMImplementation>->_new;
        my $db = $impl-><M::DIS|DISImplementation.createDISDatabase>;

        my $node = bless {}, <ClassName::ManakaiDNLElement>;

        $node->{forp} = {qw/a <=/};

        $test->assert_true ($node-><M::DNLElement.forMatch>
                              ('a', [], database_arg => $db),
                            uri => <Q::DNLElement.ForMatch.Test.Match>);

        $test->assert_false ($node-><M::DNLElement.forMatch>
                               (<Q::ManakaiDOM:all>, [], database_arg => $db),
                             uri => <Q::DNLElement.ForMatch.Test.AllNoMatch>);

        $test->assert_false ($node-><M::DNLElement.forMatch>
                               ('b', [], database_arg => $db),
                             uri => <Q::DNLElement.ForMatch.Test.NoMatch>);

        $node->{forp} = {};

        $test->assert_true ($node-><M::DNLElement.forMatch>
                              (<Q::ManakaiDOM:all>, [], database_arg => $db),
                           uri => <Q::DNLElement.ForMatch.Test.ImpliedAllMatch>);

        $test->assert_true
                ($node-><M::DNLElement.forMatch>
                              ('a', [], database_arg => $db),
                 uri => <Q::DNLElement.ForMatch.Test.ImpliedAllSuperMatch>);

        $node->{forp} = {a => '<=', b => '!<='};

        $test->assert_true
                ($node-><M::DNLElement.forMatch>
                              ('a', [], database_arg => $db),
                 uri => <Q::DNLElement.ForMatch.Test.Match.A.!B>);

        $test->assert_false
                ($node-><M::DNLElement.forMatch>
                              ('b', [], database_arg => $db),
                 uri => <Q::DNLElement.ForMatch.Test.Match.A.No!B>);

        $test->assert_false ($node-><M::DNLElement.forMatch>
                              (<Q::ManakaiDOM:all>, [], database_arg => $db),
                           uri => <Q::DNLElement.ForMatch.Test.NoMatch.NoA.!B>);

  @Method:
    @@Name: mediaTypeMatch
    @@Description:
      @@@lang:en
      @@@@:
        Tests whether the content media type of this element matches to 
        a type or not. 
    @@Param:
      @@@Name: mediaType
      @@@Type: DIS|MediaTypeURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          A media type URI reference to test against. 
    @@Param:
      @@@Name: defaultMediaType
      @@@Type: DIS|MediaTypeURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          The default media type for this element. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            No default type provided.  All <P::mediaType> will match. 
    @@NamedParam:
      @@@Name: databaseArg
      @@@Type: DIS|DISDatabase
      @@@enDesc:
        A <QUOTE::dis> database.
    @@Return:
      @@@Type:
        DOMMain:boolean
      @@@Description:
        @@@@lang:en
        @@@@@:
          Whether this element is of <P::mediaType> or not. 
      @@@PerlDef:
        if (defined $mediaType) {
          __DEEP{
            my $res = $databaseArg-><M::DIS|DISDatabase.getResource>
                         (defined $self->{mt} ? $self->{mt} : $defaultMediaType);
            $r = $res-><M::DIS|DISResource.isSubsetOfURI> ($mediaType);
          }__;
        } else {
          $r = true;
        }

  @Method:
    @@Name:mediaTypeURI
    @@enDesc:
      The URI reference of the media type of this element. 
    @@Type: DIS|MediaTypeURI
    @@NamedParam:
      @@@Name:defaultMediaType
      @@@Type: DIS|MediaTypeURI
      @@@enDesc:
        The default media type URI reference. 
      @@@nullCase:
        @@@@enDesc:
          No default is specified. 
    @@Return:
      @@@enDesc:
        The media type URI reference of this element. 
      @@@nullCase:
        @@@@enDesc:
          This element has no media type information and 
          <P::defaultMediaType> parameter is not provided. 
      @@@UndeclaredPrefixException:
      @@@PerlDef:
        $r = $self->{mt};
        $r = $defaultMediaType unless defined $r;

  @Attr:
    @@Name: expandedURI
    @@Get:
      @@@Type: DISString
      @@@PerlDef:
        $r = ${$self->{uri}};

  @Method:
    @@Name: disGetAttribute
    @@enDesc:
      Gets an attribute node. 
    @@Param:
      @@@Name: attrName
      @@@Type: DIS|AnyURI
      @@@enDesc:
        The name expanded URI of the node to retrieve. 
    @@ForpParam:
    @@MediaTypeParam:
    @@MediaTypeDefaultParam:
    @@NamedParam:
      @@@Name: databaseArg
      @@@Type: DIS|DISDatabase
      @@@enDesc:
        A <QUOTE::dis> database.
    @@Return:
      @@@Type: DNLElement
      @@@enDesc:
        The attribute (property) element node. 
      @@@nullCase:
        @@@@enDesc:
          No attribute node found. 
      @@@PerlDef:
        C: for my $c (@{$self-><M::DNLNode.disChildElements>
                                  (forp_arg => $forpArg,
                                   database_arg => $databaseArg)}) {
          if (${$c->{uri}} eq $attrName and
              $c-><M::DNLElement.mediaTypeMatch>
                                  ($mediaType, $defaultMediaType,
                                   database_arg => $databaseArg)) {
            $r = $c;
            last C;
          }
        }
##DNLElement

ElementTypeBinding:
  @Name: Test
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: test|StandaloneTest
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: NamedParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:MethodParameter
    @@DISPerl:isNamedParameter:1

ElementTypeBinding:
  @Name: NodeParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:MethodParameter
    @@DISPerl:isNamedParameter:1
    @@Name: node
    @@Type: DIS|DISNode
    @@actualType:
      @@@@: DIS|ManakaiDISNode
      @@@ForCheck: ManakaiDOM|ForClass
    @@Description:
      @@@lang:en
      @@@@:
        The node in which the name has occurred.  It is intended 
        to be reported when an exception had been raised. 
    @@ResourceDef:
      @@@rdf:type:
        ManakaiDOM:InCase
      @@@Value:
        @@@@is-null:1
      @@@Description:
        @@@@lang:en
        @@@@@:
          The source of the name is not a node. 

ElementTypeBinding:
  @Name: ForpParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:MethodParameter
    @@DISPerl:isNamedParameter:1
    @@Name: forpArg
    @@Type: DIS|ForURIList
    @@Description:
      @@@lang:en
      @@@@:
        An array reference containing additional <QUOTE::for> 
        constraints (<QUOTE::For+> list).
    @@ResourceDef:
      @@@rdf:type:
        ManakaiDOM:InCase
      @@@Value:
        @@@@is-null:1
      @@@Description:
        @@@@lang:en
        @@@@@:
          Equivalent to the empty array reference. 

ElementTypeBinding:
  @Name: MediaTypeParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:MethodParameter
    @@DISPerl:isNamedParameter:1
    @@Name: mediaType
    @@Type: DIS|MediaTypeURI
    @@Description:
      @@@lang:en
      @@@@:
        The URI reference identifying a media type. 
    @@ResourceDef:
      @@@rdf:type:
        ManakaiDOM:InCase
      @@@Value:
        @@@@is-null:1
      @@@Description:
        @@@@lang:en
        @@@@@:
          No media type specified. 

ElementTypeBinding:
  @Name: MediaTypeDefaultParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:MethodParameter
    @@DISPerl:isNamedParameter:1
    @@Name: defaultMediaType
    @@Type: DIS|MediaTypeURI
    @@Description:
      @@@lang:en
      @@@@:
        The default media type, i.e. the type used when no explicit 
        specification is not found in the source tree. 
    @@ResourceDef:
      @@@rdf:type:
        ManakaiDOM:InCase
      @@@Value:
        @@@@is-null:1
      @@@Description:
        @@@@lang:en
        @@@@@:
          Defaulted to <Q::DOMMain:any>. 

ElementTypeBinding:
  @Name: RaiseException
  @ElementType:
    ManakaiDOM:raises

ElementTypeBinding:
  @Name: NoDBException
  @ElementType:
    ManakaiDOM:raises
  @ShadowContent:
    @@@: DIS|NO_ASSOCIATED_DB_ERR
    @@Description:
      @@@lang:en
      @@@@:
        No <QUOTE::dis> database is associated to this document. 

ResourceDef:
  @QName: DISString
  @AliasFor: DISLang|String

ElementTypeBinding:
  @Name: PerlDef
  @ElementType:
    dis:Def
  @ShadowContent:
    @@ContentType:
      lang:Perl
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: InCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:InCase

ElementTypeBinding:
  @Name: nullCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:InCase
    @@Value:
      @@@is-null:1

ElementTypeBinding:
  @Name: TrueCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:InCase
    @@Value:
      @@@@:1
      @@@ContentType: DISCore|Boolean
    @@Type:
      DOMMain:boolean

ElementTypeBinding:
  @Name: FalseCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:InCase
    @@Value:
      @@@@:0
      @@@ContentType: DISCore|Boolean
    @@Type:
      DOMMain:boolean
