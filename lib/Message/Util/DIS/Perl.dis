Module:
  @QName:
    DIS:Perl
  @FullName:
    @@lang: en
    @@@:
      <QUOTE::dis> Perl Module Support
  @Namespace:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS#Perl/
  
  @Description:
    @@lang:en
    @@@:
      This module provides interfaces for generating Perl modules
      from <QUOTE::dis> files.

  @Author:
    @@FullName: Wakaba
    @@Mail: w@suika.fam.cx
  @License:
    license:Perl+MPL
  @Date:
    @@@:
      $Date: 2005/09/19 16:17:52 $
    @@ContentType:
      dis:Date.RCS
  
  @Require:
    @@Module:
      @@@QName: Util|DIS
      @@@WithFor: DIS|ForLatest
    @@Module:
      @@@QName: DIS|Value
      @@@WithFor: DIS|ForLatest

  @DefaultFor: 
    DIS:ForLatest

Namespace:
  @dd:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS#DISDoc/
  @ddel:
    http://suika.fam.cx/~wakaba/archive/2005/disdoc#
  @DIS:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS#
  @dis:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#dis--
  @dis2pm:
    http://suika.fam.cx/~wakaba/archive/2004/11/8/dis2pm#
  @DISlib:
    http://suika.fam.cx/~wakaba/archive/2004/dis/
  @disPerl:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#dis--Perl--
  @DOMCore:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#
  @DOMException:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#
  @DOMLS:
    http://suika.fam.cx/~wakaba/archive/2004/dom/ls#
  @DOMMain:
    http://suika.fam.cx/~wakaba/archive/2004/dom/main#
  @DOMMetaImpl:
    http://suika.fam.cx/~wakaba/archive/2004/dom/meta#
  @dp:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS#Perl/
  @dv:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS#Value/
  @dump:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS#DISDump/
  @ecore:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/Core/
  @html3:
    urn:x-suika-fam-cx:markup:ietf:html:3:draft:00:
  @html5:
    http://www.w3.org/1999/xhtml
  @ilang:
    urn:x-suika-fam-cx:lang:
  @infoset:
    http://www.w3.org/2001/04/infoset#
  @kwd:
    http://suika.fam.cx/~wakaba/archive/2005/rfc2119/
  @lang:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#
  @license:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/license#
  @ManakaiDOM:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#
  @Markup:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Markup#
  @MDOM:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#ManakaiDOM.
  @MDOMX:
    http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#
  @nl:
    http://suika.fam.cx/~wakaba/archive/2004/dis/NaturalLanguage#
  @null:
    http://suika.fam.cx/~wakaba/-temp/2003/09/27/null
  @owl:
    http://www.w3.org/2002/07/owl#
  @pl:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#Perl--
  @rdf:
    http://www.w3.org/1999/02/22-rdf-syntax-ns#
  @rdfs:
    http://www.w3.org/2000/01/rdf-schema#
  @s:
    http://suika.fam.cx/~wakaba/archive/2004/dis/Markup#
  @script:
    http://suika.fam.cx/~wakaba/archive/2005/5/script#
  @sw010:
    urn:x-suika-fam-cx:markup:suikawiki:0:10:
  @swcfg21:
    http://suika.fam.cx/~wakaba/archive/2005/swcfg21#
  @TreeCore:\
  @Util:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/
  @xhtml1:
    http://www.w3.org/1999/xhtml
  @xhtml2:
    http://www.w3.org/2002/06/xhtml2/
  @xml:
    http://www.w3.org/XML/1998/namespace
  @xmlns:
    http://www.w3.org/2000/xmlns/
  @xsi:
    http://www.w3.org/2001/XMLSchema-instance

## -- Features

ElementTypeBinding:
  @Name: FeatureDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DOMMain:DOMFeature
    @@ForCheck:
      ManakaiDOM:all

ElementTypeBinding:
  @Name: FeatureVerDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DOMMain:DOMFeature

ElementTypeBinding:
  @Name: featureQName
  @ElementType:
    dis:AppName
  @ShadowContent:
    @@ContentType:
      dis:TypeQName

FeatureDef:
  @QName: DIS|Perl
  @FeatureVerDef:
    @@QName: DIS|Perl10
    @@Version: 1.0
    @@DOMMetaImpl:instanceFeatureOf: DIS|Perl
    @@DOMMain:requireFeature: DIS|CoreFeature10
    @@FullName:
      @@@lang:en
      @@@@:
        <QUOTE::dis> Perl Module version 1.0

ElementTypeBinding:
  @Name: enDesc
  @ElementType: 
    dis:Description
  @ShadowContent: 
    @@lang:en

ElementTypeBinding:
  @Name: IFClsDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      @@@@: dis|MultipleResource
      @@@ForCheck: !ManakaiDOM|ForIF !ManakaiDOM|ForClass
    @@resourceFor: ManakaiDOM|ForIF
    @@resourceFor: ManakaiDOM|ForClass

    @@rdf:type:
      @@@@: ManakaiDOM|IF
      @@@ForCheck: ManakaiDOM|ForIF

    @@rdf:type:
      @@@@: ManakaiDOM|Class
      @@@ForCheck: ManakaiDOM|ForClass
    @@Implement:
      @@@@: ||+||ManakaiDOM|ForIF
      @@@ForCheck: ManakaiDOM|ForClass
      @@@ContentType: DISCore|TFPQNames

    @@DOMMain:implementFeature: DIS|Perl10

ElementTypeBinding:
  @Name: IFDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      @@@@: dis|MultipleResource
      @@@ForCheck: !ManakaiDOM|ForIF !ManakaiDOM|ForClass
    @@resourceFor: ManakaiDOM|ForIF

    @@rdf:type:
      @@@@: ManakaiDOM|IF
      @@@ForCheck: ManakaiDOM|ForIF

    @@DOMMain:implementFeature: DIS|Perl10

ElementTypeBinding:
  @Name: IFQName
  @ElementType:
    dis:QName
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForIF

ElementTypeBinding:
  @Name: ClsQName
  @ElementType:
    dis:QName
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: IFISA
  @ElementType:
    dis:ISA
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForIF

ElementTypeBinding:
  @Name: ClsISA
  @ElementType:
    dis:ISA
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: Method
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Method

ElementTypeBinding:
  @Name: Return
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|MethodReturn

ElementTypeBinding:
  @Name: Param
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|MethodParameter


ElementTypeBinding:
  @Name: Attr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Attribute

ElementTypeBinding:
  @Name: Get
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|AttributeGet

ElementTypeBinding:
  @Name: Set
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|AttributeSet

## -- Implementation

IFClsDef: 
  @IFQName: DISImplementationPerl
  @ClsQName: ManakaiDISImplementationPerl

  @enDesc:
    The object implementing <IF::DISImplementationPerl> interface
    <kwd:MUST> also implement the <IF::DIS|DISImplementation> interface.

  @DOMMetaImpl:provideFeature: DIS|Perl10

  @Method:
    @@Name: plLoadDISDatabase
    @@enDesc:
      Loads a database from a file that was saved by 
      <M::DISDatabasePerl.plStore>. 
      \
      {NOTE:: <QUOTE::dis> documents restored from external file
              would have different <A::DIS|DISDocument.implementation> 
              than this <Class::DISImplementationPerl>, even if 
              it has been created by this implementation
              and stored in the same session. 
      \
      }

      Implementation does not have to able to restore a database
      saved by other implementation.
    @@Param:
      @@@Name:fileName
      @@@Type: 
        DISLang:String::ManakaiDOM:all
      @@@enDesc:
        An environment-dependent file name.  How the relative pathes
        is interpreted is implementation dependent.
      @@@enDesc:
        @@@@ForCheck: ManakaiDOM|ForClass
        @@@@@:
          In this implementation, relative pathes are resolved against
          the current directory of the context.
    @@Return:
      @@@Type: DIS|DISDatabase
      @@@clsActualType: DIS|ManakaiDISDatabase
      @@@SimpleException:
      @@@PerlDef:
        use Storable qw/retrieve/;
        local $Carp::CarpLevel = $Carp::CarpLevel + 1;
        $r = retrieve $fileName;

        ## Restores weak references
        require Scalar::Util;
        for my $doc (values %{$r->{<Q::DIS:sourceFile>}}) {
          Scalar::Util::weaken ($doc->{<Q::TreeCore:node>}->{<Q::DIS:db>});
        }
        for my $def (values %{$r->{modDef}},
                     values %{$r->{forDef}},
                     values %{$r->{resDef}}) {
          Scalar::Util::weaken ($def->{db});
        }
##DISImplementationPerl

## -- SWCFG nodes

IFClsDef:
  @IFQName: DISElementPerl
  @ClsQName: ManakaiDISElementPerl

  @enDesc:
    The <IF::DISElementPerl> interface provides method to retrieve
    information for Perl module from a <QUOTE::dis> element.

    The object implementing the <IF::DISElementPerl> interface
    <kwd:MUST> also implement the <IF::DIS|DISElement> interface.

  @Attr:
    @@Name: plImplementation
    @@enDesc:
      The implementation object, which the object belongs to and
      which implements the feature <Feature::Util|PerlCode>
      version <FeatureVer::1.0>.
    @@Type:
      PerlCode:PCImplementation::ManakaiDOM:Perl
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          There is no implementation that supports the feature
          <Feature::Util:PerlCode> version <FeatureVer::1.0>.
      @@@PerlDef:
        __DEEP{
          $r = ($self-><AG::DIS|SWCFGNode.ownerDocument> or
                        $self)-><AG::DIS|SWCFGDoc.implementation>
                           -><M::DIS|DOMMinImpl.getFeature>
                                   (<Q::Util:PerlCode> => '1.0');
        }__;

  @Method:
    @@Name: plValueCodeFragment
    @@enDesc:
      A Perl code fragment for value attribute.
    @@Param:
      @@@Name: attrURI
      @@@Type: DIS|AnyURI
      @@@enDesc:
        The URI reference name of an attribute.
      @@@nullCase:
        @@@@enDesc:
          This node itself is used.
    @@Param:
      @@@Name: disResource
      @@@Type: DIS|DISResource
      @@@enDesc:
        The <QUOTE::dis> resource object against which a value is evaluated.
    @@ForParam:
    @@ForpParam:
    @@NamedParam:
      @@@Name:dataTypeURI
      @@@Type:
        DIS|ResourceURI
      @@@enDesc:
        The URI reference of a data type.  It is used to convert
        untyped value and to define default value if <P::useDefaultValue>
        is set to <DOM::true>.
      @@@nullCase:
        @@@@enDesc: 
          No data type.  If the value is untyped, it is treated 
          as if <Q::DISCore:String>.
    @@NamedParam:
      @@@Name:useDefaultValue
      @@@Type:
        DOMMain:boolean::ManakaiDOM:all
      @@@enDesc:
        Whether some default value should be provided if possible or not.
    @@Type:
      DIS|MPLCodeFragment
    @@Return:
      @@@enDesc:
        Perl code fragment object for value attribute.
      @@@nullCase:
        @@@@enDesc:
          There is no <P::attrURI> attribute.
      @@@UndeclaredPrefixException:
      @@@RaiseException:
        @@@@@:DIS|NO_PERL_CODE_IMPL_ERR
        @@@@enDesc:
          There is no implementation that implements
          the <Feature::Util:PerlCode> feature, version <FeatureVer::1.0>.
      @@@PerlDef:
        __DEEP{
          my $dataType;
          my $vnode = defined $attrURI
                      ? $self-><M::DIS|DISElement.disGetAttribute>
                                           ($attrURI,
                                            for_arg => $forArg,
                                            forp_arg => $forpArg,
                                 database_arg => $disResource
                                     -><AG::DIS|DISAnyResource.database>)
                      : $self;
          my $plimpl = $self-><AG::DISElementPerl.plImplementation>;
          if ($vnode) {
            unless ($plimpl) {
              __UNDEEP{__EXCEPTION{DIS|NO_PERL_CODE_IMPL_ERR}__}__;
            }
            my $isnull = $vnode-><M::DIS|DISElement.disGetAttribute>
                                           (<Q::dis:is-null>,
                                            for_arg => $forArg,
                                            forp_arg => $forpArg,
                                  database_arg => $disResource
                                     -><AG::DIS|DISAnyResource.database>);
            if ($isnull and $isnull-><M::DIS|SWCFGNode.value>) {
              $r = $plimpl-><M::DIS|MPLImpl.createPerlAtom> ('undef');
            } else {
              my $vnode_type_uri = $vnode-><M::DIS|DISElement.mediaTypeURI>
                                           (for_arg => $forArg,
                                            forp_arg => $forpArg);
              my $vnode_value = $vnode-><M::DIS|SWCFGNode.value>;
              if ($vnode_type_uri) {
                my $vnode_type = $disResource->{db}
                                     -><M::DIS|DISDatabase.getResource>
                                                      ($vnode_type_uri);
                if ($vnode_type-><M::DIS|DISResource.isSubsetOfURI>
                                        (<Q::dis:Boolean>)) {
                  $r = $plimpl-><M::DIS|MPLImpl.createPerlAtom>
                                        ($vnode_value ? true : false);
                } elsif ($vnode_type-><M::DIS|DISResource
                                             .isSubsetOfURI>
                                        (<Q::dis:TypeQName>)) {
                  $r = $plimpl-><M::DIS|MPLImpl.createPerlStringLiteral>
                                    ($vnode-><M::DIS|NSResolverDIS
                                               .qnameToURI> ($vnode_value,
                                                             node => $vnode));
                } elsif ($vnode_type-><M::DIS|DISResource
                                .isSubsetOfURI> (<Q::lang:Perl>)) {
                  $r = $disResource-><M::DISResourcePerl
                             .plPreprocessPerlStatement>
                                           ($vnode_value,
                                            node => $vnode,
                                            contains_statements => false);
                } else { ## DISCore:String or some
                  $r = $plimpl-><M::DIS|MPLImpl.createPerlStringLiteral>
                                                       ($vnode_value);
                }
              } elsif ($dataTypeURI) {
                $dataType ||= $disResource-><AG::DIS|DISAnyResource.database>
                                          -><M::DIS|DISDatabase.getResource>
                                              ($dataTypeURI);
                if ($dataType-><M::DIS|DISResource.isSubsetOfURI>
                                              (<Q::DISIDL:AnyRealNumber>)) {
                  $r = $plimpl-><M::DIS|MPLImpl.createPerlAtom>
                                              (0 + $vnode_value);
                } elsif ($dataType-><M::DIS|DISResource
                                .isSubsetOfURI> (<Q::DOMMain:boolean>)) {
                  $r = $plimpl-><M::DIS|MPLImpl.createPerlAtom>
                                    ($vnode_value eq 'tr'.'ue' ? true : false);
                } else { ## DOMMain:DOMString or some
                  $r = $plimpl-><M::DIS|MPLImpl.createPerlStringLiteral>
                                                       ($vnode_value);
                }
              } else {  ## Untyped
                $r = $plimpl-><M::DIS|MPLImpl.createPerlStringLiteral>
                                                       ($vnode_value);
              }
            }
          } # has value

          if (not $r and $useDefaultValue) {
            $dataType ||= $disResource-><AG::DIS|DISAnyResource.database>
                                      -><M::DIS|DISDatabase.getResource>
                                              ($dataTypeURI);
            if ($dataType-><M::DIS|DISResource.isSubsetOfURI>
                                              (<Q::DISLang:String>)) {
              $r = $plimpl-><M::DIS|MPLImpl.createPerlStringLiteral> ('');
            } elsif ($dataType-><M::DIS|DISResource.isSubsetOfURI>
                                              (<Q::DOMMain:boolean>) or
                     $dataType-><M::DIS|DISResource.isSubsetOfURI>
                                              (<Q::DISIDL:AnyRealNumber>)) {
              $r = $plimpl-><M::DIS|MPLImpl.createPerlAtom> ('0');
            } elsif ($dataType-><M::DIS|DISResource.isSubsetOfURI>
                                              (<Q::pl:ARRAY>)) {
              $r = $plimpl-><M::DIS|MPLImpl.createPerlAtom> ('[]');
            } elsif ($dataType-><M::DIS|DISResource.isSubsetOfURI>
                                              (<Q::pl:HASH>)) {
              $r = $plimpl-><M::DIS|MPLImpl.createPerlAtom> ('{}');
            }
          }
        }__;

  @Method:
    @@Name:plCodeFragment
    @@enDesc:
      Converts <Q::lang:dis> into Perl code.
    @@Param:
      @@@Name: disResource
      @@@Type: DIS|DISResource
      @@@clsActualType: DIS|ManakaiDISResourceDefinition
      @@@enDesc:
        A <QUOTE::dis> resource with which code is evaluated.
    @@ForParam:
    @@ForpParam:
    @@NamedParam:
      @@@Name: containsStatements
      @@@Type:
        DOMMain:boolean::ManakaiDOM:all
      @@@enDesc:
        Whether the code is block-level or inline-level.
    @@Return:
      @@@Type: DIS|MPLCodeFragment
      @@@enDesc:
        Perl code converted from this node.
      @@@disPerlException:
      @@@PerlDef:
        __DEEP{
          my $plimpl = $self-><AG::DISElementPerl.plImplementation>;
          my $et = $self-><AG::DIS|SWCFGElement.expandedURI>;
          if ($et eq <Q::dis:Def>) {
            my $value = $self-><M::DIS|SWCFGNode.value>;
            if (defined $value) {
              __UNDEEP{__EXCEPTION{DIS|DISPERL_NO_VALUE_ALLOWED_ERR::
                DIS:sourceNode => {$self},
                DIS:elementType => {$et},
              }__}__;
            }
            $r = $plimpl-><M::DIS|MPLImpl.createPerlBlockContainer>;
            for my $c (@{$self-><M::DIS|DISElement.disChildElements>
                                  (for_arg => $forArg, forp_arg => $forpArg)}) {
              my $ccode = $c-><M::DISElementPerl.plCodeFragment>
                                  ($disResource,
                                   for_arg => $forArg, forp_arg => $forpArg,
                                   contains_statements => $containsStatements);
              $r-><M::DIS|PLBlockCon.appendCodeFragment> ($ccode->clone)
                if $ccode;
            }
          } elsif ({
            <Q::DISLang:constValue> => true,
            <Q::DISPerl:cloneCode> => true,
          }->{$et}) {
            my ($qname, $const_name, $on) = split /\s*\.\s*/,
                                             $self-><M::DIS|SWCFGNode.value>, 3;
            my $parentResource = $disResource-><M::DIS|DISResourceProp
                                                .getPropertyResource>
                                                (<Q::dis2pm:parentResource>);
            my $uri = $self-><M::DIS|NSResolverDIS.tfqnamesToURI>
                             ($qname,
                              ($parentResource-><M::DIS|DISResourceProp
                                                .getPropertyResource>
                                                (<Q::dis2pm:parentResource>) ||
                               $parentResource || $disResource)->
                                      <AG::DIS|DISAnyResource.nameURI>,
                              $forArg, node => $self);
            my $const;
            if (defined $const_name) {
              my $owner = $disResource-><AG::DIS|DISAnyResource.database>
                                      -><M::DIS|DISDatabase.getResource> ($uri);
              $owner-><AS::DIS|DISAnyResource.isReferred> ($self);
              if ($et eq <Q::DISLang:constValue>) {
                $const = $owner-><M::DIS|DISResource
                                         .getConstResourceByName> ($const_name);
                unless (defined $const) {
                  __UNDEEP{__EXCEPTION{DIS|RESOURCE_NOT_DEFINED_ERR::
                    DIS:parentURI => {$uri},
                    DIS:localName => {$const_name},
                    DIS:sourceNode => {$self},
                    DIS:elementType => {$et},
                    DIS:expectedType => {<Q::ManakaiDOM:Const>},
                  }__}__;
                }
              } else {
                $const = $owner-><M::DIS|DISResource
                                         .getChildResourceByNameAndType>
                                          ($const_name, <Q::DISLang:AnyMethod>);
                unless (defined $const) {
                  __UNDEEP{__EXCEPTION{DIS|RESOURCE_NOT_DEFINED_ERR::
                    DIS:parentURI => {$uri},
                    DIS:localName => {$const_name},
                    DIS:sourceNode => {$self},
                    DIS:elementType => {$et},
                    DIS:expectedType => {<Q::DISLang:AnyMethod>},
                  }__}__;
                }
              }
            } else {
              $const = $disResource-><AG::DIS|DISAnyResource.database>
                                   -><M::DIS|DISDatabase.getResource> ($uri);
            }
            if ($const-><M::DIS|DISResource.isTypeURI>
                                      (<Q::ManakaiDOM:Const>)) {
              $const-><AS::DIS|DISAnyResource.isReferred> ($self);

              my $data_type = $const-><AG::DIS|DISResource
                                       .disActualDataTypeResource>;
              my $val = $const->{<Q::dis:Value>}-><M::DVValuePerl.plCodeFragment>
                            ($disResource,
                             data_type_uri => $data_type
                                    -><AG::DIS|DISAnyResource.uri>)
                if $const->{<Q::dis:Value>};
              unless (defined $val) {
                __UNDEEP{__EXCEPTION{DIS|NO_CONST_VALUE_ERR::
                  DIS:uri => {$const->{uri}},
                  DIS:localName => {$const->{localName}},
                  DIS:sourceNode => {$const->{src}},
                  DIS:elementType => {$et},
                }__}__;
              }
            
              if ($containsStatements) {
                $r = $plimpl-><M::DIS|MPLImpl.createPerlStatement>;
                my $rvar = $plimpl-><M::DIS|MPLImpl.createPerlVariable>
                                                 ('$', null, 'r');
                $r-><M::DIS|PLAnyCon.appendNewAssignment> ($rvar => $val);
              } else {
                $r = $val;
              }
            } elsif ($const-><M::DIS|DISResource.isTypeURI>
                                 (<Q::DISLang:AnyMethod>)) {
              my $ret = $const-><M::DIS|DISResource
                                  .getChildResourceByType>
                                 ($const-><M::DIS|DISResource
                                        .isTypeURI> (<Q::DISLang:Method>)
                                  ? <Q::DISLang:MethodReturn>
                                  : ($on and $on eq 'set')
                                    ? <Q::DISLang:AttributeSet>
                                    : <Q::DISLang:AttributeGet>);
              unless ($ret) { 
                __UNDEEP{
                  if ($const-><M::DIS|DISResource
                                        .isTypeURI> (<Q::DISLang:Method>)) {
                    __EXCEPTION{DIS|NO_METHOD_RETURN_ERR::
                      DIS:errResource => {$const},
                      DIS:sourceNode => {$const->{src}},
                      DIS:elementType => {$et},
                      DIS:uri => {$const->{uri}},
                      DIS:localName => {$const->{localName}},
                    }__;
                  } elsif ($on and $on eq 'set') {
                    __EXCEPTION{DIS|NO_ATTR_SET_ERR::
                      DIS:errResource => {$const},
                      DIS:sourceNode => {$const->{src}},
                      DIS:elementType => {$et},
                    }__;
                  } else {
                    __EXCEPTION{DIS|NO_ATTR_GET_ERR::
                      DIS:errResource => {$const},
                      DIS:sourceNode => {$const->{src}},
                      DIS:elementType => {$et},
                    }__;
                  }
                }__; # UNDEEP
              }
              $r = $ret-><AG::DISResourcePerl.plCodeFragment>;
            } elsif ($const-><M::DIS|DISResource.isTypeURI>
                                 (<Q::DISCore:AnyDefContainer>)) {
              $r = $const-><AG::DISResourcePerl.plCodeFragment>;
            } else {
              if ($et eq <Q::DISLang:constValue>) {
                __UNDEEP{__EXCEPTION{DIS|RESOURCE_NOT_DEFINED_ERR::
                  DIS:uri => {$const->{uri}},
                  DIS:localName => {$const->{localName}},
                  DIS:sourceNode => {$self->{src}},
                  DIS:expectedType => {<Q::ManakaiDOM:Const>},
                }__}__;
              } else {  # DISPerl:cloneCode
                __UNDEEP{__EXCEPTION{DIS|RESOURCE_NOT_DEFINED_ERR::
                  DIS:uri => {$const->{uri}},
                  DIS:localName => {$const->{localName}},
                  DIS:sourceNode => {$self->{src}},
                  DIS:expectedType => {<Q::DISLang:AnyMethod>},
                }__}__;
              }
            }
          } elsif ($et eq <Q::DISLang:value>) {
            my $val = $self-><M::DISElementPerl.plValueCodeFragment>
                            (null, $disResource,
                             for_arg => $forArg,
                             forp_arg => $forpArg);
            $r = $plimpl-><M::DIS|MPLImpl.createPerlStatement>;
            my $rvar = $plimpl-><M::DIS|MPLImpl.createPerlVariable>
                                                 ('$', null, 'r');
            $r-><M::DIS|PLAnyCon.appendNewAssignment> ($rvar => $val);
          } elsif ({
            <Q::dis:GetProp> => true,
            <Q::dis:GetPropNode> => true,
            <Q::swcfg21:GetPropNode> => true,
          }->{$et}) {
            my $prop_uri = $self-><AG::DIS|DISElement.qnameValueURI>;
            $disResource->{db}
                     -><M::DIS|DISDatabase.getResource> ($prop_uri)
                     -><AS::DIS|DISAnyResource.isReferred> ($self);
            $r = $plimpl-><M::DIS|MPLImpl.createPerlStatement>;
            my $val = $plimpl-><M::DIS|MPLImpl.createPerlInlineContainer>;
            $val-><M::DIS|PLInCon.appendCode> ('$self->{node}->{');
            $val-><M::DIS|PLAnyCon.appendStringLiteral> ($prop_uri);
            $val-><M::DIS|PLInCon.appendCode> ('}');
            my $rvar = $plimpl-><M::DIS|MPLImpl.createPerlVariable>
                                               ('$', null, 'r');
            $r-><M::DIS|PLAnyCon.appendNewAssignment> ($rvar => $val);
            
            if ({<Q::dis:GetPropNode> => true,
                 <Q::swcfg21:GetPropNode> => true}->{$et}) {
              my $q = $plimpl-><M::DIS|MPLImpl.createPerlBlockContainer>;
              $q-><M::DIS|PLBlockCon.appendCodeFragment> ($r);
              $q-><M::DIS|PLBlockCon.appendNewIf>
                       ($plimpl-><M::DIS|MPLImpl.createPerlInlineUnparsedCode>
                                                     ('defined $r'),
                        my $qt = $plimpl-><M::DIS|MPLImpl
                                                .createPerlBlockContainer>);
              $qt-><M::DIS|PLBlockCon.appendStatement>
                 -><M::DIS|PLAnyCon.appendNewAssignment>
                       ($rvar->clone => my $qtr = $plimpl-><M::DIS|MPLImpl
                                                    .createPerlInlineContainer>);
              my $cls = $disResource->{db}-><M::DIS|DISDatabase
                           .getResource> ({
                             <Q::dis:GetPropNode> => <Q::DOMCore:ManakaiDOMNode>,
                             <Q::swcfg21:GetPropNode> =>
                                                   <Q::swcfg21:ManakaiSWCFGNode>,
                           }->{$et}, for_arg => $forArg);
              $cls-><AS::DIS|DISAnyResource.isReferred> ($self);
              $qtr-><M::DIS|PLInCon.appendCode>
                       ($cls-><AG::DISResourcePerl
                         .plFullyQualifiedName> . q[->_get_node_reference ($r)]);
              $r = $q;
            }
          } elsif ($et eq <Q::dis:SetProp>) {
            my $prop_uri = $self-><AG::DIS|DISElement.qnameValueURI>;
            $disResource->{db}
                     -><M::DIS|DISDatabase.getResource> ($prop_uri)
                     -><AS::DIS|DISAnyResource.isReferred> ($self);
            $r = $plimpl-><M::DIS|MPLImpl.createPerlStatement>;
            my $val = $plimpl-><M::DIS|MPLImpl.createPerlInlineContainer>;
            $val-><M::DIS|PLInCon.appendCode> ('$self->{node}->{');
            $val-><M::DIS|PLAnyCon.appendStringLiteral> ($prop_uri);
            $val-><M::DIS|PLInCon.appendCode> ('}');
            my $rvar = $plimpl-><M::DIS|MPLImpl.createPerlVariable>
                                               ('$', null, 'given');
            $r-><M::DIS|PLAnyCon.appendNewAssignment> ($val => $rvar);
            my $chk = $self-><M::DIS|DISElement.disGetAttribute>
                                           (<Q::dis:CheckReadOnly>,
                for_arg => $disResource-><AG::DIS|DISAnyResource.forURI>,
                forp_arg => $disResource-><AG::DIS|DISAnyResource.forpURI>,
                database_arg => $disResource-><AG::DIS|DISAnyResource.database>);
            if ($chk and $chk-><M::DIS|SWCFGNode.value>) {
              my $q = $plimpl-><M::DIS|MPLImpl.createPerlIf>
                   (my $qc = $plimpl-><M::DIS|MPLImpl.createPerlInlineContainer>,
                    my $qt = $plimpl-><M::DIS|MPLImpl.createPerlBlockContainer>);
              $qc-><M::DIS|PLInCon.appendCode> ('$self->{node}->{');
              $qc-><M::DIS|PLAnyCon.appendStringLiteral>
                                               (<Q::DOMCore:read-only>);
              $qc-><M::DIS|PLInCon.appendCode> ('}');

              my $for_uri = $disResource->{db}-><M::DIS|DISDatabase.getFor>
                               ($forArg)-><M::DIS|DISFor.isaURI>
                               (<Q::ManakaiDOM:ManakaiDOM1>)
                            ? $forArg : <Q::ManakaiDOM:ManakaiDOMLatest>;
              my $cls = $disResource->{db}-><M::DIS|DISDatabase.getResource>
                                                (<Q::DOMCore:DOMException>,
                                                       for_arg => $for_uri);
              my $const = $disResource->{db}-><M::DIS|DISDatabase.getResource>
                                 (<Q::DOMCore:NO_MODIFICATION_ALLOWED_ERR>,
                                                       for_arg => $for_uri);
              my $subtype = $disResource->{db}
                                            -><M::DIS|DISDatabase.getResource>
                                                    (<Q::MDOMX:NOMOD_THIS>,
                                                       for_arg => $for_uri);
              $_-><AS::DIS|DISAnyResource.isReferred>
                               ($self) for $cls, $const, $subtype;
              my $context_param = $disResource-><M::ManakaiDISResourcePerl
                                        .plGetContextParameter>;
              $disResource-><M::ManakaiDISResourcePerl
                            .plAppendThrow>
                               ($qt, $cls, $const, $subtype,
                                {%$context_param},
                                node => $self);
              my $or = $r;
              $r = $plimpl-><M::DIS|MPLImpl.createPerlBlockContainer>;
              $r-><M::DIS|PLBlockCon.appendCodeFragment> ($or);
              $r-><M::DIS|PLBlockCon.appendCodeFragment> ($q);
            } # Read-only checking
          } elsif ($et eq <Q::DOMMain:raiseException>) {
            my ($cls, $const, $subtype)
                = @{$disResource->{db}-><M::DIS|DISDatabase.xcrefToResource>
                                         ($self-><M::DIS|SWCFGNode.value>,
                                          $self,
                                          node => $self,
                                          for_arg => $forArg)};
            my $context_param = $disResource-><M::ManakaiDISResourcePerl
                                        .plGetContextParameter>;
            $disResource-><M::ManakaiDISResourcePerl.plAppendThrow>
                        ($r = $plimpl-><M::DIS|MPLImpl.createPerlBlockContainer>,
                         $cls, $const, $subtype,
                         {%$context_param},
                         node => $self);
          } elsif ({
            <Q::dis:ContentType> => true,
            <Q::dis:For> => true, <Q::dis:ForCheck> => true,
            <Q::dis:ImplNote> => true,
            <Q::DISLang:nop> => true,
          }->{$et}) {
            #
          } else {
            __UNDEEP{__EXCEPTION{DIS|UNSUPPORTED_ELEMENT_TYPE_ERR::
              DIS:sourceNode => {$self},
              DIS:elementType => {$et},
            }__}__;
          }
        }__; # DEEP
##DISElementPerl

ResourceDef:
  @QName: setDefaultValue
  @rdf:type: dis2pm|BlockCode
  @PerlDef:
    if ($data_type-><M::DIS|DISResource.isSubsetOfURI>
                                              (<Q::DISLang:String>)) {
      $result = $plimpl-><M::DIS|MPLImpl.createPerlStringLiteral> ('');
    } elsif ($data_type-><M::DIS|DISResource.isSubsetOfURI>
                                              (<Q::DOMMain:boolean>) or
             $data_type-><M::DIS|DISResource.isSubsetOfURI>
                                              (<Q::DISIDL:AnyRealNumber>)) {
      $result = $plimpl-><M::DIS|MPLImpl.createPerlAtom> ('0');
    } elsif ($data_type-><M::DIS|DISResource.isSubsetOfURI>
                                              (<Q::pl:ARRAY>)) {
      $result = $plimpl-><M::DIS|MPLImpl.createPerlAtom> ('[]');
    } elsif ($data_type-><M::DIS|DISResource.isSubsetOfURI>
                                              (<Q::pl:HASH>)) {
      $result = $plimpl-><M::DIS|MPLImpl.createPerlAtom> ('{}');
    }
  @For: DIS|ForEmpty
##setDefaultValue

ResourceDef:
  @QName: DIS|MPLImpl
  @AliasFor:
    PerlCode:PCImplementation::ManakaiDOM:Perl
  @For: DIS|ForEmpty

ResourceDef:
  @QName: DIS|MPLCodeFragment
  @AliasFor:
    PerlCode:PerlCode::ManakaiDOM:Perl
  @For: DIS|ForEmpty

ResourceDef:
  @QName: DIS|PLFile
  @AliasFor:
    PerlCode:PerlFile::ManakaiDOM:Perl
  @For: DIS|ForEmpty

ResourceDef:
  @QName: DIS|PLPack
  @AliasFor:
    PerlCode:PerlPackage::ManakaiDOM:Perl
  @For: DIS|ForEmpty

ResourceDef:
  @QName: DIS|PLInCon
  @AliasFor:
    PerlCode:PerlCodeInlines::ManakaiDOM:Perl
  @For: DIS|ForEmpty

ResourceDef:
  @QName: DIS|PLBlockCon
  @AliasFor:
    PerlCode:PerlCodeStatements::ManakaiDOM:Perl
  @For: DIS|ForEmpty

ResourceDef:
  @QName: DIS|MPLSS
  @AliasFor:
    PerlCode:PerlCodeStatements::ManakaiDOM:Perl
  @For: DIS|ForEmpty

ResourceDef:
  @QName: DIS|PLAnyCon
  @AliasFor:
    PerlCode:PerlCodeUnits::ManakaiDOM:Perl
  @For: DIS|ForEmpty

ResourceDef:
  @QName: DIS|MPLSub
  @AliasFor:
    PerlCode:ManakaiPerlSub::ManakaiDOM:Perl
  @For: DIS|ForEmpty

ResourceDef:
  @QName: DIS|MPLUnparsedCode
  @AliasFor:
    PerlCode:ManakaiPerlUnparsedCode::ManakaiDOM:Perl
  @For: DIS|ForEmpty

PropDef:
  @QName: DIS|plCodeFragment
  @enDesc:
    Cache for <A::ManakaiDISResourceDefinition.plCodeFragment>.

ElementTypeBinding:
  @Name: PropDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      rdf:Property
    @@AliasFor:
      @@@For: =ManakaiDOM|all

IFClsDef:
  @IFQName: DVValuePerl
  @ClsQName: ManakaiDVValuePerl

  @Method:
    @@Name: plCodeFragment
    @@enDesc:
      Returns a Perl representation of the value.
    @@Param:
      @@@Name: disResource
      @@@Type: DIS|DISResource
      @@@clsActualType: DIS|ManakaiDISResourceDefinition
      @@@enDesc:
        A <QUOTE::dis> resource with which code is evaluated.
    @@NamedParam:
      @@@Name:dataTypeURI
      @@@Type:
        DIS|ResourceURI
      @@@enDesc:
        The URI reference of a data type.  It is used to convert
        untyped value and to define default value if <P::useDefaultValue>
        is set to <DOM::true>.
      @@@nullCase:
        @@@@enDesc: 
          No data type.  If the value is untyped, it is treated 
          as if <Q::DISCore:String>.
    @@Return:
      @@@Type: DIS|MPLCodeFragment
      @@@enDesc: A Perl representation of the value.
      @@@RaiseException:
        @@@@@:DIS|NO_PERL_CODE_IMPL_ERR
        @@@@enDesc:
          There is no implementation that implements
          the <Feature::Util:PerlCode> feature, version <FeatureVer::1.0>.
      @@@PerlDef:
        __DEEP{
          my $dataType;
          my $plimpl = $self-><AG::DISElementPerl.plImplementation>;
          unless ($plimpl) {
            __UNDEEP{__EXCEPTION{DIS|NO_PERL_CODE_IMPL_ERR}__}__;
          }
          if ($self-><AG::dv|DVValue.isNull>) {
            $r = $plimpl-><M::DIS|MPLImpl.createPerlAtom> ('undef');
          } else {
            my $vnode_type = $disResource-><AG::DIS|DISAnyResource.database>
                                         -><M::DIS|DISDatabase.getResource>
                                              ($self-><AG::dv|DVValue.dataType>);
            if ($vnode_type-><M::DIS|DISResource
                                .isSubsetOfURI> (<Q::lang:Perl>)) {
              $r = $disResource-><M::DISResourcePerl
                             .plPreprocessPerlStatement>
                            ($self-><AG::dv|DVValue.stringValue>,
                             contains_statements => false,
                             namespace_context => $self-><AG::dv|DVValue.value>);
            } elsif ($vnode_type-><M::DIS|DISResource.isSubsetOfURI>
                                        (<Q::DISCore:Integer>)) {
              $r = $plimpl-><M::DIS|MPLImpl.createPerlAtom>
                                  ($self-><AG::dv|DVValue.value> + 0);
            } elsif ($vnode_type-><M::DIS|DISResource.isSubsetOfURI>
                                        (<Q::DISCore:Boolean>)) {
              $r = $plimpl-><M::DIS|MPLImpl.createPerlAtom>
                                  ($self-><AG::dv|DVValue.value> ? true : false);
            } elsif ($dataTypeURI) {
              $dataType ||= $disResource-><AG::DIS|DISAnyResource.database>
                                        -><M::DIS|DISDatabase.getResource>
                                              ($dataTypeURI);
              my $vnode_value = $self-><AG::dv|DVValue.value>;
              if (UNIVERSAL::can ($vnode_value, 'value')) {
                $vnode_value = $vnode_value-><M::DIS|SWCFGNode.value>;
              }
              if ($dataType-><M::DIS|DISResource.isSubsetOfURI>
                                                (<Q::DISIDL:AnyRealNumber>)) {
                $r = $plimpl-><M::DIS|MPLImpl.createPerlAtom>
                                                (0 + $vnode_value);
              } elsif ($dataType-><M::DIS|DISResource
                                  .isSubsetOfURI> (<Q::DOMMain:boolean>)) {
                $r = $plimpl-><M::DIS|MPLImpl.createPerlAtom>
                                      ($vnode_value eq 'tr'.'ue' ? true :
                                       $vnode_value eq '1' ? true : false);
              } else { ## DOMMain:DOMString or some
                $r = $plimpl-><M::DIS|MPLImpl.createPerlStringLiteral>
                                         ($self-><AG::dv|DVValue.stringValue>);
              }
            } else { ## DISCore:String or some
              $r = $plimpl-><M::DIS|MPLImpl.createPerlStringLiteral>
                                    ($self-><AG::dv|DVValue.stringValue>);
            }
          }
        }__;

  @Attr:
    @@Name: plImplementation
    @@enDesc:
      The implementation object, which the object belongs to and
      which implements the feature <Feature::Util|PerlCode>
      version <FeatureVer::1.0>.
    @@Type:
      PerlCode:PCImplementation::ManakaiDOM:Perl
    @@Get:
      @@@enDesc:
        The Perl code implementation object. 
      @@@nullCase:
        @@@@enDesc:
          There is no implementation that supports the feature
          <Feature::Util:PerlCode> version <FeatureVer::1.0> or
          the resource has no source element associated.
      @@@RaiseException:
        @@@@@: DIS|NO_PERL_CODE_IMPL_ERR
        @@@@enDesc:
          There is no implementation that implements 
          the <Feature::Util:PerlCode> feature, version <FeatureVer::1.0>. 
      @@@PerlDef:
#          $r = $Message::DOM::ImplementationRegistry
#                 ->get_implementation
#                      ({<Q::Util:PerlCode> => '1.0'});
                                    ## NOTE: Method name directly written
          $r = <Class::PLImplClass>->_new;
#          unless (defined $r) {
#            __EXCEPTION{DIS|NO_PERL_CODE_IMPL_ERR::
#              
#            }__;
#          }
##DVValuePerl

ElementTypeBinding:
  @Name: ForParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:MethodParameter
    @@DISPerl:isNamedParameter:1
    @@Name: forArg
    @@Type: DIS|ForURI
    @@Description:
      @@@lang:en
      @@@@:
        The <QUOTE::for> URI reference. 
    @@ResourceDef:
      @@@rdf:type:
        ManakaiDOM:InCase
      @@@Value:
        @@@@is-null:1
        @@@@ContentType: DISCore|String
      @@@Description:
        @@@@lang:en
        @@@@@:
          Equivalent to <Q::ManakaiDOM:all>, i.e. <QUOTE::for all>. 

ResourceDef:
  @QName: PLImplClass
  @AliasFor: PerlCode|ManakaiPerlCodeImplementation||ManakaiDOM|Perl
  @For: DIS|ForEmpty

ElementTypeBinding:
  @Name: ForpParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:MethodParameter
    @@DISPerl:isNamedParameter:1
    @@Name: forpArg
    @@Type: DIS|ForURIList
    @@Description:
      @@@lang:en
      @@@@:
        An array reference containing additional <QUOTE::for> 
        constraints (<QUOTE::For+> list).
    @@ResourceDef:
      @@@rdf:type:
        ManakaiDOM:InCase
      @@@Value:
        @@@@is-null:1
        @@@@ContentType: DISCore|String
      @@@Description:
        @@@@lang:en
        @@@@@:
          Equivalent to the empty array reference. 

ElementTypeBinding:
  @Name: MediaTypeParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:MethodParameter
    @@DISPerl:isNamedParameter:1
    @@Name: mediaType
    @@Type: DIS|MediaTypeURI
    @@Description:
      @@@lang:en
      @@@@:
        The URI reference identifying a media type. 
    @@ResourceDef:
      @@@rdf:type:
        ManakaiDOM:InCase
      @@@Value:
        @@@@is-null:1
        @@@@ContentType: DISCore|String
      @@@Description:
        @@@@lang:en
        @@@@@:
          No media type specified. 

ElementTypeBinding:
  @Name: MediaTypeDefaultParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:MethodParameter
    @@DISPerl:isNamedParameter:1
    @@Name: defaultMediaType
    @@Type: DIS|MediaTypeURI
    @@Description:
      @@@lang:en
      @@@@:
        The default media type, i.e. the type used when no explicit 
        specification is not found in the source tree. 
    @@ResourceDef:
      @@@rdf:type:
        ManakaiDOM:InCase
      @@@Value:
        @@@@is-null:1
        @@@@ContentType: DISCore|String
      @@@Description:
        @@@@lang:en
        @@@@@:
          Defaulted to <Q::DOMMain:any>. 

ElementTypeBinding:
  @Name: RaiseException
  @ElementType:
    ManakaiDOM:raises

ElementTypeBinding:
  @Name: UndeclaredPrefixException
  @ElementType:
    ManakaiDOM:raises
  @ShadowContent:
    @@@: DIS|UNDECLARED_NS_PREFIX_ERR
    @@Description:
      @@@lang:en
      @@@@:
        The implementation has encounted an undeclared namespace prefix. 

ElementTypeBinding:
  @Name: NamedParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:MethodParameter
    @@DISPerl:isNamedParameter:1

ElementTypeBinding:
  @Name: NodeParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:MethodParameter
    @@DISPerl:isNamedParameter:1
    @@Name: node
    @@Type: DIS|DISNode
    @@actualType:
      @@@@: DIS|ManakaiDISNode
      @@@ForCheck: ManakaiDOM|ForClass
    @@Description:
      @@@lang:en
      @@@@:
        The node in which the name has occurred.  It is intended 
        to be reported when an exception had been raised. 
    @@ResourceDef:
      @@@rdf:type:
        ManakaiDOM:InCase
      @@@Value:
        @@@@is-null:1
        @@@@ContentType: DISCore|String
      @@@Description:
        @@@@lang:en
        @@@@@:
          The source of the name is not a node. 

## -- DIS database

IFClsDef:
  @IFQName: DISDatabasePerl
  @ClsQName: ManakaiDISDatabasePerl

  @enDesc:
    The objects implementing the <IF::DISDatabasePerl>
    interface <kwd:MUST> also implement the <IF::DIS|DISDatabase>
    interface.


  @Method:
    @@Name: plStore
    @@enDesc:
      Saves this database to an external file. 
      \
      {NOTE:: Saved files can be loaded by 
              <M::DISImplementationPerl.plLoadDISDatabase>.
      \
      }
    @@Param:
      @@@Name: fileName
      @@@Type:
        DISLang:String::ManakaiDOM:all
      @@@enDesc:
        An environment-dependent file name of external database to save. 
        \
        {NOTE:: If there is already a file named as <P::fileName>, then 
                it is overwritten. 
        \
        }
    @@Return:
      @@@SimpleException:
      @@@PerlDef:
        use Storable qw/nstore/;
        local $Carp::CarpLevel = $Carp::CarpLevel + 1;
        nstore $self, $fileName;
##DISDatabasePerl


ElementTypeBinding:
  @Name: SimpleException
  @ElementType:
    dis:Description
  @ShadowContent:
    @@lang:en
    @@@:
      - Exception of type <PerlModule::Error::Simple>::: 
             I/O error or other error reported by <PerlModule::Storable>. 
   @@ImplNote:
     @@@lang:en
     @@@@:
       {TODO:: Formal description required for simple exception}


ElementTypeBinding:
  @Name: disPerlException
  @ElementType:
    ManakaiDOM:raises
  @ShadowContent:
    @@@: DIS|DISPERL_NO_VALUE_ALLOWED_ERR
    @@Description:
      @@@lang:en
      @@@@:
        An element value is specified where it is not allowed.
  @ShadowSibling:
    @@ManakaiDOM:raises:
      @@@@: DIS|RESOURCE_NOT_DEFINED_ERR
      @@@Description:
        @@@@lang:en
        @@@@@:
          An undefined resource is referred or a referred resource
          is defined but have different type than the one expected.
    @@ManakaiDOM:raises:
      @@@@: DIS|NO_CONST_VALUE_ERR
      @@@Description:
        @@@@lang:en
        @@@@@:
          A constant value definition does not have its <Q::dis:Value>
          attribute.
    @@ManakaiDOM:raises:
      @@@@: DIS|NO_METHOD_RETURN_ERR
      @@@Description:
        @@@@lang:en
        @@@@@:
          A method definition does not have a <Q::DISLang:MethodReturn>
          child resource.
    @@ManakaiDOM:raises:
      @@@@: DIS|NO_ATTR_GET_ERR
      @@@Description:
        @@@@lang:en
        @@@@@:
          An attribute definition does not have a <Q::DISLang:AttributeGet>
          child resource.
    @@ManakaiDOM:raises:
      @@@@: DIS|NO_ATTR_SET_ERR
      @@@Description:
        @@@@lang:en
        @@@@@:
          An attribute setter is referred but the attribute definition
          does not have <Q::DISLang:AttributeSet> child resource.
    @@ManakaiDOM:raises:
      @@@@: DIS|UNSUPPORTED_ELEMENT_TYPE_ERR
      @@@Description:
        @@@@lang:en
        @@@@@:
          An unsupported type of element has appeared.

## -- DIS resources

IFClsDef:
  @IFQName: DISAnyResourcePerl
  @ClsQName: ManakaiDISAnyResourcePerl
  
  @enDesc:
    The objects implementing the <IF::DISAnyResourcePerl> interface
    <kwd:MUST> also implement the <IF::DIS|DISAnyResource> interface.
  
  @Attr:
    @@Name: plImplementation
    @@enDesc:
      The implementation object, which the object belongs to and
      which implements the feature <Feature::Util|PerlCode>
      version <FeatureVer::1.0>.
    @@Type:
      PerlCode:PCImplementation::ManakaiDOM:Perl
    @@Get:
      @@@enDesc:
        The Perl code implementation object. 
      @@@nullCase:
        @@@@enDesc:
          There is no implementation that supports the feature
          <Feature::Util:PerlCode> version <FeatureVer::1.0> or
          the resource has no source element associated.
      @@@RaiseException:
        @@@@@: DIS|NO_PERL_CODE_IMPL_ERR
        @@@@enDesc:
          There is no implementation that implements 
          the <Feature::Util:PerlCode> feature, version <FeatureVer::1.0>. 
      @@@PerlDef:
        if ($self->{src}) {
          __DEEP{
            $r = ($self->{src}-><AG::DIS|SWCFGNode.ownerDocument> or
                        $self->{src})-><AG::DIS|SWCFGDoc.implementation>
                           -><M::DIS|DOMMinImpl.getFeature>
                                   (<Q::Util:PerlCode> => '1.0');
          }__;
          unless (defined $r) {
            __EXCEPTION{DIS|NO_PERL_CODE_IMPL_ERR::
             
            }__;
          }
        } else {
#          $r = $Message::DOM::ImplementationRegistry
#                 ->get_implementation
#                      ({<Q::Util:PerlCode> => '1.0'});
                                    ## NOTE: Method name directly written
          $r = <Class::PLImplClass>->_new;
        }
##DISAnyResourcePerl

IFClsDef:
  @IFQName: DISModulePerl
  @ClsQName: ManakaiDISModulePerl

  @enDesc:
    The objects implementing the <IF::DISModulePerl> interface
    <kwd:MUST> also implement the <IF::DIS|DISModule> interface.

  @Attr:
    @@Name: plFullyQualifiedName
    @@enDesc:
      The fully-qualified Perl class package name. 
    @@Type:
      pl:package-name::ManakaiDOM:all
    @@Get:
      @@@NoPerlModuleNameException:
      @@@PerlDef:
        __DEEP{
          my $mg = $self-><AG::DIS|DISAnyResource.database>
                        -><M::DIS|DISDatabase.getResource>
                                ($self-><AG::DIS|DISAnyResource.namespaceURI>);
          unless ($self-><AG::DIS|DISAnyResource.isDefined>) {
            __UNDEEP{__EXCEPTION{DIS|RESOURCE_NOT_DEFINED_ERR::
              DIS:uri => {$self-><AG::DIS|DISAnyResource.namespaceURI>},
              DIS:sourceNode => {$self-><AG::DIS|DISAnyResource.sourceElement>},
            }__}__;
          }
          my $an = $mg-><M::DIS|DISResourceProp.getPropertyValue>
                             (<Q::dis:AppName>);
          $r = $an ? $an-><AG::dv|DVValue.stringValue>
                   : $mg-><AG::DIS|DISAnyResource.localName> || 'main';
          $r =~ s/::$//g;
          $r .= '::' . $self-><AG::DIS|DISAnyResource.localName>;
          my $sf = $an-><M::dv|DVValue.getProperty>
                             (<Q::ManakaiDOM:moduleSuffix>) if $an;
          $r .= $sf-><AG::dv|DVValue.stringValue> if $sf;
        }__;

  @Attr:
    @@Name: plInterfaceName
    @@enDesc:
      The fully-qualified Perl interface package name. 
    @@Type:
      pl:package-name::ManakaiDOM:all
    @@Get:
      @@@NoPerlModuleNameException:
      @@@PerlDef:
        __DEEP{
          my $mg = $self-><AG::DIS|DISAnyResource.database>
                        -><M::DIS|DISDatabase.getResource>
                                ($self-><AG::DIS|DISAnyResource.namespaceURI>);
          unless ($self-><AG::DIS|DISAnyResource.isDefined>) {
            __UNDEEP{__EXCEPTION{DIS|RESOURCE_NOT_DEFINED_ERR::
              DIS:uri => {$self-><AG::DIS|DISAnyResource.namespaceURI>},
              DIS:sourceNode => {$self-><AG::DIS|DISAnyResource.sourceElement>},
            }__}__;
          }
          my $an = $mg-><M::DIS|DISResourceProp.getPropertyValue>
                             (<Q::DISPerl:interfacePackage>);
          if ($an) {
            $r = $an-><AG::dv|DVValue.stringValue>;
            $r =~ s/::$//g;
            my $sf = $an-><M::dv|DVValue.getProperty>
                               (<Q::ManakaiDOM:moduleSuffix>);
            $r .= $sf-><AG::dv|DVValue.stringValue> if $sf;
          } else {
            $r = $self-><AG::DISModulePerl.plFullyQualifiedName>;
          }
        }__;
##DISModulePerl

ElementTypeBinding: 
  @Name: NoPerlModuleNameException
  @ElementType:
    ManakaiDOM:raises
  @ShadowContent:
    @@@: DIS|RESOURCE_NOT_DEFINED_ERR
    @@Description:
      @@@lang:en
      @@@@:
        The module group corresponding to the namespace URI
        of this module is not defined. 

IFClsDef:
  @IFQName: DISResourcePerlModule
  @ClsQName: DIS|ManakaiDISPerlModuleDefinition

  @enDesc:
    A class inherited by classes whose object might (but not necessarily) define
    a Perl module. 
  @ImplNote:
    @@lang:en
    @@@:
      Any object whose class inheriting this class must also inherit
      the <Class::DIS|ManakaiDISPropertyAccessor> class.
  
  @Method:
    @@Name: plGeneratePerlModuleFile
    @@enDesc:
      Generates a Perl file object. 
    @@Return:
      @@@Type: DIS|PLFile
      @@@enDesc:
        A Perl file object generated from this resource.
      @@@RaiseException:
        @@@@@:DIS|NO_LICENSE_ATTR_ERR
        @@@@enDesc:
          The <Q::dis:Module> element does not have the
          <Q::dis:License> attribute.
      @@@NoPerlModuleNameException:
      @@@RaiseException:
        @@@@@:DIS|RESOURCE_NOT_DEFINED_ERR
        @@@@enDesc:
          A feature referred from this module is not defined.
      @@@RaiseException:
        @@@@@:DIS|RESOURCE_NOT_DEFINED_ERR
        @@@@enDesc:
          A markup vocabulary is referred but it is not defined
          or have a different type than the expected one.
      @@@PerlDef:
        __DEEP{
          $r = $self-><AG::DISAnyResourcePerl.plImplementation>
                    -><M::DIS|MPLImpl.createPerlFile>;

          ## -- Source information
          $r-><AS::DIS|PLFile.sourceFile>
                 ($self-><M::DIS|DISResourceProp.getPropertyText>
                                (<Q::DIS:sourceFile>, ''));
          $r-><AS::DIS|PLFile.sourceModule>
                  ($self-><AG::DIS|DISAnyResource.nameURI>);
          $r-><AS::DIS|PLFile.sourceFor> ($self->{for});
          
          ## -- License information
          my $ownermod = $self-><AG::DIS|DISAnyResource.ownerModule>;
          my $license = $ownermod-><M::DIS|DISResourceProp
                                     .getPropertyResource> (<Q::dis:License>);
          unless ($license) {
            __UNDEEP{__EXCEPTION{DIS|NO_LICENSE_ATTR_ERR::
              DIS:sourceNode => {$ownermod->{src}},
              DIS:uri => {$ownermod->{uri}},
            }__}__;
          }
          $r-><AS::DIS|PLFile.licenseURI>
                            ($license-><AG::DIS|DISAnyResource.uri>);

          ## -- Classes
          ## TODO: Custom module construction support
          my $thismod_name = $self-><AG::DISModulePerl.plFullyQualifiedName>;
          my $thismod_pack = $r-><M::DIS|PLFile.getLastPackage>
                                     ($thismod_name, make_new_package => true);
          my %const;
          my %processed_class;
          for my $cls (@{$self-><M::DIS|DISResourceProp
                                   .getPropertyResourceList>
                                              (<Q::DIS:resource>)}) {
            if ($cls-><AG::DIS|DISAnyResource.ownerModule>
                   eq $ownermod and
                not $processed_class{$cls-><AG::DIS|DISAnyResource.uri>}) {
              $processed_class{$cls-><AG::DIS|DISAnyResource.uri>}
                = true;
              if ($cls-><M::DIS|DISResource.isTypeURI>
                              (<Q::ManakaiDOM:Class>)) {
                ## -- Subroutines and variables
                my $pack = $cls-><AG::DISResourcePerl.plCodeFragment>;
                $r-><M::DIS|PLFile.appendPackage> ($pack);
                my $pack_name = $cls-><AG::DISResourcePerl
                                          .plFullyQualifiedName>;

                ## -- Constants
                for my $cr (@{$cls-><M::DIS|DISResourceProp
                                       .getPropertyResourceList>
                                          (<Q::DIS:childResource>)}) {
                  if ($cr-><M::DIS|DISResource.isTypeURI>
                                          (<Q::ManakaiDOM:Const>)) {
                    $thismod_pack-><M::DIS|PLPack.addExport>
                      (null,
                       my $nm = $cr-><AG::DISResourcePerl.plName>);
                    $const{$nm} = $cr-><AG::DISResourcePerl
                                           .plFullyQualifiedName>;
                  } elsif ($cr-><M::DIS|DISResource.isTypeURI>
                                          (<Q::ManakaiDOM:ConstGroup>)) {
                    my $tag = $cr-><AG::DISResourcePerl.plName>;
                    for my $gcr (@{$cr-><M::DIS|DISResourceProp
                                       .getPropertyResourceList>
                                          (<Q::DIS:childResource>)}) {
                      if ($gcr-><M::DIS|DISResource.isTypeURI>
                                          (<Q::ManakaiDOM:Const>)) {
                        $thismod_pack-><M::DIS|PLPack.addExport>
                          ($tag, my $nm = $gcr-><AG::DISResourcePerl.plName>);
                        $const{$nm} = $gcr-><AG::DISResourcePerl
                                                   .plFullyQualifiedName>;
                      }
                    }
                  }
                }

                ## -- Features
                my %feature;
                for my $v (@{$cls-><M::DIS|DISResourceProp.getPropertyValueList>
                                      (<Q::DOMMetaImpl.provideFeature>)}) {
                  my $f = $self-><AG::DIS|DISAnyResource.database>
                               -><M::DIS|DISDatabase.getResource>
                                     ($v->isa (<IFName::dv|DVURIValue>)
                                         ? $v-><AG::dv|DVURIValue.uri>
                                         : $v-><AG::dv|DVValue.value>);
                  unless ($f-><AS::DIS|DISAnyResource.isDefined>) {
                    __UNDEEP{__EXCEPTION{DIS|RESOURCE_NOT_DEFINED_ERR::
                      DIS:uri => {$f-><AG::DIS|DISAnyResource.uri>},
                      DIS:expectedType => {<Q::DOMMain:DOMFeature>},
                    }__}__;
                  }
                  for my $s ($f, @{$f-><M::DIS|DISResourceProp
                                    .getPropertyResourceList>
                                   (<Q::DOMMetaImpl:extendFeature>,
                                    recursive => true,
                                    default_media_type => <Q::dis:TypeQName>)}) {
                    $feature{$s-><AG::DIS|DISAnyResource.uri>}
                         = [$s, $v];
                  }
                }
                for my $f (values %feature) {
                  my @fname = @{$f->[0]-><AG::DIS|DISResource
                                        .featureNameList>};
                  my $fver = $f->[0]-><M::DIS|DISResourceProp
                                        .getPropertyText>
                                        (<Q::dis:Version>, null);
                  next unless defined $fver;
                  my $fi = $self-><M::DISResourcePerlModule
                        .plIsFeatureImplemented> ($f->[0]->{uri}) ? true : false;
                  my $pt = $f->[1]-><M::dv|DVValue.getProperty>
                                            (<Q::DOMMetaImpl:providedThrough>);
                  if (UNIVERSAL::isa ($pt, <IFName::dv|DVURIValue>)) {
                    my $c = $pt-><M::dv|DVURIValue.getResource>
                              ($self-><AG::DIS|DISAnyResource.database>);
                    $c-><AS::DIS|DISAnyResource.isReferred>
                                    ($f->[0]-><AG::DIS|DISAnyResource.uri>);
                    my $cp = $c-><AG::DISResourcePerl.plFullyQualifiedName>;
                    for my $fname (@fname) {
                      $r-><M::DIS|PLBlockCon.appendStatement>
                          ('$Message::DOM::ImplFeature{q<' . $cp .
                           '>}->{q<' .
                           $fname . '>}->{q<' . $fver . '>} ||= '.$fi);
                      $r-><M::DIS|PLBlockCon.appendStatement>
                          ('$Message::DOM::ImplFeature{q<' . $cp .
                           '>}->{q<' . $fname . '>}->{q<>} = 1');
                    }
                  }
                  ## No DOMMetaImpl:ProvidedThrough attribute
                  for my $fname (@fname) {
                    $r-><M::DIS|PLBlockCon.appendStatement>
                        ('$Message::DOM::ImplFeature{q<' . $pack_name .
                         '>}->{q<' .
                         $fname . '>}->{q<' . $fver . '>} ||= '.$fi);
                    $r-><M::DIS|PLBlockCon.appendStatement>
                        ('$Message::DOM::ImplFeature{q<' . $pack_name .
                         '>}->{q<' . $fname . '>}->{q<>} = 1');
                  }
                } # for

                my %ifeature;
                my $ifpoint = 0;
                for my $feature (@{$cls-><M::DIS|DISResourceProp
                          .getPropertyResourceList>
                             (<Q::DOMMain:implementFeature>,
                              isa_recursive => true,
                              default_media_type => <Q::dis:TypeQName>)}) {
                  my $fver = $feature-><M::DIS|DISResourceProp
                                        .getPropertyText>
                                        (<Q::dis:Version>, null);
                  $ifpoint += $fver;
                  my $fi = defined $fver
                         ? $self-><M::DISResourcePerlModule
                                     .plIsFeatureImplemented>
                                           ($feature->{uri}) ? true : false
                         : true;
                  for my $fname (@{$feature-><AG::DIS|DISResource
                                                 .featureNameList>}) {
                    $ifeature{$fname}->{$fver} = $fi;
                    $ifeature{$fname}->{''} = true;
                  }                  
                }
                $r-><M::DIS|PLBlockCon.appendStatement>
                      ('$Message::DOM::ClassFeature{q<' . $pack_name .
                       '>} = ' . <ClassM::PLImplClass.perlLiteral> (\%ifeature));

                ## Score calculated from provided features
                $r-><M::DIS|PLBlockCon.appendStatement>
                        ('$Message::DOM::ClassPoint{q<' . $pack_name .
                         '>} = ' . $ifpoint);

                ## -- Roles
                for my $role (@{$cls-><M::DIS|DISResourceProp
                          .getPropertyResourceList>
                             (<Q::DISLang:role>, isa_recursive => true,
                              default_media_type => <Q::dis:TypeQName>)}) {
                  if ($role-><M::DIS|DISResource.isSubsetOfURI>
    (<Q::DOMMetaImpl:ImplementationSourceForManakaiDOMImplementationRegistry>)) {
                    $r-><M::DIS|PLBlockCon.appendStatement>
                          ('$Message::DOM::ManakaiDOMImplementationRegistry'.
                           '::SourceClass{q<' . $pack_name . '>} = 1');
                  }
                  if ($role-><M::DIS|DISResource.isSubsetOfURI>
            (<Q::DOMMetaImpl:ImplementationForManakaiDOMImplementationSource>)) {
                    $r-><M::DIS|PLBlockCon.appendStatement>
                          ('$Message::DOM::ManakaiDOMImplementationSource'.
                           '::SourceClass{q<' . $pack_name . '>} = 1');
                  }
                  if ($role-><M::DIS|DISResource.isSubsetOfURI>
   (<Q::DOMMetaImpl:ImplementationCompatibleWithManakaiDOMMinimumImplementation>)
                  ) {
                    $r-><M::DIS|PLBlockCon.appendStatement>
                          ('$Message::DOM::ManakaiDOMImplementation'.
                           '::CompatClass{q<' . $pack_name . '>} = 1');
                  }
                  
                  ## Node
                  if ($role-><M::DIS|DISResource.isSubsetOfURI>
                                (<Q::DOMCore:ElementRole>)) {
                    my $for_specific_et;
                    for my $et (@{$cls-><M::DIS|DISResourceProp
                          .getPropertyResourceList>
                             (<Q::s:elementType>, isa_recursive => true,
                              default_media_type => <Q::dis:TFQNames>)}) {
                      $for_specific_et = true;
                      my $ln = $et-><AG::DIS|DISResourceMV
                                        .mvLocalName>;
                      $ln = '*' unless defined $ln;
                      my $ns = $et-><AG::DIS|DISResourceMV
                                        .mvNamespaceURI>;
                      $ns = '' unless defined $ns;
                        ## ISSUE: Is NULL-namespace should be allowed here?
                      $r-><M::DIS|PLBlockCon.appendStatement>
                          ('$Message::DOM::ManakaiDOMElement' .
                           '::CompatClassET{q<' . $ns . '>}->{q<' . $ln .
                           '>}->{q<' . $pack_name . '>} = 1');
                    }
                    $r-><M::DIS|PLBlockCon.appendStatement>
                          ('$Message::DOM::ManakaiDOMElement'.
                           '::CompatClass{q<' . $pack_name . '>} = 1')
                      unless $for_specific_et;
                  }
                  if ($role-><M::DIS|DISResource.isSubsetOfURI>
                                (<Q::DOMCore:AttributeRole>)) {
                    my $for_specific_attr;
                    for my $at (@{$cls-><M::DIS|DISResourceProp
                          .getPropertyResourceList>
                             (<Q::dis:DocAttr>, isa_recursive => true,
                              default_media_type => <Q::dis:TFQNames>)}) {
                      $for_specific_attr = true;
                      my $ln = $at-><AG::DIS|DISResourceMV
                                        .mvLocalName>;
                      $ln = '*' unless defined $ln;
                      my $ns = $at-><AG::DIS|DISResourceMV
                                        .mvNamespaceURI>;
                      $ns = '' unless defined $ns;
                      my $et = $at-><AG::DIS|DISResourceMV
                                        .mvOwnerElementResource>;
                      my $etns = '*';
                      my $etln = '*';
                      if ($et) {
                        $etns = $et-><AG::DIS|DISResourceMV.mvLocalName>;
                        $etln = '*' unless defined $etln;
                        my $etns = $at-><AG::DIS|DISResourceMV
                                          .mvNamespaceURI>;
                        $etns = '' unless defined $etns;
                          ## ISSUE: Should NULL-namespace be allowed here?
                      }
                      
                      $r-><M::DIS|PLBlockCon.appendStatement>
                          ('$Message::DOM::ManakaiDOMElement' .
                           '::CompatClassAttr{q<' . $etns . '>}->{q<' . $etln .
                           '>}->{q<' . $ns . '>}->{q<' . $ln . '>}->{q<' .
                           $pack_name . '>} = 1');
                    }
                    $r-><M::DIS|PLBlockCon.appendStatement>
                          ('$Message::DOM::ManakaiDOMAttr'.
                           '::CompatClass{q<' . $pack_name . '>} = 1')
                      unless $for_specific_attr;
                  }
                  if ($role-><M::DIS|DISResource.isSubsetOfURI>
                                (<Q::DOMCore:TextRole>)) {
                    $r-><M::DIS|PLBlockCon.appendStatement>
                          ('$Message::DOM::ManakaiDOMText'.
                           '::CompatClass{q<' . $pack_name . '>} = 1');
                  }
                  if ($role-><M::DIS|DISResource.isSubsetOfURI>
                                (<Q::DOMCore:CommentRole>)) {
                    $r-><M::DIS|PLBlockCon.appendStatement>
                          ('$Message::DOM::ManakaiDOMComment'.
                           '::CompatClass{q<' . $pack_name . '>} = 1');
                  }
                  if ($role-><M::DIS|DISResource.isSubsetOfURI>
                                (<Q::DOMCore:CDATASectionRole>)) {
                    $r-><M::DIS|PLBlockCon.appendStatement>
                          ('$Message::DOM::ManakaiDOMCDATASection'.
                           '::CompatClass{q<' . $pack_name . '>} = 1');
                  }
                  if ($role-><M::DIS|DISResource.isSubsetOfURI>
                                (<Q::DOMCore:ProcessingInstructionRole>)) {
                    $r-><M::DIS|PLBlockCon.appendStatement>
                          ('$Message::DOM::ManakaiDOMProcessingInstruction'.
                           '::CompatClass{q<' . $pack_name . '>} = 1');
                    ## TODO: Target name dependent
                  }
                  if ($role-><M::DIS|DISResource.isSubsetOfURI>
                                (<Q::DOMCore:DocumentRole>)) {
                    my $for_specific_et;
                    for my $et (@{$cls-><M::DIS|DISResourceProp
                          .getPropertyResourceList>
                             (<Q::s:rootElementType>, isa_recursive => true,
                              default_media_type => <Q::dis:TFQNames>)}) {
                      $for_specific_et = true;
                      my $ln = $et-><AG::DIS|DISResourceMV
                                        .mvLocalName>;
                      $ln = '*' unless defined $ln;
                      my $ns = $et-><AG::DIS|DISResourceMV
                                        .mvNamespaceURI>;
                      $ns = '' unless defined $ns;
                        ## ISSUE: Is NULL-namespace should be allowed here?
                      $r-><M::DIS|PLBlockCon.appendStatement>
                          ('$Message::DOM::ManakaiDOMDocument' .
                           '::CompatClassET{q<' . $ns . '>}->{q<' . $ln .
                           '>}->{q<' . $pack_name . '>} = 1');
                    }
                    $r-><M::DIS|PLBlockCon.appendStatement>
                          ('$Message::DOM::ManakaiDOMDocument'.
                           '::CompatClass{q<' . $pack_name . '>} = 1')
                      unless $for_specific_et;
                    ## TODO: by document type name and media type
                  }
                  if ($role-><M::DIS|DISResource.isSubsetOfURI>
                                (<Q::DOMCore:DocumentFragmentRole>)) {
                    $r-><M::DIS|PLBlockCon.appendStatement>
                          ('$Message::DOM::ManakaiDOMDocumentFragment'.
                           '::CompatClass{q<' . $pack_name . '>} = 1');
                  }
                  if ($role-><M::DIS|DISResource.isSubsetOfURI>
                                (<Q::DOMCore:DocumentTypeRole>)) {
                    $r-><M::DIS|PLBlockCon.appendStatement>
                          ('$Message::DOM::ManakaiDOMDocumentType'.
                           '::CompatClass{q<' . $pack_name . '>} = 1');
                    ## TODO: Doctype name or public ID dependent
                  }
                  if ($role-><M::DIS|DISResource.isSubsetOfURI>
                                (<Q::DOMCore:EntityRole>)) {
                    $r-><M::DIS|PLBlockCon.appendStatement>
                          ('$Message::DOM::ManakaiDOMEntity'.
                           '::CompatClass{q<' . $pack_name . '>} = 1');
                    ## TODO: Entity name or public ID dependent
                  }
                  if ($role-><M::DIS|DISResource.isSubsetOfURI>
                                (<Q::DOMCore:EntityReferenceRole>)) {
                    $r-><M::DIS|PLBlockCon.appendStatement>
                          ('$Message::DOM::ManakaiDOMEntityReference'.
                           '::CompatClass{q<' . $pack_name . '>} = 1');
                    ## TODO: Entity name or public ID dependent
                  }
                  if ($role-><M::DIS|DISResource.isSubsetOfURI>
                                (<Q::DOMCore:NotationRole>)) {
                    $r-><M::DIS|PLBlockCon.appendStatement>
                          ('$Message::DOM::ManakaiDOMNotation'.
                           '::CompatClass{q<' . $pack_name . '>} = 1');
                    ## TODO: Notation name or public ID dependent
                  }
                  if ($role-><M::DIS|DISResource.isSubsetOfURI>
                                (<Q::DOMCore:NamespaceRole>)) {
                    $r-><M::DIS|PLBlockCon.appendStatement>
                          ('$Message::DOM::ManakaiDOMNamespace'.
                           '::CompatClass{q<' . $pack_name . '>} = 1');
                  }
                  ## NOTE: DOMCore:AnyNodeRole is subset of  
                  ##       DOMCore:ElementRole and DOMCore:TextRole and ...

                  if ($role-><M::DIS|DISResource.isSubsetOfURI>
                                (<Q::DOMLS:ParserRole>)) {
                    $r-><M::DIS|PLBlockCon.appendStatement>
                          ('$Message::DOM::DOMLS::ParserClass{q<'.
                           $pack_name . '>} = 1');
                  }
                  if ($role-><M::DIS|DISResource.isSubsetOfURI>
                                (<Q::DOMLS:SerializerRole>)) {
                    $r-><M::DIS|PLBlockCon.appendStatement>
                          ('$Message::DOM::DOMLS::SerializerClass{q<'.
                           $pack_name . '>} = 1');
                  }

                  if ($role-><M::DIS|DISResource.isSubsetOfURI>
                                (<Q::DIS:ModuleRole>)) {
                    $r-><M::DIS|PLBlockCon.appendStatement>
                          ('$Message::Util::DIS::ManakaiDISModuleDefinition'.
                           '::CompatClass{q<' . $pack_name . '>} = 1');
                  }
                  if ($role-><M::DIS|DISResource.isSubsetOfURI>
                                (<Q::DIS:ForRole>)) {
                    $r-><M::DIS|PLBlockCon.appendStatement>
                          ('$Message::Util::DIS::ManakaiDISForDefinition'.
                           '::CompatClass{q<' . $pack_name . '>} = 1');
                  }
                  if ($role-><M::DIS|DISResource.isSubsetOfURI>
                                (<Q::DIS:ResourceRole>)) {
                    $r-><M::DIS|PLBlockCon.appendStatement>
                          ('$Message::Util::DIS::ManakaiDISResourceDefinition'.
                           '::CompatClass{q<' . $pack_name . '>} = 1');
                  }
                  if ($role-><M::DIS|DISResource.isSubsetOfURI>
                                (<Q::DIS:ElementRole>)) {
                    $r-><M::DIS|PLBlockCon.appendStatement>
                          ('$Message::Util::DIS::ManakaiDISElement'.
                           '::CompatClass{q<' . $pack_name . '>} = 1');
                  }
                  if ($role-><M::DIS|DISResource.isSubsetOfURI>
                                (<Q::DIS:DatabaseRole>)) {
                    $r-><M::DIS|PLBlockCon.appendStatement>
                          ('$Message::Util::DIS::ManakaiDISDatabase'.
                           '::CompatClass{q<' . $pack_name . '>} = 1');
                  }
                }
              } elsif ($cls-><M::DIS|DISResource.isTypeURI>
                              (<Q::ManakaiDOM:ExceptionIF>)) {
                my $pack = $cls-><AG::DISResourcePerl.plCodeFragment>;
                $r-><M::DIS|PLFile.appendPackage> ($pack);
              } elsif ($cls-><M::DIS|DISResource.isTypeURI>
                              (<Q::DISPerl:ScalarVariable>) and
                       not $cls-><M::DIS|DISResourceProp
                           .getPropertyResource> (<Q::dis2pm:parentResource>)) {
                $r-><M::DIS|PLBlockCon.appendCodeFragment>
                      ($cls-><AG::DISResourcePerl.plCodeFragment>);
              }
            } # ownermodule and not alias
          } # Classes

          ## -- Exporter (constants)
          if (keys %const) {
            my $map = <ClassM::PLImplClass.perlLiteral> (\%const);
            $thismod_pack-><M::DIS|PLBlockCon.appendStatement> ("sub $_ ()")
              for keys %const;
            $thismod_pack-><M::DIS|PLPack.getSub> ('AUTOLOAD',
                                                   make_new_node => true)
              -><M::DIS|PLBlockCon.appendCode> (q[
                my $al = our $AUTOLOAD;
                $al =~ s/.+:://;
                if (] . $map . q[->{$al}) {
                  no strict 'refs';
                  *{$AUTOLOAD} = \&{] . $map . q[->{$al}};
                  goto &{$AUTOLOAD};
                } else {
                  require Carp;
                  Carp::croak (qq<Can't locate method "$AUTOLOAD">);
                }
              ]);
            $thismod_pack-><M::DIS|PLPack.getSub> ('import',
                                                   make_new_node => true)
              -><M::DIS|PLBlockCon.appendCode> (q[
                my $self = shift;
                if (@_) {
                  local $Exporter::ExportLevel = $Exporter::ExportLevel + 1;
                  $self->SUPER::import (@_);
                  for (grep {not /\W/} @_) {
                    eval qq{$_};
                  }
                }
              ]);
          }

          ## -- Require'ing external modules
          ## TODO: Custom module construction support
          for my $uri (@{$r-><M::DIS|MPLCodeFragment.disGetRequireURIList>}) {
            my $mod = $self->{db}-><M::DIS|DISDatabase.getResource> ($uri)
                           -><AG::DIS|DISAnyResource.ownerModule>;
            next unless $mod;
            my $pack = $mod-><AG::DISModulePerl.plFullyQualifiedName>;
            $r-><M::DIS|MPLCodeFragment.addRequirePerlModuleName> ($pack)
              unless $pack eq $thismod_name;
          }
        }__;

  @Method:
    @@Name: plIsFeatureImplemented
    @@enDesc:
      Returns whether a feature is implemented by this module
      or resource or not. 
      \
      {NOTE:: For modules, tests for features not provided
              by the modules will return <DOM::true>.  For 
              resources, if it does not provides the support
              for the feature, then this method will return <DOM::true>.
      \
      }
      \
      {NOTE:: Feature inheritances are not taken into account.
      \
      }
    @@Param:
      @@@Name:featureResourceURI
      @@@Type: DIS|ResourceURI
      @@@enDesc:
        The URI reference of the resource definition for 
        the feature to test.
    @@Return:
      @@@Type:
        DOMMain:boolean::ManakaiDOM:all
      @@@enDesc:
        Whether the feature is implemented or not.
      @@@PerlDef:
      __DEEP{
        if (defined $self->{<Q::DIS:isFeatureImplemented>}
                         ->{$featureResourceURI}) {
          $r = $self->{<Q::DIS:isFeatureImplemented>}
                         ->{$featureResourceURI};
        } elsif ($self->isa (<ClassName::DIS|ManakaiDISModuleDefinition>)) {
          $r = true;
          C: for my $cls (@{$self-><M::DIS|DISResourceProp
                                   .getPropertyResourceList>
                                      (<Q::DIS:resource>)}) {
            if ($cls-><M::DIS|DISResource.isTypeURI>
                                      (<Q::ManakaiDOM:Class>)) {
              unless ($cls-><M::DISResourcePerlModule
                               .plIsFeatureImplemented>
                                      ($featureResourceURI)) {
                $r = false;
                last C;
              }
            }                
            ## NOTE: DISPerl:ScalarVariable's are always implemented
          }
          $self->{<Q::DIS:isFeatureImplemented>}
                         ->{$featureResourceURI} = $r;
        } else { ## Resource definition
          ## TODO: Custom module definition
          if ($self-><M::DIS|DISResource.isFeatureProvided>
                              ($featureResourceURI)) {
            if ($self-><M::DIS|DISResource.isTypeURI>
                              (<Q::DISLang:MethodReturn>) or
                $self-><M::DIS|DISResource.isTypeURI>
                              (<Q::DISLang:AttributeGet>) or
                $self-><M::DIS|DISResource.isTypeURI>
                              (<Q::DISLang:AttributeSet>)) {
              my $def = $self-><M::DIS|DISResourceProp.getPropertyValue>
                                (<Q::dis:Def>);
              $r = $def-><AG::dv|DVList.length>;
            } else {
              $r = true;
              C: for my $res (@{$self-><M::DIS|DISResourceProp
                                     .getPropertyResourceList>
                              (<Q::DIS:childResource>)}) {
                if ($res-><M::DIS|DISResource.isTypeURI>
                              (<Q::DISLang:AnyMethod>)) {
                  unless ($res-><M::DISResourcePerlModule
                                 .plIsFeatureImplemented>
                              ($featureResourceURI)) {
                    $r = false;
                    last C;
                  }
                }
              } # for C
            } # self.type
          } else {
            $r = true;
          }
          $self->{<Q::DIS:isFeatureImplemented>}->{$featureResourceURI} = $r;
        }
      }__;
##DISResourcePerlModule

IFClsDef:
  @IFQName: DISResourcePerl
  @ClsQName: ManakaiDISResourcePerl

  @enDesc:
    The objects implementing the <IF::DISResourcePerl> interface
    <kwd:MUST> also implement the <IF::DIS|DISResource> interface.

  @Attr:
    @@Name: plName
    @@enDesc:
      The Perl name of this resource. 
    @@Get: 
      @@@Type:
        DISLang:String::ManakaiDOM:all
      @@@enDesc:
        - <Q::ManakaiDOM:Const>::: Constant function (local) name. 
        \
        - <Q::ManakaiDOM:ConstGroup>::: Export group name (without 
                                        <CHAR::COLON> prefix).
        \
        - <Q::DISLang:Attribute>::: Method name. 
        \
        - <Q::DISLang:Method>::: Method name. 
      @@@nullCase:
        @@@@enDesc:
          Either the type of this resource is not listed above 
          or this Perl constructure is anonymous. 
      @@@RaiseException:
        @@@@@: DIS|NO_LOCAL_NAME_ERR
        @@@@enDesc:
          The type of this resource is either 
          <Q::ManakaiDOM:Const> or <Q::ManakaiDOM:ConstGroup> and 
          the local name of this resource is not defined. 
      @@@RaiseException:
        @@@@@: DIS|RESERVED_PERL_METHOD_NAME_ERR
        @@@@enDesc:
          The Perl method name constructed from the source 
          result in a reserved name. 
      @@@PerlDef:
        __DEEP{
          if (exists $self->{<Q::dis2pm:name>}) {
            $r = $self->{<Q::dis2pm:name>};
          } elsif ($self-><M::DIS|DISResource.isTypeURI>
                              (<Q::DISLang:AnyMethod>)) {
            
            $r = $self-><M::DIS|DISResourceProp.getPropertyText>
                              (<Q::dis:AppName>, null);
            if (defined $r) {
              if ($self-><M::DIS|DISResourceProp.getPropertyBoolean>
                                (<Q::ManakaiDOM:isForInternal>, false)) {
                $r = '_' . $r;
              }
              ## No reserved name checks
            } elsif (defined (my $ln = $self-><AG::DIS|DISAnyResource
                                                             .localName>)) {
              $r = <ClassM::DIS|ManakaiDISImplementation
                           .camelCaseToUnderscoreName> ($ln);
              if ($self-><M::DIS|DISResourceProp.getPropertyBoolean>
                                (<Q::ManakaiDOM:isForInternal>, false)) {
                $r = '_' . $r;
              }
              if ({
                    import => 1,
                    unimport => 1,
                    isa => 1,
                    can => 1,
                    new => 1,
                    as_string => 1,
                    stringify => 1,
                    clone => 1,
                  }->{$r} or $r =~ /^___/) {
                __UNDEEP{
                  __EXCEPTION{DIS|RESERVED_PERL_METHOD_NAME_ERR::
                    DIS:uri => {$self->{uri}},
                    DIS:sourceNode => {$self->{src}},
                    DIS:generatedName => {$r},
                  }__;
                }__;
              }
            } elsif (my $op_uri = $self-><AG::DISResourcePerl
                                                  .plMethodOperator>) {
                $r = {
                       <Q::ManakaiDOM:MUErrorHandler> => '___report_error',
                       <Q::ecore:ErrorDefMethod> => '___error_def',
                       <Q::DISPerl:AsStringMethod> => 'stringify',
                       <Q::DISPerl:NewMethod> => 'new',
                       <Q::DISPerl:CloneMethod> => 'clone',
                       <Q::DISPerl:ImportMethod> => 'import',
                       <Q::DISPerl:CanMethod> => 'can',
                       <Q::DISPerl:UnimportMethod> => 'unimport',
                       <Q::DISPerl:VERSIONMethod> => 'VERSION',
                       <Q::DISPerl:ISAMethod> => 'isa',
                     }->{$op_uri};
                $r = $op_uri if $op_uri =~ /^[A-Z]+$/;
            } else {
              $r = null;
            }
          } elsif ($self-><M::DIS|DISResource.isTypeURI>
                              (<Q::ManakaiDOM:Const>)) {
            unless (defined $self->{localName}) {
              __UNDEEP{
                __EXCEPTION{DIS|NO_LOCAL_NAME_ERR::
                  DIS:uri => {$self-><AG::DIS|DISAnyResource.uri>},
                  DIS:sourceNode => {$self-><AG::DIS|DISAnyResource
                                                .sourceElement>},
                }__;
              }__;
            }
            $r = uc $self->{localName};
            if ($r =~ /^_/ or $r =~ /_$/) {
              __UNDEEP{
                __EXCEPTION{DIS|RESERVED_PERL_METHOD_NAME_ERR::
                  DIS:uri => {$self-><AG::DIS|DISAnyResource.uri>},
                  DIS:localName => {$self-><AG::DIS|DISAnyResource.localName>},
                  DIS:sourceNode => {$self-><AG::DIS|DISAnyResource
                                                              .sourceElement>},
                  DIS:generatedName => {$r},
                }__;
              }__;
            }
          } elsif ($self-><M::DIS|DISResource.isTypeURI>
                              (<Q::ManakaiDOM:ConstGroup>)) {
            $r = $self-><M::DIS|DISResourceProp.getPropertyText>
                              (<Q::dis:AppName>,
                               $self-><AG::DIS|DISAnyResource.localName>);
            unless (defined $r) {
              __UNDEEP{__EXCEPTION{DIS|NO_LOCAL_NAME_ERR::
                DIS:uri => {$self->{uri}},
                DIS:sourceNode => {$self->{src}},
              }__}__;
            }

          ## -- Method parameter
          } elsif ($self-><M::DIS|DISResource.isTypeURI>
                                       (<Q::DISLang:MethodParameter>)) {
            $r = $self-><M::DIS|DISResourceProp.getPropertyText>
                                (<Q::dis:AppName>,
                                 $self-><AG::DIS|DISAnyResource.localName>);
            if (defined $r) {
              if ($self-><M::DIS|DISResourceProp.getPropertyBoolean>
                                 (<Q::DISPerl:isNamedParameter>, false)) {
                $r = 
                 <ClassM::DIS|ManakaiDISImplementation.camelCaseToUnderscoreName>
                                                       ($r);
              }
            }

          } else {  ## Other types
            $r = null;
          }
          $self->{<Q::dis2pm:name>} = $r;
        }__;

  @Attr:
    @@Name: plFullyQualifiedName
    @@enDesc:
      The fully-qualified Perl name of this resource. 
    @@Type:
      DISLang:String::ManakaiDOM:all
    @@Get:
      @@@enDesc:
        Fully-qualified name.
        \
        - <Q::ManakaiDOM:Class>::: Class package name. 
        \
        - <Q::ManakaiDOM:IF>::: Interface package name. 
        \
        - <Q::DISPerl:ScalarVariable>::: Variable name (without variable
                                type symbol such as <CODE::$>). 
      @@@nullCase:
        @@@@enDesc:
          Otherwise. 
      @@@NoPerlModuleNameException:
      @@@RaiseException:
        @@@@@: DIS|NO_LOCAL_NAME_ERR
        @@@@enDesc:
          The local name of this resource is not defined. 
      @@@PerlDef:
        __DEEP{
          if (exists $self->{<Q::PerlCode:plFullyQualifiedName>}) {
            $r = $self->{<Q::PerlCode:plFullyQualifiedName>};
          } elsif ($self-><M::DIS|DISResource.isTypeURI>
                              (<Q::DISLang:AnyClass>) or
                   $self-><M::DIS|DISResource.isTypeURI>
                              (<Q::DISPerl:ScalarVariable>)) {
            $r = $self-><M::DIS|DISResourceProp.getPropertyText>
                              (<Q::dis:AppName>);
            if (defined $r) {
              ## NOTE: "lang:Perl" is fully-qualified name by definition
            } else {
              unless (defined $self->{localName}) {
                __UNDEEP{
                  __EXCEPTION{DIS|NO_LOCAL_NAME_ERR::
                    DIS:sourceNode => {$self->{src}},
                  }__;
                }__;
              }
              if ($self-><M::DIS|DISResource.isTypeURI>
                              (<Q::ManakaiDOM:IF>)) {
                $r = $self-><AG::DIS|DISAnyResource.ownerModule>
                          -><AG::DISModulePerl.plInterfaceName>
                   . '::' . $self->{localName};
              } else {
                $r = $self-><AG::DIS|DISAnyResource.ownerModule>
                          -><AG::DISModulePerl.plFullyQualifiedName>
                   . '::' . $self->{localName};
              }
            }
          } elsif ($self-><M::DIS|DISResource.isTypeURI>
                              (<Q::ManakaiDOM:Const>)) {
            $r = $self-><AG::DIS|DISAnyResource.ownerModule>
                      -><AG::DISModulePerl.plFullyQualifiedName>
               . '::' . $self-><AG::DISResourcePerl.plName>;
          } else {
            $r = null;
          }
          $self->{<Q::PerlCode:plFullyQualifiedName>} = $r;
        }__;

  @Attr:
    @@Name: plVariableName
    @@enDesc:
      The Perl variable name with prefix.
    @@Type:
      lang:Perl::ManakaiDOM:all
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          This resource does not define any Perl variable.
      @@@PerlDef:
        $r = $self-><M::DIS|DISResourceProp.getPropertyText>
                      (<Q::dis:AppName>,
                       $self-><AG::DIS|DISAnyResource.localName>);
        if (defined $r) {
          __DEEP{
            if ($self-><M::DIS|DISResourceProp.getPropertyBoolean>
                                 (<Q::DISPerl:isNamedParameter>, false)) {
              $r = '$opt{' . 
                 <ClassM::DIS|ManakaiDISImplementation.camelCaseToUnderscoreName>
                                                       ($r) .
                   '}';
            } else {
              my $dt = $self-><AG::DIS|DISResource
                                 .disActualDataTypeResource>;
              if ($dt-><M::DIS|DISResource.isSubsetOfURI>
                                                       (<Q::pl:Array>)) {
                $r = '@' . $r;
              } elsif ($dt-><M::DIS|DISResource.isSubsetOfURI>
                                                       (<Q::pl:Hash>)) {
                $r = '%' . $r;
              } else {
                $r = '$' . $r;
              }
            }
          }__;
        }

  @Attr:
    @@Name: plPrototype
    @@enDesc:
      The Perl parameter prototype character.
    @@Type:
      lang:Perl::ManakaiDOM:all
    @@Get:
      @@@PerlDef:
          __DEEP{
            my $dt = $self-><AG::DIS|DISResource
                                 .disActualDataTypeResource>;
            if ($dt-><M::DIS|DISResource.isSubsetOfURI>
                                                       (<Q::pl:Array>)) {
              $r = '@' . $r;
            } elsif ($dt-><M::DIS|DISResource.isSubsetOfURI>
                                                       (<Q::pl:Hash>)) {
              $r = '%' . $r;
            } else {
              $r = '$' . $r;
            }
          }__;

  @Attr:
    @@Name: plMethodOperator
    @@enDesc:
      The operator to overload by this method. 
    @@Type:
      DISLang:String::ManakaiDOM:all
    @@Get:
      @@@enDesc:
        The operator, either Perl <CODE::use operator> operator name
        of manakai operator URI reference. 
      @@@nullCase:
        @@@@enDesc:
          Either this resource does not define a Perl method or 
          this method does not overload any operator. 
      @@@UndeclaredPrefixException:
      @@@RaiseException:
        @@@@@: DIS|UNSUPPORTED_MEDIA_TYPE_ERR
        @@@@enDesc:
          Media type of the <Q::dis:Operator> node is not supported. 
      @@@PerlDef:
        __DEEP{
            my $op_node = $self-><M::DIS|DISResourceProp.getPropertyValue>
                             (<Q::dis:Operator>);
            if ($op_node) {
              if ($op_node->isa (<IFName::dv|DVURIValue>)) {
                $r = $op_node-><AG::dv|DVURIValue.uri>;
              } else {
                $r = $op_node-><AG::dv|DVValue.stringValue>;
              }
            } else {
              $r = null;
            }
        }__;

  @Attr:
    @@Name: plCodeFragment
    @@enDesc:
      Perl code definition fragment of this resource. 
    @@Type: DIS|MPLCodeFragment
    @@Get:
      @@@enDesc:
        Perl code.
      @@@nullCase:
        @@@@enDesc:
          This node does not have Perl code definition. 
      @@@RaiseException:
        @@@@@: DIS|NO_METHOD_RETURN_ERR
        @@@@enDesc:
          This resource is a <Q::DISLang:Method> but it does not 
          have <Q::DISLang:MethodReturn> child-resource. 
      @@@RaiseException:
        @@@@@: DIS|NO_ATTR_GET_ERR
        @@@@enDesc:
          This resource is a <Q::DISLang:Attribute> but it does not 
          have <Q::DISLang:AttributeGet> child-resource.
      @@@RaiseException:
        @@@@@: DIS|UNSUPPORTED_MEDIA_TYPE_ERR
        @@@@enDesc:
          The media type of <Q::dis:Def> element is not supported.
      @@@RaiseException:
        @@@@@: DIS|NON_NAMED_PARAMETER_AFTER_NAMED_ERR
        @@@@enDesc:
          A non-named method paarameter is defined after
          a named method parameter appeared.
      @@@disPerlException:
      @@@InlineElementException:
      @@@BlockElementException:
      @@@RaiseException:
        @@@@@: DIS|PERL_SUBROUTINE_ALREADY_DEFINED_ERR
        @@@@enDesc:
          A resource defines a Perl subroutine whose name is
          same as the name of another subroutine. 
      @@@RaiseException:
        @@@@@: DIS|PERL_OPERATOR_ALREADY_OVERLOADED_ERR
        @@@@enDesc:
          A resource is defined to overload an operator 
          that is also defined to be overloaded by another resource.
      @@@RaiseException:
        @@@@@: DIS|PERL_UNUSED_SUBROUTINE_ERR
        @@@@enDesc:
          A resource defines a Perl subroutine which is not
          used anywhere.
      @@@RaiseException:
        @@@@@: DIS|NO_REFLECT_GET_DEFINED_ERR
        @@@@enDesc:
          An attribute is defined to reflect an element attribute
          but no reflecting attribute getter template is defined.
      @@@RaiseException:
        @@@@@: DIS|NO_REFLECT_SET_DEFINED_ERR
        @@@@enDesc:
          An attribute is defined to reflect an element attribute
          but no reflecting attribute setter template is defined.
      @@@PerlDef:
        __DEEP{
          if (exists $self->{<Q::DIS|plCodeFragment>}) {
            $r = $self->{<Q::DIS|plCodeFragment>};
          } elsif ($self-><M::DIS|DISResource.isTypeURI>
                                (<Q::DISLang:MethodReturn>) or
                   $self-><M::DIS|DISResource.isTypeURI>
                                (<Q::DISLang:AttributeGet>) or
                   $self-><M::DIS|DISResource.isTypeURI>
                                (<Q::DISLang:AttributeSet>) or
                   $self-><M::DIS|DISResource.isTypeURI>
                                (<Q::dis2pm:BlockCode>) or
                   $self-><M::DIS|DISResource.isTypeURI>
                                (<Q::dis2pm:InlineCode>) or
                   $self-><M::DIS|DISResource.isTypeURI>
                                (<Q::DISLang:InputProcessor>) or
                   $self-><M::DIS|DISResource.isTypeURI>
                                (<Q::DOMMain:ReflectGet>) or
                   $self-><M::DIS|DISResource.isTypeURI>
                                (<Q::DOMMain:ReflectSet>)) {
            $self->{<Q::DIS|plCodeFragment>} = null;  ## To avoid loop
            my $def = $self-><M::DIS|DISResourceProp.getPropertyValue>
                                (<Q::dis:Def>);
            $def = $def->[0] if $def;
            my $is_inline = $self-><M::DIS|DISResource.isTypeURI>
                                (<Q::dis2pm:InlineCode>) ? true : false;
            unless ($def) {
              $r = null;
            } elsif ($def-><AG::dv|DVValue.dataType> eq <Q::lang:Perl>) {
              my $source_code = $def-><AG::dv|DVValue.stringValue>;
              my $source_node = $def-><AG::dv|DVValue.sourceNodePath>;
              $r = $self->{<Q::DIS|plCodeFragment>}
                 = $is_inline
                     ? $self-><M::DISResourcePerl.plPreprocessPerlStatement>
                                           ($source_code,
                                            contains_statements => false,
                                            source_file => $source_node,
                                            source_line => 1,
                                            namespace_context => $def)
                     : $self-><M::DISResourcePerl
                             .plPreprocessPerlCode>
                                   ($source_code,
                                    method_resource => 
                                ($self-><M::DIS|DISResource
                                          .isTypeURI> (<Q::DISLang:MethodReturn>)
                                ? $self-><M::DIS|DISResourceProp
                                            .getPropertyResource>
                                                   (<Q::dis2pm:parentResource>)
                                : null),
                                source_file => $source_node,
                                source_line => 1,
                                            namespace_context => $def);
            } elsif ($def-><AG::dv|DVValue.dataType> eq <Q::lang:dis>) {
              $r = $self->{<Q::DIS|plCodeFragment>}
                 = $def-><AG::dv|DVValue.value>
                       -><M::DISElementPerl.plCodeFragment>
                            ($self, for_arg => $self->{for},
                             forp_arg => $self->{forp},
                             contains_statements => not $is_inline); 
            } else {
              __UNDEEP{
                __EXCEPTION{DIS|UNSUPPORTED_MEDIA_TYPE_ERR::
                  DIS:uri => {$def-><AG::dv|DVValue.dataType>},
                  DIS:sourceNode => {$def},
                }__;
              }__;
            } # media type
          } elsif ($self-><M::DIS|DISResource.isTypeURI>
                                (<Q::DISLang:Method>)) {
            $self->{<Q::DIS|plCodeFragment>} = null;  ## To avoid loop
            my $ret = $self-><M::DIS|DISResource
                            .getChildResourceByType> (<Q::DISLang:MethodReturn>);
            unless ($ret) { 
              __UNDEEP{
                __EXCEPTION{DIS|NO_METHOD_RETURN_ERR::
                  DIS:errResource => {$self},
                  DIS:sourceNode => {$self->{src}},
                  DIS:uri => {$self->{uri}},
                  DIS:localName => {$self->{localName}},
                }__;
              }__;
            }
            my $plimpl = $self-><AG::DISAnyResourcePerl.plImplementation>;
            $r = $self->{<Q::DIS|plCodeFragment>}
               = $plimpl-><M::DIS|MPLImpl.createPerlSub>
                            ($self-><AG::DISResourcePerl.plName>);
            
            ## Method parameters
            my $params = $self-><M::DIS|DISResourceProp
                                   .getPropertyResourceList>
                                        (<Q::DIS:childResource>);
            my @param_variables;
            my @named_param_variables;
            my $prototype = '$';
            my $is_optional_param = false;
            my $is_named_param = false;
            for my $param (@$params) {
              next unless $param-><M::DIS|DISResource.isTypeURI>
                                        (<Q::DISLang:MethodParameter>);
              unless ($is_named_param) {
                if ($param-><M::DIS|DISResourceProp.getPropertyBoolean>
                                 (<Q::DISPerl:isNamedParameter>, false)) {
                  $is_named_param = true;
                  $is_optional_param = true;
                  push @param_variables, ['%opt'];
                  $prototype .= '%';
                } else {  ## Non-named parameter
                  push @param_variables, [
                    $param-><AG::DISResourcePerl.plVariableName>,
                  ];
                  if ($param-><AG::DISResourcePerl.plIsNullable>) {
                    $prototype .= ';' unless $is_optional_param;
                    $is_optional_param = true;
                  }
                  $prototype .= $param-><AG::DISResourcePerl.plPrototype>;
                  my $param_processor
                        = $param-><M::DISResourcePerl
                                                 .plGetMethodInputNormalizer>;
                  if ($param_processor) {
                    $param_variables[-1]->[1]
                        = $param_processor-><AG::DISResourcePerl
                                                 .plCodeFragment>->clone;
                    $param_variables[-1]->[1]
                                   -><M::DIS|MPLCodeFragment.replaceVariable>
                                         ('$INPUT' => $param_variables[-1]->[0]);
                  }
                }
              } else { ## Named parameter
                unless ($param-><M::DIS|DISResourceProp
                                   .getPropertyBoolean>
                                      (<Q::DISPerl:isNamedParameter>, false)) {
                  __UNDEEP{__EXCEPTION{DIS|NON_NAMED_PARAMETER_AFTER_NAMED_ERR::
                    DIS:sourceNode => {$param->{src}},
                    DIS:uri => {$param->{uri}},
                    DIS:localName => {$param->{localName}},
                  }__}__;
                }
              }
              if ($is_named_param) {
                push @named_param_variables, [
                  $param-><AG::DISResourcePerl.plVariableName>,
                  null,
                  '$' . $param-><AG::DIS|DISAnyResource.localName>,
                ];
                my $param_processor
                        = $param-><M::DISResourcePerl
                                                 .plGetMethodInputNormalizer>;
                if ($param_processor) {
                  $named_param_variables[-1]->[1]
                        = $param_processor-><AG::DISResourcePerl
                                                 .plCodeFragment>->clone;
                  $named_param_variables[-1]->[1]
                                   -><M::DIS|MPLCodeFragment.replaceVariable>
                                         ('$INPUT' => $param_variables[-1]->[0]);
                }
              }
            } # %$params
            
            $r-><AS::DIS|MPLSub.prototype> ($prototype);
            $r-><M::DIS|MPLSS.appendCodeFragment>
                   ($plimpl-><M::DIS|MPLImpl.createPerlStatement>
                          ('my (' . join (', ', '$self',
                             map {$_->[0]} @param_variables) . ') = @_'));
            for my $p (@param_variables, @named_param_variables) {
              if ($p->[1]) {  ## Input processor
                $r-><M::DIS|MPLSS.appendCodeFragment> ($p->[1]);
              }
            }
 
            ## TODO: in/out
            
            ## Return value
            my $data_type;
            try {
              $data_type = $ret-><AG::DIS|DISResource
                                     .disActualDataTypeResource>;
            } catch <IF::DIS|DISException> with {
              my $err = shift;
              if ($err->{<Q::MDOMX:subtype>} ne <Q::DIS|NO_DIS_TYPE_ERR>) {
                $err->throw;
              }
            };

            if ($data_type) {
              my $def = $data_type-><M::DIS|DISResourceProp.getPropertyValue>
                                          (<Q::dis:DefaultValue>);
              my $rs = $plimpl-><M::DIS|MPLImpl.createPerlStatement>;
              my $rvar = $plimpl-><M::DIS|MPLImpl.createPerlVariable>
                                               ('$', null, 'r');
              $rvar-><AS::PerlCode:ManakaiPerlVariable::ManakaiDOM:Perl
                               .variableScope> ('my');
              if ($def) {
                $def = $def-><M::DVValuePerl.plCodeFragment>
                               ($self,
                                data_type_uri => $data_type
                                       -><AG::DIS|DISAnyResource.uri>);
                $rs-><M::DIS|PLAnyCon.appendNewAssignment> ($rvar => $def);
              } else {
                __CODE{setDefaultValue::
                  $result => $def,
                  $data_type => $data_type,
                  $plimpl => $plimpl,
                }__;
                if ($def) {
                  $rs-><M::DIS|PLAnyCon.appendNewAssignment> ($rvar => $def);
                } else {
                  $rs-><M::DIS|PLInCon.appendCodeFragment> ($rvar);
                }
              }
              $r-><M::DIS|MPLSS.appendCodeFragment> ($rs);
            }

            my $code = $ret-><AG::DISResourcePerl.plCodeFragment>;
            if ($code) {
              for my $np (@named_param_variables) {
                $code-><M::DIS|MPLCodeFragment.replaceVariable>
                             ($np->[2] => $np->[0]);
              }
              $r-><M::DIS|MPLSS.appendCodeFragment> ($code);

              $ret->{<Q::DIS:plDefined>} = true;
              $self->{<Q::DIS:plDefined>} = true;
            } else {  ## Method code not defined
              my $cls = $self->{db}-><M::DIS|DISDatabase.getResource>
                                              (<Q::DOMException:CoreException>,
                                               for_arg => <Q::ManakaiDOM:Perl>);
              my $const = $self->{db}-><M::DIS|DISDatabase.getResource>
                                          (<Q::DOMException:NOT_SUPPORTED_ERR>,
                                               for_arg => <Q::ManakaiDOM:Perl>);
              my $subtype = $self->{db}-><M::DIS|DISDatabase.getResource>
                                  (<Q::MDOMX:MDOM_IMPL_METHOD_NOT_IMPLEMENTED>,
                                               for_arg => <Q::ManakaiDOM:Perl>);
              $_-><AS::DIS|DISAnyResource.isReferred>
                 ($ret-><AG::DIS|DISAnyResource.uri>) for $cls, $const, $subtype;
              my $context_param = $ret-><M::ManakaiDISResourcePerl
                                             .plGetContextParameter>;
              $self-><M::ManakaiDISResourcePerl.plAppendThrow>
                               ($r, $cls, $const, $subtype,
                                {%$context_param});
              $ret->{<Q::DIS:plDefined>} = false;
              $self->{<Q::DIS:plDefined>} = false;
            }

            if ($data_type) {
              $r-><M::DIS|MPLSS.appendCodeFragment>
                     ($plimpl-><M::DIS|MPLImpl.createPerlVariable>
                                               ('$', null, 'r'));
            }
          } elsif ($self-><M::DIS|DISResource.isTypeURI>
                                (<Q::DISLang:Attribute>)) {  
            $self->{<Q::DIS|plCodeFragment>} = null;  ## To avoid loop
            my $get = $self-><M::DIS|DISResource
                            .getChildResourceByType> (<Q::DISLang:AttributeGet>);
            unless ($get) { 
              __UNDEEP{
                __EXCEPTION{DIS|NO_ATTR_GET_ERR::
                  DIS:errResource => {$self},
                  DIS:sourceNode => {$self->{src}},
                }__;
              }__;
            }
            my $da; ## Reflecting element attribute
            my $plimpl = $self-><AG::DISAnyResourcePerl.plImplementation>;
            my $data_type = $get-><AG::DIS|DISResource
                                      .disActualDataTypeResource>;
            my $get_code = $plimpl-><M::DIS|MPLImpl.createPerlBlockContainer>;
            $get_code-><M::DIS|PLBlockCon.appendStatement> (q<my ($self) = @_>);
            my $code = $get-><AG::DISResourcePerl.plCodeFragment>;
            unless ($code) {
              $da = $self-><M::DIS|DISResourceProp.getPropertyResource>
                                 (<Q::dis:DocAttr>,
                                  default_media_type => <Q::DISCore:TFPQNames>);
              if ($da) {  ## Reflecting an element attribute
                my $data_type_node = $get-><AG::DIS|DISResource
                                               .disActualDataTypeValue>;
                my $daget_node = $data_type_node-><M::dv|DVValue.getProperty>
                                              (<Q::DOMMain:reflectGet>);
                ## TODO: More work might be required for 
                ##       default values for element attributes.
                my $daget;
                if (UNIVERSAL::isa ($daget_node, <IFName::dv|DVURIValue>)) {
                  $daget = $daget_node-><M::dv|DVURIValue.getResource>
                            ($self-><AG::DIS|DISAnyResource.database>);
                } else {
                  $daget = $data_type-><M::DIS|DISResource
                              .getChildResourceByType> (<Q::DOMMain:ReflectGet>);
                }
                if ($daget) {
                  $code = $daget-><AG::DISResourcePerl.plCodeFragment>->clone;
                  my $ln = $da-><AG::DIS|DISResourceMV.mvLocalName>;
                  my $pfx = $da-><AG::DIS|DISResourceMV.mvPrefix>;
                  $pfx = defined $pfx ? $pfx . ':' : '';
                  $code-><M::DIS|MPLCodeFragment.replaceVariable>
                         ('$LOCAL_NAME' => $plimpl-><M::DIS|MPLImpl
                                              .createPerlStringLiteral> ($ln));
                  $code-><M::DIS|MPLCodeFragment.replaceVariable>
                         ('$QNAME' => $plimpl-><M::DIS|MPLImpl
                                           .createPerlStringLiteral> ($pfx.$ln));
                  $code-><M::DIS|MPLCodeFragment.replaceVariable>
                         ('$PREFIX' => $plimpl-><M::DIS|MPLImpl
                                           .createPerlStringLiteral> ($pfx));
                  my $nsuri = $da-><AG::DIS|DISResourceMV
                                           .mvNamespaceURI>;
                  $code-><M::DIS|MPLCodeFragment.replaceVariable>
                         ('$NS_URI' => defined $nsuri
                                       ? $plimpl-><M::DIS|MPLImpl
                                              .createPerlStringLiteral> ($nsuri)
                                       : $plimpl-><M::DIS|MPLImpl
                                              .createPerlAtom> ('undef'));
                  $code-><M::DIS|MPLCodeFragment.replaceVariable>
                         ('$NS_URI_NO_NULL' => defined $nsuri
                                       ? $plimpl-><M::DIS|MPLImpl
                                              .createPerlStringLiteral> ($nsuri)
                                       : $plimpl-><M::DIS|MPLImpl
                                         .createPerlStringLiteral> (<Q::null:>));
                } else {
                  __UNDEEP{__EXCEPTION{DIS|NO_REFLECT_GET_DEFINED_ERR::
                    DIS:sourceNode => {$self->{src}},
                    DIS:uri => {$data_type->{uri}},
                  }__}__;
                }
              }
            }
            if ($code) {
              ## Default value
              my $def = $get-><M::DIS|DISResourceProp.getPropertyValue>;
              if ($def) {
                $def = $def-><M::DVValuePerl.plCodeFragment>
                            ($self,
                             data_type_uri => $data_type
                                    -><AG::DIS|DISAnyResource.uri>);
              } else {
                __CODE{setDefaultValue::
                  $result => $def,
                  $data_type => $data_type,
                  $plimpl => $plimpl,
                }__;
              }
              my $rs = $plimpl-><M::DIS|MPLImpl.createPerlStatement>;
              my $rvar = $plimpl-><M::DIS|MPLImpl.createPerlVariable>
                                               ('$', null, 'r');
              $rvar-><AS::PerlCode:PerlVariable::ManakaiDOM:Perl
                                 .variableScope> ('my');
              if ($def) {
                $rs-><M::DIS|PLAnyCon.appendNewAssignment> ($rvar => $def);
              } else {
                $rs-><M::DIS|PLInCon.appendCodeFragment> ($rvar);
              }
              $get_code-><M::DIS|PLBlockCon.appendCodeFragment> ($rs);

              ## Main code
              $get_code-><M::DIS|PLBlockCon.appendCodeFragment> ($code);

              ## Return value
              $get_code-><M::DIS|PLBlockCon.appendStatement> (q<$r>);

              $get->{<Q::DIS:plDefined>} = true;
            } else {  ## Getter code not defined
              my $cls = $self->{db}-><M::DIS|DISDatabase.getResource>
                                              (<Q::DOMException:CoreException>,
                                               for_arg => <Q::ManakaiDOM:Perl>);
              my $const = $self->{db}-><M::DIS|DISDatabase.getResource>
                                          (<Q::DOMException:NOT_SUPPORTED_ERR>,
                                               for_arg => <Q::ManakaiDOM:Perl>);
              my $subtype = $self->{db}-><M::DIS|DISDatabase.getResource>
                                    (<Q::MDOMX:MDOM_IMPL_ATTR_NOT_IMPLEMENTED>,
                                               for_arg => <Q::ManakaiDOM:Perl>);
              $_-><AS::DIS|DISAnyResource.isReferred>
                 ($get-><AG::DIS|DISAnyResource.uri>) for $cls, $const, $subtype;
              my $context_param = $get-><M::ManakaiDISResourcePerl
                                        .plGetContextParameter>;
              $self-><M::ManakaiDISResourcePerl.plAppendThrow>
                               ($get_code, $cls, $const, $subtype,
                                {%$context_param});
              $get->{<Q::DIS:plDefined>} = false;
              $self->{<Q::DIS:plDefined>} = false;
            }

            my $set = $self-><M::DIS|DISResource
                            .getChildResourceByType> (<Q::DISLang:AttributeSet>);
            my $set_code = $plimpl-><M::DIS|MPLImpl.createPerlBlockContainer>;
            if ($set) {
              my $data_type = $set-><AG::DIS|DISResource
                                       .disActualDataTypeResource>;
              my $code = $set-><AG::DISResourcePerl.plCodeFragment>;
              unless ($code) {
                $da ||= $self-><M::DIS|DISResourceProp
                                  .getPropertyResource>
                                 (<Q::dis:DocAttr>,
                                  default_media_type => <Q::DISCore:TFPQNames>);
                if ($da) {  ## Reflecting an element attribute
                  my $data_type_node = $set-><AG::DIS|DISResource
                                               .disActualDataTypeValue>;
                  my $daset_node = $data_type_node-><M::dv|DVValue.getProperty>
                                              (<Q::DOMMain:reflectSet>);
                  my $daset;
                  if (UNIVERSAL::isa ($daset_node, <IFName::dv|DVURIValue>)) {
                    $daset = $daset_node-><M::dv|DVURIValue.getResource>
                                ($self-><AG::DIS|DISAnyResource.database>);
                  } else {
                    $daset = $data_type-><M::DIS|DISResource
                              .getChildResourceByType> (<Q::DOMMain:ReflectSet>);
                  }
                  if ($daset) {
                    $code = $daset-><AG::DISResourcePerl.plCodeFragment>->clone;
                    my $ln = $da-><AG::DIS|DISResourceMV.mvLocalName>;
                    my $pfx = $da-><AG::DIS|DISResourceMV.mvPrefix>;
                    $pfx = defined $pfx ? $pfx . ':' : '';
                    $code-><M::DIS|MPLCodeFragment.replaceVariable>
                         ('$LOCAL_NAME' => $plimpl-><M::DIS|MPLImpl
                                              .createPerlStringLiteral> ($ln));
                    $code-><M::DIS|MPLCodeFragment.replaceVariable>
                         ('$QNAME' => $plimpl-><M::DIS|MPLImpl
                                           .createPerlStringLiteral> ($pfx.$ln));
                    $code-><M::DIS|MPLCodeFragment.replaceVariable>
                         ('$PREFIX' => $plimpl-><M::DIS|MPLImpl
                                           .createPerlStringLiteral> ($pfx));
                    my $nsuri = $da-><AG::DIS|DISResourceMV
                                           .mvNamespaceURI>;
                    $code-><M::DIS|MPLCodeFragment.replaceVariable>
                         ('$NS_URI' => defined $nsuri
                                       ? $plimpl-><M::DIS|MPLImpl
                                              .createPerlStringLiteral> ($nsuri)
                                       : $plimpl-><M::DIS|MPLImpl
                                              .createPerlAtom> ('undef'));
                    $code-><M::DIS|MPLCodeFragment.replaceVariable>
                         ('$NS_URI_NO_NULL' => defined $nsuri
                                       ? $plimpl-><M::DIS|MPLImpl
                                              .createPerlStringLiteral> ($nsuri)
                                       : $plimpl-><M::DIS|MPLImpl
                                         .createPerlStringLiteral> (<Q::null:>));
                  } else {
                    __UNDEEP{__EXCEPTION{DIS|NO_REFLECT_SET_DEFINED_ERR::
                      DIS:sourceNode => {$self->{src}},
                      DIS:uri => {$data_type->{uri}},
                    }__}__;
                  }
                }
              }
              if ($code) {
                ## Input
                $set_code-><M::DIS|PLBlockCon.appendStatement>
                              (q<my ($self, $given) = @_>);
                my $param_processor
                        = $set-><M::DISResourcePerl.plGetMethodInputNormalizer>;
                if ($param_processor) {
                  my $pcode = $param_processor-><AG::DISResourcePerl
                                                    .plCodeFragment>->clone;
                  $pcode-><M::DIS|MPLCodeFragment.replaceVariable>
                                                   ('$INPUT' => '$given');
                  $set_code-><M::DIS|PLBlockCon.appendCodeFragment> ($pcode);
                }

                ## Main code
                $set_code-><M::DIS|PLBlockCon.appendCodeFragment> ($code);

                $set->{<Q::DIS:plDefined>} = true;
                $self->{<Q::DIS:plDefined>} = $get->{<Q::DIS:plDefined>};
              } else { ## Setter code not defined
                $set_code-><M::DIS|PLBlockCon.appendStatement>
                                              (q<my ($self) = @_>);
                my $cls = $self->{db}-><M::DIS|DISDatabase.getResource>
                                              (<Q::DOMException:CoreException>,
                                               for_arg => <Q::ManakaiDOM:Perl>);
                my $const = $self->{db}-><M::DIS|DISDatabase.getResource>
                                          (<Q::DOMException:NOT_SUPPORTED_ERR>,
                                               for_arg => <Q::ManakaiDOM:Perl>);
                my $subtype = $self->{db}-><M::DIS|DISDatabase.getResource>
                                    (<Q::MDOMX:MDOM_IMPL_ATTR_NOT_IMPLEMENTED>,
                                               for_arg => <Q::ManakaiDOM:Perl>);
                $_-><AS::DIS|DISAnyResource.isReferred>
                 ($set-><AG::DIS|DISAnyResource.uri>) for $cls, $const, $subtype;
                my $context_param = $get-><M::ManakaiDISResourcePerl
                                             .plGetContextParameter>;
                $self-><M::ManakaiDISResourcePerl.plAppendThrow>
                               ($set_code, $cls, $const, $subtype,
                                {%$context_param});
                $set->{<Q::DIS:plDefined>} = false;
                $self->{<Q::DIS:plDefined>} = false;
              }
            } else {  ## No attribute setter
              $set_code-><M::DIS|PLBlockCon.appendStatement>
                                                       (q<my ($self) = @_>);
              my $cls = $self->{db}-><M::DIS|DISDatabase.getResource>
                                              (<Q::DOMException:CoreException>,
                                               for_arg => <Q::ManakaiDOM:Perl>);
              my $const = $self->{db}-><M::DIS|DISDatabase.getResource>
                                (<Q::DOMException:NO_MODIFICATION_ALLOWED_ERR>,
                                               for_arg => <Q::ManakaiDOM:Perl>);
              my $subtype = $self->{db}-><M::DIS|DISDatabase.getResource>
                                    (<Q::DOMException:READ_ONLY_ATTRIBUTE_ERR>,
                                               for_arg => <Q::ManakaiDOM:Perl>);
              $_-><AS::DIS|DISAnyResource.isReferred>
                ($self-><AG::DIS|DISAnyResource.uri>) for $cls, $const, $subtype;
              my $context_param = $get-><M::ManakaiDISResourcePerl
                                        .plGetContextParameter>;
              $self-><M::ManakaiDISResourcePerl.plAppendThrow>
                               ($set_code, $cls, $const, $subtype,
                                {%$context_param});
              $self->{<Q::DIS:plDefined>} = $get->{<Q::DIS:plDefined>};
            }

            $r = $self->{<Q::DIS|plCodeFragment>}
               = $plimpl-><M::DIS|MPLImpl.createPerlSub>
                            ($self-><AG::DISResourcePerl.plName>);
            $r-><AS::DIS|MPLSub.prototype> (q<$;$>);

            ## TODO: Don't output "if" if non-debug build
            
            $r-><M::DIS|PLBlockCon.appendNewIf>
                     ($plimpl-><M::DIS|MPLImpl.createPerlInlineUnparsedCode>
                                        (q<@_ == 1>),
                      $get_code,
                      $set_code);

          ## -- Constants
          } elsif ($self-><M::DIS|DISResource.isTypeURI>
                              (<Q::ManakaiDOM:Const>)) {
            my $data_type = $self-><AG::DIS|DISResource
                                       .disActualDataTypeResource>;
            my $plimpl = $self-><AG::DISAnyResourcePerl.plImplementation>;
            my $value = $self-><M::DIS|DISResourceProp.getPropertyValue>
                              (<Q::dis:Value>);
            if ($value) {
              $value = $value-><M::DVValuePerl.plCodeFragment>
                              ($self,
                               data_type_uri => $data_type
                                    -><AG::DIS|DISAnyResource.uri>);
            } else {
              __CODE{setDefaultValue::
                $result => $value,
                $data_type => $data_type,
                $plimpl => $plimpl,
              }__;
            }
            $r = $plimpl-><M::DIS|MPLImpl.createPerlSub>
                            ($self-><AG::DISResourcePerl.plName>);
            $r-><M::DIS|PLBlockCon.appendCodeFragment> ($value);
            $r-><AS::DIS|MPLSub.prototype> ('');

          ## -- Classes
          } elsif ($self-><M::DIS|DISResource.isTypeURI>
                              (<Q::ManakaiDOM:Class>)) {
            my $plimpl = $self-><AG::DISAnyResourcePerl.plImplementation>;
            $r = $plimpl-><M::DIS|MPLImpl.createPerlPackage>
                              ($self-><AG::DISResourcePerl
                                         .plFullyQualifiedName>);
            ## - Inheritance
            for my $scls (@{$self-><M::DIS|DISResourceProp
                                         .getPropertyResourceList>
                                    (<Q::dis:ISA>,
                                     default_media_type => <Q::dis:TFQNames>)}) {
              my $spack_name = $scls-><AG::DISResourcePerl
                                         .plFullyQualifiedName>;
              if (defined $spack_name) {
                $r-><M::DIS|PLPack.addISAPackage> ($spack_name);
              }
              $self-><M::ManakaiDISResourcePerl.plAddRequireResource>
                                                  ($scls => $r);
            }

            ## dis:AppISA packages
            for my $spack_name (@{
              $self-><AG::DISResourcePerl.plAdditionalISAPackages>
            }) {
              $r-><M::DIS|PLPack.addISAPackage> ($spack_name);
              $r-><M::DIS|MPLCodeFragment.addRequirePerlModuleName>
                                              ($spack_name);                     
            }

            ## - Implementing interfaces
            for my $scls (@{$self-><M::DIS|DISResourceProp
                                         .getPropertyResourceList>
                                    (<Q::dis:Implement>, recursive_isa => true,
                                     default_media_type => <Q::dis:TFQNames>)}) {
              my $spack_name = $scls-><AG::DISResourcePerl
                                         .plFullyQualifiedName>;
              if (defined $spack_name) {
                $r-><M::DIS|PLPack.addImplementPackage> ($spack_name);
              }
            }
    
            ## - Class members
            my @cr = @{$self-><M::DIS|DISResourceProp
                                         .getPropertyResourceList>
                                    (<Q::DIS:childResource>)};
            my @const;
            for my $cr (@cr) {
              ## - Subroutines
              if ($cr-><M::DIS|DISResource.isTypeURI>
                                    (<Q::DISLang:Method>) or
                  $cr-><M::DIS|DISResource.isTypeURI>
                                    (<Q::DISLang:Attribute>)) {
                my $is_attr = $cr-><M::DIS|DISResource.isTypeURI>
                                    (<Q::DISLang:Attribute>) ? true : false;
                my $pname = $cr-><AG::DISResourcePerl.plName>;
                my $op = $cr-><AG::DISResourcePerl.plMethodOperator>;
                my $psub = $cr-><AG::DISResourcePerl.plCodeFragment>->clone;
                if (defined $pname) {
                  if ($r-><M::DIS|PLPack.getSub> ($pname)) {
                   __UNDEEP{__EXCEPTION{DIS|PERL_SUBROUTINE_ALREADY_DEFINED_ERR::
                      PerlCode:localName => {$pname},
                      DIS:uri => {$cr->{uri}},
                      DIS:sourceNode => {$cr->{src}},
                    }__}__;
                  }
                  $r-><M::DIS|PLPack.setSub> ($pname => $psub);
          
                  if (defined $op and
                      defined $cr-><AG::DIS|DISAnyResource.localName>) {
                    if ($op =~ /^[A-Z]+$/) {
                      if ($r-><M::DIS|PLPack.getSubAliasName> ($op)) {
                        __UNDEEP{__EXCEPTION{
                          DIS|PERL_SUBROUTINE_ALREADY_DEFINED_ERR::
                            PerlCode:localName => {$op},
                            DIS:uri => {$cr->{uri}},
                            DIS:sourceNode => {$cr->{src}},
                        }__}__;
                      }
                      $r-><M::DIS|PLPack.setSubAliasName> ($op => $pname);
                    } else {
                      if ($r-><M::DIS|PLPack.getOverloadMethodName> ($op)) {
                        __UNDEEP{__EXCEPTION{
                          DIS|PERL_OPERATOR_ALREADY_OVERLOADED_ERR::
                            PerlCode:operator => {$op},
                            DIS:uri => {$cr->{uri}},
                            DIS:sourceNode => {$cr->{src}},
                        }__}__;
                      }
                      $r-><M::DIS|PLPack.setOverloadMethodName> ($op => $pname);
                    }
                  }
                } elsif (defined $op) {
                  $r-><M::DIS|PLPack.setOverloadSub> ($op => $psub);
                } else {
                  __UNDEEP{__EXCEPTION{DIS|PERL_UNUSED_SUBROUTINE_ERR::
                    DIS:uri => {$cr->{uri}},
                    DIS:sourceNode => {$cr->{src}},
                  }__}__;
                }
              ## - Constant groups
              } elsif ($cr-><M::DIS|DISResource.isTypeURI>
                                (<Q::ManakaiDOM:ConstGroup>)) {
                for my $gcr (@{$cr-><M::DIS|DISResourceProp
                                         .getPropertyResourceList>
                                    (<Q::DIS:childResource>)}) {
                  if ($gcr-><M::DIS|DISResource.isTypeURI>
                                (<Q::ManakaiDOM:Const>)) {
                    my $sub = $gcr-><AG::DISResourcePerl
                                        .plCodeFragment>;
                    if ($r-><M::DIS|PLPack.getSub>
                                          ($sub-><AG::DIS|MPLSub.localName>)) {
                      __UNDEEP{__EXCEPTION{
                          DIS|PERL_SUBROUTINE_ALREADY_DEFINED_ERR::
                            PerlCode:localName
                                    => {$sub-><AG::DIS|MPLSub.localName>},
                            DIS:uri => {$gcr->{uri}},
                            DIS:sourceNode => {$gcr->{src}},
                      }__}__;
                    }
                    $r-><M::DIS|PLPack.setSub>
                             ($sub-><AG::DIS|MPLSub.localName> => $sub);
                    push @const, $gcr;
                  }
                }
              ## - Constants
              } elsif ($cr-><M::DIS|DISResource.isTypeURI>
                                (<Q::ManakaiDOM:Const>)) {
                my $sub = $cr-><AG::DISResourcePerl.plCodeFragment>;
                if ($r-><M::DIS|PLPack.getSub>
                               ($sub-><AG::DIS|MPLSub.localName>)) {
                  __UNDEEP{__EXCEPTION{
                          DIS|PERL_SUBROUTINE_ALREADY_DEFINED_ERR::
                            PerlCode:localName
                                    => {$sub-><AG::DIS|MPLSub.localName>},
                            DIS:uri => {$cr->{uri}},
                            DIS:sourceNode => {$cr->{src}},
                  }__}__;
                }
                $r-><M::DIS|PLPack.setSub>
                                ($sub-><AG::DIS|MPLSub.localName> => $sub);
                push @const, $cr;
              ## Package-scope variables
              } elsif ($cr-><M::DIS|DISResource.isTypeURI>
                                (<Q::DISPerl:ScalarVariable>)) {
                my $varn = $cr-><AG::DISResourcePerl.plVariableName>;
                my $var = $plimpl-><M::DIS|MPLImpl.createPerlVariable>
                                                       (null, null, $varn);
                my $data_type = $cr-><AG::DIS|DISResource
                                           .disActualDataTypeResource>;
                my $value = $cr-><M::DIS|DISResourceProp.getPropertyValue>
                                    (<Q::dis:DefaultValue>);
                if ($value) {
                  $value = $value-><M::DVValuePerl.plCodeFragment>
                                    ($cr,
                                     data_type_uri => $data_type
                                          -><AG::DIS|DISAnyResource.uri>);
                } else {
                  __CODE{setDefaultValue::
                    $result => $value,
                    $data_type => $data_type,
                    $plimpl => $plimpl,
                  }__;
                }
                if ($cr-><M::DIS|DISResourceProp.getPropertyBoolean>
                              (<Q::DISPerl:defaultValueHasSelfReference>)) {
                  $r-><M::DIS|PLBlockCon.appendStatement>
                    -><M::DIS|PLBlockCon.appendCodeFragment>
                                                       (my $v = $var->clone);
                  $v-><AS::PerlCode:PerlVariable::ManakaiDOM:Perl
                                                     .variableScope> ('our');
                } else {
                  $var-><AS::PerlCode:PerlVariable::ManakaiDOM:Perl
                                                     .variableScope> ('our');
                }
                $r-><M::DIS|PLBlockCon.appendStatement>
                  -><M::DIS|PLAnyCon.appendNewAssignment> ($var => $value);
              } # Type of child resources
            }

            ## - Exceptions
            if ($self-><M::DIS|DISResource.isTypeURI>
                             (<Q::DOMException:AnyExceptionClass>)) {
              my $err_def = $plimpl-><M::DIS|MPLImpl.createPerlSub>
                                            ('___error_def');
              $err_def-><AS::DIS|MPLSub.prototype> ('');
              $err_def-><M::DIS|PLBlockCon.appendCode>
                 ($plimpl-><M::DIS|MPLImpl.perlList>
                   ([{
                       map {
                         $_-><AG::DISResourcePerl.plName> => {
                           <Q::DOMCore:code> => 0 + $_
                             -><AG::DISResourcePerl.plCodeFragment>,
                           description => $_
                             -><M::ManakaiDISResourcePerl.plMufDescriptionText>,
#                           ($_->{ExpandedURI q< DOMCore:severity>}
#                              ? (ExpandedURI q< DOMCore:severity>
#                                      => $_->{ExpandedURI q< DOMCore:severity>},
#                                 ExpandedURI q< DOMCore:type>
#                                       => $_->{ExpandedURI q< DOMCore:type>})
#                                    : ()),
                           <Q::MDOMX:subtype> => {
                             map {
                               $_-><AG::DIS|DISAnyResource.nameURI>
                               => {
                                 description => $_
                                   -><M::ManakaiDISResourcePerl
                                         .plMufDescriptionText>,
#                                 ($_->{ExpandedURI q< DOMCore:severity>}
#                                    ? (ExpandedURI q< DOMCore:severity>
#                                      => $_->{ExpandedURI q< DOMCore:severity>},
#                                       ExpandedURI q< DOMCore:type>
#                                       => $_->{ExpandedURI q< DOMCore:type>})
#                                    : ()),
                               },
                             } grep {
                               $_-><M::DIS|DISResource.isTypeURI>
                                    (<Q::ManakaiDOM:ExceptionOrWarningSubType>)
                             } @{$_-><M::DIS|DISResourceProp
                                         .getPropertyResourceList>
                                    (<Q::DIS:childResource>)}
                           },
                         },
                       } @const
                    }]));
              $r-><M::DIS|PLPack.setSub> (___error_def => $err_def);
            }

          ## -- Global variables
          } elsif ($self-><M::DIS|DISResource.isTypeURI>
                                     (<Q::DISPerl:ScalarVariable>)) {
            my $plimpl = $self-><AG::DISAnyResourcePerl.plImplementation>;
            my $varn = $self-><AG::DISResourcePerl.plVariableName>;
            my $var = $plimpl-><M::DIS|MPLImpl.createPerlVariable>
                                                       (null, null, $varn);
            my $data_type = $self-><AG::DIS|DISResource
                                       .disActualDataTypeResource>;
            my $value = $self-><M::DIS|DISResourceProp.getPropertyValue>
                              (<Q::dis:DefaultValue>);
            if ($value) {
              $value = $value-><M::DVValuePerl.plCodeFragment>
                              ($self,
                               data_type_uri => $data_type
                                    -><AG::DIS|DISAnyResource.uri>);
            } else {
              __CODE{setDefaultValue::
                $result => $value,
                $data_type => $data_type,
                $plimpl => $plimpl,
              }__;
            }
            $r = $plimpl-><M::DIS|MPLImpl.createPerlStatement>;
            $r-><M::DIS|PLAnyCon.appendNewAssignment> ($var => $value);

          ## -- Cases
          } elsif ($self-><M::DIS|DISResource.isTypeURI>
                              (<Q::ManakaiDOM:InCase>)) {
            my $data_type = $self-><AG::DIS|DISResource
                                       .disActualDataTypeResource>;
            $r = $self-><M::DIS|DISResourceProp.getPropertyValue>
                              (<Q::dis:Value>);
            if ($r) {
              $r = $r-><M::DVValuePerl.plCodeFragment>
                              ($self,
                               data_type_uri => $data_type
                                    -><AG::DIS|DISAnyResource.uri>);
            } else {
              my $plimpl = $self-><AG::DISAnyResourcePerl.plImplementation>;
              __CODE{setDefaultValue::
                $result => $r,
                $data_type => $data_type,
                $plimpl => $plimpl,
              }__;
            }

          ## -- Exception Interfaces
          } elsif ($self-><M::DIS|DISResource.isTypeURI>
                              (<Q::ManakaiDOM:ExceptionIF>)) {
            my $plimpl = $self-><AG::DISAnyResourcePerl.plImplementation>;
            $r = $plimpl-><M::DIS|MPLImpl.createPerlPackage>
                              ($self-><AG::DISResourcePerl
                                         .plFullyQualifiedName>);
            ## - Inheritance
              $r-><M::DIS|PLPack.addISAPackage> ('Message::Util::Error');
              $r-><M::DIS|MPLCodeFragment.addRequirePerlModuleName>
                                            ('Message::Util::Error');

          ## -- Unsupported types
          } else {
            $r = $self->{<Q::DIS|plCodeFragment>} = null;
          } # rdf:type
        }__;

  @Attr:
    @@Name: plAdditionalISAPackages
    @@enDesc:
      The current snapshot of the list of additional
      superclass package names (i.e. <Q::dis:AppISA>
      attributes values for Perl).
    @@Type: 
      pl:ARRAY::ManakaiDOM:all
    @@Get:
      @@@PerlDef:
        for my $t (@{$self-><M::DIS|DISResourceProp.getPropertyTextList>
                                 (<Q::dis:AppISA>)}) {
          push @$r, $t;
        }

  @ResourceDef:
    @@ForCheck: ManakaiDOM|ForClass
    @@Name: RegQNameChar
    @@enDesc:
      A regular expression character class for <Q::dis:TypeQName>
      character. 
    @@rdf:type:
      DISPerl:ScalarVariable
    @@DefaultValue:
      @@@@: qr/[^\s<>"'\/\\\[\]\{\},!\?=\$\@%]/
      @@@ContentType:
        lang:Perl
    @@Type:
      DOMMain:any::ManakaiDOM:all

  @ResourceDef:
    @@ForCheck: ManakaiDOM|ForClass
    @@Name: RegBlockContent
    @@enDesc:
      A regular expression for a block.
    @@rdf:type:
      DISPerl:ScalarVariable
    @@Type:
      DOMMain:any::ManakaiDOM:all
    @@DefaultValue:
      @@@@:
        qr/(?>[^{}\\]*)(?>(?>[^{}\\]+|\\.|\{(??{$RegBlockContent})\})*)/
      @@@ContentType:
        lang:Perl
    @@DISPerl:defaultValueHasSelfReference:1

  @Method:
    @@Name: plPreprocessPerlCode
    @@enDesc:
      Preprocesses a Perl block-level code fragment. 
    @@Param:
      @@@Name:codeArg
      @@@Type:
        lang:Perl::ManakaiDOM:all
      @@@enDesc:
        A Perl block-level code (statements and/or blocks).
    @@NodeParam:
    @@NamedParam:
      @@@Name:methodResource
      @@@Type: DIS|DISResource
      @@@clsActualType: DIS|ManakaiDISResourceDefinition
      @@@enDesc:
        The resource definition of the Perl method to which
        the <P::codeArg> belongs.
      @@@nullCase:
        @@@@enDesc:
          The <P::codeArg> does not belong to any method.
    @@NamedParam:
      @@@Name:sourceFile
      @@@Type:
        DISLang:String::ManakaiDOM:all
      @@@enDesc:
        The source file name of the <P::codeArg>.
      @@@nullCase:
        @@@@enDesc:
          No source file information available.
    @@NamedParam:
      @@@Name:sourceLine
      @@@Type:
        DOMMain:unsigned-long::ManakaiDOM:all
      @@@enDesc:
        The line number in the <P::sourceFile> from which
        the <P::codeArg> begins.
      @@@nullCase:
        @@@@enDesc:
          No source file information available.
    @@NamedParam:
      @@@Name: namespaceContext
      @@@Type: DIS|NSResolverDIS
      @@@enDesc:
        A namespace resolver.
      @@@nullCase:
        @@@@enDesc:
          <P::node> or implied one if any.
    @@Return:
      @@@Type: 
        lang:Perl::ManakaiDOM:all
      @@@enDesc:
        Preprocessed Perl code. 
      @@@BlockElementException:
      @@@InlineElementException:
      @@@PerlDef:
        __DEEP{
          my $nsr = $namespaceContext || $node || $self->{src};
          our $RegQNameChar;
          our $RegBlockContent;
          my $plimpl = $self-><AG::DISAnyResourcePerl.plImplementation>;
          $r = $plimpl-><M::DIS|MPLImpl.createPerlBlock>;
          if (defined $sourceLine) {
            $r-><AS::DIS|PLBlockCon.sourceFile> ($sourceFile);
            $r-><AS::DIS|PLBlockCon.sourceLine> ($sourceLine);
            $r-><AS::DIS|PLBlockCon.currentSourceFile> ($sourceFile);
            $r-><AS::DIS|PLBlockCon.currentSourceLine> ($sourceLine);
          } elsif ($node) {
            my $np = $node-><M::DIS|SWCFGNode.flag> ('nodePath') ||
                     $node-><M::DIS|SWCFGNode.nodePath>
                      (key => [qw/Name QName Type type/]);
            $r-><AS::DIS|PLBlockCon.currentSourceFile> ($np);
            $r-><AS::DIS|PLBlockCon.currentSourceLine> (1);
            $r-><AS::DIS|PLBlockCon.sourceFile> ($np);
            $r-><AS::DIS|PLBlockCon.sourceLine> (1);
          }
          
          for my $source_code (split /\b(_ _(?:(?!_ _)$RegQNameChar)+
                                           (?:\{$RegBlockContent\})?
                                         _ _)\b/x, $codeArg) {
            ## Block-level element
            if ($source_code =~ /_\_\z/ and
                $source_code =~ s/^_\_((?:(?!_\_)$RegQNameChar)+)//) {
              my $et = $nsr-><M::DIS|NSResolverDIS.qnameToURI>
                                     ($1,
                                      node => $node,
                                      default_namespace_uri => <Q::disPerl:>);
              if ($source_code =~ s/^\{//) {
                $source_code =~ s/\}__\z//;
              } else {
                $source_code = '';
              }

#  ## ISSUE: __FILE__ & __LINE__ will break if multiline substition happens.

              if ($et eq <Q::disPerl:DEEP> or $et eq <Q::disPerl:UNDEEP>) {
                my $block = $r-><M::DIS|PLBlockCon.appendBlock>;
                $block-><M::DIS|PLBlockCon.appendStatement>
                              ('local $Error::Depth = $Error::Depth '.
                               ($et eq <Q::disPerl:DEEP> ? '+' : '-').
                               ' 1');
                $block-><M::DIS|PLBlockCon.appendCodeFragment>
                          ($self-><M::DISResourcePerl
                                    .plPreprocessPerlCode>
                                       ($source_code,
                                        method_resource => $methodResource,
                                        source_file => $r-><AG::DIS|PLBlockCon
                                                          .currentSourceFile>,
                                        source_line => $r-><AG::DIS|PLBlockCon
                                                          .currentSourceLine>,
                                        node => $node,
                                        namespace_context=> $namespaceContext));
                $r-><M::DIS|PLBlockCon.skipLines> ($source_code);
              } elsif ({
                <Q::disPerl:EXCEPTION> => 1,
                <Q::disPerl:WARNING> => 1,
              }->{$et}) {
                $r-><M::DIS|PLBlockCon.skipLines> ($source_code);
                if ($source_code =~ s/^((?:(?!::).)+)(?:::\s*)?//s) {
                  my ($cls, $const, $subtype)
                    = @{$self->{db}-><M::DIS|DISDatabase.xcrefToResource>
                                         ($1, $nsr,
                                          node => $node,
                                          for_arg => $self->{for})};
                  my $param = $self-><M::ManakaiDISResourcePerl
                                        .plParsePreprocessParameter>
                                         ($source_code, node => $node,
                                        namespace_context=> $namespaceContext);
                  my $context_param
                            = $self-><M::ManakaiDISResourcePerl
                                        .plGetContextParameter>;

                  $self-><M::ManakaiDISResourcePerl.plAppendThrow>
                               ($r, $cls, $const, $subtype,
                                {%$param, %$context_param},
                                node => $node,
                                        namespace_context=> $namespaceContext);
                } else {
                 __UNDEEP{__EXCEPTION{DIS|PERL_PREPROCESS_NO_EXCEPTION_TYPE_ERR::
                    DIS:sourceNode => {$node},
                    DIS:sourceCode => {$source_code},
                    DIS:elementType => {$et},
                  }__}__;
                }
              } elsif ($et eq <Q::disPerl:CODE>) {
                $r-><M::DIS|PLBlockCon.skipLines> ($source_code);
                  my $code_name;
                  $source_code =~ s/^\s+//;
                  if ($source_code =~ s/^((?>(?!::).)+)//s) {
                    $code_name = $1;
                  } else {
                    __UNDEEP{
                      __EXCEPTION{DIS|PERL_PREPROCESS_NO_CODE_NAME_ERR::
                        DIS:sourceCode => {$source_code},
                        DIS:sourceNode => {$node},
                        DIS:elementType => {$et},
                      }__;
                    }__;
                  }
                  $source_code =~ s/^::\s*//;
                  my $param = $self-><M::ManakaiDISResourcePerl
                                        .plParsePreprocessParameter>
                                           ($source_code, node => $node,
                                        namespace_context=> $namespaceContext);
                  my $code_uri = $nsr-><M::DIS|NSResolverDIS
                                           .tfqnamesToURI>
                                           ($code_name, null, $self->{for},
                                            node => $node);
                  my $code = $self->{db}-><M::DIS|DISDatabase.getResource>
                                           ($code_uri);
                  $code-><AS::DIS|DISAnyResource.isReferred>
                                           ($self-><AG::DIS|DISAnyResource.uri>);
                  unless ($code-><M::DIS|DISResource.isTypeURI>
                                           (<Q::dis2pm:BlockCode>)) {
                    __UNDEEP{__EXCEPTION{DIS|RESOURCE_NOT_DEFINED_ERR::
                      DIS:uri => {$code_uri},
                      DIS:sourceNode => {$node},
                      DIS:sourceCode => {$source_code},
                      DIS:expectedType => {<Q::dis2pm:BlockCode>},
                    }__;}__;
                  }
                  my $pc = $code-><AG::DISResourcePerl
                                       .plCodeFragment>->clone;
                  unless (defined $pc) {
                    __UNDEEP{__EXCEPTION{DIS|PERL_CODE_NOT_DEFINED_ERR::
                      DIS:sourceNode => {$node},
                      DIS:sourceCode => {$source_code},
                      DIS:uri => {$code_uri},
                    }__}__;
                  }
                  for my $var (grep {/^\$/} keys %$param) {
                    my $value;
                    if ($param->{$var}->{type} eq 'variable') {
                      $value = $plimpl-><M::DIS|MPLImpl.createPerlVariable>
                                          ('$', null, $param->{$var}->{value});
                    } elsif ($param->{$var}->{type} eq 'code') {
                      $value = $self-><M::DISResourcePerl
                                         .plPreprocessPerlStatement>
                                            ($param->{$var}->{value},
                                             contains_statements => false,
                                             node => $node,
                                        namespace_context=> $namespaceContext);
                    } else {
                      $value = $plimpl-><M::DIS|MPLImpl.createPerlStringLiteral>
                                          ($param->{$var}->{value});
                    }
                    $pc-><M::DIS|MPLCodeFragment.replaceVariable>
                                          ($var => $value);
                  }
                  $r-><M::DIS|PLBlockCon.appendCodeFragment> ($pc);
                } elsif ($et eq <Q::ManakaiDOM:InputNormalize>) {
                  $r-><M::DIS|PLBlockCon.skipLines> ($source_code);
                  unless ($methodResource) {
                    __UNDEEP{__EXCEPTION{DIS|PERL_PREPROCESS_NO_METHOD_ERR::
                      DIS:sourceNode => {$node},
                      DIS:sourceCode => {$source_code},
                      DIS:elementType => {$et},
                    }__}__;
                  }
                  my $param = $methodResource
                                -><M::DIS|DISResource
                                     .getChildResourceByNameAndType>
                                    ($source_code, <Q::DISLang:MethodParameter>);
                  unless ($param) {
                    __UNDEEP{__EXCEPTION{DIS|RESOURCE_NOT_DEFINED_ERR::
                      DIS:sourceNode => {$node},
                      DIS:sourceCode => {$source_code},
                      DIS:elementType => {$et},
                      DIS:localName => {$source_code},
                      DIS:expectedType => {<Q::DISLang:MethodParameter>},
                    }__}__;
                  }
                  my $norm = $param-><M::DISResourcePerl
                                        .plGetMethodInputNormalizer>;
                  if ($norm) {
                    my $norm_code = $norm-><AG::DISResourcePerl
                                               .plCodeFragment>->clone;
                    $norm_code-><M::DIS|MPLCodeFragment.replaceVariable>
                       ('$INPUT' => $param-><AG::DISResourcePerl
                                                .plVariableName>);
                    $r-><M::DIS|PLBlockCon.appendCodeFragment> ($norm_code);
                  }
                } elsif ($et eq <Q::disPerl:FOR>) {
                  if ($source_code =~ s/^(((?>(?!::).)*)::\s*)//) {
                    $r-><M::DIS|PLBlockCon.skipLines> ($1);
                    V: for my $forq (split /\s*\|\s*/, $2) {
                      my $notfor = ($forq =~ s/^!\s*// ? true : false);
                      my $for_uri = $nsr-><M::DIS|NSResolverDIS.qnameToURI>
                                              ($forq, node => $node);
                      my $formatch = $self-><M::DIS|DISAnyResource
                                               .isForURI> ($for_uri);
                      if (($formatch and not $notfor) or
                          (not $formatch and $notfor)) {
                        $r-><M::DIS|PLBlockCon.appendCodeFragment>
                            ($self-><M::DISResourcePerl
                                  .plPreprocessPerlCode>
                                     ($source_code,
                                      method_resource => $methodResource,
                                      source_file => $r-><AG::DIS|PLBlockCon.
                                                       currentSourceFile>,
                                      source_line => $r-><AG::DIS|PLBlockCon.
                                                       currentSourceLine>,
                                      node => $node,
                                        namespace_context=> $namespaceContext));
                        last V;
                      }
                    } # V
                    $r-><M::DIS|PLBlockCon.skipLines> ($source_code);
                  } else {
                    __UNDEEP{__EXCEPTION{DIS|PERL_PREPROCESS_NO_FOR_ERR::
                      DIS:sourceNode => {$node},
                      DIS:sourceCode => {$source_code},
                      DIS:elementType => {$et},
                    }__}__;
                  }
                } elsif ($et eq <Q::disPerl:ASSERT>) {
                  $r-><M::DIS|PLBlockCon.skipLines> ($source_code);
                  my $assert_type;
                  if ($source_code =~ s/^\s*($RegQNameChar+)\s*::\s*//o) {
                    $assert_type = $nsr-><M::DIS|NSResolverDIS.qnameToURI>
                                             ($1, node => $node);
                  } else {
                    __UNDEEP{__EXCEPTION{DIS|PERL_PREPROCESS_NO_ASSERT_TYPE_ERR::
                      DIS:sourceNode => {$node},
                      DIS:sourceCode => {$source_code},
                      DIS:elementType => {$et},
                    }__}__;
                  }
                  # if output assertion then
 =pod
                    my $assert_block = $r-><M::DIS|PLBlockCon.appendBlock>;
                  
                    my $param = $self-><M::ManakaiDISResourcePerl
                                          .plParsePreprocessParameter>
                                           ($source_code, node => $node,
                                        namespace_context=> $namespaceContext);
                    my $context_param
                            = $self-><M::ManakaiDISResourcePerl
                                        .plGetContextParameter>;

                    if ($assert_type eq <Q::DISPerl:isPositive>) {

        $pre = perl_statement
                 perl_assign
                   'my $asActual' =>
                          '('.perl_code ($param->{actual}, %opt).')';
        $cond = '$asActual > 0';
        $xparam->{ExpandedURI q<DOMMain:expectedLabel>} = 'a positive value';
        $xparam->{ExpandedURI q<DOMMain:actualValue>}
                                 = perl_code_literal q<$asActual>;
      } elsif ($atype eq ExpandedURI q<DISPerl:invariant>) {
        $cond = '0';
        $xparam->{ExpandedURI q<DOMMain:expectedLabel>} = $param->{msg};
        $xparam->{ExpandedURI q<DOMMain:actualValue>} = '(invariant)';
      } else {
        valid_err (q[Assertion type <].$atype.q[> is not supported],
                   node => $opt{node});
      }

        $r = $pre . perl_if
               $cond,
               undef,


                  my $cls = $self->{db}-><M::DIS|DISDatabase.getResource>
                                   (<Q::DOMException:CoreException>);
                  my $const = $self->{db}-><M::DIS|DISDatabase.getResource>
                                   (<Q::MDOMX:MDOM_DEBUG_BUG>);
                  my $subtype = $self->{db}-><M::DIS|DISDatabase.getResource>
                                   (<Q::DOMMain:ASSERTION_ERR>);
                  $_-><AS::DIS|DISAnyResource.isReferred>
                          ($node || $self->{src}) for $cls, $const, $subtype;
                  $self-><M::ManakaiDISResourcePerl
                            .plAppendThrow>
                               ($assert_block, $cls, $const, $subtype,
                                {%$param, %$context_param,
                                 <Q::DOMMain:assertionType> => {
                                   type => 'quoted', value => $assert_type,
                                 },
                                 <Q::DOMMain:traceText> => {
                                   type => 'code',
                                   value => q<(sprintf 'at %s line %s%s%s',
                                               __FILE__, __LINE__, "\n\t",
                                               Carp::longmess ())>,
                                 }}, node => $node,
                                        namespace_context=> $namespaceContext);

  =cut

                } elsif ({
                  <Q::disPerl:FILE> => 1,
                  <Q::disPerl:LINE> => 1,
                  <Q::disPerl:PACKAGE> => 1,
                }->{$et}) {
                  $r-><M::DIS|PLAnyCon.appendAtom>
                        ('__'.{
                                 <Q::disPerl:FILE> => 'FILE',
                                 <Q::disPerl:LINE> => 'LINE',
                                 <Q::disPerl:PACKAGE> => 'PACKAGE',
                              }->{$et}.'__');
                  if (length $source_code) {
                    __UNDEEP{__EXCEPTION{
                    DIS|PERL_PREPROCESS_BLOCK_NOT_ALLOWED_ERR::
                      DIS:sourceNode => {$node},
                      DIS:sourceCode => {$source_code},
                      DIS:elementType => {$et},
                    }__}__;
                  }
                } else {
                  __UNDEEP{__EXCEPTION{DIS|UNSUPPORTED_ELEMENT_TYPE_ERR::
                    DIS:sourceNode => {$node},
                    DIS:sourceCode => {$source_code},
                    DIS:elementType => {$et},
                  }__}__;
                }
              } else {  ## Other than block-level element
                $r-><M::DIS|PLBlockCon.appendCodeFragment>
                       ($self-><M::DISResourcePerl
                             .plPreprocessPerlStatement>
                                 ($source_code, contains_statements => true,
                                  source_file => $r-><AG::DIS|PLBlockCon
                                                        .currentSourceFile>,
                                  source_line => $r-><AG::DIS|PLBlockCon
                                                        .currentSourceLine>,
                                  node => $node,
                                        namespace_context=> $namespaceContext));
                $r-><M::DIS|PLBlockCon.skipLines> ($source_code);
              }
            } # for
          }__; # DEEP

  @Method:
    @@Name: plPreprocessPerlStatement
    @@enDesc:
      Preprocesses a Perl inline code fragment
      (code fragment smaller than statement). 
    @@Param:
      @@@Name:codeArg
      @@@Type:
        lang:Perl::ManakaiDOM:all
      @@@enDesc:
        A Perl code fragment.
    @@NodeParam:
    @@NamedParam:
      @@@Name:containsStatements
      @@@Type:
        DOMMain:boolean::ManakaiDOM:all
      @@@enDesc:
        Whether one or more statements might be contained
        in <P::codeArg> or not.
    @@NamedParam:
      @@@Name:sourceFile
      @@@Type:
        DISLang:String::ManakaiDOM:all
      @@@enDesc:
        The source file name of the <P::codeArg>.
      @@@nullCase:
        @@@@enDesc:
          No source file information available.
    @@NamedParam:
      @@@Name:sourceLine
      @@@Type:
        DOMMain:unsigned-long::ManakaiDOM:all
      @@@enDesc:
        The line number in the <P::sourceFile> from which
        the <P::codeArg> begins.
      @@@nullCase:
        @@@@enDesc:
          No source file information available.
    @@NamedParam:
      @@@Name: namespaceContext
      @@@Type: DIS|NSResolverDIS
      @@@nullCase:
        @@@@enDesc:
          <P::node> or implied one if any.
    @@Return:
      @@@Type: DIS|MPLCodeFragment
      @@@enDesc:
        Preprocessed Perl code.
      @@@InCase:
        @@@@Type:
          PerlCode:PerlBlock::ManakaiDOM:Perl
        @@@@enDesc:
          If <P::containsStatements> is <DOM::false>.
      @@@InCase:
        @@@@Type:
          PerlCode:PerlInlines::ManakaiDOM:Perl
        @@@@enDesc:
          If <P::containsStatements> is <DOM::true>.
      @@@InlineElementException:
      @@@PerlDef:
        __DEEP{
          my $nsr = $namespaceContext || $node || $self->{src};
          our $RegQNameChar;
          my $plimpl = $self-><AG::DISAnyResourcePerl.plImplementation>;
          if ($containsStatements) {
            $r = $plimpl-><M::DIS|MPLImpl.createPerlBlockContainer>;
            if (defined $sourceLine) {
              $r-><AS::DIS|PLBlockCon.sourceFile> ($sourceFile);
              $r-><AS::DIS|PLBlockCon.sourceLine> ($sourceLine);
              $r-><AS::DIS|PLBlockCon.currentSourceFile> ($sourceFile);
              $r-><AS::DIS|PLBlockCon.currentSourceLine> ($sourceLine);
            } elsif ($node) {
              my $np = $node-><M::DIS|SWCFGNode.flag> ('nodePath') ||
                       $node-><M::DIS|SWCFGNode.nodePath>
                        (key => [qw/Name QName Type type/]);
              $r-><AS::DIS|PLBlockCon.sourceFile> ($np);
              $r-><AS::DIS|PLBlockCon.sourceLine> (1);
              $r-><AS::DIS|PLBlockCon.currentSourceFile> ($np);
              $r-><AS::DIS|PLBlockCon.currentSourceLine> (1);
            }
          } else {
            $r = $plimpl-><M::DIS|MPLImpl.createPerlInlineContainer>;
          }
          for my $source_code (split /(?<![\^\?qwr])(\x3C$RegQNameChar[^<>]+>
                                                     )/ox, $codeArg) {
            if ($source_code =~ s/^\x3C//) {
              $source_code =~ s/>$//;
              if ($source_code =~ /=$/) {
              ## TODO: Warning
              #  valid_warn qq<Inline element "\x3C$source_code>" ends with a "=" - >.
              #              q{should "=" be used place of "=>"?};
              }
              if ($source_code =~ s/^(.+?):://) {
                my $et = $nsr-><M::DIS|NSResolverDIS.qnameToURI>
                                     ($1,
                                      node => $node,
                                      default_namespace_uri => <Q::disPerl:>);
                if ($et eq <Q::disPerl:Q>) {          ## QName constant
                  $r-><M::DIS|PLAnyCon.appendStringLiteral>
                              ($nsr-><M::DIS|NSResolverDIS.qnameToURI>
                                           ($source_code, node => $node));
                } elsif ({
                  <Q::disPerl:M> => 1,
                  <Q::disPerl:ClassM> => 1,
                  <Q::disPerl:AG> => 1,
                  <Q::disPerl:AS> => 1,
                }->{$et}) {     ## Method call
                  my ($class_qname, $method_qname)
                         = split /\s*\.\s*/, $source_code, 2;
                  my $class_uri = $nsr-><M::DIS|NSResolverDIS.tfqnamesToURI>
                                       ($class_qname,
                                        $self-><AG::DIS|DISResource
                                                     .ownerClassNodeURI>,
                                        $self->{for},
                                        node => $node);
                  my $class = $self->{db}-><M::DIS|DISDatabase.getResource>
                                                   ($class_uri);
                  unless ($class-><AG::DIS|DISAnyResource
                                        .isDefined>) {
                    __UNDEEP{__EXCEPTION{DIS|RESOURCE_NOT_DEFINED_ERR::
                      DIS:sourceNode => {$node},
                      DIS:sourceCode => {$source_code},
                      DIS:uri => {$class_uri},
                      DIS:elementType => {$et},
                      DIS:expectedType => {<Q::DISLang:AnyClass>},
                    }__}__;
                  }
                  $class-><AS::DIS|DISAnyResource.isReferred>
                                                   ($node || $self->{src});
                  if ($et eq <Q::disPerl::ClassM> and
                      $class-><M::DIS|DISResource.isTypeURI>
                                     (<Q::ManakaiDOM:IF>)) {
                    __UNDEEP{
                      __EXCEPTION{DIS|INTERFACE_CLASS_METHOD_ERR::
                        DIS:uri => {$class_uri},
                        DIS:elementType => {$et},
                        DIS:sourceNode => {$node || $self->{src}},
                        DIS:sourceCode => {$source_code},
                        DIS:expectedType => {<Q::ManakaiDOM:IF>},
                      }__;
                    }__;
                  }
                  unless ($class-><M::DIS|DISResource.isTypeURI>
                                         (<Q::ManakaiDOM:IF>)) {
                    $self-><M::ManakaiDISResourcePerl.plAddRequireResource>
                                         ($class => $r);
                  }
                  my $method = $class-><M::DIS|DISResource
                                         .getChildResourceByNameAndType>
                                    ($method_qname,
                                     {
                                       <Q::disPerl:AG> => <Q::DISLang:Attribute>,
                                       <Q::disPerl:AS> => <Q::DISLang:Attribute>,
                                     }->{$et} || <Q::DISLang:Method>);
                  if (not $method or
                      not $method-><AG::DIS|DISAnyResource.isDefined>) {
                    __UNDEEP{
                      __EXCEPTION{DIS|RESOURCE_NOT_DEFINED_ERR::
                        DIS:localName => {$method_qname},
                        DIS:parentURI => {$class_uri},
                        DIS:elementType => {$et},
                        DIS:sourceNode => {$node || $self->{src}},
                        DIS:sourceCode => {$source_code},
                        DIS:expectedType => {{
                                       <Q::disPerl:AG> => <Q::DISLang:Attribute>,
                                       <Q::disPerl:AS> => <Q::DISLang:Attribute>,
                                     }->{$et} || <Q::DISLang:Method>},
                      }__;
                    }__;
                  }
                  my $class_name = '';
                  if ($et eq <Q::disPerl:ClassM>) {
                    $class_name = $class-><AG::DISResourcePerl
                                              .plFullyQualifiedName> . '->';
                  }
                  my $method_name = $method-><AG::DISResourcePerl.plName>;
                  $r-><M::DIS|PLAnyCon.appendBare> ($class_name . $method_name);
                } elsif ({
                  <Q::disPerl:Class> => 1,
                  <Q::disPerl:ClassName> => 1,
                  <Q::disPerl:IF> => 1,
                  <Q::disPerl:IFName> => 1,
                }->{$et}) {                            ## Perl package name
                  my $class_uri = $nsr-><M::DIS|NSResolverDIS.tfqnamesToURI>
                                       ($source_code,
                                        $self-><AG::DIS|DISResource
                                                     .ownerClassNodeURI>,
                                        $self->{for},
                                        node => $node);
                  my $class = $self->{db}-><M::DIS|DISDatabase.getResource>
                                                   ($class_uri);
                  $class-><AS::DIS|DISAnyResource.isReferred>
                                                   ($node || $self->{src});
                  my $pack = $class-><AG::DISResourcePerl.plFullyQualifiedName>;
                  unless ($pack) {
                    __UNDEEP{__EXCEPTION{DIS|NO_PERL_PACKAGE_NAME_ERR::
                      DIS:sourceNode => {$node || $self->{src}},
                      DIS:sourceCode => {$source_code},
                      DIS:uri => {$class_uri},
                      DIS:elementType => {$et},
                    }__}__;
                  }
                  if ({
                    <Q::disPerl:ClassName> => 1,
                    <Q::disPerl:IFName> => 1,
                  }->{$et}) {
                    $r-><M::DIS|PLAnyCon.appendStringLiteral> ($pack);
                  } else {
                    $r-><M::DIS|PLAnyCon.appendBare> ($pack);
                  }
                  $self-><M::ManakaiDISResourcePerl.plAddRequireResource>
                                         ($class => $r)
                    if {
                      <Q::disPerl:Class> => true,
                      <Q::disPerl:ClassName> => true,
                    }->{$et};
                } elsif ($et eq <Q::disPerl:Code>) { ## Inline code
                  my $code_name;
                  $source_code =~ s/^\s+//;
                  if ($source_code =~ s/^((?>(?!::).)+)//s) {
                    $code_name = $1;
                  } else {
                    __UNDEEP{
                      __EXCEPTION{DIS|PERL_PREPROCESS_NO_CODE_NAME_ERR::
                        DIS:sourceCode => {$source_code},
                        DIS:sourceNode => {$node || $self->{src}},
                      }__;
                    }__;
                  }
                  $source_code =~ s/^::\s*//;
                  my $param = $self-><M::ManakaiDISResourcePerl
                                        .plParsePreprocessParameter>
                                           ($source_code, node => $node,
                                        namespace_context=> $namespaceContext);
                  my $code_uri = $nsr-><M::DIS|NSResolverDIS.tfqnamesToURI>
                                           ($code_name, null, $self->{for},
                                            node => $node);
                  my $code = $self->{db}-><M::DIS|DISDatabase.getResource>
                                           ($code_uri);
                  $code-><AS::DIS|DISAnyResource.isReferred>
                                           ($node || $self->{src});
                  unless ($code-><M::DIS|DISResource.isTypeURI>
                                           (<Q::dis2pm:InlineCode>)) {
                    __UNDEEP{__EXCEPTION{DIS|RESOURCE_NOT_DEFINED_ERR::
                      DIS:uri => {$code_uri},
                      DIS:sourceNode => {$node || $self->{src}},
                      DIS:sourceCode => {$source_code},
                      DIS:expectedType => {<Q::dis2pm:InlineCode>},
                    }__;}__;
                  }
                  my $pc = $code-><AG::DISResourcePerl
                                       .plCodeFragment>->clone;
                  unless (defined $pc) {
                    __UNDEEP{__EXCEPTION{DIS|PERL_CODE_NOT_DEFINED_ERR::
                      DIS:sourceNode => {$node || $self->{src}},
                      DIS:sourceCode => {$source_code},
                      DIS:uri => {$code_uri},
                    }__}__;
                  }
                  for my $var (grep {/^\$/} keys %$param) {
                    my $value;
                    if ($param->{$var}->{type} eq 'variable') {
                      $value = $plimpl-><M::DIS|MPLImpl.createPerlVariable>
                                          ('$', null, $param->{$var}->{value});
                    } elsif ($param->{$var}->{type} eq 'code') {
                      $value = $self-><M::DISResourcePerl
                                         .plPreprocessPerlStatement>
                                            ($param->{$var}->{value},
                                             contains_statements => false,
                                             node => $node,
                                        namespace_context=> $namespaceContext);
                    } else {
                      $value = $plimpl-><M::DIS|MPLImpl.createPerlStringLiteral>
                                          ($param->{$var}->{value});
                    }
                    $pc-><M::DIS|MPLCodeFragment.replaceVariable>
                                          ($var => $value);
                  }
                  $r-><M::DIS|PLInCon.appendCodeFragment> ($pc);
                } elsif ($et eq <Q::disPerl:C>) {
                  my ($class_qname, $const_name) = split /\./, $source_code, 2;
                  my $class_uri = $nsr-><M::DIS|NSResolverDIS.tfqnamesToURI>
                                       ($class_qname,
                                        $self-><AG::DIS|DISResource
                                                     .ownerClassNodeURI>,
                                        $self->{for},
                                        node => $node);
                  my $class = $self->{db}-><M::DIS|DISDatabase.getResource>
                                                   ($class_uri);
                  $class-><AS::DIS|DISAnyResource.isReferred>
                                                   ($node || $self->{src});
                  my $const = $class-><M::DIS|DISResource
                                         .getConstResourceByName> ($const_name);
                  unless (defined $const) {
                    __UNDEEP{__EXCEPTION{DIS|RESOURCE_NOT_DEFINED_ERR::
                      DIS:sourceNode => {$node || $self->{src}},
                      DIS:sourceCode => {$source_code},
                      DIS:localName => {$const_name},
                      DIS:expectedType => {<Q::ManakaiDOM:Const>},
                    }__}__;
                  }
                  $const-><AS::DIS|DISAnyResource.isReferred> ($node);

                  my $data_type = $const-><AG::DIS|DISResource
                                       .disActualDataTypeResource>;
                  my $val = $const-><M::DIS|DISResourceProp.getPropertyValue>
                                          (<Q::dis:Value>);
                  if ($val) {
                    $val = $val-><M::DVValuePerl.plCodeFragment>
                            ($const,
                             data_type_uri => $data_type
                                    -><AG::DIS|DISAnyResource.uri>);
                  } else {
                    __UNDEEP{__EXCEPTION{DIS|NO_CONST_VALUE_ERR::
                      DIS:uri => {$const->{uri}},
                      DIS:localName => {$const->{localName}},
                      DIS:sourceNode => {$const->{src}},
                      DIS:elementType => {$et},
                   }__}__;
                  }
                  $r-><M::DIS|PLInCon.appendCodeFragment> ($val);
                } else {
                  __UNDEEP{__EXCEPTION{DIS|UNSUPPORTED_ELEMENT_TYPE_ERR::
                    DIS:elementType => {$et},
                    DIS:sourceNode => {$node || $self->{src}},
                    DIS:sourceCode => {$source_code},
                  }__}__;
                }
              } else {
                __UNDEEP{__EXCEPTION{DIS|PERL_PREPROCESS_NO_ELEMENT_TYPE_ERR::
                  DIS:sourceNode => {$node || $self->{src}},
                  DIS:sourceCode => {$source_code},
                  DIS:expectedType => {<Q::ManakaiDOM:ConstGroup>},
                }__}__;
              }
            } else {
              for my $source_code (split /(\b
                                            (?: t r u e \b|
                                                f a l s e \b|
                                                n u l l \b|
                                                t r y \s* \x7B ) |
        \                                   \\ p \x7B [^\x7B\x7D\\]+ \x7D)/x,
                                   $source_code) {
                if ({
                  'tr'.'ue' => true,
                  'fal'.'se' => true,
                  'nu'.'ll' => true,
                }->{$source_code}) {
                  $r-><M::DIS|PLAnyCon.appendAtom> ({
                    'tr'.'ue' => 1,
                    'fal'.'se' => 0,
                    'nu'.'ll' => 'undef',
                  }->{$source_code});
                } elsif ($source_code =~ /^t r y \s* \x7B$/x) {
                  $r-><M::DIS|PLInCon.appendCode> ('tr'.
                       'y '."\x7B".'local $Error::Depth = $Error::Depth + 3;');
                  $r-><M::DIS|MPLCodeFragment.addUsePerlModuleName>
                                                    ('Message::Util::Error');
                } elsif ($source_code =~ /^\\ p \x7B ([^\x7B\x7D\\]+) \x7D$/x) {
                  my $cls = $1;
                  $cls =~ s/^\s+//s;
                  $cls =~ s/\s+$//s;
                  ## TODO: Formal character class support required
                  if ($cls =~ /^inxml\s*[:|]\s*(\w+)/) {
                    $r-><M::DIS|PLAnyCon.appendAtom> ('\\'.'p{InXML'.$1.'}');
                    $r-><M::DIS|MPLCodeFragment.addUseCharClassName>
                                        ('Char::Class::XML', 'InXML'.$1);
                  } else {
                    __UNDEEP{__EXCEPTION{DIS|RESOURCE_NOT_DEFINED_ERR::
                      DIS:sourceNode => {$node},
                      DIS:sourceCode => {$source_code},
                    }__}__;
                  }
                } else {
                  if ($source_code =~ s/^(\s*[\w:]+\s*)//) {
                    ## NOTE: "$cond ?\n1\n:0" would be a syntax error
                    $r-><M::DIS|PLAnyCon.appendAtom> ($1);
                  }
                  $r-><M::DIS|PLInCon.appendCode> ($source_code);
                }
              }
            } # Inline instruction or not
          } # for
        }__; # DEEP

  @IntMethod:
    @@Name: plParsePreprocessParameter
    @@enDesc:
      Parses a parameter specification in preprocessing instruction
      and return it as a hash reference.
      \
      {NOTE:: The callee have to ensure that this resource has its 
              <CODE::src> before the call to this method.
      \
      }
    @@Param:
      @@@Name: paramSpec
      @@@Type:
        DISLang:String::ManakaiDOM:all
      @@@enDesc:
        A parameter specification to parse.
    @@NodeParam:
    @@NamedParam:
      @@@Name: namespaceContext
      @@@Type: DIS|NSResolverDIS
      @@@nullCase:
        @@@@enDesc:
          <P::node> or implied one if any.
    @@Return:
      @@@Type:
        pl:HASH::ManakaiDOM:all
      @@@enDesc:
        Hash containing parameters.  Each hash value is also 
        a hash reference, containing two keys <CODE::type> 
        (its value is either <CODE::bare>, <CODE::quoted>,
        <CODE::code> or <CODE::variable>) and
        <CODE::value>.
      @@@RaiseException:
        @@@@@: DIS|BROKEN_PARAM_SPEC_ERR
        @@@@enDesc:
          The <P::paramSpec> is not well-formed.
      @@@PerlDef:
        our $RegQNameChar;
        our $RegBlockContent;
        $r = {};
        my $nsr = $namespaceContext || $node || $self->{src};
        while ($paramSpec =~ s/^
          ## Parameter name
          (\$? $RegQNameChar+)\s*
  
          (?: =>? \s*
               ## ">" is now optional for inline element (">" is delimiter)

          ## Parameter value
          (
            ## Variable or Bare string
   \           \$? $RegQNameChar+
            |
            ## Quoted string
               '(?>[^'\\]*)' ## ISSUE: escape mechanism required?
            |
            ## Code
   \           \{$RegBlockContent\}
   
          )

          \s*)?

        (?:,\s*|$)//ox) {

        my ($n, $v) = ($1, $2);
        if (defined $v) {
          if ($v =~ /^'/) {
            $v = {type => 'quoted',
                  value => substr ($v, 1, length ($v) - 2)};
          } elsif ($v =~ /^\{/) {
            $v = {type => 'code', value => substr ($v, 1, length ($v) - 2)};
          } elsif ($v =~ /^\$/) {
            $v = {type => 'variable', value => substr $v, 1};
          } else {
            $v = {type => 'bare', value => $v};
          }
        } else {
          $v = {type => 'boolean', value => true};
        }
    
        if ($n =~ /^\$/) {
          $r->{$n} = $v;
        } else {
          __DEEP{
            $r->{$nsr-><M::DIS|NSResolverDIS.qnameToURI>
                                 ($n, node => $node || $self->{src})} = $v;
          }__;
        }
      } # while

      if (length $paramSpec) {
        __EXCEPTION{DIS|BROKEN_PARAM_SPEC_ERR::
          DIS:sourceCode => {$paramSpec},
          DIS:sourceNode => {$node || $self->{src}},
        }__;
      }

  @IntMethod:
    @@Name: plGetContextParameter
    @@enDesc:
      Returns contextual parameters which describes the <QUOTE::location>
      of this resource.
    @@Return:
      @@@Type:
        pl:HASH::ManakaiDOM:all
      @@@enDesc:
        Hash of parameters as <M::ManakaiDISResourcePerl
        .plParsePreprocessParameter> returns.
      @@@PerlDef:
        $r = {};
        __DEEP{
          if ($self-><M::DIS|DISResource.isTypeURI>
                       (<Q::DISLang:MethodReturn>)) {
            my $method = $self-><M::DIS|DISResourceProp
                              .getPropertyResource> (<Q::dis2pm:parentResource>);
            $r->{<Q::MDOMX:method>}
               = {type => 'quoted',
                  value => $method-><AG::DISResourcePerl.plName>};
            my $class = $method-><M::DIS|DISResourceProp
                              .getPropertyResource> (<Q::dis2pm:parentResource>);
            $r->{<Q::MDOMX:class>}
               = {type => 'quoted',
                  value => $class-><AG::DISResourcePerl
                                       .plFullyQualifiedName>};
          } elsif ($self-><M::DIS|DISResource.isTypeURI>
                       (<Q::DISLang:AttributeGet>)) {
            my $attr = $self-><M::DIS|DISResourceProp
                              .getPropertyResource> (<Q::dis2pm:parentResource>);
            $r->{<Q::MDOMX:attr>}
               = {type => 'quoted',
                  value => $attr-><AG::DISResourcePerl.plName>};
            my $class = $attr-><M::DIS|DISResourceProp
                              .getPropertyResource> (<Q::dis2pm:parentResource>);
            $r->{<Q::MDOMX:class>}
               = {type => 'quoted',
                  value => $class-><AG::DISResourcePerl
                                       .plFullyQualifiedName>};
            $r->{<Q::MDOMX:on>} = {type => 'quoted', value => 'get'};
          } elsif ($self-><M::DIS|DISResource.isTypeURI>
                       (<Q::DISLang:AttributeSet>)) {
            my $attr = $self-><M::DIS|DISResourceProp
                              .getPropertyResource> (<Q::dis2pm:parentResource>);
            $r->{<Q::MDOMX:attr>}
               = {type => 'quoted',
                  value => $attr-><AG::DISResourcePerl.plName>};
            my $class = $attr-><M::DIS|DISResourceProp
                              .getPropertyResource> (<Q::dis2pm:parentResource>);
            $r->{<Q::MDOMX:class>}
               = {type => 'quoted',
                  value => $class-><AG::DISResourcePerl
                                       .plFullyQualifiedName>};
            $r->{<Q::MDOMX:on>} = {type => 'quoted', value => 'set'};
          } else {
            $r->{<Q::MDOMX:resourceURI>} = {type => 'quoted',
                                            value => $self->{uri}};
          }
        }__;

  @Method:
    @@Name: plGetMethodInputNormalizer
    @@enDesc:
      Returns an input processor.  This method assumes that 
      this resource is a method parameter (<Q::DISLang:MethodParameter>)
      or an attribute setter (<Q::DISLang:AttributeSet>).
    @@Return:
      @@@Type: DIS|DISResource
      @@@clsActualType: DIS|ManakaiDISResourceDefinition
      @@@enDesc:
        A <Q::DISLang:InputProcessor> corresponding to 
        the parameter defined by this resource.
        \
        {NOTE:: <Q::ManakaiDOM:inputNormalize> property is 
                obsolete in favor of <Q::DISLang:InputProcessor>;
                this method does not support the former.
        \
        }
      @@@nullCase:
        @@@@enDesc:
          No input processor found.
      @@@PerlDef:
        my $type;
        my $type_node;
        try {
          $type = $self-><AG::DIS|DISResource
                             .disActualDataTypeResource>;
          $type_node = $self-><AG::DIS|DISResource
                                  .disActualDataTypeValue>;
        } catch <IF::DIS|DISException> with {
          my $err = shift;
          unless ($err->{<Q::MDOMX:subtype>} eq <Q::DIS:NO_DIS_TYPE_ERR>) {
            $err->throw;
          }
        };
        if ($type) {
          __DEEP{
            my $noinput = $type_node-><M::dv|DVValue.getProperty>
                                 (<Q::ManakaiDOM:noInputNormalize>);
            unless ($noinput and $noinput-><AG::dv|DVValue.value>) {
              $r = $type-><M::DIS|DISResource.getChildResourceByType>
                                                   (<Q::DISLang:InputProcessor>);
            }
          }__;
        }

  @IntMethod:
    @@Name: plAppendThrow
    @@enDesc:
      Appends a <Perl::report> method call statement for exception reporting.
    @@Param:
      @@@Name: parentNode
      @@@enDesc:
        The parent Perl code node to which a new statement is appended.
      @@@Type: DIS|PLBlockCon
    @@Param:
      @@@Name: xclass
      @@@Type: DIS|DISResource
      @@@clsActualType: DIS|ManakaiDISResourceDefinition
      @@@enDesc:
        An exception class.
    @@Param:
      @@@Name: xcode
      @@@Type: DIS|DISResource
      @@@clsActualType: DIS|ManakaiDISResourceDefinition
      @@@enDesc:
        An exception code constant.
    @@Param:
      @@@Name: xsubtype
      @@@Type: DIS|DISResource
      @@@clsActualType: DIS|ManakaiDISResourceDefinition
      @@@enDesc:
        An exception subtype.
      @@@nullCase:
        @@@@enDesc:
          No subtype.
    @@Param:
      @@@Name: xparam
      @@@Type:
        pl:HASH::ManakaiDOM:all
      @@@enDesc:
        A hash containing parameters passed to the <Perl::report> method. 
        A hash key is to be a parameter name.  Hash values 
        should also be hashes.  A hash value hash has two values: 
        <CODE::type> and <CODE::value>.  A <CODE::value>
        value is a parameter value.  If <CODE::type> is 
        <CODE::code>, then <CODE::value> is assumed as a Perl code fragment.
        Otherwise, <CODE::value> is quoted to be interpreted as a string as is.
    @@NodeParam:
    @@NamedParam:
      @@@Name: namespaceContext
      @@@Type: DIS|NSResolverDIS
      @@@nullCase:
        @@@@enDesc:
          <P::node> or implied one if any.
    @@Return:
      @@@RaiseException:
        @@@@@: DIS|RESOURCE_NOT_DEFINED_ERR
        @@@@enDesc:
          Either <P::xclass>, <P::xcode> or <P::xsubtype>
          is not defined.
      @@@PerlDef:
        my $statement = $parentNode-><M::DIS|PLBlockCon.appendStatement>
          ('report '.
           $xclass-><AG::DISResourcePerl.plFullyQualifiedName>.
           ' -object => $self');
        my $xclass_module = $xclass-><AG::DIS|DISAnyResource
                                            .ownerModule>;
        unless ($xclass-><AG::DIS|DISAnyResource.isDefined> or
                not $xclass_module) {
          __EXCEPTION{DIS|RESOURCE_NOT_DEFINED_ERR::
            DIS:sourceNode => {$self->{src}},
            DIS:uri => {$xclass->{uri}},
            DIS:localName => {$xclass->{localName}},
            DIS:expectedType => {<Q::DOMException:AnyExceptionClass>},
          }__;
        }
        $xclass-><AS::DIS|DISAnyResource.isReferred> ($self->{src});
        $self-><M::ManakaiDISResourcePerl.plAddRequireResource>
                               ($xclass_module => $statement);
        $xparam->{-type} = {type => 'quoted',
                            value => $xcode-><AG::DISResourcePerl.plName>};
        $xparam->{<Q::MDOMX:subtype>}
            = {type => 'quoted',
               value => $xsubtype-><AG::DIS|DISAnyResource.nameURI>}
          if $xsubtype;
        for my $name (keys %$xparam) {
          my $pname = $name;
          $pname =~ s/(['\\])/\\$1/g;
          $pname = qq<'$pname'>;
          $statement-><M::DIS|PLInCon.appendCode>
                           (', ' . $pname . ' => ');
          if ($xparam->{$name}->{type} eq 'code') {
            if (ref $xparam->{$name}->{value}) {
              $statement-><M::DIS|PLInCon.appendCodeFragment>
                           ($xparam->{$name}->{value});
            } else {
              $statement-><M::DIS|PLInCon.appendCodeFragment>
                       ($self-><M::DISResourcePerl
                                  .plPreprocessPerlStatement>
                                     ($xparam->{$name}->{value},
                                      node => $node,
                                      namespace_context => $namespaceContext));
            }
          } else {  ## String as is
            $statement-><M::DIS|PLAnyCon.appendStringLiteral>
                           ($xparam->{$name}->{value});
          }
        }

  @Attr:
    @@Name: plIsNullable
    @@enDesc:
      Whether this resource is <QUOTE::nullable> or not. 
      <QUOTE::Nullability> is defined for method parameters, 
      method returns, attribute getters and attribute setters.
    @@Type:
      DOMMain:boolean::ManakaiDOM:all
    @@Get:
      @@@RaiseException:
        @@@@@: DIS|NO_DIS_TYPE_ERR
        @@@@enDesc:
          There is a <Q::ManakaiDOM:InCase> child resource 
          that does not have <Q::dis:Type> attribute.
      @@@PerlDef:
        __DEEP{
          C: for my $incase (@{$self-><M::DIS|DISResourceProp
                                     .getPropertyResourceList>
                                        (<Q::DIS:childResource>)}) {
            next C unless $incase-><M::DIS|DISResource.isTypeURI>
                                        (<Q::ManakaiDOM:InCase>);
            if ($incase-><AG::DIS|DISResource.disIsNullValue> or
                $incase-><AG::DIS|DISResource.disActualDataTypeResource>
                            -><M::DIS|DISResource
                                     .isSubsetOfURI> (<Q::DOMMain:boolean>)) {
              $r = true;
              last C;
            }
          }
        }__;

  @Attr:
    @@Name:plIsDefined
    @@enDesc:
      Whether a Perl implementation for this resource is available or not.
    @@Type:
      DOMMain:boolean::ManakaiDOM:all
    @@Get:
      @@@TrueCase:
        @@@@enDesc:
          This resource has its Perl definition and it is implemented.
      @@@FalseCase:
        @@@@enDesc:
          Either this resource does not have any Perl definition
          or it does have but it is not implemented yet.
      @@@PerlDef:
        if (exists $self->{<Q::DIS:plDefined>}) {
          $r = $self->{<Q::DIS:plDefined>};
        } else {
          __DEEP{
            my $typeuri = {
              <Q::ManakaiDOM:Class> => [
                <Q::DISLang:Method>, <Q::DISLang:Attribute>,
              ],
              <Q::DISLang:Method> => [
                <Q::DISLang:MethodReturn>,
              ],
              <Q::DISLang:Attribute> => [
                <Q::DISLang:AttributeGet>, <Q::DISLang::AttributeSet>,
              ],
            };
            OUTMOST:
            for my $mytype (keys %$typeuri) {
              if ($self-><M::DIS|DISResource.isTypeURI> ($mytype)) {
                for my $ctype ($typeuri->{$mytype}) {
                  for my $cres (@{$self-><M::DIS|DISResourceProp
                                            .getPropertyResourceList>
                                          (<Q::DIS:childResource>)}) {
                    if ($cres-><M::DIS|DISResource.isTypeURI> ($ctype)) {
                      unless ($cres-><AG::DISResourcePerl
                                         .plIsDefined>) {
                        $r = false; last OUTMOST;
                      }
                    }
                  }
                  next OUTMOST;
                }
              }
            } # OUTMOST
          }__;
          $self->{<Q::DIS:plDefined>} = $r;
        }
  
  @IntMethod:
    @@Name: plAddRequireResource
    @@enDesc:
      Adds a resource to the list of resources that should
      be <Perl::require>d from a Perl code fragment.
    @@Param:
      @@@Name: resourceArg
      @@@Type: DIS|DISResource
      @@@clsActualType: DIS|ManakaiDISResourceDefinition
      @@@enDesc:
        A resource that is <Perl::require>d by <P::codeArg>.
    @@Param:
      @@@Name: codeArg
      @@@Type: DIS|MPLCodeFragment
      @@@enDesc:
        A code fragment.  <P::resourceArg> is added to the
        list of <Perl::require>d resources of this code fragment.
    @@Return:
      @@@PerlDef:
        __DEEP{
          $codeArg-><M::DIS|MPLCodeFragment.disAddRequireURI>
                      ($resourceArg-><AG::DIS|DISAnyResource.uri>);
        }__;

  @Method:
    @@ForCheck: ManakaiDOM|ForClass
    @@ManakaiDOM:isForInternal:1
    @@Name: plMufDescriptionText
    @@enDesc:
      {TODO:: Formal documentation-access API required.
      \
      }
    @@NodeParam:
    @@Return:
      @@@Type:
        DISLang:String::ManakaiDOM:all
      @@@PerlDef:
        __DEEP{
          my $muf = $self-><M::DIS|DISResourceProp.getPropertyValue>
                             (<Q::dis:Def>);
          $muf = $muf->[0] if $muf;
          if ($muf) {
            $r = $muf-><AG::dv|DVValue.stringValue>;
            if ($muf-><AG::dv|DVValue.dataType> eq <Q::lang:muf>) {
              my $nsr = $muf || $node || $self->{src};
              $r =~ s{< Q ::([^<>]+)>}{$nsr-><M::DIS|NSResolverDIS
                                     .qnameToURI> ($1, node => $muf)}gex;
            }
            $r =~ s/\s+/ /g;
            $r =~ s/^ //;
            $r =~ s/ $//;
          } else {
            my $desc = $self-><M::DIS|DISResourceProp.getPropertyValue>
                                (<Q::dis:Description>);
            if ($desc) {
              my $v = $desc-><AG::dv|DVValue.value>;
              if (UNIVERSAL::isa ($v, <IFName::DIS|SWCFGNode>)) {
                $r = $v-><M::DIS|SWCFGNode.value>;
              } else {
                $r = $desc-><AG::dv|DVValue.stringValue>;
              }
              $r =~ s/\s+/ /g;
              $r =~ s/^ //;
              $r =~ s/ $//;
              $r =~ s/%/%percent;/g;
            }
          }
        }__;
      @@@ImplNote:
        @@@@lang:en
        @@@@@: Currently only common-used patterns are supported.
##DISResourcePerl

ElementTypeBinding:
  @Name: IntMethod
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:Method
    @@ManakaiDOM:isForInternal:1
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: clsActualType
  @ElementType:
    dis:actualType
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: BlockElementException
  @ElementType:
    ManakaiDOM:raises
  @ShadowContent:
    @@@: DIS|PERL_PREPROCESS_NO_EXCEPTION_TYPE_ERR
    @@Description:
      @@@lang:en
      @@@@:
        An exception type specification is required but not specified.
  @ShadowSibling:
    @@ManakaiDOM:raises:
      @@@@: DIS|PERL_PREPROCESS_NO_CODE_NAME_ERR
      @@@Description:
        @@@@lang:en
        @@@@@:
          A code qualified name is required but not specified.
    @@ManakaiDOM:raises:
      @@@@: DIS|RESOURCE_NOT_DEFINED_ERR
      @@@Description:
        @@@@lang:en
        @@@@@:
          A referred resource is not defined or has different type.
    @@ManakaiDOM:raises:
      @@@@: DIS|PERL_CODE_NOT_DEFINED_ERR
      @@@Description:
        @@@@lang:en
        @@@@@:
          A referred resource does not have its Perl definition.
    @@ManakaiDOM:raises:
      @@@@: DIS|PERL_PREPROCESS_NO_METHOD_ERR
      @@@Description:
        @@@@lang:en
        @@@@@:
          A preprocessing instruction which is allowed only in 
          methods is embeded in a context which is not in any method.
    @@ManakaiDOM:raises:
      @@@@: DIS|PERL_PREPROCESS_NO_FOR_ERR
      @@@Description:
        @@@@lang:en
        @@@@@:
          A <QUOTE::for> qualified name is required but not specified.
    @@ManakaiDOM:raises:
      @@@@: DIS|PERL_PREPROCESS_NO_ASSERT_TYPE_ERR
      @@@Description:
        @@@@lang:en
        @@@@@:
          An assertion type qualified name is required but not specified.
    @@ManakaiDOM:raises:
      @@@@: DIS|PERL_PREPROCESS_BLOCK_NOT_ALLOWED_ERR
      @@@Description:
        @@@@lang:en
        @@@@@:
          A preprocessing instruction block is specified 
          but not allowed for this element type.

ElementTypeBinding:
  @Name: InlineElementException
  @ElementType:
    ManakaiDOM:raises
  @ShadowContent: 
    @@@: DIS|NO_SOURCE_NODE_ERR
    @@Description:
      @@@lang:en
      @@@@:
        This resource definition does not have associated node 
        in the source tree. 
  @ShadowSibling:
    @@ManakaiDOM:raises:
      @@@@: DIS|INTERFACE_CLASS_METHOD_ERR
      @@@Description:
        @@@@lang:en
        @@@@@:
          An attempt is made to call a class (static) method
          via an interface, not class. 
    @@ManakaiDOM:raises:
      @@@@: DIS|RESOURCE_NOT_DEFINED_ERR
      @@@Description:
        @@@@lang:en
        @@@@@:
          A package, method or attribute is not defined or not 
          a resoure of that type.
    @@ManakaiDOM:raises:
      @@@@: DIS|NO_LOCAL_NAME_ERR
      @@@Description:
        @@@@lang:en
        @@@@@:
          A referred resource does not have its local name so
          that it is impossible to refer it by name.
    @@ManakaiDOM:raises:
      @@@@: DIS|RESERVED_PERL_METHOD_NAME_ERR
      @@@Description:
        @@@@lang:en
        @@@@@:
          A referred method has its name reserved for special-purpose. 
    @@ManakaiDOM:raises:
      @@@@: DIS|BROKEN_PARAM_SPEC_ERR
      @@@Description:
        @@@@lang:en
        @@@@@:
          A parameter specification is not well-formed.
    @@ManakaiDOM:raises:
      @@@@: DIS|PERL_PREPROCESS_NO_CODE_NAME_ERR
      @@@Description:
        @@@@lang:en
        @@@@@:
          A preprocessing instruction does not contain
          Perl code fragment name. 
    @@ManakaiDOM:raises:
      @@@@: DIS|PERL_CODE_NOT_DEFINED_ERR
      @@@Description:
        @@@@lang:en
        @@@@@:
          The referred resource does not have its Perl definition.
    @@ManakaiDOM:raises:
      @@@@: DIS|PERL_PREPROCESS_NO_ELEMENT_TYPE_ERR
      @@@Description:
        @@@@lang:en
        @@@@@:
          A preprocessing instruction does not contain its element type name.
    @@ManakaiDOM:raises:
      @@@@: DIS|UNSUPPORTED_ELEMENT_TYPE_ERR
      @@@Description:
        @@@@lang:en
        @@@@@:
          An unknown element type is encounted.
    @@ManakaiDOM:raises:
      @@@@: DIS|NO_PERL_PACKAGE_NAME_ERR
      @@@Description:
        @@@@lang:en
        @@@@@:
          No Perl package name is defined for a class or interface.

ElementTypeBinding:
  @Name: PerlDef
  @ElementType:
    dis:Def
  @ShadowContent:
    @@ContentType:
      lang:Perl

ElementTypeBinding:
  @Name: disDef
  @ElementType:
    dis:Def
  @ShadowContent:
    @@ContentType:
      lang:dis

ElementTypeBinding:
  @Name: InCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:InCase

ElementTypeBinding:
  @Name: nullCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:InCase
    @@Value:
      @@@is-null:1
      @@@ContentType: DISCore|String

ElementTypeBinding:
  @Name: TrueCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:InCase
    @@Value:
      @@@@:1
      @@@ContentType: DISCore|Boolean

ElementTypeBinding:
  @Name: FalseCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:InCase
    @@Value:
      @@@@: 0
      @@@ContentType: DISCore|Boolean
