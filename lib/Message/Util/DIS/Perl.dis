Module:
  @QName:
    DIS:Perl
  @FullName:
    @@lang: en
    @@@:
      <QUOTE::dis> Perl Module Support
  @Namespace:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS#Perl/
  
  @Description:
    @@lang:en
    @@@:
      This module provides interfaces for generating Perl modules
      from <QUOTE::dis> files.

  @DISCore:author: DISCore|Wakaba
  @License:
    license:Perl+MPL
  @Date:
    @@@:
      $Date: 2006/03/12 10:13:33 $
    @@ContentType:
      dis:Date.RCS
  
  @Require:
    @@Module:
      @@@QName: DIS|common
    @@Module:
      @@@QName: Util|DIS
      @@@WithFor: DIS|ForLatest
    @@Module:
      @@@QName: DIS|Value
      @@@WithFor: DIS|ForLatest
    @@Module:
      @@@QName: Util|PerlCode
      @@@WithFor: ManakaiDOM|ManakaiDOMLatest
    @@Module:
      @@@QName: DIS|DPG
      @@@WithFor: ManakaiDOM|ManakaiDOMLatest
    @@Module:
      @@@QName: MDOM|GenericLS
      @@@WithFor: ManakaiDOM|ManakaiDOMLatest
    @@Module:
      @@@QName: DISlib|Charset
      @@@WithFor: ManakaiDOM|all

  @DefaultFor: 
    DIS:ForLatest

Namespace:
  @cs:
    http://suika.fam.cx/~wakaba/archive/2004/dis/Charset/
  @dd:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS#DISDoc/
  @ddel:
    http://suika.fam.cx/~wakaba/archive/2005/disdoc#
  @DIS:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS#
  @dis:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#dis--
  @DISlib:
    http://suika.fam.cx/~wakaba/archive/2004/dis/
  @disPerl:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#dis--Perl--
  @DOMCore:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#
  @DOMMain:
    http://suika.fam.cx/~wakaba/archive/2004/dom/main#
  @DOMMetaImpl:
    http://suika.fam.cx/~wakaba/archive/2004/dom/meta#
  @dp:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS#Perl/
  @dv:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS#Value/
  @dx:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#
  @dump:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS#DISDump/
  @ecore:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/Core/
  @Err:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/
  @f:
    http://suika.fam.cx/~wakaba/archive/2004/dom/feature#
  @fe:
    http://suika.fam.cx/www/2006/feature/
  @gls:
    http://suika.fam.cx/~wakaba/archive/2004/dom/gls#
  @idl:
    http://suika.fam.cx/~wakaba/archive/2004/dis/IDL#
  @ilang:
    urn:x-suika-fam-cx:lang:
  @infoset:
    http://www.w3.org/2001/04/infoset#
  @kwd:
    http://suika.fam.cx/~wakaba/archive/2005/rfc2119/
  @lang:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#
  @license:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/license#
  @ManakaiDOM:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#
  @Markup:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Markup#
  @MDOM:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#ManakaiDOM.
  @MDOMX:
    http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#
  @mn:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/ManakaiNode#
  @nl:
    http://suika.fam.cx/~wakaba/archive/2004/dis/NaturalLanguage#
  @null:
    http://suika.fam.cx/~wakaba/-temp/2003/09/27/null
  @pc:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/PerlCode#
  @pl:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#Perl--
  @rdf:
    http://www.w3.org/1999/02/22-rdf-syntax-ns#
  @rdfs:
    http://www.w3.org/2000/01/rdf-schema#
  @s:
    http://suika.fam.cx/~wakaba/archive/2004/dis/Markup#
  @script:
    http://suika.fam.cx/~wakaba/archive/2005/5/script#
  @swcfg21:
    http://suika.fam.cx/~wakaba/archive/2005/swcfg21#
  @Util:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/

## -- Features

ElementTypeBinding:
  @Name: FeatureDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: f|Feature
    @@For: ManakaiDOM|all

ElementTypeBinding:
  @Name: FeatureVerDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: f|Feature

ElementTypeBinding:
  @Name: featureQName
  @ElementType:
    f:name
  @ShadowContent:
    @@ContentType: DISCore|QName

FeatureDef:
  @QName: DIS|Perl
  @FeatureVerDef:
    @@QName: DIS|Perl10
    @@Version: 1.0
    @@f:instanceOf: DIS|Perl
    @@f:requires: DIS|CoreFeature10
    @@f:requires: gls|Generic30
    @@FullName:
      @@@lang:en
      @@@@:
        <QUOTE::dis> Perl Module version 1.0

ElementTypeBinding:
  @Name: enDesc
  @ElementType: 
    dis:Description
  @ShadowContent: 
    @@lang:en

ElementTypeBinding:
  @Name: IFClsDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      @@@@: dis|MultipleResource
      @@@ForCheck: !ManakaiDOM|ForIF !ManakaiDOM|ForClass
    @@resourceFor: ManakaiDOM|ForIF
    @@resourceFor: ManakaiDOM|ForClass

    @@rdf:type:
      @@@@: ManakaiDOM|IF
      @@@ForCheck: ManakaiDOM|ForIF

    @@rdf:type:
      @@@@: ManakaiDOM|Class
      @@@ForCheck: ManakaiDOM|ForClass
    @@Implement:
      @@@@: ||+||ManakaiDOM|ForIF
      @@@ForCheck: ManakaiDOM|ForClass
      @@@ContentType: DISCore|TFPQNames

    @@f:implements: DIS|Perl10

    @@ForCheck: DIS|ForEmpty

ElementTypeBinding:
  @Name: IFDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      @@@@: dis|MultipleResource
      @@@ForCheck: !ManakaiDOM|ForIF !ManakaiDOM|ForClass
    @@resourceFor: ManakaiDOM|ForIF

    @@rdf:type:
      @@@@: ManakaiDOM|IF
      @@@ForCheck: ManakaiDOM|ForIF

    @@DOMMain:implementFeature: DIS|Perl10

    @@ForCheck: DIS|ForEmpty

ElementTypeBinding:
  @Name: IFQName
  @ElementType:
    dis:QName
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForIF

ElementTypeBinding:
  @Name: ClsQName
  @ElementType:
    dis:QName
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: IFISA
  @ElementType:
    dis:ISA
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForIF

ElementTypeBinding:
  @Name: ClsISA
  @ElementType:
    dis:ISA
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: Method
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Method
    @@For: !=DIS|ForEmpty

ElementTypeBinding:
  @Name: Return
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|MethodReturn

ElementTypeBinding:
  @Name: Param
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|MethodParameter

ElementTypeBinding:
  @Name: Attr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Attribute
    @@For: !=DIS|ForEmpty

ElementTypeBinding:
  @Name: Get
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|AttributeGet

ElementTypeBinding:
  @Name: Set
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|AttributeSet

## -- Implementation

IFClsDef: 
  @IFQName: DISImplementationPerl
  @ClsQName: ManakaiDISImplementationPerl

  @enDesc:
    The object implementing <IF::DISImplementationPerl> interface
    <kwd:MUST> also implement the <IF::DIS|DISImplementation> interface.

  @f:provides: DIS|Perl10

  @Method:
    @@Name: plLoadDISDatabase
    @@enDesc:
      Loads a database from a file that was saved by 
      <M::DISDatabasePerl.plStore>. 
      \
      {NOTE:: <QUOTE::dis> documents restored from external file
              would have different <A::DIS|DISDocument.implementation> 
              than this <Class::DISImplementationPerl>, even if 
              it has been created by this implementation
              and stored in the same session. 
      \
      }

      Implementation does not have to able to restore a database
      saved by other implementation.
    @@Param:
      @@@Name:fileName
      @@@Type: 
        DISLang:String::ManakaiDOM:all
      @@@enDesc:
        An environment-dependent file name.  How the relative pathes
        is interpreted is implementation dependent.
      @@@enDesc:
        @@@@ForCheck: ManakaiDOM|ForClass
        @@@@@:
          In this implementation, relative pathes are resolved against
          the current directory of the context.
    @@Param:
      @@@Name: moduleResolver
      @@@Type: DISPerl|CODE||ManakaiDOM|all
      @@@enDesc:
        A reference to code.  The code would be passed two parameters,
        the database and a module, and it <kwd:MUST> return
        a <TYPE::DISPerl|String||ManakaiDOM|all> or <DOM::null>.
        It is expected that the code constructs a file name path
        from the module parameter.  Returning <DOM::null> means
        that the code cannot create the file name.   The 
        code <kwd:SHOULD-NOT> throw any exception.  The code
        would be called when a submodule have to be loaded.

        {NOTE:: If the returned path is relative, it is
                resolved against the context, i.e. the current directory.
        }
    @@Return:
      @@@Type: DIS|DISDatabase
      @@@clsActualType: DIS|ManakaiDISDatabase
      @@@SimpleException:
      @@@PerlDef:
        use Storable qw/retrieve/;
        local $Carp::CarpLevel = $Carp::CarpLevel + 1;
        $r = retrieve $fileName;

        ## Restores weak references
        require Scalar::Util;
        for my $doc (values %{$r->{<H::DIS:sourceFile>}}) {
          Scalar::Util::weaken ($doc->{<H::mn:node>}->{<H::DIS:db>})
            if $doc->{<H::mn:node>}->{<H::DIS:db>};
          Scalar::Util::weaken ($doc->{db}) if $doc->{db};
          Scalar::Util::weaken ($doc->{ns}->{'###db'}) if $doc->{ns}->{'###db'};
        }
        for my $def (values %{$r->{modDef}},
                     values %{$r->{forDef}},
                     values %{$r->{resDef}}) {
          $def->{db} = $r;
          Scalar::Util::weaken ($def->{db});
        }

        $r->{<H::dp|dbModuleResolver>} = $moduleResolver;
        delete $r->{<H::DOMCore|error-handler>};
          ## Remove |undef| value if exists.
##DISImplementationPerl

ResourceDef:
  @QName: disdb
  @AliasFor: DIS|DISDatabase
  @For: DIS|ForEmpty

## -- SWCFG nodes

IFClsDef:
  @IFQName: DISElementPerl
  @ClsQName: ManakaiDISElementPerl

  @enDesc:
    The <IF::DISElementPerl> interface provides method to retrieve
    information for Perl module from a <QUOTE::dis> element.

    The object implementing the <IF::DISElementPerl> interface
    <kwd:MUST> also implement the <IF::DIS|DISElement> interface.

  @Attr:
    @@Name: plImplementation
    @@enDesc:
      The implementation object, which the object belongs to and
      which implements the feature <Feature::Util|PerlCode>
      version <FeatureVer::1.0>.
    @@Type: DIS|MPLImpl
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          There is no implementation that supports the feature
          <Feature::Util:PerlCode> version <FeatureVer::1.0>.
      @@@PerlDef:
                                   ## NOTE: Method name is directly written
        $r = <Class::PLImplClass>->_new;

  @Method:
    @@Name: plValueCodeFragment
    @@enDesc:
      A Perl code fragment for value attribute.
    @@Param:
      @@@Name: attrURI
      @@@Type: DIS|AnyURI
      @@@enDesc:
        The URI reference name of an attribute.
      @@@nullCase:
        @@@@enDesc:
          This node itself is used.
    @@Param:
      @@@Name: disResource
      @@@Type: DIS|DISResource
      @@@enDesc:
        The <QUOTE::dis> resource object against which a value is evaluated.
    @@ForParam:
    @@ForpParam:
    @@NamedParam:
      @@@Name:dataTypeURI
      @@@Type:
        DIS|ResourceURI
      @@@enDesc:
        The URI reference of a data type.  It is used to convert
        untyped value and to define default value if <P::useDefaultValue>
        is set to <DOM::true>.
      @@@nullCase:
        @@@@enDesc: 
          No data type.  If the value is untyped, it is treated 
          as if <Q::DISCore:String>.
    @@NamedParam:
      @@@Name:useDefaultValue
      @@@Type:
        DOMMain:boolean::ManakaiDOM:all
      @@@enDesc:
        Whether some default value should be provided if possible or not.
    @@Type:
      DIS|MPLCodeFragment
    @@Return:
      @@@enDesc:
        Perl code fragment object for value attribute.
      @@@nullCase:
        @@@@enDesc:
          There is no <P::attrURI> attribute.
      @@@UndeclaredPrefixException:
      @@@RaiseException:
        @@@@@:DIS|NO_PERL_CODE_IMPL_ERR
        @@@@enDesc:
          There is no implementation that implements
          the <Feature::Util:PerlCode> feature, version <FeatureVer::1.0>.
      @@@PerlDef:
        __DEEP{
          my $dataType;
          my $vnode = defined $attrURI
                      ? $self-><M::DIS|DISElement.disGetAttribute>
                                           ($attrURI,
                                            for_arg => $forArg,
                                            forp_arg => $forpArg,
                                 database_arg => $disResource
                                     -><AG::DIS|DISAnyResource.database>)
                      : $self;
          my $plimpl = $self-><AG::DISElementPerl.plImplementation>;
          if ($vnode) {
            unless ($plimpl) {
              __UNDEEP{__EXCEPTION{DIS|NO_PERL_CODE_IMPL_ERR}__}__;
            }
            my $isnull = $vnode-><M::DIS|DISElement.disGetAttribute>
                                           (<Q::dis:is-null>,
                                            for_arg => $forArg,
                                            forp_arg => $forpArg,
                                  database_arg => $disResource
                                     -><AG::DIS|DISAnyResource.database>);
            if ($isnull and $isnull-><M::DIS|SWCFGNode.value>) {
              $r = $plimpl-><M::DIS|MPLImpl.createPerlAtom> ('undef');
            } else {
              my $vnode_type_uri = $vnode-><M::DIS|DISElement.mediaTypeURI>
                                           (for_arg => $forArg,
                                            forp_arg => $forpArg);
              my $vnode_value = $vnode-><M::DIS|SWCFGNode.value>;
              if ($vnode_type_uri) {
                my $vnode_type = $disResource->{db}
                                     -><M::DIS|DISDatabase.getResource>
                                                      ($vnode_type_uri);
                if ($vnode_type-><M::DIS|DISResource.isSubsetOfURI>
                                        (<Q::dis:Boolean>)) {
                  $r = $plimpl-><M::DIS|MPLImpl.createPerlAtom>
                                        ($vnode_value ? true : false);
                } elsif ($vnode_type-><M::DIS|DISResource
                                             .isSubsetOfURI>
                                        (<Q::dis:TypeQName>)) {
                  $r = $plimpl-><M::DIS|MPLImpl.createPerlStringLiteral>
                                    ($vnode-><M::DIS|NSResolverDIS
                                               .qnameToURI> ($vnode_value,
                                                             node => $vnode));
                } elsif ($vnode_type-><M::DIS|DISResource
                                .isSubsetOfURI> (<Q::lang:Perl>)) {
                  $r = $disResource-><M::DISResourcePerl
                             .plPreprocessPerlStatement>
                                           ($vnode_value,
                                            node => $vnode,
                                            contains_statements => false);
                } else { ## DISCore:String or some
                  $r = $plimpl-><M::DIS|MPLImpl.createPerlStringLiteral>
                                                       ($vnode_value);
                }
              } elsif ($dataTypeURI) {
                $dataType ||= $disResource-><AG::DIS|DISAnyResource.database>
                                          -><M::DIS|DISDatabase.getResource>
                                              ($dataTypeURI);
                if ($dataType-><M::DIS|DISResource.isSubsetOfURI>
                                              (<Q::DISIDL:AnyRealNumber>)) {
                  $r = $plimpl-><M::DIS|MPLImpl.createPerlAtom>
                                              (0 + $vnode_value);
                } elsif ($dataType-><M::DIS|DISResource
                                .isSubsetOfURI> (<Q::DOMMain:boolean>)) {
                  $r = $plimpl-><M::DIS|MPLImpl.createPerlAtom>
                                    ($vnode_value eq 'tr'.'ue' ? true : false);
                } else { ## DOMMain:DOMString or some
                  $r = $plimpl-><M::DIS|MPLImpl.createPerlStringLiteral>
                                                       ($vnode_value);
                }
              } else {  ## Untyped
                $r = $plimpl-><M::DIS|MPLImpl.createPerlStringLiteral>
                                                       ($vnode_value);
              }
            }
          } # has value

          if (not $r and $useDefaultValue) {
            $dataType ||= $disResource-><AG::DIS|DISAnyResource.database>
                                      -><M::DIS|DISDatabase.getResource>
                                              ($dataTypeURI);
            if ($dataType-><M::DIS|DISResource.isSubsetOfURI>
                                              (<Q::DISLang:String>)) {
              $r = $plimpl-><M::DIS|MPLImpl.createPerlStringLiteral> ('');
            } elsif ($dataType-><M::DIS|DISResource.isSubsetOfURI>
                                              (<Q::DOMMain:boolean>) or
                     $dataType-><M::DIS|DISResource.isSubsetOfURI>
                                              (<Q::DISIDL:AnyRealNumber>)) {
              $r = $plimpl-><M::DIS|MPLImpl.createPerlAtom> ('0');
            } elsif ($dataType-><M::DIS|DISResource.isSubsetOfURI>
                                              (<Q::pl:ARRAY>)) {
              $r = $plimpl-><M::DIS|MPLImpl.createPerlAtom> ('[]');
            } elsif ($dataType-><M::DIS|DISResource.isSubsetOfURI>
                                              (<Q::pl:HASH>)) {
              $r = $plimpl-><M::DIS|MPLImpl.createPerlAtom> ('{}');
            }
          }
        }__;

  @Method:
    @@Name: plCodeFragment
    @@enDesc:
      Converts <Q::lang:dis> into Perl code.
    @@Param:
      @@@Name: disResource
      @@@Type: DIS|DISResource
      @@@clsActualType: DIS|ManakaiDISResourceDefinition
      @@@enDesc:
        A <QUOTE::dis> resource with which code is evaluated.
    @@ForParam:
    @@ForpParam:
    @@NamedParam:
      @@@Name: containsStatements
      @@@Type:
        DOMMain:boolean::ManakaiDOM:all
      @@@enDesc:
        Whether the code is block-level or inline-level.
    @@NamedParam:
      @@@Name: databaseArg
      @@@Type: DIS|DISDatabase
      @@@nullCase:
        @@@@enDesc: Implied one.
    @@Return:
      @@@Type: DIS|MPLCodeFragment
      @@@enDesc:
        Perl code converted from this node.
      @@@disPerlException:
      @@@PerlDef:
        __DEEP{
          my $plimpl = $self-><AG::DISElementPerl.plImplementation>;
          my $et = $self-><AG::DIS|SWCFGElement.expandedURI>;
          if ($et eq <Q::dis:Def>) {
            my $value = $self-><M::DIS|SWCFGNode.value>;
            if (defined $value) {
              __UNDEEP{__EXCEPTION{DIS|DISPERL_NO_VALUE_ALLOWED_ERR::
                DIS:sourceNode => {$self},
                DIS:elementType => {$et},
              }__}__;
            }
            $r = $plimpl-><M::DIS|MPLImpl.createPerlBlockContainer>;
            for my $c (@{$self-><M::DIS|DISElement.disChildElements>
                                  (for_arg => $forArg, forp_arg => $forpArg,
                                   database_arg => $databaseArg)}) {
              my $ccode = $c-><M::DISElementPerl.plCodeFragment>
                                  ($disResource,
                                   for_arg => $forArg, forp_arg => $forpArg,
                                   contains_statements => $containsStatements,
                                   database_arg => $databaseArg);
              $r-><M::DIS|PLBlockCon.appendCodeFragment> ($ccode->clone)
                if $ccode;
            }
          } elsif ({
            <Q::DISLang:constValue> => true,
            <Q::DISPerl:cloneCode> => true,
          }->{$et}) {
            my ($qname, $const_name, $on) = split /\s*\.\s*/,
                                             $self-><M::DIS|SWCFGNode.value>, 3;
            my $parentResource = $disResource
                                         -><AG::DIS|DISResource.parentResource>;
            my $uri = $self-><M::DIS|NSResolverDIS.tfqnamesToURI>
                             ($qname,
                              ($parentResource
                                       -><AG::DIS|DISResource.parentResource> ||
                               $parentResource || $disResource)->
                                      <AG::DIS|DISAnyResource.nameURI>,
                              $forArg, node => $self);
            my $const;
            if (defined $const_name) {
              my $owner = $disResource-><AG::DIS|DISAnyResource.database>
                                      -><M::DIS|DISDatabase.getResource> ($uri);
              $owner-><AS::DIS|DISAnyResource.isReferred> ($self);
              if ($et eq <Q::DISLang:constValue>) {
                $const = $owner-><M::DIS|DISResource
                                         .getConstResourceByName> ($const_name);
                unless (defined $const) {
                  __UNDEEP{__EXCEPTION{DIS|RESOURCE_NOT_DEFINED_ERR::
                    DIS:parentURI => {$uri},
                    DIS:localName => {$const_name},
                    DIS:sourceNode => {$self},
                    DIS:elementType => {$et},
                    DIS:expectedType => {<Q::ManakaiDOM:Const>},
                  }__}__;
                }
              } else {
                $const = $owner-><M::DIS|DISResource
                                         .getChildResourceByNameAndType>
                                          ($const_name, <Q::DISLang:AnyMethod>);
                unless (defined $const) {
                  __UNDEEP{__EXCEPTION{DIS|RESOURCE_NOT_DEFINED_ERR::
                    DIS:parentURI => {$uri},
                    DIS:localName => {$const_name},
                    DIS:sourceNode => {$self},
                    DIS:elementType => {$et},
                    DIS:expectedType => {<Q::DISLang:AnyMethod>},
                  }__}__;
                }
              }
            } else {
              $const = $disResource-><AG::DIS|DISAnyResource.database>
                                   -><M::DIS|DISDatabase.getResource> ($uri);
            }
            if ($const-><M::DIS|DISResource.isTypeURI>
                                      (<Q::ManakaiDOM:Const>)) {
              $const-><AS::DIS|DISAnyResource.isReferred> ($self);

              my $data_type = $const-><AG::DIS|DISResource
                                       .disActualDataTypeResource>;
              my $val = $const->{<Q::dis:Value>}-><M::DVValuePerl.plCodeFragment>
                            ($disResource,
                             data_type_uri => $data_type
                                    -><AG::DIS|DISAnyResource.uri>,
                                   database_arg => $databaseArg)
                if $const->{<Q::dis:Value>};
              unless (defined $val) {
                __UNDEEP{__EXCEPTION{DIS|NO_CONST_VALUE_ERR::
                  DIS:uri => {$const->{uri}},
                  DIS:localName => {$const-><AG::DIS|DISAnyResource.localName>},
                  DIS:sourceNode => {$const->{src}},
                  DIS:elementType => {$et},
                }__}__;
              }
            
              if ($containsStatements) {
                $r = $plimpl-><M::DIS|MPLImpl.createPerlStatement>;
                my $rvar = $plimpl-><M::DIS|MPLImpl.createPerlVariable>
                                                 ('$', null, 'r');
                $r-><M::DIS|PLAnyCon.appendNewAssignment> ($rvar => $val);
              } else {
                $r = $val;
              }
            } elsif ($const-><M::DIS|DISResource.isTypeURI>
                                 (<Q::DISLang:AnyMethod>)) {
              my $ret = $const-><M::DIS|DISResource
                                  .getChildResourceByType>
                                 ($const-><M::DIS|DISResource
                                        .isTypeURI> (<Q::DISLang:Method>)
                                  ? <Q::DISLang:MethodReturn>
                                  : ($on and $on eq 'set')
                                    ? <Q::DISLang:AttributeSet>
                                    : <Q::DISLang:AttributeGet>);
              unless ($ret) { 
                __UNDEEP{
                  if ($const-><M::DIS|DISResource
                                        .isTypeURI> (<Q::DISLang:Method>)) {
                    __EXCEPTION{DIS|NO_METHOD_RETURN_ERR::
                      DIS:errResource => {$const},
                      DIS:sourceNode => {$const->{src}},
                      DIS:elementType => {$et},
                      DIS:uri => {$const-><AG::DIS|DISAnyResource.uri>},
                      DIS:localName => {$const-><AG::DIS|DISAnyResource
                                                    .localName>},
                    }__;
                  } elsif ($on and $on eq 'set') {
                    __EXCEPTION{DIS|NO_ATTR_SET_ERR::
                      DIS:errResource => {$const},
                      DIS:sourceNode => {$const->{src}},
                      DIS:elementType => {$et},
                      DIS:uri => {$const-><AG::DIS|DISAnyResource.uri>},
                    }__;
                  } else {
                    __EXCEPTION{DIS|NO_ATTR_GET_ERR::
                      DIS:errResource => {$const},
                      DIS:sourceNode => {$const->{src}},
                      DIS:elementType => {$et},
                      DIS:uri => {$const-><AG::DIS|DISAnyResource.uri>},
                    }__;
                  }
                }__; # UNDEEP
              }
              $r = $ret-><AG::DISResourcePerl.plCodeFragment>;
            } elsif ($const-><M::DIS|DISResource.isTypeURI>
                                 (<Q::DISCore:AnyDefContainer>)) {
              $r = $const-><AG::DISResourcePerl.plCodeFragment>;
            } else {
              if ($et eq <Q::DISLang:constValue>) {
                __UNDEEP{__EXCEPTION{DIS|RESOURCE_NOT_DEFINED_ERR::
                  DIS:uri => {$const->{uri}},
                  DIS:localName => {$const-><AG::DIS|DISAnyResource.localName>},
                  DIS:sourceNode => {$self},
                  DIS:expectedType => {<Q::ManakaiDOM:Const>},
                }__}__;
              } else {  # DISPerl:cloneCode
                __UNDEEP{__EXCEPTION{DIS|RESOURCE_NOT_DEFINED_ERR::
                  DIS:uri => {$const->{uri}},
                  DIS:localName => {$const-><AG::DIS|DISAnyResource.localName>},
                  DIS:sourceNode => {$self},
                  DIS:expectedType => {<Q::DISLang:AnyMethod>},
                }__}__;
              }
            }
          } elsif ($et eq <Q::DISLang:value>) {
            my $val = $self-><M::DISElementPerl.plValueCodeFragment>
                            (null, $disResource,
                             for_arg => $forArg,
                             forp_arg => $forpArg,
                                   database_arg => $databaseArg);
            $r = $plimpl-><M::DIS|MPLImpl.createPerlStatement>;
            my $rvar = $plimpl-><M::DIS|MPLImpl.createPerlVariable>
                                                 ('$', null, 'r');
            $r-><M::DIS|PLAnyCon.appendNewAssignment> ($rvar => $val);
          } elsif ({
            <Q::dis:GetProp> => true,
            <Q::dis:GetPropNode> => true,
            <Q::swcfg21:GetPropNode> => true,
          }->{$et}) {
            my $prop_uri = $self-><AG::DIS|DISElement.qnameValueURI>;
            my $prop_res = $disResource->{db}
                     -><M::DIS|DISDatabase.getResource> ($prop_uri);
            $prop_res-><AS::DIS|DISAnyResource.isReferred> ($self);
            my $prop_name = $prop_res-><M::DIS|DISResourceProp.getPropertyText>
                       (<Q::DISPerl:propHashKey>, $prop_uri);
            $r = $plimpl-><M::DIS|MPLImpl.createPerlStatement>;
            my $node_prop_name = $disResource->{db}
                     -><M::DIS|DISDatabase.getResource> (<Q::mn:node>)
                     -><M::DIS|DISResourceProp.getPropertyText>
                       (<Q::DISPerl:propHashKey>, <Q::mn:node>);
            my $val = $plimpl-><M::DIS|MPLImpl.createPerlInlineContainer>;
            $val-><M::DIS|PLInCon.appendCode> ('$self->{');
            $val-><M::DIS|PLAnyCon.appendStringLiteral> ($node_prop_name);
            $val-><M::DIS|PLInCon.appendCode> ('}->{');
            $val-><M::DIS|PLAnyCon.appendStringLiteral> ($prop_name);
            $val-><M::DIS|PLInCon.appendCode> ('}');
            my $rvar = $plimpl-><M::DIS|MPLImpl.createPerlVariable>
                                               ('$', null, 'r');
            $r-><M::DIS|PLAnyCon.appendNewAssignment> ($rvar => $val);
            
            if ({<Q::dis:GetPropNode> => true,
                 <Q::swcfg21:GetPropNode> => true}->{$et}) {
              my $q = $plimpl-><M::DIS|MPLImpl.createPerlBlockContainer>;
              $q-><M::DIS|PLBlockCon.appendCodeFragment> ($r);
              $q-><M::DIS|PLBlockCon.appendNewIf>
                       ($plimpl-><M::DIS|MPLImpl.createPerlInlineUnparsedCode>
                                                     ('defined $r'),
                        my $qt = $plimpl-><M::DIS|MPLImpl
                                                .createPerlBlockContainer>);
              $qt-><M::DIS|PLBlockCon.appendStatement>
                 -><M::DIS|PLAnyCon.appendNewAssignment>
                       ($rvar->clone => my $qtr = $plimpl-><M::DIS|MPLImpl
                                                    .createPerlInlineContainer>);
              my $cls = $disResource->{db}-><M::DIS|DISDatabase
                           .getResource> ({
                             <Q::dis:GetPropNode> => <Q::DOMCore:ManakaiDOMNode>,
                             <Q::swcfg21:GetPropNode> =>
                                                   <Q::swcfg21:ManakaiSWCFGNode>,
                           }->{$et}, for_arg => $forArg);
              $cls-><AS::DIS|DISAnyResource.isReferred> ($self);
              $qtr-><M::DIS|PLInCon.appendCode>
                       ($cls-><AG::DISResourcePerl
                         .plFullyQualifiedName> . q[->_get_node_reference ($r)]);
              $r = $q;
            }
          } elsif ($et eq <Q::dis:SetProp>) {
            my $prop_uri = $self-><AG::DIS|DISElement.qnameValueURI>;
            my $prop_res = $disResource->{db}
                     -><M::DIS|DISDatabase.getResource> ($prop_uri);
            $prop_res-><AS::DIS|DISAnyResource.isReferred> ($self);
            my $prop_name = $prop_res-><M::DIS|DISResourceProp.getPropertyText>
                       (<Q::DISPerl:propHashKey>, $prop_uri);
            $r = $plimpl-><M::DIS|MPLImpl.createPerlStatement>;
            my $node_prop_name = $disResource->{db}
                     -><M::DIS|DISDatabase.getResource> (<Q::mn:node>)
                     -><M::DIS|DISResourceProp.getPropertyText>
                       (<Q::DISPerl:propHashKey>, <Q::mn:node>);
            my $val = $plimpl-><M::DIS|MPLImpl.createPerlInlineContainer>;
            $val-><M::DIS|PLInCon.appendCode> ('$self->{');
            $val-><M::DIS|PLAnyCon.appendStringLiteral> ($node_prop_name);
            $val-><M::DIS|PLInCon.appendCode> ('}->{');
            $val-><M::DIS|PLAnyCon.appendStringLiteral> ($prop_name);
            $val-><M::DIS|PLInCon.appendCode> ('}');
            my $rvar = $plimpl-><M::DIS|MPLImpl.createPerlVariable>
                                               ('$', null, 'given');
            $r-><M::DIS|PLAnyCon.appendNewAssignment> ($val => $rvar);
            my $chk = $self-><M::DIS|DISElement.disGetAttribute>
                                           (<Q::dis:CheckReadOnly>,
                for_arg => $disResource-><AG::DIS|DISAnyResource.forURI>,
                forp_arg => $disResource-><AG::DIS|DISAnyResource.forpURI>,
                database_arg => $disResource-><AG::DIS|DISAnyResource.database>);
            if ($chk and $chk-><M::DIS|SWCFGNode.value>) {
              my $q = $plimpl-><M::DIS|MPLImpl.createPerlIf>
                   (my $qc = $plimpl-><M::DIS|MPLImpl.createPerlInlineContainer>,
                    my $qt = $plimpl-><M::DIS|MPLImpl.createPerlBlockContainer>);
              my $ro_prop_name = $disResource->{db}
                     -><M::DIS|DISDatabase.getResource> (<Q::DOMCore:read-only>)
                     -><M::DIS|DISResourceProp.getPropertyText>
                       (<Q::DISPerl:propHashKey>, <Q::DOMCore:read-only>);
              $qc-><M::DIS|PLInCon.appendCode> ('$self->{');
              $qc-><M::DIS|PLAnyCon.appendStringLiteral> ($node_prop_name);
              $qc-><M::DIS|PLInCon.appendCode> ('}->{');
              $qc-><M::DIS|PLAnyCon.appendStringLiteral> ($ro_prop_name);
              $qc-><M::DIS|PLInCon.appendCode> ('}');

              my $for_uri = $disResource->{db}-><M::DIS|DISDatabase.getFor>
                               ($forArg)-><M::DIS|DISFor.isaURI>
                               (<Q::ManakaiDOM:ManakaiDOM1>)
                            ? $forArg : <Q::ManakaiDOM:ManakaiDOMLatest>;
              my $cls = $disResource->{db}-><M::DIS|DISDatabase.getResource>
                                            (<Q::DOMCore:ManakaiDOMException>,
                                                       for_arg => $for_uri);
              my $const = $disResource->{db}-><M::DIS|DISDatabase.getResource>
                                 (<Q::DOMCore:NO_MODIFICATION_ALLOWED_ERR>,
                                                       for_arg => $for_uri);
              my $subtype = $disResource->{db}
                                            -><M::DIS|DISDatabase.getResource>
                                                    (<Q::MDOMX:NOMOD_THIS>,
                                                       for_arg => $for_uri);
              $_-><AS::DIS|DISAnyResource.isReferred>
                               ($self) for $cls, $const, $subtype;
              my $context_param = $disResource-><M::ManakaiDISResourcePerl
                                        .plGetContextParameter>;
              $disResource-><M::ManakaiDISResourcePerl
                            .plAppendThrow>
                               ($qt, $cls, $const, $subtype,
                                {%$context_param},
                                node => $self);
              my $or = $r;
              $r = $plimpl-><M::DIS|MPLImpl.createPerlBlockContainer>;
              $r-><M::DIS|PLBlockCon.appendCodeFragment> ($q);
              $r-><M::DIS|PLBlockCon.appendCodeFragment> ($or);
            } # Read-only checking
          } elsif ($et eq <Q::DOMMain:raiseException>) {
            my ($cls, $const, $subtype)
                = @{$disResource->{db}-><M::DIS|DISDatabase.xcrefToResource>
                                         ($self-><M::DIS|SWCFGNode.value>,
                                          $self,
                                          node => $self,
                                          for_arg => $forArg)};
            my $context_param = $disResource-><M::ManakaiDISResourcePerl
                                        .plGetContextParameter>;
            $disResource-><M::ManakaiDISResourcePerl.plAppendThrow>
                        ($r = $plimpl-><M::DIS|MPLImpl.createPerlBlockContainer>,
                         $cls, $const, $subtype,
                         {%$context_param},
                         node => $self);
          } elsif ({
            <Q::dis:ContentType> => true,
            <Q::dis:For> => true, <Q::dis:ForCheck> => true,
            <Q::dis:ImplNote> => true,
            <Q::DISLang:nop> => true,
          }->{$et}) {
            #
          } else {
            __UNDEEP{__EXCEPTION{DIS|UNSUPPORTED_ELEMENT_TYPE_ERR::
              DIS:sourceNode => {$self},
              DIS:elementType => {$et},
            }__}__;
          }
        }__; # DEEP
##DISElementPerl

ResourceDef:
  @QName: setDefaultValue
  @rdf:type: DISPerl|BlockCode
  @PerlDef:
    if ($data_type-><M::DIS|DISResource.isSubsetOfURI>
                                              (<Q::DISLang:String>)) {
      $result = $plimpl-><M::DIS|MPLImpl.createPerlStringLiteral> ('');
    } elsif ($data_type-><M::DIS|DISResource.isSubsetOfURI>
                                              (<Q::DOMMain:boolean>) or
             $data_type-><M::DIS|DISResource.isSubsetOfURI>
                                              (<Q::DISIDL:AnyRealNumber>)) {
      $result = $plimpl-><M::DIS|MPLImpl.createPerlAtom> ('0');
    } elsif ($data_type-><M::DIS|DISResource.isSubsetOfURI>
                                              (<Q::DISPerl|ARRAY>)) {
      $result = $plimpl-><M::DIS|MPLImpl.createPerlAtom> ('[]');
    } elsif ($data_type-><M::DIS|DISResource.isSubsetOfURI>
                                              (<Q::DISPerl|HASH>)) {
      $result = $plimpl-><M::DIS|MPLImpl.createPerlAtom> ('{}');
    }
  @For: DIS|ForEmpty
##setDefaultValue

ResourceDef:
  @QName: setDefaultValueDoc
  @rdf:type: DISPerl|BlockCode
  @PerlDef:
    if ($data_type-><M::DIS|DISResource.isSubsetOfURI>
                                              (<Q::DISLang:String>)) {
      $result = $doc-><M::PCDocument.createPCLiteral> ('');
    } elsif ($data_type-><M::DIS|DISResource.isSubsetOfURI>
                                              (<Q::idl|boolean>) or
             $data_type-><M::DIS|DISResource.isSubsetOfURI>
                                              (<Q::DISIDL:AnyRealNumber>)) {
      $result = $doc-><M::PCDocument.createPCNumberLiteral> ('0');
    } elsif ($data_type-><M::DIS|DISResource.isSubsetOfURI>
                                              (<Q::DISPerl|ARRAY>)) {
      $result = $doc-><M::PCDocument.createPCLiteral> ([]);
    } elsif ($data_type-><M::DIS|DISResource.isSubsetOfURI>
                                              (<Q::DISPerl|HASH>)) {
      $result = $doc-><M::PCDocument.createPCLiteral> ({});
    }
  @For: DIS|ForEmpty
##setDefaultValueDoc

ResourceDef:
  @QName: DIS|MPLImpl
  @AliasFor: pc|PCImplementation||ManakaiDOM|ManakaiDOMLatest
  @For: DIS|ForEmpty

ResourceDef:
  @QName: DIS|MPLCodeFragment
  @AliasFor: pc|PerlCode||ManakaiDOM|ManakaiDOMLatest
  @For: DIS|ForEmpty

ResourceDef:
  @QName: DIS|PLFile
  @AliasFor: pc|PerlFile||ManakaiDOM|ManakaiDOMLatest
  @For: DIS|ForEmpty

ResourceDef:
  @QName: DIS|PLPack
  @AliasFor: pc|PerlPackage||ManakaiDOM|ManakaiDOMLatest
  @For: DIS|ForEmpty

ResourceDef:
  @QName: DIS|PLInCon
  @AliasFor: pc|PerlCodeInlines||ManakaiDOM|ManakaiDOMLatest
  @For: DIS|ForEmpty

ResourceDef:
  @QName: DIS|PLBlockCon
  @AliasFor: pc|PerlCodeStatements||ManakaiDOM|ManakaiDOMLatest
  @For: DIS|ForEmpty

ResourceDef:
  @QName: DIS|MPLSS
  @AliasFor: pc|PerlCodeStatements||ManakaiDOM|ManakaiDOMLatest
  @For: DIS|ForEmpty

ResourceDef:
  @QName: DIS|PLAnyCon
  @AliasFor: pc|PerlCodeUnits||ManakaiDOM|ManakaiDOMLatest
  @For: DIS|ForEmpty

ResourceDef:
  @QName: DIS|MPLSub
  @AliasFor: pc|PerlSub||ManakaiDOM|ManakaiDOMLatest
  @For: DIS|ForEmpty

ResourceDef:
  @QName: DIS|MPLUnparsedCode
  @AliasFor: pc|PerlUnparsedCode||ManakaiDOM|ManakaiDOMLatest
  @For: DIS|ForEmpty

ResourceDef:
  @QName: PCVar
  @AliasFor: pc|PerlVariable||ManakaiDOM|ManakaiDOMLatest
  @For: DIS|ForEmpty

PropDef:
  @QName: DIS|plCodeFragment
  @enDesc:
    Cache for <A::ManakaiDISResourceDefinition.plCodeFragment>.

PropDef:
  @QName: DIS|plDefined
  @enDesc:
    Whether a Perl definition for this resource is implemented or not.

PropDef:
  @QName: plFullyQualifiedName
  @enDesc:
    Fully qualified name.

ElementTypeBinding:
  @Name: PropDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      rdf:Property
    @@For: =ManakaiDOM|all

IFClsDef:
  @IFQName: DVValuePerl
  @ClsQName: ManakaiDVValuePerl

  @Method:
    @@Name: plCodeFragment
    @@enDesc:
      Returns a Perl representation of the value.
    @@Param:
      @@@Name: disResource
      @@@Type: DIS|DISResource
      @@@clsActualType: DIS|ManakaiDISResourceDefinition
      @@@enDesc:
        A <QUOTE::dis> resource with which code is evaluated.
    @@NamedParam:
      @@@Name:dataTypeURI
      @@@Type:
        DIS|ResourceURI
      @@@enDesc:
        The URI reference of a data type.  It is used to convert
        untyped value and to define default value if <P::useDefaultValue>
        is set to <DOM::true>.
      @@@nullCase:
        @@@@enDesc: 
          No data type.  If the value is untyped, it is treated 
          as if <Q::DISCore:String>.
    @@Return:
      @@@Type: DIS|MPLCodeFragment
      @@@enDesc: A Perl representation of the value.
      @@@RaiseException:
        @@@@@:DIS|NO_PERL_CODE_IMPL_ERR
        @@@@enDesc:
          There is no implementation that implements
          the <Feature::Util:PerlCode> feature, version <FeatureVer::1.0>.
      @@@PerlDef:
        __DEEP{
          my $dataType;
          my $plimpl = $self-><AG::DISElementPerl.plImplementation>;
          unless ($plimpl) {
            __UNDEEP{__EXCEPTION{DIS|NO_PERL_CODE_IMPL_ERR}__}__;
          }
          if ($self-><AG::dv|DVValue.isNull>) {
            $r = $plimpl-><M::DIS|MPLImpl.createPerlAtom> ('undef');
          } else {
            my $vnode_type = $disResource-><AG::DIS|DISAnyResource.database>
                                         -><M::DIS|DISDatabase.getResource>
                                              ($self-><AG::dv|DVValue.dataType>);
            if ($vnode_type-><M::DIS|DISResource
                                .isSubsetOfURI> (<Q::lang:Perl>)) {
              $r = $disResource-><M::DISResourcePerl
                             .plPreprocessPerlStatement>
                            ($self-><AG::dv|DVValue.stringValue>,
                             contains_statements => false,
                             namespace_context => $self);
            } elsif ($vnode_type-><M::DIS|DISResource.isSubsetOfURI>
                                        (<Q::DISCore:Integer>)) {
              $r = $plimpl-><M::DIS|MPLImpl.createPerlAtom>
                                  ($self-><AG::dv|DVValue.value> + 0);
            } elsif ($vnode_type-><M::DIS|DISResource.isSubsetOfURI>
                                        (<Q::DISCore:Boolean>)) {
              $r = $plimpl-><M::DIS|MPLImpl.createPerlAtom>
                                  ($self-><AG::dv|DVValue.value> ? true : false);
            } elsif ($dataTypeURI) {
              $dataType ||= $disResource-><AG::DIS|DISAnyResource.database>
                                        -><M::DIS|DISDatabase.getResource>
                                              ($dataTypeURI);
              my $vnode_value = $self-><AG::dv|DVValue.value>;
              if (UNIVERSAL::can ($vnode_value, 'value')) {
                $vnode_value = $vnode_value-><M::DIS|SWCFGNode.value>;
              }
              if ($dataType-><M::DIS|DISResource.isSubsetOfURI>
                                                (<Q::DISIDL:AnyRealNumber>)) {
                $r = $plimpl-><M::DIS|MPLImpl.createPerlAtom>
                                                (0 + $vnode_value);
              } elsif ($dataType-><M::DIS|DISResource
                                  .isSubsetOfURI> (<Q::DOMMain:boolean>)) {
                $r = $plimpl-><M::DIS|MPLImpl.createPerlAtom>
                                      ($vnode_value eq 'tr'.'ue' ? true :
                                       $vnode_value eq '1' ? true : false);
              } else { ## DOMMain:DOMString or some
                $r = $plimpl-><M::DIS|MPLImpl.createPerlStringLiteral>
                                         ($self-><AG::dv|DVValue.stringValue>);
              }
            } else { ## DISCore:String or some
              $r = $plimpl-><M::DIS|MPLImpl.createPerlStringLiteral>
                                    ($self-><AG::dv|DVValue.stringValue>);
            }
          }
        }__;

  @Attr:
    @@Name: plImplementation
    @@enDesc:
      The implementation object, which the object belongs to and
      which implements the feature <Feature::Util|PerlCode>
      version <FeatureVer::1.0>.
    @@Type: DIS|MPLImpl
    @@Get:
      @@@enDesc:
        The Perl code implementation object. 
      @@@nullCase:
        @@@@enDesc:
          There is no implementation that supports the feature
          <Feature::Util:PerlCode> version <FeatureVer::1.0> or
          the resource has no source element associated.
      @@@RaiseException:
        @@@@@: DIS|NO_PERL_CODE_IMPL_ERR
        @@@@enDesc:
          There is no implementation that implements 
          the <Feature::Util:PerlCode> feature, version <FeatureVer::1.0>. 
      @@@PerlDef:
                                    ## NOTE: Method name directly written
          $r = <Class::PLImplClass>->_new;
##DVValuePerl

ElementTypeBinding:
  @Name: ForParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:MethodParameter
    @@DISPerl:isNamedParameter:1
    @@Name: forArg
    @@Type: DIS|ForURI
    @@Description:
      @@@lang:en
      @@@@:
        The <QUOTE::for> URI reference. 
    @@ResourceDef:
      @@@rdf:type:
        ManakaiDOM:InCase
      @@@Value:
        @@@@is-null:1
        @@@@ContentType: DISCore|String
      @@@Description:
        @@@@lang:en
        @@@@@:
          Equivalent to <Q::ManakaiDOM:all>, i.e. <QUOTE::for all>. 

ResourceDef:
  @QName: PLImplClass
  @AliasFor: PerlCode|ManakaiPCImplementation||ManakaiDOM|ManakaiDOMLatest
  @For: DIS|ForEmpty

ElementTypeBinding:
  @Name: ForpParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:MethodParameter
    @@DISPerl:isNamedParameter:1
    @@Name: forpArg
    @@Type: DIS|ForURIList
    @@Description:
      @@@lang:en
      @@@@:
        An array reference containing additional <QUOTE::for> 
        constraints (<QUOTE::For+> list).
    @@ResourceDef:
      @@@rdf:type:
        ManakaiDOM:InCase
      @@@Value:
        @@@@is-null:1
        @@@@ContentType: DISCore|String
      @@@Description:
        @@@@lang:en
        @@@@@:
          Equivalent to the empty array reference. 

ElementTypeBinding:
  @Name: MediaTypeParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:MethodParameter
    @@DISPerl:isNamedParameter:1
    @@Name: mediaType
    @@Type: DIS|MediaTypeURI
    @@Description:
      @@@lang:en
      @@@@:
        The URI reference identifying a media type. 
    @@ResourceDef:
      @@@rdf:type:
        ManakaiDOM:InCase
      @@@Value:
        @@@@is-null:1
        @@@@ContentType: DISCore|String
      @@@Description:
        @@@@lang:en
        @@@@@:
          No media type specified. 

ElementTypeBinding:
  @Name: MediaTypeDefaultParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:MethodParameter
    @@DISPerl:isNamedParameter:1
    @@Name: defaultMediaType
    @@Type: DIS|MediaTypeURI
    @@Description:
      @@@lang:en
      @@@@:
        The default media type, i.e. the type used when no explicit 
        specification is not found in the source tree. 
    @@ResourceDef:
      @@@rdf:type:
        ManakaiDOM:InCase
      @@@Value:
        @@@@is-null:1
        @@@@ContentType: DISCore|String
      @@@Description:
        @@@@lang:en
        @@@@@:
          Defaulted to <Q::DOMMain:any>. 

ElementTypeBinding:
  @Name: RaiseException
  @ElementType:
    ManakaiDOM:raises

ElementTypeBinding:
  @Name: UndeclaredPrefixException
  @ElementType:
    ManakaiDOM:raises
  @ShadowContent:
    @@@: DIS|UNDECLARED_NS_PREFIX_ERR
    @@Description:
      @@@lang:en
      @@@@:
        The implementation has encounted an undeclared namespace prefix. 

ElementTypeBinding:
  @Name: NamedParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:MethodParameter
    @@DISPerl:isNamedParameter:1

ElementTypeBinding:
  @Name: NodeParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:MethodParameter
    @@DISPerl:isNamedParameter:1
    @@Name: node
    @@Type: DIS|DISNode
    @@actualType:
      @@@@: DIS|ManakaiDISNode
      @@@ForCheck: ManakaiDOM|ForClass
    @@Description:
      @@@lang:en
      @@@@:
        The node in which the name has occurred.  It is intended 
        to be reported when an exception had been raised. 
    @@ResourceDef:
      @@@rdf:type:
        ManakaiDOM:InCase
      @@@Value:
        @@@@is-null:1
        @@@@ContentType: DISCore|String
      @@@Description:
        @@@@lang:en
        @@@@@:
          The source of the name is not a node. 

## -- DIS database

IFClsDef:
  @IFQName: DISDatabasePerl
  @ClsQName: ManakaiDISDatabasePerl

  @enDesc:
    The objects implementing the <IF::DISDatabasePerl>
    interface <kwd:MUST> also implement the <IF::DIS|DISDatabase>
    interface.


  @Method:
    @@Name: plStore
    @@enDesc:
      Saves this database to an external file. 
      \
      {NOTE:: Saved files can be loaded by 
              <M::DISImplementationPerl.plLoadDISDatabase>.
      \
      }
    @@Param:
      @@@Name: fileName
      @@@Type:
        DISLang:String::ManakaiDOM:all
      @@@enDesc:
        An environment-dependent file name of external database to save. 
        \
        {NOTE:: If there is already a file named as <P::fileName>, then 
                it is overwritten. 
        \
        }
    @@Param:
      @@@Name: moduleResolver
      @@@Type: DISPerl|CODE||ManakaiDOM|all
      @@@enDesc:
        A reference to code which resolvers a module into
        a file name path, as in <M::DISDatabasePerl.plLoadDISDatabase>.
    @@NamedParam:
      @@@Name: noMainDatabase
      @@@Type: idl|boolean||ManakaiDOM|all
      @@@enDesc:
        If <DOM::true>, the method doesn't write the main database file.
    @@Return:
      @@@SimpleException:
      @@@PerlDef:
        use Storable qw/nstore/;
        local $Carp::CarpLevel = $Carp::CarpLevel + 1;

        ## Updates resource to module mapping
        my %mod_res;
        my %mod_for;
        my %mod_mod;   ## Module objects with full properties
        my %temp_mod;  ## Module objects for index
        __DEEP{
          my $core_mod = $self-><M::DIS|DISDatabase.getModule>
                                  (<Q::DISlib|DISCore>);
            ## Loads the core module for resources does not belong
            ## to any module.

          R: for my $res (values %{$self->{resDef}}) {
            my $mod_urir = $res-><AG::DIS|DISAnyResource.ownerModuleURIRef>;
            unless (defined $mod_urir) {
              next R unless $res-><AG::anyres.isDefined>;
              $mod_urir = \<Q::DISlib|DISCore>;
            }
            for my $res_uri (@{$res-><AG::DIS|DISAnyResource.uris>}) {
              $self->{<H::DIS|resourceModuleMap>}->{$res_uri} = $mod_urir;
              $mod_res{$$mod_urir}->{$res_uri} = $res;
            }
            CORE::delete $res->{db};
          }

          R: for my $res (values %{$self->{forDef}}) {
            my $mod_urir = $res-><AG::DIS|DISAnyResource.ownerModuleURIRef>;
            unless (defined $mod_urir) {
              next R unless $res-><AG::anyres.isDefined>;
              $mod_urir = \<Q::DISlib|DISCore>;
            }
            for my $res_uri (@{$res-><AG::DIS|DISAnyResource.uris>}) {
              $self->{<H::DIS|resourceModuleMap>}->{$res_uri} = $mod_urir;
              $mod_for{$$mod_urir}->{$res_uri} = $res;
            }
            CORE::delete $res->{db};
          }

          for my $res (values %{$self->{modDef}}) {
            my $mod_uri = $res-><AG::anyres.uri>;
            if ($res-><AG::DIS|DISAnyResource.isDefined> and
                not $res->isa (<ClassName::DIS|ManakaiDISModuleLite>)) {
              $mod_mod{$mod_uri} = $res;
              CORE::delete $res->{db};
              $temp_mod{$mod_uri} = bless {},
                                       <ClassName::DIS|ManakaiDISModuleLite>;
              for ('uri', 'localName', 'namespaceURI', 'for', 'forp',
                   <H::DIS|isDefined>, <H::DIS|isReferred>,
                   <H::DIS|sourceNodeID>, <H::DIS|defaultNamespaceURI>,
                   <H::dp|plHashKey>, <H::DIS|revision>) {
                $temp_mod{$mod_uri}->{$_} = $res->{$_}
                  if defined $res->{$_};
              }
            } else {
              $temp_mod{$mod_uri} = $res;
            }
          }
        }__;

        ## Obtains module file names and contents
        my %mod_file;
        __DEEP{
          for my $mod_uri (keys %{{%mod_res, %mod_for, %mod_mod}}) {
            my $mod_file_name = ($moduleResolver or sub ($$) {})
              ->($self, $self-><M::DIS|DISDatabase.getModule> ($mod_uri),
                 <Q::dp|ModuleResourceFile>);
            my $mod_idx_file_name = ($moduleResolver or sub ($$) {})
              ->($self, $self-><M::DIS|DISDatabase.getModule> ($mod_uri),
                 <Q::dp|ModuleIndexFile>);
            for (keys %{$mod_res{$mod_uri}||{}}) {
              $mod_file{$mod_file_name}->{resDef}->{$_}
                = $mod_res{$mod_uri}->{$_};
              $mod_file{$mod_idx_file_name}->{<H::DIS|resourceModuleMap>}->{$_}
                = \$mod_uri;
            } 
            for (keys %{$mod_for{$mod_uri}||{}}) {
              $mod_file{$mod_file_name}->{forDef}->{$_}
                = $mod_for{$mod_uri}->{$_};
              $mod_file{$mod_idx_file_name}->{<H::DIS|resourceModuleMap>}->{$_}
                = \$mod_uri;
            }
            if ($mod_mod{$mod_uri}) {
              $mod_file{$mod_file_name}->{modDef}->{$mod_uri}
                = $mod_mod{$mod_uri};
              $mod_file{$mod_idx_file_name}->{modDef}->{$mod_uri}
                = $temp_mod{$mod_uri};
            }
          }
        }__;

        ## Database module files
        for my $mod_file_name (keys %mod_file) {
          nstore $mod_file{$mod_file_name}, $mod_file_name;
        }

        ## The main database
        unless ($noMainDatabase) {
          local $self->{<H::dp|dbModuleResolver>} = null;
          local $self->{resDef} = {};
          local $self->{forDef} = {};
          local $self->{modDef} = \%temp_mod;
          local $self->{<H::DOMCore|error-handler>} = null;
          nstore $self, $fileName;
        }

        require Scalar::Util;
        for my $res (values %temp_mod,
                     map {values %{$_->{forDef}||{}},
                          values %{$_->{resDef}||{}},
                          values %{$_->{modDef}||{}}} values %mod_file) {
          $res->{db} = $self;
          Scalar::Util::weaken ($res->{db});
        }

  @Method:
    @@Name: plAddHashKey
    @@enDesc:
      Adds a binding of hash key and resource.
    @@Param:
      @@@Name: keyScope
      @@@Type: DIS|AnyURI
      @@@enDesc:
        An identifier to define the scope of hash key.
    @@Param:
      @@@Name: keyName
      @@@Type: DISLang|String||ManakaiDOM|all
      @@@enDesc:
        Hash key value to register.
    @@Param:
      @@@Name: disResource
      @@@Type: DIS|DISResource
      @@@enDesc:
        A <QUOTE::dis> resource associated to <P::keyName>.
    @@Return:
      @@@RaiseException:
        @@@@@: DIS|PERL_HASH_KEY_ALREADY_DEFINED_ERR
        @@@@enDesc:
          The pair of <P::keyScope> and <P::keyName> is 
          already registered for other resource.
      @@@PerlDef:
        __DEEP{
          my $ks = $self-><M::DIS|DISDatabase.getResource> ($keyScope);
          $ks-><AS::DIS|DISAnyResource.isReferred> ($keyName);
          for my $ks_uri (@{$ks-><M::anyres.getSuperResourceURIList>}) {
            my $ks_r = $self-><M::disdb.getResource> ($ks_uri);
            if ($ks_r->{<H::dp|plHashKey>}->{$keyName}) {
              __UNDEEP{__EXCEPTION{DIS|PERL_HASH_KEY_ALREADY_DEFINED_ERR::
                DIS:uri => {$disResource-><AG::DIS|DISAnyResource.uri>},
                DIS:anotherURI => {${$ks_r->{<H::dp|plHashKey>}->{$keyName}}},
                DIS:hashKeyScope => {$ks_uri},
                DIS:hashKeyName => {$keyName},
              }__}__;
            }
          }
          $ks->{<H::dp|plHashKey>}->{$keyName} =
          $disResource-><AG::anyres.ownerModule>
                      ->{<H::dp|plHashKey>}
                      ->{$keyScope}->{$keyName}
            = $disResource-><AG::anyres.uriRef>;
        }__;

  @Method:
    @@ManakaiDOM:isForInternal:1
    @@ForCheck: ManakaiDOM|ForClass
    @@Name: plLoadDISDatabaseModule
    @@enDesc:
      Loads a database submodule file generated by 
      <M::DISDatabasePerl.plStore>.
    @@Param:
      @@@Name: disModule
      @@@Type: DIS|DISModule
      @@@enDesc:
        The <QUOTE::dis> module whose database submodule
        should be loaded.
    @@SimpleException:
    @@Return:
      @@@PerlDef:
        if ($disModule->isa (<ClassName::DIS|ManakaiDISModuleLite>)) {
          my $dbmod;
          my $fileName;
          __DEEP{
            $fileName = ($self->{<H::dp|dbModuleResolver>} or sub () {})
                           ->($self, $disModule);
            __UNDEEP{__DOMCore:ERROR{
            dp|info-open-database-module-resource-start::
              DIS|fileName => {$fileName},
            }__}__;
            use Storable qw/retrieve/;
            {
              local $Carp::CarpLevel = $Error::Level;
              $dbmod = retrieve $fileName;
            }
            __UNDEEP{__DOMCore:ERROR{dp|info-open-database-module-resource-end::
              DIS|fileName => {$fileName},
            }__}__;
  
            require Scalar::Util;        
            S: for my $res_uri (keys %{$dbmod->{modDef}}) {
              my $res = $dbmod->{modDef}->{$res_uri};
              my $dres = $self->{modDef}->{$res_uri};
  
              unless (defined $dres) {
                $dres = $self->{modDef}->{$res_uri}
                      = {db => $self};
                Scalar::Util::weaken ($dres->{db});
              } elsif (ref $dres ne <ClassName::DIS|ManakaiDISModuleLite>) {
                __UNDEEP{__EXCEPTION{DIS|RESOURCE_ALREADY_DEFINED_ERR::
                  DIS:uri => {$res_uri},
                  DIS:moduleURI => {$disModule-><AG::DIS|DISAnyResource.uri>},
                }__}__;
              }
              for my $pn (keys %$res) {
                $dres->{$pn} = $res->{$pn};
              }
  
              bless $dres, <ClassName::DIS|ManakaiDISModuleDefinition>;
            } # S

            S: for my $res_uri (keys %{$dbmod->{forDef}}) {
              my $res = $dbmod->{forDef}->{$res_uri};
              next S unless $res_uri eq $res-><AG::DIS|DISAnyResource.uri>;
              $res->{db} = $self;
              Scalar::Util::weaken ($res->{db});
              if (defined $self->{forDef}->{$res_uri} and
                  not ref $self->{forDef}->{$res_uri} eq 'HASH' and
                      # There should be a bug...
                  $self->{forDef}->{$res_uri}-><AG::anyres.isDefined>) {
                __UNDEEP{__EXCEPTION{DIS|RESOURCE_ALREADY_DEFINED_ERR::
                  DIS:uri => {$res_uri},
                  DIS:moduleURI => {$disModule-><AG::DIS|DISAnyResource.uri>},
                }__}__;
              }
              $self->{forDef}->{$res_uri} = $res;
            } # S
 
            S: for my $res_uri (keys %{$dbmod->{resDef}}) {
              my $res = $dbmod->{resDef}->{$res_uri};
              next S unless $res_uri eq $res-><AG::DIS|DISAnyResource.uri>;
              $res->{db} = $self;
              Scalar::Util::weaken ($res->{db});
              if (defined $self->{resDef}->{$res_uri}) {
                if ($self->{resDef}->{$res_uri}-><AG::anyres.isDefined>) {
                  if ($res-><AG::anyres.isDefined>) {
                    __UNDEEP{__EXCEPTION{DIS|RESOURCE_ALREADY_DEFINED_ERR::
                      DIS:uri => {$res_uri},
                      DIS:moduleURI => {$disModule-><AG::DIS|DISAnyResource.uri>},
                    }__}__;
                  }
                }
              }
              for my $uri (grep {$res->{aliasURI}->{$_}}
                           keys %{$res->{aliasURI}}) {
                $self->{resDef}->{$uri} = $res;
              }
            } # S
          }__;
        } # not loaded

  @Method:
    @@Name: plUpdateModule
    @@enDesc:
      Reads a definition from the source file.  If it and
      other modules referenced from it is updated, then they
      are synced with the source.
    @@Param:
      @@@Name: modules
      @@@Type: DISPerl|ARRAY||ManakaiDOM|all
      @@@enDesc:
        A list of pairs of module name URI and <QUOTE::for> URI.
    @@NamedParam:
      @@@Name: getModuleIndexFileName
      @@@Type: DISPerl|CODE||ManakaiDOM|all
      @@@enDesc:
        A code to convert a module URI into file name.
 
        The first parameter is the database object.

        The second parameter is the name URI of the module.

        The code must return a string, which represents an
        environment dependent file path name for the database
        resource index file for the module given by the second
        parameter.
    @@NamedParam:
      @@@Name: getModuleSourceDocumentFromURI
      @@@Type: DISPerl|CODE||ManakaiDOM|all
      @@@enDesc:
        A code to obtain the <QUOTE::dis> document object
        from the name URI of the module.
      
        The first parameter is the database object.

        The second parameter is the name URI of the module.

        The code must return a <QUOTE::dis> document object,
        which contains the source document of the module
        identified by the second parameter.  Even if no source
        file is found, or if the source file is not a valid
        source file, then the code must return a <QUOTE::dis>
        document object, though its content is implementation
        dependent.
    @@NamedParam:
      @@@Name: getModuleSourceDocumentFromResource
      @@@Type: DISPerl|CODE||ManakaiDOM|all
      @@@enDesc:
        The <CODE::resolver> parameter to the <M::disdb.loadModule>
        method.
    @@NamedParam:
      @@@Name: getModuleSourceRevision
      @@@Type: DISPerl|CODE||ManakaiDOM|all
      @@@enDesc:
        A code to obtain the revision number of the module source
        file.

        The first parameter is the database object.

        The second parameter is the name URI of the module.

        The code must return a number, which represents the
        revision number of the source file of the module
        identified by the second parameter.  It will be compared
        with <A::anyres.revision> attribute value of the current
        module object in the database.  If there is no source
        file for the module or it cannot obtain the revision number,
        then the code must return a zero.  Otherwise, it must
        return a positive number.
    @@NamedParam:
      @@@Name: getReferringModuleURIList
      @@@Type: DISPerl|CODE||ManakaiDOM|all
      @@@enDesc:
        A code to return a list of URIs of modules referenced
        from a module source file.

        The first parameter is the database object.

        The second parameter is the name URI of the module.

        The code must return a reference to an array, which
        contains name URIs that identify modules referenced
        from the module source file identified by the second parameter.
    @@NamedParam:
      @@@Name: onResourceRead
      @@@Type: DISPerl|CODE||ManakaiDOM|all
      @@@enDesc:
        The <CODE::onResourceRead> parameter to the
        <M::disdb.loadModule> method.
    @@Return:
      @@@PerlDef:
        __DEEP{
          my $db = $self;

          ## -- Creates a list of modules that must be updated
          my $update_module = {};
          my $target_module = {map {$_->[0] => true} @$modules};
          my $checked_module = {};
          my %update_read;
          T: while (%$target_module) {
            my $target_module_uri = [keys %$target_module]->[0];
            delete $target_module->{$target_module_uri};
            next T if $checked_module->{$target_module_uri};
            $checked_module->{$target_module_uri} = true;

            unless (defined $db->{modDef}->{$target_module_uri}) {
              my $target_module_file_name
                = $getModuleIndexFileName->($db, $target_module_uri);
              if (-f $target_module_file_name) {
                $db-><M::DISDatabasePerl.plLoadDISDatabaseIndex>
                       ($target_module_file_name);
              }
            }
            my $target_module_resource = $db-><M::disdb.getModule>
                                                  ($target_module_uri);
            
            my $source_revision
              = $getModuleSourceRevision->($db, $target_module_uri);
            my $target_module_revision
              = $target_module_resource-><AG::anyres.revision>;
            if ($source_revision > 0 and
                ($source_revision > $target_module_revision or
                 $target_module_revision == 0)) {
              for (@{$getReferringModuleURIList->($db, $target_module_uri)}) {
                $target_module->{$_} = true;
              }
              $update_module->{$target_module_uri} = true;
              $update_read{$target_module_uri}->{<Q::ManakaiDOM|all>} = true;
            } else { # Source is not updated
              for (@{$target_module_resource
                       -><M::DIS|DISModule.getReferringModuleURIList>}) {
                $target_module->{$_} = true;
              }
            }
          } # T


          ## Removes modules that need update
          my $srinfo = {};
          for my $mod (@{$db-><M::disdb.getModuleResourceList>}) {
            my $mod_uri = $mod-><AG::anyres.nameURI>;
            if ($update_module->{$mod_uri}) {
              my $mod_for = $mod-><AG::anyres.forURI>;
              $update_read{$mod_uri}->{$mod_for} = true;
              __UNDEEP{__DOMCore:ERROR{dp|info-unload-module-start::
                DIS|uri => {$mod_uri},
                DIS|forURI => {$mod_for},
              }__}__;
              $srinfo = $db-><M::disdb.unloadModule> ($mod, srinfo => $srinfo);
              __UNDEEP{__DOMCore:ERROR{dp|info-unload-module-end::
                DIS|uri => {$mod_uri},
                DIS|forURI => {$mod_for},
              }__}__;
            }
          }

          for (@$modules) {
            my ($mod_name, $mod_for) = @$_;
            my $tfuri;
            unless (defined $mod_for) {
              $mod_for = <Q::ManakaiDOM|all>;
              if (defined $db->{modDef}->{$mod_name} and
                  defined $db->{modDef}->{$mod_name}->{<Q::dis|DefaultFor>}) {
                $mod_for = $db-><M::disdb.getModule> ($mod_name)
                              -><M::DIS|DISResourceProp.getPropertyText>
                                  (<Q::dis|DefaultFor>, <Q::ManakaiDOM|all>);
              } else {
                my $mod_doc = $getModuleSourceDocumentFromURI
                                ->($db, $mod_name, $mod_for);
                my $mod_el = $mod_doc-><AG::DIS|DISDocument.moduleElement>;
                if ($mod_el) {
                  $mod_for = $mod_el-><AG::DIS|DISModuleElement.defaultForURI>;
                }
              }
            }
            __CODE{DIS|tfurisToURI:: $turi => $mod_name, $furi => $mod_for,
                                     $uri => $tfuri}__;
            unless (defined $db->{modDef}->{$tfuri}) {
              $update_read{$mod_name}->{$mod_for} = true;
            }
          }

          ## Reads updated sources
          for my $mod_name (keys %update_read) {
            for my $mod_for (keys %{$update_read{$mod_name}}) {
              $db-><M::disdb.loadModule>
                     ($getModuleSourceDocumentFromURI
                        ->($db, $mod_name, $mod_for),
                      $getModuleSourceDocumentFromResource,
                      for_arg => $mod_for, on_resource_read => $onResourceRead,
                      srinfo => $srinfo);
            }
          }
        }__;

  @Method:
    @@Name: plLoadDISDatabaseIndex
    @@enDesc:
      Loads a <QUOTE::dis> database index file and merge
      it into the database.
    @@Param:
      @@@Name: fileName
      @@@Type: DISString
      @@@enDesc:
        The environment dependent file path name of the database
        index file.
    @@Return:
      @@@PerlDef:
        use Storable qw/retrieve/;
        local $Carp::CarpLevel = $Carp::CarpLevel + 1;
        __DOMCore:ERROR{dp|info-open-database-module-index-start::
          DIS|fileName => {$fileName},
        }__;
        my $idb = retrieve $fileName;
        __DOMCore:ERROR{dp|info-open-database-module-index-end::
          DIS|fileName => {$fileName},
        }__;

        require Scalar::Util;
        F: for my $imod_uri (keys %{$idb->{modDef}}) {
          my $imod = $idb->{modDef}->{$imod_uri};
          next F unless $imod;
          if (defined $self->{modDef}->{$imod_uri}) {
            next F if $imod eq $self->{modDef}->{$imod_uri};
            __DOMCore:ERROR{dp|error-module-is-already-in-database::
              DIS|uri => {$imod_uri},
            }__;
          }
          $self->{modDef}->{$imod_uri} = $imod;
          $imod->{db} = $self;
          Scalar::Util::weaken ($imod->{db});
        }

        F: for my $ires_uri (keys %{$idb->{<H::DIS|resourceModuleMap>}}) {
          next F unless $idb->{<H::DIS|resourceModuleMap>}->{$ires_uri};
          if (defined $self->{<H::DIS|resourceModuleMap>}->{$ires_uri}) {
            __DOMCore:ERROR{dp|error-resource-is-already-in-database::
              DIS|uri => {$ires_uri},
              DIS|moduleURI => {${$self->{<H::DIS|resourceModuleMap>}
                                       ->{$ires_uri}}},
            }__;
          }
          $self->{<H::DIS|resourceModuleMap>}->{$ires_uri}
            = $idb->{<H::DIS|resourceModuleMap>}->{$ires_uri};
        }

  @Attr:
    @@Name: plDatabaseModuleResolver
    @@enDesc:
      The database resource module file resolver.
      See <M::DISImplementationPerl.plLoadDISDatabase>.
    @@Type: DISPerl|CODE||ManakaiDOM|all
    @@Get:
      @@@PerlDef:
        $r = $self->{<H::dp|dbModuleResolver>};
    @@Set:
      @@@PerlDef:
        $self->{<H::dp|dbModuleResolver>} = $given;
##DISDatabasePerl

ElementTypeBinding:
  @Name: ErrDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DOMCore|DOMErrorType
    @@For: DIS|ForLatest
    @@ecore:textFormatter: ecore|MUErrorFormatter||ManakaiDOM|Perl
    @@DOMCore:severity: DOMCore|SEVERITY_ERROR||ManakaiDOM|ManakaiDOMLatest

ElementTypeBinding:
  @Name: InfoDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DOMCore|DOMErrorType
    @@For: DIS|ForLatest
    @@ecore:textFormatter: ecore|MUErrorFormatter||ManakaiDOM|Perl
    @@DOMCore:severity: DOMCore|SEVERITY_WARNING||ManakaiDOM|ManakaiDOMLatest

ErrDef:
  @QName: dp|error-module-is-already-in-database
  @enMufDef:
    Module <%p (name => {<Q::DIS|uri>});> is already in database
  @ecore:hasParameter:
    @@@: DIS|uri
    @@enDesc:
      The URI of the module.

ErrDef:
  @QName: dp|error-resource-is-already-in-database
  @enMufDef:
    Resource <%p (name => {<Q::DIS|uri>});> is already in 
    module <%p (name => {<Q::DIS|moduleURI>});>
  @ecore:hasParameter:
    @@@: DIS|uri
    @@enDesc:
      The URI of the resource.
  @ecore:hasParameter:
    @@@: DIS|moduleURI
    @@enDesc:
      The URI of the module in which <Q::DIS|uri> is already defined.

ElementTypeBinding:
  @Name: enMufDef
  @ElementType:
    ecore:defaultMessage
  @ShadowContent:
    @@ContentType:
      lang:muf
    @@lang:en

InfoDef:
  @QName: dp|info-open-database-module-resource-start
  @enDesc:
    Notifies that a database module resource file is being opened.
  @ecore:hasParameter:
    @@@: DIS|fileName
    @@enDesc:
      The name of the database module resource file.
  @enMufDef:
    Opening database module "%p (name => {<Q::DIS|fileName>});"...

InfoDef:
  @QName: dp|info-open-database-module-resource-end
  @enDesc:
    Notifies that a database module resource file has been opened.
  @ecore:hasParameter:
    @@@: DIS|fileName
    @@enDesc:
      The name of the database module resource file.
  @enMufDef: done

InfoDef:
  @QName: dp|info-open-database-module-index-start
  @enDesc:
    Notifies that a database module index file is being opened.
  @ecore:hasParameter:
    @@@: DIS|fileName
    @@enDesc:
      The name of the database module index file.
  @enMufDef:
    Opening database module index "%p (name => {<Q::DIS|fileName>});"...

InfoDef:
  @QName: dp|info-open-database-module-index-end
  @enDesc:
    Notifies that a database module index file has been opened.
  @ecore:hasParameter:
    @@@: DIS|fileName
    @@enDesc:
      The name of the database module index file.
  @enMufDef: done

InfoDef:
  @QName: dp|info-unload-module-start
  @enDesc:
    Notifies that a module is being unloaded.
  @ecore:hasParameter:
    @@@: DIS|uri
    @@enDesc:
      The name URI of the module.
  @ecore:hasParameter:
    @@@: DIS|forURI
    @@enDesc:
      The <QUOTE::for> URI of the module.
  @ecore:hasParameter:
    @@@: DIS|resource
    @@enDesc:
      The module.
  @enMufDef:
    Removing module <%p (name => {<Q::DIS|uri>});> for
    <%p (name => {<Q::DIS|forURI>});> from database...

InfoDef:
  @QName: dp|info-unload-module-end
  @enDesc:
    Notifies that a module has been unloaded.
  @ecore:hasParameter:
    @@@: DIS|uri
    @@enDesc:
      The name URI of the module.
  @ecore:hasParameter:
    @@@: DIS|forURI
    @@enDesc:
      The <QUOTE::for> URI of the module.
  @ecore:hasParameter:
    @@@: DIS|resource
    @@enDesc:
      The module.
  @enMufDef: done

ResourceDef:
  @QName: dp|ModuleIndexFile
  @DISCore:resourceType: DISCore|Resource
  @For: =ManakaiDOM|all

ResourceDef:
  @QName: dp|ModuleResourceFile
  @DISCore:resourceType: DISCore|Resource
  @For: =ManakaiDOM|all

PropDef:
  @QName: dp|dbModuleResolver
  @enDesc:
    A code reference, which converts <QUOTE::dis> module
    into a file name path.
  @DIS:key: dbmodcode

PropDef:
  @QName: dp|plHashKey
  @enDesc:
    See <M::DISDatabasePerl.plAddHashKey>.

ElementTypeBinding:
  @Name: SimpleException
  @ElementType:
    dis:Description
  @ShadowContent:
    @@lang:en
    @@@:
      - Exception of type <PerlModule::Error::Simple>::: 
             I/O error or other error reported by <PerlModule::Storable>. 
   @@ImplNote:
     @@@lang:en
     @@@@:
       {TODO:: Formal description required for simple exception}


ElementTypeBinding:
  @Name: disPerlException
  @ElementType:
    ManakaiDOM:raises
  @ShadowContent:
    @@@: DIS|DISPERL_NO_VALUE_ALLOWED_ERR
    @@Description:
      @@@lang:en
      @@@@:
        An element value is specified where it is not allowed.
  @ShadowSibling:
    @@ManakaiDOM:raises:
      @@@@: DIS|RESOURCE_NOT_DEFINED_ERR
      @@@Description:
        @@@@lang:en
        @@@@@:
          An undefined resource is referred or a referred resource
          is defined but have different type than the one expected.
    @@ManakaiDOM:raises:
      @@@@: DIS|NO_CONST_VALUE_ERR
      @@@Description:
        @@@@lang:en
        @@@@@:
          A constant value definition does not have its <Q::dis:Value>
          attribute.
    @@ManakaiDOM:raises:
      @@@@: DIS|NO_METHOD_RETURN_ERR
      @@@Description:
        @@@@lang:en
        @@@@@:
          A method definition does not have a <Q::DISLang:MethodReturn>
          child resource.
    @@ManakaiDOM:raises:
      @@@@: DIS|NO_ATTR_GET_ERR
      @@@Description:
        @@@@lang:en
        @@@@@:
          An attribute definition does not have a <Q::DISLang:AttributeGet>
          child resource.
    @@ManakaiDOM:raises:
      @@@@: DIS|NO_ATTR_SET_ERR
      @@@Description:
        @@@@lang:en
        @@@@@:
          An attribute setter is referred but the attribute definition
          does not have <Q::DISLang:AttributeSet> child resource.
    @@ManakaiDOM:raises:
      @@@@: DIS|UNSUPPORTED_ELEMENT_TYPE_ERR
      @@@Description:
        @@@@lang:en
        @@@@@:
          An unsupported type of element has appeared.

## -- DIS resources

IFClsDef:
  @IFQName: DISAnyResourcePerl
  @ClsQName: ManakaiDISAnyResourcePerl
  
  @enDesc:
    The objects implementing the <IF::DISAnyResourcePerl> interface
    <kwd:MUST> also implement the <IF::DIS|DISAnyResource> interface.
  
  @Attr:
    @@Name: plImplementation
    @@enDesc:
      The implementation object, which the object belongs to and
      which implements the feature <Feature::Util|PerlCode>
      version <FeatureVer::1.0>.
    @@Type: DIS|MPLImpl
    @@Get:
      @@@enDesc:
        The Perl code implementation object. 
      @@@nullCase:
        @@@@enDesc:
          There is no implementation that supports the feature
          <Feature::Util:PerlCode> version <FeatureVer::1.0> or
          the resource has no source element associated.
      @@@RaiseException:
        @@@@@: DIS|NO_PERL_CODE_IMPL_ERR
        @@@@enDesc:
          There is no implementation that implements 
          the <Feature::Util:PerlCode> feature, version <FeatureVer::1.0>. 
      @@@PerlDef:
        $r = <Class::PLImplClass>->_new;
                                   ## NOTE: Method name is directly written.
##DISAnyResourcePerl

IFClsDef:
  @IFQName: DISModulePerl
  @ClsQName: ManakaiDISModulePerl

  @enDesc:
    The objects implementing the <IF::DISModulePerl> interface
    <kwd:MUST> also implement the <IF::DIS|DISModule> interface.

  @Attr:
    @@Name: plFullyQualifiedName
    @@enDesc:
      The fully-qualified Perl class package name. 
    @@Type:
      pl:package-name::ManakaiDOM:all
    @@Get:
      @@@NoPerlModuleNameException:
      @@@PerlDef:
        __DEEP{
          my $man = $self-><M::DIS|DISResourceProp.getPropertyValue>
                             (<Q::DISPerl:packageName>);
          if ($man) {
            $r = $man-><AG::dv|DVValue.stringValue>;
          } else {
            my $mg = $self-><AG::DIS|DISAnyResource.database>
                          -><M::DIS|DISDatabase.getResource>
                             ($self-><AG::DIS|DISAnyResource.namespaceURI>,
                              for_arg => $self-><AG::DIS|DISAnyResource.forURI>);
            unless ($self-><AG::DIS|DISAnyResource.isDefined>) {
              __UNDEEP{__EXCEPTION{DIS|RESOURCE_NOT_DEFINED_ERR::
                DIS:uri => {$self-><AG::DIS|DISAnyResource.namespaceURI>},
                DIS:sourceNode =>
                          {$self-><AG::DIS|DISAnyResource.sourceElement>},
              }__}__;
            }
            my $an = $mg-><M::DIS|DISResourceProp.getPropertyValue>
                             (<Q::DISPerl:packageName>);
            $r = $an ? $an-><AG::dv|DVValue.stringValue>
                     : $mg-><AG::DIS|DISAnyResource.localName> || 'main';
            $r =~ s/::$//g;
            $r .= '::' . $self-><AG::DIS|DISAnyResource.localName>;
            my $sf = $an-><M::dv|DVValue.getProperty>
                             (<Q::ManakaiDOM:moduleSuffix>) if $an;
            $r .= $sf-><AG::dv|DVValue.stringValue> if $sf;
          }
        }__;

  @Attr:
    @@Name: plInterfaceName
    @@enDesc:
      The fully-qualified Perl interface package name. 
    @@Type:
      pl:package-name::ManakaiDOM:all
    @@Get:
      @@@NoPerlModuleNameException:
      @@@PerlDef:
        __DEEP{
          my $man = $self-><M::DIS|DISResourceProp.getPropertyValue>
                             (<Q::DISPerl:interfacePackageName>) ||
                    $self-><M::DIS|DISResourceProp.getPropertyValue>
                             (<Q::DISPerl:packageName>);
          if ($man) {
            $r = $man-><AG::dv|DVValue.stringValue>;
          } else {
            my $mg = $self-><AG::DIS|DISAnyResource.database>
                          -><M::DIS|DISDatabase.getResource>
                             ($self-><AG::DIS|DISAnyResource.namespaceURI>,
                              for_arg => $self-><AG::DIS|DISAnyResource.forURI>);
            unless ($self-><AG::DIS|DISAnyResource.isDefined>) {
              __UNDEEP{__EXCEPTION{DIS|RESOURCE_NOT_DEFINED_ERR::
                DIS:uri => {$self-><AG::DIS|DISAnyResource.namespaceURI>},
                DIS:sourceNode =>
                          {$self-><AG::DIS|DISAnyResource.sourceElement>},
              }__}__;
            }
            my $an = $mg-><M::DIS|DISResourceProp.getPropertyValue>
                             (<Q::DISPerl:interfacePackageName>) ||
                     $mg-><M::DIS|DISResourceProp.getPropertyValue>
                             (<Q::DISPerl:packageName>);
            if ($an) {
              $r = $an-><AG::dv|DVValue.stringValue>;
              $r =~ s/::$//g;
              my $sf = $an-><M::dv|DVValue.getProperty>
                               (<Q::ManakaiDOM:moduleSuffix>);
              $r .= $sf-><AG::dv|DVValue.stringValue> if $sf;
            } else {
              $r = $self-><AG::DISModulePerl.plFullyQualifiedName>;
            }
          }
        }__;
##DISModulePerl

ElementTypeBinding: 
  @Name: NoPerlModuleNameException
  @ElementType:
    ManakaiDOM:raises
  @ShadowContent:
    @@@: DIS|RESOURCE_NOT_DEFINED_ERR
    @@Description:
      @@@lang:en
      @@@@:
        The module group corresponding to the namespace URI
        of this module is not defined. 

IFClsDef:
  @IFQName: DISResourcePerlModule
  @ClsQName: DIS|ManakaiDISPerlModuleDefinition

  @enDesc:
    A class inherited by classes whose object might (but not necessarily) define
    a Perl module. 
  @ImplNote:
    @@lang:en
    @@@:
      Any object whose class inheriting this class must also inherit
      the <Class::DIS|ManakaiDISPropertyAccessor> class.
  
  @Method:
    @@Name: plGeneratePerlModuleFile
    @@enDesc:
      Generates a Perl file object. 
    @@Return:
      @@@Type: DIS|PLFile
      @@@enDesc:
        A Perl file object generated from this resource.
      @@@RaiseException:
        @@@@@:DIS|NO_LICENSE_ATTR_ERR
        @@@@enDesc:
          The <Q::dis:Module> element does not have the
          <Q::dis:License> attribute.
      @@@NoPerlModuleNameException:
      @@@RaiseException:
        @@@@@:DIS|RESOURCE_NOT_DEFINED_ERR
        @@@@enDesc:
          A feature referred from this module is not defined.
      @@@RaiseException:
        @@@@@:DIS|RESOURCE_NOT_DEFINED_ERR
        @@@@enDesc:
          A markup vocabulary is referred but it is not defined
          or have a different type than the expected one.
      @@@PerlDef:
        __DEEP{
          $r = $self-><AG::DISAnyResourcePerl.plImplementation>
                    -><M::DIS|MPLImpl.createPerlFile>;

          ## -- Source information
          $r-><AS::DIS|PLFile.sourceFile>
                 ($self-><M::DIS|DISResourceProp.getPropertyText>
                                (<Q::DIS:sourceFile>, ''));
          $r-><AS::DIS|PLFile.sourceModule>
                  ($self-><AG::DIS|DISAnyResource.nameURI>);
          $r-><AS::DIS|PLFile.sourceFor>
                                ($self-><AG::DIS|DISAnyResource.forURI>);
          
          ## -- License information
          my $ownermod = $self-><AG::DIS|DISAnyResource.ownerModule>;
          my $license = $ownermod-><M::DIS|DISResourceProp
                                     .getPropertyResource> (<Q::dis:License>);
          unless ($license) {
            __UNDEEP{__EXCEPTION{DIS|NO_LICENSE_ATTR_ERR::
              DIS:sourceNode => {$ownermod-><AG::DIS|DISAnyResource
                                                  .sourceElement>},
              DIS:uri => {$ownermod-><AG::DIS|DISAnyResource.uri>},
            }__}__;
          }
          $r-><AS::DIS|PLFile.licenseURI>
                            ($license-><AG::DIS|DISAnyResource.uri>);

          ## -- Classes
          ## TODO: Custom module construction support
          my $thismod_name = $self-><AG::DISModulePerl.plFullyQualifiedName>;
          my $thismod_pack = $r-><M::DIS|PLFile.getLastPackage>
                                     ($thismod_name, make_new_package => true);
          my %const;
          my %processed_class;
          for my $cls (@{$self-><M::DIS|DISModule.getResourceList>}) {
            if ($cls-><AG::DIS|DISAnyResource.ownerModule>
                   eq $ownermod and
                not $processed_class{$cls-><AG::DIS|DISAnyResource.uri>}) {
              $processed_class{$cls-><AG::DIS|DISAnyResource.uri>}
                = true;
              
              my $mcode = $cls-><M::DISResourcePerl.getPerlModuleMemberCode>
                                  ($r-><AG::Node.ownerDocument>,
                                   $thismod_pack, \%const);
              if ($mcode) {
                $r-><AG::Node.ownerDocument>
                  -><M::Document.adoptNode> ($mcode);
                $r-><M::Node.appendChild> ($mcode);
              }

              if ($cls-><M::DIS|DISAnyResource.isTypeURI>
                              (<Q::DISLang:Interface>)) {
              }
            } # ownermodule and not alias
          } # Classes

          ## -- Exporter (constants)
          if (keys %const) {
            my $map = <ClassM::PLImplClass.perlLiteral> (\%const);
            $thismod_pack-><M::DIS|PLBlockCon.appendStatement> ("sub $_ ()")
              for sort {$a cmp $b} keys %const;
            $thismod_pack-><M::DIS|PLPack.getSub> ('AUTOLOAD',
                                                   make_new_node => true)
              -><M::DIS|PLBlockCon.appendCode> (q[
                my $al = our $AUTOLOAD;
                $al =~ s/.+:://;
                if (] . $map . q[->{$al}) {
                  no strict 'refs';
                  *{$AUTOLOAD} = \&{] . $map . q[->{$al}};
                  goto &{$AUTOLOAD};
                } else {
                  require Carp;
                  Carp::croak (qq<Can't locate method "$AUTOLOAD">);
                }
              ]);
            $thismod_pack-><M::DIS|PLPack.getSub> ('import',
                                                   make_new_node => true)
              -><M::DIS|PLBlockCon.appendCode> (q[
                my $self = shift;
                if (@_) {
                  local $Exporter::ExportLevel = $Exporter::ExportLevel + 1;
                  $self->SUPER::import (@_);
                  for (grep {not /\W/} @_) {
                    eval qq{$_};
                  }
                }
              ]);
          }

          ## -- Require'ing external modules
          ## TODO: Custom module construction support
          for my $uri (@{$r-><M::DIS|MPLCodeFragment.disGetRequireURIList>}) {
            my $mod = $self->{db}-><M::DIS|DISDatabase.getAnyResource> ($uri)
                           -><AG::DIS|DISAnyResource.ownerModule>;
            next unless $mod;
            my $pack = $mod-><AG::DISModulePerl.plFullyQualifiedName>;
            $r-><M::DIS|MPLCodeFragment.addRequirePerlModuleName> ($pack)
              unless $pack eq $thismod_name;
          }
        }__;

  @Method:
    @@Name: plIsFeatureImplemented
    @@enDesc:
      Returns whether a feature is implemented by this module
      or resource or not. 
      \
      {NOTE:: For modules, tests for features not provided
              by the modules will return <DOM::true>.  For 
              resources, if it does not provides the support
              for the feature, then this method will return <DOM::true>.
      \
      }
      \
      {NOTE:: Feature inheritances are not taken into account.
      \
      }
    @@Param:
      @@@Name:featureResourceURI
      @@@Type: DIS|ResourceURI
      @@@enDesc:
        The URI reference of the resource definition for 
        the feature to test.
    @@Return:
      @@@Type:
        DOMMain:boolean::ManakaiDOM:all
      @@@enDesc:
        Whether the feature is implemented or not.
      @@@PerlDef:
      __DEEP{
        if (defined $self->{<H::DIS:isFeatureImplemented>}
                         ->{$featureResourceURI}) {
          $r = $self->{<H::DIS:isFeatureImplemented>}
                         ->{$featureResourceURI};
        } elsif ($self->isa (<ClassName::DIS|ManakaiDISModuleDefinition>)) {
          $r = true;
          C: for my $cls (@{$self-><M::DIS|DISModule.getResourceList>}) {
            if ($cls-><AG::DIS|DISAnyResource.ownerModule> eq $self and
                $cls-><M::DIS|DISAnyResource.isTypeURI> (<Q::DISLang:Class>)) {
              unless ($cls-><M::dp|DISResourcePerlModule.plIsFeatureImplemented>
                                      ($featureResourceURI)) {
                $r = false;
                last C;
              }
            }                
            ## NOTE: |DISPerl:ScalarVariable|s and interfaces are
            ##       always implemented
          }
          $self->{<H::DIS:isFeatureImplemented>}
                         ->{$featureResourceURI} = $r;
        } else { ## Resource definition
          ## TODO: Custom module definition
          if ($self-><M::DIS|DISResource.isFeatureProvided>
                              ($featureResourceURI)) {
            if ($self-><M::DIS|DISAnyResource.isTypeURI>
                              (<Q::DISLang:MethodReturn>) or
                $self-><M::DIS|DISAnyResource.isTypeURI>
                              (<Q::DISLang:AttributeGet>) or
                $self-><M::DIS|DISAnyResource.isTypeURI>
                              (<Q::DISLang:AttributeSet>)) {
              my $def = $self-><M::DIS|DISResourceProp.getPropertyValue>
                                (<Q::dis:Def>);
              $r = $def-><AG::dv|DVList.length>;
            } else {
              $r = true;
              C: for my $res (@{$self-><M::DIS|DISResource
                                                   .getChildResourceList>}) {
                if ($res-><M::DIS|DISAnyResource.isTypeURI>
                              (<Q::DISLang:AnyMethod>)) {
                  unless ($res-><M::DISResourcePerlModule
                                 .plIsFeatureImplemented>
                              ($featureResourceURI)) {
                    $r = false;
                    last C;
                  }
                }
              } # for C
            } # self.type
          } else {
            $r = true;
          }
          $self->{<H::DIS:isFeatureImplemented>}->{$featureResourceURI} = $r;
        }
      }__;
##DISResourcePerlModule

ResourceDef:
  @QName: Node
  @AliasFor: Tree|Node||ManakaiDOM|ManakaiDOMLatest
  @For: DIS|ForLatest

ResourceDef:
  @QName: Document
  @AliasFor: Tree|Document||ManakaiDOM|ManakaiDOMLatest
  @For: DIS|ForLatest

PropDef:
  @QName: dp|plName
  @enDesc:
    <A::DISResourcePerl||DIS|ForLatest.plName>.

ElementTypeBinding:
  @Name: TMethods
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType:
      @@@@: dis|MultipleResource
      @@@ForCheck: !ManakaiDOM|ForClass
    @@resourceFor: ManakaiDOM|ForClass
    @@DISCore:resourceType: DISCore|Resource
    @@For: DIS|ForLatest

ElementTypeBinding:
  @Name: TMethod
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass
    @@DISCore:resourceType: DIS|Method

ElementTypeBinding:
  @Name: TAttr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass
    @@DISCore:resourceType: DIS|Attribute

ResourceDef:
  @QName: anyres
  @AliasFor: DIS|DISAnyResource
  @For: DIS|ForEmpty

ElementTypeBinding:
  @Name: CODE
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISPerl|BlockCode
    @@ForCheck: ManakaiDOM|ForClass

IFClsDef:
  @IFQName: DISResourcePerl
  @ClsQName: ManakaiDISResourcePerl

  @enDesc:
    The objects implementing the <IF::DISResourcePerl> interface
    <kwd:MUST> also implement the <IF::DIS|DISResource> interface.

  @Attr:
    @@Name: plName
    @@enDesc:
      The Perl name of this resource. 
    @@Get: 
      @@@Type: DISString
      @@@nullCase:
        @@@@enDesc:
          Either the type of this resource is not listed above 
          or this Perl constructure is anonymous. 
      @@@RaiseException:
        @@@@@: DIS|NO_LOCAL_NAME_ERR
        @@@@enDesc:
          The type of this resource is either 
          <Q::ManakaiDOM:Const> or <Q::ManakaiDOM:ConstGroup> and 
          the local name of this resource is not defined. 
      @@@RaiseException:
        @@@@@: DIS|RESERVED_PERL_METHOD_NAME_ERR
        @@@@enDesc:
          The Perl method name constructed from the source 
          result in a reserved name. 
      @@@PerlDef:
        my $method;
        __CODE{DIS|getMethodForType::
          $resource => $self,
          $method_name => 'pl_name',
          $method => $method,
        }__;
        if ($method) {
          __DEEP{
            $r = $method->(@_);
          }__;
        } else {
          $r = null;
        } 

  @Method:
    @@Name: getPerlNameList
    @@enDesc:
      Returns a list of Perl method names assigned to the resource.
    @@Return:
      @@@Type: DISPerl|ARRAY||ManakaiDOM|all
      @@@enDesc:
        An unordered snapshot list of Perl names.
      @@@RaiseException:
        @@@@@: DIS|RESERVED_PERL_METHOD_NAME_ERR
        @@@@enDesc:
          The Perl method name constructed from the source 
          result in a reserved name. 
      @@@PerlDef:
        __DEEP{
          ## Primary name
          my $nm = $self-><M::DIS|DISResourceProp.getPropertyTextList>
                                     (<Q::DISPerl:methodName>);
          if (@$nm > 0) {
            push @$r, @$nm;
            ## NOTE: No reserved name checks enforced in this case
          } elsif (defined (my $ln = $self-><AG::DIS|DISAnyResource
                                                               .localName>)) {
            $nm = <ClassM::DIS|ManakaiDISImplementation
                           .camelCaseToUnderscoreName> ($ln);
            if ($self-><M::DIS|DISResourceProp.getPropertyBoolean>
                                (<Q::ManakaiDOM:isForInternal>)) {
              $nm = '_' . $nm;
            }
            if ({
                    import => 1,
                    unimport => 1,
                    isa => 1,
                    can => 1,
                    new => 1,
                    as_string => 1,
                    stringify => 1,
                    clone => 1,
                }->{$nm} or $nm =~ /^___/) {
              __UNDEEP{__EXCEPTION{DIS|RESERVED_PERL_METHOD_NAME_ERR::
                  DIS:uri => {$self-><AG::DIS|DISAnyResource.uri>},
                  DIS:sourceNode =>
                             {$self-><AG::DIS|DISAnyResource.sourceElement>},
                  DIS:generatedName => {$nm},
                }__;
              }__;
            }
            push @$r, $nm;
          }

          ## Names specified via "dis:Operator" attributes
          for my $opv (@{$self-><M::DIS|DISResourceProp.getPropertyValueList>
                             (<Q::dis:Operator>)}) {
            if ($opv->isa (<IFName::dv|DVURIValue>)) {
              my $op_uri = $opv-><AG::dv|DVURIValue.uri>;
              my $nm = {
                       <Q::ManakaiDOM:MUErrorHandler> => '___report_error',
                       <Q::ecore:ErrorDefMethod> => '___error_def',
                       <Q::DISPerl:AsStringMethod> => 'stringify',
                       <Q::DISPerl:NewMethod> => 'new',
                       <Q::DISPerl:CloneMethod> => 'clone',
                       <Q::DISPerl:ImportMethod> => 'import',
                       <Q::DISPerl:CanMethod> => 'can',
                       <Q::DISPerl:UnimportMethod> => 'unimport',
                       <Q::DISPerl:VERSIONMethod> => 'VERSION',
                       <Q::DISPerl:ISAMethod> => 'isa',
                       <Q::DISLang:ArrayGet> => 'FETCH',
                       <Q::DISLang:ArraySet> => 'STORE',
                       <Q::DISLang:HashGet> => 'FETCH',
                       <Q::DISLang:HashSet> => 'STORE',
                       <Q::DISLang:ToString> => 'stringify',
                     }->{$op_uri};
              push @$r, $nm if defined $nm;
            } else {
              my $nm = $opv-><AG::dv|DVValue.stringValue>;
              if ($nm =~ /^[A-Z]+$/) {
                push @$r, $nm;
              }
            }
          } # operators
        }__;

  @Method:
    @@Name: getPerlOperatorList
    @@enDesc:
      Returns a list of Perl operators assigned to the resource.
    @@Return:
      @@@Type: DISPerl|ARRAY||ManakaiDOM|all
      @@@enDesc:
        An unordered snapshot list of Perl operators.
      @@@PerlDef:
        __DEEP{
          for my $opv (@{$self-><M::DIS|DISResourceProp.getPropertyValueList>
                             (<Q::dis:Operator>)}) {
            if ($opv->isa (<IFName::dv|DVURIValue>)) {
              my $op_uri = $opv-><AG::dv|DVURIValue.uri>;
              my $nm = {
                         <Q::DISPerl:AsStringMethod> => '""',
                         <Q::DISLang:ToString> => '""',
                       }->{$op_uri};
              push @$r, $nm if defined $nm;
            } else {
              my $nm = $opv-><AG::dv|DVValue.stringValue>;
              if ($nm !~ /^[A-Z]+$/) {
                push @$r, $nm;
              }
            }
          } # operators
        }__;

  @Attr:
    @@Name: plFullyQualifiedName
    @@enDesc:
      The fully-qualified Perl name of this resource. 
    @@Type: DISString
    @@Get:
      @@@enDesc:
        Fully-qualified name.
      @@@nullCase:
        @@@@enDesc:
          Otherwise. 
      @@@NoPerlModuleNameException:
      @@@RaiseException:
        @@@@@: DIS|NO_LOCAL_NAME_ERR
        @@@@enDesc:
          The local name of this resource is not defined. 
      @@@PerlDef:
        if (exists $self->{<H::dp|plFullyQualifiedName>}) {
          $r = $self->{<H::dp|plFullyQualifiedName>};
        } else {
          my $method;
          __CODE{DIS|getMethodForType::
            $resource => $self,
            $method_name => 'pl_fully_qualified_name',
            $method => $method,
          }__;
          if ($method) {
            __DEEP{
              $self->{<H::dp|plFullyQualifiedName>} = $r = $method->(@_);
            }__;
          } else {
            $self->{<H::dp|plFullyQualifiedName>} = $r = null;
         } 
       }

  @Attr:
    @@Name: plVariableName
    @@enDesc:
      The Perl variable name with prefix.
    @@Type:
      lang:Perl::ManakaiDOM:all
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          This resource does not define any Perl variable.
      @@@PerlDef:
        $r = $self-><M::DIS|DISResourceProp.getPropertyText>
                      (<Q::DISPerl:variableName>,
                       $self-><AG::DIS|DISAnyResource.localName>);
        if (defined $r) {
          __DEEP{
            if ($self-><M::DIS|DISResourceProp.getPropertyBoolean>
                                 (<Q::DISPerl:isNamedParameter>, false)) {
              $r = '$opt{' . 
                 <ClassM::DIS|ManakaiDISImplementation.camelCaseToUnderscoreName>
                                                       ($r) .
                   '}';
            } else {
              my $dt = $self-><AG::DIS|DISResource
                                 .disActualDataTypeResource>;
              if ($dt-><M::DIS|DISResource.isSubsetOfURI>
                                                       (<Q::DISPerl:Array>) or
                  $dt-><M::DIS|DISResource.isSubsetOfURI> (<Q::DISPerl:List>)) {
                $r = '@' . $r;
              } elsif ($dt-><M::DIS|DISResource.isSubsetOfURI>
                                                       (<Q::DISPerl:Hash>)) {
                $r = '%' . $r;
              } else {
                $r = '$' . $r;
              }
            }
          }__;
        }

  @Attr:
    @@Name: plPrototype
    @@enDesc:
      The Perl parameter prototype character.
    @@Type:
      lang:Perl::ManakaiDOM:all
    @@Get:
      @@@PerlDef:
          __DEEP{
            my $dt = $self-><AG::DIS|DISResource
                                 .disActualDataTypeResource>;
            if ($dt-><M::DIS|DISResource.isSubsetOfURI>
                                                       (<Q::DISPerl|Array>)) {
              $r = '@' . $r;
            } elsif ($dt-><M::DIS|DISResource.isSubsetOfURI>
                                                       (<Q::DISPerl|Hash>)) {
              $r = '%' . $r;
            } else {
              $r = '$' . $r;
            }
          }__;

  @Attr:
    @@Name: plCodeFragment
    @@enDesc:
      Perl code definition fragment of this resource. 
    @@Type: DIS|MPLCodeFragment
    @@Get:
      @@@enDesc:
        Perl code.
      @@@nullCase:
        @@@@enDesc:
          This node does not have Perl code definition. 
      @@@RaiseException:
        @@@@@: DIS|NO_METHOD_RETURN_ERR
        @@@@enDesc:
          This resource is a <Q::DISLang:Method> but it does not 
          have <Q::DISLang:MethodReturn> child-resource. 
      @@@RaiseException:
        @@@@@: DIS|NO_ATTR_GET_ERR
        @@@@enDesc:
          This resource is a <Q::DISLang:Attribute> but it does not 
          have <Q::DISLang:AttributeGet> child-resource.
      @@@RaiseException:
        @@@@@: DIS|UNSUPPORTED_MEDIA_TYPE_ERR
        @@@@enDesc:
          The media type of <Q::dis:Def> element is not supported.
      @@@RaiseException:
        @@@@@: DIS|NON_NAMED_PARAMETER_AFTER_NAMED_ERR
        @@@@enDesc:
          A non-named method paarameter is defined after
          a named method parameter appeared.
      @@@disPerlException:
      @@@InlineElementException:
      @@@BlockElementException:
      @@@RaiseException:
        @@@@@: DIS|PERL_SUBROUTINE_ALREADY_DEFINED_ERR
        @@@@enDesc:
          A resource defines a Perl subroutine whose name is
          same as the name of another subroutine. 
      @@@RaiseException:
        @@@@@: DIS|PERL_OPERATOR_ALREADY_OVERLOADED_ERR
        @@@@enDesc:
          A resource is defined to overload an operator 
          that is also defined to be overloaded by another resource.
      @@@RaiseException:
        @@@@@: DIS|PERL_UNUSED_SUBROUTINE_ERR
        @@@@enDesc:
          A resource defines a Perl subroutine which is not
          used anywhere.
      @@@RaiseException:
        @@@@@: DIS|NO_REFLECT_GET_DEFINED_ERR
        @@@@enDesc:
          An attribute is defined to reflect an element attribute
          but no reflecting attribute getter template is defined.
      @@@RaiseException:
        @@@@@: DIS|NO_REFLECT_SET_DEFINED_ERR
        @@@@enDesc:
          An attribute is defined to reflect an element attribute
          but no reflecting attribute setter template is defined.
      @@@PerlDef:
        if (exists $self->{<H::DIS|plCodeFragment>}) {
          $r = $self->{<H::DIS|plCodeFragment>};
        } else {
          my $method;
          __CODE{DIS|getMethodForType::
            $resource => $self,
            $method_name => 'pl_code_fragment',
            $method => $method,
          }__;
          if ($method) {
            $r = $method->(@_);
          } else {
            $r = $self->{<H::DIS|plCodeFragment>} = null;
          } 
        }

  @Method:
    @@Name: getPerlModuleMemberCode
    @@enDesc:
      Generates a Perl code for the resource, for the use
      within Perl module.
    @@Param:
      @@@Name: factory
      @@@Type: PCDocument
      @@@enDesc:
        The document to which the newly created Perl code belongs.
    @@Param:
      @@@Name: thismod_pack
      @@@Type: DIS|PLPack
      @@@enDesc:
        The package of the module.
    @@Param:
      @@@Name: const
      @@@Type: DISPerl|HASH||ManakaiDOM|all
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The generated code.
      @@@nullCase:
        @@@@enDesc:
          If no code is defined for the type of the resource.
      @@@PerlDef:
        my $method;
        __CODE{DIS|getMethodForType::
          $resource => $self,
          $method_name => 'get_perl_module_member_code',
          $method => $method,
        }__;
        if ($method) {
          __DEEP{
            $r = $method->(@_);
          }__;
        } else {
          $r = null;
        } 

  @Method:
    @@Name: getPerlClassMemberCode
    @@enDesc:
      Generates a Perl code for the resource, for the use
      within Perl class.
    @@Param:
      @@@Name: factory
      @@@Type: PCDocument
      @@@enDesc:
        The document to which the newly created Perl code belongs.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The generated code.
      @@@nullCase:
        @@@@enDesc:
          If no code is defined for the type of the resource.
      @@@PerlDef:
        my $method;
        __CODE{DIS|getMethodForType::
          $resource => $self,
          $method_name => 'get_perl_class_member_code',
          $method => $method,
        }__;
        if ($method) {
          __DEEP{
            $r = $method->(@_);
          }__;
        } else {
          $r = null;
        } 

  @Method:
    @@Name: getPerlInterfaceMemberCode
    @@enDesc:
      Generates a Perl code for the resource, for the use
      within Perl interface.
    @@Param:
      @@@Name: factory
      @@@Type: PCDocument
      @@@enDesc:
        The document to which the newly created Perl code belongs.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The generated code.
      @@@nullCase:
        @@@@enDesc:
          If no code is defined for the type of the resource.
      @@@PerlDef:
        my $method;
        __CODE{DIS|getMethodForType::
          $resource => $self,
          $method_name => 'get_perl_interface_member_code',
          $method => $method,
        }__;
        if ($method) {
          __DEEP{
            $r = $method->(@_);
          }__;
        } else {
          $r = null;
        } 

  @Method:
    @@Name: getPerlDefinitionHashNamespace
    @@enDesc:
      Returns the Perl package name of the hash that should
      contain the definition of the resource.
    @@Return:
      @@@Type: DISString
      @@@enDesc:
        The namespace of the hash.
      @@@nullCase:
        @@@@enDesc:
          If no definition hash is defined for the resource.
      @@@PerlDef:
        my $method;
        __CODE{DIS|getMethodForType::
          $resource => $self,
          $method_name => 'get_perl_definition_hash_namespace',
          $method => $method,
        }__;
        if ($method) {
          __DEEP{
            $r = $method->(@_);
          }__;
        } else {
          $r = null;
        } 

  @Method:
    @@Name: getPerlErrorCodeName
    @@enDesc:
      Returns the name of the error code to which the resource belongs.
    @@Param:
      @@@Name: factory
      @@@Type: PCDocument
      @@@enDesc:
        The document to which the newly created Perl code belongs.
    @@Return:
      @@@Type: DISString
      @@@enDesc:
        The error code name.
      @@@nullCase:
        @@@@enDesc:
          If no error code name is defined.
      @@@PerlDef:
        my $method;
        __CODE{DIS|getMethodForType::
          $resource => $self,
          $method_name => 'get_perl_error_code_name',
          $method => $method,
        }__;
        if ($method) {
          __DEEP{
            $r = $method->(@_);
          }__;
        } else {
          $r = null;
        } 

  @Attr:
    @@Name: plAdditionalISAPackages
    @@enDesc:
      The current snapshot of the list of additional
      superclass package names (i.e. <Q::dis:AppISA>
      attributes values for Perl).
    @@Type: 
      pl:ARRAY::ManakaiDOM:all
    @@Get:
      @@@PerlDef:
        for my $t (@{$self-><M::DIS|DISResourceProp.getPropertyTextList>
                                 (<Q::dis:AppISA>)}) {
          push @$r, $t;
        }

  @ResourceDef:
    @@ForCheck: ManakaiDOM|ForClass
    @@Name: RegQNameChar
    @@enDesc:
      A regular expression character class for <Q::dis:TypeQName>
      character. 
    @@rdf:type:
      DISPerl:ScalarVariable
    @@DefaultValue:
      @@@@: qr/[^\s<>"'\/\\\[\]\{\},!\?=\$\@%]/
      @@@ContentType:
        lang:Perl
    @@Type:
      DOMMain:any::ManakaiDOM:all

  @ResourceDef:
    @@ForCheck: ManakaiDOM|ForClass
    @@Name: RegBlockContent
    @@enDesc:
      A regular expression for a block.
    @@rdf:type:
      DISPerl:ScalarVariable
    @@Type:
      DOMMain:any::ManakaiDOM:all
    @@DefaultValue:
      @@@@:
        qr/(?>[^{}\\]*)(?>(?>[^{}\\]+|\\.|\{(??{$RegBlockContent})\})*)/
      @@@ContentType:
        lang:Perl
    @@DISPerl:defaultValueHasSelfReference:1

  @Method:
    @@Name: plPreprocessPerlCode
    @@enDesc:
      Preprocesses a Perl block-level code fragment. 
    @@Param:
      @@@Name:codeArg
      @@@Type:
        lang:Perl::ManakaiDOM:all
      @@@enDesc:
        A Perl block-level code (statements and/or blocks).
    @@NodeParam:
    @@NamedParam:
      @@@Name:methodResource
      @@@Type: DIS|DISResource
      @@@clsActualType: DIS|ManakaiDISResourceDefinition
      @@@enDesc:
        The resource definition of the Perl method to which
        the <P::codeArg> belongs.
      @@@nullCase:
        @@@@enDesc:
          The <P::codeArg> does not belong to any method.
    @@NamedParam:
      @@@Name:sourceFile
      @@@Type:
        DISLang:String::ManakaiDOM:all
      @@@enDesc:
        The source file name of the <P::codeArg>.
      @@@nullCase:
        @@@@enDesc:
          No source file information available.
    @@NamedParam:
      @@@Name:sourceLine
      @@@Type:
        DOMMain:unsigned-long::ManakaiDOM:all
      @@@enDesc:
        The line number in the <P::sourceFile> from which
        the <P::codeArg> begins.
      @@@nullCase:
        @@@@enDesc:
          No source file information available.
    @@NamedParam:
      @@@Name: namespaceContext
      @@@Type: DIS|NSResolverDIS
      @@@enDesc:
        A namespace resolver.
      @@@nullCase:
        @@@@enDesc:
          <P::node> or implied one if any.
    @@Return:
      @@@Type: 
        lang:Perl::ManakaiDOM:all
      @@@enDesc:
        Preprocessed Perl code. 
      @@@BlockElementException:
      @@@InlineElementException:
      @@@PerlDef:
        __DEEP{
          my $nsr = $namespaceContext || $node || $self->{src};
          my $db = $self-><AG::DIS|DISAnyResource.database>;
          our $RegQNameChar;
          our $RegBlockContent;
          my $plimpl = $self-><AG::DISAnyResourcePerl.plImplementation>;
          $r = $plimpl-><M::DIS|MPLImpl.createPerlBlock>;
          if (defined $sourceLine) {
            $r-><AS::DIS|PLBlockCon.sourceFile> ($sourceFile);
            $r-><AS::DIS|PLBlockCon.sourceLine> ($sourceLine);
            $r-><AS::DIS|PLBlockCon.currentSourceFile> ($sourceFile);
            $r-><AS::DIS|PLBlockCon.currentSourceLine> ($sourceLine);
          } elsif ($node) {
            my $np = $node-><M::DIS|SWCFGNode.flag> ('nodePath') ||
                     $node-><M::DIS|SWCFGNode.nodePath>
                      (key => [qw/Name QName Type type/]);
            $r-><AS::DIS|PLBlockCon.currentSourceFile> ($np);
            $r-><AS::DIS|PLBlockCon.currentSourceLine> (1);
            $r-><AS::DIS|PLBlockCon.sourceFile> ($np);
            $r-><AS::DIS|PLBlockCon.sourceLine> (1);
          }
          
          for my $source_code (split /\b(_ _(?:(?!_ _)$RegQNameChar)+
                                           (?:\{$RegBlockContent\})?
                                         _ _)\b/x, $codeArg) {
            ## Block-level element
            if ($source_code =~ /_\_\z/ and
                $source_code =~ s/^_\_((?:(?!_\_)$RegQNameChar)+)//) {
              my $et = $nsr-><M::DIS|NSResolverDIS.qnameToURI>
                                     ($1,
                                      node => $node,
                                      default_namespace_uri => <Q::disPerl:>);
              if ($source_code =~ s/^\{//) {
                $source_code =~ s/\}__\z//;
              } else {
                $source_code = '';
              }

#  ## ISSUE: __FILE__ & __LINE__ will break if multiline substition happens.

              if ($et eq <Q::disPerl:DEEP> or $et eq <Q::disPerl:UNDEEP>) {
                my $block = $r-><M::DIS|PLBlockCon.appendBlock>;
                $block-><M::DIS|PLBlockCon.appendStatement>
                              ('local $Error::Depth = $Error::Depth '.
                               ($et eq <Q::disPerl:DEEP> ? '+' : '-').
                               ' 1');
                $block-><M::DIS|PLBlockCon.appendCodeFragment>
                          ($self-><M::DISResourcePerl
                                    .plPreprocessPerlCode>
                                       ($source_code,
                                        method_resource => $methodResource,
                                        source_file => $r-><AG::DIS|PLBlockCon
                                                          .currentSourceFile>,
                                        source_line => $r-><AG::DIS|PLBlockCon
                                                          .currentSourceLine>,
                                        node => $node,
                                        namespace_context=> $namespaceContext));
                $r-><M::DIS|PLBlockCon.skipLines> ($source_code);
              } elsif ({
                <Q::disPerl:EXCEPTION> => 1,
              }->{$et}) {
                $r-><M::DIS|PLBlockCon.skipLines> ($source_code);
                if ($source_code =~ s/^((?:(?!::).)+)(?:::\s*)?//s) {
                  my ($if, $const, $subtype)
                    = @{$db-><M::DIS|DISDatabase.xcrefToResource>
                                         ($1, $nsr,
                                          node => $node,
                            for_arg => $self-><AG::DIS|DISAnyResource.forURI>)};
                  my $cls = $if-><M::DIS|DISAnyResource.isTypeURI>
                                         (<Q::DISLang:Class>)
                          ? $if
                          : $if-><M::DIS|DISResourceProp.getPropertyResource>
                                         (<Q::dx:implementedBy>);
                  unless ($cls and
                          $cls-><M::DIS|DISAnyResource.isTypeURI>
                                         (<Q::DISLang:Class>)) {
                    __UNDEEP{__EXCEPTION{DIS|NO_EXCEPTION_CLASS_ERR::
                      DIS:uri => {$if-><AG::DIS|DISAnyResource.uri>},
                    }__}__;
                  }
                  my $param = $self-><M::ManakaiDISResourcePerl
                                        .plParsePreprocessParameter>
                                         ($source_code, node => $node,
                                        namespace_context=> $namespaceContext);
                  my $context_param
                            = $self-><M::ManakaiDISResourcePerl
                                        .plGetContextParameter>;

                  $self-><M::ManakaiDISResourcePerl.plAppendThrow>
                               ($r, $cls, $const, $subtype,
                                {%$param, %$context_param},
                                node => $node,
                                        namespace_context=> $namespaceContext);
                } else {
                 __UNDEEP{__EXCEPTION{DIS|PERL_PREPROCESS_NO_EXCEPTION_TYPE_ERR::
                    DIS:sourceNode => {$node},
                    DIS:sourceCode => {$source_code},
                    DIS:elementType => {$et},
                  }__}__;
                }
              } elsif ({
                <Q::DOMCore:ERROR> => true,
              }->{$et}) {
                $r-><M::DIS|PLBlockCon.skipLines> ($source_code);
                if ($source_code =~ s/^((?:(?!::).)+)(?:::\s*)?//s) {
                  my $err_uri = $nsr-><M::DIS|NSResolverDIS.tfqnamesToURI>
                                        ($1, null,
                                         $self-><AG::DIS|DISAnyResource.forURI>,
                                         node => $node);
                  my $err = $db-><M::DIS|DISDatabase.getResource> ($err_uri);
                  unless ($err and
                          $err-><M::DIS|DISAnyResource.isTypeURI>
                                         (<Q::DOMCore|DOMErrorType>)) {
                    __UNDEEP{__EXCEPTION{DIS|RESOURCE_NOT_DEFINED_ERR::
                      DIS:uri => {$err_uri},
                      DIS:sourceNode => {$node},
                      DIS:sourceCode => {$source_code},
                      DIS:expectedType => {<Q::DOMCore|DOMErrorType>},
                    }__}__;
                  }
                  my $param = $self-><M::ManakaiDISResourcePerl
                                        .plParsePreprocessParameter>
                                         ($source_code, node => $node,
                                        namespace_context=> $namespaceContext);
                  my $context_param = $self-><M::ManakaiDISResourcePerl
                                        .plGetContextParameter>;
                  $param = {%$param, %$context_param,
                            -type => {
                              type => 'quoted',
                              value => $err-><AG::DIS|DISAnyResource.nameURI>,
                            }};

                  my $errcls = $db-><M::DIS|DISDatabase.getResource>
                              (<Q::DOMCore:ManakaiDOMError>,
                               for_arg => $err-><AG::DIS|DISAnyResource.forURI>);
                  if (not $errcls-><AG::DIS|DISAnyResource.isDefined>) {
                    $errcls = $db-><M::DIS|DISDatabase.getResource>
                              (<Q::DOMCore:ManakaiDOMError>,
                               for_arg => <Q::ManakaiDOM:ManakaiDOMLatest>);
                  }

                  for ($err, $errcls) {
                    $_-><AS::DIS|DISAnyResource.isReferred>
                            ($node or
                             $self-><AG::DIS|DISAnyResource.sourceElement> or
                             $self-><AG::DIS|DISAnyResource.uri>);
                  }

                  my $statement = $r-><M::DIS|PLBlockCon.appendStatement>
                    ('report '.
                     $errcls-><AG::DISResourcePerl.plFullyQualifiedName>.
                     ' -object => $self');

                  $self-><M::ManakaiDISResourcePerl.plAddRequireResource>
                               ($errcls-><AG::DIS|DISAnyResource.ownerModule>
                                => $statement);

                  for my $name (keys %$param) {
                    my $pname = $name;
                    my $pres = $db-><M::DIS|DISDatabase.getResource> ($pname);
                    if ($pres-><AG::DIS|DISAnyResource.isDefined>) {
                      $pname = $pres-><M::DIS|DISResourceProp.getPropertyText>
                                           (<Q::ecore:propKey>, $pname);
                    }
                    $pname =~ s/(['\\])/\\$1/g;
                    $pname = qq<'$pname'>;
                    $statement-><M::DIS|PLInCon.appendCode>
                           (', ' . $pname . ' => ');
                    if ($param->{$name}->{type} eq 'code') {
                      if (ref $param->{$name}->{value}) {
                        $statement-><M::DIS|PLInCon.appendCodeFragment>
                           ($param->{$name}->{value});
                      } else {
                        $statement-><M::DIS|PLInCon.appendCodeFragment>
                          ($self-><M::DISResourcePerl
                                  .plPreprocessPerlStatement>
                                     ($param->{$name}->{value},
                                      node => $node,
                                      namespace_context => $namespaceContext));
                      }
                    } else {  ## String as is
                      $statement-><M::DIS|PLAnyCon.appendStringLiteral>
                           ($param->{$name}->{value});
                    }
                  }
                } else {
                 __UNDEEP{__EXCEPTION{DIS|PERL_PREPROCESS_NO_EXCEPTION_TYPE_ERR::
                    DIS:sourceNode => {$node},
                    DIS:sourceCode => {$source_code},
                    DIS:elementType => {$et},
                  }__}__;
                }
              } elsif ($et eq <Q::disPerl:CODE>) {
                $r-><M::DIS|PLBlockCon.skipLines> ($source_code);
                  my $code_name;
                  $source_code =~ s/^\s+//;
                  if ($source_code =~ s/^((?>(?!::).)+)//s) {
                    $code_name = $1;
                  } else {
                    __UNDEEP{
                      __EXCEPTION{DIS|PERL_PREPROCESS_NO_CODE_NAME_ERR::
                        DIS:sourceCode => {$source_code},
                        DIS:sourceNode => {$node},
                        DIS:elementType => {$et},
                      }__;
                    }__;
                  }
                  $source_code =~ s/^::\s*//;
                  my $param = $self-><M::ManakaiDISResourcePerl
                                        .plParsePreprocessParameter>
                                           ($source_code, node => $node,
                                        namespace_context=> $namespaceContext);
                  my $code_uri = $nsr-><M::DIS|NSResolverDIS
                                           .tfqnamesToURI>
                                         ($code_name, null,
                                          $self-><AG::DIS|DISAnyResource.forURI>,
                                          node => $node);
                  my $code = $self->{db}-><M::DIS|DISDatabase.getResource>
                                           ($code_uri);
                  $code-><AS::DIS|DISAnyResource.isReferred>
                                           ($self-><AG::DIS|DISAnyResource.uri>);
                  unless ($code-><M::DIS|DISResource.isTypeURI>
                                           (<Q::DISPerl:BlockCode>)) {
                    __UNDEEP{__EXCEPTION{DIS|RESOURCE_NOT_DEFINED_ERR::
                      DIS:uri => {$code_uri},
                      DIS:sourceNode => {$node},
                      DIS:sourceCode => {$source_code},
                      DIS:expectedType => {<Q::DISPerl:BlockCode>},
                    }__;}__;
                  }
                  my $pc = $code-><AG::DISResourcePerl
                                       .plCodeFragment>;
                  unless (defined $pc) {
                    __UNDEEP{__EXCEPTION{DIS|PERL_CODE_NOT_DEFINED_ERR::
                      DIS:sourceNode => {$node},
                      DIS:sourceCode => {$source_code},
                      DIS:uri => {$code_uri},
                    }__}__;
                  }
                  $pc = $pc->clone;
                  for my $var (grep {/^\$/} keys %$param) {
                    my $value;
                    if ($param->{$var}->{type} eq 'variable') {
                      $value = $plimpl-><M::DIS|MPLImpl.createPerlVariable>
                                          ('$', null, $param->{$var}->{value});
                    } elsif ($param->{$var}->{type} eq 'code') {
                      $value = $self-><M::DISResourcePerl
                                         .plPreprocessPerlStatement>
                                            ($param->{$var}->{value},
                                             contains_statements => false,
                                             node => $node,
                                        namespace_context=> $namespaceContext);
                    } else {
                      $value = $plimpl-><M::DIS|MPLImpl.createPerlStringLiteral>
                                          ($param->{$var}->{value});
                    }
                    $pc-><M::DIS|MPLCodeFragment.replaceVariable>
                                          ($var => $value);
                  }
                  $r-><M::DIS|PLBlockCon.appendCodeFragment> ($pc);
                } elsif ($et eq <Q::ManakaiDOM:InputNormalize>) {
                  $r-><M::DIS|PLBlockCon.skipLines> ($source_code);
                  unless ($methodResource) {
                    __UNDEEP{__EXCEPTION{DIS|PERL_PREPROCESS_NO_METHOD_ERR::
                      DIS:sourceNode => {$node},
                      DIS:sourceCode => {$source_code},
                      DIS:elementType => {$et},
                    }__}__;
                  }
                  my $param = $methodResource
                                -><M::DIS|DISResource
                                     .getChildResourceByNameAndType>
                                    ($source_code, <Q::DISLang:MethodParameter>);
                  unless ($param) {
                    __UNDEEP{__EXCEPTION{DIS|RESOURCE_NOT_DEFINED_ERR::
                      DIS:sourceNode => {$node},
                      DIS:sourceCode => {$source_code},
                      DIS:elementType => {$et},
                      DIS:localName => {$source_code},
                      DIS:expectedType => {<Q::DISLang:MethodParameter>},
                    }__}__;
                  }
                  my $norm = $param-><M::DISResourcePerl
                                        .plGetMethodInputNormalizer>;
                  if ($norm) {
                    my $norm_code = $norm-><AG::DISResourcePerl
                                               .plCodeFragment>->clone;
                    $norm_code-><M::DIS|MPLCodeFragment.replaceVariable>
                       ('$INPUT' => $param-><AG::DISResourcePerl
                                                .plVariableName>);
                    $r-><M::DIS|PLBlockCon.appendCodeFragment> ($norm_code);
                  }
                } elsif ($et eq <Q::disPerl:FOR>) {
                  if ($source_code =~ s/^(((?>(?!::).)*)::\s*)//) {
                    $r-><M::DIS|PLBlockCon.skipLines> ($1);
                    V: for my $forq (split /\s*\|\s*/, $2) {
                      my $notfor = ($forq =~ s/^!\s*// ? true : false);
                      my $for_uri = $nsr-><M::DIS|NSResolverDIS.qnameToURI>
                                              ($forq, node => $node);
                      my $formatch = $self-><M::DIS|DISAnyResource
                                               .isForURI> ($for_uri);
                      if (($formatch and not $notfor) or
                          (not $formatch and $notfor)) {
                        $r-><M::DIS|PLBlockCon.appendCodeFragment>
                            ($self-><M::DISResourcePerl
                                  .plPreprocessPerlCode>
                                     ($source_code,
                                      method_resource => $methodResource,
                                      source_file => $r-><AG::DIS|PLBlockCon.
                                                       currentSourceFile>,
                                      source_line => $r-><AG::DIS|PLBlockCon.
                                                       currentSourceLine>,
                                      node => $node,
                                        namespace_context=> $namespaceContext));
                        last V;
                      }
                    } # V
                    $r-><M::DIS|PLBlockCon.skipLines> ($source_code);
                  } else {
                    __UNDEEP{__EXCEPTION{DIS|PERL_PREPROCESS_NO_FOR_ERR::
                      DIS:sourceNode => {$node},
                      DIS:sourceCode => {$source_code},
                      DIS:elementType => {$et},
                    }__}__;
                  }
                } elsif ($et eq <Q::disPerl:ASSERT>) {
                  $r-><M::DIS|PLBlockCon.skipLines> ($source_code);
                  my $assert_type;
                  if ($source_code =~ s/^\s*($RegQNameChar+)\s*::\s*//o) {
                    $assert_type = $nsr-><M::DIS|NSResolverDIS.qnameToURI>
                                             ($1, node => $node);
                  } else {
                    __UNDEEP{__EXCEPTION{DIS|PERL_PREPROCESS_NO_ASSERT_TYPE_ERR::
                      DIS:sourceNode => {$node},
                      DIS:sourceCode => {$source_code},
                      DIS:elementType => {$et},
                    }__}__;
                  }
                  # if output assertion then
 =pod
                    my $assert_block = $r-><M::DIS|PLBlockCon.appendBlock>;
                  
                    my $param = $self-><M::ManakaiDISResourcePerl
                                          .plParsePreprocessParameter>
                                           ($source_code, node => $node,
                                        namespace_context=> $namespaceContext);
                    my $context_param
                            = $self-><M::ManakaiDISResourcePerl
                                        .plGetContextParameter>;

                    if ($assert_type eq <Q::DISPerl:isPositive>) {

        $pre = perl_statement
                 perl_assign
                   'my $asActual' =>
                          '('.perl_code ($param->{actual}, %opt).')';
        $cond = '$asActual > 0';
        $xparam->{ExpandedURI q<DOMMain:expectedLabel>} = 'a positive value';
        $xparam->{ExpandedURI q<DOMMain:actualValue>}
                                 = perl_code_literal q<$asActual>;
      } elsif ($atype eq ExpandedURI q<DISPerl:invariant>) {
        $cond = '0';
        $xparam->{ExpandedURI q<DOMMain:expectedLabel>} = $param->{msg};
        $xparam->{ExpandedURI q<DOMMain:actualValue>} = '(invariant)';
      } else {
        valid_err (q[Assertion type <].$atype.q[> is not supported],
                   node => $opt{node});
      }

        $r = $pre . perl_if
               $cond,
               undef,


                  my $cls = $self->{db}-><M::DIS|DISDatabase.getResource>
                                   (<Q::dx:CoreException>);
                  my $const = $self->{db}-><M::DIS|DISDatabase.getResource>
                                   (<Q::MDOMX:MDOM_DEBUG_BUG>);
                  my $subtype = $self->{db}-><M::DIS|DISDatabase.getResource>
                                   (<Q::DOMMain:ASSERTION_ERR>);
                  $_-><AS::DIS|DISAnyResource.isReferred>
                          ($node || $self->{src}) for $cls, $const, $subtype;
                  $self-><M::ManakaiDISResourcePerl
                            .plAppendThrow>
                               ($assert_block, $cls, $const, $subtype,
                                {%$param, %$context_param,
                                 <Q::DOMMain:assertionType> => {
                                   type => 'quoted', value => $assert_type,
                                 },
                                 <Q::DOMMain:traceText> => {
                                   type => 'code',
                                   value => q<(sprintf 'at %s line %s%s%s',
                                               __FILE__, __LINE__, "\n\t",
                                               Carp::longmess ())>,
                                 }}, node => $node,
                                        namespace_context=> $namespaceContext);

  =cut

                } elsif ({
                  <Q::disPerl:FILE> => 1,
                  <Q::disPerl:LINE> => 1,
                  <Q::disPerl:PACKAGE> => 1,
                }->{$et}) {
                  $r-><M::DIS|PLAnyCon.appendAtom>
                        ('__'.{
                                 <Q::disPerl:FILE> => 'FILE',
                                 <Q::disPerl:LINE> => 'LINE',
                                 <Q::disPerl:PACKAGE> => 'PACKAGE',
                              }->{$et}.'__');
                  if (length $source_code) {
                    __UNDEEP{__EXCEPTION{
                    DIS|PERL_PREPROCESS_BLOCK_NOT_ALLOWED_ERR::
                      DIS:sourceNode => {$node},
                      DIS:sourceCode => {$source_code},
                      DIS:elementType => {$et},
                    }__}__;
                  }
                } else {
                  __UNDEEP{__EXCEPTION{DIS|UNSUPPORTED_ELEMENT_TYPE_ERR::
                    DIS:sourceNode => {$node},
                    DIS:sourceCode => {$source_code},
                    DIS:elementType => {$et},
                  }__}__;
                }
              } else {  ## Other than block-level element
                $r-><M::DIS|PLBlockCon.appendCodeFragment>
                       ($self-><M::DISResourcePerl
                             .plPreprocessPerlStatement>
                                 ($source_code, contains_statements => true,
                                  source_file => $r-><AG::DIS|PLBlockCon
                                                        .currentSourceFile>,
                                  source_line => $r-><AG::DIS|PLBlockCon
                                                        .currentSourceLine>,
                                  node => $node,
                                        namespace_context=> $namespaceContext));
                $r-><M::DIS|PLBlockCon.skipLines> ($source_code);
              }
            } # for
          }__; # DEEP

  @Method:
    @@Name: plPreprocessPerlStatement
    @@enDesc:
      Preprocesses a Perl inline code fragment
      (code fragment smaller than statement). 
    @@Param:
      @@@Name:codeArg
      @@@Type:
        lang:Perl::ManakaiDOM:all
      @@@enDesc:
        A Perl code fragment.
    @@NodeParam:
    @@NamedParam:
      @@@Name:containsStatements
      @@@Type:
        DOMMain:boolean::ManakaiDOM:all
      @@@enDesc:
        Whether one or more statements might be contained
        in <P::codeArg> or not.
    @@NamedParam:
      @@@Name:sourceFile
      @@@Type:
        DISLang:String::ManakaiDOM:all
      @@@enDesc:
        The source file name of the <P::codeArg>.
      @@@nullCase:
        @@@@enDesc:
          No source file information available.
    @@NamedParam:
      @@@Name:sourceLine
      @@@Type:
        DOMMain:unsigned-long::ManakaiDOM:all
      @@@enDesc:
        The line number in the <P::sourceFile> from which
        the <P::codeArg> begins.
      @@@nullCase:
        @@@@enDesc:
          No source file information available.
    @@NamedParam:
      @@@Name: namespaceContext
      @@@Type: DIS|NSResolverDIS
      @@@nullCase:
        @@@@enDesc:
          <P::node> or implied one if any.
    @@Return:
      @@@Type: DIS|MPLCodeFragment
      @@@enDesc:
        Preprocessed Perl code.
      @@@InCase:
        @@@@Type: PCBlock
        @@@@enDesc:
          If <P::containsStatements> is <DOM::false>.
      @@@InCase:
        @@@@Type: DIS|PLInCon
        @@@@enDesc:
          If <P::containsStatements> is <DOM::true>.
      @@@InlineElementException:
      @@@PerlDef:
        __DEEP{
          my $nsr = $namespaceContext || $node || $self->{src};
          our $RegQNameChar;
          my $plimpl = $self-><AG::DISAnyResourcePerl.plImplementation>;
          my $db = $self-><AG::DIS|DISAnyResource.database>;
          if ($containsStatements) {
            $r = $plimpl-><M::DIS|MPLImpl.createPerlBlockContainer>;
            if (defined $sourceLine) {
              $r-><AS::DIS|PLBlockCon.sourceFile> ($sourceFile);
              $r-><AS::DIS|PLBlockCon.sourceLine> ($sourceLine);
              $r-><AS::DIS|PLBlockCon.currentSourceFile> ($sourceFile);
              $r-><AS::DIS|PLBlockCon.currentSourceLine> ($sourceLine);
            } elsif ($node) {
              my $np = $node-><M::DIS|SWCFGNode.flag> ('nodePath') ||
                       $node-><M::DIS|SWCFGNode.nodePath>
                        (key => [qw/Name QName Type type/]);
              $r-><AS::DIS|PLBlockCon.sourceFile> ($np);
              $r-><AS::DIS|PLBlockCon.sourceLine> (1);
              $r-><AS::DIS|PLBlockCon.currentSourceFile> ($np);
              $r-><AS::DIS|PLBlockCon.currentSourceLine> (1);
            }
          } else {
            $r = $plimpl-><M::DIS|MPLImpl.createPerlInlineContainer>;
          }
          for my $source_code (split /(?<![\^\?qwr])(\x3C$RegQNameChar[^<>]+>
                                                     )/ox, $codeArg) {
            if ($source_code =~ s/^\x3C//) {
              $source_code =~ s/>$//;
              if ($source_code =~ /=$/) {
              ## TODO: Warning
              #  valid_warn qq<Inline element "\x3C$source_code>" ends with a "=" - >.
              #              q{should "=" be used place of "=>"?};
              }
              if ($source_code =~ s/^(.+?):://) {
                my $et = $nsr-><M::DIS|NSResolverDIS.qnameToURI>
                                     ($1,
                                      node => $node,
                                      default_namespace_uri => <Q::disPerl:>);
                if ($et eq <Q::disPerl:Q>) {          ## QName constant
                  $r-><M::DIS|PLAnyCon.appendStringLiteral>
                              ($nsr-><M::DIS|NSResolverDIS.qnameToURI>
                                           ($source_code, node => $node));
                } elsif ($et eq <Q::disPerl:H>) {
                  my $uri = $nsr-><M::DIS|NSResolverDIS.qnameToURI>
                                           ($source_code, node => $node);
                  my $prop_res = $db-><M::DIS|DISDatabase.getResource> ($uri);
                  $prop_res-><AS::DIS|DISAnyResource.isReferred>
                                  ($node or $self-><AG::DIS|DISAnyResource.uri>);
                  my $pname = $prop_res-><M::DIS|DISResourceProp.getPropertyText>
                                           (<Q::DISPerl:propHashKey>, $uri);
                  $r-><M::DIS|PLAnyCon.appendStringLiteral> ($pname);
                } elsif ({
                  <Q::disPerl:M> => 1,
                  <Q::disPerl:ClassM> => 1,
                  <Q::disPerl:AG> => 1,
                  <Q::disPerl:AS> => 1,
                }->{$et}) {     ## Method call
                  my ($class_qname, $method_qname)
                         = split /\s*\.\s*/, $source_code, 2;
                  my $class_uri = $nsr-><M::DIS|NSResolverDIS.tfqnamesToURI>
                                       ($class_qname,
                                        $self-><AG::DIS|DISResource
                                                     .ownerClassNodeURI>,
                                        $self-><AG::DIS|DISAnyResource.forURI>,
                                        node => $node);
                  my $class = $self->{db}-><M::DIS|DISDatabase.getResource>
                                                   ($class_uri);
                  unless ($class-><AG::DIS|DISAnyResource
                                        .isDefined>) {
                    __UNDEEP{__EXCEPTION{DIS|RESOURCE_NOT_DEFINED_ERR::
                      DIS:sourceNode => {$node},
                      DIS:sourceCode => {$source_code},
                      DIS:uri => {$class_uri},
                      DIS:elementType => {$et},
                      DIS:expectedType => {<Q::DISLang:AnyClass>},
                    }__}__;
                  }
                  $class-><AS::DIS|DISAnyResource.isReferred>
                                 ($node || $self->{src} || $self->{uri});
                  if ($et eq <Q::disPerl::ClassM> and
                      $class-><M::DIS|DISResource.isTypeURI>
                                     (<Q::ManakaiDOM:IF>)) {
                    __UNDEEP{
                      __EXCEPTION{DIS|INTERFACE_CLASS_METHOD_ERR::
                        DIS:uri => {$class_uri},
                        DIS:elementType => {$et},
                        DIS:sourceNode => {$node || $self->{src}},
                        DIS:sourceCode => {$source_code},
                        DIS:expectedType => {<Q::ManakaiDOM:IF>},
                      }__;
                    }__;
                  }
                  unless ($class-><M::DIS|DISResource.isTypeURI>
                                         (<Q::ManakaiDOM:IF>)) {
                    $self-><M::ManakaiDISResourcePerl.plAddRequireResource>
                                         ($class => $r);
                  }
                  my $method = $class-><M::DIS|DISResource
                                         .getChildResourceByNameAndType>
                                    ($method_qname,
                                     {
                                       <Q::disPerl:AG> => <Q::DISLang:Attribute>,
                                       <Q::disPerl:AS> => <Q::DISLang:Attribute>,
                                     }->{$et} || <Q::DISLang:Method>);
                  if (not $method or
                      not $method-><AG::DIS|DISAnyResource.isDefined>) {
                    __UNDEEP{
                      __EXCEPTION{DIS|RESOURCE_NOT_DEFINED_ERR::
                        DIS:localName => {$method_qname},
                        DIS:parentURI => {$class_uri},
                        DIS:elementType => {$et},
                        DIS:sourceNode => {$node || $self->{src}},
                        DIS:sourceCode => {$source_code},
                        DIS:expectedType => {{
                                       <Q::disPerl:AG> => <Q::DISLang:Attribute>,
                                       <Q::disPerl:AS> => <Q::DISLang:Attribute>,
                                     }->{$et} || <Q::DISLang:Method>},
                      }__;
                    }__;
                  }
                  my $class_name = '';
                  if ($et eq <Q::disPerl:ClassM>) {
                    $class_name = $class-><AG::DISResourcePerl
                                              .plFullyQualifiedName> . '->';
                  }
                  my $method_name = $method-><AG::DISResourcePerl.plName>;
                  $r-><M::DIS|PLAnyCon.appendBare> ($class_name . $method_name);
                } elsif ({
                  <Q::disPerl:Class> => 1,
                  <Q::disPerl:ClassName> => 1,
                  <Q::disPerl:IF> => 1,
                  <Q::disPerl:IFName> => 1,
                }->{$et}) {                            ## Perl package name
                  my $class_uri = $nsr-><M::DIS|NSResolverDIS.tfqnamesToURI>
                                       ($source_code,
                                        $self-><AG::DIS|DISResource
                                                     .ownerClassNodeURI>,
                                        $self-><AG::DIS|DISAnyResource.forURI>,
                                        node => $node);
                  my $class = $self->{db}-><M::DIS|DISDatabase.getResource>
                                                   ($class_uri);
                  $class-><AS::DIS|DISAnyResource.isReferred>
                                         ($node || $self->{src} || $self->{uri});
                  my $pack = $class-><AG::DISResourcePerl.plFullyQualifiedName>;
                  unless ($pack) {
                    __UNDEEP{__EXCEPTION{DIS|NO_PERL_PACKAGE_NAME_ERR::
                      DIS:sourceNode => {$node || $self->{src}},
                      DIS:sourceCode => {$source_code},
                      DIS:uri => {$class_uri},
                      DIS:elementType => {$et},
                    }__}__;
                  }
                  if ({
                    <Q::disPerl:ClassName> => 1,
                    <Q::disPerl:IFName> => 1,
                  }->{$et}) {
                    $r-><M::DIS|PLAnyCon.appendStringLiteral> ($pack);
                  } else {
                    $r-><M::DIS|PLAnyCon.appendBare> ($pack);
                  }
                  $self-><M::ManakaiDISResourcePerl.plAddRequireResource>
                                         ($class => $r)
                    if {
                      <Q::disPerl:Class> => true,
                      <Q::disPerl:ClassName> => true,
                    }->{$et};
                } elsif ($et eq <Q::disPerl:Code>) { ## Inline code
                  my $code_name;
                  $source_code =~ s/^\s+//;
                  if ($source_code =~ s/^((?>(?!::).)+)//s) {
                    $code_name = $1;
                  } else {
                    __UNDEEP{
                      __EXCEPTION{DIS|PERL_PREPROCESS_NO_CODE_NAME_ERR::
                        DIS:sourceCode => {$source_code},
                        DIS:sourceNode => {$node || $self->{src}},
                      }__;
                    }__;
                  }
                  $source_code =~ s/^::\s*//;
                  my $param = $self-><M::ManakaiDISResourcePerl
                                        .plParsePreprocessParameter>
                                           ($source_code, node => $node,
                                        namespace_context=> $namespaceContext);
                  my $code_uri = $nsr-><M::DIS|NSResolverDIS.tfqnamesToURI>
                                         ($code_name, null,
                                          $self-><AG::DIS|DISAnyResource.forURI>,
                                          node => $node);
                  my $code = $self->{db}-><M::DIS|DISDatabase.getResource>
                                           ($code_uri);
                  $code-><AS::DIS|DISAnyResource.isReferred>
                                         ($node || $self->{src} || $self->{uri});
                  unless ($code-><M::DIS|DISResource.isTypeURI>
                                           (<Q::DISPerl:InlineCode>)) {
                    __UNDEEP{__EXCEPTION{DIS|RESOURCE_NOT_DEFINED_ERR::
                      DIS:uri => {$code_uri},
                      DIS:sourceNode => {$node || $self->{src}},
                      DIS:sourceCode => {$source_code},
                      DIS:expectedType => {<Q::DISPerl:InlineCode>},
                    }__;}__;
                  }
                  my $pc = $code-><AG::DISResourcePerl
                                       .plCodeFragment>->clone;
                  unless (defined $pc) {
                    __UNDEEP{__EXCEPTION{DIS|PERL_CODE_NOT_DEFINED_ERR::
                      DIS:sourceNode => {$node || $self->{src}},
                      DIS:sourceCode => {$source_code},
                      DIS:uri => {$code_uri},
                    }__}__;
                  }
                  for my $var (grep {/^\$/} keys %$param) {
                    my $value;
                    if ($param->{$var}->{type} eq 'variable') {
                      $value = $plimpl-><M::DIS|MPLImpl.createPerlVariable>
                                          ('$', null, $param->{$var}->{value});
                    } elsif ($param->{$var}->{type} eq 'code') {
                      $value = $self-><M::DISResourcePerl
                                         .plPreprocessPerlStatement>
                                            ($param->{$var}->{value},
                                             contains_statements => false,
                                             node => $node,
                                        namespace_context=> $namespaceContext);
                    } else {
                      $value = $plimpl-><M::DIS|MPLImpl.createPerlStringLiteral>
                                          ($param->{$var}->{value});
                    }
                    $pc-><M::DIS|MPLCodeFragment.replaceVariable>
                                          ($var => $value);
                  }
                  $r-><M::DIS|PLInCon.appendCodeFragment> ($pc);
                } elsif ($et eq <Q::disPerl:C>) {
                  my ($class_qname, $const_name) = split /\./, $source_code, 2;
                  my $class_uri = $nsr-><M::DIS|NSResolverDIS.tfqnamesToURI>
                                       ($class_qname,
                                        $self-><AG::DIS|DISResource
                                                     .ownerClassNodeURI>,
                                        $self-><AG::DIS|DISAnyResource.forURI>,
                                        node => $node);
                  my $class = $self->{db}-><M::DIS|DISDatabase.getResource>
                                                   ($class_uri);
                  $class-><AS::DIS|DISAnyResource.isReferred>
                                        ($node || $self->{src} || $self->{uri});
                  my $const = $class-><M::DIS|DISResource
                                         .getConstResourceByName> ($const_name);
                  unless (defined $const) {
                    __UNDEEP{__EXCEPTION{DIS|RESOURCE_NOT_DEFINED_ERR::
                      DIS:sourceNode => {$node || $self->{src}},
                      DIS:sourceCode => {$source_code},
                      DIS:localName => {$const_name},
                      DIS:expectedType => {<Q::ManakaiDOM:Const>},
                    }__}__;
                  }
                  $const-><AS::DIS|DISAnyResource.isReferred>
                                                 ($node || $self->{uri});

                  my $data_type = $const-><AG::DIS|DISResource
                                       .disActualDataTypeResource>;
                  my $val = $const-><M::DIS|DISResourceProp.getPropertyValue>
                                          (<Q::dis:Value>);
                  if ($val) {
                    $val = $val-><M::DVValuePerl.plCodeFragment>
                            ($const,
                             data_type_uri => $data_type
                                    -><AG::DIS|DISAnyResource.uri>);
                  } else {
                    __UNDEEP{__EXCEPTION{DIS|NO_CONST_VALUE_ERR::
                      DIS:uri => {$const->{uri}},
                      DIS:localName => {$const-><AG::DIS|DISAnyResource
                                                    .localName>},
                      DIS:sourceNode => {$const->{src}},
                      DIS:elementType => {$et},
                   }__}__;
                  }
                  $r-><M::DIS|PLInCon.appendCodeFragment> ($val);
                } else {
                  __UNDEEP{__EXCEPTION{DIS|UNSUPPORTED_ELEMENT_TYPE_ERR::
                    DIS:elementType => {$et},
                    DIS:sourceNode => {$node || $self->{src}},
                    DIS:sourceCode => {$source_code},
                  }__}__;
                }
              } else {
                __UNDEEP{__EXCEPTION{DIS|PERL_PREPROCESS_NO_ELEMENT_TYPE_ERR::
                  DIS:sourceNode => {$node || $self->{src}},
                  DIS:sourceCode => {$source_code},
                  DIS:expectedType => {<Q::ManakaiDOM:ConstGroup>},
                }__}__;
              }
            } else {
              for my $source_code (split /(\b
                                            (?: t r u e \b|
                                                f a l s e \b|
                                                n u l l \b|
                                                t r y \s* \x7B ) |
        \                                   \\ p \x7B [^\x7B\x7D\\]+ \x7D)/x,
                                   $source_code) {
                if ({
                  'tr'.'ue' => true,
                  'fal'.'se' => true,
                  'nu'.'ll' => true,
                }->{$source_code}) {
                  $r-><M::DIS|PLAnyCon.appendAtom> ({
                    'tr'.'ue' => 1,
                    'fal'.'se' => 0,
                    'nu'.'ll' => 'undef',
                  }->{$source_code});
                } elsif ($source_code =~ /^t r y \s* \x7B$/x) {
                  $r-><M::DIS|PLInCon.appendCode> ('tr'.
                       'y '."\x7B".'local $Error::Depth = $Error::Depth + 3;');
                  $r-><M::DIS|MPLCodeFragment.addUsePerlModuleName>
                                                    ('Message::Util::Error');
                } elsif ($source_code =~ /^\\ p \x7B ([^\x7B\x7D\\]+) \x7D$/x) {
                  my $cls = $1;
                  $cls =~ s/^\s+//s;
                  $cls =~ s/\s+$//s;
                  ## TODO: Formal character class support required
                  if ($cls =~ /^inxml\s*[:|]\s*(\w+)/) {
                    $r-><M::DIS|PLAnyCon.appendAtom> ('\\'.'p{InXML'.$1.'}');
                    $r-><M::DIS|MPLCodeFragment.addUseCharClassName>
                                        ('Char::Class::XML', 'InXML'.$1);
                  } else {
                    __UNDEEP{__EXCEPTION{DIS|RESOURCE_NOT_DEFINED_ERR::
                      DIS:sourceNode => {$node},
                      DIS:sourceCode => {$source_code},
                    }__}__;
                  }
                } else {
                  if ($source_code =~ s/^(\s*[\w:]+\s*)//) {
                    ## NOTE: "$cond ?\n1\n:0" would be a syntax error
                    $r-><M::DIS|PLAnyCon.appendAtom> ($1);
                  }
                  $r-><M::DIS|PLInCon.appendCode> ($source_code);
                }
              }
            } # Inline instruction or not
          } # for
        }__; # DEEP

  @IntMethod:
    @@Name: plParsePreprocessParameter
    @@enDesc:
      Parses a parameter specification in preprocessing instruction
      and return it as a hash reference.
      \
      {NOTE:: The callee have to ensure that this resource has its 
              <CODE::src> before the call to this method.
      \
      }
    @@Param:
      @@@Name: paramSpec
      @@@Type:
        DISLang:String::ManakaiDOM:all
      @@@enDesc:
        A parameter specification to parse.
    @@NodeParam:
    @@NamedParam:
      @@@Name: namespaceContext
      @@@Type: DIS|NSResolverDIS
      @@@nullCase:
        @@@@enDesc:
          <P::node> or implied one if any.
    @@Return:
      @@@Type:
        pl:HASH::ManakaiDOM:all
      @@@enDesc:
        Hash containing parameters.  Each hash value is also 
        a hash reference, containing two keys <CODE::type> 
        (its value is either <CODE::bare>, <CODE::quoted>,
        <CODE::code> or <CODE::variable>) and
        <CODE::value>.
      @@@RaiseException:
        @@@@@: DIS|BROKEN_PARAM_SPEC_ERR
        @@@@enDesc:
          The <P::paramSpec> is not well-formed.
      @@@PerlDef:
        our $RegQNameChar;
        our $RegBlockContent;
        $r = {};
        my $nsr = $namespaceContext || $node || $self->{src};
        while ($paramSpec =~ s/^
          ## Parameter name
          (\$? $RegQNameChar+)\s*
  
          (?: =>? \s*
               ## ">" is now optional for inline element (">" is delimiter)

          ## Parameter value
          (
            ## Variable or Bare string
   \           \$? $RegQNameChar+
            |
            ## Quoted string
               '(?>[^'\\]*)' ## ISSUE: escape mechanism required?
            |
            ## Code
   \           \{$RegBlockContent\}
   
          )

          \s*)?

        (?:,\s*|$)//ox) {

        my ($n, $v) = ($1, $2);
        if (defined $v) {
          if ($v =~ /^'/) {
            $v = {type => 'quoted',
                  value => substr ($v, 1, length ($v) - 2)};
          } elsif ($v =~ /^\{/) {
            $v = {type => 'code', value => substr ($v, 1, length ($v) - 2)};
          } elsif ($v =~ /^\$/) {
            $v = {type => 'variable', value => substr $v, 1};
          } else {
            $v = {type => 'bare', value => $v};
          }
        } else {
          $v = {type => 'boolean', value => true};
        }
    
        if ($n =~ /^\$/) {
          $r->{$n} = $v;
        } else {
          __DEEP{
            $r->{$nsr-><M::DIS|NSResolverDIS.qnameToURI>
                                 ($n, node => $node || $self->{src})} = $v;
          }__;
        }
      } # while

      if (length $paramSpec) {
        __EXCEPTION{DIS|BROKEN_PARAM_SPEC_ERR::
          DIS:sourceCode => {$paramSpec},
          DIS:sourceNode => {$node || $self->{src}},
        }__;
      }

  @IntMethod:
    @@Name: plGetContextParameter
    @@enDesc:
      Returns contextual parameters which describes the <QUOTE::location>
      of this resource.
    @@Return:
      @@@Type:
        pl:HASH::ManakaiDOM:all
      @@@enDesc:
        Hash of parameters as <M::ManakaiDISResourcePerl
        .plParsePreprocessParameter> returns.
      @@@PerlDef:
        $r = {};
        __DEEP{
          if ($self-><M::DIS|DISResource.isTypeURI>
                       (<Q::DISLang:MethodReturn>)) {
            my $method = $self-><AG::DIS|DISResource.parentResource>;
            $r->{<Q::MDOMX:method>}
               = {type => 'quoted',
                  value => $method-><AG::DISResourcePerl.plName>};
            my $class = $method-><AG::DIS|DISResource.parentResource>;
            $r->{<Q::MDOMX:class>}
               = {type => 'quoted',
                  value => $class-><AG::DISResourcePerl
                                       .plFullyQualifiedName>};
          } elsif ($self-><M::DIS|DISResource.isTypeURI>
                       (<Q::DISLang:AttributeGet>)) {
            my $attr = $self-><AG::DIS|DISResource.parentResource>;
            $r->{<Q::MDOMX:attr>}
               = {type => 'quoted',
                  value => $attr-><AG::DISResourcePerl.plName>};
            my $class = $attr-><AG::DIS|DISResource.parentResource>;
            $r->{<Q::MDOMX:class>}
               = {type => 'quoted',
                  value => $class-><AG::DISResourcePerl
                                       .plFullyQualifiedName>};
            $r->{<Q::MDOMX:on>} = {type => 'quoted', value => 'get'};
          } elsif ($self-><M::DIS|DISResource.isTypeURI>
                       (<Q::DISLang:AttributeSet>)) {
            my $attr = $self-><AG::DIS|DISResource.parentResource>;
            $r->{<Q::MDOMX:attr>}
               = {type => 'quoted',
                  value => $attr-><AG::DISResourcePerl.plName>};
            my $class = $attr-><AG::DIS|DISResource.parentResource>;
            $r->{<Q::MDOMX:class>}
               = {type => 'quoted',
                  value => $class-><AG::DISResourcePerl
                                       .plFullyQualifiedName>};
            $r->{<Q::MDOMX:on>} = {type => 'quoted', value => 'set'};
          } else {
            $r->{<Q::MDOMX:resourceURI>} = {type => 'quoted',
                                            value => $self->{uri}};
          }
        }__;

  @Method:
    @@Name: plGetMethodInputNormalizer
    @@enDesc:
      Returns an input processor.  This method assumes that 
      this resource is a method parameter (<Q::DISLang:MethodParameter>)
      or an attribute setter (<Q::DISLang:AttributeSet>).
    @@Return:
      @@@Type: DIS|DISResource
      @@@clsActualType: DIS|ManakaiDISResourceDefinition
      @@@enDesc:
        A <Q::DISLang:InputProcessor> corresponding to 
        the parameter defined by this resource.
        \
        {NOTE:: <Q::ManakaiDOM:inputNormalize> property is 
                obsolete in favor of <Q::DISLang:InputProcessor>;
                this method does not support the former.
        \
        }
      @@@nullCase:
        @@@@enDesc:
          No input processor found.
      @@@PerlDef:
        my $type;
        my $type_node;
        try {
          $type = $self-><AG::DIS|DISResource
                             .disActualDataTypeResource>;
          $type_node = $self-><AG::DIS|DISResource
                                  .disActualDataTypeValue>;
        } catch <IF::DIS|DISException> with {
          my $err = shift;
          unless ($err->{<Q::MDOMX:subtype>} eq <Q::DIS:NO_DIS_TYPE_ERR>) {
            $err->throw;
          }
        };
        if ($type) {
          __DEEP{
            my $noinput = $type_node-><M::dv|DVValue.getProperty>
                                 (<Q::ManakaiDOM:noInputNormalize>);
            unless ($noinput and $noinput-><AG::dv|DVValue.value>) {
              $r = $type-><M::DIS|DISResource.getChildResourceByType>
                                                   (<Q::DISLang:InputProcessor>);
            }
          }__;
        }

  @IntMethod:
    @@Name: plAppendThrow
    @@enDesc:
      Appends a <Perl::report> method call statement for exception reporting.
    @@Param:
      @@@Name: parentNode
      @@@enDesc:
        The parent Perl code node to which a new statement is appended.
      @@@Type: DIS|PLBlockCon
    @@Param:
      @@@Name: xclass
      @@@Type: DIS|DISResource
      @@@clsActualType: DIS|ManakaiDISResourceDefinition
      @@@enDesc:
        An exception class.
    @@Param:
      @@@Name: xcode
      @@@Type: DIS|DISResource
      @@@clsActualType: DIS|ManakaiDISResourceDefinition
      @@@enDesc:
        An exception code constant.
    @@Param:
      @@@Name: xsubtype
      @@@Type: DIS|DISResource
      @@@clsActualType: DIS|ManakaiDISResourceDefinition
      @@@enDesc:
        An exception subtype.
      @@@nullCase:
        @@@@enDesc:
          No subtype.
    @@Param:
      @@@Name: xparam
      @@@Type:
        pl:HASH::ManakaiDOM:all
      @@@enDesc:
        A hash containing parameters passed to the <Perl::report> method. 
        A hash key is to be a parameter name.  Hash values 
        should also be hashes.  A hash value hash has two values: 
        <CODE::type> and <CODE::value>.  A <CODE::value>
        value is a parameter value.  If <CODE::type> is 
        <CODE::code>, then <CODE::value> is assumed as a Perl code fragment.
        Otherwise, <CODE::value> is quoted to be interpreted as a string as is.
    @@NodeParam:
    @@NamedParam:
      @@@Name: namespaceContext
      @@@Type: DIS|NSResolverDIS
      @@@nullCase:
        @@@@enDesc:
          <P::node> or implied one if any.
    @@Return:
      @@@RaiseException:
        @@@@@: DIS|RESOURCE_NOT_DEFINED_ERR
        @@@@enDesc:
          Either <P::xclass>, <P::xcode> or <P::xsubtype>
          is not defined.
      @@@PerlDef:
        my $statement = $parentNode-><M::DIS|PLBlockCon.appendStatement>
          ('report '.
           $xclass-><AG::DISResourcePerl.plFullyQualifiedName>.
           ' -object => $self');
        my $xclass_module = $xclass-><AG::DIS|DISAnyResource
                                            .ownerModule>;
        unless ($xclass-><AG::DIS|DISAnyResource.isDefined> or
                not $xclass_module) {
          __EXCEPTION{DIS|RESOURCE_NOT_DEFINED_ERR::
            DIS:sourceNode => {$self->{src}},
            DIS:uri => {$xclass->{uri}},
            DIS:localName => {$xclass-><AG::DIS|DISAnyResource.localName>},
            DIS:expectedType => {<Q::dx:AnyExceptionClass>},
          }__;
        }
        $xclass-><AS::DIS|DISAnyResource.isReferred>
           ($self->{src} || $self->{uri});
        $self-><M::ManakaiDISResourcePerl.plAddRequireResource>
                               ($xclass_module => $statement);
        $xparam->{-type} = {type => 'quoted',
                            value => $xcode-><AG::DISResourcePerl.plName>};
        $xparam->{<Q::MDOMX:subtype>}
            = {type => 'quoted',
               value => $xsubtype-><AG::DIS|DISAnyResource.nameURI>}
          if $xsubtype;
        for my $name (keys %$xparam) {
          my $pname = $name;
          $pname =~ s/(['\\])/\\$1/g;
          $pname = qq<'$pname'>;
          $statement-><M::DIS|PLInCon.appendCode>
                           (', ' . $pname . ' => ');
          if ($xparam->{$name}->{type} eq 'code') {
            if (ref $xparam->{$name}->{value}) {
              $statement-><M::DIS|PLInCon.appendCodeFragment>
                           ($xparam->{$name}->{value});
            } else {
              $statement-><M::DIS|PLInCon.appendCodeFragment>
                       ($self-><M::DISResourcePerl
                                  .plPreprocessPerlStatement>
                                     ($xparam->{$name}->{value},
                                      node => $node,
                                      namespace_context => $namespaceContext));
            }
          } else {  ## String as is
            $statement-><M::DIS|PLAnyCon.appendStringLiteral>
                           ($xparam->{$name}->{value});
          }
        }

  @Attr:
    @@Name: plIsNullable
    @@enDesc:
      Whether this resource is <QUOTE::nullable> or not. 
      <QUOTE::Nullability> is defined for method parameters, 
      method returns, attribute getters and attribute setters.
    @@Type:
      DOMMain:boolean::ManakaiDOM:all
    @@Get:
      @@@RaiseException:
        @@@@@: DIS|NO_DIS_TYPE_ERR
        @@@@enDesc:
          There is a <Q::ManakaiDOM:InCase> child resource 
          that does not have <Q::dis:Type> attribute.
      @@@PerlDef:
        __DEEP{
          C: for my $incase (@{$self-><M::DIS|DISResource
                                                .getChildResourceList>}) {
            next C unless $incase-><M::DIS|DISResource.isTypeURI>
                                        (<Q::ManakaiDOM:InCase>);
            if ($incase-><AG::DIS|DISResource.disIsNullValue> or
                $incase-><AG::DIS|DISResource.disActualDataTypeResource>
                            -><M::DIS|DISResource
                                     .isSubsetOfURI> (<Q::DOMMain:boolean>)) {
              $r = true;
              last C;
            }
          }
        }__;

  @Attr:
    @@Name:plIsDefined
    @@enDesc:
      Whether a Perl implementation for this resource is available or not.
    @@Type:
      DOMMain:boolean::ManakaiDOM:all
    @@Get:
      @@@TrueCase:
        @@@@enDesc:
          This resource has its Perl definition and it is implemented.
      @@@FalseCase:
        @@@@enDesc:
          Either this resource does not have any Perl definition
          or it does have but it is not implemented yet.
      @@@PerlDef:
        if (exists $self->{<H::DIS:plDefined>}) {
          $r = $self->{<H::DIS:plDefined>};
        } else {
          __DEEP{
            my $typeuri = {
              <Q::ManakaiDOM:Class> => [
                <Q::DISLang:Method>, <Q::DISLang:Attribute>,
              ],
              <Q::DISLang:Method> => [
                <Q::DISLang:MethodReturn>,
              ],
              <Q::DISLang:Attribute> => [
                <Q::DISLang:AttributeGet>, <Q::DISLang::AttributeSet>,
              ],
            };
            OUTMOST:
            for my $mytype (keys %$typeuri) {
              if ($self-><M::DIS|DISResource.isTypeURI> ($mytype)) {
                for my $ctype ($typeuri->{$mytype}) {
                  for my $cres (@{$self-><M::DIS|DISResource
                                                  .getChildResourceList>}) {
                    if ($cres-><M::DIS|DISResource.isTypeURI> ($ctype)) {
                      unless ($cres-><AG::DISResourcePerl
                                         .plIsDefined>) {
                        $r = false; last OUTMOST;
                      }
                    }
                  }
                  next OUTMOST;
                }
              }
            } # OUTMOST
          }__;
          $self->{<H::DIS:plDefined>} = $r;
        }
  
  @IntMethod:
    @@Name: plAddRequireResource
    @@enDesc:
      Adds a resource to the list of resources that should
      be <Perl::require>d from a Perl code fragment.
    @@Param:
      @@@Name: resourceArg
      @@@Type: DIS|DISResource
      @@@clsActualType: DIS|ManakaiDISResourceDefinition
      @@@enDesc:
        A resource that is <Perl::require>d by <P::codeArg>.
    @@Param:
      @@@Name: codeArg
      @@@Type: DIS|MPLCodeFragment
      @@@enDesc:
        A code fragment.  <P::resourceArg> is added to the
        list of <Perl::require>d resources of this code fragment.
    @@Return:
      @@@PerlDef:
        __DEEP{
          $codeArg-><M::DIS|MPLCodeFragment.disAddRequireURI>
                      ($resourceArg-><AG::DIS|DISAnyResource.uri>);
        }__;

  @Method:
    @@ForCheck: ManakaiDOM|ForClass
    @@ManakaiDOM:isForInternal:1
    @@Name: plMufDescriptionText
    @@enDesc:
      {TODO:: Formal documentation-access API required.
      \
      }
    @@NodeParam:
    @@Return:
      @@@Type:
        DISLang:String::ManakaiDOM:all
      @@@PerlDef:
        __DEEP{
          my $muf = $self-><M::DIS|DISResourceProp.getPropertyValue>
                             (<Q::ecore:defaultMessage>);
          $muf = $muf->[0] if $muf;
          if ($muf) {
            $r = $muf-><AG::dv|DVValue.stringValue>;
            if ($muf-><AG::dv|DVValue.dataType> eq <Q::lang:muf>) {
              my $nsr = $muf || $node || $self->{src};
              $r =~ s{< Q ::([^<>]+)>}{$nsr-><M::DIS|NSResolverDIS
                                     .qnameToURI> ($1, node => $muf)}gex;
            }
            $r =~ s/\s+/ /g;
            $r =~ s/^ //;
            $r =~ s/ $//;
          } else {
            my $desc = $self-><M::DIS|DISResourceProp.getPropertyValue>
                                (<Q::dis:Description>);
            if ($desc) {
              my $v = $desc-><AG::dv|DVValue.value>;
              if (UNIVERSAL::isa ($v, <IFName::DIS|SWCFGNode>)) {
                $r = $v-><M::DIS|SWCFGNode.value>;
              } else {
                $r = $desc-><AG::dv|DVValue.stringValue>;
              }
              $r =~ s/\s+/ /g;
              $r =~ s/^ //;
              $r =~ s/ $//;
              $r =~ s/%/%percent;/g;
            }
          }
        }__;
      @@@ImplNote:
        @@@@lang:en
        @@@@@: Currently only common-used patterns are supported.
##DISResourcePerl

ElementTypeBinding:
  @Name: IntMethod
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:Method
    @@ManakaiDOM:isForInternal:1
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: clsActualType
  @ElementType:
    dis:actualType
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: BlockElementException
  @ElementType:
    ManakaiDOM:raises
  @ShadowContent:
    @@@: DIS|PERL_PREPROCESS_NO_EXCEPTION_TYPE_ERR
    @@Description:
      @@@lang:en
      @@@@:
        An exception type specification is required but not specified.
  @ShadowSibling:
    @@ManakaiDOM:raises:
      @@@@: DIS|PERL_PREPROCESS_NO_CODE_NAME_ERR
      @@@Description:
        @@@@lang:en
        @@@@@:
          A code qualified name is required but not specified.
    @@ManakaiDOM:raises:
      @@@@: DIS|RESOURCE_NOT_DEFINED_ERR
      @@@Description:
        @@@@lang:en
        @@@@@:
          A referred resource is not defined or has different type.
    @@ManakaiDOM:raises:
      @@@@: DIS|PERL_CODE_NOT_DEFINED_ERR
      @@@Description:
        @@@@lang:en
        @@@@@:
          A referred resource does not have its Perl definition.
    @@ManakaiDOM:raises:
      @@@@: DIS|PERL_PREPROCESS_NO_METHOD_ERR
      @@@Description:
        @@@@lang:en
        @@@@@:
          A preprocessing instruction which is allowed only in 
          methods is embeded in a context which is not in any method.
    @@ManakaiDOM:raises:
      @@@@: DIS|PERL_PREPROCESS_NO_FOR_ERR
      @@@Description:
        @@@@lang:en
        @@@@@:
          A <QUOTE::for> qualified name is required but not specified.
    @@ManakaiDOM:raises:
      @@@@: DIS|PERL_PREPROCESS_NO_ASSERT_TYPE_ERR
      @@@Description:
        @@@@lang:en
        @@@@@:
          An assertion type qualified name is required but not specified.
    @@ManakaiDOM:raises:
      @@@@: DIS|PERL_PREPROCESS_BLOCK_NOT_ALLOWED_ERR
      @@@Description:
        @@@@lang:en
        @@@@@:
          A preprocessing instruction block is specified 
          but not allowed for this element type.

ElementTypeBinding:
  @Name: InlineElementException
  @ElementType:
    ManakaiDOM:raises
  @ShadowContent: 
    @@@: DIS|NO_SOURCE_NODE_ERR
    @@Description:
      @@@lang:en
      @@@@:
        This resource definition does not have associated node 
        in the source tree. 
  @ShadowSibling:
    @@ManakaiDOM:raises:
      @@@@: DIS|INTERFACE_CLASS_METHOD_ERR
      @@@Description:
        @@@@lang:en
        @@@@@:
          An attempt is made to call a class (static) method
          via an interface, not class. 
    @@ManakaiDOM:raises:
      @@@@: DIS|RESOURCE_NOT_DEFINED_ERR
      @@@Description:
        @@@@lang:en
        @@@@@:
          A package, method or attribute is not defined or not 
          a resoure of that type.
    @@ManakaiDOM:raises:
      @@@@: DIS|NO_LOCAL_NAME_ERR
      @@@Description:
        @@@@lang:en
        @@@@@:
          A referred resource does not have its local name so
          that it is impossible to refer it by name.
    @@ManakaiDOM:raises:
      @@@@: DIS|RESERVED_PERL_METHOD_NAME_ERR
      @@@Description:
        @@@@lang:en
        @@@@@:
          A referred method has its name reserved for special-purpose. 
    @@ManakaiDOM:raises:
      @@@@: DIS|BROKEN_PARAM_SPEC_ERR
      @@@Description:
        @@@@lang:en
        @@@@@:
          A parameter specification is not well-formed.
    @@ManakaiDOM:raises:
      @@@@: DIS|PERL_PREPROCESS_NO_CODE_NAME_ERR
      @@@Description:
        @@@@lang:en
        @@@@@:
          A preprocessing instruction does not contain
          Perl code fragment name. 
    @@ManakaiDOM:raises:
      @@@@: DIS|PERL_CODE_NOT_DEFINED_ERR
      @@@Description:
        @@@@lang:en
        @@@@@:
          The referred resource does not have its Perl definition.
    @@ManakaiDOM:raises:
      @@@@: DIS|PERL_PREPROCESS_NO_ELEMENT_TYPE_ERR
      @@@Description:
        @@@@lang:en
        @@@@@:
          A preprocessing instruction does not contain its element type name.
    @@ManakaiDOM:raises:
      @@@@: DIS|UNSUPPORTED_ELEMENT_TYPE_ERR
      @@@Description:
        @@@@lang:en
        @@@@@:
          An unknown element type is encounted.
    @@ManakaiDOM:raises:
      @@@@: DIS|NO_PERL_PACKAGE_NAME_ERR
      @@@Description:
        @@@@lang:en
        @@@@@:
          No Perl package name is defined for a class or interface.

ElementTypeBinding:
  @Name: PerlDef
  @ElementType:
    dis:Def
  @ShadowContent:
    @@ContentType:
      lang:Perl

ElementTypeBinding:
  @Name: InCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:InCase

ElementTypeBinding:
  @Name: nullCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:InCase
    @@Value:
      @@@is-null:1
      @@@ContentType: DISCore|String

ElementTypeBinding:
  @Name: TrueCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:InCase
    @@Value:
      @@@@:1
      @@@ContentType: DISCore|Boolean

ElementTypeBinding:
  @Name: FalseCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:InCase
    @@Value:
      @@@@: 0
      @@@ContentType: DISCore|Boolean


TMethods:
  @enDesc:
    <Q::DISLang|AnyMethod>

  @TAttr:
    @@Name: plName
    @@enDesc:
        - <Q::DISLang:Attribute>::: Method name. 
        \
        - <Q::DISLang:Method>::: Method name. 
    @@DIS:targetType: DISLang|AnyMethod
    @@Get:
      @@@Type: DISString
      @@@PerlDef:
        __DEEP{
          $r = $self-><M::dp|DISResourcePerl.getPerlNameList>->[0];
        }__;

  @TMethod:
    @@Name: getPerlClassMemberCode
    @@DIS:targetType: DISLang|AnyMethod
    @@Param:
      @@@Name: factory
      @@@Type: PCDocument
    @@Return:
      @@@Type: Node
      @@@PerlDef:
        __DEEP{
          $r = $self-><AG::DISResourcePerl.plCodeFragment>
                    -><M::Node.cloneNode> (true);
          for (@{$self-><M::dp|DISResourcePerl.getPerlNameList>}) {
            $r-><M::DIS|MPLSub.addPerlName> ($_);
          }
          for (@{$self-><M::dp|DISResourcePerl.getPerlOperatorList>}) {
            $r-><M::DIS|MPLSub.addPerlOperator> ($_);
          }
        }__;
##DISLang:AnyMethod

TMethods:
  @enDesc:
    <Q::DISLang|Method>

  @ImplNote:
    @@lang:en
    @@@:
      {ISSUE::
        auto-<Perl::use Message::Util::Error;>-addition.
      }

  @TAttr:
    @@Name: plCodeFragment
    @@DIS:targetType: DISLang|Method
    @@Get:
      @@@Type: DIS|MPLCodeFragment
      @@@PerlDef:
        __DEEP{
            $self->{<H::DIS|plCodeFragment>} = null;  ## To avoid loop
            my $ret = $self-><M::DIS|DISResource
                            .getChildResourceByType> (<Q::DISLang:MethodReturn>);
            unless ($ret) { 
              __UNDEEP{
                __EXCEPTION{DIS|NO_METHOD_RETURN_ERR::
                  DIS:errResource => {$self},
                  DIS:sourceNode => {$self->{src}},
                  DIS:uri => {$self->{uri}},
                  DIS:localName => {$self-><AG::DIS|DISAnyResource.localName>},
                }__;
              }__;
            }
            my $plimpl = $self-><AG::DISAnyResourcePerl.plImplementation>;
            $r = $self->{<H::DIS|plCodeFragment>}
               = $plimpl-><M::DIS|MPLImpl.createPerlSub>
                            ($self-><AG::DISResourcePerl.plName>);
            
            ## Method parameters
            my $params = $self-><M::DIS|DISResource.getChildResourceList>;
            my @param_variables;
            my @named_param_variables;
            my $prototype = '$';
            my $is_optional_param = false;
            my $is_named_param = false;
            for my $param (@$params) {
              next unless $param-><M::DIS|DISAnyResource.isTypeURI>
                                        (<Q::DISLang:MethodParameter>);
              unless ($is_named_param) {
                if ($param-><M::DIS|DISResourceProp.getPropertyBoolean>
                                 (<Q::DISPerl:isNamedParameter>, false)) {
                  $is_named_param = true;
                  if (not $is_optional_param and
                      not $param-><AG::DISResourcePerl.plIsNullable>) {
                    $prototype .= ';'
                  }
                  $is_optional_param = true;
                  push @param_variables, ['%opt'];
                  $prototype .= '%';
                } else {  ## Non-named parameter
                  push @param_variables, [
                    $param-><AG::DISResourcePerl.plVariableName>,
                  ];
                  if ($param-><AG::DISResourcePerl.plIsNullable>) {
                    $prototype .= ';' unless $is_optional_param;
                    $is_optional_param = true;
                  } elsif ($is_optional_param) {
                    $prototype =~ tr/;//d;
                    $is_optional_param = false;
                  }
                  $prototype .= $param-><AG::DISResourcePerl.plPrototype>;
                  my $param_processor
                        = $param-><M::DISResourcePerl
                                                 .plGetMethodInputNormalizer>;
                  if ($param_processor) {
                    $param_variables[-1]->[1]
                        = $param_processor-><AG::DISResourcePerl
                                                 .plCodeFragment>;
                    unless ($param_variables[-1]->[1]) {
                     __UNDEEP{__EXCEPTION{DIS|PERL_CODE_NOT_DEFINED_ERR::
                        DIS:sourceNode => {$param->{src}},
                        DIS:uri => {$param->{uri}},
                      }__}__;
                    }
                    $param_variables[-1]->[1] = $param_variables[-1]->[1]->clone;
                    $param_variables[-1]->[1]
                                   -><M::DIS|MPLCodeFragment.replaceVariable>
                                         ('$INPUT' => $param_variables[-1]->[0]);
                  }
                }
              } else { ## Named parameter
                unless ($param-><M::DIS|DISResourceProp
                                   .getPropertyBoolean>
                                      (<Q::DISPerl:isNamedParameter>, false)) {
                  __UNDEEP{__EXCEPTION{DIS|NON_NAMED_PARAMETER_AFTER_NAMED_ERR::
                    DIS:sourceNode => {$param->{src}},
                    DIS:uri => {$param->{uri}},
                    DIS:localName => {$param-><AG::DIS|DISAnyResource
                                                  .localName>},
                  }__}__;
                } elsif ($param-><AG::DISResourcePerl.plIsNullable>) {
                  $prototype =~ s/;%$/%/;
                }
              }
              if ($is_named_param) {
                push @named_param_variables, [
                  $param-><AG::DISResourcePerl.plVariableName>,
                  null,
                  '$' . $param-><AG::DIS|DISAnyResource.localName>,
                ];
                my $param_processor
                        = $param-><M::DISResourcePerl
                                                 .plGetMethodInputNormalizer>;
                if ($param_processor) {
                  $named_param_variables[-1]->[1]
                        = $param_processor-><AG::DISResourcePerl
                                                 .plCodeFragment>;
                  unless ($param_variables[-1]->[1]) {
                   __UNDEEP{__EXCEPTION{DIS|PERL_CODE_NOT_DEFINED_ERR::
                      DIS:sourceNode => {$param->{src}},
                      DIS:uri => {$param->{uri}},
                    }__}__;
                  }
                  $named_param_variables[-1]->[1]
                    = $named_param_variables[-1]->[1]->clone;
                  $named_param_variables[-1]->[1]
                                   -><M::DIS|MPLCodeFragment.replaceVariable>
                                         ('$INPUT' => $param_variables[-1]->[0]);
                }
              }
            } # %$params
            
            $r-><AS::DIS|MPLSub.prototype> ($prototype);
            $r-><M::DIS|MPLSS.appendCodeFragment>
                   ($plimpl-><M::DIS|MPLImpl.createPerlStatement>
                          ('my (' . join (', ', '$self',
                             map {$_->[0]} @param_variables) . ') = @_'));
            for my $p (@param_variables, @named_param_variables) {
              if ($p->[1]) {  ## Input processor
                $r-><M::DIS|MPLSS.appendCodeFragment> ($p->[1]);
              }
            }
 
            ## TODO: in/out
            
            ## Return value
            my $data_type;
            my $data_type_value;
            try {
              $data_type = $ret-><AG::DIS|DISResource
                                     .disActualDataTypeResource>;
              $data_type_value = $ret-><AG::DIS|DISResource
                                     .disActualDataTypeValue>;
            } catch <IF::DIS|DISException> with {
              my $err = shift;
              if ($err->{<Q::MDOMX:subtype>} ne <Q::DIS|NO_DIS_TYPE_ERR>) {
                $err->throw;
              }
            };
            if ($data_type and $data_type-><M::DIS|DISResource.isSubsetOfURI>
                                                        (<Q::idl:void>)) {
              undef $data_type;
              undef $data_type_value;
            }

            if ($data_type) {
              my $def = $data_type-><M::DIS|DISResourceProp.getPropertyValue>
                                          (<Q::dis:DefaultValue>);
              my $rs = $plimpl-><M::DIS|MPLImpl.createPerlStatement>;
              my $rvar = $plimpl-><M::DIS|MPLImpl.createPerlVariable>
                                               ('$', null, 'r');
              $rvar-><AS::PCVar.variableScope> ('my');
              if ($def) {
                $def = $def-><M::DVValuePerl.plCodeFragment>
                               ($self,
                                data_type_uri => $data_type
                                       -><AG::DIS|DISAnyResource.uri>);
                $rs-><M::DIS|PLAnyCon.appendNewAssignment> ($rvar => $def);
              } else {
                __CODE{setDefaultValue::
                  $result => $def,
                  $data_type => $data_type,
                  $plimpl => $plimpl,
                }__;
                if ($def) {
                  $rs-><M::DIS|PLAnyCon.appendNewAssignment> ($rvar => $def);
                } else {
                  $rs-><M::DIS|PLInCon.appendCodeFragment> ($rvar);
                }
              }
              $r-><M::DIS|MPLSS.appendCodeFragment> ($rs);
            }

            my $code = $ret-><AG::DISResourcePerl.plCodeFragment>;
            if ($code) {
              for my $np (@named_param_variables) {
                $code-><M::DIS|MPLCodeFragment.replaceVariable>
                             ($np->[2] => $np->[0]);
              }
              $r-><M::DIS|MPLSS.appendCodeFragment> ($code);

              $ret->{<H::DIS:plDefined>} = true;
              $self->{<H::DIS:plDefined>} = true;
            } else {  ## Method code not defined
              my $cls = $self->{db}-><M::DIS|DISDatabase.getResource>
                                              (<Q::dx:CoreException>,
                                               for_arg => <Q::ManakaiDOM:Perl>);
              my $const = $self->{db}-><M::DIS|DISDatabase.getResource>
                                          (<Q::dx:NOT_SUPPORTED_ERR>,
                                               for_arg => <Q::ManakaiDOM:Perl>);
              my $subtype = $self->{db}-><M::DIS|DISDatabase.getResource>
                                  (<Q::MDOMX:MDOM_IMPL_METHOD_NOT_IMPLEMENTED>,
                                               for_arg => <Q::ManakaiDOM:Perl>);
              $_-><AS::DIS|DISAnyResource.isReferred>
                 ($ret-><AG::DIS|DISAnyResource.uri>) for $cls, $const, $subtype;
              my $context_param = $ret-><M::ManakaiDISResourcePerl
                                             .plGetContextParameter>;
              $self-><M::ManakaiDISResourcePerl.plAppendThrow>
                               ($r, $cls, $const, $subtype,
                                {%$context_param});
              $ret->{<H::DIS:plDefined>} = false;
              $self->{<H::DIS:plDefined>} = false;
            }

            if ($data_type) {
              my $rvar = $plimpl-><M::DIS|MPLImpl.createPerlVariable>
                                               ('$', null, 'r');

              ## Output processor
              my $nin = $data_type_value-><M::dv|DVValue.getProperty>
                                        (<Q::ManakaiDOM:noInputNormalize>);
              my $op = $data_type-><M::DIS|DISResource.getChildResourceByType>
                                        (<Q::DISLang:OutputProcessor>)
                unless $nin and $nin-><AG::dv|DVValue.value>;
              if ($op) {
                my $opcode = $op-><AG::dp|DISResourcePerl.plCodeFragment>;
                unless ($opcode) {
                 __UNDEEP{__EXCEPTION{DIS|PERL_CODE_NOT_DEFINED_ERR::
                    DIS:uri => {$op-><AG::DIS|DISAnyResource.uri>},
                  }__}__;
                }
                $opcode = $opcode->clone;
                $opcode-><M::DIS|MPLCodeFragment.replaceVariable>
                                         ('$INPUT' => $rvar->clone);
                $r-><M::DIS|MPLSS.appendCodeFragment> ($opcode);
              }

              ## Return value
              $r-><M::DIS|MPLSS.appendCodeFragment> ($rvar);
            }
        }__;
##DISLang:Method

TMethods:
  @enDesc:
    <Q::DISLang|Attribute>

  @TAttr:
    @@Name: plCodeFragment
    @@DIS:targetType: DISLang|Attribute
    @@Get:
      @@@Type: DIS|MPLCodeFragment
      @@@PerlDef:
        __DEEP{
            $self->{<H::DIS|plCodeFragment>} = null;  ## To avoid loop
            my $get = $self-><M::DIS|DISResource
                            .getChildResourceByType> (<Q::DISLang:AttributeGet>);
            unless ($get) { 
              __UNDEEP{
                __EXCEPTION{DIS|NO_ATTR_GET_ERR::
                  DIS:errResource => {$self},
                  DIS:sourceNode => {$self->{src}},
                  DIS:uri => {$self-><AG::DIS|DISAnyResource.uri>},
                }__;
              }__;
            }
            my $da; ## Reflecting element attribute
            my $plimpl = $self-><AG::DISAnyResourcePerl.plImplementation>;
            my $data_type = $get-><AG::DIS|DISResource
                                      .disActualDataTypeResource>;
            my $data_type_value = $get-><AG::DIS|DISResource
                                     .disActualDataTypeValue>;
            my $get_code = $plimpl-><M::DIS|MPLImpl.createPerlBlockContainer>;
            $get_code-><M::DIS|PLBlockCon.appendStatement> (q<my ($self) = @_>);
            my $code = $get-><AG::DISResourcePerl.plCodeFragment>;
            unless ($code) {
              $da = $self-><M::DIS|DISResourceProp.getPropertyResource>
                                 (<Q::dis:DocAttr>,
                                  default_media_type => <Q::DISCore:TFPQNames>);
              if ($da) {  ## Reflecting an element attribute
                my $data_type_node = $get-><AG::DIS|DISResource
                                               .disActualDataTypeValue>;
                my $daget_node = $data_type_node-><M::dv|DVValue.getProperty>
                                              (<Q::DOMMain:reflectGet>);
                ## TODO: More work might be required for 
                ##       default values for element attributes.
                my $daget;
                if (UNIVERSAL::isa ($daget_node, <IFName::dv|DVURIValue>)) {
                  $daget = $daget_node-><M::dv|DVURIValue.getResource>
                            ($self-><AG::DIS|DISAnyResource.database>);
                } else {
                  $daget = $data_type-><M::DIS|DISResource
                              .getChildResourceByType> (<Q::DOMMain:ReflectGet>);
                }
                if ($daget) {
                  $code = $daget-><AG::DISResourcePerl.plCodeFragment>->clone;
                  my $ln = $da-><AG::DIS|DISResourceMV.mvLocalName>;
                  my $pfx = $da-><AG::DIS|DISResourceMV.mvPrefix>;
                  $pfx = defined $pfx ? $pfx . ':' : '';
                  $code-><M::DIS|MPLCodeFragment.replaceVariable>
                         ('$LOCAL_NAME' => $plimpl-><M::DIS|MPLImpl
                                              .createPerlStringLiteral> ($ln));
                  $code-><M::DIS|MPLCodeFragment.replaceVariable>
                         ('$QNAME' => $plimpl-><M::DIS|MPLImpl
                                           .createPerlStringLiteral> ($pfx.$ln));
                  $code-><M::DIS|MPLCodeFragment.replaceVariable>
                         ('$PREFIX' => $plimpl-><M::DIS|MPLImpl
                                           .createPerlStringLiteral> ($pfx));
                  my $nsuri = $da-><AG::DIS|DISResourceMV
                                           .mvNamespaceURI>;
                  $code-><M::DIS|MPLCodeFragment.replaceVariable>
                         ('$NS_URI' => defined $nsuri
                                       ? $plimpl-><M::DIS|MPLImpl
                                              .createPerlStringLiteral> ($nsuri)
                                       : $plimpl-><M::DIS|MPLImpl
                                              .createPerlAtom> ('undef'));
                  $code-><M::DIS|MPLCodeFragment.replaceVariable>
                         ('$NS_URI_NO_NULL' => defined $nsuri
                                       ? $plimpl-><M::DIS|MPLImpl
                                              .createPerlStringLiteral> ($nsuri)
                                       : $plimpl-><M::DIS|MPLImpl
                                         .createPerlStringLiteral> (<Q::null:>));
                } else {
                  __UNDEEP{__EXCEPTION{DIS|NO_REFLECT_GET_DEFINED_ERR::
                    DIS:sourceNode => {$self->{src}},
                    DIS:uri => {$data_type->{uri}},
                  }__}__;
                }
              }
            }
            if ($code) {
              ## Default value
              my $def = $get-><M::DIS|DISResourceProp.getPropertyValue>
                                   (<Q::dis:DefaultValue>);
              if ($def) {
                $def = $def-><M::DVValuePerl.plCodeFragment>
                            ($self,
                             data_type_uri => $data_type
                                    -><AG::DIS|DISAnyResource.uri>);
              } else {
                __CODE{setDefaultValue::
                  $result => $def,
                  $data_type => $data_type,
                  $plimpl => $plimpl,
                }__;
              }
              my $rs = $plimpl-><M::DIS|MPLImpl.createPerlStatement>;
              my $rvar1 = $plimpl-><M::DIS|MPLImpl.createPerlVariable>
                                               ('$', null, 'r');
              $rvar1-><AS::PCVar.variableScope> ('my');
              if ($def) {
                $rs-><M::DIS|PLAnyCon.appendNewAssignment> ($rvar1 => $def);
              } else {
                $rs-><M::DIS|PLInCon.appendCodeFragment> ($rvar1);
              }
              $get_code-><M::DIS|PLBlockCon.appendCodeFragment> ($rs);

              ## Main code
              $get_code-><M::DIS|PLBlockCon.appendCodeFragment> ($code);

              ## Return value
              my $rvar = $plimpl-><M::DIS|MPLImpl.createPerlVariable>
                                               ('$', null, 'r');

              ## Output processor
              my $nin = $data_type_value-><M::dv|DVValue.getProperty>
                                        (<Q::ManakaiDOM:noInputNormalize>);
              my $op = $data_type-><M::DIS|DISResource.getChildResourceByType>
                                        (<Q::DISLang:OutputProcessor>)
                unless $nin and $nin-><AG::dv|DVValue.value>;
              if ($op) {
                my $opcode = $op-><AG::dp|DISResourcePerl.plCodeFragment>;
                unless ($opcode) {
                 __UNDEEP{__EXCEPTION{DIS|PERL_CODE_NOT_DEFINED_ERR::
                    DIS:uri => {$op-><AG::DIS|DISAnyResource.uri>},
                  }__}__;
                }
                $opcode = $opcode->clone;
                $opcode-><M::DIS|MPLCodeFragment.replaceVariable>
                                         ('$INPUT' => $rvar->clone);
                $get_code-><M::DIS|MPLSS.appendCodeFragment> ($opcode);
              }

              $get_code-><M::DIS|PLBlockCon.appendStatement> ($rvar);

              $get->{<H::DIS:plDefined>} = true;
            } else {  ## Getter code not defined
              my $cls = $self->{db}-><M::DIS|DISDatabase.getResource>
                                              (<Q::dx:CoreException>,
                                               for_arg => <Q::ManakaiDOM:Perl>);
              my $const = $self->{db}-><M::DIS|DISDatabase.getResource>
                                          (<Q::dx:NOT_SUPPORTED_ERR>,
                                               for_arg => <Q::ManakaiDOM:Perl>);
              my $subtype = $self->{db}-><M::DIS|DISDatabase.getResource>
                                    (<Q::MDOMX:MDOM_IMPL_ATTR_NOT_IMPLEMENTED>,
                                               for_arg => <Q::ManakaiDOM:Perl>);
              $_-><AS::DIS|DISAnyResource.isReferred>
                 ($get-><AG::DIS|DISAnyResource.uri>) for $cls, $const, $subtype;
              my $context_param = $get-><M::ManakaiDISResourcePerl
                                        .plGetContextParameter>;
              $self-><M::ManakaiDISResourcePerl.plAppendThrow>
                               ($get_code, $cls, $const, $subtype,
                                {%$context_param});
              $get->{<H::DIS:plDefined>} = false;
              $self->{<H::DIS:plDefined>} = false;
            }

            my $set = $self-><M::DIS|DISResource
                            .getChildResourceByType> (<Q::DISLang:AttributeSet>);
            my $set_code = $plimpl-><M::DIS|MPLImpl.createPerlBlockContainer>;
            if ($set) {
              my $data_type = $set-><AG::DIS|DISResource
                                       .disActualDataTypeResource>;
              my $code = $set-><AG::DISResourcePerl.plCodeFragment>;
              unless ($code) {
                $da ||= $self-><M::DIS|DISResourceProp
                                  .getPropertyResource>
                                 (<Q::dis:DocAttr>,
                                  default_media_type => <Q::DISCore:TFPQNames>);
                if ($da) {  ## Reflecting an element attribute
                  my $data_type_node = $set-><AG::DIS|DISResource
                                               .disActualDataTypeValue>;
                  my $daset_node = $data_type_node-><M::dv|DVValue.getProperty>
                                              (<Q::DOMMain:reflectSet>);
                  my $daset;
                  if (UNIVERSAL::isa ($daset_node, <IFName::dv|DVURIValue>)) {
                    $daset = $daset_node-><M::dv|DVURIValue.getResource>
                                ($self-><AG::DIS|DISAnyResource.database>);
                  } else {
                    $daset = $data_type-><M::DIS|DISResource
                              .getChildResourceByType> (<Q::DOMMain:ReflectSet>);
                  }
                  if ($daset) {
                    $code = $daset-><AG::DISResourcePerl.plCodeFragment>->clone;
                    my $ln = $da-><AG::DIS|DISResourceMV.mvLocalName>;
                    my $pfx = $da-><AG::DIS|DISResourceMV.mvPrefix>;
                    $pfx = defined $pfx ? $pfx . ':' : '';
                    $code-><M::DIS|MPLCodeFragment.replaceVariable>
                         ('$LOCAL_NAME' => $plimpl-><M::DIS|MPLImpl
                                              .createPerlStringLiteral> ($ln));
                    $code-><M::DIS|MPLCodeFragment.replaceVariable>
                         ('$QNAME' => $plimpl-><M::DIS|MPLImpl
                                           .createPerlStringLiteral> ($pfx.$ln));
                    $code-><M::DIS|MPLCodeFragment.replaceVariable>
                         ('$PREFIX' => $plimpl-><M::DIS|MPLImpl
                                           .createPerlStringLiteral> ($pfx));
                    my $nsuri = $da-><AG::DIS|DISResourceMV
                                           .mvNamespaceURI>;
                    $code-><M::DIS|MPLCodeFragment.replaceVariable>
                         ('$NS_URI' => defined $nsuri
                                       ? $plimpl-><M::DIS|MPLImpl
                                              .createPerlStringLiteral> ($nsuri)
                                       : $plimpl-><M::DIS|MPLImpl
                                              .createPerlAtom> ('undef'));
                    $code-><M::DIS|MPLCodeFragment.replaceVariable>
                         ('$NS_URI_NO_NULL' => defined $nsuri
                                       ? $plimpl-><M::DIS|MPLImpl
                                              .createPerlStringLiteral> ($nsuri)
                                       : $plimpl-><M::DIS|MPLImpl
                                         .createPerlStringLiteral> (<Q::null:>));
                  } else {
                    __UNDEEP{__EXCEPTION{DIS|NO_REFLECT_SET_DEFINED_ERR::
                      DIS:sourceNode => {$self->{src}},
                      DIS:uri => {$data_type->{uri}},
                    }__}__;
                  }
                }
              }
              if ($code) {
                ## Input
                $set_code-><M::DIS|PLBlockCon.appendStatement>
                              (q<my ($self, $given) = @_>);
                my $param_processor
                        = $set-><M::DISResourcePerl.plGetMethodInputNormalizer>;
                if ($param_processor) {
                  my $pcode = $param_processor-><AG::DISResourcePerl
                                                    .plCodeFragment>->clone;
                  $pcode-><M::DIS|MPLCodeFragment.replaceVariable>
                                                   ('$INPUT' => '$given');
                  $set_code-><M::DIS|PLBlockCon.appendCodeFragment> ($pcode);
                }

                ## Main code
                $set_code-><M::DIS|PLBlockCon.appendCodeFragment> ($code);

                $set->{<H::DIS:plDefined>} = true;
                $self->{<H::DIS:plDefined>} = $get->{<H::DIS:plDefined>};
              } else { ## Setter code not defined
                $set_code-><M::DIS|PLBlockCon.appendStatement>
                                              (q<my ($self) = @_>);
                my $cls = $self->{db}-><M::DIS|DISDatabase.getResource>
                                              (<Q::dx:CoreException>,
                                               for_arg => <Q::ManakaiDOM:Perl>);
                my $const = $self->{db}-><M::DIS|DISDatabase.getResource>
                                          (<Q::dx:NOT_SUPPORTED_ERR>,
                                               for_arg => <Q::ManakaiDOM:Perl>);
                my $subtype = $self->{db}-><M::DIS|DISDatabase.getResource>
                                    (<Q::MDOMX:MDOM_IMPL_ATTR_NOT_IMPLEMENTED>,
                                               for_arg => <Q::ManakaiDOM:Perl>);
                $_-><AS::DIS|DISAnyResource.isReferred>
                 ($set-><AG::DIS|DISAnyResource.uri>) for $cls, $const, $subtype;
                my $context_param = $get-><M::ManakaiDISResourcePerl
                                             .plGetContextParameter>;
                $self-><M::ManakaiDISResourcePerl.plAppendThrow>
                               ($set_code, $cls, $const, $subtype,
                                {%$context_param});
                $set->{<H::DIS:plDefined>} = false;
                $self->{<H::DIS:plDefined>} = false;
              }
            } else {  ## No attribute setter
              $set_code-><M::DIS|PLBlockCon.appendStatement>
                                                       (q<my ($self) = @_>);
              my $cls = $self->{db}-><M::DIS|DISDatabase.getResource>
                                              (<Q::dx:CoreException>,
                                               for_arg => <Q::ManakaiDOM:Perl>);
              my $const = $self->{db}-><M::DIS|DISDatabase.getResource>
                                (<Q::dx:NO_MODIFICATION_ALLOWED_ERR>,
                                               for_arg => <Q::ManakaiDOM:Perl>);
              my $subtype = $self->{db}-><M::DIS|DISDatabase.getResource>
                                    (<Q::dx:READ_ONLY_ATTRIBUTE_ERR>,
                                               for_arg => <Q::ManakaiDOM:Perl>);
              $_-><AS::DIS|DISAnyResource.isReferred>
                ($self-><AG::DIS|DISAnyResource.uri>) for $cls, $const, $subtype;
              my $context_param = $get-><M::ManakaiDISResourcePerl
                                        .plGetContextParameter>;
              $self-><M::ManakaiDISResourcePerl.plAppendThrow>
                               ($set_code, $cls, $const, $subtype,
                                {%$context_param});
              $self->{<H::DIS:plDefined>} = $get->{<H::DIS:plDefined>};
            }

            $r = $self->{<H::DIS|plCodeFragment>}
               = $plimpl-><M::DIS|MPLImpl.createPerlSub>
                            ($self-><AG::DISResourcePerl.plName>);
            $r-><AS::DIS|MPLSub.prototype> (q<$;$>);

            ## TODO: Don't output "if" if non-debug build
            
            $r-><M::DIS|PLBlockCon.appendNewIf>
                     ($plimpl-><M::DIS|MPLImpl.createPerlInlineUnparsedCode>
                                        (q<@_ == 1>),
                      $get_code,
                      $set_code);
        }__;
##DISLang:Attribute

TMethods:
  @enDesc:
    <Q::DIS|AnyMethod>

  @TMethod:
    @@Name: getPerlModuleMemberCode
    @@DIS:targetType: DIS|AnyMethod
    @@Param:
      @@@Name: factory
      @@@Type: PCDocument
    @@Param:
      @@@Name: thismod_pack
      @@@Type: DIS|PLPack
    @@Return:
      @@@Type: Node
      @@@PerlDef:
        __DEEP{
          my $method_code = $self-><AG::DISResourcePerl.plCodeFragment>;
          my $method_names = $self-><M::DIS|MPLSub.getPerlNameList>;
          $method_code-><M::DIS|MPLSub.clearPerlName>;
          my $type_uris = $self-><M::DIS|DISResourceProp
                                           .getPropertyTextList>
                                        (<Q::DIS|targetType>);
          my $method_name_0 = $method_names->[0];
          my $type_uri_0 = $type_uris->[0];
          my $st = $factory-><M::PCDocument.createPCStatement>;
                $st-><M::DIS|PLBlockCon.appendCode>
                       ('$Message::Util::DIS::Method{');
                $st-><M::DIS|PLAnyCon.appendStringLiteral> ($type_uri_0);
                $st-><M::DIS|PLBlockCon.appendCode> ('}->{');
                $st-><M::DIS|PLAnyCon.appendStringLiteral> ($method_name_0);
                $st-><M::DIS|PLBlockCon.appendCode> ('} = ');
                $st-><AG::Node.ownerDocument>
                   -><M::Document.adoptNode> ($method_code);
                $st-><M::Node.appendChild> ($method_code);
          $thismod_pack-><M::Node.appendChild> ($st);
          for my $type_uri (@$type_uris) {
            M: for my $method_name (@$method_names) {
              next M if $method_name eq $method_name_0 and
                        $type_uri eq $type_uri_0;
              my $st = $factory-><M::PCDocument.createPCStatement>;
                    $st-><M::DIS|PLBlockCon.appendCode>
                           ('$Message::Util::DIS::Method{');
                    $st-><M::DIS|PLAnyCon.appendStringLiteral> ($type_uri);
                    $st-><M::DIS|PLBlockCon.appendCode> ('}->{');
                    $st-><M::DIS|PLAnyCon.appendStringLiteral> ($method_name);
                    $st-><M::DIS|PLBlockCon.appendCode> ('} = ');
                    $st-><M::DIS|PLBlockCon.appendCode>
                           ('$Message::Util::DIS::Method{');
                    $st-><M::DIS|PLAnyCon.appendStringLiteral> ($type_uri_0);
                    $st-><M::DIS|PLBlockCon.appendCode> ('}->{');
                    $st-><M::DIS|PLAnyCon.appendStringLiteral> ($method_name_0);
                    $st-><M::DIS|PLBlockCon.appendCode> ('}');
              $thismod_pack-><M::Node.appendChild> ($st);
            }
          }
        }__;
##DIS:AnyMethod

TMethods:
  @enDesc:
    <Q::DISLang|MethodParameter>

  @TAttr:
    @@Name: plName
    @@DIS:targetType: DISLang|MethodParameter
    @@Get:
      @@@Type: DISString
      @@@PerlDef:
        __DEEP{
          $r = $self-><M::DIS|DISResourceProp.getPropertyText>
                        (<Q::DISPerl:paramName>,
                         $self-><AG::DIS|DISAnyResource.localName>);
          if (defined $r) {
            if ($self-><M::DIS|DISResourceProp.getPropertyBoolean>
                         (<Q::DISPerl:isNamedParameter>, false)) {
              $r = <ClassM::DIS|ManakaiDISImplementation.camelCaseToUnderscoreName>
                                                       ($r);
            }
          }
        }__;
##DISLang:MethodParameter

TMethods:
  @enDesc:
    <Q::DISLang|Const>

  @TAttr:
    @@Name: plName
    @@DIS:targetType: DISLang|Const
    @@enDesc:
      Constant function (local) name. 
    @@Get:
      @@@Type: DISString
      @@@PerlDef:
        __DEEP{
            unless (defined $self-><AG::DIS|DISAnyResource.localName>) {
              __UNDEEP{
                __EXCEPTION{DIS|NO_LOCAL_NAME_ERR::
                  DIS:uri => {$self-><AG::DIS|DISAnyResource.uri>},
                  DIS:sourceNode => {$self-><AG::DIS|DISAnyResource
                                                .sourceElement>},
                }__;
              }__;
            }
            $r = uc $self-><AG::DIS|DISAnyResource.localName>;
            if ($r =~ /^_/ or $r =~ /_$/) {
              __UNDEEP{
                __EXCEPTION{DIS|RESERVED_PERL_METHOD_NAME_ERR::
                  DIS:uri => {$self-><AG::DIS|DISAnyResource.uri>},
                  DIS:localName => {$self-><AG::DIS|DISAnyResource.localName>},
                  DIS:sourceNode => {$self-><AG::DIS|DISAnyResource
                                                              .sourceElement>},
                  DIS:generatedName => {$r},
                }__;
              }__;
            }
      }__;

  @TAttr:
    @@Name: plFullyQualifiedName
    @@DIS:targetType: DISLang|Const
    @@Get:
      @@@Type: DISString
      @@@PerlDef:
        __DEEP{
            $r = $self-><AG::DIS|DISResource.parentResource>
                      -><AG::DIS|DISResource.parentResource>
                      -><AG::DISModulePerl.plFullyQualifiedName>
               . '::' . $self-><AG::DISResourcePerl.plName>;
        }__;

  @TAttr:
    @@Name: plCodeFragment
    @@DIS:targetType: DISLang|Const
    @@Get:
      @@@Type: DIS|MPLCodeFragment
      @@@PerlDef:
        __DEEP{
            my $data_type = $self-><AG::DIS|DISResource
                                       .disActualDataTypeResource>;
            my $plimpl = $self-><AG::DISAnyResourcePerl.plImplementation>;
            my $value = $self-><M::DIS|DISResourceProp.getPropertyValue>
                              (<Q::dis:Value>);
            if ($value) {
              $value = $value-><M::DVValuePerl.plCodeFragment>
                              ($self,
                               data_type_uri => $data_type
                                    -><AG::DIS|DISAnyResource.uri>);
            } else {
              __CODE{setDefaultValue::
                $result => $value,
                $data_type => $data_type,
                $plimpl => $plimpl,
              }__;
            }
            $r = $plimpl-><M::DIS|MPLImpl.createPerlSub>
                            ($self-><AG::DISResourcePerl.plName>);
            $r-><M::DIS|PLBlockCon.appendCodeFragment> ($value);
            $r-><AS::DIS|MPLSub.prototype> ('');
        }__;

  @TMethod:
    @@Name: getPerlInterfaceMemberCode
    @@DIS:targetType: DISLang|Const
    @@Param:
      @@@Name: factory
      @@@Type: PCDocument
    @@Return:
      @@@Type: Node
      @@@PerlDef:
        __DEEP{
          $r = $self-><AG::DISResourcePerl.plCodeFragment>;
        }__;

  @TMethod:
    @@Name: getPerlClassMemberCode
    @@DIS:targetType: DISLang|Const
    @@Param:
      @@@Name: factory
      @@@Type: PCDocument
    @@Return:
      @@@Type: Node
      @@@PerlDef:
        __DEEP{
          $r = $self-><AG::DISResourcePerl.plCodeFragment>;
        }__;
##DISLang:Const

TMethods:
  @TMethod:
    @@Name: getPerlDefinitionHashNamespace
    @@DIS:targetType: dx|ErrorCode
    @@DIS:targetType: dx|ErrorSubCode
    @@Return:
      @@@Type: DISString
      @@@PerlDef:
        __DEEP{
          my $if = $self-><M::anyres.getErrorInterfaceResource>;
          if ($if) {
            $r = $if-><AG::DISResourcePerl.plFullyQualifiedName>;
          } else {
            $r = null;
          }
        }__;
##dx:ErrorCode, dx:ErrorSubCode

TMethods:
  @TMethod:
    @@Name: getPerlInterfaceMemberCode
    @@DIS:targetType: dx|ErrorCode
    @@Param:
      @@@Name: factory
      @@@Type: PCDocument
    @@Return:
      @@@Type: Node
      @@@PerlDef:
        __DEEP{
          $r = $factory-><M::Document.createDocumentFragment>;

          ## Perl constant function
          my $const = $self-><AG::DISResourcePerl.plCodeFragment>;
          $factory-><M::Document.adoptNode> ($const);
          $r-><M::Node.appendChild> ($const);

          ## Error definition
          my $def_st = $factory-><M::PCDocument.createPCStatement>;
          for ($def_st-><M::DIS|PLAnyCon.appendNewPCExpression> ('=')) {
            $_-><M::DIS|PLAnyCon.appendNewPCVariable>
                  ('$',
                   $self-><M::DISResourcePerl.getPerlDefinitionHashNamespace>,
                   'ErrorDef')
              -><AS::PCVar.hashKey> ($self-><AG::DISResourcePerl.plName>);
            $_-><M::DIS|PLAnyCon.appendNewPCLiteral> ({
              <H::DOMCore|code> => 0+$self-><AG::DISResourcePerl.plCodeFragment>,
              <H::ecore|description> =>
                $self-><M::ManakaiDISResourcePerl.plMufDescriptionText>,
            });
          }
          $r-><M::Node.appendChild> ($def_st);

          ## Error subcode definitions
          for (@{$self-><M::DIS|DISResource.getChildResourceListByType>
                          (<Q::dx|ErrorSubCode>)}) {
            $r-><M::Node.appendChild>
                  ($_-><M::DISResourcePerl.getPerlInterfaceMemberCode>
                         ($factory));
          }
        }__;
##dx:ErrorCode

TMethods:
  @TMethod:
    @@Name: getPerlInterfaceMemberCode
    @@DIS:targetType: dx|ErrorSubCode
    @@Param:
      @@@Name: factory
      @@@Type: PCDocument
    @@Return:
      @@@Type: Node
      @@@PerlDef:
        __DEEP{
          ## Error definition
          my $errif = $self-><M::anyres.getErrorInterfaceResource>;
          $r = $factory-><M::PCDocument.createPCStatement>;
          $r-><M::DIS|PLAnyCon.appendNewPCVariable>
                ('$',
                 $errif-><M::DISResourcePerl.getPerlDefinitionHashNamespace>,
                 'ErrorDef')
            -><AS::PCVar.hashKey>
                ($self-><M::DISResourcePerl.getPerlErrorCodeName>);
          $r-><M::DIS|PLBlockCon.appendCode> ('->{');
          $r-><M::DIS|PLAnyCon.appendStringLiteral> (<H::MDOMX|subtype>);
          $r-><M::DIS|PLBlockCon.appendCode> ('}->{');
          $r-><M::DIS|PLAnyCon.appendStringLiteral>
                ($self-><AG::anyres.nameURI>);
          $r-><M::DIS|PLBlockCon.appendCode> ('} = ');
          $r-><M::DIS|PLAnyCon.appendNewPCLiteral> ({
                  <H::ecore|description> =>
                  $self-><M::ManakaiDISResourcePerl.plMufDescriptionText>,
                });
          $self-><M::ManakaiDISResourcePerl.plAddRequireResource>
                   ($errif => $r);
        }__;

  @TMethod:
    @@Name: getPerlErrorCodeName
    @@DIS:targetType: dx|ErrorSubCode
    @@Param:
      @@@Name: factory
      @@@Type: PCDocument
    @@Return:
      @@@Type: DISString
      @@@PerlDef:
        __DEEP{
          my $code = $self-><M::anyres.getErrorCodeResource>;
          if ($code) {
            $r = $code-><AG::DISResourcePerl.plName>;
          } else {
            $r = null;
          }
        }__;
##dx:ErrorSubCode

TMethods:
  @enDesc:
    <Q::DISLang|ConstGroup>

  @TAttr:
    @@Name: plName
    @@DIS:targetType: DISLang|ConstGroup
    @@enDesc:
      Export group name (without <CHAR::COLON> prefix).
    @@Get:
      @@@Type: DISString
      @@@PerlDef:
        __DEEP{
          $r = $self-><M::DIS|DISResourceProp.getPropertyText>
                         (<Q::DISPerl:exportTagName>,
                          $self-><AG::anyres.localName>);
        }__;
        unless (defined $r) {
          __EXCEPTION{DIS|NO_LOCAL_NAME_ERR::
            DIS:uri => {$self-><AG::anyres.uri>},
            DIS:sourceNode => {$self-><AG::anyres.sourceElement>},
          }__;
        }

  @TMethod:
    @@Name: getPerlClassMemberCode
    @@DIS:targetType: DISLang|ConstGroup
    @@Param:
      @@@Name: factory
      @@@Type: PCDocument
    @@Return:
      @@@Type: Node
      @@@PerlDef:
        __DEEP{
          $r = $factory-><M::Document.createDocumentFragment>;
          for my $gcr (@{$self-><M::DIS|DISResource.getChildResourceList>}) {
            if ($gcr-><M::DIS|DISAnyResource.isTypeURI> (<Q::DISLang|Const>)) {
              if ($gcr-><M::anyres.isTypeURI> (<Q::dx|ErrorCode>)) {
                $r-><M::Node.appendChild>
                      ($gcr-><M::DISResourcePerl.getPerlInterfaceMemberCode>
                               ($factory));
              } else {
                my $sub = $gcr-><AG::DISResourcePerl.plCodeFragment>;
                $factory-><M::Document.adoptNode> ($sub);
                $r-><M::Node.appendChild> ($sub);
              }
            }
          }
        }__;

  @TMethod:
    @@Name: getPerlInterfaceMemberCode
    @@DIS:targetType: DISLang|ConstGroup
    @@Param:
      @@@Name: factory
      @@@Type: PCDocument
    @@Return:
      @@@Type: Node
      @@@PerlDef:
        __DEEP{
          $r = $factory-><M::Document.createDocumentFragment>;

          ## Error code definitions
          for (@{$self-><M::DIS|DISResource.getChildResourceListByType>
                          (<Q::DISLang|Const>)}) {
            my $mcode = $_-><M::DISResourcePerl.getPerlInterfaceMemberCode>
                              ($factory);
            if ($mcode) {
              $r-><AG::Node.ownerDocument>
                -><M::Document.adoptNode> ($mcode);
              $r-><M::Node.appendChild> ($mcode);
            }
          }
        }__;
##DISLang:ConstGroup

TMethods:
  @enDesc:
    <Q::DISLang|AnyClass>

  @TAttr:
    @@Name: plName
    @@DIS:targetType: DISLang|AnyClass
    @@Get:
      @@@Type: DISString
      @@@PerlDef:
        __DEEP{
            $r = $self-><M::DIS|DISResourceProp.getPropertyText>
                                (<Q::DISPerl:name>,
                                 $self-><AG::DIS|DISAnyResource.localName>);
            if (defined $r) {
              $r = <ClassM::DIS|ManakaiDISImplementation
                           .camelCaseToUnderscoreName> ($r);
            }
        }__;

  @TAttr:
    @@Name: plFullyQualifiedName
    @@DIS:targetType: DISLang|AnyClass
    @@enDesc:
        - <Q::ManakaiDOM:Class>::: Class package name. 
    @@Get:
      @@@Type: DISString
      @@@PerlDef:
        __DEEP{
            $r = $self-><M::DIS|DISResourceProp.getPropertyText>
                              (<Q::DISPerl:packageName>);
            if (defined $r) {
              ## NOTE: "lang:Perl" is fully-qualified name by definition
            } else {
              unless (defined $self-><AG::DIS|DISAnyResource.localName>) {
                __UNDEEP{
                  __EXCEPTION{DIS|NO_LOCAL_NAME_ERR::
                    DIS:sourceNode => {$self->{src}},
                  }__;
                }__;
              }
                $r = $self-><AG::DIS|DISAnyResource.ownerModule>
                          -><AG::DISModulePerl.plFullyQualifiedName>
                   . '::' . $self-><AG::DIS|DISAnyResource.localName>;
            }
        }__;
##DISLang:AnyClass

TMethods:
  @enDesc:
    <Q::DISLang|Class>

  @TAttr:
    @@Name: plCodeFragment
    @@DIS:targetType: DISLang|Class
    @@Get:
      @@@Type: DIS|MPLCodeFragment
      @@@PerlDef:
        __DEEP{
            my $plimpl = $self-><AG::DISAnyResourcePerl.plImplementation>;
            $r = $plimpl-><M::DIS|MPLImpl.createPerlPackage>
                              ($self-><AG::DISResourcePerl
                                         .plFullyQualifiedName>);
            ## - Inheritance
            for my $scls (@{$self-><M::DIS|DISResourceProp
                                     .getPropertyResourceList> (<Q::dis:ISA>)}) {
              my $spack_name = $scls-><AG::DISResourcePerl.plFullyQualifiedName>;
              if (defined $spack_name) {
                $r-><M::DIS|PLPack.addISAPackage> ($spack_name);
              } else {
                __UNDEEP{__EXCEPTION{DIS|NO_PERL_PACKAGE_NAME_ERR::
                  DIS:uri => {$scls-><AG::DIS|DISAnyResource.uri>},
                  DIS:elementType => {<Q::dis:ISA>},
                }__}__;
              }
              $self-><M::ManakaiDISResourcePerl.plAddRequireResource>
                                                  ($scls => $r);
            }

            ## dis:AppISA packages
            for my $spack_name (@{
              $self-><AG::DISResourcePerl.plAdditionalISAPackages>
            }) {
              $r-><M::DIS|PLPack.addISAPackage> ($spack_name);
              $r-><M::DIS|MPLCodeFragment.addRequirePerlModuleName>
                                              ($spack_name);                     
            }

            ## - Implementing interfaces
            for my $scls (@{$self-><M::DIS|DISResourceProp
                                         .getPropertyResourceList>
                                    (<Q::dis:Implement>, recursive_isa => true,
                                     default_media_type => <Q::dis:TFQNames>)}) {
              my $spack_name = $scls-><AG::DISResourcePerl
                                         .plFullyQualifiedName>;
              if (defined $spack_name) {
                $r-><M::DIS|PLPack.addImplementPackage> ($spack_name);
                if ($scls-><M::DIS|DISAnyResource.isTypeURI>
                      (<Q::Err:MUErrorInterface>)) {
                  $r-><M::DIS|MPLCodeFragment.addExceptionInterfacePackageName>
                      ($spack_name);
                }
              }
            }
    
            ## - Class members
            my @cr = @{$self-><M::DIS|DISResource.getChildResourceList>};
            for my $cr (@cr) {
              my $mcode = $cr-><M::DISResourcePerl.getPerlClassMemberCode>
                                  ($r-><AG::Node.ownerDocument>);
              if ($mcode) {
                $r-><AG::Node.ownerDocument>
                  -><M::Document.adoptNode> ($mcode);
                $r-><M::Node.appendChild> ($mcode);
              }
            }

            ## - Error Descriptions
            if ($self-><M::DIS|DISAnyResource.isTypeURI>
                 (<Q::Err:MUErrorClass>)) {
              my $tf = $self-><M::DIS|DISResourceProp.getPropertyResource>
                                (<Q::ecore:textFormatter>);
              if ($tf) {
                my $fpc = $plimpl-><M::DIS|MPLImpl.createPerlSub>
                                     ('_FORMATTER_PACKAGE_');
                $fpc-><M::DIS|PLAnyCon.appendStringLiteral>
                                     ($tf-><AG::dp|DISResourcePerl
                                                .plFullyQualifiedName>);
                $r-><M::DIS|PLPack.setSubNode> ($fpc);
              }
            } # Err:MUErrorClass

              my %rule;
              ## Muf2003 formatting rule definitions for errors
              for my $rc (@{$self-><M::DIS|DISResource
                                      .getChildResourceListByType>
                               (<Q::Muf2003:RuleDefClass>)}) {
                my $rule_name = $rc-><AG::dp|DISResourcePerl.plName>;
                my $rcls = $rule{$rule_name} = {};
                for my $rm (@{$rc-><M::DIS|DISResource
                                      .getChildResourceListByType>
                               (<Q::DISLang|Method>)}) {
                  my $c = $rm-><AG::dp|DISResourcePerl.plCodeFragment>;
                  $rcls->{$rm-><AG::dp|DISResourcePerl.plName>} = $c;
                  $c-><M::DIS|MPLSub.clearPerlName>;
                }
              }
              if (%rule) {
                my $rule_def = $plimpl-><M::DIS|MPLImpl.createPerlSub>
                                          ('___rule_def');
                $rule_def-><M::DIS|PLBlockCon.appendStatement>
                         -><M::DIS|PLAnyCon.appendNewPCLiteral> (\%rule);
                $r-><M::DIS|PLPack.setSubNode> ($rule_def);
              }

 
            ## - Lexer and Parser
            my $dpgparser;
            for my $val (@{$self-><M::DIS|DISResourceProp.getPropertyValueList>
                             (<Q::DISPerl:dpgDef>)}) {
              require Message::Util::DIS::DPG;
              $dpgparser ||= $plimpl-><M::f|GetFeature
                                         ||ManakaiDOM|ManakaiDOMLatest
                                         .getFeature>
                                       (<Q::fe:GenericLS> => '3.0')
                                  -><M::gls|GLSImplementation
                                         ||ManakaiDOM|ManakaiDOMLatest
                                                           .createGLSParser>
                                       ({<Q::DIS|DPG> => '1.0'});
              my $dpgdoc = $dpgparser-><M::DPG|DPGParser
                                       ||ManakaiDOM|ManakaiDOMLatest.parseString>
                              ($val-><AG::dv|DVValue.value>, $val);
              
              $r-><M::DOMCore|Node||ManakaiDOM|ManakaiDOMLatest.appendChild>
                    ($dpgdoc-><AG::DOMCore|Document||ManakaiDOM|ManakaiDOMLatest
                                 .documentElement>
                            -><M::DPG|DPGRulesElement
                                    ||ManakaiDOM|ManakaiDOMLatest.plCodeFragment>
                              ($r-><AG::DOMCore|Node||ManakaiDOM|ManakaiDOMLatest
                                  .ownerDocument>,
                               dis_resource => $self,
                               context_object => $val));
            }
        }__;

  @TMethod:
    @@Name: getPerlModuleMemberCode
    @@DIS:targetType: DISLang|Class
    @@Param:
      @@@Name: factory
      @@@Type: PCDocument
    @@Param:
      @@@Name: thismod_pack
      @@@Type: DIS|PLPack
    @@Param:
      @@@Name: const
      @@@Type: DISPerl|HASH||ManakaiDOM|all
    @@Return:
      @@@Type: Node
      @@@PerlDef:
        __DEEP{
          $r = $factory-><M::PCDocument.createPCBlock>;
          my $cls = $self;

          ## -- Subroutines and variables
          my $pack = $cls-><AG::DISResourcePerl.plCodeFragment>;
          $factory-><M::Document.adoptNode> ($pack);
          $r-><M::Node.appendChild> ($pack);
                my $pack_name = $cls-><AG::DISResourcePerl
                                          .plFullyQualifiedName>;

                ## -- Constants
                for my $cr (@{$cls-><M::DIS|DISResource.getChildResourceList>}) {
                  if ($cr-><M::DIS|DISAnyResource.isTypeURI>
                                          (<Q::ManakaiDOM:Const>)) {
                    $thismod_pack-><M::DIS|PLPack.addExport>
                      (null,
                       my $nm = $cr-><AG::DISResourcePerl.plName>);
                    $const->{$nm} = $cr-><AG::DISResourcePerl
                                           .plFullyQualifiedName>;
                  } elsif ($cr-><M::DIS|DISAnyResource.isTypeURI>
                                          (<Q::ManakaiDOM:ConstGroup>)) {
                    my $tag = $cr-><AG::DISResourcePerl.plName>;
                    for my $gcr (@{$cr-><M::DIS|DISResource
                                                    .getChildResourceList>}) {
                      if ($gcr-><M::DIS|DISAnyResource.isTypeURI>
                                          (<Q::ManakaiDOM:Const>)) {
                        $thismod_pack-><M::DIS|PLPack.addExport>
                          ($tag, my $nm = $gcr-><AG::DISResourcePerl.plName>);
                        $const->{$nm} = $gcr-><AG::DISResourcePerl
                                                   .plFullyQualifiedName>;
                      }
                    }
                  }
                }

                ## -- Features
                my %feature;
                for my $v (@{$cls-><M::DIS|DISResourceProp.getPropertyValueList>
                                      (<Q::f:provides>)}) {
                  my $f = $self-><AG::DIS|DISAnyResource.database>
                               -><M::DIS|DISDatabase.getResource>
                                     ($v->isa (<IFName::dv|DVURIValue>)
                                         ? $v-><AG::dv|DVURIValue.uri>
                                         : $v-><AG::dv|DVValue.value>);
                  unless ($f-><AS::DIS|DISAnyResource.isDefined>) {
                    __UNDEEP{__EXCEPTION{DIS|RESOURCE_NOT_DEFINED_ERR::
                      DIS:uri => {$f-><AG::DIS|DISAnyResource.uri>},
                      DIS:expectedType => {<Q::f:Feature>},
                    }__}__;
                  }
                  for my $s ($f, @{$f-><M::DIS|DISResourceProp
                                    .getPropertyResourceList>
                                   (<Q::f:extends>,
                                    recursive => true,
                                    default_media_type => <Q::dis:TypeQName>)}) {
                    $feature{$s-><AG::DIS|DISAnyResource.uri>}
                         = [$s, $v];
                  }
                }
                for my $f (values %feature) {
                  my @fname = @{$f->[0]-><AG::DIS|DISResource
                                        .featureNameList>};
                  my $fver = $f->[0]-><M::DIS|DISResourceProp
                                        .getPropertyText>
                                        (<Q::dis:Version>, null);
                  next unless defined $fver;
                  my $fi = $self-><M::DISResourcePerlModule
                        .plIsFeatureImplemented> ($f->[0]->{uri}) ? true : false;
                  my $pt = $f->[1]-><M::dv|DVValue.getProperty>
                                            (<Q::f:through>);
                  if (UNIVERSAL::isa ($pt, <IFName::dv|DVURIValue>)) {
                    my $c = $pt-><M::dv|DVURIValue.getResource>
                              ($self-><AG::DIS|DISAnyResource.database>);
                    $c-><AS::DIS|DISAnyResource.isReferred>
                                    ($f->[0]-><AG::DIS|DISAnyResource.uri>);
                    my $cp = $c-><AG::DISResourcePerl.plFullyQualifiedName>;
                    for my $fname (@fname) {
                      $r-><M::DIS|PLBlockCon.appendStatement>
                          ('$Message::DOM::ImplFeature{q<' . $cp .
                           '>}->{q<' .
                           $fname . '>}->{q<' . $fver . '>} ||= '.$fi);
                      $r-><M::DIS|PLBlockCon.appendStatement>
                          ('$Message::DOM::ImplFeature{q<' . $cp .
                           '>}->{q<' . $fname . '>}->{q<>} = 1');
                    }
                  } else { # no "through" attribute
                    for my $fname (@fname) {
                      $r-><M::DIS|PLBlockCon.appendStatement>
                          ('$Message::DOM::ImplFeature{q<' . $pack_name .
                           '>}->{q<' .
                           $fname . '>}->{q<' . $fver . '>} ||= '.$fi);
                      $r-><M::DIS|PLBlockCon.appendStatement>
                          ('$Message::DOM::ImplFeature{q<' . $pack_name .
                           '>}->{q<' . $fname . '>}->{q<>} = 1');
                    }
                  }
                } # for

                my %ifeature;
                my $ifpoint = 0;
                my %fdup; # Check dupulication
                FI: for my $feature (@{$cls-><M::DIS|DISResourceProp
                          .getPropertyResourceList>
                             (<Q::f:implements>,
                              isa_recursive => true)}) {
                  my $furi = $feature-><AG::DIS|DISAnyResource.uri>;
                  next FI if $fdup{$furi};
                  $fdup{$furi} = true;

                  my $fver = $feature-><M::DIS|DISResourceProp
                                        .getPropertyText>
                                        (<Q::dis:Version>, null);
                  $ifpoint += $fver;
                  my $fi = defined $fver
                         ? $self-><M::DISResourcePerlModule
                                     .plIsFeatureImplemented>
                                           ($feature->{uri}) ? true : false
                         : true;
                  for my $fname (@{$feature-><AG::DIS|DISResource
                                                 .featureNameList>}) {
                    $ifeature{$fname}->{$fver} = $fi;
                    $ifeature{$fname}->{''} = true;
                  }                  
                } # FI
                $r-><M::DIS|PLBlockCon.appendStatement>
                      ('$Message::DOM::ClassFeature{q<' . $pack_name .
                       '>} = ' . <ClassM::PLImplClass.perlLiteral> (\%ifeature));

                ## TODO: Features from implementing interfaces.

                ## Score calculated from provided features
                $r-><M::DIS|PLBlockCon.appendStatement>
                        ('$Message::DOM::ClassPoint{q<' . $pack_name .
                         '>} = ' . $ifpoint);

                ## -- Roles
                for my $role (@{$cls-><M::DIS|DISResourceProp
                          .getPropertyResourceList>
                             (<Q::DISLang:role>, isa_recursive => true,
                              default_media_type => <Q::dis:TypeQName>)}) {
                  if ($role-><M::DIS|DISResource.isSubsetOfURI>
    (<Q::DOMMetaImpl:ImplementationSourceForManakaiDOMImplementationRegistry>)) {
                    $r-><M::DIS|PLBlockCon.appendStatement>
                          ('$Message::DOM::ManakaiDOMImplementationRegistry'.
                           '::SourceClass{q<' . $pack_name . '>} = 1');
                  }
                  if ($role-><M::DIS|DISResource.isSubsetOfURI>
            (<Q::DOMMetaImpl:ImplementationForManakaiDOMImplementationSource>)) {
                    $r-><M::DIS|PLBlockCon.appendStatement>
                          ('$Message::DOM::ManakaiDOMImplementationSource'.
                           '::SourceClass{q<' . $pack_name . '>} = 1');
                  }
                  if ($role-><M::DIS|DISResource.isSubsetOfURI>
   (<Q::DOMMetaImpl:ImplementationCompatibleWithManakaiDOMMinimumImplementation>)
                  ) {
                    $r-><M::DIS|PLBlockCon.appendStatement>
                          ('$Message::DOM::ManakaiDOMImplementation'.
                           '::CompatClass{q<' . $pack_name . '>} = 1');
                  }
                  
                  ## Node
                  if ($role-><M::DIS|DISResource.isSubsetOfURI>
                                (<Q::DOMCore:ElementRole>)) {
                    my $for_specific_et;
                    for my $et (@{$cls-><M::DIS|DISResourceProp
                          .getPropertyResourceList>
                             (<Q::s:elementType>, isa_recursive => true,
                              default_media_type => <Q::dis:TFQNames>)}) {
                      $for_specific_et = true;
                      my $ln = $et-><AG::DIS|DISResourceMV
                                        .mvLocalName>;
                      $ln = '*' unless defined $ln;
                      my $ns = $et-><AG::DIS|DISResourceMV
                                        .mvNamespaceURI>;
                      $ns = '' unless defined $ns;
                        ## ISSUE: Is NULL-namespace should be allowed here?
                      $r-><M::DIS|PLBlockCon.appendStatement>
                          ('$Message::DOM::ManakaiDOMElement' .
                           '::CompatClassET{q<' . $ns . '>}->{q<' . $ln .
                           '>}->{q<' . $pack_name . '>} = 1');
                    }
                    $r-><M::DIS|PLBlockCon.appendStatement>
                          ('$Message::DOM::ManakaiDOMElement'.
                           '::CompatClass{q<' . $pack_name . '>} = 1')
                      unless $for_specific_et;
                  }
                  if ($role-><M::DIS|DISResource.isSubsetOfURI>
                                (<Q::DOMCore:AttributeRole>)) {
                    my $for_specific_attr;
                    for my $at (@{$cls-><M::DIS|DISResourceProp
                          .getPropertyResourceList>
                             (<Q::dis:DocAttr>, isa_recursive => true,
                              default_media_type => <Q::dis:TFQNames>)}) {
                      $for_specific_attr = true;
                      my $ln = $at-><AG::DIS|DISResourceMV
                                        .mvLocalName>;
                      $ln = '*' unless defined $ln;
                      my $ns = $at-><AG::DIS|DISResourceMV
                                        .mvNamespaceURI>;
                      $ns = '' unless defined $ns;
                      my $et = $at-><AG::DIS|DISResourceMV
                                        .mvOwnerElementResource>;
                      my $etns = '*';
                      my $etln = '*';
                      if ($et) {
                        $etns = $et-><AG::DIS|DISResourceMV.mvLocalName>;
                        $etln = '*' unless defined $etln;
                        my $etns = $at-><AG::DIS|DISResourceMV
                                          .mvNamespaceURI>;
                        $etns = '' unless defined $etns;
                          ## ISSUE: Should NULL-namespace be allowed here?
                      }
                      
                      $r-><M::DIS|PLBlockCon.appendStatement>
                          ('$Message::DOM::ManakaiDOMElement' .
                           '::CompatClassAttr{q<' . $etns . '>}->{q<' . $etln .
                           '>}->{q<' . $ns . '>}->{q<' . $ln . '>}->{q<' .
                           $pack_name . '>} = 1');
                    }
                    $r-><M::DIS|PLBlockCon.appendStatement>
                          ('$Message::DOM::ManakaiDOMAttr'.
                           '::CompatClass{q<' . $pack_name . '>} = 1')
                      unless $for_specific_attr;
                  }
                  if ($role-><M::DIS|DISResource.isSubsetOfURI>
                                (<Q::DOMCore:TextRole>)) {
                    $r-><M::DIS|PLBlockCon.appendStatement>
                          ('$Message::DOM::ManakaiDOMText'.
                           '::CompatClass{q<' . $pack_name . '>} = 1');
                  }
                  if ($role-><M::DIS|DISResource.isSubsetOfURI>
                                (<Q::DOMCore:CommentRole>)) {
                    $r-><M::DIS|PLBlockCon.appendStatement>
                          ('$Message::DOM::ManakaiDOMComment'.
                           '::CompatClass{q<' . $pack_name . '>} = 1');
                  }
                  if ($role-><M::DIS|DISResource.isSubsetOfURI>
                                (<Q::DOMCore:CDATASectionRole>)) {
                    $r-><M::DIS|PLBlockCon.appendStatement>
                          ('$Message::DOM::ManakaiDOMCDATASection'.
                           '::CompatClass{q<' . $pack_name . '>} = 1');
                  }
                  if ($role-><M::DIS|DISResource.isSubsetOfURI>
                                (<Q::DOMCore:ProcessingInstructionRole>)) {
                    $r-><M::DIS|PLBlockCon.appendStatement>
                          ('$Message::DOM::ManakaiDOMProcessingInstruction'.
                           '::CompatClass{q<' . $pack_name . '>} = 1');
                    ## TODO: Target name dependent
                  }
                  if ($role-><M::DIS|DISResource.isSubsetOfURI>
                                (<Q::DOMCore:DocumentRole>)) {
                    my $for_specific_et;
                    for my $et (@{$cls-><M::DIS|DISResourceProp
                          .getPropertyResourceList>
                             (<Q::s:rootElementType>, isa_recursive => true,
                              default_media_type => <Q::dis:TFQNames>)}) {
                      $for_specific_et = true;
                      my $ln = $et-><AG::DIS|DISResourceMV
                                        .mvLocalName>;
                      $ln = '*' unless defined $ln;
                      my $ns = $et-><AG::DIS|DISResourceMV
                                        .mvNamespaceURI>;
                      $ns = '' unless defined $ns;
                        ## ISSUE: Is NULL-namespace should be allowed here?
                      $r-><M::DIS|PLBlockCon.appendStatement>
                          ('$Message::DOM::ManakaiDOMDocument' .
                           '::CompatClassET{q<' . $ns . '>}->{q<' . $ln .
                           '>}->{q<' . $pack_name . '>} = 1');
                    }
                    $r-><M::DIS|PLBlockCon.appendStatement>
                          ('$Message::DOM::ManakaiDOMDocument'.
                           '::CompatClass{q<' . $pack_name . '>} = 1')
                      unless $for_specific_et;
                    ## TODO: by document type name and media type
                  }
                  if ($role-><M::DIS|DISResource.isSubsetOfURI>
                                (<Q::DOMCore:DocumentFragmentRole>)) {
                    $r-><M::DIS|PLBlockCon.appendStatement>
                          ('$Message::DOM::ManakaiDOMDocumentFragment'.
                           '::CompatClass{q<' . $pack_name . '>} = 1');
                  }
                  if ($role-><M::DIS|DISResource.isSubsetOfURI>
                                (<Q::DOMCore:DocumentTypeRole>)) {
                    $r-><M::DIS|PLBlockCon.appendStatement>
                          ('$Message::DOM::ManakaiDOMDocumentType'.
                           '::CompatClass{q<' . $pack_name . '>} = 1');
                    ## TODO: Doctype name or public ID dependent
                  }
                  if ($role-><M::DIS|DISResource.isSubsetOfURI>
                                (<Q::DOMCore:EntityRole>)) {
                    $r-><M::DIS|PLBlockCon.appendStatement>
                          ('$Message::DOM::ManakaiDOMEntity'.
                           '::CompatClass{q<' . $pack_name . '>} = 1');
                    ## TODO: Entity name or public ID dependent
                  }
                  if ($role-><M::DIS|DISResource.isSubsetOfURI>
                                (<Q::DOMCore:EntityReferenceRole>)) {
                    $r-><M::DIS|PLBlockCon.appendStatement>
                          ('$Message::DOM::ManakaiDOMEntityReference'.
                           '::CompatClass{q<' . $pack_name . '>} = 1');
                    ## TODO: Entity name or public ID dependent
                  }
                  if ($role-><M::DIS|DISResource.isSubsetOfURI>
                                (<Q::DOMCore:NotationRole>)) {
                    $r-><M::DIS|PLBlockCon.appendStatement>
                          ('$Message::DOM::ManakaiDOMNotation'.
                           '::CompatClass{q<' . $pack_name . '>} = 1');
                    ## TODO: Notation name or public ID dependent
                  }
                  if ($role-><M::DIS|DISResource.isSubsetOfURI>
                                (<Q::DOMCore:NamespaceRole>)) {
                    $r-><M::DIS|PLBlockCon.appendStatement>
                          ('$Message::DOM::ManakaiDOMNamespace'.
                           '::CompatClass{q<' . $pack_name . '>} = 1');
                  }
                  if ($role-><M::DIS|DISResource.isSubsetOfURI>
                                (<Q::DOMCore:ElementTypeDefinitionRole>)) {
                    $r-><M::DIS|PLBlockCon.appendStatement>
                          ('$Message::DOM::ManakaiDOMElementTypeDefinition'.
                           '::CompatClass{q<' . $pack_name . '>} = 1');
                  }
                  if ($role-><M::DIS|DISResource.isSubsetOfURI>
                                (<Q::DOMCore:AttributeDefinitionRole>)) {
                    $r-><M::DIS|PLBlockCon.appendStatement>
                          ('$Message::DOM::ManakaiDOMAttributeDefinition'.
                           '::CompatClass{q<' . $pack_name . '>} = 1');
                  }
                  ## NOTE: DOMCore:AnyNodeRole is subset of  
                  ##       DOMCore:ElementRole and DOMCore:TextRole and ...

                  if ($role-><M::DIS|DISResource.isSubsetOfURI>
                                (<Q::gls:ParserRole>)) {
                    $r-><M::DIS|PLBlockCon.appendStatement>
                          ('$Message::DOM::DOMLS::ParserClass{q<'.
                           $pack_name . '>} = 1');
                  }
                  if ($role-><M::DIS|DISResource.isSubsetOfURI>
                                (<Q::gls:SerializerRole>)) {
                    $r-><M::DIS|PLBlockCon.appendStatement>
                          ('$Message::DOM::DOMLS::SerializerClass{q<'.
                           $pack_name . '>} = 1');
                  }

                  if ($role-><M::DIS|DISResource.isSubsetOfURI>
                                (<Q::DIS:ModuleRole>)) {
                    $r-><M::DIS|PLBlockCon.appendStatement>
                          ('$Message::Util::DIS::ManakaiDISModuleDefinition'.
                           '::CompatClass{q<' . $pack_name . '>} = 1');
                  }
                  if ($role-><M::DIS|DISResource.isSubsetOfURI>
                                (<Q::DIS:ForRole>)) {
                    $r-><M::DIS|PLBlockCon.appendStatement>
                          ('$Message::Util::DIS::ManakaiDISForDefinition'.
                           '::CompatClass{q<' . $pack_name . '>} = 1');
                  }
                  if ($role-><M::DIS|DISResource.isSubsetOfURI>
                                (<Q::DIS:ResourceRole>)) {
                    $r-><M::DIS|PLBlockCon.appendStatement>
                          ('$Message::Util::DIS::ManakaiDISResourceDefinition'.
                           '::CompatClass{q<' . $pack_name . '>} = 1');
                  }
                  if ($role-><M::DIS|DISResource.isSubsetOfURI>
                                (<Q::DIS:ElementRole>)) {
                    $r-><M::DIS|PLBlockCon.appendStatement>
                          ('$Message::Util::DIS::ManakaiDISElement'.
                           '::CompatClass{q<' . $pack_name . '>} = 1');
                  }
                  if ($role-><M::DIS|DISResource.isSubsetOfURI>
                                (<Q::DIS:DatabaseRole>)) {
                    $r-><M::DIS|PLBlockCon.appendStatement>
                          ('$Message::Util::DIS::ManakaiDISDatabase'.
                           '::CompatClass{q<' . $pack_name . '>} = 1');
                  }
                  if ($role-><M::DIS|DISResource.isSubsetOfURI>
                                (<Q::dv|ValueRole>)) {
                    $r-><M::DIS|PLBlockCon.appendStatement>
                          ('$Message::Util::DIS::Value::ManakaiDVValue'.
                           '::CompatClass{q<' . $pack_name . '>} = 1');
                  }
                  if ($role-><M::DIS|DISResource.isSubsetOfURI>
                                (<Q::mn|NodeRefRole>)) {
                    my %nrp;
                    my $db = $self-><AG::DIS|DISAnyResource.database>;
                    for my $p (<Q::mn|subnode0>,
                               <Q::mn|subnode1>,
                               <Q::mn|subnode2>,
                               <Q::mn|origin0>,
                               <Q::mn|xrefnode0>) {
                      $nrp{
                        $db-><M::DIS|DISDatabase.getResource> ($p)
                           -><M::DIS|DISResourceProp.getPropertyText>
                                  (<Q::mn:stemName>, $p)
                      } = [keys %{{map {
                        $_-><M::DIS|DISResourceProp.getPropertyText>
                                  (<Q::DISPerl:propHashKey>,
                                   $_-><AG::DIS|DISAnyResource.uri>) => true,
                      } @{$cls-><M::DIS|DISResourceProp.getPropertyResourceList>
                                  ($p, isa_recursive => true)}}}];
                    }
                    for (keys %nrp) {
                      CORE::delete $nrp{$_} unless @{$nrp{$_}};
                    }
                    $r-><M::DIS|PLBlockCon.appendStatement>
                          ('$Message::Util::ManakaiNode::ManakaiNodeRef'.
                           '::Prop{q<' . $pack_name . '>} = '.
                           <ClassM::PLImplClass.perlLiteral> (\%nrp));
                  }
                }
          
          my $fragment = $factory-><M::Document.createDocumentFragment>;
          my @children = @{$r-><AG::Node.childNodes>};
          for (@children) {
            $fragment-><M::Node.appendChild> ($_);
          }
          $r = $fragment;
        }__;
##DISLang:Class

TMethods:
  @enDesc:
    <Q::Muf2003:RuleDefClass>

  @TMethod:
    @@Name: getPerlModuleMemberCode
    @@DIS:targetType: Muf2003|RuleDefClass
    @@Param:
      @@@Name: factory
      @@@Type: PCDocument
    @@Return:
      @@@Type: Node
      @@@PerlDef: \
##Muf2003:RuleDefClass

ResourceDef:
  @QName: PCDocument
  @AliasFor: pc|PCDocument||ManakaiDOM|ManakaiDOMLatest
  @For: DIS|ForEmpty

TMethods:
  @enDesc:
    <Q::DISLang|Interface>

  @TAttr:
    @@Name: plFullyQualifiedName
    @@DIS:targetType: DISLang|Interface
    @@enDesc:
        - <Q::ManakaiDOM:IF>::: Interface package name. 
    @@Get:
      @@@Type: DISString
      @@@PerlDef:
        __DEEP{
            $r = $self-><M::DIS|DISResourceProp.getPropertyText>
                              (<Q::DISPerl:packageName>);
            if (defined $r) {
              ## NOTE: "lang:Perl" is fully-qualified name by definition
            } else {
              unless (defined $self-><AG::DIS|DISAnyResource.localName>) {
                __UNDEEP{
                  __EXCEPTION{DIS|NO_LOCAL_NAME_ERR::
                    DIS:sourceNode => {$self->{src}},
                  }__;
                }__;
              }
                $r = $self-><AG::DIS|DISAnyResource.ownerModule>
                          -><AG::DISModulePerl.plInterfaceName>
                   . '::' . $self-><AG::DIS|DISAnyResource.localName>;
            }
        }__;

  @TAttr:
    @@Name: plCodeFragment
    @@DIS:targetType: DISLang|Interface
    @@Get:
      @@@Type: DIS|MPLCodeFragment
      @@@PerlDef:
        __DEEP{
          my $plimpl = $self-><AG::DISAnyResourcePerl.plImplementation>;
          $r = $plimpl-><M::DIS|MPLImpl.createPerlPackage>
                              ($self-><AG::DISResourcePerl
                                         .plFullyQualifiedName>);

          if ($self-><M::DIS|DISResource.isTypeURI> (<Q::dx:Interface>)) {
            ## - Inheritance
            $r-><M::DIS|PLPack.addISAPackage> ('Message::Util::Error');
            $r-><M::DIS|MPLCodeFragment.addRequirePerlModuleName>
                  ('Message::Util::Error');

            ## - Error definition reference
            $r-><M::DIS|PLInCon.appendCode>
                  ("sub ___error_def () {\n".
                   '  \%'.$self-><AG::DISResourcePerl.plFullyQualifiedName>.
                   "::ErrorDef\n".
                   "}\n");
          }

          ## - Interface members
          my @cr = @{$self-><M::DIS|DISResource.getChildResourceList>};
          for my $cr (@cr) {
            my $mcode = $cr-><M::DISResourcePerl.getPerlInterfaceMemberCode>
                              ($r-><AG::Node.ownerDocument>);
            if ($mcode) {
              $r-><AG::Node.ownerDocument>
                -><M::Document.adoptNode> ($mcode);
              $r-><M::Node.appendChild> ($mcode);
            }
          }
        }__;

  @TMethod:
    @@Name: getPerlModuleMemberCode
    @@DIS:targetType: DISLang|Interface
    @@Param:
      @@@Name: factory
      @@@Type: PCDocument
    @@Param:
      @@@Name: thismod_pack
      @@@Type: DIS|PLPack
    @@Param:
      @@@Name: const
      @@@Type: DISPerl|HASH||ManakaiDOM|all
    @@Return:
      @@@Type: Node
      @@@PerlDef:
        __DEEP{
          $r = $self-><AG::DISResourcePerl.plCodeFragment>;
          for my $cr (@{$self-><M::DIS|DISResource
                                 .getChildResourceListByType>
                                          (<Q::DISLang:ConstGroup>)}) {
                  my $tag = $cr-><AG::DISResourcePerl.plName>;
                  for my $gcr (@{$cr-><M::DIS|DISResource
                                                    .getChildResourceListByType>
                                          (<Q::DISLang:Const>)}) {
                    $thismod_pack-><M::DIS|PLPack.addExport>
                          ($tag, my $nm = $gcr-><AG::DISResourcePerl.plName>);
                    $const->{$nm} = $gcr-><AG::DISResourcePerl
                                                   .plFullyQualifiedName>;
                  }
                }
        }__;
##DISLang:Interface

TMethods:
  @TMethod:
    @@Name: getPerlDefinitionHashNamespace
    @@DIS:targetType: dx|Interface
    @@Return:
      @@@Type: DISString
      @@@PerlDef:
        __DEEP{
          $r = $self-><AG::DISResourcePerl.plFullyQualifiedName>;
        }__;
##dx:Interface

TMethods:
  @TMethod:
    @@Name: getPerlModuleMemberCode
    @@DIS:targetType: DISPerl|ScalarVariable
    @@DIS:targetType: DOMCore|DOMConfigurationParameter
    @@DIS:targetType: DOMCore|DOMConfigurationParameterApplication
    @@DIS:targetType: DOMCore|DOMErrorType
    @@Param:
      @@@Name: factory
      @@@Type: PCDocument
    @@Param:
      @@@Name: thismod_pack
      @@@Type: DIS|PLPack
    @@Return:
      @@@Type: Node
      @@@PerlDef:
        __DEEP{
          unless ($self-><AG::DIS|DISResource.parentResource>) {
            my $code = $self-><AG::DISResourcePerl.plCodeFragment>;
            $factory-><M::Document.adoptNode> ($code);
            $thismod_pack-><M::Node.appendChild> ($code);
          }
        }__;

TMethods:
  @enDesc:
    <Q::DISPerl|ScalarVariable>

  @TAttr:
    @@Name: plFullyQualifiedName
    @@DIS:targetType: DISPerl|ScalarVariable
    @@enDesc:
        - <Q::DISPerl:ScalarVariable>::: Variable name (without variable
                                type symbol such as <CODE::$>). 
    @@Get:
      @@@Type: DISString
      @@@PerlDef:
        __DEEP{
            $r = $self-><M::DIS|DISResourceProp.getPropertyText>
                              (<Q::DISPerl:packageName>);
            if (defined $r) {
              ## NOTE: "lang:Perl" is fully-qualified name by definition
            } else {
              unless (defined $self-><AG::DIS|DISAnyResource.localName>) {
                __UNDEEP{
                  __EXCEPTION{DIS|NO_LOCAL_NAME_ERR::
                    DIS:sourceNode => {$self->{src}},
                  }__;
                }__;
              }
                $r = $self-><AG::DIS|DISAnyResource.ownerModule>
                          -><AG::DISModulePerl.plFullyQualifiedName>
                   . '::' . $self-><AG::DIS|DISAnyResource.localName>;
            }
        }__;

  @TAttr:
    @@Name: plCodeFragment
    @@DIS:targetType: DISPerl|ScalarVariable
    @@Get:
      @@@Type: DIS|MPLCodeFragment
      @@@PerlDef:
        __DEEP{
            my $plimpl = $self-><AG::DISAnyResourcePerl.plImplementation>;
            my $varn = $self-><AG::DISResourcePerl.plVariableName>;
            my $var = $plimpl-><M::DIS|MPLImpl.createPerlVariable>
                                                       (null, null, $varn);
            my $data_type = $self-><AG::DIS|DISResource
                                       .disActualDataTypeResource>;
            my $value = $self-><M::DIS|DISResourceProp.getPropertyValue>
                              (<Q::dis:DefaultValue>);
            if ($value) {
              $value = $value-><M::DVValuePerl.plCodeFragment>
                              ($self,
                               data_type_uri => $data_type
                                    -><AG::DIS|DISAnyResource.uri>);
            } else {
              __CODE{setDefaultValue::
                $result => $value,
                $data_type => $data_type,
                $plimpl => $plimpl,
              }__;
            }
            $r = $plimpl-><M::DIS|MPLImpl.createPerlStatement>;
            $r-><M::DIS|PLAnyCon.appendNewAssignment> ($var => $value);
        }__;

  @TMethod:
    @@Name: getPerlClassMemberCode
    @@DIS:targetType: DISPerl|ScalarVariable
    @@Param:
      @@@Name: factory
      @@@Type: PCDocument
    @@Return:
      @@@Type: Node
      @@@PerlDef:
        __DEEP{
          $r = $factory-><M::Document.createDocumentFragment>;
          my $varn = $self-><AG::DISResourcePerl.plVariableName>;
          my $var = $factory-><M::PCDocument.createPCVariable>
                                (null, null, $varn);
          my $data_type = $self-><AG::DIS|DISResource.disActualDataTypeResource>;
          my $value = $self-><M::DIS|DISResourceProp.getPropertyValue>
                                    (<Q::dis:DefaultValue>);
          if ($value) {
            $value = $value-><M::DVValuePerl.plCodeFragment>
                                    ($self,
                                     data_type_uri => $data_type
                                          -><AG::DIS|DISAnyResource.uri>);
            $factory-><M::Document.adoptNode> ($value);
          } else {
            __CODE{setDefaultValueDoc::
              $result => $value,
              $data_type => $data_type,
              $doc => $factory,
            }__;
          }
          if ($self-><M::DIS|DISResourceProp.getPropertyBoolean>
                              (<Q::DISPerl:defaultValueHasSelfReference>)) {
            my $v = $var-><M::Node.cloneNode>;
            $v-><AS::PCVar.variableScope> ('our');
            $r-><M::Node.appendChild>
                  ($factory-><M::PCDocument.createPCStatement>)
              -><M::Node.appendChild> ($v);
          } else {
            $var-><AS::PCVar.variableScope> ('our');
          }
          for ($r-><M::Node.appendChild>
                     ($factory-><M::PCDocument.createPCStatement>)
                 -><M::DIS|PLAnyCon.appendNewPCExpression> ('=')) {
            $_-><M::Node.appendChild> ($var);
            $_-><M::Node.appendChild> ($value);
          }
        }__;
##DISPerl:ScalarVariable

TMethods:
  @enDesc:
    <Q::DISCore|AnyDefContainer>

  @TAttr:
    @@Name: plCodeFragment
    @@DIS:targetType: DISCore|AnyDefContainer
    @@Get:
      @@@Type: DIS|MPLCodeFragment
      @@@PerlDef:
        __DEEP{
            $self->{<Q::DIS|plCodeFragment>} = null;  ## To avoid loop
            my $def = $self-><M::DIS|DISResourceProp.getPropertyValue>
                                (<Q::dis:Def>);
            $def = $def->[0] if $def;
            my $is_inline = $self-><M::DIS|DISAnyResource.isTypeURI>
                                (<Q::DISPerl:InlineCode>) ? true : false;
            unless ($def) {
              $r = null;
            } elsif ($def-><AG::dv|DVValue.dataType> eq <Q::lang:Perl>) {
              my $source_code = $def-><AG::dv|DVValue.stringValue>;
              my $source_node = $def-><AG::dv|DVValue.sourceNodePath>;
              $r = $self->{<H::DIS|plCodeFragment>}
                 = $is_inline
                     ? $self-><M::DISResourcePerl.plPreprocessPerlStatement>
                                           ($source_code,
                                            contains_statements => false,
                                            source_file => $source_node,
                                            source_line => 1,
                                            namespace_context => $def)
                     : $self-><M::DISResourcePerl
                             .plPreprocessPerlCode>
                                   ($source_code,
                                    method_resource => 
                                ($self-><M::DIS|DISAnyResource
                                          .isTypeURI> (<Q::DISLang:MethodReturn>)
                                ? $self-><AG::DIS|DISResource.parentResource>
                                : null),
                                source_file => $source_node,
                                source_line => 1,
                                            namespace_context => $def);
            } elsif ($def-><AG::dv|DVValue.dataType> eq <Q::lang:dis>) {
              $r = $self->{<H::DIS|plCodeFragment>}
                 = $def-><AG::dv|DVValue.value>
                       -><M::DISElementPerl.plCodeFragment>
                            ($self,
                             for_arg => $self-><AG::DIS|DISAnyResource.forURI>,
                             forp_arg => $self-><AG::DIS|DISAnyResource.forpURI>,
                             contains_statements => (not $is_inline),
                      database_arg => $self-><AG::DIS|DISAnyResource.database>); 
            } else {
              __UNDEEP{
                __EXCEPTION{DIS|UNSUPPORTED_MEDIA_TYPE_ERR::
                  DIS:uri => {$def-><AG::dv|DVValue.dataType>},
                  DIS:sourceNode => {$def},
                }__;
              }__;
            } # media type
        }__;
##DISCore:AnyDefContainer

TMethods:
  @enDesc:
    <Q::ManakaiDOM|InCase>

  @TAttr:
    @@Name: plCodeFragment
    @@DIS:targetType: ManakaiDOM|InCase
    @@Get:
      @@@Type: DIS|MPLCodeFragment
      @@@PerlDef:
        __DEEP{
            my $data_type = $self-><AG::DIS|DISResource
                                       .disActualDataTypeResource>;
            $r = $self-><M::DIS|DISResourceProp.getPropertyValue>
                              (<Q::dis:Value>);
            if ($r) {
              $r = $r-><M::DVValuePerl.plCodeFragment>
                              ($self,
                               data_type_uri => $data_type
                                    -><AG::DIS|DISAnyResource.uri>);
            } else {
              my $plimpl = $self-><AG::DISAnyResourcePerl.plImplementation>;
              __CODE{setDefaultValue::
                $result => $r,
                $data_type => $data_type,
                $plimpl => $plimpl,
              }__;
            }
        }__;
##ManakaiDOM:InCase

TMethods:
  @TAttr:
    @@Name: plCodeFragment
    @@DIS:targetType: DOMCore|DOMConfigurationParameter
    @@DIS:targetType: DOMCore|DOMConfigurationParameterApplication
    @@Get:
      @@@Type: DIS|MPLCodeFragment
      @@@PerlDef:
        __DEEP{
            my $cparam = $self;
            if ($self-><M::DIS|DISAnyResource.isTypeURI>
                           (<Q::DOMCore:DOMConfigurationParameterApplication>)) {
              $cparam = $self-><M::DIS|DISResourceProp.getPropertyResource>
                           (<Q::DOMCore:domConfigurationParameter>);
              unless ($cparam) {
                __UNDEEP{__EXCEPTION{DIS|RESOURCE_NOT_DEFINED_ERR::
                  DIS:uri => {($cparam or $self)-><AG::DIS|DISAnyResource.uri>},
                  DIS:expectedType => {<Q::DOMCore:DOMConfigurationParameter>},
                }__}__;
              }
            }
            my $uri = $cparam-><AG::DIS|DISAnyResource.nameURI>;
            my $plimpl = $self-><AG::DISAnyResourcePerl.plImplementation>;
            my $db = $self-><AG::DIS|DISAnyResource.database>;
            my $cfgname = <ClassM::PLImplClass.perlLiteral>
                           (lc $cparam-><M::DIS|DISResourceProp.getPropertyText>
                             (<Q::DOMCore:domConfigurationParameterName>, $uri));
            my %prop;
            for ([getter => <Q::DOMCore:DOMConfigurationParameterGetter>],
                 [setter => <Q::DOMCore:DOMConfigurationParameterSetter>],
                 [get_default =>
                     <Q::DOMCore:DOMConfigurationParameterDefaultGetter>],
                 [unsetter => <Q::DOMCore:DOMConfigurationParameterUnsetter>],
                 [checker => <Q::DOMCore:DOMConfigurationParameterChecker>]) {
              my $cres = $cparam-><M::DIS|DISResource.getChildResourceByType>
                                  ($_->[1]);
              if ($cres) {
                $prop{$_->[0]}
                  = bless \($cres-><AG::dp|DISResourcePerl.plCodeFragment>
                                 ->stringify), 'manakai::code';
              }
            }
            my $type = $cparam-><AG::DIS|DISResource.disActualDataTypeResource>;
            if ($type-><M::DIS|DISResource.isSubsetOfURI> (<Q::idl:boolean>)) {
              $prop{type} = 'boolean';
              my @csrc = ($cparam);
              push @csrc, $self unless $cparam eq $self;
              for (@csrc) {
                C: for my $c (@{$self-><M::DIS|DISResource
                                          .getChildResourceListByType>
                                                 (<Q::ManakaiDOM:InCase>)}) {
                  my $v = $c-><M::DIS|DISResourceProp.getPropertyValue>
                                                 (<Q::dis:Value>);
                  next C unless $v;
                  my $support = $c-><M::DIS|DISResourceProp.getPropertyBoolean>
                                                 (<Q::DOMCore:isSupported>);
                  my $tf = $v-><AG::dv|DVValue.value> ? true : false;
                  $prop{vsupport}->[$tf] = true if $support;
                  if ($tf) {
                    if ($c-><M::DIS|DISResourceProp.getPropertyBoolean>
                                                 (<Q::dis:IsDefault>)) {
                      $prop{default} = true;
                    }
                  }
                  SP: for (@{$c-><M::DIS|DISResourceProp.getPropertyValueList>
                                   (<Q::dis:SetParam>)}) {
                    next unless $_->isa (<IFName::dv|DVURIValue>);
                    my $suri = $_-><AG::dv|DVURIValue.uri>;
                    my $sres = $db-><M::DIS|DISDatabase.getResource> ($suri);
                    my $v = $_-><M::dv|DVValue.getProperty> (<Q::dis:Value>);
                    next SP unless $v;
                    $prop{setparam}->[$tf]->{
                      $sres-><M::DIS|DISResourceProp.getPropertyText>
                                 (<Q::DISPerl:propHashKey>, $suri)
                    } = $v-><AG::dv|DVValue.value>;
                  } # SP
                }
              }
            } elsif ($type-><M::DIS|DISResource.isSubsetOfURI>
                                               (<Q::DISLang:String>)) {
              $prop{type} = 'string';
            } else {
              $prop{type} = 'object';
              $prop{otype} =$type-><AG::dp|DISResourcePerl.plFullyQualifiedName>;
            }
            my @target = sort { $a cmp $b } map {
                           $_-><AG::dp|DISResourcePerl.plFullyQualifiedName>
                         } @{
                          # $self, not $cparam
                          $self-><M::DIS|DISResourceProp.getPropertyResourceList>
                              (<Q::DOMCore:targetType>)
                         };
            my $target0 = <ClassM::PLImplClass.perlLiteral> ($target[0]);
            $r = $plimpl-><M::DIS|MPLImpl.createPerlStatement>
                   ('$Message::DOM::DOMCore::ManakaiDOMConfiguration{'.
                    $target0 . '}->{' . $cfgname . '} = ' . 
                    <ClassM::PLImplClass.perlLiteral> ({
                      iname => $db-><M::DIS|DISDatabase.getResource> ($uri)
                                  -><M::DIS|DISResourceProp.getPropertyText>
                                        (<Q::DISPerl:propHashKey>, $uri),
                      %prop,
                    }));
            if (@target > 1) {
              my $c = $plimpl-><M::DIS|MPLImpl.createPerlBlockContainer>;
              $c-><M::DIS|PLBlockCon.appendCodeFragment> ($r);
              for my $target (@target[1..$#target]) {
                $c-><M::DIS|PLBlockCon.appendCodeFragment>
                  ($plimpl-><M::DIS|MPLImpl.createPerlStatement>
                   ('$Message::DOM::DOMCore::ManakaiDOMConfiguration{'.
                    <ClassM::PLImplClass.perlLiteral> ($target) .
                    '}->{'. $cfgname .
                    '} = $Message::DOM::DOMCore::ManakaiDOMConfiguration{' .
                    $target0 . '}->{' . $cfgname . '}'));
              }
              $r = $c;
            }
        }__;
##domconfig param

TMethods:
  @TAttr:
    @@Name: plCodeFragment
    @@DIS:targetType: DOMCore|DOMErrorType
    @@Get:
      @@@Type: DIS|MPLCodeFragment
      @@@PerlDef:
        __DEEP{
            my $plimpl = $self-><AG::DISAnyResourcePerl.plImplementation>;
            my $db = $self-><AG::DIS|DISAnyResource.database>;
            my $sev = $self-><M::DIS|DISResourceProp.getPropertyResource>
                                (<Q::DOMCore:severity>);
            if (not $sev or not $sev-><M::DIS|DISAnyResource.isTypeURI>
                                         (<Q::DISLang:Const>)) {
              __UNDEEP{__EXCEPTION{DIS|RESOURCE_NOT_DEFINED_ERR::
                DIS:uri => {($sev or $self)-><AG::DIS|DISAnyResource.uri>},
                DIS:expectedType => {<Q::DISLang:Const>},
              }__}__;
            }
            my $tf = $self-><M::DIS|DISResourceProp.getPropertyResource>
                                (<Q::ecore:textFormatter>);
            unless ($tf) {
              $tf = $db-><M::DIS|DISDatabase.getResource>
                           (<Q::ecore|MUErrorFormatter>,
                            for_arg => <Q::ManakaiDOM|Perl>);
            }
            $r = $plimpl-><M::DIS|MPLImpl.createPerlStatement>
                   ('$Message::DOM::DOMCore::ManakaiDOMError::Def{'.
                    <ClassM::PLImplClass.perlLiteral>
                      ($self-><AG::DIS|DISAnyResource.nameURI>).
                    '} = '.
                    <ClassM::PLImplClass.perlLiteral> ({
                      <H::DOMCore:errorType> => $self-><M::DIS|DISResourceProp
                        .getPropertyText>
                          (<Q::DOMCore:errorType>,
                           $self-><AG::DIS|DISAnyResource.nameURI>),
                      description => $self-><M::ManakaiDISResourcePerl
                                                  .plMufDescriptionText>,
                      <H::DOMCore:severity> => 0 + $sev-><AG::DISResourcePerl
                                                        .plCodeFragment>,
                      <H::ecore:textFormatter> => $tf-><AG::dp|DISResourcePerl
                                                      .plFullyQualifiedName>,
                    }));
        }__;
##DOMCore:DOMErrorType

TMethods:
  @enDesc:
    <Q::cs|CharsetSet>

  @TMethod:
    @@Name: getPerlModuleMemberCode
    @@DIS:targetType: cs|CharsetSet
    @@Param:
      @@@Name: factory
      @@@Type: PCDocument
    @@Param:
      @@@Name: thismod_pack
      @@@Type: DIS|PLPack
    @@Return:
      @@@Type: Node
      @@@PerlDef:
        __DEEP{
          my %done;
          for my $v (@{$self-><M::DIS|DISResourceProp.getPropertyValueList>
                                (<Q::cs|moduleRef>)}) {
            my $mod = $v-><M::dv|DVURIValue.getResource>
                            ($self-><AG::anyres.database>);
            R: for my $res (@{$mod-><M::DIS|DISModule.getResourceList>}) {
              next R unless $res-><M::anyres.isTypeURI> (<Q::cs|Charset>);
              next R if $done{$res-><AG::anyres.uri>};
              $done{$res-><AG::anyres.uri>} = true;
              $res-><M::DISResourcePerl.getPerlModuleMemberCode>
                      ($factory, $thismod_pack);
            }
          }
        }__;
##cs|CharsetSet

TMethods:
  @enDesc:
    <Q::cs|Charset>

  @TMethod:
    @@Name: getPerlDefinitionHashNamespace
    @@DIS:targetType: cs|Charset
    @@Return:
      @@@Type: DISString
      @@@PerlDef:
        $r = q<Message::Charset::Encode>;

  @TMethod:
    @@Name: getPerlModuleMemberCode
    @@DIS:targetType: cs|Charset
    @@Param:
      @@@Name: factory
      @@@Type: PCDocument
    @@Param:
      @@@Name: thismod_pack
      @@@Type: DIS|PLPack
    @@Return:
      @@@Type: Node
      @@@PerlDef:
        __DEEP{
          my $uris = [grep {$_ !~ /^tag:suika\.fam\.cx,2005-09/} @{
                        $self-><AG::anyres.uris>
                     }];
          my $ns = $self-><M::DISResourcePerl.getPerlDefinitionHashNamespace>;

          $r = $factory-><M::PCDocument.createPCStatement>;
          $r-><M::DIS|PLAnyCon.appendNewPCVariable> ('$', $ns, 'CharsetDef');
          $r-><M::DIS|PLBlockCon.appendCode> ('->{');
          $r-><M::DIS|PLAnyCon.appendStringLiteral> ($uris->[0]);
          $r-><M::DIS|PLBlockCon.appendCode> ('} = ');
          for my $uri (@$uris[1..$#$uris]) {
            $r-><M::DIS|PLAnyCon.appendNewPCVariable> ('$', $ns, 'CharsetDef');
            $r-><M::DIS|PLBlockCon.appendCode> ('->{');
            $r-><M::DIS|PLAnyCon.appendStringLiteral> ($uri);
            $r-><M::DIS|PLBlockCon.appendCode> ('} = ');
          }

          my $prop = {
            uri => {map {$_ => true} @$uris},
            <H::cs|ietfName> =>
                $self-><M::DIS|DISResourceProp.getPropertyTextList>
                         (<Q::cs|ietfName>),
            <H::cs|preferredMIMEName> =>
                $self-><M::DIS|DISResourceProp.getPropertyText>
                         (<Q::cs|preferredMIMEName>),
            <H::cs|xmlName> =>
                $self-><M::DIS|DISResourceProp.getPropertyTextList>
                         (<Q::cs|xmlName>),
            <H::cs|perlName> =>
                $self-><M::DIS|DISResourceProp.getPropertyTextList>
                         (<Q::cs|perlName>),
            <H::cs|isBlockSafe> => $self-><M::anyres.isTypeURI>
                                            (<Q::cs|BlockSafe>),
            <H::cs|BOM.Required> => $self-><M::anyres.isTypeURI>
                                            (<Q::cs|BOM.Required>),
            <H::cs|BOM.Allowed> => $self-><M::anyres.isTypeURI>
                                            (<Q::cs|BOM.Allowed>),
            <H::cs|ASCII8> => $self-><M::anyres.isTypeURI>
                                            (<Q::cs|ASCII8>),
            <H::cs|ASCII16> => $self-><M::anyres.isTypeURI>
                                            (<Q::cs|ASCII16>),
            <H::cs|ASCII16BE> => $self-><M::anyres.isTypeURI>
                                            (<Q::cs|ASCII16BE>),
            <H::cs|ASCII16LE> => $self-><M::anyres.isTypeURI>
                                            (<Q::cs|ASCII16LE>),
            <H::cs|ASCII32> => $self-><M::anyres.isTypeURI>
                                            (<Q::cs|ASCII32>),
            <H::cs|ASCII32Endian1234> => $self-><M::anyres.isTypeURI>
                                            (<Q::cs|ASCII32Endian1234>),
            <H::cs|ASCII32Endian2143> => $self-><M::anyres.isTypeURI>
                                            (<Q::cs|ASCII32Endian3243>),
            <H::cs|ASCII32Endian3412> => $self-><M::anyres.isTypeURI>
                                            (<Q::cs|ASCII32Endian3412>),
            <H::cs|ASCII32Endian4321> => $self-><M::anyres.isTypeURI>
                                            (<Q::cs|ASCII32Endian4321>),
            <H::cs|UTF8EncodingScheme> => $self-><M::anyres.isTypeURI>
                                            (<Q::cs|UTF8EncodingScheme>),
            <H::cs|noBOMVariant> =>
                $self-><M::DIS|DISResourceProp.getPropertyText>
                         (<Q::cs|noBOMVariant>),
            <H::cs|noBOMVariant16BE> =>
                $self-><M::DIS|DISResourceProp.getPropertyText>
                         (<Q::cs|noBOMVariant16BE>),
            <H::cs|noBOMVariant16LE> =>
                $self-><M::DIS|DISResourceProp.getPropertyText>
                         (<Q::cs|noBOMVariant16LE>),
            <H::cs|noBOMVariant32Endian1234> =>
                $self-><M::DIS|DISResourceProp.getPropertyText>
                         (<Q::cs|noBOMVariant32Endian1234>),
            <H::cs|noBOMVariant32Endian2143> =>
                $self-><M::DIS|DISResourceProp.getPropertyText>
                         (<Q::cs|noBOMVariant32Endian3243>),
            <H::cs|noBOMVariant32Endian3412> =>
                $self-><M::DIS|DISResourceProp.getPropertyText>
                         (<Q::cs|noBOMVariant32Endian3412>),
            <H::cs|noBOMVariant32Endian4321> =>
                $self-><M::DIS|DISResourceProp.getPropertyText>
                         (<Q::cs|noBOMVariant32Endian4321>),
          };

          unless (defined $prop->{<H::cs|preferredMIMEName>}) {
            $prop->{<H::cs|preferredMIMEName>}
              = $self-><M::DIS|DISResourceProp.getPropertyText>
                         (<Q::cs|ianaCanonicalName>,
                          $prop->{<H::cs|ietfName>}->[0]);
          }

          for (keys %$prop) {
            delete $prop->{$_} unless $prop->{$_};
            delete $prop->{$_}
              if ref $prop->{$_} eq 'ARRAY' and not @{$prop->{$_}};
            delete $prop->{$_}
              if ref $prop->{$_} eq 'HASH' and not %{$prop->{$_}};
          }

          if (1 < keys %$prop) { # |uri| + ...
            $r-><M::DIS|PLAnyCon.appendNewPCLiteral> ($prop);
            $thismod_pack-><M::Node.appendChild> ($r);
          }
          $r = null;
        }__;
##cs|Charset
