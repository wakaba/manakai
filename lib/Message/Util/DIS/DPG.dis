Module:
  @QName: DIS|DPG
  @FullName:
    @@lang: en
    @@@:
      <QUOTE::dis> DPG Module
  @Namespace:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS#DPG/
  
  @enDesc:
    The <Module::DIS|DPG>, <QUOTE::dis> parser generator, is a compiler
    generator implementation for the <QUOTE::dis> system.

  @DISCore:author: DISCore|Wakaba
  @License: license|Perl+MPL

  @Date:
    $Date: 2005/12/20 12:16:51 $
  
  @Require:
    @@Module:
      @@@QName: DIS|common
    @@Module:
      @@@QName: Util|PerlCode
      @@@WithFor: ManakaiDOM|ManakaiDOMLatest

  @DefaultFor: ManakaiDOM|ManakaiDOMLatest

Namespace:
  @DIS:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS#
  @dis:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#dis--
  @DISlib:
    http://suika.fam.cx/~wakaba/archive/2004/dis/
  @dp:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS#Perl/
  @f:
    http://suika.fam.cx/~wakaba/archive/2004/dom/feature#
  @html5:
    http://www.w3.org/1999/xhtml
  @idl:
    http://suika.fam.cx/~wakaba/archive/2004/dis/IDL#
  @kwd:
    http://suika.fam.cx/~wakaba/archive/2005/rfc2119/
  @lang:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#
  @license:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/license#
  @ManakaiDOM:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#
  @MDOM:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#ManakaiDOM.
  @MDOMX:
    http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#
  @mn:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/ManakaiNode#
  @pc:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/PerlCode#
  @pg:
    http://suika.fam.cx/~wakaba/archive/2005/11/pg/
  @rdf:
    http://www.w3.org/1999/02/22-rdf-syntax-ns#
  @rdfs:
    http://www.w3.org/2000/01/rdf-schema#
  @s:
    http://suika.fam.cx/~wakaba/archive/2004/dis/Markup#
  @Util:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/

## -- Features

ElementTypeBinding:
  @Name: FeatureDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: f|Feature
    @@For: =ManakaiDOM|all

ElementTypeBinding:
  @Name: FeatureVerDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: f|Feature

ElementTypeBinding:
  @Name: featureQName
  @ElementType:
    f:name
  @ShadowContent:
    @@ContentType: DISCore|QName

FeatureDef:
  @QName: DIS|DPG
  @FeatureVerDef:
    @@QName: DIS|DPG10
    @@Version: 1.0
    @@f:instanceOf: DIS|DPG
    @@f:requires: DOMXML|XMLFeature30
    @@f:requires: pc|CoreFeature10
    @@FullName:
      @@@lang:en
      @@@@:
        DPG version 1.0

ElementTypeBinding:
  @Name: enDesc
  @ElementType: 
    dis:Description
  @ShadowContent: 
    @@lang:en

ElementTypeBinding:
  @Name: IFClsETDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      @@@@: dis|MultipleResource
      @@@ForCheck: !ManakaiDOM|ForIF !ManakaiDOM|ForClass !s|ForML
    @@resourceFor: ManakaiDOM|ForIF
    @@resourceFor: ManakaiDOM|ForClass
    @@resourceFor: s|ForML

    @@rdf:type:
      @@@@: DISLang|Interface
      @@@ForCheck: ManakaiDOM|ForIF
    @@s:elementType:
      @@@@: ||+||s|ForML
      @@@ForCheck: ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames

    @@rdf:type:
      @@@@: DISLang|Class
      @@@ForCheck: ManakaiDOM|ForClass
    @@Implement:
      @@@@: ||+||ManakaiDOM|ForIF
      @@@ForCheck: ManakaiDOM|ForClass
      @@@ContentType: DISCore|TFPQNames
    @@s:elementType:
      @@@@: ||+||s|ForML
      @@@ForCheck: ManakaiDOM|ForClass
      @@@ContentType: DISCore|TFPQNames
      @@@DISCore:stopISARecursive:1

    @@rdf:type:
      @@@@: s|ElementType
      @@@ForCheck: s|ForML

    @@f:implements: DIS|DPG10

ElementTypeBinding:
  @Name: IFClsDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      @@@@: dis|MultipleResource
      @@@ForCheck: !ManakaiDOM|ForIF !ManakaiDOM|ForClass
    @@resourceFor: ManakaiDOM|ForIF
    @@resourceFor: ManakaiDOM|ForClass

    @@rdf:type:
      @@@@: DISLang|Interface
      @@@ForCheck: ManakaiDOM|ForIF

    @@rdf:type:
      @@@@: DISLang|Class
      @@@ForCheck: ManakaiDOM|ForClass
    @@Implement:
      @@@@: ||+||ManakaiDOM|ForIF
      @@@ForCheck: ManakaiDOM|ForClass
      @@@ContentType: DISCore|TFPQNames

    @@f:implements: DIS|DPG10

    @@ForCheck: ManakaiDOM|ManakaiDOM

ElementTypeBinding:
  @Name: IFDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      @@@@: dis|MultipleResource
      @@@ForCheck: !ManakaiDOM|ForIF !ManakaiDOM|ForClass
    @@resourceFor: ManakaiDOM|ForIF

    @@rdf:type:
      @@@@: DISLang|Interface
      @@@ForCheck: ManakaiDOM|ForIF

    @@ForCheck: ManakaiDOM|ManakaiDOM

ElementTypeBinding:
  @Name: IFQName
  @ElementType:
    dis:QName
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForIF

ElementTypeBinding:
  @Name: ClsQName
  @ElementType:
    dis:QName
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: ETQName
  @ElementType:
    dis:AppName
  @ShadowContent:
    @@ForCheck:
      s:ForML
    @@ContentType: DISCore|QName

ElementTypeBinding:
  @Name: ATTRQName
  @ElementType:
    dis:AppName
  @ShadowContent:
    @@ForCheck:
      s:ForML
    @@ContentType: DISCore|QName

ElementTypeBinding:
  @Name: IFISA
  @ElementType:
    dis:ISA
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForIF

ElementTypeBinding:
  @Name: ClsISA
  @ElementType:
    dis:ISA
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: Method
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Method
    @@For: !=ManakaiDOM|ManakaiDOM

ElementTypeBinding:
  @Name: Return
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|MethodReturn

ElementTypeBinding:
  @Name: Param
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|MethodParameter

ElementTypeBinding:
  @Name: plMName
  @ElementType:
    DISPerl:methodName

ElementTypeBinding:
  @Name: PerlDef
  @ElementType:
    dis:Def
  @ShadowContent:
    @@ContentType: lang|Perl

ElementTypeBinding:
  @Name: disDef
  @ElementType:
    dis:Def
  @ShadowContent:
    @@ContentType: lang|dis

ElementTypeBinding:
  @Name: PropDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: rdf|Property

## -- The DPG Document Object Model

IFClsDef:
  @IFQName: DPGDocument
  @ClsQName: ManakaiDPGDocument

  @IFISA: Document
  @ClsISA: DOMCore|ManakaiDOMDocument

  @enDesc:
    The <IF::DPGDocument> interface <kwd:MUST> be implemented by
    <IF::Document> objects if the implementation supports the DPG object model.

  @f:provides:
    @@@: DIS|DPG10
    @@f:through: DOMCore|ManakaiDOMImplementation

  @s:rootElementType: RulesElementType
##DPGDocument

ResourceDef:
  @For: ManakaiDOM|DOM
  @QName: Node
  @AliasFor: DOMCore|Node

ResourceDef:
  @For: ManakaiDOM|DOM
  @QName: Document
  @AliasFor: DOMCore|Document

ResourceDef:
  @For: ManakaiDOM|DOM
  @QName: Element
  @AliasFor: DOMCore|Element

IFClsDef:
  @IFQName: DPGElement
  @ClsQName: ManakaiDPGElement

  @IFISA: Element
  @ClsISA: DOMCore|ManakaiDOMElement

  @enDesc:
    The <IF::DPGElement> interface <kwd:MUST> be implemented by
    <IF::Element> objects whose namespace URI is <URI^^DISCore:QName::pg:>
    if the implementation supports the DPG object model.

##DPGElement

IFClsDef:
  @IFQName: DPGElementAttribute
  @ClsQName: ManakaiDPGElementAttribute

  @enDesc:
    The <IF::DPGElementAttribute> interface is implemented by
    objects whose element type allowes DPG attributes being specified.

  @Method:
    @@Name: dpgGetAttribute
    @@enDesc:
      Returns a DPG attribute value.
    @@Param:
      @@@Name: attrName
      @@@Type: DOMString
      @@@enDesc:
        The name of the attribute.
    @@Return:
      @@@Type: DOMString
      @@@enDesc:
        The attribute value.

          {NOTE:: If the DPG attribute element is invalid so that 
                  its <XA::value> attribute is not specified, then
                  what is the return value is undefined.
          }
      @@@nullCase:
        @@@@enDesc:
          The attribute is not specified.
      @@@PerlDef:
        __DEEP{
          $r = null;
          no warnings "uninitialized";
          C: for my $child (@{$self-><AG::Node.childNodes>}) {
            if ($child-><AG::Node.namespaceURI>.$child-><AG::Node.localName> eq
                <Q::pg:attributeSpecification>) {
              if ($child-><M::Element.getAttributeNS> (null, 'name') eq
                  $attrName) {
                $r = $child-><M::Element.getAttributeNS> (null, 'value');
                last C;
              }
            }
          }
        }__;
##DPGElementAttribute

ElementTypeBinding:
  @Name: nullCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: ManakaiDOM|InCase
    @@Value:
      @@@is-null:1

ResourceDef:
  @For: ManakaiDOM|DOM
  @QName: DOMString
  @AliasFor: DOMMain|DOMString

IFClsETDef:
  @IFQName: DPGRulesElement
  @ClsQName: ManakaiDPGRulesElement
  @ETQName: pg|rules
  @QName:
    @@@: RulesElementType
    @@ForCheck: s|ForML

  @IFISA: DPGElement
  @ClsISA: ManakaiDPGElement

  @enDesc:
    The <XE::pg|rules> element type is used for the root element
    of the DPG rule fragment.  It <kwd:MAY> contain zero or more
    <XE::pg|rule> and / or <XE::pg|lexmode> child elements.

  @Method:
    @@Name: plCodeFragment
    @@enDesc:
      Generates a Perl code fragment from the subtree rooted by
      the node.
    @@Param:
      @@@Name: codeDocument
      @@@Type: pc|PCDocument
      @@@enDesc:
        A <IF::pc|PCDocument>.  The generated Perl code nodes will
        belong to the document.
    @@NamedParam:
      @@@Name: disResource
      @@@Type: dp|DISResourcePerl||DIS|ForLatest
      @@@enDesc:
        The <QUOTE::dis> resource object against which <Q::lang:Perl>
        code fragments, if any, are evaluated and converted into Perl code.
    @@NamedParam:
      @@@Name: contextObject
      @@@Type: DIS|NSResolverDIS||DIS|ForLatest
      @@@enDesc:
        The context where various references, such as namespace prefixes
        and relative URI references, are evaluated.  It <kwd:MUST> implement
        the <IF::DIS|NSResolverDIS> interface if there are <Q::lang:Perl>
        code fragments.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        A set of elements generated from the rules.

          {NOTE:: If the subtree contains one or more <XE::pg|embedStatement>
                  element nodes whose content is invalid, then their
                  evaluation processes might throw an exception.
          }
      @@@PerlDef:
        __DEEP{
          no warnings 'uninitialized';

          $r = $codeDocument-><M::Document.createDocumentFragment>;

          ## --- Range operations
          
            my $or_range = sub ($$) {
    my ($r1, $r2) = @_;
    my @r1 = @$r1;
    my @r2 = @$r2;
    my ($c1, $c2);
    my $r = [];
    while (@r1 or @r2 or $c1 or $c2) {
      $c1 ||= shift @r1;
      $c2 ||= shift @r2;
      if (not $c1) {
        push @$r, $c2, @r2;
        undef $c2;
 \      @r2 = ();
      } elsif (not $c2) {
        push @$r, $c1, @r1;
        undef $c1;
 \      @r1 = ();
      } else {
        ($c1, $c2) = ($c2, $c1) if $c1->[0] > $c2->[0];
        if ($c1->[1] <= $c2->[0]) {
          push @$r, $c1;
          undef $c1;
        } else {
          $c2 = [$c1->[0], $c2->[1]];
          undef $c1;
        }
      }
    }
    return $r;
  };
  
  my $add_range = sub ($$;$) {
    my ($range, $s, $e) = @_;
    return $or_range->($range, [[$s, defined $e ? $e : $s]]);
  };
  
  my $negate_range = sub ($) {
    my $range = shift;
    my $r = [];
    push @$r, [0, $range->[0]->[0] - 1] if $range->[0]->[0] > 0;
    for my $i (1..$#$range) {
      push @$r, [$range->[$i - 1]->[1] + 1, $range->[$i]->[0] - 1];
    }
    push @$r, [$range->[$#$range]->[1] + 1, "Inf"] unless $range->[$#$range]->[1] eq "Inf";
    return $r;
  };
  
  my $and_minus_ranges = sub ($$) {
    my (@ra, @rab, @rb);
    my @rangea = @{$_[0]};
    my @rangeb = @{$_[1]};
    my $rangea;
    my $rangeb;
    while (@rangea or @rangeb or $rangea or $rangeb) {
      $rangea ||= shift @rangea;
      $rangeb ||= shift @rangeb;
      if (not $rangea) {
        push @rb, $rangeb, @rangeb;
        last;
      } elsif (not $rangeb) {
        push @ra, $rangea, @rangea;
        last;
      } else {
        if ($rangea->[0] < $rangeb->[0]) {
          if ($rangea->[1] ne 'Inf' and
              $rangea->[1] < $rangeb->[0]) { ## [a .. a] .. [b ..
            push @ra, $rangea;
            $rangea = undef;
          } elsif ($rangea->[1] eq 'Inf') {
            if ($rangeb->[1] eq 'Inf') {  ## [a .. [b ..
              push @ra, [$rangea->[0], $rangeb->[0] - 1];
              push @rab, $rangeb;
              last;
            } else {                      ## [a .. [b .. b] ..
              push @ra, [$rangea->[0], $rangeb->[0] - 1];
              push @rab, $rangeb;
              $rangea = [$rangeb->[1] + 1, 'Inf'];
              $rangeb = undef;
            }
          } else {                      
            if ($rangeb->[1] eq 'Inf') {  ## [a .. [b .. a] ..
              push @ra, [$rangea->[0], $rangeb->[0] - 1];
              push @rab, [$rangeb->[0], $rangea->[1]];
              $rangeb = [$rangea->[1] + 1, 'Inf'];
              $rangea = undef;
            } else {
              if ($rangea->[1] < $rangeb->[1]) { ## [a .. [b .. a] .. b]
                push @ra, [$rangea->[0], $rangeb->[0] - 1];
                push @rab, [$rangeb->[0], $rangea->[1]];
                $rangeb = [$rangea->[1] + 1, $rangeb->[1]];
                $rangea = undef;
              } elsif ($rangea->[1] > $rangeb->[1]) { ## [a .. [b .. b] .. a]
                push @ra, [$rangea->[0], $rangeb->[0] - 1];
                push @rab, $rangeb;
                $rangea = [$rangeb->[1] + 1, $rangea->[1]];
                $rangeb = undef;
              } else {                            ## [a .. [b .. ab]]
                push @ra, [$rangea->[0], $rangeb->[0] - 1];
                push @rab, $rangeb;
                $rangea = $rangeb = undef;
              }
            }
          }
        } elsif ($rangea->[0] > $rangeb->[0]) {
          if ($rangeb->[1] ne 'Inf' and
              $rangeb->[1] < $rangea->[0]) { ## [b .. b] .. [a ..
            push @rb, $rangeb;
            $rangeb = undef;
          } elsif ($rangea->[1] eq 'Inf') {
            if ($rangeb->[1] eq 'Inf') {  ## [b .. [a ..
              push @rb, [$rangeb->[0], $rangea->[0] - 1];
              push @rab, $rangea;
              last;
            } else {                      ## [b .. [a .. b] ..
              push @rb, [$rangeb->[0], $rangea->[0] - 1];
              push @rab, [$rangea->[0], $rangeb->[1]];
              $rangea = [$rangeb->[1] + 1, 'Inf'];
              $rangeb = undef;
            }
          } else {                      
            if ($rangeb->[1] eq 'Inf') {  ## [b .. [a .. a] ..
              push @rb, [$rangeb->[0], $rangea->[0] - 1, -7];
              push @rab, $rangea;
              $rangeb = [$rangea->[1] + 1, 'Inf'];
              $rangea = undef;
            } else {
              if ($rangea->[1] < $rangeb->[1]) { ## [b .. [a .. a] .. b]
                push @rb, [$rangeb->[0], $rangea->[0] - 1,-3];
                push @rab, $rangea;
                $rangeb = [$rangea->[1] + 1, $rangeb->[1]];
                $rangea = undef;
              } elsif ($rangea->[1] > $rangeb->[1]) { ## [b .. [a .. b] .. a]
                push @rb, [$rangeb->[0], $rangea->[0] - 1,-4];
                push @rab, [$rangea->[0], $rangeb->[1],-5];
                $rangea = [$rangeb->[1] + 1, $rangea->[1]];
                $rangeb = undef;
              } else {                            ## [b .. [a .. ab]]
                push @rb, [$rangeb->[0], $rangea->[0] - 1,-6];
                push @rab, $rangea;
                $rangea = $rangeb = undef;
              }
            }
          }
        } else {
          if ($rangea->[1] eq 'Inf') {  
            if ($rangeb->[1] eq 'Inf') {          ## [[ab ..
              push @rab, $rangea;
              last;
            } else {                              ## [[ab .. b] ..
              push @rab, $rangeb;
              $rangea = [$rangeb->[1] + 1, 'Inf'];
              $rangeb = undef;
            }
          } else {
            if ($rangeb->[1] eq 'Inf') {          ## [[ab .. a] ..
              push @rab, $rangea;
              $rangeb = [$rangea->[1] + 1, 'Inf'];
              $rangea = undef;
            } else {
              if ($rangea->[1] < $rangeb->[1]) {  ## [[ab .. a] .. b]
                push @rab, $rangea;
                $rangeb = [$rangea->[1] + 1, $rangeb->[1]];
                $rangea = undef;
              } elsif ($rangea->[1] > $rangeb->[1]) { ## [[ab .. b] .. a]
                push @rab, $rangeb;
                $rangea = [$rangeb->[1] + 1, $rangea->[1]];
                $rangeb = undef;
              } else {                            ## [[ab .. ab]]
                push @rab, $rangea;
                $rangea = $rangeb = undef;
              }
            }
          }
        }
      }
    }
    return (\@ra, \@rab, \@rb);
  };

    
          ## --- Tokenizer preparation
            ## TODO: Multiple tokenizer support required

          my $tokenizer = $codeDocument->create_perl_sub ('_shift_token');
          $r-><M::Node.appendChild> ($tokenizer);
          $tokenizer->prototype ('$');
  my $tokenizer_param = $tokenizer->append_statement
                                  ->append_new_pc_expression ('=');
  $tokenizer_param->append_new_pc_variable ('$', undef, 'self')
                  ->variable_scope ('my');
  $tokenizer_param->append_new_pc_function_call (undef, 'shift');
  my $if_stack = $tokenizer->append_new_pc_choose
                           ->append_new_pc_when;
  my $stack_array = $if_stack->condition->append_new_pc_dereference ('@');
  for ($stack_array->append_new_pc_expression ('->')) {
    $_->append_new_pc_variable ('$', undef, 'self');
    $_->append_bare ('{token}');
  }
  $if_stack->block
           ->append_statement
           ->append_new_pc_function_call (undef, 'return')
           ->append_new_pc_function_call (undef, 'shift')
           ->append_child ($stack_array->clone_node (1));

          ## --- For each child elements (rule or lexmode)...

          my %rules;       # defined parser rules
          my %root_rules;  # defined |standalone| parser rules

          B: for my $cel (@{$self-><AG::Node.childNodes>}) {
            my $xuri = $cel->namespace_uri . $cel->local_name;

            ## -- Rule element - adds reference to hash
            if ($xuri eq <Q::pg:rule>) {
              my $name = $cel->get_attribute_ns (undef, 'name');
              $rules{$name} = {source => $cel, param => []};
              $root_rules{$name} = 1
                if $cel-><M::DPGElementAttribute.dpgGetAttribute> ('standalone');
      
              ## Creates a list of parameters
              C: for my $paramspec (@{$cel->child_nodes}) {
                next C unless $paramspec->namespace_uri eq <Q::pg:>;
                next C unless $paramspec->local_name eq 'parameterDeclaration';
                push @{$rules{$name}->{param}},
                     $paramspec->get_attribute_ns (undef, 'name');
              }

            ## -- Lexmode element - generate tokenizer
            } elsif ($xuri eq <Q::pg:lexmode>) {
              ## TODO: Multiple lexmode support
    
      my %token = ($;.'initial' => {
        name => $;.'initial',
        next_token => [],
      });

      my $copy_state = sub ($$) {
        my ($original_name, $new_prefix) = @_;
        my @copy = ($original_name.$;.'0');
        my @cs;
        while (@copy) {
          my $cname = shift @copy;
          next if $token{$new_prefix, $cname};
          my $original = $token{$cname};
          $token{$new_prefix, $cname} = my $new = {
            name => $new_prefix.$;.$cname,
            next_state => [],
          };
          for my $nxt (@{$original->{next_state}}) {
            push @{$new->{next_state}}, [$nxt->[0], $new_prefix.$;.$nxt->[1]];
            push @copy, $nxt->[1];
          }
          if ($original->{accept}) {
            push @cs, $new;
          }
        } # @copy
        return @cs;
      }; # copy_state

      for my $tel (grep {$_->node_type == $_->ELEMENT_NODE} @{$cel->child_nodes}) {
        my $xuri = $tel->namespace_uri . $tel->local_name;
        if ($xuri eq <Q::pg:lAssignmentStatement>) {
          my $sname = $tel->get_attribute_ns (undef, 'name');
          my $i = 0;
          if ($token{$sname, $i}) {
            die qq<"$sname" is already defined>;
            ## TODO: exception
          }
          my $s0 = $token{$sname, $i} = {
            name => $sname.$;.$i,
            next_state => [],
          };
          my @current_state = ($s0);
          my $ignore = $tel-><M::DPGElementAttribute.dpgGetAttribute> ('ignore');
          my $value = $tel-><M::DPGElementAttribute.dpgGetAttribute> ('value');
          for my $lel (grep {$_->node_type == $_->ELEMENT_NODE} @{$tel->child_nodes}) {
            my $xuri = $lel->namespace_uri . $lel->local_name;
            if ($xuri eq <Q::pg:charClass>) {
              my $range = [];
              for my $mel (grep {$_->node_type == $_->ELEMENT_NODE} @{$lel->child_nodes}) {
                my $xuri = $mel->namespace_uri . $mel->local_name;
                if ($xuri eq <Q::pg:string>) {
                  $range = $add_range->($range, ord $mel->text_content);
                } elsif ($xuri eq <Q::pg:charRange>) {
                  $range = $add_range->($range, $mel->get_attribute_ns (undef, 'start'),
                                                $mel->get_attribute_ns (undef, 'end'));
                }
              }
              if ($lel->get_attribute_ns (undef, 'negative')) {
                $range = $negate_range->($range);
              }
              
              my $new_s = {
                name => $sname.$;.(++$i),
                next_state => [],
              };
              my $v = $lel->get_attribute_ns (undef, 'occurence');
              if ($v eq 'zeromore') {
                $token{$new_s->{name}} = $new_s;
                push @{$new_s->{next_state}}, [$range, $new_s->{name}];
                for my $s (@current_state) {
                  push @{$s->{next_state}}, [$range, $new_s->{name}];
                }
                push @current_state, $new_s;
              } elsif ($v eq 'zeroone') {
                $token{$new_s->{name}} = $new_s;
                for my $s (@current_state) {
                  push @{$s->{next_state}}, [$range, $new_s->{name}];
                }
                push @current_state, $new_s;
              } elsif ($v eq 'onemore') {
                $token{$new_s->{name}} = $new_s;
                push @{$new_s->{next_state}}, [$range, $new_s->{name}];
                for my $s (@current_state) {
                  push @{$s->{next_state}}, [$range, $new_s->{name}];
                }
   \            @current_state = ($new_s);
              } else { # one
                $token{$new_s->{name}} = $new_s;
                for my $s (@current_state) {
                  push @{$s->{next_state}}, [$range, $new_s->{name}];
                }
   \            @current_state = ($new_s);
              }
            } elsif ($xuri eq <Q::pg:lRuleRef>) {
              my $rrulename = $lel->get_attribute_ns (undef, 'name');
              if ($token{$rrulename, 0}) {
                my @cs = $copy_state->($rrulename => $sname);
                for my $s (@current_state) {
                  push @{$s->{next_state}}, @{$token{$sname, $rrulename, 0}->{next_state}};
                }
   \            @current_state = @cs;
              } else {
                die "$rrulename is not defined";
                ## TODO: exception
              }
            }
          }
          push @{$token{$;.'initial'}->{next_state}}, @{$s0->{next_state}};
          for my $s (@current_state) {
            $s->{accept} = $sname;
            $s->{ignore} = $ignore if $ignore;
            $s->{value} = $value if $value;
          }
        }
      }

      my %dfa;
      my $make_dfa_state;
      $make_dfa_state = sub (@) {
        my (@src_name) = @_;
        my @src = map {$token{$_}} @src_name;
        my $next_state = [[[], [$;.'dummy']]];
        
        my @rsb = map {@{$_->{next_state}}} @src;
        for my $rsb (@rsb) {
          my $new_next_state = [];
          RSA: for my $rsa (@$next_state) {
            if (not $rsb) {
              push @$new_next_state, $rsa if @{$rsa->[0]};
              next RSA;
            }
            my ($ra, $rab, $rb) = $and_minus_ranges->($rsa->[0], $rsb->[0]);
            push @$new_next_state, [$ra, $rsa->[1]] if @$ra;
            push @$new_next_state, [$rab, [sort {$a cmp $b} @{$rsa->[1]}, $rsb->[1]]] if @$rab;
            if (@$rb) {
              $rsb = [$rb, $rsb->[1]];
            } else {
              $rsb = undef;
            }
          } # RSA
          if ($rsb) {
            push @$new_next_state, [$rsb->[0], [$rsb->[1]]];
          }
          $next_state = $new_next_state;
        }
        
        my $state_name = join $;.$;, @src_name;
        $dfa{$state_name} = {
          name => $state_name,
          next_state => @rsb ? $next_state : [],
        };
        
        for (@src) {
          if ($_->{accept}) {
            $dfa{$state_name}->{accept} = $_->{accept};
            $dfa{$state_name}->{value} = 1 if $_->{value};
          }
          $dfa{$state_name}->{ignore} = 1 if $_->{ignore};
        }
      };
      my @req_state = ([$;.'initial']);
      while (@req_state) {
        my $req_state = shift @req_state;
        my $req_state_name = join $;.$;, @$req_state;
        next if $dfa{$req_state_name};
        $make_dfa_state->(@$req_state);
        for (@{$dfa{$req_state_name}->{next_state}}) {
          push @req_state, $_->[1];
        }
      }
      
      my $escape_state_name = sub ($) {
        my $s = shift;
        $s =~ s/([\W_])/sprintf '_%08X', ord $1/ge;
        $s =~ s/_0000001C/__/g;
        return $s;
      };
      
      for ($tokenizer->append_statement
                     ->append_new_pc_expression ('=')) {
        $_->append_new_pc_variable ('$', undef, 'ch')
          ->variable_scope ('my');
        $_->append_new_pc_number_literal (-2);
      }
      
      my %ancestor_state;
      my $state_to_code;
      $state_to_code = sub ($$%) {
        my ($parent, $state_name, %opt) = @_;
        $ancestor_state{$state_name} = 1;
        
        my $state_block = $parent->append_new_pc_block;
        my $estate_name = $escape_state_name->($state_name);
        $state_block->label ('S'.$estate_name);
        my $state_select;
        
        if ($opt{outermost}) {
          $state_block->append_statement
                      ->append_new_pc_variable ('@', undef, 'ch')
                      ->variable_scope ('my');
        }
        
        if (@{$dfa{$state_name}->{next_state}}) {
          my $spush = $state_block->append_statement;
          for ($spush->append_new_pc_function_call (undef, 'push')
                     ->append_new_pc_expression (',')) {
            $_->append_new_pc_variable ('@', undef, 'ch');
            $_->append_new_pc_variable ('$', undef, 'ch');
          }
          $state_block->parent_node->insert_before ($spush, $state_block)
            unless $opt{outermost};
              ## NOTE: This statement must be placed before the named block;
              ##       otherwise token value cannot be correctly returned
              ##       when |redo|ne.  An exception is the outermost state.
          
          for my $as ($state_block->append_statement
                                  ->append_new_pc_expression ('=')) {
            $as->append_new_pc_variable ('$', undef, 'ch')
               ->variable_scope ('my');
            for ($as->append_new_pc_expression ('->')) {
              $_->append_new_pc_variable ('$', undef, 'self');
              $_->append_atom ('_shift_char');
            }
          }
        
          $state_select = $state_block->append_new_pc_choose;
          for my $rs (@{$dfa{$state_name}->{next_state}}) {
            my $when = $state_select->append_new_pc_when;
          
            my $cond = $when->condition;
            my $cond_and = $cond->append_new_pc_expression ('or');
            for my $range (@{$rs->[0]}) {
              if ($range->[0] == $range->[1]) {
                my $match = $cond_and->append_new_pc_expression ('==');
                $match->append_new_pc_variable ('$', undef, 'ch');
                $match->append_new_pc_number_literal ($range->[0]);
              } else {
                my $x_range = $cond_and->append_new_pc_expression ('and');
                my $x_range_s = $x_range->append_new_pc_expression ('<=');
                $x_range_s->append_new_pc_number_literal ($range->[0]);
                $x_range_s->append_new_pc_variable ('$', undef, 'ch');
                unless ($range->[1] eq 'Inf') {
                  my $x_range_e = $x_range->append_new_pc_expression ('<=');
                  $x_range_e->append_new_pc_variable ('$', undef, 'ch');
                  $x_range_e->append_new_pc_number_literal ($range->[1]);
                }
              }
            }
          
            my $when_block = $when->block;
            my $next_state_name = join $;.$;, @{$rs->[1]};
            if ($ancestor_state{$next_state_name}) {
              $when_block->append_child ($spush->clone_node (1));
              $when_block->append_statement
                         ->append_new_pc_function_call (undef, 'redo')
                         ->append_new_pc_variable
                             ('', undef, 'S'.$escape_state_name->($next_state_name));
            } else {
              $state_to_code->($when_block, $next_state_name, outermost => 0);
            }
          } # for next_state
        }

        if ($dfa{$state_name}->{accept}) {
          if ($state_select) {
            for ($state_select->append_new_pc_otherwise->block) {
              my $push_ap = $_->append_statement
                              ->append_new_pc_function_call
                                          (undef, 'unshift')
                              ->append_new_pc_expression (',');
              for ($push_ap->append_new_pc_dereference ('@')
                           ->append_new_pc_expression ('->')) {
                $_->append_new_pc_variable ('$', undef, 'self');
                $_->append_bare ('{char}');
              }
              $push_ap->append_new_pc_variable ('$', undef, 'ch');
              for ($_->append_statement->append_new_pc_expression ('=')) {
                $_->append_new_pc_variable ('$', undef, 'ch');
                $_->append_new_pc_number_literal (-2);
              }
            }
          }
          my $accept_code_parent = $state_block;
          unless ($dfa{$state_name}->{ignore}) {
            my %value;
            if ($dfa{$state_name}->{value}) {
              ## Removes dummy item
              $accept_code_parent->append_statement
                                 ->append_new_pc_function_call (undef, 'shift')
                                 ->append_new_pc_variable ('@', undef, 'ch');
              for ($accept_code_parent->append_statement
                                      ->append_new_pc_expression ('=')) {
                $_->append_new_pc_variable ('$', undef, 'token_val')
                  ->variable_scope ('my');
                $_->append_string_literal ('');
              }
              for ($accept_code_parent->append_new_pc_choose
                                      ->append_new_pc_when) {
                for ($_->condition->append_new_pc_expression ('>')) {
                  $_->append_new_pc_variable ('$', undef, 'ch');
                  $_->append_new_pc_number_literal (-1);
                }
                for ($_->block->append_statement
                              ->append_new_pc_function_call (undef, 'push')
                              ->append_new_pc_expression (',')) {
                  $_->append_new_pc_variable ('@', undef, 'ch');
                  $_->append_new_pc_variable ('$', undef, 'ch');
                }
              }
              for ($accept_code_parent->append_new_pc_while) {
                $_->condition->append_new_pc_variable ('@', undef, 'ch');
                for ($_->block->append_statement
                              ->append_new_pc_expression ('.=')) {
                  $_->append_new_pc_variable ('$', undef, 'token_val');
                  $_->append_new_pc_function_call (undef, 'chr')
                    ->append_new_pc_function_call (undef, 'shift')
                    ->append_new_pc_variable ('@', undef, 'ch');
                }
              }
              $value{value} = $accept_code_parent->append_new_pc_variable
                                                     ('$', undef, 'token_val');
            }
            $accept_code_parent->append_statement
                       ->append_new_pc_function_call (undef, 'return')
                       ->append_new_pc_literal ({
                           type => $dfa{$state_name}->{accept},
                           %value,
                         });
          } else {
            $accept_code_parent->append_statement
                       ->append_new_pc_function_call (undef, 'redo')
                       ->append_new_pc_variable
                           ('', undef, 'S'.$escape_state_name->($;.'initial'));
          }
        } elsif ($opt{outermost}) {
          if ($state_select) {
          for ($state_select->append_new_pc_when) {
            for ($_->condition->append_new_pc_expression ('==')) {
              $_->append_new_pc_variable ('$', undef, 'ch');
              $_->append_new_pc_number_literal (-1);
            }
            $_->block->append_statement
                     ->append_new_pc_function_call (undef, 'return')
                     ->append_new_pc_literal ({
                         type => '#EOF',
                       });
          }}
          my $chr_ch = $codeDocument
                         ->create_pc_function_call (undef, 'chr');
          $chr_ch->append_new_pc_variable ('$', undef, 'ch');
          $state_block->append_statement
                      ->append_new_pc_function_call (undef, 'return')
                      ->append_new_pc_literal ({
                          type => '#INVALID',
                          value => $chr_ch,
                        });
        } else {
          my $push_ap = $state_block->append_statement
                                    ->append_new_pc_function_call
                                          (undef, 'unshift')
                                    ->append_new_pc_expression (',');
          for ($push_ap->append_new_pc_dereference ('@')
                       ->append_new_pc_expression ('->')) {
            $_->append_new_pc_variable ('$', undef, 'self');
            $_->append_bare ('{char}');
          }
          $push_ap->append_new_pc_variable ('$', undef, 'ch');
        }
        
        $ancestor_state{$state_name} = 0;
      }; # $state_to_code
              $state_to_code->($tokenizer, $;.'initial', outermost => 1);

            } # xuri
          } # B


          ## --- Generates parser methods

          # Template for 'get next token' statements
  my $next_token_code = $codeDocument->create_pc_statement;
  for ($next_token_code->append_new_pc_expression ('=')) {
    $_->append_new_pc_variable ('$', undef, 'token');
    for ($_->append_new_pc_expression ('->')) {
      $_->append_new_pc_variable ('$', undef, 'self');
      $_->append_bare ('_shift_token');
    }
  }

          
  my $block_id = 0;
  my $rstatement_to_code;
  my $rexpression_to_code;
  $rstatement_to_code = sub ($$$) {
    my ($parent, $statement, $next_token_required) = @_;
    my $xuri = $statement->namespace_uri . $statement->local_name;
    if ($xuri eq <Q::pg:matchStatement>) {
      my $match_parent = $parent;
      my $match_occur = $statement->get_attribute_ns (undef, 'occurence');
      
      
      if ($match_occur eq 'onemore') {
        $match_parent = $match_parent->append_new_pc_block;
        for ($match_parent->append_statement->append_new_pc_expression ('=')) {
          $_->append_new_pc_variable ('$', undef, 'has_content')
            ->variable_scope ('my');
          $_->append_new_pc_number_literal (0);
        }
      }
      
      my $match_block_id = 0;
      if ($match_occur eq 'zeromore' or $match_occur eq 'onemore') {
        $match_parent = $match_parent->append_new_pc_block;
        $match_parent->label ('MATCH_' . ($match_block_id = ++$block_id));
      }
      
      my $match_choose = $match_parent->append_new_pc_choose;
      my $token_type_var = $codeDocument->create_pc_expression ('->');
      $token_type_var->append_new_pc_variable ('$', undef, 'token');
      $token_type_var->append_bare ('{type}');
      my $has_sep;
      C: for my $child (@{$statement->child_nodes}) {
        next C unless $child->node_type == $child->ELEMENT_NODE;
        my $xuri = $child->namespace_uri . $child->local_name;
        if ($xuri eq <Q::pg:matchBlock>) {
          my $token_name = $child->get_attribute_ns (undef, 'token');
          my $is_sep = $child-><M::DPGElementAttribute.dpgGetAttribute>
                                                    ('separator');
          my $token_parent;
          unless ($is_sep) {
            for ($match_choose->append_new_pc_when) {
              for ($_->condition->append_new_pc_expression ('eq')) {
                $_->append_child ($token_type_var->clone_node (1));
                $_->append_string_literal ($token_name);
              }
              $token_parent = $_->block;
            }
            if ($match_occur eq 'onemore') {
              for ($token_parent->append_statement->append_new_pc_expression ('=')) {
                $_->append_new_pc_variable ('$', undef, 'has_content');
                $_->append_new_pc_number_literal (1);
              }
            }
          } else { # separator
            $has_sep = 1;
            for ($match_parent->append_new_pc_choose) {
              for ($_->append_new_pc_when) {
                for ($_->condition->append_new_pc_expression ('eq')) {
                  $_->append_child ($token_type_var->clone_node (1));
                  $_->append_string_literal ($token_name);
                }
                $token_parent = $_->block;
              }
              for ($_->append_new_pc_otherwise->block) {
                $_->append_statement
                  ->append_new_pc_function_call (undef, 'last')
                  ->append_new_pc_variable ('', undef, 'MATCH_'.$match_block_id);
              }
            }
          }
          
          ## Child statements
          $next_token_required = 1;
          D: for my $child (@{$child->child_nodes}) {
            next D unless $child->node_type == $child->ELEMENT_NODE;
            $next_token_required = $rstatement_to_code->($token_parent, $child,
                                                         $next_token_required);
          }
          
          if ($next_token_required) {
            $token_parent->append_child ($next_token_code->clone_node (1));
            $next_token_required = 0;
          }

          if ($is_sep and
              ($match_occur eq 'zeromore' or $match_occur eq 'onemore')) {
            $token_parent-><M::pc|PerlCodeStatements.appendStatement>
                  -><M::pc|PerlCodeUnits.appendNewPCFunctionCall>
                                 (null, 'redo')
                  -><M::pc|PerlCodeUnits.appendNewPCVariable>
                                 ('', null, 'MATCH_'.$match_block_id);
          }
    
        }
      } # pc:matchStatement children
      
      if (not $match_occur or $match_occur eq 'onemore') {
        my $err_block = $match_choose->append_new_pc_otherwise->block;
        if ($match_occur eq 'onemore') {
          $err_block = $err_block->append_new_pc_choose->append_new_pc_when->block;
          for ($err_block->parent_node->condition->append_new_pc_expression ('==')) {
            $_->append_new_pc_variable ('$', undef, 'has_content');
            $_->append_new_pc_number_literal (0);
          }
        }
        ## TODO: Error reporting
        $err_block->append_statement ('die');
      }
      
      if (not $has_sep and ($match_occur eq 'zeromore' or $match_occur eq 'onemore')) {
        for ($match_choose->append_new_pc_otherwise->block) {
                
          $_->append_statement
                           ->append_new_pc_function_call (undef, 'last')
                           ->append_new_pc_variable ('', undef, 'MATCH_'.$match_block_id);
        }
        $match_parent->append_statement
                     ->append_new_pc_function_call (undef, 'redo')
                     ->append_new_pc_variable ('', undef, 'MATCH_'.$match_block_id);
      }

      return 0; # next_token_required == 0

            } elsif ($xuri eq <Q::pg:embedStatement>) {
              my $lang = $statement->get_attribute_ns (undef, 'type');
              if ($lang eq 'lang:Perl') {## TODO: lang URI
                my %param;
                my $source;
                C: for my $child (@{$statement->child_nodes}) {
                  next C unless $child->node_type == $child->ELEMENT_NODE;
                  my $xuri = $child-><AG::Node.namespaceURI>
                           . $child-><AG::Node.localName>;
                  if ($xuri eq <Q::pg:parameterSpecification>) {
                    $param{$child-><M::Element.getAttributeNS> (undef, 'name')}
                      = $child;
                  } elsif ($xuri eq <Q::pg:embedBlock>) {
                    $source = $child-><AG::Node.textContent>;
                  }
                }

                my $plcode = $disResource-><M::dp|DISResourcePerl||DIS|ForLatest
                                                .plPreprocessPerlCode>
                                 ($source, namespace_context => $contextObject);

                my $dparent = $parent-><AG::Node.ownerDocument>
                                   -><M::pc|PCDocument.createPCExpression> (',');
                for (keys %param) {
                  $rexpression_to_code->($dparent, $param{$_});
                  $plcode-><M::pc|PerlCode.replaceVariable>
                    ('$'.$_ => $dparent-><AG::Node.lastChild>);
                }

                $parent-><M::pc|PerlCodeStatements.appendCodeFragment> ($plcode);
                return $next_token_required;
              } else {
                die qq<Lexical content type <$lang> is not supported>;
                ## TODO: exception
              }

    } elsif ($xuri eq <Q::pg:myStatement>) {
      $parent->append_statement
             ->append_new_pc_variable
                 ('$', undef, $statement->get_attribute_ns (undef, 'name'))
             ->variable_scope ('my');
              return $next_token_required;
    
    } elsif ($xuri eq <Q::pg:ruleRefStatement>) {
      my $rule_name = $statement->get_attribute_ns (undef, 'name');
      if ($rules{$rule_name}) {
        if ($root_rules{$rule_name}) {
          unless ($next_token_required) {
            for ($parent->append_statement
                        ->append_new_pc_function_call (undef, 'push')
                        ->append_new_pc_expression (',')) {
              for ($_->append_new_pc_dereference ('@')
                     ->append_new_pc_expression ('->')) {
                $_->append_new_pc_variable ('$', undef, 'self');
                $_->append_bare ('{token}');
              }
              $_->append_new_pc_variable ('$', undef, 'token');
            }
          }
       
          
          my $param_spec_list;
          for ($parent->append_statement->append_new_pc_apply) {
            for ($_->append_new_pc_expression ('->')) {
              $_->append_new_pc_variable ('$', undef, 'self');
              $_->append_bare ('_parse_' . $rule_name);
            }
            $param_spec_list = $_->append_new_pc_expression (',');
          }
          
          my %param;
          C: for my $child (@{$statement->child_nodes}) {
            next C unless $child->node_type == $child->ELEMENT_NODE;
            if ($child->namespace_uri . $child->local_name eq
                <Q::pg:parameterSpecification>) {
              $param{$child->get_attribute_ns (undef, 'name')} = $child;
            }
          }
          
          for my $param_name (@{$rules{$rule_name}->{param}}) {
            if ($param{$param_name}) {
              $rexpression_to_code->($param_spec_list, $param{$param_name});
            } else {
              $param_spec_list->append_atom ('undef');
            }
          }
          
          return 1; # next_token_required == 1
        } else { # not a standalone rule
          my $block;
          unless ($rules{$rule_name}->{code}->[$next_token_required += 0]) {
            $block = $parent->append_new_pc_block;
            $rules{$rule_name}->{code}->[$next_token_required]
              = [$block, $next_token_required]; # prevent infinite loop
            my $o_next_token_required = $next_token_required;
            
            ## Child statements
            C: for my $child (@{$rules{$rule_name}->{source}->child_nodes}) {
              next C unless $child->node_type == $child->ELEMENT_NODE;
              $next_token_required = $rstatement_to_code->($block, $child,
                                                           $next_token_required);
            }
            $rules{$rule_name}->{code}->[$o_next_token_required]
              = [$block->clone_node (1), $next_token_required];
          } else {
            $block = $parent->append_child
                       ($rules{$rule_name}->{code}->[$next_token_required]->[0]
                                          ->clone_node (1));
            $next_token_required
              = $rules{$rule_name}->{code}->[$next_token_required]->[1];
          }
          
          my %param;
          C: for my $child (@{$statement->child_nodes}) {
            next C unless $child->node_type == $child->ELEMENT_NODE;
            if ($child->namespace_uri . $child->local_name eq
                <Q::pg:parameterSpecification>) {
              $param{$child->get_attribute_ns (undef, 'name')} = $child;
            }
          }
          
          my $block_first = $block->first_child;
          for my $param_name (reverse @{$rules{$rule_name}->{param}}) {
            $block_first = $block->insert_before
                             ($codeDocument->create_pc_statement, $block_first);
            for ($block_first->append_new_pc_expression ('=')) {
              $_->append_new_pc_variable ('$', undef, $param_name)
                ->variable_scope ('my');
              if ($param{$param_name}) {
                $rexpression_to_code->($_, $param{$param_name});
              } else {
                $_->append_atom ('undef');
              }
            }
          }
          
          return $next_token_required;
        }
      } elsif ($rule_name eq 'builtin:nestedBlockAsText') {
        my %param = (start_by_open => not $next_token_required,
                     open => '{', close => '}');
        
        C: for my $child (@{$statement->child_nodes}) {
          next C unless $child->node_type == $child->ELEMENT_NODE;
          if ($child->namespace_uri . $child->local_name eq
              <Q::pg:parameterSpecification>) {
            $param{$child->get_attribute_ns (undef, 'name')} = $child;
          }
        }
          
        for ($parent->append_statement->append_new_pc_apply) {
          for ($_->append_new_pc_expression ('->')) {
            $_->append_new_pc_variable ('$', undef, 'self');
            $_->append_bare ('_parse_nested_block_as_text');
          }
          my $param_spec_list = $_->append_new_pc_expression (',');
          for my $param_name (qw/doc parent open close start_by_open/) {
            if (ref $param{$param_name}) {
              $rexpression_to_code->($param_spec_list, $param{$param_name});
            } else {
              $param_spec_list->append_new_pc_literal ($param{$param_name});
            }
          }
        }
        
        return 1; # $next_token_required == 1
      } else {
        die qq<Rule "$rule_name" is not defined>;
        ## TODO: exception
      }



    } elsif ($xuri eq <Q::pg:assignmentStatement>) {
      my $assign = $parent->append_statement->append_new_pc_expression ('=');
      my $lvalue = $statement->first_child;
      if ($lvalue->namespace_uri . $lvalue->local_name eq <Q::pg:memberRef>) {
        my $context = $assign->append_new_pc_expression ('->');
        C: for my $child (@{$lvalue->child_nodes}) {
          my $xuri = $child->namespace_uri . $child->local_name;
          if ($xuri eq <Q::pg:variable>) {
            $context->append_new_pc_variable
              ('$', undef, $child->get_attribute_ns (undef, 'name'));
          } elsif ($xuri eq <Q::pg:member>) {
            $context->append_bare ('{'.$child->get_attribute_ns (undef, 'name').'}');
          }
        }
      }
              return $next_token_required;
    
    } elsif ($xuri eq <Q::pg:codeBlock>) {
      D: for my $child (@{$statement->child_nodes}) {
        next D unless $child->node_type == $child->ELEMENT_NODE;
        my $xuri = $child->namespace_uri . $child->local_name;
        if ($xuri eq <Q::pg:matchStatement>) {
          if ($next_token_required) {
            $parent->append_child ($next_token_code->clone_node (1));
            $next_token_required = false;
          }
        }
        $next_token_required = $rstatement_to_code->($parent, $child, $next_token_required);
      }
      return $next_token_required;
    } else {
      ## ISSUE: Can unsupported elements safely ignored?
      return $next_token_required;
    } # xuri
  }; # rstatement_to_code


  
  $rexpression_to_code = sub ($$) {
    my ($parent, $source_parent) = @_;
    $parent = $parent->append_new_pc_expression (',');
    C: for my $child (@{$source_parent->child_nodes}) {
      next C unless $child->node_type == $child->ELEMENT_NODE;
      my $xuri = $child->namespace_uri . $child->local_name;
      if ($xuri eq <Q::pg:memberRef>) {
        my $context = $parent->append_new_pc_expression ('->');
        D: for my $child (@{$child->child_nodes}) {
          next D unless $child->node_type == $child->ELEMENT_NODE;
          my $xuri = $child->namespace_uri . $child->local_name;
          if ($xuri eq <Q::pg:variable>) {
            $context->append_new_pc_variable
              ('$', undef, $child->get_attribute_ns (undef, 'name'));
          } elsif ($xuri eq <Q::pg:member>) {
            $context->append_bare ('{'.$child->get_attribute_ns (undef, 'name').'}');
          }
        }
      } elsif ($xuri eq <Q::pg:string>) {
        $parent->append_string_literal ($child->text_content);
      }
    }
  }; # rexpression_to_code
  
  for my $rule_name (keys %root_rules) {
    my $rule_sub = $codeDocument->create_perl_sub ('_parse_' . $rule_name);
    $r-><M::Node.appendChild> ($rule_sub);

            my $params_s = $rule_sub->append_statement;
            my @params = ('$self');
            my $proto = '$';
    
    $rule_sub->append_statement->append_new_pc_variable ('$', undef, 'token')
                               ->variable_scope ('my');
    
    ## Child statements
    my $next_token_required = 1;
    C: for my $child (@{$rules{$rule_name}->{source}->child_nodes}) {
      next C unless $child->node_type == $child->ELEMENT_NODE;
              if ($child-><AG::Node.namespaceURI> . $child-><AG::Node.localName>
                    eq <Q::pg:parameterDeclaration>) {
                push @params, '$'.$child-><M::Element.getAttributeNS>
                                    (null, 'name');
                $proto .= '$';
              } else {
                $next_token_required
                  = $rstatement_to_code->($rule_sub, $child,
                                          $next_token_required);
              }
    }

            $params_s->append_code ('my ('.join (', ', @params).') = @_');
            $rule_sub->prototype ($proto);
  
    unless ($next_token_required) {
      for ($rule_sub->append_statement
                    ->append_new_pc_function_call (undef, 'push')
                    ->append_new_pc_expression (',')) {
        for ($_->append_new_pc_dereference ('@')
               ->append_new_pc_expression ('->')) {
          $_->append_new_pc_variable ('$', undef, 'self');
          $_->append_bare ('{token}');
        }
        $_->append_new_pc_variable ('$', undef, 'token');
      }
    }
          
  } # for %root_rules

        }__;
##DPGRulesElement

ElementTypeBinding:
  @Name: NamedParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:MethodParameter
    @@DISPerl:isNamedParameter:1

IFClsETDef:
  @IFQName: DPGRuleElement
  @ClsQName: ManakaiDPGRuleElement
  @ETQName: pg|rule

  @IFISA: DPGElement
  @ClsISA: ManakaiDPGElement

  @IFISA: DPGElementAttribute
  @ClsISA: ManakaiDPGElementAttribute

##DPGRuleElement

IFClsETDef:
  @IFQName: DPGMatchBlockElement
  @ClsQName: ManakaiDPGMatchBlockElement
  @ETQName: pg|matchBlock

  @IFISA: DPGElement
  @ClsISA: ManakaiDPGElement
  
  @IFISA: DPGElementAttribute
  @ClsISA: ManakaiDPGElementAttribute

##DPGMatchBlockElement

IFClsETDef:
  @IFQName: DPGLexmodeElement
  @ClsQName: ManakaiDPGLexmodeElement
  @ETQName: pg|lexmode
  
  @IFISA: DPGElement
  @ClsISA: ManakaiDPGElement

  @IFISA: DPGElementAttribute
  @ClsISA: ManakaiDPGElementAttribute

##DPGLexmodeElement

IFClsETDef:
  @IFQName: DPGLAssignmentStatementElement
  @ClsQName: ManakaiDPGLAssignmentStatementElement
  @ETQName: pg|lAssignmentStatement
  
  @IFISA: DPGElement
  @ClsISA: ManakaiDPGElement

  @IFISA: DPGElementAttribute
  @ClsISA: ManakaiDPGElementAttribute

##DPGLAssignmentStatementElement

IFClsDef:
  @IFQName: DPGParser
  @ClsQName: ManakaiDPGParser

  @enDesc:
    A <IF::DPGParser> object parses a DPG source document and 
    converts it into a DOM tree representation.

    A <IF::DPGParser> object can be retrived by <M::GenericLS.createGLSParser>
    method in the Generic Load and Save module with feature string
    <Feature::DIS|DPG> version <FeatureVer::1.0>.

  @DISLang:role: DOMLS|ParserRole

  @Method:
    @@ManakaiDOM:isForInternal:1
    @@ForCheck: ManakaiDOM|ForClass
    @@Operator: DISPerl|NewMethod
    @@enDesc:
      Creates a new instance of the object.
    @@Param:
      @@@Name: impl
      @@@Type: DOMLS|GLSImplementation
      @@@enDesc:
        The implementation from which the parser is created.
    @@Param:
      @@@Name: features
      @@@Type: DOMString
      @@@dis:actualType: f|FeaturesString
      @@@enDesc:
        The set of features requested for the parser.
    @@Return:
      @@@Type: DOMMain|DOMObject
      @@@dis:actualType: DPGParser
      @@@enDesc:
        The newly created parser.
      @@@PerlDef:
        $r = bless {
          <H::DOMCore:implementation>
            => $impl-><M::f|GetFeature.getFeature>
                 (<Q::DIS|DPG> => ''),
        }, $self;

  @Method:
    @@Name: parseString
    @@enDesc:
      Parses a string as DPG textual definition and converts it into
      its XML representation.
    @@Param:
      @@@Name: sourceText
      @@@Type: DOMString
      @@@enDesc:
        The text to parse.
    @@Param:
      @@@Name: namespaceContext
      @@@Type: DIS|NSResolverDIS||DIS|ForLatest
      @@@enDesc:
        The namespace prefix resolver against which <P::sourceText>
        is evaluated.

          {NOTE::
             Although namespace prefixes in DPG syntax are resolved
             by the parser, those in embed statements are not resolved
             as well as other context dependent information such as 
             base URI or method call.  In fact embed statement contents
             are transparently copied and not parsed at all.
          }
    @@Return:
      @@@Type: DPGDocument
      @@@enDesc:
        An XML representation of <P::sourceText>.
      @@@PerlDef:
        $self->{char} = [];
        $self->{token} = [];
        $self->{source} = $sourceText;
        __DEEP{
          $r = $self->_parse_Rules ($self->{<H::DOMCore:implementation>});
        }__;

  @Method:
    @@Name: shiftChar
    @@ManakaiDOM:isForInternal:1
    @@ForCheck: ManakaiDOM|ForClass
    @@enDesc:
      Returns the next character.
    @@Return:
      @@@Type: idl|long||ManakaiDOM|all
      @@@enDesc:
        The code position number of the next character, if any,
        or <CODE::-2>.
      @@@PerlDef:
        if (@{$self->{char}}) {
          $r = shift @{$self->{char}};
        } else {
          my $char = substr ($self->{source}, pos ($self->{source}), 1);
          pos ($self->{source})++;

          if (length $char) {
            $r = ord $char;
          } else {
            $r = -1;
          }
        }

  @Method:
    @@Name: parseNestedBlockAsText
    @@ManakaiDOM:isForInternal:1
    @@ForCheck: ManakaiDOM|ForClass
    @@enDesc:
      Parses an embed statement block.
    @@Param:
      @@@Name: doc
      @@@Type: DPGDocument
      @@@enDesc:
        The owner document object used if new node is being created.
    @@Param:
      @@@Name: parent
      @@@Type: Element
      @@@enDesc:
        The parent element node to which the value from the parsed statement 
        should be attached.
    @@Return:
      @@@PerlDef:
        my $nest_count = 1; # already opened
        my $s = '';
        __DEEP{
          C: while ((my $ch = $self-><M::ManakaiDPGParser.shiftChar>) > -1) {
            if ($ch == 0x007B) {
              $s .= '{'; # }
              $nest_count++;
            } elsif ($ch == 0x007D) {
              if (--$nest_count == 0) {
                last C;
              } elsif ($nest_count < 0) {
                $nest_count = 0;
              }
              $s .= chr $ch;
            } else {
              $s .= chr $ch;
            }
          }

          if (length $s) {
            my $el = $doc-><M::Document.createElementNS>
                        (<Q::pg:>, 'embedBlock');
            $el-><AS::Node.textContent> ($s);
            $parent-><M::Node.appendChild> ($el);
          }
        }__;

  @DISPerl:dpgDef:

  rule Rules ($impl) : standalone {
    my $doc; ;; : return
    my $docel;
    lang:Perl {
      $doc = $impl-><M::DOMCore|DOMImplementation.createDocument>
                      (<Q::pg:>, 'rules');
      $docel = $doc-><AG::Document.documentElement>;
    }
    
    ;; Rules := *rule
    ~* (RULE) {
      &_Rule ($doc => $doc, $parent => $docel);
    } (lEXMODE) {
      &_Lexmode ($doc => $doc, $parent => $docel);
    }
    
    ~ (EOF) { }
  } ;; Rules
  
  rule _Lexmode ($doc, $parent) {
    ;; Lexmode := LEXMODE NAME *AttributeSpecification LBRACE
    ;;            *LStatement RBRACE
    
    my $el;
    lang:Perl {
      $el = $doc-><M::Document.createElementNS> (<Q::pg:>, 'lexmode');
      $parent-><M::Node.appendChild> ($el);
    }
    
    ;; Lexmode name
    ~ (NAME) {
      lang:Perl ($name => $token.value) {
        $el-><M::Element.setAttributeNS> (null, 'name', $name);
      }
    }
    
    &AttributeSpecificationList ($doc => $doc, $parent => $el);
    
    ~ (LBRACE) { }
    
    ;; LStatement := LAssignmentStatement;
    ~* (NAME) {
      ;; LAssignmentStatement := NAME *AttributeSpecification DEFINE
      ;;                         1*(CharClass Occrence / NAME) SEMICOLON
      my $lassign;
      lang:Perl ($name => $token.value) {
        $lassign = $doc-><M::Document.createElementNS> (<Q::pg:>, 'lAssignmentStatement');
        $lassign-><M::Element.setAttributeNS> (null, 'name', $name);
        $el-><M::Node.appendChild> ($lassign);
      }
      
      &AttributeSpecificationList ($doc => $doc, $parent => $lassign);
      
      ~ (DEFINE) { }
      
      ~* (CLSOPEN) {
        my $cls;
        lang:Perl {
          $cls = $doc-><M::Document.createElementNS> (<Q::pg:>, 'charClass');
          $lassign-><M::Node.appendChild> ($cls);
        }
        &_CharClass ($doc => $doc, $parent => $cls);
      } (NCLSOPEN) {
        my $cls;
        lang:Perl {
          $cls = $doc-><M::Document.createElementNS> (<Q::pg:>, 'charClass');
          $cls-><M::Element.setAttributeNS> (null, 'negative', '1');
          $lassign-><M::Node.appendChild> ($cls);
        }
        &_CharClass ($doc => $doc, $parent => $cls);
      } (NAME) {
        lang:Perl ($name => $token.value) {
          my $lname = $doc-><M::Document.createElementNS> (<Q::pg:>, 'lRuleRef');
          $lname-><M::Element.setAttributeNS> (null, 'name', $name);
          $lassign-><M::Node.appendChild> ($lname);
        }
      }
      
      ~ (SEMICOLON) { }
    }
    
    ~ (RBRACE) { }
  } ;; _Lexmode
  
  rule _CharClass ($doc, $parent) {
    ;; CharClass := (CLSOPEN / NCLSOPEN) 1*CharSpec CLSCLOSE
    ;; CharSpec := STRING / CHAR [RANGE CHAR]
    ~+ (STRING) {
      lang:Perl ($value => $token.value) {
        my $str = $doc-><M::Document.createElementNS> (<Q::pg:>, 'string');
        $str-><AS::Node.textContent> (substr ($value, 1, length ($value) - 2));
        $parent-><M::Node.appendChild> ($str);
      }
    } (CHAR) {
      my $char;
      lang:Perl ($value => $token.value) {
        $char = $doc-><M::Document.createElementNS> (<Q::pg:>, 'charRange');
        my $code = $value;
        $code =~ s/^U\+/0x/;
        $char-><M::Element.setAttributeNS> (null, 'start', hex $code);
        $char-><M::Element.setAttributeNS> (null, 'end', hex $code);
        $parent-><M::Node.appendChild> ($char);
      }
      ~? (RANGE) {
        ~ (CHAR) {
          lang:Perl ($value => $token.value) {
            my $code = $value;
            $code =~ s/^U\+/0x/;
            $char-><M::Element.setAttributeNS> (null, 'end', hex $code);
          }
        }
      }
    }
    
    ~ (CLSCLOSE) { }
    
    
    ~? (ZEROMORE) {
      lang:Perl {
        $parent-><M::Element.setAttributeNS> (null, 'occurence', 'zeromore');
      }
    } (ONEMORE) {
      lang:Perl {
        $parent-><M::Element.setAttributeNS> (null, 'occurence', 'onemore');
      }
    } (ZEROONE) {
      lang:Perl {
        $parent-><M::Element.setAttributeNS> (null, 'occurence', 'zeroone');
      }
    }
  } ;; _CharClass
  
  
  rule _Rule ($doc, $parent) {
    ;; Rule := RULE NAME [ParameterDeclarationList] *AttributeSpecification
    ;;         CodeBlock
    
    my $el;
    lang:Perl {
      $el = $doc-><M::Document.createElementNS> (<Q::pg:>, 'rule');
      $parent-><M::Node.appendChild> ($el);
    }
    
    ;; Rule name
    ~ (NAME) {
      lang:Perl ($name => $token.value) {
        $el-><M::Element.setAttributeNS> (null, 'name', $name);
      }
    }
    
    ;; ParameterDeclarationList := "(" [ParameterDeclaration
    ;;                                  *(COMMA ParameterDeclaration)] ")"
    ;; ParameterDeclaration := VARIABLE
    ~? (LPAREN) {
      ~* (VARIABLE) {
        lang:Perl ($name => $token.value) {
          my $pel = $doc-><M::Document.createElementNS>
                            (<Q::pg:>, 'parameterDeclaration');
          $pel-><M::Element.setAttributeNS> (null, 'name', substr ($name, 1));
          $el-><M::Node.appendChild> ($pel);
        }
      } (COMMA) : separator {
        ;;
      }
      ~ (RPAREN) { }
    }
    
    &AttributeSpecificationList ($doc => $doc, $parent => $el);
    
    &CodeBlock ($doc => $doc, $parent => $el);
  } ;; _Rule
  
  rule AttributeSpecificationList ($doc, $parent) {
    ;; AttributeSpecification := BooleanAttributeSpecification
    ;; BooleanAttributeSpecification := COLON NAME Occurence
    ~* (COLON) {
      ~ (NAME) {
        my $ael;
        lang:Perl ($name => $token.value) {
          $ael = $doc-><M::Document.createElementNS>
                            (<Q::pg:>, 'attributeSpecification');
          $ael-><M::Element.setAttributeNS> (null, 'name', $name);
          $ael-><M::Element.setAttributeNS> (null, 'value', '1');
          $parent-><M::Node.appendChild> ($ael);
        }
        ~? (ZEROMORE) {
          lang:Perl {
            $ael-><M::Element.setAttributeNS> (null, 'occurence', 'zeromore');
          }
        } (ONEMORE) {
          lang:Perl {
            $ael-><M::Element.setAttributeNS> (null, 'occurence', 'onemore');
          }
        } (ZEROONE) {
          lang:Perl {
            $ael-><M::Element.setAttributeNS> (null, 'occurence', 'zeroone');
          }
        }
      }
    }
  } ;; AttributeSpecificationList
  
  rule CodeBlock ($doc, $parent) : standalone {
    ;; CodeBlock := LBRACE *Statement RBRACE
    ~ (LBRACE) { }
    
    my $block;
    lang:Perl {
      $block = $doc-><M::Document.createElementNS> (<Q::pg:>, 'codeBlock');
      $parent-><M::Node.appendChild> ($block);
    }
    
    ;; Statement := MyStatement / AssignmentStatement / MatchStatement
    ;;            / RuleRefStatement / EmbedStatement
    
    ~* (MATCH) {
      ;; MatchStatement := MATCH Occurence
      ;;                   1*(LPAREN NAME RPAREN *AttributeSpecification CodeBlock)
      my $match;
      lang:Perl {
        $match = $doc-><M::Document.createElementNS> (<Q::pg:>, 'matchStatement');
        $block-><M::Node.appendChild> ($match);
      }
        ~? (ZEROMORE) {
          lang:Perl {
            $match-><M::Element.setAttributeNS> (null, 'occurence', 'zeromore');
          }
        } (ONEMORE) {
          lang:Perl {
            $match-><M::Element.setAttributeNS> (null, 'occurence', 'onemore');
          }
        } (ZEROONE) {
          lang:Perl {
            $match-><M::Element.setAttributeNS> (null, 'occurence', 'zeroone');
          }
        }
        ~+ (LPAREN) {
          my $match_block;
          lang:Perl {
            $match_block = $doc-><M::Document.createElementNS> (<Q::pg:>, 'matchBlock');
            $match-><M::Node.appendChild> ($match_block);
          }
          ~ (NAME) {
            lang:Perl ($name => $token.value) {
              $match_block-><M::Element.setAttributeNS> (null, 'token', $name);
            }
          }
          ~ (RPAREN) { }
          
          &AttributeSpecificationList ($doc => $doc, $parent => $match_block);
          
          &CodeBlock ($doc => $doc, $parent => $match_block);
        }
    } (NAME) {
      ;; EmbedStatement := NAME [ParameterSpecificationList] ExternalBlock
      my $embed;
      lang:Perl ($name => $token.value) {
        ## TODO: Expand QName
        $embed = $doc-><M::Document.createElementNS> (<Q::pg:>, 'embedStatement');
        $embed-><M::Element.setAttributeNS> (null, 'type', $name);
        $block-><M::Node.appendChild> ($embed);
      }
      
      &ParameterSpecificationListOpt ($doc => $doc, $parent => $embed);
      
      &builtin:nestedBlockAsText ($doc => $doc, $parent => $embed,
                                  $open => '{', $close => '}');
    } (RULEREF) {
      ;; RuleRefStatement := RULEREF [ParameterSpecificationList] SEMICOLON;
      my $ruleref;
      lang:Perl ($name => $token.value) {
        $ruleref = $doc-><M::Document.createElementNS> (<Q::pg:>, 'ruleRefStatement');
        $ruleref-><M::Element.setAttributeNS> (null, 'name', substr ($name, 1));
        $block-><M::Node.appendChild> ($ruleref);
      }
      
      &ParameterSpecificationListOpt ($doc => $doc, $parent => $ruleref);
      
      ~ (SEMICOLON) { }
    } (VARIABLE) {
      ;; AssignmentStatement := Lvalue ASSIGN Rvalue;
      my $assign;
      my $lvalue;
      lang:Perl ($name => $token.value) {
        $assign = $doc-><M::Document.createElementNS> (<Q::pg:>, 'assignmentStatement');
        $lvalue = $doc-><M::Document.createElementNS> (<Q::pg:>, 'memberRef');
        my $var = $doc-><M::Document.createElementNS> (<Q::pg:>, 'variable');
        $var-><M::Element.setAttributeNS> (null, 'name', substr ($name, 1));
        $lvalue-><M::Node.appendChild> ($var);
        $assign-><M::Node.appendChild> ($lvalue);
        $block-><M::Node.appendChild> ($assign);
      }
      
      ~* (DOT) {
        ~ (NAME) {
          lang:Perl ($name => $token.value) {
            my $mem = $doc-><M::Document.createElementNS> (<Q::pg:>, 'member');
            $mem-><M::Element.setAttributeNS> (null, 'name', $name);
            $lvalue-><M::Node.appendChild> ($mem);
          }
        }
      }
      
      ~ (ASSIGN) { }
      
      &Rvalue ($doc => $doc, $parent => $assign);
      
      ~ (SEMICOLON) { }
    } (mY) {
      ;; MyStatement := MY VARIABLE SEMICOLON
      ~ (VARIABLE) {
        my $my;
        lang:Perl ($name => $token.value) {
          $my = $doc-><M::Document.createElementNS> (<Q::pg:>, 'myStatement');
          $my-><M::Element.setAttributeNS> (null, 'name', substr ($name, 1));
          $block-><M::Node.appendChild> ($my);
        }
      }
      ~ (SEMICOLON) { }
    }
    
    ~ (RBRACE) { }
  } ;; CodeBlock
    
    ;; Lvalue := VARIABLE *(DOT NAME)
  
  rule Rvalue ($doc, $parent) {
    ;; Rvalue := STRING / VARIABLE *(DOT NAME)
    
    ~ (STRING) {
      lang:Perl ($value => $token.value) {
        my $str = $doc-><M::Document.createElementNS> (<Q::pg:>, 'string');
        $str-><AS::Node.textContent> (substr ($value, 1, length ($value) - 2));
        $parent-><M::Node.appendChild> ($str);
      }
    } (VARIABLE) {
      my $memref;
      lang:Perl ($name => $token.value) {
        $memref = $doc-><M::Document.createElementNS> (<Q::pg:>, 'memberRef');
        my $var = $doc-><M::Document.createElementNS> (<Q::pg:>, 'variable');
        $var-><M::Element.setAttributeNS> (null, 'name', substr ($name, 1));
        $memref-><M::Node.appendChild> ($var);
        $parent-><M::Node.appendChild> ($memref);
      }
      
      ~* (DOT) {
        ~ (NAME) {
          lang:Perl ($name => $token.value) {
            my $mem = $doc-><M::Document.createElementNS> (<Q::pg:>, 'member');
            $mem-><M::Element.setAttributeNS> (null, 'name', $name);
            $memref-><M::Node.appendChild> ($mem);
          }
        }
      }
    }
  } ;; Rvalue

  rule ParameterSpecificationListOpt ($doc, $parent) {
    ;; ParameterSpecificationList := LPAREN [VARIABLE REPLACE Rvalue
    ;;                                       *(COMMA Lvalue REPLACE Rvalue)] RPAREN
    ~? (LPAREN) {
      ~* (VARIABLE) {
        my $param;
        lang:Perl ($name => $token.value) {
          $param = $doc-><M::Document.createElementNS> (<Q::pg:>, 'parameterSpecification');
          $parent-><M::Node.appendChild> ($param);
          $param-><M::Element.setAttributeNS> (null, 'name', substr ($name, 1));
        }
        
        ~ (REPLACE) { }
        
        &Rvalue ($doc => $doc, $parent => $param);
      } (COMMA) : separator { }
      
      ~ (RPAREN) { }
    }
  }


    lexmode default : initial {
      WSP : ignore := [U+0009..U+000D U+0020]+;
      COMMENT : ignore := [';'] [';'] [^U+000A..U+000D]* [U+000A..U+000D]*;
    
    NAME : value := [U+0041..U+005A U+0061..U+007A '_' '-']
                    [U+0030..U+0039 U+0041..U+005A U+0061..U+007A '_' '-' ':']*;

    VARIABLE : value := ['$'] NAME;
    RULEREF : value := ['&'] NAME;
    
    CHAR : value := ['U' 'u'] ['+']
                    [U+0030..U+0039 U+0041..U+0046 U+0061..U+0066]
                    [U+0030..U+0039 U+0041..U+0046 U+0061..U+0066]
                    [U+0030..U+0039 U+0041..U+0046 U+0061..U+0066]
                    [U+0030..U+0039 U+0041..U+0046 U+0061..U+0066]+;
    
    STRING : value := [U+0027] [^U+0027 U+005C]* [U+0027];
    
    COMMA := [','];
    REPLACE := ['='] ['>'];
    ASSIGN := ['='];
    DEFINE := [':'] ['='];
    LPAREN := ['('];
    RPAREN := [')'];
    LBRACE := ['{'];
    RBRACE := ['}'];
    CLSOPEN := ['['];
    NCLSOPEN := ['['] ['^'];
    CLSCLOSE := [']'];
    ZEROMORE := ['*'];
    ONEMORE := ['+'];
    ZEROONE := ['?'];
    COLON := [':'];
    SEMICOLON := [';'];
    MATCH := ['~'];
    DOT := ['.'];
    RANGE := ['.'] ['.'];
    
    mY := ['m'] ['y'];
    RULE := ['r'] ['u'] ['l'] ['e'];
    lEXMODE := ['l'] ['e'] ['x'] ['m'] ['o'] ['d'] ['e'];
  } ;; lexmode

    

##DPGParser
