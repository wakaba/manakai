Module:
  @QName: DIS|DPG
  @FullName:
    @@lang: en
    @@@:
      <QUOTE::dis> DPG Module
  @Namespace:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS#DPG/
  
  @enDesc:
    The <Module::DIS|DPG>, <QUOTE::dis> parser generator, is a compiler
    generator implementation for the <QUOTE::dis> system.

  @DISCore:author: DISCore|Wakaba
  @License: license|Perl+MPL

  @Date:
    $Date: 2006/02/22 11:22:08 $
  
  @Require:
    @@Module:
      @@@QName: DIS|common
    @@Module:
      @@@QName: Util|PerlCode
      @@@WithFor: ManakaiDOM|ManakaiDOMLatest

  @DefaultFor: ManakaiDOM|ManakaiDOMLatest

Namespace:
  @DIS:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS#
  @dis:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#dis--
  @DISlib:
    http://suika.fam.cx/~wakaba/archive/2004/dis/
  @dp:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS#Perl/
  @dx:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#
  @ecore:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/Core/
  @f:
    http://suika.fam.cx/~wakaba/archive/2004/dom/feature#
  @gls:
    http://suika.fam.cx/~wakaba/archive/2004/dom/gls#
  @html5:
    http://www.w3.org/1999/xhtml
  @idl:
    http://suika.fam.cx/~wakaba/archive/2004/dis/IDL#
  @kwd:
    http://suika.fam.cx/~wakaba/archive/2005/rfc2119/
  @lang:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#
  @license:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/license#
  @ManakaiDOM:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#
  @MDOM:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#ManakaiDOM.
  @MDOMX:
    http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#
  @mn:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/ManakaiNode#
  @pc:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/PerlCode#
  @pg:
    http://suika.fam.cx/~wakaba/archive/2005/11/pg/
  @rdf:
    http://www.w3.org/1999/02/22-rdf-syntax-ns#
  @rdfs:
    http://www.w3.org/2000/01/rdf-schema#
  @s:
    http://suika.fam.cx/~wakaba/archive/2004/dis/Markup#
  @Util:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/

## -- Features

ElementTypeBinding:
  @Name: FeatureDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: f|Feature
    @@For: =ManakaiDOM|all

ElementTypeBinding:
  @Name: FeatureVerDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: f|Feature

ElementTypeBinding:
  @Name: featureQName
  @ElementType:
    f:name
  @ShadowContent:
    @@ContentType: DISCore|QName

FeatureDef:
  @QName: DIS|DPG
  @FeatureVerDef:
    @@QName: DIS|DPG10
    @@Version: 1.0
    @@f:instanceOf: DIS|DPG
    @@f:requires: DOMXML|XMLFeature30
    @@f:requires: pc|CoreFeature10
    @@FullName:
      @@@lang:en
      @@@@:
        DPG version 1.0

ElementTypeBinding:
  @Name: enDesc
  @ElementType: 
    dis:Description
  @ShadowContent: 
    @@lang:en

ElementTypeBinding:
  @Name: IFClsETDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      @@@@: dis|MultipleResource
      @@@ForCheck: !ManakaiDOM|ForIF !ManakaiDOM|ForClass !s|ForML
    @@resourceFor: ManakaiDOM|ForIF
    @@resourceFor: ManakaiDOM|ForClass
    @@resourceFor: s|ForML

    @@rdf:type:
      @@@@: DISLang|Interface
      @@@ForCheck: ManakaiDOM|ForIF
    @@s:elementType:
      @@@@: ||+||s|ForML
      @@@ForCheck: ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames

    @@rdf:type:
      @@@@: DISLang|Class
      @@@ForCheck: ManakaiDOM|ForClass
    @@Implement:
      @@@@: ||+||ManakaiDOM|ForIF
      @@@ForCheck: ManakaiDOM|ForClass
      @@@ContentType: DISCore|TFPQNames
    @@s:elementType:
      @@@@: ||+||s|ForML
      @@@ForCheck: ManakaiDOM|ForClass
      @@@ContentType: DISCore|TFPQNames
      @@@DISCore:stopISARecursive:1

    @@rdf:type:
      @@@@: s|ElementType
      @@@ForCheck: s|ForML

    @@f:implements: DIS|DPG10

    @@ForCheck: ManakaiDOM|ManakaiDOM

ElementTypeBinding:
  @Name: IFClsDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      @@@@: dis|MultipleResource
      @@@ForCheck: !ManakaiDOM|ForIF !ManakaiDOM|ForClass
    @@resourceFor: ManakaiDOM|ForIF
    @@resourceFor: ManakaiDOM|ForClass

    @@rdf:type:
      @@@@: DISLang|Interface
      @@@ForCheck: ManakaiDOM|ForIF

    @@rdf:type:
      @@@@: DISLang|Class
      @@@ForCheck: ManakaiDOM|ForClass
    @@Implement:
      @@@@: ||+||ManakaiDOM|ForIF
      @@@ForCheck: ManakaiDOM|ForClass
      @@@ContentType: DISCore|TFPQNames

    @@f:implements: DIS|DPG10

    @@ForCheck: ManakaiDOM|ManakaiDOM

ElementTypeBinding:
  @Name: IFDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      @@@@: dis|MultipleResource
      @@@ForCheck: !ManakaiDOM|ForIF !ManakaiDOM|ForClass
    @@resourceFor: ManakaiDOM|ForIF

    @@rdf:type:
      @@@@: DISLang|Interface
      @@@ForCheck: ManakaiDOM|ForIF

    @@ForCheck: ManakaiDOM|ManakaiDOM

ElementTypeBinding:
  @Name: IFQName
  @ElementType:
    dis:QName
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForIF

ElementTypeBinding:
  @Name: ClsQName
  @ElementType:
    dis:QName
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: ETQName
  @ElementType:
    dis:AppName
  @ShadowContent:
    @@ForCheck:
      s:ForML
    @@ContentType: DISCore|QName

ElementTypeBinding:
  @Name: ATTRQName
  @ElementType:
    dis:AppName
  @ShadowContent:
    @@ForCheck:
      s:ForML
    @@ContentType: DISCore|QName

ElementTypeBinding:
  @Name: IFISA
  @ElementType:
    dis:ISA
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForIF

ElementTypeBinding:
  @Name: ClsISA
  @ElementType:
    dis:ISA
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: Method
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Method
    @@For: !=ManakaiDOM|ManakaiDOM

ElementTypeBinding:
  @Name: Return
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|MethodReturn

ElementTypeBinding:
  @Name: Param
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|MethodParameter

ElementTypeBinding:
  @Name: plMName
  @ElementType:
    DISPerl:methodName

ElementTypeBinding:
  @Name: PerlDef
  @ElementType:
    dis:Def
  @ShadowContent:
    @@ContentType: lang|Perl

ElementTypeBinding:
  @Name: disDef
  @ElementType:
    dis:Def
  @ShadowContent:
    @@ContentType: lang|dis

ElementTypeBinding:
  @Name: PropDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: rdf|Property

## -- The DPG Document Object Model

IFClsDef:
  @IFQName: DPGDocument
  @ClsQName: ManakaiDPGDocument

  @IFISA: Document
  @ClsISA: DOMCore|ManakaiDOMDocument

  @enDesc:
    The <IF::DPGDocument> interface <kwd:MUST> be implemented by
    <IF::Document> objects if the implementation supports the DPG object model.

  @f:provides:
    @@@: DIS|DPG10
    @@f:through: DOMCore|ManakaiDOMImplementation

  @s:rootElementType: RulesElementType
##DPGDocument

ResourceDef:
  @For: ManakaiDOM|DOM
  @QName: Node
  @AliasFor: DOMCore|Node

ResourceDef:
  @For: ManakaiDOM|DOM
  @QName: Document
  @AliasFor: DOMCore|Document

ResourceDef:
  @For: ManakaiDOM|DOM
  @QName: Element
  @AliasFor: DOMCore|Element

IFClsDef:
  @IFQName: DPGElement
  @ClsQName: ManakaiDPGElement

  @IFISA: Element
  @ClsISA: DOMCore|ManakaiDOMElement

  @enDesc:
    The <IF::DPGElement> interface <kwd:MUST> be implemented by
    <IF::Element> objects whose namespace URI is <URI^^DISCore:QName::pg:>
    if the implementation supports the DPG object model.

##DPGElement

IFClsDef:
  @IFQName: DPGElementAttribute
  @ClsQName: ManakaiDPGElementAttribute

  @enDesc:
    The <IF::DPGElementAttribute> interface is implemented by
    objects whose element type allowes DPG attributes being specified.

  @Method:
    @@Name: dpgGetAttribute
    @@enDesc:
      Returns a DPG attribute value.
    @@Param:
      @@@Name: attrName
      @@@Type: DOMString
      @@@enDesc:
        The name of the attribute.
    @@Return:
      @@@Type: DOMString
      @@@enDesc:
        The attribute value.

          {NOTE:: If the DPG attribute element is invalid so that 
                  its <XA::value> attribute is not specified, then
                  what is the return value is undefined.
          }
      @@@nullCase:
        @@@@enDesc:
          The attribute is not specified.
      @@@PerlDef:
        __DEEP{
          $r = null;
          no warnings "uninitialized";
          C: for my $child (@{$self-><AG::Node.childNodes>}) {
            if ($child-><AG::Node.namespaceURI>.$child-><AG::Node.localName> eq
                <Q::pg:attributeSpecification>) {
              if ($child-><M::Element.getAttributeNS> (null, 'name') eq
                  $attrName) {
                $r = $child-><M::Element.getAttributeNS> (null, 'value');
                last C;
              }
            }
          }
        }__;

  @Method:
    @@Name: dpgGetAttributeList
    @@enDesc:
      Returns a list of DPG attribute values.
    @@Param:
      @@@Name: attrName
      @@@Type: DOMString
      @@@enDesc:
        The name of the attribute.
    @@Return:
      @@@Type: DISPerl|ARRAY||ManakaiDOM|all
      @@@enDesc:
        A reference to a snapshot list of the attribute values.

          {NOTE:: If a DPG attribute element is invalid so that 
                  its <XA::value> attribute is not specified, then
                  what is the return value is undefined.
          }
      @@@PerlDef:
        __DEEP{
          no warnings "uninitialized";
          C: for my $child (@{$self-><AG::Node.childNodes>}) {
            if ($child-><AG::Node.namespaceURI>.$child-><AG::Node.localName> eq
                <Q::pg:attributeSpecification>) {
              if ($child-><M::Element.getAttributeNS> (null, 'name') eq
                  $attrName) {
                push @$r,
                     $child-><M::Element.getAttributeNS> (null, 'value');
              }
            }
          }
        }__;
##DPGElementAttribute

ElementTypeBinding:
  @Name: nullCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: ManakaiDOM|InCase
    @@Value:
      @@@is-null:1

ResourceDef:
  @For: ManakaiDOM|DOM
  @QName: DOMString
  @AliasFor: DOMMain|DOMString

IFClsETDef:
  @IFQName: DPGRulesElement
  @ClsQName: ManakaiDPGRulesElement
  @ETQName: pg|rules
  @QName:
    @@@: RulesElementType
    @@ForCheck: s|ForML

  @IFISA: DPGElement
  @ClsISA: ManakaiDPGElement

  @enDesc:
    The <XE::pg|rules> element type is used for the root element
    of the DPG rule fragment.  It <kwd:MAY> contain zero or more
    <XE::pg|rule> and / or <XE::pg|lexmode> child elements.

  @Method:
    @@Name: plCodeFragment
    @@enDesc:
      Generates a Perl code fragment from the subtree rooted by
      the node.
    @@Param:
      @@@Name: codeDocument
      @@@Type: pc|PCDocument
      @@@enDesc:
        A <IF::pc|PCDocument>.  The generated Perl code nodes will
        belong to the document.
    @@NamedParam:
      @@@Name: disResource
      @@@Type: dp|DISResourcePerl||DIS|ForLatest
      @@@enDesc:
        The <QUOTE::dis> resource object against which <Q::lang:Perl>
        code fragments, if any, are evaluated and converted into Perl code.
    @@NamedParam:
      @@@Name: contextObject
      @@@Type: DIS|NSResolverDIS||DIS|ForLatest
      @@@enDesc:
        The context where various references, such as namespace prefixes
        and relative URI references, are evaluated.  It <kwd:MUST> implement
        the <IF::DIS|NSResolverDIS> interface if there are <Q::lang:Perl>
        code fragments.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        A set of elements generated from the rules.

          {NOTE:: If the subtree contains one or more <XE::pg|embedStatement>
                  element nodes whose content is invalid, then their
                  evaluation processes might throw an exception.
          }
      @@@dx:raises:
        @@@@@: pg|VALIDITY_ERR
        @@@@enDesc:
          The source document is invalid so that one or more
          error is reported and the process has been discontinued.
      @@@PerlDef:
        __DEEP{
          no warnings 'uninitialized';

          $r = $codeDocument-><M::Document.createDocumentFragment>;

          ## --- Range operations
          
            my $or_range = sub ($$) {
    my ($r1, $r2) = @_;
    my @r1 = @$r1;
    my @r2 = @$r2;
    my ($c1, $c2);
    my $r = [];
    while (@r1 or @r2 or $c1 or $c2) {
      $c1 ||= shift @r1;
      $c2 ||= shift @r2;
      if (not $c1) {
        push @$r, $c2, @r2;
        undef $c2;
 \      @r2 = ();
      } elsif (not $c2) {
        push @$r, $c1, @r1;
        undef $c1;
 \      @r1 = ();
      } else {
        ($c1, $c2) = ($c2, $c1) if $c1->[0] > $c2->[0];
        if ($c1->[1] < $c2->[0]) {
          push @$r, $c1;
          undef $c1;
        } else {
          $c2 = [$c1->[0], $c2->[1]];
          undef $c1;
        }
      }
    }
    return $r;
  };
  
  my $add_range = sub ($$;$) {
    my ($range, $s, $e) = @_;
    return $or_range->($range, [[$s, defined $e ? $e : $s]]);
  };
  
  my $negate_range = sub ($) {
    my $range = shift;
    my $r = [];
    push @$r, [0, $range->[0]->[0] - 1] if $range->[0]->[0] > 0;
    for my $i (1..$#$range) {
      push @$r, [$range->[$i - 1]->[1] + 1, $range->[$i]->[0] - 1];
    }
    push @$r, [$range->[$#$range]->[1] + 1, "Inf"] unless $range->[$#$range]->[1] eq "Inf";
    return $r;
  };

            my $merge_adjacent_range = sub ($) {
              my $range = shift;
              my $r = [];
              push @$r, $range->[0] if @$range;
              for my $i (1..$#$range) {
                if ($r->[-1]->[1] + 1 == $range->[$i]->[0]) {
                  $r->[-1] = [$r->[-1]->[0], $range->[$i]->[1]];
                } else {
                  push @$r, $range->[$i];
                }
              }
              return $r;
            }; # merge_adjacent_range
  
  my $and_minus_ranges = sub ($$) {
    my (@ra, @rab, @rb);
    my @rangea = @{$_[0]};
    my @rangeb = @{$_[1]};
    my $rangea;
    my $rangeb;
    while (@rangea or @rangeb or $rangea or $rangeb) {
      $rangea ||= shift @rangea;
      $rangeb ||= shift @rangeb;
      if (not $rangea) {
        push @rb, $rangeb, @rangeb;
        last;
      } elsif (not $rangeb) {
        push @ra, $rangea, @rangea;
        last;
      } else {
        if ($rangea->[0] < $rangeb->[0]) {
          if ($rangea->[1] ne 'Inf' and
              $rangea->[1] < $rangeb->[0]) { ## [a .. a] .. [b ..
            push @ra, $rangea;
            $rangea = undef;
          } elsif ($rangea->[1] eq 'Inf') {
            if ($rangeb->[1] eq 'Inf') {  ## [a .. [b ..
              push @ra, [$rangea->[0], $rangeb->[0] - 1];
              push @rab, $rangeb;
              last;
            } else {                      ## [a .. [b .. b] ..
              push @ra, [$rangea->[0], $rangeb->[0] - 1];
              push @rab, $rangeb;
              $rangea = [$rangeb->[1] + 1, 'Inf'];
              $rangeb = undef;
            }
          } else {                      
            if ($rangeb->[1] eq 'Inf') {  ## [a .. [b .. a] ..
              push @ra, [$rangea->[0], $rangeb->[0] - 1];
              push @rab, [$rangeb->[0], $rangea->[1]];
              $rangeb = [$rangea->[1] + 1, 'Inf'];
              $rangea = undef;
            } else {
              if ($rangea->[1] < $rangeb->[1]) { ## [a .. [b .. a] .. b]
                push @ra, [$rangea->[0], $rangeb->[0] - 1];
                push @rab, [$rangeb->[0], $rangea->[1]];
                $rangeb = [$rangea->[1] + 1, $rangeb->[1]];
                $rangea = undef;
              } elsif ($rangea->[1] > $rangeb->[1]) { ## [a .. [b .. b] .. a]
                push @ra, [$rangea->[0], $rangeb->[0] - 1];
                push @rab, $rangeb;
                $rangea = [$rangeb->[1] + 1, $rangea->[1]];
                $rangeb = undef;
              } else {                            ## [a .. [b .. ab]]
                push @ra, [$rangea->[0], $rangeb->[0] - 1];
                push @rab, $rangeb;
                $rangea = $rangeb = undef;
              }
            }
          }
        } elsif ($rangea->[0] > $rangeb->[0]) {
          if ($rangeb->[1] ne 'Inf' and
              $rangeb->[1] < $rangea->[0]) { ## [b .. b] .. [a ..
            push @rb, $rangeb;
            $rangeb = undef;
          } elsif ($rangea->[1] eq 'Inf') {
            if ($rangeb->[1] eq 'Inf') {  ## [b .. [a ..
              push @rb, [$rangeb->[0], $rangea->[0] - 1];
              push @rab, $rangea;
              last;
            } else {                      ## [b .. [a .. b] ..
              push @rb, [$rangeb->[0], $rangea->[0] - 1];
              push @rab, [$rangea->[0], $rangeb->[1]];
              $rangea = [$rangeb->[1] + 1, 'Inf'];
              $rangeb = undef;
            }
          } else {                      
            if ($rangeb->[1] eq 'Inf') {  ## [b .. [a .. a] ..
              push @rb, [$rangeb->[0], $rangea->[0] - 1, -7];
              push @rab, $rangea;
              $rangeb = [$rangea->[1] + 1, 'Inf'];
              $rangea = undef;
            } else {
              if ($rangea->[1] < $rangeb->[1]) { ## [b .. [a .. a] .. b]
                push @rb, [$rangeb->[0], $rangea->[0] - 1,-3];
                push @rab, $rangea;
                $rangeb = [$rangea->[1] + 1, $rangeb->[1]];
                $rangea = undef;
              } elsif ($rangea->[1] > $rangeb->[1]) { ## [b .. [a .. b] .. a]
                push @rb, [$rangeb->[0], $rangea->[0] - 1,-4];
                push @rab, [$rangea->[0], $rangeb->[1],-5];
                $rangea = [$rangeb->[1] + 1, $rangea->[1]];
                $rangeb = undef;
              } else {                            ## [b .. [a .. ab]]
                push @rb, [$rangeb->[0], $rangea->[0] - 1,-6];
                push @rab, $rangea;
                $rangea = $rangeb = undef;
              }
            }
          }
        } else {
          if ($rangea->[1] eq 'Inf') {  
            if ($rangeb->[1] eq 'Inf') {          ## [[ab ..
              push @rab, $rangea;
              last;
            } else {                              ## [[ab .. b] ..
              push @rab, $rangeb;
              $rangea = [$rangeb->[1] + 1, 'Inf'];
              $rangeb = undef;
            }
          } else {
            if ($rangeb->[1] eq 'Inf') {          ## [[ab .. a] ..
              push @rab, $rangea;
              $rangeb = [$rangea->[1] + 1, 'Inf'];
              $rangea = undef;
            } else {
              if ($rangea->[1] < $rangeb->[1]) {  ## [[ab .. a] .. b]
                push @rab, $rangea;
                $rangeb = [$rangea->[1] + 1, $rangeb->[1]];
                $rangea = undef;
              } elsif ($rangea->[1] > $rangeb->[1]) { ## [[ab .. b] .. a]
                push @rab, $rangeb;
                $rangea = [$rangeb->[1] + 1, $rangea->[1]];
                $rangeb = undef;
              } else {                            ## [[ab .. ab]]
                push @rab, $rangea;
                $rangea = $rangeb = undef;
              }
            }
          }
        }
      }
    }
    return (\@ra, \@rab, \@rb);
  };

          ## --- State operations

          ## Copy a set of states.  This is used to resolve
          ## references in |lAssignmentStatement|.
          my $copy_state = sub ($$$) {
            my ($token, $original_name, $new_prefix) = @_;
            my @copy = ($original_name.$;.'0');
            my @cs;
            while (@copy) {
              my $cname = shift @copy;
              next if $token->{$new_prefix, $cname};
              my $original = $token->{$cname};
              $token->{$new_prefix, $cname} = my $new = {
                name => $new_prefix.$;.$cname,
                next_state => [],
              };
              for my $nxt (@{$original->{next_state}}) {
                push @{$new->{next_state}},
                     [$nxt->[0], $new_prefix.$;.$nxt->[1]];
                push @copy, $nxt->[1];
              }
              if ($original->{accept}) {
                push @cs, $new;
              }
            } # @copy
            return @cs;
          }; # copy_state

          my $array_uniq = sub ($) {
            my $array = shift;
            my %array = map {$_ => true} @$array;
            return [keys %array];
          }; # array_uniq

          ## Makes a DFA state from a set of NFA states
          my $make_dfa_state = sub ($@) {
            my ($token, $dfa, @src_name) = @_;
            my @src = map {$token->{$_}} @src_name;
            my $next_state = [[[], [$;.'dummy']]];
        
            my @rsb = map {@{$_->{next_state}}} @src;
            for my $rsb (@rsb) {
              my $new_next_state = [];
              RSA: for my $rsa (@$next_state) {
                if (not $rsb) {
                  push @$new_next_state, $rsa if @{$rsa->[0]};
                  next RSA;
                }
                my ($ra, $rab, $rb) = $and_minus_ranges->($rsa->[0], $rsb->[0]);
                push @$new_next_state, [$ra, $rsa->[1]] if @$ra;
                push @$new_next_state,
                     [$rab,
                      $array_uniq->([sort {$a cmp $b} @{$rsa->[1]},
                                                      $rsb->[1]]),
                     ] if @$rab;
                if (@$rb) {
                  $rsb = [$rb, $rsb->[1]];
                } else {
                  $rsb = undef;
                }
              } # RSA
              if ($rsb) {
                push @$new_next_state, [$rsb->[0], [$rsb->[1]]];
              }
              $next_state = $new_next_state;
            }
        
            my $state_name = join $;.$;, @src_name;
            $dfa->{$state_name} = {
              name => $state_name,
              next_state => @rsb ? $next_state : [],
            };
        
            for (@src) {
              if ($_->{accept}) {
                $dfa->{$state_name}->{accept} = $_->{accept};
                $dfa->{$state_name}->{value} = 1 if $_->{value};
              }
              $dfa->{$state_name}->{ignore} = 1 if $_->{ignore};
            }
          }; # make_dfa_state

          ## Converts an internal state name to a Perl name
          my $escape_state_name = sub ($) {
            my $s = shift;
            $s =~ s/([\W_])/sprintf '_%08X', ord $1/ge;
            $s =~ s/_0000001C/__/g;
            return $s;
          }; # escape_state_name
      
          ## Converts a DFA state into Perl lexer code
          my %ancestor_state;
          my $state_to_code;
          $state_to_code = sub ($$$$%) {
            my ($dfa, $parent, $state_name, $factory, %opt) = @_;
            $ancestor_state{$state_name} = 1;
        
            if ($opt{outermost} and defined $opt{default_token_name}) {
              $parent-><M::pc|PerlCodeStatements.appendStatement>
                     -><M::pc|PerlCodeUnits.appendNewPCVariable>
                         ('@', null, 'dch')
                     -><AS::pc|PerlVariable.variableScope> ('my');
            }

        my $state_block = $parent->append_new_pc_block;
        my $estate_name = $escape_state_name->($state_name);
        $state_block->label ('S'.$estate_name);
        my $state_select;
        
            if ($opt{outermost}) {
              $state_block
                 -><M::pc|PerlCodeStatements.appendStatement>
                 -><M::pc|PerlCodeUnits.appendNewPCVariable>
                     ('@', null, 'ch')
                 -><AS::pc|PerlVariable.variableScope> ('my');
            }

        if (@{$dfa->{$state_name}->{next_state}}) {
          my $spush = $state_block->append_statement;
          for ($spush->append_new_pc_function_call (undef, 'push')
                     ->append_new_pc_expression (',')) {
            $_->append_new_pc_variable ('@', undef, 'ch');
            $_->append_new_pc_variable ('$', undef, 'ch');
          }
          $state_block->parent_node->insert_before ($spush, $state_block)
            unless $opt{outermost};
              ## NOTE: This statement must be placed before the named block;
              ##       otherwise token value cannot be correctly returned
              ##       when |redo|ne.  An exception is the outermost state.
          
          for my $as ($state_block->append_statement
                                  ->append_new_pc_expression ('=')) {
            $as->append_new_pc_variable ('$', undef, 'ch')
               ->variable_scope ('my');
            for ($as->append_new_pc_expression ('->')) {
              $_->append_new_pc_variable ('$', undef, 'self');
              $_->append_atom ('_shift_char');
            }
          }
        
          $state_select = $state_block->append_new_pc_choose;
          for my $rs (@{$dfa->{$state_name}->{next_state}}) {
            my $when = $state_select->append_new_pc_when;
          
            my $cond = $when->condition;
            my $cond_and = $cond->append_new_pc_expression ('or');
            for my $range (@{$rs->[0]}) {
              if ($range->[0] == $range->[1]) {
                my $match = $cond_and->append_new_pc_expression ('==');
                $match->append_new_pc_variable ('$', undef, 'ch');
                $match->append_new_pc_number_literal ($range->[0]);
              } else {
                my $x_range = $cond_and->append_new_pc_expression ('and');
                my $x_range_s = $x_range->append_new_pc_expression ('<=');
                $x_range_s->append_new_pc_number_literal ($range->[0]);
                $x_range_s->append_new_pc_variable ('$', undef, 'ch');
                unless ($range->[1] eq 'Inf') {
                  my $x_range_e = $x_range->append_new_pc_expression ('<=');
                  $x_range_e->append_new_pc_variable ('$', undef, 'ch');
                  $x_range_e->append_new_pc_number_literal ($range->[1]);
                }
              }
            }
          
            my $when_block = $when->block;
            my $next_state_name = join $;.$;, @{$rs->[1]};
            if ($ancestor_state{$next_state_name}) {
              $when_block->append_child ($spush->clone_node (1));
              $when_block->append_statement
                         ->append_new_pc_function_call (undef, 'redo')
                         ->append_new_pc_variable
                             ('', undef, 'S'.$escape_state_name->($next_state_name));
            } else {
                      __DEEP{
                        $state_to_code
                          ->($dfa, $when_block, $next_state_name, $factory,
                             %opt, outermost => 0);
                        ## "If match, then |return|s"
                      }__;
                      
                      if ($dfa->{$state_name}->{accept}) {
                        ## "If doesn't match, then |unshift|s |ch|"
                        for ($when_block
                                 -><M::pc|PerlCodeStatements.appendStatement>
                                 -><M::pc|PerlCodeUnits.appendNewPCFunctionCall>
                                       (null, 'unshift')
                                 -><M::pc|PerlCodeUnits.appendNewPCExpression>
                                       (',')) {
                          for ($_-><M::pc|PerlCodeUnits
                                             .appendNewPCDereference> ('@')
                                 -><M::pc|PerlCodeUnits
                                             .appendNewPCExpression> ('->')) {
                            $_-><M::pc|PerlCodeUnits.appendNewPCVariable>
                                  ('$', null, 'self');
                            $_-><M::pc|PerlCodeUnits.appendBare> ('{char}');
                          }
                          $_-><M::pc|PerlCodeUnits.appendNewPCVariable>
                                    ('$', null, 'ch');
                        }
                      } # If this state is "accept"
            }
          } # for next_state
        }

        if ($dfa->{$state_name}->{accept}) {
          if ($state_select) {
            for ($state_select->append_new_pc_otherwise->block) {
              my $push_ap = $_->append_statement
                              ->append_new_pc_function_call
                                          (undef, 'unshift')
                              ->append_new_pc_expression (',');
              for ($push_ap->append_new_pc_dereference ('@')
                           ->append_new_pc_expression ('->')) {
                $_->append_new_pc_variable ('$', undef, 'self');
                $_->append_bare ('{char}');
              }
              $push_ap->append_new_pc_variable ('$', undef, 'ch');
              for ($_->append_statement->append_new_pc_expression ('=')) {
                $_->append_new_pc_variable ('$', undef, 'ch');
                $_->append_new_pc_number_literal (-2);
              }
            }
          }
          my $accept_code_parent = $state_block;
          unless ($dfa->{$state_name}->{ignore}) {
            my %value;
            if ($dfa->{$state_name}->{value}) {
              ## Removes dummy item
              $accept_code_parent->append_statement
                                 ->append_new_pc_function_call (undef, 'shift')
                                 ->append_new_pc_variable ('@', undef, 'ch');
              for ($accept_code_parent->append_statement
                                      ->append_new_pc_expression ('=')) {
                $_->append_new_pc_variable ('$', undef, 'token_val')
                  ->variable_scope ('my');
                $_->append_string_literal ('');
              }
              for ($accept_code_parent->append_new_pc_choose
                                      ->append_new_pc_when) {
                for ($_->condition->append_new_pc_expression ('>')) {
                  $_->append_new_pc_variable ('$', undef, 'ch');
                  $_->append_new_pc_number_literal (-1);
                }
                for ($_->block->append_statement
                              ->append_new_pc_function_call (undef, 'push')
                              ->append_new_pc_expression (',')) {
                          if (@{$dfa->{$state_name}->{next_state}}) {
                            for ($_
                                 -><M::pc|PerlCodeUnits.appendNewPCDereference>
                                    ('@')
                                 -><M::pc|PerlCodeUnits.appendNewPCExpression>
                                    ('->')) {
                              $_-><M::pc|PerlCodeUnits.appendNewPCVariable>
                                    ('$', null, 'self');
                              $_-><M::pc|PerlCodeUnits.appendBare> ('{char}');
                            }
                            $_-><M::pc|PerlCodeUnits.appendNewPCFunctionCall>
                                  (null, 'pop')
                              -><M::pc|PerlCodeUnits.appendNewPCVariable>
                                  ('@', null, 'ch');
                          } else {
                            $_-><M::pc|PerlCodeUnits.appendNewPCVariable>
                                  ('@', null, 'ch');
                            $_-><M::pc|PerlCodeUnits.appendNewPCVariable>
                                  ('$', null, 'ch');
                          }
                }
              }
                      for ($accept_code_parent
                             -><M::pc|PerlCodeStatements.appendNewPCWhile>) {
                        $_-><AG::pc|PCWhile.condition>
                          -><M::pc|PerlCodeUnits.appendNewPCVariable>
                              ('@', null, 'ch');
                        for ($_-><AG::pc|PCWhile.block>
                               -><M::pc|PerlCodeStatements.appendStatement>
                               -><M::pc|PerlCodeUnits.appendNewPCExpression>
                                   ('.=')) {
                          $_-><M::pc|PerlCodeUnits.appendNewPCVariable>
                                ('$', null, 'token_val');
                          $_-><M::pc|PerlCodeUnits.appendNewPCFunctionCall>
                                (null, 'chr')
                            -><M::pc|PerlCodeUnits.appendNewPCFunctionCall>
                                (null, 'shift')
                            -><M::pc|PerlCodeUnits.appendNewPCVariable>
                                ('@', null, 'ch');
                        }
                      }
              $value{value} = $accept_code_parent->append_new_pc_variable
                                                     ('$', undef, 'token_val');
                    }
                    if (defined $opt{default_token_name}) {
                      for ($accept_code_parent
                             -><M::pc|PerlCodeStatements.appendNewPCChoose>) {
                        for ($_-><M::pc|PCChoose.appendNewPCWhen>) {
                          $_-><AG::pc|PCWhen.condition>
                            -><M::pc|PerlCodeUnits.appendNewPCVariable>
                                ('@', null, 'dch');
                          for ($_-><AG::pc|PCWhen.block>) {
                            for ($_-><M::pc|PerlCodeStatements.appendStatement>
                                   -><M::pc|PerlCodeUnits
                                           .appendNewPCFunctionCall>
                                       (null, 'unshift')
                                   -><M::pc|PerlCodeUnits
                                           .appendNewPCExpression>
                                       (',')) {
                              for ($_-><M::pc|PerlCodeUnits
                                             .appendNewPCDereference> ('@')
                                     -><M::pc|PerlCodeUnits
                                             .appendNewPCExpression> ('->')) {
                                $_-><M::pc|PerlCodeUnits.appendNewPCVariable>
                                      ('$', null, 'self');
                                $_-><M::pc|PerlCodeUnits.appendBare>
                                      ('{token}');
                              }
                              my $ld = $factory
                                         -><M::pc|PCDocument.createPCExpression>
                                             ('+');
                              $ld-><M::pc|PerlCodeUnits.appendAtom> (0);
                              $ld-><M::pc|PerlCodeUnits.appendNewPCVariable>
                                     ('@', null, 'dch');
                              $_-><M::pc|PerlCodeUnits.appendNewPCLiteral> ({
                                       type => $dfa->{$state_name}->{accept},
                                       %value,
                                       location => $factory
                                            -><M::pc|PCDocument.createPCVariable>
                                                ('$', null, 'location'),
                                       location_d => $ld,
                                     });
                            }

                            my $v
                              = $factory-><M::pc|PCDocument.createPCVariable>
                                            ('$', null, 'token_val');
                            $_-><M::pc|PerlCodeStatements.appendStatement>
                              -><M::Node.appendChild>
                                  ($v-><M::Node.cloneNode> (true))
                              -><AS::pc|PerlVariable.variableScope> ('my');
                            for ($_-><M::pc|PerlCodeStatements
                                           .appendNewPCWhile>) {
                              $_-><AG::pc|PCWhile.condition>
                                -><M::pc|PerlCodeUnits.appendNewPCVariable>
                                    ('@', null, 'dch');
                              for ($_-><AG::pc|PCWhile.block>
                                     -><M::pc|PerlCodeStatements
                                             .appendStatement>
                                     -><M::pc|PerlCodeUnits
                                             .appendNewPCExpression>
                                         ('.=')) {
                                $_-><M::Node.appendChild>
                                      ($v-><M::Node.cloneNode> (true));
                                $_-><M::pc|PerlCodeUnits
                                          .appendNewPCFunctionCall>
                                      (null, 'chr')
                                  -><M::pc|PerlCodeUnits
                                          .appendNewPCFunctionCall>
                                      (null, 'shift')
                                  -><M::pc|PerlCodeUnits.appendNewPCVariable>
                                      ('@', null, 'dch');
                              }
                            }
                            $_-><M::pc|PerlCodeStatements.appendStatement>
                              -><M::pc|PerlCodeUnits.appendNewPCFunctionCall>
                                  (null, 'return')
                              -><M::pc|PerlCodeUnits.appendNewPCLiteral> ({
                                    type => $opt{default_token_name},
                                    value => $v,
                                    location => $factory
                                            -><M::pc|PCDocument.createPCVariable>
                                                ('$', null, 'location'),
                                  });
                          }
                        }
                        for ($_-><M::pc|PCChoose.appendNewPCOtherwise>
                               -><AG::pc|PCOtherwise.block>) {
                          $_-><M::pc|PerlCodeStatements.appendStatement>
                            -><M::pc|PerlCodeUnits.appendNewPCFunctionCall>
                                (null, 'return')
                            -><M::pc|PerlCodeUnits.appendNewPCLiteral> ({
                                   type => $dfa->{$state_name}->{accept},
                                   location => $factory
                                            -><M::pc|PCDocument.createPCVariable>
                                                ('$', null, 'location'),
                                   %value,
                                 });
                        }
                      }
                    } else {
                      $accept_code_parent
                        -><M::pc|PerlCodeStatements.appendStatement>
                        -><M::pc|PerlCodeUnits.appendNewPCFunctionCall>
                            (null, 'return')
                        -><M::pc|PerlCodeUnits.appendNewPCLiteral> ({
                               type => $dfa->{$state_name}->{accept},
                               location => $factory
                                            -><M::pc|PCDocument.createPCVariable>
                                                ('$', null, 'location'),
                               %value,
                             });
                    }
          } else {
            $accept_code_parent->append_statement
                       ->append_new_pc_function_call (undef, 'redo')
                       ->append_new_pc_variable
                           ('', undef, 'S'.$escape_state_name->($;.'initial'));
          }
        } elsif ($opt{outermost}) {
          if ($state_select) {
          for ($state_select->append_new_pc_when) {
            for ($_->condition->append_new_pc_expression ('==')) {
              $_->append_new_pc_variable ('$', undef, 'ch');
              $_->append_new_pc_number_literal (-1);
            }
                      my $block = $_-><AG::pc|PCWhen.block>;
                      if (defined $opt{default_token_name}) {
                        for ($block
                               -><M::pc|PerlCodeStatements.appendNewPCChoose>) {
                          for ($_-><M::pc|PCChoose.appendNewPCWhen>) {
                            $_-><AG::pc|PCWhen.condition>
                              -><M::pc|PerlCodeUnits.appendNewPCVariable>
                                  ('@', null, 'dch');
                            for ($_-><AG::pc|PCWhen.block>) {
                              for ($_-><M::pc|PerlCodeStatements.appendStatement>
                                     -><M::pc|PerlCodeUnits
                                             .appendNewPCFunctionCall>
                                         (null, 'unshift')
                                     -><M::pc|PerlCodeUnits
                                             .appendNewPCExpression>
                                         (',')) {
                                for ($_-><M::pc|PerlCodeUnits
                                               .appendNewPCDereference> ('@')
                                       -><M::pc|PerlCodeUnits
                                               .appendNewPCExpression> ('->')) {
                                  $_-><M::pc|PerlCodeUnits.appendNewPCVariable>
                                        ('$', null, 'self');
                                  $_-><M::pc|PerlCodeUnits.appendBare>
                                        ('{token}');
                                }
                                my $ld = $factory
                                         -><M::pc|PCDocument.createPCExpression>
                                             ('+');
                                $ld-><M::pc|PerlCodeUnits.appendAtom> (0);
                                $ld-><M::pc|PerlCodeUnits.appendNewPCVariable>
                                     ('@', null, 'dch');
                                $_-><M::pc|PerlCodeUnits.appendNewPCLiteral> ({
                                         type => '#EOF',
                                         location => $factory
                                            -><M::pc|PCDocument.createPCVariable>
                                                ('$', null, 'location'),
                                         location_d => $ld,
                                       });
                              }
  
                              my $v
                                = $factory-><M::pc|PCDocument.createPCVariable>
                                              ('$', null, 'token_val');
                              $_-><M::pc|PerlCodeStatements.appendStatement>
                                -><M::Node.appendChild>
                                    ($v-><M::Node.cloneNode> (true))
                                -><AS::pc|PerlVariable.variableScope> ('my');
                              for ($_-><M::pc|PerlCodeStatements
                                             .appendNewPCWhile>) {
                                $_-><AG::pc|PCWhile.condition>
                                  -><M::pc|PerlCodeUnits.appendNewPCVariable>
                                      ('@', null, 'dch');
                                for ($_-><AG::pc|PCWhile.block>
                                       -><M::pc|PerlCodeStatements
                                               .appendStatement>
                                       -><M::pc|PerlCodeUnits
                                               .appendNewPCExpression>
                                           ('.=')) {
                                  $_-><M::Node.appendChild>
                                        ($v-><M::Node.cloneNode> (true));
                                  $_-><M::pc|PerlCodeUnits
                                            .appendNewPCFunctionCall>
                                        (null, 'chr')
                                    -><M::pc|PerlCodeUnits
                                            .appendNewPCFunctionCall>
                                        (null, 'shift')
                                    -><M::pc|PerlCodeUnits.appendNewPCVariable>
                                        ('@', null, 'dch');
                                }
                              }
                              $_-><M::pc|PerlCodeStatements.appendStatement>
                                -><M::pc|PerlCodeUnits.appendNewPCFunctionCall>
                                    (null, 'return')
                                -><M::pc|PerlCodeUnits.appendNewPCLiteral> ({
                                      type => $opt{default_token_name},
                                      value => $v,
                                      location => $factory
                                            -><M::pc|PCDocument.createPCVariable>
                                                ('$', null, 'location'),
                                    });
                            }
                          }
                          for ($_-><M::pc|PCChoose.appendNewPCOtherwise>
                                 -><AG::pc|PCOtherwise.block>) {
                            $_-><M::pc|PerlCodeStatements.appendStatement>
                              -><M::pc|PerlCodeUnits.appendNewPCFunctionCall>
                                  (null, 'return')
                              -><M::pc|PerlCodeUnits.appendNewPCLiteral> ({
                                    type => '#EOF',
                                    location => $factory
                                            -><M::pc|PCDocument.createPCVariable>
                                                ('$', null, 'location'),
                                  });
                          }
                        }
                      } else { # no default token
                        $block-><M::pc|PerlCodeStatements.appendStatement>
                              -><M::pc|PerlCodeUnits.appendNewPCFunctionCall>
                                  (null, 'return')
                              -><M::pc|PerlCodeUnits.appendNewPCLiteral> ({
                                    type => '#EOF',
                                    location => $factory
                                            -><M::pc|PCDocument.createPCVariable>
                                                ('$', null, 'location'),
                                  });
                      }
                    }
                  }
                  if (defined $opt{default_token_name}) {
                    for ($state_block
                           -><M::pc|PerlCodeStatements.appendStatement>
                           -><M::pc|PerlCodeUnits.appendNewPCFunctionCall>
                                    (null, 'push')
                           -><M::pc|PerlCodeUnits.appendNewPCExpression>
                                    (',')) {
                      $_-><M::pc|PerlCodeUnits.appendNewPCVariable>
                            ('@', null, 'dch');
                      $_-><M::pc|PerlCodeUnits.appendNewPCVariable>
                            ('$', null, 'ch');
                    }
                    $state_block-><M::pc|PerlCodeStatements.appendStatement>
                                -><M::pc|PerlCodeUnits.appendNewPCFunctionCall>
                                    (null, 'redo')
                                -><M::pc|PerlCodeUnits.appendNewPCVariable>
                                    ('', null, 'S'.$estate_name);
                  } else {
                    my $chr_ch
                      = $factory-><M::pc|PCDocument.createPCFunctionCall>
                                    (null, 'chr');
                    $chr_ch-><M::pc|PerlCodeUnits.appendNewPCVariable>
                               ('$', null, 'ch');
                    $state_block-><M::pc|PerlCodeStatements.appendStatement>
                                -><M::pc|PerlCodeUnits.appendNewPCFunctionCall>
                                    (null, 'return')
                                -><M::pc|PerlCodeUnits.appendNewPCLiteral> ({
                                      type => '#INVALID',
                                      value => $chr_ch,
                                      location => $factory
                                            -><M::pc|PCDocument.createPCVariable>
                                                ('$', null, 'location'),
                                    });
                  }
        } else {
          my $push_ap = $state_block->append_statement
                                    ->append_new_pc_function_call
                                          (undef, 'unshift')
                                    ->append_new_pc_expression (',');
          for ($push_ap->append_new_pc_dereference ('@')
                       ->append_new_pc_expression ('->')) {
            $_->append_new_pc_variable ('$', undef, 'self');
            $_->append_bare ('{char}');
          }
          $push_ap->append_new_pc_variable ('$', undef, 'ch');
        }
        
            $ancestor_state{$state_name} = 0;
          }; # $state_to_code

    
          ## --- Tokenizer method template
          my $tokenizer
            = $codeDocument-><M::pc|PCDocument.createPerlSub> (null);
          $tokenizer->prototype ('$');
  my $tokenizer_param = $tokenizer->append_statement
                                  ->append_new_pc_expression ('=');
  $tokenizer_param->append_new_pc_variable ('$', undef, 'self')
                  ->variable_scope ('my');
  $tokenizer_param->append_new_pc_function_call (undef, 'shift');
  my $if_stack = $tokenizer->append_new_pc_choose
                           ->append_new_pc_when;
  my $stack_array = $if_stack->condition->append_new_pc_dereference ('@');
  for ($stack_array->append_new_pc_expression ('->')) {
    $_->append_new_pc_variable ('$', undef, 'self');
    $_->append_bare ('{token}');
  }
  $if_stack->block
           ->append_statement
           ->append_new_pc_function_call (undef, 'return')
           ->append_new_pc_function_call (undef, 'shift')
           ->append_child ($stack_array->clone_node (1));

          ## --- For each child elements (rule or lexmode)...
          my %lexmodes;    # defined tokenizers
          my $initial_lexmode;
          my $root_lexmode_number = 0;
          my %rules;       # defined parser rules
          my %root_rules;  # defined |standalone| parser rules
          my %external_rules; # defined |external| parser rules
          my %token_error;
          my $default_token_error;

          B: for my $cel (@{$self-><AG::Node.childNodes>}) {
            my $xuri = $cel->namespace_uri . $cel->local_name;

            ## -- Rule element - adds reference to hash
            if ($xuri eq <Q::pg:rule>) {
              my $name = $cel->get_attribute_ns (undef, 'name');
              $rules{$name} = {source => $cel, param => []};
              $external_rules{$name} = true
                if $cel-><M::Element.getAttributeNS> (null, 'isExternal');
              $root_rules{$name}
                = $cel-><M::DPGElementAttribute.dpgGetAttribute> ('perl-name')
                || $name
                if $cel-><M::DPGElementAttribute.dpgGetAttribute>
                           ('standalone') or
                   $cel-><M::DPGElementAttribute.dpgGetAttribute>
                           ('recursive') or
                   $external_rules{$name};
      
              ## Creates a list of parameters
              C: for my $paramspec (@{$cel->child_nodes}) {
                next C unless $paramspec->namespace_uri eq <Q::pg:>;
                next C unless $paramspec->local_name eq 'parameterDeclaration';
                push @{$rules{$name}->{param}},
                     $paramspec->get_attribute_ns (undef, 'name');
              }

            ## -- Token error element - error handling code
            } elsif ($xuri eq <Q::pg:tokenError>) {
              my $name = $cel-><M::Element.getAttributeNS> (null, 'name');
              $token_error{$name} = {
                source => $cel,
                param => [],
              };
              if ($cel-><M::DPGElementAttribute.dpgGetAttribute> ('default')) {
                $default_token_error = $name;
              }
      
              ## Creates a list of parameters
              C: for my $paramspec (@{$cel->child_nodes}) {
                next C unless $paramspec->namespace_uri eq <Q::pg:>;
                next C unless $paramspec->local_name eq 'parameterDeclaration';
                push @{$token_error{$name}->{param}},
                     $paramspec-><M::Element.getAttributeNS> (null, 'name');
              }

            ## -- Lexmode element - generate tokenizer
            } elsif ($xuri eq <Q::pg:lexmode>) {
              my $name = $cel-><M::Element.getAttributeNS> (null, 'name');
              if ($lexmodes{$name}) {
                __UNDEEP{__DOMCore:ERROR{pg|unique-lexmode-name-error::
                  pg|name => {$name},
                  pg|element => {$cel},
                }__}__;
              }

              my $supermodes
                = $cel-><M::DPGElementAttribute.dpgGetAttributeList>
                          ('extends');

              my $default_token_name;
              my %token;
              $lexmodes{$name} = \%token;
              for my $rname (@$supermodes) {
                unless ($lexmodes{$rname}) {
                  __UNDEEP{__DOMCore:ERROR{pg|lexmode-not-defined-error::
                    pg|name => {$rname},
                    pg|element => {$cel},
                  }__}__;
                } else {
                  %token = (%token, %{$lexmodes{$rname}});
                }
              }
              $token{$;.'initial'} = {
                name => $;.'initial',
                next_state => [
                  map {@{$lexmodes{$_}->{$;.'initial'}->{next_state}}
                  } @$supermodes
                ],
              };

      for my $tel (grep {$_->node_type == $_->ELEMENT_NODE} @{$cel->child_nodes}) {
        my $xuri = $tel->namespace_uri . $tel->local_name;
        if ($xuri eq <Q::pg:lAssignmentStatement>) {
          my $sname = $tel->get_attribute_ns (undef, 'name');
          my $is_variable = $tel-><M::Element.getAttributeNS>
                                    (null, 'isVariable');
          $sname = '$' . $sname if $is_variable;
          my $i = 0;
          if ($token{$sname, $i}) {
            die qq<"$sname" is already defined>;
            ## TODO: exception
          }
          my $s0 = $token{$sname, $i} = {
            name => $sname.$;.$i,
            next_state => [],
          };
          my @current_state = ($s0);
          my $ignore = $tel-><M::DPGElementAttribute.dpgGetAttribute> ('ignore');
          my $value = $tel-><M::DPGElementAttribute.dpgGetAttribute> ('value');
          for my $lel (grep {$_->node_type == $_->ELEMENT_NODE} @{$tel->child_nodes}) {
            my $xuri = $lel->namespace_uri . $lel->local_name;
            if ($xuri eq <Q::pg:charClass> or $xuri eq <Q::pg:anyChar>) {
              my $range = [];
              if ($xuri eq <Q::pg:charClass>) {
                for my $mel (grep {$_->node_type == $_->ELEMENT_NODE} @{$lel->child_nodes}) {
                  my $xuri = $mel->namespace_uri . $mel->local_name;
                  if ($xuri eq <Q::pg:string>) {
                    $range = $add_range->($range, ord $mel->text_content);
                  } elsif ($xuri eq <Q::pg:charRange>) {
                    $range = $add_range->($range, $mel->get_attribute_ns (undef, 'start'),
                                                $mel->get_attribute_ns (undef, 'end'));
                  }
                }
                $range = $merge_adjacent_range->($range);
                if ($lel->get_attribute_ns (undef, 'negative')) {
                  $range = $negate_range->($range);
                }
              } else { # pg:anyChar
                $range = [0, 'Inf'];
              }
              
              my $new_s = {
                name => $sname.$;.(++$i),
                next_state => [],
              };
              my $v = $lel->get_attribute_ns (undef, 'occurence');
              if ($v eq 'zeromore') {
                $token{$new_s->{name}} = $new_s;
                push @{$new_s->{next_state}}, [$range, $new_s->{name}];
                for my $s (@current_state) {
                  push @{$s->{next_state}}, [$range, $new_s->{name}];
                }
                push @current_state, $new_s;
              } elsif ($v eq 'zeroone') {
                $token{$new_s->{name}} = $new_s;
                for my $s (@current_state) {
                  push @{$s->{next_state}}, [$range, $new_s->{name}];
                }
                push @current_state, $new_s;
              } elsif ($v eq 'onemore') {
                $token{$new_s->{name}} = $new_s;
                push @{$new_s->{next_state}}, [$range, $new_s->{name}];
                for my $s (@current_state) {
                  push @{$s->{next_state}}, [$range, $new_s->{name}];
                }
   \            @current_state = ($new_s);
              } else { # one
                $token{$new_s->{name}} = $new_s;
                for my $s (@current_state) {
                  push @{$s->{next_state}}, [$range, $new_s->{name}];
                }
   \            @current_state = ($new_s);
              }
            } elsif ($xuri eq <Q::pg:lVariableRef>) {
              my $rrulename = '$'.$lel->get_attribute_ns (undef, 'name');
              my @new_current_state;
              if ($token{$rrulename, 0}) {
   \            @new_current_state
                  = $copy_state->(\%token, $rrulename => $sname.$;.(++$i));
              } else {
                die "$rrulename is not defined";
                ## TODO: exception
              } 
              my $v = $lel->get_attribute_ns (undef, 'occurence');
              if ($v eq 'zeromore') {
                for my $s (@current_state, @new_current_state) {
                  push @{$s->{next_state}},
   \                   @{$token{$sname, $i, $rrulename, 0}->{next_state}};
                }
                push @current_state, @new_current_state;
              } elsif ($v eq 'zeroone') {
                for my $s (@current_state) {
                  push @{$s->{next_state}},
   \                   @{$token{$sname, $i, $rrulename, 0}->{next_state}};
                }
                push @current_state, @new_current_state;
              } elsif ($v eq 'onemore') {
                for my $s (@current_state, @new_current_state) {
                  push @{$s->{next_state}},
   \                   @{$token{$sname, $i, $rrulename, 0}->{next_state}};
                }
   \            @current_state = @new_current_state;
              } else { # one
                for my $s (@current_state) {
                  push @{$s->{next_state}},
   \                   @{$token{$sname, $i, $rrulename, 0}->{next_state}};
                }
   \            @current_state = @new_current_state;
              }
            } # $xuri
          } # $lel
          push @{$token{$;.'initial'}->{next_state}}, @{$s0->{next_state}}
            unless $is_variable;
          for my $s (@current_state) {
            $s->{accept} = $sname;
            $s->{ignore} = $ignore if $ignore;
            $s->{value} = $value if $value;
          }
                } elsif ($xuri eq <Q::pg:lQDefaultTokenStatement>) {
                  $default_token_name
                    = $tel-><M::Element.getAttributeNS> (null, 'name');
                } # xuri
              }

              next B unless $cel-><M::DPGElementAttribute.dpgGetAttribute>
                                     ('standalone') or
                            $initial_lexmode eq $name;
              $root_lexmode_number++;

      my %dfa;
      my @req_state = ([$;.'initial']);
      while (@req_state) {
        my $req_state = shift @req_state;
        my $req_state_name = join $;.$;, @$req_state;
        next if $dfa{$req_state_name};
        $make_dfa_state->(\%token, \%dfa, @$req_state);
        for (@{$dfa{$req_state_name}->{next_state}}) {
          push @req_state, $_->[1];
        }
      }

              my $scan_sub = $tokenizer-><M::Node.cloneNode> (true);
              $scan_sub-><M::pc|PerlSub.addPerlName> ('_scan_'.$name);
              for ($scan_sub-><M::pc|PerlCodeStatements.appendStatement>
                     ->append_new_pc_expression ('=')) {
        $_->append_new_pc_variable ('$', undef, 'ch')
          ->variable_scope ('my');
        $_->append_new_pc_number_literal (-2);
      }
      
              ## Set the scanner as initial one if desired
              if ($cel-><M::DPGElementAttribute.dpgGetAttribute> ('initial')) {
                $initial_lexmode = $scan_sub;
              } else {
                $initial_lexmode ||= $scan_sub;
              }

              ## "Copies current location information"
              for ($scan_sub-><M::pc|PerlCodeStatements.appendStatement>
                            -><M::pc|PerlCodeUnits.appendNewPCExpression>
                                ('=')) {
                $_-><M::pc|PerlCodeUnits.appendNewPCVariable>
                      ('$', null, 'location')
                  -><AS::pc|PerlVariable.variableScope> ('my');
                $_-><M::pc|PerlCodeUnits.appendBare>
                      ('{%{$self->{location}},
                         char_d => 0+@{$self->{char}}}');
              }

              __DEEP{
                $state_to_code->(\%dfa, $scan_sub, $;.'initial',
                                 $codeDocument, outermost => 1,
                                 default_token_name => $default_token_name);
              }__;
              $r-><M::Node.appendChild> ($scan_sub);
            } # xuri
          } # B

          $state_to_code = null;


          ## --- Generates parser methods

          ## Template for 'get next token' statements
          my $next_token_code = $codeDocument->create_pc_statement;
          for ($next_token_code->append_new_pc_expression ('=')) {
            $_->append_new_pc_variable ('$', undef, 'token');
            for ($_->append_new_pc_expression ('->')) {
              $_->append_new_pc_variable ('$', undef, 'self');
              if ($root_lexmode_number > 1) {
                $_-><M::pc|PerlCodeUnits.appendBare> ('{scanner}');
                $_-><M::pc|PerlCodeUnits.appendBare> ('($self)');
              } elsif ($root_lexmode_number > 0) {
                $_-><M::pc|PerlCodeUnits.appendBare>
                      ($initial_lexmode-><AG::pc|PerlSub.pcLocalName>);
              } else {
                $_-><M::pc|PerlCodeUnits.appendBare> ('_shift_token');
              }
            }
          }

          ## Error handling code
          unless ($default_token_error) {
            $default_token_error = $;.'default-token-error';
            my $root = $codeDocument-><M::pc|PCDocument.createPCBlock>;
            for ($root-><M::pc|PerlCodeStatements.appendStatement>
                      -><M::pc|PerlCodeUnits.appendNewPCFunctionCall>
                          (null, 'die')
                      -><M::pc|PerlCodeUnits.appendNewPCExpression> ('->')) {
              $_-><M::pc|PerlCodeUnits.appendNewPCVariable>
                          ('$', null, 'token');
              $_-><M::pc|PerlCodeUnits.appendBare> ('{type}');
            }
            $token_error{$default_token_error} = {
              code => $root,
              param => [],
            };
          }

          ## Converts an expression in rule block into Perl expression
          my $match_block_ids = {};
          my $rexpression_to_code = sub ($$;%) {
            my ($parent, $source_parent, %opt) = @_;
    $parent = $parent->append_new_pc_expression (',');
    C: for my $child (@{$source_parent->child_nodes}) {
      next C unless $child->node_type == $child->ELEMENT_NODE;
      my $xuri = $child->namespace_uri . $child->local_name;
      if ($xuri eq <Q::pg:memberRef>) {
        my $context = $parent->append_new_pc_expression ('->');
        D: for my $child (@{$child->child_nodes}) {
          next D unless $child->node_type == $child->ELEMENT_NODE;
          my $xuri = $child->namespace_uri . $child->local_name;
          if ($xuri eq <Q::pg:variable>) {
            $context->append_new_pc_variable
              ('$', undef, $child->get_attribute_ns (undef, 'name'));
          } elsif ($xuri eq <Q::pg:member>) {
            $context->append_bare ('{'.$child->get_attribute_ns (undef, 'name').'}');
          }
        }
      } elsif ($xuri eq <Q::pg:string>) {
        $parent->append_string_literal ($child->text_content);
              } # xuri
            }
          }; # rexpression_to_code
  
          ## Converts a statement in rule block into Perl code
          my $block_id = 0;
          my $rstatement_to_code;
          $rstatement_to_code = sub ($$$$$$;%) {
            my ($parent, $statement, $next_token_required, $rules, $root_rules,
                $factory, %opt) = @_;
            my $xuri = $statement->namespace_uri . $statement->local_name;
            if ($xuri eq <Q::pg:matchStatement>) {
              my $match_parent = $parent;
              my $match_occur = $statement-><M::Element.getAttributeNS>
                                              (null, 'occurence');
      if ($match_occur eq 'onemore') {
        $match_parent = $match_parent->append_new_pc_block;
        for ($match_parent->append_statement->append_new_pc_expression ('=')) {
          $_->append_new_pc_variable ('$', undef, 'has_content')
            ->variable_scope ('my');
          $_->append_new_pc_number_literal (0);
        }
      }
      
      my $match_block_id = 0;
      if ($match_occur eq 'zeromore' or $match_occur eq 'onemore') {
        $match_parent = $match_parent->append_new_pc_block;
        $match_parent->label ('MATCH_' . ($match_block_id = ++$block_id));
                my $bname
                  = $statement
                      -><M::DPGElementAttribute.dpgGetAttribute> ('name');
                $match_block_ids->{$bname} = $match_block_id if $bname;
      }
      
      my $match_choose = $match_parent->append_new_pc_choose;
      my $token_type_var = $factory->create_pc_expression ('->');
      $token_type_var->append_new_pc_variable ('$', undef, 'token');
      $token_type_var->append_bare ('{type}');
      my $has_sep;       ## There is a :separator block
      my $has_sep_term;  ## There is a :separator:terminator? block
      C: for my $child (@{$statement->child_nodes}) {
        next C unless $child->node_type == $child->ELEMENT_NODE;
        my $xuri = $child->namespace_uri . $child->local_name;
        if ($xuri eq <Q::pg:matchBlock>) {
          my $token_name = $child->get_attribute_ns (undef, 'token');
          if ($child-><M::Element.getAttributeNS> (null, 'isReservedToken')) {
            $token_name = '#' . $token_name;
          }

          my $cond = $factory-><M::pc|PCDocument.createPCExpression> ('eq');
          $cond-><M::Node.appendChild>
                   ($token_type_var-><M::Node.cloneNode> (true));
          $cond-><M::pc|PerlCodeUnits.appendStringLiteral> ($token_name);
          if ($child-><M::Element.getAttributeNS> (null, 'valueOperation') eq
              '==') {
            for ($factory-><M::pc|PCDocument.createPCExpression> ('and')) {
              $_-><M::Node.appendChild> ($cond);
              for ($_-><M::pc|PerlCodeUnits.appendNewPCExpression> ('eq')) {
                for ($_-><M::pc|PerlCodeUnits.appendNewPCExpression> ('->')) {
                  $_-><M::pc|PerlCodeUnits.appendNewPCVariable>
                    ('$', null, 'token');
                  $_-><M::pc|PerlCodeUnits.appendBare> ('{value}');
                }
                $_-><M::pc|PerlCodeUnits.appendStringLiteral>
                  ($child-><M::Element.getAttributeNS> (null, 'value'));
              }
              $cond = $_;
            }
          }
          
          my $is_sep = $child-><M::DPGElementAttribute.dpgGetAttribute>
                                                    ('separator');
          my $token_parent;
          unless ($is_sep) {
            for ($match_choose->append_new_pc_when) {
              $_-><AG::pc|PCWhen.condition>
                -><M::Node.appendChild> ($cond);
              $token_parent = $_->block;
            }
            if ($match_occur eq 'onemore') {
              for ($token_parent->append_statement->append_new_pc_expression ('=')) {
                $_->append_new_pc_variable ('$', undef, 'has_content');
                $_->append_new_pc_number_literal (1);
              }
            }
          } else { # separator
            $has_sep = 1;
                    if ($child-><M::DPGElementAttribute.dpgGetAttribute>
                                                             ('terminator')) {
                      ## BUG: |?| occurence not checked.
                      $has_sep_term = true;
                    }
            for ($match_parent->append_new_pc_choose) {
              for ($_->append_new_pc_when) {
                $_-><AG::pc|PCWhen.condition>
                  -><M::Node.appendChild> ($cond);
                $token_parent = $_->block;
              }
              for ($_->append_new_pc_otherwise->block) {
                $_->append_statement
                  ->append_new_pc_function_call (undef, 'last')
                  ->append_new_pc_variable ('', undef, 'MATCH_'.$match_block_id);
              }
            }
          }
          
                  ## Child statements
                  $next_token_required = 1;
                  D: for my $child (@{$child-><AG::Node.childNodes>}) {
                    next D unless $child-><AG::Node.nodeType> ==
                                  <C::Node.ELEMENT_NODE>;
                    __DEEP{
                      ($next_token_required, undef)
                        = $rstatement_to_code
                            ->($token_parent, $child, $next_token_required,
                               $rules, $root_rules, $factory, %opt);
                    }__;
                  }
          
          if ($next_token_required) {
            $token_parent->append_child ($next_token_code->clone_node (1));
            $next_token_required = 0;
          }

          if ($is_sep and
              ($match_occur eq 'zeromore' or $match_occur eq 'onemore')) {
            $token_parent-><M::pc|PerlCodeStatements.appendStatement>
                  -><M::pc|PerlCodeUnits.appendNewPCFunctionCall>
                                 (null, 'redo')
                  -><M::pc|PerlCodeUnits.appendNewPCVariable>
                                 ('', null, 'MATCH_'.$match_block_id);
          }
    
        } elsif ($xuri eq <Q::pg:matchElseBlock>) {
          my $token_parent
            = $match_choose-><M::pc|PCChoose.appendNewPCOtherwise>
                           -><AG::pc|PCOtherwise.block>;
          
          ## Child statements
          $next_token_required = false;
          D: for my $child (@{$child->child_nodes}) {
            next D unless $child->node_type == $child->ELEMENT_NODE;
            __DEEP{
              ($next_token_required, undef)
                = $rstatement_to_code
                    ->($token_parent, $child, $next_token_required,
                       $rules, $root_rules, $factory, %opt);
            }__;
            ## NOTE: |pg:matchElseBlock| should not contain
            ##       any statement which affects on |next_token_required|
            ##       status; its result is undefined.
          }

          ## NOTE: Interaction between |pg:matchElseBlock| and
          ##       occurences other than |zeroone| is unknown.
        } # $xuri
      } # pc:matchStatement children
      
      if (not $match_occur or $match_occur eq 'onemore') {
        my $err_block = $match_choose->append_new_pc_otherwise->block;
        if ($match_occur eq 'onemore') {
          $err_block = $err_block->append_new_pc_choose->append_new_pc_when->block;
          for ($err_block->parent_node->condition->append_new_pc_expression ('==')) {
            $_->append_new_pc_variable ('$', undef, 'has_content');
            $_->append_new_pc_number_literal (0);
          }
        }

                if ($has_sep_term) { ## :separator :terminator?
                  $err_block-><M::pc|PerlCodeStatements.appendStatement>
                            -><M::pc|PerlCodeUnits.appendNewPCFunctionCall>
                                (null, 'last')
                            -><M::pc|PerlCodeUnits.appendNewPCVariable>
                                ('', null, 'MATCH_'.$match_block_id);
                } else {
                  my $terr_name = $default_token_error;
                  unless ($token_error{$terr_name}->{code}) {
                    ## Child statements
                    $token_error{$terr_name}->{code}
                      = $factory-><M::pc|PCDocument.createPCBlock>;
                    C: for my $child (@{$token_error{$terr_name}->{source}
                                              -><AG::Node.childNodes>}) {
                      next C unless $child-><AG::Node.nodeType> ==
                                    <C::Node.ELEMENT_NODE>;
                      __DEEP{
                        $rstatement_to_code
                          ->($token_error{$terr_name}->{code}, $child, true,
                             $rules, $root_rules, $factory, %opt);
                      }__;
                    }
                  }
                  $err_block-><M::Node.appendChild>
                                ($token_error{$terr_name}->{code}
                                              -><M::Node.cloneNode> (true));
          
                  my %param;
                  C: for my $child (@{$statement-><AG::Node.childNodes>}) {
                    if ($child-><AG::Node.namespaceURI> .
                        $child-><AG::Node.localName> eq
                        <Q::pg:parameterSpecification>) {
                      $param{$child-><M::Element.getAttributeNS>
                                       (null, 'name')} = $child;
                    }
                  }
          
                  my $block_first = $err_block-><AG::Node.firstChild>;
                  for my $param_name (reverse @{$token_error{$terr_name}
                                                      ->{param}}) {
                    $block_first = $err_block-><M::Node.insertBefore>
                             ($factory-><M::pc|PCDocument.createPCStatement>,
                              $block_first);
                    for ($block_first-><M::pc|PerlCodeUnits
                                            .appendNewPCExpression> ('=')) {
                      $_-><M::pc|PerlCodeUnits.appendNewPCVariable>
                                ('$', null, $param_name)
                        -><AS::pc|PerlVariable.variableScope> ('my');
                      if ($param{$param_name}) {
                        $rexpression_to_code->($_, $param{$param_name});
                      } else {
                        $_-><M::pc|PerlCodeUnits.appendAtom> ('undef');
                      }
                    }
                  }
                } # no has_sep_term
              }
      
      if (not $has_sep and ($match_occur eq 'zeromore' or $match_occur eq 'onemore')) {
        for ($match_choose->append_new_pc_otherwise->block) {
                
                         $_-><M::pc|PerlCodeStatements.appendStatement>
                           -><M::pc|PerlCodeUnits.appendNewPCFunctionCall>
                               (null, 'last')
                           -><M::pc|PerlCodeUnits.appendNewPCVariable>
                               ('', null, 'MATCH_'.$match_block_id);
        }
        $match_parent->append_statement
                     ->append_new_pc_function_call (undef, 'redo')
                     ->append_new_pc_variable ('', undef, 'MATCH_'.$match_block_id);
      }

              return 0; # next_token_required == 0

            } elsif ($xuri eq <Q::pg:embedStatement>) {
              my $lang = $statement->get_attribute_ns (undef, 'type');
              if ($lang eq <Q::lang:Perl>) {
                my %param;
                my $source;
                C: for my $child (@{$statement->child_nodes}) {
                  next C unless $child->node_type == $child->ELEMENT_NODE;
                  my $xuri = $child-><AG::Node.namespaceURI>
                           . $child-><AG::Node.localName>;
                  if ($xuri eq <Q::pg:parameterSpecification>) {
                    $param{$child-><M::Element.getAttributeNS> (undef, 'name')}
                      = $child;
                  } elsif ($xuri eq <Q::pg:embedBlock>) {
                    $source = $child-><AG::Node.textContent>;
                  }
                }

                my $plcode = $opt{dis_resource}
                               -><M::dp|DISResourcePerl||DIS|ForLatest
                                                .plPreprocessPerlCode>
                                 ($source,
                                  namespace_context => $opt{ns_context});

                my $dparent = $parent-><AG::Node.ownerDocument>
                                   -><M::pc|PCDocument.createPCExpression> (',');
                for (keys %param) {
                  $rexpression_to_code
                    ->($dparent, $param{$_},
                       dis_resource => $opt{dis_resource},
                       match_block_id => $opt{match_block_id});
                  $plcode-><M::pc|PerlCode.replaceVariable>
                    ('$'.$_ => $dparent-><AG::Node.lastChild>);
                }

                $parent-><M::pc|PerlCodeStatements.appendCodeFragment> ($plcode);
                return $next_token_required;
              } else {
                die qq<Lexical content type <$lang> is not supported>;
                ## TODO: exception
              }

            } elsif ($xuri eq <Q::pg:myStatement>) {
              my $name = $statement-><M::Element.getAttributeNS> (null, 'name');
              $parent-><M::pc|PerlCodeStatements.appendStatement>
                     -><M::pc|PerlCodeUnits.appendNewPCVariable>
                         ('$', null, $name)
                     -><AS::pc|PerlVariable.variableScope> ('my');

              return $next_token_required;
    
    } elsif ($xuri eq <Q::pg:ruleRefStatement>) {
      my $rule_name = $statement->get_attribute_ns (undef, 'name');
      if ($rules->{$rule_name}) {
        if ($root_rules->{$rule_name}) {
                  if (not $next_token_required or
                      $statement-><M::DPGElementAttribute.dpgGetAttribute>
                                    ('unshift-current-token')) {
                    for ($parent-><M::pc|PerlCodeStatements.appendStatement>
                                -><M::pc|PerlCodeUnits.appendNewPCFunctionCall>
                                    (null, 'unshift')
                                -><M::pc|PerlCodeUnits.appendNewPCExpression>
                                    (',')) {
                      for ($_-><M::pc|PerlCodeUnits.appendNewPCDereference>
                                 ('@')
                             -><M::pc|PerlCodeUnits.appendNewPCExpression>
                                 ('->')) {
                        $_-><M::pc|PerlCodeUnits.appendNewPCVariable>
                              ('$', null, 'self');
                        $_-><M::pc|PerlCodeUnits.appendBare> ('{token}');
                      }
                      $_-><M::pc|PerlCodeUnits.appendNewPCVariable>
                            ('$', null, 'token');
                    }
                  }
       
          
          my $param_spec_list;
          for ($parent->append_statement->append_new_pc_apply) {
            for ($_->append_new_pc_expression ('->')) {
              $_->append_new_pc_variable ('$', undef, 'self');
              $_->append_bare ('_parse_' . $root_rules->{$rule_name});
            }
            $param_spec_list = $_->append_new_pc_expression (',');
          }
          
          my %param;
          C: for my $child (@{$statement->child_nodes}) {
            next C unless $child->node_type == $child->ELEMENT_NODE;
            if ($child->namespace_uri . $child->local_name eq
                <Q::pg:parameterSpecification>) {
              $param{$child->get_attribute_ns (undef, 'name')} = $child;
            }
          }
          
          for my $param_name (@{$rules->{$rule_name}->{param}}) {
            if ($param{$param_name}) {
              $rexpression_to_code->($param_spec_list, $param{$param_name});
            } else {
              $param_spec_list->append_atom ('undef');
            }
          }
          
                  return 1; # next_token_required == 1
                } else { # not a standalone rule
                  my $block;
                  $next_token_required = false
                    if $statement-><M::DPGElementAttribute.dpgGetAttribute>
                                     ('unshift-current-token');
                  unless ($rules->{$rule_name}->{code}
                                ->[$next_token_required += 0]) {
                    $block = $parent-><M::pc|PerlCodeStatements
                                         .appendNewPCBlock>;
                    $rules->{$rule_name}->{code}->[$next_token_required]
                      = [$block, $next_token_required]; # prevent infinite loop
                    my $o_next_token_required = $next_token_required;
            
                    ## Child statements
                    C: for my $child (@{$rules->{$rule_name}->{source}
                                              -><AG::Node.childNodes>}) {
                      next C unless $child-><AG::Node.nodeType> ==
                                    <C::Node.ELEMENT_NODE>;
                      __DEEP{
                        ($next_token_required, undef)
                          = $rstatement_to_code
                              ->($block, $child,
                                 $next_token_required,
                                 $rules, $root_rules, $factory, %opt);
                      }__;
                    }
                    $rules->{$rule_name}->{code}->[$o_next_token_required]
                      = [$block-><M::Node.cloneNode> (true),
                         $next_token_required];
                  } else {
                    $block = $parent-><M::Node.appendChild>
                       ($rules->{$rule_name}->{code}
                              ->[$next_token_required]->[0]
                              -><M::Node.cloneNode> (true));
                    $next_token_required
                      = $rules->{$rule_name}->{code}
                              ->[$next_token_required]->[1];
                  }
          
                  my %param;
                  C: for my $child (@{$statement-><AG::Node.childNodes>}) {
                    if ($child-><AG::Node.namespaceURI> .
                        $child-><AG::Node.localName> eq
                        <Q::pg:parameterSpecification>) {
                      $param{$child-><M::Element.getAttributeNS>
                                       (null, 'name')} = $child;
                    }
                  }
          
                  my $block_first = $block-><AG::Node.firstChild>;
                  for my $param_name (reverse @{$rules->{$rule_name}
                                                      ->{param}}) {
                    $block_first = $block-><M::Node.insertBefore>
                             ($factory-><M::pc|PCDocument.createPCStatement>,
                              $block_first);
                    for ($block_first-><M::pc|PerlCodeUnits
                                            .appendNewPCExpression> ('=')) {
                      $_-><M::pc|PerlCodeUnits.appendNewPCVariable>
                                ('$', null, $param_name)
                        -><AS::pc|PerlVariable.variableScope> ('my');
                      if ($param{$param_name}) {
                        $rexpression_to_code->($_, $param{$param_name});
                      } else {
                        $_-><M::pc|PerlCodeUnits.appendAtom> ('undef');
                      }
                    }
                  }
            
                  return $next_token_required;
                }

                return 1; # $next_token_required == 1
              } else {
                __UNDEEP{
                  my $continue = __DOMCore:ERROR{pg|rule-not-defined-error::
                    pg|name => {$rule_name},
                    pg|element => {$statement},
                  }__;
                  unless ($continue) {
                    __EXCEPTION{pg|VALIDITY_ERR::
                      
                    }__;
                  }
                }__;
              }

            } elsif ($xuri eq <Q::pg:qLexmodeStatement>) {
              for ($parent-><M::pc|PerlCodeStatements.appendStatement>
                          -><M::pc|PerlCodeUnits.appendNewPCExpression>
                              ('=')) {
                for ($_-><M::pc|PerlCodeUnits.appendNewPCExpression>
                           ('->')) {
                  $_-><M::pc|PerlCodeUnits.appendNewPCVariable>
                        ('$', null, 'self');
                  $_-><M::pc|PerlCodeUnits.appendBare> ('{scanner}');
                }
                for ($_-><M::pc|PerlCodeUnits.appendNewPCApply>) {
                  for ($_-><M::pc|PerlCodeUnits.appendNewPCExpression>
                             ('->')) {
                    $_-><M::pc|PerlCodeUnits.appendNewPCVariable>
                          ('$', null, 'self');
                    $_-><M::pc|PerlCodeUnits.appendBare> ('can');
                  }
                  $_-><M::pc|PerlCodeUnits.appendStringLiteral>
                        ('_scan_'.
                         $statement-><M::Element.getAttributeNS>
                                       (null, 'name'));
                }
              }
              return $next_token_required;
                     ## ISSUE: Is this correct? Or 1?

            } elsif ($xuri eq <Q::pg:qRequiresNextTokenStatement>) {
              return true;

    } elsif ($xuri eq <Q::pg:assignmentStatement>) {
      my $assign = $parent->append_statement->append_new_pc_expression ('=');
      my $lvalue = $statement->first_child;
      if ($lvalue->namespace_uri . $lvalue->local_name eq <Q::pg:memberRef>) {
        my $context = $assign->append_new_pc_expression ('->');
        C: for my $child (@{$lvalue->child_nodes}) {
          my $xuri = $child->namespace_uri . $child->local_name;
          if ($xuri eq <Q::pg:variable>) {
            $context->append_new_pc_variable
              ('$', undef, $child->get_attribute_ns (undef, 'name'));
          } elsif ($xuri eq <Q::pg:member>) {
            $context->append_bare ('{'.$child->get_attribute_ns (undef, 'name').'}');
          }
        }
      }
              return $next_token_required;

            } elsif ($xuri eq <Q::pg:ifTrueStatement>) {
              for ($parent-><M::pc|PerlCodeStatements.appendNewPCChoose>
                          -><M::pc|PCChoose.appendNewPCWhen>) {
                $_-><AG::pc|PCWhen.condition>
                  -><M::pc|PerlCodeUnits.appendNewPCVariable>
                      ('$', null, $statement-><M::Element.getAttributeNS>
                                                (null, 'name'));
                ## Child statements
                my $parent = $_-><AG::pc|PCWhen.block>;
                D: for my $child (@{$statement-><AG::Node.childNodes>}) {
                  next D unless $child-><AG::Node.nodeType> ==
                                <C::Node.ELEMENT_NODE>;
                  __DEEP{
                    ($next_token_required, undef)
                        = $rstatement_to_code
                            ->($parent, $child, $next_token_required,
                               $rules, $root_rules, $factory, %opt);
                  }__;
                }
              }
              return $next_token_required; ## ISSUE: Correct?

            } elsif ($xuri eq <Q::pg:returnStatement>) {
              ## ISSUE: |return| variable does not work with return
              ##        statements.
              unless ($next_token_required) {
                    for ($parent-><M::pc|PerlCodeStatements.appendStatement>
                                -><M::pc|PerlCodeUnits.appendNewPCFunctionCall>
                                    (null, 'unshift')
                                -><M::pc|PerlCodeUnits.appendNewPCExpression>
                                    (',')) {
                      for ($_-><M::pc|PerlCodeUnits.appendNewPCDereference>
                                 ('@')
                             -><M::pc|PerlCodeUnits.appendNewPCExpression>
                                 ('->')) {
                        $_-><M::pc|PerlCodeUnits.appendNewPCVariable>
                              ('$', null, 'self');
                        $_-><M::pc|PerlCodeUnits.appendBare> ('{token}');
                      }
                      $_-><M::pc|PerlCodeUnits.appendNewPCVariable>
                            ('$', null, 'token');
                    }
              }
              $parent-><M::pc|PerlCodeStatements.appendStatement>
                     -><M::pc|PerlCodeUnits.appendNewPCFunctionCall>
                         (null, 'return');
              return $next_token_required;
    
            } elsif ($xuri eq <Q::pg:codeBlock>) {
              my $return;
      D: for my $child (@{$statement->child_nodes}) {
        next D unless $child->node_type == $child->ELEMENT_NODE;
        my $xuri = $child->namespace_uri . $child->local_name;
        if ($xuri eq <Q::pg:matchStatement>) {
          if ($next_token_required) {
            $parent->append_child ($next_token_code->clone_node (1));
            $next_token_required = false;
          }
                } elsif ($xuri eq <Q::pg:myStatement>) {
                  if ($child-><M::DPGElementAttribute.dpgGetAttribute>
                       ('return')) {
                    $return = $child-><M::Element.getAttributeNS> (null, 'name');
                  }
                }
                __DEEP{
                  ($next_token_required, undef)
                    = $rstatement_to_code
                        ->($parent, $child,
                           $next_token_required,
                           $rules, $root_rules, $factory, %opt);
                }__;
              }
              return ($next_token_required, $return);

            } else {
              ## ISSUE: Can unsupported elements safely ignored?
              return $next_token_required;
            } # xuri
          }; # rstatement_to_code

          ## -- Converts each |standalone| rules into Perl code
          for my $rule_name (grep {not $external_rules{$_}} keys %root_rules) {
            my $rule_sub = $codeDocument-><M::pc|PCDocument.createPerlSub>
                                      ('_parse_'.$root_rules{$rule_name});
            $r-><M::Node.appendChild> ($rule_sub);

            my $params_s = $rule_sub->append_statement;
            my @params = ('$self');
            my $proto = '$';
    
    $rule_sub->append_statement->append_new_pc_variable ('$', undef, 'token')
                               ->variable_scope ('my');
    
    ## Child statements
            my $return;
    my $next_token_required = 1;
    C: for my $child (@{$rules{$rule_name}->{source}->child_nodes}) {
      next C unless $child->node_type == $child->ELEMENT_NODE;
              if ($child-><AG::Node.namespaceURI> . $child-><AG::Node.localName>
                    eq <Q::pg:parameterDeclaration>) {
                push @params, '$'.$child-><M::Element.getAttributeNS>
                                    (null, 'name');
                $proto .= '$';
              } else {
                my $rv;
                __DEEP{
                  ($next_token_required, $rv)
                    = $rstatement_to_code
                        ->($rule_sub, $child,
                           $next_token_required, \%rules, \%root_rules,
                           $codeDocument, dis_resource => $disResource,
                           ns_context => $contextObject);
                }__;
                $return ||= $rv;
              }
    }

            $params_s->append_code ('my ('.join (', ', @params).') = @_');
            $rule_sub->prototype ($proto);
  
    unless ($next_token_required) {
      for ($rule_sub->append_statement
                    ->append_new_pc_function_call (undef, 'unshift')
                    ->append_new_pc_expression (',')) {
        for ($_->append_new_pc_dereference ('@')
               ->append_new_pc_expression ('->')) {
          $_->append_new_pc_variable ('$', undef, 'self');
          $_->append_bare ('{token}');
        }
        $_->append_new_pc_variable ('$', undef, 'token');
      }
    }

            if ($return) {
              $rule_sub-><M::pc|PerlCodeStatements.appendStatement>
                       -><M::pc|PerlCodeUnits.appendNewPCFunctionCall>
                           (null, 'return')
                       -><M::pc|PerlCodeUnits.appendNewPCVariable>
                           ('$', null, $return);
            }
          
          } # for %root_rules

          $rstatement_to_code = null;

        }__;
##DPGRulesElement

ElementTypeBinding:
  @Name: NamedParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:MethodParameter
    @@DISPerl:isNamedParameter:1

IFClsETDef:
  @IFQName: DPGRuleElement
  @ClsQName: ManakaiDPGRuleElement
  @ETQName: pg|rule

  @IFISA: DPGElement
  @ClsISA: ManakaiDPGElement

  @IFISA: DPGElementAttribute
  @ClsISA: ManakaiDPGElementAttribute

##DPGRuleElement

IFClsETDef:
  @IFQName: DPGMatchStatementElement
  @ClsQName: ManakaiDPGMatchStatementElement
  @ETQName: pg|matchStatement

  @IFISA: DPGElement
  @ClsISA: ManakaiDPGElement
  
  @IFISA: DPGElementAttribute
  @ClsISA: ManakaiDPGElementAttribute

##DPGMatchStatementElement

IFClsETDef:
  @IFQName: DPGMatchBlockElement
  @ClsQName: ManakaiDPGMatchBlockElement
  @ETQName: pg|matchBlock

  @IFISA: DPGElement
  @ClsISA: ManakaiDPGElement
  
  @IFISA: DPGElementAttribute
  @ClsISA: ManakaiDPGElementAttribute

##DPGMatchBlockElement

IFClsETDef:
  @IFQName: DPGMatchElseBlockElement
  @ClsQName: ManakaiDPGMatchElseBlockElement
  @ETQName: pg|matchElseBlock

  @IFISA: DPGElement
  @ClsISA: ManakaiDPGElement
  
  @IFISA: DPGElementAttribute
  @ClsISA: ManakaiDPGElementAttribute

##DPGMatchElseBlockElement

IFClsETDef:
  @IFQName: DPGMyStatementElement
  @ClsQName: ManakaiDPGMyStatementElement
  @ETQName: pg|myStatement

  @IFISA: DPGElement
  @ClsISA: ManakaiDPGElement

  @IFISA: DPGElementAttribute
  @ClsISA: ManakaiDPGElementAttribute
##DPGMyStatementElement

IFClsETDef:
  @IFQName: DPGEmbedStatementElement
  @ClsQName: ManakaiDPGEmbedStatementElement
  @ETQName: pg|embedStatement

  @IFISA: DPGElement
  @ClsISA: ManakaiDPGElement

  @IFISA: DPGElementAttribute
  @ClsISA: ManakaiDPGElementAttribute
##DPGEmbedStatementElement

IFClsETDef:
  @IFQName: DPGRuleRefStatementElement
  @ClsQName: ManakaiDPGRuleRefStatementElement
  @ETQName: pg|ruleRefStatement

  @IFISA: DPGElement
  @ClsISA: ManakaiDPGElement

  @IFISA: DPGElementAttribute
  @ClsISA: ManakaiDPGElementAttribute
##DPGRuleRefStatementElement

IFClsETDef:
  @IFQName: DPGLexmodeElement
  @ClsQName: ManakaiDPGLexmodeElement
  @ETQName: pg|lexmode
  
  @IFISA: DPGElement
  @ClsISA: ManakaiDPGElement

  @IFISA: DPGElementAttribute
  @ClsISA: ManakaiDPGElementAttribute

##DPGLexmodeElement

IFClsETDef:
  @IFQName: DPGLAssignmentStatementElement
  @ClsQName: ManakaiDPGLAssignmentStatementElement
  @ETQName: pg|lAssignmentStatement
  
  @IFISA: DPGElement
  @ClsISA: ManakaiDPGElement

  @IFISA: DPGElementAttribute
  @ClsISA: ManakaiDPGElementAttribute

##DPGLAssignmentStatementElement

IFClsETDef:
  @IFQName: DPGLQDefaultTokenStatementElement
  @ClsQName: ManakaiDPGLQDefaultTokenStatementElement
  @ETQName: pg|lQDefaultTokenStatement
  
  @IFISA: DPGElement
  @ClsISA: ManakaiDPGElement

  @IFISA: DPGElementAttribute
  @ClsISA: ManakaiDPGElementAttribute

##DPGLQDefaultTokenStatementElement

IFClsETDef:
  @IFQName: DPGTokenErrorElement
  @ClsQName: ManakaiDPGTokenErrorElement
  @ETQName: pg|tokenError
  
  @IFISA: DPGElement
  @ClsISA: ManakaiDPGElement

  @IFISA: DPGElementAttribute
  @ClsISA: ManakaiDPGElementAttribute

##DPGTokenErrorElement

IFClsDef:
  @IFQName: DPGParser
  @ClsQName: ManakaiDPGParser

  @Implement: ecore|MUErrorTarget||ManakaiDOM|Perl

  @enDesc:
    A <IF::DPGParser> object parses a DPG source document and 
    converts it into a DOM tree representation.

    A <IF::DPGParser> object can be retrived by <M::GenericLS.createGLSParser>
    method in the Generic Load and Save module with feature string
    <Feature::DIS|DPG> version <FeatureVer::1.0>.

  @DISLang:role: gls|ParserRole

  @Attr:
    @@Name: domConfig
    @@enDesc:
      The configuration of the parser.

    @@Get:
      @@@Type: DOMCore|DOMConfiguration
      @@@enDesc: The DOM configuration object.
      @@@PerlDef:
        __CODE{DOMCore|getConfigObject::
          $target => $self,
          $targetHash => $self,
          $targetType => {<IFName::DPGParser>},
          $result => $r,
        }__;

  @Method:
    @@ManakaiDOM:isForInternal:1
    @@ForCheck: ManakaiDOM|ForClass
    @@Operator: DISPerl|NewMethod
    @@enDesc:
      Creates a new instance of the object.
    @@Param:
      @@@Name: impl
      @@@Type: gls|GLSImplementation
      @@@enDesc:
        The implementation from which the parser is created.
    @@Param:
      @@@Name: features
      @@@Type: DOMString
      @@@dis:actualType: f|FeaturesString
      @@@enDesc:
        The set of features requested for the parser.
    @@Return:
      @@@Type: DOMMain|DOMObject
      @@@dis:actualType: DPGParser
      @@@enDesc:
        The newly created parser.
      @@@PerlDef:
        $r = bless {
          <H::DOMCore:implementation>
            => $impl-><M::f|GetFeature.getFeature>
                 (<Q::DIS|DPG> => ''),
        }, $self;

  @Method:
    @@Name: parseString
    @@enDesc:
      Parses a string as DPG textual definition and converts it into
      its XML representation.
    @@Param:
      @@@Name: sourceText
      @@@Type: DOMString
      @@@enDesc:
        The text to parse.
    @@Param:
      @@@Name: namespaceContext
      @@@Type: DIS|NSResolverDIS||DIS|ForLatest
      @@@enDesc:
        The namespace prefix resolver against which <P::sourceText>
        is evaluated.

          {NOTE::
             Although namespace prefixes in DPG syntax are resolved
             by the parser, those in embed statements are not resolved
             as well as other context dependent information such as 
             base URI or method call.  In fact embed statement contents
             are transparently copied and not parsed at all.
          }
    @@Return:
      @@@Type: DPGDocument
      @@@enDesc:
        An XML representation of <P::sourceText>.
      @@@dx:raises:
        @@@@@: pg|PARSE_ERR
        @@@@enDesc:
          If the DPG document contains one or more error.
      @@@PerlDef:
        $self->{char} = [];
        $self->{token} = [];
        $self->{source} = $sourceText;
        $self->{nsresolver} = $namespaceContext;
        $self->{location} = {};
        __DEEP{
          $r = $self->_parse_Rules ($self->{<H::DOMCore:implementation>});
        }__;

  @Method:
    @@Name: shiftChar
    @@ManakaiDOM:isForInternal:1
    @@ForCheck: ManakaiDOM|ForClass
    @@enDesc:
      Returns the next character.
    @@Return:
      @@@Type: idl|long||ManakaiDOM|all
      @@@enDesc:
        The code position number of the next character, if any,
        or <CODE::-2>.
      @@@PerlDef:
        if (@{$self->{char}}) {
          $r = shift @{$self->{char}};
        } else {
          my $char = substr ($self->{source}, pos ($self->{source}), 1);
          pos ($self->{source})++;

          if (length $char) {
            $r = ord $char;
          } else {
            $r = -1;
          }
        }

  @Method:
    @@Name: parseEmbedBlock
    @@ManakaiDOM:isForInternal:1
    @@ForCheck: ManakaiDOM|ForClass
    @@enDesc:
      Parses an embed statement block.
    @@Param:
      @@@Name: doc
      @@@Type: DPGDocument
      @@@enDesc:
        The owner document object used if new node is being created.
    @@Param:
      @@@Name: parent
      @@@Type: Element
      @@@enDesc:
        The parent element node to which the value from the parsed statement 
        should be attached.
    @@Return:
      @@@PerlDef:
        my $token = $self->_scan_default;
        if ($token->{type} eq 'LBRACE') {
          my $nest_count = 1; # already opened
          my $s = '';
          __DEEP{
            C: while ((my $ch = $self-><M::ManakaiDPGParser.shiftChar>) > -1) {
              if ($ch == 0x007B) {
                $s .= '{'; # }
                $nest_count++;
              } elsif ($ch == 0x007D) {
                if (--$nest_count == 0) {
                  last C;
                } elsif ($nest_count < 0) {
                  $nest_count = 0;
                }
                $s .= chr $ch;
              } else {
                $s .= chr $ch;
              }
            }

            if (length $s) {
              my $el = $doc-><M::Document.createElementNS>
                        (<Q::pg:>, 'embedBlock');
              $el-><AS::Node.textContent> ($s);
              $parent-><M::Node.appendChild> ($el);
            }
          }__;
        } else {
          unshift @{$self->{token}}, $token;
        }

  @Method:
    @@ManakaiDOM:isForInternal: 1
    @@Operator: ManakaiDOM|MUErrorHandler
    @@enDesc:
      When a <IF::ecore|ErrorInterface||ManakaiDOM|Perl> is <Perl::report>ed,
      then this method is invoked.
      
      The method calls the <cfg::DOMCore|error-handler> if the error is of 
      <IF::DOMCore|DOMError>.  Otherwise, the error is re-thrown so that
      corresponding <Perl::catch> clause, if any, can catch the error.
    @@Param:
      @@@Name: err
      @@@Type: ecore|ErrorInterface||ManakaiDOM|Perl
      @@@enDesc:
        The reported error object.
    @@Return:
      @@@Type: DISPerl|Any
      @@@enDesc:
        If the <P::err> is a <IF::DOMCore|DOMError>, then the return value
        of the error handler.

           {NOTE:: If the error is thrown, the method never returns.
           }
      @@@nullCase:
        @@@@enDesc:
          No error handler.
      @@@PerlDef:
        if ($err->isa (<IFName::DOMCore|DOMError||ManakaiDOM|ManakaiDOM>)) {
          __DEEP{
            A: {
              my $cfg = $self-><AG::DPGParser.domConfig>;
              my $h = $cfg-><M::DOMCore|DOMConfiguration.getParameter>
                               ('error-handler');
              $r = $h-><M::DOMCore|DOMErrorHandler.handleError> ($err);
            } # A
          }__;
        } else {
          $err-><M::ecore|ErrorInterface||ManakaiDOM|Perl.throw>;
        }

  @DISPerl:dpgDef:

    rule Rules ($impl) : standalone {
      my $doc : return;
      my $docel;
      lang:Perl {
        $doc = $impl-><M::DOMCore|DOMImplementation.createDocument>
                      (<Q::pg:>, 'rules');
        $doc-><AS::Document.strictErrorChecking> (false);
        $docel = $doc-><AG::Document.documentElement>;
      }
    
      // Rules := *(Rule / Lexmode / TokenError)
      ~* (NAME == 'rule') {
        &_Rule ($doc => $doc, $parent => $docel);
      } (NAME == 'lexmode') {
        &_Lexmode ($doc => $doc, $parent => $docel);
      } (NAME == 'token-error') {
        &_TokenError ($doc => $doc, $parent => $docel);
      }
    
      ~ (#EOF) { }

      lang:Perl {
        if ($self->{has_error}) {
          __EXCEPTION{pg|PARSE_ERR::
          }__;
        }
      }
    } // Rules
  
    rule _Lexmode ($doc, $parent) {
      /*
        Lexmode := 'lexmode' NAME *AttributeSpecification LBRACE
                   *LStatement RBRACE
      */
    
      my $el;
      lang:Perl {
        $el = $doc-><M::Document.createElementNS> (<Q::pg:>, 'lexmode');
        $parent-><M::Node.appendChild> ($el);
      }
    
      // Lexmode name
      ~ (NAME) {
        lang:Perl ($name => $token.value) {
          $el-><M::Element.setAttributeNS> (null, 'name', $name);
        }
      }
    
      &AttributeSpecificationList ($doc => $doc, $parent => $el);
      
      ~ (LBRACE) { }
    
      /*
        LStatement := LAssignmentStatement / LQDefaultTokenStatement
        LAssignmentStatement := (NAME / VARIABLE) *AttributeSpecification
                                DEFINE 1*LRValue SEMICOLON
      */
      ~* (NAME) {
        my $lassign;
        lang:Perl ($name => $token.value) {
          $lassign = $doc-><M::Document.createElementNS>
                             (<Q::pg:>, 'lAssignmentStatement');
          $lassign-><M::Element.setAttributeNS> (null, 'name', $name);
          $el-><M::Node.appendChild> ($lassign);
        }
      
        &AttributeSpecificationList ($doc => $doc, $parent => $lassign);
      
        ~ (DEFINE) { }

        &LRValueList ($doc => $doc, $parent => $lassign);
      
        ~ (SEMICOLON) { }
      } (VARIABLE) {
        my $lassign;
        lang:Perl ($name => $token.value) {
          $lassign = $doc-><M::Document.createElementNS>
                             (<Q::pg:>, 'lAssignmentStatement');
          $lassign-><M::Element.setAttributeNS>
                             (null, 'name', substr ($name, 1));
          $lassign-><M::Element.setAttributeNS> (null, 'isVariable', '1');
          $el-><M::Node.appendChild> ($lassign);
        }
      
        &AttributeSpecificationList ($doc => $doc, $parent => $lassign);
      
        ~ (DEFINE) { }

        &LRValueList ($doc => $doc, $parent => $lassign);
      
        ~ (SEMICOLON) { }
      } (QKEYWORD == '?default-token') {
        /*
          LQDefaultTokenStatement := '?default-token' NAME
                                     *AttributeSpecification SEMICOLON
        */
        
        my $ldef;
        ~ (NAME) {
          lang:Perl ($name => $token.value) {
            $ldef = $doc-><M::Document.createElementNS>
                               (<Q::pg:>, 'lQDefaultTokenStatement');
            $ldef-><M::Element.setAttributeNS> (null, 'name', $name);
            $el-><M::Node.appendChild> ($ldef);
          }
        }
      
        &AttributeSpecificationList ($doc => $doc, $parent => $ldef);

        ~ (SEMICOLON) { }
      }
    
      ~ (RBRACE) { }
    } // _Lexmode

    rule LRValueList ($doc, $parent) {
      /*
        LRValue := CharClass [Occurence] /
                   DOT [Occurence] /
                   VARIABLE
      */

      ~* (CLSOPEN) {
        my $cls;
        lang:Perl {
          $cls = $doc-><M::Document.createElementNS>
                           (<Q::pg:>, 'charClass');
          $lassign-><M::Node.appendChild> ($cls);
        }
        &_CharClass ($doc => $doc, $parent => $cls);
      } (NCLSOPEN) {
        my $cls;
        lang:Perl {
          $cls = $doc-><M::Document.createElementNS>
                           (<Q::pg:>, 'charClass');
          $cls-><M::Element.setAttributeNS> (null, 'negative', '1');
          $lassign-><M::Node.appendChild> ($cls);
        }
        &_CharClass ($doc => $doc, $parent => $cls);
      } (DOT) {
        my $cls;
        lang:Perl {
          $cls = $doc-><M::Document.createElementNS> (<Q::pg:>, 'anyChar');
          $lassign-><M::Node.appendChild> ($cls);
        }
        &OccurenceOpt ($parent => $cls);
      } (VARIABLE) {
        my $lname;
        lang:Perl ($name => $token.value) {
          $lname = $doc-><M::Document.createElementNS>
                                (<Q::pg:>, 'lVariableRef');
          $lname-><M::Element.setAttributeNS>
                                (null, 'name', substr ($name, 1));
          $lassign-><M::Node.appendChild> ($lname);
        }
        &OccurenceOpt ($parent => $lname);
      }
    } // LRValueList
  
    rule _CharClass ($doc, $parent) {
      /*
        CharClass := (CLSOPEN / NCLSOPEN) 1*CharSpec CLSCLOSE
        CharSpec := STRING / CHAR [RANGE CHAR]
      */
      ~+ (STRING) {
        lang:Perl ($value => $token.value) {
          my $str = $doc-><M::Document.createElementNS> (<Q::pg:>, 'string');
          $str-><AS::Node.textContent>
                  (substr ($value, 1, length ($value) - 2));
          $parent-><M::Node.appendChild> ($str);
        }
      } (CHAR) {
        my $char;
        lang:Perl ($value => $token.value) {
          $char = $doc-><M::Document.createElementNS> (<Q::pg:>, 'charRange');
          my $code = $value;
          $code =~ s/^U\+/0x/;
          $char-><M::Element.setAttributeNS> (null, 'start', hex $code);
          $char-><M::Element.setAttributeNS> (null, 'end', hex $code);
          $parent-><M::Node.appendChild> ($char);
        }
        ~? (RANGE) {
          ~ (CHAR) {
            lang:Perl ($value => $token.value) {
              my $code = $value;
              $code =~ s/^U\+/0x/;
              $char-><M::Element.setAttributeNS> (null, 'end', hex $code);
            }
          }
        }
      }
    
      ~ (CLSCLOSE) { }
    
      &OccurenceOpt ($parent => $parent);
    } // _CharClass
  
    rule OccurenceOpt ($parent) {
      /*
        Occurence := ZEROMORE / ONEMORE / ZEROONE
      */
      ~? (ZEROMORE) {
        lang:Perl {
          $parent-><M::Element.setAttributeNS>
                       (null, 'occurence', 'zeromore');
        }
      } (ONEMORE) {
        lang:Perl {
          $parent-><M::Element.setAttributeNS>
                       (null, 'occurence', 'onemore');
        }
      } (ZEROONE) {
        lang:Perl {
          $parent-><M::Element.setAttributeNS> 
                       (null, 'occurence', 'zeroone');
        }
      }
    } // OccurenceOpt
  
    rule _Rule ($doc, $parent) {
      /*
        Rule := 'rule' NAME [ParameterDeclarationList] *AttributeSpecification
                (CodeBlock / LANGLE 'external' RANGLE SEMICOLON)
      */
    
      my $el;
      lang:Perl {
        $el = $doc-><M::Document.createElementNS> (<Q::pg:>, 'rule');
        $parent-><M::Node.appendChild> ($el);
      }
    
      // Rule name
      ~ (NAME) {
        lang:Perl ($name => $token.value) {
          $el-><M::Element.setAttributeNS> (null, 'name', $name);
        }
      }

      &ParameterDeclarationListOpt ($doc => $doc, $parent => $el);    
    
      &AttributeSpecificationList ($doc => $doc, $parent => $el);
    
      ~ (LBRACE) {
        &_CodeBlock ($doc => $doc, $parent => $el);
      } (LANGLE) {
        ~ (NAME == 'external') {
          lang:Perl {
            $el-><M::Element.setAttributeNS> (null, 'isExternal', '1');
          }
          ~ (RANGLE) { }
          ~ (SEMICOLON) { }
        }
      }
    } // _Rule
  
    rule AttributeSpecificationList ($doc, $parent) {
      /*
        AttributeSpecification := COLON NAME [Occurence]
                                  [REPLACE (STRING / NAME)]
      */

      ~* (COLON) {
        // Attribute name
        ~ (NAME) {
          my $ael;
          lang:Perl ($name => $token.value) {
            $ael = $doc-><M::Document.createElementNS>
                            (<Q::pg:>, 'attributeSpecification');
            $ael-><M::Element.setAttributeNS> (null, 'name', $name);
            $ael-><M::Element.setAttributeNS> (null, 'value', '1');
            $parent-><M::Node.appendChild> ($ael);
          }
 
          &OccurenceOpt ($parent => $ael);

          // String value
          ~? (REPLACE) {
            ~ (STRING) {
              lang:Perl ($value => $token.value) {
                $ael-><M::Element.setAttributeNS>
                        (null, 'value',
                         substr ($value, 1, length ($value) - 2));
              }
            } (NAME) {
              lang:Perl ($value => $token.value) {
                $ael-><M::Element.setAttributeNS>
                        (null, 'value', $value);
              }
            }
          }
        }
      }
    } // AttributeSpecificationList
  
    rule _CodeBlock ($doc, $parent) : standalone {
      /*
        CodeBlock := LBRACE *Statement RBRACE
      */
    
      my $block;
      lang:Perl {
        $block = $doc-><M::Document.createElementNS> (<Q::pg:>, 'codeBlock');
        $parent-><M::Node.appendChild> ($block);
      }
    
      /*
        Statement := MyStatement / AssignmentStatement / MatchStatement /
                     RuleRefStatement / EmbedStatement / QLexmodeStatement /
                     QRequiresNextTokenStatement /
                     IfTrueStatement / ReturnStatement
      */
    
      ~* (MATCH) {
        /*
          MatchStatement := MATCH Occurence *AttributeSpecification
                            1*(LPAREN [RNI] NAME [EQUALS STRING] RPAREN
                               *AttributeSpecification CodeBlock)
        */

        my $match;
        lang:Perl {
          $match = $doc-><M::Document.createElementNS>
                           (<Q::pg:>, 'matchStatement');
          $block-><M::Node.appendChild> ($match);
        }

        &OccurenceOpt ($parent => $match);

        &AttributeSpecificationList
          ($doc => $doc, $parent => $match);

        ~+ (LPAREN) {
          my $match_block;
          lang:Perl {
            $match_block = $doc-><M::Document.createElementNS> (<Q::pg:>, 'matchBlock');
            $match-><M::Node.appendChild> ($match_block);
          }
            ~? (RNI) {
              lang:Perl {
                $match_block-><M::Element.setAttributeNS>
                                   (null, 'isReservedToken' => '1');
              }
            }
            ~ (NAME) {
              lang:Perl ($name => $token.value) {
                $match_block-><M::Element.setAttributeNS>
                                   (null, 'token', $name);
              }
            }

            ~? (EQUALS) {
              ~ (STRING) {
                lang:Perl ($value => $token.value) {
                  $match_block-><M::Element.setAttributeNS>
                                   (null, 'valueOperation', '==');
                  $match_block-><M::Element.setAttributeNS>
                                   (null, 'value',
                                    substr ($value, 1, length ($value) - 2));
                }
              }
            }

          ~ (RPAREN) { }
          
          &AttributeSpecificationList
            ($doc => $doc, $parent => $match_block);
          
          ~ (LBRACE) {
            &_CodeBlock ($doc => $doc, $parent => $match_block);
          }
        } // LPAREN

        ~? (NAME == 'else') {
          my $match_block;
          lang:Perl {
            $match_block = $doc-><M::Document.createElementNS>
                                   (<Q::pg:>, 'matchElseBlock');
            $match-><M::Node.appendChild> ($match_block);
          }

          &AttributeSpecificationList ($doc => $doc, $parent => $match_block);

          ~ (LBRACE) {
            &_CodeBlock ($doc => $doc, $parent => $match_block);
          }
        } // else

      } (NAME == 'my') {
        /*
          MyStatement := MY VARIABLE SEMICOLON
        */
        ~ (VARIABLE) {
          my $my;
          lang:Perl ($name => $token.value) {
            $my = $doc-><M::Document.createElementNS> (<Q::pg:>, 'myStatement');
            $my-><M::Element.setAttributeNS> (null, 'name', substr ($name, 1));
            $block-><M::Node.appendChild> ($my);
          }

          &AttributeSpecificationList ($doc => $doc, $parent => $my);
        }

        ~ (SEMICOLON) { }

      } (NAME == 'if-true') {
        /*
          IfTrueStatement := 'if-true' LPAREN VARIABLE RPAREN
                             *AttributeSpecification CodeBlock
        */

        my $ift;
        lang:Perl {
          $ift = $doc-><M::Document.createElementNS>
                            (<Q::pg:>, 'ifTrueStatement');
          $block-><M::Node.appendChild> ($ift);
        }
        
        ~ (LPAREN) {
          ~ (VARIABLE) {
            lang:Perl ($name => $token.value) {
              $ift-><M::Element.setAttributeNS>
                      (null, 'name', substr ($name, 1));
            }
          }
          ~ (RPAREN) { }
        }

        &AttributeSpecificationList ($doc => $doc, $parent => $ift);

        ~ (LBRACE) {
          &_CodeBlock ($doc => $doc, $parent => $ift);
        }

      } (NAME == 'return') {
        /*
          ReturnStatement := 'return' SEMICOLON
        */

        lang:Perl {
          my $ret = $doc-><M::Document.createElementNS>
                            (<Q::pg:>, 'returnStatement');
          $block-><M::Node.appendChild> ($ret);
        }

        ~ (SEMICOLON) { }

      } (NAME) {
        /*
          EmbedStatement := NAME [ParameterSpecificationList]
                            *AttributeSpecification EmbedBlock
        */
        my $embed;
        lang:Perl ($name => $token.value) {
          my ($prefix, $lname) = split /:/, $name;
          ($prefix, $lname) = (null, $prefix) unless defined $lname;
          my $nsuri = $self->{nsresolver}
                           -><M::DIS|NSResolverDIS||DIS|ForLatest
                                .prefixToURI> ($prefix);
          $embed = $doc-><M::Document.createElementNS>
                               (<Q::pg:>, 'embedStatement');
          $embed-><M::Element.setAttributeNS> (null, 'type', $nsuri.$lname);
          $block-><M::Node.appendChild> ($embed);
        }
      
        &ParameterSpecificationListOpt ($doc => $doc, $parent => $embed);
      
        &AttributeSpecificationList ($doc => $doc, $parent => $embed);

        &EmbedBlock ($doc => $doc, $parent => $embed);

      } (RULEREF) {
        /*
          RuleRefStatement := RULEREF [ParameterSpecificationList]
                              *AttributeSpecification SEMICOLON
        */
      my $ruleref;
      lang:Perl ($name => $token.value) {
        $ruleref = $doc-><M::Document.createElementNS> (<Q::pg:>, 'ruleRefStatement');
        $ruleref-><M::Element.setAttributeNS> (null, 'name', substr ($name, 1));
        $block-><M::Node.appendChild> ($ruleref);
      }
      
      &ParameterSpecificationListOpt ($doc => $doc, $parent => $ruleref);
      
        &AttributeSpecificationList ($doc => $doc, $parent => $ruleref);
      
      ~ (SEMICOLON) { }

        } (QKEYWORD == '?lexmode') {
          /*
            Changes current |lexmode|

            QLexmodeStatement := '?lexmode' (NAME / STRING) SEMICOLON
          */

          ~ (NAME) {
            lang:Perl ($mode => $token.value) {
              my $lm = $doc-><M::Document.createElementNS>
                         (<Q::pg:>, 'qLexmodeStatement');
              $lm-><M::Element.setAttributeNS> (null, 'name', $mode);
              $block-><M::Node.appendChild> ($lm);
            }
          } (STRING) {
            lang:Perl ($mode => $token.value) {
              my $lm = $doc-><M::Document.createElementNS>
                         (<Q::pg:>, 'qLexmodeStatement');
              $lm-><M::Element.setAttributeNS>
                         (null, 'name',
                          substr ($mode, 1, length ($mode) - 2));
              $block-><M::Node.appendChild> ($lm);
            }
          }

          ~ (SEMICOLON) { }
        
        } (QKEYWORD == '?requires-next-token') {
          /*
            Turns |$next-token-requires| flag on.

            QRequiresNextTokenStatement := '?requires-next-token' SEMICOLON
          */

          lang:Perl ($mode => $token.value) {
            my $lm = $doc-><M::Document.createElementNS>
                         (<Q::pg:>, 'qRequiresNextTokenStatement');
            $block-><M::Node.appendChild> ($lm);
          }

          ~ (SEMICOLON) { }

        } (VARIABLE) {
          /*
            AssignmentStatement := Lvalue ASSIGN Rvalue;
          */
      my $assign;
      my $lvalue;
      lang:Perl ($name => $token.value) {
        $assign = $doc-><M::Document.createElementNS> (<Q::pg:>, 'assignmentStatement');
        $lvalue = $doc-><M::Document.createElementNS> (<Q::pg:>, 'memberRef');
        my $var = $doc-><M::Document.createElementNS> (<Q::pg:>, 'variable');
        $var-><M::Element.setAttributeNS> (null, 'name', substr ($name, 1));
        $lvalue-><M::Node.appendChild> ($var);
        $assign-><M::Node.appendChild> ($lvalue);
        $block-><M::Node.appendChild> ($assign);
      }
      
      ~* (DOT) {
        ~ (NAME) {
          lang:Perl ($name => $token.value) {
            my $mem = $doc-><M::Document.createElementNS> (<Q::pg:>, 'member');
            $mem-><M::Element.setAttributeNS> (null, 'name', $name);
            $lvalue-><M::Node.appendChild> ($mem);
          }
        }
      }
      
      ~ (ASSIGN) { }
      
      &Rvalue ($doc => $doc, $parent => $assign);
      
      ~ (SEMICOLON) { }

      }
    
      ~ (RBRACE) { }
    } // _CodeBlock

    /*
      EmbedBlock := '{' *((<any character> - '{' / '}') / EmbedBlock) '}'

          ISSUE: How escapes ('\' <any character>) should be parsed?
    */
    rule EmbedBlock ($doc, $parent)
           : perl-name => 'embed_block'
           <external>;
    
    // Lvalue := VARIABLE *(DOT NAME)
  
    rule Rvalue ($doc, $parent) {
      /*
        Rvalue := STRING / VARIABLE *(DOT NAME)
      */
    
      ~ (STRING) {
        lang:Perl ($value => $token.value) {
          my $str = $doc-><M::Document.createElementNS> (<Q::pg:>, 'string');
          $str-><AS::Node.textContent>
                  (substr ($value, 1, length ($value) - 2));
          $parent-><M::Node.appendChild> ($str);
        }
      } (VARIABLE) {
        my $memref;
        lang:Perl ($name => $token.value) {
          $memref = $doc-><M::Document.createElementNS>
                              (<Q::pg:>, 'memberRef');
          my $var = $doc-><M::Document.createElementNS>
                              (<Q::pg:>, 'variable');
          $var-><M::Element.setAttributeNS>
                    (null, 'name', substr ($name, 1));
          $memref-><M::Node.appendChild> ($var);
          $parent-><M::Node.appendChild> ($memref);
        }
        
        ~* (DOT) {
          ~ (NAME) {
            lang:Perl ($name => $token.value) {
              my $mem = $doc-><M::Document.createElementNS>
                                (<Q::pg:>, 'member');
              $mem-><M::Element.setAttributeNS> (null, 'name', $name);
              $memref-><M::Node.appendChild> ($mem);
            }
          }
        }
      }
    } // Rvalue

    rule ParameterDeclarationListOpt ($doc, $parent) {
      /*
        ParameterDeclarationList := "(" [ParameterDeclaration
                                         *(COMMA ParameterDeclaration)] ")"
        ParameterDeclaration := VARIABLE
      */
      ~? (LPAREN) {
        ~* (VARIABLE) {
          lang:Perl ($name => $token.value) {
            my $pel = $doc-><M::Document.createElementNS>
                              (<Q::pg:>, 'parameterDeclaration');
            $pel-><M::Element.setAttributeNS>
                    (null, 'name', substr ($name, 1));
            $parent-><M::Node.appendChild> ($pel);
          }
        } (COMMA) : separator { }

        ~ (RPAREN) { }
      }
    } // ParameterDeclarationListOpt

    rule ParameterSpecificationListOpt ($doc, $parent) {
      /*
        ParameterSpecificationList := LPAREN [VARIABLE REPLACE Rvalue
                                      *(COMMA Lvalue REPLACE Rvalue)] RPAREN
      */

      ~? (LPAREN) {
        ~* (VARIABLE) {
          my $param;
          lang:Perl ($name => $token.value) {
            $param = $doc-><M::Document.createElementNS>
                             (<Q::pg:>, 'parameterSpecification');
            $parent-><M::Node.appendChild> ($param);
            $param-><M::Element.setAttributeNS>
                      (null, 'name', substr ($name, 1));
          }
       
          ~ (REPLACE) { }
        
          &Rvalue ($doc => $doc, $parent => $param);
        } (COMMA) : separator { }
      
        ~ (RPAREN) { }
      }
    }

    rule _TokenError ($doc, $parent) {
      /*
        TokenError := 'token-error' NAME [ParameterDeclarationList]
                      *AttributeSpecification CodeBlock
      */

      my $el;

      ~ (NAME) {
        lang:Perl ($name => $token.value) {
          $el = $doc-><M::Document.createElementNS> (<Q::pg:>, 'tokenError');
          $el-><M::Element.setAttributeNS> (null, 'name', $name);
          $parent-><M::Node.appendChild> ($el);
        }
      }

      &ParameterDeclarationListOpt ($doc => $doc, $parent => $el);

      &AttributeSpecificationList ($doc => $doc, $parent => $el);

      ~ (LBRACE) {
        &_CodeBlock ($doc => $doc, $parent => $el);
      }
    } // _TokenError

    token-error default : default {
      lang:Perl {
        my $location = {
          utf32_offset => pos ($self->{source}),
        };
        my $continue = __DOMCore:ERROR{pg|bad-token-error::
          pg|error-token => {$token},
          DOMCore|location => {$location},
          pg|source-text => {\($self->{source})},
        }__;
        unless ($continue) {
          __EXCEPTION{pg|PARSE_ERR::
          }__;
        }
        $self->{has_error} = true;
      }
    } // token-error default


    lexmode default : initial : standalone {
      WSP : ignore := [U+0009..U+000D U+0020]+;
      COMMENT : ignore := [';'] [';'] [^U+000A..U+000D]* [U+000A..U+000D]*;

      /*
        Comment : from |//| to the end of the line
      */
      CommentLine : ignore := ['/'] ['/'] [^U+000A..U+000D]*
                                          [U+000A..U+000D]*;

      /*
        Comment : from |/*| to |*| |/|
      */
      $CommentPhrase0 := [^'/' '*'] [^'*']* ['*']+;
      CommentPhrase : ignore := ['/'] ['*'] [^'*']* ['*']+
                                $CommentPhrase0* ['/'];

      /*
        Name
      */    
      $name := [U+0041..U+005A U+0061..U+007A '_' '-']
               [U+0030..U+0039 U+0041..U+005A U+0061..U+007A '_' '-' ':']*;
      NAME : value := $name;

      VARIABLE : value := ['$'] $name;
      RULEREF : value := ['&'] $name;

      /*
        Q-keyword
      */
      QKEYWORD : value := ['?'] $name;

      /*
        Character code point
      */
      $hexdigit := [U+0030..U+0039 U+0041..U+0046 U+0061..U+0066];
      CHAR : value := ['U' 'u'] ['+']
                      $hexdigit $hexdigit $hexdigit $hexdigit+;
    
    STRING : value := [U+0027] [^U+0027 U+005C]* [U+0027];
    
    COMMA := [','];
    REPLACE := ['='] ['>'];
    ASSIGN := ['='];
    DEFINE := [':'] ['='];
    LPAREN := ['('];
    RPAREN := [')'];
    LBRACE := ['{'];
    RBRACE := ['}'];
    CLSOPEN := ['['];
    NCLSOPEN := ['['] ['^'];
    CLSCLOSE := [']'];
    ZEROMORE := ['*'];
    ONEMORE := ['+'];
    ZEROONE := ['?'];
    COLON := [':'];
    SEMICOLON := [';'];
    MATCH := ['~'];
    DOT := ['.'];
    RANGE := ['.'] ['.'];

      /*
        Reserved name indicator
      */
      RNI := ['#'];

      /*
        Attribute value equals
      */
      EQUALS := ['='] ['='];

      LANGLE := ['<'];
      RANGLE := ['>'];
    } // lexmode
##DPGParser

ElementTypeBinding:
  @Name: Attr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Attribute
    @@ForCheck: !=ManakaiDOM|ManakaiDOM

ElementTypeBinding:
  @Name: Get
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|AttributeGet

ElementTypeBinding:
  @Name: Set
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|AttributeSet

ElementTypeBinding:
  @Name: CParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      @@@@: DOMCore|DOMConfigurationParameter
      @@@For: ManakaiDOM|DOM
    @@rdf:type:
      @@@@: DISCore|Property
      @@@For: =ManakaiDOM|all
    @@For: ManakaiDOM|DOM3
    @@For: =ManakaiDOM|all

ElementTypeBinding:
  @Name: CParamApp
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      @@@@: DOMCore|DOMConfigurationParameterApplication
      @@@For: ManakaiDOM|DOM
    @@rdf:type:
      @@@@: DISCore|Property
      @@@For: =ManakaiDOM|all
    @@For: ManakaiDOM|DOM3
    @@For: =ManakaiDOM|all

CParamApp:
  @DOMCore:domConfigurationParameter: DOMCore|error-handler
  @DOMCore:targetType: DPGParser

ElementTypeBinding:
  @Name: ErrDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DOMCore|DOMErrorType
    @@For: ManakaiDOM|DOM3
    @@ecore:textFormatter: ManakaiDPGExceptionFormatter

ErrDef:
  @QName: pg|bad-token-error
  @enDesc:
    The parser is encountered to a token whose type is not
    allowed there.
  @DOMCore:severity: DOMCore|SEVERITY_FATAL_ERROR
  @enMufDef:
    Token |%dpg-error-token-type;|%dpg-error-token-value
    (prefix => { (|}, suffix => {|)}); is not 
    allowed %dpg-error-lines (prefix => {(|}, suffix => {|)});

ErrDef:
  @QName: pg|unique-lexmode-name-error
  @enDesc:
    A <CODE::lexmode> name <kwd:MUST-NOT> appear more than once in the
    same DPG document.
  @DOMCore:severity: DOMCore|SEVERITY_ERROR
  @enMufDef:
    |lexmode| |%p (name => {<Q::pg|name>});| is already defined

ErrDef:
  @QName: pg|rule-not-defined-error
  @enDesc:
    The referenced <CODE::rule> name <kwd:MUST> be defined
    in the same DPG document.
  @DOMCore:severity: DOMCore|SEVERITY_ERROR
  @enMufDef:
    |rule| |%p (name => {<Q::pg:name>});| is not defined

ErrDef:
  @QName: pg|lexmode-not-defined-error
  @enDesc:
    The referenced <CODE::lexmode> name <kwd:MUST> be defined
    in the same DPG document.
  @DOMCore:severity: DOMCore|SEVERITY_ERROR
  @enMufDef:
    |lexmode| |%p (name => {<Q::pg|name>});| is not defined

PropDef:
  @QName: pg|error-token
  @enDesc:
    The token where the parser found an error.

PropDef:
  @QName: pg|source-text
  @enDesc:
    A reference to the original source text, if available.

PropDef:
  @QName: pg|name
  @enDesc:
    A name.

PropDef:
  @QName: pg|element
  @enDesc:
    An element.

ElementTypeBinding:
  @Name:enMufDef
  @ElementType:
    ecore:defaultMessage
  @ShadowContent:
    @@lang:en
    @@ContentType:
      lang:muf

ResourceDef:
  @rdf:type:
    @@@: dis|MultipleResource
    @@ForCheck: !ManakaiDOM|ForIF !ManakaiDOM|ForClass
  @resourceFor: ManakaiDOM|ForIF
  @resourceFor:
    @@@: ManakaiDOM|ForClass
    @@ForCheck: ManakaiDOM|ManakaiDOM !=ManakaiDOM|ManakaiDOM
  @For: ManakaiDOM|DOM3
  @For: =ManakaiDOM|ManakaiDOM

  @rdf:type:
    @@@: dx|Interface
    @@ForCheck: ManakaiDOM|ForIF

  @rdf:type:
    @@@: dx|Class
    @@ForCheck: ManakaiDOM|ForClass

  @Implement:
    @@@: ||ManakaiDOM|ManakaiDOM||ManakaiDOM|ForIF
    @@ContentType: DISCore|TFPQNames
    @@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM
  @Implement:
    @@@: ||ManakaiDOM|ManakaiDOMLatest||ManakaiDOM|ForIF
    @@ContentType: DISCore|TFPQNames
    @@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOMLatest
  @dx:implementedBy:
    @@@: ||ManakaiDOM|ManakaiDOMLatest||ManakaiDOM|ForClass
    @@ForCheck: ManakaiDOM|ForIF ManakaiDOM|ManakaiDOMLatest

  @f:implements:
    @@@: DIS|DPG10
    @@For: ManakaiDOM|DOM3

  @DISPerl:ISA:
    @@@: dx|Exception||ManakaiDOM|Perl
    @@ForCheck: ManakaiDOM|ForClass

  @IFQName: DPGException
  @ClsQName: ManakaiDPGException

  @ecore:textFormatter: ManakaiDPGExceptionFormatter

  @enDesc:
    A <IF::DPGParser> might throw a <IF::DPGException> if the processing is
    stopped.  The processing can be stopped due to a <IF::DOMCore|DOMError>
    with a <A::DOMCore|DOMError.severity> of 
    <C::DOMCore|DOMError.SEVERITY_FATAL_ERROR> or a non-recovered
    <C::DOMCore|DOMError.SEVERITY_ERROR>, or if 
    <M::DOMCore|DOMErrorHandler.handleError> method returned <DOM::false>.

  @Attr:
    @@Name: code
    @@Get:
      @@@Type: idl|unsignedShort||ManakaiDOM|all
      @@@dis:actualType: DPGExceptionCode
    @@ForCheck: ManakaiDOM|ForIF

  @ResourceDef:
    @@rdf:type: DISLang|ConstGroup
    @@ForCheck: ManakaiDOM|ForIF !=ManakaiDOM|ManakaiDOM

    @@QName: DPGExceptionCode

    @@rdfs:subClassOf: idl|unsignedShort||ManakaiDOM|all
    @@Type: idl|unsignedShort||ManakaiDOM|all

    @@enDesc:
      An integer indicating the type of error generated.

    @@ResourceDef:
      @@@QName: pg|PARSE_ERR
      @@@DISCore:resourceType: dx|ErrorCode
      @@@Value:
        @@@@@: 81
        @@@@ContentType: DISCore|Integer
      @@@enDesc:
        An attempt was made to load a DPG document and
        the processing has been stopped.
    @@ResourceDef:
      @@@QName: pg|VALIDITY_ERR
      @@@DISCore:resourceType: dx|ErrorCode
      @@@Value:
        @@@@@: 10083
        @@@@ContentType: DISCore|Integer
      @@@enDesc:
        An attempt was made to process an invalid DPG document
        and the processing has been stopped.
##DPGException

IFClsDef:
  @IFQName: DPGExceptionFormatter
  @ClsQName: ManakaiDPGExceptionFormatter

  @ClsISA: ecore|MUErrorFormatter||ManakaiDOM|Perl

  @RuleDef:
    @@Name: dpg-error-token-type
    @@enDesc:
      The type of the token the parser is encountered.

    @@Method:
      @@@Name: after
      @@@Param:
        @@@@Name: name
        @@@@Type: DOMString
        @@@@enDesc: The name of the method.
      @@@Param:
        @@@@Name: p
        @@@@Type: DISPerl|HASH
        @@@@enDesc: The set of the parameters to the method.
      @@@Param:
        @@@@Name: o
        @@@@Type: DISPerl|HASH
        @@@@enDesc: The option value.
      @@@Return:
        @@@@PerlDef:
          $p->{-result} = $o->{<H::pg|error-token>}->{type}
            if defined $o->{<H::pg|error-token>}->{type};

  @RuleDef:
    @@Name: dpg-error-token-value
    @@enDesc:
      The value of the token the parser is encountered, if any.

    @@Method:
      @@@Name: after
      @@@Param:
        @@@@Name: name
        @@@@Type: DOMString
        @@@@enDesc: The name of the method.
      @@@Param:
        @@@@Name: p
        @@@@Type: DISPerl|HASH
        @@@@enDesc: The set of the parameters to the method.
      @@@Param:
        @@@@Name: o
        @@@@Type: DISPerl|HASH
        @@@@enDesc: The option value.
      @@@Return:
        @@@@PerlDef:
          $p->{-result} = $o->{<H::pg|error-token>}->{value}
            if defined $o->{<H::pg|error-token>}->{value};

  @RuleDef:
    @@Name: dpg-error-lines
    @@enDesc:
      A copy of fragment of the source text that contains the line
      where the error occurred, if available.
    
    @@Method:
      @@@Name: after
      @@@Param:
        @@@@Name: name
        @@@@Type: DOMString
        @@@@enDesc: The name of the method.
      @@@Param:
        @@@@Name: p
        @@@@Type: DISPerl|HASH
        @@@@enDesc: The set of the parameters to the method.
      @@@Param:
        @@@@Name: o
        @@@@Type: DISPerl|HASH
        @@@@enDesc: The option value.
      @@@Return:
        @@@@PerlDef:
          my $pos = $o-><AG::DOMCore|DOMError.location>
                      -><AG::DOMCore|DOMLocator.utf32Offset>;
          if ($pos > -1) {
            my $src = $o->{<H::pg|source-text>};
            my $start = $pos;
            $start = rindex ($$src, "\x0A", $start - 1) for 0..2;
            $start++;
            my $end = $pos;
            $end = index ($$src, "\x0A", $end + 1) for 0..2;
            $end = length $$src if $end < 0;
            $p->{-result} = substr $$src, $start, $end - $start;
          }
##DPGExceptionFormatter

ElementTypeBinding:
  @Name: RuleDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass
    @@rdf:type: Muf2003|RuleDefClass

ElementTypeBinding:
  @Name: RuleParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: Muf2003|RuleParameter
