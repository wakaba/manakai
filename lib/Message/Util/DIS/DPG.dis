Module:
  @QName: DIS|DPG
  @FullName:
    @@lang: en
    @@@:
      <QUOTE::dis> DPG Module
  @Namespace:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS#DPG/
  
  @enDesc:
    The <Module::DIS|DPG>, <QUOTE::dis> parser generator, is a compiler
    generator implementation for the <QUOTE::dis> system.

  @DISCore:author: DISCore|Wakaba
  @License: license|Perl+MPL

  @Date:
    $Date: 2005/12/23 14:20:22 $
  
  @Require:
    @@Module:
      @@@QName: DIS|common
    @@Module:
      @@@QName: Util|PerlCode
      @@@WithFor: ManakaiDOM|ManakaiDOMLatest

  @DefaultFor: ManakaiDOM|ManakaiDOMLatest

Namespace:
  @DIS:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS#
  @dis:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#dis--
  @DISlib:
    http://suika.fam.cx/~wakaba/archive/2004/dis/
  @dp:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS#Perl/
  @dx:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#
  @ecore:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/Core/
  @f:
    http://suika.fam.cx/~wakaba/archive/2004/dom/feature#
  @html5:
    http://www.w3.org/1999/xhtml
  @idl:
    http://suika.fam.cx/~wakaba/archive/2004/dis/IDL#
  @kwd:
    http://suika.fam.cx/~wakaba/archive/2005/rfc2119/
  @lang:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#
  @license:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/license#
  @ManakaiDOM:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#
  @MDOM:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#ManakaiDOM.
  @MDOMX:
    http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#
  @mn:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/ManakaiNode#
  @pc:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/PerlCode#
  @pg:
    http://suika.fam.cx/~wakaba/archive/2005/11/pg/
  @rdf:
    http://www.w3.org/1999/02/22-rdf-syntax-ns#
  @rdfs:
    http://www.w3.org/2000/01/rdf-schema#
  @s:
    http://suika.fam.cx/~wakaba/archive/2004/dis/Markup#
  @Util:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/

## -- Features

ElementTypeBinding:
  @Name: FeatureDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: f|Feature
    @@For: =ManakaiDOM|all

ElementTypeBinding:
  @Name: FeatureVerDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: f|Feature

ElementTypeBinding:
  @Name: featureQName
  @ElementType:
    f:name
  @ShadowContent:
    @@ContentType: DISCore|QName

FeatureDef:
  @QName: DIS|DPG
  @FeatureVerDef:
    @@QName: DIS|DPG10
    @@Version: 1.0
    @@f:instanceOf: DIS|DPG
    @@f:requires: DOMXML|XMLFeature30
    @@f:requires: pc|CoreFeature10
    @@FullName:
      @@@lang:en
      @@@@:
        DPG version 1.0

ElementTypeBinding:
  @Name: enDesc
  @ElementType: 
    dis:Description
  @ShadowContent: 
    @@lang:en

ElementTypeBinding:
  @Name: IFClsETDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      @@@@: dis|MultipleResource
      @@@ForCheck: !ManakaiDOM|ForIF !ManakaiDOM|ForClass !s|ForML
    @@resourceFor: ManakaiDOM|ForIF
    @@resourceFor: ManakaiDOM|ForClass
    @@resourceFor: s|ForML

    @@rdf:type:
      @@@@: DISLang|Interface
      @@@ForCheck: ManakaiDOM|ForIF
    @@s:elementType:
      @@@@: ||+||s|ForML
      @@@ForCheck: ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames

    @@rdf:type:
      @@@@: DISLang|Class
      @@@ForCheck: ManakaiDOM|ForClass
    @@Implement:
      @@@@: ||+||ManakaiDOM|ForIF
      @@@ForCheck: ManakaiDOM|ForClass
      @@@ContentType: DISCore|TFPQNames
    @@s:elementType:
      @@@@: ||+||s|ForML
      @@@ForCheck: ManakaiDOM|ForClass
      @@@ContentType: DISCore|TFPQNames
      @@@DISCore:stopISARecursive:1

    @@rdf:type:
      @@@@: s|ElementType
      @@@ForCheck: s|ForML

    @@f:implements: DIS|DPG10

ElementTypeBinding:
  @Name: IFClsDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      @@@@: dis|MultipleResource
      @@@ForCheck: !ManakaiDOM|ForIF !ManakaiDOM|ForClass
    @@resourceFor: ManakaiDOM|ForIF
    @@resourceFor: ManakaiDOM|ForClass

    @@rdf:type:
      @@@@: DISLang|Interface
      @@@ForCheck: ManakaiDOM|ForIF

    @@rdf:type:
      @@@@: DISLang|Class
      @@@ForCheck: ManakaiDOM|ForClass
    @@Implement:
      @@@@: ||+||ManakaiDOM|ForIF
      @@@ForCheck: ManakaiDOM|ForClass
      @@@ContentType: DISCore|TFPQNames

    @@f:implements: DIS|DPG10

    @@ForCheck: ManakaiDOM|ManakaiDOM

ElementTypeBinding:
  @Name: IFDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      @@@@: dis|MultipleResource
      @@@ForCheck: !ManakaiDOM|ForIF !ManakaiDOM|ForClass
    @@resourceFor: ManakaiDOM|ForIF

    @@rdf:type:
      @@@@: DISLang|Interface
      @@@ForCheck: ManakaiDOM|ForIF

    @@ForCheck: ManakaiDOM|ManakaiDOM

ElementTypeBinding:
  @Name: IFQName
  @ElementType:
    dis:QName
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForIF

ElementTypeBinding:
  @Name: ClsQName
  @ElementType:
    dis:QName
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: ETQName
  @ElementType:
    dis:AppName
  @ShadowContent:
    @@ForCheck:
      s:ForML
    @@ContentType: DISCore|QName

ElementTypeBinding:
  @Name: ATTRQName
  @ElementType:
    dis:AppName
  @ShadowContent:
    @@ForCheck:
      s:ForML
    @@ContentType: DISCore|QName

ElementTypeBinding:
  @Name: IFISA
  @ElementType:
    dis:ISA
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForIF

ElementTypeBinding:
  @Name: ClsISA
  @ElementType:
    dis:ISA
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: Method
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Method
    @@For: !=ManakaiDOM|ManakaiDOM

ElementTypeBinding:
  @Name: Return
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|MethodReturn

ElementTypeBinding:
  @Name: Param
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|MethodParameter

ElementTypeBinding:
  @Name: plMName
  @ElementType:
    DISPerl:methodName

ElementTypeBinding:
  @Name: PerlDef
  @ElementType:
    dis:Def
  @ShadowContent:
    @@ContentType: lang|Perl

ElementTypeBinding:
  @Name: disDef
  @ElementType:
    dis:Def
  @ShadowContent:
    @@ContentType: lang|dis

ElementTypeBinding:
  @Name: PropDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: rdf|Property

## -- The DPG Document Object Model

IFClsDef:
  @IFQName: DPGDocument
  @ClsQName: ManakaiDPGDocument

  @IFISA: Document
  @ClsISA: DOMCore|ManakaiDOMDocument

  @enDesc:
    The <IF::DPGDocument> interface <kwd:MUST> be implemented by
    <IF::Document> objects if the implementation supports the DPG object model.

  @f:provides:
    @@@: DIS|DPG10
    @@f:through: DOMCore|ManakaiDOMImplementation

  @s:rootElementType: RulesElementType
##DPGDocument

ResourceDef:
  @For: ManakaiDOM|DOM
  @QName: Node
  @AliasFor: DOMCore|Node

ResourceDef:
  @For: ManakaiDOM|DOM
  @QName: Document
  @AliasFor: DOMCore|Document

ResourceDef:
  @For: ManakaiDOM|DOM
  @QName: Element
  @AliasFor: DOMCore|Element

IFClsDef:
  @IFQName: DPGElement
  @ClsQName: ManakaiDPGElement

  @IFISA: Element
  @ClsISA: DOMCore|ManakaiDOMElement

  @enDesc:
    The <IF::DPGElement> interface <kwd:MUST> be implemented by
    <IF::Element> objects whose namespace URI is <URI^^DISCore:QName::pg:>
    if the implementation supports the DPG object model.

##DPGElement

IFClsDef:
  @IFQName: DPGElementAttribute
  @ClsQName: ManakaiDPGElementAttribute

  @enDesc:
    The <IF::DPGElementAttribute> interface is implemented by
    objects whose element type allowes DPG attributes being specified.

  @Method:
    @@Name: dpgGetAttribute
    @@enDesc:
      Returns a DPG attribute value.
    @@Param:
      @@@Name: attrName
      @@@Type: DOMString
      @@@enDesc:
        The name of the attribute.
    @@Return:
      @@@Type: DOMString
      @@@enDesc:
        The attribute value.

          {NOTE:: If the DPG attribute element is invalid so that 
                  its <XA::value> attribute is not specified, then
                  what is the return value is undefined.
          }
      @@@nullCase:
        @@@@enDesc:
          The attribute is not specified.
      @@@PerlDef:
        __DEEP{
          $r = null;
          no warnings "uninitialized";
          C: for my $child (@{$self-><AG::Node.childNodes>}) {
            if ($child-><AG::Node.namespaceURI>.$child-><AG::Node.localName> eq
                <Q::pg:attributeSpecification>) {
              if ($child-><M::Element.getAttributeNS> (null, 'name') eq
                  $attrName) {
                $r = $child-><M::Element.getAttributeNS> (null, 'value');
                last C;
              }
            }
          }
        }__;
##DPGElementAttribute

ElementTypeBinding:
  @Name: nullCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: ManakaiDOM|InCase
    @@Value:
      @@@is-null:1

ResourceDef:
  @For: ManakaiDOM|DOM
  @QName: DOMString
  @AliasFor: DOMMain|DOMString

IFClsETDef:
  @IFQName: DPGRulesElement
  @ClsQName: ManakaiDPGRulesElement
  @ETQName: pg|rules
  @QName:
    @@@: RulesElementType
    @@ForCheck: s|ForML

  @IFISA: DPGElement
  @ClsISA: ManakaiDPGElement

  @enDesc:
    The <XE::pg|rules> element type is used for the root element
    of the DPG rule fragment.  It <kwd:MAY> contain zero or more
    <XE::pg|rule> and / or <XE::pg|lexmode> child elements.

  @Method:
    @@Name: plCodeFragment
    @@enDesc:
      Generates a Perl code fragment from the subtree rooted by
      the node.
    @@Param:
      @@@Name: codeDocument
      @@@Type: pc|PCDocument
      @@@enDesc:
        A <IF::pc|PCDocument>.  The generated Perl code nodes will
        belong to the document.
    @@NamedParam:
      @@@Name: disResource
      @@@Type: dp|DISResourcePerl||DIS|ForLatest
      @@@enDesc:
        The <QUOTE::dis> resource object against which <Q::lang:Perl>
        code fragments, if any, are evaluated and converted into Perl code.
    @@NamedParam:
      @@@Name: contextObject
      @@@Type: DIS|NSResolverDIS||DIS|ForLatest
      @@@enDesc:
        The context where various references, such as namespace prefixes
        and relative URI references, are evaluated.  It <kwd:MUST> implement
        the <IF::DIS|NSResolverDIS> interface if there are <Q::lang:Perl>
        code fragments.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        A set of elements generated from the rules.

          {NOTE:: If the subtree contains one or more <XE::pg|embedStatement>
                  element nodes whose content is invalid, then their
                  evaluation processes might throw an exception.
          }
      @@@PerlDef:
        __DEEP{
          no warnings 'uninitialized';

          $r = $codeDocument-><M::Document.createDocumentFragment>;

          ## --- Range operations
          
            my $or_range = sub ($$) {
    my ($r1, $r2) = @_;
    my @r1 = @$r1;
    my @r2 = @$r2;
    my ($c1, $c2);
    my $r = [];
    while (@r1 or @r2 or $c1 or $c2) {
      $c1 ||= shift @r1;
      $c2 ||= shift @r2;
      if (not $c1) {
        push @$r, $c2, @r2;
        undef $c2;
 \      @r2 = ();
      } elsif (not $c2) {
        push @$r, $c1, @r1;
        undef $c1;
 \      @r1 = ();
      } else {
        ($c1, $c2) = ($c2, $c1) if $c1->[0] > $c2->[0];
        if ($c1->[1] <= $c2->[0]) {
          push @$r, $c1;
          undef $c1;
        } else {
          $c2 = [$c1->[0], $c2->[1]];
          undef $c1;
        }
      }
    }
    return $r;
  };
  
  my $add_range = sub ($$;$) {
    my ($range, $s, $e) = @_;
    return $or_range->($range, [[$s, defined $e ? $e : $s]]);
  };
  
  my $negate_range = sub ($) {
    my $range = shift;
    my $r = [];
    push @$r, [0, $range->[0]->[0] - 1] if $range->[0]->[0] > 0;
    for my $i (1..$#$range) {
      push @$r, [$range->[$i - 1]->[1] + 1, $range->[$i]->[0] - 1];
    }
    push @$r, [$range->[$#$range]->[1] + 1, "Inf"] unless $range->[$#$range]->[1] eq "Inf";
    return $r;
  };
  
  my $and_minus_ranges = sub ($$) {
    my (@ra, @rab, @rb);
    my @rangea = @{$_[0]};
    my @rangeb = @{$_[1]};
    my $rangea;
    my $rangeb;
    while (@rangea or @rangeb or $rangea or $rangeb) {
      $rangea ||= shift @rangea;
      $rangeb ||= shift @rangeb;
      if (not $rangea) {
        push @rb, $rangeb, @rangeb;
        last;
      } elsif (not $rangeb) {
        push @ra, $rangea, @rangea;
        last;
      } else {
        if ($rangea->[0] < $rangeb->[0]) {
          if ($rangea->[1] ne 'Inf' and
              $rangea->[1] < $rangeb->[0]) { ## [a .. a] .. [b ..
            push @ra, $rangea;
            $rangea = undef;
          } elsif ($rangea->[1] eq 'Inf') {
            if ($rangeb->[1] eq 'Inf') {  ## [a .. [b ..
              push @ra, [$rangea->[0], $rangeb->[0] - 1];
              push @rab, $rangeb;
              last;
            } else {                      ## [a .. [b .. b] ..
              push @ra, [$rangea->[0], $rangeb->[0] - 1];
              push @rab, $rangeb;
              $rangea = [$rangeb->[1] + 1, 'Inf'];
              $rangeb = undef;
            }
          } else {                      
            if ($rangeb->[1] eq 'Inf') {  ## [a .. [b .. a] ..
              push @ra, [$rangea->[0], $rangeb->[0] - 1];
              push @rab, [$rangeb->[0], $rangea->[1]];
              $rangeb = [$rangea->[1] + 1, 'Inf'];
              $rangea = undef;
            } else {
              if ($rangea->[1] < $rangeb->[1]) { ## [a .. [b .. a] .. b]
                push @ra, [$rangea->[0], $rangeb->[0] - 1];
                push @rab, [$rangeb->[0], $rangea->[1]];
                $rangeb = [$rangea->[1] + 1, $rangeb->[1]];
                $rangea = undef;
              } elsif ($rangea->[1] > $rangeb->[1]) { ## [a .. [b .. b] .. a]
                push @ra, [$rangea->[0], $rangeb->[0] - 1];
                push @rab, $rangeb;
                $rangea = [$rangeb->[1] + 1, $rangea->[1]];
                $rangeb = undef;
              } else {                            ## [a .. [b .. ab]]
                push @ra, [$rangea->[0], $rangeb->[0] - 1];
                push @rab, $rangeb;
                $rangea = $rangeb = undef;
              }
            }
          }
        } elsif ($rangea->[0] > $rangeb->[0]) {
          if ($rangeb->[1] ne 'Inf' and
              $rangeb->[1] < $rangea->[0]) { ## [b .. b] .. [a ..
            push @rb, $rangeb;
            $rangeb = undef;
          } elsif ($rangea->[1] eq 'Inf') {
            if ($rangeb->[1] eq 'Inf') {  ## [b .. [a ..
              push @rb, [$rangeb->[0], $rangea->[0] - 1];
              push @rab, $rangea;
              last;
            } else {                      ## [b .. [a .. b] ..
              push @rb, [$rangeb->[0], $rangea->[0] - 1];
              push @rab, [$rangea->[0], $rangeb->[1]];
              $rangea = [$rangeb->[1] + 1, 'Inf'];
              $rangeb = undef;
            }
          } else {                      
            if ($rangeb->[1] eq 'Inf') {  ## [b .. [a .. a] ..
              push @rb, [$rangeb->[0], $rangea->[0] - 1, -7];
              push @rab, $rangea;
              $rangeb = [$rangea->[1] + 1, 'Inf'];
              $rangea = undef;
            } else {
              if ($rangea->[1] < $rangeb->[1]) { ## [b .. [a .. a] .. b]
                push @rb, [$rangeb->[0], $rangea->[0] - 1,-3];
                push @rab, $rangea;
                $rangeb = [$rangea->[1] + 1, $rangeb->[1]];
                $rangea = undef;
              } elsif ($rangea->[1] > $rangeb->[1]) { ## [b .. [a .. b] .. a]
                push @rb, [$rangeb->[0], $rangea->[0] - 1,-4];
                push @rab, [$rangea->[0], $rangeb->[1],-5];
                $rangea = [$rangeb->[1] + 1, $rangea->[1]];
                $rangeb = undef;
              } else {                            ## [b .. [a .. ab]]
                push @rb, [$rangeb->[0], $rangea->[0] - 1,-6];
                push @rab, $rangea;
                $rangea = $rangeb = undef;
              }
            }
          }
        } else {
          if ($rangea->[1] eq 'Inf') {  
            if ($rangeb->[1] eq 'Inf') {          ## [[ab ..
              push @rab, $rangea;
              last;
            } else {                              ## [[ab .. b] ..
              push @rab, $rangeb;
              $rangea = [$rangeb->[1] + 1, 'Inf'];
              $rangeb = undef;
            }
          } else {
            if ($rangeb->[1] eq 'Inf') {          ## [[ab .. a] ..
              push @rab, $rangea;
              $rangeb = [$rangea->[1] + 1, 'Inf'];
              $rangea = undef;
            } else {
              if ($rangea->[1] < $rangeb->[1]) {  ## [[ab .. a] .. b]
                push @rab, $rangea;
                $rangeb = [$rangea->[1] + 1, $rangeb->[1]];
                $rangea = undef;
              } elsif ($rangea->[1] > $rangeb->[1]) { ## [[ab .. b] .. a]
                push @rab, $rangeb;
                $rangea = [$rangeb->[1] + 1, $rangea->[1]];
                $rangeb = undef;
              } else {                            ## [[ab .. ab]]
                push @rab, $rangea;
                $rangea = $rangeb = undef;
              }
            }
          }
        }
      }
    }
    return (\@ra, \@rab, \@rb);
  };

          ## --- State operations

          ## Copy a set of states.  This is used to resolve
          ## references in |lAssignmentStatement|.
          my $copy_state = sub ($$$) {
            my ($token, $original_name, $new_prefix) = @_;
            my @copy = ($original_name.$;.'0');
            my @cs;
            while (@copy) {
              my $cname = shift @copy;
              next if $token->{$new_prefix, $cname};
              my $original = $token->{$cname};
              $token->{$new_prefix, $cname} = my $new = {
                name => $new_prefix.$;.$cname,
                next_state => [],
              };
              for my $nxt (@{$original->{next_state}}) {
                push @{$new->{next_state}},
                     [$nxt->[0], $new_prefix.$;.$nxt->[1]];
                push @copy, $nxt->[1];
              }
              if ($original->{accept}) {
                push @cs, $new;
              }
            } # @copy
            return @cs;
          }; # copy_state

          ## Makes a DFA state from a set of NFA states
          my $make_dfa_state = sub ($@) {
            my ($token, $dfa, @src_name) = @_;
            my @src = map {$token->{$_}} @src_name;
            my $next_state = [[[], [$;.'dummy']]];
        
            my @rsb = map {@{$_->{next_state}}} @src;
            for my $rsb (@rsb) {
              my $new_next_state = [];
              RSA: for my $rsa (@$next_state) {
                if (not $rsb) {
                  push @$new_next_state, $rsa if @{$rsa->[0]};
                  next RSA;
                }
                my ($ra, $rab, $rb) = $and_minus_ranges->($rsa->[0], $rsb->[0]);
                push @$new_next_state, [$ra, $rsa->[1]] if @$ra;
                push @$new_next_state, [$rab, [sort {$a cmp $b} @{$rsa->[1]}, $rsb->[1]]] if @$rab;
                if (@$rb) {
                  $rsb = [$rb, $rsb->[1]];
                } else {
                  $rsb = undef;
                }
              } # RSA
              if ($rsb) {
                push @$new_next_state, [$rsb->[0], [$rsb->[1]]];
              }
              $next_state = $new_next_state;
            }
        
            my $state_name = join $;.$;, @src_name;
            $dfa->{$state_name} = {
              name => $state_name,
              next_state => @rsb ? $next_state : [],
            };
        
            for (@src) {
              if ($_->{accept}) {
                $dfa->{$state_name}->{accept} = $_->{accept};
                $dfa->{$state_name}->{value} = 1 if $_->{value};
              }
              $dfa->{$state_name}->{ignore} = 1 if $_->{ignore};
            }
          }; # make_dfa_state

          ## Converts an internal state name to a Perl name
          my $escape_state_name = sub ($) {
            my $s = shift;
            $s =~ s/([\W_])/sprintf '_%08X', ord $1/ge;
            $s =~ s/_0000001C/__/g;
            return $s;
          }; # escape_state_name
      
          ## Converts a DFA state into Perl lexer code
          my %ancestor_state;
          my $state_to_code;
          $state_to_code = sub ($$$$%) {
            my ($dfa, $parent, $state_name, $factory, %opt) = @_;
            $ancestor_state{$state_name} = 1;
        
        my $state_block = $parent->append_new_pc_block;
        my $estate_name = $escape_state_name->($state_name);
        $state_block->label ('S'.$estate_name);
        my $state_select;
        
        if ($opt{outermost}) {
          $state_block->append_statement
                      ->append_new_pc_variable ('@', undef, 'ch')
                      ->variable_scope ('my');
        }
        
        if (@{$dfa->{$state_name}->{next_state}}) {
          my $spush = $state_block->append_statement;
          for ($spush->append_new_pc_function_call (undef, 'push')
                     ->append_new_pc_expression (',')) {
            $_->append_new_pc_variable ('@', undef, 'ch');
            $_->append_new_pc_variable ('$', undef, 'ch');
          }
          $state_block->parent_node->insert_before ($spush, $state_block)
            unless $opt{outermost};
              ## NOTE: This statement must be placed before the named block;
              ##       otherwise token value cannot be correctly returned
              ##       when |redo|ne.  An exception is the outermost state.
          
          for my $as ($state_block->append_statement
                                  ->append_new_pc_expression ('=')) {
            $as->append_new_pc_variable ('$', undef, 'ch')
               ->variable_scope ('my');
            for ($as->append_new_pc_expression ('->')) {
              $_->append_new_pc_variable ('$', undef, 'self');
              $_->append_atom ('_shift_char');
            }
          }
        
          $state_select = $state_block->append_new_pc_choose;
          for my $rs (@{$dfa->{$state_name}->{next_state}}) {
            my $when = $state_select->append_new_pc_when;
          
            my $cond = $when->condition;
            my $cond_and = $cond->append_new_pc_expression ('or');
            for my $range (@{$rs->[0]}) {
              if ($range->[0] == $range->[1]) {
                my $match = $cond_and->append_new_pc_expression ('==');
                $match->append_new_pc_variable ('$', undef, 'ch');
                $match->append_new_pc_number_literal ($range->[0]);
              } else {
                my $x_range = $cond_and->append_new_pc_expression ('and');
                my $x_range_s = $x_range->append_new_pc_expression ('<=');
                $x_range_s->append_new_pc_number_literal ($range->[0]);
                $x_range_s->append_new_pc_variable ('$', undef, 'ch');
                unless ($range->[1] eq 'Inf') {
                  my $x_range_e = $x_range->append_new_pc_expression ('<=');
                  $x_range_e->append_new_pc_variable ('$', undef, 'ch');
                  $x_range_e->append_new_pc_number_literal ($range->[1]);
                }
              }
            }
          
            my $when_block = $when->block;
            my $next_state_name = join $;.$;, @{$rs->[1]};
            if ($ancestor_state{$next_state_name}) {
              $when_block->append_child ($spush->clone_node (1));
              $when_block->append_statement
                         ->append_new_pc_function_call (undef, 'redo')
                         ->append_new_pc_variable
                             ('', undef, 'S'.$escape_state_name->($next_state_name));
            } else {
              $state_to_code->($dfa, $when_block, $next_state_name, $factory,
                               outermost => 0);
            }
          } # for next_state
        }

        if ($dfa->{$state_name}->{accept}) {
          if ($state_select) {
            for ($state_select->append_new_pc_otherwise->block) {
              my $push_ap = $_->append_statement
                              ->append_new_pc_function_call
                                          (undef, 'unshift')
                              ->append_new_pc_expression (',');
              for ($push_ap->append_new_pc_dereference ('@')
                           ->append_new_pc_expression ('->')) {
                $_->append_new_pc_variable ('$', undef, 'self');
                $_->append_bare ('{char}');
              }
              $push_ap->append_new_pc_variable ('$', undef, 'ch');
              for ($_->append_statement->append_new_pc_expression ('=')) {
                $_->append_new_pc_variable ('$', undef, 'ch');
                $_->append_new_pc_number_literal (-2);
              }
            }
          }
          my $accept_code_parent = $state_block;
          unless ($dfa->{$state_name}->{ignore}) {
            my %value;
            if ($dfa->{$state_name}->{value}) {
              ## Removes dummy item
              $accept_code_parent->append_statement
                                 ->append_new_pc_function_call (undef, 'shift')
                                 ->append_new_pc_variable ('@', undef, 'ch');
              for ($accept_code_parent->append_statement
                                      ->append_new_pc_expression ('=')) {
                $_->append_new_pc_variable ('$', undef, 'token_val')
                  ->variable_scope ('my');
                $_->append_string_literal ('');
              }
              for ($accept_code_parent->append_new_pc_choose
                                      ->append_new_pc_when) {
                for ($_->condition->append_new_pc_expression ('>')) {
                  $_->append_new_pc_variable ('$', undef, 'ch');
                  $_->append_new_pc_number_literal (-1);
                }
                for ($_->block->append_statement
                              ->append_new_pc_function_call (undef, 'push')
                              ->append_new_pc_expression (',')) {
                  $_->append_new_pc_variable ('@', undef, 'ch');
                  $_->append_new_pc_variable ('$', undef, 'ch');
                }
              }
              for ($accept_code_parent->append_new_pc_while) {
                $_->condition->append_new_pc_variable ('@', undef, 'ch');
                for ($_->block->append_statement
                              ->append_new_pc_expression ('.=')) {
                  $_->append_new_pc_variable ('$', undef, 'token_val');
                  $_->append_new_pc_function_call (undef, 'chr')
                    ->append_new_pc_function_call (undef, 'shift')
                    ->append_new_pc_variable ('@', undef, 'ch');
                }
              }
              $value{value} = $accept_code_parent->append_new_pc_variable
                                                     ('$', undef, 'token_val');
            }
            $accept_code_parent->append_statement
                       ->append_new_pc_function_call (undef, 'return')
                       ->append_new_pc_literal ({
                           type => $dfa->{$state_name}->{accept},
                           %value,
                         });
          } else {
            $accept_code_parent->append_statement
                       ->append_new_pc_function_call (undef, 'redo')
                       ->append_new_pc_variable
                           ('', undef, 'S'.$escape_state_name->($;.'initial'));
          }
        } elsif ($opt{outermost}) {
          if ($state_select) {
          for ($state_select->append_new_pc_when) {
            for ($_->condition->append_new_pc_expression ('==')) {
              $_->append_new_pc_variable ('$', undef, 'ch');
              $_->append_new_pc_number_literal (-1);
            }
            $_->block->append_statement
                     ->append_new_pc_function_call (undef, 'return')
                     ->append_new_pc_literal ({
                         type => '#EOF',
                       });
          }}
          my $chr_ch = $factory
                         ->create_pc_function_call (undef, 'chr');
          $chr_ch->append_new_pc_variable ('$', undef, 'ch');
          $state_block->append_statement
                      ->append_new_pc_function_call (undef, 'return')
                      ->append_new_pc_literal ({
                          type => '#INVALID',
                          value => $chr_ch,
                        });
        } else {
          my $push_ap = $state_block->append_statement
                                    ->append_new_pc_function_call
                                          (undef, 'unshift')
                                    ->append_new_pc_expression (',');
          for ($push_ap->append_new_pc_dereference ('@')
                       ->append_new_pc_expression ('->')) {
            $_->append_new_pc_variable ('$', undef, 'self');
            $_->append_bare ('{char}');
          }
          $push_ap->append_new_pc_variable ('$', undef, 'ch');
        }
        
            $ancestor_state{$state_name} = 0;
          }; # $state_to_code

    
          ## --- Tokenizer preparation
            ## TODO: Multiple tokenizer support required

          my $tokenizer = $codeDocument->create_perl_sub ('_shift_token');
          $r-><M::Node.appendChild> ($tokenizer);
          $tokenizer->prototype ('$');
  my $tokenizer_param = $tokenizer->append_statement
                                  ->append_new_pc_expression ('=');
  $tokenizer_param->append_new_pc_variable ('$', undef, 'self')
                  ->variable_scope ('my');
  $tokenizer_param->append_new_pc_function_call (undef, 'shift');
  my $if_stack = $tokenizer->append_new_pc_choose
                           ->append_new_pc_when;
  my $stack_array = $if_stack->condition->append_new_pc_dereference ('@');
  for ($stack_array->append_new_pc_expression ('->')) {
    $_->append_new_pc_variable ('$', undef, 'self');
    $_->append_bare ('{token}');
  }
  $if_stack->block
           ->append_statement
           ->append_new_pc_function_call (undef, 'return')
           ->append_new_pc_function_call (undef, 'shift')
           ->append_child ($stack_array->clone_node (1));

          ## --- For each child elements (rule or lexmode)...

          my %rules;       # defined parser rules
          my %root_rules;  # defined |standalone| parser rules
          my %external_rules; # defined |external| parser rules
          my %token_error;
          my $default_token_error;

          B: for my $cel (@{$self-><AG::Node.childNodes>}) {
            my $xuri = $cel->namespace_uri . $cel->local_name;

            ## -- Rule element - adds reference to hash
            if ($xuri eq <Q::pg:rule>) {
              my $name = $cel->get_attribute_ns (undef, 'name');
              $rules{$name} = {source => $cel, param => []};
              $external_rules{$name} = true
                if $cel-><M::Element.getAttributeNS> (null, 'isExternal');
              $root_rules{$name}
                = $cel-><M::DPGElementAttribute.dpgGetAttribute> ('perl-name')
                || $name
                if $cel-><M::DPGElementAttribute.dpgGetAttribute>
                           ('standalone') or
                   $external_rules{$name};
      
              ## Creates a list of parameters
              C: for my $paramspec (@{$cel->child_nodes}) {
                next C unless $paramspec->namespace_uri eq <Q::pg:>;
                next C unless $paramspec->local_name eq 'parameterDeclaration';
                push @{$rules{$name}->{param}},
                     $paramspec->get_attribute_ns (undef, 'name');
              }

            ## -- Token error element - error handling code
            } elsif ($xuri eq <Q::pg:tokenError>) {
              my $name = $cel-><M::Element.getAttributeNS> (null, 'name');
              $token_error{$name} = {
                source => $cel,
                param => [],
              };
              if ($cel-><M::DPGElementAttribute.dpgGetAttribute> ('default')) {
                $default_token_error = $name;
              }
      
              ## Creates a list of parameters
              C: for my $paramspec (@{$cel->child_nodes}) {
                next C unless $paramspec->namespace_uri eq <Q::pg:>;
                next C unless $paramspec->local_name eq 'parameterDeclaration';
                push @{$token_error{$name}->{param}},
                     $paramspec-><M::Element.getAttributeNS> (null, 'name');
              }

            ## -- Lexmode element - generate tokenizer
            } elsif ($xuri eq <Q::pg:lexmode>) {
              ## TODO: Multiple lexmode support
    
      my %token = ($;.'initial' => {
        name => $;.'initial',
        next_token => [],
      });

      for my $tel (grep {$_->node_type == $_->ELEMENT_NODE} @{$cel->child_nodes}) {
        my $xuri = $tel->namespace_uri . $tel->local_name;
        if ($xuri eq <Q::pg:lAssignmentStatement>) {
          my $sname = $tel->get_attribute_ns (undef, 'name');
          my $is_variable = $tel-><M::Element.getAttributeNS>
                                    (null, 'isVariable');
          $sname = '$' . $sname if $is_variable;
          my $i = 0;
          if ($token{$sname, $i}) {
            die qq<"$sname" is already defined>;
            ## TODO: exception
          }
          my $s0 = $token{$sname, $i} = {
            name => $sname.$;.$i,
            next_state => [],
          };
          my @current_state = ($s0);
          my $ignore = $tel-><M::DPGElementAttribute.dpgGetAttribute> ('ignore');
          my $value = $tel-><M::DPGElementAttribute.dpgGetAttribute> ('value');
          for my $lel (grep {$_->node_type == $_->ELEMENT_NODE} @{$tel->child_nodes}) {
            my $xuri = $lel->namespace_uri . $lel->local_name;
            if ($xuri eq <Q::pg:charClass> or $xuri eq <Q::pg:anyChar>) {
              my $range = [];
              if ($xuri eq <Q::pg:charClass>) {
                for my $mel (grep {$_->node_type == $_->ELEMENT_NODE} @{$lel->child_nodes}) {
                  my $xuri = $mel->namespace_uri . $mel->local_name;
                  if ($xuri eq <Q::pg:string>) {
                    $range = $add_range->($range, ord $mel->text_content);
                  } elsif ($xuri eq <Q::pg:charRange>) {
                    $range = $add_range->($range, $mel->get_attribute_ns (undef, 'start'),
                                                $mel->get_attribute_ns (undef, 'end'));
                  }
                }
                if ($lel->get_attribute_ns (undef, 'negative')) {
                  $range = $negate_range->($range);
                }
              } else { # pg:anyChar
                $range = [0, 'Inf'];
              }
              
              my $new_s = {
                name => $sname.$;.(++$i),
                next_state => [],
              };
              my $v = $lel->get_attribute_ns (undef, 'occurence');
              if ($v eq 'zeromore') {
                $token{$new_s->{name}} = $new_s;
                push @{$new_s->{next_state}}, [$range, $new_s->{name}];
                for my $s (@current_state) {
                  push @{$s->{next_state}}, [$range, $new_s->{name}];
                }
                push @current_state, $new_s;
              } elsif ($v eq 'zeroone') {
                $token{$new_s->{name}} = $new_s;
                for my $s (@current_state) {
                  push @{$s->{next_state}}, [$range, $new_s->{name}];
                }
                push @current_state, $new_s;
              } elsif ($v eq 'onemore') {
                $token{$new_s->{name}} = $new_s;
                push @{$new_s->{next_state}}, [$range, $new_s->{name}];
                for my $s (@current_state) {
                  push @{$s->{next_state}}, [$range, $new_s->{name}];
                }
   \            @current_state = ($new_s);
              } else { # one
                $token{$new_s->{name}} = $new_s;
                for my $s (@current_state) {
                  push @{$s->{next_state}}, [$range, $new_s->{name}];
                }
   \            @current_state = ($new_s);
              }
            } elsif ($xuri eq <Q::pg:lVariableRef>) {
              my $rrulename = '$'.$lel->get_attribute_ns (undef, 'name');
              my @new_current_state;
              if ($token{$rrulename, 0}) {
   \            @new_current_state
                  = $copy_state->(\%token, $rrulename => $sname.$;.(++$i));
              } else {
                die "$rrulename is not defined";
                ## TODO: exception
              } 
              my $v = $lel->get_attribute_ns (undef, 'occurence');
              if ($v eq 'zeromore') {
                for my $s (@current_state, @new_current_state) {
                  push @{$s->{next_state}},
   \                   @{$token{$sname, $i, $rrulename, 0}->{next_state}};
                }
                push @current_state, @new_current_state;
              } elsif ($v eq 'zeroone') {
                for my $s (@current_state) {
                  push @{$s->{next_state}},
   \                   @{$token{$sname, $i, $rrulename, 0}->{next_state}};
                }
                push @current_state, @new_current_state;
              } elsif ($v eq 'onemore') {
                for my $s (@current_state, @new_current_state) {
                  push @{$s->{next_state}},
   \                   @{$token{$sname, $i, $rrulename, 0}->{next_state}};
                }
   \            @current_state = @new_current_state;
              } else { # one
                for my $s (@current_state) {
                  push @{$s->{next_state}},
   \                   @{$token{$sname, $i, $rrulename, 0}->{next_state}};
                }
   \            @current_state = @new_current_state;
              }
            } # $xuri
          } # $lel
          push @{$token{$;.'initial'}->{next_state}}, @{$s0->{next_state}}
            unless $is_variable;
          for my $s (@current_state) {
            $s->{accept} = $sname;
            $s->{ignore} = $ignore if $ignore;
            $s->{value} = $value if $value;
          }
        }
      }

      my %dfa;
      my @req_state = ([$;.'initial']);
      while (@req_state) {
        my $req_state = shift @req_state;
        my $req_state_name = join $;.$;, @$req_state;
        next if $dfa{$req_state_name};
        $make_dfa_state->(\%token, \%dfa, @$req_state);
        for (@{$dfa{$req_state_name}->{next_state}}) {
          push @req_state, $_->[1];
        }
      }
      
      for ($tokenizer->append_statement
                     ->append_new_pc_expression ('=')) {
        $_->append_new_pc_variable ('$', undef, 'ch')
          ->variable_scope ('my');
        $_->append_new_pc_number_literal (-2);
      }
      
              $state_to_code->(\%dfa, $tokenizer, $;.'initial',
                               $codeDocument, outermost => 1);
            } # xuri
          } # B


          $state_to_code = null;


          ## --- Generates parser methods

          ## Template for 'get next token' statements
          my $next_token_code = $codeDocument->create_pc_statement;
          for ($next_token_code->append_new_pc_expression ('=')) {
            $_->append_new_pc_variable ('$', undef, 'token');
            for ($_->append_new_pc_expression ('->')) {
              $_->append_new_pc_variable ('$', undef, 'self');
              $_->append_bare ('_shift_token');
            }
          }

          ## Error handling code
          unless ($default_token_error) {
            $default_token_error = $;.'default-token-error';
            my $root = $codeDocument-><M::pc|PCDocument.createPCStatement>;
            for ($root-><M::pc|PerlCodeUnits.appendNewPCFunctionCall>
                          (null, 'die')
                      -><M::pc|PerlCodeUnits.appendNewPCExpression> ('->')) {
              $_-><M::pc|PerlCodeUnits.appendNewPCVariable>
                          ('$', null, 'token');
              $_-><M::pc|PerlCodeUnits.appendBare> ('{type}');
            }
            $token_error{$default_token_error} = {
              code => $root,
            };
          }

          ## Converts an expression in rule block into Perl expression
          my $rexpression_to_code = sub ($$) {
            my ($parent, $source_parent) = @_;
    $parent = $parent->append_new_pc_expression (',');
    C: for my $child (@{$source_parent->child_nodes}) {
      next C unless $child->node_type == $child->ELEMENT_NODE;
      my $xuri = $child->namespace_uri . $child->local_name;
      if ($xuri eq <Q::pg:memberRef>) {
        my $context = $parent->append_new_pc_expression ('->');
        D: for my $child (@{$child->child_nodes}) {
          next D unless $child->node_type == $child->ELEMENT_NODE;
          my $xuri = $child->namespace_uri . $child->local_name;
          if ($xuri eq <Q::pg:variable>) {
            $context->append_new_pc_variable
              ('$', undef, $child->get_attribute_ns (undef, 'name'));
          } elsif ($xuri eq <Q::pg:member>) {
            $context->append_bare ('{'.$child->get_attribute_ns (undef, 'name').'}');
          }
        }
      } elsif ($xuri eq <Q::pg:string>) {
        $parent->append_string_literal ($child->text_content);
              }
            }
          }; # rexpression_to_code
  
          ## Converts a statement in rule block into Perl code
          my $block_id = 0;
          my $rstatement_to_code;
          $rstatement_to_code = sub ($$$$$$) {
            my ($parent, $statement, $next_token_required, $rules, $root_rules,
                $factory) = @_;
            my $xuri = $statement->namespace_uri . $statement->local_name;
            if ($xuri eq <Q::pg:matchStatement>) {
              my $match_parent = $parent;
              my $match_occur = $statement-><M::Element.getAttributeNS>
                                              (null, 'occurence');
      if ($match_occur eq 'onemore') {
        $match_parent = $match_parent->append_new_pc_block;
        for ($match_parent->append_statement->append_new_pc_expression ('=')) {
          $_->append_new_pc_variable ('$', undef, 'has_content')
            ->variable_scope ('my');
          $_->append_new_pc_number_literal (0);
        }
      }
      
      my $match_block_id = 0;
      if ($match_occur eq 'zeromore' or $match_occur eq 'onemore') {
        $match_parent = $match_parent->append_new_pc_block;
        $match_parent->label ('MATCH_' . ($match_block_id = ++$block_id));
      }
      
      my $match_choose = $match_parent->append_new_pc_choose;
      my $token_type_var = $factory->create_pc_expression ('->');
      $token_type_var->append_new_pc_variable ('$', undef, 'token');
      $token_type_var->append_bare ('{type}');
      my $has_sep;
      C: for my $child (@{$statement->child_nodes}) {
        next C unless $child->node_type == $child->ELEMENT_NODE;
        my $xuri = $child->namespace_uri . $child->local_name;
        if ($xuri eq <Q::pg:matchBlock>) {
          my $token_name = $child->get_attribute_ns (undef, 'token');
          if ($child-><M::Element.getAttributeNS> (null, 'isReservedToken')) {
            $token_name = '#' . $token_name;
          }

          my $cond = $factory-><M::pc|PCDocument.createPCExpression> ('eq');
          $cond-><M::Node.appendChild>
                   ($token_type_var-><M::Node.cloneNode> (true));
          $cond-><M::pc|PerlCodeUnits.appendStringLiteral> ($token_name);
          if ($child-><M::Element.getAttributeNS> (null, 'valueOperation') eq
              '==') {
            for ($factory-><M::pc|PCDocument.createPCExpression> ('and')) {
              $_-><M::Node.appendChild> ($cond);
              for ($_-><M::pc|PerlCodeUnits.appendNewPCExpression> ('eq')) {
                for ($_-><M::pc|PerlCodeUnits.appendNewPCExpression> ('->')) {
                  $_-><M::pc|PerlCodeUnits.appendNewPCVariable>
                    ('$', null, 'token');
                  $_-><M::pc|PerlCodeUnits.appendBare> ('{value}');
                }
                $_-><M::pc|PerlCodeUnits.appendStringLiteral>
                  ($child-><M::Element.getAttributeNS> (null, 'value'));
              }
              $cond = $_;
            }
          }
          
          my $is_sep = $child-><M::DPGElementAttribute.dpgGetAttribute>
                                                    ('separator');
          my $token_parent;
          unless ($is_sep) {
            for ($match_choose->append_new_pc_when) {
              $_-><AG::pc|PCWhen.condition>
                -><M::Node.appendChild> ($cond);
              $token_parent = $_->block;
            }
            if ($match_occur eq 'onemore') {
              for ($token_parent->append_statement->append_new_pc_expression ('=')) {
                $_->append_new_pc_variable ('$', undef, 'has_content');
                $_->append_new_pc_number_literal (1);
              }
            }
          } else { # separator
            $has_sep = 1;
            for ($match_parent->append_new_pc_choose) {
              for ($_->append_new_pc_when) {
                $_-><AG::pc|PCWhen.condition>
                  -><M::Node.appendChild> ($cond);
                $token_parent = $_->block;
              }
              for ($_->append_new_pc_otherwise->block) {
                $_->append_statement
                  ->append_new_pc_function_call (undef, 'last')
                  ->append_new_pc_variable ('', undef, 'MATCH_'.$match_block_id);
              }
            }
          }
          
          ## Child statements
          $next_token_required = 1;
          D: for my $child (@{$child->child_nodes}) {
            next D unless $child->node_type == $child->ELEMENT_NODE;
            ($next_token_required, undef)
              = $rstatement_to_code->($token_parent, $child,
                                      $next_token_required,
                                      $rules, $root_rules, $factory);
          }
          
          if ($next_token_required) {
            $token_parent->append_child ($next_token_code->clone_node (1));
            $next_token_required = 0;
          }

          if ($is_sep and
              ($match_occur eq 'zeromore' or $match_occur eq 'onemore')) {
            $token_parent-><M::pc|PerlCodeStatements.appendStatement>
                  -><M::pc|PerlCodeUnits.appendNewPCFunctionCall>
                                 (null, 'redo')
                  -><M::pc|PerlCodeUnits.appendNewPCVariable>
                                 ('', null, 'MATCH_'.$match_block_id);
          }
    
        }
      } # pc:matchStatement children
      
      if (not $match_occur or $match_occur eq 'onemore') {
        my $err_block = $match_choose->append_new_pc_otherwise->block;
        if ($match_occur eq 'onemore') {
          $err_block = $err_block->append_new_pc_choose->append_new_pc_when->block;
          for ($err_block->parent_node->condition->append_new_pc_expression ('==')) {
            $_->append_new_pc_variable ('$', undef, 'has_content');
            $_->append_new_pc_number_literal (0);
          }
        }
  
                  my $terr_name = $default_token_error;
                  unless ($token_error{$terr_name}->{code}) {
                    ## Child statements
                    C: for my $child (@{$token_error{$terr_name}->{source}
                                              -><AG::Node.childNodes>}) {
                      next C unless $child-><AG::Node.nodeType> ==
                                    <C::Node.ELEMENT_NODE>;
                      $rstatement_to_code->($err_block, $child, true,
                                            $rules, $root_rules, $factory);
                    }
                    $token_error{$terr_name}->{code}
                      = $err_block-><M::Node.cloneNode> (true);
                  } else {
                    $err_block-><AG::Node.parentNode>
                               -><M::Node.replaceChild>
                       (my $teb = $token_error{$terr_name}->{code}
                              -><M::Node.cloneNode> (true), $err_block);
                    $err_block = $teb;
                  }
          
                  my %param;
                  C: for my $child (@{$statement-><AG::Node.childNodes>}) {
                    if ($child-><AG::Node.namespaceURI> .
                        $child-><AG::Node.localName> eq
                        <Q::pg:parameterSpecification>) {
                      $param{$child-><M::Element.getAttributeNS>
                                       (null, 'name')} = $child;
                    }
                  }
          
                  my $block_first = $err_block-><AG::Node.firstChild>;
                  for my $param_name (reverse @{$token_error{$terr_name}
                                                      ->{param}}) {
                    $block_first = $err_block-><M::Node.insertBefore>
                             ($factory-><M::pc|PCDocument.createPCStatement>,
                              $block_first);
                    for ($block_first-><M::pc|PerlCodeUnits
                                            .appendNewPCExpression> ('=')) {
                      $_-><M::pc|PerlCodeUnits.appendNewPCVariable>
                                ('$', null, $param_name)
                        -><AS::pc|PerlVariable.variableScope> ('my');
                      if ($param{$param_name}) {
                        $rexpression_to_code->($_, $param{$param_name});
                      } else {
                        $_-><M::pc|PerlCodeUnits.appendAtom> ('undef');
                      }
                    }
                  }
              }
      
      if (not $has_sep and ($match_occur eq 'zeromore' or $match_occur eq 'onemore')) {
        for ($match_choose->append_new_pc_otherwise->block) {
                
          $_->append_statement
                           ->append_new_pc_function_call (undef, 'last')
                           ->append_new_pc_variable ('', undef, 'MATCH_'.$match_block_id);
        }
        $match_parent->append_statement
                     ->append_new_pc_function_call (undef, 'redo')
                     ->append_new_pc_variable ('', undef, 'MATCH_'.$match_block_id);
      }

              return 0; # next_token_required == 0

            } elsif ($xuri eq <Q::pg:embedStatement>) {
              my $lang = $statement->get_attribute_ns (undef, 'type');
              if ($lang eq <Q::lang:Perl>) {
                my %param;
                my $source;
                C: for my $child (@{$statement->child_nodes}) {
                  next C unless $child->node_type == $child->ELEMENT_NODE;
                  my $xuri = $child-><AG::Node.namespaceURI>
                           . $child-><AG::Node.localName>;
                  if ($xuri eq <Q::pg:parameterSpecification>) {
                    $param{$child-><M::Element.getAttributeNS> (undef, 'name')}
                      = $child;
                  } elsif ($xuri eq <Q::pg:embedBlock>) {
                    $source = $child-><AG::Node.textContent>;
                  }
                }

                my $plcode = $disResource-><M::dp|DISResourcePerl||DIS|ForLatest
                                                .plPreprocessPerlCode>
                                 ($source, namespace_context => $contextObject);

                my $dparent = $parent-><AG::Node.ownerDocument>
                                   -><M::pc|PCDocument.createPCExpression> (',');
                for (keys %param) {
                  $rexpression_to_code->($dparent, $param{$_});
                  $plcode-><M::pc|PerlCode.replaceVariable>
                    ('$'.$_ => $dparent-><AG::Node.lastChild>);
                }

                $parent-><M::pc|PerlCodeStatements.appendCodeFragment> ($plcode);
                return $next_token_required;
              } else {
                die qq<Lexical content type <$lang> is not supported>;
                ## TODO: exception
              }

            } elsif ($xuri eq <Q::pg:myStatement>) {
              my $name = $statement-><M::Element.getAttributeNS> (null, 'name');
              $parent-><M::pc|PerlCodeStatements.appendStatement>
                     -><M::pc|PerlCodeUnits.appendNewPCVariable>
                         ('$', null, $name)
                     -><AS::pc|PerlVariable.variableScope> ('my');

              return $next_token_required;
    
    } elsif ($xuri eq <Q::pg:ruleRefStatement>) {
      my $rule_name = $statement->get_attribute_ns (undef, 'name');
      if ($rules->{$rule_name}) {
        if ($root_rules->{$rule_name}) {
          unless ($next_token_required) {
            for ($parent->append_statement
                        ->append_new_pc_function_call (undef, 'push')
                        ->append_new_pc_expression (',')) {
              for ($_->append_new_pc_dereference ('@')
                     ->append_new_pc_expression ('->')) {
                $_->append_new_pc_variable ('$', undef, 'self');
                $_->append_bare ('{token}');
              }
              $_->append_new_pc_variable ('$', undef, 'token');
            }
          }
       
          
          my $param_spec_list;
          for ($parent->append_statement->append_new_pc_apply) {
            for ($_->append_new_pc_expression ('->')) {
              $_->append_new_pc_variable ('$', undef, 'self');
              $_->append_bare ('_parse_' . $root_rules->{$rule_name});
            }
            $param_spec_list = $_->append_new_pc_expression (',');
          }
          
          my %param;
          C: for my $child (@{$statement->child_nodes}) {
            next C unless $child->node_type == $child->ELEMENT_NODE;
            if ($child->namespace_uri . $child->local_name eq
                <Q::pg:parameterSpecification>) {
              $param{$child->get_attribute_ns (undef, 'name')} = $child;
            }
          }
          
          for my $param_name (@{$rules->{$rule_name}->{param}}) {
            if ($param{$param_name}) {
              $rexpression_to_code->($param_spec_list, $param{$param_name});
            } else {
              $param_spec_list->append_atom ('undef');
            }
          }
          
                  return 1; # next_token_required == 1
                } else { # not a standalone rule
                  my $block;
                  unless ($rules->{$rule_name}->{code}
                                ->[$next_token_required += 0]) {
                    $block = $parent-><M::pc|PerlCodeStatements
                                         .appendNewPCBlock>;
                    $rules->{$rule_name}->{code}->[$next_token_required]
                      = [$block, $next_token_required]; # prevent infinite loop
                    my $o_next_token_required = $next_token_required;
            
                    ## Child statements
                    C: for my $child (@{$rules->{$rule_name}->{source}
                                              -><AG::Node.childNodes>}) {
                      next C unless $child-><AG::Node.nodeType> ==
                                    <C::Node.ELEMENT_NODE>;
                      ($next_token_required, undef)
                        = $rstatement_to_code->($block, $child,
                                                $next_token_required,
                                                $rules, $root_rules, $factory);
                    }
                    $rules->{$rule_name}->{code}->[$o_next_token_required]
                      = [$block-><M::Node.cloneNode> (true),
                         $next_token_required];
                  } else {
                    $block = $parent-><M::Node.appendChild>
                       ($rules->{$rule_name}->{code}
                              ->[$next_token_required]->[0]
                              -><M::Node.cloneNode> (true));
                    $next_token_required
                      = $rules->{$rule_name}->{code}
                              ->[$next_token_required]->[1];
                  }
          
                  my %param;
                  C: for my $child (@{$statement-><AG::Node.childNodes>}) {
                    if ($child-><AG::Node.namespaceURI> .
                        $child-><AG::Node.localName> eq
                        <Q::pg:parameterSpecification>) {
                      $param{$child-><M::Element.getAttributeNS>
                                       (null, 'name')} = $child;
                    }
                  }
          
                  my $block_first = $block-><AG::Node.firstChild>;
                  for my $param_name (reverse @{$rules->{$rule_name}
                                                      ->{param}}) {
                    $block_first = $block-><M::Node.insertBefore>
                             ($factory-><M::pc|PCDocument.createPCStatement>,
                              $block_first);
                    for ($block_first-><M::pc|PerlCodeUnits
                                            .appendNewPCExpression> ('=')) {
                      $_-><M::pc|PerlCodeUnits.appendNewPCVariable>
                                ('$', null, $param_name)
                        -><AS::pc|PerlVariable.variableScope> ('my');
                      if ($param{$param_name}) {
                        $rexpression_to_code->($_, $param{$param_name});
                      } else {
                        $_-><M::pc|PerlCodeUnits.appendAtom> ('undef');
                      }
                    }
                  }
            
                  return $next_token_required;
                }
      } elsif ($rule_name eq 'builtin:nestedBlockAsText') {
        my %param = (start_by_open => not $next_token_required,
                     open => '{', close => '}');
        
        C: for my $child (@{$statement->child_nodes}) {
          next C unless $child->node_type == $child->ELEMENT_NODE;
          if ($child->namespace_uri . $child->local_name eq
              <Q::pg:parameterSpecification>) {
            $param{$child->get_attribute_ns (undef, 'name')} = $child;
          }
        }
          
        for ($parent->append_statement->append_new_pc_apply) {
          for ($_->append_new_pc_expression ('->')) {
            $_->append_new_pc_variable ('$', undef, 'self');
            $_->append_bare ('_parse_nested_block_as_text');
          }
          my $param_spec_list = $_->append_new_pc_expression (',');
          for my $param_name (qw/doc parent open close start_by_open/) {
            if (ref $param{$param_name}) {
              $rexpression_to_code->($param_spec_list, $param{$param_name});
            } else {
              $param_spec_list->append_new_pc_literal ($param{$param_name});
            }
          }
        }
        
                return 1; # $next_token_required == 1
              } else {
                die qq<Rule "$rule_name" is not defined>;
                ## TODO: exception
              }



    } elsif ($xuri eq <Q::pg:assignmentStatement>) {
      my $assign = $parent->append_statement->append_new_pc_expression ('=');
      my $lvalue = $statement->first_child;
      if ($lvalue->namespace_uri . $lvalue->local_name eq <Q::pg:memberRef>) {
        my $context = $assign->append_new_pc_expression ('->');
        C: for my $child (@{$lvalue->child_nodes}) {
          my $xuri = $child->namespace_uri . $child->local_name;
          if ($xuri eq <Q::pg:variable>) {
            $context->append_new_pc_variable
              ('$', undef, $child->get_attribute_ns (undef, 'name'));
          } elsif ($xuri eq <Q::pg:member>) {
            $context->append_bare ('{'.$child->get_attribute_ns (undef, 'name').'}');
          }
        }
      }
              return $next_token_required;
    
            } elsif ($xuri eq <Q::pg:codeBlock>) {
              my $return;
      D: for my $child (@{$statement->child_nodes}) {
        next D unless $child->node_type == $child->ELEMENT_NODE;
        my $xuri = $child->namespace_uri . $child->local_name;
        if ($xuri eq <Q::pg:matchStatement>) {
          if ($next_token_required) {
            $parent->append_child ($next_token_code->clone_node (1));
            $next_token_required = false;
          }
                } elsif ($xuri eq <Q::pg:myStatement>) {
                  if ($child-><M::DPGElementAttribute.dpgGetAttribute>
                       ('return')) {
                    $return = $child-><M::Element.getAttributeNS> (null, 'name');
                  }
                }
                ($next_token_required, undef)
                  = $rstatement_to_code->($parent, $child,
                                          $next_token_required,
                                          $rules, $root_rules, $factory);
              }
              return ($next_token_required, $return);

            } else {
              ## ISSUE: Can unsupported elements safely ignored?
              return $next_token_required;
            } # xuri
          }; # rstatement_to_code

          ## -- Converts each |standalone| rules into Perl code
          for my $rule_name (grep {not $external_rules{$_}} keys %root_rules) {
            my $rule_sub = $codeDocument-><M::pc|PCDocument.createPerlSub>
                                      ('_parse_'.$root_rules{$rule_name});
            $r-><M::Node.appendChild> ($rule_sub);

            my $params_s = $rule_sub->append_statement;
            my @params = ('$self');
            my $proto = '$';
    
    $rule_sub->append_statement->append_new_pc_variable ('$', undef, 'token')
                               ->variable_scope ('my');
    
    ## Child statements
            my $return;
    my $next_token_required = 1;
    C: for my $child (@{$rules{$rule_name}->{source}->child_nodes}) {
      next C unless $child->node_type == $child->ELEMENT_NODE;
              if ($child-><AG::Node.namespaceURI> . $child-><AG::Node.localName>
                    eq <Q::pg:parameterDeclaration>) {
                push @params, '$'.$child-><M::Element.getAttributeNS>
                                    (null, 'name');
                $proto .= '$';
              } else {
                my $rv;
                ($next_token_required, $rv)
                  = $rstatement_to_code->($rule_sub, $child,
                                          $next_token_required,
 \                                        \%rules, \%root_rules,
                                          $codeDocument);
                $return ||= $rv;
              }
    }

            $params_s->append_code ('my ('.join (', ', @params).') = @_');
            $rule_sub->prototype ($proto);
  
    unless ($next_token_required) {
      for ($rule_sub->append_statement
                    ->append_new_pc_function_call (undef, 'push')
                    ->append_new_pc_expression (',')) {
        for ($_->append_new_pc_dereference ('@')
               ->append_new_pc_expression ('->')) {
          $_->append_new_pc_variable ('$', undef, 'self');
          $_->append_bare ('{token}');
        }
        $_->append_new_pc_variable ('$', undef, 'token');
      }
    }

            if ($return) {
              $rule_sub-><M::pc|PerlCodeStatements.appendStatement>
                       -><M::pc|PerlCodeUnits.appendNewPCFunctionCall>
                           (null, 'return')
                       -><M::pc|PerlCodeUnits.appendNewPCVariable>
                           ('$', null, $return);
            }
          
          } # for %root_rules

          $rstatement_to_code = null;

        }__;
##DPGRulesElement

ElementTypeBinding:
  @Name: NamedParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:MethodParameter
    @@DISPerl:isNamedParameter:1

IFClsETDef:
  @IFQName: DPGRuleElement
  @ClsQName: ManakaiDPGRuleElement
  @ETQName: pg|rule

  @IFISA: DPGElement
  @ClsISA: ManakaiDPGElement

  @IFISA: DPGElementAttribute
  @ClsISA: ManakaiDPGElementAttribute

##DPGRuleElement

IFClsETDef:
  @IFQName: DPGMatchBlockElement
  @ClsQName: ManakaiDPGMatchBlockElement
  @ETQName: pg|matchBlock

  @IFISA: DPGElement
  @ClsISA: ManakaiDPGElement
  
  @IFISA: DPGElementAttribute
  @ClsISA: ManakaiDPGElementAttribute

##DPGMatchBlockElement

IFClsETDef:
  @IFQName: DPGMyStatementElement
  @ClsQName: ManakaiDPGMyStatementElement
  @ETQName: pg|myStatement

  @IFISA: DPGElement
  @ClsISA: ManakaiDPGElement

  @IFISA: DPGElementAttribute
  @ClsISA: ManakaiDPGElementAttribute
##DPGMyStatementElement

IFClsETDef:
  @IFQName: DPGEmbedStatementElement
  @ClsQName: ManakaiDPGEmbedStatementElement
  @ETQName: pg|embedStatement

  @IFISA: DPGElement
  @ClsISA: ManakaiDPGElement

  @IFISA: DPGElementAttribute
  @ClsISA: ManakaiDPGElementAttribute
##DPGEmbedStatementElement

IFClsETDef:
  @IFQName: DPGLexmodeElement
  @ClsQName: ManakaiDPGLexmodeElement
  @ETQName: pg|lexmode
  
  @IFISA: DPGElement
  @ClsISA: ManakaiDPGElement

  @IFISA: DPGElementAttribute
  @ClsISA: ManakaiDPGElementAttribute

##DPGLexmodeElement

IFClsETDef:
  @IFQName: DPGLAssignmentStatementElement
  @ClsQName: ManakaiDPGLAssignmentStatementElement
  @ETQName: pg|lAssignmentStatement
  
  @IFISA: DPGElement
  @ClsISA: ManakaiDPGElement

  @IFISA: DPGElementAttribute
  @ClsISA: ManakaiDPGElementAttribute

##DPGLAssignmentStatementElement

IFClsETDef:
  @IFQName: DPGTokenErrorElement
  @ClsQName: ManakaiDPGTokenErrorElement
  @ETQName: pg|tokenError
  
  @IFISA: DPGElement
  @ClsISA: ManakaiDPGElement

  @IFISA: DPGElementAttribute
  @ClsISA: ManakaiDPGElementAttribute

##DPGTokenErrorElement

IFClsDef:
  @IFQName: DPGParser
  @ClsQName: ManakaiDPGParser

  @Implement: ecore|MUErrorTarget||ManakaiDOM|Perl

  @enDesc:
    A <IF::DPGParser> object parses a DPG source document and 
    converts it into a DOM tree representation.

    A <IF::DPGParser> object can be retrived by <M::GenericLS.createGLSParser>
    method in the Generic Load and Save module with feature string
    <Feature::DIS|DPG> version <FeatureVer::1.0>.

  @DISLang:role: DOMLS|ParserRole

  @Attr:
    @@Name: domConfig
    @@enDesc:
      The configuration of the parser.

    @@Get:
      @@@Type: DOMCore|DOMConfiguration
      @@@enDesc: The DOM configuration object.
      @@@PerlDef:
        __CODE{DOMCore|getConfigObject::
          $target => $self,
          $targetHash => $self,
          $targetType => {<IFName::DPGParser>},
          $result => $r,
        }__;

  @Method:
    @@ManakaiDOM:isForInternal:1
    @@ForCheck: ManakaiDOM|ForClass
    @@Operator: DISPerl|NewMethod
    @@enDesc:
      Creates a new instance of the object.
    @@Param:
      @@@Name: impl
      @@@Type: DOMLS|GLSImplementation
      @@@enDesc:
        The implementation from which the parser is created.
    @@Param:
      @@@Name: features
      @@@Type: DOMString
      @@@dis:actualType: f|FeaturesString
      @@@enDesc:
        The set of features requested for the parser.
    @@Return:
      @@@Type: DOMMain|DOMObject
      @@@dis:actualType: DPGParser
      @@@enDesc:
        The newly created parser.
      @@@PerlDef:
        $r = bless {
          <H::DOMCore:implementation>
            => $impl-><M::f|GetFeature.getFeature>
                 (<Q::DIS|DPG> => ''),
        }, $self;

  @Method:
    @@Name: parseString
    @@enDesc:
      Parses a string as DPG textual definition and converts it into
      its XML representation.
    @@Param:
      @@@Name: sourceText
      @@@Type: DOMString
      @@@enDesc:
        The text to parse.
    @@Param:
      @@@Name: namespaceContext
      @@@Type: DIS|NSResolverDIS||DIS|ForLatest
      @@@enDesc:
        The namespace prefix resolver against which <P::sourceText>
        is evaluated.

          {NOTE::
             Although namespace prefixes in DPG syntax are resolved
             by the parser, those in embed statements are not resolved
             as well as other context dependent information such as 
             base URI or method call.  In fact embed statement contents
             are transparently copied and not parsed at all.
          }
    @@Return:
      @@@Type: DPGDocument
      @@@enDesc:
        An XML representation of <P::sourceText>.
      @@@dx:raises:
        @@@@@: pg|PARSE_ERR
        @@@@enDesc:
          If the DPG document contains one or more error.
      @@@PerlDef:
        $self->{char} = [];
        $self->{token} = [];
        $self->{source} = $sourceText;
        $self->{nsresolver} = $namespaceContext;
        __DEEP{
          $r = $self->_parse_Rules ($self->{<H::DOMCore:implementation>});
        }__;

  @Method:
    @@Name: shiftChar
    @@ManakaiDOM:isForInternal:1
    @@ForCheck: ManakaiDOM|ForClass
    @@enDesc:
      Returns the next character.
    @@Return:
      @@@Type: idl|long||ManakaiDOM|all
      @@@enDesc:
        The code position number of the next character, if any,
        or <CODE::-2>.
      @@@PerlDef:
        if (@{$self->{char}}) {
          $r = shift @{$self->{char}};
        } else {
          my $char = substr ($self->{source}, pos ($self->{source}), 1);
          pos ($self->{source})++;

          if (length $char) {
            $r = ord $char;
          } else {
            $r = -1;
          }
        }

  @Method:
    @@Name: parseEmbedBlock
    @@ManakaiDOM:isForInternal:1
    @@ForCheck: ManakaiDOM|ForClass
    @@enDesc:
      Parses an embed statement block.
    @@Param:
      @@@Name: doc
      @@@Type: DPGDocument
      @@@enDesc:
        The owner document object used if new node is being created.
    @@Param:
      @@@Name: parent
      @@@Type: Element
      @@@enDesc:
        The parent element node to which the value from the parsed statement 
        should be attached.
    @@Return:
      @@@PerlDef:
        my $token = $self->_shift_token;
        if ($token->{type} eq 'LBRACE') {
          my $nest_count = 1; # already opened
          my $s = '';
          __DEEP{
            C: while ((my $ch = $self-><M::ManakaiDPGParser.shiftChar>) > -1) {
              if ($ch == 0x007B) {
                $s .= '{'; # }
                $nest_count++;
              } elsif ($ch == 0x007D) {
                if (--$nest_count == 0) {
                  last C;
                } elsif ($nest_count < 0) {
                  $nest_count = 0;
                }
                $s .= chr $ch;
              } else {
                $s .= chr $ch;
              }
            }

            if (length $s) {
              my $el = $doc-><M::Document.createElementNS>
                        (<Q::pg:>, 'embedBlock');
              $el-><AS::Node.textContent> ($s);
              $parent-><M::Node.appendChild> ($el);
            }
          }__;
        } else {
          unshift @{$self->{token}}, $token;
        }

  @Method:
    @@ManakaiDOM:isForInternal: 1
    @@Operator: ManakaiDOM|MUErrorHandler
    @@enDesc:
      When a <IF::ecore|ErrorInterface||ManakaiDOM|Perl> is <Perl::report>ed,
      then this method is invoked.
      
      The method calls the <cfg::DOMCore|error-handler> if the error is of 
      <IF::DOMCore|DOMError>.  Otherwise, the error is re-thrown so that
      corresponding <Perl::catch> clause, if any, can catch the error.
    @@Param:
      @@@Name: err
      @@@Type: ecore|ErrorInterface||ManakaiDOM|Perl
      @@@enDesc:
        The reported error object.
    @@Return:
      @@@Type: DISPerl|Any
      @@@enDesc:
        If the <P::err> is a <IF::DOMCore|DOMError>, then the return value
        of the error handler.

           {NOTE:: If the error is thrown, the method never returns.
           }
      @@@nullCase:
        @@@@enDesc:
          No error handler.
      @@@PerlDef:
        if ($err->isa (<IFName::DOMCore|DOMError||ManakaiDOM|ManakaiDOM>)) {
          __DEEP{
            A: {
              my $cfg = $self-><AG::Document.domConfig>;
              my $h = $cfg-><M::DOMCore|DOMConfiguration.getParameter>
                               ('error-handler');
              $r = $h-><M::DOMCore|DOMErrorHandler.handleError> ($err);
            } # A
          }__;
        } else {
          $err-><M::ecore|ErrorInterface||ManakaiDOM|Perl.throw>;
        }

  @DISPerl:dpgDef:

    rule Rules ($impl) : standalone {
      my $doc : return;
      my $docel;
      lang:Perl {
        $doc = $impl-><M::DOMCore|DOMImplementation.createDocument>
                      (<Q::pg:>, 'rules');
        $docel = $doc-><AG::Document.documentElement>;
      }
    
      // Rules := *(Rule / Lexmode / TokenError)
      ~* (NAME == 'rule') {
        &_Rule ($doc => $doc, $parent => $docel);
      } (NAME == 'lexmode') {
        &_Lexmode ($doc => $doc, $parent => $docel);
      } (NAME == 'token-error') {
        &_TokenError ($doc => $doc, $parent => $docel);
      }
    
      ~ (#EOF) { }

      lang:Perl {
        if ($self->{has_error}) {
          __EXCEPTION{pg|PARSE_ERR::
          }__;
        }
      }
    } // Rules
  
    rule _Lexmode ($doc, $parent) {
      /*
        Lexmode := 'lexmode' NAME *AttributeSpecification LBRACE
                   *LStatement RBRACE
      */
    
      my $el;
      lang:Perl {
        $el = $doc-><M::Document.createElementNS> (<Q::pg:>, 'lexmode');
        $parent-><M::Node.appendChild> ($el);
      }
    
      // Lexmode name
      ~ (NAME) {
        lang:Perl ($name => $token.value) {
          $el-><M::Element.setAttributeNS> (null, 'name', $name);
        }
      }
    
      &AttributeSpecificationList ($doc => $doc, $parent => $el);
      
      ~ (LBRACE) { }
    
      /*
        LStatement := LAssignmentStatement;
        LAssignmentStatement := (NAME / VARIABLE) *AttributeSpecification
                                DEFINE 1*LRValue SEMICOLON
      */
      ~* (NAME) {
        my $lassign;
        lang:Perl ($name => $token.value) {
          $lassign = $doc-><M::Document.createElementNS>
                             (<Q::pg:>, 'lAssignmentStatement');
          $lassign-><M::Element.setAttributeNS> (null, 'name', $name);
          $el-><M::Node.appendChild> ($lassign);
        }
      
        &AttributeSpecificationList ($doc => $doc, $parent => $lassign);
      
        ~ (DEFINE) { }

        &LRValueList ($doc => $doc, $parent => $lassign);
      
        ~ (SEMICOLON) { }
      } (VARIABLE) {
        my $lassign;
        lang:Perl ($name => $token.value) {
          $lassign = $doc-><M::Document.createElementNS>
                             (<Q::pg:>, 'lAssignmentStatement');
          $lassign-><M::Element.setAttributeNS>
                             (null, 'name', substr ($name, 1));
          $lassign-><M::Element.setAttributeNS> (null, 'isVariable', '1');
          $el-><M::Node.appendChild> ($lassign);
        }
      
        &AttributeSpecificationList ($doc => $doc, $parent => $lassign);
      
        ~ (DEFINE) { }

        &LRValueList ($doc => $doc, $parent => $lassign);
      
        ~ (SEMICOLON) { }
      }
    
      ~ (RBRACE) { }
    } // _Lexmode

    rule LRValueList ($doc, $parent) {
      /*
        LRValue := CharClass [Occurence] /
                   DOT [Occurence] /
                   VARIABLE
      */

      ~* (CLSOPEN) {
        my $cls;
        lang:Perl {
          $cls = $doc-><M::Document.createElementNS>
                           (<Q::pg:>, 'charClass');
          $lassign-><M::Node.appendChild> ($cls);
        }
        &_CharClass ($doc => $doc, $parent => $cls);
      } (NCLSOPEN) {
        my $cls;
        lang:Perl {
          $cls = $doc-><M::Document.createElementNS>
                           (<Q::pg:>, 'charClass');
          $cls-><M::Element.setAttributeNS> (null, 'negative', '1');
          $lassign-><M::Node.appendChild> ($cls);
        }
        &_CharClass ($doc => $doc, $parent => $cls);
      } (DOT) {
        my $cls;
        lang:Perl {
          $cls = $doc-><M::Document.createElementNS> (<Q::pg:>, 'anyChar');
          $lassign-><M::Node.appendChild> ($cls);
        }
        &OccurenceOpt ($parent => $cls);
      } (VARIABLE) {
        my $lname;
        lang:Perl ($name => $token.value) {
          $lname = $doc-><M::Document.createElementNS>
                                (<Q::pg:>, 'lVariableRef');
          $lname-><M::Element.setAttributeNS>
                                (null, 'name', substr ($name, 1));
          $lassign-><M::Node.appendChild> ($lname);
        }
        &OccurenceOpt ($parent => $lname);
      }
    } // LRValueList
  
    rule _CharClass ($doc, $parent) {
      /*
        CharClass := (CLSOPEN / NCLSOPEN) 1*CharSpec CLSCLOSE
        CharSpec := STRING / CHAR [RANGE CHAR]
      */
      ~+ (STRING) {
        lang:Perl ($value => $token.value) {
          my $str = $doc-><M::Document.createElementNS> (<Q::pg:>, 'string');
          $str-><AS::Node.textContent>
                  (substr ($value, 1, length ($value) - 2));
          $parent-><M::Node.appendChild> ($str);
        }
      } (CHAR) {
        my $char;
        lang:Perl ($value => $token.value) {
          $char = $doc-><M::Document.createElementNS> (<Q::pg:>, 'charRange');
          my $code = $value;
          $code =~ s/^U\+/0x/;
          $char-><M::Element.setAttributeNS> (null, 'start', hex $code);
          $char-><M::Element.setAttributeNS> (null, 'end', hex $code);
          $parent-><M::Node.appendChild> ($char);
        }
        ~? (RANGE) {
          ~ (CHAR) {
            lang:Perl ($value => $token.value) {
              my $code = $value;
              $code =~ s/^U\+/0x/;
              $char-><M::Element.setAttributeNS> (null, 'end', hex $code);
            }
          }
        }
      }
    
      ~ (CLSCLOSE) { }
    
      &OccurenceOpt ($parent => $parent);
    } // _CharClass
  
    rule OccurenceOpt ($parent) {
      /*
        Occurence := ZEROMORE / ONEMORE / ZEROONE
      */
      ~? (ZEROMORE) {
        lang:Perl {
          $parent-><M::Element.setAttributeNS>
                       (null, 'occurence', 'zeromore');
        }
      } (ONEMORE) {
        lang:Perl {
          $parent-><M::Element.setAttributeNS>
                       (null, 'occurence', 'onemore');
        }
      } (ZEROONE) {
        lang:Perl {
          $parent-><M::Element.setAttributeNS> 
                       (null, 'occurence', 'zeroone');
        }
      }
    } // OccurenceOpt
  
    rule _Rule ($doc, $parent) {
      /*
        Rule := 'rule' NAME [ParameterDeclarationList] *AttributeSpecification
                (CodeBlock / LANGLE 'external' RANGLE SEMICOLON)
      */
    
      my $el;
      lang:Perl {
        $el = $doc-><M::Document.createElementNS> (<Q::pg:>, 'rule');
        $parent-><M::Node.appendChild> ($el);
      }
    
      // Rule name
      ~ (NAME) {
        lang:Perl ($name => $token.value) {
          $el-><M::Element.setAttributeNS> (null, 'name', $name);
        }
      }

      &ParameterDeclarationListOpt ($doc => $doc, $parent => $el);    
    
      &AttributeSpecificationList ($doc => $doc, $parent => $el);
    
      ~ (LBRACE) {
        &_CodeBlock ($doc => $doc, $parent => $el);
      } (LANGLE) {
        ~ (NAME == 'external') {
          lang:Perl {
            $el-><M::Element.setAttributeNS> (null, 'isExternal', '1');
          }
          ~ (RANGLE) { }
          ~ (SEMICOLON) { }
        }
      }
    } // _Rule
  
    rule AttributeSpecificationList ($doc, $parent) {
      /*
        AttributeSpecification := COLON NAME [Occurence] [REPLACE STRING]
      */

      ~* (COLON) {
        // Attribute name
        ~ (NAME) {
          my $ael;
          lang:Perl ($name => $token.value) {
            $ael = $doc-><M::Document.createElementNS>
                            (<Q::pg:>, 'attributeSpecification');
            $ael-><M::Element.setAttributeNS> (null, 'name', $name);
            $ael-><M::Element.setAttributeNS> (null, 'value', '1');
            $parent-><M::Node.appendChild> ($ael);
          }
 
          &OccurenceOpt ($parent => $ael);

          // String value
          ~? (REPLACE) {
            ~ (STRING) {
              lang:Perl ($value => $token.value) {
                $ael-><M::Element.setAttributeNS>
                        (null, 'value',
                         substr ($value, 1, length ($value) - 2));
              }
            }
          }
        }
      }
    } // AttributeSpecificationList
  
    rule _CodeBlock ($doc, $parent) : standalone {
      /*
        CodeBlock := LBRACE *Statement RBRACE
      */
    
      my $block;
      lang:Perl {
        $block = $doc-><M::Document.createElementNS> (<Q::pg:>, 'codeBlock');
        $parent-><M::Node.appendChild> ($block);
      }
    
      /*
        Statement := MyStatement / AssignmentStatement / MatchStatement /
                     RuleRefStatement / EmbedStatement
      */
    
      ~* (MATCH) {
        /*
          MatchStatement := MATCH Occurence
                            1*(LPAREN [RNI] NAME [EQUALS STRING] RPAREN
                               *AttributeSpecification CodeBlock)
        */
        my $match;
        lang:Perl {
          $match = $doc-><M::Document.createElementNS>
                           (<Q::pg:>, 'matchStatement');
          $block-><M::Node.appendChild> ($match);
        }
        ~? (ZEROMORE) {
          lang:Perl {
            $match-><M::Element.setAttributeNS> (null, 'occurence', 'zeromore');
          }
        } (ONEMORE) {
          lang:Perl {
            $match-><M::Element.setAttributeNS> (null, 'occurence', 'onemore');
          }
        } (ZEROONE) {
          lang:Perl {
            $match-><M::Element.setAttributeNS> (null, 'occurence', 'zeroone');
          }
        }
        ~+ (LPAREN) {
          my $match_block;
          lang:Perl {
            $match_block = $doc-><M::Document.createElementNS> (<Q::pg:>, 'matchBlock');
            $match-><M::Node.appendChild> ($match_block);
          }
            ~? (RNI) {
              lang:Perl {
                $match_block-><M::Element.setAttributeNS>
                                   (null, 'isReservedToken' => '1');
              }
            }
            ~ (NAME) {
              lang:Perl ($name => $token.value) {
                $match_block-><M::Element.setAttributeNS>
                                   (null, 'token', $name);
              }
            }

            ~? (EQUALS) {
              ~ (STRING) {
                lang:Perl ($value => $token.value) {
                  $match_block-><M::Element.setAttributeNS>
                                   (null, 'valueOperation', '==');
                  $match_block-><M::Element.setAttributeNS>
                                   (null, 'value',
                                    substr ($value, 1, length ($value) - 2));
                }
              }
            }

          ~ (RPAREN) { }
          
          &AttributeSpecificationList ($doc => $doc, $parent => $match_block);
          
          ~ (LBRACE) {
            &_CodeBlock ($doc => $doc, $parent => $match_block);
          }
        }

      } (NAME == 'my') {
        /*
          MyStatement := MY VARIABLE SEMICOLON
        */
        ~ (VARIABLE) {
          my $my;
          lang:Perl ($name => $token.value) {
            $my = $doc-><M::Document.createElementNS> (<Q::pg:>, 'myStatement');
            $my-><M::Element.setAttributeNS> (null, 'name', substr ($name, 1));
            $block-><M::Node.appendChild> ($my);
          }

          &AttributeSpecificationList ($doc => $doc, $parent => $my);
        }

        ~ (SEMICOLON) { }

      } (NAME) {
        /*
          EmbedStatement := NAME [ParameterSpecificationList] EmbedBlock
        */
        my $embed;
        lang:Perl ($name => $token.value) {
          my ($prefix, $lname) = split /:/, $name;
          ($prefix, $lname) = (null, $prefix) unless defined $lname;
          my $nsuri = $self->{nsresolver}
                           -><M::DIS|NSResolverDIS||DIS|ForLatest
                                .prefixToURI> ($prefix);
          $embed = $doc-><M::Document.createElementNS>
                               (<Q::pg:>, 'embedStatement');
          $embed-><M::Element.setAttributeNS> (null, 'type', $nsuri.$lname);
          $block-><M::Node.appendChild> ($embed);
        }
      
        &ParameterSpecificationListOpt ($doc => $doc, $parent => $embed);
      
        &AttributeSpecificationList ($doc => $doc, $parent => $embed);

        &EmbedBlock ($doc => $doc, $parent => $embed);
      } (RULEREF) {
        /*
          RuleRefStatement := RULEREF [ParameterSpecificationList] SEMICOLON
        */
      my $ruleref;
      lang:Perl ($name => $token.value) {
        $ruleref = $doc-><M::Document.createElementNS> (<Q::pg:>, 'ruleRefStatement');
        $ruleref-><M::Element.setAttributeNS> (null, 'name', substr ($name, 1));
        $block-><M::Node.appendChild> ($ruleref);
      }
      
      &ParameterSpecificationListOpt ($doc => $doc, $parent => $ruleref);
      
      ~ (SEMICOLON) { }
        } (VARIABLE) {
          /*
            AssignmentStatement := Lvalue ASSIGN Rvalue;
          */
      my $assign;
      my $lvalue;
      lang:Perl ($name => $token.value) {
        $assign = $doc-><M::Document.createElementNS> (<Q::pg:>, 'assignmentStatement');
        $lvalue = $doc-><M::Document.createElementNS> (<Q::pg:>, 'memberRef');
        my $var = $doc-><M::Document.createElementNS> (<Q::pg:>, 'variable');
        $var-><M::Element.setAttributeNS> (null, 'name', substr ($name, 1));
        $lvalue-><M::Node.appendChild> ($var);
        $assign-><M::Node.appendChild> ($lvalue);
        $block-><M::Node.appendChild> ($assign);
      }
      
      ~* (DOT) {
        ~ (NAME) {
          lang:Perl ($name => $token.value) {
            my $mem = $doc-><M::Document.createElementNS> (<Q::pg:>, 'member');
            $mem-><M::Element.setAttributeNS> (null, 'name', $name);
            $lvalue-><M::Node.appendChild> ($mem);
          }
        }
      }
      
      ~ (ASSIGN) { }
      
      &Rvalue ($doc => $doc, $parent => $assign);
      
      ~ (SEMICOLON) { }

      }
    
      ~ (RBRACE) { }
    } // _CodeBlock

    /*
      EmbedBlock := '{' *((<any character> - '{' / '}') / EmbedBlock) '}'

          ISSUE: How escapes ('\' <any character>) should be parsed?
    */
    rule EmbedBlock ($doc, $parent)
           : perl-name => 'embed_block'
           <external>;
    
    // Lvalue := VARIABLE *(DOT NAME)
  
    rule Rvalue ($doc, $parent) {
      /*
        Rvalue := STRING / VARIABLE *(DOT NAME)
      */
    
      ~ (STRING) {
        lang:Perl ($value => $token.value) {
          my $str = $doc-><M::Document.createElementNS> (<Q::pg:>, 'string');
          $str-><AS::Node.textContent>
                  (substr ($value, 1, length ($value) - 2));
          $parent-><M::Node.appendChild> ($str);
        }
      } (VARIABLE) {
        my $memref;
        lang:Perl ($name => $token.value) {
          $memref = $doc-><M::Document.createElementNS>
                              (<Q::pg:>, 'memberRef');
          my $var = $doc-><M::Document.createElementNS>
                              (<Q::pg:>, 'variable');
          $var-><M::Element.setAttributeNS>
                    (null, 'name', substr ($name, 1));
          $memref-><M::Node.appendChild> ($var);
          $parent-><M::Node.appendChild> ($memref);
        }
        
        ~* (DOT) {
          ~ (NAME) {
            lang:Perl ($name => $token.value) {
              my $mem = $doc-><M::Document.createElementNS>
                                (<Q::pg:>, 'member');
              $mem-><M::Element.setAttributeNS> (null, 'name', $name);
              $memref-><M::Node.appendChild> ($mem);
            }
          }
        }
      }
    } // Rvalue

    rule ParameterDeclarationListOpt ($doc, $parent) {
      /*
        ParameterDeclarationList := "(" [ParameterDeclaration
                                         *(COMMA ParameterDeclaration)] ")"
        ParameterDeclaration := VARIABLE
      */
      ~? (LPAREN) {
        ~* (VARIABLE) {
          lang:Perl ($name => $token.value) {
            my $pel = $doc-><M::Document.createElementNS>
                              (<Q::pg:>, 'parameterDeclaration');
            $pel-><M::Element.setAttributeNS>
                    (null, 'name', substr ($name, 1));
            $parent-><M::Node.appendChild> ($pel);
          }
        } (COMMA) : separator { }

        ~ (RPAREN) { }
      }
    } // ParameterDeclarationListOpt

    rule ParameterSpecificationListOpt ($doc, $parent) {
      /*
        ParameterSpecificationList := LPAREN [VARIABLE REPLACE Rvalue
                                      *(COMMA Lvalue REPLACE Rvalue)] RPAREN
      */

      ~? (LPAREN) {
        ~* (VARIABLE) {
          my $param;
          lang:Perl ($name => $token.value) {
            $param = $doc-><M::Document.createElementNS>
                             (<Q::pg:>, 'parameterSpecification');
            $parent-><M::Node.appendChild> ($param);
            $param-><M::Element.setAttributeNS>
                      (null, 'name', substr ($name, 1));
          }
       
          ~ (REPLACE) { }
        
          &Rvalue ($doc => $doc, $parent => $param);
        } (COMMA) : separator { }
      
        ~ (RPAREN) { }
      }
    }

    rule _TokenError ($doc, $parent) {
      /*
        TokenError := 'token-error' NAME [ParameterDeclarationList]
                      *AttributeSpecification CodeBlock
      */

      my $el;

      ~ (NAME) {
        lang:Perl ($name => $token.value) {
          $el = $doc-><M::Document.createElementNS> (<Q::pg:>, 'tokenError');
          $el-><M::Element.setAttributeNS> (null, 'name', $name);
          $parent-><M::Node.appendChild> ($el);
        }
      }

      &ParameterDeclarationListOpt ($doc => $doc, $parent => $el);

      &AttributeSpecificationList ($doc => $doc, $parent => $el);

      ~ (LBRACE) {
        &_CodeBlock ($doc => $doc, $parent => $el);
      }
    } // _TokenError

    token-error default : default {
      lang:Perl ($token_name => $token.type) {
        my $continue = __DOMCore:ERROR{pg|bad-token-error::
          pg|token-type => {$token_name},
        }__;
        unless ($continue) {
          __EXCEPTION{pg|PARSE_ERR::
          }__;
        }
        $self->{has_error} = true;
      }
    } // token-error default


    lexmode default : initial {
      WSP : ignore := [U+0009..U+000D U+0020]+;
      COMMENT : ignore := [';'] [';'] [^U+000A..U+000D]* [U+000A..U+000D]*;

      /*
        Comment : from |//| to the end of the line
      */
      CommentLine : ignore := ['/'] ['/'] [^U+000A..U+000D]*
                                          [U+000A..U+000D]*;

      /*
        Comment : from |/*| to |*| |/|
      */
      $CommentPhrase0 := [^'/' '*'] [^'*']* ['*']+;
      CommentPhrase : ignore := ['/'] ['*'] [^'*']* ['*']+
                                $CommentPhrase0* ['/'];

      /*
        Name
      */    
      $name := [U+0041..U+005A U+0061..U+007A '_' '-']
               [U+0030..U+0039 U+0041..U+005A U+0061..U+007A '_' '-' ':']*;
      NAME : value := $name;

      VARIABLE : value := ['$'] $name;
      RULEREF : value := ['&'] $name;
    

      /*
        Character code point
      */
      $hexdigit := [U+0030..U+0039 U+0041..U+0046 U+0061..U+0066];
      CHAR : value := ['U' 'u'] ['+']
                      $hexdigit $hexdigit $hexdigit $hexdigit+;
    
    STRING : value := [U+0027] [^U+0027 U+005C]* [U+0027];
    
    COMMA := [','];
    REPLACE := ['='] ['>'];
    ASSIGN := ['='];
    DEFINE := [':'] ['='];
    LPAREN := ['('];
    RPAREN := [')'];
    LBRACE := ['{'];
    RBRACE := ['}'];
    CLSOPEN := ['['];
    NCLSOPEN := ['['] ['^'];
    CLSCLOSE := [']'];
    ZEROMORE := ['*'];
    ONEMORE := ['+'];
    ZEROONE := ['?'];
    COLON := [':'];
    SEMICOLON := [';'];
    MATCH := ['~'];
    DOT := ['.'];
    RANGE := ['.'] ['.'];

      /*
        Reserved name indicator
      */
      RNI := ['#'];

      /*
        Attribute value equals
      */
      EQUALS := ['='] ['='];

      LANGLE := ['<'];
      RANGLE := ['>'];
    } // lexmode
##DPGParser

ElementTypeBinding:
  @Name: Attr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Attribute
    @@ForCheck: !=ManakaiDOM|ManakaiDOM

ElementTypeBinding:
  @Name: Get
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|AttributeGet

ElementTypeBinding:
  @Name: Set
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|AttributeSet

ElementTypeBinding:
  @Name: CParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      @@@@: DOMCore|DOMConfigurationParameter
      @@@For: ManakaiDOM|DOM
    @@rdf:type:
      @@@@: DISCore|Property
      @@@For: =ManakaiDOM|all
    @@For: ManakaiDOM|DOM3
    @@For: =ManakaiDOM|all

ElementTypeBinding:
  @Name: CParamApp
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      @@@@: DOMCore|DOMConfigurationParameterApplication
      @@@For: ManakaiDOM|DOM
    @@rdf:type:
      @@@@: DISCore|Property
      @@@For: =ManakaiDOM|all
    @@For: ManakaiDOM|DOM3
    @@For: =ManakaiDOM|all

CParamApp:
  @DOMCore:domConfigurationParameter: DOMCore|error-handler
  @DOMCore:targetType: DPGParser

ElementTypeBinding:
  @Name: ErrDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DOMCore|DOMErrorType
    @@For: ManakaiDOM|DOM3

ErrDef:
  @QName: pg|bad-token-error
  @enDesc:
    The parser is encountered to a token whose type is not
    allowed there.
  @DOMCore:severity: DOMCore|SEVERITY_ERROR
  @enMufDef:
    Token "%p (name => {<Q::pg|token-type>});" is not allowed

PropDef:
  @QName: pg|token-type
  @enDesc:
    The type of the token occurred in the source.

ElementTypeBinding:
  @Name:enMufDef
  @ElementType:
    ecore:defaultMessage
  @ShadowContent:
    @@lang:en
    @@ContentType:
      lang:muf

ResourceDef:
  @rdf:type:
    @@@: dis|MultipleResource
    @@ForCheck: !ManakaiDOM|ForIF !ManakaiDOM|ForClass
  @resourceFor: ManakaiDOM|ForIF
  @resourceFor:
    @@@: ManakaiDOM|ForClass
    @@ForCheck: ManakaiDOM|ManakaiDOM !=ManakaiDOM|ManakaiDOM
  @For: ManakaiDOM|DOM3
  @For: =ManakaiDOM|ManakaiDOM

  @rdf:type:
    @@@: dx|Interface
    @@ForCheck: ManakaiDOM|ForIF

  @rdf:type:
    @@@: dx|Class
    @@ForCheck: ManakaiDOM|ForClass

  @Implement:
    @@@: ||ManakaiDOM|ManakaiDOM||ManakaiDOM|ForIF
    @@ContentType: DISCore|TFPQNames
    @@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM
  @Implement:
    @@@: ||ManakaiDOM|ManakaiDOMLatest||ManakaiDOM|ForIF
    @@ContentType: DISCore|TFPQNames
    @@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOMLatest
  @dx:implementedBy:
    @@@: ||ManakaiDOM|ManakaiDOMLatest||ManakaiDOM|ForClass
    @@ForCheck: ManakaiDOM|ForIF ManakaiDOM|ManakaiDOMLatest

  @f:implements:
    @@@: DIS|DPG10
    @@For: ManakaiDOM|DOM3

  @DISPerl:ISA:
    @@@: dx|Exception||ManakaiDOM|Perl
    @@ForCheck: ManakaiDOM|ForClass

  @IFQName: DPGException
  @ClsQName: ManakaiDPGException

  @enDesc:
    A <IF::DPGParser> might throw a <IF::DPGException> if the processing is
    stopped.  The processing can be stopped due to a <IF::DOMCore|DOMError>
    with a <A::DOMCore|DOMError.severity> of 
    <C::DOMCore|DOMError.SEVERITY_FATAL_ERROR> or a non-recovered
    <C::DOMCore|DOMError.SEVERITY_ERROR>, or if 
    <M::DOMCore|DOMErrorHandler.handleError> method returned <DOM::false>.

  @Attr:
    @@Name: code
    @@Get:
      @@@Type: idl|unsignedShort||ManakaiDOM|all
      @@@dis:actualType: DPGExceptionCode
    @@ForCheck: ManakaiDOM|ForIF

  @ResourceDef:
    @@rdf:type: DISLang|ConstGroup
    @@ForCheck: ManakaiDOM|ForIF !=ManakaiDOM|ManakaiDOM

    @@QName: DPGExceptionCode

    @@rdfs:subClassOf: idl|unsignedShort||ManakaiDOM|all
    @@Type: idl|unsignedShort||ManakaiDOM|all

    @@enDesc:
      An integer indicating the type of error generated.

    @@ResourceDef:
      @@@rdf:type: DISLang|Const
      @@@QName: pg|PARSE_ERR
      @@@Value:
        @@@@@: 81
        @@@@ContentType: DISCore|Integer
      @@@enDesc:
        An attempt was made to load a DPG document and
        the processing has been stopped.
##DPGException
