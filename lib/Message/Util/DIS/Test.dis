Module:
  @QName: DIS|Test
  @enFN:
    <QUOTE::dis> Testing Module
  @Namespace:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS#Test/
  
  @enDesc:
    The <Module::DIS|Test> module provides a set of interfaces
    for test scripts generated from <QUOTE::dis> resource sets.

  @DISCore:author: DISCore|Wakaba
  @License: license|Perl+MPL
  @Date:
    @@@:
      $Date: 2006/01/21 07:06:10 $
    @@ContentType: dis|Date.RCS
  
  @Require:
    @@Module:
      @@@QName: DIS|common
    @@Module:
      @@@QName: DISlib|Test
      @@@WithFor: ManakaiDOM|all
    @@Module:
      @@@QName: MDOM|DOMFeature
      @@@WithFor: ManakaiDOM|ManakaiDOMLatest
    @@Module:
      @@@WithFor: ManakaiDOM|ManakaiDOM
    @@Module:
      @@@WithFor: ManakaiDOM|ManakaiDOMLatest

  @DefaultFor: ManakaiDOM|ManakaiDOMLatest

Namespace:
  @DIS:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS#
  @dis:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#dis--
  @DISlib:
    http://suika.fam.cx/~wakaba/archive/2004/dis/
  @dtest:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS#Test/
  @dx:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#
  @ecore:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/Core/
  @Err:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/
  @f:
    http://suika.fam.cx/~wakaba/archive/2004/dom/feature#
  @html3:
    urn:x-suika-fam-cx:markup:ietf:html:3:draft:00:
  @html5:
    http://www.w3.org/1999/xhtml
  @idl:
    http://suika.fam.cx/~wakaba/archive/2004/dis/IDL#
  @ilang:
    urn:x-suika-fam-cx:lang:
  @infoset:
    http://www.w3.org/2001/04/infoset#
  @kwd:
    http://suika.fam.cx/~wakaba/archive/2005/rfc2119/
  @lang:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#
  @license:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/license#
  @ManakaiDOM:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#
  @MDOM:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#ManakaiDOM.
  @MDOMX:
    http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#
  @mn:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/ManakaiNode#
  @nl:
    http://suika.fam.cx/~wakaba/archive/2004/dis/NaturalLanguage#
  @null:
    http://suika.fam.cx/~wakaba/-temp/2003/09/27/null
  @rdf:
    http://www.w3.org/1999/02/22-rdf-syntax-ns#
  @rdfs:
    http://www.w3.org/2000/01/rdf-schema#
  @s:
    http://suika.fam.cx/~wakaba/archive/2004/dis/Markup#
  @script:
    http://suika.fam.cx/~wakaba/archive/2005/5/script#
  @sw010:
    urn:x-suika-fam-cx:markup:suikawiki:0:10:
  @swcfg21:
    http://suika.fam.cx/~wakaba/archive/2005/swcfg21#
  @test:
    http://suika.fam.cx/~wakaba/archive/2004/dis/Test#
  @Util:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/
  @xhtml1:
    http://www.w3.org/1999/xhtml
  @xhtml2:
    http://www.w3.org/2002/06/xhtml2/
  @xml:
    http://www.w3.org/XML/1998/namespace
  @xmlns:
    http://www.w3.org/2000/xmlns/

## -- Features

ElementTypeBinding:
  @Name: FeatureDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DOMFeature|Feature
    @@For: ManakaiDOM|all

ElementTypeBinding:
  @Name: FeatureVerDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DOMFeature|Feature

ElementTypeBinding:
  @Name: featureQName
  @ElementType:
    DOMFeature:name
  @ShadowContent:
    @@ContentType: DISCore|QName

FeatureDef:
  @QName: DIS|Test
  @FeatureVerDef:
    @@QName: DIS|Test10
    @@Version: 1.0
    @@f:requires: f|min30
    @@f:instanceOf: DIS|Test
    @@enFN:
      <QUOTE::dis> Testing Module, version 1.0

ElementTypeBinding:
  @Name: enDesc
  @ElementType: 
    dis:Description
  @ShadowContent: 
    @@lang:en

ElementTypeBinding:
  @Name: enFN
  @ElementType:
    dis:FullName
  @ShadowContent:
    @@lang:en

ElementTypeBinding:
  @Name: enImplNote
  @ElementType:
    dis:ImplNote
  @ShadowContent:
    @@lang:en

ElementTypeBinding:
  @Name: IFClsDef
  @ElementType: 
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      @@@@: dis|MultipleResource
      @@@ForCheck: !ManakaiDOM|ForIF !ManakaiDOM|ForClass
    @@resourceFor: ManakaiDOM|ForIF
    @@resourceFor: ManakaiDOM|ForClass
    @@For: ManakaiDOM|ManakaiDOM

    @@rdf:type:
      @@@@: DISLang|Interface
      @@@ForCheck: ManakaiDOM|ForIF

    @@rdf:type:
      @@@@: DISLang|Class
      @@@ForCheck: ManakaiDOM|ForClass
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOM||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOMLatest||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOMLatest

    @@f:implements: DIS|Test10

ElementTypeBinding:
  @Name: IFQName
  @ElementType:
    dis:QName
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForIF

ElementTypeBinding:
  @Name: ClsQName
  @ElementType:
    dis:QName
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: IFISA
  @ElementType:
    dis:ISA
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForIF

ElementTypeBinding:
  @Name: ClsISA
  @ElementType:
    dis:ISA
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: Method
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Method
    @@For: !=ManakaiDOM|ManakaiDOM

ElementTypeBinding:
  @Name: Return
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|MethodReturn

ElementTypeBinding:
  @Name: Param
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|MethodParameter

ElementTypeBinding:
  @Name: Attr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Attribute
    @@For: !=ManakaiDOM|ManakaiDOM

ElementTypeBinding:
  @Name: Get
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|AttributeGet

ElementTypeBinding:
  @Name: Set
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|AttributeSet

## -- Implementation

IFClsDef: 
  @IFQName: DTImplementation
  @ClsQName: ManakaiDTImplementation

  @IFISA: f|MinimumImplementation
  @ClsISA: f|ManakaiMinimumImplementation

  @f:provides: DIS|Test10

  @Method:
    @@Name: createTestManager
    @@enDesc:
      Creates a <IF::DTManager> object.
    @@Param:
      @@@Name: totalNumber
      @@@Type: unsignedLong
      @@@enDesc:
        The total number of tests.
    @@Param:
      @@@Name: outputFile
      @@@Type: DISPerl|FileHandle
      @@@enDesc:
        The file handle to which reports are written.
      @@@nullCase:
        @@@@enDesc:
          Defaulted to the standard output.
    @@Return:
      @@@Type: DTManager
      @@@enDesc:
        The newly created test manager.
      @@@PerlDef:
        $r = bless {<H::dtest|number> => $totalNumber,
                    <H::dtest|currentNumber> => 0,
                    <H::dtest|failedNumber> => 0,
                    <H::dtest|output> => $outputFile || \*STDOUT},
                   <ClassName::ManakaiDTManager>;
        print {$r->{<H::dtest|output>}}
                "1.." . $r->{<H::dtest|number>} . "\n";
##DISImplementationTest

PropDef:
  @QName: dtest|uri
  @enDesc:
    A URI that identifies the test.
  @dtest:key: i

PropDef:
  @QName: dtest|id
  @enDesc:
    A subtest identifier.
  @dtest:key: s

PropDef:
  @QName: dtest|number
  @enDesc:
    The total number of tests.
  @dtest:key: n

PropDef:
  @QName: dtest|currentNumber
  @enDesc:
    The current number of tests.
  @dtest:key: c

SPropDef:
  @QName: dtest|key
  @enDesc:
    The key name of the property when it is used in 
    <Class::DTManager::ManakaiDOM:ManakaiDOMLatest>.
  @dataType: DISCore|String
  @multipleProperties: DISCore|Single
  @rdfs:domain: rdfs|Property
  @rdfs:subPropertyOf: DISPerl|propHashKey

IFClsDef:
  @IFQName: DTManager
  @ClsQName: ManakaiDTManager

  @ClsISA: dx|ManakaiDefaultExceptionHandler||ManakaiDOM|Perl

  @Attr:
    @@Name: totalNumber
    @@enDesc
      The total number of tests.
    @@Type: unsignedLong
    @@Get:
      @@@PerlDef:
        $r = $self->{<H::dtest|number>};

  @Attr:
    @@Name: currentNumber
    @@enDesc:
      The number of tests that is already done.
    @@Type: unsignedLong
    @@Get:
      @@@PerlDef:
        $r = $self->{<H::dtest|currentNumber>};

  @Attr:
    @@Name: failedNumber
    @@enDesc:
      The number of tests that has failed.
    @@Type: unsignedLong
    @@Get:
      @@@PerlDef:
        $r = $self->{<H::dtest|failedNumber>};

  @Attr:
    @@Name: outputFile
    @@enDesc:
      The file handle to which reports are written.
    @@Type: DISPerl|Filehandle
    @@Get:
      @@@PerlDef:
        $r = $self->{<H::dtest|output>};

  @Method:
    @@Name: startNewTest
    @@enDesc:
      Starts a new test.
    @@Param:
      @@@Name: uri
      @@@Type: DISString
      @@@enDesc:
        A URI that identifies the test.
    @@Return:
      @@@PerlDef:
        if (not $self->{<H::dtest|ok>} and defined $self->{<H::dtest|uri>}) {
          __DEEP{
            $self-><M::DTManager.notOK>;
          }__;
        }
        $self->{<H::dtest|currentNumber>}++;
        $self->{<H::dtest|uri>} = $uri;
        $self->{<H::dtest|testData>} = {};
        CORE::delete $self->{<H::dtest|id>};

  @Attr:
    @@Name: uri
    @@enDesc:
      A URI that identifies the current test.
    @@Type: DISString
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          Currently no test is done.
      @@@PerlDef:
        $r = $self->{<H::dtest|uri>};

  @Attr:
    @@Name: id
    @@enDesc:
      An opaque string that identifies a subtest.
    @@Type: DISString
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          No subtest identifier.
      @@@PerlDef:
        $r = $self->{<H::dtest|id>};
    @@Set:
      @@@nullCase:
        @@@@enDesc:
          Unset subtest identifier.
      @@@PerlDef:
        $self->{<H::dtest|id>} = $given;

  @Method:
    @@Name: ok
    @@enDesc:
      Records that the test has been passed.
    @@Return:
      @@@PerlDef:
        print {$self->{<H::dtest|output>}}
                "ok " . $self->{<H::dtest|currentNumber>} . "\n";
        CORE::delete $self->{<H::dtest|uri>};

  @Method:
    @@Name: notOK
    @@enDesc:
      Records that the test has not been passed.
    @@URIParam:
    @@Return:
      @@@PerlDef:
        print {$self->{<H::dtest|output>}}
                "not ok " . $self->{<H::dtest|currentNumber>} . "\n";
        my $s = '<' .
                (defined $uri ? $uri : $self->{<H::dtest|uri>});
        if (defined $self->{<H::dtest|id>}) {
          $s .= ($s =~ /#/) ? '.' : '#';
          $s .= $self->{<H::dtest|id>};
        }
        $s .= '>';
        __CODE{printComment::
          $test => $self,
          $s => $s,
        }__;
        $self->{<H::dtest|failedNumber>}++;
        CORE::delete $self->{<H::dtest|uri>};
        CORE::delete $self->{<H::dtest|id>};

  @Method:
    @@Name: assertTrue
    @@enDesc:
      If the <P::actualValue> is not <DOM::true> then the test fails.
    @@Param:
      @@@Name: actualValue
      @@@Type: DISPerl|Any
      @@@enDesc: The actual value.
    @@URIParam:
    @@Return:
      @@@AErr:
      @@@PerlDef:
        if (not $actualValue) {
          __DEEP{
            $self-><M::DTManager.notOK> (uri => $uri);
          }__;
          my $v;
          __CODE{formatValue::
            $input => $actualValue,
            $output => $v,
          }__;
          __CODE{printComment::
            $test => $self,
            $s => {
              'non-tr'.'ue value ('.$v.') is occurred where tr'.'ue is expected'
            },
          }__;
          __EXCEPTION{ASSERTION_ERR}__;
        }

  @Method:
    @@Name: assertFalse
    @@enDesc:
      If the <P::actualValue> is not <DOM::false> then the test fails.
    @@Param:
      @@@Name: actualValue
      @@@Type: DISPerl|Any
      @@@enDesc: The actual value.
    @@Return:
      @@@AErr:
      @@@PerlDef:
        if ($actualValue) {
          __DEEP{
            $self-><M::DTManager.notOK>;
          }__;
          my $v;
          __CODE{formatValue::
            $input => $actualValue,
            $output => $v,
          }__;
          __CODE{printComment::
            $test => $self,
            $s => {
             'non-fal'.'se value ('.$v.') is occurred where fal'.'se is expected'
            },
          }__;
          __EXCEPTION{ASSERTION_ERR}__;
        }

  @Method:
    @@Name: assertNull
    @@enDesc:
      If the <P::actualValue> is not <DOM::null> then the test fails.
    @@Param:
      @@@Name: actualValue
      @@@Type: DISPerl|Any
      @@@enDesc: The actual value.
    @@Return:
      @@@AErr:
      @@@PerlDef:
        if (defined $actualValue) {
          __DEEP{
            $self-><M::DTManager.notOK>;
          }__;
          my $v;
          __CODE{formatValue::
            $input => $actualValue,
            $output => $v,
          }__;
          __CODE{printComment::
            $test => $self,
            $s => {
              'non-nu'.'ll value ('.$v.') is occurred where nu'.'ll is expected'
            },
          }__;
          __EXCEPTION{ASSERTION_ERR}__;
        }

  @Method:
    @@Name: assertNotNull
    @@enDesc:
      If the <P::actualValue> is <DOM::null> then the test fails.
    @@Param:
      @@@Name: actualValue
      @@@Type: DISPerl|Any
      @@@enDesc: The actual value.
    @@Return:
      @@@AErr:
      @@@PerlDef:
        if (not defined $actualValue) {
          __DEEP{
            $self-><M::DTManager.notOK>;
          }__;
          __CODE{printComment::
            $test => $self,
            $s => {
              'nu'.'ll value is occurred where a non-nu'.'ll value is expected'
            },
          }__;
          __EXCEPTION{ASSERTION_ERR}__;
        }

  @Method:
    @@Name: assertString
    @@enDesc:
      If the <P::actualValue> is not equal to the <P::expectedValue>
      as a string, then fails.
    @@NamedParam:
      @@@Name: actualValue
      @@@Type: DISPerl|StringValue
      @@@enDesc: The actual value.
    @@NamedParam:
      @@@Name: expectedValue
      @@@Type: DISPerl|StringValue
      @@@enDesc: The expected value.
    @@Return:
      @@@AErr:
      @@@PerlDef:
        if (not defined $actualValue) {
          __DEEP{
            $self-><M::DTManager.notOK>;
          }__;
          __CODE{printComment::
            $test => $self,
            $s => {
              'null value is occurred where a string value is expected'
            },
          }__;
          __EXCEPTION{ASSERTION_ERR}__;
        } elsif ($actualValue ne $expectedValue) {
          __DEEP{
            $self-><M::DTManager.notOK>;
          }__;
          my $aval;
          my $xval;
          __CODE{formatValue::
            $input => $actualValue,
            $output => $aval,
          }__;
          __CODE{formatValue::
            $input => $expectedValue,
            $output => $xval,
          }__;
          __CODE{printComment::
            $test => $self,
            $s => {
              'Got ' . $aval . ' where ' . $xval . ' is expected'
            },
          }__;
        }

  @Method:
    @@Name: assertEquals
    @@enDesc:
      If two values are not equal (i.e. if <Perl::<P::value1> eq <P::value2>>
      is not <DOM::true>), then fails.
    @@Param:
      @@@Name: value1
      @@@Type: DISPerl|Any
      @@@enDesc: A value.
    @@Param:
      @@@Name: value2
      @@@Type: DISPerl|Any
      @@@enDesc: Another value.
    @@Return:
      @@@AErr:
      @@@PerlDef:
        if (not defined $value1 and not defined $value2) {
          ## ok
        } elsif (defined $value1 and defined $value2 and $value1 eq $value2) {
          ## ok
        } else {
          __DEEP{
            $self-><M::DTManager.notOK>;
          }__;
          my $v1;
          my $v2;
          __CODE{formatValue::
            $input => $value1,
            $output => $v1,
          }__;
          __CODE{formatValue::
            $input => $value2,
            $output => $v2,
          }__;
          __CODE{printComment::
            $test => $self,
            $s => {
              'values ' . $v1 . ' and ' . $v2 . ' are not equal'
            },
          }__;
          __EXCEPTION{ASSERTION_ERR}__;
        }

  @Method:
    @@Name: assertNotEquals
    @@enDesc:
      If two values <EM::are> equal (i.e. if <Perl::<P::value1> eq <P::value2>>
      is not <DOM::false>), then fails.
    @@Param:
      @@@Name: value1
      @@@Type: DISPerl|Any
      @@@enDesc: A value.
    @@Param:
      @@@Name: value2
      @@@Type: DISPerl|Any
      @@@enDesc: Another value.
    @@Return:
      @@@AErr:
      @@@PerlDef:
        if (not defined $value1 and defined $value2) {
          ## ok
        } elsif (defined $value1 and not defined $value2) {
          ## ok
        } elsif (not ($value1 eq $value2)) {
          ## ok
        } else {
          __DEEP{
            $self-><M::DTManager.notOK>;
          }__;
          my $v1;
          my $v2;
          __CODE{formatValue::
            $input => $value1,
            $output => $v1,
          }__;
          __CODE{formatValue::
            $input => $value2,
            $output => $v2,
          }__;
          __CODE{printComment::
            $test => $self,
            $s => {
              'values are equal: ' . $v1
            },
          }__;
          __EXCEPTION{ASSERTION_ERR}__;
        }

  @Method:
    @@Name: assertNumEquals
    @@enDesc:
      If two values are not equal (i.e. if
      <Perl::<P::actualValue> == <P::expectedValue>>
      is not <DOM::true>), then fails.
    @@NamedParam:
      @@@Name: actualValue
      @@@Type: DISPerl|Any
      @@@enDesc:
        The value returned by the testing code.
      @@@nullCase:
        @@@@enDesc:
          A <DOM::null> value is returned by the testing code.
    @@NamedParam:
      @@@Name: expectedValue
      @@@Type: DISPerl|Any
      @@@enDesc:
        The expected value.
    @@Return:
      @@@AErr:
      @@@PerlDef:
        if (not defined $actualValue) {
          __DEEP{
            $self-><M::DTManager.notOK>;
          }__;
          __CODE{printComment::
            $test => $self,
            $s => {
              'nu'.'ll value is occurred where a non-nu'.'ll value is expected'
            },
          }__;
          __EXCEPTION{ASSERTION_ERR}__;
        } elsif ($actualValue == $expectedValue) {
          ## ok
        } else {
          __DEEP{
            $self-><M::DTManager.notOK>;
          }__;
          my $v1;
          my $v2;
          __CODE{formatValue::
            $input => $actualValue,
            $output => $v1,
          }__;
          __CODE{formatValue::
            $input => $expectedValue,
            $output => $v2,
          }__;
          __CODE{printComment::
            $test => $self,
            $s => {
              'value ' . $v1 . ' is not equal to expected value ' . $v2
            },
          }__;
          __EXCEPTION{ASSERTION_ERR}__;
        }

  @Method:
    @@Name: assertNumNotEquals
    @@enDesc:
      If two values are equal (i.e. if
      <Perl::<P::actualValue> == <P::expectedValue>>
      is <DOM::true>), then fails.
    @@NamedParam:
      @@@Name: actualValue
      @@@Type: DISPerl|Any
      @@@enDesc:
        The value returned by the testing code.
      @@@nullCase:
        @@@@enDesc:
          A <DOM::null> value is returned by the testing code.
    @@NamedParam:
      @@@Name: expectedValue
      @@@Type: DISPerl|Any
      @@@enDesc:
        The expected value.
    @@Return:
      @@@AErr:
      @@@PerlDef:
        if (not defined $actualValue) {
          __DEEP{
            $self-><M::DTManager.notOK>;
          }__;
          __CODE{printComment::
            $test => $self,
            $s => {
              'nu'.'ll value is occurred where a non-nu'.'ll value is expected'
            },
          }__;
          __EXCEPTION{ASSERTION_ERR}__;
        } elsif ($actualValue == $expectedValue) {
          __DEEP{
            $self-><M::DTManager.notOK>;
          }__;
          my $v1;
          my $v2;
          __CODE{formatValue::
            $input => $actualValue,
            $output => $v1,
          }__;
          __CODE{formatValue::
            $input => $expectedValue,
            $output => $v2,
          }__;
          __CODE{printComment::
            $test => $self,
            $s => {
              'value ' . $v1 . ' is equal to value ' .
              $v2 . ' (they must be different)'
            },
          }__;
          __EXCEPTION{ASSERTION_ERR}__;
        }

  @Method:
    @@Name: assertException
    @@enDesc:
      If an exception is not thrown, then fails.

        {NOTE:: If an exception other than one being test
                is thrown in <P::code>, then it will be rethrown.
        }
    @@NamedParam:
      @@@Name: code
      @@@Type: DISPerl|CODE
      @@@enDesc:
        A code reference to be executed.  When executed, the <P::code>
        would receive an argument: <VAR::$test>, the test manager object.
    @@NamedParam:
      @@@Name: exceptionSubtype
      @@@Type: DISString
      @@@enDesc:
        The subtype of the exception that is expected to be thrown
        within <P::code>.
      @@@nullCase:
        @@@@enDesc:
          Whether any exception with a particular subcode is 
          thrown or not is not tested.
    @@Return:
      @@@AErr:
      @@@PerlDef:
        my $passed;
        try {
          $code->($self);
        } catch <IF::dx|Exception||ManakaiDOM|Perl> with {
          my $err = shift;
          my $err_subtype = $err-><AG::dx|Exception||ManakaiDOM|Perl.subtype>;
          if (defined $err_subtype and defined $exceptionSubtype and
              $err_subtype eq $exceptionSubtype) {
            $passed = true;
          } else {
            $err-><M::ecore|Error||ManakaiDOM|Perl.throw>;
          }
        };
        if (not $passed and defined $exceptionSubtype) {
          __DEEP{
            $self-><M::DTManager.notOK>;
          }__;
          __CODE{printComment::
            $test => $self,
            $s => {
              'Exception of subtype <' . $exceptionSubtype .
              '> is expected but not thrown'
            },
          }__;
          __EXCEPTION{ASSERTION_ERR}__;
        }

  @Method:
    @@Name: assertISA
    @@enDesc:
      Unless an object <EM::is-a> package, it fails.
    @@Param:
      @@@Name: object
      @@@Type: DISPerl|Any
      @@@enDesc:
        The object returned by the testing code.
      @@@nullCase:
        @@@@enDesc:
          A <DOM::null> value is returned by the testing code.
    @@Param:
      @@@Name: package
      @@@Type: DISPerl|String
      @@@enDesc:
        The expected package name.
    @@Return:
      @@@AErr:
      @@@PerlDef:
        if (not defined $object) {
          __DEEP{
            $self-><M::DTManager.notOK>;
          }__;
          __CODE{printComment::
            $test => $self,
            $s => {
              'nu'.'ll value is occurred where a non-nu'.'ll value is expected'
            },
          }__;
          __EXCEPTION{ASSERTION_ERR}__;
        } elsif (UNIVERSAL::isa ($object, $package)) {
          # ok
        } else {
          __DEEP{
            $self-><M::DTManager.notOK>;
          }__;
          my $v1;
          my $v2;
          __CODE{formatValue::
            $input => $object,
            $output => $v1,
          }__;
          __CODE{formatValue::
            $input => $package,
            $output => $v2,
          }__;
          __CODE{printComment::
            $test => $self,
            $s => {
              'object ' . $v1 . ' must be ' .
              'an instance of package ' . $v2
            },
          }__;
          __EXCEPTION{ASSERTION_ERR}__;
        }

  @Method:
    @@Name: assertNever
    @@enDesc:
      Always the test fails.
    @@Return:
      @@@AErr:
      @@@PerlDef:
        __DEEP{
          $self-><M::DTManager.notOK>;
        }__;
        __CODE{printComment::
          $test => $self,
          $s => {
            'An ungeneral event occurred'
          },
        }__;
        __EXCEPTION{ASSERTION_ERR}__;

  @Method:
    @@Name: assertDOMTreeEquals
    @@enDesc:
      The test fails if the actual DOM subtree does not match
      to expected tree structure.
    @@NamedParam:
      @@@Name: expectedHash
      @@@Type: DISPerl|HASH||ManakaiDOM|all
      @@@enDesc:
        A Perl hash representation of TDT tree.
    @@NamedParam:
      @@@Name: actualValue
      @@@Type: Node
      @@@enDesc:
        The root node of the subtree compared with <P::expectedHash>.
    @@NamedParam:
      @@@Name: nodePathString
      @@@Type: DOMString
      @@@enDesc:
        A semi human readable string that describes the position
        of the context where <P::actualValue> appeared.  It might
        be used to report an error.
      @@@nullCase:
        @@@@enDesc: No context information available.
    @@Return:
      @@@AErr:
      @@@PerlDef:
        if (defined $nodePathString) {
          $nodePathString .= '/';
        } else {
          $nodePathString = '';
        }

        if (not defined $actualValue) {
          __DEEP{
            $self-><M::DTManager.notOK>;
          }__;
          __CODE{printComment::
            $test => $self,
            $s => {
              $nodePathString.': '.
              'nu'.'ll value is occurred where a non-nu'.'ll value is expected'
            },
          }__;
          __EXCEPTION{ASSERTION_ERR}__;
        } elsif (not ref $actualValue) {
          __DEEP{
            $self-><M::DTManager.notOK>;
          }__;
          __CODE{printComment::
            $test => $self,
            $s => {
              $nodePathString.': '.
              'not a blessed reference (|'.$actualValue.'| (|'.
              (ref $actualValue).'|)) where node is expected'
            },
          }__;
          __EXCEPTION{ASSERTION_ERR}__;
        }

        if ($actualValue->can ('node_name')) {
          $nodePathString .= $actualValue->node_name;
        } else {
          $nodePathString .= 'object ('.(ref $actualValue).')';
        }
        
        for my $attr (keys %{$expectedHash}) {
          if ($attr eq 'node_type') {
            my $ant = $actualValue->node_type;
            if ($ant != {
              'document' => <C::Node.DOCUMENT_NODE>,
              'document-fragment' => <C::Node.DOCUMENT_FRAGMENT_NODE>,
              'element' => <C::Node.ELEMENT_NODE>,
              'attribute' => <C::Node.ATTRIBUTE_NODE>,
 ## TODO: Trun this line enable after namespace node is implemented
 #             'namespace' => C::Node.NAMESPACE_NODE>,
              'text' => <C::Node.TEXT_NODE>,
              'cdata-section' => <C::Node.CDATA_SECTION_NODE>,
              'comment' => <C::Node.COMMENT_NODE>,
              'pi' => <C::Node.PROCESSING_INSTRUCTION_NODE>,
              'document-type' => <C::Node.DOCUMENT_TYPE_NODE>,
              'entity' => <C::Node.ENTITY_NODE>,
              'entity-reference' => <C::Node.ENTITY_REFERENCE_NODE>,
              'notation' => <C::Node.NOTATION_NODE>,
              'element-type-definition' => <C::Node.ELEMENT_TYPE_DEFINITION_NODE>,
              'attribute-definition' => <C::Node.ATTRIBUTE_DEFINITION_NODE>,
            }->{$expectedHash->{$attr}}) {
              __DEEP{
                $self-><M::DTManager.notOK>;
              }__;
              __CODE{printComment::
                $test => $self,
                $s => {
                  $nodePathString.': Its node type is '.$ant.' ('.
                  $expectedHash->{$attr}.' is expected'
                },
              }__;
              __EXCEPTION{ASSERTION_ERR}__;
            }
          } elsif ($attr eq 'child_nodes') {
            my $acld = $actualValue->child_nodes;
            my $xcld = $expectedHash->{$attr};
            if (@$acld != @$xcld) {
              __DEEP{
                $self-><M::DTManager.notOK>;
              }__;
              __CODE{printComment::
                $test => $self,
                $s => {
                  $nodePathString.': It has '.@$acld.' child nodes ('.@$xcld.
                  ' expected'
                },
              }__;
              __EXCEPTION{ASSERTION_ERR}__;
            }
            for (0..$#{$expectedHash->{$attr}}) {
              __DEEP{
                $self-><M::DTManager.assertDOMTreeEquals>
                         (actual_value => $acld->[$_],
                          expected_hash => $xcld->[$_],
                          node_path_string => $nodePathString);
              }__;
            }

 ## TODO: Implement these values
          } elsif ($attr eq 'attributes') {

          } elsif ($attr eq 'element_types') {

          } elsif ($attr eq 'attribute_definitions') {

          } elsif ($attr eq 'general_entities') {

          } elsif ($attr eq 'notations') {

          } elsif ($attr eq 'namespaces') {

          } else {
            my $aval;
            my $amtd = $actualValue->can ($attr);
            unless ($amtd) {
              __DEEP{
                $self-><M::DTManager.notOK>;
              }__;
              __CODE{printComment::
                $test => $self,
                $s => {
                  $nodePathString.': Object (type |'.(ref $actualValue).
                  '|) does not have attribute |'.$attr.'|'
                },
              }__;
              __EXCEPTION{ASSERTION_ERR}__;
            }

            __DEEP{
              $aval = $actualValue->$attr;
            }__;

            my $xval = $expectedHash->{$attr};

            if ($xval->{type} eq 'nu'.'ll') {
              if (defined $aval) {
                __DEEP{
                  $self-><M::DTManager.notOK>;
                }__;
                __CODE{printComment::
                  $test => $self,
                  $s => {
                    $nodePathString.'->'.$attr.': Value is not nu'.'ll (|'.
                    $aval.'| (type |'.(ref $aval).'|'
                  },
                }__;
                __EXCEPTION{ASSERTION_ERR}__;
              }
            } else {
              unless (defined $aval) {
                __DEEP{
                  $self-><M::DTManager.notOK>;
                }__;
                __CODE{printComment::
                  $test => $self,
                  $s => {
                    $nodePathString.'->'.$attr.': Value is nu'.'ll (a '.
                    $xval->{type}.' with value |'.$xval->{value}.'| is expected'
                  },
                }__;
                __EXCEPTION{ASSERTION_ERR}__;
              }
              if ($xval->{type} eq 'boolean') {
                if (($aval and not $xval->{value}) or
                    (not $aval and $xval->{value})) {
                  __DEEP{
                    $self-><M::DTManager.notOK>;
                  }__;
                  __CODE{printComment::
                    $test => $self,
                    $s => {
                      $nodePathString.'->'.$attr.': Value is not boolean '.
                      $xval->{value}
                    },
                  }__;
                  __EXCEPTION{ASSERTION_ERR}__;
                }
              } elsif ($xval->{type} eq 'number') {
                unless ($aval == $xval->{value}) {
                  __DEEP{
                    $self-><M::DTManager.notOK>;
                  }__;
                  __CODE{printComment::
                    $test => $self,
                    $s => {
                      $nodePathString.'->'.$attr.': Value is |'.$aval.'| (|'.
                      $xval->{value}.'| is expected)'
                    },
                  }__;
                  __EXCEPTION{ASSERTION_ERR}__;
                }
              } elsif ($xval->{type} eq 'string') {
                unless ($aval eq $xval->{value}) {
                  __DEEP{
                    $self-><M::DTManager.notOK>;
                  }__;
                  __CODE{printComment::
                    $test => $self,
                    $s => {
                      $nodePathString.'->'.$attr.': Value is |'.$aval.'|, type |'.
                      (ref $aval).'| (|'.
                      $xval->{value}.'| is expected)'
                    },
                  }__;
                  __EXCEPTION{ASSERTION_ERR}__;
                }
              } # $aval->{type}
            } # $aval->{type} undef
          }
        }

  @Method:
    @@Operator:
      @@@@: DESTROY
      @@@ContentType: DISPerl|Perl
    @@Return:
      @@@PerlDef:
        if (not $self->{<H::dtest|ok>} and defined $self->{<H::dtest|uri>}) {
          __DEEP{
            $self-><M::DTManager.notOK>;
          }__;
        }

        if ($self->{<H::dtest|currentNumber>} < $self->{<H::dtest|number>}) {
          __CODE{printComment::
            $test => $self,
            $s => {
              sprintf "Looks like you planned %d tests but only ran %d.",
                      $self->{<H::dtest|number>},
                      $self->{<H::dtest|currentNumber>}
            },
          }__;
        } elsif ($self->{<H::dtest|number>} <
                 $self->{<H::dtest|currentNumber>}) {
          __CODE{printComment::
            $test => $self,
            $s => {
              sprintf "Looks like you planned %d tests but ran %d extra.",
                      $self->{<H::dtest|number>},
                      $self->{<H::dtest|currentNumber>}
                        - $self->{<H::dtest|number>}
            },
          }__;
        }
        if ($self->{<H::dtest|failedNumber>}) {
          __CODE{printComment::
           $test => $self,
           $s => {
              sprintf "Looks like you failed %d tests of %d.",
                      $self->{<H::dtest|failedNumber>},
                      $self->{<H::dtest|number>}
            },
          }__;
        } else {
          __CODE{printComment::
           $test => $self,
           $s => {
              sprintf "Looks like you passed %d tests.",
                      $self->{<H::dtest|number>}
            },
          }__;
        }

  @ResourceDef:
    @@ForCheck: ManakaiDOM|ForClass
    @@QName: printComment
    @@rdf:type: DISPerl|BlockCode
    @@enDesc:
      Prints a comment to <Q::dtest|output>.
    @@PerlDef:
      my $__s = $s;
      $__s =~ s/\n/\n## /g;
      $__s =~ s/\n## $/\n/s;
      $__s .= "\n" unless $__s =~ /\n$/;
      $__s = q<## > . $__s;
      print {$test->{<H::dtest|output>}} $__s;

  @ResourceDef:
    @@ForCheck: ManakaiDOM|ForClass
    @@QName: formatValue
    @@rdf:type: DISPerl|BlockCode
    @@enDesc:
      Formats a value for error messages.
    @@PerlDef:
      $output = $input;
      my $__ref = ref $output;
      if (not defined $output) {
        $output = '(undef)';
      } elsif ($output eq '') {
        $output = '(empty)';
      } else {
        $output =~ s{([\x00-\x09\x0B-\x1F\x7F-\xA0])}
                    {sprintf '\\x{%04X}', ord $1}ge;
        $output =~ s/\x0A/\x{000A}\n/g;
        $output = "'" . $output . "'";
      }
      $output .= ' ['.$__ref.']' if length $__ref;

  @Method:
    @@Name: setTestData
    @@enDesc:
      Associates a data with the key on the test manager.

        {NOTE:: Associations of keys and data are removed when
                <M::DTManager.startNewTest> method is called.
        }

        {NOTE:: It is useful to register a value whose destructor
                might invoke part of test code which should usually
                not be executed on that timing in successful cases
                but may be executed in failure cases so that the failure
                report is made unappropriate.  (See user data handler
                tests in the implementation of DOM Level 3 Core for example.)
        }
   @@Param:
     @@@Name: key
     @@@Type: DISString
     @@@enDesc:
       The key.  If there is already data for the <P::key>, then
       its data is updated.
   @@Param:
     @@@Name: data
     @@@Type: DISPerl|Any
     @@@enDesc:
       The data.
     @@@nullCase:
       @@@@enDesc: The association is removed.
   @@Return:
     @@@PerlDef:
       $self->{<H::dtest|testData>}->{$key} = $data;
##DTManager

PropDef:
  @QName: dtest|testData
  @enDesc:
    Test data.
  @dtest:key: d

ElementTypeBinding:
  @Name: NamedParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:MethodParameter
    @@DISPerl:isNamedParameter:1

ElementTypeBinding:
  @Name: URIParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:MethodParameter
    @@DISPerl:isNamedParameter:1
    @@Name: uri
    @@Type: DISString
    @@Description:
      @@@lang:en
      @@@@:
        A URI that identifies the subtest.
    @@ResourceDef:
      @@@rdf:type: ManakaiDOM|InCase
      @@@Value:
        @@@@is-null:1
      @@@Description:
        @@@@lang:en
        @@@@@:
          The subtest has no URI.

ElementTypeBinding:
  @Name: AErr
  @ElementType:
    dx:raises
  @ShadowContent:
    @@@: ASSERTION_ERR
    @@Description:
      @@@lang:en
      @@@@:
        If assetion fails.

ResourceDef:
  @QName: DISString
  @AliasFor: DOMMain|DOMString
  @For: ManakaiDOM|ManakaiDOM

ResourceDef:
  @QName: Node
  @AliasFor: Tree|Node
  @For: ManakaiDOM|ManakaiDOM

PropDef:
  @QName: dtest|failedNumber
  @enDesc:
    The number of current failed tests.
  @dtest:key: f

PropDef:
  @QName: dtest|output
  @enDesc:
    The file handle to which messages should be written.
  @dtest:key: o

ElementTypeBinding:
  @Name: PerlDef
  @ElementType:
    dis:Def
  @ShadowContent:
    @@ContentType:
      lang:Perl
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: InCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:InCase

ElementTypeBinding:
  @Name: nullCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:InCase
    @@Value:
      @@@is-null:1
      @@@ContentType: DISCore|String

ElementTypeBinding:
  @Name: TrueCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:InCase
    @@Value:
      @@@@: 1
      @@@ContentType: DISCore|Boolean
    @@Type: idl|boolean||ManakaiDOM|all

ElementTypeBinding:
  @Name: FalseCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:InCase
    @@Value:
      @@@@: 0
      @@@ContentType: DISCore|Boolean
    @@Type: idl|boolean||ManakaiDOM|all

IFClsDef:
  @IFQName: DTException
  @ClsQName: ManakaiDTException

  @rdf:type:
    @@@: dx|Interface
    @@ForCheck: ManakaiDOM|ForIF

  @rdf:type:
    @@@: dx|Class
    @@ForCheck: ManakaiDOM|ForClass

  @ClsISA: dx|Exception||ManakaiDOM|Perl
  @dx:implementedBy: ||ManakaiDOM|ManakaiDOMLatest||ManakaiDOM|ForClass

  @ResourceDef:
    @@QName: DTExceptionCode
    @@ForCheck: ManakaiDOM|ForIF
    @@rdf:type: DISLang|ConstGroup

    @@enDesc:
      Exception codes for <IF::DTException>. 

    @@Type: idl|unsignedShort||ManakaiDOM|all
    @@rdfs:subClassOf: idl|unsignedShort||ManakaiDOM|all

    @@ResourceDef:
      @@@rdf:type: DISLang|Const
      @@@QName: test|PARSE_ERR
      @@@Value:
        @@@@@: 81
        @@@@ContentType: DISCore|Integer
      @@@enDesc:
        An attempt was made to load a TDT document and
        the processing has been stopped.

    @@ResourceDef:
      @@@QName: ASSERTION_ERR
      @@@rdf:type: DISLang|Const
      @@@Value:
        @@@@@:10001
        @@@@ContentType: DISCore|Integer
      @@@enDesc:
        An assertion failed.
##DTException


ElementTypeBinding:
  @Name: PropDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: rdf|Property
    @@For: =ManakaiDOM|all

ElementTypeBinding:
  @Name: RPropDef:
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: rdf|Property
    @@rdf:type: DISSource|Property
    @@For: =ManakaiDOM|all

ElementTypeBinding:
  @Name: SPropDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: rdf|Property
    @@rdf:type: DISSource|Property
    @@rdf:type: DISSource|ResourceProperty
    @@For: =ManakaiDOM|all

FeatureDef:
  @QName: DIS|TDT
  @FeatureVerDef:
    @@QName: DIS|TDT10
    @@Version: 1.0
    @@f:instanceOf: DIS|TDT
    @@enFN:
      The <DFN::TDT> format, version 1.0

IFClsDef:
  @IFQName: TDTParser
  @ClsQName: ManakaiTDTParser

  @Implement: ecore|MUErrorTarget||ManakaiDOM|Perl

  @DISLang:role: DOMLS|ParserRole

  @f:implements: DIS|TDT10
  @f:provides:
    @@@: DIS|TDT10
    @@f:through: DOMCore|ManakaiDOMImplementation

  @enDesc:
    A <IF::TDTParser> object parses a TDT source document and
    returns it as an object.

    A <IF::TDTParser> object can be retrieved by 
    <M::GenericLS|GLSImplementation.createGLSParer>

  @Attr:
    @@Name: domConfig
    @@enDesc:
      The configuration of the parser.

    @@Get:
      @@@Type: DOMCore|DOMConfiguration
      @@@enDesc: The DOM configuration object.
      @@@PerlDef:
        __CODE{DOMCore|getConfigObject::
          $target => $self,
          $targetHash => $self,
          $targetType => {<IFName::TDTParser>},
          $result => $r,
        }__;

  @Method:
    @@ManakaiDOM:isForInternal:1
    @@ForCheck: ManakaiDOM|ForClass
    @@Operator: DISPerl|NewMethod
    @@enDesc:
      Creates a new instance of the object.
    @@Param:
      @@@Name: impl
      @@@Type: DOMLS|GLSImplementation
      @@@enDesc:
        The implementation from which the parser is created.
    @@Param:
      @@@Name: features
      @@@Type: DOMString
      @@@dis:actualType: f|FeaturesString
      @@@enDesc:
        The set of features requested for the parser.
    @@Return:
      @@@Type: DOMMain|DOMObject
      @@@enDesc:
        The newly created parser.
      @@@PerlDef:
        $r = bless {
          <H::DOMCore:implementation> => $impl,
        }, $self;

  @Method:
    @@Name: parseString
    @@enDesc:
      Parses a string as TDT textual definition and converts it into
      its object representation.
    @@Param:
      @@@Name: sourceText
      @@@Type: DOMString
      @@@enDesc:
        The text to parse.
    @@Return:
      @@@Type: DISPerl|HASH
      @@@enDesc:
        An object representation of <P::sourceText>.
      @@@dx:raises:
        @@@@@: test|PARSE_ERR
        @@@@enDesc:
          If the TDT document contains one or more error.
      @@@PerlDef:
        $self->{char} = [];
        $self->{token} = [];
        $self->{source} = $sourceText;
        __DEEP{
          $r = $self->_parse_document;
        }__;

  @Method:
    @@Name: shiftChar
    @@ManakaiDOM:isForInternal:1
    @@ForCheck: ManakaiDOM|ForClass
    @@enDesc:
      Returns the next character.
    @@Return:
      @@@Type: idl|long||ManakaiDOM|all
      @@@enDesc:
        The code position number of the next character, if any,
        or <CODE::-2>.
      @@@PerlDef:
        if (@{$self->{char}}) {
          $r = shift @{$self->{char}};
        } else {
          my $char = substr ($self->{source}, pos ($self->{source}), 1);
          pos ($self->{source})++;

          if (length $char) {
            $r = ord $char;
          } else {
            $r = -1;
          }
        }

  @Method:
    @@ManakaiDOM:isForInternal: 1
    @@Operator: ManakaiDOM|MUErrorHandler
    @@enDesc:
      When a <IF::ecore|ErrorInterface||ManakaiDOM|Perl> is <Perl::report>ed,
      then this method is invoked.
      
      The method calls the <cfg::DOMCore|error-handler> if the error is of 
      <IF::DOMCore|DOMError>.  Otherwise, the error is re-thrown so that
      corresponding <Perl::catch> clause, if any, can catch the error.
    @@Param:
      @@@Name: err
      @@@Type: ecore|ErrorInterface||ManakaiDOM|Perl
      @@@enDesc:
        The reported error object.
    @@Return:
      @@@Type: DISPerl|Any
      @@@enDesc:
        If the <P::err> is a <IF::DOMCore|DOMError>, then the return value
        of the error handler.

           {NOTE:: If the error is thrown, the method never returns.
           }
      @@@nullCase:
        @@@@enDesc:
          No error handler.
      @@@PerlDef:
        if ($err->isa (<IFName::DOMCore|DOMError||ManakaiDOM|ManakaiDOM>)) {
          __DEEP{
            A: {
              my $cfg = $self-><AG::TDTParser.domConfig>;
              my $h = $cfg-><M::DOMCore|DOMConfiguration.getParameter>
                               ('error-handler');
              $r = $h-><M::DOMCore|DOMErrorHandler.handleError> ($err);
            } # A
          }__;
        } else {
          $err-><M::ecore|ErrorInterface||ManakaiDOM|Perl.throw>;
        }

  @DISPerl:dpgDef:
    lexmode default : initial : standalone {

      /* Name */
      $name-start-char := [U+0041..U+005A U+0061..U+007A];
      $name-char       := [U+0041..U+005A U+0061..U+007A U+0030..U+0039 '-'];
      NAME : value := $name-start-char $name-char*;

      /* Block */
      LBRACE := ['{'];
      RBRACE := ['}'];
      COLON := [':'];

      /* String */
      STRING : value := [U+0027] [^U+0027]* [U+0027];
      $hexdigit := [U+0030..U+0039 U+0041..U+0046 U+0061..U+0066];
      CHAR : value := ['U'] ['+'] $hexdigit $hexdigit $hexdigit $hexdigit
                                  $hexdigit? $hexdigit?;

      /* Number */
      MINUS := ['-'];
      DNUM : value := [U+0030..U+0039]+;
      XNUM : value := ['0'] ['x']
                      [U+0030..U+0039 U+0041..U+0046 U+0061..U+0066 '_']+;
      BNUM : value := ['0'] ['b'] ['0' '1' '_']+;
      
      /* Ignored white space */
      WSP : ignore := [U+0009..U+000D U+0020]+;

      /* Ignored comment */
      COMMENT1 : ignore := ['/'] ['/'] [^U+000A..U+000D]* [U+000A..U+000D]*;
      $comment2 := [^'/' '*'] [^'*']* ['*']+;
      COMMENT2 : ignore := ['/'] ['*'] [^'*']* ['*']+ $comment2* ['/'];

    } // lexmode default

    rule document : standalone : recursive {
      /*
        document := node;
        node := node-type "{" *(node / attribute) "}"
        node-type := 'document' / 'document-fragment' /
                     'element' /
                     'attribute' / 'namespace' /
                     'text' / 'cdata-section' /
                     'comment' /
                     'pi' /
                     'document-type' /
                     'entity' / 'entity-reference' /
                     'notation' /
                     'element-type-definition' / 'attribute-definition'
      */

      my $node : return;
      lang:Perl {
        $node = {
        };
      }

      ~ (NAME) {
        lang:Perl ($v => $token.value) {
          $node->{node_type} = $v;
        }
      }

      ~ (LBRACE) { }

      &_node ($node => $node);

      ~ (EOF) { }
    }

    rule _node ($node) : standalone : recursive {
      // ~ (NAME) { }
      // ~ (LBRACE) { }

      ~* (NAME) {
        my $name;
        lang:Perl ($v => $token.value) {
          $name = $v;
        }

        ~ (COLON) {
          &_attribute ($node => $node, $name => $name);
        } (LBRACE) {
          my $subnode;
          lang:Perl {
            $subnode = {
              node_type => $name,
            };
            if ($name eq 'attribute') {
              push @{$node->{attributes}||=[]}, $subnode;
            } elsif ($name eq 'element-type-definition') {
              push @{$node->{element_types}||=[]}, $subnode;
            } elsif ($name eq 'attribute-definition') {
              push @{$node->{attribute_definitions}||=[]}, $subnode;
            } elsif ($name eq 'entity') {
              push @{$node->{general_entities}||=[]}, $subnode;
            } elsif ($name eq 'notation') {
              push @{$node->{notations}||=[]}, $subnode;
            } elsif ($name eq 'namespace') {
              push @{$node->{namespaces}||=[]}, $subnode;
            } else {
              push @{$node->{child_nodes}||=[]}, $subnode;
            }
          }
          &_node ($node => $subnode);
        }
      }

      ~ (RBRACE) { }

    } // _node

    rule _attribute ($node, $name) {
      /*
        attribute := attribute-name ":" attribute-value ";"
        attribute-name := name
        attribute-value := 'null' / 'true' / 'false' / 1*(string / char) / number
      */
 
      // ~ (NAME) { }
      // ~ (COLON) { }

      lang:Perl {
        $name =~ tr/-/_/;
      }

      ~ (NAME == 'null') {
        lang:Perl {
          $node->{$name} = {type => 'nu'.'ll'};
        }
      } (NAME == 'true') {
        lang:Perl {
          $node->{$name} = {type => 'boolean', value => 1};
        }
      } (NAME == 'false') {
        lang:Perl {
          $node->{$name} = {type => 'boolean', value => 0};
        }
      } (STRING) {
        lang:Perl ($v => $token.value) {
          $node->{$name} = {type => 'string',
                            value => substr ($v, 1, length ($v) - 2)};
        }

        ~* (STRING) {
          lang:Perl ($v => $token.value) {
            $node->{$name}->{value} .= substr ($v, 1, length ($v) - 2);
          }
        } (CHAR) {
          lang:Perl ($v => $token.value) {
            $node->{$name}->{value} .= chr hex substr ($v, 2);
          }
        }
      } (CHAR) {
        lang:Perl ($v => $token.value) {
          $node->{$name} = {type => 'string',
                            value => chr hex substr ($v, 2)};
        }

        ~* (STRING) {
          lang:Perl ($v => $token.value) {
            $node->{$name}->{value} .= substr ($v, 1, length ($v) - 2);
          }
        } (CHAR) {
          lang:Perl ($v => $token.value) {
            $node->{$name}->{value} .= chr hex substr ($v, 2);
          }
        }
      } (DNUM) {
        lang:Perl ($v => $token.value) {
          $node->{$name} = {type => 'number', value => 0+$v};
        }
      } (XNUM) {
        lang:Perl ($v => $token.value) {
          $node->{$name} = {type => 'number', value => hex $v};
        }
      } (BNUM) {
        lang:Perl ($v => $token.value) {
          $node->{$name} = {type => 'number', value => eval $v};
        }
      }

      ~ (SEMICOLON) { }
    } // _attribute
##TDTParser

IFClsDef:
  @IFQName: DTExceptionFormatter
  @ClsQName: ManakaiDTExceptionFormatter

  @ClsISA: ecore|MUErrorFormatter||ManakaiDOM|Perl

  @RuleDef:
    @@Name: tdt-error-token-type
    @@enDesc:
      The type of the token the parser is encountered.

    @@Method:
      @@@Name: after
      @@@Param:
        @@@@Name: name
        @@@@Type: DOMString
        @@@@enDesc: The name of the method.
      @@@Param:
        @@@@Name: p
        @@@@Type: DISPerl|HASH
        @@@@enDesc: The set of the parameters to the method.
      @@@Param:
        @@@@Name: o
        @@@@Type: DISPerl|HASH
        @@@@enDesc: The option value.
      @@@Return:
        @@@@PerlDef:
          $p->{-result} = $o->{<H::test|error-token>}->{type}
            if defined $o->{<H::test|error-token>}->{type};

  @RuleDef:
    @@Name: tdt-error-token-value
    @@enDesc:
      The value of the token the parser is encountered, if any.

    @@Method:
      @@@Name: after
      @@@Param:
        @@@@Name: name
        @@@@Type: DOMString
        @@@@enDesc: The name of the method.
      @@@Param:
        @@@@Name: p
        @@@@Type: DISPerl|HASH
        @@@@enDesc: The set of the parameters to the method.
      @@@Param:
        @@@@Name: o
        @@@@Type: DISPerl|HASH
        @@@@enDesc: The option value.
      @@@Return:
        @@@@PerlDef:
          $p->{-result} = $o->{<H::test|error-token>}->{value}
            if defined $o->{<H::test|error-token>}->{value};

  @RuleDef:
    @@Name: tdt-error-lines
    @@enDesc:
      A copy of fragment of the source text that contains the line
      where the error occurred, if available.
    
    @@Method:
      @@@Name: after
      @@@Param:
        @@@@Name: name
        @@@@Type: DOMString
        @@@@enDesc: The name of the method.
      @@@Param:
        @@@@Name: p
        @@@@Type: DISPerl|HASH
        @@@@enDesc: The set of the parameters to the method.
      @@@Param:
        @@@@Name: o
        @@@@Type: DISPerl|HASH
        @@@@enDesc: The option value.
      @@@Return:
        @@@@PerlDef:
          my $pos = $o-><AG::DOMCore|DOMError.location>
                      -><AG::DOMCore|DOMLocator.utf32Offset>;
          if ($pos > -1) {
            my $src = $o->{<H::test|source-text>};
            my $start = $pos;
            $start = rindex ($$src, "\x0A", $start - 1) for 0..2;
            $start++;
            my $end = $pos;
            $end = index ($$src, "\x0A", $end + 1) for 0..2;
            $end = length $$src if $end < 0;
            $p->{-result} = substr $$src, $start, $end - $start;
          }
##DPGExceptionFormatter

ElementTypeBinding:
  @Name: RuleDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass
    @@rdf:type: Muf2003|RuleDefClass

ElementTypeBinding:
  @Name: RuleParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: Muf2003|RuleParameter

ElementTypeBinding:
  @Name:enMufDef
  @ElementType:
    ecore:defaultMessage
  @ShadowContent:
    @@lang:en
    @@ContentType:
      lang:muf

PropDef:
  @QName: test|error-token
  @enDesc:
    The token where the parser found an error.

PropDef:
  @QName: test|source-text
  @enDesc:
    A reference to the original source text, if available.

ElementTypeBinding:
  @Name: CParamApp
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      @@@@: DOMCore|DOMConfigurationParameterApplication
      @@@For: ManakaiDOM|DOM
    @@rdf:type:
      @@@@: DISCore|Property
      @@@For: =ManakaiDOM|all
    @@For: ManakaiDOM|DOM3
    @@For: =ManakaiDOM|all

CParamApp:
  @DOMCore:domConfigurationParameter: DOMCore|error-handler
  @DOMCore:targetType: TDTParser

ElementTypeBinding:
  @Name: ErrDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DOMCore|DOMErrorType
    @@For: ManakaiDOM|DOM3
    @@ecore:textFormatter: ManakaiDTExceptionFormatter

ErrDef:
  @QName: test|bad-token-error
  @enDesc:
    The parser is encountered to a token whose type is not
    allowed there.
  @DOMCore:severity: DOMCore|SEVERITY_FATAL_ERROR
  @enMufDef:
    Token |%tdt-error-token-type;|%tdt-error-token-value
    (prefix => { (|}, suffix => {|)}); is not 
    allowed %tdt-error-lines (prefix => {(|}, suffix => {|)});
