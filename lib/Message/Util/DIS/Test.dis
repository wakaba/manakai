Module:
  @QName: DIS|Test
  @enFN:
    <QUOTE::dis> Testing Module
  @Namespace:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS#Test/
  
  @enDesc:
    The <Module::DIS|Test> module provides a set of interfaces
    for test scripts generated from <QUOTE::dis> resource sets.

  @DISCore:author: DISCore|Wakaba
  @License: license|Perl+MPL
  @Date:
    $Date: 2006/02/08 16:37:36 $
  
  @Require:
    @@Module:
      @@@QName: DIS|common
    @@Module:
      @@@QName: DISlib|Test
      @@@WithFor: ManakaiDOM|all
    @@Module:
      @@@QName: MDOM|DOMFeature
      @@@WithFor: ManakaiDOM|ManakaiDOMLatest
    @@Module:
      @@@QName: MDOM|GenericLS
      @@@WithFor: ManakaiDOM|ManakaiDOMLatest
    @@Module:
      @@@WithFor: ManakaiDOM|ManakaiDOM
    @@Module:
      @@@WithFor: ManakaiDOM|ManakaiDOMLatest
    @@Module:
      @@@QName: Util|DIS
      @@@WithFor: DIS|ForLatest

  @DefaultFor: ManakaiDOM|ManakaiDOMLatest

Namespace:
  @DIS:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS#
  @dis:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#dis--
  @DISlib:
    http://suika.fam.cx/~wakaba/archive/2004/dis/
  @dtest:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS#Test/
  @dx:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#
  @ecore:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/Core/
  @f:
    http://suika.fam.cx/~wakaba/archive/2004/dom/feature#
  @gls:
    http://suika.fam.cx/~wakaba/archive/2004/dom/gls#
  @idl:
    http://suika.fam.cx/~wakaba/archive/2004/dis/IDL#
  @kwd:
    http://suika.fam.cx/~wakaba/archive/2005/rfc2119/
  @lang:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#
  @license:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/license#
  @ManakaiDOM:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#
  @MDOM:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#ManakaiDOM.
  @rdf:
    http://www.w3.org/1999/02/22-rdf-syntax-ns#
  @rdfs:
    http://www.w3.org/2000/01/rdf-schema#
  @test:
    http://suika.fam.cx/~wakaba/archive/2004/dis/Test#
  @Util:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/

## -- Features

ElementTypeBinding:
  @Name: FeatureDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DOMFeature|Feature
    @@For: ManakaiDOM|all

ElementTypeBinding:
  @Name: FeatureVerDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DOMFeature|Feature

ElementTypeBinding:
  @Name: featureQName
  @ElementType:
    DOMFeature:name
  @ShadowContent:
    @@ContentType: DISCore|QName

FeatureDef:
  @QName: DIS|Test
  @FeatureVerDef:
    @@QName: DIS|Test10
    @@Version: 1.0
    @@f:requires: f|min30
    @@f:instanceOf: DIS|Test
    @@enFN:
      <QUOTE::dis> Testing Module, version 1.0

ElementTypeBinding:
  @Name: enDesc
  @ElementType: 
    dis:Description
  @ShadowContent: 
    @@lang:en

ElementTypeBinding:
  @Name: enFN
  @ElementType:
    dis:FullName
  @ShadowContent:
    @@lang:en

ElementTypeBinding:
  @Name: enImplNote
  @ElementType:
    dis:ImplNote
  @ShadowContent:
    @@lang:en

ElementTypeBinding:
  @Name: IFClsDef
  @ElementType: 
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      @@@@: dis|MultipleResource
      @@@ForCheck: !ManakaiDOM|ForIF !ManakaiDOM|ForClass
    @@resourceFor: ManakaiDOM|ForIF
    @@resourceFor: ManakaiDOM|ForClass
    @@For: ManakaiDOM|ManakaiDOM

    @@rdf:type:
      @@@@: DISLang|Interface
      @@@ForCheck: ManakaiDOM|ForIF

    @@rdf:type:
      @@@@: DISLang|Class
      @@@ForCheck: ManakaiDOM|ForClass
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOM||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOMLatest||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOMLatest

    @@f:implements: DIS|Test10

ElementTypeBinding:
  @Name: IFQName
  @ElementType:
    dis:QName
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForIF

ElementTypeBinding:
  @Name: ClsQName
  @ElementType:
    dis:QName
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: IFISA
  @ElementType:
    dis:ISA
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForIF

ElementTypeBinding:
  @Name: ClsISA
  @ElementType:
    dis:ISA
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: Method
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Method
    @@For: !=ManakaiDOM|ManakaiDOM

ElementTypeBinding:
  @Name: Return
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|MethodReturn

ElementTypeBinding:
  @Name: Param
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|MethodParameter

ElementTypeBinding:
  @Name: Attr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Attribute
    @@For: !=ManakaiDOM|ManakaiDOM

ElementTypeBinding:
  @Name: Get
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|AttributeGet

ElementTypeBinding:
  @Name: Set
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|AttributeSet

## -- Implementation

IFClsDef: 
  @IFQName: DTImplementation
  @ClsQName: ManakaiDTImplementation

  @IFISA: f|MinimumImplementation
  @ClsISA: f|ManakaiMinimumImplementation

  @f:provides: DIS|Test10

  @Method:
    @@Name: createTestManager
    @@enDesc:
      Creates a <IF::DTManager> object.
    @@Param:
      @@@Name: totalNumber
      @@@Type: unsignedLong
      @@@enDesc:
        The total number of tests.
    @@Param:
      @@@Name: outputFile
      @@@Type: DISPerl|FileHandle
      @@@enDesc:
        The file handle to which reports are written.
      @@@nullCase:
        @@@@enDesc:
          Defaulted to the standard output.
    @@Return:
      @@@Type: DTManager
      @@@enDesc:
        The newly created test manager.
      @@@PerlDef:
        $r = bless {<H::dtest|number> => $totalNumber,
                    <H::dtest|currentNumber> => 0,
                    <H::dtest|failedNumber> => 0,
                    <H::dtest|output> => $outputFile || \*STDOUT},
                   <ClassName::ManakaiDTManager>;
        print {$r->{<H::dtest|output>}}
                "1.." . $r->{<H::dtest|number>} . "\n";
##DISImplementationTest

PropDef:
  @QName: dtest|uri
  @enDesc:
    A URI that identifies the test.
  @dtest:key: i

PropDef:
  @QName: dtest|id
  @enDesc:
    A subtest identifier.
  @dtest:key: s

PropDef:
  @QName: dtest|number
  @enDesc:
    The total number of tests.
  @dtest:key: n

PropDef:
  @QName: dtest|currentNumber
  @enDesc:
    The current number of tests.
  @dtest:key: c

SPropDef:
  @QName: dtest|key
  @enDesc:
    The key name of the property when it is used in 
    <Class::DTManager::ManakaiDOM:ManakaiDOMLatest>.
  @dataType: DISCore|String
  @multipleProperties: DISCore|Single
  @rdfs:domain: rdfs|Property
  @rdfs:subPropertyOf: DISPerl|propHashKey

IFClsDef:
  @IFQName: DTManager
  @ClsQName: ManakaiDTManager

  @ClsISA: dx|ManakaiDefaultExceptionHandler||ManakaiDOM|Perl

  @Attr:
    @@Name: totalNumber
    @@enDesc
      The total number of tests.
    @@Type: unsignedLong
    @@Get:
      @@@PerlDef:
        $r = $self->{<H::dtest|number>};

  @Attr:
    @@Name: currentNumber
    @@enDesc:
      The number of tests that is already done.
    @@Type: unsignedLong
    @@Get:
      @@@PerlDef:
        $r = $self->{<H::dtest|currentNumber>};

  @Attr:
    @@Name: failedNumber
    @@enDesc:
      The number of tests that has failed.
    @@Type: unsignedLong
    @@Get:
      @@@PerlDef:
        $r = $self->{<H::dtest|failedNumber>};

  @Attr:
    @@Name: outputFile
    @@enDesc:
      The file handle to which reports are written.
    @@Type: DISPerl|Filehandle
    @@Get:
      @@@PerlDef:
        $r = $self->{<H::dtest|output>};

  @Method:
    @@Name: startNewTest
    @@enDesc:
      Starts a new test.
    @@Param:
      @@@Name: uri
      @@@Type: DISString
      @@@enDesc:
        A URI that identifies the test.
    @@Return:
      @@@PerlDef:
        if (not $self->{<H::dtest|ok>} and defined $self->{<H::dtest|uri>}) {
          __DEEP{
            $self-><M::DTManager.notOK>;
          }__;
        }
        $self->{<H::dtest|currentNumber>}++;
        $self->{<H::dtest|uri>} = $uri;
        $self->{<H::dtest|testData>} = {};
        CORE::delete $self->{<H::dtest|id>};

  @Attr:
    @@Name: uri
    @@enDesc:
      A URI that identifies the current test.
    @@Type: DISString
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          Currently no test is done.
      @@@PerlDef:
        $r = $self->{<H::dtest|uri>};

  @Attr:
    @@Name: id
    @@enDesc:
      An opaque string that identifies a subtest.
    @@Type: DISString
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          No subtest identifier.
      @@@PerlDef:
        $r = $self->{<H::dtest|id>};
    @@Set:
      @@@nullCase:
        @@@@enDesc:
          Unset subtest identifier.
      @@@PerlDef:
        $self->{<H::dtest|id>} = $given;

  @Method:
    @@Name: ok
    @@enDesc:
      Records that the test has been passed.
    @@Return:
      @@@PerlDef:
        print {$self->{<H::dtest|output>}}
                "ok " . $self->{<H::dtest|currentNumber>} . "\n";
        CORE::delete $self->{<H::dtest|uri>};

  @Method:
    @@Name: notOK
    @@enDesc:
      Records that the test has not been passed.
    @@URIParam:
    @@Return:
      @@@PerlDef:
        print {$self->{<H::dtest|output>}}
                "not ok " . $self->{<H::dtest|currentNumber>} . "\n";
        my $s = '<' .
                (defined $uri ? $uri : $self->{<H::dtest|uri>});
        if (defined $self->{<H::dtest|id>}) {
          $s .= ($s =~ /#/) ? '.' : '#';
          $s .= $self->{<H::dtest|id>};
        }
        $s .= '>';
        __CODE{printComment::
          $test => $self,
          $s => $s,
        }__;
        $self->{<H::dtest|failedNumber>}++;
        CORE::delete $self->{<H::dtest|uri>};
        CORE::delete $self->{<H::dtest|id>};

  @Method:
    @@Name: assertTrue
    @@enDesc:
      If the <P::actualValue> is not <DOM::true> then the test fails.
    @@Param:
      @@@Name: actualValue
      @@@Type: DISPerl|Any
      @@@enDesc: The actual value.
    @@URIParam:
    @@Return:
      @@@AErr:
      @@@PerlDef:
        if (not $actualValue) {
          __DEEP{
            $self-><M::DTManager.notOK> (uri => $uri);
          }__;
          my $v;
          __CODE{formatValue::
            $input => $actualValue,
            $output => $v,
          }__;
          __CODE{printComment::
            $test => $self,
            $s => {
              'non-tr'.'ue value ('.$v.') is occurred where tr'.'ue is expected'
            },
          }__;
          __EXCEPTION{ASSERTION_ERR}__;
        }

  @Method:
    @@Name: assertFalse
    @@enDesc:
      If the <P::actualValue> is not <DOM::false> then the test fails.
    @@Param:
      @@@Name: actualValue
      @@@Type: DISPerl|Any
      @@@enDesc: The actual value.
    @@Return:
      @@@AErr:
      @@@PerlDef:
        if ($actualValue) {
          __DEEP{
            $self-><M::DTManager.notOK>;
          }__;
          my $v;
          __CODE{formatValue::
            $input => $actualValue,
            $output => $v,
          }__;
          __CODE{printComment::
            $test => $self,
            $s => {
             'non-fal'.'se value ('.$v.') is occurred where fal'.'se is expected'
            },
          }__;
          __EXCEPTION{ASSERTION_ERR}__;
        }

  @Method:
    @@Name: assertNull
    @@enDesc:
      If the <P::actualValue> is not <DOM::null> then the test fails.
    @@Param:
      @@@Name: actualValue
      @@@Type: DISPerl|Any
      @@@enDesc: The actual value.
    @@Return:
      @@@AErr:
      @@@PerlDef:
        if (defined $actualValue) {
          __DEEP{
            $self-><M::DTManager.notOK>;
          }__;
          my $v;
          __CODE{formatValue::
            $input => $actualValue,
            $output => $v,
          }__;
          __CODE{printComment::
            $test => $self,
            $s => {
              'non-nu'.'ll value ('.$v.') is occurred where nu'.'ll is expected'
            },
          }__;
          __EXCEPTION{ASSERTION_ERR}__;
        }

  @Method:
    @@Name: assertNotNull
    @@enDesc:
      If the <P::actualValue> is <DOM::null> then the test fails.
    @@Param:
      @@@Name: actualValue
      @@@Type: DISPerl|Any
      @@@enDesc: The actual value.
    @@Return:
      @@@AErr:
      @@@PerlDef:
        if (not defined $actualValue) {
          __DEEP{
            $self-><M::DTManager.notOK>;
          }__;
          __CODE{printComment::
            $test => $self,
            $s => {
              'nu'.'ll value is occurred where a non-nu'.'ll value is expected'
            },
          }__;
          __EXCEPTION{ASSERTION_ERR}__;
        }

  @Method:
    @@Name: assertString
    @@enDesc:
      If the <P::actualValue> is not equal to the <P::expectedValue>
      as a string, then fails.
    @@NamedParam:
      @@@Name: actualValue
      @@@Type: DISPerl|StringValue
      @@@enDesc: The actual value.
    @@NamedParam:
      @@@Name: expectedValue
      @@@Type: DISPerl|StringValue
      @@@enDesc: The expected value.
    @@Return:
      @@@AErr:
      @@@PerlDef:
        if (not defined $actualValue) {
          __DEEP{
            $self-><M::DTManager.notOK>;
          }__;
          __CODE{printComment::
            $test => $self,
            $s => {
              'null value is occurred where a string value is expected'
            },
          }__;
          __EXCEPTION{ASSERTION_ERR}__;
        } elsif ($actualValue ne $expectedValue) {
          __DEEP{
            $self-><M::DTManager.notOK>;
          }__;
          my $aval;
          my $xval;
          __CODE{formatValue::
            $input => $actualValue,
            $output => $aval,
          }__;
          __CODE{formatValue::
            $input => $expectedValue,
            $output => $xval,
          }__;
          __CODE{printComment::
            $test => $self,
            $s => {
              'Got ' . $aval . ' where ' . $xval . ' is expected'
            },
          }__;
        }

  @Method:
    @@Name: assertEquals
    @@enDesc:
      If two values are not equal (i.e. if <Perl::<P::value1> eq <P::value2>>
      is not <DOM::true>), then fails.
    @@Param:
      @@@Name: value1
      @@@Type: DISPerl|Any
      @@@enDesc: A value.
    @@Param:
      @@@Name: value2
      @@@Type: DISPerl|Any
      @@@enDesc: Another value.
    @@Return:
      @@@AErr:
      @@@PerlDef:
        if (not defined $value1 and not defined $value2) {
          ## ok
        } elsif (defined $value1 and defined $value2 and $value1 eq $value2) {
          ## ok
        } else {
          __DEEP{
            $self-><M::DTManager.notOK>;
          }__;
          my $v1;
          my $v2;
          __CODE{formatValue::
            $input => $value1,
            $output => $v1,
          }__;
          __CODE{formatValue::
            $input => $value2,
            $output => $v2,
          }__;
          __CODE{printComment::
            $test => $self,
            $s => {
              'values ' . $v1 . ' and ' . $v2 . ' are not equal'
            },
          }__;
          __EXCEPTION{ASSERTION_ERR}__;
        }

  @Method:
    @@Name: assertNotEquals
    @@enDesc:
      If two values <EM::are> equal (i.e. if <Perl::<P::value1> eq <P::value2>>
      is not <DOM::false>), then fails.
    @@Param:
      @@@Name: value1
      @@@Type: DISPerl|Any
      @@@enDesc: A value.
    @@Param:
      @@@Name: value2
      @@@Type: DISPerl|Any
      @@@enDesc: Another value.
    @@Return:
      @@@AErr:
      @@@PerlDef:
        if (not defined $value1 and defined $value2) {
          ## ok
        } elsif (defined $value1 and not defined $value2) {
          ## ok
        } elsif (not ($value1 eq $value2)) {
          ## ok
        } else {
          __DEEP{
            $self-><M::DTManager.notOK>;
          }__;
          my $v1;
          my $v2;
          __CODE{formatValue::
            $input => $value1,
            $output => $v1,
          }__;
          __CODE{formatValue::
            $input => $value2,
            $output => $v2,
          }__;
          __CODE{printComment::
            $test => $self,
            $s => {
              'values are equal: ' . $v1
            },
          }__;
          __EXCEPTION{ASSERTION_ERR}__;
        }

  @Method:
    @@Name: assertNumEquals
    @@enDesc:
      If two values are not equal (i.e. if
      <Perl::<P::actualValue> == <P::expectedValue>>
      is not <DOM::true>), then fails.
    @@NamedParam:
      @@@Name: actualValue
      @@@Type: DISPerl|Any
      @@@enDesc:
        The value returned by the testing code.
      @@@nullCase:
        @@@@enDesc:
          A <DOM::null> value is returned by the testing code.
    @@NamedParam:
      @@@Name: expectedValue
      @@@Type: DISPerl|Any
      @@@enDesc:
        The expected value.
    @@Return:
      @@@AErr:
      @@@PerlDef:
        if (not defined $actualValue) {
          __DEEP{
            $self-><M::DTManager.notOK>;
          }__;
          __CODE{printComment::
            $test => $self,
            $s => {
              'nu'.'ll value is occurred where a non-nu'.'ll value is expected'
            },
          }__;
          __EXCEPTION{ASSERTION_ERR}__;
        } elsif ($actualValue == $expectedValue) {
          ## ok
        } else {
          __DEEP{
            $self-><M::DTManager.notOK>;
          }__;
          my $v1;
          my $v2;
          __CODE{formatValue::
            $input => $actualValue,
            $output => $v1,
          }__;
          __CODE{formatValue::
            $input => $expectedValue,
            $output => $v2,
          }__;
          __CODE{printComment::
            $test => $self,
            $s => {
              'value ' . $v1 . ' is not equal to expected value ' . $v2
            },
          }__;
          __EXCEPTION{ASSERTION_ERR}__;
        }

  @Method:
    @@Name: assertNumNotEquals
    @@enDesc:
      If two values are equal (i.e. if
      <Perl::<P::actualValue> == <P::expectedValue>>
      is <DOM::true>), then fails.
    @@NamedParam:
      @@@Name: actualValue
      @@@Type: DISPerl|Any
      @@@enDesc:
        The value returned by the testing code.
      @@@nullCase:
        @@@@enDesc:
          A <DOM::null> value is returned by the testing code.
    @@NamedParam:
      @@@Name: expectedValue
      @@@Type: DISPerl|Any
      @@@enDesc:
        The expected value.
    @@Return:
      @@@AErr:
      @@@PerlDef:
        if (not defined $actualValue) {
          __DEEP{
            $self-><M::DTManager.notOK>;
          }__;
          __CODE{printComment::
            $test => $self,
            $s => {
              'nu'.'ll value is occurred where a non-nu'.'ll value is expected'
            },
          }__;
          __EXCEPTION{ASSERTION_ERR}__;
        } elsif ($actualValue == $expectedValue) {
          __DEEP{
            $self-><M::DTManager.notOK>;
          }__;
          my $v1;
          my $v2;
          __CODE{formatValue::
            $input => $actualValue,
            $output => $v1,
          }__;
          __CODE{formatValue::
            $input => $expectedValue,
            $output => $v2,
          }__;
          __CODE{printComment::
            $test => $self,
            $s => {
              'value ' . $v1 . ' is equal to value ' .
              $v2 . ' (they must be different)'
            },
          }__;
          __EXCEPTION{ASSERTION_ERR}__;
        }

  @Method:
    @@Name: assertException
    @@enDesc:
      If an exception is not thrown, then fails.

        {NOTE:: If an exception other than one being test
                is thrown in <P::code>, then it will be rethrown.
        }
    @@NamedParam:
      @@@Name: code
      @@@Type: DISPerl|CODE
      @@@enDesc:
        A code reference to be executed.  When executed, the <P::code>
        would receive an argument: <VAR::$test>, the test manager object.
    @@NamedParam:
      @@@Name: exceptionSubtype
      @@@Type: DISString
      @@@enDesc:
        The subtype of the exception that is expected to be thrown
        within <P::code>.
      @@@nullCase:
        @@@@enDesc:
          Whether any exception with a particular subcode is 
          thrown or not is not tested.
    @@Return:
      @@@AErr:
      @@@PerlDef:
        my $passed;
        try {
          $code->($self);
        } catch <IF::dx|Exception||ManakaiDOM|Perl> with {
          my $err = shift;
          my $err_subtype = $err-><AG::dx|Exception||ManakaiDOM|Perl.subtype>;
          if (defined $err_subtype and defined $exceptionSubtype and
              $err_subtype eq $exceptionSubtype) {
            $passed = true;
          } else {
            $err-><M::ecore|Error||ManakaiDOM|Perl.throw>;
          }
        };
        if (not $passed and defined $exceptionSubtype) {
          __DEEP{
            $self-><M::DTManager.notOK>;
          }__;
          __CODE{printComment::
            $test => $self,
            $s => {
              'Exception of subtype <' . $exceptionSubtype .
              '> is expected but not thrown'
            },
          }__;
          __EXCEPTION{ASSERTION_ERR}__;
        }

  @Method:
    @@Name: assertISA
    @@enDesc:
      Unless an object <EM::is-a> package, it fails.
    @@Param:
      @@@Name: object
      @@@Type: DISPerl|Any
      @@@enDesc:
        The object returned by the testing code.
      @@@nullCase:
        @@@@enDesc:
          A <DOM::null> value is returned by the testing code.
    @@Param:
      @@@Name: package
      @@@Type: DISPerl|String
      @@@enDesc:
        The expected package name.
    @@Return:
      @@@AErr:
      @@@PerlDef:
        if (not defined $object) {
          __DEEP{
            $self-><M::DTManager.notOK>;
          }__;
          __CODE{printComment::
            $test => $self,
            $s => {
              'nu'.'ll value is occurred where a non-nu'.'ll value is expected'
            },
          }__;
          __EXCEPTION{ASSERTION_ERR}__;
        } elsif (UNIVERSAL::isa ($object, $package)) {
          # ok
        } else {
          __DEEP{
            $self-><M::DTManager.notOK>;
          }__;
          my $v1;
          my $v2;
          __CODE{formatValue::
            $input => $object,
            $output => $v1,
          }__;
          __CODE{formatValue::
            $input => $package,
            $output => $v2,
          }__;
          __CODE{printComment::
            $test => $self,
            $s => {
              'object ' . $v1 . ' must be ' .
              'an instance of package ' . $v2
            },
          }__;
          __EXCEPTION{ASSERTION_ERR}__;
        }

  @Method:
    @@Name: assertNever
    @@enDesc:
      Always the test fails.
    @@Return:
      @@@AErr:
      @@@PerlDef:
        __DEEP{
          $self-><M::DTManager.notOK>;
        }__;
        __CODE{printComment::
          $test => $self,
          $s => {
            'A code that should have never been reached is executed'
          },
        }__;
        __EXCEPTION{ASSERTION_ERR}__;

  @Method:
    @@Name: assertDOMTreeEquals
    @@enDesc:
      The test fails if the actual DOM subtree does not match
      to expected tree structure.
    @@NamedParam:
      @@@Name: expectedHash
      @@@Type: DISPerl|HASH||ManakaiDOM|all
      @@@enDesc:
        A Perl hash representation of TDT tree.
    @@NamedParam:
      @@@Name: actualValue
      @@@Type: Node
      @@@enDesc:
        The root node of the subtree compared with <P::expectedHash>.
    @@NamedParam:
      @@@Name: nodePathString
      @@@Type: DOMString
      @@@enDesc:
        A semi human readable string that describes the position
        of the context where <P::actualValue> appeared.  It might
        be used to report an error.
      @@@nullCase:
        @@@@enDesc: No context information available.
    @@Return:
      @@@AErr:
      @@@PerlDef:
        if (defined $nodePathString) {
          $nodePathString .= '/';
        } else {
          $nodePathString = '';
        }

        if (not defined $actualValue) {
          __DEEP{
            $self-><M::DTManager.notOK>;
          }__;
          __CODE{printComment::
            $test => $self,
            $s => {
              $nodePathString.': '.
              'nu'.'ll value is occurred where a non-nu'.'ll value is expected'
            },
          }__;
          __EXCEPTION{ASSERTION_ERR}__;
        } elsif (not ref $actualValue) {
          __DEEP{
            $self-><M::DTManager.notOK>;
          }__;
          __CODE{printComment::
            $test => $self,
            $s => {
              $nodePathString.': '.
              'not a blessed reference (|'.$actualValue.'| (|'.
              (ref $actualValue).'|)) where node is expected'
            },
          }__;
          __EXCEPTION{ASSERTION_ERR}__;
        }

        if ($actualValue->can ('node_name')) {
          my $nt = $actualValue->can ('node_type') ? $actualValue->node_type : 0;
          if ($nt == <C::Node.ELEMENT_NODE>) {
            $nodePathString .= $actualValue->node_name;
          } elsif ($nt == <C::Node.ATTRIBUTE_NODE>) {
            $nodePathString .= '@' . $actualValue->node_name;
          } else {
            $nodePathString .= ({
              <C::Node.DOCUMENT_TYPE_NODE> => 'doctype',
              <C::Node.PROCESSING_INSTRUCTION_NODE> => 'pi',
              <C::Node.ELEMENT_TYPE_DEFINITION_NODE> => 'element-type-def',
              <C::Node.ATTRIBUTE_DEFINITION_NODE> => 'attr-def',
            }->{$nt} or $nt) . ' (' . $actualValue->node_name . ')';
          }
        } else {
          $nodePathString .= 'object ('.(ref $actualValue).')';
        }
        
        for my $attr (keys %{$expectedHash}) {
          if ($attr eq 'node_type') {
            my $ant = $actualValue->node_type;
            if ($ant != {
              'document' => <C::Node.DOCUMENT_NODE>,
              'document-fragment' => <C::Node.DOCUMENT_FRAGMENT_NODE>,
              'element' => <C::Node.ELEMENT_NODE>,
              'attribute' => <C::Node.ATTRIBUTE_NODE>,
 ## TODO: Trun this line enable after namespace node is implemented
 #             'namespace' => C::Node.NAMESPACE_NODE>,
              'text' => <C::Node.TEXT_NODE>,
              'cdata-section' => <C::Node.CDATA_SECTION_NODE>,
              'comment' => <C::Node.COMMENT_NODE>,
              'pi' => <C::Node.PROCESSING_INSTRUCTION_NODE>,
              'document-type' => <C::Node.DOCUMENT_TYPE_NODE>,
              'general-entity' => <C::Node.ENTITY_NODE>,
              'general-entity-reference' => <C::Node.ENTITY_REFERENCE_NODE>,
              'notation' => <C::Node.NOTATION_NODE>,
              'element-type-definition' => <C::Node.ELEMENT_TYPE_DEFINITION_NODE>,
              'attribute-definition' => <C::Node.ATTRIBUTE_DEFINITION_NODE>,
            }->{$expectedHash->{$attr}}) {
              __DEEP{
                $self-><M::DTManager.notOK>;
              }__;
              __CODE{printComment::
                $test => $self,
                $s => {
                  $nodePathString.': Its node type is '.$ant.' ('.
                  $expectedHash->{$attr}.' is expected'
                },
              }__;
              __EXCEPTION{ASSERTION_ERR}__;
            }
          } elsif ($attr eq 'child_nodes') {
            my $acld = $actualValue->child_nodes;
            my $xcld = $expectedHash->{$attr};
            if (@$acld != @$xcld) {
              __DEEP{
                $self-><M::DTManager.notOK>;
              }__;
              __CODE{printComment::
                $test => $self,
                $s => {
                  $nodePathString.': It has '.@$acld.' child nodes ('.@$xcld.
                  ' expected)'
                },
              }__;
              __EXCEPTION{ASSERTION_ERR}__;
            }
            for (0..$#{$expectedHash->{$attr}}) {
              __DEEP{
                $self-><M::DTManager.assertDOMTreeEquals>
                         (actual_value => $acld->[$_],
                          expected_hash => $xcld->[$_],
                          node_path_string => $nodePathString);
              }__;
            }

          } elsif ($attr eq 'attributes') {
            unless ($actualValue->can ($attr)) {
              __DEEP{
                $self-><M::DTManager.notOK>;
              }__;
              __CODE{printComment::
                $test => $self,
                $s => {
                  $nodePathString.': Object (type |'.(ref $actualValue).
                  '|) does not have attribute |'.$attr.'|'
                },
              }__;
              __EXCEPTION{ASSERTION_ERR}__;
            }
            my $attrs = $actualValue->$attr;
            my @akeys = sort {$a cmp $b} keys %$attrs;
            if (@akeys != @{$expectedHash->{$attr}}) {
              __DEEP{
                $self-><M::DTManager.notOK>;
              }__;
              __CODE{printComment::
                $test => $self,
                $s => {
                  $nodePathString.': It has '.@akeys.
                  ' child nodes ('.@{$expectedHash->{$attr}}.' expected)'
                },
              }__;
              __EXCEPTION{ASSERTION_ERR}__;
            }
            for my $xitem (@{$expectedHash->{$attr}}) {
              __DEEP{
                if ($xitem->{local_name}) {
                  $self-><M::DTManager.assertDOMTreeEquals>
                         (actual_value =>
                            $attrs->get_named_item_ns
                                      ($xitem->{namespace_uri}
                                         ? $xitem->{namespace_uri}->{value}
                                         : null,
                                       $xitem->{local_name}->{value}),
                          expected_hash => $xitem,
                          node_path_string => $nodePathString);
                } elsif ($xitem->{node_name}) {
                  $self-><M::DTManager.assertDOMTreeEquals>
                         (actual_value => $attrs->{$xitem->{node_name}->{value}},
                          expected_hash => $xitem,
                          node_path_string => $nodePathString);
                }
              }__;              
            }

          } elsif ($attr eq 'element_types' or
                   $attr eq 'attribute_definitions') {
            unless ($actualValue->can ($attr)) {
              __DEEP{
                $self-><M::DTManager.notOK>;
              }__;
              __CODE{printComment::
                $test => $self,
                $s => {
                  $nodePathString.': Object (type |'.(ref $actualValue).
                  '|) does not have attribute |'.$attr.'|'
                },
              }__;
              __EXCEPTION{ASSERTION_ERR}__;
            }
            my $ets = $actualValue->$attr;
            my @akeys = sort {$a cmp $b} keys %$ets;
            my @xkeys = sort {$a cmp $b}
                        map {$_->{node_name}->{value}} @{$expectedHash->{$attr}};
            if (@akeys != @xkeys) {
              __DEEP{
                $self-><M::DTManager.notOK>;
              }__;
              __CODE{printComment::
                $test => $self,
                $s => {
                  $nodePathString.': It has '.@akeys.' child nodes ('.@xkeys.
                  ' expected)'
                },
              }__;
              __EXCEPTION{ASSERTION_ERR}__;
            }
            for my $xitem (@{$expectedHash->{$attr}}) {
              __DEEP{
                $self-><M::DTManager.assertDOMTreeEquals>
                         (actual_value => $ets->{$xitem->{node_name}->{value}},
                          expected_hash => $xitem,
                          node_path_string => $nodePathString);
              }__;              
            }

          } elsif ($attr eq 'general_entities') {
            ## TODO: Implement

          } elsif ($attr eq 'notations') {
            ## TODO: Implement

          } elsif ($attr eq 'namespaces') {
            ## TODO: Implement

          } else {
            my $aval;
            my $amtd = $actualValue->can ($attr);
            unless ($amtd) {
              __DEEP{
                $self-><M::DTManager.notOK>;
              }__;
              __CODE{printComment::
                $test => $self,
                $s => {
                  $nodePathString.': Object (type |'.(ref $actualValue).
                  '|) does not have attribute |'.$attr.'|'
                },
              }__;
              __EXCEPTION{ASSERTION_ERR}__;
            }

            __DEEP{
              $aval = $actualValue->$attr;
            }__;

            my $xval = $expectedHash->{$attr};

            __CODE{assertTypedValueEquals::
              $self => $self,
              $nodePathString => $nodePathString,
              $attr => $attr,
              $aval => $aval,
              $xval => $xval,
              $actualValue => $actualValue,
            }__;
          }
        }

  @Method:
    @@Name: assertErrorEquals
    @@enDesc:
      The test fails if the actual error object does not match
      to expected tree structure.
    @@NamedParam:
      @@@Name: expectedHash
      @@@Type: DISPerl|HASH||ManakaiDOM|all
      @@@enDesc:
        A Perl hash representation of TDT Error Description tree.
    @@NamedParam:
      @@@Name: actualValue
      @@@Type: ecore|ErrorInterface||ManakaiDOM|Perl
      @@@enDesc:
        The object to compare with <P::expectedHash>.
    @@NamedParam:
      @@@Name: nodePathString
      @@@Type: DOMString
      @@@enDesc:
        A semi human readable string that describes the position
        of the context where <P::actualValue> appeared.  It might
        be used to report an error.
      @@@nullCase:
        @@@@enDesc: No context information available.
    @@Return:
      @@@AErr:
      @@@PerlDef:
        if (defined $nodePathString) {
          $nodePathString .= '/';
        } else {
          $nodePathString = '';
        }

        if (not defined $actualValue) {
          __DEEP{
            $self-><M::DTManager.notOK>;
          }__;
          __CODE{printComment::
            $test => $self,
            $s => {
              $nodePathString.': '.
              'nu'.'ll value is occurred where a non-nu'.'ll value is expected'
            },
          }__;
          __EXCEPTION{ASSERTION_ERR}__;
        } elsif (not ref $actualValue) {
          __DEEP{
            $self-><M::DTManager.notOK>;
          }__;
          __CODE{printComment::
            $test => $self,
            $s => {
              $nodePathString.': '.
              'not a blessed reference (|'.$actualValue.'| (|'.
              (ref $actualValue).'|)) where an Error is expected'
            },
          }__;
          __EXCEPTION{ASSERTION_ERR}__;
        }

        $nodePathString .= 'error ('.(ref $actualValue);
        if ($actualValue->can ('type')) {
          $nodePathString .= ', ' . $actualValue->type;
          if ($actualValue->can ('subtype')) {
            $nodePathString .= ', ' . $actualValue->subtype;
          }
        }
        $nodePathString .= ')';
        
        for my $attr (keys %{$expectedHash}) {
          if ($attr eq '_type') {
            #
          } else {
            my $aval;
            my $amtd = $actualValue->can ($attr);
            unless ($amtd) {
              __DEEP{
                $self-><M::DTManager.notOK>;
              }__;
              __CODE{printComment::
                $test => $self,
                $s => {
                  $nodePathString.': Object (type |'.(ref $actualValue).
                  '|) does not have attribute |'.$attr.'|'
                },
              }__;
              __EXCEPTION{ASSERTION_ERR}__;
            }

            __DEEP{
              $aval = $actualValue->$attr;
            }__;

            my $xval = $expectedHash->{$attr};

            __CODE{assertTypedValueEquals::
              $self => $self,
              $nodePathString => $nodePathString,
              $attr => $attr,
              $aval => $aval,
              $xval => $xval,
              $actualValue => $actualValue,
            }__;
          }
        }

  @Method:
    @@Name: assertDOMLocatorEquals
    @@enDesc:
      The test fails if the actual locator object does not match
      to expected structure.
    @@NamedParam:
      @@@Name: expectedHash
      @@@Type: DISPerl|HASH||ManakaiDOM|all
      @@@enDesc:
        A Perl hash representation of TDT's locator value.
    @@NamedParam:
      @@@Name: actualValue
      @@@Type: ecore|ErrorInterface||ManakaiDOM|Perl
      @@@enDesc:
        The object to compare with <P::expectedHash>.
    @@NamedParam:
      @@@Name: nodePathString
      @@@Type: DOMString
      @@@enDesc:
        A semi human readable string that describes the position
        of the context where <P::actualValue> appeared.  It might
        be used to report an error.
      @@@nullCase:
        @@@@enDesc: No context information available.
    @@Return:
      @@@AErr:
      @@@PerlDef:
        if (defined $nodePathString) {
          $nodePathString .= '/';
        } else {
          $nodePathString = '';
        }

        if (not defined $actualValue) {
          __DEEP{
            $self-><M::DTManager.notOK>;
          }__;
          __CODE{printComment::
            $test => $self,
            $s => {
              $nodePathString.': '.
              'nu'.'ll value is occurred where a non-nu'.'ll value is expected'
            },
          }__;
          __EXCEPTION{ASSERTION_ERR}__;
        } elsif (not ref $actualValue) {
          __DEEP{
            $self-><M::DTManager.notOK>;
          }__;
          __CODE{printComment::
            $test => $self,
            $s => {
              $nodePathString.': '.
              'not a blessed reference (|'.$actualValue.'| (|'.
              (ref $actualValue).'|)) where a |DOMLocator| is expected'
            },
          }__;
          __EXCEPTION{ASSERTION_ERR}__;
        }

        $nodePathString .= 'locator ('.(ref $actualValue).')';
        
        for my $attr (keys %{$expectedHash}) {
          if ($attr eq 'type') {
            #
          } elsif ($attr eq '_line_column') {
            for my $attr (qw/line_number column_number/) {
              unless ($actualValue->can ($attr)) {
                __DEEP{
                  $self-><M::DTManager.notOK>;
                }__;
                __CODE{printComment::
                  $test => $self,
                  $s => {
                    $nodePathString.': Object (type |'.(ref $actualValue).
                    '|) does not have attribute |'.$attr.'|'
                  },
                }__;
                __EXCEPTION{ASSERTION_ERR}__;
              }
              if ($actualValue->$attr == -1) {
                __DEEP{
                  $self-><M::DTManager.notOK>;
                }__;
                __CODE{printComment::
                  $test => $self,
                  $s => {
                    $nodePathString.': |'.$attr.'| value is not available'
                  },
                }__;
                __EXCEPTION{ASSERTION_ERR}__;
              }
            } # ->line_number & ->column_number check
            
            my $aline = $actualValue->line_number;
            my $acol = $actualValue->column_number;
            my $xval = $expectedHash->{_line_column};
            unless (
              $xval->{l1} <= $aline and $aline <= $xval->{l2} and
              (
               ($xval->{l1} == $aline and $xval->{l1} == $xval->{l2} and
                $xval->{c1} <= $acol and $acol <= $xval->{c2}) or
               ($xval->{l1} == $aline and $xval->{l1} != $xval->{l2} and
                $xval->{c1} <= $acol) or
               ($xval->{l2} == $aline and $xval->{l1} != $xval->{l2} and
                $acol <= $xval->{c2}) or
               ($xval->{l1} < $aline and $aline < $xval->{l2})
              )
            ) {
              __DEEP{
                $self-><M::DTManager.notOK>;
              }__;
              __CODE{printComment::
                $test => $self,
                $s => {
                  $nodePathString.': Line and column ('.$aline.', '.
                  $acol.') is not in the expected'.
                  ' range ('.$xval->{l1}.', '.$xval->{c1}.')..('.
                  $xval->{l2}.', '.$xval->{c2}.')'
                },
              }__;
              __EXCEPTION{ASSERTION_ERR}__;
            }
          } else {
            my $aval;
            my $amtd = $actualValue->can ($attr);
            unless ($amtd) {
              __DEEP{
                $self-><M::DTManager.notOK>;
              }__;
              __CODE{printComment::
                $test => $self,
                $s => {
                  $nodePathString.': Object (type |'.(ref $actualValue).
                  '|) does not have attribute |'.$attr.'|'
                },
              }__;
              __EXCEPTION{ASSERTION_ERR}__;
            }

            __DEEP{
              $aval = $actualValue->$attr;
            }__;

            my $xval = $expectedHash->{$attr};

            __CODE{assertTypedValueEquals::
              $self => $self,
              $nodePathString => $nodePathString,
              $attr => $attr,
              $aval => $aval,
              $xval => $xval,
              $actualValue => $actualValue,
            }__;
          }
        }

  @ResourceDef:
    @@QName: assertTypedValueEquals
    @@ForCheck: ManakaiDOM|ForClass
    @@rdf:type: DISPerl|BlockCode
    @@enDesc:
      $self, $nodePathString, $attr, $aval, $xval,
      $actualValue
    @@PerlDef:
      if ($xval->{type} eq 'nu'.'ll') {
        if (defined $aval) {
          __DEEP{
            $self-><M::DTManager.notOK>;
          }__;
          __CODE{printComment::
            $test => $self,
            $s => {
              $nodePathString.'->'.$attr.': Value is not nu'.'ll (|'.
              $aval.'| (type |'.(ref $aval).'|)'
            },
          }__;
          __EXCEPTION{ASSERTION_ERR}__;
        }
      } elsif ($xval->{type} eq 'boolean') {
        if (($aval and not $xval->{value}) or
            (not $aval and $xval->{value})) {
          __DEEP{
            $self-><M::DTManager.notOK>;
          }__;
          __CODE{printComment::
            $test => $self,
            $s => {
              $nodePathString.'->'.$attr.': Value is not boolean '.
              $xval->{value}
            },
          }__;
          __EXCEPTION{ASSERTION_ERR}__;
        }
      } else {
        unless (defined $aval) {
          __DEEP{
            $self-><M::DTManager.notOK>;
          }__;
          __CODE{printComment::
            $test => $self,
            $s => {
              $nodePathString.'->'.$attr.': Value is nu'.'ll (a '.
              $xval->{type}.' with value |'.$xval->{value}.'| is expected)'
            },
          }__;
          __EXCEPTION{ASSERTION_ERR}__;
        }
        if ($xval->{type} eq 'number') {
          unless ($aval == $xval->{value}) {
            __DEEP{
              $self-><M::DTManager.notOK>;
            }__;
            __CODE{printComment::
              $test => $self,
              $s => {
                $nodePathString.'->'.$attr.': Value is |'.$aval.'| (|'.
                $xval->{value}.'| is expected)'
              },
            }__;
            __EXCEPTION{ASSERTION_ERR}__;
          }
        } elsif ($xval->{type} eq 'const') {
          unless ($actualValue->can ($xval->{value})) {
            __DEEP{
              $self-><M::DTManager.notOK>;
            }__;
            __CODE{printComment::
              $test => $self,
              $s => {
                $nodePathString.': Object (type |'.(ref $actualValue).
                '|) does not have constant |'.$xval->{value}.'|'
              },
            }__;
            __EXCEPTION{ASSERTION_ERR}__;
          }
          my $__m = $xval->{value};
          unless ($aval == $actualValue->$__m) {
            __DEEP{
              $self-><M::DTManager.notOK>;
            }__;
            __CODE{printComment::
              $test => $self,
              $s => {
                $nodePathString.'->'.$attr.': Value is |'.$aval.'| (|'.
                $xval->{value}.'|, i.e. |'.$actualValue->$__m.
                '|, is expected)'
              },
            }__;
            __EXCEPTION{ASSERTION_ERR}__;
          }
        } elsif ($xval->{type} eq 'string') {
          unless ($aval eq $xval->{value}) {
            __DEEP{
              $self-><M::DTManager.notOK>;
            }__;
            __CODE{printComment::
              $test => $self,
              $s => {
                $nodePathString.'->'.$attr.': Value is |'.$aval.'|, type |'.
                (ref $aval).'| (|'.
                $xval->{value}.'| is expected)'
              },
            }__;
            __EXCEPTION{ASSERTION_ERR}__;
          }
        } elsif ($xval->{type} eq 'DOMStringList') {
          unless (UNIVERSAL::isa ($aval,
                                  <IFName::DOMCore:DOMStringList>)) {
            __DEEP{
              $self-><M::DTManager.notOK>;
            }__;
            __CODE{printComment::
              $test => $self,
              $s => {
                $nodePathString.'->'.$attr.': Value is |'.$aval.
                '|, type |'.(ref $aval).'| (|DOMStringList| |'.
                (join '|, |', @{$xval->{value}}).'|) is expected)'
              },
            }__;
            __EXCEPTION{ASSERTION_ERR}__;
          }
          unless (@$aval == @{$xval->{value}}) {
            __DEEP{
              $self-><M::DTManager.notOK>;
            }__;
            __CODE{printComment::
              $test => $self,
              $s => {
                $nodePathString.'->'.$attr.': Value has '.@$aval.
               '| items (|'.@{$xval->{value}}.'| is expected)'
              },
            }__;
            __EXCEPTION{ASSERTION_ERR}__;
          }
          for my $__i (0..$#$aval) {
            unless ($aval->[$__i] eq $xval->{value}->[$__i]) {
              __DEEP{
                $self-><M::DTManager.notOK>;
              }__;
              __CODE{printComment::
                $test => $self,
                $s => {
                  $nodePathString.'->'.$attr.'->['.$__i.']: Value is |'.
                  $aval->[$__i].'|, type |'.(ref $aval).'| (|'.
                  $xval->{value}->[$__i].'| is expected)'
                },
              }__;
              __EXCEPTION{ASSERTION_ERR}__;
            }
          } # item

        } elsif ($xval->{type} eq 'TypeInfo') {
          unless (UNIVERSAL::isa ($aval, <IFName::DOMCore:TypeInfo>)) {
            __DEEP{
              $self-><M::DTManager.notOK>;
            }__;
            my $__v;
            __CODE{formatValue::
              $input => $aval,
              $output => $__v,
            }__;
            __CODE{printComment::
              $test => $self,
              $s => {
                $nodePathString.'->'.$attr.': Value is '.$__v.
                ' (|TypeInfo| |'.
                (join '|, |', @{$xval->{value}}).'|) is expected)'
              },
            }__;
            __EXCEPTION{ASSERTION_ERR}__;
          }
          for (['type_namespace', 0], ['type_name', 1]) {
            my $__m = $_->[0];
            my $__av = $aval->$__m;
            unless ((defined $__av and defined $xval->{value}->[$_->[1]] and
                     $__av eq $xval->{value}->[$_->[1]]) or
                    (not defined $__av and
                     not defined $xval->{value}->[$_->[1]])) {
              __DEEP{
                $self-><M::DTManager.notOK>;
              }__;
              my $__v;
              __CODE{formatValue::
                $input => $__av,
                $output => $__v,
              }__;
              my $__xv;
              __CODE{formatValue::
                $input => {$xval->{value}->[$_->[1]]},
                $output => $__xv,
              }__;
              __CODE{printComment::
                $test => $self,
                $s => {
                  $nodePathString.'->'.$attr.'->'.$__m.': Value is '.$__v.
                  ' ('.$__xv.' is expected)'
                },
              }__;
              __EXCEPTION{ASSERTION_ERR}__;
            }
          } # item
        } elsif ($xval->{type} eq 'DOMLocator') {
          __DEEP{
            $self-><M::DTManager.assertDOMLocatorEquals>
                         (actual_value => $aval,
                          expected_hash => $xval,
                          node_path_string => $nodePathString);
          }__;
        } else {
          die "Value type |".$xval->{type}."| is not supported";
        } # aval->{type}
      } # aval->{type} undef

  @Method:
    @@Operator:
      @@@@: DESTROY
      @@@ContentType: DISPerl|Perl
    @@Return:
      @@@PerlDef:
        if (not $self->{<H::dtest|ok>} and defined $self->{<H::dtest|uri>}) {
          __DEEP{
            $self-><M::DTManager.notOK>;
          }__;
        }

        if ($self->{<H::dtest|currentNumber>} < $self->{<H::dtest|number>}) {
          __CODE{printComment::
            $test => $self,
            $s => {
              sprintf "Looks like you planned %d tests but only ran %d.",
                      $self->{<H::dtest|number>},
                      $self->{<H::dtest|currentNumber>}
            },
          }__;
        } elsif ($self->{<H::dtest|number>} <
                 $self->{<H::dtest|currentNumber>}) {
          __CODE{printComment::
            $test => $self,
            $s => {
              sprintf "Looks like you planned %d tests but ran %d extra.",
                      $self->{<H::dtest|number>},
                      $self->{<H::dtest|currentNumber>}
                        - $self->{<H::dtest|number>}
            },
          }__;
        }
        if ($self->{<H::dtest|failedNumber>}) {
          __CODE{printComment::
           $test => $self,
           $s => {
              sprintf "Looks like you failed %d tests of %d.",
                      $self->{<H::dtest|failedNumber>},
                      $self->{<H::dtest|number>}
            },
          }__;
        } else {
          __CODE{printComment::
           $test => $self,
           $s => {
              sprintf "Looks like you passed %d tests.",
                      $self->{<H::dtest|number>}
            },
          }__;
        }

  @Method:
    @@Name: failureComment
    @@enDesc:
      Prints a comment that describes the failure.
    @@Param:
      @@@Name: s
      @@@Type: DOMString
      @@@enDesc:
        A semi-human-readable text that describes the situation.
    @@Return:
      @@@PerlDef:
        __CODE{printComment::
          $s => $s,
          $test => $self,
        }__;

  @ResourceDef:
    @@ForCheck: ManakaiDOM|ForClass
    @@QName: printComment
    @@rdf:type: DISPerl|BlockCode
    @@enDesc:
      Prints a comment to <Q::dtest|output>.
    @@PerlDef:
      my $__s = $s;
      $__s =~ s/\n/\n## /g;
      $__s =~ s/\n## $/\n/s;
      $__s .= "\n" unless $__s =~ /\n$/;
      $__s = q<## > . $__s;
      print {$test->{<H::dtest|output>}} $__s;

  @ResourceDef:
    @@ForCheck: ManakaiDOM|ForClass
    @@QName: formatValue
    @@rdf:type: DISPerl|BlockCode
    @@enDesc:
      Formats a value for error messages.
    @@PerlDef:
      $output = $input;
      my $__ref = ref $output;
      if (not defined $output) {
        $output = '(undef)';
      } elsif ($output eq '') {
        $output = '(empty)';
      } else {
        $output =~ s{([\x00-\x09\x0B-\x1F\x7F-\xA0])}
                    {sprintf '\\x{%04X}', ord $1}ge;
        $output =~ s/\x0A/\x{000A}\n/g;
        $output = "'" . $output . "'";
      }
      $output .= ' ['.$__ref.']' if length $__ref;

  @Method:
    @@Name: setTestData
    @@enDesc:
      Associates a data with the key on the test manager.

        {NOTE:: Associations of keys and data are removed when
                <M::DTManager.startNewTest> method is called.
        }

        {NOTE:: It is useful to register a value whose destructor
                might invoke part of test code which should usually
                not be executed on that timing in successful cases
                but may be executed in failure cases so that the failure
                report is made unappropriate.  (See user data handler
                tests in the implementation of DOM Level 3 Core for example.)
        }
   @@Param:
     @@@Name: key
     @@@Type: DISString
     @@@enDesc:
       The key.  If there is already data for the <P::key>, then
       its data is updated.
   @@Param:
     @@@Name: data
     @@@Type: DISPerl|Any
     @@@enDesc:
       The data.
     @@@nullCase:
       @@@@enDesc: The association is removed.
   @@Return:
     @@@PerlDef:
       $self->{<H::dtest|testData>}->{$key} = $data;
##DTManager

PropDef:
  @QName: dtest|ok
  @dtest:key: ok

PropDef:
  @QName: dtest|testData
  @enDesc:
    Test data.
  @dtest:key: d

ElementTypeBinding:
  @Name: NamedParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:MethodParameter
    @@DISPerl:isNamedParameter:1

ElementTypeBinding:
  @Name: URIParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:MethodParameter
    @@DISPerl:isNamedParameter:1
    @@Name: uri
    @@Type: DISString
    @@Description:
      @@@lang:en
      @@@@:
        A URI that identifies the subtest.
    @@ResourceDef:
      @@@rdf:type: ManakaiDOM|InCase
      @@@Value:
        @@@@is-null:1
      @@@Description:
        @@@@lang:en
        @@@@@:
          The subtest has no URI.

ElementTypeBinding:
  @Name: AErr
  @ElementType:
    dx:raises
  @ShadowContent:
    @@@: ASSERTION_ERR
    @@Description:
      @@@lang:en
      @@@@:
        If assetion fails.

ResourceDef:
  @QName: DISString
  @AliasFor: DOMMain|DOMString
  @For: ManakaiDOM|ManakaiDOM

ResourceDef:
  @QName: Node
  @AliasFor: Tree|Node
  @For: ManakaiDOM|ManakaiDOM

PropDef:
  @QName: dtest|failedNumber
  @enDesc:
    The number of current failed tests.
  @dtest:key: f

PropDef:
  @QName: dtest|output
  @enDesc:
    The file handle to which messages should be written.
  @dtest:key: o

ElementTypeBinding:
  @Name: PerlDef
  @ElementType:
    dis:Def
  @ShadowContent:
    @@ContentType:
      lang:Perl
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: InCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:InCase

ElementTypeBinding:
  @Name: nullCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:InCase
    @@Value:
      @@@is-null:1
      @@@ContentType: DISCore|String

ElementTypeBinding:
  @Name: TrueCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:InCase
    @@Value:
      @@@@: 1
      @@@ContentType: DISCore|Boolean
    @@Type: idl|boolean||ManakaiDOM|all

ElementTypeBinding:
  @Name: FalseCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:InCase
    @@Value:
      @@@@: 0
      @@@ContentType: DISCore|Boolean
    @@Type: idl|boolean||ManakaiDOM|all

IFClsDef:
  @IFQName: DTException
  @ClsQName: ManakaiDTException

  @rdf:type:
    @@@: dx|Interface
    @@ForCheck: ManakaiDOM|ForIF

  @rdf:type:
    @@@: dx|Class
    @@ForCheck: ManakaiDOM|ForClass

  @ClsISA: dx|Exception||ManakaiDOM|Perl
  @dx:implementedBy: ||ManakaiDOM|ManakaiDOMLatest||ManakaiDOM|ForClass

  @ResourceDef:
    @@QName: DTExceptionCode
    @@ForCheck: ManakaiDOM|ForIF
    @@rdf:type: DISLang|ConstGroup

    @@enDesc:
      Exception codes for <IF::DTException>. 

    @@Type: idl|unsignedShort||ManakaiDOM|all
    @@rdfs:subClassOf: idl|unsignedShort||ManakaiDOM|all

    @@ResourceDef:
      @@@rdf:type: DISLang|Const
      @@@QName: dtest|PARSE_ERR
      @@@Value:
        @@@@@: 81
        @@@@ContentType: DISCore|Integer
      @@@enDesc:
        An attempt was made to load a TDT document and
        the processing has been stopped.

    @@ResourceDef:
      @@@QName: ASSERTION_ERR
      @@@rdf:type: DISLang|Const
      @@@Value:
        @@@@@:10001
        @@@@ContentType: DISCore|Integer
      @@@enDesc:
        An assertion failed.
##DTException


ElementTypeBinding:
  @Name: PropDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: rdf|Property
    @@For: =ManakaiDOM|all

ElementTypeBinding:
  @Name: RPropDef:
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: rdf|Property
    @@rdf:type: DISSource|Property
    @@For: =ManakaiDOM|all

ElementTypeBinding:
  @Name: SPropDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: rdf|Property
    @@rdf:type: DISSource|Property
    @@rdf:type: DISSource|ResourceProperty
    @@For: =ManakaiDOM|all

FeatureDef:
  @QName: DIS|TDT
  @FeatureVerDef:
    @@QName: DIS|TDT10
    @@Version: 1.0
    @@f:instanceOf: DIS|TDT
    @@enFN:
      The <DFN::TDT> format, version 1.0

IFClsDef:
  @IFQName: TDTParser
  @ClsQName: ManakaiTDTParser

  @Implement: ecore|MUErrorTarget||ManakaiDOM|Perl

  @DISLang:role: gls|ParserRole

  @f:implements: DIS|TDT10
  @f:provides:
    @@@: DIS|TDT10
    @@f:through: DOMCore|ManakaiDOMImplementation

  @enDesc:
    A <IF::TDTParser> object parses a TDT source document and
    returns it as an object.

    A <IF::TDTParser> object can be retrieved by 
    <M::GenericLS|GLSImplementation.createGLSParer>

  @Attr:
    @@Name: domConfig
    @@enDesc:
      The configuration of the parser.

    @@Get:
      @@@Type: DOMCore|DOMConfiguration
      @@@enDesc: The DOM configuration object.
      @@@PerlDef:
        __CODE{DOMCore|getConfigObject::
          $target => $self,
          $targetHash => $self,
          $targetType => {<IFName::TDTParser>},
          $result => $r,
        }__;

  @Method:
    @@ManakaiDOM:isForInternal:1
    @@ForCheck: ManakaiDOM|ForClass
    @@Operator: DISPerl|NewMethod
    @@enDesc:
      Creates a new instance of the object.
    @@Param:
      @@@Name: impl
      @@@Type: gls|GLSImplementation
      @@@enDesc:
        The implementation from which the parser is created.
    @@Param:
      @@@Name: features
      @@@Type: DOMString
      @@@dis:actualType: f|FeaturesString
      @@@enDesc:
        The set of features requested for the parser.
    @@Return:
      @@@Type: DOMMain|DOMObject
      @@@enDesc:
        The newly created parser.
      @@@PerlDef:
        $r = bless {
          <H::DOMCore:implementation> => $impl,
        }, $self;

  @Method:
    @@Name: parseString
    @@enDesc:
      Parses a string as TDT textual definition and converts it into
      its object representation.
    @@Param:
      @@@Name: sourceText
      @@@Type: DOMString
      @@@enDesc:
        The text to parse.
    @@Return:
      @@@Type: DISPerl|HASH
      @@@enDesc:
        An object representation of <P::sourceText>.
      @@@dx:raises:
        @@@@@: dtest|PARSE_ERR
        @@@@enDesc:
          If the TDT document contains one or more error.
      @@@PerlDef:
        $self->{char} = [];
        $self->{token} = [];
        $self->{source} = $sourceText;
        $self->{location} = {};
        __DEEP{
          $r = $self->_parse_document;
        }__;

  @Method:
    @@Name: parseTDTErrorString
    @@enDesc:
      Parses a string as TDT Error Description textual definition and
      converts it into its object representation.
    @@Param:
      @@@Name: sourceText
      @@@Type: DOMString
      @@@enDesc:
        The text to parse.
    @@Param:
      @@@Name: disDatabase
      @@@Type: DIS|DISDatabase||DIS|ForLatest
      @@@enDesc:
        An <QUOTE::dis> database used to extract definition for errors.
    @@Param:
      @@@Name: nsResolver
      @@@Type: DIS|NSResolverDIS||DIS|ForLatest
      @@@enDesc:
        An namespace resolver.
    @@Param:
      @@@Name: defaultTURI
      @@@Type: DOMString
      @@@enDesc:
        The default <QUOTE::T> URI for <Q::DISCore:TFQNames>.
      @@@nullCase:
        @@@@enDesc:
          <Q::DOMMain:any> is the default for historical reason.
    @@Param:
      @@@Name: defaultFURI
      @@@Type: DOMString
      @@@enDesc:
        The default <QUOTE::F> URI for <Q::DISCore:TFQNames>.
      @@@nullCase:
        @@@@enDesc:
          <Q::ManakaiDOM:all>.
    @@Return:
      @@@Type: DISPerl|HASH
      @@@enDesc:
        An object representation of <P::sourceText>.
      @@@dx:raises:
        @@@@@: dtest|PARSE_ERR
        @@@@enDesc:
          If the TDT document contains one or more error.
      @@@PerlDef:
        $self->{char} = [];
        $self->{token} = [];
        $self->{source} = $sourceText;
        $self->{dis_database} = $disDatabase;
        $self->{ns_resolver_dis} = $nsResolver;
        $self->{default_t} = $defaultTURI;
        $self->{default_f} = $defaultFURI;
        $self->{location} = {};
        __DEEP{
          $r = $self->_parse_tdterr;
        }__;

  @Method:
    @@Name: shiftChar
    @@ManakaiDOM:isForInternal:1
    @@ForCheck: ManakaiDOM|ForClass
    @@enDesc:
      Returns the next character.
    @@Return:
      @@@Type: idl|long||ManakaiDOM|all
      @@@enDesc:
        The code position number of the next character, if any,
        or <CODE::-2>.
      @@@PerlDef:
        if (@{$self->{char}}) {
          $r = shift @{$self->{char}};
        } else {
          my $char = substr ($self->{source}, pos ($self->{source}), 1);
          pos ($self->{source})++;

          if (length $char) {
            $r = ord $char;
          } else {
            $r = -1;
          }
        }

  @Method:
    @@ManakaiDOM:isForInternal: 1
    @@Operator: ManakaiDOM|MUErrorHandler
    @@enDesc:
      When a <IF::ecore|ErrorInterface||ManakaiDOM|Perl> is <Perl::report>ed,
      then this method is invoked.
      
      The method calls the <cfg::DOMCore|error-handler> if the error is of 
      <IF::DOMCore|DOMError>.  Otherwise, the error is re-thrown so that
      corresponding <Perl::catch> clause, if any, can catch the error.
    @@Param:
      @@@Name: err
      @@@Type: ecore|ErrorInterface||ManakaiDOM|Perl
      @@@enDesc:
        The reported error object.
    @@Return:
      @@@Type: DISPerl|Any
      @@@enDesc:
        If the <P::err> is a <IF::DOMCore|DOMError>, then the return value
        of the error handler.

           {NOTE:: If the error is thrown, the method never returns.
           }
      @@@nullCase:
        @@@@enDesc:
          No error handler.
      @@@PerlDef:
        if ($err->isa (<IFName::DOMCore|DOMError||ManakaiDOM|ManakaiDOM>)) {
          __DEEP{
            A: {
              my $cfg = $self-><AG::TDTParser.domConfig>;
              my $h = $cfg-><M::DOMCore|DOMConfiguration.getParameter>
                               ('error-handler');
              $r = $h-><M::DOMCore|DOMErrorHandler.handleError> ($err);
            } # A
          }__;
        } else {
          $err-><M::ecore|ErrorInterface||ManakaiDOM|Perl.throw>;
        }

  @DISPerl:dpgDef:
    lexmode default : initial : standalone {

      /* Name */
      $name-start-char := [U+0041..U+005A U+0061..U+007A];
      $name-char       := [U+0041..U+005A U+0061..U+007A U+0030..U+0039 '-' '_'];
      NAME : value := $name-start-char $name-char*;

      /* Block */
      LBRACE := ['{'];
      RBRACE := ['}'];

      /* Declaration */
      COLON := [':'];
      SEMICOLON := [';'];

      /* String */
      STRING : value := [U+0027] [^U+0027]* [U+0027];
      $hexdigit := [U+0030..U+0039 U+0041..U+0046 U+0061..U+0066];
      CHAR : value := ['U'] ['+'] $hexdigit $hexdigit $hexdigit $hexdigit
                                  $hexdigit? $hexdigit?;

      /* Number */
      MINUS := ['-'];
      DNUM : value := [U+0030..U+0039]+;
      XNUM : value := ['0'] ['x']
                      [U+0030..U+0039 U+0041..U+0046 U+0061..U+0066 '_']+;
      BNUM : value := ['0'] ['b'] ['0' '1' '_']+;

      /* Functional notation */
      COMMA := [','];
      LPAREN := ['('];
      RPAREN := [')'];

      /* Range */
      RANGE := ['.'] ['.'];

      /* URI */
      URI : value := ['<'] [^'<' '>' '[' ']'] [^'<' '>']* ['>'];
      QName : value := ['<'] ['['] [^'<' '>' '[' ']']* [']'] ['>'];
      TFQNames : value := ['<'] ['['] ['['] [^'<' '>' '[' ']']*
                          [']'] [']'] ['>'];
      
      /* Ignored white space */
      WSP : ignore := [U+0009..U+000D U+0020]+;

      /* Ignored comment */
      COMMENT1 : ignore := ['/'] ['/'] [^U+000A..U+000D]* [U+000A..U+000D]*;
      $comment2 := [^'/' '*'] [^'*']* ['*']+;
      COMMENT2 : ignore := ['/'] ['*'] [^'*']* ['*']+ $comment2* ['/'];

    } // lexmode default

    /*
      A TDT Document (|lang:tdt|).
    */
    rule document : standalone : recursive {
      /*
        document := node;
        node := node-type "{" *(node / attribute / empty-declaration) "}"
        node-type := 'document' / 'document-fragment' /
                     'element' /
                     'attribute' / 'namespace' /
                     'text' / 'cdata-section' /
                     'comment' /
                     'pi' /
                     'document-type' /
                     'general-entity' / 'general-entity-reference' /
                     'notation' /
                     'element-type-definition' / 'attribute-definition'
        empty-declaration := ';'

        TODO: |{ a; b }| should be allowed.
      */

      my $node : return;
      lang:Perl {
        $node = {
        };
      }

      ~ (NAME) {
        lang:Perl ($v => $token.value) {
          $node->{node_type} = $v;
        }
      }

      ~ (LBRACE) { }

      &_node ($node => $node);

      ~ (#EOF) { }
    } // document

    /*
      A TDT Error Description Document (|lang:tdterr|).

        tdterr := any-err-type-qname "{" position *(attribute / empty-statement)
                                     "}"
        any-err-type-qname := QName ;; References a |ecore:AnyErrorCode|.
        position := [QName / URI] ["(" number "," number ")"
                                   [".." "(" number "," number ")"]] ";"
    */
    rule tdterr : standalone {
      my $err : return;

      ~ (TFQNames) {
        lang:Perl ($v => $token.value) : has-error {
          my $disq = substr ($v, 3, length ($v) - 6);
          my $erruri;
          try {
            $erruri = $self->{ns_resolver_dis}
                           ->tfqnames_to_uri ($disq, $self->{default_t},
                                                     $self->{default_f});
          } catch Message::Util::Error with {
            my $err = shift;
            if ($err->can ('subtype') and
                $err->subtype eq <Q::DIS:UNDECLARED_NS_PREFIX_ERR
                                   ::SuikaWikiConfig21:ForLatest>) {
              my $location = {
                utf32_offset => pos ($self->{source}),
              };
              my $continue =
              __DOMCore:ERROR{dtest|undeclared-namespace-prefix-error::
                dtest|error-token => {$token},
                DOMCore|location => {$location},
                dtest|source-text => {\($self->{source})},
                dtest|qname => {$disq},
              }__;
              unless ($continue) {
                __EXCEPTION{dtest|PARSE_ERR::
                }__;
              }
              $erruri = $disq;
            } else {
              $err->throw;
            }
          };
          my $errres = $self->{dis_database}->get_resource ($erruri);
          $errres->is_referred (true);
          if ($errres->is_type_uri (<Q::dx|ErrorSubCode>)) {
            $err->{subtype} = {
              type => 'string',
              value => $errres->name_uri,
            };
          } elsif ($errres->is_type_uri (<Q::dx|ErrorCode>)) {
            $err->{type} = {
              type => 'string',
              value => $errres->local_name,
            };
          } elsif ($errres->is_type_uri (<Q::DOMCore|DOMErrorType>)) {
            $err->{type} = {
              type => 'string',
              value => $errres->get_property_text
                                  (<Q::DOMCore|errorType>, $errres->name_uri),
            },
          } else {
            my $location = {
              utf32_offset => pos ($self->{source}),
            };
            my $continue = __DOMCore:ERROR{dtest|bad-error-resource-error::
              dtest|error-token => {$token},
              DOMCore|location => {$location},
              dtest|source-text => {\($self->{source})},
              dtest|qname => {$disq},
              dtest|relatedURI => {$erruri},
              dtest|resource => {$errres},
            }__;
            unless ($continue) {
              __EXCEPTION{dtest|PARSE_ERR::
              }__;
            }
          }
        }
      }

      ~ (LBRACE) { }

      my $has_pos;

      ~? (QName) {
        lang:Perl ($v => $token.value) {
          my $disq = substr ($v, 2, length ($v) - 4);
          my $erruri;
          try {
            $erruri = $self->{ns_resolver_dis}->qname_to_uri ($disq);
          } catch Message::Util::Error with {
            my $err = shift;
            if ($err->can ('subtype') and
                $err->subtype eq <Q::DIS:UNDECLARED_NS_PREFIX_ERR
                                   ::SuikaWikiConfig21:ForLatest>) {
              my $location = {
                utf32_offset => pos ($self->{source}),
              };
              my $continue =
              __DOMCore:ERROR{dtest|undeclared-namespace-prefix-error::
                dtest|error-token => {$token},
                DOMCore|location => {$location},
                dtest|source-text => {\($self->{source})},
                dtest|qname => {$disq},
              }__;
              unless ($continue) {
                __EXCEPTION{dtest|PARSE_ERR::
                }__;
              }
              $erruri = $disq;
            } else {
              $err->throw;
            }
          };
          $err->{location}->{type} = 'DOMLocator';
          $err->{location}->{uri} = $erruri;
          $has_pos = true;
        }
      } (URI) {
        lang:Perl ($v => $token.vakue) {
          $err->{location}->{type} = 'DOMLocator';
          $err->{location}->{uri}
            = {type => 'string', value => substr ($v, length ($v) - 2)};
          $has_pos = true;
        }
      }

      ~? (LPAREN) {
        ~ (DNUM) {
          lang:Perl ($v => $token.value) {
            $err->{location}->{type} = 'DOMLocator';
            $err->{location}->{_line_column} = {l1 => 0+$v, l2 => 0+$v};
          }
        } (XNUM) {
          lang:Perl ($v => $token.value) {
            $err->{location}->{type} = 'DOMLocator';
            $err->{location}->{_line_column} = {l1 => hex $v, l2 => hex $v};
          }
        } (BNUM) {
          lang:Perl ($v => $token.value) {
            $err->{location}->{type} = 'DOMLocator';
            $err->{location}->{_line_column} = {l1 => eval $v, l2 => eval $v};
          }
        }
        ~ (COMMA) { }
        ~ (DNUM) {
          lang:Perl ($v => $token.value) {
            $err->{location}->{_line_column}->{c1} =
            $err->{location}->{_line_column}->{c2} = 0+ $v;
          }
        } (XNUM) {
          lang:Perl ($v => $token.value) {
            $err->{location}->{_line_column}->{c1} =
            $err->{location}->{_line_column}->{c2} = hex $v;
          }
        } (BNUM) {
          lang:Perl ($v => $token.value) {
            $err->{location}->{_line_column}->{c1} =
            $err->{location}->{_line_column}->{c2} = eval $v;
          }
        }
        ~ (RPAREN) { }

        ~? (RANGE) {
          ~ (LPAREN) { }
          ~ (DNUM) {
            lang:Perl ($v => $token.value) {
              $err->{location}->{_line_column}->{l2} = 0+ $v;
            }
          } (XNUM) {
            lang:Perl ($v => $token.value) {
              $err->{location}->{_line_column}->{l2} = hex $v;
            }
          } (BNUM) {
            lang:Perl ($v => $token.value) {
              $err->{location}->{_line_column}->{l2} = eval $v;
            }
          }
          ~ (COMMA) { }
          ~ (DNUM) {
            lang:Perl ($v => $token.value) {
              $err->{location}->{_line_column}->{c2} = 0+ $v;
            }
          } (XNUM) {
            lang:Perl ($v => $token.value) {
              $err->{location}->{_line_column}->{c2} = hex $v;
            }
          } (BNUM) {
            lang:Perl ($v => $token.value) {
              $err->{location}->{_line_column}->{c2} = eval $v;
            }
          }
          ~ (RPAREN) { }
        }

        lang:Perl { $has_pos = true; }
      }

      if-true ($has_pos) {
        ~ (SEMICOLON) { }
      }

      &_node ($node => $err);

      ~ (#EOF) { }
    }

    rule _node ($node) : standalone : recursive {
      // ~ (NAME) { }
      // ~ (LBRACE) { }

      ~* (NAME) {
        my $name;
        lang:Perl ($v => $token.value) {
          $name = $v;
        }

        ~ (COLON) {
          &_attribute ($node => $node, $name => $name);
        } (LBRACE) {
          my $subnode;
          lang:Perl {
            $subnode = {
              node_type => $name,
            };
            if ($name eq 'attribute') {
              push @{$node->{attributes}||=[]}, $subnode;
            } elsif ($name eq 'element-type-definition') {
              push @{$node->{element_types}||=[]}, $subnode;
            } elsif ($name eq 'attribute-definition') {
              push @{$node->{attribute_definitions}||=[]}, $subnode;
            } elsif ($name eq 'general-entity') {
              push @{$node->{general_entities}||=[]}, $subnode;
            } elsif ($name eq 'notation') {
              push @{$node->{notations}||=[]}, $subnode;
            } elsif ($name eq 'namespace') {
              push @{$node->{namespaces}||=[]}, $subnode;
            } else {
              push @{$node->{child_nodes}||=[]}, $subnode;
            }
          }
          &_node ($node => $subnode);
        }
      } (SEMICOLON) { }

      ~ (RBRACE) { }

    } // _node

    rule _attribute ($node, $name) {
      /*
        attribute := attribute-name ":" attribute-value ";"
        attribute-name := NAME
        attribute-value := 'null' / 'true' / 'false'
                         / string
                         / number
                         / 'const' "(" NAME ")"
                         / 'DOMStringList' "(" [string] *("," string) [","] ")"
                         / 'TypeInfo' "(" [string / 'null']
                                          *("," (string / 'null')) [","] ")"
        string := 1*(STRING / CHAR)
        number := DNUM / HNUM / BNUM
      */
 
      // ~ (NAME) { }
      // ~ (COLON) { }

      lang:Perl {
        $name =~ tr/-/_/;
      }

      ~ (NAME == 'null') {
        lang:Perl {
          $node->{$name} = {type => 'nu'.'ll'};
        }
      } (NAME == 'true') {
        lang:Perl {
          $node->{$name} = {type => 'boolean', value => 1};
        }
      } (NAME == 'false') {
        lang:Perl {
          $node->{$name} = {type => 'boolean', value => 0};
        }
      } (STRING) {
        lang:Perl ($v => $token.value) {
          $node->{$name} = {type => 'string',
                            value => substr ($v, 1, length ($v) - 2)};
        }

        ~* (STRING) {
          lang:Perl ($v => $token.value) {
            $node->{$name}->{value} .= substr ($v, 1, length ($v) - 2);
          }
        } (CHAR) {
          lang:Perl ($v => $token.value) {
            $node->{$name}->{value} .= chr hex substr ($v, 2);
          }
        }
      } (CHAR) {
        lang:Perl ($v => $token.value) {
          $node->{$name} = {type => 'string',
                            value => chr hex substr ($v, 2)};
        }

        ~* (STRING) {
          lang:Perl ($v => $token.value) {
            $node->{$name}->{value} .= substr ($v, 1, length ($v) - 2);
          }
        } (CHAR) {
          lang:Perl ($v => $token.value) {
            $node->{$name}->{value} .= chr hex substr ($v, 2);
          }
        }
      } (DNUM) {
        lang:Perl ($v => $token.value) {
          $node->{$name} = {type => 'number', value => 0+$v};
        }
      } (XNUM) {
        lang:Perl ($v => $token.value) {
          $node->{$name} = {type => 'number', value => hex $v};
        }
      } (BNUM) {
        lang:Perl ($v => $token.value) {
          $node->{$name} = {type => 'number', value => eval $v};
        }
      } (NAME == 'const') {
        ~ (LPAREN) { }

        ~ (NAME) {
          lang:Perl ($v => $token.value) {
            $node->{$name} = {type => 'const', value => $v};
          }
        }

        ~ (RPAREN) { }
      } (NAME == 'DOMStringList') {
        my $list;
        lang:Perl {
          $node->{$name} = {type => 'DOMStringList', value => ($list = [])};
        }

        ~ (LPAREN) { }

        ~* (STRING) {
          lang:Perl ($v => $token.value) {
            push @$list, substr ($v, 1, length ($v) - 2);
          }
          ~* (STRING) {
            lang:Perl ($v => $token.value) {
              $list->[-1] .= substr ($v, 1, length ($v) - 2);
            }
          } (CHAR) {
            lang:Perl ($v => $token.value) {
              $list->[-1] .= chr hex substr ($v, 2);
            }
          }
        } (CHAR) {
          lang:Perl ($v => $token.value) {
            push @$list, chr hex substr ($v, 2);
          }
          ~* (STRING) {
            lang:Perl ($v => $token.value) {
              $list->[-1] .= substr ($v, 1, length ($v) - 2);
            }
          } (CHAR) {
            lang:Perl ($v => $token.value) {
              $list->[-1] .= chr hex substr ($v, 2);
            }
          }
        } (COMMA) : separator : terminator? { }

        ~ (RPAREN) { }
      } (NAME == 'TypeInfo') {
        my $list;
        lang:Perl {
          $node->{$name} = {type => 'TypeInfo', value => ($list = [])};
        }

        ~ (LPAREN) { }

        ~* (STRING) {
          lang:Perl ($v => $token.value) {
            push @$list, substr ($v, 1, length ($v) - 2);
          }
          ~* (STRING) {
            lang:Perl ($v => $token.value) {
              $list->[-1] .= substr ($v, 1, length ($v) - 2);
            }
          } (CHAR) {
            lang:Perl ($v => $token.value) {
              $list->[-1] .= chr hex substr ($v, 2);
            }
          }
        } (CHAR) {
          lang:Perl ($v => $token.value) {
            push @$list, chr hex substr ($v, 2);
          }
          ~* (STRING) {
            lang:Perl ($v => $token.value) {
              $list->[-1] .= substr ($v, 1, length ($v) - 2);
            }
          } (CHAR) {
            lang:Perl ($v => $token.value) {
              $list->[-1] .= chr hex substr ($v, 2);
            }
          }
        } (NAME == 'null') {
          lang:Perl {
            push @$list, null;
          }
        } (COMMA) : separator : terminator? { }

        ~ (RPAREN) { }
      }

      ~ (SEMICOLON) { }
    } // _attribute

    token-error default : default {
      lang:Perl {
        my $location = {
          utf32_offset => pos ($self->{source}),
        };
        my $continue = __DOMCore:ERROR{dtest|bad-token-error::
          dtest|error-token => {$token},
          DOMCore|location => {$location},
          dtest|source-text => {\($self->{source})},
        }__;
        unless ($continue) {
          __EXCEPTION{dtest|PARSE_ERR::
          }__;
        }
        $self->{has_error} = true;
      }
    } // token-error default
##TDTParser

IFClsDef:
  @IFQName: DTExceptionFormatter
  @ClsQName: ManakaiDTExceptionFormatter

  @ClsISA: ecore|MUErrorFormatter||ManakaiDOM|Perl

  @RuleDef:
    @@Name: tdt-error-token-type
    @@enDesc:
      The type of the token the parser is encountered.

    @@Method:
      @@@Name: after
      @@@Param:
        @@@@Name: name
        @@@@Type: DOMString
        @@@@enDesc: The name of the method.
      @@@Param:
        @@@@Name: p
        @@@@Type: DISPerl|HASH
        @@@@enDesc: The set of the parameters to the method.
      @@@Param:
        @@@@Name: o
        @@@@Type: DISPerl|HASH
        @@@@enDesc: The option value.
      @@@Return:
        @@@@PerlDef:
          $p->{-result} = $o->{<H::dtest|error-token>}->{type}
            if defined $o->{<H::dtest|error-token>}->{type};

  @RuleDef:
    @@Name: tdt-error-token-value
    @@enDesc:
      The value of the token the parser is encountered, if any.

    @@Method:
      @@@Name: after
      @@@Param:
        @@@@Name: name
        @@@@Type: DOMString
        @@@@enDesc: The name of the method.
      @@@Param:
        @@@@Name: p
        @@@@Type: DISPerl|HASH
        @@@@enDesc: The set of the parameters to the method.
      @@@Param:
        @@@@Name: o
        @@@@Type: DISPerl|HASH
        @@@@enDesc: The option value.
      @@@Return:
        @@@@PerlDef:
          $p->{-result} = $o->{<H::dtest|error-token>}->{value}
            if defined $o->{<H::dtest|error-token>}->{value};

  @RuleDef:
    @@Name: tdt-error-lines
    @@enDesc:
      A copy of fragment of the source text that contains the line
      where the error occurred, if available.
    
    @@Method:
      @@@Name: after
      @@@Param:
        @@@@Name: name
        @@@@Type: DOMString
        @@@@enDesc: The name of the method.
      @@@Param:
        @@@@Name: p
        @@@@Type: DISPerl|HASH
        @@@@enDesc: The set of the parameters to the method.
      @@@Param:
        @@@@Name: o
        @@@@Type: DISPerl|HASH
        @@@@enDesc: The option value.
      @@@Return:
        @@@@PerlDef:
          my $pos = $o-><AG::DOMCore|DOMError.location>
                      -><AG::DOMCore|DOMLocator.utf32Offset>;
          if ($pos > -1) {
            my $src = $o->{<H::dtest|source-text>};
            my $start = $pos;
            $start = rindex ($$src, "\x0A", $start - 1) for 0..2;
            $start++;
            my $end = $pos;
            $end = index ($$src, "\x0A", $end + 1) for 0..2;
            $end = length $$src if $end < 0;
            $p->{-result} = substr $$src, $start, $end - $start;
          }
##DPGExceptionFormatter

ElementTypeBinding:
  @Name: RuleDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass
    @@rdf:type: Muf2003|RuleDefClass

ElementTypeBinding:
  @Name: RuleParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: Muf2003|RuleParameter

ElementTypeBinding:
  @Name:enMufDef
  @ElementType:
    ecore:defaultMessage
  @ShadowContent:
    @@lang:en
    @@ContentType:
      lang:muf

PropDef:
  @QName: dtest|error-token
  @enDesc:
    The token where the parser found an error.

PropDef:
  @QName: dtest|source-text
  @enDesc:
    A reference to the original source text, if available.

PropDef:
  @QName: dtest|relatedURI
  @enDesc:
    A related URI.

PropDef:
  @QName: dtest|resource
  @enDesc:
    A related <QUOTE::dis> resource.

PropDef:
  @QName: dtest|qname
  @enDesc:
    A related <QUOTE::dis> QName.

ElementTypeBinding:
  @Name: CParamApp
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      @@@@: DOMCore|DOMConfigurationParameterApplication
      @@@For: ManakaiDOM|DOM
    @@rdf:type:
      @@@@: DISCore|Property
      @@@For: =ManakaiDOM|all
    @@For: ManakaiDOM|DOM3
    @@For: =ManakaiDOM|all

CParamApp:
  @DOMCore:domConfigurationParameter: DOMCore|error-handler
  @DOMCore:targetType: TDTParser

ElementTypeBinding:
  @Name: ErrDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DOMCore|DOMErrorType
    @@For: ManakaiDOM|DOM3
    @@ecore:textFormatter: ManakaiDTExceptionFormatter

ErrDef:
  @QName: dtest|bad-token-error
  @enDesc:
    The parser is encountered to a token whose type is not
    allowed there.
  @DOMCore:severity: DOMCore|SEVERITY_FATAL_ERROR
  @enMufDef:
    Token |%tdt-error-token-type;|%tdt-error-token-value
    (prefix => { (|}, suffix => {|)}); is not 
    allowed %tdt-error-lines (prefix => {(|}, suffix => {|)});

ErrDef:
  @QName: dtest|undeclared-namespace-prefix-error
  @enDesc:
    The namespace prefix is not declared.
  @DOMCore:severity: DOMCore|SEVERITY_ERROR
  @enMufDef:
    |%p (name => {<Q::dtest:qname>});|: Namespace prefix is not declared

ErrDef:
  @QName: dtest|bad-error-resource-error
  @enDesc:
    The type of an error resource is not supported.
  @DOMCore:severity: DOMCore|SEVERITY_ERROR
  @enMufDef:
    <%p (name => {<Q::dtest:uri>});>: Not an error of supported error type
