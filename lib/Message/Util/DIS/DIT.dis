Module:
  @QName: DIS|DIT
  @enFN:
    The DIT <QUOTE::dis> Serialization Format
  @Namespace:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS#DIT/
  
  @enDesc:
    ...

  @DISCore:author: DISCore|Wakaba
  @License: license|Perl+MPL
  @Date:
    $Date: 2007/03/21 11:28:18 $
  
  @Require:
    @@Module:
      @@@QName: DIS|common
    @@Module:
      @@@QName: MDOM|DOMCore
      @@@WithFor: ManakaiDOM|ManakaiDOMLatest
    @@Module:
      @@@QName: MDOM|GenericLS
      @@@WithFor: ManakaiDOM|ManakaiDOMLatest
    @@Module:
      @@@WithFor: ManakaiDOM|ManakaiDOM
    @@Module:
      @@@WithFor: ManakaiDOM|ManakaiDOMLatest
    @@Module:
      @@@QName: Util|DIS
      @@@WithFor: DIS|ForLatest

  @DefaultFor: ManakaiDOM|ManakaiDOMLatest

Namespace:
  @c:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#
  @DIS:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS#
  @dis:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#dis--
  @DISlib:
    http://suika.fam.cx/~wakaba/archive/2004/dis/
  @dit:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS#DIT/
  @domperl:
    http://suika.fam.cx/~wakaba/archive/2006/dom/perl/
  @dtest:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS#Test/
  @dx:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#
  @ecore:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/Core/
  @f:
    http://suika.fam.cx/~wakaba/archive/2004/dom/feature#
  @gls:
    http://suika.fam.cx/~wakaba/archive/2004/dom/gls#
  @idl:
    http://suika.fam.cx/~wakaba/archive/2004/dis/IDL#
  @kwd:
    http://suika.fam.cx/~wakaba/archive/2005/rfc2119/
  @lang:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#
  @license:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/license#
  @ManakaiDOM:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#
  @MDOM:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#ManakaiDOM.
  @rdf:
    http://www.w3.org/1999/02/22-rdf-syntax-ns#
  @rdfs:
    http://www.w3.org/2000/01/rdf-schema#
  @tc:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/DOM/TreeCore/
  @te:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/DOM/Element/
  @test:
    http://suika.fam.cx/~wakaba/archive/2004/dis/Test#
  @Util:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/

## -- Features

ElementTypeBinding:
  @Name: FeatureDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DOMFeature|Feature

ElementTypeBinding:
  @Name: FeatureVerDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DOMFeature|Feature

ElementTypeBinding:
  @Name: featureQName
  @ElementType:
    DOMFeature:name
  @ShadowContent:
    @@ContentType: DISCore|QName

FeatureDef:
  @QName: DIS|DIT
  @FeatureVerDef:
    @@QName: DIS|DIT10
    @@Version: 1.0
    @@f:requires: c|CoreFeature30
    @@f:instanceOf: DIS|DIT
    @@enFN:
      The DIT Module, Version 1.0

ElementTypeBinding:
  @Name: enDesc
  @ElementType: 
    dis:Description
  @ShadowContent: 
    @@lang:en

ElementTypeBinding:
  @Name: enFN
  @ElementType:
    dis:FullName
  @ShadowContent:
    @@lang:en

ElementTypeBinding:
  @Name: enImplNote
  @ElementType:
    dis:ImplNote
  @ShadowContent:
    @@lang:en

ElementTypeBinding:
  @Name: IFClsDef
  @ElementType: 
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      @@@@: dis|MultipleResource
      @@@ForCheck: !ManakaiDOM|ForIF !ManakaiDOM|ForClass
    @@resourceFor: ManakaiDOM|ForIF
    @@resourceFor: ManakaiDOM|ForClass

    @@rdf:type:
      @@@@: DISLang|Interface
      @@@ForCheck: ManakaiDOM|ForIF

    @@rdf:type:
      @@@@: DISLang|Class
      @@@ForCheck: ManakaiDOM|ForClass

    @@Implement:
      @@@@: ||+||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass

    @@f:implements: DIS|DIT10

ElementTypeBinding:
  @Name: IFQName
  @ElementType:
    dis:QName
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForIF

ElementTypeBinding:
  @Name: ClsQName
  @ElementType:
    dis:QName
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: IFISA
  @ElementType:
    dis:ISA
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForIF

ElementTypeBinding:
  @Name: ClsISA
  @ElementType:
    dis:ISA
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: Method
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Method

ElementTypeBinding:
  @Name: Return
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|MethodReturn

ElementTypeBinding:
  @Name: Param
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|MethodParameter

ElementTypeBinding:
  @Name: Attr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Attribute

ElementTypeBinding:
  @Name: Get
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|AttributeGet

ElementTypeBinding:
  @Name: Set
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|AttributeSet

ResourceDef:
  @QName: DOMString
  @AliasFor: str|DOMString

ResourceDef:
  @QName: Node
  @AliasFor: tc|Node

ElementTypeBinding:
  @Name: PerlDef
  @ElementType:
    dis:Def
  @ShadowContent:
    @@ContentType: lang|Perl
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: InCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:InCase

ElementTypeBinding:
  @Name: nullCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:InCase
    @@Value:
      @@@is-null:1
      @@@ContentType: DISCore|String

ElementTypeBinding:
  @Name: TrueCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:InCase
    @@Value:
      @@@@: 1
      @@@ContentType: DISCore|Boolean
    @@Type: idl|boolean

ElementTypeBinding:
  @Name: FalseCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:InCase
    @@Value:
      @@@@: 0
      @@@ContentType: DISCore|Boolean
    @@Type: idl|boolean

ElementTypeBinding:
  @Name: RPropDef:
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISSource|Property

ElementTypeBinding:
  @Name: SPropDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISSource|Property
    @@rdf:type: DISSource|ResourceProperty

IFClsDef:
  @IFQName: DITParser
  @ClsQName: ManakaiDITParser

  @Implement: ecore|MUErrorTarget

  @DISLang:role: gls|ParserRole

  @f:implements: DIS|DIT10

  @enDesc:
    A <IF::DITParser> object parses a DIT source document and
    returns it as an object. 

    A <IF::DITParser> object can be retrieved by 
    <M::GenericLS|GLSImplementation.createGLSParer>.

  @Attr:
    @@Name: domConfig
    @@enDesc:
      The configuration of the parser.

    @@Get:
      @@@Type: c|DOMConfiguration
      @@@enDesc: The DOM configuration object.
      @@@PerlDef:
        __CODE{c|getConfigObject::
          $target => $self,
          $targetHash => $self,
          $targetType => {<IFName::DITParser>},
          $result => $r,
        }__;

  @Method:
    @@ManakaiDOM:isForInternal:1
    @@ForCheck: ManakaiDOM|ForClass
    @@Operator: DISPerl|NewMethod
    @@enDesc:
      Creates a new instance of the object.
    @@Param:
      @@@Name: impl
      @@@Type: gls|GLSImplementation
      @@@enDesc:
        The implementation from which the parser is created.
    @@Param:
      @@@Name: features
      @@@Type: DOMString
      @@@dis:actualType: f|FeaturesString
      @@@enDesc:
        The set of features requested for the parser.
    @@Return:
      @@@Type: DOMMain|DOMObject
      @@@enDesc:
        The newly created parser.
      @@@PerlDef:
        $r = bless {
          <H::f|implementation> => $impl,
        }, $self;

  @Method:
    @@Name: parseString
    @@enDesc:
      Parses a string as DIT textual definition and
      merge resources included there into a <QUOTE::dis> database.
    @@Param:
      @@@Name: sourceText
      @@@Type: DOMString
      @@@enDesc:
        The text to parse.
    @@Param:
      @@@Name: disDatabase
      @@@Type: DISDatabase
      @@@enDesc:
        The <QUOTE::dis> database object to which the
        loaded resources will belong.
    @@Return:
      @@@Type: DISModule
      @@@enDesc:
        The <QUOTE::dis> module object generated from the
        <P::sourceText>.
      @@@dx:raises:
        @@@@@: dit|PARSE_ERR
        @@@@enDesc:
          <kwd:MUST> be thrown if the DIT document contains one or more error.
      @@@PerlDef:
        $self->{char} = [];
        $self->{token} = [];
        $self->{source} = \$sourceText;
        $self->{location} = {};
        __DEEP{
          $r = $self->_parse_document;
        }__;

  @Method:
    @@Name: shiftChar
    @@ManakaiDOM:isForInternal:1
    @@ForCheck: ManakaiDOM|ForClass
    @@enDesc:
      Returns the next character.
    @@Return:
      @@@Type: idl|long||ManakaiDOM|all
      @@@enDesc:
        The code position number of the next character, if any,
        or <CODE::-2>.
      @@@PerlDef:
        if (@{$self->{char}}) {
          $r = shift @{$self->{char}};
        } else {
          my $char = substr (${$self->{source}}, pos (${$self->{source}}), 1);
          pos (${$self->{source}})++;

          if (length $char) {
            $r = ord $char;
          } else {
            $r = -1;
          }
        }
  
  @Method:
    @@ManakaiDOM:isForInternal: 1
    @@Name: qnameToURI
    @@enDesc:
      Resolves a qualified name in DIT document into the URI.
    @@Param:
      @@@Name: qname
      @@@Type: DOMString
      @@@enDesc:
        The qualified name to resolve.
    @@Return:
      @@@Type: DOMString
      @@@enDesc:
        The URI.
      @@@dx:raises:
        @@@@@: dit|PARSE_ERR
        @@@@enDesc:
          If the namespace prefix is not defined.
      @@@PerlDef:
        my ($pfx, $ln) = split /\|/, $qname, 2;
            my $uri = $self->{namespace}->{$pfx};
            if (defined $uri) {
              $r = $uri . $ln;
            } else {
              my $location = {
                utf32_offset => pos (${$self->{source}}),
              };
              my $continue = __c|ERROR{dit|namespace-prefix-not-defined-error::
                dit|error-token => {$token},
                dit|source-text => {$self->{source}},
                c|location => {$location},
                dit|namespace-prefix => {$prefix},
              }__;
              unless ($continue) {
                __EXCEPTION{dit|PARSE_ERR}__;
              }
              $r = $ln;
            }

  @Method:
    @@Name: parseEmbedBlock
    @@ManakaiDOM:isForInternal:1
    @@ForCheck: ManakaiDOM|ForClass
    @@enDesc:
      Parses an embed statement block.
    @@Return:
      @@@PerlDef:
        my $token = $self->_scan_default;
        if ($token->{type} eq 'QSTART') {
          my $nest_count = 1; # already opened
          my $s = '';
          __DEEP{
            C: while ((my $ch = $self->_shift_char) > -1) {
              if ($ch == 0x007B) {
                $s .= '{'; # }
                $nest_count++;
              } elsif ($ch == 0x007D) {
                if (--$nest_count == 0) {
                  last C;
                } elsif ($nest_count < 0) {
                  $nest_count = 0;
                }
                $s .= chr $ch;
              } else {
                $s .= chr $ch;
              }
            }

            push @{$self->{value}}, {type => 'string', value => $s};
          }__;
        } else {
          unshift @{$self->{token}}, $token;
        }

  @Method:
    @@ManakaiDOM:isForInternal: 1
    @@Operator: ManakaiDOM|MUErrorHandler
    @@enDesc:
      When a <IF::ecore|ErrorInterface> is <Perl::report>ed,
      then this method is invoked.
      
      The method calls the <cfg::DOMCore|error-handler> if the error is of 
      <IF::DOMCore|DOMError>.  Otherwise, the error is re-thrown so that
      corresponding <Perl::catch> clause, if any, can catch the error.
    @@Param:
      @@@Name: err
      @@@Type: ecore|ErrorInterface
      @@@enDesc:
        The reported error object.
    @@Return:
      @@@Type: DISPerl|Any
      @@@enDesc:
        If the <P::err> is a <IF::DOMCore|DOMError>, then the return value
        of the error handler.

           {NOTE:: If the error is thrown, the method never returns.
           }
      @@@nullCase:
        @@@@enDesc:
          No error handler.
      @@@PerlDef:
        if ($err->isa (<IFName::DOMCore|DOMError>)) {
          __DEEP{
            A: {
              my $cfg = $self-><AG::TDTParser.domConfig>;
              my $h = $cfg-><M::DOMCore|DOMConfiguration.getParameter>
                               ('error-handler');
              $r = $h-><M::DOMCore|DOMErrorHandler.handleError> ($err);
            } # A
          }__;
        } else {
          $err-><M::ecore|ErrorInterface.throw>;
        }

  @DISPerl:dpgDef:
    lexmode default : initial : standalone {

      /* Name */
      $name-start-char := [U+0041..U+005A U+0061..U+007A];
      $name-char       := [U+0041..U+005A U+0061..U+007A U+0030..U+0039 '-' '_'];
      $name := $name-start-char $name-char*;
      $prefixed-name := $name? ['|'] $name?;
      NAME : value := $name;
      PREFIXEDNAME : value := $prefixed-name;
          /*
            A |PREFIXEDNAME| are to be expanded into a triple
            of namespace prefix, namespace URI, and local name.
          */
      ANDNAME : value := ['&'] $name;
      DOLLERNAME : value := ['$'] $name;

      /* At-keyword */
      ATKEYWORD : value := ['@'] $name;

      /* RNI-keyword */
      RNIKEYWORD : value := ['#'] $name;

      /* Block */
      LBRACE := ['{'];
      RBRACE := ['}'];

      /* Declaration */
      COLON := [':'];
      DCOLON := [':'] [':'];
      EQUAL := ['='];
      SEMICOLON := [';'];

      /* String */
      $hexdigit := [U+0030..U+0039 U+0041..U+0046 U+0061..U+0066];
      $ucs2 := [U+005C] ['u'] $hexdigit $hexdigit $hexdigit $hexdigit;
      $ucs4 := [U+005C] ['U'] $hexdigit $hexdigit $hexdigit $hexdigit
          $hexdigit $hexdigit $hexdigit $hexdigit;
      $schar := $ucs2? $ucs4? [^U+0027 U+005C]?
      STRING : value := [U+0027] $schar* [U+0027];
      QSTART := ['q'] ['{'];

      /* Number */
      MINUS := ['-'];
      DNUM : value := [U+0030..U+0039] [U+0030..U+0039 '_']*;
      XNUM : value := ['0'] ['x']
                      [U+0030..U+0039 U+0041..U+0046 U+0061..U+0066 '_']+;
      BNUM : value := ['0'] ['b'] ['0' '1' '_']+;

      /* Functional notation */
      COMMA := [','];
      LPAREN := ['('];
      RPAREN := [')'];

      /* Range */
      RANGE := ['.'] ['.'];

      /* URI */
      URI : value := ['<'] [^'<' '>' '[' ']'] [^'<' '>']* ['>'];

      /*
        cwsp := WSP / COMMENT1 / COMMENT2
          ;; allowed everywhere
      */
      
      /* Ignored white space */
      WSP : ignore := [U+0009..U+000D U+0020]+;

      /* Ignored comment */
      COMMENT1 : ignore := ['/'] ['/'] [^U+000A..U+000D]* [U+000A..U+000D]*;
      $comment2 := [^'/' '*'] [^'*']* ['*']+;
      COMMENT2 : ignore := ['/'] ['*'] [^'*']* ['*']+ $comment2* ['/'];

    } // lexmode default

    /*
      QSTRING := 'q{' *((<any character> - '{' / '}') / QSTRING) '}'

          ISSUE: How escapes ('\' <any character>) should be parsed?
    */
    rule QSTRING
           : perl-name => 'embed_block'
           <external>;

    /*
      A DIT Document (|lang:dit|).
    */
    rule root-document : standalone {
      /*
        root-document := header body
      */

      lang:Perl {
        ## Reset
        $self->{namespace} = {};
        $self->{default_namespace} = undef;
      }

      &header;

      &body;

      ~ (#EOF) { }
    } // root-document

    rule imported-document : standalone {
      /*
        imported-document := header
      */

      &header;

      ~ (#EOF) { }
    } // imported-document

    rule header {
      /*
        header := *at-namespace *at-require *at-import
      */

      &at-namespaces;
      &at-requires;
      &at-imports;
    } // header

    rule at-namespaces {
      ~* (ATKEYWORD == '@namespace') {
        /*
          at-namespace := '@namespace' namespace-prefix (URI / PREFIXEDNAME)
              SEMICOLON
              ;; NOTE: In this context the namespace prefix in |PREFIXEDNAME|
              ;; is not significant once it is resolved into a namespace URI.

          namespace-prefix := NAME / '#default'
        */
        my $prefix;
        ~ (NAME) {
          lang:Perl ($value => $token.value) {
            $prefix = $value;
          }
        } (RNIKEYWORD == '#default') {
          //
        }

        my $nsuri;
        ~ (URI) {
          lang:Perl ($value => $token.value) {
            $nsuri = substr $value, 1, length ($value) - 2;
          }
        } (PREFIXEDNAME) {
          lang:Perl ($value => $token.value) {
            $nsuri = $self->_qname_to_uri ($value);
          }
        }

        lang:Perl {
          if (defined $prefix) {
            if (defined $self->{namespace}->{$prefix}) {
              my $location = {
                utf32_offset => pos (${$self->{source}}),
              };
              my $continue = __c|ERROR{dit|namespace-prefix-redefined-error::
                c|location => {$location},
                dit|namespace-prefix => {$prefix},
                dit|old-definition => {$self->{namespace}->{$prefix}},
                dit|new-definition => {$nsuri},
              }__;
              unless ($continue) {
                __EXCEPTION{dit|PARSE_ERR}__;
              }
            }
            $self->{namespace}->{$prefix} = $nsuri;
          } else {
            if (defined $self->{default_namespace}) {
              my $location = {
                utf32_offset => pos (${$self->{source}}),
              };
              my $continue = __c|ERROR{dit|namespace-prefix-redefined-error::
                c|location => {$location},
                dit|namespace-prefix => {$prefix},
                dit|old-definition => {$self->{default_namespace}},
                dit|new-definition => {$nsuri},
              }__;
              unless ($continue) {
                __EXCEPTION{dit|PARSE_ERR}__;
              }
            }
            $self->{default_namespace} = $nsuri;
          }
        }
      }
      ~ (SEMICOLON) { }
    } // at-namespaces

    rule at-requires {
      ~* (ATKEYWORD == '@require') {
        /*
          at-require := '@require' PREFIXEDNAME SEMICOLON
        */
        ~ (PREFIXEDNAME) {
          lang:Perl ($value => $token.value) {
            my $module_uri = $self->_qname_to_uri ($value);
            ## TODO: What to do?
          }
        }
        ~ (SEMICOLON) { }
      }
    } // at-requires

    rule at-imports { 
      ~* (ATIMPORT == '@import') {
        /*
          at-import := '@import' PREFIXEDNAME SEMICOLON
        */
        ~ (PREFIXEDNAME) {
          lang:Perl ($value => $token.value) {
            my $file_uri = $self->_qname_to_uri ($value);

            ## NOTE: Intentionally no warning when
            ## the file has already been imported by anywhere
            unless ($self->{imported_uri}->{$file_uri}) {
              $self->{imported_uri}->{$file_uri} = 1;

              push @{$self->{file}},
                  [$self->{source}, $self->{location},
                  $self->{char}, $self->{token}];
  
              ## TODO: get file's content
              my $s = '';
              $self->{source} = $s;
              $self->{location} = {}; ## TODO: set something
              $self->{char} = [];
              $self->{token} = [];
              $self->parse_imported_document;

              my $file = pop @{$self->{file}};
              $self->{source} = $file->[0];
              $self->{location} = $file->[1];
              $self->{char} = $file->[2];
              $self->{token} = $file->[3];
            }
          }
        }
        ~ (SEMICOLON) { }
      }
    } // at-imports

    rule body {
      /*
        body := *(in-resource-rule / resource / at-let)
    
        in-resource-rule := property / ref / empty-rule
      */

      ~* (PREFIXEDNAME) {
        my $prop_uri;
        lang:Perl ($value => $token.value) {
          $prop_uri = $self->_qname_to_uri ($value);
        }
        &_property ($prop_uri => $prop_uri);
      } (ATKEYWORD == '@let') {
        &_at-let;
      } (LBRACE) {
        &_resource;
      } (ANDNAME) {
        /*
          ref := ANDNAME
        */

        // TODO: expansion
      } (SEMICOLON) {
        /*
          empty-rule := SEMICOLON
        */
      }
    } // body

    rule _at-let {
      /*
        at-let := '@let' ANDNAME parameters resource SEMICOLON

        parameters := [VARNAME *(COMMA VARNAME)]
            ;; ISSUE: Should a block allowed as a parameter?
      */

      my $let_name;
      ~ (ANDNAME) {
        lang:Perl ($value => $token.value) {
          $let_name = $value;
          if (defined $self->{let}->{$let_name}) {
            ## ISSUE: error? override?
          }
        }
      }

      ~* (VARNAME) {

      } (COMMA) : separator {
        /* ISSUE: $a,,$b == $a,$b ?? */
      }

      ~ (LBRACE) {
        &_resource;
      }

      // TODO: 

      ~ (SEMICOLON) { }
    } // _at-let

    rule _resource : recursive {
      /*
        resource := LBRACE *in-resource-rule RBRACE
      */

      ~* (PREFIXEDNAME) {
        my $prop_uri;
        lang:Perl ($value => $token.value) {
          $prop_uri = $self->_qname_to_uri ($value);
        }
        &_property ($prop_uri => $prop_uri);
      } (ANDNAME) {
        /*
          ref := ANDNAME
        */

        // TODO: expansion
      } (SEMICOLON) {
        /*
          empty-rule := SEMICOLON
        */
      }

      ~ (RBRACE) { }
    } // _resource

    rule _property ($prop_uri) : recursive {
      /*
        property := one-value-property / ordered-list-property
            / unordered-list-property

        one-value-property := property EQUAL value SEMICOLON

        unordered-list-property := property-name DCOLON value SEMICOLON

        ordered-list-property := property-name COLON value SEMICOLON

        property-name := PREFIXEDNAME
            ;; ISSUE: Should a |NAME| be allowed as a property name?
            ;; ISSUE: Should a union of properties be allowed?
            ;; TODO: A special syntax for |dis|subsetOf| is necessary
      */

      ~ (EQUAL) {

      } (DCOLON) {
    
      } (COLON) {

      }

      // TODO: value

      ~ (SEMICOLON) { }
    } // _property

    rule value : recursive {
      /*
        value := (primitive-or-function / resource)
            [LBRACE *(property / empty-rule) RBRACE]
            / variable-ref
            ;; ISSUE: Should a block allowed after |variable-ref|?
            ;; ISSUE: {a; b} is not allowed now...
      */

      ~ (DOLLERNAME) {
        /*
          variable-ref := DOLLERNAME
        */

        // TODO:
      } else {
        ~ (LBRACE) {
          lang:Perl {
            push @{$self->{resources}}, $self->{resource};
            $self->{resource} = {};
          }

          &_resource;

          lang:Perl {
            my $uri = '## TODO: DISCore:uri from |{resource}|';
            my $v = $self->{impl}->create_dv_value (<Q::DISCore|URI>, $uri);
            ## TODO: register |{resource}| to anywhere
            push @{$self->{value}}, $v;
            $self->{resource} = pop @{$self->{resources}};
          }
        } else {
          &primitive-or-function;
        }
        
        ~ (LBRACE) {
          ~* (PREFIXEDNAME) {
            // property
            my $prop_uri;
            lang:Perl ($value => $token.value) {
              $prop_uri = $self->_qname_to_uri ($value);
            }
            &_property ($prop_uri => $prop_uri);
          } (SEMICOLON) {
            // empty-rule
          }
          ~ (RBRACE) { }
        }
      }
    } // value

    rule primitive-or-function : recursive {
      /*
        primitive-or-function := primitive-value / function-call

        primitive-value := STRING / QSTRING / number / URI / PREFIXEDNAME

        number := MINUS? (DNUM / XNUM / BNUM)
      */

        ~ (STRING) {
          lang:Perl ($value => $token.value) {
            my $v = substr $value, 1, length ($value) - 2;
            $v =~ s/\\(u[0-9A-Fa-f]{4}|U[0-9A-Fa-f]{8})/
              chr hex substr $1, 1
            /ge;
            push @{$self->{value}},
                $self->{impl}->create_dv_value_ref
                    (<Q::DISLang|String>, \$v);
          }
        } (QSTART) {
          &QSTRING;
        } (PREFIXEDNAME) {
          lang:Perl ($value => $token.value) {
            my ($pfx, $ln) = split /\|/, $value, 2;
            my $uri = $self->{namespace}->{$pfx};
            if (defined $uri) {
              push @{$self->{value}},
                  my $v = $self->{impl}->create_dv_value
                      (<Q::DISLang|QName>, $ln);
              $v->prefix ($pfx);
              $v->namespace_uri ($uri);
            } else {
              my $location = {
                utf32_offset => pos (${$self->{source}}),
              };
              my $continue = __c|ERROR{dit|namespace-prefix-not-defined-error::
                dit|error-token => {$token},
                dit|source-text => {$self->{source}},
                c|location => {$location},
                dit|namespace-prefix => {$prefix},
              }__;
              unless ($continue) {
                __EXCEPTION{dit|PARSE_ERR}__;
              }
              push @{$self->{value}},
                  my $v = $self->{impl}->create_dv_value
                      (<Q::DISLang|QName>, $ln);
              $v->prefix ($pfx);
            }
          }
        } (URI) {
          lang:Perl ($value => $token.value) {
            my $v = substr $value, 1, length ($value) - 2;
            push @{$self->{value}}, 
                $self->{impl}->create_dv_value_ref (<Q::DISCore|URI>, \$v);
          }
        } (DNUM) {
          lang:Perl ($value => $token.value) {
            my $v = $value;
            $v =~ tr/_//d;
            $v =~ s/^0+//;
            push @{$self->{value}},
                $self->{impl}->create_dv_value_ref
                    (<Q::DISLang|Number>, 0+$v);
          }
        } (XNUM) {
          lang:Perl ($value => $token.value) {
            my $v = $value;
            $v =~ tr/_//d;
            push @{$self->{value}},
                $self->{impl}->create_dv_value_ref
                    (<Q::DISLang|Number>, hex $v);
          }
        } (BNUM) {
          lang:Perl ($value => $token.value) {
            my $v = $value;
            $v =~ tr/_//d;
            push @{$self->{value}},
                $self->{impl}->create_dv_value_ref
                    (<Q::DISLang|Number>, 0+eval $v);
          }
        } (MINUS) {
          ~ (DNUM) {
            lang:Perl ($value => $token.value) {
              my $v = $value;
              $v =~ tr/_//d;
              $v =~ s/^0+//;
              push @{$self->{value}},
                  $self->{impl}->create_dv_value_ref
                      (<Q::DISLang|Number>, -$v);
            }
          } (XNUM) {
            lang:Perl ($value => $token.value) {
              my $v = $value;
              $v =~ tr/_//d;
              push @{$self->{value}}, 
                  $self->{impl}->create_dv_value_ref
                      (<Q::DISLang|Number>, -hex $v);
            }
          } (BNUM) {
            lang:Perl ($value => $token.value) {
              my $v = $value;
              $v =~ tr/_//d;
              push @{$self->{value}},
                  $self->{impl}->create_dv_value_ref
                      (<Q::DISLang|Number>, -eval $v);
            }
          }
        } (NAME) {
          /*
            function-call := NAME [LPAREN
                [primitive-or-function *(COMMA primitive-or-function)] RPAREN]
          */
          my $function_name;
          lang:Perl ($value => $token.value) {
            $function_name = $value;
            push @{$self->{values}}, $self->{value};
            $self->{value} = [];
          }

        ~? (LPAREN) {
          &primitive-or-function;
          ~* (COMMA) {
            &primitive-or-function;
          }
          ~ (RPAREN) { }
        }

          lang:Perl {
            my $param = $self->{value};
            $self->{value} = pop @{$self->{values}};

            ## TODO: param number check

            if ($function_name eq 'tr'.'ue') {
              push @{$self->{value}},
                  $self->{impl}->create_dv_value_ref
                      (<Q::DISLang|Boolean>, 1);
            } elsif ($function_name eq 'fal'.'se') {
              push @{$self->{value}},
                  $self->{impl}->create_dv_value_ref
                      (<Q::DISLang|Boolean>, 0);
            } elsif ($function_name eq 'nu'.'ll') {
              push @{$self->{value}}, 
                  my $v = $self->{impl}->create_dv_value_ref
                      (<Q::DISLang|Null>, 0);
              $v->is_null (1);
            } elsif ($function_name eq 'with-type') {
              my $new_type = $param->[1]->value;
              ## TODO:
            } elsif ($function_name eq 'local-name') {
              if ($param->[0]->can ('local_name')) {
                push @{$self->{value}},
                    $self->{impl}->create_dv_value 
                        (<Q::DISLang|String>, $param->[0]->local_name);
              } else {
                push @{$self->{value}}, $param->[0];
              }
            } elsif ($function_name eq 'namespace-uri') {
              my $nsuri;
              if ($param->[0]->can ('namespace_uri')) {
                $nsuri = $param->[0]->namespace_uri;
              }
              push @{$self->{value}},
                  my $v = $self->{impl}->create_dv_value
                      (<Q::DISLang|URI>, defined $nsuri ? $nsuri : '');
              $v->is_null (1) unless defined $nsuri;
            } elsif ($function_name eq 'namespace-prefix') {
              my $prefix;
              if ($param->[0]->can ('prefix')) {
                $prefix = $param->[0]->prefix;
              }
              push @{$self->{value}},
                  my $v = $self->{impl}->create_dv_value
                      (<Q::DISLang|String>, defined $prefix ? $prefix : '');
              $v->is_null (1) unless defined $prefix;
            } else {
              ## TODO: error
            }
          }
    } // primitive-or-function

    token-error default : default {
      lang:Perl {
        my $location = {
          utf32_offset => pos ($self->{source}),
        };
        my $continue = __c|ERROR{dit|bad-token-error::
          dit|error-token => {$token},
          c|location => {$location},
          dit|source-text => {\($self->{source})},
        }__;
        unless ($continue) {
          __EXCEPTION{dit|PARSE_ERR::
          }__;
        }
        $self->{has_error} = true;
      }
    } // token-error default
##DITParser


ResourceDef:
  @DISCore:resourceType:
    @@@: dis|MultipleResource
    @@ForCheck: !ManakaiDOM|ForIF !ManakaiDOM|ForClass
  @resourceFor: ManakaiDOM|ForIF
  @resourceFor:
    @@@: ManakaiDOM|ForClass

  @DISCore:resourceType:
    @@@: dx|Interface
    @@ForCheck: ManakaiDOM|ForIF

  @DISCore:resourceType:
    @@@: dx|Class
    @@ForCheck: ManakaiDOM|ForClass

  @Implement:
    @@@: ||+||ManakaiDOM|ForIF
    @@ContentType: DISCore|TFPQNames
    @@ForCheck: ManakaiDOM|ForClass
  @dx:implementedBy:
    @@@: ||+||ManakaiDOM|ForClass
    @@ForCheck: ManakaiDOM|ForIF

  @f:implements:
    @@@: DIS|DPG10

  @DISPerl:ISA:
    @@@: dx|Exception
    @@ForCheck: ManakaiDOM|ForClass

  @IFQName: DITException
  @ClsQName: ManakaiDITException

  @ecore:textFormatter: ManakaiDITExceptionFormatter

  @enDesc:
    A <IF::DITParser> might throw a <IF::DPGException> if the processing is
    stopped.  The processing can be stopped due to a <IF::c|DOMError>
    with a <A::c|DOMError.severity> of 
    <C::c|DOMError.SEVERITY_FATAL_ERROR> or a non-recovered
    <C::c|DOMError.SEVERITY_ERROR>, or if 
    <M::c|DOMErrorHandler.handleError> method returned <DOM::false>.

  @Attr:
    @@Name: code
    @@Get:
      @@@Type: idl|unsignedShort
      @@@dis:actualType: DITExceptionCode
    @@ForCheck: ManakaiDOM|ForIF

  @ResourceDef:
    @@rdf:type: DISLang|ConstGroup
    @@ForCheck: ManakaiDOM|ForIF

    @@QName: DITExceptionCode

    @@subsetOf: idl|unsignedShort
    @@Type: idl|unsignedShort

    @@enDesc:
      An integer indicating the type of error generated.

    @@ResourceDef:
      @@@QName: dit|PARSE_ERR
      @@@DISCore:resourceType: dx|ErrorCode
      @@@Value:
        @@@@@: 81
        @@@@ContentType: DISCore|Integer
      @@@enDesc:
        An attempt was made to load a DIT document and
        the processing has been stopped.
##DITException

IFClsDef:
  @IFQName: DITExceptionFormatter
  @ClsQName: ManakaiDITExceptionFormatter

  @ClsISA: ecore|MUErrorFormatter||ManakaiDOM|Perl

  @RuleDef:
    @@Name: dit-error-token-type
    @@enDesc:
      The type of the token the parser is encountered.

    @@Method:
      @@@Name: after
      @@@Param:
        @@@@Name: name
        @@@@Type: DOMString
        @@@@enDesc: The name of the method.
      @@@Param:
        @@@@Name: p
        @@@@Type: DISPerl|HASH
        @@@@enDesc: The set of the parameters to the method.
      @@@Param:
        @@@@Name: o
        @@@@Type: DISPerl|HASH
        @@@@enDesc: The option value.
      @@@Return:
        @@@@PerlDef:
          $p->{-result} = $o->{<H::dit|error-token>}->{type}
            if defined $o->{<H::dit|error-token>}->{type};

  @RuleDef:
    @@Name: dit-error-token-value
    @@enDesc:
      The value of the token the parser is encountered, if any.

    @@Method:
      @@@Name: after
      @@@Param:
        @@@@Name: name
        @@@@Type: DOMString
        @@@@enDesc: The name of the method.
      @@@Param:
        @@@@Name: p
        @@@@Type: DISPerl|HASH
        @@@@enDesc: The set of the parameters to the method.
      @@@Param:
        @@@@Name: o
        @@@@Type: DISPerl|HASH
        @@@@enDesc: The option value.
      @@@Return:
        @@@@PerlDef:
          $p->{-result} = $o->{<H::dit|error-token>}->{value}
            if defined $o->{<H::dit|error-token>}->{value};

  @RuleDef:
    @@Name: dit-error-lines
    @@enDesc:
      A copy of fragment of the source text that contains the line
      where the error occurred, if available.
    
    @@Method:
      @@@Name: after
      @@@Param:
        @@@@Name: name
        @@@@Type: DOMString
        @@@@enDesc: The name of the method.
      @@@Param:
        @@@@Name: p
        @@@@Type: DISPerl|HASH
        @@@@enDesc: The set of the parameters to the method.
      @@@Param:
        @@@@Name: o
        @@@@Type: DISPerl|HASH
        @@@@enDesc: The option value.
      @@@Return:
        @@@@PerlDef:
          my $pos = $o-><AG::DOMCore|DOMError.location>
                      -><AG::DOMCore|DOMLocator.utf32Offset>;
          if ($pos > -1) {
            my $src = $o->{<H::dit|source-text>};
            my $start = $pos;
            $start = rindex ($$src, "\x0A", $start - 1) for 0..2;
            $start++;
            my $end = $pos;
            $end = index ($$src, "\x0A", $end + 1) for 0..2;
            $end = length $$src if $end < 0;
            $p->{-result} = substr $$src, $start, $end - $start;
          }
##DITExceptionFormatter

ElementTypeBinding:
  @Name: RuleDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass
    @@rdf:type: Muf2003|RuleDefClass

ElementTypeBinding:
  @Name: RuleParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: Muf2003|RuleParameter

ElementTypeBinding:
  @Name:enMufDef
  @ElementType:
    ecore:defaultMessage
  @ShadowContent:
    @@lang:en
    @@ContentType:
      lang:muf

PropDef:
  @QName: dit|error-token
  @enDesc:
    The token where the parser found an error.

PropDef:
  @QName: dit|source-text
  @enDesc:
    A reference to the original source text, if available.

PropDef:
  @QName: dit|relatedURI
  @enDesc:
    A related URI.

PropDef:
  @QName: dit|resource
  @enDesc:
    A related <QUOTE::dis> resource.

PropDef:
  @QName: dit|namespace-prefix
  @enDesc:
    The namespace prefix.

PropDef:
  @QName: dit|old-definition

PropDef:
  @QName: dit|new-definition

ElementTypeBinding:
  @Name: CParamApp
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      @@@@: DOMCore|DOMConfigurationParameterApplication
      @@@For: ManakaiDOM|DOM
    @@rdf:type:
      @@@@: DISCore|Property
      @@@For: =ManakaiDOM|all
    @@For: ManakaiDOM|DOM3
    @@For: =ManakaiDOM|all

CParamApp:
  @DOMCore:domConfigurationParameter: DOMCore|error-handler
  @DOMCore:targetType: DITParser

ElementTypeBinding:
  @Name: ErrDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DOMCore|DOMErrorType
    @@For: ManakaiDOM|DOM3
    @@ecore:textFormatter: ManakaiDITExceptionFormatter

ErrDef:
  @QName: dit|bad-token-error
  @enDesc:
    The parser is encountered to a token whose type is not
    allowed there.
  @DOMCore:severity: DOMCore|SEVERITY_FATAL_ERROR
  @enMufDef:
    Token |%dit-error-token-type;|%dit-error-token-value
    (prefix => { (|}, suffix => {|)}); is not 
    allowed %dit-error-lines (prefix => {(|}, suffix => {|)});

ErrDef:
  @QName: dit|namespace-prefix-not-defined-error
  @enDesc:
    The namespace prefix is not declared.
  @DOMCore:severity: DOMCore|SEVERITY_ERROR
  @enMufDef:
    Namespace prefix |%p (name => {<Q::dit|namespace-prefix>});| is not defined

ErrDef:
  @QName: dit|bad-error-resource-error
  @enDesc:
    The type of an error resource is not supported.
  @DOMCore:severity: DOMCore|SEVERITY_ERROR
  @enMufDef:
    <%p (name => {<Q::dit|uri>});>: Not an error of supported error type

ErrDef:
  @QName: dit|namespace-prefix-redefined-error
  @enDesc:
    The specified namespace prefix is already bound to a namespace URI.
  @c:severity: c|SEVERITY_ERROR
  @enMufDef:
    Namespace prefix |%p (name => {<Q::dit|namespace-prefix>});| is
    already bound to <%p (name => {<Q::dit|old-definition>});>
