Module:
  @QName: DIS|DIT
  @enFN:
    The DIT <QUOTE::dis> Serialization Format
  @Namespace:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS#DIT/
  
  @enDesc:
    ...

  @DISCore:author: DISCore|Wakaba
  @License: license|Perl+MPL
  @Date:
    $Date: 2006/12/29 02:14:49 $
  
  @Require:
    @@Module:
      @@@QName: DIS|common
    @@Module:
      @@@QName: MDOM|DOMCore
      @@@WithFor: ManakaiDOM|ManakaiDOMLatest
    @@Module:
      @@@QName: MDOM|GenericLS
      @@@WithFor: ManakaiDOM|ManakaiDOMLatest
    @@Module:
      @@@WithFor: ManakaiDOM|ManakaiDOM
    @@Module:
      @@@WithFor: ManakaiDOM|ManakaiDOMLatest
    @@Module:
      @@@QName: Util|DIS
      @@@WithFor: DIS|ForLatest

  @DefaultFor: ManakaiDOM|ManakaiDOMLatest

Namespace:
  @c:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#
  @DIS:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS#
  @dis:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#dis--
  @DISlib:
    http://suika.fam.cx/~wakaba/archive/2004/dis/
  @dit:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS#DIT/
  @domperl:
    http://suika.fam.cx/~wakaba/archive/2006/dom/perl/
  @dtest:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS#Test/
  @dx:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#
  @ecore:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/Core/
  @f:
    http://suika.fam.cx/~wakaba/archive/2004/dom/feature#
  @gls:
    http://suika.fam.cx/~wakaba/archive/2004/dom/gls#
  @idl:
    http://suika.fam.cx/~wakaba/archive/2004/dis/IDL#
  @kwd:
    http://suika.fam.cx/~wakaba/archive/2005/rfc2119/
  @lang:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#
  @license:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/license#
  @ManakaiDOM:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#
  @MDOM:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#ManakaiDOM.
  @rdf:
    http://www.w3.org/1999/02/22-rdf-syntax-ns#
  @rdfs:
    http://www.w3.org/2000/01/rdf-schema#
  @tc:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/DOM/TreeCore/
  @te:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/DOM/Element/
  @test:
    http://suika.fam.cx/~wakaba/archive/2004/dis/Test#
  @Util:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/

## -- Features

ElementTypeBinding:
  @Name: FeatureDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DOMFeature|Feature
    @@For: ManakaiDOM|all

ElementTypeBinding:
  @Name: FeatureVerDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DOMFeature|Feature

ElementTypeBinding:
  @Name: featureQName
  @ElementType:
    DOMFeature:name
  @ShadowContent:
    @@ContentType: DISCore|QName

FeatureDef:
  @QName: DIS|DIT
  @FeatureVerDef:
    @@QName: DIS|DIT10
    @@Version: 1.0
    @@f:requires: c|CoreFeature30
    @@f:instanceOf: DIS|DIT
    @@enFN:
      The DIT Module, Version 1.0

ElementTypeBinding:
  @Name: enDesc
  @ElementType: 
    dis:Description
  @ShadowContent: 
    @@lang:en

ElementTypeBinding:
  @Name: enFN
  @ElementType:
    dis:FullName
  @ShadowContent:
    @@lang:en

ElementTypeBinding:
  @Name: enImplNote
  @ElementType:
    dis:ImplNote
  @ShadowContent:
    @@lang:en

ElementTypeBinding:
  @Name: IFClsDef
  @ElementType: 
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      @@@@: dis|MultipleResource
      @@@ForCheck: !ManakaiDOM|ForIF !ManakaiDOM|ForClass
    @@resourceFor: ManakaiDOM|ForIF
    @@resourceFor: ManakaiDOM|ForClass
    @@For: ManakaiDOM|ManakaiDOM

    @@rdf:type:
      @@@@: DISLang|Interface
      @@@ForCheck: ManakaiDOM|ForIF

    @@rdf:type:
      @@@@: DISLang|Class
      @@@ForCheck: ManakaiDOM|ForClass
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOM||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOMLatest||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOMLatest

    @@f:implements: DIS|DIT10

ElementTypeBinding:
  @Name: IFQName
  @ElementType:
    dis:QName
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForIF

ElementTypeBinding:
  @Name: ClsQName
  @ElementType:
    dis:QName
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: IFISA
  @ElementType:
    dis:ISA
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForIF

ElementTypeBinding:
  @Name: ClsISA
  @ElementType:
    dis:ISA
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: Method
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Method
    @@For: !=ManakaiDOM|ManakaiDOM

ElementTypeBinding:
  @Name: Return
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|MethodReturn

ElementTypeBinding:
  @Name: Param
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|MethodParameter

ElementTypeBinding:
  @Name: Attr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Attribute
    @@For: !=ManakaiDOM|ManakaiDOM

ElementTypeBinding:
  @Name: Get
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|AttributeGet

ElementTypeBinding:
  @Name: Set
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|AttributeSet

## -- Implementation

IFClsDef: 
  @IFQName: DITImplementation
  @ClsQName: ManakaiDITImplementation

  @domperl:implementedByObjectsOf: c|DOMImplementation
  @domperl:classImplementedByObjectsOf: c|ManakaiDOMImplementation

##DITImplementation

ElementTypeBinding:
  @Name: NamedParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:MethodParameter
    @@DISPerl:isNamedParameter:1

ResourceDef:
  @QName: DOMString
  @AliasFor: str|DOMString
  @For: ManakaiDOM|ManakaiDOM

ResourceDef:
  @QName: Node
  @AliasFor: tc|Node
  @For: ManakaiDOM|ManakaiDOM

ElementTypeBinding:
  @Name: PerlDef
  @ElementType:
    dis:Def
  @ShadowContent:
    @@ContentType: lang|Perl
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: InCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:InCase

ElementTypeBinding:
  @Name: nullCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:InCase
    @@Value:
      @@@is-null:1
      @@@ContentType: DISCore|String

ElementTypeBinding:
  @Name: TrueCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:InCase
    @@Value:
      @@@@: 1
      @@@ContentType: DISCore|Boolean
    @@Type: idl|boolean||ManakaiDOM|all

ElementTypeBinding:
  @Name: FalseCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:InCase
    @@Value:
      @@@@: 0
      @@@ContentType: DISCore|Boolean
    @@Type: idl|boolean||ManakaiDOM|all

IFClsDef:
  @IFQName: DITException
  @ClsQName: ManakaiDITException

  @rdf:type:
    @@@: dx|Interface
    @@ForCheck: ManakaiDOM|ForIF

  @rdf:type:
    @@@: dx|Class
    @@ForCheck: ManakaiDOM|ForClass

  @ClsISA: dx|Exception||ManakaiDOM|Perl
  @dx:implementedBy: ||ManakaiDOM|ManakaiDOMLatest||ManakaiDOM|ForClass

  @ResourceDef:
    @@QName: DITExceptionCode
    @@ForCheck: ManakaiDOM|ForIF
    @@rdf:type: DISLang|ConstGroup

    @@enDesc:
      Exception codes for <IF::DITException>. 

    @@Type: idl|unsignedShort||ManakaiDOM|all
    @@rdfs:subClassOf: idl|unsignedShort||ManakaiDOM|all

    @@ResourceDef:
      @@@QName: dit|PARSE_ERR
      @@@DISCore:resourceType: dx|ErrorCode
      @@@Value:
        @@@@@: 81
        @@@@ContentType: DISCore|Integer
      @@@enDesc:
        An attempt was made to load a DIT document and
        the processing has been stopped.
##DITException

ElementTypeBinding:
  @Name: RPropDef:
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISSource|Property
    @@For: =ManakaiDOM|all

ElementTypeBinding:
  @Name: SPropDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISSource|Property
    @@rdf:type: DISSource|ResourceProperty
    @@For: =ManakaiDOM|all

IFClsDef:
  @IFQName: DITParser
  @ClsQName: ManakaiDITParser

  @Implement: ecore|MUErrorTarget||ManakaiDOM|Perl

  @DISLang:role: gls|ParserRole

  @f:implements: DIS|DIT10

  @enDesc:
    A <IF::DITParser> object parses a DIT source document and
    returns it as an object. 

    A <IF::DITParser> object can be retrieved by 
    <M::GenericLS|GLSImplementation.createGLSParer>

  @Attr:
    @@Name: domConfig
    @@enDesc:
      The configuration of the parser.

    @@Get:
      @@@Type: c|DOMConfiguration
      @@@enDesc: The DOM configuration object.
      @@@PerlDef:
        __CODE{c|getConfigObject::
          $target => $self,
          $targetHash => $self,
          $targetType => {<IFName::DITParser>},
          $result => $r,
        }__;

  @Method:
    @@ManakaiDOM:isForInternal:1
    @@ForCheck: ManakaiDOM|ForClass
    @@Operator: DISPerl|NewMethod
    @@enDesc:
      Creates a new instance of the object.
    @@Param:
      @@@Name: impl
      @@@Type: gls|GLSImplementation
      @@@enDesc:
        The implementation from which the parser is created.
    @@Param:
      @@@Name: features
      @@@Type: DOMString
      @@@dis:actualType: f|FeaturesString
      @@@enDesc:
        The set of features requested for the parser.
    @@Return:
      @@@Type: DOMMain|DOMObject
      @@@enDesc:
        The newly created parser.
      @@@PerlDef:
        $r = bless {
          <H::f|implementation> => $impl,
        }, $self;

  @Method:
    @@Name: parseString
    @@enDesc:
      Parses a string as DIT textual definition and
      merge resources included there into a <QUOTE::dis> database.
    @@Param:
      @@@Name: sourceText
      @@@Type: DOMString
      @@@enDesc:
        The text to parse.
    @@Param:
      @@@Name: disDatabase
      @@@Type: DISDatabase
      @@@enDesc:
        The <QUOTE::dis> database object to which the
        loaded resources will belong.
    @@Return:
      @@@Type: DISModule
      @@@enDesc:
        The <QUOTE::dis> module object generated from the
        <P::sourceText>.
      @@@dx:raises:
        @@@@@: dit|PARSE_ERR
        @@@@enDesc:
          <kwd:MUST> be thrown if the DIT document contains one or more error.
      @@@PerlDef:
        $self->{char} = [];
        $self->{token} = [];
        $self->{source} = $sourceText;
        $self->{location} = {};
        __DEEP{
          $r = $self->_parse_document;
        }__;

  @Method:
    @@Name: shiftChar
    @@ManakaiDOM:isForInternal:1
    @@ForCheck: ManakaiDOM|ForClass
    @@enDesc:
      Returns the next character.
    @@Return:
      @@@Type: idl|long||ManakaiDOM|all
      @@@enDesc:
        The code position number of the next character, if any,
        or <CODE::-2>.
      @@@PerlDef:
        if (@{$self->{char}}) {
          $r = shift @{$self->{char}};
        } else {
          my $char = substr ($self->{source}, pos ($self->{source}), 1);
          pos ($self->{source})++;

          if (length $char) {
            $r = ord $char;
          } else {
            $r = -1;
          }
        }

  @Method:
    @@ManakaiDOM:isForInternal: 1
    @@Operator: ManakaiDOM|MUErrorHandler
    @@enDesc:
      When a <IF::ecore|ErrorInterface||ManakaiDOM|Perl> is <Perl::report>ed,
      then this method is invoked.
      
      The method calls the <cfg::DOMCore|error-handler> if the error is of 
      <IF::DOMCore|DOMError>.  Otherwise, the error is re-thrown so that
      corresponding <Perl::catch> clause, if any, can catch the error.
    @@Param:
      @@@Name: err
      @@@Type: ecore|ErrorInterface||ManakaiDOM|Perl
      @@@enDesc:
        The reported error object.
    @@Return:
      @@@Type: DISPerl|Any
      @@@enDesc:
        If the <P::err> is a <IF::DOMCore|DOMError>, then the return value
        of the error handler.

           {NOTE:: If the error is thrown, the method never returns.
           }
      @@@nullCase:
        @@@@enDesc:
          No error handler.
      @@@PerlDef:
        if ($err->isa (<IFName::DOMCore|DOMError||ManakaiDOM|ManakaiDOM>)) {
          __DEEP{
            A: {
              my $cfg = $self-><AG::TDTParser.domConfig>;
              my $h = $cfg-><M::DOMCore|DOMConfiguration.getParameter>
                               ('error-handler');
              $r = $h-><M::DOMCore|DOMErrorHandler.handleError> ($err);
            } # A
          }__;
        } else {
          $err-><M::ecore|ErrorInterface||ManakaiDOM|Perl.throw>;
        }

  @DISPerl:dpgDef:
    lexmode default : initial : standalone {

      /* Name */
      $name-start-char := [U+0041..U+005A U+0061..U+007A];
      $name-char       := [U+0041..U+005A U+0061..U+007A U+0030..U+0039 '-' '_'];
      NAME : value := $name-start-char $name-char*;

      /* At-keyword */
      ATKEYWORD : value := ['@'] $name-start-char $name-char*;

      /* Block */
      LBRACE := ['{'];
      RBRACE := ['}'];

      /* Declaration */
      COLON := [':'];
      SEMICOLON := [';'];

      /* String */
      STRING : value := [U+0027] [^U+0027]* [U+0027];
      $hexdigit := [U+0030..U+0039 U+0041..U+0046 U+0061..U+0066];
      CHAR : value := ['U'] ['+'] $hexdigit $hexdigit $hexdigit $hexdigit
                                  $hexdigit? $hexdigit?;

      /* Number */
      MINUS := ['-'];
      DNUM : value := [U+0030..U+0039]+;
      XNUM : value := ['0'] ['x']
                      [U+0030..U+0039 U+0041..U+0046 U+0061..U+0066 '_']+;
      BNUM : value := ['0'] ['b'] ['0' '1' '_']+;

      /* Functional notation */
      COMMA := [','];
      LPAREN := ['('];
      RPAREN := [')'];

      /* Range */
      RANGE := ['.'] ['.'];

      /* URI */
      URI : value := ['<'] [^'<' '>' '[' ']'] [^'<' '>']* ['>'];
      QNAME : value := ['<'] ['['] [^'<' '>' '[' ']']* [']'] ['>'];
      TFQNAMES : value := ['<'] ['['] ['['] [^'<' '>' '[' ']']*
                          [']'] [']'] ['>'];
      
      /* Ignored white space */
      WSP : ignore := [U+0009..U+000D U+0020]+;

      /* Ignored comment */
      COMMENT1 : ignore := ['/'] ['/'] [^U+000A..U+000D]* [U+000A..U+000D]*;
      $comment2 := [^'/' '*'] [^'*']* ['*']+;
      COMMENT2 : ignore := ['/'] ['*'] [^'*']* ['*']+ $comment2* ['/'];

    } // lexmode default

    /*
      A DIT Document (|lang:dit|).
    */
    rule document : standalone : recursive {
      /*
        document := *at-namespace *(declaration / block)

        declaration := 
        block := 

        at-namespace := '@namespace' NAME uri SEMICOLON
            / '@namespace' uri SEMICOLON

        uri := URI / QNAME / TFQNAMES

        cwsp := WSP / COMMENT1 / COMMENT2
          ;; allowed everywhere
      */

      my $node : return;
      lang:Perl {
        $node = {
        };
      }

      ~ (NAME) {
        lang:Perl ($v => $token.value) {
          $node->{node_type} = $v;
        }
      }

      ~ (LBRACE) { }

      &_node ($node => $node);

      ~ (#EOF) { }
    } // document

    /*
      A TDT Error Description Document (|lang:tdterr|).

        tdterr := any-err-type-qname "{" position *(attribute / empty-statement)
                                     "}"
        any-err-type-qname := QName ;; References a |ecore:AnyErrorCode|.
        position := [QName / URI] ["(" number "," number ")"
                                   [".." "(" number "," number ")"]] ";"
    */
    rule tdterr : standalone {
      my $err : return;

      ~ (TFQNames) {
        lang:Perl ($v => $token.value) : has-error {
          my $disq = substr ($v, 3, length ($v) - 6);
          my $erruri;
          try {
            $erruri = $self->{ns_resolver_dis}
                           ->tfqnames_to_uri ($disq, $self->{default_t},
                                                     $self->{default_f});
          } catch Message::Util::Error with {
            my $err = shift;
            if ($err->can ('subtype') and
                $err->subtype eq <Q::DIS:UNDECLARED_NS_PREFIX_ERR
                                   ::SuikaWikiConfig21:ForLatest>) {
              my $location = {
                utf32_offset => pos ($self->{source}),
              };
              my $continue =
              __DOMCore:ERROR{dtest|undeclared-namespace-prefix-error::
                dtest|error-token => {$token},
                DOMCore|location => {$location},
                dtest|source-text => {\($self->{source})},
                dtest|qname => {$disq},
              }__;
              unless ($continue) {
                __EXCEPTION{dtest|PARSE_ERR::
                }__;
              }
              $erruri = $disq;
            } else {
              $err->throw;
            }
          };
          my $errres = $self->{dis_database}->get_resource ($erruri);
          $errres->is_referred (true);
          if ($errres->is_type_uri (<Q::dx|ErrorSubCode>)) {
            $err->{subtype} = {
              type => 'string',
              value => $errres->name_uri,
            };
          } elsif ($errres->is_type_uri (<Q::dx|ErrorCode>)) {
            $err->{type} = {
              type => 'string',
              value => $errres->local_name,
            };
          } elsif ($errres->is_type_uri (<Q::DOMCore|DOMErrorType>)) {
            $err->{type} = {
              type => 'string',
              value => $errres->get_property_text
                                  (<Q::DOMCore|errorType>, $errres->name_uri),
            },
          } else {
            my $location = {
              utf32_offset => pos ($self->{source}),
            };
            my $continue = __DOMCore:ERROR{dtest|bad-error-resource-error::
              dtest|error-token => {$token},
              DOMCore|location => {$location},
              dtest|source-text => {\($self->{source})},
              dtest|qname => {$disq},
              dtest|relatedURI => {$erruri},
              dtest|resource => {$errres},
            }__;
            unless ($continue) {
              __EXCEPTION{dtest|PARSE_ERR::
              }__;
            }
          }
        }
      }

      ~ (LBRACE) { }

      my $has_pos;

      ~? (QName) {
        lang:Perl ($v => $token.value) {
          my $disq = substr ($v, 2, length ($v) - 4);
          my $erruri;
          try {
            $erruri = $self->{ns_resolver_dis}->qname_to_uri ($disq);
          } catch Message::Util::Error with {
            my $err = shift;
            if ($err->can ('subtype') and
                $err->subtype eq <Q::DIS:UNDECLARED_NS_PREFIX_ERR
                                   ::SuikaWikiConfig21:ForLatest>) {
              my $location = {
                utf32_offset => pos ($self->{source}),
              };
              my $continue =
              __DOMCore:ERROR{dtest|undeclared-namespace-prefix-error::
                dtest|error-token => {$token},
                DOMCore|location => {$location},
                dtest|source-text => {\($self->{source})},
                dtest|qname => {$disq},
              }__;
              unless ($continue) {
                __EXCEPTION{dtest|PARSE_ERR::
                }__;
              }
              $erruri = $disq;
            } else {
              $err->throw;
            }
          };
          $err->{location}->{type} = 'DOMLocator';
          $err->{location}->{uri} = $erruri;
          $has_pos = true;
        }
      } (URI) {
        lang:Perl ($v => $token.vakue) {
          $err->{location}->{type} = 'DOMLocator';
          $err->{location}->{uri}
            = {type => 'string', value => substr ($v, length ($v) - 2)};
          $has_pos = true;
        }
      }

      ~? (LPAREN) {
        ~ (DNUM) {
          lang:Perl ($v => $token.value) {
            $err->{location}->{type} = 'DOMLocator';
            $err->{location}->{_line_column} = {l1 => 0+$v, l2 => 0+$v};
          }
        } (XNUM) {
          lang:Perl ($v => $token.value) {
            $err->{location}->{type} = 'DOMLocator';
            $err->{location}->{_line_column} = {l1 => hex $v, l2 => hex $v};
          }
        } (BNUM) {
          lang:Perl ($v => $token.value) {
            $err->{location}->{type} = 'DOMLocator';
            $err->{location}->{_line_column} = {l1 => eval $v, l2 => eval $v};
          }
        }
        ~ (COMMA) { }
        ~ (DNUM) {
          lang:Perl ($v => $token.value) {
            $err->{location}->{_line_column}->{c1} =
            $err->{location}->{_line_column}->{c2} = 0+ $v;
          }
        } (XNUM) {
          lang:Perl ($v => $token.value) {
            $err->{location}->{_line_column}->{c1} =
            $err->{location}->{_line_column}->{c2} = hex $v;
          }
        } (BNUM) {
          lang:Perl ($v => $token.value) {
            $err->{location}->{_line_column}->{c1} =
            $err->{location}->{_line_column}->{c2} = eval $v;
          }
        }
        ~ (RPAREN) { }

        ~? (RANGE) {
          ~ (LPAREN) { }
          ~ (DNUM) {
            lang:Perl ($v => $token.value) {
              $err->{location}->{_line_column}->{l2} = 0+ $v;
            }
          } (XNUM) {
            lang:Perl ($v => $token.value) {
              $err->{location}->{_line_column}->{l2} = hex $v;
            }
          } (BNUM) {
            lang:Perl ($v => $token.value) {
              $err->{location}->{_line_column}->{l2} = eval $v;
            }
          }
          ~ (COMMA) { }
          ~ (DNUM) {
            lang:Perl ($v => $token.value) {
              $err->{location}->{_line_column}->{c2} = 0+ $v;
            }
          } (XNUM) {
            lang:Perl ($v => $token.value) {
              $err->{location}->{_line_column}->{c2} = hex $v;
            }
          } (BNUM) {
            lang:Perl ($v => $token.value) {
              $err->{location}->{_line_column}->{c2} = eval $v;
            }
          }
          ~ (RPAREN) { }
        }

        lang:Perl { $has_pos = true; }
      }

      if-true ($has_pos) {
        ~ (SEMICOLON) { }
      }

      &_node ($node => $err);

      ~ (#EOF) { }
    }

    rule _node ($node) : standalone : recursive {
      // ~ (NAME) { }
      // ~ (LBRACE) { }

      ~* (NAME) {
        my $name;
        lang:Perl ($v => $token.value) {
          $name = $v;
        }

        ~ (COLON) {
          &_attribute ($node => $node, $name => $name);
        } (LBRACE) {
          my $subnode;
          lang:Perl {
            $subnode = {
              node_type => $name,
            };
            if ($name eq 'attribute') {
              push @{$node->{attributes}||=[]}, $subnode;
            } elsif ($name eq 'element-type-definition') {
              push @{$node->{element_types}||=[]}, $subnode;
            } elsif ($name eq 'attribute-definition') {
              push @{$node->{attribute_definitions}||=[]}, $subnode;
            } elsif ($name eq 'general-entity') {
              push @{$node->{general_entities}||=[]}, $subnode;
            } elsif ($name eq 'notation') {
              push @{$node->{notations}||=[]}, $subnode;
            } elsif ($name eq 'namespace') {
              push @{$node->{namespaces}||=[]}, $subnode;
            } else {
              push @{$node->{child_nodes}||=[]}, $subnode;
            }
          }
          &_node ($node => $subnode);
        }
      } (SEMICOLON) { }

      ~ (RBRACE) { }

    } // _node

    rule _attribute ($node, $name) {
      /*
        attribute := attribute-name ":" attribute-value ";"
        attribute-name := NAME
        attribute-value := 'null' / 'true' / 'false'
                         / string
                         / number
                         / 'const' "(" NAME ")"
                         / 'DOMStringList' "(" [string] *("," string) [","] ")"
                         / 'TypeInfo' "(" [string / 'null']
                                          *("," (string / 'null')) [","] ")"
        string := 1*(STRING / CHAR)
        number := DNUM / HNUM / BNUM
      */
 
      // ~ (NAME) { }
      // ~ (COLON) { }

      lang:Perl {
        $name =~ tr/-/_/;
      }

      ~ (NAME == 'null') {
        lang:Perl {
          $node->{$name} = {type => 'nu'.'ll'};
        }
      } (NAME == 'true') {
        lang:Perl {
          $node->{$name} = {type => 'boolean', value => 1};
        }
      } (NAME == 'false') {
        lang:Perl {
          $node->{$name} = {type => 'boolean', value => 0};
        }
      } (STRING) {
        lang:Perl ($v => $token.value) {
          $node->{$name} = {type => 'string',
                            value => substr ($v, 1, length ($v) - 2)};
        }

        ~* (STRING) {
          lang:Perl ($v => $token.value) {
            $node->{$name}->{value} .= substr ($v, 1, length ($v) - 2);
          }
        } (CHAR) {
          lang:Perl ($v => $token.value) {
            $node->{$name}->{value} .= chr hex substr ($v, 2);
          }
        }
      } (CHAR) {
        lang:Perl ($v => $token.value) {
          $node->{$name} = {type => 'string',
                            value => chr hex substr ($v, 2)};
        }

        ~* (STRING) {
          lang:Perl ($v => $token.value) {
            $node->{$name}->{value} .= substr ($v, 1, length ($v) - 2);
          }
        } (CHAR) {
          lang:Perl ($v => $token.value) {
            $node->{$name}->{value} .= chr hex substr ($v, 2);
          }
        }
      } (DNUM) {
        lang:Perl ($v => $token.value) {
          $node->{$name} = {type => 'number', value => 0+$v};
        }
      } (XNUM) {
        lang:Perl ($v => $token.value) {
          $node->{$name} = {type => 'number', value => hex $v};
        }
      } (BNUM) {
        lang:Perl ($v => $token.value) {
          $node->{$name} = {type => 'number', value => eval $v};
        }
      } (NAME == 'const') {
        ~ (LPAREN) { }

        ~ (NAME) {
          lang:Perl ($v => $token.value) {
            $node->{$name} = {type => 'const', value => $v};
          }
        }

        ~ (RPAREN) { }
      } (NAME == 'DOMStringList') {
        my $list;
        lang:Perl {
          $node->{$name} = {type => 'DOMStringList', value => ($list = [])};
        }

        ~ (LPAREN) { }

        ~* (STRING) {
          lang:Perl ($v => $token.value) {
            push @$list, substr ($v, 1, length ($v) - 2);
          }
          ~* (STRING) {
            lang:Perl ($v => $token.value) {
              $list->[-1] .= substr ($v, 1, length ($v) - 2);
            }
          } (CHAR) {
            lang:Perl ($v => $token.value) {
              $list->[-1] .= chr hex substr ($v, 2);
            }
          }
        } (CHAR) {
          lang:Perl ($v => $token.value) {
            push @$list, chr hex substr ($v, 2);
          }
          ~* (STRING) {
            lang:Perl ($v => $token.value) {
              $list->[-1] .= substr ($v, 1, length ($v) - 2);
            }
          } (CHAR) {
            lang:Perl ($v => $token.value) {
              $list->[-1] .= chr hex substr ($v, 2);
            }
          }
        } (COMMA) : separator : terminator? { }

        ~ (RPAREN) { }
      } (NAME == 'TypeInfo') {
        my $list;
        lang:Perl {
          $node->{$name} = {type => 'TypeInfo', value => ($list = [])};
        }

        ~ (LPAREN) { }

        ~* (STRING) {
          lang:Perl ($v => $token.value) {
            push @$list, substr ($v, 1, length ($v) - 2);
          }
          ~* (STRING) {
            lang:Perl ($v => $token.value) {
              $list->[-1] .= substr ($v, 1, length ($v) - 2);
            }
          } (CHAR) {
            lang:Perl ($v => $token.value) {
              $list->[-1] .= chr hex substr ($v, 2);
            }
          }
        } (CHAR) {
          lang:Perl ($v => $token.value) {
            push @$list, chr hex substr ($v, 2);
          }
          ~* (STRING) {
            lang:Perl ($v => $token.value) {
              $list->[-1] .= substr ($v, 1, length ($v) - 2);
            }
          } (CHAR) {
            lang:Perl ($v => $token.value) {
              $list->[-1] .= chr hex substr ($v, 2);
            }
          }
        } (NAME == 'null') {
          lang:Perl {
            push @$list, null;
          }
        } (COMMA) : separator : terminator? { }

        ~ (RPAREN) { }
      }

      ~ (SEMICOLON) { }
    } // _attribute

    token-error default : default {
      lang:Perl {
        my $location = {
          utf32_offset => pos ($self->{source}),
        };
        my $continue = __DOMCore:ERROR{dtest|bad-token-error::
          dtest|error-token => {$token},
          DOMCore|location => {$location},
          dtest|source-text => {\($self->{source})},
        }__;
        unless ($continue) {
          __EXCEPTION{dtest|PARSE_ERR::
          }__;
        }
        $self->{has_error} = true;
      }
    } // token-error default
##TDTParser

IFClsDef:
  @IFQName: DTExceptionFormatter
  @ClsQName: ManakaiDTExceptionFormatter

  @ClsISA: ecore|MUErrorFormatter||ManakaiDOM|Perl

  @RuleDef:
    @@Name: tdt-error-token-type
    @@enDesc:
      The type of the token the parser is encountered.

    @@Method:
      @@@Name: after
      @@@Param:
        @@@@Name: name
        @@@@Type: DOMString
        @@@@enDesc: The name of the method.
      @@@Param:
        @@@@Name: p
        @@@@Type: DISPerl|HASH
        @@@@enDesc: The set of the parameters to the method.
      @@@Param:
        @@@@Name: o
        @@@@Type: DISPerl|HASH
        @@@@enDesc: The option value.
      @@@Return:
        @@@@PerlDef:
          $p->{-result} = $o->{<H::dtest|error-token>}->{type}
            if defined $o->{<H::dtest|error-token>}->{type};

  @RuleDef:
    @@Name: tdt-error-token-value
    @@enDesc:
      The value of the token the parser is encountered, if any.

    @@Method:
      @@@Name: after
      @@@Param:
        @@@@Name: name
        @@@@Type: DOMString
        @@@@enDesc: The name of the method.
      @@@Param:
        @@@@Name: p
        @@@@Type: DISPerl|HASH
        @@@@enDesc: The set of the parameters to the method.
      @@@Param:
        @@@@Name: o
        @@@@Type: DISPerl|HASH
        @@@@enDesc: The option value.
      @@@Return:
        @@@@PerlDef:
          $p->{-result} = $o->{<H::dtest|error-token>}->{value}
            if defined $o->{<H::dtest|error-token>}->{value};

  @RuleDef:
    @@Name: tdt-error-lines
    @@enDesc:
      A copy of fragment of the source text that contains the line
      where the error occurred, if available.
    
    @@Method:
      @@@Name: after
      @@@Param:
        @@@@Name: name
        @@@@Type: DOMString
        @@@@enDesc: The name of the method.
      @@@Param:
        @@@@Name: p
        @@@@Type: DISPerl|HASH
        @@@@enDesc: The set of the parameters to the method.
      @@@Param:
        @@@@Name: o
        @@@@Type: DISPerl|HASH
        @@@@enDesc: The option value.
      @@@Return:
        @@@@PerlDef:
          my $pos = $o-><AG::DOMCore|DOMError.location>
                      -><AG::DOMCore|DOMLocator.utf32Offset>;
          if ($pos > -1) {
            my $src = $o->{<H::dtest|source-text>};
            my $start = $pos;
            $start = rindex ($$src, "\x0A", $start - 1) for 0..2;
            $start++;
            my $end = $pos;
            $end = index ($$src, "\x0A", $end + 1) for 0..2;
            $end = length $$src if $end < 0;
            $p->{-result} = substr $$src, $start, $end - $start;
          }
##DPGExceptionFormatter

ElementTypeBinding:
  @Name: RuleDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass
    @@rdf:type: Muf2003|RuleDefClass

ElementTypeBinding:
  @Name: RuleParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: Muf2003|RuleParameter

ElementTypeBinding:
  @Name:enMufDef
  @ElementType:
    ecore:defaultMessage
  @ShadowContent:
    @@lang:en
    @@ContentType:
      lang:muf

PropDef:
  @QName: dtest|error-token
  @enDesc:
    The token where the parser found an error.

PropDef:
  @QName: dtest|source-text
  @enDesc:
    A reference to the original source text, if available.

PropDef:
  @QName: dtest|relatedURI
  @enDesc:
    A related URI.

PropDef:
  @QName: dtest|resource
  @enDesc:
    A related <QUOTE::dis> resource.

PropDef:
  @QName: dtest|qname
  @enDesc:
    A related <QUOTE::dis> QName.

ElementTypeBinding:
  @Name: CParamApp
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      @@@@: DOMCore|DOMConfigurationParameterApplication
      @@@For: ManakaiDOM|DOM
    @@rdf:type:
      @@@@: DISCore|Property
      @@@For: =ManakaiDOM|all
    @@For: ManakaiDOM|DOM3
    @@For: =ManakaiDOM|all

CParamApp:
  @DOMCore:domConfigurationParameter: DOMCore|error-handler
  @DOMCore:targetType: TDTParser

ElementTypeBinding:
  @Name: ErrDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DOMCore|DOMErrorType
    @@For: ManakaiDOM|DOM3
    @@ecore:textFormatter: ManakaiDTExceptionFormatter

ErrDef:
  @QName: dtest|bad-token-error
  @enDesc:
    The parser is encountered to a token whose type is not
    allowed there.
  @DOMCore:severity: DOMCore|SEVERITY_FATAL_ERROR
  @enMufDef:
    Token |%tdt-error-token-type;|%tdt-error-token-value
    (prefix => { (|}, suffix => {|)}); is not 
    allowed %tdt-error-lines (prefix => {(|}, suffix => {|)});

ErrDef:
  @QName: dtest|undeclared-namespace-prefix-error
  @enDesc:
    The namespace prefix is not declared.
  @DOMCore:severity: DOMCore|SEVERITY_ERROR
  @enMufDef:
    |%p (name => {<Q::dtest:qname>});|: Namespace prefix is not declared

ErrDef:
  @QName: dtest|bad-error-resource-error
  @enDesc:
    The type of an error resource is not supported.
  @DOMCore:severity: DOMCore|SEVERITY_ERROR
  @enMufDef:
    <%p (name => {<Q::dtest:uri>});>: Not an error of supported error type
