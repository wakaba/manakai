Module:
  @QName: Markup|H2H
  @enFN:
    H2H/0.9 and H2H/1.0 Document Markup Language DOM
  @enDesc:
      {TODO::

      }

  @Namespace:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Markup/H2H/

  @DISCore:author: DISCore|Wakaba
  @License: license|Perl+MPL
  @Date:
    $Date: 2006/12/30 08:27:49 $

  @Require:
    @@Module:
      @@@QName: Markup|common
    @@Module:
      @@@QName: MDOM|TreeCore
    @@Module:
      @@@QName: Markup|Atom

Namespace:
  @aa:
    http://pc5.2ch.net/test/read.cgi/hp/1096723178/aavocab#
  @c:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#
  @cfg:
    http://suika.fam.cx/www/2006/dom-config/
  @dis:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#dis--
  @doc:
    http://suika.fam.cx/~wakaba/archive/2005/7/tutorial#
  @d:
    http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#
  @DOMMain:
    http://suika.fam.cx/~wakaba/archive/2004/dom/main#
  @dx:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#
  @ecore:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/Core/
  @f:
    http://suika.fam.cx/~wakaba/archive/2004/dom/feature#
  @fe:
    http://suika.fam.cx/www/2006/feature/
  @gls:
    http://suika.fam.cx/~wakaba/archive/2004/dom/gls#
  @h2h:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Markup/H2H/
  @html:
    http://www.w3.org/1999/xhtml
  @idl:
    http://suika.fam.cx/~wakaba/archive/2004/dis/IDL#
  @kwd:
    http://suika.fam.cx/~wakaba/archive/2005/rfc2119/
  @lang:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#
  @license:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/license#
  @ManakaiDOM:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#
  @Markup:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Markup#
  @mat:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Markup/Atom/
  @MDOM:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#ManakaiDOM.
  @MDOMX:
    http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#
  @dlp:
    http://suika.fam.cx/~wakaba/archive/2004/dis/Perl#
  @html3:
    urn:x-suika-fam-cx:markup:ietf:html:3:draft:00:
  @html5:
    http://www.w3.org/1999/xhtml
  @rel:
    http://www.iana.org/assignments/relation/
  @s:
    http://suika.fam.cx/~wakaba/archive/2004/dis/Markup#
  @sw09:
    urn:x-suika-fam-cx:markup:suikawiki:0:9:
  @sw010:
    urn:x-suika-fam-cx:markup:suikawiki:0:10:
  @tc:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/DOM/TreeCore/
  @td:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/DOM/Document/
  @te:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/DOM/Element/
  @test:
    http://suika.fam.cx/~wakaba/archive/2004/dis/Test#
  @tx:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/DOM/XML/
  @urigen:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/URI/Generic/
  @xhtml2:
    http://www.w3.org/2002/06/xhtml2/
  @xml:
    http://www.w3.org/XML/1998/namespace
  @xmlns:
    http://www.w3.org/2000/xmlns/

ElementTypeBinding:
  @Name: CODE
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: dlp|BlockCode
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: Method
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|Method

ElementTypeBinding:
  @Name: Param
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|MethodParameter

ElementTypeBinding:
  @Name: Return
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|MethodReturn

ElementTypeBinding:
  @Name: Attr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|Attribute

ElementTypeBinding:
  @Name: Get
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|AttributeGet

ElementTypeBinding:
  @Name: Set
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|AttributeSet

ElementTypeBinding:
  @Name: nullCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: ManakaiDOM|InCase
    @@Value:
      @@@is-null:1

ElementTypeBinding:
  @Name: PerlDef
  @ElementType:
    dis:Def
  @ShadowContent:
    @@ContentType: lang|Perl
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: PerlCDef
  @ElementType:
    dis:Def
  @ShadowContent:
    @@ContentType: lang|Perl

ElementTypeBinding:
  @Name: enImplNote
  @ElementType:
    dis:ImplNote
  @ShadowContent:
    @@lang:en

ElementTypeBinding:
  @Name: enFN
  @ElementType:
    dis:FullName
  @ShadowContent:
    @@lang:en

ElementTypeBinding:
  @Name: PTests
  @ElementType: 
    dis:ResourceDef
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass
    @@DISCore:resourceType: test|ParserTestSet

ElementTypeBinding:
  @Name: PTest
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass
    @@DISCore:resourceType: test|ParserTest

ElementTypeBinding:
  @Name: DEnt
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: test|RootEntity

ElementTypeBinding:
  @Name: IFClsETDef
  @ElementType: 
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType:
      @@@@: dis|MultipleResource
      @@@ForCheck: !ManakaiDOM|ForIF !ManakaiDOM|ForClass !s|ForML
    @@resourceFor: ManakaiDOM|ForIF
    @@resourceFor: ManakaiDOM|ForClass
    @@resourceFor: s|ForML

    @@DISCore:resourceType:
      @@@@: DISLang|Interface
      @@@ForCheck: ManakaiDOM|ForIF

    @@DISCore:resourceType:
      @@@@: DISLang|Class
      @@@ForCheck: ManakaiDOM|ForClass

    @@Implement:
      @@@@: ||+||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass

    @@s:elementType:
      @@@@: ||+||s|ForML
      @@@ContentType: DISCore|TFPQNames
      @@@DISCore:stopISARecursive:1

    @@DISCore:resourceType:
      @@@@: s|ElementType
      @@@ForCheck: s|ForML

    @@f:implements: AtomFeature10

ElementTypeBinding:
  @Name: IFClsDef
  @ElementType: 
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType:
      @@@@: dis|MultipleResource
      @@@ForCheck: !ManakaiDOM|ForIF !ManakaiDOM|ForClass !s|ForML
    @@resourceFor: ManakaiDOM|ForIF
    @@resourceFor: ManakaiDOM|ForClass

    @@DISCore:resourceType:
      @@@@: DISLang|Interface
      @@@ForCheck: ManakaiDOM|ForIF

    @@DISCore:resourceType:
      @@@@: DISLang|Class
      @@@ForCheck: ManakaiDOM|ForClass

    @@Implement:
      @@@@: ||+||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass

    @@f:implements: AtomFeature10

ElementTypeBinding:
  @Name: IFQName
  @ElementType:
    dis:QName
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForIF

ElementTypeBinding:
  @Name: ClsQName
  @ElementType:
    dis:QName
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: ETRQName
  @ElementType:
    dis:QName
  @ShadowContent:
    @@ForCheck: s|ForML

ElementTypeBinding:
  @Name: ETQName
  @ElementType:
    dis:AppName
  @ShadowContent:
    @@ForCheck: s|ForML
    @@ContentType: DISCore|QName

ElementTypeBinding:
  @Name: IFISA
  @ElementType:
    dis:ISA
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForIF

ElementTypeBinding:
  @Name: ClsISA
  @ElementType:
    dis:ISA
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: disDef
  @ElementType:
    dis:Def
  @ShadowContent:
    @@ContentType:
      lang:dis
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: Code
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: dlp|InlineCode
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: Test
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: test|StandaloneTest
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: TestC
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: test|StandaloneTest

ResourceDef:
  @QName: Document
  @AliasFor: td|Document

ResourceDef:
  @QName: Element
  @AliasFor: te|Element

ResourceDef:
  @QName: Attr
  @AliasFor: te|Attr

ResourceDef:
  @QName: DOMString
  @AliasFor: DOMMain|DOMString

ResourceDef:
  @QName: DOMURI
  @AliasFor: ManakaiDOM|ManakaiDOMURI

ResourceDef:
  @QName: DOMTimeStamp
  @AliasFor: DOMMain|DOMTimeStamp

ResourceDef:
  @QName: boolean
  @AliasFor: idl|boolean||ManakaiDOM|all

ResourceDef:
  @QName: Node
  @AliasFor: tc|Node

ResourceDef:
  @QName: NodeList
  @AliasFor: tc|NodeList

ResourceDef:
  @QName: StaticNodeList
  @AliasFor: tc|StaticNodeList

ElementTypeBinding:
  @Name: enDesc
  @ElementType:
    dis:Description
  @ShadowContent:
    @@lang:en

ElementTypeBinding:
  @Name: TrueCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType:
      ManakaiDOM:InCase
    @@Value:
      @@@@: 1
      @@@ContentType: DISCore|Boolean
    @@Type: idl|boolean||ManakaiDOM|all

ElementTypeBinding:
  @Name: FalseCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType:
      ManakaiDOM:InCase
    @@Value:
      @@@@: 0
      @@@ContentType: DISCore|Boolean
    @@Type: idl|boolean||ManakaiDOM|all

## -- Features

ElementTypeBinding:
  @Name: FeatureDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: f|Feature
    @@For: =ManakaiDOM|all

ElementTypeBinding:
  @Name: FeatureVerDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: f|Feature

ElementTypeBinding:
  @Name: featureQName
  @ElementType:
    f:name
  @ShadowContent:
    @@ContentType: DISCore|QName

FeatureDef:
  @featureQName: fe|H2H
  @QName: H2HFeature
  @FeatureVerDef:
    @@QName: H2HFeature10
    @@Version: 1.0
    @@f:instanceOf: H2HFeature
    @@f:requires: tx|XMLFeature30
    @@enDesc:
      The H2H Document Markup Language DOM, version 1.0.

## -- Implementation

## TODO:

## -- Elements

IFClsDef:
  @IFQName: H2HElement
  @ClsQName: ManakaiH2HElement

  @IFISA: Element
  @ClsISA: te|ManakaiDOMElement

  @s:elementType: AnyH2HElement||ManakaiDOM|all
##H2HElement

ResourceDef:
  @QName: AnyH2HElement
  @DISCore:resourceType: s|AnyElementInNS
  @AppName:
    @@@: h2h|*
    @@ContentType: DISCore|QName
  @ForCheck: =ManakaiDOM|all

ElementTypeBinding:
  @Name: NodeReadOnlyError
  @ElementType:
    dx:raises
  @ShadowContent:
    @@@: MDOMX|NOMOD_THIS
    @@Description:
      @@@lang:en
      @@@@:
        If the node or a descendant of it, which
        is to be modified, is read-only.

## -- Parser

IFClsDef:
  @IFQName: H2HParser
  @ClsQName: ManakaiH2HParser

  @Implement: ecore|MUErrorTarget||ManakaiDOM|Perl

  @DISLang:role: gls|ParserRole

  @f:implements: H2HFeature10
  @f:provides:
    @@@: H2HFeature10
    @@f:through: c|ManakaiDOMImplementation

  @enDesc:
    A <IF::H2HParser> object parses an H2H/0.9 or H2H/1.0
    textual document and returns it as an object.

  @Attr:
    @@Name: domConfig
    @@enDesc:
      The configuration of the parser.

    @@Get:
      @@@Type: c|DOMConfiguration
      @@@enDesc: The DOM configuration object.
      @@@PerlDef:
        __CODE{c|getConfigObject::
          $target => $self,
          $targetHash => $self,
          $targetType => {<IFName::H2HParser>},
          $result => $r,
        }__;

  @Method:
    @@ManakaiDOM:isForInternal:1
    @@ForCheck: ManakaiDOM|ForClass
    @@Operator: DISPerl|NewMethod
    @@enDesc:
      Creates a new instance of the object.
    @@Param:
      @@@Name: impl
      @@@Type: gls|GLSImplementation
      @@@enDesc:
        The implementation from which the parser is created.
    @@Param:
      @@@Name: features
      @@@Type: DOMString
      @@@dis:actualType: f|FeaturesString
      @@@enDesc:
        The set of features requested for the parser.
    @@Return:
      @@@Type: DOMMain|DOMObject
      @@@enDesc:
        The newly created parser.
      @@@PerlDef:
        $r = bless {
          <H::f|implementation> => $impl->get_feature ('XML' => '3.0'),
        }, $self;

  @Method:
    @@Name: parseString
    @@enDesc:
      Parses a string as SWDML textual document and converts it into
      DOM tree.
    @@Param:
      @@@Name: sourceText
      @@@Type: DOMString
      @@@enDesc:
        The text to parse.
    @@Return:
      @@@Type: DISPerl|HASH
      @@@enDesc:
        An object representation of <P::sourceText>.
      @@@PerlDef:
        $self->{token} = [];
        $sourceText =~ s/\x0D\x0A/\x0A/g;
        $sourceText =~ tr/\x0D/\x0A/;
        $self->{line} = [split /\x0A/, $sourceText];
        $self->{location} = {};
        $self->{doc} = $self->{<H::f|implementation>}
                            ->create_document (<Q::html5|>, 'html');
        $self->{doc}->strict_error_checking (false);
        $self->{doc}->document_element
                    ->set_attribute_ns (<Q::xmlns|>, 'xmlns', <Q::html5|>);
        __DEEP{
          $self->_construct_tree;
        }__;

        $r = $self->{doc};

  @Method:
    @@Name: shiftLine
    @@ManakaiDOM:isForInternal:1
    @@ForCheck: ManakaiDOM|ForClass
    @@enDesc:
      Returns the next character.
    @@Return:
      @@@Type: DOMString
      @@@enDesc:
        A line, without line break characters.
      @@@nullCase:
        @@@@enDesc:
          If no more line is available.
      @@@PerlDef:
        if (@{$self->{line}}) {
          $r = shift @{$self->{line}};
        } else {
          $r = null;
        }

  @Method:
    @@Name: shiftToken
    @@ManakaiDOM:isForInternal: 1
    @@Return:
      @@@Type: dlp|HASH||ManakaiDOM|all
      @@@PerlDef:
        if (@{$self->{token}}) {
          $r = shift @{$self->{token}};
        } else {
          my $attrvalue = sub {
            my $v = shift;
            $v =~ s/&quot;/"/g;
            $v =~ s/&lt;/</g;
            $v =~ s/&gt;/>/g;
            $v =~ s/&reg;/\x{00AE}/g;
            $v =~ s/&hearts;/\x{2661}/g;
            $v =~ s/&amp;/&/g;
            $v;
          };
          my $uriv = sub {
            my $v = $attrvalue->(shift);
            $v =~ s/^\{/(/;
            $v =~ s/\}$/)/;
            $v =~ s/^\#([0-9si]+)$/($1)/;
            $v =~ s/^\(([0-9]{4})([0-9]{2})([0-9]{2})([^)]*)\)$/($1, $2, $3$4)/;
            $v =~ s/[si]/, /g if $v =~ /^\(/ and $v =~ /\)$/;
            $v;
          };

          $r = {type => '#EOF'};
          L: while (defined (my $line = $self->_shift_line)) {
            if ($line =~ s/^([A-Z]+|T[0-9])(\*?\+?\*?)(?:\s+|$)//) {
              my $command = $1;
              my $flag = $2;
              $r = {type => 'start', value => $command};

              my $uri;
              if ($flag =~ /\*/ and $line =~ s/^([^{\s]\S*)\s*//) {
                $uri = $1;
              }

              my $attr = '';
              if ($line =~ s/^\{(\s*(?:[A-Za-z][^{}]*)?)\}\s*//) {
                $attr = $1;
              }

              if (not defined $uri and
                  $flag =~ /\*/ and $line =~ s/^([^{\s]\S*)\s*//) {
                $uri = $1;
              }

              my @token;
              my $info = {
                # val# val#(*)
                ABBR => [2, 2],
                ACRONYM => [2, 2],
                CITE => [2, 1],
                LDIARY => [4, 4],
                LIMG => [4, 4],
                LINK => [2, 1],
                LMG => [2, 2],
                LNEW => [2, 2],
                PERSON => [2, 2],
                RIBU => [2, 2],
                RUBY => [2, 2],
                SEE => [2, 2],
              }->{$command};
              my @value = split /\s+/, $line,
                                ($flag =~ /\*/ ? $info->[1] : $info->[0]) || 1;

              if (defined $uri) {
                push @token, {type => 'uri', value => $uriv->($uri)};
              }

              my %attr;
              while ($attr =~ /([A-Za-z0-9_-]+)\s*(?:=>?|:)\s*([^";,]+|"[^"]+")/gc) {
                my $name = lc $1;
                my $value = $2;
                $value =~ tr/"//d;
                $attr{$name} = $value;
              }
              delete $attr{'content-type'};

              if ({
                ABBR => true, ACRONYM => true,
                RUBY => true, RIBU => true,
              }->{$command}) {
                if (@value == 1 and $attr{title}) {
                  push @value, $attr{title};
                  delete $attr{title};
                }
                if (@value == 2) {
                  unshift @{$self->{line}}, 'RB',
                                           'DATA {} >>'.$value[1],
                                         '/RB',
                                         'RT',
                                           'DATA {} >>'.$value[0],
                                         '/RT',
                                       '/'.$command;
                } else {
                  unshift @{$self->{line}}, 'DATA {} >>'.$value[0], '/'.$command;
                }
              } elsif ($command eq 'CITE') {
                if (@value == 2) {
                  if (defined $uri or $value[0] !~ /^[a-z-]+:/) {
                    unshift @{$self->{line}}, 'SRC',
                                             'DATA {} >>'.$value[0].' '.$value[1],
                                           '/SRC', 'BODYTEXT';
                  } else {
                    push @token, {type => 'uri', value => $uriv->($value[0])};
                    unshift @{$self->{line}}, 'SRC',
                                             'DATA {} >>'.$value[1],
                                           '/SRC', 'BODYTEXT';
                  }
                } elsif (@value == 1) {
                  if (defined $uri or $value[0] !~ /^[a-z-]+:/) {
                    unshift @{$self->{line}}, 'SRC',
                                             'DATA {} >>'.$value[0],
                                           '/SRC', 'BODYTEXT';
                  } else {
                    push @token, {type => 'uri', value => $uriv->($value[0])};
                    unshift @{$self->{line}}, 'BODYTEXT';
                  }
                } else {
                  unshift @{$self->{line}}, 'BODYTEXT';
                }
              } elsif ($command eq 'DATA') {
                my @token;
                $line =~ s/^>>//;
                while (length $line) {
                  if ($line =~ s/^<([a-z0-9]+)\s*//) {
                    my $tagname = $1;
                    push @token, {type => 'start', value => $tagname};
                    while ($line =~ s/^([a-z-]+)\s*=\s*"([^"]*)"\s*//) {
                      push @token, {type => $1, value => $attrvalue->($2)};
                    }
                    $line =~ s#^/?\s*>##;
                    push @token, {type => 'end', value => $tagname}
                        if $tagname eq 'img' or $tagname eq 'input' or
                           $tagname eq 'br';
                  } elsif ($line =~ s#^</([a-z0-9]+)\s*>##) {
                    push @token, {type => 'end', value => $1};
                  } elsif ($line =~ s/^<!--(.*?)-->//) {
                    push @token, {type => 'html-comment', value => $1};
                  } elsif ($line =~ s/^&([a-z]+);//) {
                    my $name = $1;
                    if ($name eq 'amp') {
                      push @token, {type => 'text', value => '&'};
                    } elsif ($name eq 'lt') {
                      push @token, {type => 'text', value => '<'};
                    } elsif ($name eq 'gt') {
                      push @token, {type => 'text', value => '>'};
                    } elsif ($name eq 'quot') {
                      push @token, {type => 'text', value => '"'};
                    } elsif ($name eq 'reg') {
                      push @token, {type => 'text', value => "\x{00AE}"};
                    } elsif ($name eq 'amp') {
                      push @token, {type => 'text', value => "\x{2661}"};
                    } else {
                      push @token, {type => 'char', value => $name};
                    }
                  } elsif ($line =~ s/^&#([0-9]+);//) {
                    push @token, {type => 'text', value => ord $1};
                  } elsif ($line =~ s/^&#x([0-9A-Fa-f]+);//) {
                    push @token, {type => 'text', value => ord hex $1};
                  } elsif ($line =~ s/^([^<&]+)//) {
                    push @token, {type => 'text', value => $1};
                  } else {
                    push @token, {type => 'text', value => substr ($line, 0, 1)};
                    substr ($line, 0, 1) = '';
                  }
                }
                push @token, {type => 'eol'};

                $r = shift @token;
                push @{$self->{token}}, @token;
                last L;
              } elsif ({
                DD => true, DT => true,
                DEL => true, INS => true,
                LI => true,
                RB => true, RT => true,
                STRONG => true,
                YAMI => true,
                EM => true,
                HOUR => true, KION => true, LUNCH => true,
                TAION => true, TENKI => true, THEME => true,
                T1 => true, T2 => true, T3 => true, T4 => true,
                T5 => true, T6 => true, T7 => true, SP => true,
              }->{$command}) {
                if (@value) {
                  unshift @{$self->{line}}, 'DATA {} >>'.$value[0], '/'.$command;
                }
              } elsif ($command eq 'DIV') {
                if (@value) {
                  $r = {type => 'class', value => $value[0]};
                }
              } elsif ($command eq 'LDIARY') {
                $value[0] =~ s/^([0-9]{4})([0-9]{2})([0-9]{2})/$1, $2, $3/;
                $value[0] =~ s/[is]/, /;
                $r = {type => 'start', value => 'LINK'};
                push @token, {type => 'uri', value => "($value[0])"};
                unshift @{$self->{line}}, 'DATA {} >>'.$value[1], '/LINK';
              } elsif ($command eq 'LIMG') {
                $r = {type => 'start', value => 'IMG'};
                push @token, {type => 'uri', value => $uriv->($value[0])};
                unshift @{$self->{line}}, 'DATA {} >>'.$value[3], '/IMG';
              } elsif ($command eq 'LMG') {
                $r = {type => 'start', value => 'IMG'};
                push @token, {type => 'uri', value => $uriv->($value[0])};
                unshift @{$self->{line}}, 'DATA {} >>'.$value[1], '/IMG';
              } elsif ($command eq 'LINK') {
                if (@value == 2) {
                  push @token, {type => 'uri', value => $uriv->($value[0])};
                  unshift @{$self->{line}}, 'DATA {} >>'.$value[1], '/LINK';
                } elsif ($flag =~ /\+/) {
                  push @token, {type => 'uri', value => $uriv->($value[0])};
                } else {
                  unshift @{$self->{line}}, 'DATA {} >>'.$value[0], '/LINK';
                }
              } elsif ($command eq 'NEW') {
                $r = {type => 'start', value => 'SECTION'};
                unshift @{$self->{line}}, 'H', 'DATA {} >>'.$value[0], '/H';
              } elsif ($command eq 'LNEW') {
                $r = {type => 'start', value => 'SECTION'};
                push @token, {type => 'uri', value => $uriv->($value[0])};
                unshift @{$self->{line}}, 'H', 'DATA {} >>'.$value[1], '/H';
              } elsif ($command eq 'SUB') {
                $r = {type => 'start', value => 'SUB'};
                unshift @{$self->{line}}, 'H', 'DATA {} >>'.$value[0], '/H';
              } elsif ($command eq 'PERSON') {
                push @token, {type => 'key', value => $attrvalue->($value[0])};
                unshift @{$self->{line}}, 'DATA {} >>'.$value[1], '/PERSON';
              } elsif ($command eq 'SEE') {
                if (@value == 2) {
                  push @token, {type => 'key', value => $attrvalue->($value[0])};
                  unshift @{$self->{line}}, 'DATA {} >>'.$value[1], '/SEE';
                } else {
                  unshift @{$self->{line}}, 'DATA {} >>'.$value[0], '/SEE';
                }
              } elsif ($command eq 'SPAN') {
                if (@value == 2) {
                  push @token, {type => 'class',
                                value => $attrvalue->($value[0])};
                  unshift @{$self->{line}}, 'DATA {} >>'.$value[1], '/SPAN';
                } else {
                  unshift @{$self->{line}}, 'DATA {} >>'.$value[0], '/SPAN';
                }
              } elsif ($command eq 'OK') {
                $r = {type => '#EOF'};
                next L;
              } elsif ($command eq 'XML') {
                unshift @{$self->{line}}, 'DATA {} >>XML '.$line;
                next L;
              }

              for (keys %attr) {
                push @token, {type => $_, value => $attrvalue->($attr{$_})};
              }

              push @{$self->{token}}, @token;
              last L;
            } elsif ($line eq 'H2H/1.0') {
              $r = {type => 'magic', value => 'H2H/1.0'};
              last L;
            } elsif ($line =~ m#^/([A-Z]+)\s*$#) {
              $r = {type => 'end', value => $1};
              last L;
            } elsif ($line =~ s/^!#//) {
              $r = {type => 'hnf-comment', value => $line};
              last L;
            } elsif ($line =~ s/^!//) {
              $r = {type => 'html-comment', value => $line};
              last L;
            } else {
              unshift @{$self->{line}}, 'DATA {} >>'.$line;
              next L;
            }
          } # L
        }

  @Method:
    @@Name: constructTree
    @@ManakaiDOM:isForInternal: 1
    @@Return:
      @@@PerlDef:
        my $doc_el = $self->{doc}->document_element;
        my $head_el = $self->{doc}->create_element_ns (<Q::html5|>, 'head');
        my $body_el = $self->{doc}->create_element_ns (<Q::html5|>, 'body');
        $doc_el->append_child ($head_el);
        $doc_el->append_child ($body_el);
        $doc_el->set_user_data ('command-name' => '#html');
        $head_el->set_user_data ('command-name' => '#head');
        $body_el->set_user_data ('command-name' => '#body');
        $doc_el->set_attribute_ns (<Q::sw09|>, 'sw9:Name' => 'H2H');
        $doc_el->set_attribute_ns (<Q::sw09|>, 'sw9:Version' => '0.9');

        my $parent = {
          subsection => $body_el,
          attr => $body_el,
          text => $body_el,
        };
        my $state = 'data';
          ## data - normal
          ## list - UL or OL
          ## br   - after br start tag token
          ## eol  - after eol token

        T: while (my $token = $self->_shift_token) {
          last T if $token->{type} eq '#EOF';

          if ($token->{type} eq 'text') {
            if ($state eq 'list') {
              my $li_el = $self->{doc}->create_element_ns (<Q::html5|>, 'li');
              $li_el->manakai_append_text ($token->{value});
              $parent->{text}->append_child ($li_el);
            } else {
              $parent->{text}->manakai_append_text ("\x0A") if $state eq 'eol';
              $parent->{text}->manakai_append_text ($token->{value});
              $state = 'data';
            }
          } elsif ($token->{type} eq 'eol') {
            if ($state eq 'eol') {
              $parent->{text}->manakai_append_text ("\x0A");
            } else {
              $state = $state eq 'br' ? 'data' : 'eol';
            }
          } elsif ($token->{type} eq 'start') {
            my $info = {
                      # nsuri, qname, parent, state
              ABBR => [<Q::html5|>, 'abbr', $parent->{text}, 'data'],
              ACRONYM => [<Q::html5|>, 'abbr', $parent->{text}, 'data'],
              BODYTEXT => [<Q::html3|>, 'bodytext', $parent->{text}, 'data'],
              CITE => [<Q::html5|>, 'blockquote', $parent->{text}, 'data',
                       {PRE => true}],
              DD => [<Q::html5|>, 'dd', $parent->{text}, 'data'],
              DEL => [<Q::html5|>, 'del', $parent->{text}, 'data'],
              DIV => [<Q::html5|>, 'div', $parent->{text}, 'data', {P => true}],
              DL => [<Q::html5|>, 'dl', $parent->{text}, 'data'],
              DT => [<Q::html5|>, 'dt', $parent->{text}, 'data'],
              EM => [<Q::html5|>, 'em', $parent->{text}, 'data'],
              FN => [<Q::h2h|>, 'fn', $parent->{text}, 'data'],
              H => [<Q::xhtml2|>, 'h', $parent->{text}, 'data'],
              HOUR => [<Q::h2h|>, 'hour', $head_el, 'data'],
              IMG => [<Q::html5|>, 'img', $parent->{text}, 'data'],
              INS => [<Q::html5|>, 'ins', $parent->{text}, 'data'],
              KION => [<Q::h2h|>, 'kion', $head_el, 'data'],
              LI => [<Q::html5|>, 'li', $parent->{text}, 'data'],
              LINK => [<Q::html5|>, 'a', $parent->{text}, 'data'],
              LUNCH => [<Q::h2h|>, 'lunch', $head_el, 'data'],
              OL => [<Q::html5|>, 'ol', $parent->{text}, 'list', {PRE => true}],
              P => [<Q::html5|>, 'p', $parent->{text}, 'data',
                    {P => true, PRE => true}],
              PERSON => [<Q::html3|>, 'person', $parent->{text}, 'data'],
              PRE => [<Q::html5|>, 'pre', $parent->{text}, 'data', 
                      {P => true}],
              RB => [<Q::html5|>, 'rb', $parent->{text}, 'data'],
              RIBU => [<Q::html5|>, 'ruby', $parent->{text}, 'data'],
              RT => [<Q::html5|>, 'rt', $parent->{text}, 'data'],
              RUBY => [<Q::html5|>, 'ruby', $parent->{text}, 'data'],
              SECTION => [<Q::html5|>, 'section', $body_el, 'data'],
              SEE => [<Q::html5|>, 'i', $parent->{text}, 'data'],
              SP => [<Q::h2h|>, 'sp', $head_el, 'data'],
              SPAN => [<Q::html5|>, 'span', $parent->{text}, 'data'],
              SRC => [<Q::html3|>, 'credit', $parent->{text}, 'data'],
              STRONG => [<Q::html5|>, 'strong', $parent->{text}, 'data'],
              SUBSECTION => [<Q::html5|>, 'section', $parent->{subsection}, 'data'],
              T1 => [<Q::h2h|>, 't1', $head_el, 'data'],
              T2 => [<Q::h2h|>, 't2', $head_el, 'data'],
              T3 => [<Q::h2h|>, 't3', $head_el, 'data'],
              T4 => [<Q::h2h|>, 't4', $head_el, 'data'],
              T5 => [<Q::h2h|>, 't5', $head_el, 'data'],
              T6 => [<Q::h2h|>, 't6', $head_el, 'data'],
              T7 => [<Q::h2h|>, 't7', $head_el, 'data'],
              TAION => [<Q::h2h|>, 'taion', $head_el, 'data'],
              TENKI => [<Q::h2h|>, 'tenki', $head_el, 'data'],
              THEME => [<Q::h2h|>, 'theme', $head_el, 'data'],
              UL => [<Q::html5|>, 'ul', $parent->{text}, 'list', {PRE => true}],
              YAMI => [<Q::h2h|>, 'yami', $parent->{text}, 'data'],
              a => [<Q::html5|>, 'a', $parent->{text}, 'data'],
              abbr => [<Q::html5|>, 'abbr', $parent->{text}, 'data'],
              acronym => [<Q::html5|>, 'abbr', $parent->{text}, 'data'],
              blockquote => [<Q::html5|>, 'blockquote', $parent->{text}, 'data'],
              br => [<Q::html5|>, 'br', $parent->{text}, 'br'],
              caption => [<Q::html5|>, 'caption', $parent->{text}, 'data'],
              code => [<Q::html5|>, 'code', $parent->{text}, 'data'],
              dd => [<Q::html5|>, 'dd', $parent->{text}, 'data'],
              del => [<Q::html5|>, 'del', $parent->{text}, 'data'],
              dfn => [<Q::html5|>, 'dfn', $parent->{text}, 'data'],
              div => [<Q::html5|>, 'div', $parent->{text}, 'data'],
              dl => [<Q::html5|>, 'dl', $parent->{text}, 'data'],
              dt => [<Q::html5|>, 'dt', $parent->{text}, 'data'],
              em => [<Q::html5|>, 'em', $parent->{text}, 'data'],
              form => [<Q::html5|>, 'form', $parent->{text}, 'data'],
              h1 => [<Q::html5|>, 'h1', $parent->{text}, 'data'],
              h2 => [<Q::html5|>, 'h2', $parent->{text}, 'data'],
              h3 => [<Q::html5|>, 'h3', $parent->{text}, 'data'],
              h4 => [<Q::html5|>, 'h4', $parent->{text}, 'data'],
              img => [<Q::html5|>, 'img', $parent->{text}, 'data'],
              input => [<Q::html5|>, 'input', $parent->{text}, 'data'],
              ins => [<Q::html5|>, 'ins', $parent->{text}, 'data'],
              kbd => [<Q::html5|>, 'kbd', $parent->{text}, 'data'],
              label => [<Q::html5|>, 'label', $parent->{text}, 'data'],
              li => [<Q::html5|>, 'li', $parent->{text}, 'data'],
              ol => [<Q::html5|>, 'ol', $parent->{text}, 'data'],
              p => [<Q::html5|>, 'p', $parent->{text}, 'data'],
              pre => [<Q::html5|>, 'pre', $parent->{text}, 'data'],
              q => [<Q::html5|>, 'q', $parent->{text}, 'data'],
              rb => [<Q::html5|>, 'rb', $parent->{text}, 'data'],
              rp => [<Q::html5|>, 'rp', $parent->{text}, 'data'],
              rt => [<Q::html5|>, 'rt', $parent->{text}, 'data'],
              ruby => [<Q::html5|>, 'ruby', $parent->{text}, 'data'],
              span => [<Q::html5|>, 'span', $parent->{text}, 'data'],
              strong => [<Q::html5|>, 'strong', $parent->{text}, 'data'],
              sup => [<Q::html5|>, 'sup', $parent->{text}, 'data'],
              table => [<Q::html5|>, 'table', $parent->{text}, 'data'],
              tbody => [<Q::html5|>, 'tbody', $parent->{text}, 'data'],
              td => [<Q::html5|>, 'td', $parent->{text}, 'data'],
              th => [<Q::html5|>, 'th', $parent->{text}, 'data'],
              thead => [<Q::html5|>, 'thead', $parent->{text}, 'data'],
              tr => [<Q::html5|>, 'tr', $parent->{text}, 'data'],
              ul => [<Q::html5|>, 'ul', $parent->{text}, 'data'],
              var => [<Q::html5|>, 'var', $parent->{text}, 'data'],
            }->{$token->{value}}
                   || [<Q::h2h|>, $token->{value}, $parent->{text}, 'data'];
            while ($info->[4]->{$info->[2]->get_user_data ('command-name')}) {
              $info->[2] = $info->[2]->parent_node;
            }
            my $el = $self->{doc}->create_element_ns ($info->[0], $info->[1]);
            $el->set_user_data ('command-name', $token->{value});
            $info->[2]->append_child ($el);
            $parent->{text} = $el;
            $parent->{attr} = $el;
            $parent->{subsection} = $el if $token->{value} eq 'SECTION';
            $state = $info->[3];
          } elsif ($token->{type} eq 'end') {
            E: while (my $et = $parent->{text}->get_user_data ('command-name')) {
              $parent->{text} = $parent->{text}->parent_node;
              last E if $et eq $token->{value};
              last E if $et eq '#body';
            }
            $parent->{attr} = $parent->{text};
            $state = {
              UL => 'list',
              OL => 'list',
            }->{$parent->{text}->get_user_data ('command-name')}
                || $state eq 'br' ? 'br' : 'data';
          } elsif ($token->{type} eq 'char') {
            my $el = $self->{doc}->create_element_ns (<Q::h2h|>, 'char');
            $el->manakai_append_text ($token->{value});
            $parent->{text}->append_child ($el);
            $state = 'data' if $state eq 'br';
          } elsif ($token->{type} eq 'magic') {
            my ($name, $version) = split m#/#, $token->{value}, 2;
            $doc_el->set_attribute_ns (<Q::sw09|>, 'sw9:Name', $name);
            $doc_el->set_attribute_ns (<Q::sw09|>, 'sw9:Version', $version);
          } elsif ($token->{type} eq 'hnf-comment') {
            my $com = $self->{doc}->create_element_ns
                                         (<Q::h2h|>, 'hnf-comment');
            $com->text_content ($token->{value});
            $parent->{text}->append_child ($com);
          } elsif ($token->{type} eq 'html-comment') {
            my $com = $self->{doc}->create_element_ns
                                         (<Q::h2h|>, 'html-comment');
            $com->text_content ($token->{value});
            $parent->{text}->append_child ($com);
          } elsif ($token->{type} eq 'source') {
            my $src = $self->{doc}->create_element_ns (<Q::html3|>, 'credit');
            $src->manakai_append_text ($token->{value});
            $parent->{text}->append_child ($src);
          } elsif ($token->{type} eq 'uri') {
            my $v = $token->{value};
            if ($v =~ /^\(([^()]+)\)$/) {
              my @v = split /\s*,\s*/, $1;
              $parent->{attr}->set_attribute_ns
                                 (<Q::h2h|>, 'href-year' => $v[0]+0);
              $parent->{attr}->set_attribute_ns
                                 (<Q::h2h|>, 'href-month' => $v[1]+0);
              $parent->{attr}->set_attribute_ns
                                 (<Q::h2h|>, 'href-day' => $v[2]+0);
              $parent->{attr}->set_attribute_ns
                                 (<Q::h2h|>, 'href-section' => $v[3]+0) if $v[3];
              $parent->{attr}->set_attribute_ns
                                 (<Q::h2h|>, 'href-subsection' => $v[4]+0)
                  if $v[4];
            } else {
              my $xuri = $parent->{attr}->manakai_expanded_uri;
              if ($xuri eq <Q::html5|a>) {
                $parent->{attr}->set_attribute_ns
                                   (null, href => $token->{value});
              } elsif ($xuri eq <Q::html5|blockquote>) {
                $parent->{attr}->set_attribute_ns
                                   (null, cite => $token->{value});
              } else {
                $parent->{attr}->set_attribute_ns
                                   (<Q::xhtml2|>, href => $token->{value});
              }
            }
          } elsif ({
            title => true, style => true,
            class => true, href => true, 'accept-charset' => true,
            action => true, method => true, alt => true, src => true,
            type => true, value => true, name => true, accesskey => true,
            for => true, cite => true, onclick => true, colspan => true,
            scope => true, summary => true,
          }->{$token->{type}}) {
            $parent->{attr}->set_attribute_ns
                               (null, $token->{type}, $token->{value});
          } elsif ($token->{type} eq 'cat') {
            for (split /\s*,\s*/, $token->{value}) {
              my $el = $self->{doc}->create_element_ns (<Q::h2h|>, 'cat');
              $el->manakai_append_text ($_);
              $parent->{attr}->append_child ($el);
            }
          } elsif ($token->{type} eq 'lang' or $token->{type} eq 'xml:lang') {
            $parent->{attr}->set_attribute_ns
                               (<Q::xml|>, 'xml:lang' => $token->{value});
          } elsif ($token->{type} eq 'id') {
            $parent->{attr}->set_attribute_ns
                               (<Q::xml|>, 'xml:id' => $token->{value});
          } elsif ($token->{type} eq 'wbradded') {
            # ignore
          } else {
          # key, level, place, position, time
            $parent->{attr}->set_attribute_ns
                               (<Q::h2h|>, $token->{type}, $token->{value});
          }
        }

  @Method:
    @@ManakaiDOM:isForInternal: 1
    @@Operator: ManakaiDOM|MUErrorHandler
    @@enDesc:
      When a <IF::ecore|ErrorInterface||ManakaiDOM|Perl> is <Perl::report>ed,
      then this method is invoked.
      
      The method calls the <cfg::DOMCore|error-handler> if the error is of 
      <IF::DOMCore|DOMError>.  Otherwise, the error is re-thrown so that
      corresponding <Perl::catch> clause, if any, can catch the error.
    @@Param:
      @@@Name: err
      @@@Type: ecore|ErrorInterface||ManakaiDOM|Perl
      @@@enDesc:
        The reported error object.
    @@Return:
      @@@Type: DISPerl|Any
      @@@enDesc:
        If the <P::err> is a <IF::DOMCore|DOMError>, then the return value
        of the error handler.

           {NOTE:: If the error is thrown, the method never returns.
           }
      @@@nullCase:
        @@@@enDesc:
          No error handler.
      @@@PerlDef:
        if ($err->isa (<IFName::DOMCore|DOMError||ManakaiDOM|ManakaiDOM>)) {
          __DEEP{
            A: {
              my $cfg = $self-><AG::H2HParser.domConfig>;
              my $h = $cfg-><M::DOMCore|DOMConfiguration.getParameter>
                               ('error-handler');
              $r = $h-><M::DOMCore|DOMErrorHandler.handleError> ($err);
            } # A
          }__;
        } else {
          $err-><M::ecore|ErrorInterface||ManakaiDOM|Perl.throw>;
        }

  @PTests:
    @@PTest:
      @@@QName: p.magic.sw09.test
      @@@DEnt:
        @@@@test:value:
          #?SuikaWiki/0.9
      @@@test:domTree:
        document {
          element {
            namespace-uri: 'urn:x-suika-fam-cx:markup:suikawiki:0:9:';
            local-name: 'document';
            markup-language-name: 'SuikaWiki';
            markup-language-version: '0.9';
            element {
              namespace-uri: 'http://www.w3.org/2002/06/xhtml2/';
              local-name: 'head';
              has-child-nodes: false;
            }
            element {
              namespace-uri: 'http://www.w3.org/2002/06/xhtml2/';
              local-name: 'body';
              has-child-nodes: false;
            }
          }
        }
    @@PTest:
      @@@QName: p.magic.swimg09.test
      @@@DEnt:
        @@@@test:value:
          #?SuikaWikiImage/0.9
      @@@test:domTree:
        document {
          element {
            namespace-uri: 'urn:x-suika-fam-cx:markup:suikawiki:0:9:';
            local-name: 'document';
            markup-language-name: 'SuikaWikiImage';
            markup-language-version: '0.9';
            element {
              namespace-uri: 'http://www.w3.org/2002/06/xhtml2/';
              local-name: 'head';
              has-child-nodes: false;
            }
            element {
              namespace-uri: 'http://www.w3.org/2002/06/xhtml2/';
              local-name: 'body';
              has-child-nodes: false;
            }
          }
        }

    @@PerlDef:
      my $impl = $Message::DOM::ImplementationRegistry->get_dom_implementation ({
        'Core' => '3.0',
        'XML' => '3.0',
      });

      for my $test_data (@$TestData) {
        my $parser = <Class::ManakaiH2HParser>->new ($impl);

        $test->start_new_test ($test_data->{uri});
        my $doc_ent = $test_data->{entity}->{$test_data->{root_uri}};
        my $not_ok;

        ## -- DOM Configuration Parameters

        my $pcfg = $parser->dom_config;
        for (keys %{$test_data->{dom_config}}) {
          $pcfg->set_parameter ($_ => $test_data->{dom_config}->{$_});
        }

#        $pcfg->set_parameter ('error-handler' => sub ($$) {
#          my (undef, $err) = @_;
#	  my $err_type = $err->type;
#	  if ($test_data->{dom_error}->{$err_type}) {
#            $test->assert_error_equals
#                     (actual_value => $err,
#                      expected_hash => shift @{$test_data->{dom_error}
#                                                         ->{$err_type}});
#          } else { # Uncatched error
#            warn $err;
#            unless ($err->severity == <C::c|DOMError.SEVERITY_WARNING>) {
#              $test->failure_comment ('Unexpected error |'.$err->type.'|');
#              $not_ok = true;
#            }
#          }
#          return true; # continue as far as possible
#        });

        ## -- Test and Result

          my $doc;
          try {
            $doc = $parser->parse_string ($doc_ent->{<Q::test|value>});
            $test->assert_dom_tree_equals
                     (actual_value => $doc,
                      expected_hash => $test_data->{dom_tree});
            for (values %{$test_data->{dom_error}||{}}) {
              if (@$_) {
                $test->failure_comment
                         (@$_.' |DOMError|s of type |'.
                          $_->[0]->{type}->{value}.'| are not reported');
                $not_ok = true;
              }
            }
            $not_ok ? $test->not_ok : $test->ok;
            undef $doc;
          } catch Message::Util::IF::DTException with {
            require Message::DOM::SimpleLS;
            my $ls = Message::DOM::SimpleLS::ManakaiDOMSimpleXMLSerializer->new;
            print STDERR $ls->write_to_string ($doc);
          } otherwise {
            my $err = shift;
            warn $err;
            $test->not_ok;
          };
      }
##H2HParser

