Module:
  @QName: Markup|H2H
  @enFN:
    H2H/0.9 and H2H/1.0 Document Markup Language DOM
  @enDesc:
      {TODO::

      }

  @Namespace:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Markup/H2H/

  @DISCore:author: DISCore|Wakaba
  @License: license|Perl+MPL
  @Date:
    $Date: 2006/05/06 07:02:59 $

  @Require:
    @@Module:
      @@@QName: Markup|common
    @@Module:
      @@@QName: MDOM|TreeCore
      @@@WithFor: ManakaiDOM|ManakaiDOMLatest
    @@Module:
      @@@WithFor: ManakaiDOM|ManakaiDOM
    @@Module:
      @@@WithFor: ManakaiDOM|ManakaiDOMLatest
    @@Module:
      @@@QName: Markup|Atom
      @@@WithFor: ManakaiDOM|ManakaiDOMLatest
  @DefaultFor: ManakaiDOM|ManakaiDOMLatest

Namespace:
  @aa:
    http://pc5.2ch.net/test/read.cgi/hp/1096723178/aavocab#
  @c:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#
  @cfg:
    http://suika.fam.cx/www/2006/dom-config/
  @dis:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#dis--
  @doc:
    http://suika.fam.cx/~wakaba/archive/2005/7/tutorial#
  @d:
    http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#
  @DOMMain:
    http://suika.fam.cx/~wakaba/archive/2004/dom/main#
  @dx:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#
  @ecore:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/Core/
  @f:
    http://suika.fam.cx/~wakaba/archive/2004/dom/feature#
  @fe:
    http://suika.fam.cx/www/2006/feature/
  @gls:
    http://suika.fam.cx/~wakaba/archive/2004/dom/gls#
  @h2h:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Markup/H2H/
  @html:
    http://www.w3.org/1999/xhtml
  @idl:
    http://suika.fam.cx/~wakaba/archive/2004/dis/IDL#
  @kwd:
    http://suika.fam.cx/~wakaba/archive/2005/rfc2119/
  @lang:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#
  @license:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/license#
  @ManakaiDOM:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#
  @Markup:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Markup#
  @mat:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Markup/Atom/
  @MDOM:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#ManakaiDOM.
  @MDOMX:
    http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#
  @dlp:
    http://suika.fam.cx/~wakaba/archive/2004/dis/Perl#
  @html3:
    urn:x-suika-fam-cx:markup:ietf:html:3:draft:00:
  @html5:
    http://www.w3.org/1999/xhtml
  @rel:
    http://www.iana.org/assignments/relation/
  @s:
    http://suika.fam.cx/~wakaba/archive/2004/dis/Markup#
  @sw09:
    urn:x-suika-fam-cx:markup:suikawiki:0:9:
  @sw010:
    urn:x-suika-fam-cx:markup:suikawiki:0:10:
  @tc:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/DOM/TreeCore/
  @td:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/DOM/Document/
  @te:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/DOM/Element/
  @test:
    http://suika.fam.cx/~wakaba/archive/2004/dis/Test#
  @tx:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/DOM/XML/
  @urigen:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/URI/Generic/
  @xhtml2:
    http://www.w3.org/2002/06/xhtml2/
  @xml:
    http://www.w3.org/XML/1998/namespace
  @xmlns:
    http://www.w3.org/2000/xmlns/

ElementTypeBinding:
  @Name: CODE
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: dlp|BlockCode
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: Method
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|Method
    @@ForCheck: !=ManakaiDOM|ManakaiDOM

ElementTypeBinding:
  @Name: Param
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|MethodParameter

ElementTypeBinding:
  @Name: Return
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|MethodReturn

ElementTypeBinding:
  @Name: Attr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|Attribute
    @@ForCheck: !=ManakaiDOM|ManakaiDOM

ElementTypeBinding:
  @Name: Get
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|AttributeGet

ElementTypeBinding:
  @Name: Set
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|AttributeSet

ElementTypeBinding:
  @Name: nullCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: ManakaiDOM|InCase
    @@Value:
      @@@is-null:1

ElementTypeBinding:
  @Name: PerlDef
  @ElementType:
    dis:Def
  @ShadowContent:
    @@ContentType: lang|Perl
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: PerlCDef
  @ElementType:
    dis:Def
  @ShadowContent:
    @@ContentType: lang|Perl

ElementTypeBinding:
  @Name: enImplNote
  @ElementType:
    dis:ImplNote
  @ShadowContent:
    @@lang:en

ElementTypeBinding:
  @Name: enFN
  @ElementType:
    dis:FullName
  @ShadowContent:
    @@lang:en

ElementTypeBinding:
  @Name: PTests
  @ElementType: 
    dis:ResourceDef
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass
    @@DISCore:resourceType: test|ParserTestSet

ElementTypeBinding:
  @Name: PTest
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass
    @@DISCore:resourceType: test|ParserTest

ElementTypeBinding:
  @Name: DEnt
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: test|RootEntity

ElementTypeBinding:
  @Name: IFClsETDef
  @ElementType: 
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType:
      @@@@: dis|MultipleResource
      @@@ForCheck: !ManakaiDOM|ForIF !ManakaiDOM|ForClass !s|ForML
    @@resourceFor: ManakaiDOM|ForIF
    @@resourceFor: ManakaiDOM|ForClass
    @@resourceFor: s|ForML
    @@For: ManakaiDOM|ManakaiDOM

    @@DISCore:resourceType:
      @@@@: DISLang|Interface
      @@@ForCheck: ManakaiDOM|ForIF

    @@DISCore:resourceType:
      @@@@: DISLang|Class
      @@@ForCheck: ManakaiDOM|ForClass
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOM||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOMLatest||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOMLatest

    @@s:elementType:
      @@@@: ||+||s|ForML
      @@@ContentType: DISCore|TFPQNames
      @@@DISCore:stopISARecursive:1

    @@DISCore:resourceType:
      @@@@: s|ElementType
      @@@ForCheck: s|ForML

    @@f:implements: AtomFeature10

ElementTypeBinding:
  @Name: IFClsDef
  @ElementType: 
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType:
      @@@@: dis|MultipleResource
      @@@ForCheck: !ManakaiDOM|ForIF !ManakaiDOM|ForClass !s|ForML
    @@resourceFor: ManakaiDOM|ForIF
    @@resourceFor: ManakaiDOM|ForClass
    @@For: ManakaiDOM|ManakaiDOM

    @@DISCore:resourceType:
      @@@@: DISLang|Interface
      @@@ForCheck: ManakaiDOM|ForIF

    @@DISCore:resourceType:
      @@@@: DISLang|Class
      @@@ForCheck: ManakaiDOM|ForClass
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOM||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOMLatest||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOMLatest

    @@f:implements: AtomFeature10

ElementTypeBinding:
  @Name: IFQName
  @ElementType:
    dis:QName
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForIF

ElementTypeBinding:
  @Name: ClsQName
  @ElementType:
    dis:QName
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: ETRQName
  @ElementType:
    dis:QName
  @ShadowContent:
    @@ForCheck: s|ForML

ElementTypeBinding:
  @Name: ETQName
  @ElementType:
    dis:AppName
  @ShadowContent:
    @@ForCheck: s|ForML
    @@ContentType: DISCore|QName

ElementTypeBinding:
  @Name: IFISA
  @ElementType:
    dis:ISA
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForIF

ElementTypeBinding:
  @Name: ClsISA
  @ElementType:
    dis:ISA
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: disDef
  @ElementType:
    dis:Def
  @ShadowContent:
    @@ContentType:
      lang:dis
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: Code
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: dlp|InlineCode
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: Test
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: test|StandaloneTest
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: TestC
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: test|StandaloneTest

ResourceDef:
  @QName: Document
  @AliasFor: td|Document
  @For: ManakaiDOM|DOM

ResourceDef:
  @QName: Element
  @AliasFor: te|Element
  @For: ManakaiDOM|DOM

ResourceDef:
  @QName: Attr
  @AliasFor: te|Attr
  @For: ManakaiDOM|DOM

ResourceDef:
  @QName: DOMString
  @AliasFor: DOMMain|DOMString
  @For: ManakaiDOM|DOM

ResourceDef:
  @QName: DOMURI
  @AliasFor: ManakaiDOM|ManakaiDOMURI
  @For: ManakaiDOM|DOM3

ResourceDef:
  @QName: DOMTimeStamp
  @AliasFor: DOMMain|DOMTimeStamp
  @For: ManakaiDOM|DOM2

ResourceDef:
  @QName: boolean
  @AliasFor: idl|boolean||ManakaiDOM|all

ResourceDef:
  @QName: Node
  @AliasFor: tc|Node
  @For: ManakaiDOM|ManakaiDOM

ResourceDef:
  @QName: NodeList
  @AliasFor: tc|NodeList
  @For: ManakaiDOM|ManakaiDOM

ResourceDef:
  @QName: StaticNodeList
  @AliasFor: tc|StaticNodeList
  @For: ManakaiDOM|ManakaiDOM

ElementTypeBinding:
  @Name: enDesc
  @ElementType:
    dis:Description
  @ShadowContent:
    @@lang:en

ElementTypeBinding:
  @Name: TrueCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType:
      ManakaiDOM:InCase
    @@Value:
      @@@@: 1
      @@@ContentType: DISCore|Boolean
    @@Type: idl|boolean||ManakaiDOM|all

ElementTypeBinding:
  @Name: FalseCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType:
      ManakaiDOM:InCase
    @@Value:
      @@@@: 0
      @@@ContentType: DISCore|Boolean
    @@Type: idl|boolean||ManakaiDOM|all

## -- Features

ElementTypeBinding:
  @Name: FeatureDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: f|Feature
    @@For: =ManakaiDOM|all

ElementTypeBinding:
  @Name: FeatureVerDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: f|Feature

ElementTypeBinding:
  @Name: featureQName
  @ElementType:
    f:name
  @ShadowContent:
    @@ContentType: DISCore|QName

FeatureDef:
  @featureQName: fe|H2H
  @QName: H2HFeature
  @FeatureVerDef:
    @@QName: H2HFeature010
    @@Version: 0.10
    @@f:instanceOf: H2HFeature
    @@f:requires: tx|XMLFeature30
    @@enDesc:
      The H2H Document Markup Language DOM, version 1.0.

## -- Implementation

## TODO:

## -- Elements

IFClsDef:
  @IFQName: H2HElement
  @ClsQName: ManakaiH2HElement

  @IFISA: Element
  @ClsISA: te|ManakaiDOMElement

  @s:elementType: AnyH2HElement||ManakaiDOM|all
##H2HElement

ResourceDef:
  @QName: AnyH2HElement
  @DISCore:resourceType: s|AnyElementInNS
  @AppName:
    @@@: h2h|*
    @@ContentType: DISCore|QName
  @ForCheck: =ManakaiDOM|all

ElementTypeBinding:
  @Name: NodeReadOnlyError
  @ElementType:
    dx:raises
  @ShadowContent:
    @@@: MDOMX|NOMOD_THIS
    @@Description:
      @@@lang:en
      @@@@:
        If the node or a descendant of it, which
        is to be modified, is read-only.

## -- Parser

IFClsDef:
  @IFQName: H2HParser
  @ClsQName: ManakaiH2HParser

  @Implement: ecore|MUErrorTarget||ManakaiDOM|Perl

  @DISLang:role: gls|ParserRole

  @f:implements: H2HFeature010
  @f:provides:
    @@@: H2HFeature010
    @@f:through: c|ManakaiDOMImplementation

  @enDesc:
    A <IF::H2HParser> object parses an H2H/0.9 or H2H/1.0
    textual document and returns it as an object.

  @Attr:
    @@Name: domConfig
    @@enDesc:
      The configuration of the parser.

    @@Get:
      @@@Type: c|DOMConfiguration
      @@@enDesc: The DOM configuration object.
      @@@PerlDef:
        __CODE{c|getConfigObject::
          $target => $self,
          $targetHash => $self,
          $targetType => {<IFName::H2HParser>},
          $result => $r,
        }__;

  @Method:
    @@ManakaiDOM:isForInternal:1
    @@ForCheck: ManakaiDOM|ForClass
    @@Operator: DISPerl|NewMethod
    @@enDesc:
      Creates a new instance of the object.
    @@Param:
      @@@Name: impl
      @@@Type: gls|GLSImplementation
      @@@enDesc:
        The implementation from which the parser is created.
    @@Param:
      @@@Name: features
      @@@Type: DOMString
      @@@dis:actualType: f|FeaturesString
      @@@enDesc:
        The set of features requested for the parser.
    @@Return:
      @@@Type: DOMMain|DOMObject
      @@@enDesc:
        The newly created parser.
      @@@PerlDef:
        $r = bless {
          <H::f|implementation> => $impl,
        }, $self;

  @Method:
    @@Name: parseString
    @@enDesc:
      Parses a string as SWDML textual document and converts it into
      DOM tree.
    @@Param:
      @@@Name: sourceText
      @@@Type: DOMString
      @@@enDesc:
        The text to parse.
    @@Return:
      @@@Type: DISPerl|HASH
      @@@enDesc:
        An object representation of <P::sourceText>.
      @@@PerlDef:
        $self->{scanner} = $self->can ('_scan_Body');
        $self->{char} = [0x000A];
        $self->{token} = [];
        $self->{source} = $sourceText;
        pos ($self->{source}) = 0;
        $self->{location} = {};
        $self->{doc} = $self->{<H::f|implementation>}
                            ->create_document (<Q::sw09|>, 'document');
        $self->{doc}->strict_error_checking (false);
        $self->{docel} = $self->{doc}->document_element;
        $self->{docel}->set_attribute_ns (<Q::xmlns|>, 'xmlns', <Q::sw09|>);
        $self->{docel}->set_attribute_ns (<Q::xmlns|>, 'xmlns:h2', <Q::xhtml2|>);
        $self->{docel}->markup_language_name ('SuikaWiki');
        $self->{docel}->markup_language_version ('0.10');
        $self->{docel}->append_child
                          ($self->{doc}->create_element_ns
                                           (<Q::xhtml2|>, 'h2:head'));
        $self->{docel}->append_child
                          ($self->{doc}->create_element_ns
                                           (<Q::xhtml2|>, 'h2:body'));
        __DEEP{
          $self->_parse_Document;
        }__;

        $r = $self->{doc};

  @Method:
    @@Name: shiftLine
    @@ManakaiDOM:isForInternal:1
    @@ForCheck: ManakaiDOM|ForClass
    @@enDesc:
      Returns the next character.
    @@Return:
      @@@Type: DOMString
      @@@enDesc:
        A line, without line break characters.
      @@@nullCase:
        @@@@enDesc:
          If no more line is available.
      @@@PerlDef:
        if (@{$self->{line}}) {
          $r = shift @{$self->{line}};
        } elsif ($self->{source} =~ /([^\x0D\x0A]+)/gc) {
          $r = $1;
        } else {
          $r = null;
        }

  @Method:
    @@Name: shiftToken
    @@ManakaiDOM:isForInternal: 1
    @@Return:
      @@@Type: dlp|HASH||ManakaiDOM|all
      @@@PerlDef:
        if (@{$self->{token}}) {
          $r = shift @{$self->{token}};
        } else {
          my $attrvalue = sub {
            my $v = shift;
            $v =~ s/&quot;/"/g;
            $v =~ s/&lt;/</g;
            $v =~ s/&gt;/>/g;
            $v =~ s/&reg;/\x{00AE}/g;
            $v =~ s/&hearts;/\x{2661}/g;
            $v =~ s/&amp;/&/g;
            $v;
          };
          my $uriv = sub {
            my $v = $attrvalue->(shift);
            $v =~ s/^\{/(/;
            $v =~ s/\}$/)/;
            $v =~ s/^\#([0-9si]+)$/($1)/;
            $v =~ s/^\(([0-9]{4})([0-9]{2})([0-9]{2})([^)]*)\)$/($1, $2, $3$4)/;
            $v =~ s/[si]/, /g if $v =~ /^\(/ and $v =~ /\)$/;
            $v;
          };

          $r = {type => '#EOF'};
          L: while (defined (my $line = $self->_shift_line)) {
            if ($line =~ s/^([A-Z]+)(\*?\+?\*?)(?:\s+|$)//) {
              my $command = $1;
              my $flag = $2;
              $r = {type => 'start', value => $command};

              my $uri;
              if ($flag =~ /\*/ and $line =~ s/^([^{\s]\S*)\s*//) {
                $uri = $1;
              }

              my $attr = '';
              if ($line =~ s/^\{(\s*(?:[a-z][^{}]*)?)\}\s*//) {
                $attr = $1;
              }

              if (not defined $uri and
                  $flag =~ /\*/ and $line =~ s/^([^{\s]\S*)\s*//) {
                $uri = $1;
              }

              my @token;
              my $info = {
                # val# val#(*)
                ABBR => [2, 2],
                ACRONYM => [2, 2],
                CITE => [2, 1],
                LDIARY => [4, 4],
                LIMG => [4, 4],
                LINK => [2, 1],
                LMG => [2, 2],
                LNEW => [2, 2],
                PERSON => [2, 2],
                RIBU => [2, 2],
                RUBY => [2, 2],
                SEE => [2, 2],
              }->{$command};
              my @value = split /\s+/, $line,
                                ($flag =~ /\*/ ? $info->[1] : $info->[0]) || 1;

              if (defined $uri) {
                push @token, {type => 'uri', value => $uriv->($uri)};
              }

              my %attr;
              while ($attr =~ /([A-Za-z0-9_-]+)\s*(?:=>?|:)\s*([^";,]+|"[^"]+")/gc) {
                my $name = lc $1;
                my $value = $2;
                $value =~ tr/"//d;
                $attr{$name} = $value;
              }
              delete $attr{'content-type'};

              if ({
                ABBR => true, ACRONYM => true,
                RUBY => true, RIBU => true,
              }->{$command}) {
                if (@value == 1 and $attr{title}) {
                  push @value, $attr{title};
                  delete $attr{title};
                }
                if (@value == 2) {
                  unshift @{$self->{line}}, 'RB',
                                           'DATA {} '.$value[1],
                                         '/RB',
                                         'RT',
                                           'DATA {} '.$value[0],
                                         '/RT',
                                       '/'.$command;
                } else {
                  unshift @{$self->{line}}, 'DATA {} '.$value[0], '/'.$command;
                }
              } elsif ($command eq 'CITE') {
                if (@value == 2) {
                  if (defined $uri or $value[0] !~ /^[a-z-]+:/) {
                    unshift @{$self->{line}}, 'SRC',
                                             'DATA {} '.$value[0].' '.$value[1],
                                           '/SRC';
                  } else {
                    push @token, {type => 'uri', value => $uriv->($value[0])};
                    unshift @{$self->{line}}, 'SRC',
                                             'DATA {} '.$value[1],
                                           '/SRC';
                  }
                } else {
                  if (defined $uri or $value[0] !~ /^[a-z-]+:/) {
                    unshift @{$self->{line}}, 'SRC',
                                             'DATA {} '.$value[0],
                                           '/SRC';
                  } else {
                    push @token, {type => 'uri', value => $uriv->($value[0])};
                  }
                }
              } elsif ($command eq 'DATA') {
                my @token;
                while (length $line) {
                  if ($line =~ s/^<([a-z0-9]+)\s*//) {
                    push @token, {type => 'start', value => $1};
                    while ($line =~ s/^([a-z-]+)\s*=\s*"([^"]*)"\s*//) {
                      push @token, {type => $1, value => $attrvalue->($2)};
                    }
                    $line =~ s#^/?\s*>##;
                  } elsif ($line =~ s#^</([a-z0-9]+)\s*>##) {
                    push @token, {type => 'end', value => $1};
                  } elsif ($line =~ s/^&([a-z]+);//) {
                    my $name = $1;
                    if ($name eq 'amp') {
                      push @token, {type => 'text', value => '&'};
                    } elsif ($name eq 'lt') {
                      push @token, {type => 'text', value => '<'};
                    } elsif ($name eq 'gt') {
                      push @token, {type => 'text', value => '>'};
                    } elsif ($name eq 'quot') {
                      push @token, {type => 'text', value => '"'};
                    } elsif ($name eq 'reg') {
                      push @token, {type => 'text', value => "\x{00AE}"};
                    } elsif ($name eq 'amp') {
                      push @token, {type => 'text', value => "\x{2661}"};
                    } else {
                      push @token, {type => 'char', value => $name};
                    }
                  } elsif ($line =~ s/^&#([0-9]+);//) {
                    push @token, {type => 'text', value => ord $1};
                  } elsif ($line =~ s/^&#x([0-9A-Fa-f]+);//) {
                    push @token, {type => 'text', value => ord hex $1};
                  } elsif ($line =~ s/^([^<&]+)//) {
                    push @token, {type => 'text', value => $1};
                  } else {
                    push @token, {type => 'text', value => substr ($line, 0, 1)};
                    substr ($line, 0, 1) = '';
                  }
                }
                push @token, {type => 'eol'};

                $r = shift @token;
                push @{$self->{token}}, @token;
                last L;
              } elsif ({
                DD => true, DT => true,
                DEL => true, INS => true,
                LI => true,
                RB => true, RT => true,
                STRONG => true,
                YAMI => true,
                EM => true,
                HOUR => true, KION => true, LUNCH => true,
                TAION => true, TENKI => true, THEME => true,
                T1 => true, T2 => true, T3 => true, T4 => true,
                T5 => true, T6 => true, T7 => true, SP => true,
              }->{$command}) {
                if (@value) {
                  unshift @{$self->{line}}, 'DATA {} '.$value[0], '/'.$command;
                }
              } elsif ($command eq 'DIV') {
                if (@value) {
                  $r = {type => 'class', value => $value[0]};
                }
              } elsif ($command eq 'LDIARY') {
                $value[0] =~ s/^([0-9]{4})([0-9]{2})([0-9]{2})/$1, $2, $3/;
                $value[0] =~ s/[is]/, /;
                $r = {type => 'start', value => 'LINK'};
                push @token, {type => 'uri', value => "($value[0])"};
                unshift @{$self->{line}}, 'DATA {} '.$value[1], '/LINK';
              } elsif ($command eq 'LIMG') {
                $r = {type => 'start', value => 'IMG'};
                push @token, {type => 'uri', value => $uriv->($value[0])};
                unshift @{$self->{line}}, 'DATA {} '.$value[3], '/IMG';
              } elsif ($command eq 'LMG') {
                $r = {type => 'start', value => 'IMG'};
                push @token, {type => 'uri', value => $uriv->($value[0])};
                unshift @{$self->{line}}, 'DATA {} '.$value[1], '/IMG';
              } elsif ($command eq 'LINK') {
                if (@value == 2) {
                  push @token, {type => 'uri', value => $uriv->($value[0])};
                  unshift @{$self->{line}}, 'DATA {} '.$value[1], '/LINK';
                } elsif ($flag =~ /\+/) {
                  push @token, {type => 'uri', value => $uriv->($value[0])};
                } else {
                  unshift @{$self->{line}}, 'DATA {} '.$value[0], '/LINK';
                }
              } elsif ($command eq 'NEW') {
                $r = {type => 'start', value => 'SECTION'};
                push @token, {type => 'start', value => 'H'};
                unshift @{$self->{line}}, 'DATA {} '.$value[0], '/H';
              } elsif ($command eq 'SUB') {
                $r = {type => 'start', value => 'SUB'};
                push @token, {type => 'start', value => 'H'};
                unshift @{$self->{line}}, 'DATA {} '.$value[0], '/H';
              } elsif ($command eq 'PERSON') {
                push @token, {type => 'key', value => $attrvalue->($value[0])};
                unshift @{$self->{line}}, 'DATA {} '.$value[1], '/PERSON';
              } elsif ($command eq 'SEE') {
                if (@value == 2) {
                  push @token, {type => 'key', value => $attrvalue->($value[0])};
                  unshift @{$self->{line}}, 'DATA {} '.$value[1], '/SEE';
                } else {
                  unshift @{$self->{line}}, 'DATA {} '.$value[0], '/SEE';
                }
              } elsif ($command eq 'SPAN') {
                if (@value == 2) {
                  push @token, {type => 'class',
                                value => $attrvalue->($value[0])};
                  unshift @{$self->{line}}, 'DATA {} '.$value[1], '/SPAN';
                } else {
                  unshift @{$self->{line}}, 'DATA {} '.$value[0], '/SPAN';
                }
              } elsif ($command eq 'OK') {
                $r = {type => 'end', value => 'HEAD'};
                push @token, {type => 'start', value => 'BODY'};
              } elsif ($command eq 'XML') {
                unshift @{$self->{line}}, 'DATA {} XML '.$line;
                next L;
              }

              for (keys %attr) {
                push @token, {type => $_, value => $attrvalue->($attr{$_})};
              }

              push @{$self->{token}}, @token;
              last L;
            } elsif ($line eq 'H2H/1.0') {
              $r = {type => 'magic', value => 'H2H/1.0'};
              last L;
            } elsif ($line =~ m#^/([A-Z]+)\s*$#) {
              $r = {type => 'end', value => $1};
              last L;
            } else {
              unshift @{$self->{line}}, 'DATA {} '.$line;
              next L;
            }
          } # L
        }

  @Method:
    @@ManakaiDOM:isForInternal: 1
    @@Operator: ManakaiDOM|MUErrorHandler
    @@enDesc:
      When a <IF::ecore|ErrorInterface||ManakaiDOM|Perl> is <Perl::report>ed,
      then this method is invoked.
      
      The method calls the <cfg::DOMCore|error-handler> if the error is of 
      <IF::DOMCore|DOMError>.  Otherwise, the error is re-thrown so that
      corresponding <Perl::catch> clause, if any, can catch the error.
    @@Param:
      @@@Name: err
      @@@Type: ecore|ErrorInterface||ManakaiDOM|Perl
      @@@enDesc:
        The reported error object.
    @@Return:
      @@@Type: DISPerl|Any
      @@@enDesc:
        If the <P::err> is a <IF::DOMCore|DOMError>, then the return value
        of the error handler.

           {NOTE:: If the error is thrown, the method never returns.
           }
      @@@nullCase:
        @@@@enDesc:
          No error handler.
      @@@PerlDef:
        if ($err->isa (<IFName::DOMCore|DOMError||ManakaiDOM|ManakaiDOM>)) {
          __DEEP{
            A: {
              my $cfg = $self-><AG::H2HParser.domConfig>;
              my $h = $cfg-><M::DOMCore|DOMConfiguration.getParameter>
                               ('error-handler');
              $r = $h-><M::DOMCore|DOMErrorHandler.handleError> ($err);
            } # A
          }__;
        } else {
          $err-><M::ecore|ErrorInterface||ManakaiDOM|Perl.throw>;
        }

  @PTests:
    @@PTest:
      @@@QName: p.magic.sw09.test
      @@@DEnt:
        @@@@test:value:
          #?SuikaWiki/0.9
      @@@test:domTree:
        document {
          element {
            namespace-uri: 'urn:x-suika-fam-cx:markup:suikawiki:0:9:';
            local-name: 'document';
            markup-language-name: 'SuikaWiki';
            markup-language-version: '0.9';
            element {
              namespace-uri: 'http://www.w3.org/2002/06/xhtml2/';
              local-name: 'head';
              has-child-nodes: false;
            }
            element {
              namespace-uri: 'http://www.w3.org/2002/06/xhtml2/';
              local-name: 'body';
              has-child-nodes: false;
            }
          }
        }
    @@PTest:
      @@@QName: p.magic.swimg09.test
      @@@DEnt:
        @@@@test:value:
          #?SuikaWikiImage/0.9
      @@@test:domTree:
        document {
          element {
            namespace-uri: 'urn:x-suika-fam-cx:markup:suikawiki:0:9:';
            local-name: 'document';
            markup-language-name: 'SuikaWikiImage';
            markup-language-version: '0.9';
            element {
              namespace-uri: 'http://www.w3.org/2002/06/xhtml2/';
              local-name: 'head';
              has-child-nodes: false;
            }
            element {
              namespace-uri: 'http://www.w3.org/2002/06/xhtml2/';
              local-name: 'body';
              has-child-nodes: false;
            }
          }
        }

    @@PerlDef:
      my $impl = $Message::DOM::ImplementationRegistry->get_implementation ({
        'Core' => '3.0',
        'XML' => '3.0',
      });

      for my $test_data (@$TestData) {
        my $parser = <Class::ManakaiH2HParser>->new ($impl);

        $test->start_new_test ($test_data->{uri});
        my $doc_ent = $test_data->{entity}->{$test_data->{root_uri}};
        my $not_ok;

        ## -- DOM Configuration Parameters

        my $pcfg = $parser->dom_config;
        for (keys %{$test_data->{dom_config}}) {
          $pcfg->set_parameter ($_ => $test_data->{dom_config}->{$_});
        }

#        $pcfg->set_parameter ('error-handler' => sub ($$) {
#          my (undef, $err) = @_;
#	  my $err_type = $err->type;
#	  if ($test_data->{dom_error}->{$err_type}) {
#            $test->assert_error_equals
#                     (actual_value => $err,
#                      expected_hash => shift @{$test_data->{dom_error}
#                                                         ->{$err_type}});
#          } else { # Uncatched error
#            warn $err;
#            unless ($err->severity == <C::c|DOMError.SEVERITY_WARNING>) {
#              $test->failure_comment ('Unexpected error |'.$err->type.'|');
#              $not_ok = true;
#            }
#          }
#          return true; # continue as far as possible
#        });

        ## -- Test and Result

          my $doc;
          try {
            $doc = $parser->parse_string ($doc_ent->{<Q::test|value>});
            $test->assert_dom_tree_equals
                     (actual_value => $doc,
                      expected_hash => $test_data->{dom_tree});
            for (values %{$test_data->{dom_error}||{}}) {
              if (@$_) {
                $test->failure_comment
                         (@$_.' |DOMError|s of type |'.
                          $_->[0]->{type}->{value}.'| are not reported');
                $not_ok = true;
              }
            }
            $not_ok ? $test->not_ok : $test->ok;
            undef $doc;
          } catch Message::Util::IF::DTException with {
            require Message::DOM::SimpleLS;
            my $ls = Message::DOM::SimpleLS::ManakaiDOMSimpleXMLSerializer->new;
            print STDERR $ls->write_to_string ($doc);
          } otherwise {
            my $err = shift;
            warn $err;
            $test->not_ok;
          };
      }
##H2HParser

