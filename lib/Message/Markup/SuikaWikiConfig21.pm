#!/usr/bin/perl 
## This file is automatically generated
## 	at 2005-11-23T07:40:56+00:00,
## 	from file "lib/Message/Markup/SuikaWikiConfig21.dis",
## 	module <http://suika.fam.cx/~wakaba/archive/2005/manakai/Markup#SuikaWikiConfig21>,
## 	for <http://suika.fam.cx/~wakaba/archive/2005/swcfg21#ForLatest>.
## Don't edit by hand!
use strict;
require Message::DOM::DOMFeature;
require Message::DOM::DOMLS;
require Message::Util::Error;
require Message::Util::Error::DOMException;
require Message::Util::ManakaiNode;
require Tie::Array;
package Message::Markup::SuikaWikiConfig21;
our $VERSION = 20051123.0740;
sub HIERARCHY_REQUEST_ERR ();
sub NAMESPACE_ERR ();
sub NOT_SUPPORTED_ERR ();
sub PARSE_ERR ();
sub TYPE_MISMATCH_ERR ();
sub WRONG_DOCUMENT_ERR ();
sub AUTOLOAD {


        my $al = our $AUTOLOAD;
        $al =~ s/.+:://;
        if ({'HIERARCHY_REQUEST_ERR', 'Message::Markup::IFLatest::SWCFGException::HIERARCHY_REQUEST_ERR', 'NAMESPACE_ERR', 'Message::Markup::IFLatest::SWCFGException::NAMESPACE_ERR', 'NOT_SUPPORTED_ERR', 'Message::Markup::IFLatest::SWCFGException::NOT_SUPPORTED_ERR', 'PARSE_ERR', 'Message::Markup::IFLatest::SWCFGException::PARSE_ERR', 'TYPE_MISMATCH_ERR', 'Message::Markup::IFLatest::SWCFGException::TYPE_MISMATCH_ERR', 'WRONG_DOCUMENT_ERR', 'Message::Markup::IFLatest::SWCFGException::WRONG_DOCUMENT_ERR'}->{$al}) {
          no strict 'refs';
          *{$AUTOLOAD} = \&{{'HIERARCHY_REQUEST_ERR', 'Message::Markup::IFLatest::SWCFGException::HIERARCHY_REQUEST_ERR', 'NAMESPACE_ERR', 'Message::Markup::IFLatest::SWCFGException::NAMESPACE_ERR', 'NOT_SUPPORTED_ERR', 'Message::Markup::IFLatest::SWCFGException::NOT_SUPPORTED_ERR', 'PARSE_ERR', 'Message::Markup::IFLatest::SWCFGException::PARSE_ERR', 'TYPE_MISMATCH_ERR', 'Message::Markup::IFLatest::SWCFGException::TYPE_MISMATCH_ERR', 'WRONG_DOCUMENT_ERR', 'Message::Markup::IFLatest::SWCFGException::WRONG_DOCUMENT_ERR'}->{$al}};
          goto &{$AUTOLOAD};
        } else {
          require Carp;
          Carp::croak (qq<Can't locate method "$AUTOLOAD">);
        }
      
}
sub import {


        my $self = shift;
        if (@_) {
          local $Exporter::ExportLevel = $Exporter::ExportLevel + 1;
          $self->SUPER::import (@_);
          for (grep {not /\W/} @_) {
            eval qq{$_};
          }
        }
      
}
our %EXPORT_TAG = ('SWCFGExceptionCode', ['HIERARCHY_REQUEST_ERR', 'NAMESPACE_ERR', 'NOT_SUPPORTED_ERR', 'PARSE_ERR', 'TYPE_MISMATCH_ERR', 'WRONG_DOCUMENT_ERR']);
our @EXPORT_OK = ('HIERARCHY_REQUEST_ERR', 'NAMESPACE_ERR', 'NOT_SUPPORTED_ERR', 'PARSE_ERR', 'TYPE_MISMATCH_ERR', 'WRONG_DOCUMENT_ERR');
use Exporter; push our @ISA, 'Exporter';
package Message::Markup::IFLatest::SWCFGNode;
our $VERSION = 20051123.0740;
package Message::Markup::SuikaWikiConfig21::ManakaiSWCFGNode;
our $VERSION = 20051123.0740;
push our @ISA, 'Message::Util::ManakaiNode::ManakaiNodeRef', 'Message::Util::Error::DOMException::ManakaiDefaultExceptionHandler', 'Message::Markup::IF::SWCFGNode', 'Message::Markup::IFLatest::SWCFGNode';
sub append_node ($$%) {
my ($self, $node, %opt) = @_;
my $r;

{

unless 
(UNIVERSAL::isa ($node, 
'Message::Markup::IFLatest::SWCFGNode'
) or
        UNIVERSAL::isa ($node, 
'Message::Markup::SuikaWikiConfig21::ManakaiSWCFGNode'
)) {
          ## NOTE: dis.pl and cdis2pm.pl does not support
          ##       interface "implement"ing in this case
  if ($opt{node_or_text}) {
    

{

local $Error::Depth = $Error::Depth + 1;

{



      $r = $self->
append_text
 ($node);
    


;}


;}

;
  } else {
    
report Message::Markup::SuikaWikiConfig21::ManakaiSWCFGException -object => $self, '-type' => 'TYPE_MISMATCH_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'append_node', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#NOT_NODE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::Markup::SuikaWikiConfig21::ManakaiSWCFGNode', 'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#actualType' => ref $node;

;
  }
} else {
  my $this_node_type = $self->
node_type
;
  my $that_node_type = $node->
node_type
;
  if ($this_node_type eq '#comment') {
    
report Message::Markup::SuikaWikiConfig21::ManakaiSWCFGException -object => $self, '-type' => 'HIERARCHY_REQUEST_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'append_node', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#HIERARCHY_BAD_TYPE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::Markup::SuikaWikiConfig21::ManakaiSWCFGNode', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#param-name' => 'node', 'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#parentNodeType' => $this_node_type, 'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#childNodeType' => $that_node_type;

;
  } elsif ($this_node_type ne '#document') {
    if ($that_node_type eq '#comment') {
      
report Message::Markup::SuikaWikiConfig21::ManakaiSWCFGException -object => $self, '-type' => 'HIERARCHY_REQUEST_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'append_node', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#HIERARCHY_BAD_TYPE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::Markup::SuikaWikiConfig21::ManakaiSWCFGNode', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#param-name' => 'node', 'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#parentNodeType' => $this_node_type, 'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#childNodeType' => $that_node_type;

;
    }
  } else {
    if ($that_node_type eq '#document' or
        $that_node_type eq '#fragment') {
      
report Message::Markup::SuikaWikiConfig21::ManakaiSWCFGException -object => $self, '-type' => 'HIERARCHY_REQUEST_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'append_node', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#HIERARCHY_BAD_TYPE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::Markup::SuikaWikiConfig21::ManakaiSWCFGNode', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#param-name' => 'node', 'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#parentNodeType' => $this_node_type, 'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#childNodeType' => $that_node_type;

;
    }
  }
  unless (($self->
owner_document
 || $self) eq
      $node->
owner_document
) {
    
report Message::Markup::SuikaWikiConfig21::ManakaiSWCFGException -object => $self, '-type' => 'WRONG_DOCUMENT_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'append_node', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#EXTERNAL_NODE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::Markup::SuikaWikiConfig21::ManakaiSWCFGNode', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#param-name' => 'node';

;
  }
  my $this_node = $node;
  ANCESTOR: {
    if ($this_node eq $self) {
      
report Message::Markup::SuikaWikiConfig21::ManakaiSWCFGException -object => $self, '-type' => 'HIERARCHY_REQUEST_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'append_node', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#HIERARCHY_ANCESTOR_OR_SELF_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::Markup::SuikaWikiConfig21::ManakaiSWCFGNode', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#param-name' => 'node';

;
    }
    redo ANCESTOR if $this_node = $this_node->
parent_node
;
  }

  if ($node->
node_type eq 
'#fragment') {
    $self->{
'node'
}
         ->
_import_tree
 ($node->{
'node'
});
    for my $cn (@{$node->{
'node'
}->{
'swcn'
}}) {
      $cn->{
'p'
} = $self->{
'node'
};
    }
    push @{$self->{
'node'
}->{
'swcn'
}}, 
         @{$node->{
'node'
}->{
'swcn'
}};
    $node->{
'node'
}->{
'swcn'
} = [];
    $node->{
'node'
}->
_orphanate
;
    $r = $self;
  } else {
    if ($node->{
'node'
}->{
'p'
}) {
      my @pl = $node->{
'node'
}->{
'p'
}
                                          ->{
'swcn'
};
      for my $i (0..$#pl) {
        if ($pl[$i] eq $node->{
'node'
}) {
          splice @pl, $i, 1, ();
          last;
        }
      }
    }
    $self->{
'node'
}->
_import_tree
 ($node->{
'node'
});
    push @{$self->{
'node'
}->{
'swcn'
}},
         $node->{
'node'
};
    $node->{
'node'
}->{
'p'
}
                     = $self->{
'node'
};
    $r = $node;
  }
}


;}
$r}
sub append_new_node ($%) {
my ($self, %opt) = @_;
my $r;

{

my 
$this_type = $self->
node_type
;
if ($this_type eq '#comment') {
  
report Message::Markup::SuikaWikiConfig21::ManakaiSWCFGException -object => $self, '-type' => 'HIERARCHY_REQUEST_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'append_new_node', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#HIERARCHY_BAD_TYPE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::Markup::SuikaWikiConfig21::ManakaiSWCFGNode', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#param-name' => 'type', 'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#parentNodeType' => $this_type, 'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#childNodeType' => $opt{type};

;
}
if ($opt{type} eq '#element') {
  

{

local $Error::Depth = $Error::Depth + 1;

{



    $r = ($self->
owner_document
 || $self)
               ->
create_element_ns

                          ($opt{namespace_uri}, $opt{local_name});
  


;}


;}

;
  $r->{
'node'
}->{
'swval'
} = $opt{value}
    if defined $opt{value};
} elsif ($opt{type} eq '#comment') {
  if ($this_type ne '#document') {
    
report Message::Markup::SuikaWikiConfig21::ManakaiSWCFGException -object => $self, '-type' => 'HIERARCHY_REQUEST_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'append_new_node', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#HIERARCHY_BAD_TYPE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::Markup::SuikaWikiConfig21::ManakaiSWCFGNode', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#param-name' => 'type', 'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#parentNodeType' => $this_type, 'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#childNodeType' => $opt{type};

;
  }
  

{

local $Error::Depth = $Error::Depth + 1;

{



    $r = ($self->
owner_document
 || $self)
                     ->
create_comment
 ($opt{value});
  


;}


;}

;
} else {
  
report Message::Markup::SuikaWikiConfig21::ManakaiSWCFGException -object => $self, '-type' => 'HIERARCHY_REQUEST_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'append_new_node', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#HIERARCHY_BAD_TYPE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::Markup::SuikaWikiConfig21::ManakaiSWCFGNode', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#param-name' => 'type', 'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#parentNodeType' => $this_type, 'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#childNodeType' => $opt{type};

;
}
$self->{
'node'
}->
_import_tree
 ($r->{
'node'
});
push @{$self->{
'node'
}->{
'swcn'
}},
     $r->{
'node'
};
$r->{
'node'
}->{
'p'
} = $self->{
'node'
};


;}
$r}
sub append_text ($$) {
my ($self, $text) = @_;

{

my 
$node = $self->{
'node'
};
my $nt = $self->
node_type
;
if ($nt eq '#document') {
  
report Message::Markup::SuikaWikiConfig21::ManakaiSWCFGException -object => $self, '-type' => 'HIERARCHY_REQUEST_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'append_text', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#HIERARCHY_NO_VALUE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::Markup::SuikaWikiConfig21::ManakaiSWCFGNode', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#param-name' => 'text', 'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#parentNodeType' => $nt;

;
} elsif (ref ($node->{
'swval'
}) eq 'ARRAY') {
  push @{$node->{
'swval'
}}, $text;
} elsif (defined $node->{
'swval'
}) {
  $node->{
'swval'
} .= $text;
} else {
  

{

unless 
($node->{
'etx'
}) {
  my $__qn;
  if ($node->{
'nsx'
}) {
    $__qn = $self->
_get_node_reference
 ($node)
            ->
real_qualified_name
;
  } else {
    $__qn = $node->{
'swln'
};

  }
  my $__od = $node->{
'swod'
};
  if ($__od->{
'swetb'
}->{$__qn}) {
    my $b = $__od->{
'swetb'
}->{$__qn};
    $node->{
'swns'
} = 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#RealName'
;
    if ($node->{
'nsx'
}) {
      $node->{
'swln'
} = $__qn;
    } else {
      $node->{
'nsx'
} = 
1
;
    }
    unless ($b->{namespaceExpanded}) {
      if ($b->{shadowLocalName} =~ s/^([^:]*)://) {
        my $__prefix = $1;
        

{

local $Error::Depth = $Error::Depth + 1;

{



          $b->{shadowNamespaceURI}
             = $self->
_get_node_reference
 ($__od)
                     ->
lookup_namespace_uri

                           ($__prefix, make_new_binding => 
0
,
                            raise_prefix_exception => 
1
);
        


;}


;}

;
      }
      $b->{namespaceExpanded} = 
1
;
    }
    $node->{
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowNamespaceURI'
} = $b->{shadowNamespaceURI};
    $node->{
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowLocalName'
} = $b->{shadowLocalName};
    for my $__p (qw/shadowContent shadowSibling/) {
      next unless $b->{$__p};
      my $cl = $self->
_get_node_reference
 ($b->{$__p})
                  ->clone;
      my $__n = $node->{{shadowContent => 
'shadow'
,
                         shadowSibling => 
'shadowsib'
}->{$__p}}
         = $cl->{
'node'
};
      $node->
_import_tree
 ($__n);
      $__n->{{shadowContent => 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowParent'
,
              shadowSibling => 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowSiblingOf'
}->{$__p}} = $node;
    }
  }
  $node->{
'etx'
} = 
1
;
}


;}

;
  if (defined $node->{
'shadow'
} and
      defined $node->{
'shadow'
}->{
'swval'
}) {
    $node->{
'swval'
}
       = $node->{
'shadow'
}->{
'swval'
} . $text;
  } else {
    $node->{
'swval'
} = $text;
  }
}


;}
}
sub remove_child_node ($$) {
my ($self, $node) = @_;

{

my 
$n = $node->{
'node'
};
$self->{
'node'
}->{
'swcn'
}
   = [grep {not $_ eq $n} @{$self->{
'node'
}
                                 ->{
'swcn'
}}];
$node->{
'node'
}->
_orphanate
;


;}
}
sub get_attribute ($$%) {
my ($self, $localName, %opt) = @_;
my $r;

{

FIND: 
{
  my $node = $self->{
'node'
};
  

{

unless 
($node->{
'etx'
}) {
  my $__qn;
  if ($node->{
'nsx'
}) {
    $__qn = $self->
_get_node_reference
 ($node)
            ->
real_qualified_name
;
  } else {
    $__qn = $node->{
'swln'
};

  }
  my $__od = $node->{
'swod'
};
  if ($__od->{
'swetb'
}->{$__qn}) {
    my $b = $__od->{
'swetb'
}->{$__qn};
    $node->{
'swns'
} = 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#RealName'
;
    if ($node->{
'nsx'
}) {
      $node->{
'swln'
} = $__qn;
    } else {
      $node->{
'nsx'
} = 
1
;
    }
    unless ($b->{namespaceExpanded}) {
      if ($b->{shadowLocalName} =~ s/^([^:]*)://) {
        my $__prefix = $1;
        

{

local $Error::Depth = $Error::Depth + 1;

{



          $b->{shadowNamespaceURI}
             = $self->
_get_node_reference
 ($__od)
                     ->
lookup_namespace_uri

                           ($__prefix, make_new_binding => 
0
,
                            raise_prefix_exception => 
1
);
        


;}


;}

;
      }
      $b->{namespaceExpanded} = 
1
;
    }
    $node->{
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowNamespaceURI'
} = $b->{shadowNamespaceURI};
    $node->{
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowLocalName'
} = $b->{shadowLocalName};
    for my $__p (qw/shadowContent shadowSibling/) {
      next unless $b->{$__p};
      my $cl = $self->
_get_node_reference
 ($b->{$__p})
                  ->clone;
      my $__n = $node->{{shadowContent => 
'shadow'
,
                         shadowSibling => 
'shadowsib'
}->{$__p}}
         = $cl->{
'node'
};
      $node->
_import_tree
 ($__n);
      $__n->{{shadowContent => 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowParent'
,
              shadowSibling => 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowSiblingOf'
}->{$__p}} = $node;
    }
  }
  $node->{
'etx'
} = 
1
;
}


;}

;
  my @c = (@{$node->{
'swcn'
}},
           ($node->{
'shadow'
}
            ? @{$node->{
'shadow'
}
                     ->{
'swcn'
}} : ()));
  while (@c) {
    my $c = $self->
_get_node_reference

                                          (my $cn = shift @c);
    if ($c->
node_type eq 
'#element' and
        $c->
local_name eq 
$localName) {
      $r = $c;
      last FIND;
    }
    

{

unless 
($cn->{
'etx'
}) {
  my $__qn;
  if ($cn->{
'nsx'
}) {
    $__qn = $self->
_get_node_reference
 ($cn)
            ->
real_qualified_name
;
  } else {
    $__qn = $cn->{
'swln'
};

  }
  my $__od = $cn->{
'swod'
};
  if ($__od->{
'swetb'
}->{$__qn}) {
    my $b = $__od->{
'swetb'
}->{$__qn};
    $cn->{
'swns'
} = 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#RealName'
;
    if ($cn->{
'nsx'
}) {
      $cn->{
'swln'
} = $__qn;
    } else {
      $cn->{
'nsx'
} = 
1
;
    }
    unless ($b->{namespaceExpanded}) {
      if ($b->{shadowLocalName} =~ s/^([^:]*)://) {
        my $__prefix = $1;
        

{

local $Error::Depth = $Error::Depth + 1;

{



          $b->{shadowNamespaceURI}
             = $self->
_get_node_reference
 ($__od)
                     ->
lookup_namespace_uri

                           ($__prefix, make_new_binding => 
0
,
                            raise_prefix_exception => 
1
);
        


;}


;}

;
      }
      $b->{namespaceExpanded} = 
1
;
    }
    $cn->{
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowNamespaceURI'
} = $b->{shadowNamespaceURI};
    $cn->{
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowLocalName'
} = $b->{shadowLocalName};
    for my $__p (qw/shadowContent shadowSibling/) {
      next unless $b->{$__p};
      my $cl = $self->
_get_node_reference
 ($b->{$__p})
                  ->clone;
      my $__n = $cn->{{shadowContent => 
'shadow'
,
                         shadowSibling => 
'shadowsib'
}->{$__p}}
         = $cl->{
'node'
};
      $cn->
_import_tree
 ($__n);
      $__n->{{shadowContent => 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowParent'
,
              shadowSibling => 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowSiblingOf'
}->{$__p}} = $cn;
    }
  }
  $cn->{
'etx'
} = 
1
;
}


;}

;
    if ($cn->{
'shadowsib'
}) {
      push @c, @{$cn->{
'shadowsib'
}->{
'swcn'
}};
    }
  }
  ## Not found
  if ($opt{make_new_node}) {
    

{

local $Error::Depth = $Error::Depth + 1;

{



      $r = ($self->
owner_document
 || $self)
                ->
create_element_ns
 (
undef
, $localName);
      $self->
append_node
 ($r);
    


;}


;}

;
  }
} # FIND


;}
$r}
sub get_attribute_ns ($$$%) {
my ($self, $namespaceURI, $localName, %opt) = @_;
my $r;

{

FIND: 
{
  my $node = $self->{
'node'
};
  

{

unless 
($node->{
'etx'
}) {
  my $__qn;
  if ($node->{
'nsx'
}) {
    $__qn = $self->
_get_node_reference
 ($node)
            ->
real_qualified_name
;
  } else {
    $__qn = $node->{
'swln'
};

  }
  my $__od = $node->{
'swod'
};
  if ($__od->{
'swetb'
}->{$__qn}) {
    my $b = $__od->{
'swetb'
}->{$__qn};
    $node->{
'swns'
} = 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#RealName'
;
    if ($node->{
'nsx'
}) {
      $node->{
'swln'
} = $__qn;
    } else {
      $node->{
'nsx'
} = 
1
;
    }
    unless ($b->{namespaceExpanded}) {
      if ($b->{shadowLocalName} =~ s/^([^:]*)://) {
        my $__prefix = $1;
        

{

local $Error::Depth = $Error::Depth + 1;

{



          $b->{shadowNamespaceURI}
             = $self->
_get_node_reference
 ($__od)
                     ->
lookup_namespace_uri

                           ($__prefix, make_new_binding => 
0
,
                            raise_prefix_exception => 
1
);
        


;}


;}

;
      }
      $b->{namespaceExpanded} = 
1
;
    }
    $node->{
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowNamespaceURI'
} = $b->{shadowNamespaceURI};
    $node->{
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowLocalName'
} = $b->{shadowLocalName};
    for my $__p (qw/shadowContent shadowSibling/) {
      next unless $b->{$__p};
      my $cl = $self->
_get_node_reference
 ($b->{$__p})
                  ->clone;
      my $__n = $node->{{shadowContent => 
'shadow'
,
                         shadowSibling => 
'shadowsib'
}->{$__p}}
         = $cl->{
'node'
};
      $node->
_import_tree
 ($__n);
      $__n->{{shadowContent => 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowParent'
,
              shadowSibling => 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowSiblingOf'
}->{$__p}} = $node;
    }
  }
  $node->{
'etx'
} = 
1
;
}


;}

;
  my @c = (@{$node->{
'swcn'
}},
           ($node->{
'shadow'
}
            ? @{$node->{
'shadow'
}
                     ->{
'swcn'
}} : ()));
  while (@c) {
    my $c = $self->
_get_node_reference

                                       (my $cn = shift @c);
    if ($c->
node_type eq 
'#element' and
        ((not defined $namespaceURI and 
          not defined $c->
namespace_uri
) or
         (defined $namespaceURI and
          defined $c->
namespace_uri and
          
$namespaceURI eq $c->
namespace_uri
)) and
        $c->
local_name eq 
$localName) {
      $r = $c;
      last FIND;
    }
    

{

unless 
($cn->{
'etx'
}) {
  my $__qn;
  if ($cn->{
'nsx'
}) {
    $__qn = $self->
_get_node_reference
 ($cn)
            ->
real_qualified_name
;
  } else {
    $__qn = $cn->{
'swln'
};

  }
  my $__od = $cn->{
'swod'
};
  if ($__od->{
'swetb'
}->{$__qn}) {
    my $b = $__od->{
'swetb'
}->{$__qn};
    $cn->{
'swns'
} = 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#RealName'
;
    if ($cn->{
'nsx'
}) {
      $cn->{
'swln'
} = $__qn;
    } else {
      $cn->{
'nsx'
} = 
1
;
    }
    unless ($b->{namespaceExpanded}) {
      if ($b->{shadowLocalName} =~ s/^([^:]*)://) {
        my $__prefix = $1;
        

{

local $Error::Depth = $Error::Depth + 1;

{



          $b->{shadowNamespaceURI}
             = $self->
_get_node_reference
 ($__od)
                     ->
lookup_namespace_uri

                           ($__prefix, make_new_binding => 
0
,
                            raise_prefix_exception => 
1
);
        


;}


;}

;
      }
      $b->{namespaceExpanded} = 
1
;
    }
    $cn->{
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowNamespaceURI'
} = $b->{shadowNamespaceURI};
    $cn->{
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowLocalName'
} = $b->{shadowLocalName};
    for my $__p (qw/shadowContent shadowSibling/) {
      next unless $b->{$__p};
      my $cl = $self->
_get_node_reference
 ($b->{$__p})
                  ->clone;
      my $__n = $cn->{{shadowContent => 
'shadow'
,
                         shadowSibling => 
'shadowsib'
}->{$__p}}
         = $cl->{
'node'
};
      $cn->
_import_tree
 ($__n);
      $__n->{{shadowContent => 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowParent'
,
              shadowSibling => 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowSiblingOf'
}->{$__p}} = $cn;
    }
  }
  $cn->{
'etx'
} = 
1
;
}


;}

;
    if ($cn->{
'shadowsib'
}) {
      push @c, @{$cn->{
'shadowsib'
}->{
'swcn'
}};
    }
  }
  ## Not found
  if ($opt{make_new_node}) {
    

{

local $Error::Depth = $Error::Depth + 1;

{



      $r = ($self->
owner_document
 || $self)
                ->
create_element_ns

                         ($namespaceURI, $localName);
      $self->
append_node
 ($r);
    


;}


;}

;
  }
} # FIND


;}
$r}
sub get_attribute_value ($$%) {
my ($self, $localName, %opt) = @_;
my $r = '';

{


{

local $Error::Depth = $Error::Depth + 1;

{


  my 
$node = $self->
get_attribute
 ($localName);
  if (ref $node) {
    $r = $node->
value
 (%opt);
    if ($opt{default_list} and ref $r eq 'ARRAY' and @$r == 0) {
      $r = $opt{default_list};
    }
  } else {
    $r = $opt{default_list} || $opt{default};
  }



;}


;}

;


;}
$r}
sub get_attribute_value_ns ($$$%) {
my ($self, $namespaceURI, $localName, %opt) = @_;
my $r = '';

{


{

local $Error::Depth = $Error::Depth + 1;

{


  my 
$node = $self->
get_attribute_ns

                         ($namespaceURI, $localName);
  if (ref $node) {
    $r = $node->
value
 (%opt);
    if ($opt{default_list} and ref $r eq 'ARRAY' and @$r == 0) {
      $r = $opt{default_list};
    }
  } else {
    $r = $opt{default_list} || $opt{default};
  }



;}


;}

;


;}
$r}
sub get_element_by ($$;%) {
my ($self, $code, %opt) = @_;
my $r;

{

FIND: 
{
  my $node = $self->{
'node'
};
  

{

unless 
($node->{
'etx'
}) {
  my $__qn;
  if ($node->{
'nsx'
}) {
    $__qn = $self->
_get_node_reference
 ($node)
            ->
real_qualified_name
;
  } else {
    $__qn = $node->{
'swln'
};

  }
  my $__od = $node->{
'swod'
};
  if ($__od->{
'swetb'
}->{$__qn}) {
    my $b = $__od->{
'swetb'
}->{$__qn};
    $node->{
'swns'
} = 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#RealName'
;
    if ($node->{
'nsx'
}) {
      $node->{
'swln'
} = $__qn;
    } else {
      $node->{
'nsx'
} = 
1
;
    }
    unless ($b->{namespaceExpanded}) {
      if ($b->{shadowLocalName} =~ s/^([^:]*)://) {
        my $__prefix = $1;
        

{

local $Error::Depth = $Error::Depth + 1;

{



          $b->{shadowNamespaceURI}
             = $self->
_get_node_reference
 ($__od)
                     ->
lookup_namespace_uri

                           ($__prefix, make_new_binding => 
0
,
                            raise_prefix_exception => 
1
);
        


;}


;}

;
      }
      $b->{namespaceExpanded} = 
1
;
    }
    $node->{
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowNamespaceURI'
} = $b->{shadowNamespaceURI};
    $node->{
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowLocalName'
} = $b->{shadowLocalName};
    for my $__p (qw/shadowContent shadowSibling/) {
      next unless $b->{$__p};
      my $cl = $self->
_get_node_reference
 ($b->{$__p})
                  ->clone;
      my $__n = $node->{{shadowContent => 
'shadow'
,
                         shadowSibling => 
'shadowsib'
}->{$__p}}
         = $cl->{
'node'
};
      $node->
_import_tree
 ($__n);
      $__n->{{shadowContent => 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowParent'
,
              shadowSibling => 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowSiblingOf'
}->{$__p}} = $node;
    }
  }
  $node->{
'etx'
} = 
1
;
}


;}

;
  

{

local $Error::Depth = $Error::Depth + 1;

{


    my 
@c = (@{$node->{
'swcn'
}},
             ($node->{
'shadow'
}
              ? @{$node->{
'shadow'
}
                       ->{
'swcn'
}} : ()));
    while (@c) {
      my $this = $self->
_get_node_reference

                      (my $t = shift @c);
      if ($t->{
'swnt'
} eq '#element' and
          $code->($self, $this, %opt)) {
        $r = $this;
        last FIND;
      }
      

{

unless 
($t->{
'etx'
}) {
  my $__qn;
  if ($t->{
'nsx'
}) {
    $__qn = $self->
_get_node_reference
 ($t)
            ->
real_qualified_name
;
  } else {
    $__qn = $t->{
'swln'
};

  }
  my $__od = $t->{
'swod'
};
  if ($__od->{
'swetb'
}->{$__qn}) {
    my $b = $__od->{
'swetb'
}->{$__qn};
    $t->{
'swns'
} = 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#RealName'
;
    if ($t->{
'nsx'
}) {
      $t->{
'swln'
} = $__qn;
    } else {
      $t->{
'nsx'
} = 
1
;
    }
    unless ($b->{namespaceExpanded}) {
      if ($b->{shadowLocalName} =~ s/^([^:]*)://) {
        my $__prefix = $1;
        

{

local $Error::Depth = $Error::Depth + 1;

{



          $b->{shadowNamespaceURI}
             = $self->
_get_node_reference
 ($__od)
                     ->
lookup_namespace_uri

                           ($__prefix, make_new_binding => 
0
,
                            raise_prefix_exception => 
1
);
        


;}


;}

;
      }
      $b->{namespaceExpanded} = 
1
;
    }
    $t->{
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowNamespaceURI'
} = $b->{shadowNamespaceURI};
    $t->{
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowLocalName'
} = $b->{shadowLocalName};
    for my $__p (qw/shadowContent shadowSibling/) {
      next unless $b->{$__p};
      my $cl = $self->
_get_node_reference
 ($b->{$__p})
                  ->clone;
      my $__n = $t->{{shadowContent => 
'shadow'
,
                         shadowSibling => 
'shadowsib'
}->{$__p}}
         = $cl->{
'node'
};
      $t->
_import_tree
 ($__n);
      $__n->{{shadowContent => 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowParent'
,
              shadowSibling => 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowSiblingOf'
}->{$__p}} = $t;
    }
  }
  $t->{
'etx'
} = 
1
;
}


;}

;
      if ($t->{
'shadowsib'
}) {
        push @c, @{$t->{
'shadowsib'
}->{
'swcn'
}};
      }
    }
  


;}


;}

;
  ## Not found
  if ($opt{make_new_node}) {
    

{

local $Error::Depth = $Error::Depth + 1;

{



      $r = $self->
append_new_node

                        (type => '#element',
                         namespace_uri =>
                             ($self->
owner_document
 ||
                              $self)
                                  ->
default_element_type_namespace_uri
,
                         local_name => 'Node');
      if (ref $opt{make_new_node} eq 'CODE') {
        $opt{make_new_node}->($self, $r, %opt);
      }
    


;}


;}

;
  }
} # FIND


;}
$r}
sub set_attribute ($$$) {
my ($self, $localName, $value) = @_;
my $r;

{

if 
({qw/HASH 1 CODE 1/}->{ref ($value)}) {
  
report Message::Markup::SuikaWikiConfig21::ManakaiSWCFGException -object => $self, '-type' => 'TYPE_MISMATCH_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'set_attribute', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#BAD_VALUE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::Markup::SuikaWikiConfig21::ManakaiSWCFGNode', 'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#actualType' => ref $value;

;
}

FIND: {
  for my $cn (@{$self->{
'node'
}->{
'swcn'
}}) {
    my $c = $self->
_get_node_reference
 ($cn);
    if ($c->
node_type eq 
'#element' and
        $c->
local_name eq 
$localName) {
      $r = $c;
      $r->{
'node'
}->{
'swval'
} = $value;
      for my $rcn (@{$r->{
'node'
}->{
'swcn'
}}) {
        CORE::delete $rcn->{
'p'
};
        $rcn->
_orphanate
;
      }
      $r->{
'node'
}->{
'swcn'
} = [];
      last FIND;
    }
  }
  ## Not found
  

{

local $Error::Depth = $Error::Depth + 1;

{



    $r = ($self->
owner_document
 || $self)
              ->
create_element_ns
 (
undef
, $localName);
    $self->
append_node
 ($r);
    $r->{
'node'
}->{
'swval'
} = $value;
  


;}


;}

;
} # FIND


;}
$r}
sub set_attribute_ns ($$$$) {
my ($self, $namespaceURI, $localName, $value) = @_;
my $r;

{

if 
({qw/HASH 1 CODE 1/}->{ref ($value)}) {
  
report Message::Markup::SuikaWikiConfig21::ManakaiSWCFGException -object => $self, '-type' => 'TYPE_MISMATCH_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'set_attribute_ns', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#BAD_VALUE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::Markup::SuikaWikiConfig21::ManakaiSWCFGNode', 'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#actualType' => ref $value;

;
}

FIND: {
  for my $cn (@{$self->{
'node'
}->{
'swcn'
}}) {
    my $c = $self->
_get_node_reference
 ($cn);
    my $cnsuri = $c->
namespace_uri
;
    if ($c->
node_type eq 
'#element' and
        ((not defined $namespaceURI and 
          not defined $cnsuri) or
         (defined $namespaceURI and defined $cnsuri and
          $namespaceURI eq $cnsuri)) and
        $cn->
local_name eq 
$localName) {
      $r = $c;
      $r->{
'node'
}->{
'swval'
} = $value;
      for my $rcn (@{$r->{
'node'
}->{
'swcn'
}}) {
        CORE::delete $rcn->{
'p'
};
        $rcn->
_orphanate
;
      }
      $r->{
'node'
}->{
'swcn'
} = [];
      last FIND;
    }
  }
  ## Not found
  

{

local $Error::Depth = $Error::Depth + 1;

{



    $r = ($self->
owner_document
 || $self)
              ->
create_element_ns

                                ($namespaceURI, $localName);
    $self->
append_node
 ($r);
    $r->{
'node'
}->{
'swval'
} = $value;
  


;}


;}

;
} # FIND


;}
$r}
sub remove_attribute ($$) {
my ($self, $localName) = @_;
my $r = 0;

{

my 
@removed;
$self->{
'node'
}->{
'swcn'
} = [grep {
  my $c = $self->
_get_node_reference
 ($_);
  if ($c->
node_type eq 
'#element' and
      $c->
local_name eq 
$localName) {
    push @removed, $_;
    CORE::delete $_->{
'p'
};
    
0
;
  } else {
    
1
;
  }
} @{$self->{
'node'
}->{
'swcn'
}}];
for my $n (@removed) {
  $n->
_orphanate
;
}
$r = 
1
;


;}
$r}
sub remove_attribute_ns ($$$) {
my ($self, $namespaceURI, $localName) = @_;
my $r = 0;

{

my 
@removed;
$self->{
'node'
}->{
'swcn'
} = [grep {
  my $c = $self->
_get_node_reference
 ($_);
  my $cnsuri = $c->
namespace_uri
;
  if ($c->
node_type eq 
'#element' and
      ((not defined $namespaceURI and not defined $cnsuri) or
       (defined $namespaceURI and defined $cnsuri and
        $namespaceURI eq $cnsuri)) and
      $c->
local_name eq 
$localName) {
    push @removed, $_;
    CORE::delete $_->{
'p'
};
    
0
;
  } else {
    
1
;
  }
} @{$self->{
'node'
}->{
'swcn'
}}];
for my $n (@removed) {
  $n->
_orphanate
;
}
$r = 
1
;


;}
$r}
sub child_nodes ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r;

{


{


$self->{'node'}->{
'rc'
}++;
${$self->{'node'}->{
'grc'
}}++;
$r = bless {
  
'node'
 => $self->{'node'},
}, 'Message::Markup::SuikaWikiConfig21::ManakaiSWCFGChildNodeList';


;}

;
$r->{nodeClass} = ref $self;


;}
$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::Markup::SuikaWikiConfig21::ManakaiSWCFGNode', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'child_nodes';
}
}
sub local_name ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r = '';
$r;
} else {my ($self, $given) = @_;
}
}
sub namespace_uri ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r = '';
$r;
} else {my ($self, $given) = @_;
}
}
sub node_type ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r = '';
$r = '#element';
$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::Markup::SuikaWikiConfig21::ManakaiSWCFGNode', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'node_type';
}
}
sub parent_node ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r;

{


$r = $self->{
'node'
}->{
'p'
};
if ($r) {
  if ($r->{
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowParent'
}) {
    $r = $r->{
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowParent'
};
  } elsif ($r->{
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowSiblingOf'
}) {
    $r = $r->{
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowSiblingOf'
}->{
'p'
};
  }
}
$r = $self->
_get_node_reference
 ($r) if $r;


;}
$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::Markup::SuikaWikiConfig21::ManakaiSWCFGNode', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'parent_node';
}
}
sub real_parent_node ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r;
$r = $self->{'node'}->{'p'};
if (defined $r) {$r = Message::Markup::SuikaWikiConfig21::ManakaiSWCFGNode->_get_node_reference ($r);
}
$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::Markup::SuikaWikiConfig21::ManakaiSWCFGNode', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'real_parent_node';
}
}
sub count ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r = 0;

{

my 
$node = $self->{
'node'
};
$r = (defined $node->{
'swval'
} ? 1 : 0)
   + @{$node->{
'swcn'
}};


{

unless 
($node->{
'etx'
}) {
  my $__qn;
  if ($node->{
'nsx'
}) {
    $__qn = $self->
_get_node_reference
 ($node)
            ->
real_qualified_name
;
  } else {
    $__qn = $node->{
'swln'
};

  }
  my $__od = $node->{
'swod'
};
  if ($__od->{
'swetb'
}->{$__qn}) {
    my $b = $__od->{
'swetb'
}->{$__qn};
    $node->{
'swns'
} = 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#RealName'
;
    if ($node->{
'nsx'
}) {
      $node->{
'swln'
} = $__qn;
    } else {
      $node->{
'nsx'
} = 
1
;
    }
    unless ($b->{namespaceExpanded}) {
      if ($b->{shadowLocalName} =~ s/^([^:]*)://) {
        my $__prefix = $1;
        

{

local $Error::Depth = $Error::Depth + 1;

{



          $b->{shadowNamespaceURI}
             = $self->
_get_node_reference
 ($__od)
                     ->
lookup_namespace_uri

                           ($__prefix, make_new_binding => 
0
,
                            raise_prefix_exception => 
1
);
        


;}


;}

;
      }
      $b->{namespaceExpanded} = 
1
;
    }
    $node->{
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowNamespaceURI'
} = $b->{shadowNamespaceURI};
    $node->{
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowLocalName'
} = $b->{shadowLocalName};
    for my $__p (qw/shadowContent shadowSibling/) {
      next unless $b->{$__p};
      my $cl = $self->
_get_node_reference
 ($b->{$__p})
                  ->clone;
      my $__n = $node->{{shadowContent => 
'shadow'
,
                         shadowSibling => 
'shadowsib'
}->{$__p}}
         = $cl->{
'node'
};
      $node->
_import_tree
 ($__n);
      $__n->{{shadowContent => 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowParent'
,
              shadowSibling => 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowSiblingOf'
}->{$__p}} = $node;
    }
  }
  $node->{
'etx'
} = 
1
;
}


;}

;
if ($node->{
'shadow'
}) {
  $r++ if not defined $node->{
'swval'
} and
          defined $node->{
'shadow'
}->{
'swval'
};
  $r += @{$node->{
'shadow'
}->{
'swcn'
}};
}
for my $cc (@{$node->{
'swcn'
}}) {
  

{

unless 
($cc->{
'etx'
}) {
  my $__qn;
  if ($cc->{
'nsx'
}) {
    $__qn = $self->
_get_node_reference
 ($cc)
            ->
real_qualified_name
;
  } else {
    $__qn = $cc->{
'swln'
};

  }
  my $__od = $cc->{
'swod'
};
  if ($__od->{
'swetb'
}->{$__qn}) {
    my $b = $__od->{
'swetb'
}->{$__qn};
    $cc->{
'swns'
} = 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#RealName'
;
    if ($cc->{
'nsx'
}) {
      $cc->{
'swln'
} = $__qn;
    } else {
      $cc->{
'nsx'
} = 
1
;
    }
    unless ($b->{namespaceExpanded}) {
      if ($b->{shadowLocalName} =~ s/^([^:]*)://) {
        my $__prefix = $1;
        

{

local $Error::Depth = $Error::Depth + 1;

{



          $b->{shadowNamespaceURI}
             = $self->
_get_node_reference
 ($__od)
                     ->
lookup_namespace_uri

                           ($__prefix, make_new_binding => 
0
,
                            raise_prefix_exception => 
1
);
        


;}


;}

;
      }
      $b->{namespaceExpanded} = 
1
;
    }
    $cc->{
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowNamespaceURI'
} = $b->{shadowNamespaceURI};
    $cc->{
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowLocalName'
} = $b->{shadowLocalName};
    for my $__p (qw/shadowContent shadowSibling/) {
      next unless $b->{$__p};
      my $cl = $self->
_get_node_reference
 ($b->{$__p})
                  ->clone;
      my $__n = $cc->{{shadowContent => 
'shadow'
,
                         shadowSibling => 
'shadowsib'
}->{$__p}}
         = $cl->{
'node'
};
      $cc->
_import_tree
 ($__n);
      $__n->{{shadowContent => 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowParent'
,
              shadowSibling => 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowSiblingOf'
}->{$__p}} = $cc;
    }
  }
  $cc->{
'etx'
} = 
1
;
}


;}

;
  $r += @{$cc->{
'shadowsib'
}->{
'swcn'
}}
     if $cc->{
'shadowsib'
};
}


;}
$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::Markup::SuikaWikiConfig21::ManakaiSWCFGNode', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'count';
}
}
sub real_count ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r = 0;

{


$r = (defined $self->{
'node'
}->{
'swval'
} ? 1 : 0)
   + @{$self->{
'node'
}->{
'swcn'
}};


;}
$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::Markup::SuikaWikiConfig21::ManakaiSWCFGNode', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'real_count';
}
}
sub inner_text ($;%) {
my ($self, %opt) = @_;
my $r = '';

{

my 
$node = $self->{
'node'
};
if (defined $opt{new_value}) {
  $node->{
'swval'
} = $opt{new_value};
}
my $v;
if (defined $node->{
'swval'
}) {
  $v = $node->{
'swval'
};
} else {
  

{

unless 
($node->{
'etx'
}) {
  my $__qn;
  if ($node->{
'nsx'
}) {
    $__qn = $self->
_get_node_reference
 ($node)
            ->
real_qualified_name
;
  } else {
    $__qn = $node->{
'swln'
};

  }
  my $__od = $node->{
'swod'
};
  if ($__od->{
'swetb'
}->{$__qn}) {
    my $b = $__od->{
'swetb'
}->{$__qn};
    $node->{
'swns'
} = 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#RealName'
;
    if ($node->{
'nsx'
}) {
      $node->{
'swln'
} = $__qn;
    } else {
      $node->{
'nsx'
} = 
1
;
    }
    unless ($b->{namespaceExpanded}) {
      if ($b->{shadowLocalName} =~ s/^([^:]*)://) {
        my $__prefix = $1;
        

{

local $Error::Depth = $Error::Depth + 1;

{



          $b->{shadowNamespaceURI}
             = $self->
_get_node_reference
 ($__od)
                     ->
lookup_namespace_uri

                           ($__prefix, make_new_binding => 
0
,
                            raise_prefix_exception => 
1
);
        


;}


;}

;
      }
      $b->{namespaceExpanded} = 
1
;
    }
    $node->{
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowNamespaceURI'
} = $b->{shadowNamespaceURI};
    $node->{
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowLocalName'
} = $b->{shadowLocalName};
    for my $__p (qw/shadowContent shadowSibling/) {
      next unless $b->{$__p};
      my $cl = $self->
_get_node_reference
 ($b->{$__p})
                  ->clone;
      my $__n = $node->{{shadowContent => 
'shadow'
,
                         shadowSibling => 
'shadowsib'
}->{$__p}}
         = $cl->{
'node'
};
      $node->
_import_tree
 ($__n);
      $__n->{{shadowContent => 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowParent'
,
              shadowSibling => 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowSiblingOf'
}->{$__p}} = $node;
    }
  }
  $node->{
'etx'
} = 
1
;
}


;}

;
  $v = defined $node->{
'shadow'
}
             ? $node->{
'shadow'
}->{
'swval'
} : 
undef
;
}
$r = ref $v eq 'ARRAY' ? join "\x0A", @$v : $v;


;}
$r}
sub actual_inner_text ($;%) {
my ($self, %opt) = @_;
my $r = '';

{

my 
$node = $self->{
'node'
};
if (defined $opt{new_value}) {
  $node->{
'swval'
} = $opt{new_value};
}
my $v;
if (defined $node->{
'swval'
}) {
  $v = $node->{
'swval'
};
}
$r = ref $v eq 'ARRAY' ? join "\x0A", @$v : $v;


;}
$r}
sub value ($%) {
my ($self, %opt) = @_;
my $r;

{

my 
$node = $self->{
'node'
};
my $v;
if (defined $node->{
'swval'
}) {
  $v = $node->{
'swval'
};
} else {
  

{

unless 
($node->{
'etx'
}) {
  my $__qn;
  if ($node->{
'nsx'
}) {
    $__qn = $self->
_get_node_reference
 ($node)
            ->
real_qualified_name
;
  } else {
    $__qn = $node->{
'swln'
};

  }
  my $__od = $node->{
'swod'
};
  if ($__od->{
'swetb'
}->{$__qn}) {
    my $b = $__od->{
'swetb'
}->{$__qn};
    $node->{
'swns'
} = 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#RealName'
;
    if ($node->{
'nsx'
}) {
      $node->{
'swln'
} = $__qn;
    } else {
      $node->{
'nsx'
} = 
1
;
    }
    unless ($b->{namespaceExpanded}) {
      if ($b->{shadowLocalName} =~ s/^([^:]*)://) {
        my $__prefix = $1;
        

{

local $Error::Depth = $Error::Depth + 1;

{



          $b->{shadowNamespaceURI}
             = $self->
_get_node_reference
 ($__od)
                     ->
lookup_namespace_uri

                           ($__prefix, make_new_binding => 
0
,
                            raise_prefix_exception => 
1
);
        


;}


;}

;
      }
      $b->{namespaceExpanded} = 
1
;
    }
    $node->{
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowNamespaceURI'
} = $b->{shadowNamespaceURI};
    $node->{
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowLocalName'
} = $b->{shadowLocalName};
    for my $__p (qw/shadowContent shadowSibling/) {
      next unless $b->{$__p};
      my $cl = $self->
_get_node_reference
 ($b->{$__p})
                  ->clone;
      my $__n = $node->{{shadowContent => 
'shadow'
,
                         shadowSibling => 
'shadowsib'
}->{$__p}}
         = $cl->{
'node'
};
      $node->
_import_tree
 ($__n);
      $__n->{{shadowContent => 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowParent'
,
              shadowSibling => 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowSiblingOf'
}->{$__p}} = $node;
    }
  }
  $node->{
'etx'
} = 
1
;
}


;}

;
  $v = defined $node->{
'shadow'
}
             ? $node->{
'shadow'
}->{
'swval'
} : 
undef
;
}
if ($opt{as_array} and ref $v ne 'ARRAY') {
  $r = defined $v ? [$v] : [];
} else {
  $r = $v;
}


;}
$r}
sub value_ref ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r;

{

my 
$node = $self->{
'node'
};
if (defined $node->{
'swval'
}) {
  $r = \ ($node->{
'swval'
});
} else {
  

{

unless 
($node->{
'etx'
}) {
  my $__qn;
  if ($node->{
'nsx'
}) {
    $__qn = $self->
_get_node_reference
 ($node)
            ->
real_qualified_name
;
  } else {
    $__qn = $node->{
'swln'
};

  }
  my $__od = $node->{
'swod'
};
  if ($__od->{
'swetb'
}->{$__qn}) {
    my $b = $__od->{
'swetb'
}->{$__qn};
    $node->{
'swns'
} = 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#RealName'
;
    if ($node->{
'nsx'
}) {
      $node->{
'swln'
} = $__qn;
    } else {
      $node->{
'nsx'
} = 
1
;
    }
    unless ($b->{namespaceExpanded}) {
      if ($b->{shadowLocalName} =~ s/^([^:]*)://) {
        my $__prefix = $1;
        

{

local $Error::Depth = $Error::Depth + 1;

{



          $b->{shadowNamespaceURI}
             = $self->
_get_node_reference
 ($__od)
                     ->
lookup_namespace_uri

                           ($__prefix, make_new_binding => 
0
,
                            raise_prefix_exception => 
1
);
        


;}


;}

;
      }
      $b->{namespaceExpanded} = 
1
;
    }
    $node->{
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowNamespaceURI'
} = $b->{shadowNamespaceURI};
    $node->{
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowLocalName'
} = $b->{shadowLocalName};
    for my $__p (qw/shadowContent shadowSibling/) {
      next unless $b->{$__p};
      my $cl = $self->
_get_node_reference
 ($b->{$__p})
                  ->clone;
      my $__n = $node->{{shadowContent => 
'shadow'
,
                         shadowSibling => 
'shadowsib'
}->{$__p}}
         = $cl->{
'node'
};
      $node->
_import_tree
 ($__n);
      $__n->{{shadowContent => 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowParent'
,
              shadowSibling => 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowSiblingOf'
}->{$__p}} = $node;
    }
  }
  $node->{
'etx'
} = 
1
;
}


;}

;
  $r = defined $node->{
'shadow'
}
             ? \ ($node->{
'shadow'
}->{
'swval'
}) : 
undef
;
}


;}
$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::Markup::SuikaWikiConfig21::ManakaiSWCFGNode', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'value_ref';
}
}
sub stringify ($;%) {
my ($self, %opt) = @_;
my $r = '';

{

my 
$nt = $self->
node_type
;
my $node = $self->{
'node'
};
if ($nt eq '#element') {
  $r = $self->
actual_inner_text
;
  if (scalar @{$node->{
'swcn'
}}) {
    if (defined $r) {
      $r =~ s/(^|\x0A)(?=([\\\@\#\s]|$))?/$1."  ".
                                          (defined $2?"\\":"")/ges;
      $r = $self->
real_qualified_name

         . ":\x0A  \@\@"
         . (ref ($node->{
'swval'
}) eq 'ARRAY' ? '[list]' : '')
         . ":" . ((($r !~ /[\x0D\x0A:]/) and (length ($r) < 50))
                  ? '' : "\x0A")
         . (length $r ? $r : '\\') . "\x0A";
    } else {
      $r = $self->
real_qualified_name

         . ":\x0A";
    }
    for my $cn (@{$node->{
'swcn'
}}) {
      next unless $cn->{
'swnt'
} eq '#element';
      my $rc = $self->
_get_node_reference
 ($cn)
                 ->stringify;
      $rc =~ s/\x0A  /\x0A     /gs;
      $rc =~ s/(\x0A +\@)/$1\@/gs;
      $r .= '  @' . $rc;
    }
  } else {
    $r = '' unless defined $r;
    $r =~ s/(^|\x0A)(?=([\\\@\#\s]|$))?/$1."  ".(defined $2?"\\":"")/ges;
    $r = $self->
real_qualified_name

       . (ref ($node->{
'swval'
}) eq 'ARRAY' ? '[list]' : '')
       . ":" . ((($r !~ /[\x0D\x0A:]/) and (length ($r) < 50))
                ? '' : "\x0A")
       . (length $r ? $r : '\\') . "\x0A";
  }
  $r = "\\" . $r if substr ($r, 0, 1) =~ /[\\\@\#\s]/;
} elsif ($nt eq '#document') {
  if ($opt{output_header}) {
    $r = '#?SuikaWikiConfig/' . $node->{
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#version'
} . "\n";
  }
  
  for my $cn (@{$node->{
'swcn'
}}) {
    $r .= "\x0A";
    $r .= $self->
_get_node_reference
 ($cn)->stringify;
  }

  ## Element Type Binding
  my $eb = '';
  for my $bk (sort keys %{$self->{
'node'
}
                               ->{
'swetb'
}}) {
    my $b = $self->{
'node'
}->{
'swetb'
}->{$bk};
    next unless $b;
    $eb .= "\x0A" . 'ElementTypeBinding:' . "\x0A"
                  . '  @Name:' . "\x0A"
                  . '    ' . $b->{elementType} . "\x0A"
                  . '  @ElementType:' . "\x0A"
                  . '    ';
    if ($b->{namespaceExpanded}) {
      $eb .= $self->
lookup_namespace_prefix

                    ($b->{shadowNamespaceURI}, make_new_binding => 
1
);
      $eb .= $b->{shadowLocalName};
    } else {
      ## NOTE: If namespace binding has changed, 
      ##       associated namespace URI might change. 
      $eb .= $b->{shadowLocalName};
    }
    $eb .= "\x0A";
    for my $p (qw/shadowContent shadowSibling/) {
      next unless $b->{$p};
      $eb .= '  @' . ucfirst ($p) . ":\x0A";
      my $rc = $self->
_get_node_reference
 ($b->{$p});
      my $ebc = $rc->stringify;
      $ebc =~ s/\x0A  /\x0A       /gs;
      $ebc =~ s/(\x0A +\@)/$1\@\@/gs;
      $ebc =~ s/\x0A(?=\S)/\x0A    \@\@/gs;
      $eb .= '    @@' . $ebc;
      $ebc = $rc->
inner_text
;
      if (defined $ebc) {
        $ebc =~ s/(^|\x0A)(?=([\\\@\#\s]|$))?/$1.'      '.
                                          (defined $2?"\\":"")/ges;
        $eb .= '    @@@'
            . (ref ($b->{$p}->{
'swval'
}) eq 'ARRAY' ? '[list]' : '')
            . ":" . ((($ebc !~ /[\x0D\x0A:]/) and (length ($ebc) < 50))
                     ? '' : "\x0A")
            . (length $ebc ? $ebc : '\\') . "\x0A";
      }
    }
  } # swcfg21:etBinding
  $r .= $eb;

  ## Namespace bindings
  my $ns = '';
  for my $pfx (sort keys %{$self->{
'node'
}
                                ->{
'swnsb'
}}) {
    if ($pfx ne 'URI') {
      $ns .= '  @' . $pfx . ':' . "\x0A"
          .  '    ';
      my $uri = $self->{
'node'
}->{
'swnsb'
}->{$pfx};
      if (defined $uri) {
        if (length $uri) {
          if ($uri =~ /^[\\#\s\@]/) {
            $ns .= '\\' . $uri . "\x0A";
          } else {
            $ns .= $uri . "\x0A";
          }
        } else {
          $ns .= "\\\x0A";
        }
      } else {
        $ns .= '@@is-
undef: 
1' . "\x0A";
      }
    }
  }
  $r .= "\x0A" . 'Namespace:' . "\x0A" . $ns . "\x0A" if length $ns;
} elsif ($nt eq '#comment') {
  $r = $self->
inner_text
;
  $r =~ s/\x0A/\x0A#/gs;
  $r = '#' . $r . "\n";
} elsif ($nt eq '#fragment') {
  for my $cn (@{$node->{
'swcn'
}}) {
    $r .= $self->
_get_node_reference
 ($cn)->stringify;
  }
} else {
  

;
}


;}
$r}
sub root_node ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r;

{


$r = $self->{
'node'
};
{
  if ($r->{
'p'
}) {
    $r = $r->{
'p'
};
    redo;
  } elsif ($r->{
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowParent'
}) {
    $r = $r->{
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowParent'
};
    redo;
  } elsif ($r->{
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowSiblingOf'
}) {
    $r = $r->{
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowSiblingOf'
};
    redo;
  } elsif ($r->{
'shadowmaster'
}) {
    $r = $r->{
'swod'
};
  }
}
$r = $self->
_get_node_reference
 ($r);


;}
$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::Markup::SuikaWikiConfig21::ManakaiSWCFGNode', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'root_node';
}
}
sub node_path ($;%) {
my ($self, %opt) = @_;
my $r = '';

{

my 
$parent = $self->
parent_node
;
if ($parent) {
  $r = $parent->
node_path
 (%opt);
} else {
  $r = '';
}
my $node_type = $self->
node_type
;
if ($node_type eq '#element') {
  $r .= '/' . $self->
real_qualified_name
;
  if ($opt{key}) {
    for my $k (ref $opt{key} eq 'ARRAY' ? @{$opt{key}} : $opt{key}) {
      my $key_val = $self->
get_attribute_value
 ($k);
      if (defined $key_val) {
        $r .= '[@' . $k . '=' . $key_val . ']';
      }
    }
  }
} elsif ($node_type eq '#comment') {
  $r .= q</comment ()>;
} elsif ($node_type eq '#document') {
  $r .= q</document (>
     .  ($self->
flag
 (
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#fileName'
) || '')
     .  q<)>;
} elsif ($node_type eq '#fragment') {
  $r .= q</fragment ()>;
} else {
  

;
}


;}
$r}
sub flag ($$;$%) {
my ($self, $name, $value, %opt) = @_;
my $r;

{

if 
(defined $value) {
  $r = $self->{
'node'
}->{
'swflag'
}->{$name} = $value;
} else {
  $r = defined $self->{
'node'
}->{
'swflag'
}->{$name}
          ? $self->{
'node'
}->{
'swflag'
}->{$name} : $opt{default};
}


;}
$r}
sub option ($$;$) {
my ($self, $name, $value) = @_;
my $r;

{

if 
(defined $value) {
  $self->{
'node'
}->{
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#option'
}->{$name} = $value;
}
$r = $self->{
'node'
}->{
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#option'
}->{$name};


;}
$r}
sub clone ($) {
my ($self) = @_;
my $r;

{


{

local $Error::Depth = $Error::Depth + 1;

{


  my 
$od = $self->
owner_document
 || $self;
  my $nt = $self->
node_type
;
  if ($nt eq '#element') {
    $r = $self->
_get_node_reference

              (
Message::Markup::SuikaWikiConfig21::ManakaiSWCFGElement->_new_object
);
    for my $p (
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowLocalName'
, 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowNamespaceURI'
,
               
'swln'
, 
'swns'
,
               
'nsx'
, 
'etx'
,
               
'swod'
) {
      $r->{
'node'
}->{$p} = $self->{
'node'
}->{$p};
    }
    $r->{
'node'
}->{
'swval'
}
        = defined $self->{
'node'
}->{
'swval'
}
          ? ref $self->{
'node'
}->{
'swval'
} eq 'ARRAY'
          ? [@{$self->{
'node'
}->{
'swval'
}}]
          : $self->{
'node'
}->{
'swval'
} : 
undef
;
    for my $p (
'shadow'
, 
'shadowsib'
) {
      if ($self->{
'node'
}->{$p}) {
        my $c = $self->
_get_node_reference

                   ($self->{
'node'
}->{$p})->clone;
        $r->{
'node'
}->{$p} = $c->{
'node'
};
        $r->{
'node'
}
          ->
_import_tree
 ($r->{
'node'
}->{$p});
        $r->{
'node'
}->{$p}
          ->{+{
                
'shadow'
 => 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowParent'
,
                
'shadowsib'
 => 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowSiblingOf'
,
             }->{$p}} = $r->{
'node'
};
      }
    }
    for my $cn (@{$self->{
'node'
}->{
'swcn'
}}) {
      my $c = $self->
_get_node_reference
 ($cn);
      $r->
append_node
 ($c->clone);
    }
  } elsif ($nt eq '#comment') {
    $r = $od->
create_comment

                    ($self->{
'node'
}->{
'swval'
});
  } elsif ($nt eq '#fragment') {
    $r = $od->
create_document_fragment
;
    ## swcfg21:isShadowMaster property is not copied
    for my $cn (@{$self->{
'node'
}->{
'swcn'
}}) {
      my $c = $self->
_get_node_reference
 ($cn);
      $r->
append_node
 ($c->clone);
    }
    $r->{
'node'
}->{
'swval'
}
        = defined $self->{
'node'
}->{
'swval'
}
          ? ref $self->{
'node'
}->{
'swval'
} eq 'ARRAY'
          ? [@{$self->{
'node'
}->{
'swval'
}}]
          : $self->{
'node'
}->{
'swval'
} : 
undef
;
  } elsif ($nt eq '#document') {
    $r = $od->
implementation

            ->
create_swcfg_document
;
    $r->{
'node'
}->{
'swnsb'
}
       = {%{$self->{
'node'
}->{
'swnsb'
}}};
    for my $bk (keys %{$self->{
'node'
}->{
'swetb'
}}) {
      my $b = $self->{
'node'
}->{
'swetb'
}->{$bk};
      next unless $b;
      my $c = $r->{
'node'
}->{
'swetb'
}->{$bk} = {
        elementType => $b->{elementType},
        shadowLocalName => $b->{shadowLocalName},
        shadowNamespaceURI => $b->{shadowNamespaceURI},
        namespaceExpanded => $b->{namespaceExpanded},
      };
      for my $p (qw/shadowContent shadowSibling/) {
        if ($b->{$p}) {
          my $cl = $self->
_get_node_reference

                         ($b->{$p})->clone;
          $c->{$p} = $cl->{
'node'
};
          $r->{
'node'
}->
_import_tree
 ($c->{$p});
          my @l = $c->{$p};
          while (@l) {
            my $l = shift @l; next unless $l;
            $l->{
'swod'
} = $r->{
'node'
};
            for my $n (@{$l->{
'swcn'
}}, 
                       $l->{
'shadow'
},   ## Does not allowed
                       $l->{
'shadowsib'
}) { ## but for safe
              push @l, $n;
            }
          }
          $c->{$p}->{
'shadowmaster'
} = 
1
;
        }
      }
    }
    for my $cn (@{$self->{
'node'
}->{
'swcn'
}}) {
      my $c = $self->
_get_node_reference
 ($cn)->clone;
      $r->{
'node'
}
        ->
_import_tree
 ($c->{
'node'
});
      my @l = $c->{
'node'
};
      while (@l) {
        my $l = shift @l; next unless $l;
        

{


$l->{'swod'} = $r->{'node'};
if (${$l->{
'tid'
}} ne ${$r->{'node'}->{
'tid'
}}) {
  $r->{'node'}->{
'rc'
}++;
  ${$r->{'node'}->{
'grc'
}}++;
}


;}

;
        for my $n (@{$l->{
'swcn'
}}, 
                   $l->{
'shadow'
},
                   $l->{
'shadowsib'
}) {
          push @l, $n;
        }
      }
      $r->
append_node
 ($c);
    }
  } else {
    

;
  }



;}


;}

;
$r->{
'node'
}->{
'swflag'
}
                   = {%{$self->{
'node'
}->{
'swflag'
}||{}}};
$r->{
'node'
}->{
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#option'
}
                   = {%{$self->{
'node'
}->{
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#option'
}||{}}};


;}
$r}
sub owner_document ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r;
$r = $self->{'node'}->{'swod'};
if (defined $r) {$r = Message::Markup::SuikaWikiConfig21::ManakaiSWCFGNode->_get_node_reference ($r);
}
$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::Markup::SuikaWikiConfig21::ManakaiSWCFGNode', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'owner_document';
}
}
sub lookup_namespace_prefix ($;$%) {
my ($self, $namespaceURI, %opt) = @_;
my $r = '';

{


$r = 
undef
;
my $od = $self->
owner_document
 || $self;
my $binds = $od->{
'node'
}->{
'swnsb'
};
if (defined $namespaceURI) {
  FIND: {
    for my $prefix (keys %$binds) {
      if (defined $binds->{$prefix} and
          $binds->{$prefix} eq $namespaceURI) {
        $r = $prefix;
        last FIND;
      }
    }
    last FIND unless $opt{make_new_binding};
    ## Not found
    if ($namespaceURI =~ /(\w+)$/) {
      my $prefix = $1;
      unless (exists $binds->{$prefix}) {
        $binds->{$prefix} = $namespaceURI;
        $r = $prefix;
        last FIND;
      }
    }
    my $i = 1;
    {
      unless (exists $binds->{'ns'.$i}) {
        $binds->{$r = 'ns'.$i} = $namespaceURI;
        last FIND;
      }
      $i++;
      redo;
    }
  } # FIND
} else {  ## Null namespace
  FIND: {
    if (exists $binds->{'nu'.'ll'} and not defined $binds->{'nu'.'ll'}) {
      $r = 'nu'.'ll';
      last FIND;
    }
    for my $prefix (keys %$binds) {
      if (not defined $prefix) {
        $r = $prefix;
        last FIND;
      }
    }
    last FIND unless $opt{make_new_binding};
    ## Not found
    my $i = '';
    {
      unless (exists $binds->{'nu'.'ll'.$i}) {
        $binds->{$r = 'nu'.'ll'.$i} = 
undef
;
        last FIND;
      }
      $i++;
      redo;
    }
  }
}


;}
$r}
sub lookup_namespace_uri ($$%) {
my ($self, $prefix, %opt) = @_;
my $r = '';

{

my 
$od = $self->
owner_document
 || $self;
my $binds = $od->{
'node'
}->{
'swnsb'
};
if (exists $binds->{$prefix}) {
  $r = $binds->{$prefix};
} elsif ($opt{make_new_binding}) {
  $r = $binds->{$prefix} = $prefix;
} elsif ($opt{raise_prefix_exception}) {
  
report Message::Markup::SuikaWikiConfig21::ManakaiSWCFGException -object => $self, 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS#sourceNode' => $self, '-type' => 'NAMESPACE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'lookup_namespace_uri', 'http://www.w3.org/2001/04/infoset#prefix' => $prefix, 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS#UNDECLARED_NS_PREFIX_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::Markup::SuikaWikiConfig21::ManakaiSWCFGNode', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#param-name' => 'prefix';

;
} else {
  $r = 
undef
;
}


;}
$r}
sub bind_namespace_uri ($$;$) {
my ($self, $prefix, $namespaceURI) = @_;

{

unless 
($prefix eq 'URI') {
  my $od = $self->
owner_document
 || $self;
  if (defined $namespaceURI) {
    $od->{
'node'
}->{
'swnsb'
}->{$prefix}
                           = $namespaceURI;
  } else {
    CORE::delete $od->{
'node'
}->{
'swnsb'
}->{$prefix};
  }
}


;}
}
sub _get_node_reference ($$) {
my ($self, $object) = @_;
my $r;

{

my 
$class;
if ($object->{
'swnt'
} eq '#element') {
  $class = 
'Message::Markup::SuikaWikiConfig21::ManakaiSWCFGElement'
;
} elsif ($object->{
'swnt'
} eq '#comment') {
  $class = 
'Message::Markup::SuikaWikiConfig21::ManakaiSWCFGComment'
;
} elsif ($object->{
'swnt'
} eq '#document') {
  $class = 
'Message::Markup::SuikaWikiConfig21::ManakaiSWCFGDocument'
;
} elsif ($object->{
'swnt'
} eq '#fragment') {
  $class = 
'Message::Markup::SuikaWikiConfig21::ManakaiSWCFGDocumentFragment'
;
} else {
  

;
}


{


$object->{
'rc'
}++;
${$object->{
'grc'
}}++;
$r = bless {
  
'node'
 => $object,
}, $class;


;}

;


;}
$r}
sub is_same_node ($$) {
my ($self, $other) = @_;
my $r = 0;

{

if 
(UNIVERSAL::isa ($other, 
'Message::Util::IF::NodeRef'
)
    and $other->{
'node'
}->{
'nid'
}
      eq $self->{
'node'
}->{
'nid'
}) {
  $r = 
1
;
}


;}
$r}
sub _new_object ($$) {
my ($self, $refClass) = @_;
my $r;

{

my 
$node =
   $r = 
Message::Util::ManakaiNode::ManakaiNodeStem->_new

          ($refClass);
$node->{
'swcn'
} = [];


;}
$r}
sub node_id ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r = '';

{


$r = $self->{
'node'
}->{
'nid'
};


;}
$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::Markup::SuikaWikiConfig21::ManakaiSWCFGNode', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'node_id';
}
}
sub node_id_ref ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r;

{


$r = \($self->{
'node'
}->{
'nid'
});


;}
$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::Markup::SuikaWikiConfig21::ManakaiSWCFGNode', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'node_id_ref';
}
}
use overload 
bool => sub () {1}, 
'""' => 'stringify', 
'eq' => 'is_same_node', 
fallback => 1;
$Message::DOM::ClassFeature{q<Message::Markup::SuikaWikiConfig21::ManakaiSWCFGNode>} = {'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#core', {'', '1', '2.1', '1'}};
$Message::DOM::ClassPoint{q<Message::Markup::SuikaWikiConfig21::ManakaiSWCFGNode>} = 2.1;
$Message::Util::ManakaiNode::ManakaiNodeRef::Prop{q<Message::Markup::SuikaWikiConfig21::ManakaiSWCFGNode>} = {'o', ['p'], 's', ['swcn']};
package Message::Markup::IFLatest::SWCFGComment;
our $VERSION = 20051123.0740;
package Message::Markup::SuikaWikiConfig21::ManakaiSWCFGComment;
our $VERSION = 20051123.0740;
push our @ISA, 'Message::Markup::SuikaWikiConfig21::ManakaiSWCFGNode', 'Message::Markup::IF::SWCFGComment', 'Message::Markup::IFLatest::SWCFGComment';
sub node_type ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r = '';
$r = '#comment';
$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::Markup::SuikaWikiConfig21::ManakaiSWCFGComment', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'node_type';
}
}
sub _new_object ($) {
my ($self) = @_;
my $r;

{


$r = 
Message::Markup::SuikaWikiConfig21::ManakaiSWCFGNode->_new_object
 ($self);
$r->{
'swnt'
} = '#comment';
$r->{
'swval'
} = '';
$r->{
'nsx'
} = 
1
; ## Always t r u e
$r->{
'etx'
} = 
1
; ## Always t r u e


;}
$r}
$Message::DOM::ClassFeature{q<Message::Markup::SuikaWikiConfig21::ManakaiSWCFGComment>} = {'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#core', {'', '1', '2.1', '1'}};
$Message::DOM::ClassPoint{q<Message::Markup::SuikaWikiConfig21::ManakaiSWCFGComment>} = 4.2;
$Message::Util::ManakaiNode::ManakaiNodeRef::Prop{q<Message::Markup::SuikaWikiConfig21::ManakaiSWCFGComment>} = {'o', ['p'], 's', ['swcn']};
package Message::Markup::IFLatest::SWCFGElement;
our $VERSION = 20051123.0740;
package Message::Markup::SuikaWikiConfig21::ManakaiSWCFGElement;
our $VERSION = 20051123.0740;
push our @ISA, 'Message::Markup::SuikaWikiConfig21::ManakaiSWCFGNode', 'Message::Markup::IF::SWCFGElement', 'Message::Markup::IFLatest::SWCFGElement';
sub expanded_uri ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r = '';

{


{

my 
$__node = $self->{
'node'
};


{

unless 
($__node->{
'etx'
}) {
  my $__qn;
  if ($__node->{
'nsx'
}) {
    $__qn = $self->
_get_node_reference
 ($__node)
            ->
real_qualified_name
;
  } else {
    $__qn = $__node->{
'swln'
};

  }
  my $__od = $__node->{
'swod'
};
  if ($__od->{
'swetb'
}->{$__qn}) {
    my $b = $__od->{
'swetb'
}->{$__qn};
    $__node->{
'swns'
} = 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#RealName'
;
    if ($__node->{
'nsx'
}) {
      $__node->{
'swln'
} = $__qn;
    } else {
      $__node->{
'nsx'
} = 
1
;
    }
    unless ($b->{namespaceExpanded}) {
      if ($b->{shadowLocalName} =~ s/^([^:]*)://) {
        my $__prefix = $1;
        

{

local $Error::Depth = $Error::Depth + 1;

{



          $b->{shadowNamespaceURI}
             = $self->
_get_node_reference
 ($__od)
                     ->
lookup_namespace_uri

                           ($__prefix, make_new_binding => 
0
,
                            raise_prefix_exception => 
1
);
        


;}


;}

;
      }
      $b->{namespaceExpanded} = 
1
;
    }
    $__node->{
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowNamespaceURI'
} = $b->{shadowNamespaceURI};
    $__node->{
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowLocalName'
} = $b->{shadowLocalName};
    for my $__p (qw/shadowContent shadowSibling/) {
      next unless $b->{$__p};
      my $cl = $self->
_get_node_reference
 ($b->{$__p})
                  ->clone;
      my $__n = $__node->{{shadowContent => 
'shadow'
,
                         shadowSibling => 
'shadowsib'
}->{$__p}}
         = $cl->{
'node'
};
      $__node->
_import_tree
 ($__n);
      $__n->{{shadowContent => 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowParent'
,
              shadowSibling => 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowSiblingOf'
}->{$__p}} = $__node;
    }
  }
  $__node->{
'etx'
} = 
1
;
}


;}

;
unless ($__node->{
'nsx'
}) {
  if ($__node->{
'swln'
} =~ s/^([^:]*)://) {
    my $__prefix = $1;
    

{

local $Error::Depth = $Error::Depth + 1;

{



      $__node->{
'swns'
}
           = $self->
lookup_namespace_uri

                           ($__prefix, make_new_binding => 
0
, 
                            raise_prefix_exception => 
1
);
    


;}


;}

;
  } else {
    $__node->{
'swns'
}
           = $__node->{
'swod'
}
                    ->{
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#defaultETNamespaceURI'
};
  }
  $__node->{
'nsx'
} = 
1
;
}


;}

;
if (defined $self->{
'node'
}->{
'swns'
}) {
  if ($self->{
'node'
}
           ->{
'swns'
} eq 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#RealName'
) {
    $r = $self->{
'node'
}->{
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowNamespaceURI'
} .
         $self->{
'node'
}->{
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowLocalName'
};
  } else {
    $r = $self->{
'node'
}->{
'swns'
} .
         $self->{
'node'
}->{
'swln'
};
  }
} else {
  $r = $self->{
'node'
}->{
'swln'
};
}


;}
$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::Markup::SuikaWikiConfig21::ManakaiSWCFGElement', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'expanded_uri';
}
}
sub prefix ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r = '';

{


{

my 
$__node = $self->{
'node'
};


{

unless 
($__node->{
'etx'
}) {
  my $__qn;
  if ($__node->{
'nsx'
}) {
    $__qn = $self->
_get_node_reference
 ($__node)
            ->
real_qualified_name
;
  } else {
    $__qn = $__node->{
'swln'
};

  }
  my $__od = $__node->{
'swod'
};
  if ($__od->{
'swetb'
}->{$__qn}) {
    my $b = $__od->{
'swetb'
}->{$__qn};
    $__node->{
'swns'
} = 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#RealName'
;
    if ($__node->{
'nsx'
}) {
      $__node->{
'swln'
} = $__qn;
    } else {
      $__node->{
'nsx'
} = 
1
;
    }
    unless ($b->{namespaceExpanded}) {
      if ($b->{shadowLocalName} =~ s/^([^:]*)://) {
        my $__prefix = $1;
        

{

local $Error::Depth = $Error::Depth + 1;

{



          $b->{shadowNamespaceURI}
             = $self->
_get_node_reference
 ($__od)
                     ->
lookup_namespace_uri

                           ($__prefix, make_new_binding => 
0
,
                            raise_prefix_exception => 
1
);
        


;}


;}

;
      }
      $b->{namespaceExpanded} = 
1
;
    }
    $__node->{
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowNamespaceURI'
} = $b->{shadowNamespaceURI};
    $__node->{
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowLocalName'
} = $b->{shadowLocalName};
    for my $__p (qw/shadowContent shadowSibling/) {
      next unless $b->{$__p};
      my $cl = $self->
_get_node_reference
 ($b->{$__p})
                  ->clone;
      my $__n = $__node->{{shadowContent => 
'shadow'
,
                         shadowSibling => 
'shadowsib'
}->{$__p}}
         = $cl->{
'node'
};
      $__node->
_import_tree
 ($__n);
      $__n->{{shadowContent => 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowParent'
,
              shadowSibling => 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowSiblingOf'
}->{$__p}} = $__node;
    }
  }
  $__node->{
'etx'
} = 
1
;
}


;}

;
unless ($__node->{
'nsx'
}) {
  if ($__node->{
'swln'
} =~ s/^([^:]*)://) {
    my $__prefix = $1;
    

{

local $Error::Depth = $Error::Depth + 1;

{



      $__node->{
'swns'
}
           = $self->
lookup_namespace_uri

                           ($__prefix, make_new_binding => 
0
, 
                            raise_prefix_exception => 
1
);
    


;}


;}

;
  } else {
    $__node->{
'swns'
}
           = $__node->{
'swod'
}
                    ->{
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#defaultETNamespaceURI'
};
  }
  $__node->{
'nsx'
} = 
1
;
}


;}

;
my $node = $self->{
'node'
};
my $od = $self->
owner_document
;
my $defURI = $od->
default_element_type_namespace_uri
;
if (defined $node->{
'swns'
}) {
  if (not defined $defURI or
      $node->{
'swns'
} ne $defURI or
      $node->{
'swln'
} eq 'Namespace' or
      $node->{
'swln'
} eq 'ElementTypeBinding' or
      $node->{
'swln'
} =~ /:/) {
    $r = $self->
lookup_namespace_prefix

                                     ($node->{
'swns'
},
                                      make_new_binding => 1);
  } else {
    $r = 
undef
;
  }
} else {  ## Null namespace
  if (defined $defURI or $node->{
'swln'
} =~ /:/ or
      $node->{
'swln'
} eq 'Namespace' or
      $node->{
'swln'
} eq 'ElementTypeBinding') {
    $r = $self->
lookup_namespace_prefix

                                     ($node->{
'swns'
},
                                      make_new_binding => 1);
  } else {
    $r = 
undef
;
  }
}


;}
$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::Markup::SuikaWikiConfig21::ManakaiSWCFGElement', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'prefix';
}
}
sub qualified_name ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r = '';

{


{

my 
$__node = $self->{
'node'
};


{

unless 
($__node->{
'etx'
}) {
  my $__qn;
  if ($__node->{
'nsx'
}) {
    $__qn = $self->
_get_node_reference
 ($__node)
            ->
real_qualified_name
;
  } else {
    $__qn = $__node->{
'swln'
};

  }
  my $__od = $__node->{
'swod'
};
  if ($__od->{
'swetb'
}->{$__qn}) {
    my $b = $__od->{
'swetb'
}->{$__qn};
    $__node->{
'swns'
} = 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#RealName'
;
    if ($__node->{
'nsx'
}) {
      $__node->{
'swln'
} = $__qn;
    } else {
      $__node->{
'nsx'
} = 
1
;
    }
    unless ($b->{namespaceExpanded}) {
      if ($b->{shadowLocalName} =~ s/^([^:]*)://) {
        my $__prefix = $1;
        

{

local $Error::Depth = $Error::Depth + 1;

{



          $b->{shadowNamespaceURI}
             = $self->
_get_node_reference
 ($__od)
                     ->
lookup_namespace_uri

                           ($__prefix, make_new_binding => 
0
,
                            raise_prefix_exception => 
1
);
        


;}


;}

;
      }
      $b->{namespaceExpanded} = 
1
;
    }
    $__node->{
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowNamespaceURI'
} = $b->{shadowNamespaceURI};
    $__node->{
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowLocalName'
} = $b->{shadowLocalName};
    for my $__p (qw/shadowContent shadowSibling/) {
      next unless $b->{$__p};
      my $cl = $self->
_get_node_reference
 ($b->{$__p})
                  ->clone;
      my $__n = $__node->{{shadowContent => 
'shadow'
,
                         shadowSibling => 
'shadowsib'
}->{$__p}}
         = $cl->{
'node'
};
      $__node->
_import_tree
 ($__n);
      $__n->{{shadowContent => 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowParent'
,
              shadowSibling => 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowSiblingOf'
}->{$__p}} = $__node;
    }
  }
  $__node->{
'etx'
} = 
1
;
}


;}

;
unless ($__node->{
'nsx'
}) {
  if ($__node->{
'swln'
} =~ s/^([^:]*)://) {
    my $__prefix = $1;
    

{

local $Error::Depth = $Error::Depth + 1;

{



      $__node->{
'swns'
}
           = $self->
lookup_namespace_uri

                           ($__prefix, make_new_binding => 
0
, 
                            raise_prefix_exception => 
1
);
    


;}


;}

;
  } else {
    $__node->{
'swns'
}
           = $__node->{
'swod'
}
                    ->{
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#defaultETNamespaceURI'
};
  }
  $__node->{
'nsx'
} = 
1
;
}


;}

;
my $node = $self->{
'node'
};
my $od = $self->
owner_document
;
my $defURI = $od->
default_element_type_namespace_uri
;
if (defined $node->{
'swns'
}) {
  my $nsURI = ($node->{
'swns'
} eq 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#RealName'

                ? $node->{
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowNamespaceURI'
}
                : $node->{
'swns'
});
  my $ln = ($node->{
'swns'
} eq 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#RealName'

                ? $node->{
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowlocalName'
}
                : $node->{
'swln'
});
  if (not defined $defURI or
      $nsURI ne $defURI or
      $ln eq 'Namespace' or
      $ln eq 'ElementTypeBinding' or
      $ln =~ /:/) {
    $r = $self->
lookup_namespace_prefix

                                     ($node->{
'swns'
},
                                      make_new_binding => 1) .
         ':' . $ln;
  } else {
    $r = $ln;
  }
} else {  ## Null namespace
  if (defined $defURI or $node->{
'swln'
} =~ /:/ or
      $node->{
'swln'
} eq 'Namespace' or
      $node->{
'swln'
} eq 'ElementTypeBinding') {
    $r = $self->
lookup_namespace_prefix

                                     ($node->{
'swns'
},
                                      make_new_binding => 1) .
         ':' . $node->{
'swln'
};
  } else {
    $r = $node->{
'swln'
};
  }
}


;}
$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::Markup::SuikaWikiConfig21::ManakaiSWCFGElement', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'qualified_name';
}
}
sub real_qualified_name ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r = '';

{


{

my 
$__node = $self->{
'node'
};


{

unless 
($__node->{
'etx'
}) {
  my $__qn;
  if ($__node->{
'nsx'
}) {
    $__qn = $self->
_get_node_reference
 ($__node)
            ->
real_qualified_name
;
  } else {
    $__qn = $__node->{
'swln'
};

  }
  my $__od = $__node->{
'swod'
};
  if ($__od->{
'swetb'
}->{$__qn}) {
    my $b = $__od->{
'swetb'
}->{$__qn};
    $__node->{
'swns'
} = 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#RealName'
;
    if ($__node->{
'nsx'
}) {
      $__node->{
'swln'
} = $__qn;
    } else {
      $__node->{
'nsx'
} = 
1
;
    }
    unless ($b->{namespaceExpanded}) {
      if ($b->{shadowLocalName} =~ s/^([^:]*)://) {
        my $__prefix = $1;
        

{

local $Error::Depth = $Error::Depth + 1;

{



          $b->{shadowNamespaceURI}
             = $self->
_get_node_reference
 ($__od)
                     ->
lookup_namespace_uri

                           ($__prefix, make_new_binding => 
0
,
                            raise_prefix_exception => 
1
);
        


;}


;}

;
      }
      $b->{namespaceExpanded} = 
1
;
    }
    $__node->{
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowNamespaceURI'
} = $b->{shadowNamespaceURI};
    $__node->{
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowLocalName'
} = $b->{shadowLocalName};
    for my $__p (qw/shadowContent shadowSibling/) {
      next unless $b->{$__p};
      my $cl = $self->
_get_node_reference
 ($b->{$__p})
                  ->clone;
      my $__n = $__node->{{shadowContent => 
'shadow'
,
                         shadowSibling => 
'shadowsib'
}->{$__p}}
         = $cl->{
'node'
};
      $__node->
_import_tree
 ($__n);
      $__n->{{shadowContent => 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowParent'
,
              shadowSibling => 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowSiblingOf'
}->{$__p}} = $__node;
    }
  }
  $__node->{
'etx'
} = 
1
;
}


;}

;
unless ($__node->{
'nsx'
}) {
  if ($__node->{
'swln'
} =~ s/^([^:]*)://) {
    my $__prefix = $1;
    

{

local $Error::Depth = $Error::Depth + 1;

{



      $__node->{
'swns'
}
           = $self->
lookup_namespace_uri

                           ($__prefix, make_new_binding => 
0
, 
                            raise_prefix_exception => 
1
);
    


;}


;}

;
  } else {
    $__node->{
'swns'
}
           = $__node->{
'swod'
}
                    ->{
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#defaultETNamespaceURI'
};
  }
  $__node->{
'nsx'
} = 
1
;
}


;}

;
my $node = $self->{
'node'
};
my $od = $self->
owner_document
;
my $defURI = $od->
default_element_type_namespace_uri
;
if (defined $node->{
'swns'
}) {
  if ($node->{
'swns'
} eq 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#RealName'
) {
    $r = $node->{
'swln'
};
  } elsif (not defined $defURI or
      $node->{
'swns'
} ne $defURI or
      $node->{
'swln'
} eq 'Namespace' or
      $node->{
'swln'
} eq 'ElementTypeBinding' or
      $node->{
'swln'
} =~ /:/) {
    $r = $self->
lookup_namespace_prefix

                                     ($node->{
'swns'
},
                                      make_new_binding => 1) .
         ':' . $node->{
'swln'
};
  } else {
    $r = $node->{
'swln'
};
  }
} else {  ## Null namespace
  if (defined $defURI or $node->{
'swln'
} =~ /:/ or
      $node->{
'swln'
} eq 'Namespace' or
      $node->{
'swln'
} eq 'ElementTypeBinding') {
    $r = $self->
lookup_namespace_prefix

                                     ($node->{
'swns'
},
                                      make_new_binding => 1) .
         ':' . $node->{
'swln'
};
  } else {
    $r = $node->{
'swln'
};
  }
}


;}
$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::Markup::SuikaWikiConfig21::ManakaiSWCFGElement', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'real_qualified_name';
}
}
sub node_type ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r = '';
$r = '#element';
$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::Markup::SuikaWikiConfig21::ManakaiSWCFGElement', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'node_type';
}
}
sub local_name ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r = '';

{


{

my 
$__node = $self->{
'node'
};


{

unless 
($__node->{
'etx'
}) {
  my $__qn;
  if ($__node->{
'nsx'
}) {
    $__qn = $self->
_get_node_reference
 ($__node)
            ->
real_qualified_name
;
  } else {
    $__qn = $__node->{
'swln'
};

  }
  my $__od = $__node->{
'swod'
};
  if ($__od->{
'swetb'
}->{$__qn}) {
    my $b = $__od->{
'swetb'
}->{$__qn};
    $__node->{
'swns'
} = 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#RealName'
;
    if ($__node->{
'nsx'
}) {
      $__node->{
'swln'
} = $__qn;
    } else {
      $__node->{
'nsx'
} = 
1
;
    }
    unless ($b->{namespaceExpanded}) {
      if ($b->{shadowLocalName} =~ s/^([^:]*)://) {
        my $__prefix = $1;
        

{

local $Error::Depth = $Error::Depth + 1;

{



          $b->{shadowNamespaceURI}
             = $self->
_get_node_reference
 ($__od)
                     ->
lookup_namespace_uri

                           ($__prefix, make_new_binding => 
0
,
                            raise_prefix_exception => 
1
);
        


;}


;}

;
      }
      $b->{namespaceExpanded} = 
1
;
    }
    $__node->{
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowNamespaceURI'
} = $b->{shadowNamespaceURI};
    $__node->{
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowLocalName'
} = $b->{shadowLocalName};
    for my $__p (qw/shadowContent shadowSibling/) {
      next unless $b->{$__p};
      my $cl = $self->
_get_node_reference
 ($b->{$__p})
                  ->clone;
      my $__n = $__node->{{shadowContent => 
'shadow'
,
                         shadowSibling => 
'shadowsib'
}->{$__p}}
         = $cl->{
'node'
};
      $__node->
_import_tree
 ($__n);
      $__n->{{shadowContent => 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowParent'
,
              shadowSibling => 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowSiblingOf'
}->{$__p}} = $__node;
    }
  }
  $__node->{
'etx'
} = 
1
;
}


;}

;
unless ($__node->{
'nsx'
}) {
  if ($__node->{
'swln'
} =~ s/^([^:]*)://) {
    my $__prefix = $1;
    

{

local $Error::Depth = $Error::Depth + 1;

{



      $__node->{
'swns'
}
           = $self->
lookup_namespace_uri

                           ($__prefix, make_new_binding => 
0
, 
                            raise_prefix_exception => 
1
);
    


;}


;}

;
  } else {
    $__node->{
'swns'
}
           = $__node->{
'swod'
}
                    ->{
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#defaultETNamespaceURI'
};
  }
  $__node->{
'nsx'
} = 
1
;
}


;}

;
$r = (defined $self->{
'node'
}->{
'swns'
} and
      $self->{
'node'
}->{
'swns'
} eq 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#RealName'
)
       ? $self->{
'node'
}->{
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowLocalName'
}
       : $self->{
'node'
}->{
'swln'
};


;}
$r;
} else {my ($self, $given) = @_;

{


{

my 
$__node = $self->{
'node'
};


{

unless 
($__node->{
'etx'
}) {
  my $__qn;
  if ($__node->{
'nsx'
}) {
    $__qn = $self->
_get_node_reference
 ($__node)
            ->
real_qualified_name
;
  } else {
    $__qn = $__node->{
'swln'
};

  }
  my $__od = $__node->{
'swod'
};
  if ($__od->{
'swetb'
}->{$__qn}) {
    my $b = $__od->{
'swetb'
}->{$__qn};
    $__node->{
'swns'
} = 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#RealName'
;
    if ($__node->{
'nsx'
}) {
      $__node->{
'swln'
} = $__qn;
    } else {
      $__node->{
'nsx'
} = 
1
;
    }
    unless ($b->{namespaceExpanded}) {
      if ($b->{shadowLocalName} =~ s/^([^:]*)://) {
        my $__prefix = $1;
        

{

local $Error::Depth = $Error::Depth + 1;

{



          $b->{shadowNamespaceURI}
             = $self->
_get_node_reference
 ($__od)
                     ->
lookup_namespace_uri

                           ($__prefix, make_new_binding => 
0
,
                            raise_prefix_exception => 
1
);
        


;}


;}

;
      }
      $b->{namespaceExpanded} = 
1
;
    }
    $__node->{
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowNamespaceURI'
} = $b->{shadowNamespaceURI};
    $__node->{
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowLocalName'
} = $b->{shadowLocalName};
    for my $__p (qw/shadowContent shadowSibling/) {
      next unless $b->{$__p};
      my $cl = $self->
_get_node_reference
 ($b->{$__p})
                  ->clone;
      my $__n = $__node->{{shadowContent => 
'shadow'
,
                         shadowSibling => 
'shadowsib'
}->{$__p}}
         = $cl->{
'node'
};
      $__node->
_import_tree
 ($__n);
      $__n->{{shadowContent => 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowParent'
,
              shadowSibling => 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowSiblingOf'
}->{$__p}} = $__node;
    }
  }
  $__node->{
'etx'
} = 
1
;
}


;}

;
unless ($__node->{
'nsx'
}) {
  if ($__node->{
'swln'
} =~ s/^([^:]*)://) {
    my $__prefix = $1;
    

{

local $Error::Depth = $Error::Depth + 1;

{



      $__node->{
'swns'
}
           = $self->
lookup_namespace_uri

                           ($__prefix, make_new_binding => 
0
, 
                            raise_prefix_exception => 
1
);
    


;}


;}

;
  } else {
    $__node->{
'swns'
}
           = $__node->{
'swod'
}
                    ->{
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#defaultETNamespaceURI'
};
  }
  $__node->{
'nsx'
} = 
1
;
}


;}

;
if (defined $self->{
'node'
}->{
'swns'
} and
    $self->{
'node'
}->{
'swns'
} eq 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#RealName'
) {
  $self->{
'node'
}->{
'swns'
}
      = $self->{
'node'
}->{
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowNamespaceURI'
};
}
$self->{
'node'
}->{
'swln'
} = $given;


;}
}
}
sub real_local_name ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r = '';

{


{

my 
$__node = $self->{
'node'
};


{

unless 
($__node->{
'etx'
}) {
  my $__qn;
  if ($__node->{
'nsx'
}) {
    $__qn = $self->
_get_node_reference
 ($__node)
            ->
real_qualified_name
;
  } else {
    $__qn = $__node->{
'swln'
};

  }
  my $__od = $__node->{
'swod'
};
  if ($__od->{
'swetb'
}->{$__qn}) {
    my $b = $__od->{
'swetb'
}->{$__qn};
    $__node->{
'swns'
} = 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#RealName'
;
    if ($__node->{
'nsx'
}) {
      $__node->{
'swln'
} = $__qn;
    } else {
      $__node->{
'nsx'
} = 
1
;
    }
    unless ($b->{namespaceExpanded}) {
      if ($b->{shadowLocalName} =~ s/^([^:]*)://) {
        my $__prefix = $1;
        

{

local $Error::Depth = $Error::Depth + 1;

{



          $b->{shadowNamespaceURI}
             = $self->
_get_node_reference
 ($__od)
                     ->
lookup_namespace_uri

                           ($__prefix, make_new_binding => 
0
,
                            raise_prefix_exception => 
1
);
        


;}


;}

;
      }
      $b->{namespaceExpanded} = 
1
;
    }
    $__node->{
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowNamespaceURI'
} = $b->{shadowNamespaceURI};
    $__node->{
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowLocalName'
} = $b->{shadowLocalName};
    for my $__p (qw/shadowContent shadowSibling/) {
      next unless $b->{$__p};
      my $cl = $self->
_get_node_reference
 ($b->{$__p})
                  ->clone;
      my $__n = $__node->{{shadowContent => 
'shadow'
,
                         shadowSibling => 
'shadowsib'
}->{$__p}}
         = $cl->{
'node'
};
      $__node->
_import_tree
 ($__n);
      $__n->{{shadowContent => 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowParent'
,
              shadowSibling => 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowSiblingOf'
}->{$__p}} = $__node;
    }
  }
  $__node->{
'etx'
} = 
1
;
}


;}

;
unless ($__node->{
'nsx'
}) {
  if ($__node->{
'swln'
} =~ s/^([^:]*)://) {
    my $__prefix = $1;
    

{

local $Error::Depth = $Error::Depth + 1;

{



      $__node->{
'swns'
}
           = $self->
lookup_namespace_uri

                           ($__prefix, make_new_binding => 
0
, 
                            raise_prefix_exception => 
1
);
    


;}


;}

;
  } else {
    $__node->{
'swns'
}
           = $__node->{
'swod'
}
                    ->{
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#defaultETNamespaceURI'
};
  }
  $__node->{
'nsx'
} = 
1
;
}


;}

;
$r = $self->{
'node'
}->{
'swln'
};


;}
$r;
} else {my ($self, $given) = @_;

{


{

my 
$__node = $self->{
'node'
};


{

unless 
($__node->{
'etx'
}) {
  my $__qn;
  if ($__node->{
'nsx'
}) {
    $__qn = $self->
_get_node_reference
 ($__node)
            ->
real_qualified_name
;
  } else {
    $__qn = $__node->{
'swln'
};

  }
  my $__od = $__node->{
'swod'
};
  if ($__od->{
'swetb'
}->{$__qn}) {
    my $b = $__od->{
'swetb'
}->{$__qn};
    $__node->{
'swns'
} = 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#RealName'
;
    if ($__node->{
'nsx'
}) {
      $__node->{
'swln'
} = $__qn;
    } else {
      $__node->{
'nsx'
} = 
1
;
    }
    unless ($b->{namespaceExpanded}) {
      if ($b->{shadowLocalName} =~ s/^([^:]*)://) {
        my $__prefix = $1;
        

{

local $Error::Depth = $Error::Depth + 1;

{



          $b->{shadowNamespaceURI}
             = $self->
_get_node_reference
 ($__od)
                     ->
lookup_namespace_uri

                           ($__prefix, make_new_binding => 
0
,
                            raise_prefix_exception => 
1
);
        


;}


;}

;
      }
      $b->{namespaceExpanded} = 
1
;
    }
    $__node->{
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowNamespaceURI'
} = $b->{shadowNamespaceURI};
    $__node->{
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowLocalName'
} = $b->{shadowLocalName};
    for my $__p (qw/shadowContent shadowSibling/) {
      next unless $b->{$__p};
      my $cl = $self->
_get_node_reference
 ($b->{$__p})
                  ->clone;
      my $__n = $__node->{{shadowContent => 
'shadow'
,
                         shadowSibling => 
'shadowsib'
}->{$__p}}
         = $cl->{
'node'
};
      $__node->
_import_tree
 ($__n);
      $__n->{{shadowContent => 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowParent'
,
              shadowSibling => 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowSiblingOf'
}->{$__p}} = $__node;
    }
  }
  $__node->{
'etx'
} = 
1
;
}


;}

;
unless ($__node->{
'nsx'
}) {
  if ($__node->{
'swln'
} =~ s/^([^:]*)://) {
    my $__prefix = $1;
    

{

local $Error::Depth = $Error::Depth + 1;

{



      $__node->{
'swns'
}
           = $self->
lookup_namespace_uri

                           ($__prefix, make_new_binding => 
0
, 
                            raise_prefix_exception => 
1
);
    


;}


;}

;
  } else {
    $__node->{
'swns'
}
           = $__node->{
'swod'
}
                    ->{
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#defaultETNamespaceURI'
};
  }
  $__node->{
'nsx'
} = 
1
;
}


;}

;
$self->{
'node'
}->{
'swln'
} = $given;


;}
}
}
sub namespace_uri ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r = '';

{


{

my 
$__node = $self->{
'node'
};


{

unless 
($__node->{
'etx'
}) {
  my $__qn;
  if ($__node->{
'nsx'
}) {
    $__qn = $self->
_get_node_reference
 ($__node)
            ->
real_qualified_name
;
  } else {
    $__qn = $__node->{
'swln'
};

  }
  my $__od = $__node->{
'swod'
};
  if ($__od->{
'swetb'
}->{$__qn}) {
    my $b = $__od->{
'swetb'
}->{$__qn};
    $__node->{
'swns'
} = 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#RealName'
;
    if ($__node->{
'nsx'
}) {
      $__node->{
'swln'
} = $__qn;
    } else {
      $__node->{
'nsx'
} = 
1
;
    }
    unless ($b->{namespaceExpanded}) {
      if ($b->{shadowLocalName} =~ s/^([^:]*)://) {
        my $__prefix = $1;
        

{

local $Error::Depth = $Error::Depth + 1;

{



          $b->{shadowNamespaceURI}
             = $self->
_get_node_reference
 ($__od)
                     ->
lookup_namespace_uri

                           ($__prefix, make_new_binding => 
0
,
                            raise_prefix_exception => 
1
);
        


;}


;}

;
      }
      $b->{namespaceExpanded} = 
1
;
    }
    $__node->{
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowNamespaceURI'
} = $b->{shadowNamespaceURI};
    $__node->{
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowLocalName'
} = $b->{shadowLocalName};
    for my $__p (qw/shadowContent shadowSibling/) {
      next unless $b->{$__p};
      my $cl = $self->
_get_node_reference
 ($b->{$__p})
                  ->clone;
      my $__n = $__node->{{shadowContent => 
'shadow'
,
                         shadowSibling => 
'shadowsib'
}->{$__p}}
         = $cl->{
'node'
};
      $__node->
_import_tree
 ($__n);
      $__n->{{shadowContent => 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowParent'
,
              shadowSibling => 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowSiblingOf'
}->{$__p}} = $__node;
    }
  }
  $__node->{
'etx'
} = 
1
;
}


;}

;
unless ($__node->{
'nsx'
}) {
  if ($__node->{
'swln'
} =~ s/^([^:]*)://) {
    my $__prefix = $1;
    

{

local $Error::Depth = $Error::Depth + 1;

{



      $__node->{
'swns'
}
           = $self->
lookup_namespace_uri

                           ($__prefix, make_new_binding => 
0
, 
                            raise_prefix_exception => 
1
);
    


;}


;}

;
  } else {
    $__node->{
'swns'
}
           = $__node->{
'swod'
}
                    ->{
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#defaultETNamespaceURI'
};
  }
  $__node->{
'nsx'
} = 
1
;
}


;}

;
$r = (defined $self->{
'node'
}->{
'swns'
} and
      $self->{
'node'
}->{
'swns'
} eq 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#RealName'
)
     ? $self->{
'node'
}->{
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowNamespaceURI'
}
     : $self->{
'node'
}->{
'swns'
};


;}
$r;
} else {my ($self, $given) = @_;

{

unless 
(defined $given and $given eq 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#RealName'
) {
  

{

my 
$__node = $self->{
'node'
};


{

unless 
($__node->{
'etx'
}) {
  my $__qn;
  if ($__node->{
'nsx'
}) {
    $__qn = $self->
_get_node_reference
 ($__node)
            ->
real_qualified_name
;
  } else {
    $__qn = $__node->{
'swln'
};

  }
  my $__od = $__node->{
'swod'
};
  if ($__od->{
'swetb'
}->{$__qn}) {
    my $b = $__od->{
'swetb'
}->{$__qn};
    $__node->{
'swns'
} = 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#RealName'
;
    if ($__node->{
'nsx'
}) {
      $__node->{
'swln'
} = $__qn;
    } else {
      $__node->{
'nsx'
} = 
1
;
    }
    unless ($b->{namespaceExpanded}) {
      if ($b->{shadowLocalName} =~ s/^([^:]*)://) {
        my $__prefix = $1;
        

{

local $Error::Depth = $Error::Depth + 1;

{



          $b->{shadowNamespaceURI}
             = $self->
_get_node_reference
 ($__od)
                     ->
lookup_namespace_uri

                           ($__prefix, make_new_binding => 
0
,
                            raise_prefix_exception => 
1
);
        


;}


;}

;
      }
      $b->{namespaceExpanded} = 
1
;
    }
    $__node->{
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowNamespaceURI'
} = $b->{shadowNamespaceURI};
    $__node->{
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowLocalName'
} = $b->{shadowLocalName};
    for my $__p (qw/shadowContent shadowSibling/) {
      next unless $b->{$__p};
      my $cl = $self->
_get_node_reference
 ($b->{$__p})
                  ->clone;
      my $__n = $__node->{{shadowContent => 
'shadow'
,
                         shadowSibling => 
'shadowsib'
}->{$__p}}
         = $cl->{
'node'
};
      $__node->
_import_tree
 ($__n);
      $__n->{{shadowContent => 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowParent'
,
              shadowSibling => 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowSiblingOf'
}->{$__p}} = $__node;
    }
  }
  $__node->{
'etx'
} = 
1
;
}


;}

;
unless ($__node->{
'nsx'
}) {
  if ($__node->{
'swln'
} =~ s/^([^:]*)://) {
    my $__prefix = $1;
    

{

local $Error::Depth = $Error::Depth + 1;

{



      $__node->{
'swns'
}
           = $self->
lookup_namespace_uri

                           ($__prefix, make_new_binding => 
0
, 
                            raise_prefix_exception => 
1
);
    


;}


;}

;
  } else {
    $__node->{
'swns'
}
           = $__node->{
'swod'
}
                    ->{
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#defaultETNamespaceURI'
};
  }
  $__node->{
'nsx'
} = 
1
;
}


;}

;
  if (defined $self->{
'node'
}->{
'swns'
} and
     $self->{
'node'
}->{
'swns'
} eq 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#RealName'
) {
    $self->{
'node'
}->{
'swln'
}
      = $self->{
'node'
}->{
'swln'
};
  }
  $self->{
'node'
}->{
'swns'
} = $given;
}


;}
}
}
sub real_namespace_uri ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r = '';

{


{

my 
$__node = $self->{
'node'
};


{

unless 
($__node->{
'etx'
}) {
  my $__qn;
  if ($__node->{
'nsx'
}) {
    $__qn = $self->
_get_node_reference
 ($__node)
            ->
real_qualified_name
;
  } else {
    $__qn = $__node->{
'swln'
};

  }
  my $__od = $__node->{
'swod'
};
  if ($__od->{
'swetb'
}->{$__qn}) {
    my $b = $__od->{
'swetb'
}->{$__qn};
    $__node->{
'swns'
} = 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#RealName'
;
    if ($__node->{
'nsx'
}) {
      $__node->{
'swln'
} = $__qn;
    } else {
      $__node->{
'nsx'
} = 
1
;
    }
    unless ($b->{namespaceExpanded}) {
      if ($b->{shadowLocalName} =~ s/^([^:]*)://) {
        my $__prefix = $1;
        

{

local $Error::Depth = $Error::Depth + 1;

{



          $b->{shadowNamespaceURI}
             = $self->
_get_node_reference
 ($__od)
                     ->
lookup_namespace_uri

                           ($__prefix, make_new_binding => 
0
,
                            raise_prefix_exception => 
1
);
        


;}


;}

;
      }
      $b->{namespaceExpanded} = 
1
;
    }
    $__node->{
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowNamespaceURI'
} = $b->{shadowNamespaceURI};
    $__node->{
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowLocalName'
} = $b->{shadowLocalName};
    for my $__p (qw/shadowContent shadowSibling/) {
      next unless $b->{$__p};
      my $cl = $self->
_get_node_reference
 ($b->{$__p})
                  ->clone;
      my $__n = $__node->{{shadowContent => 
'shadow'
,
                         shadowSibling => 
'shadowsib'
}->{$__p}}
         = $cl->{
'node'
};
      $__node->
_import_tree
 ($__n);
      $__n->{{shadowContent => 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowParent'
,
              shadowSibling => 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowSiblingOf'
}->{$__p}} = $__node;
    }
  }
  $__node->{
'etx'
} = 
1
;
}


;}

;
unless ($__node->{
'nsx'
}) {
  if ($__node->{
'swln'
} =~ s/^([^:]*)://) {
    my $__prefix = $1;
    

{

local $Error::Depth = $Error::Depth + 1;

{



      $__node->{
'swns'
}
           = $self->
lookup_namespace_uri

                           ($__prefix, make_new_binding => 
0
, 
                            raise_prefix_exception => 
1
);
    


;}


;}

;
  } else {
    $__node->{
'swns'
}
           = $__node->{
'swod'
}
                    ->{
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#defaultETNamespaceURI'
};
  }
  $__node->{
'nsx'
} = 
1
;
}


;}

;
$r = $self->{
'node'
}->{
'swns'
};


;}
$r;
} else {my ($self, $given) = @_;

{

unless 
(defined $given and $given eq 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#RealName'
) {
  

{

my 
$__node = $self->{
'node'
};


{

unless 
($__node->{
'etx'
}) {
  my $__qn;
  if ($__node->{
'nsx'
}) {
    $__qn = $self->
_get_node_reference
 ($__node)
            ->
real_qualified_name
;
  } else {
    $__qn = $__node->{
'swln'
};

  }
  my $__od = $__node->{
'swod'
};
  if ($__od->{
'swetb'
}->{$__qn}) {
    my $b = $__od->{
'swetb'
}->{$__qn};
    $__node->{
'swns'
} = 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#RealName'
;
    if ($__node->{
'nsx'
}) {
      $__node->{
'swln'
} = $__qn;
    } else {
      $__node->{
'nsx'
} = 
1
;
    }
    unless ($b->{namespaceExpanded}) {
      if ($b->{shadowLocalName} =~ s/^([^:]*)://) {
        my $__prefix = $1;
        

{

local $Error::Depth = $Error::Depth + 1;

{



          $b->{shadowNamespaceURI}
             = $self->
_get_node_reference
 ($__od)
                     ->
lookup_namespace_uri

                           ($__prefix, make_new_binding => 
0
,
                            raise_prefix_exception => 
1
);
        


;}


;}

;
      }
      $b->{namespaceExpanded} = 
1
;
    }
    $__node->{
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowNamespaceURI'
} = $b->{shadowNamespaceURI};
    $__node->{
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowLocalName'
} = $b->{shadowLocalName};
    for my $__p (qw/shadowContent shadowSibling/) {
      next unless $b->{$__p};
      my $cl = $self->
_get_node_reference
 ($b->{$__p})
                  ->clone;
      my $__n = $__node->{{shadowContent => 
'shadow'
,
                         shadowSibling => 
'shadowsib'
}->{$__p}}
         = $cl->{
'node'
};
      $__node->
_import_tree
 ($__n);
      $__n->{{shadowContent => 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowParent'
,
              shadowSibling => 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowSiblingOf'
}->{$__p}} = $__node;
    }
  }
  $__node->{
'etx'
} = 
1
;
}


;}

;
unless ($__node->{
'nsx'
}) {
  if ($__node->{
'swln'
} =~ s/^([^:]*)://) {
    my $__prefix = $1;
    

{

local $Error::Depth = $Error::Depth + 1;

{



      $__node->{
'swns'
}
           = $self->
lookup_namespace_uri

                           ($__prefix, make_new_binding => 
0
, 
                            raise_prefix_exception => 
1
);
    


;}


;}

;
  } else {
    $__node->{
'swns'
}
           = $__node->{
'swod'
}
                    ->{
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#defaultETNamespaceURI'
};
  }
  $__node->{
'nsx'
} = 
1
;
}


;}

;
  $self->{
'node'
}->{
'swns'
} = $given;
}


;}
}
}
sub _new_object ($) {
my ($self) = @_;
my $r;

{


$r = 
Message::Markup::SuikaWikiConfig21::ManakaiSWCFGNode->_new_object
 ($self);
$r->{
'swnt'
} = '#element';


;}
$r}
$Message::DOM::ClassFeature{q<Message::Markup::SuikaWikiConfig21::ManakaiSWCFGElement>} = {'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#core', {'', '1', '2.1', '1'}};
$Message::DOM::ClassPoint{q<Message::Markup::SuikaWikiConfig21::ManakaiSWCFGElement>} = 4.2;
$Message::Util::ManakaiNode::ManakaiNodeRef::Prop{q<Message::Markup::SuikaWikiConfig21::ManakaiSWCFGElement>} = {'o', ['p'], 's', ['swcn'], 's0', ['shadow', 'shadowsib']};
package Message::Markup::IFLatest::SWCFGDocument;
our $VERSION = 20051123.0741;
package Message::Markup::SuikaWikiConfig21::ManakaiSWCFGDocument;
our $VERSION = 20051123.0741;
push our @ISA, 'Message::Markup::SuikaWikiConfig21::ManakaiSWCFGNode', 'Message::Markup::IF::SWCFGDocument', 'Message::Markup::IFLatest::SWCFGDocument';
sub create_element_ns ($$$) {
my ($self, $namespaceURI, $localName) = @_;
my $r;

{


$r = 
Message::Markup::SuikaWikiConfig21::ManakaiSWCFGElement->_new_object
;


{


$r->{'swod'} = $self->{'node'};
if (${$r->{
'tid'
}} ne ${$self->{'node'}->{
'tid'
}}) {
  $self->{'node'}->{
'rc'
}++;
  ${$self->{'node'}->{
'grc'
}}++;
}


;}

;
$r->{
'swns'
} = $namespaceURI;
$r->{
'swln'
} = $localName;
$r->{
'nsx'
} = 
1
;
$r->{
'etx'
} = 
1
;
$r = $self->
_get_node_reference
 ($r);


;}
$r}
sub create_comment ($;$) {
my ($self, $data) = @_;
my $r;

{


$r = 
Message::Markup::SuikaWikiConfig21::ManakaiSWCFGComment->_new_object
;


{


$r->{'swod'} = $self->{'node'};
if (${$r->{
'tid'
}} ne ${$self->{'node'}->{
'tid'
}}) {
  $self->{'node'}->{
'rc'
}++;
  ${$self->{'node'}->{
'grc'
}}++;
}


;}

;
$r->{
'swval'
} = defined $data ? $data : '';
$r = $self->
_get_node_reference
 ($r);


;}
$r}
sub create_document_fragment ($) {
my ($self) = @_;
my $r;

{


$r = 
Message::Markup::SuikaWikiConfig21::ManakaiSWCFGDocumentFragment->_new_object
;


{


$r->{'swod'} = $self->{'node'};
if (${$r->{
'tid'
}} ne ${$self->{'node'}->{
'tid'
}}) {
  $self->{'node'}->{
'rc'
}++;
  ${$self->{'node'}->{
'grc'
}}++;
}


;}

;
$r = $self->
_get_node_reference
 ($r);


;}
$r}
sub default_element_type_namespace_uri ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r = '';
$r = $self->{'node'}->{'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#defaultETNamespaceURI'};
$r;
} else {my ($self, $given) = @_;
$self->{'node'}->{'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#defaultETNamespaceURI'} = $given;
}
}
sub implementation ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r;
$r = $self->{'node'}->{'impl'};
$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::Markup::SuikaWikiConfig21::ManakaiSWCFGDocument', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'implementation';
}
}
sub node_type ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r = '';
$r = '#document';
$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::Markup::SuikaWikiConfig21::ManakaiSWCFGDocument', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'node_type';
}
}
sub inner_text ($;%) {
my ($self, %opt) = @_;
my $r = '';
$r}
sub actual_inner_text ($;%) {
my ($self, %opt) = @_;
my $r = '';
$r}
sub _new_object ($) {
my ($self) = @_;
my $r;

{


$r = 
Message::Markup::SuikaWikiConfig21::ManakaiSWCFGNode->_new_object
 ($self);
$r->{
'swnt'
} = '#document';
$r->{
'swnsb'
} = {URI => ''};
$r->{
'swetb'
} = {};
$r->{
'nsx'
} = 
1
; ## Always t r u e
$r->{
'etx'
} = 
1
; ## Always t r u e


;}
$r}
$Message::DOM::ClassFeature{q<Message::Markup::SuikaWikiConfig21::ManakaiSWCFGDocument>} = {'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#core', {'', '1', '2.1', '1'}};
$Message::DOM::ClassPoint{q<Message::Markup::SuikaWikiConfig21::ManakaiSWCFGDocument>} = 4.2;
$Message::Util::ManakaiNode::ManakaiNodeRef::Prop{q<Message::Markup::SuikaWikiConfig21::ManakaiSWCFGDocument>} = {'o', ['p'], 's', ['swcn'], 's2', ['swetb']};
package Message::Markup::IFLatest::SWCFGDocumentFragment;
our $VERSION = 20051123.0741;
package Message::Markup::SuikaWikiConfig21::ManakaiSWCFGDocumentFragment;
our $VERSION = 20051123.0741;
push our @ISA, 'Message::Markup::SuikaWikiConfig21::ManakaiSWCFGNode', 'Message::Markup::IF::SWCFGDocumentFragment', 'Message::Markup::IFLatest::SWCFGDocumentFragment';
sub is_shadow_master ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r = 0;
$r = $self->{'node'}->{'shadowmaster'};
$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::Markup::SuikaWikiConfig21::ManakaiSWCFGDocumentFragment', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'is_shadow_master';
}
}
sub node_type ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r = '';
$r = '#fragment';
$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::Markup::SuikaWikiConfig21::ManakaiSWCFGDocumentFragment', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'node_type';
}
}
sub _new_object ($) {
my ($self) = @_;
my $r;

{


$r = 
Message::Markup::SuikaWikiConfig21::ManakaiSWCFGNode->_new_object
 ($self);
$r->{
'swnt'
} = '#fragment';
$r->{
'nsx'
} = 
1
; ## Always t r u e
$r->{
'etx'
} = 
1
; ## Always t r u e


;}
$r}
$Message::DOM::ClassFeature{q<Message::Markup::SuikaWikiConfig21::ManakaiSWCFGDocumentFragment>} = {'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#core', {'', '1', '2.1', '1'}};
$Message::DOM::ClassPoint{q<Message::Markup::SuikaWikiConfig21::ManakaiSWCFGDocumentFragment>} = 4.2;
$Message::Util::ManakaiNode::ManakaiNodeRef::Prop{q<Message::Markup::SuikaWikiConfig21::ManakaiSWCFGDocumentFragment>} = {'o', ['shadowo', 'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowParent', 'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowSiblingOf', 'p'], 's', ['swcn']};
package Message::Markup::IFLatest::SWCFGChildNodeList;
our $VERSION = 20051123.0741;
package Message::Markup::SuikaWikiConfig21::ManakaiSWCFGChildNodeList;
our $VERSION = 20051123.0741;
push our @ISA, 'Message::Util::ManakaiNode::ManakaiNodeRef', 'Tie::Array', 'Message::Markup::IF::SWCFGChildNodeList', 'Message::Markup::IFLatest::SWCFGChildNodeList';
sub FETCHSIZE ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r = 0;

{

my 
$node = $self->{
'node'
};
$r = @{$node->{
'swcn'
}};


{

unless 
($node->{
'etx'
}) {
  my $__qn;
  if ($node->{
'nsx'
}) {
    $__qn = $self->{nodeClass}->
_get_node_reference
 ($node)
            ->
real_qualified_name
;
  } else {
    $__qn = $node->{
'swln'
};

  }
  my $__od = $node->{
'swod'
};
  if ($__od->{
'swetb'
}->{$__qn}) {
    my $b = $__od->{
'swetb'
}->{$__qn};
    $node->{
'swns'
} = 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#RealName'
;
    if ($node->{
'nsx'
}) {
      $node->{
'swln'
} = $__qn;
    } else {
      $node->{
'nsx'
} = 
1
;
    }
    unless ($b->{namespaceExpanded}) {
      if ($b->{shadowLocalName} =~ s/^([^:]*)://) {
        my $__prefix = $1;
        

{

local $Error::Depth = $Error::Depth + 1;

{



          $b->{shadowNamespaceURI}
             = $self->{nodeClass}->
_get_node_reference
 ($__od)
                     ->
lookup_namespace_uri

                           ($__prefix, make_new_binding => 
0
,
                            raise_prefix_exception => 
1
);
        


;}


;}

;
      }
      $b->{namespaceExpanded} = 
1
;
    }
    $node->{
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowNamespaceURI'
} = $b->{shadowNamespaceURI};
    $node->{
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowLocalName'
} = $b->{shadowLocalName};
    for my $__p (qw/shadowContent shadowSibling/) {
      next unless $b->{$__p};
      my $cl = $self->{nodeClass}->
_get_node_reference
 ($b->{$__p})
                  ->clone;
      my $__n = $node->{{shadowContent => 
'shadow'
,
                         shadowSibling => 
'shadowsib'
}->{$__p}}
         = $cl->{
'node'
};
      $node->
_import_tree
 ($__n);
      $__n->{{shadowContent => 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowParent'
,
              shadowSibling => 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowSiblingOf'
}->{$__p}} = $node;
    }
  }
  $node->{
'etx'
} = 
1
;
}


;}

;
if ($node->{
'shadow'
}) {
  $r += @{$node->{
'shadow'
}->{
'swcn'
}};
}
for my $c (@{$node->{
'swcn'
}}) {
  

{

unless 
($c->{
'etx'
}) {
  my $__qn;
  if ($c->{
'nsx'
}) {
    $__qn = $self->{nodeClass}->
_get_node_reference
 ($c)
            ->
real_qualified_name
;
  } else {
    $__qn = $c->{
'swln'
};

  }
  my $__od = $c->{
'swod'
};
  if ($__od->{
'swetb'
}->{$__qn}) {
    my $b = $__od->{
'swetb'
}->{$__qn};
    $c->{
'swns'
} = 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#RealName'
;
    if ($c->{
'nsx'
}) {
      $c->{
'swln'
} = $__qn;
    } else {
      $c->{
'nsx'
} = 
1
;
    }
    unless ($b->{namespaceExpanded}) {
      if ($b->{shadowLocalName} =~ s/^([^:]*)://) {
        my $__prefix = $1;
        

{

local $Error::Depth = $Error::Depth + 1;

{



          $b->{shadowNamespaceURI}
             = $self->{nodeClass}->
_get_node_reference
 ($__od)
                     ->
lookup_namespace_uri

                           ($__prefix, make_new_binding => 
0
,
                            raise_prefix_exception => 
1
);
        


;}


;}

;
      }
      $b->{namespaceExpanded} = 
1
;
    }
    $c->{
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowNamespaceURI'
} = $b->{shadowNamespaceURI};
    $c->{
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowLocalName'
} = $b->{shadowLocalName};
    for my $__p (qw/shadowContent shadowSibling/) {
      next unless $b->{$__p};
      my $cl = $self->{nodeClass}->
_get_node_reference
 ($b->{$__p})
                  ->clone;
      my $__n = $c->{{shadowContent => 
'shadow'
,
                         shadowSibling => 
'shadowsib'
}->{$__p}}
         = $cl->{
'node'
};
      $c->
_import_tree
 ($__n);
      $__n->{{shadowContent => 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowParent'
,
              shadowSibling => 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowSiblingOf'
}->{$__p}} = $c;
    }
  }
  $c->{
'etx'
} = 
1
;
}


;}

;
  $r += @{$c->{
'shadowsib'
}->{
'swcn'
}}
     if $c->{
'shadowsib'
};
}


;}
$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::Markup::SuikaWikiConfig21::ManakaiSWCFGChildNodeList', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'length';
}
}
*length = \&FETCHSIZE;
sub FETCH ($$) {
my ($self, $index) = @_;
my $r;

{

if 
($index < 0) {
  $index = $self->
length
 + $index;
}
my $node = $self->{
'node'
};
$r = $node->{
'swcn'
}->[$index];
unless ($r) {
  $index -= @{$node->{
'swcn'
}};
  

{

unless 
($node->{
'etx'
}) {
  my $__qn;
  if ($node->{
'nsx'
}) {
    $__qn = $self->{nodeClass}->
_get_node_reference
 ($node)
            ->
real_qualified_name
;
  } else {
    $__qn = $node->{
'swln'
};

  }
  my $__od = $node->{
'swod'
};
  if ($__od->{
'swetb'
}->{$__qn}) {
    my $b = $__od->{
'swetb'
}->{$__qn};
    $node->{
'swns'
} = 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#RealName'
;
    if ($node->{
'nsx'
}) {
      $node->{
'swln'
} = $__qn;
    } else {
      $node->{
'nsx'
} = 
1
;
    }
    unless ($b->{namespaceExpanded}) {
      if ($b->{shadowLocalName} =~ s/^([^:]*)://) {
        my $__prefix = $1;
        

{

local $Error::Depth = $Error::Depth + 1;

{



          $b->{shadowNamespaceURI}
             = $self->{nodeClass}->
_get_node_reference
 ($__od)
                     ->
lookup_namespace_uri

                           ($__prefix, make_new_binding => 
0
,
                            raise_prefix_exception => 
1
);
        


;}


;}

;
      }
      $b->{namespaceExpanded} = 
1
;
    }
    $node->{
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowNamespaceURI'
} = $b->{shadowNamespaceURI};
    $node->{
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowLocalName'
} = $b->{shadowLocalName};
    for my $__p (qw/shadowContent shadowSibling/) {
      next unless $b->{$__p};
      my $cl = $self->{nodeClass}->
_get_node_reference
 ($b->{$__p})
                  ->clone;
      my $__n = $node->{{shadowContent => 
'shadow'
,
                         shadowSibling => 
'shadowsib'
}->{$__p}}
         = $cl->{
'node'
};
      $node->
_import_tree
 ($__n);
      $__n->{{shadowContent => 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowParent'
,
              shadowSibling => 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowSiblingOf'
}->{$__p}} = $node;
    }
  }
  $node->{
'etx'
} = 
1
;
}


;}

;
  $r = $node->{
'shadow'
}->{
'swcn'
}->[$index]
    if $node->{
'shadow'
};
  unless ($r) {
    if ($node->{
'shadow'
}) {
      $index -= @{$node->{
'shadow'
}->{
'swcn'
}};
    }
    for my $c (@{$node->{
'swcn'
}}) {
      

{

unless 
($c->{
'etx'
}) {
  my $__qn;
  if ($c->{
'nsx'
}) {
    $__qn = $self->{nodeClass}->
_get_node_reference
 ($c)
            ->
real_qualified_name
;
  } else {
    $__qn = $c->{
'swln'
};

  }
  my $__od = $c->{
'swod'
};
  if ($__od->{
'swetb'
}->{$__qn}) {
    my $b = $__od->{
'swetb'
}->{$__qn};
    $c->{
'swns'
} = 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#RealName'
;
    if ($c->{
'nsx'
}) {
      $c->{
'swln'
} = $__qn;
    } else {
      $c->{
'nsx'
} = 
1
;
    }
    unless ($b->{namespaceExpanded}) {
      if ($b->{shadowLocalName} =~ s/^([^:]*)://) {
        my $__prefix = $1;
        

{

local $Error::Depth = $Error::Depth + 1;

{



          $b->{shadowNamespaceURI}
             = $self->{nodeClass}->
_get_node_reference
 ($__od)
                     ->
lookup_namespace_uri

                           ($__prefix, make_new_binding => 
0
,
                            raise_prefix_exception => 
1
);
        


;}


;}

;
      }
      $b->{namespaceExpanded} = 
1
;
    }
    $c->{
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowNamespaceURI'
} = $b->{shadowNamespaceURI};
    $c->{
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowLocalName'
} = $b->{shadowLocalName};
    for my $__p (qw/shadowContent shadowSibling/) {
      next unless $b->{$__p};
      my $cl = $self->{nodeClass}->
_get_node_reference
 ($b->{$__p})
                  ->clone;
      my $__n = $c->{{shadowContent => 
'shadow'
,
                         shadowSibling => 
'shadowsib'
}->{$__p}}
         = $cl->{
'node'
};
      $c->
_import_tree
 ($__n);
      $__n->{{shadowContent => 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowParent'
,
              shadowSibling => 
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#shadowSiblingOf'
}->{$__p}} = $c;
    }
  }
  $c->{
'etx'
} = 
1
;
}


;}

;
      if ($c->{
'shadowsib'
}) {
        $r = $c->{
'shadowsib'
}->{
'swcn'
}->[$index];
        last if $r;
        $index -= @{$c->{
'shadowsib'
}->{
'swcn'
}};
      }
    }
  }
}
$r = $self->{nodeClass}
          ->
_get_node_reference
 ($r) if $r;


;}
$r}
*item = \&FETCH;
sub TIEARRAY ($$) {
my ($self, $nodeList) = @_;
my $r;

{


$r = $nodeList;


;}
$r}
sub DESTROY ($) {
my ($self) = @_;

{

if 
(my $node = $self->{
'node'
}) {
  CORE::delete $self->{
'node'
};
  unless ($self->{
'w'
}) {
    $node->{
'rc'
}--;
    ${$node->{
'grc'
}}--;
    unless (
(${$node->{'grc'}} > 0)
) {
      $node->
_destroy
;
    }
  }
} else {
  warn ref ($self) . q{->DESTROY: there is no associated }.
       q{node object - you have a global variable or }.
       qq{potential memory-leak detected\n};
}


;}
}
use overload 
bool => sub () {1}, 
'@{}' => sub ($) {
my ($self) = @_;
my $r = [];

{

tie 
my @list, ref $self, $self;
$r = \@list;


;}
$r}
, 
fallback => 1;
$Message::DOM::ClassFeature{q<Message::Markup::SuikaWikiConfig21::ManakaiSWCFGChildNodeList>} = {'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#core', {'', '1', '2.1', '1'}};
$Message::DOM::ClassPoint{q<Message::Markup::SuikaWikiConfig21::ManakaiSWCFGChildNodeList>} = 2.1;
$Message::Util::ManakaiNode::ManakaiNodeRef::Prop{q<Message::Markup::SuikaWikiConfig21::ManakaiSWCFGChildNodeList>} = {};
package Message::Markup::IFLatest::SWCFGException;
our $VERSION = 20051123.0741;
push our @ISA, 'Message::Util::Error';
sub HIERARCHY_REQUEST_ERR () {
3}
sub WRONG_DOCUMENT_ERR () {
4}
sub TYPE_MISMATCH_ERR () {
17}
sub NOT_SUPPORTED_ERR () {
9}
sub NAMESPACE_ERR () {
14}
sub PARSE_ERR () {
81}
sub ___error_def () {

{'HIERARCHY_REQUEST_ERR', {'description', 'An attempt is made to insert a node somewhere it does not belong.', 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#code', '3', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype', {'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#HIERARCHY_ANCESTOR_OR_SELF_ERR', {'description', 'An attempt is made to insert an ancestor of this node or this node itself.'}, 'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#HIERARCHY_BAD_TYPE_ERR', {'description', 'An attempt is made to insert a node %p ( name => {http://suika.fam.cx/~wakaba/archive/2005/swcfg21#childNodeType}, prefix => { of type }); into the node %p (name => {http://suika.fam.cx/~wakaba/archive/2005/swcfg21#parentNodeType}, prefix => {of type });, which is not allowed'}, 'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#HIERARCHY_NO_VALUE_ERR', {'description', 'An attempt is made to set a node value for a %p (name => {http://suika.fam.cx/~wakaba/archive/2005/swcfg21#parentNodeType}); node'}}}, 'NAMESPACE_ERR', {'description', 'An error related to namespaces has occurred.', 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#code', '14', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype', {'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS#UNDECLARED_NS_PREFIX_ERR', {'description', 'Namespace prefix "%p (name => {http://www.w3.org/2001/04/infoset#prefix});" is not declared'}}}, 'NOT_SUPPORTED_ERR', {'description', '', 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#code', '9', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype', {'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#SWCFG_VERSION_NOT_SUPPORTED_ERR', {'description', 'The implementation does not support the specified version of SuikaWikiConfig.'}}}, 'PARSE_ERR', {'description', '', 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#code', '81', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype', {'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#SWCFG_PARSE_ERR', {'description', 'The implementation is unable to read and parse the SuikaWikiConfig document.'}}}, 'TYPE_MISMATCH_ERR', {'description', 'The type of an object is incompatible with the type of the parameter.', 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#code', '17', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype', {'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#APPEND_NULL_TEXT_ERR', {'description', 'An attempt is made to append a <DOM::null> value.'}, 'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#BAD_VALUE_ERR', {'description', 'A value%p (name => {http://suika.fam.cx/~wakaba/archive/2005/swcfg21#actualType}, prefix => { of type }); is specified where only either string or array reference is allowed'}, 'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#NOT_NODE_ERR', {'description', 'The type of an object is not <IF::SWCFGNode>.'}}}, 'WRONG_DOCUMENT_ERR', {'description', 'A node is used in a different document than the one for which it is created.', 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#code', '4', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype', {'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#EXTERNAL_NODE_ERR', {'description', 'An attempt is made to append a node created for another document'}}}}
}
package Message::Markup::SuikaWikiConfig21::ManakaiSWCFGException;
our $VERSION = 20051123.0741;
push our @ISA, 'Message::Util::Error::DOMException::Exception', 'Message::Markup::IF::SWCFGException', 'Message::Markup::IFLatest::SWCFGException';
sub text ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r;

{


$r = $self->SUPER::text;
if (defined $self->{
'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS#sourceNode'
}) {
  $r = 'Node ' . $self->{
'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS#sourceNode'
}->
node_path

                  . ': ' . $r;
}


;}
$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::Markup::SuikaWikiConfig21::ManakaiSWCFGException', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'text';
}
}
$Message::DOM::ClassFeature{q<Message::Markup::SuikaWikiConfig21::ManakaiSWCFGException>} = {'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#core', {'', '1', '2.1', '1'}};
$Message::DOM::ClassPoint{q<Message::Markup::SuikaWikiConfig21::ManakaiSWCFGException>} = 2.1;
package Message::Markup::IFLatest::SWCFGParser;
our $VERSION = 20051123.0741;
package Message::Markup::SuikaWikiConfig21::ManakaiSWCFGParser;
our $VERSION = 20051123.0741;
push our @ISA, 'Message::Util::Error::DOMException::ManakaiDefaultExceptionHandler', 'Message::Markup::IF::SWCFGParser', 'Message::Markup::IFLatest::SWCFGParser';
sub parse ($$) {
my ($self, $input) = @_;

{

if 
(ref $input eq 'HASH') {
  $input = bless $input, 
'Message::DOM::DOMLS::ManakaiDOMLSInput'
;
}


;}
my $r;

{

my 
$text;
## 1. characterStream
if (defined (my $cs = $input->
character_stream
)) {
  local $/ = undef;
  $text = \ (readline $cs);
}
## 2. byteStream
elsif (defined (my $bs = $input->
byte_stream
)) {
  
report Message::Markup::SuikaWikiConfig21::ManakaiSWCFGException -object => $self, '-type' => 'NOT_SUPPORTED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'parse', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::Markup::SuikaWikiConfig21::ManakaiSWCFGParser', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#param-name' => 'input';

;
}
## 3. stringData
elsif (defined (my $sd = $input->
string_data
)) {
  $text = \$sd;
}
## 4. systemId
## 5. publicId
elsif (defined (my $sysId = $input->
system_id
) or
       defined (my $pubId = $input->
public_id
)) {
  
report Message::Markup::SuikaWikiConfig21::ManakaiSWCFGException -object => $self, '-type' => 'NOT_SUPPORTED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'parse', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::Markup::SuikaWikiConfig21::ManakaiSWCFGParser', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#param-name' => 'input';

;
} else {
  ## TODO: no-input-specified DOM error
  
report Message::Markup::SuikaWikiConfig21::ManakaiSWCFGException -object => $self, '-type' => 'PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'parse', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#SWCFG_PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::Markup::SuikaWikiConfig21::ManakaiSWCFGParser', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#param-name' => 'input';

;
}

my $root = $self->{
'impl'
}
                ->
create_swcfg_document
;

## TODO: Make configurable
my $no_magic_line = 
0
;
my $no_namespace = 
0
;
my $no_preserve_wsp = 
0
;
my $no_binding = 
0
;

## Magic line
if (not $no_magic_line and
    $$text =~ s[^\#\?SuikaWikiConfig/(\d+\.\d+)\x0D?\x0A][]s) {
  my $version = $1;
  if ($version eq '2.1') {
    # 
  } elsif ($version eq '2.0') {
    $no_namespace = 
1
;
    $no_preserve_wsp = 
1
;
    $no_binding = 
1
;
  } else {
    ## TODO: Version unsupported DOM error
    
report Message::Markup::SuikaWikiConfig21::ManakaiSWCFGException -object => $self, '-type' => 'PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'parse', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#SWCFG_PARSE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::Markup::SuikaWikiConfig21::ManakaiSWCFGParser', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#param-name' => 'input';

;
  }
}

my $current = $root;
my $current_element = $root;
my $is_new_element = 0;
my $is_list_element = 0;
my $wsp_length = 0;
my $vfragment = '';
for my $line (split /\x0D?\x0A/, $$text) {
  if ($line =~ /^([^#\s].*):\s*([^\s:][^:]*)?$/) {
    my ($name, $val) = ($1, $2);
    substr ($name, 0, 1) = '' if defined $name and 
                                 substr ($name, 0, 1) eq '\\';
    substr ($val, 0, 1) = '' if defined $val and
                                substr ($val, 0, 1) eq '\\';
   if (substr ($name, -6) eq '[list]') {
     substr ($name, -6) = '';
     $val = length ($val) ? [$val] : [];
     $is_list_element = 1;
   } else {
     $is_list_element = 0;
   }
   $current_element = $root->
append_new_node

                                 (type => '#element',
                                  local_name => $name,
                                  value => $val);
   $current_element->{
'node'
}
                   ->{
'nsx'
} = 
0
     unless 
$no_namespace;
   $current_element->{
'node'
}
                   ->{
'etx'
} = 
0
     unless 
$no_binding;
   if (defined $2) {  ## Foo: bar
     $current = $root;
     $current_element = $root;
   } else {           ## Foo:\n  bar\n  baz
     $current = $current_element;
     $is_new_element = 1;
   }
 } elsif ($line =~ /^\s+(\@+)(.*):\s*([^\s:][^:]*)?$/) {
   my ($nest, $name, $val) = (length $1, $2, $3);
   substr ($name, 0, 1) = '' if defined $name and 
                                substr ($name, 0, 1) eq '\\';
   substr ($val, 0, 1) = '' if defined $val and
                               substr ($val, 0, 1) eq '\\';
   if (substr ($name, -6) eq '[list]') {
     substr ($name, -6) = '';
     $val = (defined ($val) and length ($val)) ? [$val] : [];
     $is_list_element = 1;
   } else {
     $is_list_element = 0;
   }
   my $ce;
   if (length ($name)) {
     while ($current_element->
flag

                                        ('p__nest_level' => 
undef
,
                                         default => 0) >= $nest) {
       $current_element
            = $current_element->
parent_node
;
     }
     $ce = $current_element->
append_new_node

                                (type => '#element',
                                 local_name => $name,
                                 value => $val);
     $ce->{
'node'
}
                   ->{
'nsx'
} = 
0
       unless 
$no_namespace;
     $ce->{
'node'
}
                   ->{
'etx'
} = 
0
       unless 
$no_binding;
     $ce->
flag
 ('p__nest_level'
           => $current_element->
flag

                                  ('p__nest_level' => 
undef
,
                                   default => 0) + 1);
     unless (defined $3) {  ##  @foo: \nbar
       $current_element = $ce;
       $current = $ce;
       $is_new_element = 1;
     }
   } else {  ## @@:
     while ($current_element->
flag

                                ('p__nest_level' => 
undef
,
                                 default => 0) >= $nest - 1) {
       $current_element
                 = $current_element->
parent_node
;
     }
     if (defined $val) {
       if (defined $current_element->{
'node'
}
                                   ->{
'swval'
}) {
         if (ref $current_element->{
'node'
}->{
'swval'
}
               eq 'ARRAY') {
           push @{$current_element->{
'node'
}
                                  ->{
'swval'
}}, $val;
         } else {
           $current_element->{
'node'
}
                                  ->{
'swval'
} .= $val;
         }
       } else {
         $current_element->{
'node'
}->{
'swval'
} = $val;
       }
     }
     $current = $current_element;
     unless (defined $3) {  ##  @@: \nbar
       $is_new_element = 1;
     }
   }
 } elsif ($line =~ /^(\s+)(\S.*)$/) {
   my ($wsp, $val) = ($1, $2);
   if (substr ($val, 0, 1) eq '#' and
       not $is_new_element and
       length $wsp < $wsp_length) {  ## Not part of element
     $current = $root->
append_new_node

                              (type => '#comment',
                               value => substr ($val, 1));
   } else {
     if (substr ($val, 0, 1) eq '\\') {
       substr ($val, 0, 1) = '';
       $wsp = '';
     }
     if ($is_new_element or $is_list_element) {
       $wsp_length = length $wsp;
         if (defined $current_element->{
'node'
}
                                     ->{
'swval'
}) {
           if (ref $current_element->{
'node'
}
                                   ->{
'swval'
} eq 'ARRAY') {
             push @{$current_element->{
'node'
}
                                    ->{
'swval'
}}, $val;
           } else {
             $current_element->{
'node'
}
                                    ->{
'swval'
} .= $val;
           }
         } else {
           $current_element->{
'node'
}
                           ->{
'swval'
} = $val;
         }
       $is_new_element = 0;
       $vfragment = '';
     } else {
       $wsp = $no_preserve_wsp ? '' : substr ($wsp, $wsp_length);
       $val = $vfragment . "\x0A" . $wsp . $val;
         if (defined $current_element->{
'node'
}
                                     ->{
'swval'
}) {
           if (ref $current_element->{
'node'
}
                                   ->{
'swval'
} eq 'ARRAY') {
             push @{$current_element->{
'node'
}
                                    ->{
'swval'
}}, $val;
           } else {
             $current_element->{
'node'
}
                                  ->{
'swval'
} .= $val;
           }
         } else {
           $current_element->{
'node'
}
                                  ->{
'swval'
} = $val;
         }
       $vfragment = '';
     }
   }
 } elsif ($line =~ /^(\s*)$/) {
   $vfragment .= "\x0A" . substr ($1, $wsp_length)
        unless $no_preserve_wsp;
   $current = $root
        if $current->
node_type eq 
'#comment';
 } else { $line =~ /^\#?(.*)$/;
 #} elsif ($line =~ /^\#(.*)$/) {
   my ($v) = ($1);
   if ($current->
node_type eq 
'#comment') {
     $current->
append_text
 ("\x0A" . $v);
   } else {
     $current = $root->
append_new_node

                              (type => '#comment', value => $v);
   }
 #} else {
 #  $current = $root;
 #  #print STDERR qq(**$line**\n); 
 }
}
unless ($no_namespace and $no_binding) {
 my @remove;
 for my $i (0..$#{$root->{
'node'
}->{
'swcn'
}}) {
   my $n = $root->{
'node'
}->{
'swcn'
}->[$i];
   next unless $n->{
'swnt'
} eq '#element';
   if (not $no_namespace and $n->{
'swln'
} eq 'Namespace') {
     for my $cn (@{$n->{
'swcn'
}}) {
       next unless $cn->{
'swnt'
} eq '#element';
       if ($cn->{
'swval'
}) {
         $root->{
'node'
}->{
'swnsb'
}
              ->{$cn->{
'swln'
}} = $cn->{
'swval'
};
       } else {
         ISNULL: {
           for my $in (@{$cn->{
'swcn'
}}) {
             if ($in->{
'swnt'
} eq '#element' and
                 $in->{
'swln'
} eq 'is-
undef
' and
                 $in->{
'swval'
}) {
               $root->{
'node'
}->{
'swnsb'
}
                    ->{$cn->{
'swln'
}} = undef;
               last ISNULL;
             }
           }
           $root->{
'node'
}->{
'swnsb'
}
                ->{$cn->{
'swln'
}} = $cn->{
'swval'
};
         } # ISNULL
       }
     }
     ## TODO: DOM error if unknown node
     push @remove, $i;
     CORE::delete $n->{
'p'
};
     $n->
_orphanate
;
   } elsif (not $no_binding and
            $n->{
'swln'
} eq 'ElementTypeBinding') {
     my ($et, $sn, $sc, $ss) = ('', '');
     my @etr;
     CN: for my $cn (@{$n->{
'swcn'
}}) {
       unless ($cn->{
'swnt'
} eq '#element') {
         push @etr, $cn;
         next CN;
       }
       if ($cn->{
'swln'
} eq 'Name') {
         $et = $cn->{
'swval'
} if defined $cn->{
'swval'
};
         push @etr, $cn;
       } elsif ($cn->{
'swln'
} eq 'ElementType') {
         $sn = $cn->{
'swval'
} if defined $cn->{
'swval'
};
         push @etr, $cn;
       } elsif ($cn->{
'swln'
} eq 'ShadowContent') {
         $sc = $cn;
         $sc->{
'swnt'
} = '#fragment';
         $sc->{
'p'
} = 
undef
;
         $sc->{
'shadowmaster'
} = 
1
;
         $sc->{
'shadowo'
} = $root->{
'node'
};
         $sc->{
'nsx'
} = 
1
;
         $sc->{
'etx'
} = 
1
;
         $sc->{
't'
}
           = 
'Message::Markup::SuikaWikiConfig21::ManakaiSWCFGDocumentFragment'
;
       } elsif ($cn->{
'swln'
} eq 'ShadowSibling') {
         $ss = $cn;
         $ss->{
'swnt'
} = '#fragment';
         $ss->{
'p'
} = 
undef
;
         $ss->{
'shadowmaster'
} = 
1
;
         $ss->{
'shadowo'
} = $root->{
'node'
};
         $ss->{
'nsx'
} = 
1
;
         $ss->{
'etx'
} = 
1
;
         $ss->{
't'
}
           = 
'Message::Markup::SuikaWikiConfig21::ManakaiSWCFGDocumentFragment'
;
       } else {
         push @etr, $cn;
       }
     }
     $n->{
'swcn'
} = [];
     for (@etr) {
       CORE::delete $_->{
'p'
};
       $_->
_orphanate
;
     }
     unless (defined $root->{
'node'
}
                          ->{
'swetb'
}->{$et}) {
       $root->{
'node'
}
            ->{
'swetb'
}->{$et} = {
         elementType => $et,
         shadowLocalName => $sn,
         namespaceExpanded => 
0
,
         shadowContent => $sc,
         shadowSibling => $ss,
       };
     }
     ## TODO: DOM error if unknown node
     push @remove, $i;
     CORE::delete $n->{
'p'
};
     $n->
_orphanate
;
   }
 } # $i
 for my $i (reverse @remove) {
   splice @{$root->{
'node'
}->{
'swcn'
}},
          $i, 1, ();
 }
}
$r = $root;


;}
$r}
sub new ($$$) {
my ($self, $impl, $features) = @_;

{

if 
(CORE::defined $features) {
  if (CORE::ref ($features) eq 'HASH') {
    my $new = {};
    for my $fname (keys %{$features}) {
      if (CORE::ref ($features->{$fname}) eq 'HASH') {
        my $lfname = lc $fname;
        for my $fver (keys %{$features->{$fname}}) {
          $new->{$lfname}->{$fver} = $features->{$fname}->{$fver};
        }
      } else {
        $new->{lc $fname} = {(CORE::defined $features->{$fname}
                                ? $features->{$fname} : '') => 1};
      }
    }
    $features = $new;
  } else {
    my @f = split /\s+/, $features;
    $features = {};
    while (@f) {
      my $name = lc shift @f;
      if (@f and $f[0] =~ /^[\d\.]+$/) {
        $features->{$name}->{shift @f} = 1;
      } else {
        $features->{$name}->{''} = 1;
      }
    }
  }
} else {
  $features = {};
}


;}
my $r;

{


$r = bless {
'impl'
 =>
               $impl->
get_feature

                  (
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#Core'
 => '2.1')},
           $self;


;}
$r}
$Message::DOM::ClassFeature{q<Message::Markup::SuikaWikiConfig21::ManakaiSWCFGParser>} = {'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#core', {'', '1', '2.1', '1'}};
$Message::DOM::ClassPoint{q<Message::Markup::SuikaWikiConfig21::ManakaiSWCFGParser>} = 2.1;
$Message::DOM::DOMLS::ParserClass{q<Message::Markup::SuikaWikiConfig21::ManakaiSWCFGParser>} = 1;
package Message::Markup::IFLatest::SWCFGImplementation;
our $VERSION = 20051123.0741;
package Message::Markup::SuikaWikiConfig21::ManakaiSWCFGImplementation;
our $VERSION = 20051123.0741;
push our @ISA, 'Message::DOM::DOMFeature::ManakaiMinimumImplementation', 'Message::Markup::IF::SWCFGImplementation', 'Message::Markup::IFLatest::SWCFGImplementation';
sub create_swcfg_document ($;$) {
my ($self, $version) = @_;
my $r;

{

if 
(defined $version and $version ne '2.1') {
  
report Message::Markup::SuikaWikiConfig21::ManakaiSWCFGException -object => $self, '-type' => 'NOT_SUPPORTED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'create_swcfg_document', 'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#version' => $version, 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#SWCFG_VERSION_NOT_SUPPORTED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::Markup::SuikaWikiConfig21::ManakaiSWCFGImplementation';

;
}
$r = 
Message::Markup::SuikaWikiConfig21::ManakaiSWCFGDocument->_new_object
;
$r->{
'impl'
} = $self;
$r->{
'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#version'
} = $version || '2.1';
$r = 
Message::Markup::SuikaWikiConfig21::ManakaiSWCFGNode->_get_node_reference
 ($r);


;}
$r}
sub create_swcfg_parser ($;$) {
my ($self, $versions) = @_;
my $r;

{


## TODO: Support $versions
if (defined $versions) {
  
report Message::Markup::SuikaWikiConfig21::ManakaiSWCFGException -object => $self, '-type' => 'NOT_SUPPORTED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'create_swcfg_parser', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#SWCFG_VERSION_NOT_SUPPORTED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::Markup::SuikaWikiConfig21::ManakaiSWCFGImplementation';

;
}
$r = 
'Message::Markup::SuikaWikiConfig21::ManakaiSWCFGParser'
->new ($self);


;}
$r}
$Message::DOM::ImplFeature{q<Message::Markup::SuikaWikiConfig21::ManakaiSWCFGImplementation>}->{q<http://suika.fam.cx/~wakaba/archive/2005/swcfg21#core>}->{q<2.1>} ||= 1;
$Message::DOM::ImplFeature{q<Message::Markup::SuikaWikiConfig21::ManakaiSWCFGImplementation>}->{q<http://suika.fam.cx/~wakaba/archive/2005/swcfg21#core>}->{q<>} = 1;
$Message::DOM::ClassFeature{q<Message::Markup::SuikaWikiConfig21::ManakaiSWCFGImplementation>} = {'http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#minimum', {'', '1', '3.0', '1'}, 'http://suika.fam.cx/~wakaba/archive/2005/swcfg21#core', {'', '1', '2.1', '1'}};
$Message::DOM::ClassPoint{q<Message::Markup::SuikaWikiConfig21::ManakaiSWCFGImplementation>} = 5.1;
$Message::DOM::ManakaiDOMImplementationSource::SourceClass{q<Message::Markup::SuikaWikiConfig21::ManakaiSWCFGImplementation>} = 1;
$Message::DOM::ManakaiDOMImplementation::CompatClass{q<Message::Markup::SuikaWikiConfig21::ManakaiSWCFGImplementation>} = 1;
$Message::Util::ManakaiNode::ManakaiNodeRef::Prop{q<Message::Markup::SuikaWikiConfig21::ManakaiSWCFGImplementation>} = {};
push @Message::Markup::IF::SWCFGException::ISA, 'Message::Util::Error' unless @Message::Markup::IF::SWCFGException::ISA;
for ($Message::Markup::IF::SWCFGChildNodeList::, $Message::Markup::IF::SWCFGComment::, $Message::Markup::IF::SWCFGDocument::, $Message::Markup::IF::SWCFGDocumentFragment::, $Message::Markup::IF::SWCFGElement::, $Message::Markup::IF::SWCFGImplementation::, $Message::Markup::IF::SWCFGNode::, $Message::Markup::IF::SWCFGParser::){}
## License: <http://suika.fam.cx/~wakaba/archive/2004/8/18/license#Perl+MPL>
1;
