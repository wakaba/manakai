Module:
  @QName:
    Markup:SuikaWikiConfig21
  @FullName:
    @@lang: en
    @@@:
      SuikaWikiConfig/2.1 Object Model
  @Namespace:
    http://suika.fam.cx/~wakaba/archive/2005/swcfg21#
  
  @Description:
    @@lang:en
    @@@:
      The <Module::SuikaWikiConfig21> module provides an object model 
      for SuikaWikiConfig/2.1 document format.  

  @Author:
    @@FullName: Wakaba
    @@Mail: w@suika.fam.cx
  @License:
    @@@:
      license:Perl+MPL
    @@Original:
      @@@FullName:
        SuikaWiki <PerlModule::SuikaWiki::Markup::SuikaWikiConfig20>
      @@@Year:2003
      @@@Author:
        @@@@FullName:Wakaba
        @@@@Mail:w@suika.fam.cx
  @Date:
    @@@:
      $Date: 2005/03/04 12:18:52 $
    @@ContentType:
      dis:Date.RCS
  
  @Require:
    @@Module:
      @@@Name: ManakaiNode
      @@@WithFor:
        ManakaiDOM:all
    @@Module:
      @@@Name: DISIDL
      @@@QName:
        DISlib:DISIDL
      @@@WithFor:
        ManakaiDOM:all
    @@Module:
      @@@Name: DOMException
      @@@QName:
        UtilError:DOMException
      @@@WithFor:
        ManakaiDOM:all
    @@Module:
      @@@Name: DOMBoot
      @@@QName:
        MDOM:DOMBoot
      @@@WithFor:
        ManakaiDOM:ManakaiDOM
    @@Module:
      @@@Name: DOMBoot
      @@@QName:
        MDOM:DOMBoot
      @@@WithFor:
        ManakaiDOM:ManakaiDOMLatest
    @@Module:
      @@@Name: SuikaWikiConfig21
      @@@WithFor:
        ManakaiDOM:all
    @@Module:
      @@@Name: SuikaWikiConfig21
      @@@WithFor: 
        swcfg21:ForLatest

  @DefaultFor: 
    swcfg21:ForLatest

Namespace:
  @dis:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#dis--
  @dis2pm:
    http://suika.fam.cx/~wakaba/archive/2004/11/8/dis2pm#
  @DISLang:
    http://suika.fam.cx/~wakaba/archive/2004/dis/Lang#
  @DISlib:
    http://suika.fam.cx/~wakaba/archive/2004/dis/
  @DOMCore:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#
  @DOMLS:
    http://suika.fam.cx/~wakaba/archive/2004/dom/ls#
  @DOMMain:
    http://suika.fam.cx/~wakaba/archive/2004/dom/main#
  @lang:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#
  @license:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/license#
  @ManakaiDOM:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#
  @Markup:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Markup#
  @MDOM:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#ManakaiDOM.
  @MDOMX:
    http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#
  @owl:
    http://www.w3.org/2002/07/owl#
  @Perl:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#Perl--
  @rdf:
    http://www.w3.org/1999/02/22-rdf-syntax-ns#
  @rdfs:
    http://www.w3.org/2000/01/rdf-schema#
  @swcfg21:
    http://suika.fam.cx/~wakaba/archive/2005/swcfg21#
  @TreeCore:\
  @UtilError:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/

ResourceDef:
  @QName:
    Markup:
  @rdf:type:
    dis:ModuleGroup
  @FullName:
    @@lang:en
    @@@:
      The manakai Markup Language support modules
  @AppName:
    @@@:
      Message::Markup::IFLatest::
    @@ContentType:
      lang:Perl
    @@ForCheck: 
      ManakaiDOM:ForIF ForLatest
  @AppName:
    @@@:
      Message::Markup::IF::
    @@ContentType:
      lang:Perl
    @@ForCheck: 
      ManakaiDOM:ForIF
  @AppName:
    @@@:
      Message::Markup::
    @@ForCheck: ForLatest

## -- "For" definitions

## For one of multiple resources

ForDef:
  @QName: 
    swcfg21:ForIF
  @FullName:
    @@lang:en
    @@@: For interface
  @ISA:
    ManakaiDOM:ForIF

ForDef:
  @QName:
    swcfg21:ForClass
  @FullName:
    @@lang:en
    @@@: For class
  @ISA:
    ManakaiDOM:ForClass

## For a version

ForDef:
  @QName:
    swcfg21:ForLatest
  @FullName:
    @@lang:en
    @@@: For latest version
  @ISA:
    ManakaiDOM:Perl

## -- Features and versions

ElementTypeBinding:
  @Name: FeatureDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DOMMain:DOMFeature
    @@AliasFor:
      @@@@:
        ::ManakaiDOM:all
      @@@For:
        !=ManakaiDOM:all

ElementTypeBinding:
  @Name: FeatureVerDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DOMMain:DOMFeature

ElementTypeBinding:
  @Name: featureQName
  @ElementType:
    dis:AppName
  @ShadowContent:
    @@ContentType:
      dis:TypeQName

FeatureDef:
  @QName: CoreFeature
  @featureQName: Core
  @FeatureVerDef:
    @@QName: CoreFeature21
    @@Version: 2.1
    @@ISA: CoreFeature
    @@FullName:
      @@@lang:en
      @@@@:
        The SuikaWikiConfig/2.1 object model
    @@Description:
      @@@lang:en
      @@@@:
        The SuikaWikiConfig/2.1 object model. 

PropDef:
  @QName: 
    swcfg21:namespaceAwareVariant
  @Description:
    @@lang:en
    @@@:
      A namespace aware variant of the subject method or attribute. 

PropDef:
  @QName: namespaceUnawareVariant
  @Description:
    @@lang:en
    @@@:
      A namespace unaware variant of the subject method or attribute. 

## -- Node

IFClassDef:
  @IFQName: SWCFGNode
  @ClassQName: ManakaiSWCFGNode

  @ISA:
    @@@:
      ManakaiDOM:ManakaiDOMNodeReference::ManakaiDOM:Perl
    @@ForCheck: ForClass
  
  @Description:
    @@lang:en
    @@@:
      Each SuikaWikiConfig/2.1 node object implements the 
      <IF::SWCFGNode> interface, which provides access to 
      its properties and chilren. 
      \
      {NOTE:: The <M::new> method, available in the module 
              <PerlModule::Message::Markup::SuikaWikiConfig20::Node>, 
              is removed from the object model in favor of 
              the factory methods on <IF::SWCFGImplementation> and 
              <IF::SWCFGDocument> interfaces. 
      \
      }

  @Method:
    @@Name:appendNode
    @@Description:
      @@@lang:en
      @@@@:
        Appends a node to the list of children of this node. 
    @@Param:
      @@@Name:node
      @@@Type:
        DOMMain:Object
      @@@Description:
        @@@@lang:en
        @@@@@:
          The node or node value to append. 
      @@@InCase:
        @@@@Type:SWCFGNode
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The <P::node> is appended to the list of children. 
      @@@InCase:
        @@@@Type:SWCFGDocumentFragment
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            Children of the <P::node> is appended. 
      @@@InCase:
        @@@@Type:SWCFGString
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The <P::node> is appended to the value of this node, 
            as <M::SWCFGNode.appendText> does, if <P::nodeOrText> 
            is set to <DOM::true>.  Otherwise, an exception is raised. 
    @@NamedParam:
      @@@Name:nodeOrText
      @@@Type:
        DOMMain:boolean
      @@@Description:
        @@@@lang:en
        @@@@@:
          Whether a string input should be accepted or not. 
      @@@InCase:
        @@@@Value:true
        @@@@Type:
          DOMMain:boolean
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            A <TYPE::SWCFGString> is accepted as a <P::node> parameter 
            value. 
      @@@InCase:
        @@@@Value:false
        @@@@Type:
          DOMMain:boolean
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            A <TYPE::SWCFGString> is not accepted as a <P::node> 
            parameter value. 
    @@Return:
      @@@Type:SWCFGNode
      @@@actualType:ManakaiSWCFGNode
      @@@Description:
        @@@@lang:en
        @@@@@:
          The node appended to the child list. 
          \
          If the <P::node> is of <IF::SWCFGDocumentFragment>, 
          this (parent) node is returned instead. 
      @@@RaiseException:
        @@@@@: HIERARCHY_ANCESTOR_OR_SELF_ERR
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The <P::node> is an ancestor of this node or this node itself. 
      @@@RaiseException:
        @@@@@: HIERARCHY_BAD_TYPE_ERR
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            An attempt is made to append non-element node on element or 
            document fragment node or an attempt is made to append any 
            node on comment node or document or document fragment 
            node on any node. 
      @@@RaiseException:
        @@@@@:NOT_NODE_ERR
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The <P::node> object is not of <IF::SWCFGNode> if 
            <P::nodeOrText> is <DOM::false> or is neither of 
            <IF::SWCFGNode> nor <IF::SWCFGString> if 
            <P::nodeOrText> is <DOM::true>. 
      @@@RaiseException:
        @@@@@: EXTERNAL_NODE_ERR
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The <P::node> does not belong to the same document 
            as the owner of this node. 
      @@@PerlDef:
        unless (UNIVERSAL::isa ($node, <IFName::SWCFGNode>)) {
          if ($nodeOrText) {
            __DEEP{
              $r = $self-><M::ManakaiSWCFGNode.appendText> ($node);
            }__;
          } else {
            __EXCEPTION{NOT_NODE_ERR::
              SuikaWikiConfig21:actualType => {ref $node},
            }__;
          }
        } else {
          my $this_node_type = $self-><M::SWCFGNode.nodeType>;
          my $that_node_type = $node-><M::SWCFGNode.nodeType>;
          if ($this_node_type eq '#comment') {
            __EXCEPTION{HIERARCHY_BAD_TYPE_ERR::
              MDOMX:param-name => 'node',
              swcfg21:parentNodeType => {$this_node_type},
              swcfg21:childNodeType => {$that_node_type},
            }__;
          } elsif ($this_node_type ne '#document') {
            if ($that_node_type eq '#comment') {
              __EXCEPTION{HIERARCHY_BAD_TYPE_ERR::
                MDOMX:param-name => 'node',
                swcfg21:parentNodeType => {$this_node_type},
                swcfg21:childNodeType => {$that_node_type},
              }__;
            }
          } else {
            if ($that_node_type eq '#document' or
                $that_node_type eq '#fragment') {
              __EXCEPTION{HIERARCHY_BAD_TYPE_ERR::
                MDOMX:param-name => 'node',
                swcfg21:parentNodeType => {$this_node_type},
                swcfg21:childNodeType => {$that_node_type},
              }__;
            }
          }
          unless (($self-><AG::SWCFGNode.ownerDocument> || $self) eq
              $node-><AG::SWCFGNode.ownerDocument>) {
            __EXCEPTION{EXTERNAL_NODE_ERR::
              MDOMX:param-name => 'node',
            }__;
          }
          my $this_node = $node;
          ANCESTOR: {
            if ($this_node eq $self) {
              __EXCEPTION{HIERARCHY_ANCESTOR_OR_SELF_ERR::
                MDOMX:param-name => 'node',
              }__;
            }
            redo ANCESTOR if $this_node = $this_node-><AG::SWCFGNode.parentNode>;
          }

          if ($node-><M::SWCFGNode.nodeType> eq '#fragment') {
            $self->{<Q::TreeCore:node>}
                 -><M::ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl
                                     .importTree> ($node->{<Q::TreeCore:node>});
            for my $cn (@{$node->{<Q::TreeCore:node>}->{<Q::childNodes>}}) {
              $cn->{<Q::parent>} = $self->{<Q::TreeCore:node>};
            }
            push @{$self->{<Q::TreeCore:node>}->{<Q::childNodes>}}, 
       \         @{$node->{<Q::TreeCore:node>}->{<Q::childNodes>}};
            $node->{<Q::TreeCore:node>}->{<Q::childNodes>} = [];
            $node->{<Q::TreeCore:node>}
                 -><M::ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl
                                               .orphanate>;
            $r = $self;
          } else {
            if ($node->{<Q::TreeCore:node>}->{<Q::parent>}) {
              my @pl = $node->{<Q::TreeCore:node>}->{<Q::parent>}
                                                  ->{<Q::childNodes>};
              for my $i (0..$#pl) {
                if ($pl[$i] eq $node->{<Q::TreeCore:node>}) {
                  splice @pl, $i, 1, ();
                  last;
                }
              }
            }
            $self->{<Q::TreeCore:node>}
                 -><M::ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl
                          .importTree> ($node->{<Q::TreeCore:node>});
            push @{$self->{<Q::TreeCore:node>}->{<Q::childNodes>}},
                 $node->{<Q::TreeCore:node>};
            $node->{<Q::TreeCore:node>}->{<Q::parent>}
                             = $self->{<Q::TreeCore:node>};
            $r = $node;
          }
        }

  @Method:
    @@Name:appendNewNode
    @@Description:
      @@@lang:en
      @@@@:
        Constructs a new node object and appends it to the child list 
        of this node. 
    @@TypeParam:
    @@LocalNameParam:
    @@NSURIParam:
    @@ValueParam:
    @@Return:
      @@@Type:SWCFGNode
      @@@actualType:ManakaiSWCFGNode
      @@@Description:
        @@@@lang:en
        @@@@@: The newly created node. 
      @@@RaiseException:
        @@@@@: HIERARCHY_ANCESTOR_OR_SELF_ERR
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The <P::node> is an ancestor of this node or this node itself. 
      @@@RaiseException:
        @@@@@: HIERARCHY_BAD_TYPE_ERR
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            An attempt is made to append non-element node on element or 
            document fragment node or an attempt is made to append any 
            node on comment node or document or document fragment 
            node on any node. 
      @@@RaiseException:
        @@@@@: EXTERNAL_NODE_ERR
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The <P::node> does not belong to the same document 
            as the owner of this node. 
      @@@PerlDef:
        my $this_type = $self-><AG::SWCFGNode.nodeType>;
        if ($this_type eq '#comment') {
          __EXCEPTION{HIERARCHY_BAD_TYPE_ERR::
            MDOMX:param-name => 'type',
            swcfg21:parentNodeType => {$this_type},
            swcfg21:childNodeType => {$type},
          }__;
        }
        if ($type eq '#element') {
          __DEEP{
            $r = ($self-><AG::SWCFGNode.ownerDocument> || $self)
                       -><M::SWCFGDocument.createElementNS>
                                  ($namespaceURI, $localName);
          }__;
          $r->{<Q::TreeCore:node>}->{<Q::value>} = $value
            if defined $value;
        } elsif ($type eq '#comment') {
          if ($this_type ne '#document') {
            __EXCEPTION{HIERARCHY_BAD_TYPE_ERR::
              MDOMX:param-name => 'type',
              swcfg21:parentNodeType => {$this_type},
              swcfg21:childNodeType => {$type},
            }__;
          }
          __DEEP{
            $r = ($self-><AG::SWCFGNode.ownerDocument> || $self)
                             -><M::SWCFGDocument.createComment> ($value);
          }__;
        } else {
          __EXCEPTION{HIERARCHY_BAD_TYPE_ERR::
            MDOMX:param-name => 'type',
            swcfg21:parentNodeType => {$this_type},
            swcfg21:childNodeType => {$type},
          }__;
        }
        $self->{<Q::TreeCore:node>}
             -><M::ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl
                          .importTree> ($r->{<Q::TreeCore:node>});
        push @{$self->{<Q::TreeCore:node>}->{<Q::childNodes>}},
             $r->{<Q::TreeCore:node>};
        $r->{<Q::TreeCore:node>}->{<Q::parent>} = $self->{<Q::TreeCore:node>};

  @Method:
    @@Name:appendText
    @@Description:
      @@@lang:en
      @@@@:
        Appends a string to the value of this node.  If the node value 
        is of list, the string is added as a new item.  Otherwise, 
        it is simply added at the end of the current value. 
    @@Param:
      @@@Name:text
      @@@Type:SWCFGString
      @@@Description:
        @@@@lang:en
        @@@@@:
          A text to append. 
    @@Return:
      @@@RaiseException:
        @@@@@: HIERARCHY_NO_VALUE_ERR
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            An attempt is made to set a value to document node.
      @@@PerlDef:
        my $node = $self->{<Q::TreeCore:node>};
        my $nt = $self-><AG::SWCFGNode.nodeType>;
        if ($nt eq '#document') {
          __EXCEPTION{HIERARCHY_NO_VALUE_ERR::
            MDOMX:param-name => 'text',
            swcfg21:parentNodeType => {$nt},
          }__;
        } elsif (ref ($node->{<Q::value>}) eq 'ARRAY') {
          push @{$node->{<Q::value>}}, $text;
        } elsif (defined $node->{<Q::value>}) {
          $node->{<Q::value>} .= $text;
        } else {
          __CODE{expandETBinding:: $node => $node}__;
          if (defined $node->{<Q::shadowContent>} and
              defined $node->{<Q::shadowContent>}->{<Q::value>}) {
            $node->{<Q::value>}
               = $node->{<Q::shadowContent>}->{<Q::value>} . $text;
          } else {
            $node->{<Q::value>} = $text;
          }
        }

  @Method:
    @@Name:removeChildNode
    @@Description:
      @@@lang:en
      @@@@:
        Removes a node from the child node list of this node. 
        \
        {TODO:: How this method should do for shadow tree is not 
                decided yet. 
        \
        }
    @@Param:
      @@@Name:node
      @@@Type:SWCFGNode
      @@@actualType:ManakaiSWCFGNode
      @@@Description:
        @@@@lang:en
        @@@@@:
          The node to remove.  If the <P::node> is not a child of 
          this node, no action has taken. 
    @@Return:
      @@@PerlDef:
        my $n = $node->{<Q::TreeCore:node>};
        $self->{<Q::TreeCore:node>}->{<Q::childNodes>}
           = [grep {not $_ eq $n} @{$self->{<Q::TreeCore:node>}
                                         ->{<Q::childNodes>}}];
        $node->{<Q::TreeCore:node>}
             -><M::ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl.orphanate>;
  @Method:
    @@Name:getAttribute
    @@Description:
      @@@lang:en
      @@@@:
        Returns the first child element node object whose local name matches 
        with the given name, if any. 
    @@NSVariant:.getAttributeNS
    @@Param:
      @@@Name:localName
      @@@Type:SWCFGString
      @@@Description:
        @@@@lang:en
        @@@@@:
          The local name of element to return. 
    @@MakeNewNodeParam:
    @@Return:
      @@@Type:SWCFGElement
      @@@Description:
        @@@@lang:en
        @@@@@:
          The first child element node whose local name matches to 
          <P::name>. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Type:SWCFGElement
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            There is no child element found whose name is <P::name>. 
      @@@PerlDef:
        FIND: {
          my $node = $self->{<Q::TreeCore:node>};
          __CODE{expandETBinding:: $node => $node}__;
          my @c = (@{$node->{<Q::childNodes>}},
                   ($node->{<Q::shadowContent>}
                    ? @{$node->{<Q::shadowContent>}
                             ->{<Q::childNodes>}} : ()));
          while (@c) {
            my $c = <ClassM::ManakaiSWCFGNode.getNodeReference>
                                                  (my $cn = shift @c);
            if ($c-><AG::SWCFGNode.nodeType> eq '#element' and
                $c-><AG::SWCFGNode.localName> eq $localName) {
              $r = $c;
              last FIND;
            }
            __CODE{expandETBinding:: $node => $cn}__;
            if ($cn->{<Q::shadowSibling>}) {
              push @c, @{$cn->{<Q::shadowSibling>}->{<Q::childNodes>}};
            }
          }
          ## Not found
          if ($makeNewNode) {
            __DEEP{
              $r = ($self-><AG::SWCFGNode.ownerDocument> || $self)
                        -><AG::SWCFGDocument.createElementNS> (null, $localName);
              $self-><M::SWCFGNode.appendNode> ($r);
            }__;
          }
        } # FIND

  @Method:
    @@Name:getAttributeNS
    @@Description:
      @@@lang:en
      @@@@:
        Returns the first child node whose name matches to the 
        pair of namespace URI and local name. 
    @@NewIn21:
    @@NonNSVariant:.getAttribute
    @@Param:
      @@@Name:namespaceURI
      @@@Type:SWCFGString
      @@@Description:
        @@@@lang:en
        @@@@@:
          The namespace URI of the element to get. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@: The null namespace. 
    @@Param:
      @@@Name:localName
      @@@Type:SWCFGString
      @@@Description:
        @@@@lang:en
        @@@@@:
          The local name of the element to get. 
    @@MakeNewNodeParam:
    @@Return:
      @@@Type:SWCFGElement
      @@@Description:
        @@@@lang:en
        @@@@@:
          The first child element node whose name matches to 
          <P::namespaceURI> and <P::localName>. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Type:SWCFGElement
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            There is no child element found whose name is <P::namespaceURI>
            and <P::localName> pair. 
      @@@PerlDef:
        FIND: {
          my $node = $self->{<Q::TreeCore:node>};
          __CODE{expandETBinding:: $node => $node}__;
          my @c = (@{$node->{<Q::childNodes>}},
                   ($node->{<Q::shadowContent>}
                    ? @{$node->{<Q::shadowContent>}
                             ->{<Q::childNodes>}} : ()));
          while (@c) {
            my $c = <ClassM::ManakaiSWCFGNode.getNodeReference>
                                               (my $cn = shift @c);
            if ($c-><AG::SWCFGNode.nodeType> eq '#element' and
                ((not defined $namespaceURI and 
                  not defined $c-><AG::SWCFGNode.namespaceURI>) or
                 (defined $namespaceURI and
                  defined $c-><AG::SWCFGNode.namespaceURI> and
                  $namespaceURI eq $c-><AG::SWCFGNode.namespaceURI>)) and
                $c-><AG::SWCFGNode.localName> eq $localName) {
              $r = $c;
              last FIND;
            }
            __CODE{expandETBinding:: $node => $cn}__;
            if ($cn->{<Q::shadowSibling>}) {
              push @c, @{$cn->{<Q::shadowSibling>}->{<Q::childNodes>}};
            }
          }
          ## Not found
          if ($makeNewNode) {
            __DEEP{
              $r = ($self-><AG::SWCFGNode.ownerDocument> || $self)
                        -><AG::SWCFGDocument.createElementNS>
                                 ($namespaceURI, $localName);
              $self-><M::SWCFGNode.appendNode> ($r);
            }__;
          }
        } # FIND

  @Method:
    @@Name:getAttributeValue
    @@Description:
      @@@lang:en
      @@@@:
        Returns the value of the first child element with a given 
        local name. 
    @@NSVariant:.getAttributeValueNS
    @@Param:
      @@@Name:localName
      @@@Type:SWCFGString
      @@@Description:
        @@@@lang:en
        @@@@@:
          The local name of the child element to get its value. 
    @@DefaultParam:
    @@DefaultListParam:
    @@Return:
      @@@Type:SWCFGString
      @@@Description:
        @@@@lang:en
        @@@@@:
          The value of specified child element.  It might be either 
          a simple string value, a list (array reference) value or 
          a <DOM::null> value. 
          \
          If the element value is <DOM::null> or there is no such element 
          exist and the <P::default> parameter is specified, then 
          the <P::default> value is returned.  If the element 
          value is of list and it have zero item and the <P::defaultList> 
          parameter is specified, then the <P::defaultValue> is returned. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Type:SWCFGString
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            Either if there is no such child element found, if 
            the element value is <DOM::null> or if the <P::default> 
            value is specified as <DOM::null>. 
      @@@PerlDef:
        __DEEP{
          my $node = $self-><M::SWCFGNode.getAttribute> ($localName);
          if (ref $node) {
            $r = $node-><M::SWCFGNode.value> (%opt);
            if ($defaultList and ref $r eq 'ARRAY' and @$r == 0) {
              $r = $defaultList;
            }
          } else {
            $r = $defaultList || $default;
          }
        }__;

  @Method:
    @@Name:getAttributeValueNS
    @@Description:
      @@@lang:en
      @@@@:
        Returns the value of the first child element with a given 
        local name and namespace URI pair. 
    @@NewIn21:
    @@NonNSVariant:.getAttributeValue
    @@Param:
      @@@Name:namespaceURI
      @@@Type:SWCFGString
      @@@Description:
        @@@@lang:en
        @@@@@:
          The namespace URI of the element to get. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@: The null namespace. 
    @@Param:
      @@@Name:localName
      @@@Type:SWCFGString
      @@@Description:
        @@@@lang:en
        @@@@@:
          The local name of the child element to get its value. 
    @@DefaultParam:
    @@DefaultListParam:
    @@Return:
      @@@Type:SWCFGString
      @@@Description:
        @@@@lang:en
        @@@@@:
          The value of specified child element.  It might be either 
          a simple string value, a list (array reference) value or 
          a <DOM::null> value. 
          \
          If the element value is <DOM::null> or there is no such element 
          exist and the <P::default> parameter is specified, then 
          the <P::default> value is returned.  If the element 
          value is of list and it have zero item and the <P::defaultList> 
          parameter is specified, then the <P::defaultValue> is returned. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Type:SWCFGString
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            Either if there is no such child element found, if 
            the element value is <DOM::null> or if the <P::default> 
            value is specified as <DOM::null>. 
      @@@PerlDef:
        __DEEP{
          my $node = $self-><M::SWCFGNode.getAttributeNS>
                                 ($namespaceURI, $localName);
          if (ref $node) {
            $r = $node-><M::SWCFGNode.value> (%opt);
            if ($defaultList and ref $r eq 'ARRAY' and @$r == 0) {
              $r = $defaultList;
            }
          } else {
            $r = $defaultList || $default;
          }
        }__;

  @Method:
    @@Name:getElementBy
    @@Description:
      @@@lang:en
      @@@@:
        Returns the first child element node that satisfies the 
        given condition, if any. 
    @@Param:
      @@@Name:code
      @@@Type:
        Perl:CODE
      @@@Description:
        @@@@lang:en
        @@@@@:
          An anonymous function whose arguments are a <IF::SWCFGElement> 
          node and a named parameter list (Perl hash) and
          returning a boolean value.  This method calls this 
          function to test an element node should be returned as 
          the result.  The element node to test is passed as the first 
          argument and any named parameters to this method are 
          passed to the function. 
    @@NamedParam:
      @@@Name:makeNewNode
      @@@Type:
        Perl:CODE
      @@@Description:
        @@@@lang:en
        @@@@@:
          An anonymous function whose arguments are a newly created 
          <IF::SWCFGElement> node and a named parameter list (Perl hash) 
          with no return value expected.  Any named parameters to this 
          method are passed to the function.  The function is expected 
          to modify the node of the first argument (including, but 
          not limited to, renaming its name) to match the <P::code>'s 
          condition, although it is not tested. 
    @@Return:
      @@@Type:SWCFGElement
      @@@Description:
        @@@@lang:en
        @@@@@:
          The first matching child element node. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Type:SWCFGElement
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            There is no element node with which the <P::code> returns 
            a <DOM::true> value. 
      @@@PerlDef:
        FIND: {
          my $node = $self->{<Q::TreeCore:node>};
          __CODE{expandETBinding:: $node => $node}__;
          __DEEP{
            my @c = (@{$node->{<Q::childNodes>}},
                     ($node->{<Q::shadowContent>}
                      ? @{$node->{<Q::shadowContent>}
                               ->{<Q::childNodes>}} : ()));
            while (@c) {
              my $this = <ClassM::ManakaiSWCFGNode.getNodeReference>
                              (my $t = shift @c);
              if ($t->{<Q::nodeType>} eq '#element' and
                  $code->($self, $this, %opt)) {
                $r = $this;
                last FIND;
              }
              __CODE{expandETBinding:: $node => $t}__;
              if ($t->{<Q::shadowSibling>}) {
                push @c, @{$t->{<Q::shadowSibling>}->{<Q::childNodes>}};
              }
            }
          }__;
          ## Not found
          if ($makeNewNode) {
            __DEEP{
              $r = $self-><M::SWCFGNode.appendNewNode>
                                (type => '#element',
                                 namespace_uri =>
                                     ($self-><AG::SWCFGNode.ownerDocument> ||
                                      $self)
                                          -><AG::SWCFGDocument
                                                .defaultElementTypeNamespaceURI>,
                                 local_name => 'Node');
              if (ref $makeNewNode eq 'CODE') {
                $makeNewNode->($self, $r, %opt);
              }
            }__;
          }
        } # FIND

  @Method:
    @@Name:setAttribute
    @@Description:
      @@@lang:en
      @@@@:
        Sets the value of the first child element with the given name.  If 
        it does not exist, a new element has created and the value is set 
        to it. 
        \
        {TODO:: How this method treats shadow tree is not yet decided.
        \
        }
    @@NSVariant:.setAttributeNS
    @@Param:
      @@@Name:localName
      @@@Type:SWCFGString
      @@@Description:
        @@@@lang:en
        @@@@@:
          The name of the element to set the value. 
    @@Param:
      @@@Name:value
      @@@Type:SWCFGString
      @@@Description:
        @@@@lang:en
        @@@@@: The value to set. 
    @@Return:
      @@@Type:SWCFGElement
      @@@Description:
        @@@@lang:en
        @@@@@: The element to which the value is set. 
      @@@RaiseException:
        @@@@@:BAD_VALUE_ERR
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            An attempt is made to set a value whose type is neither 
            a string, a list (array reference) or a blessed object. 
      @@@PerlDef:
        if ({qw/HASH 1 CODE 1/}->{ref ($value)}) {
          __EXCEPTION{BAD_VALUE_ERR::
            swcfg21:actualType => {ref $value},
          }__;
        }

        FIND: {
          for my $cn (@{$self->{<Q::TreeCore:node>}->{<Q::childNodes>}}) {
            my $c = <ClassM::ManakaiSWCFGNode.getNodeReference> ($cn);
            if ($c-><AG::SWCFGNode.nodeType> eq '#element' and
                $c-><AG::SWCFGNode.localName> eq $localName) {
              $r = $c;
              $r->{<Q::TreeCore:node>}->{<Q::value>} = $value;
              for my $rcn (@{$r->{<Q::TreeCore:node>}->{<Q::childNodes>}}) {
                CORE::delete $rcn->{<Q::parent>};
                $rcn-><M::ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl
                             .orphanate>;
              }
              $r->{<Q::TreeCore:node>}->{<Q::childNodes>} = [];
              last FIND;
            }
          }
          ## Not found
          __DEEP{
            $r = ($self-><AG::SWCFGNode.ownerDocument> || $self)
                      -><AG::SWCFGDocument.createElementNS> (null, $localName);
            $self-><M::SWCFGNode.appendNode> ($r);
            $r->{<Q::TreeCore:node>}->{<Q::value>} = $value;
          }__;
        } # FIND

  @Method:
    @@Name:setAttributeNS
    @@Description:
      @@@lang:en
      @@@@:
        Sets the value of the first child element with the given name.  If 
        it does not exist, a new element has created and the value is set 
        to it. 
        \
        {TODO:: How this method treats shadow tree is not yet decided.
        \
        }
    @@NonNSVariant:.setAttribute
    @@NewIn21:
    @@Param:
      @@@Name:namespaceURI
      @@@Type:SWCFGString
      @@@Description:
        @@@@lang:en
        @@@@@:
          The namespace URI of the element to set the value. 
    @@Param:
      @@@Name:localName
      @@@Type:SWCFGString
      @@@Description:
        @@@@lang:en
        @@@@@:
          The name of the element to set the value. 
    @@Param:
      @@@Name:value
      @@@Type:SWCFGString
      @@@Description:
        @@@@lang:en
        @@@@@: The value to set. 
    @@Return:
      @@@Type:SWCFGElement
      @@@Description:
        @@@@lang:en
        @@@@@: The element to which the value is set. 
      @@@RaiseException:
        @@@@@:BAD_VALUE_ERR
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            An attempt is made to set a value whose type is neither 
            a string, a list (array reference) or a blessed object. 
      @@@PerlDef:
        if ({qw/HASH 1 CODE 1/}->{ref ($value)}) {
          __EXCEPTION{BAD_VALUE_ERR::
            swcfg21:actualType => {ref $value},
          }__;
        }

        FIND: {
          for my $cn (@{$self->{<Q::TreeCore:node>}->{<Q::childNodes>}}) {
            my $c = <ClassM::ManakaiSWCFGNode.getNodeReference> ($cn);
            my $cnsuri = $c-><AG::SWCFGNode.namespaceURI>;
            if ($c-><AG::SWCFGNode.nodeType> eq '#element' and
                ((not defined $namespaceURI and 
                  not defined $cnsuri) or
                 (defined $namespaceURI and defined $cnsuri and
                  $namespaceURI eq $cnsuri)) and
                $cn-><AG::SWCFGNode.localName> eq $localName) {
              $r = $c;
              $r->{<Q::TreeCore:node>}->{<Q::value>} = $value;
              for my $rcn (@{$r->{<Q::TreeCore:node>}->{<Q::childNodes>}}) {
                CORE::delete $rcn->{<Q::parent>};
                $rcn-><M::ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl
                             .orphanate>;
              }
              $r->{<Q::TreeCore:node>}->{<Q::childNodes>} = [];
              last FIND;
            }
          }
          ## Not found
          __DEEP{
            $r = ($self-><AG::SWCFGNode.ownerDocument> || $self)
                      -><AG::SWCFGDocument.createElementNS>
                                        ($namespaceURI, $localName);
            $self-><M::SWCFGNode.appendNode> ($r);
            $r->{<Q::TreeCore:node>}->{<Q::value>} = $value;
          }__;
        } # FIND

  @Method:
    @@Name: removeAttribute
    @@Description:
      @@@lang:en
      @@@@:
        Removes all child elements with the given name. 
        \
        {TODO:: How this method treats shadow tree is not yet decided.
        \
        }
    @@NSVariant:.removeAttributeNS
    @@Param:
      @@@Name:localName
      @@@Type:SWCFGString
      @@@Description:
        @@@@lang:en
        @@@@@:
          The local name of the element to remove.
    @@Return:
      @@@Type:
        DOMMain:boolean
      @@@Description:
        @@@@lang:en
        @@@@@:
          Always returns <DOM::true>. 
      @@@PerlDef:
        my @removed;
        $self->{<Q::TreeCore:node>}->{<Q::childNodes>} = [grep {
          my $c = <ClassM::ManakaiSWCFGNode.getNodeReference> ($_);
          if ($c-><AG::SWCFGNode.nodeType> eq '#element' and
              $c-><AG::SWCFGNode.localName> eq $localName) {
            push @removed, $_;
            CORE::delete $_->{<Q::parent>};
            false;
          } else {
            true;
          }
        } @{$self->{<Q::TreeCore:node>}->{<Q::childNodes>}}];
        for my $n (@removed) {
          $n-><M::ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl
                          .orphanate>;
        }
        true;

  @Method:
    @@Name: removeAttributeNS
    @@Description:
      @@@lang:en
      @@@@:
        Removes all child elements with the given name. 
        \
        {TODO:: How this method treats shadow tree is not yet decided.
        \
        }
    @@NonNSVariant:.removeAttribute
    @@NewIn21:
    @@Param:
      @@@Name:namespaceURI
      @@@Type:SWCFGString
      @@@Description:
        @@@@lang:en
        @@@@@:
          The namespace URI of the element to remove. 
    @@Param:
      @@@Name:localName
      @@@Type:SWCFGString
      @@@Description:
        @@@@lang:en
        @@@@@:
          The local name of the element to remove.
    @@Return:
      @@@Type:
        DOMMain:boolean
      @@@Description:
        @@@@lang:en
        @@@@@:
          Always returns <DOM::true>. 
      @@@PerlDef:
        my @removed;
        $self->{<Q::TreeCore:node>}->{<Q::childNodes>} = [grep {
          my $c = <ClassM::ManakaiSWCFGNode.getNodeReference> ($_);
          my $cnsuri = $c-><AG::SWCFGNode.namespaceURI>;
          if ($c-><AG::SWCFGNode.nodeType> eq '#element' and
              ((not defined $namespaceURI and not defined $cnsuri) or
               (defined $namespaceURI and defined $cnsuri and
                $namespaceURI eq $cnsuri)) and
              $c-><AG::SWCFGNode.localName> eq $localName) {
            push @removed, $_;
            CORE::delete $_->{<Q::parent>};
            false;
          } else {
            true;
          }
        } @{$self->{<Q::TreeCore:node>}->{<Q::childNodes>}}];
        for my $n (@removed) {
          $n-><M::ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl
                          .orphanate>;
        }
        true;

  @Attr:
    @@Name:childNodes
    @@Type:SWCFGChildNodeList
    @@actualType:ManakaiSWCFGChildNodeList
    @@Description:
      @@@lang:en
      @@@@:
        The list of child nodes, including nodes from shadow trees. 
        If the type of the node is 
        <CODE::#comment>, the list is always empty. 
    @@Get:
      @@@PerlDef:
        $r = $self->{<Q::TreeCore:node>}
                  -><M::ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl
                            .newReference>
                        (<ClassName::ManakaiSWCFGChildNodeList>);

  @Attr:
    @@Name:localName
    @@Description:
      @@@lang:en
      @@@@:
        The local name of the node.  
    @@Type:SWCFGString
    @@Get:
      @@@disDef:
        @@@@DISLang:nop:
      @@@Description:
        @@@@lang:en
        @@@@@:
          The local name of the node. 
      @@@Type:SWCFGString
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Type:SWCFGString
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The node does not have the local name. 
            No node of type other than <CODE::#element> has the local name. 
    @@Set:
      @@@disDef:
        @@@@DISLang:nop:
      @@@Description:
        @@@@lang:en
        @@@@@:
          Sets the local name.  Setting the local name to the node 
          whose type is other than <CODE::#element> has no effect. 

  @Attr:
    @@Name:namespaceURI
    @@NewIn21:
    @@Description:
      @@@lang:en
      @@@@:
        The namespace URI of the node. 
    @@Type:SWCFGString
    @@Get:
      @@@disDef:
        @@@@DISLang:nop:
      @@@Type:SWCFGString
      @@@Description:
        @@@@lang:en
        @@@@@:
          The namespace URI of the node. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Type:SWCFGString
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The node does not have the namespace URI. 
            No node of type other than <CODE::#element> has the local name. 
    @@Set:
      @@@disDef:
        @@@@DISLang:nop:
      @@@Description:
        @@@@lang:en
        @@@@@:
          Sets the namespace URI.  Setting the local name to the node 
          whose type is other than <CODE::#element> has no effect. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Type:SWCFGString
        @@@@Description:
          @@@@@lang:en
          @@@@@@: 
            Sets the node not to have its namespace URI (or sets 
            the namespace as the <QUOTE::<DOM::null> namespace>. 

  @Attr:
    @@Name:nodeType
    @@Type:SWCFGString
    @@Description:
      @@@lang:en
      @@@@:
        The type of the node. 
    @@Get:
      @@@Type:SWCFGString
      @@@disDef:
        @@@@ConstValue:\#element
      @@@InCase:
        @@@@Value:\#comment
        @@@@Type:SWCFGString
        @@@@Description:
          @@@@@lang:en
          @@@@@@:This node is a comment node. 
      @@@InCase:
        @@@@Value:\#document
        @@@@Type:SWCFGString
        @@@@Description:
          @@@@@lang:en
          @@@@@@:This node is a document node. 
      @@@InCase:
        @@@@Value:\#element
        @@@@Type:SWCFGString
        @@@@Description:
          @@@@@lang:en
          @@@@@@:This node is an element node. 
      @@@InCase:
        @@@@Value:\#fragment
        @@@@Type:SWCFGString
        @@@@Description:
          @@@@@lang:en
          @@@@@@:This node is a document fragment node. 

  @Attr:
    @@Name:parentNode
    @@Type:SWCFGNode
    @@Description:
      @@@lang:en
      @@@@:
        The parent node of this node, if any. 
    @@ModIn21:
    @@Get:
      @@@Description:
        @@@@lang:en
        @@@@@:The parent node. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Type:SWCFGNode
        @@@@Description:
          @@@@@lang:en
          @@@@@@:This node has no parent node. 
      @@@PerlDef:
        $r = $self->{<Q::TreeCore:node>}->{<Q::parent>};
        if ($r) {
          if ($r->{<Q::shadowParent>}) {
            $r = $r->{<Q::shadowParent>};
          } elsif ($r->{<Q::shadowSiblingOf>}) {
            $r = $r->{<Q::shadowSiblingOf>}->{<Q::parent>};
          }
        }
        $r = <ClassM::ManakaiSWCFGNode.getNodeReference> ($r) if $r;

  @Attr:
    @@Name:realParentNode
    @@Type:SWCFGNode
    @@Description:
      @@@lang:en
      @@@@:
        The parent node of this node, if any. 
    @@NewIn21:
    @@Get:
      @@@disDef:
        @@@@swcfg21:GetPropNode:parent
      @@@Description:
        @@@@lang:en
        @@@@@:The parent node. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Type:SWCFGNode
        @@@@Description:
          @@@@@lang:en
          @@@@@@:This node has no parent node. 

  @Attr:
    @@Name:count
    @@Type:
      DOMMain:unsigned-long
    @@Description:
      @@@lang:en
      @@@@:
        The number of children of this node, includeing 
        child nodes in shadow trees.  If this node has 
        the value, it is also counted as a <QUOTE::child>. 
    @@ModIn21:
    @@Get:
      @@@PerlDef:
        my $node = $self->{<Q::TreeCore:node>};
        $r = (defined $node->{<Q::value>} ? 1 : 0)
           + @{$node->{<Q::childNodes>}};
        __CODE{expandETBinding:: $node => $node}__;
        if ($node->{<Q::shadowContent>}) {
          $r++ if not defined $node->{<Q::value>} and
                  defined $node->{<Q::shadowContent>}->{<Q::value>};
          $r += @{$node->{<Q::shadowContent>}->{<Q::childNodes>}};
        }
        for my $cc (@{$node->{<Q::childNodes>}}) {
          __CODE{expandETBinding:: $node => $cc}__;
          $r += @{$cc->{<Q::shadowSibling>}->{<Q::childNodes>}}
             if $cc->{<Q::shadowSibling>};
        }

  @Attr:
    @@Name:realCount
    @@Type:
      DOMMain:unsigned-long
    @@Description:
      @@@lang:en
      @@@@:
        The number of children of this node.  If this node has 
        the value, it is also counted as a <QUOTE::child>. 
    @@NewIn21:
    @@Get:
      @@@PerlDef:
        $r = (defined $self->{<Q::TreeCore:node>}->{<Q::value>} ? 1 : 0)
           + @{$self->{<Q::TreeCore:node>}->{<Q::childNodes>}};

  @Method:
    @@Name:innerText
    @@Description:
      @@@lang:en
      @@@@:
        Returns the text value of this node. 
    @@ModIn21:
    @@NamedParam:
      @@@Name:newValue
      @@@Type:
        DOMMain:any
      @@@Description:
        @@@@lang:en
        @@@@@:
          The new node value.  If <P::newValue> is specified, 
          the node value is changed before returning the value. 
          Sets a value to document or document fragment node has no effect. 
    @@Return:
      @@@Type:SWCFGString
      @@@Description:
        @@@@lang:en
        @@@@@:
          The value of this node.  If the value is of list, 
          values are separeted by a <CHAR::LINE FEED> character. 
          Note that the last item of the list will <EM::not> 
          suffixed by a <CHAR::LINE FEED>. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Type:SWCFGString
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The node has no value. 
      @@@PerlDef:
        my $node = $self->{<Q::TreeCore:node>};
        if (defined $newValue) {
          $node->{<Q::value>} = $newValue;
        }
        my $v;
        if (defined $node->{<Q::value>}) {
          $v = $node->{<Q::value>};
        } else {
          __CODE{expandETBinding:: $node => $node}__;
          $v = defined $node->{<Q::shadowContent>}
                     ? $node->{<Q::shadowContent>}->{<Q::value>} : null;
        }
        $r = ref $v eq 'ARRAY' ? join "\x0A", @$v : $v;

  @Method:
    @@Name:actualInnerText
    @@Description:
      @@@lang:en
      @@@@:
        Returns the text value of this node. 
    @@NewIn21:
    @@NamedParam:
      @@@Name:newValue
      @@@Type:
        DOMMain:any
      @@@Description:
        @@@@lang:en
        @@@@@:
          The new node value.  If <P::newValue> is specified, 
          the node value is changed before returning the value. 
          Sets a value to document or document fragment node has no effect. 
    @@Return:
      @@@Type:SWCFGString
      @@@Description:
        @@@@lang:en
        @@@@@:
          The value of this node.  If the value is of list, 
          values are separeted by a <CHAR::LINE FEED> character. 
          Note that the last item of the list will <EM::not> 
          suffixed by a <CHAR::LINE FEED>. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Type:SWCFGString
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The node has no value. 
      @@@PerlDef:
        my $node = $self->{<Q::TreeCore:node>};
        if (defined $newValue) {
          $node->{<Q::value>} = $newValue;
        }
        my $v;
        if (defined $node->{<Q::value>}) {
          $v = $node->{<Q::value>};
        }
        $r = ref $v eq 'ARRAY' ? join "\x0A", @$v : $v;

  @Method:
    @@Name:value
    @@Description:
      @@@lang:en
      @@@@:
        Returns the value of this node. 
    @@ModIn21:
    @@NamedParam:
      @@@Name:asArray
      @@@Type:
        DOMMain:boolean
      @@@Description:
        @@@@lang:en
        @@@@@:
          Whether the value should be returned as an array reference 
          even if the node value is a simple string. 
      @@@InCase:
        @@@@Value:true
        @@@@Type:
          DOMMain:boolean
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The node value is always returned as an array reference. 
      @@@InCase:
        @@@@Value:false
        @@@@Type:
          DOMMain:boolean
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The node value is returned as an array reference if and 
            only if the node value is a list value. 
    @@Return:
      @@@Type:
        DOMMain:any
      @@@Description:
        @@@@lang:en
        @@@@@:
          The node value. If the <P::asArray> value is <DOM::false>, 
          the current node value is returned as is.  If the <P::asArray> 
          value is <DOM::true> and the node value is a simple string, 
          then an array reference containing the value as an only item 
          is returned.  If <P::true> and the node value is not defined, 
          then an empty array reference is returned. 
      @@@PerlDef:
        my $node = $self->{<Q::TreeCore:node>};
        my $v;
        if (defined $node->{<Q::value>}) {
          $v = $node->{<Q::value>};
        } else {
          __CODE{expandETBinding:: $node => $node}__;
          $v = defined $node->{<Q::shadowContent>}
                     ? $node->{<Q::shadowContent>}->{<Q::value>} : null;
        }
        if ($asArray and ref $v ne 'ARRAY') {
          $r = defined $v ? [$v] : [];
        } else {
          $r = $v;
        }

  @Method:
    @@Operator:
      @@@ContentType:
        dis:TypeQName
      @@@@:
        DISPerl:AsStringMethod
    @@Description:
      @@@lang:en
      @@@@:
        The string representation of the node, i.e. the serialized 
        text form of a SuikaWikiConfig/2.0 document or document fragment. 
        \
        {NOTE:: If a namespace URI in any node in the subtree rooted 
                by this node does not have its corresponding namespace 
                prefix, then this method assigns a prefix to that URI. 
        \
        }
        \
        {NOTE:: This method results in a ill-formed SuikaWikiConfig 
                document (fragment) if any node has unserializable 
                property, e.g. a value starts with <CODE::?SuikaWikiConfig> 
                on the comment node. 
        \
        }
    @@ModIn21:
    @@NamedParam:
      @@@Name:outputHeader
      @@@Type:
        DOMMain:boolean
      @@@Description:
        @@@@lang:en
        @@@@@:
          Whether the magic identifier (the signature header) should 
          be prefixed or not, if this node is the document node. 
    @@Return:
      @@@Type:SWCFGString
      @@@PerlDef:
        my $nt = $self-><AG::SWCFGNode.nodeType>;
        my $node = $self->{<Q::TreeCore:node>};
        if ($nt eq '#element') {
          $r = $self-><M::SWCFGNode.actualInnerText>;
          if (scalar @{$node->{<Q::childNodes>}}) {
            if (defined $r) {
              $r =~ s/(^|\x0A)(?=([\\\@\#\s]|$))?/$1."  ".
                                                  (defined $2?"\\":"")/ges;
              $r = $self-><AG::SWCFGElement.realQualifiedName>
                 . ":\x0A  \@\@"
                 . (ref ($node->{<Q::value>}) eq 'ARRAY' ? '[list]' : '')
                 . ":" . ((($r !~ /[\x0D\x0A:]/) and (length ($r) < 50))
                          ? '' : "\x0A")
                 . (length $r ? $r : '\\') . "\x0A";
            } else {
              $r = $self-><AG::SWCFGElement.realQualifiedName>
                 . ":\x0A";
            }
            for my $cn (@{$node->{<Q::childNodes>}}) {
              next unless $cn->{<Q::nodeType>} eq '#element';
              my $rc = <ClassM::ManakaiSWCFGNode.getNodeReference> ($cn)
                         ->stringify;
              $rc =~ s/\x0A  /\x0A     /gs;
              $rc =~ s/(\x0A +\@)/$1\@/gs;
              $r .= '  @' . $rc;
            }
          } else {
            $r = '' unless defined $r;
            $r =~ s/(^|\x0A)(?=([\\\@\#\s]|$))?/$1."  ".(defined $2?"\\":"")/ges;
            $r = $self-><AG::SWCFGElement.realQualifiedName>
               . (ref ($node->{<Q::value>}) eq 'ARRAY' ? '[list]' : '')
               . ":" . ((($r !~ /[\x0D\x0A:]/) and (length ($r) < 50))
                        ? '' : "\x0A")
               . (length $r ? $r : '\\') . "\x0A";
          }
          $r = "\\" . $r if substr ($r, 0, 1) =~ /[\\\@\#\s]/;
        } elsif ($nt eq '#document') {
          if ($outputHeader) {
            $r = '#?SuikaWikiConfig/' . $node->{<Q::version>} . "\n";
          }
          
          for my $cn (@{$node->{<Q::childNodes>}}) {
            $r .= "\x0A";
            $r .= <ClassM::ManakaiSWCFGNode.getNodeReference> ($cn)->stringify;
          }

          ## Element Type Binding
          my $eb = '';
          for my $bk (sort keys %{$self->{<Q::TreeCore:node>}
                                       ->{<Q::etBinding>}}) {
            my $b = $self->{<Q::TreeCore:node>}->{<Q::etBinding>}->{$bk};
            next unless $b;
            $eb .= "\x0A" . 'ElementTypeBinding:' . "\x0A"
                          . '  @Name:' . "\x0A"
                          . '    ' . $b->{elementType} . "\x0A"
                          . '  @ElementType:' . "\x0A"
                          . '    ';
            if ($b->{namespaceExpanded}) {
              $eb .= $self-><M::SWCFGNode.lookupNamespacePrefix>
                            ($b->{shadowNamespaceURI}, make_new_binding => true);
              $eb .= $b->{shadowLocalName};
            } else {
              ## NOTE: If namespace binding has changed, 
              ##       associated namespace URI might change. 
              $eb .= $b->{shadowLocalName};
            }
            $eb .= "\x0A";
            for my $p (qw/shadowContent shadowSibling/) {
              next unless $b->{$p};
              $eb .= '  @' . ucfirst ($p) . ":\x0A";
              my $rc = <ClassM::ManakaiSWCFGNode.getNodeReference> ($b->{$p});
              my $ebc = $rc->stringify;
              $ebc =~ s/\x0A  /\x0A       /gs;
              $ebc =~ s/(\x0A +\@)/$1\@\@/gs;
              $ebc =~ s/\x0A(?=\S)/\x0A    \@\@/gs;
              $eb .= '    @@' . $ebc;
              $ebc = $rc-><M::SWCFGNode.innerText>;
              if (defined $ebc) {
                $ebc =~ s/(^|\x0A)(?=([\\\@\#\s]|$))?/$1.'      '.
                                                  (defined $2?"\\":"")/ges;
                $eb .= '    @@@'
                    . (ref ($b->{$p}->{<Q::value>}) eq 'ARRAY' ? '[list]' : '')
                    . ":" . ((($ebc !~ /[\x0D\x0A:]/) and (length ($ebc) < 50))
                             ? '' : "\x0A")
                    . (length $ebc ? $ebc : '\\') . "\x0A";
              }
            }
          } # <Q::etBinding>
          $r .= $eb;

          ## Namespace bindings
          my $ns = '';
          for my $pfx (sort keys %{$self->{<Q::TreeCore:node>}
                                        ->{<Q::nsBinding>}}) {
            if ($pfx ne 'URI') {
              $ns .= '  @' . $pfx . ':' . "\x0A"
                  .  '    ';
              my $uri = $self->{<Q::TreeCore:node>}->{<Q::nsBinding>}->{$pfx};
              if (defined $uri) {
                if (length $uri) {
                  if ($uri =~ /^[\\#\s\@]/) {
                    $ns .= '\\' . $uri . "\x0A";
                  } else {
                    $ns .= $uri . "\x0A";
                  }
                } else {
                  $ns .= "\\\x0A";
                }
              } else {
                $ns .= '@@is-null: 1' . "\x0A";
              }
            }
          }
          $r .= "\x0A" . 'Namespace:' . "\x0A" . $ns . "\x0A" if length $ns;
        } elsif ($nt eq '#comment') {
          $r = $self-><AG::SWCFGNode.innerText>;
          $r =~ s/\x0A/\x0A#/gs;
          $r = '#' . $r . "\n";
        } elsif ($nt eq '#fragment') {
          for my $cn (@{$node->{<Q::childNodes>}}) {
            $r .= <ClassM::ManakaiSWCFGNode.getNodeReference> ($cn)->stringify;
          }
        } else {
          __ASSERT{DISPerl:invariant::
            msg => {qq[Node type: "$nt"]},
          }__;
        }

  @Attr:
    @@Name:rootNode
    @@Description:
      @@@lang:en
      @@@@:
        The root node of the tree to which this node belongs. 
        If this node is part of a shadow master tree, the root node 
        of the main tree. 
    @@Get:
      @@@Type:SWCFGNode
      @@@PerlDef:
        $r = $self->{<Q::TreeCore:node>};
        {
          if ($r->{<Q::parent>}) {
            $r = $r->{<Q::parent>};
            redo;
          } elsif ($r->{<Q::shadowParent>}) {
            $r = $r->{<Q::shadowParent>};
            redo;
          } elsif ($r->{<Q::shadowSiblingOf>}) {
            $r = $r->{<Q::shadowSiblingOf>};
            redo;
          } elsif ($r->{<Q::isShadowMaster>}) {
            $r = $r->{<Q::DOMCore:ownerDocument>};
          }
        }
        $r = <ClassM::ManakaiSWCFGNode.getNodeReference> ($r);

  @Method:
    @@Name:nodePath
    @@Description:
      @@@lang:en
      @@@@:
        Returns a string representing the position of this node 
        in the document tree. 
        \
        {NOTE:: The position is represented in the informal 
                XPath-like expression.  In the current implementation, 
                it does not conform to XPath nor is able to 
                identify the node uniquely.  
        \
        }
    @@NamedParam:
      @@@Name:key
      @@@Type:
        DOMMain:any
      @@@Description:
        @@@@lang:en
        @@@@@:
          Either an attribute name or a reference to an array 
          containing attribute names.  Attribute names are 
          used as <QUOTE::keys> to identify a node. 
    @@Return:
      @@@Type:SWCFGString
      @@@Description:
        @@@@lang:en
        @@@@@:
          Node path string. 
      @@@PerlDef:
        my $parent = $self-><M::SWCFGNode.parentNode>;
        if ($parent) {
          $r = $parent-><M::SWCFGNode.nodePath> (%opt);
        } else {
          $r = '';
        }
        my $node_type = $self-><M::SWCFGNode.nodeType>;
        if ($node_type eq '#element') {
          $r .= '/' . $self-><AG::SWCFGElement.realQualifiedName>;
          if ($key) {
            for my $k (ref $key eq 'ARRAY' ? @{$key} : $key) {
              my $key_val = $self-><M::SWCFGNode.getAttributeValue> ($k);
              if (defined $key_val) {
                $r .= '[@' . $k . '=' . $key_val . ']';
              }
            }
          }
        } elsif ($node_type eq '#comment') {
          $r .= q</comment ()>;
        } elsif ($node_type eq '#document') {
          $r .= q</document (>
             .  ($self-><M::SWCFGNode.flag> (<Q::swcfg21:fileName>) || '')
             .  q<)>;
        } elsif ($node_type eq '#fragment') {
          $r .= q</fragment ()>;
        } else {
          __ASSERT{DISPerl:invariant::
            msg => {qq<Node path = "$r" ... Oops! Node type: "$node_type">},
          }__;
        }

  @Method:
    @@Name:flag
    @@Description:
      @@@lang:en
      @@@@:
        Gets or sets an application data associated with this node. 
        \
        {NOTE:: The SuikaWikiConfig/2.1 object implementation 
                does not use <QUOTE::flags> to decide what to do. 
                Applications are free to use this space. 
        \
        }
    @@Param:
      @@@Name:name
      @@@Type:SWCFGString
      @@@Description:
        @@@@lang:en
        @@@@@:
          The name of flag to get or set its value. 
          \
          {NOTE:: Applications are advised to use a URI reference 
                  <SRC::RFC 3986> for flag names to avoid name confliction. 
          \
          }
    @@Param:
      @@@Name:value
      @@@Type:
        DOMMain:any
      @@@Description:
        @@@@lang:en
        @@@@@:
          Any data to associate with this node. 
          \
          {NOTE:: Associating a node belonging to the same tree as 
                  this node might lead memory leak because of its 
                  reference loop. 
          \
          }
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Type:
          DOMMain:any
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The current flag value is left unchanged. 
            \
            {NOTE:: There is no way to remove a flag entirely. 
            \
            }
    @@DefaultParam:
    @@Return:
      @@@Type:
        DOMMain:any
      @@@Description:
        @@@@lang:en
        @@@@@:
          The (possibly new) value associated with the flag of <P::name>. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Type:
          DOMMain:any
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            No value is associated with the flag and no default value provided. 
      @@@PerlDef:
        if (defined $value) {
          $r = $self->{<Q::TreeCore:node>}->{<Q::flag>}->{$name} = $value;
        } else {
          $r = defined $self->{<Q::TreeCore:node>}->{<Q::flag>}->{$name}
                  ? $self->{<Q::TreeCore:node>}->{<Q::flag>}->{$name} : $default;
        }

  @Method:
    @@Name:option
    @@Description:
      @@@lang:en
      @@@@:
        Gets or sets a named option to this node. 
        \
        {NOTE:: Currently no options has defined. 
        \
        }
    @@Param:
      @@@Name:name
      @@@Type:SWCFGString
      @@@Description:
        @@@@lang:en
        @@@@@: The option name. 
    @@Param:
      @@@Name:value
      @@@Type:
        DOMMain:any
      @@@Description:
        @@@@lang:en
        @@@@@:The option value to set. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Type:
          DOMMain:any
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The option value is left unchanged. 
            \
            {NOTE:: There is no way to remove an option value.  
            \
            }
    @@Return:
      @@@Type:
        DOMMain:any
      @@@Description:
        @@@@lang:en
        @@@@@:The (possibly new) value of the option. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Type:
          DOMMain:any
        @@@@Description:
          @@@@@lang:en
          @@@@@@:No value has set to the option. 
      @@@PerlDef:
        if (defined $value) {
          $self->{<Q::TreeCore:node>}->{<Q::option>}->{$name} = $value;
        }
        $r = $self->{<Q::TreeCore:node>}->{<Q::option>}->{$name};

  @Method:
    @@Operator:
      @@@ContentType:
        dis:TypeQName
      @@@@:
        DISPerl:CloneMethod
    @@Description:
      @@@lang:en
      @@@@:
        Makes a copy of this node.  All child nodes are cloned and 
        all flags and options are copied (rather than cloned).  
        The new node does not have any parent.  
    @@ModIn21:
    @@Return:
      @@@Type:SWCFGNode
      @@@Description:
        @@@@lang:en
        @@@@@: 
          The cloned node.
          \
          If this node is a document node, then the another document is made.  
      @@@PerlDef:
        __DEEP{
          my $od = $self-><AG::SWCFGNode.ownerDocument> || $self;
          my $nt = $self-><AG::SWCFGNode.nodeType>;
          if ($nt eq '#element') {
            $r = $od-><M::SWCFGDocument.createElementNS>
                            ($self-><AG::SWCFGNode.namespaceURI>,
                             $self-><AG::SWCFGNode.localName>);
            for my $p (<Q::shadowLocalName>, <Q::shadowNamespaceURI>) {
              $r->{<Q::TreeCore:node>}->{$p} = $self->{<Q::TreeCore:node>}->{$p};
            }
            $r->{<Q::TreeCore:node>}->{<Q::value>}
                = defined $self->{<Q::TreeCore:node>}->{<Q::value>}
                  ? ref $self->{<Q::TreeCore:node>}->{<Q::value>} eq 'ARRAY'
                  ? [@{$self->{<Q::TreeCore:node>}->{<Q::value>}}]
                  : $self->{<Q::TreeCore:node>}->{<Q::value>} : null;
            for my $p (<Q::shadowContent>, <Q::shadowSibling>) {
              if ($self->{<Q::TreeCore:node>}->{$p}) {
                my $c = <ClassM::ManakaiSWCFGNode.getNodeReference>
                           ($self->{<Q::TreeCore:node>}->{$p})->clone;
                $r->{<Q::TreeCore:node>}->{$p} = $c->{<Q::TreeCore:node>};
                $r->{<Q::TreeCore:node>}
                  -><M::ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl
                          .importTree>
                           ($r->{<Q::TreeCore:node>}->{$p});
                $r->{<Q::TreeCore:node>}->{$p}
                  ->{{
                        <Q::shadowContent> => <Q::shadowParent>,
                        <Q::shadowSibling> => <Q::shadowSiblingOf>,
                     }->{$p}} = $r->{<Q::TreeCore:node>};
              }
            }
            for my $cn (@{$self->{<Q::TreeCore:node>}->{<Q::childNodes>}}) {
              my $c = <ClassM::ManakaiSWCFGNode.getNodeReference> ($cn);
              $r-><AG::SWCFGNode.appendNode> ($c->clone);
            }
          } elsif ($nt eq '#comment') {
            $r = $od-><M::SWCFGDocument.createComment>
                            ($self->{<Q::TreeCore:node>}->{<Q::value>});
          } elsif ($nt eq '#fragment') {
            $r = $od-><M::SWCFGDocument.createDocumentFragment>;
            ## <Q::isShadowMaster> property is not copied
            for my $cn (@{$self->{<Q::TreeCore:node>}->{<Q::childNodes>}}) {
              my $c = <ClassM::ManakaiSWCFGNode.getNodeReference> ($cn);
              $r-><AG::SWCFGNode.appendNode> ($c->clone);
            }
            $r->{<Q::TreeCore:node>}->{<Q::value>}
                = defined $self->{<Q::TreeCore:node>}->{<Q::value>}
                  ? ref $self->{<Q::TreeCore:node>}->{<Q::value>} eq 'ARRAY'
                  ? [@{$self->{<Q::TreeCore:node>}->{<Q::value>}}]
                  : $self->{<Q::TreeCore:node>}->{<Q::value>} : null;
          } elsif ($nt eq '#document') {
            $r = $od-><AG::SWCFGDocument.implementation>
                    -><M::SWCFGImplementation.createSWCFGDocument>;
            $r->{<Q::TreeCore:node>}->{<Q::nsBinding>}
               = {%{$self->{<Q::TreeCore:node>}->{<Q::nsBinding>}}};
            for my $bk (keys %{$self->{<Q::TreeCore:node>}->{<Q::etBinding>}}) {
              my $b = $self->{<Q::TreeCore:node>}->{<Q::etBinding>}->{$bk};
              next unless $b;
              my $c = $r->{<Q::TreeCore:node>}->{<Q::etBinding>}->{$bk} = {
                elementType => $b->{elementType},
                shadowLocalName => $b->{shadowLocalName},
                shadowNamespaceURI => $b->{shadowNamespaceURI},
                namespaceExpanded => $b->{namespaceExpanded},
              };
              for my $p (qw/shadowContent shadowSibling/) {
                if ($b->{$p}) {
                  my $cl = <ClassM::ManakaiSWCFGNode.getNodeReference>
                                 ($b->{$p})->clone;
                  $c->{$p} = $cl->{<Q::TreeCore:node>};
                  $r->{<Q::TreeCore:node>}
                    -><M::ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl
                          .importTree> ($c->{$p});
                  my @l = $c->{$p};
                  while (@l) {
                    my $l = shift @l; next unless $l;
                    $l->{<Q::DOMCore:ownerDocument>} = $r->{<Q::TreeCore:node>};
                    for my $n (@{$l->{<Q::childNodes>}}, 
                               $l->{<Q::shadowContent>},   ## Does not allowed
                               $l->{<Q::shadowSibling>}) { ## but for safe
                      push @l, $n;
                    }
                  }
                  $c->{$p}->{<Q::isShadowMaster>} = true;
                }
              }
            }
            for my $cn (@{$self->{<Q::TreeCore:node>}->{<Q::childNodes>}}) {
              my $c = <ClassM::ManakaiSWCFGNode.getNodeReference> ($cn)->clone;
              $r->{<Q::TreeCore:node>}
                -><M::ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl
                          .importTree> ($c->{<Q::TreeCore:node>});
              my @l = $c->{<Q::TreeCore:node>};
              while (@l) {
                my $l = shift @l; next unless $l;
                $l->{<Q::DOMCore:ownerDocument>} = $r->{<Q::TreeCore:node>};
                for my $n (@{$l->{<Q::childNodes>}}, 
                           $l->{<Q::shadowContent>},
                           $l->{<Q::shadowSibling>}) {
                  push @l, $n;
                }
              }
              $r-><AG::SWCFGNode.appendNode> ($c);
            }
          } else {
            __ASSERT{DISPerl:invariant::
              msg => {qq[Node type: "$nt"]},
            }__;
          }
        }__;
        $r->{<Q::TreeCore:node>}->{<Q::flag>}
                           = {%{$self->{<Q::TreeCore:node>}->{<Q::flag>}||{}}};
        $r->{<Q::TreeCore:node>}->{<Q::option>}
                           = {%{$self->{<Q::TreeCore:node>}->{<Q::option>}||{}}};

  @Attr:
    @@Name:ownerDocument
    @@NewIn21:
    @@Description:
      @@@lang:en
      @@@@:
        The document object associated with this node. 
    @@Get:
      @@@Type:SWCFGDocument
      @@@Description:
        @@@@lang:en
        @@@@@:
          The document object associated with this node. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Type:SWCFGDocument
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            This node is a document node. 
      @@@disDef:
        @@@@swcfg21:GetPropNode:
          DOMCore:ownerDocument

  @Method:
    @@Name:lookupNamespacePrefix
    @@Description:
      @@@lang:en
      @@@@:
        Looks up the namespace prefix associated to the given 
        namespace URI.  The default namespaces are ignored. 
    @@NewIn21:
    @@Param:
      @@@Name:namespaceURI
      @@@Type:SWCFGString
      @@@Description:
        @@@@lang:en
        @@@@@:
          The namespace URI to look for. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The <DOM::null> namespace. 
    @@NamedParam:
      @@@Name: makeNewBinding
      @@@Type: 
        DOMMain:boolean
      @@@Description:
        @@@@lang:en
        @@@@@:
          Whether a new namespace prefix should be bound when 
          no namespace URI has been associated yet. 
      @@@InCase:
        @@@@Value:true
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            New binding is made if no prefix associated. 
      @@@InCase:
        @@@@Value:false
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            Simply returns the <DOM::null> if no prefix associated. 
    @@Return:
      @@@Type:SWCFGString
      @@@Description:
        @@@@lang:en
        @@@@@:
           An associated namespace prefix.  If more than one prefix 
           are associated to the namespace URI, the returned prefix 
           is implementation dependent. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Type:SWCFGString
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            No associated namespace prefix found. 
      @@@PerlDef:
        $r = null;
        my $od = $self-><AG::SWCFGNode.ownerDocument> || $self;
        my $binds = $od->{<Q::TreeCore:node>}->{<Q::nsBinding>};
        if (defined $namespaceURI) {
          FIND: {
            for my $prefix (keys %$binds) {
              if (defined $binds->{$prefix} and
                  $binds->{$prefix} eq $namespaceURI) {
                $r = $prefix;
                last FIND;
              }
            }
            last FIND unless $makeNewBinding;
            ## Not found
            if ($namespaceURI =~ /(\w+)$/) {
              my $prefix = $1;
              unless (exists $binds->{$prefix}) {
                $binds->{$prefix} = $namespaceURI;
                $r = $prefix;
                last FIND;
              }
            }
            my $i = 1;
            {
              unless (exists $binds->{'ns'.$i}) {
                $binds->{$r = 'ns'.$i} = $namespaceURI;
                last FIND;
              }
              $i++;
              redo;
            }
          } # FIND
        } else {  ## Null namespace
          FIND: {
            if (exists $binds->{'nu'.'ll'} and not defined $binds->{'nu'.'ll'}) {
              $r = 'nu'.'ll';
              last FIND;
            }
            for my $prefix (keys %$binds) {
              if (not defined $prefix) {
                $r = $prefix;
                last FIND;
              }
            }
            last FIND unless $makeNewBinding;
            ## Not found
            my $i = '';
            {
              unless (exists $binds->{'nu'.'ll'.$i}) {
                $binds->{$r = 'nu'.'ll'.$i} = null;
                last FIND;
              }
              $i++;
              redo;
            }
          }
        }

  @Method:
    @@Name:lookupNamespaceURI
    @@Description:
      @@@lang:en
      @@@@:
        Looks up the namespace URI associated to the given prefix. 
    @@NewIn21:
    @@Param:
      @@@Name:prefix
      @@@Type:SWCFGString
      @@@Description:
        @@@@lang:en
        @@@@@:
          The namespace URI to look for. 
    @@NamedParam:
      @@@Name: makeNewBinding
      @@@Type:
        DOMMain:boolean
      @@@Description:
        @@@@lang:en
        @@@@@:
          Whether a new binding should be created if no namespace URI 
          is associated with the <P::prefix> or not. 
      @@@InCase:
        @@@@Value:true
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            A new binding to the temporary namespace URI 
            exactly same as <P::prefix> is created 
            if no binding found. 
      @@@InCase:
        @@@@Value:false
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            No new binding is created if no binding found.  Note that 
            even if no association newly created, this method 
            returns the <DOM::null> value. 
    @@Return:
      @@@Type:SWCFGString
      @@@Description:
        @@@@lang:en
        @@@@@:The associated namespace URI. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Type:SWCFGString
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            No namespace prefix is associated to the prefix or 
            the <DOM::null> namespace is associated. 
      @@@PerlDef:
        my $od = $self-><AG::SWCFGNode.ownerDocument> || $self;
        my $binds = $od->{<Q::TreeCore:node>}->{<Q::nsBinding>};
        if (exists $binds->{$prefix}) {
          $r = $binds->{$prefix};
        } elsif ($makeNewBinding) {
          $r = $binds->{$prefix} = $prefix;
        } else {
          $r = null;
        }

  @Method:
    @@Name:bindNamespaceURI
    @@Description:
      @@@lang:en
      @@@@:
        Binds a namespace URI to a prefix. 
    @@NewIn21:
    @@Param:
      @@@Name:prefix
      @@@Type:SWCFGString
      @@@Description:
        @@@@lang:en
        @@@@@:
          The namespace prefix to which the URI is bound. 
          If this <P::prefix> is already bound to another URI, 
          that binding is overwritten. 
      @@@InCase:
        @@@@Value:URI
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            Any attempt to change the namespace URI will not success, 
            i.e. the namespace binding left unchanged. 
    @@Param:
      @@@Name:namespaceURI
      @@@Type:SWCFGString
      @@@Description:
        @@@@lang:en
        @@@@@:
          The namespace URI. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Type:SWCFGString
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The namespace binding for <P::prefix> is removed. 
    @@Return:
      @@@PerlDef:
        unless ($prefix eq 'URI') {
          my $od = $self-><AG::SWCFGNode.ownerDocument> || $self;
          if (defined $namespaceURI) {
            $od->{<Q::TreeCore:node>}->{<Q::nsBinding>}->{$prefix}
                                   = $namespaceURI;
          } else {
            CORE::delete $od->{<Q::TreeCore:node>}->{<Q::nsBinding>}->{$prefix};
          }
        }

  @IntMethod:
    @@Name:getNodeReference
    @@Description:
      @@@lang:en
      @@@@:
        Returns a new reference to the node object. 
    @@ManakaiDOM:isStatic:1
    @@Param:
      @@@Name:object
      @@@Type:
        ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl
      @@@Description:
        @@@@lang:en
        @@@@@:
          The node object to be referred. 
    @@Return:
      @@@Type:SWCFGNode
      @@@actualType:ManakaiSWCFGNode
      @@@Description:
        @@@@lang:en
        @@@@@:
          A newly created reference.
      @@@PerlDef:
        my $class;
        if ($object->{<Q::nodeType>} eq '#element') {
          $class = <ClassName::ManakaiSWCFGElement>;
        } elsif ($object->{<Q::nodeType>} eq '#comment') {
          $class = <ClassName::ManakaiSWCFGComment>;
        } elsif ($object->{<Q::nodeType>} eq '#document') {
          $class = <ClassName::ManakaiSWCFGDocument>;
        } elsif ($object->{<Q::nodeType>} eq '#fragment') {
          $class = <ClassName::ManakaiSWCFGDocumentFragment>;
        } else {
          __ASSERT{DISPerl:invariant::
            msg => {qq[Node type: "$object->{<Q::nodeType>}" ].
                    qq[(ref: "@{[ref $object]}")]},
          }__;
        }
        $r = $object-><M::ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl
                                  .newReference> ($class);
  
  @Method:
     @@Name:  isSameNode
     @@Description:
        @@@lang:en
        @@@@:
          Return whether this node is the same node as the given one.
        \
          When two node references are references to the same object, 
          even if through a proxy, the references may be used completely 
          interchangably, such that all attributes have the same values 
          and calling the same method on either reference always has 
          exactly same effect.
     @@NewIn21:
     @@Operator:
        @@@@: eq
        @@@ContentType:
          lang:Perl
     @@Param:
        @@@Name:  other
        @@@Type:  SWCFGNode
        @@@Description:
          @@@@lang:en
          @@@@@: The node to test against.
     @@Return:
        @@@Type:  
          DOMMain:boolean
        @@@InCase:
          @@@@Value: true
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The two nodes are the same.
        @@@InCase:
          @@@@Value: false
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The two nodes are not same.
        @@@PerlDef:
            if (UNIVERSAL::isa ($other,
                                <ClassName::ManakaiDOM:ManakaiDOMNodeReference
                                          ::ManakaiDOM:Perl>)
                and $other->{<Q::TreeCore:node>}->{<Q::TreeCore:nodeID>}
                  eq $self->{<Q::TreeCore:node>}->{<Q::TreeCore:nodeID>}) {
              $r = true;
            }

  @IntMethod:
    @@Name:newObject
    @@ManakaiDOM:isStatic:1
    @@Description:
      @@@lang:en
      @@@@:
        Creates a new instance object for <IF::SWCFGNode>. 
    @@Return:
      @@@Type:
        ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl
      @@@Description:
        @@@@lang:en
        @@@@@:
          The newly created node object.
      @@@PerlDef:
        @@@@@:
          my $node = $r = <ClassM::ManakaiDOM:ManakaiDOMNodeObject
                                        ::ManakaiDOM:Perl.new>;
          push @{$node->{<Q::TreeCore:origin>}}, <Q::parent>;
          push @{$node->{<Q::TreeCore:subnode>}}, <Q::childNodes>;
          push @{$node->{<Q::TreeCore:irefnode>}}, <Q::DOMCore:ownerDocument>;
          push @{$node->{<Q::TreeCore:anydata2>}}, <Q::flag>, <Q::option>;
          $node->{<Q::childNodes>} = [];
        @@@@ImplNote:
          @@@@@lang:en
          @@@@@@:
            Required property: <Q::nodeType>, <Q::DOMCore:ownerDocument>. 
            \
            Optional properties: <Q::value>, <Q::parent>, 
                  <Q::childNodes>, <Q::flag>, <Q::option>. 

  @IntMethod:
    @@Operator:
      @@@@:
        ManakaiDOM:MUErrorHandler
      @@@ContentType:
        dis:TypeQName
    @@Description:
      @@@lang:en
      @@@@:
        This method is a generic error handler; all manakai exceptions 
        and warnings associated to an object are once reported to this method 
        and then delivered to appropriate entities. 
        \
        If the error is an exception (such as <X::DOMCore:DOMException> or 
        <X::ManakaiDOM:ManakaiDOMImplementationException>), it is 
        simply thrown.  If the error is only a warning, it is reported 
        via the <IF::DOMCore:DOMError> interface. 
        \
        See <PerlModule::Message::Util::Error> documentation for more 
        information on the error reporting mechanism.
        \
        {NOTE:: This kind of methods are named as <Perl::___report_error> 
                in the convention of <PerlModule::Message::Util::Error>. 
        \
        }
    @@Param:
      @@@Name:err
      @@@Type: 
        ManakaiDOM:ManakaiDOMExceptionOrWarning::ManakaiDOM:Perl
      @@@Description:
        @@@@lang:en
        @@@@@:
          An exception object that describes what kind of error it is 
          and how it should be recovered. 
          \
          {NOTE:: Exception objects in manakai implementation 
                  inherit the class <PerlModule::Message::Util::Error>, 
                  that in turn inherits <PerlModule::Error>.
          \
          }
    @@Return:
      @@@PerlDef:
          if ($err->isa (<ClassName::ManakaiDOM:ManakaiDOMException
                                   ::ManakaiDOM:Perl>)) {
            $err->throw;
          } else {
            \## TODO: Implement warning reporting
            warn $err->stringify;
          }

  @Attr:
    @@Name: nodeID
    @@Description:
      @@@lang:en
      @@@@:
        A unique identifier of this node. 
        \
        {NOTE:: Node IDs are a globally unique opaque string.  Note that 
                two nodes separetely parsed and constructed from the 
                same document would have different node IDs. 
        \
        }
    @@Get:
      @@@Type: SWCFGString
      @@@disDef:
        @@@@GetProp:
          TreeCore:nodeID
##SWCFGNode

PropDef:
  @QName: fileName
  @Description:
    @@lang:en
    @@@:
      The name of the source file. 

IFClassDef:
  @IFQName:SWCFGComment
  @ClassQName:ManakaiSWCFGComment
  @IFISA: SWCFGNode
  @ClassISA: ManakaiSWCFGNode
  @Description:
    @@lang:en
    @@@:
      A comment node. 
      \
      {NOTE:: A comment node have a value.  A comment node has no child node. 
              The <CODE::#?SuikaWikiConfig/2.1> magic line is not a comment. 
              The parent node of a comment node, if any, is always 
              the document node in SuikaWikiConfig versions 2.0 and 2.1. 
      \
      }
  
  @RedefAttr:
    @@Name:nodeType
    @@Type:SWCFGString
    @@Description:
      @@@lang:en
      @@@@:
        The type of the node. 
    @@Get:
      @@@disDef:
        @@@@ConstValue:\#comment
      @@@InCase:
        @@@@Value:\#comment
        @@@@Type:SWCFGString
        @@@@Description:
          @@@@@lang:en
          @@@@@@:This node is a comment node. 

  @IntMethod:
    @@Name:newObject
    @@ManakaiDOM:isStatic:1
    @@Description:
      @@@lang:en
      @@@@:
        Creates a new instance object for <IF::SWCFGComment>. 
    @@Return:
      @@@Type:
        ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl
      @@@Description:
        @@@@lang:en
        @@@@@:
          The newly created node object.
      @@@PerlDef:
        @@@@@:
          $r = <ClassM::ManakaiSWCFGNode.newObject>;
          $r->{<Q::nodeType>} = '#comment';
          $r->{<Q::value>} = '';
          $r->{<Q::namespaceExpanded>} = true; ## Always true
          $r->{<Q::etExpanded>} = true; ## Always true
        @@@@ImplNote:
          @@@@@lang:en
          @@@@@@:
            Required property: <Q::DOMCore:ownerDocument>, <Q::nodeType>. 
            \
            Optional properties: <Q::value>, <Q::parent>, 
                  <Q::childNodes>, <Q::flag>, <Q::option>. 
##SWCFGComment

IFClassDef:
  @IFQName:SWCFGElement
  @ClassQName:ManakaiSWCFGElement
  @IFISA: SWCFGNode
  @ClassISA: ManakaiSWCFGNode
  @Description:
    @@lang:en
    @@@:
      An element node. 
      \
      {NOTE:: An element node have a value.  An element node can have 
              child elements if the value is a simple string (if any). 
              Future version of SuikaWikiConfig might allow a comment child. 
      \
      }

  @Attr:
    @@Name:expandedURI
    @@Type:SWCFGString
    @@Description:
      @@@lang:en
      @@@@:
        The expanded URI of the node. 
    @@NewIn21:
    @@Get:
      @@@PerlDef:
        __CODE{expandNamespace}__;
        if (defined $self->{<Q::TreeCore:node>}->{<Q::namespaceURI>}) {
          if ($self->{<Q::TreeCore:node>}
                   ->{<Q::namespaceURI>} eq <Q::RealName>) {
            $r = $self->{<Q::TreeCore:node>}->{<Q::shadowNamespaceURI>} .
                 $self->{<Q::TreeCore:node>}->{<Q::shadowLocalName>};
          } else {
            $r = $self->{<Q::TreeCore:node>}->{<Q::namespaceURI>} .
                 $self->{<Q::TreeCore:node>}->{<Q::localName>};
          }
        } else {
          $r = $self->{<Q::TreeCore:node>}->{<Q::localName>};
        }

  @Attr:
    @@Name:prefix
    @@Description:
      @@@lang:en
      @@@@:
        The namespace prefix of this node. 
    @@NewIn21:
    @@Get:
      @@@Type:SWCFGString
      @@@Description:
        @@@@lang:en
        @@@@@:The namespace prefix. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Type:SWCFGString
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            Either this node is not an element node or its namespace 
            is the default and no prefix is required. 
      @@@PerlDef:
        __CODE{expandNamespace}__;
        my $node = $self->{<Q::TreeCore:node>};
        my $od = $self-><AG::SWCFGNode.ownerDocument>;
        my $defURI = $od-><AG::SWCFGDocument.defaultElementTypeNamespaceURI>;
        if (defined $node->{<Q::namespaceURI>}) {
          if (not defined $defURI or
              $node->{<Q::namespaceURI>} ne $defURI or
              $node->{<Q::localName>} eq 'Namespace' or
              $node->{<Q::localName>} eq 'ElementTypeBinding' or
              $node->{<Q::localName>} =~ /:/) {
            $r = $self-><AG::SWCFGNode.lookupNamespacePrefix>
                                             ($node->{<Q::namespaceURI>},
                                              make_new_binding => 1);
          } else {
            $r = null;
          }
        } else {  ## Null namespace
          if (defined $defURI or $node->{<Q::localName>} =~ /:/ or
              $node->{<Q::localName>} eq 'Namespace' or
              $node->{<Q::localName>} eq 'ElementTypeBinding') {
            $r = $self-><AG::SWCFGNode.lookupNamespacePrefix>
                                             ($node->{<Q::namespaceURI>},
                                              make_new_binding => 1);
          } else {
            $r = null;
          }
        }

  @Attr:
    @@Name: qualifiedName
    @@Type: SWCFGString
    @@Description:
      @@@lang:en
      @@@@:
        The qualified name of the element type, i.e. the local name 
        with or with out the namespace prefix followed by a <CHAR::COLON>. 
    @@NewIn21:
    @@Get:
      @@@PerlDef:
        __CODE{expandNamespace}__;
        my $node = $self->{<Q::TreeCore:node>};
        my $od = $self-><AG::SWCFGNode.ownerDocument>;
        my $defURI = $od-><AG::SWCFGDocument.defaultElementTypeNamespaceURI>;
        if (defined $node->{<Q::namespaceURI>}) {
          my $nsURI = ($node->{<Q::namespaceURI>} eq <Q::RealName>
                        ? $node->{<Q::shadowNamespaceURI>}
                        : $node->{<Q::namespaceURI>});
          my $ln = ($node->{<Q::namespaceURI>} eq <Q::RealName>
                        ? $node->{<Q::shadowlocalName>}
                        : $node->{<Q::localName>});
          if (not defined $defURI or
              $nsURI ne $defURI or
              $ln eq 'Namespace' or
              $ln eq 'ElementTypeBinding' or
              $ln =~ /:/) {
            $r = $self-><AG::SWCFGNode.lookupNamespacePrefix>
                                             ($node->{<Q::namespaceURI>},
                                              make_new_binding => 1) .
                 ':' . $ln;
          } else {
            $r = $ln;
          }
        } else {  ## Null namespace
          if (defined $defURI or $node->{<Q::localName>} =~ /:/ or
              $node->{<Q::localName>} eq 'Namespace' or
              $node->{<Q::localName>} eq 'ElementTypeBinding') {
            $r = $self-><AG::SWCFGNode.lookupNamespacePrefix>
                                             ($node->{<Q::namespaceURI>},
                                              make_new_binding => 1) .
                 ':' . $node->{<Q::localName>};
          } else {
            $r = $node->{<Q::localName>};
          }
        }

  @Attr:
    @@Name: realQualifiedName
    @@Type: SWCFGString
    @@Description:
      @@@lang:en
      @@@@:
        The qualified name of the element type, i.e. the local name 
        with or with out the namespace prefix followed by a <CHAR::COLON>. 
    @@NewIn21:
    @@Get:
      @@@PerlDef:
        __CODE{expandNamespace}__;
        my $node = $self->{<Q::TreeCore:node>};
        my $od = $self-><AG::SWCFGNode.ownerDocument>;
        my $defURI = $od-><AG::SWCFGDocument.defaultElementTypeNamespaceURI>;
        if (defined $node->{<Q::namespaceURI>}) {
          if ($node->{<Q::namespaceURI>} eq <Q::RealName>) {
            $r = $node->{<Q::localName>};
          } elsif (not defined $defURI or
              $node->{<Q::namespaceURI>} ne $defURI or
              $node->{<Q::localName>} eq 'Namespace' or
              $node->{<Q::localName>} eq 'ElementTypeBinding' or
              $node->{<Q::localName>} =~ /:/) {
            $r = $self-><AG::SWCFGNode.lookupNamespacePrefix>
                                             ($node->{<Q::namespaceURI>},
                                              make_new_binding => 1) .
                 ':' . $node->{<Q::localName>};
          } else {
            $r = $node->{<Q::localName>};
          }
        } else {  ## Null namespace
          if (defined $defURI or $node->{<Q::localName>} =~ /:/ or
              $node->{<Q::localName>} eq 'Namespace' or
              $node->{<Q::localName>} eq 'ElementTypeBinding') {
            $r = $self-><AG::SWCFGNode.lookupNamespacePrefix>
                                             ($node->{<Q::namespaceURI>},
                                              make_new_binding => 1) .
                 ':' . $node->{<Q::localName>};
          } else {
            $r = $node->{<Q::localName>};
          }
        }
  
  @RedefAttr:
    @@Name:nodeType
    @@Type:SWCFGString
    @@Description:
      @@@lang:en
      @@@@:
        The type of the node. 
    @@Get:
      @@@disDef:
        @@@@ConstValue:\#element
      @@@InCase:
        @@@@Value:\#element
        @@@@Type:SWCFGString
        @@@@Description:
          @@@@@lang:en
          @@@@@@:This node is an element node. 

  @RedefAttr:
    @@Name:localName
    @@Description:
      @@@lang:en
      @@@@:
        The local name of the node. 
    @@Type:SWCFGString
    @@ModIn21:
    @@Get:
      @@@Type:SWCFGString
      @@@Description:
        @@@@lang:en
        @@@@@:
          The local name of the node. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Type:SWCFGString
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The node does not have the local name. 
            No node of type other than <CODE::#element> has the local name. 
      @@@PerlDef:
        __CODE{expandNamespace}__;
        $r = (defined $self->{<Q::TreeCore:node>}->{<Q::namespaceURI>} and
              $self->{<Q::TreeCore:node>}->{<Q::namespaceURI>} eq <Q::RealName>)
               ? $self->{<Q::TreeCore:node>}->{<Q::shadowLocalName>}
               : $self->{<Q::TreeCore:node>}->{<Q::localName>};
    @@Set:
      @@@Description:
        @@@@lang:en
        @@@@@:
          Sets the local name.  Setting the local name to the node 
          whose type is other than <CODE::#element> has no effect. 
      @@@PerlDef:
        __CODE{expandNamespace}__;
        if (defined $self->{<Q::TreeCore:node>}->{<Q::namespaceURI>} and
            $self->{<Q::TreeCore:node>}->{<Q::namespaceURI>} eq <Q::RealName>) {
          $self->{<Q::TreeCore:node>}->{<Q::namespaceURI>}
              = $self->{<Q::TreeCore:node>}->{<Q::shadowNamespaceURI>};
        }
        $self->{<Q::TreeCore:node>}->{<Q::localName>} = $given;

  @Attr:
    @@Name:realLocalName
    @@Description:
      @@@lang:en
      @@@@:
        The real local name of the node. 
    @@Type:SWCFGString
    @@NewIn21:
    @@Get:
      @@@Type:SWCFGString
      @@@Description:
        @@@@lang:en
        @@@@@:
          The local name of the node.  If an element type binding 
          has bound to this element, then actual element type name. 
      @@@PerlDef:
        __CODE{expandNamespace}__;
        $r = $self->{<Q::TreeCore:node>}->{<Q::localName>};
    @@Set:
      @@@Description:
        @@@@lang:en
        @@@@@:
          Sets the local name.  Setting the local name to the node 
          whose type is other than <CODE::#element> has no effect.  
          Changes for element type name does not take effect 
          until <M::SWCFGDocument.updateElementTypeBinding> method is called. 
      @@@PerlDef:
        __CODE{expandNamespace}__;
        $self->{<Q::TreeCore:node>}->{<Q::localName>} = $given;

  @RedefAttr:
    @@Name:namespaceURI
    @@NewIn21:
    @@Description:
      @@@lang:en
      @@@@:
        The namespace URI of the node. 
    @@Type:SWCFGString
    @@Get:
      @@@Type:SWCFGString
      @@@Description:
        @@@@lang:en
        @@@@@:
          The namespace URI of the node. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Type:SWCFGString
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The node does not have the namespace URI. 
      @@@PerlDef:
        __CODE{expandNamespace}__;
        $r = (defined $self->{<Q::TreeCore:node>}->{<Q::namespaceURI>} and
              $self->{<Q::TreeCore:node>}->{<Q::namespaceURI>} eq <Q::RealName>)
             ? $self->{<Q::TreeCore:node>}->{<Q::shadowNamespaceURI>}
             : $self->{<Q::TreeCore:node>}->{<Q::namespaceURI>};
    @@Set:
      @@@Type:SWCFGString
      @@@Description:
        @@@@lang:en
        @@@@@:
          Sets the namespace URI.
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Type:SWCFGString
        @@@@Description:
          @@@@@lang:en
          @@@@@@: 
            Sets the node not to have its namespace URI (or sets 
            the namespace as the <QUOTE::<DOM::null> namespace>. 
      @@@InCase:
        @@@@Value:
          @@@@@ContentType:
            dis:TypeQName
          @@@@@@:
            swcfg21:RealName
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The namespace URI (both <EM::real> or <EM::shadow>) 
            has left unchanged. 
      @@@PerlDef:
        unless (defined $given and $given eq <Q::RealName>) {
          __CODE{expandNamespace}__;
          if (defined $self->{<Q::TreeCore:node>}->{<Q::namespaceURI>} and
             $self->{<Q::TreeCore:node>}->{<Q::namespaceURI>} eq <Q::RealName>) {
            $self->{<Q::TreeCore:node>}->{<Q::localName>}
              = $self->{<Q::TreeCore:node>}->{<Q::localName>};
          }
          $self->{<Q::TreeCore:node>}->{<Q::namespaceURI>} = $given;
        }

  @Attr:
    @@Name:realNamespaceURI
    @@NewIn21:
    @@Description:
      @@@lang:en
      @@@@:
        The namespace URI of the node. 
    @@Type:SWCFGString
    @@Get:
      @@@Type:SWCFGString
      @@@Description:
        @@@@lang:en
        @@@@@:
          The namespace URI of the node. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Type:SWCFGString
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The node does not have the namespace URI. 
      @@@InCase:
        @@@@Value:
          @@@@@ContentType:
            dis:TypeQName
          @@@@@@:
            swcfg21:RealName
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            Any element type binding has been bound to this element; 
            the local name of this node is the <EM::real> qualified name. 
      @@@PerlDef:
        __CODE{expandNamespace}__;
        $r = $self->{<Q::TreeCore:node>}->{<Q::namespaceURI>};
    @@Set:
      @@@Type:SWCFGString
      @@@Description:
        @@@@lang:en
        @@@@@:
          Sets the namespace URI.
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Type:SWCFGString
        @@@@Description:
          @@@@@lang:en
          @@@@@@: 
            Sets the node not to have its namespace URI (or sets 
            the namespace as the <QUOTE::<DOM::null> namespace>. 
      @@@InCase:
        @@@@Value:
          @@@@@ContentType:
            dis:TypeQName
          @@@@@@:
            swcfg21:RealName
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The namespace URI (both <EM::real> or <EM::shadow>) 
            has left unchanged. 
      @@@PerlDef:
        unless (defined $given and $given eq <Q::RealName>) {
          __CODE{expandNamespace}__;
          $self->{<Q::TreeCore:node>}->{<Q::namespaceURI>} = $given;
        }

  @IntMethod:
    @@Name:newObject
    @@ManakaiDOM:isStatic:1
    @@Description:
      @@@lang:en
      @@@@:
        Creates a new instance object for <IF::SWCFGElement>. 
    @@Return:
      @@@Type:
        ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl
      @@@Description:
        @@@@lang:en
        @@@@@:
          The newly created node object.
      @@@PerlDef:
        @@@@@:
          $r = <ClassM::ManakaiSWCFGNode.newObject>;
          $r->{<Q::nodeType>} = '#element';
          push @{$r->{<Q::TreeCore:subnode0>}}, <Q::shadowContent>,
                                                <Q::shadowSibling>;
        @@@@ImplNote:
          @@@@@lang:en
          @@@@@@:
            Required property: <Q::DOMCore:ownerDocument>, <Q::nodeType>, 
              <Q::localName>. 
            \
            Optional properties: <Q::value>, <Q::parent>, 
                  <Q::childNodes>, <Q::flag>, <Q::option>, 
                  <Q::namespaceURI>, <Q::namespaceExpanded>, 
                  <Q::shadowContent>, <Q::shadowSibling>, 
                  <Q::etExpanded>. 

  @ResourceDef:
    @@QName: expandETBinding
    @@rdf:type:
      dis2pm:BlockCode
    @@Description:
      @@@lang:en
      @@@@:
        Expands element type bindings. 
    @@ForCheck: ForClass
    @@PerlDef:
      unless ($node->{<Q::etExpanded>}) {
        my $__qn;
        if ($node->{<Q::namespaceExpanded>}) {
          $__qn = <ClassM::ManakaiSWCFGNode.getNodeReference> ($node)
                  -><AG::SWCFGElement.realQualifiedName>;
        } else {
          $__qn = $node->{<Q::localName>};

        }
        my $__od = $node->{<Q::DOMCore:ownerDocument>};
        if ($__od->{<Q::etBinding>}->{$__qn}) {
          my $b = $__od->{<Q::etBinding>}->{$__qn};
          $node->{<Q::namespaceURI>} = <Q::RealName>;
          if ($node->{<Q::namespaceExpanded>}) {
            $node->{<Q::localName>} = $__qn;
          } else {
            $node->{<Q::namespaceExpanded>} = true;
          }
          unless ($b->{namespaceExpanded}) {
            if ($b->{shadowLocalName} =~ s/^([^:]*)://) {
              my $__prefix = $1;
              __DEEP{
                $b->{shadowNamespaceURI}
                   = <ClassM::ManakaiSWCFGNode.getNodeReference> ($__od)
                           -><M::SWCFGNode.lookupNamespaceURI>
                                 ($__prefix, make_new_binding => 1);
              }__;
            }
            $b->{namespaceExpanded} = true;
          }
          $node->{<Q::shadowNamespaceURI>} = $b->{shadowNamespaceURI};
          $node->{<Q::shadowLocalName>} = $b->{shadowLocalName};
          for my $__p (qw/shadowContent shadowSibling/) {
            next unless $b->{$__p};
            my $cl = <ClassM::ManakaiSWCFGNode.getNodeReference> ($b->{$__p})
                        ->clone;
            my $__n = $node->{{shadowContent => <Q::shadowContent>,
                               shadowSibling => <Q::shadowSibling>}->{$__p}}
               = $cl->{<Q::TreeCore:node>};
            $node-><M::ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl
                            .importTree> ($__n);
            $__n->{{shadowContent => <Q::shadowParent>,
                    shadowSibling => <Q::shadowSiblingOf>}->{$__p}} = $node;
          }
        }
        $node->{<Q::etExpanded>} = true;
      }

  @ResourceDef:
    @@QName: expandNamespace
    @@rdf:type:
      dis2pm:BlockCode
    @@ForCheck: ForClass
    @@Description:
      @@@lang:en
      @@@@:
        Expands qualified name into namespace URI and local name. 
    @@PerlDef:
      my $__node = $self->{<Q::TreeCore:node>};
      __CODE{expandETBinding:: $node => $__node}__;
      unless ($__node->{<Q::namespaceExpanded>}) {
        if ($__node->{<Q::localName>} =~ s/^([^:]*)://g) {
          my $__prefix = $1;
          __DEEP{
            $__node->{<Q::namespaceURI>}
                 = $self-><M::SWCFGNode.lookupNamespaceURI>
                                 ($__prefix, make_new_binding => 1);
          }__;
        } else {
          $__node->{<Q::namespaceURI>}
                 = $__node->{<Q::DOMCore:ownerDocument>}
                          ->{<Q::defaultETNamespaceURI>};
        }
        $__node->{<Q::namespaceExpanded>} = true;
      }
##SWCFGElement

IFClassDef:
  @IFQName:SWCFGDocument
  @ClassQName:ManakaiSWCFGDocument
  @IFISA: SWCFGNode
  @ClassISA: ManakaiSWCFGNode
  @Description:
    @@lang:en
    @@@:
      A document node. 
      \
      {NOTE:: A document node does not have any value.  A document node can have 
              child nodes whose type is either element or comment. 
              A document node has no parent. 
      \
      }

  @Method:
    @@Name:createElementNS
    @@Description:
      @@@lang:en
      @@@@:
        Creates a new element. 
        \
        {NOTE:: No element type binding expansion will occur 
                at the time of creation. 
        \
        }
    @@NewIn21:
    @@Param:
      @@@Name:namespaceURI
      @@@Type:SWCFGString
      @@@Description:
        @@@@lang:en
        @@@@@:
          The namespace URI of the element to create. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Type:SWCFGString
        @@@@Description:
          @@@@@lang:en
          @@@@@@: The new element has no namespace. 
    @@Param:
      @@@Name:localName
      @@@Type:SWCFGString
      @@@Description:
        @@@@lang:en
        @@@@@:
          The local name of the element to create. 
    @@Return:
      @@@Type:SWCFGElement
      @@@Description:
        @@@@lang:en
        @@@@@:
          The newly created element. 
      @@@PerlDef:
        $r = <ClassM::ManakaiSWCFGElement.newObject>;
        $r->{<Q::DOMCore:ownerDocument>} = $self->{<Q::TreeCore:node>};
        $r->{<Q::namespaceURI>} = $namespaceURI;
        $r->{<Q::localName>} = $localName;
        $r->{<Q::namespaceExpanded>} = true;
        $r->{<Q::etExpanded>} = true;
        $r = <ClassM::ManakaiSWCFGNode.getNodeReference> ($r);

  @Method:
    @@Name:createComment
    @@Description:
      @@@lang:en
      @@@@:
        Creates a new comment node. 
    @@NewIn21:
    @@Param:
      @@@Name:data
      @@@Type:SWCFGString
      @@@Description:
        @@@@lang:en
        @@@@@:
          The initial content of the comment. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Type:SWCFGString
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The new comment node has the empty value. 
    @@Return:
      @@@Type:SWCFGComment
      @@@Description:
        @@@@lang:en
        @@@@@:
          The newly created comment. 
      @@@PerlDef:
        $r = <ClassM::ManakaiSWCFGComment.newObject>;
        $r->{<Q::DOMCore:ownerDocument>} = $self->{<Q::TreeCore:node>};
        $r->{<Q::value>} = defined $data ? $data : '';
        $r = <ClassM::ManakaiSWCFGNode.getNodeReference> ($r);

  @Method:
    @@Name:createDocumentFragment
    @@Description:
      @@@lang:en
      @@@@:
        Creates a new document fragment node. 
    @@NewIn21:
    @@Return:
      @@@Type:SWCFGDocumentFragment
      @@@Description:
        @@@@lang:en
        @@@@@:
          The newly created document fragment node. 
      @@@PerlDef:
        $r = <ClassM::ManakaiSWCFGDocumentFragment.newObject>;
        $r->{<Q::DOMCore:ownerDocument>} = $self->{<Q::TreeCore:node>};
        $r = <ClassM::ManakaiSWCFGNode.getNodeReference> ($r);

  @Attr:
    @@Name: defaultElementTypeNamespaceURI
    @@Description:
      @@@lang:en
      @@@@:
        The default namespace URI for element type names. 
    @@NewIn21:
    @@Type:SWCFGString
    @@Get:
      @@@disDef:
        @@@@GetProp:defaultETNamespaceURI
    @@Set:
      @@@disDef:
        @@@@SetProp:defaultETNamespaceURI

  @Attr:
    @@Name: implementation
    @@Description:
      @@@lang:en
      @@@@:
        The SuikaWikiConfig implementation to which this document 
        belongs. 
    @@NewIn21:
    @@Type: SWCFGImplementation
    @@Get:
      @@@disDef:
        @@@@GetProp:
          DOMCore:implementation
  
  @RedefAttr:
    @@Name:nodeType
    @@Type:SWCFGString
    @@Description:
      @@@lang:en
      @@@@:
        The type of the node. 
    @@Get:
      @@@disDef:
        @@@@ConstValue:\#document
      @@@Type:SWCFGString
      @@@InCase:
        @@@@Value:\#document
        @@@@Type:SWCFGString
        @@@@Description:
          @@@@@lang:en
          @@@@@@:This node is a document node. 

  @RedefMethod:
    @@Name:innerText
    @@Description:
      @@@lang:en
      @@@@:
        Returns the text value of this node. 
    @@NamedParam:
      @@@Name:newValue
      @@@Type:
        DOMMain:any
      @@@Description:
        @@@@lang:en
        @@@@@:
          An attempt to set a value to document node has no effect. 
    @@Return:
      @@@Type:SWCFGString
      @@@Description:
        @@@@lang:en
        @@@@@:
          The value of this node.
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Type:SWCFGString
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The node has no value. 
      @@@disDef:
        @@@@DISLang:nop:

  @Method:
    @@Name:actualInnerText
    @@Description:
      @@@lang:en
      @@@@:
        Returns the text value of this node. 
    @@NewIn21:
    @@NamedParam:
      @@@Name:newValue
      @@@Type:
        DOMMain:any
      @@@Description:
        @@@@lang:en
        @@@@@:
          An attempt to set a value to document node has no effect. 
    @@Return:
      @@@Type:SWCFGString
      @@@Description:
        @@@@lang:en
        @@@@@:
          The value of this node.
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Type:SWCFGString
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The node has no value. 
      @@@disDef:
        @@@@DISLang:nop:

  @IntMethod:
    @@Name:newObject
    @@ManakaiDOM:isStatic:1
    @@Description:
      @@@lang:en
      @@@@:
        Creates a new instance object for <IF::SWCFGDocument>. 
    @@Return:
      @@@Type:
        ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl
      @@@Description:
        @@@@lang:en
        @@@@@:
          The newly created node object.
      @@@PerlDef:
        @@@@@:
          $r = <ClassM::ManakaiSWCFGNode.newObject>;
          $r->{<Q::nodeType>} = '#document';
          $r->{<Q::nsBinding>} = {URI => ''};
          $r->{<Q::etBinding>} = {};
          $r->{<Q::namespaceExpanded>} = true; ## Always true
          $r->{<Q::etExpanded>} = true; ## Always true
          push @{$r->{<Q::TreeCore:subnode2>}}, <Q::etBinding>;
        @@@@ImplNote:
          @@@@@lang:en
          @@@@@@:
            Required property: <Q::DOMCore:ownerDocument>, <Q::nodeType>, 
                  <Q::DOMCore:implementation>, <Q::nsBinding>, 
                  <Q::etBinding>. 
            \
            Optional properties: <Q::childNodes>, <Q::flag>, <Q::option>, 
                  <Q::defaultETNamespaceURI>. 
##SWCFGDocument

IFClassDef:
  @IFQName:SWCFGDocumentFragment
  @ClassQName:ManakaiSWCFGDocumentFragment
  @IFISA: SWCFGNode
  @ClassISA: ManakaiSWCFGNode
  @Description:
    @@lang:en
    @@@:
      A document fragment node. 
      \
      {NOTE:: A document fragment node may have its value if 
              and only if its <A::SWCFGDocumentFragment.isShadowMaster> 
              is <DOM::true>.
              A document fragment node can have child elements. 
              Future version of SuikaWikiConfig might allow a comment child. 
              A document fragment node has no parent. 
      \
      }

  @Attr:
    @@Name: isShadowMaster
    @@Type: 
      DOMMain:boolean
    @@Description:
      @@@lang:en
      @@@@:
        Whether this node is the root node for the shadow content 
        or shadow sibling tree or not. 
    @@NewIn21:
    @@Get:
      @@@disDef:
        @@@@GetProp: isShadowMaster
  
  @RedefAttr:
    @@Name:nodeType
    @@Type:SWCFGString
    @@Description:
      @@@lang:en
      @@@@:
        The type of the node. 
    @@Get:
      @@@disDef:
        @@@@ConstValue:\#fragment
      @@@InCase:
        @@@@Value:\#fragment
        @@@@Type:SWCFGString
        @@@@Description:
          @@@@@lang:en
          @@@@@@:This node is a document fragment node. 

  @IntMethod:
    @@Name:newObject
    @@ManakaiDOM:isStatic:1
    @@Description:
      @@@lang:en
      @@@@:
        Creates a new instance object for <IF::SWCFGDocumentFragment>. 
    @@Return:
      @@@Type:
        ManakaiDOM:ManakaiDOMNodeObject::ManakaiDOM:Perl
      @@@Description:
        @@@@lang:en
        @@@@@:
          The newly created node object.
      @@@PerlDef:
        @@@@@:
          $r = <ClassM::ManakaiSWCFGNode.newObject>;
          $r->{<Q::nodeType>} = '#fragment';
          $r->{<Q::namespaceExpanded>} = true; ## Always true
          $r->{<Q::etExpanded>} = true; ## Always true
          push @{$r->{<Q::TreeCore:origin>}},
                     <Q::shadowOwner>, <Q::shadowParent>, <Q::shadowSiblingOf>;
        @@@@ImplNote:
          @@@@@lang:en
          @@@@@@:
            Required property: <Q::DOMCore:ownerDocument>, <Q::nodeType>. 
            \
            Optional properties: <Q::parent>, <Q::value>,
                  <Q::childNodes>, <Q::flag>, <Q::option>, <Q::shadowOwner>, 
                  <Q::shadowParent>, <Q::shadowSiblingOf>. 
##SWCFGDocumentFragment

IFClassDef:
  @IFQName:SWCFGChildNodeList
  @ClassQName:ManakaiSWCFGChildNodeList
  @Description:
    @@lang:en
    @@@:
      A child node list of a node. 
  @AppISA:
    @@ForCheck: ForClass
    @@ContentType:
      lang:Perl
    @@@:
      Tie::Array

  @Attr:
    @@Name:length
    @@Type:
      DOMMain:unsigned-long
    @@Operator:
      @@@@:FETCHSIZE
      @@@ContentType:
        lang:Perl
    @@Description:
      @@@lang:en
      @@@@:
        The number of child nodes, including those belong to shadow trees. 
    @@Get:
      @@@PerlDef:
        my $node = $self->{<Q::TreeCore:node>};
        $r = @{$node->{<Q::childNodes>}};
        __CODE{expandETBinding:: $node => $node}__;
        if ($node->{<Q::shadowContent>}) {
          $r += @{$node->{<Q::shadowContent>}->{<Q::childNodes>}};
        }
        for my $c (@{$node->{<Q::childNodes>}}) {
          __CODE{expandETBinding:: $node => $c}__;
          $r += @{$c->{<Q::shadowSibling>}->{<Q::childNodes>}}
             if $c->{<Q::shadowSibling>};
        }

  @Method:
    @@Name:item
    @@Description:
      @@@lang:en
      @@@@:
        Returns a child node. 
    @@Operator:
      @@@@:FETCH
      @@@ContentType:
        lang:Perl
    @@NewIn21:
    @@Param:
      @@@Name:index
      @@@Type:
        DOMMain:long
      @@@Description:
        @@@@lang:en
        @@@@@:
          The ordinal index of the node to retrieve, counting from zero. 
          A negative index identifies a node from the end of the list. 
    @@Return:
      @@@Type:SWCFGNode
      @@@Description:
        @@@@lang:en
        @@@@@:
          The <P::index>th child node in the list. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Type:SWCFGNode
        @@@@Description:
          @@@@@lang:en
          @@@@@@: 
            There is no <P::index>th node in the list. 
      @@@PerlDef:
        if ($index < 0) {
          $index = $self-><AG::SWCFGChildNodeList.length> + $index;
        }
        my $node = $self->{<Q::TreeCore:node>};
        $r = $node->{<Q::childNodes>}->[$index];
        unless ($r) {
          $index -= @{$node->{<Q::childNodes>}};
          __CODE{expandETBinding:: $node => $node}__;
          $r = $node->{<Q::shadowContent>}->{<Q::childNodes>}->[$index]
            if $node->{<Q::shadowContent>};
          unless ($r) {
            if ($node->{<Q::shadowContent>}) {
              $index -= @{$node->{<Q::shadowContent>}->{<Q::childNodes>}};
            }
            for my $c (@{$node->{<Q::childNodes>}}) {
              __CODE{expandETBinding:: $node => $c}__;
              if ($c->{<Q::shadowSibling>}) {
                $r = $c->{<Q::shadowSibling>}->{<Q::childNodes>}->[$index];
                last if $r;
                $index -= @{$c->{<Q::shadowSibling>}->{<Q::childNodes>}};
              }
            }
          }
        }
        $r = <ClassM::ManakaiSWCFGNode.getNodeReference> ($r) if $r;

  @IntMethod:
    @@Operator:
      @@@@:TIEARRAY
      @@@ContentType:
        lang:Perl
    @@ManakaiDOM:isStatic:1
    @@Description:
      @@@lang:en
      @@@@:
        Binds a node list to an array.  This method is intended to 
        be called by Perl <Perl::tie> function. 
    @@Param:
      @@@Name: nodeList
      @@@Type: SWCFGChildNodeList
      @@@Description:
        @@@@lang:en
        @@@@@:
          A node list that is tied with an array. 
    @@Return:
      @@@Type: SWCFGChildNodeList
      @@@Description:
        @@@@lang:en
        @@@@@:
          The node list to which the array has bound, 
          i.e. <P::nodeList>.
      @@@PerlDef:
        $r = $nodeList;

  @IntMethod:
    @@Operator:
      @@@@:@{}
      @@@ContentType:
        lang:Perl
    @@Description:
      @@@lang:en
      @@@@:
        Returns an array representation of this node list. 
        \
        {NOTE:: It is intended that most operations through the 
                array is as like ones in DOM Level 0 JavaScript 
                implementations as possible. 
        \
        }
    @@Return:
      @@@Type:
        Perl:ARRAY::ManakaiDOM:all
      @@@PerlDef:
        tie my @list, ref $self, $self;
        $r = \@list;

  @IntMethod:
    @@Operator:
      @@@@:DESTROY
      @@@ContentType:
        lang:Perl
    @@Description:
      @@@lang:en
      @@@@:
        Redefines destructor for the class
        <Class::ManakaiDOM:ManakaiDOMNodeReference>, 
        since the <PerlModule::Tie::Array> also has its own empty destructor. 
    @@Return:
      @@@Def:
        @@@@ContentType:
          lang:dis
        @@@@DISPerl:cloneCode:
          ManakaiDOM:ManakaiDOMNodeReference::ManakaiDOM:Perl.destroy

##SWCFGChildNodeList

PropDef:
  @QName:childNodes
  @Description:
    @@lang:en
    @@@:
      Child nodes of a node. 

PropDef:
  @QName:shadowContent
  @Description:
    @@lang:en
    @@@:
      Child nodes of a node, copied from the shadow master tree. 

PropDef:
  @QName:shadowSibling
  @Description:
    @@lang:en
    @@@:
      Younger sibling nodes of a node, copied from the shadow master tree. 

PropDef:
  @QName: shadowOwner
  @Description:
    @@lang:en
    @@@:
      The owner document of the master shadow tree.  This property is 
      redudant (always same, if any, as <Q::DOMCore:ownerDocument>) 
      but need to maintain the origin-subnode relationship. 

PropDef:
  @QName:value
  @Description:
    @@lang:en
    @@@:
      The value of a node.  It is either a simple value, represented
      as a string, or a 
      list value, represented as an array reference.  If a node 
      does not has a value, its value is <DOM::null>. 

PropDef:
  @QName:namespaceURI
  @Type:SWCFGString
  @Description:
    @@lang:en
    @@@:
      The namespace URI of an element node.  
  @InCase:
    @@Value:
      @@@is-null:1
    @@Type:SWCFGString
    @@Description:
      @@@lang:en
      @@@@:
        The node has no namespace (or has <QUOTE::<DOM::null> namespace>. 

PropDef:
  @QName:localName
  @Description:
    @@lang:en
    @@@:
      The local name of an element node. 

PropDef:
  @QName:namespaceExpanded
  @Description:
    @@lang:en
    @@@:
      Whether the namespace URI has expanded or not. 
  @Type:
    DOMMain:boolean

PropDef:
  @QName: etExpanded
  @Description:
    @@lang:en
    @@@:
      Whether the element type binding has been expanded or not.
  @Type:
    DOMMain:boolean

PropDef:
  @QName:nsBinding
  @Description:
    @@lang:en
    @@@:
      Namespace prefix and URI bindings. 

PropDef:
  @QName:etBinding
  @Description:
    @@lang:en
    @@@:
      Element type bindings. 

ResourceDef:
  @QName: RealName
  @rdf:type:
    rdfs:Class
  @Description:
    @@lang:en
    @@@:
      The special-purpose namespace to which qualified names 
      unparsed because of element type bindings belong. 
  @For:
    =ManakaiDOM:all

PropDef:
  @QName:isShadowMaster
  @Description:
    @@lang:en
    @@@:
      Whether a document fragment node is the root node of a 
      shadow master tree or not. 
  @Type:
    DOMMain:boolean
  @rdfs:range: SWCFGDocumentFragment

PropDef:
  @QName:defaultETNamespaceURI
  @Description:
    @@lang:en
    @@@:
      Default namespace URI for element type. 
  @Type: SWCFGString

PropDef:
  @QName:flag
  @Type:
    Perl:HASH
  @Description:
    @@lang:en
    @@@:
      Flags associated with the node. 

PropDef:
  @QName:option
  @Type:
    Perl:HASH
  @Description:
    @@lang:en
    @@@:
      Node-wide options set to the node. 
  #@Type:c

PropDef:
  @QName:nodeType
  @Type:SWCFGString
  @Description:
    @@lang:en
    @@@:
      The node type. 

## -- Exceptions

ExceptionDef:
  @IFQName: SWCFGException
  @ClassQName:ManakaiSWCFGException
  @Description:
    @@lang:en
    @@@:
      Exceptions raised if an attempt to make a bad operation has made. 
  @XConstGroupDef:
    @@IFQName: SWCFGExceptionCode
    @@ClassQName: ManakaiSWCFGExceptionCode
    @@rdfs:subClassOf:
      DOMMain:unsigned-long::ManakaiDOM:all
    @@Type:
      DOMMain:unsigned-long
    @@XConst:
      @@@Name:HIERARCHY_REQUEST_ERR
      @@@Value:3
      @@@Description:
        @@@@lang:en
        @@@@@: 
          An attempt is made to insert a node somewhere it does not belong. 
      @@@XSubTypeDef:
        @@@@QName:HIERARCHY_ANCESTOR_OR_SELF_ERR
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            An attempt is made to insert an ancestor of this node or 
            this node itself. 
      @@@XSubTypeDef:
        @@@@QName:HIERARCHY_BAD_TYPE_ERR
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            An attempt is made to insert a comment node into non-document 
            node or a document or document fragment node somwehre or 
            any node into comment node. 
        @@@@enMufDef:
          An attempt is made to insert a node %p (
          name => {<Q::swcfg21:childNodeType>}, prefix => { of type });
          into the node %p (name => {<Q::swcfg21:parentNodeType>},
          prefix => {of type });, which is not allowed
        @@@@XParam:
          @@@@@QName: parentNodeType
          @@@@@Description:
            @@@@@@lang:en
            @@@@@@@:
              The type of the node into which an attempt is made to
              insert another node. 
        @@@@XParam:
          @@@@@QName: childNodeType
          @@@@@Description:
            @@@@@@lang:en
            @@@@@@@:
              The type of the node that an attempt is made to
              insert into another node.
      @@@XSubTypeDef:
        @@@@QName: HIERARCHY_NO_VALUE_ERR
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            An attempt is made to set a node value for a document node. 
        @@@@enMufDef:
          An attempt is made to set a node value for a 
          %p (name => {<Q::parentNodeType>}); node
        @@@@XParam:
          @@@@@QName: parentNodeType
          @@@@@Description:
            @@@@@@lang:en
            @@@@@@@:
              The type of the node to which the value is attempted to set. 
    @@XConst:
      @@@Name:WRONG_DOCUMENT_ERR
      @@@Value:4
      @@@Description:
        @@@@lang:en
        @@@@@:
          A node is used in a different document than the one for which 
          it is created. 
      @@@XSubTypeDef:
        @@@@QName:EXTERNAL_NODE_ERR
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            An attempt is made to insert a foreign node. 
        @@@@enMufDef:
          An attempt is made to append a node created for another document
    @@XConst:
      @@@Name:TYPE_MISMATCH_ERR
      @@@Value:17
      @@@Description:
        @@@@lang:en
        @@@@@: 
          The type of an object is incompatible with the type of 
          the parameter. 
      @@@XSubTypeDef:
        @@@@QName:BAD_VALUE_ERR
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The type of an object is not a string nor a list (array reference). 
        @@@@enMufDef:
          A value%p (name => {<Q::actualType>}, prefix => { of type }); is 
          specified where only either string or array reference is allowed
        @@@@XParam:
          @@@@@QName:actualType
          @@@@@Description:
            @@@@@@lang:en
            @@@@@@@:
              The type of the object specified. 
      @@@XSubTypeDef:
        @@@@QName:NOT_NODE_ERR
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The type of an object is not <IF::SWCFGNode>. 
        @@@@XParam:
          @@@@@QName:actualType
          @@@@@Description:
            @@@@@@lang:en
            @@@@@@@:
              The type of the object specified. 
       @@@XSubTypeDef:
         @@@@QName:APPEND_NULL_TEXT_ERR
         @@@@Description:
           @@@@@lang:en
           @@@@@@:
             An attempt is made to append a <DOM::null> value. 
    @@XConst:
      @@@Name: NOT_SUPPORTED_ERR
      @@@Value: 9
      @@@XSubTypeDef:
        @@@@QName:SWCFG_VERSION_NOT_SUPPORTED_ERR
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The implementation does not support the specified version 
            of SuikaWikiConfig. 
        @@@@XParam:
          @@@@@QName:version
          @@@@@Description:
            @@@@@@lang:en
            @@@@@@@:
              The version of SuikaWikiConfig that the implementation 
              does not support. 
    @@XConst:
      @@@Name:PARSE_ERR
      @@@Value:81
      @@@XSubTypeDef:
        @@@@QName:SWCFG_PARSE_ERR
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The implementation is unable to read and parse the 
            SuikaWikiConfig document. 
##SWCFGException

XPropDef:
  @QName: parentNodeType
  @Description:
    @@lang:en
    @@@:
      The type of the node that an attempt is made to
      insert into another node.

XPropDef:
  @QName: childNodeType
  @Description:
    @@lang:en
    @@@:
      The type of the node into which an attempt is made to
      insert another node.

XPropDef:
  @QName:actualType
  @Description:
    @@lang:en
    @@@:
      The type of the actually specified value. 
  @dataType:
    DISCore:String

XPropDef:
  @QName: version
  @Type: SWCFGString
  @Description:
    @@lang:en
    @@@:
      The version of the SuikaWikiConfig format.  Currently there is 
      version <CODE::2.0> and <CODE::2.1> defined. 

## -- Datatypes

TypeDef:
  @QName:SWCFGString
  @rdfs:subClassOf:
    DISLang:String::ManakaiDOM:all
  @Description:
    @@lang:en
    @@@:
      Strings. 

## -- Load

IFClassDef: 
  @IFQName: SWCFGParser
  @ClassQName: ManakaiSWCFGParser
  @Description:
    @@lang:en
    @@@:
      This interface provides methods to load SuikaWikiConfig documents. 
  
  @Method:
    @@Name: parse
    @@Description:
      @@@lang:en
      @@@@:
        Parses a SuikaWikiConfig document from a resource. 
    @@Param:
      @@@Name:input
      @@@Type:
        DOMLS:LSInput::ManakaiDOM:ManakaiDOMLatest
      @@@Description:
        @@@@lang:en
        @@@@@:
          The <IF::DOMLS:LSInput> from which the source of the document 
          is to be read. 
    @@Return:
      @@@Type:SWCFGDocument
      @@@Description:
        @@@@lang:en
        @@@@@:
          The newly created SuikaWikiConfig document node. 
      @@@RaiseException:
        @@@@@:SWCFG_PARSE_ERR
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The <IF::SWCFGParser> was unable to load the SuikaWikiConfig 
            document. 
      @@@PerlDef:
           my $text;
           ## 1. characterStream
           if (defined (my $cs = $input-><AG::DOMLS:LSInput
                              ::ManakaiDOM:ManakaiDOMLatest.characterStream>)) {
             local $/ = undef;
             $text = \ (readline $cs);
           }
           ## 2. byteStream
           elsif (defined (my $bs = $input-><AG::DOMLS:LSInput
                              ::ManakaiDOM:ManakaiDOMLatest.byteStream>)) {
             __EXCEPTION{
               ManakaiSWCFGException.NOT_SUPPORTED_ERR::
                 MDOMX:param-name => 'input',
             }__;
           }
           ## 3. stringData
           elsif (defined (my $sd = $input-><AG::DOMLS:LSInput
                                   ::ManakaiDOM:ManakaiDOMLatest.stringData>)) {
             $text = \$sd;
           }
           ## 4. systemId
           ## 5. publicId
           elsif (defined (my $sysId = $input-><AG::DOMLS:LSInput
                                      ::ManakaiDOM:ManakaiDOMLatest.systemId>) or
                  defined (my $pubId = $input-><AG::DOMLS:LSInput
                                      ::ManakaiDOM:ManakaiDOMLatest.publicId>)) {
             __EXCEPTION{
               ManakaiSWCFGException.NOT_SUPPORTED_ERR::
                 MDOMX:param-name => 'input',
             }__;
           } else {
             ## TODO: no-input-specified DOM error
             __EXCEPTION{SWCFG_PARSE_ERR::
               MDOMX:param-name => 'input',
             }__;
           }
           
           my $root = $self->{<Q::DOMCore:implementation>}
                           -><M::SWCFGImplementation.createSWCFGDocument>;

           ## TODO: Make configurable
           my $no_magic_line = false;
           my $no_namespace = false;
           my $no_preserve_wsp = false;
           my $no_binding = false;
           
           ## Magic line
           if (not $no_magic_line and
               $$text =~ s[^\#\?SuikaWikiConfig/(\d+\.\d+)\x0D?\x0A][]s) {
             my $version = $1;
             if ($version eq '2.1') {
               # 
             } elsif ($version eq '2.0') {
               $no_namespace = true;
               $no_preserve_wsp = true;
               $no_binding = true;
             } else {
               ## TODO: Version unsupported DOM error
               __EXCEPTION{SWCFG_PARSE_ERR::
                 MDOMX:param-name => 'input',
               }__;
             }
           }

           my $current = $root;
           my $current_element = $root;
           my $is_new_element = 0;
           my $is_list_element = 0;
           my $wsp_length = 0;
           my $vfragment = '';
           for my $line (split /\x0D?\x0A/, $$text) {
             if ($line =~ /^([^#\s].*):\s*([^\s:][^:]*)?$/) {
               my ($name, $val) = ($1, $2);
               substr ($name, 0, 1) = '' if defined $name and 
                                            substr ($name, 0, 1) eq '\\';
               substr ($val, 0, 1) = '' if defined $val and
                                           substr ($val, 0, 1) eq '\\';
              if (substr ($name, -6) eq '[list]') {
                substr ($name, -6) = '';
                $val = length ($val) ? [$val] : [];
                $is_list_element = 1;
              } else {
                $is_list_element = 0;
              }
              $current_element = $root-><AG::SWCFGNode.appendNewNode>
                                            (type => '#element',
                                             local_name => $name,
                                             value => $val);
              $current_element->{<Q::TreeCore:node>}
                              ->{<Q::namespaceExpanded>} = false
                unless $no_namespace;
              $current_element->{<Q::TreeCore:node>}
                              ->{<Q::etExpanded>} = false
                unless $no_binding;
              if (defined $2) {  ## Foo: bar
                $current = $root;
                $current_element = $root;
              } else {           ## Foo:\n  bar\n  baz
                $current = $current_element;
                $is_new_element = 1;
              }
            } elsif ($line =~ /^\s+(\@+)(.*):\s*([^\s:][^:]*)?$/) {
              my ($nest, $name, $val) = (length $1, $2, $3);
              substr ($name, 0, 1) = '' if defined $name and 
                                           substr ($name, 0, 1) eq '\\';
              substr ($val, 0, 1) = '' if defined $val and
                                          substr ($val, 0, 1) eq '\\';
              if (substr ($name, -6) eq '[list]') {
                substr ($name, -6) = '';
                $val = (defined ($val) and length ($val)) ? [$val] : [];
                $is_list_element = 1;
              } else {
                $is_list_element = 0;
              }
              my $ce;
              if (length ($name)) {
                while ($current_element-><M::SWCFGNode.flag>
                                                   ('p__nest_level' => null,
                                                    default => 0) >= $nest) {
                  $current_element
                       = $current_element-><AG::SWCFGNode.parentNode>;
                }
                $ce = $current_element-><AG::SWCFGNode.appendNewNode>
                                           (type => '#element',
                                            local_name => $name,
                                            value => $val);
                $ce->{<Q::TreeCore:node>}
                              ->{<Q::namespaceExpanded>} = false
                  unless $no_namespace;
                $ce->{<Q::TreeCore:node>}
                              ->{<Q::etExpanded>} = false
                  unless $no_binding;
                $ce-><M::SWCFGNode.flag> ('p__nest_level'
                      => $current_element-><M::SWCFGNode.flag>
                                             ('p__nest_level' => null,
                                              default => 0) + 1);
                unless (defined $3) {  ##  @foo: \nbar
                  $current_element = $ce;
                  $current = $ce;
                  $is_new_element = 1;
                }
              } else {  ## @@:
                while ($current_element-><M::SWCFGNode.flag>
                                           ('p__nest_level' => null,
                                            default => 0) >= $nest - 1) {
                  $current_element
                            = $current_element-><AG::SWCFGNode.parentNode>;
                }
                if (defined $val) {
                  if (defined $current_element->{<Q::TreeCore:node>}
                                              ->{<Q::value>}) {
                    if (ref $current_element->{<Q::TreeCore:node>}->{<Q::value>}
                          eq 'ARRAY') {
                      push @{$current_element->{<Q::TreeCore:node>}
                                             ->{<Q::value>}}, $val;
                    } else {
                      $current_element->{<Q::TreeCore:node>}
                                             ->{<Q::value>} .= $val;
                    }
                  } else {
                    $current_element->{<Q::TreeCore:node>}->{<Q::value>} = $val;
                  }
                }
                $current = $current_element;
                unless (defined $3) {  ##  @@: \nbar
                  $is_new_element = 1;
                }
              }
            } elsif ($line =~ /^(\s+)(\S.*)$/) {
              my ($wsp, $val) = ($1, $2);
              if (substr ($val, 0, 1) eq '#' and
                  not $is_new_element and
                  length $wsp < $wsp_length) {  ## Not part of element
                $current = $root-><M::SWCFGNode.appendNewNode>
                                         (type => '#comment',
                                          value => substr ($val, 1));
              } else {
                if (substr ($val, 0, 1) eq '\\') {
                  substr ($val, 0, 1) = '';
                  $wsp = '';
                }
                if ($is_new_element or $is_list_element) {
                  $wsp_length = length $wsp;
                    if (defined $current_element->{<Q::TreeCore:node>}
                                                ->{<Q::value>}) {
                      if (ref $current_element->{<Q::TreeCore:node>}
                                              ->{<Q::value>} eq 'ARRAY') {
                        push @{$current_element->{<Q::TreeCore:node>}
                                               ->{<Q::value>}}, $val;
                      } else {
                        $current_element->{<Q::TreeCore:node>}
                                               ->{<Q::value>} .= $val;
                      }
                    } else {
                      $current_element->{<Q::TreeCore:node>}
                                      ->{<Q::value>} = $val;
                    }
                  $is_new_element = 0;
                  $vfragment = '';
                } else {
                  $wsp = $no_preserve_wsp ? '' : substr ($wsp, $wsp_length);
                  $val = $vfragment . "\x0A" . $wsp . $val;
                    if (defined $current_element->{<Q::TreeCore:node>}
                                                ->{<Q::value>}) {
                      if (ref $current_element->{<Q::TreeCore:node>}
                                              ->{<Q::value>} eq 'ARRAY') {
                        push @{$current_element->{<Q::TreeCore:node>}
                                               ->{<Q::value>}}, $val;
                      } else {
                        $current_element->{<Q::TreeCore:node>}
                                             ->{<Q::value>} .= $val;
                      }
                    } else {
                      $current_element->{<Q::TreeCore:node>}
                                             ->{<Q::value>} = $val;
                    }
                  $vfragment = '';
                }
              }
            } elsif ($line =~ /^(\s*)$/) {
              $vfragment .= "\x0A" . substr ($1, $wsp_length)
                   unless $no_preserve_wsp;
              $current = $root
                   if $current-><AG::SWCFGNode.nodeType> eq '#comment';
            } else { $line =~ /^\#?(.*)$/;
            #} elsif ($line =~ /^\#(.*)$/) {
              my ($v) = ($1);
              if ($current-><AG::SWCFGNode.nodeType> eq '#comment') {
                $current-><M::SWCFGNode.appendText> ("\x0A" . $v);
              } else {
                $current = $root-><M::SWCFGNode.appendNewNode>
                                         (type => '#comment', value => $v);
              }
            #} else {
            #  $current = $root;
            #  #print STDERR qq(**$line**\n); 
            }
          }
          unless ($no_namespace and $no_binding) {
            my @remove;
            for my $i (0..$#{$root->{<Q::TreeCore:node>}->{<Q::childNodes>}}) {
              my $n = $root->{<Q::TreeCore:node>}->{<Q::childNodes>}->[$i];
              next unless $n->{<Q::nodeType>} eq '#element';
              if (not $no_namespace and $n->{<Q::localName>} eq 'Namespace') {
                for my $cn (@{$n->{<Q::childNodes>}}) {
                  next unless $cn->{<Q::nodeType>} eq '#element';
                  if ($cn->{<Q::value>}) {
                    $root->{<Q::TreeCore:node>}->{<Q::nsBinding>}
                         ->{$cn->{<Q::localName>}} = $cn->{<Q::value>};
                  } else {
                    ISNULL: {
                      for my $in (@{$cn->{<Q::childNodes>}}) {
                        if ($in->{<Q::nodeType>} eq '#element' and
                            $in->{<Q::localName>} eq 'is-null' and
                            $in->{<Q::value>}) {
                          $root->{<Q::TreeCore:node>}->{<Q::nsBinding>}
                               ->{$cn->{<Q::localName>}} = undef;
                          last ISNULL;
                        }
                      }
                      $root->{<Q::TreeCore:node>}->{<Q::nsBinding>}
                           ->{$cn->{<Q::localName>}} = $cn->{<Q::value>};
                    } # ISNULL
                  }
                }
                ## TODO: DOM error if unknown node
                push @remove, $i;
              } elsif (not $no_binding and
                       $n->{<Q::localName>} eq 'ElementTypeBinding') {
                my ($et, $sn, $sc, $ss) = ('', '');
                for my $cn (@{$n->{<Q::childNodes>}}) {
                  next unless $cn->{<Q::nodeType>} eq '#element';
                  if ($cn->{<Q::localName>} eq 'Name') {
                    $et = $cn->{<Q::value>} if defined $cn->{<Q::value>};
                  } elsif ($cn->{<Q::localName>} eq 'ElementType') {
                    $sn = $cn->{<Q::value>} if defined $cn->{<Q::value>};
                  } elsif ($cn->{<Q::localName>} eq 'ShadowContent') {
                    $sc = $cn;
                    $sc->{<Q::nodeType>} = '#fragment';
                    $sc->{<Q::parent>} = null;
                    $sc->{<Q::isShadowMaster>} = true;
                    $sc->{<Q::shadowOwner>} = $root->{<Q::TreeCore:node>};
                    $sc->{<Q::namespaceExpanded>} = true;
                    $sc->{<Q::etExpanded>} = true;
                    push @{$sc->{<Q::TreeCore:origin>}}, <Q::shadowOwner>, 
                             <Q::shadowParent>, <Q::shadowSiblingOf>;
                  } elsif ($cn->{<Q::localName>} eq 'ShadowSibling') {
                    $ss = $cn;
                    $ss->{<Q::nodeType>} = '#fragment';
                    $ss->{<Q::parent>} = null;
                    $ss->{<Q::isShadowMaster>} = true;
                    $ss->{<Q::shadowOwner>} = $root->{<Q::TreeCore:node>};
                    $ss->{<Q::namespaceExpanded>} = true;
                    $ss->{<Q::etExpanded>} = true;
                    push @{$ss->{<Q::TreeCore:origin>}}, <Q::shadowOwner>,
                             <Q::shadowParent>, <Q::shadowSiblingOf>;
                  }
                }
                $n->{<Q::childNodes>} = [];
                unless (defined $root->{<Q::TreeCore:node>}
                                     ->{<Q::etBinding>}->{$et}) {
                  $root->{<Q::TreeCore:node>}
                       ->{<Q::etBinding>}->{$et} = {
                    elementType => $et,
                    shadowLocalName => $sn,
                    namespaceExpanded => false,
                    shadowContent => $sc,
                    shadowSibling => $ss,
                  };
                }
                ## TODO: DOM error if unknown node
                push @remove, $i;
              }
            } # $i
            for my $i (reverse @remove) {
              splice @{$root->{<Q::TreeCore:node>}->{<Q::childNodes>}},
                     $i, 1, ();
            }
          }
          $r = $root;

  @IntMethod:
    @@Operator:
      @@@@:
        ManakaiDOM:MUErrorHandler
      @@@ContentType:
        dis:TypeQName
    @@Description:
      @@@lang:en
      @@@@:
        This method is a generic error handler; all manakai exceptions 
        and warnings associated to an object are once reported to this method 
        and then delivered to appropriate entities. 
        \
        If the error is an exception (such as <X::DOMCore:DOMException> or 
        <X::ManakaiDOM:ManakaiDOMImplementationException>), it is 
        simply thrown.  If the error is only a warning, it is reported 
        via the <IF::DOMCore:DOMError> interface. 
        \
        See <PerlModule::Message::Util::Error> documentation for more 
        information on the error reporting mechanism.
        \
        {NOTE:: This kind of methods are named as <Perl::___report_error> 
                in the convention of <PerlModule::Message::Util::Error>. 
        \
        }
    @@Param:
      @@@Name:err
      @@@Type: 
        ManakaiDOM:ManakaiDOMExceptionOrWarning::ManakaiDOM:Perl
      @@@Description:
        @@@@lang:en
        @@@@@:
          An exception object that describes what kind of error it is 
          and how it should be recovered. 
          \
          {NOTE:: Exception objects in manakai implementation 
                  inherit the class <PerlModule::Message::Util::Error>, 
                  that in turn inherits <PerlModule::Error>.
          \
          }
    @@Return:
      @@@PerlDef:
          if ($err->isa (<ClassName::ManakaiDOM:ManakaiDOMException
                                   ::ManakaiDOM:Perl>)) {
            $err->throw;
          } else {
            \## TODO: Implement warning reporting
            warn $err->stringify;
          }

## -- Bootstraps

IFClassDef:
  @IFQName: SWCFGImplementation
  @ClassQName: ManakaiSWCFGImplementation
  @Description:
    @@lang:en
    @@@:
      This interface allows applications to retrieve an instance of 
      <IF::SWCFGParser>. 
  @ImplNote:
    @@lang:en
    @@@:
      This interface should be implemented on the same object that 
      implements <IF::DOMImplementation>. 

  @Role:
    @@@:
      DOMCore:DOMImplementation::ManakaiDOM:ManakaiDOM
    @@compat:
      DOMCore:ManakaiDOMImplementation::ManakaiDOM:ManakaiDOMLatest
    @@ForCheck: ForClass

  # recognizedVersions : StringList
  
  @Method:
    @@Name: createSWCFGDocument
    @@Description:
      @@@lang:en
      @@@@:
        Creates an empty <IF::SWCFGDocument> object. 
    @@NewIn21:
    @@Param:
      @@@Name:version
      @@@Type:SWCFGString
      @@@Description:
        @@@@lang:en
        @@@@@:
          The version of the SuikaWikiConfig format.  Currently 
          only the version <CODE::2.1> is supported. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Type:SWCFGString
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The latest version of the SuikaWikiConfig that the implementation 
            supports is selected. 
    @@Return:
      @@@Type:SWCFGDocument
      @@@actualType:ManakaiSWCFGDocument
      @@@Description:
        @@@@lang:en
        @@@@@:The newly created SuikaWikiConfig document object.
      @@@RaiseException:
        @@@@@:SWCFG_VERSION_NOT_SUPPORTED_ERR
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The <P::version> is not supported. 
      @@@PerlDef:
        if (defined $version and $version ne '2.1') {
          __EXCEPTION{SWCFG_VERSION_NOT_SUPPORTED_ERR::
            swcfg21:version => {$version},
          }__;
        }
        $r = <ClassM::ManakaiSWCFGDocument.newObject>;
        $r->{<Q::DOMCore:implementation>} = $self;
        $r->{<Q::version>} = $version || '2.1';
        $r = <ClassM::ManakaiSWCFGNode.getNodeReference> ($r);
    
  @Method:
    @@Name: createSWCFGParser
    @@Description:
      @@@lang:en
      @@@@:
        Creates a new <IF::SWCFGParser>. 
    @@NewIn21:
    @@Param:
      @@@Name:versions
      @@@Type:any
      @@@Description:
        @@@@lang:en
        @@@@@:
          Future version of this implementation will allow 
          a list containing the versions of SuikaWikiConfig documents 
          that can be loaded by the <IF::SWCFGParser> created. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Type:SWCFGString
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            Permits SuikaWikiConfig documents of any recognized 
            version to be loaded by the <IF::SWCFGParser>. 
    @@Return:
      @@@Type: SWCFGParser
      @@@Description:
        @@@@lang:en
        @@@@@:
          The newly created <IF::SWCFGParser>. 
      @@@RaiseException:
        @@@@@: SWCFG_VERSION_NOT_SUPPORTED_ERR
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The implementation does not support one of the specified 
            version. 
      @@@PerlDef:
        ## TODO: Support $versions
        if (defined $versions) {
          __EXCEPTION{SWCFG_VERSION_NOT_SUPPORTED_ERR}__;
        }
        $r = bless {<Q::DOMCore:implementation> => $self},
                   <ClassName::ManakaiSWCFGParser>;

## -- lang:dis vocabulary

TreeElementType:
  @QName: GetPropNode
  @dataType:
    dis:TypeQName
  @rdfs:range:
    rdf:Property
  @Description:
    @@lang:en
    @@@:
      Gets the nodal value of a <Class::ManakaiDOM:ManakaiDOMNodeReference> 
      property (actually <Class::ManakaiDOM:ManakaiDOMNodeObject> property). 

## -- Syntax sugar

ElementTypeBinding:
  @Name: PropDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      rdf:Property
    @@AliasFor:
      @@@@:
        ::ManakaiDOM:all
      @@@For:
        !=ManakaiDOM:all

ElementTypeBinding:
  @Name: IFClassDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      @@@@:
        dis:MultipleResource
      @@@ForCheck: !ForClass !ForIF
    @@rdf:type:
      @@@@:
        ManakaiDOM:IF
      @@@ForCheck: ForIF
    @@rdf:type:
      @@@@:
        ManakaiDOM:Class
      @@@ForCheck: ForClass
    @@resourceFor: ForIF
    @@resourceFor:
      @@@@: ForClass
      @@@ForCheck: ForLatest
    @@DOMMain:implementFeature:
      @@@@:CoreFeature21
      @@@ForCheck: ForClass

ElementTypeBinding:
  @Name: IFQName
  @ElementType:
    dis:QName
  @ShadowContent:
    @@ForCheck: ForIF

ElementTypeBinding:
  @Name: ClassQName
  @ElementType:
    dis:QName
  @ShadowContent:
    @@ForCheck: ForClass

ElementTypeBinding:
  @Name: IFISA
  @ElementType:
    dis:ISA
  @ShadowContent:
    @@ForCheck: ForIF

ElementTypeBinding:
  @Name: ClassISA
  @ElementType:
    dis:ISA
  @ShadowContent:
    @@ForCheck: ForClass

ElementTypeBinding:
  @Name: Method
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:Method

ElementTypeBinding:
  @Name: IntMethod
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:Method
    @@ManakaiDOM:isForInternal:1

ElementTypeBinding:
  @Name: RedefMethod
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:Method
    @@ManakaiDOM:isRedefining:1

ElementTypeBinding:
  @Name: Return
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:MethodReturn

ElementTypeBinding:
  @Name: Param
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:MethodParameter

ElementTypeBinding:
  @Name: NamedParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:MethodParameter
    @@DISPerl:isNamedParameter:1

ElementTypeBinding:
  @Name: MakeNewNodeParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:MethodParameter
    @@DISPerl:isNamedParameter:1
    @@Name:makeNewNode
    @@Type:
      DOMMain:boolean
    @@Description:
      @@@lang:en
      @@@@:
        Whether a new node should be made when one is not found. 
    @@ResourceDef:
      @@@rdf:type:
        ManakaiDOM:InCase
      @@@Value:true
      @@@Type:
        DOMMain:boolean
      @@@Description:
        @@@@lang:en
        @@@@@: A new node is created when no such node found. 
    @@ResourceDef:
      @@@rdf:type:
        ManakaiDOM:InCase
      @@@Value:false
      @@@Type:
        DOMMain:boolean
      @@@Description:
        @@@@lang:en
        @@@@@: A new node is not created even when no such node found. 

ElementTypeBinding:
  @Name: DefaultParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:MethodParameter
    @@DISPerl:isNamedParameter:1
    @@Name:default
    @@Type:
      DOMMain:any
    @@Description:
      @@@lang:en
      @@@@:
        Default value that is returned when no explicit value specification 
        found. 
    @@ResourceDef:
      @@@rdf:type:
        ManakaiDOM:InCase
      @@@Type:
        DOMMain:any
      @@@Value:
        @@@@is-null:1
      @@@Description:
        @@@@lang:en
        @@@@@: No default value. 

ElementTypeBinding:
  @Name: DefaultListParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:MethodParameter
    @@DISPerl:isNamedParameter:1
    @@Name:defaultList
    @@Type:
      DOMMain:any
    @@Description:
      @@@lang:en
      @@@@:
        Default list value that is returned when the value is of list 
        but there is <EM::zero> item found.  The <P::defaultList> value 
        should be an array reference for consistency. 
    @@ResourceDef:
      @@@rdf:type:
        ManakaiDOM:InCase
      @@@Value:
        @@@@is-null:1
      @@@Type:
        DOMMain:any
      @@@Description:
        @@@@lang:en
        @@@@@: No default list value. 

ElementTypeBinding:
  @Name: TypeParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:MethodParameter
    @@DISPerl:isNamedParameter:1
    @@Name:type
    @@Type:SWCFGString
    @@Description:
      @@@lang:en
      @@@@:
        Type of the node to create.  This parameter is <EM::required>. 
    @@ResourceDef:
      @@@rdf:type:
        ManakaiDOM:InCase
      @@@Value:\#comment
      @@@Type:SWCFGString
      @@@Description:
        @@@@lang:en
        @@@@@:Comment node.
    @@ResourceDef:
      @@@rdf:type:
        ManakaiDOM:InCase
      @@@Value:\#document
      @@@Type:SWCFGString
      @@@Description:
        @@@@lang:en
        @@@@@:Document node.
    @@ResourceDef:
      @@@rdf:type:
        ManakaiDOM:InCase
      @@@Value:\#element
      @@@Type:SWCFGString
      @@@Description:
        @@@@lang:en
        @@@@@:Element node.
    @@ResourceDef:
      @@@rdf:type:
        ManakaiDOM:InCase
      @@@Value:\#fragment
      @@@Type:SWCFGString
      @@@Description:
        @@@@lang:en
        @@@@@:Document fragment node.

ElementTypeBinding:
  @Name: LocalNameParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:MethodParameter
    @@DISPerl:isNamedParameter:1
    @@Name:localName
    @@Type:SWCFGString
    @@Description:
      @@@lang:en
      @@@@:
        The local name of the node to create.  This parameter is 
        <EM::required> when the node <P::type> is set to <CODE::#element>. 

ElementTypeBinding:
  @Name: NSURIParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:MethodParameter
    @@DISPerl:isNamedParameter:1
    @@Name:namespaceURI
    @@Type:SWCFGString
    @@Description:
      @@@lang:en
      @@@@:
        The namespace URI of the node to create.  This parameter should 
        be specified if and only if the node <P::type> is <CODE::#element>. 

ElementTypeBinding:
  @Name: ValueParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:MethodParameter
    @@DISPerl:isNamedParameter:1
    @@Name:value
    @@Type:SWCFGString
    @@Description:
      @@@lang:en
      @@@@:
        The value of the node to create.  This parameter should 
        only be specified for the node of <P::type> <CODE::#element> 
        or <CODE::#comment>. 
    @@ResourceDef:
      @@@rdf:type:
        ManakaiDOM:InCase
      @@@Value:
        @@@@is-null:1
      @@@Type:SWCFGString
      @@@Description:
        @@@@lang:en
        @@@@@:
          If the <P::type> is set to <CODE::#comment>, a <DOM::null> 
          value is equivalent to an empty string.  Otherwise, 
          the node created has no value. 

ElementTypeBinding:
  @Name: actualType
  @ElementType:
    dis:actualType
  @ShadowContent:
    @@ForCheck: ForClass

ElementTypeBinding:
  @Name: Attr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:Attribute

ElementTypeBinding:
  @Name: RedefAttr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:Attribute
    @@ManakaiDOM:isRedefining:1

ElementTypeBinding:
  @Name: Get
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:AttributeGet

ElementTypeBinding:
  @Name: Set
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:AttributeSet

ElementTypeBinding:
  @Name: InCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:InCase

ElementTypeBinding:
  @Name: disDef
  @ElementType:
    dis:Def
  @ShadowContent:
    @@ContentType:
      lang:dis

ElementTypeBinding:
  @Name: PerlDef
  @ElementType:
    dis:Def
  @ShadowContent:
    @@ContentType:
      lang:Perl

ElementTypeBinding:
  @Name: TreeElementType
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:TreeElementType
    @@AliasFor:
      @@@@:
        ::ManakaiDOM:all
      @@@For:
        !=ManakaiDOM:all

ElementTypeBinding:
  @Name: NSVariant
  @ElementType:
    swcfg21:namespaceAwareVariant
  @ShadowSibling:
    @@DISCore:isDeprecated:1

ElementTypeBinding:
  @Name: NonNSVariant
  @ElementType:
    swcfg21:namespaceUnawareVariant

ElementTypeBinding:
  @Name: NewIn21
  @ElementType:
    dis:Description
  @ShadowContent:
    @@lang:en
    @@@:
        {NOTE:: Introduced in SuikaWikiConfig/2.1 object model. 
        \
        }

ElementTypeBinding:
  @Name: ModIn21
  @ElementType:
    dis:Description
  @ShadowContent:
    @@lang:en
    @@@:
        {NOTE:: Modified in SuikaWikiConfig/2.1 object model. 
        \
        }

ElementTypeBinding:
  @Name: ExceptionDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      @@@@:
        dis:MultipleResource
      @@@ForCheck: !ForClass !ForIF
    @@rdf:type:
      @@@@:
        ManakaiDOM:ExceptionIF
      @@@ForCheck: ForIF
    @@rdf:type:
      @@@@:
        ManakaiDOM:ExceptionClass
      @@@ForCheck: ForClass
    @@resourceFor: ForIF
    @@resourceFor:
      @@@@: ForClass
      @@@ForCheck: ForLatest
    @@ISA:
      @@@@:
        DOMMain:ManakaiDOMExceptionIF::ManakaiDOM:Perl
      @@@ForCheck: ForIF
    @@ISA:
      @@@@:
        ManakaiDOM:ManakaiDOMException::ManakaiDOM:Perl
      @@@ForCheck: ForClass

ElementTypeBinding:
  @Name: RaiseException
  @ElementType:
    ManakaiDOM:raises

ElementTypeBinding:
  @Name: XConstGroupDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:ConstGroup

ElementTypeBinding:
  @Name: XConst
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:Const

ElementTypeBinding:
  @Name: XSubTypeDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:ExceptionOrWarningSubType
    @@ForCheck: ForClass

ElementTypeBinding:
  @Name: XParam
  @ElementType:
    ManakaiDOM:exceptionOrWarningParameter

ElementTypeBinding:
  @Name: XPropDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: 
      DOMMain:XWParameter
    @@AliasFor:
      @@@For:
        !=ManakaiDOM:all
      @@@@:
        ::ManakaiDOM:all

ElementTypeBinding:
  @Name: TypeDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:DataType
    @@AliasFor:
      @@@@:
        ::ManakaiDOM:all
      @@@For: 
        ManakaiDOM:all !=ManakaiDOM:all

ElementTypeBinding:
  @Name: ConstValue
  @ElementType:
    DISLang:value
  @ShadowContent:
    @@ContentType:
      DISCore:String

ElementTypeBinding:
  @Name: enMufDef
  @ElementType:
    dis:Def
  @ShadowContent:
    @@ContentType:
      lang:muf
    @@lang:en

## SuikaWikiConfig21.dis ends here
