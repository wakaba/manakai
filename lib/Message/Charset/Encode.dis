Module:
  @QName: MCharset|Encode
  @FullName:
    @@lang: en
    @@@: Manakai Charset Encode Module
  @Namespace:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Charset/Encode/
  
  @enDesc:
    The <DFN::manakai Charset Encode Module> is ...

    {TODO::
      This module is subject to change.
    }

  @DISCore:author: DISCore|Wakaba
  @License: license|Perl+MPL
  @Date:
    $Date: 2006/03/12 10:13:31 $
  
  @Require:
    @@Module:
      @@@QName: MDOM|DOMFeature
      @@@WithFor: ManakaiDOM|ManakaiDOMLatest
    @@Module:
      @@@WithFor: ManakaiDOM|ManakaiDOM
    @@Module:
      @@@QName: DISlib|Charset
      @@@WithFor: ManakaiDOM|all
  @DefaultFor: ManakaiDOM|ManakaiDOMLatest

Namespace:
  @cs:
    http://suika.fam.cx/~wakaba/archive/2004/dis/Charset/
  @dis:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#dis--
  @DISlib:
    http://suika.fam.cx/~wakaba/archive/2004/dis/
  @dx:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#
  @f:
    http://suika.fam.cx/~wakaba/archive/2004/dom/feature#
  @fe:
    http://suika.fam.cx/www/2006/feature/
  @icharset:
    urn:x-suika-fam-cx:charset:
  @idl:
    http://suika.fam.cx/~wakaba/archive/2004/dis/IDL#
  @kwd:
    http://suika.fam.cx/~wakaba/archive/2005/rfc2119/
  @lang:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#
  @license:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/license#
  @ManakaiDOM:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#
  @MCharset:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Charset/
  @mce:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Charset/Encode/
  @MDOM:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#ManakaiDOM.
  @mn:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/ManakaiNode#
  @rdf:
    http://www.w3.org/1999/02/22-rdf-syntax-ns#
  @rdfs:
    http://www.w3.org/2000/01/rdf-schema#
  @test:
    http://suika.fam.cx/~wakaba/archive/2004/dis/Test#
  @xml-auto-charset:
    http://suika.fam.cx/www/2006/03/xml-entity/

ResourceDef:
  @QName: MCharset|
  @rdf:type: dis|ModuleGroup
  @FullName:
    @@lang:en
    @@@:
      The manakai Charset modules
  @DISPerl:packageName:
    Message::Charset::
  @DISPerl:interfacePackageName:
    @@@:
      Message::Charset::IFLatest::
    @@For: ManakaiDOM|ManakaiDOMLatest
  @DISPerl:interfacePackageName:
    @@@:
      Message::Charset::IF::
    @@For: !ManakaiDOM|ManakaiDOMLatest

## -- Features

FeatureDef:
  @QName: MCEncodeFeature
  @featureQName: fe|MCEncode
  @FeatureVerDef:
    @@QName: MCEncodeFeature10
    @@f:instanceOf: MCEncodeFeature
    @@Version: 1.0
    @@enDesc:
      The manakai Charset Encode Module, version 1.0

ElementTypeBinding:
  @Name: FeatureDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: f|Feature
    @@For: =ManakaiDOM|all

ElementTypeBinding:
  @Name: FeatureVerDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: f|Feature

ElementTypeBinding:
  @Name: featureQName
  @ElementType:
    f:name
  @ShadowContent:
    @@ContentType: DISCore|QName

ElementTypeBinding:
  @Name: IFQName
  @ElementType:
    dis:QName
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForIF

ElementTypeBinding:
  @Name: ClsQName
  @ElementType:
    dis:QName
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: IFISA
  @ElementType:
    dis:ISA
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForIF

ElementTypeBinding:
  @Name: ClsISA
  @ElementType:
    dis:ISA
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: IFClsDef
  @ElementType: 
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      @@@@: dis|MultipleResource
      @@@ForCheck: !ManakaiDOM|ForIF !ManakaiDOM|ForClass
    @@resourceFor: ManakaiDOM|ForIF
    @@resourceFor:
      @@@@: ManakaiDOM|ForClass
      @@@ForCheck: ManakaiDOM|ManakaiDOMLatest !=ManakaiDOM|ManakaiDOM
    @@For: ManakaiDOM|ManakaiDOMLatest
    @@For: =ManakaiDOM|ManakaiDOM

    @@rdf:type:
      @@@@: DISLang|Interface
      @@@ForCheck: ManakaiDOM|ForIF

    @@rdf:type:
      @@@@: DISLang|Class
      @@@ForCheck: ManakaiDOM|ForClass
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOM||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOMLatest||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOMLatest

    @@f:implements:
      @@@@: MCEncodeFeature10
      @@@For: ManakaiDOM|ManakaiDOMLatest

ElementTypeBinding:
  @Name: ClsDef
  @ElementType: 
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      @@@@: dis|MultipleResource
      @@@ForCheck: !ManakaiDOM|ForIF !ManakaiDOM|ForClass
    @@resourceFor:
      @@@@: ManakaiDOM|ForClass
      @@@ForCheck: ManakaiDOM|ManakaiDOMLatest
    @@For: ManakaiDOM|ManakaiDOMLatest

    @@rdf:type:
      @@@@: DISLang|Class
      @@@ForCheck: ManakaiDOM|ForClass

    @@f:implements:
      @@@@: MCEncodeFeature10
      @@@For: ManakaiDOM|ManakaiDOMLatest

ElementTypeBinding:
  @Name: Method
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Method
    @@ForCheck: !=ManakaiDOM|ManakaiDOM

ElementTypeBinding:
  @Name: IntMethod
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Method
    @@ForCheck: !=ManakaiDOM|ManakaiDOM ManakaiDOM|ForClass
    @@ManakaiDOM:isForInternal: 1

ElementTypeBinding:
  @Name: Param
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|MethodParameter

ElementTypeBinding:
  @Name: NamedParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|MethodParameter
    @@DISPerl:isNamedParameter: 1

ElementTypeBinding:
  @Name: Return
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|MethodReturn

ElementTypeBinding:
  @Name: Attr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|Attribute
    @@ForCheck: !=ManakaiDOM|ManakaiDOM

ElementTypeBinding:
  @Name: Get
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|AttributeGet

ElementTypeBinding:
  @Name: Set
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|AttributeSet

ElementTypeBinding:
  @Name: InCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: ManakaiDOM|InCase

ElementTypeBinding:
  @Name: PerlDef
  @ElementType:
    dis:Def
  @ShadowContent:
    @@ContentType:
      lang:Perl
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: Test
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: test|StandaloneTest
    @@ForCheck: ManakaiDOM|ForClass
  
ElementTypeBinding:
  @Name: enDesc
  @ElementType:
    dis:Description
  @ShadowContent:
    @@lang:en

ElementTypeBinding:
  @Name: enImplNote
  @ElementType:
    dis:ImplNote
  @ShadowContent:
    @@lang:en

ElementTypeBinding:
  @Name: enFN
  @ElementType:
    dis:FullName
  @ShadowContent:
    @@lang:en

## -- Implementation

IFClsDef:
  @IFQName: MCEncodeImplementation
  @ClsQName: ManakaiMCEncodeImplementation

  @IFISA: f|MinimumImplementation
  @ClsISA: f|ManakaiMinimumImplementation

  @enDesc:
    The <IF::MCEncodeImplementation> interface provides
    factory methods to create <IF::MCEncodeHandle> objects.

  @f:provides: MCEncodeFeature10

  @Test:
    @@enDesc:
      The implementation registry should know this class when the
      module is loaded.
    @@PerlDef:
      I: {
        for my $impl (@{$Message::DOM::ImplementationRegistry
                              ->get_implementation_list
                                  ({<Q::fe|MCEncode> => '1.0'})}) {
          if ($impl->isa (<IFName::MCEncodeImplementation>)) {
            last I;
          }
        }
        $test->assert_never;
      } # I

  @Method:
    @@Name: createMCDecodeHandle
    @@enDesc:
      Creates an <IF::MCDecodeHandle> object.
    @@Param:
      @@@Name: charset
      @@@Type: String
      @@@enDesc:
        The URI that identifies the charset
        in which strings are written to the <P::byteStream>.
    @@Param:
      @@@Name: byteStream
      @@@Type: DISPerl|Filehandle||ManakaiDOM|all
      @@@enDesc:
        A reference to the filehandle that contains the byte 
        stream read by the <IF::MCDecodeHandle> object.
    @@Param:
      @@@Name: onerror
      @@@Type: DISPerl|CODE||ManakaiDOM|all
      @@@enDesc:
        A subroutine that is called back when an error is encountered.
        The <A::MCDecodeHandle.onerror> attribute of the
        created object is set to this parameter value.
      @@@nullCase:
        @@@@enDesc:
          The <A::MCDecodeHandle.onerror> attribute is set to
          a do-nothing subroutine.
    @@Return:
      @@@Type: MCDecodeHandle
      @@@enDesc:
        The newly created filehandle object.
      @@@nullCase:
        @@@@enDesc:
          If the implementation does not support <P::charset>.
      @@@PerlDef:
        my $csdef = $Message::Charset::Encode::CharsetDef->{$charset};
        my $obj = {<H::mce|filehandle> => $byteStream,
                   <H::mce|charset> => $charset,
                   <H::mce|characterQueue> => [],
                   <H::mce|byteBuffer> => '',
                   <H::mce|onerror> => $onerror || sub {}};
        if ($csdef->{uri}->{<Q::xml-auto-charset:>} or
            $charset eq <Q::xml-auto-charset:>) {
          __DEEP{
            my $b = '';
            $csdef = $Message::Charset::Encode::CharsetDef
                         ->{<Q::cs|Perl.utf-8>}; # UTF-8 with no BOM
            $obj->{<H::mce|inputEncoding>} = 'utf-8';
            if (read $obj->{<H::mce|filehandle>}, $b, 256) {
              no warnings "substr";
              no warnings "uninitialized";
              if (substr ($b, 0, 1) eq "<") {
                if (substr ($b, 1, 1) eq "?") { # ASCII8
                  __CODE{XMLEntity.guess::
                    $ascii => $b,
                    $errorCondition => {
                      not $csdef->{<H::cs|ASCII8>} or
                      $csdef->{<H::cs|BOM.Required>}
                    },
                    $defaultURI => {<Q::cs|Perl.utf-8>},
                    $defaultName => 'utf-8',
                    $restoreBOM => {},
                  }__;
                  if (defined $csdef->{<H::cs|noBOMVariant>}) {
                    $csdef = $Message::Charset::Encode::CharsetDef
                               ->{$csdef->{<H::cs|noBOMVariant>}};
                  }
                } elsif (substr ($b, 1, 1) eq "\x00") {
                  if (substr ($b, 2, 2) eq "?\x00") { # ASCII16LE
                    my $c = $b; $c =~ tr/\x00//d;
                    __CODE{XMLEntity.guess::
                      $ascii => $c,
                      $errorCondition => {
                        not $csdef->{<H::cs|ASCII16>} or
                        $csdef->{<H::cs|ASCII16BE>} or
                        $csdef->{<H::cs|BOM.Required>}
                      },
                      $defaultURI => {<Q::cs|Perl.utf-8>},
                      $defaultName => 'utf-8',
                      $restoreBOM => {},
                    }__;
                    if (defined $csdef->{<H::cs|noBOMVariant16LE>}) {
                      $csdef = $Message::Charset::Encode::CharsetDef
                                 ->{$csdef->{<H::cs|noBOMVariant16LE>}};
                    }
                  } elsif (substr ($b, 2, 2) eq "\x00\x00") { # ASCII32Endian4321
                    my $c = $b; $c =~ tr/\x00//d;
                    __CODE{XMLEntity.guess::
                      $ascii => $c,
                      $errorCondition => {
                        not $csdef->{<H::cs|ASCII32>} or
                        $csdef->{<H::cs|ASCII32Endian1234>} or
                        $csdef->{<H::cs|ASCII32Endian2143>} or
                        $csdef->{<H::cs|ASCII32Endian3412>} or
                        $csdef->{<H::cs|BOM.Required>}
                      },
                      $defaultURI => {<Q::cs|Perl.utf-8>},
                      $defaultName => 'utf-8',
                      $restoreBOM => {},
                    }__;
                    if (defined $csdef->{<H::cs|noBOMVariant32Endian4321>}) {
                      $csdef = $Message::Charset::Encode::CharsetDef
                                 ->{$csdef->{<H::cs|noBOMVariant32Endian4321>}};
                    }
                  }
                }
              } elsif (substr ($b, 0, 3) eq "\xEF\xBB\xBF") { # UTF8
                $obj->{<H::mce|hasBOM>} = true;
                substr ($b, 0, 3) = '';
                my $c = $b;
                __CODE{XMLEntity.guess::
                  $ascii => $c,
                  $errorCondition => {
                    not $csdef->{<H::cs|UTF8EncodingScheme>} or
                    not $csdef->{<H::cs|BOM.Allowed>}
                  },
                  $defaultURI => {<Q::cs|Perl.utf-8>},
                  $defaultName => 'utf-8',
                  $restoreBOM => {},
                }__;
                if (defined $csdef->{<H::cs|noBOMVariant>}) {
                  $csdef = $Message::Charset::Encode::CharsetDef
                             ->{$csdef->{<H::cs|noBOMVariant>}};
                }
              } elsif (substr ($b, 0, 2) eq "\x00<") {
                if (substr ($b, 2, 2) eq "\x00?") { # ASCII16BE
                  my $c = $b; $c =~ tr/\x00//d;
                  __CODE{XMLEntity.guess::
                    $ascii => $c,
                    $errorCondition => {
                      not $csdef->{<H::cs|ASCII16>} or
                      $csdef->{<H::cs|ASCII16LE>} or
                      $csdef->{<H::cs|BOM.Required>}
                    },
                    $defaultURI => {<Q::cs|Perl.utf-8>},
                    $defaultName => 'utf-8',
                    $restoreBOM => {},
                  }__;
                  if (defined $csdef->{<H::cs|noBOMVariant16BE>}) {
                    $csdef = $Message::Charset::Encode::CharsetDef
                               ->{$csdef->{<H::cs|noBOMVariant16BE>}};
                  }
                } elsif (substr ($b, 2, 2) eq "\x00\x00") { # ASCII32Endian3412
                  my $c = $b; $c =~ tr/\x00//d;
                  __CODE{XMLEntity.guess::
                    $ascii => $c,
                    $errorCondition => {
                      not $csdef->{<H::cs|ASCII32>} or
                      $csdef->{<H::cs|ASCII32Endian1234>} or
                      $csdef->{<H::cs|ASCII32Endian2143>} or
                      $csdef->{<H::cs|ASCII32Endian4321>} or
                      $csdef->{<H::cs|BOM.Required>}
                    },
                    $defaultURI => {<Q::cs|Perl.utf-8>},
                    $defaultName => 'utf-8',
                    $restoreBOM => {},
                  }__;
                  if (defined $csdef->{<H::cs|noBOMVariant32Endian3412>}) {
                    $csdef = $Message::Charset::Encode::CharsetDef
                               ->{$csdef->{<H::cs|noBOMVariant32Endian3412>}};
                  }
                }
              } elsif (substr ($b, 0, 2) eq "\xFE\xFF") {
                if (substr ($b, 2, 2) eq "\x00<") { # ASCII16BE
                  $obj->{<H::mce|hasBOM>} = true;
                  substr ($b, 0, 2) = '';
                  my $c = $b; $c =~ tr/\x00//d;
                  __CODE{XMLEntity.guess::
                    $ascii => $c,
                    $errorCondition => {
                      not $csdef->{<H::cs|ASCII16>} or
                      $csdef->{<H::cs|ASCII16LE>} or
                      not $csdef->{<H::cs|BOM.Allowed>}
                    },
                    $defaultURI => {<Q::cs|Perl.utf-16be>},
                    $defaultName => 'utf-16',
                    $restoreBOM => {},
                  }__;
                  if (defined $csdef->{<H::cs|noBOMVariant16BE>}) {
                    $csdef = $Message::Charset::Encode::CharsetDef
                               ->{$csdef->{<H::cs|noBOMVariant16BE>}};
                  }
                } elsif (substr ($b, 2, 2) eq "\x00\x00") { # ASCII32Endian3412
                  $obj->{<H::mce|hasBOM>} = true;
                  substr ($b, 0, 4) = '';
                  my $c = $b; $c =~ tr/\x00//d;
                  __CODE{XMLEntity.guess::
                    $ascii => $c,
                    $errorCondition => {
                      not $csdef->{<H::cs|ASCII32>} or
                      $csdef->{<H::cs|ASCII32Endian1234>} or
                      $csdef->{<H::cs|ASCII32Endian2143>} or
                      $csdef->{<H::cs|ASCII32Endian4321>} or
                      not $csdef->{<H::cs|BOM.Allowed>}
                    },
                    $defaultURI => {<Q::cs|Perl.utf-16be>},
                    $defaultName => 'utf-16',
                    $restoreBOM => {
                      $obj->{<H::mce|byteBuffer>} .= "\x00\x00";
                    },
                  }__;
                  if (defined $csdef->{<H::cs|noBOMVariant32Endian3412>}) {
                    $csdef = $Message::Charset::Encode::CharsetDef
                               ->{$csdef->{<H::cs|noBOMVariant32Endian3412>}};
                  }
                } else {
                  $csdef = $Message::Charset::Encode::CharsetDef
                             ->{<Q::cs|Perl.utf-16be>};
                  $obj->{<H::mce|inputEncoding>} = 'utf-16';
                  substr ($b, 0, 2) = '';
                  $obj->{<H::mce|hasBOM>} = true;
                }
              } elsif (substr ($b, 0, 2) eq "\xFF\xFE") {
                if (substr ($b, 2, 2) eq "<\x00") { # ASCII16LE
                  $obj->{<H::mce|hasBOM>} = true;
                  substr ($b, 0, 2) = '';
                  my $c = $b; $c =~ tr/\x00//d;
                  __CODE{XMLEntity.guess::
                    $ascii => $c,
                    $errorCondition => {
                      not $csdef->{<H::cs|ASCII16>} or
                      $csdef->{<H::cs|ASCII16BE>} or
                      not $csdef->{<H::cs|BOM.Allowed>}
                    },
                    $defaultURI => {<Q::cs|Perl.utf-16le>},
                    $defaultName => 'utf-16',
                    $restoreBOM => {},
                  }__;
                  if (defined $csdef->{<H::cs|noBOMVariant16LE>}) {
                    $csdef = $Message::Charset::Encode::CharsetDef
                               ->{$csdef->{<H::cs|noBOMVariant16LE>}};
                  }
                } elsif (substr ($b, 2, 2) eq "\x00\x00") { # ASCII32Endian4321
                  $obj->{<H::mce|hasBOM>} = true;
                  substr ($b, 0, 4) = '';
                  my $c = $b; $c =~ tr/\x00//d;
                  __CODE{XMLEntity.guess::
                    $ascii => $c,
                    $errorCondition => {
                      not $csdef->{<H::cs|ASCII32>} or
                      $csdef->{<H::cs|ASCII32Endian1234>} or
                      $csdef->{<H::cs|ASCII32Endian2143>} or
                      $csdef->{<H::cs|ASCII32Endian3412>} or
                      not $csdef->{<H::cs|BOM.Allowed>}
                    },
                    $defaultURI => {<Q::cs|Perl.utf-16le>},
                    $defaultName => 'utf-16',
                    $restoreBOM => {
                      $obj->{<H::mce|byteBuffer>} .= "\x00\x00";
                    },
                  }__;
                  if (defined $csdef->{<H::cs|noBOMVariant32Endian4321>}) {
                    $csdef = $Message::Charset::Encode::CharsetDef
                               ->{$csdef->{<H::cs|noBOMVariant32Endian4321>}};
                  }
                } else {
                  $csdef = $Message::Charset::Encode::CharsetDef
                             ->{<Q::cs|Perl.utf-16le>};
                  $obj->{<H::mce|inputEncoding>} = 'utf-16';
                  substr ($b, 0, 2) = '';
                  $obj->{<H::mce|hasBOM>} = true;
                }
              } elsif (substr ($b, 0, 2) eq "\x00\x00") {
                if (substr ($b, 2, 2) eq "\x00<") { # ASCII32Endian1234
                  my $c = $b; $c =~ tr/\x00//d;
                  __CODE{XMLEntity.guess::
                    $ascii => $c,
                    $errorCondition => {
                      not $csdef->{<H::cs|ASCII32>} or
                      $csdef->{<H::cs|ASCII32Endian2143>} or
                      $csdef->{<H::cs|ASCII32Endian3412>} or
                      $csdef->{<H::cs|ASCII32Endian4321>} or
                      $csdef->{<H::cs|BOM.Required>}
                    },
                    $defaultURI => {<Q::cs|Perl.utf-8>},
                    $defaultName => 'utf-8',
                    $restoreBOM => {},
                  }__;
                  if (defined $csdef->{<H::cs|noBOMVariant32Endian1234>}) {
                    $csdef = $Message::Charset::Encode::CharsetDef
                               ->{$csdef->{<H::cs|noBOMVariant32Endian1234>}};
                  }
                } elsif (substr ($b, 2, 2) eq "<\x00") { # ASCII32Endian2143
                  my $c = $b; $c =~ tr/\x00//d;
                  __CODE{XMLEntity.guess::
                    $ascii => $c,
                    $errorCondition => {
                      not $csdef->{<H::cs|ASCII32>} or
                      $csdef->{<H::cs|ASCII32Endian1234>} or
                      $csdef->{<H::cs|ASCII32Endian3412>} or
                      $csdef->{<H::cs|ASCII32Endian4321>} or
                      $csdef->{<H::cs|BOM.Required>}
                    },
                    $defaultURI => {<Q::cs|Perl.utf-8>},
                    $defaultName => 'utf-8',
                    $restoreBOM => {},
                  }__;
                  if (defined $csdef->{<H::cs|noBOMVariant32Endian2143>}) {
                    $csdef = $Message::Charset::Encode::CharsetDef
                               ->{$csdef->{<H::cs|noBOMVariant32Endian2143>}};
                  }
                } elsif (substr ($b, 2, 2) eq "\xFE\xFF") { # ASCII32Endian1234
                  $obj->{<H::mce|hasBOM>} = true;
                  substr ($b, 0, 4) = '';
                  my $c = $b; $c =~ tr/\x00//d;
                  __CODE{XMLEntity.guess::
                    $ascii => $c,
                    $errorCondition => {
                      not $csdef->{<H::cs|ASCII32>} or
                      $csdef->{<H::cs|ASCII32Endian2143>} or
                      $csdef->{<H::cs|ASCII32Endian3412>} or
                      $csdef->{<H::cs|ASCII32Endian4321>} or
                      $csdef->{<H::cs|BOM.Required>}
                    },
                    $defaultURI => {<Q::cs|Perl.utf-8>},
                    $defaultName => 'utf-8',
                    $restoreBOM => {
                      $obj->{<H::mce|hasBOM>} = false;
                      $obj->{<H::mce|byteBuffer>} .= "\x00\x00\xFE\xFF";
                    },
                  }__;
                  if (defined $csdef->{<H::cs|noBOMVariant32Endian1234>}) {
                    $csdef = $Message::Charset::Encode::CharsetDef
                               ->{$csdef->{<H::cs|noBOMVariant32Endian1234>}};
                  }
                } elsif (substr ($b, 2, 2) eq "\xFF\xFE") { # ASCII32Endian2143
                  $obj->{<H::mce|hasBOM>} = true;
                  substr ($b, 0, 4) = '';
                  my $c = $b; $c =~ tr/\x00//d;
                  __CODE{XMLEntity.guess::
                    $ascii => $c,
                    $errorCondition => {
                      not $csdef->{<H::cs|ASCII32>} or
                      $csdef->{<H::cs|ASCII32Endian1234>} or
                      $csdef->{<H::cs|ASCII32Endian3412>} or
                      $csdef->{<H::cs|ASCII32Endian4321>} or
                      $csdef->{<H::cs|BOM.Required>}
                    },
                    $defaultURI => {<Q::cs|Perl.utf-8>},
                    $defaultName => 'utf-8',
                    $restoreBOM => {
                      $obj->{<H::mce|hasBOM>} = false;
                      $obj->{<H::mce|byteBuffer>} .= "\x00\x00\xFF\xFE";
                    },
                  }__;
                  if (defined $csdef->{<H::cs|noBOMVariant32Endian2143>}) {
                    $csdef = $Message::Charset::Encode::CharsetDef
                               ->{$csdef->{<H::cs|noBOMVariant32Endian2143>}};
                  }
                }
              # \x4C\x6F\xA7\x94 EBCDIC
              } # buffer
              $obj->{<H::mce|byteBuffer>} .= $b;
            } # read
          }__;
        } elsif ($csdef->{uri}->{<Q::cs|XML.utf-8>}) {
          ## BOM is optional.
          __DEEP{
            my $b = '';
            if (read $obj->{<H::mce|filehandle>}, $b, 3) {
              if ($b eq "\xEF\xBB\xBF") {
                $obj->{<H::mce|hasBOM>} = true;
              } else {
                $obj->{<H::mce|byteBuffer>} .= $b;
              }
            }
            $csdef = $Message::Charset::Encode::CharsetDef
                         ->{<Q::cs|Perl.utf-8>}; # UTF-8 with no BOM
          }__;
        } elsif ($csdef->{uri}->{<Q::cs|XML.utf-16>}) {
          ## BOM is mandated.
          __DEEP{
            my $b = '';
            if (read $obj->{<H::mce|filehandle>}, $b, 2) {
              if ($b eq "\xFE\xFF") {
                $obj->{<H::mce|hasBOM>} = true;
                $csdef = $Message::Charset::Encode::CharsetDef
                             ->{<Q::cs|Perl.utf-16be>}; # UTF-16BE with no BOM
              } elsif ($b eq "\xFF\xFE") {
                $obj->{<H::mce|hasBOM>} = true;
                $csdef = $Message::Charset::Encode::CharsetDef
                             ->{<Q::cs|Perl.utf-16le>}; # UTF-16LE with no BOM
              } else {
                $obj->{<H::mce|onerror>}
                    ->($onerror, null, <Q::cs|no-bom-error>,
                       charset_uri => $charset);
                $obj->{<H::mce|hasBOM>} = false;
                $obj->{<H::mce|byteBuffer>} .= $b;
                $csdef = $Message::Charset::Encode::CharsetDef
                             ->{<Q::cs|Perl.utf-16be>}; # UTF-16BE with no BOM
              }
            } else {
              $obj->{<H::mce|onerror>}
                  ->($onerror, null, <Q::cs|no-bom-error>,
                     charset_uri => $charset);
              $obj->{<H::mce|hasBOM>} = false;
              $csdef = $Message::Charset::Encode::CharsetDef
                           ->{<Q::cs|Perl.utf-16be>}; # UTF-16BE with no BOM
            }
          }__;
        }

        if (not defined $r and $csdef->{<H::cs|isBlockSafe>}) {
          if (defined $csdef->{<H::cs|perlName>}->[0]) {
            $obj->{<H::mce|perlEncodingName>} = $csdef->{<H::cs|perlName>}->[0];
            $r = bless $obj, <ClassName::ManakaiMCDecodeHandle>;
            require Encode;
            undef $r unless Encode::find_encoding
                              ($obj->{<H::mce|perlEncodingName>});
          }
        }
        unless (defined $r) {
          __DEEP{
            $obj->{<H::mce|onerror>}
                ->($onerror, null, <Q::cs|charset-not-supported-error>,
                   charset_uri => $charset);
          }__;
        }

    @@CODE:
      @@@QName: XMLEntity.guess
      @@@PerlDef:
        if ($ascii =~ /^<\?xml\s+(?:version\s*=\s*["'][^"']*["']\s*)?
                        encoding\s*=\s*["']([^"']*)/x) {
          $obj->{<H::mce|inputEncoding>} = lc $1;
          my $__uri = $self-><M::MCEncodeImplementation.getURIFromCharsetName>
                               (<Q::cs|xmlName>, $obj->{<H::mce|inputEncoding>});
          $csdef = $Message::Charset::Encode::CharsetDef->{$__uri};
          if ($errorCondition) {
            $obj->{<H::mce|onerror>}
                ->($obj->{<H::mce|onerror>}, null,
                   <Q::cs|charset-name-mismatch-error>,
                   charset_uri => $__uri,
                   charset_name => $obj->{<H::mce|inputEncoding>});
          }
        } else {
          $csdef = $Message::Charset::Encode::CharsetDef->{$defaultURI};
          $obj->{<H::mce|inputEncoding>} = $defaultName;
          $restoreBOM;
        }

    @@Test:
      @@@QName: MCEncodeImpl.createMCDecodeHandle.test
      @@@PerlDef:
        my $impl;
        __CODE{createImplForTest:: $impl => $impl}__;

        my $byte = 'a';
        open my $fh, '>', \$byte;
        my $efh = $impl-><M::MCEncodeImplementation.createMCDecodeHandle>
                           (<Q::cs|Perl.utf8>, $fh);
        
        $test->id ('interface');
        $test->assert_isa ($efh, <IFName::MCDecodeHandle>);

        $test->id ('onerr');
        $test->assert_isa ($efh-><AG::MCDecodeHandle.onerror>, 'CODE');

    @@Test:
      @@@QName: MCEncodeImpl.createMCXMLDecodeHandle.test
      @@@PerlDef:
        my $impl;
        __CODE{createImplForTest:: $impl => $impl}__;

        my $byte = 'a';
        open my $fh, '<', \$byte;
        my $efh = $impl-><M::MCEncodeImplementation.createMCDecodeHandle>
                           (<Q::xml-auto-charset:>, $fh);
        
        $test->id ('interface');
        $test->assert_isa ($efh, <IFName::MCDecodeHandle>);

        $test->id ('onerr');
        $test->assert_isa ($efh-><AG::MCDecodeHandle.onerror>, 'CODE');

    @@Test:
      @@@QName: MCEncodeImpl.createMCDecodeHandle.3.test
      @@@PerlDef:
        my $impl;
        __CODE{createImplForTest:: $impl => $impl}__;

        my $errors = 0;

        my $byte = 'a';
        open my $fh, '>', \$byte;
        my $efh = $impl-><M::MCEncodeImplementation.createMCDecodeHandle>
                           (q<http://www.charset.example/>, $fh, sub {
                             $errors++;
                             $test->id ('errortype');
                             $test->assert_equals
                                      ($_[2],
                                       <Q::cs|charset-not-supported-error>);
                           });

        $test->id ('errors');
        $test->assert_num_equals (actual_value => $errors, expected_value => 1);

        $test->id ('return');
        $test->assert_null ($efh);

  @Method:
    @@Name: getURIFromCharsetName
    @@enDesc:
      Returns a DOM URI that identifies a charset.
    @@Param:
      @@@Name: domain
      @@@Type: String
      @@@enDesc:
        A DOM URI that identifies the context in which the charset
        name is used.
    @@Param:
      @@@Name: name
      @@@Type: String
      @@@enDesc:
        The charset name to convert.
    @@Return:
      @@@Type: String
      @@@enDesc:
        A DOM URI that identifies <P::name>.
      @@@nullCase:
        @@@@enDesc:
          The implementation was unable to resolve <P::name> to a URI.
      @@@PerlDef:
        if ({
          <Q::cs|ietfName> => true,
          <Q::cs|xmlName> => true,
        }->{$domain}) {
          $name = lc $name;
          if ($domain eq <Q::cs|ietfName>) {
            $r = <Q::icharset|> . $name;
          } elsif ($domain eq <Q::cs|xmlName>) {
            $r = <Q::cs|XML.> . $name;
          }

          unless ($Message::Charset::Encode::CharsetDef->{$r}) {
            U: for my $uri (keys %$Message::Charset::Encode::CharsetDef) {
              for (@{$Message::Charset::Encode::CharsetDef->{$uri}->{+{
                     <Q::cs|ietfName> => <H::cs|ietfName>,
                     <Q::cs|xmlName> => <H::cs|xmlName>,
                   }->{$domain}} or []}) {
                if ($_ eq $name) {
                  $r = $uri;
                  last U;
                }
              }
            } # U
          }
        } else {
          $r = null;
        }

    @@Test:
      @@@QName: MCEncodeImpl.name2uri.test
      @@@PerlDef:
        my $impl;
        __CODE{createImplForTest:: $impl => $impl}__;

        for (
          [<Q::icharset|utf-8>, 'utf-8'],
          [<Q::icharset|x-no-such-charset>, 'x-no-such-charset'],
          [<Q::icharset|utf-8>, 'UTF-8'],
          [<Q::icharset|utf-8>, 'uTf-8'],
          [<Q::icharset|utf-16be>, 'utf-16be'],
        ) {
          $test->id ('ietfname2uri.'.$_->[1]);
          my $iname = $impl-><M::MCEncodeImplementation.getURIFromCharsetName>
                               (<Q::cs|ietfName>, $_->[1]);
          $test->assert_equals ($iname, $_->[0]);
        }

        for (
          [<Q::cs|XML.utf-8>, 'utf-8'],
          [<Q::cs|XML.x-no-such-charset>, 'x-no-such-charset'],
          [<Q::cs|XML.utf-8>, 'UTF-8'],
          [<Q::cs|XML.utf-8>, 'uTf-8'],
          [<Q::icharset|utf-16be>, 'utf-16be'],
        ) {
          $test->id ('xmlname2uri.'.$_->[1]);
          my $iname = $impl-><M::MCEncodeImplementation.getURIFromCharsetName>
                               (<Q::cs|xmlName>, $_->[1]);
          $test->assert_equals ($iname, $_->[0]);
        }
    
  @Method:
    @@Name: getCharsetNameFromURI
    @@enDesc:
      Returns a name for the charset identified by a DOM URI.
    @@Param:
      @@@Name: domain
      @@@Type: String
      @@@enDesc:
        A DOM URI that identifies the context in which the charset
        name is used.
    @@Param:
      @@@Name: uri
      @@@Type: String
      @@@enDesc:
        A DOM URI of the charset.
    @@Return:
      @@@Type: String
      @@@enDesc:
        A charset name that identifies <P::uri>.
      @@@nullCase:
        @@@@enDesc:
          The implementation was unable to find the charset name
          for the <P::uri> that can be used in <P::domain> context.
      @@@PerlDef:
        if ({
          <Q::cs|ietfName> => true,
          <Q::cs|xmlName> => true,
        }->{$domain}) {
          $r = $Message::Charset::Encode::CharsetDef->{$uri}->{+{
                 <Q::cs|ietfName> => <H::cs|ietfName>,
                 <Q::cs|xmlName> => <H::cs|xmlName>,
               }->{$domain}}->[0];
          unless (defined $r) {
            if ($domain eq <Q::cs|ietfName> and
                substr ($uri, 0, length <Q::icharset|>) eq <Q::icharset|>) {
              $r = substr ($uri, length <Q::icharset|>);
            } elsif ($domain eq <Q::cs|xmlName> and
                substr ($uri, 0, length <Q::cs|XML.>) eq <Q::cs|XML.>) {
              $r = substr ($uri, length <Q::cs|XML.>);
            }
          }
        } else {
          $r = null;
        }

    @@Test:
      @@@QName: MCEncodeImpl.uri2name.test
      @@@PerlDef:
        my $impl;
        __CODE{createImplForTest:: $impl => $impl}__;

        for (
          [<Q::icharset|utf-8>, 'utf-8'],
          [<Q::icharset|x-no-such-charset>, 'x-no-such-charset'],
          [q<http://charset.example/>, null],
        ) {
          $test->id ('uri2ietfname.'.$_->[0]);
          my $iname = $impl-><M::MCEncodeImplementation.getCharsetNameFromURI>
                               (<Q::cs|ietfName>, $_->[0]);
          $test->assert_equals ($iname, $_->[1]);
        }

        for (
          [<Q::cs|XML.utf-8>, 'utf-8'],
          [<Q::cs|XML.x-no-such-charset>, 'x-no-such-charset'],
          [q<http://charset.example/>, null],
        ) {
          $test->id ('uri2xmlname.'.$_->[0]);
          my $iname = $impl-><M::MCEncodeImplementation.getCharsetNameFromURI>
                               (<Q::cs|xmlName>, $_->[0]);
          $test->assert_equals ($iname, $_->[1]);
        }

  @CODE:
    @@QName: createImplForTest
    @@PerlDef:
      $impl = <Class::ManakaiMCEncodeImplementation>->_new;
##MCEncodeImplementation

ElementTypeBinding:
  @Name: CODE
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISPerl|BlockCode
    @@ForCheck: ManakaiDOM|ForClass

IFClsDef:
  @IFQName: MCDecodeHandle
  @ClsQName: ManakaiMCDecodeHandle

  @enDesc:
    An <IF::MCDecodeHandle> provides the read access to a character
    stream.

  @enDesc:
    @@ddid: cestype
    @@ForCheck: ManakaiDOM|ForClass
    @@@:
      The class <Class::ManakaiMCDecodeHandle> can be used to
      encapsulate a byte filehandle with <Perl::Encode> call
      into a character filehandle-like object.

      The encoding <kwd:MUST> be stateless and signatureless.  In addition,
      its <Perl::Encode> implementation <kwd:MUST> support 
      the <Perl::FB_QUIET> flag.

  @Attr:
    @@Name: charset
    @@enDesc:
      A URI that identifies the charset of the handle.
    @@Type: String
    @@Get:
      @@@PerlDef:
        $r = $self->{<H::mce|charset>};

  @Attr:
    @@Name: onerror
    @@enDesc:
      A callback function that is invoked when an error is encountered.

      {P:: The function will be invoked with arguments:

        - <Perl::$self>::: The function itself.

        - <Perl::$handle>::: The <IF::MCDecodeHandle> object.
                             If the error is thrown during the
                             construction of the object, it might
                             be <DOM::null> instead.

        - <Perl::$errorType>::: The DOM URI that identifies the category
                                of the error.

        - <Perl::%opt>::: Named parameters depending to the <Perl::$errorType>.

        It <kwd:MAY> throw an exception.
      }
    @@Type: DISPerl|CODE||ManakaiDOM|all
    @@Get:
      @@@PerlDef:
        $r = $self->{<H::mce|onerror>};
    @@Set:
      @@@PerlDef:
        $self->{<H::mce|onerror>} = $given;
 
    @@Test:
      @@@QName: MCDecodeHandle.onoctetstreamerror.test
      @@@PerlDef:
        my $impl;
        __CODE{createImplForTest:: $impl => $impl}__;

        my $byte = "a\xE3\x81\x82\x81a";
        open my $fh, '<', \$byte;
        my $efh = $impl-><M::MCEncodeImplementation.createMCDecodeHandle>
                           (<Q::cs|Perl.utf8>, $fh);

        $test->id ('default');
        $test->assert_isa ($efh-><AG::MCDecodeHandle.onerror>,
                           'CODE');

        $test->id ('get.set');
        my $sub1 = sub { return "2" };
        $efh-><AS::MCDecodeHandle.onerror> ($sub1);
        my $sub2 = $efh-><AG::MCDecodeHandle.onerror>;
        $test->assert_equals ($sub2, $sub1);
        $test->assert_equals ($sub2->(), "2");

  @Method:
    @@Name: getc
    @@enDesc:
      Returns the next character from the input.
    @@Return:
      @@@Type: String
      @@@enDesc:
        The next character.
      @@@nullCase:
        @@@@enDesc:
          If at the end of the file, or if there was an error, in which
          case <Perl::$!> is set.
      @@@PerlDef:
        if (@{$self->{<H::mce|characterQueue>}}) {
          $r = shift @{$self->{<H::mce|characterQueue>}};
        } else {
          __DEEP{
            my $error;
            if ($self->{<H::mce|continue>}) {
              if (read $self->{<H::mce|filehandle>},
                       $self->{<H::mce|byteBuffer>}, 256,
                       length $self->{<H::mce|byteBuffer>}) {
                # 
              } else {
                $error = true;
              }
              $self->{<H::mce|continue>} = false;
            } elsif (512 > length $self->{<H::mce|byteBuffer>}) {
              read $self->{<H::mce|filehandle>},
                   $self->{<H::mce|byteBuffer>}, 256,
                   length $self->{<H::mce|byteBuffer>};
            }

            unless ($error) {
              my $string = Encode::decode ($self->{<H::mce|perlEncodingName>},
                                           $self->{<H::mce|byteBuffer>},
                                           Encode::FB_QUIET ());
              if (length $string) {
                push @{$self->{<H::mce|characterQueue>}}, split //, $string;
                $r = shift @{$self->{<H::mce|characterQueue>}};
                if (length $self->{<H::mce|byteBuffer>}) {
                  $self->{<H::mce|continue>} = true;
                }
              } else {
                if (length $self->{<H::mce|byteBuffer>}) {
                  $error = true;
                } else {
                  $r = null;
                }
              }
            }
            if ($error) {
              $r = substr $self->{<H::mce|byteBuffer>}, 0, 1, '';
              $self->{<H::mce|onerror>}
                   ->($self->{<H::mce|onerror>}, $self,
                      <Q::cs|illegal-octets-error>,
                      octets => \$r);
            }
          }__;
        }

    @@Test:
      @@@QName: MCDecodeHandle.getc.1.test
      @@@PerlDef:
        my $impl;
        __CODE{createImplForTest:: $impl => $impl}__;

        my $byte = "a\xE3\x81\x82\x81a";
        open my $fh, '<', \$byte;
        my $efh = $impl-><M::MCEncodeImplementation.createMCDecodeHandle>
                           (<Q::cs|Perl.utf8>, $fh);

        my $error = null;
        $efh-><AS::MCDecodeHandle.onerror> (sub {
          my ($self, $efh, $type, %opt) = @_;
          $error = ${$opt{octets}};
        });

        $test->id (1);
        $test->assert_equals ($efh->getc, "a");
        $test->id ('1.err');
        $test->assert_null ($error);

        $test->id (2);
        $test->assert_equals ($efh->getc, "\x{3042}");
        $test->id ('1.err');
        $test->assert_null ($error);

        $test->id (3);
        $test->assert_equals ($efh->getc, "\x81");
        $test->id ('1.err');
        $test->assert_equals ($error, "\x81");
        $error = null;

        $test->id (4);
        $test->assert_equals ($efh->getc, "a");
        $test->id ('4.err');
        $test->assert_null ($error);

        $test->id ('eof');
        $test->assert_null ($efh->getc);
        $test->id ('eof.err');
        $test->assert_null ($error);

    @@Test:
      @@@QName: MCDecodeHandle.getc.2.test
      @@@PerlDef:
        my $impl;
        __CODE{createImplForTest:: $impl => $impl}__;

        my $byte = "a" x 256;
        $byte .= "b" x 256;

        open my $fh, '<', \$byte;
        my $efh = $impl-><M::MCEncodeImplementation.createMCDecodeHandle>
                           (<Q::cs|Perl.utf8>, $fh);

        my $error = null;
        $efh-><AS::MCDecodeHandle.onerror> (sub {
          my ($self, $efh, $type, %opt) = @_;
          $error = ${$opt{octets}};
        });

        for my $i (0..255) {
          $test->id ("a.$i");
          $test->assert_equals ($efh->getc, "a");
          $test->id ("a.$i.err");
          $test->assert_null ($error);
        }

        for my $i (0..255) {
          $test->id ("b.$i");
          $test->assert_equals ($efh->getc, "b");
          $test->id ("b.$i.err");
          $test->assert_null ($error);
        }

        $test->id ('eof');
        $test->assert_null ($efh->getc);
        $test->id ('eof.err');
        $test->assert_null ($error);

    @@Test:
      @@@QName: MCDecodeHandle.getc.3.test
      @@@PerlDef:
        my $impl;
        __CODE{createImplForTest:: $impl => $impl}__;

        my $byte = "a" x 255;
        $byte .= "\xE3\x81\x82";
        $byte .= "b" x 256;

        open my $fh, '<', \$byte;
        my $efh = $impl-><M::MCEncodeImplementation.createMCDecodeHandle>
                           (<Q::cs|Perl.utf8>, $fh);

        my $error = null;
        $efh-><AS::MCDecodeHandle.onerror> (sub {
          my ($self, $efh, $type, %opt) = @_;
          $error = ${$opt{octets}};
        });

        for my $i (0..254) {
          $test->id ("a.$i");
          $test->assert_equals ($efh->getc, "a");
          $test->id ("a.$i.err");
          $test->assert_null ($error);
        }

        $test->id ("A");
        $test->assert_equals ($efh->getc, "\x{3042}");
        $test->id ("A.err");
        $test->assert_null ($error);

        for my $i (0..255) {
          $test->id ("b.$i");
          $test->assert_equals ($efh->getc, "b");
          $test->id ("b.$i.err");
          $test->assert_null ($error);
        }

        $test->id ('eof');
        $test->assert_null ($efh->getc);
        $test->id ('eof.err');
        $test->assert_null ($error);

    @@Test:
      @@@QName: MCDecodeHandle.getc.4.test
      @@@PerlDef:
        my $impl;
        __CODE{createImplForTest:: $impl => $impl}__;

        my $byte = "a" x 255;
        $byte .= "\xE3";

        open my $fh, '<', \$byte;
        my $efh = $impl-><M::MCEncodeImplementation.createMCDecodeHandle>
                           (<Q::cs|Perl.utf8>, $fh);

        my $error = null;
        $efh-><AS::MCDecodeHandle.onerror> (sub {
          my ($self, $efh, $type, %opt) = @_;
          $error = ${$opt{octets}};
        });

        for my $i (0..254) {
          $test->id ("a.$i");
          $test->assert_equals ($efh->getc, "a");
          $test->id ("a.$i.err");
          $test->assert_null ($error);
        }

        $test->id ("E3");
        $test->assert_equals ($efh->getc, "\xE3");
        $test->id ("E3.err");
        $test->assert_equals ($error, "\xE3");
        $error = null;
        
        $test->id ('eof');
        $test->assert_null ($efh->getc);
        $test->id ('eof.err');
        $test->assert_null ($error);

  @Attr:
    @@Name: inputEncoding
    @@enDesc:
      The name of the input charset.
    @@Type: String
    @@Get:
      @@@enDesc:
        If there is a string looks like encoding declaration,
        then the value of it, in lowercase.  Otherwise and
        there is the UTF-16 <CHAR::BOM>, then <CODE::utf-16>.
        Otherwise, <CODE::utf-8>.
      @@@nullCase:
        @@@@enDesc:
          If the charset is different from <Q::xml-auto-charset:>.
      @@@PerlDef:
        $r = $self->{<H::mce|inputEncoding>};

  @Attr:
    @@Name: hasBOM
    @@enDesc:
      Whether the decoder detected the <CHAR::BYTE ORDER MARK> or not.
    @@Type: idl|boolean||ManakaiDOM|all
    @@Get:
      @@@TrueCase:
        @@@@enDesc:
          If there is the <CHAR::BOM>.
      @@@FalseCase:
        @@@@enDesc:
          Either if there is no <CHAR::BOM>, the decoder not 
          reached to the end of the <CHAR::BOM>, or 
          the decoder implementation does not provide whether
          there is the <CHAR::BOM> or not.
      @@@PerlDef:
        $r = $self->{<H::mce|hasBOM>};

  @Test:
    @@QName: MCDecodeHandle.utf-8-optional-bom.1.test
    @@PerlDef:
      my $impl;
      __CODE{createImplForTest:: $impl => $impl}__;

      my $byte = qq<\xEF\xBB\xBFabc>;

      my $error;

      open my $fh, '<', \$byte;
      my $efh = $impl-><M::MCEncodeImplementation.createMCDecodeHandle>
                         (<Q::cs|XML.utf-8>, $fh, sub { $error = true });

      $test->id (1);
      $test->assert_equals ($efh->getc, "a");

      $test->id (2);
      $test->assert_equals ($efh->getc, "b");

      $test->id (3);
      $test->assert_equals ($efh->getc, "c");

      $test->id (4);
      $test->assert_null ($efh->getc);

      $test->id ('err');
      $test->assert_false ($error);

      $test->id ('bom');
      $test->assert_true ($efh-><AG::MCDecodeHandle.hasBOM>);

  @Test:
    @@QName: MCDecodeHandle.utf-8-optional-bom.2.test
    @@PerlDef:
      my $impl;
      __CODE{createImplForTest:: $impl => $impl}__;

      my $byte = qq<abc>;

      my $error;

      open my $fh, '<', \$byte;
      my $efh = $impl-><M::MCEncodeImplementation.createMCDecodeHandle>
                         (<Q::cs|XML.utf-8>, $fh, sub { $error = true });

      $test->id (1);
      $test->assert_equals ($efh->getc, "a");

      $test->id (2);
      $test->assert_equals ($efh->getc, "b");

      $test->id (3);
      $test->assert_equals ($efh->getc, "c");

      $test->id (4);
      $test->assert_null ($efh->getc);

      $test->id ('err');
      $test->assert_false ($error);

      $test->id ('bom');
      $test->assert_false ($efh-><AG::MCDecodeHandle.hasBOM>);

  @Test:
    @@QName: MCDecodeHandle.utf-8-optional-bom.3.test
    @@PerlDef:
      my $impl;
      __CODE{createImplForTest:: $impl => $impl}__;

      my $byte = qq<\xEF\xBB\xBF\xEF\xBB\xBFabc>;

      my $error;

      open my $fh, '<', \$byte;
      my $efh = $impl-><M::MCEncodeImplementation.createMCDecodeHandle>
                         (<Q::cs|XML.utf-8>, $fh, sub { $error = true });

      $test->id ('zwnbsp');
      $test->assert_equals ($efh->getc, "\x{FEFF}");

      $test->id (1);
      $test->assert_equals ($efh->getc, "a");

      $test->id (2);
      $test->assert_equals ($efh->getc, "b");

      $test->id (3);
      $test->assert_equals ($efh->getc, "c");

      $test->id (4);
      $test->assert_null ($efh->getc);

      $test->id ('err');
      $test->assert_false ($error);

      $test->id ('bom');
      $test->assert_true ($efh-><AG::MCDecodeHandle.hasBOM>);

  @Test:
    @@QName: MCDecodeHandle.utf-8-optional-bom.4.test
    @@PerlDef:
      my $impl;
      __CODE{createImplForTest:: $impl => $impl}__;

      my $byte = qq<\xEF\xBB\xBF>;

      my $error;

      open my $fh, '<', \$byte;
      my $efh = $impl-><M::MCEncodeImplementation.createMCDecodeHandle>
                         (<Q::cs|XML.utf-8>, $fh, sub { $error = true });

      $test->id (1);
      $test->assert_null ($efh->getc);

      $test->id ('err');
      $test->assert_false ($error);

      $test->id ('bom');
      $test->assert_true ($efh-><AG::MCDecodeHandle.hasBOM>);

  @Test:
    @@QName: MCDecodeHandle.utf-8-optional-bom.5.test
    @@PerlDef:
      my $impl;
      __CODE{createImplForTest:: $impl => $impl}__;

      my $byte = qq<>;

      my $error;

      open my $fh, '<', \$byte;
      my $efh = $impl-><M::MCEncodeImplementation.createMCDecodeHandle>
                         (<Q::cs|XML.utf-8>, $fh, sub { $error = true });

      $test->id (1);
      $test->assert_null ($efh->getc);

      $test->id ('err');
      $test->assert_false ($error);

      $test->id ('bom');
      $test->assert_false ($efh-><AG::MCDecodeHandle.hasBOM>);

  @Test:
    @@QName: MCDecodeHandle.utf-8-optional-bom.6.test
    @@PerlDef:
      my $impl;
      __CODE{createImplForTest:: $impl => $impl}__;

      my $byte = qq<ab>;

      my $error;

      open my $fh, '<', \$byte;
      my $efh = $impl-><M::MCEncodeImplementation.createMCDecodeHandle>
                         (<Q::cs|XML.utf-8>, $fh, sub { $error = true });

      $test->id (1);
      $test->assert_equals ($efh->getc, "a");

      $test->id (2);
      $test->assert_equals ($efh->getc, "b");

      $test->id (3);
      $test->assert_null ($efh->getc);

      $test->id ('err');
      $test->assert_false ($error);

      $test->id ('bom');
      $test->assert_false ($efh-><AG::MCDecodeHandle.hasBOM>);

  @Test:
    @@QName: MCDecodeHandle.utf-8-optional-bom.7.test
    @@PerlDef:
      my $impl;
      __CODE{createImplForTest:: $impl => $impl}__;

      my $byte = qq<a>;

      my $error;

      open my $fh, '<', \$byte;
      my $efh = $impl-><M::MCEncodeImplementation.createMCDecodeHandle>
                         (<Q::cs|XML.utf-8>, $fh, sub { $error = true });

      $test->id (1);
      $test->assert_equals ($efh->getc, "a");

      $test->id (2);
      $test->assert_null ($efh->getc);

      $test->id ('err');
      $test->assert_false ($error);

      $test->id ('bom');
      $test->assert_false ($efh-><AG::MCDecodeHandle.hasBOM>);


  @Test:
    @@QName: MCDecodeHandle.utf-16-with-bom.1.test
    @@PerlDef:
      my $impl;
      __CODE{createImplForTest:: $impl => $impl}__;

      my $byte = qq<\xFE\xFF\x4E\x00\x00a>;

      my $error;

      open my $fh, '<', \$byte;
      my $efh = $impl-><M::MCEncodeImplementation.createMCDecodeHandle>
                         (<Q::cs|XML.utf-16>, $fh, sub { $error = true });

      $test->id (1);
      $test->assert_equals ($efh->getc, "\x{4E00}");

      $test->id (2);
      $test->assert_equals ($efh->getc, "a");

      $test->id (3);
      $test->assert_null ($efh->getc);

      $test->id ('err');
      $test->assert_false ($error);

      $test->id ('bom');
      $test->assert_true ($efh-><AG::MCDecodeHandle.hasBOM>);

  @Test:
    @@QName: MCDecodeHandle.utf-16-with-bom.2.test
    @@PerlDef:
      my $impl;
      __CODE{createImplForTest:: $impl => $impl}__;

      my $byte = qq<\xFF\xFE\x00\x4Ea\x00>;

      my $error;

      open my $fh, '<', \$byte;
      my $efh = $impl-><M::MCEncodeImplementation.createMCDecodeHandle>
                         (<Q::cs|XML.utf-16>, $fh, sub { $error = true });

      $test->id (1);
      $test->assert_equals ($efh->getc, "\x{4E00}");

      $test->id (2);
      $test->assert_equals ($efh->getc, "a");

      $test->id (3);
      $test->assert_null ($efh->getc);

      $test->id ('err');
      $test->assert_false ($error);

      $test->id ('bom');
      $test->assert_true ($efh-><AG::MCDecodeHandle.hasBOM>);

  @Test:
    @@QName: MCDecodeHandle.utf-16-with-bom.3.test
    @@PerlDef:
      my $impl;
      __CODE{createImplForTest:: $impl => $impl}__;

      my $byte = qq<\xFE\xFF\x00a>;

      my $error;

      open my $fh, '<', \$byte;
      my $efh = $impl-><M::MCEncodeImplementation.createMCDecodeHandle>
                         (<Q::cs|XML.utf-16>, $fh, sub { $error = true });

      $test->id (1);
      $test->assert_equals ($efh->getc, "a");

      $test->id (2);
      $test->assert_null ($efh->getc);

      $test->id ('err');
      $test->assert_false ($error);

      $test->id ('bom');
      $test->assert_true ($efh-><AG::MCDecodeHandle.hasBOM>);

  @Test:
    @@QName: MCDecodeHandle.utf-16-with-bom.4.test
    @@PerlDef:
      my $impl;
      __CODE{createImplForTest:: $impl => $impl}__;

      my $byte = qq<\xFF\xFEa\x00>;

      my $error;

      open my $fh, '<', \$byte;
      my $efh = $impl-><M::MCEncodeImplementation.createMCDecodeHandle>
                         (<Q::cs|XML.utf-16>, $fh, sub { $error = true });

      $test->id (1);
      $test->assert_equals ($efh->getc, "a");

      $test->id (2);
      $test->assert_null ($efh->getc);

      $test->id ('err');
      $test->assert_false ($error);

      $test->id ('bom');
      $test->assert_true ($efh-><AG::MCDecodeHandle.hasBOM>);

  @Test:
    @@QName: MCDecodeHandle.utf-16-with-bom.5.test
    @@PerlDef:
      my $impl;
      __CODE{createImplForTest:: $impl => $impl}__;

      my $byte = qq<\xFE\xFFa>;

      my $error;

      open my $fh, '<', \$byte;
      my $efh = $impl-><M::MCEncodeImplementation.createMCDecodeHandle>
                         (<Q::cs|XML.utf-16>, $fh, sub { $error = $_[2] });

      $test->id ('0.error');
      $test->assert_null ($error);

      $test->id (1);
      $test->assert_equals ($efh->getc, "a");
      $test->id ('1.error');
      $test->assert_equals ($error, <Q::cs|illegal-octets-error>);
      $error = null;

      $test->id (2);
      $test->assert_null ($efh->getc);

      $test->id ('err');
      $test->assert_null ($error);

      $test->id ('bom');
      $test->assert_true ($efh-><AG::MCDecodeHandle.hasBOM>);

  @Test:
    @@QName: MCDecodeHandle.utf-16-with-bom.6.test
    @@PerlDef:
      my $impl;
      __CODE{createImplForTest:: $impl => $impl}__;

      my $byte = qq<\xFF\xFEa>;

      my $error;

      open my $fh, '<', \$byte;
      my $efh = $impl-><M::MCEncodeImplementation.createMCDecodeHandle>
                         (<Q::cs|XML.utf-16>, $fh, sub { $error = $_[2] });

      $test->id ('0.error');
      $test->assert_null ($error);

      $test->id (1);
      $test->assert_equals ($efh->getc, "a");
      $test->id ('1.error');
      $test->assert_equals ($error, <Q::cs|illegal-octets-error>);
      $error = null;

      $test->id (2);
      $test->assert_null ($efh->getc);

      $test->id ('err');
      $test->assert_null ($error);

      $test->id ('bom');
      $test->assert_true ($efh-><AG::MCDecodeHandle.hasBOM>);

  @Test:
    @@QName: MCDecodeHandle.utf-16-with-bom.7.test
    @@PerlDef:
      my $impl;
      __CODE{createImplForTest:: $impl => $impl}__;

      my $byte = qq<\xFE\xFF>;

      my $error;

      open my $fh, '<', \$byte;
      my $efh = $impl-><M::MCEncodeImplementation.createMCDecodeHandle>
                         (<Q::cs|XML.utf-16>, $fh, sub { $error = $_[2] });

      $test->id (1);
      $test->assert_null ($efh->getc);

      $test->id ('err');
      $test->assert_null ($error);

      $test->id ('bom');
      $test->assert_true ($efh-><AG::MCDecodeHandle.hasBOM>);

  @Test:
    @@QName: MCDecodeHandle.utf-16-with-bom.8.test
    @@PerlDef:
      my $impl;
      __CODE{createImplForTest:: $impl => $impl}__;

      my $byte = qq<\xFF\xFE>;

      my $error;

      open my $fh, '<', \$byte;
      my $efh = $impl-><M::MCEncodeImplementation.createMCDecodeHandle>
                         (<Q::cs|XML.utf-16>, $fh, sub { $error = $_[2] });

      $test->id (1);
      $test->assert_null ($efh->getc);

      $test->id ('err');
      $test->assert_null ($error);

      $test->id ('bom');
      $test->assert_true ($efh-><AG::MCDecodeHandle.hasBOM>);

  @Test:
    @@QName: MCDecodeHandle.utf-16-with-bom.9.test
    @@PerlDef:
      my $impl;
      __CODE{createImplForTest:: $impl => $impl}__;

      my $byte = qq<\xFD\xFF>;

      my $error;

      open my $fh, '<', \$byte;
      my $efh = $impl-><M::MCEncodeImplementation.createMCDecodeHandle>
                         (<Q::cs|XML.utf-16>, $fh, sub { $error = $_[2] });

      $test->id ('no.bom');
      $test->assert_equals ($error, <Q::cs|no-bom-error>);
      $error = null;

      $test->id (1);
      $test->assert_equals ($efh->getc, "\x{FDFF}");

      $test->id (2);
      $test->assert_null ($efh->getc);

      $test->id ('err');
      $test->assert_null ($error);

      $test->id ('bom');
      $test->assert_false ($efh-><AG::MCDecodeHandle.hasBOM>);

  @Test:
    @@QName: MCDecodeHandle.utf-16-with-bom.10.test
    @@PerlDef:
      my $impl;
      __CODE{createImplForTest:: $impl => $impl}__;

      my $byte = qq<\xFD>;

      my $error;

      open my $fh, '<', \$byte;
      my $efh = $impl-><M::MCEncodeImplementation.createMCDecodeHandle>
                         (<Q::cs|XML.utf-16>, $fh, sub { $error = $_[2] });

      $test->id ('no.bom');
      $test->assert_equals ($error, <Q::cs|no-bom-error>);
      $error = null;

      $test->id (1);
      $test->assert_equals ($efh->getc, "\xFD");
      $test->id ('1.error');
      $test->assert_equals ($error, <Q::cs|illegal-octets-error>);
      $error = null;

      $test->id (2);
      $test->assert_null ($efh->getc);

      $test->id ('err');
      $test->assert_null ($error);

      $test->id ('bom');
      $test->assert_false ($efh-><AG::MCDecodeHandle.hasBOM>);

  @Test:
    @@QName: MCDecodeHandle.utf-16-with-bom.11.test
    @@PerlDef:
      my $impl;
      __CODE{createImplForTest:: $impl => $impl}__;

      my $byte = qq<>;

      my $error;

      open my $fh, '<', \$byte;
      my $efh = $impl-><M::MCEncodeImplementation.createMCDecodeHandle>
                         (<Q::cs|XML.utf-16>, $fh, sub { $error = $_[2] });

      $test->id ('no.bom');
      $test->assert_equals ($error, <Q::cs|no-bom-error>);
      $error = null;

      $test->id (1);
      $test->assert_null ($efh->getc);

      $test->id ('err');
      $test->assert_null ($error);

      $test->id ('bom');
      $test->assert_false ($efh-><AG::MCDecodeHandle.hasBOM>);

  @Test:
    @@QName: MCDecodeHandle.xml.1.test
    @@PerlDef:
      my $impl;
      __CODE{createImplForTest:: $impl => $impl}__;

      my @testdata = (
        {
          id => q<l=0>,
          in => q<>,
          out => [null],
          name => 'utf-8', bom => false,
        },
        {
          id => q<l=1>,
          in => "a",
          out => [null, "a", null],
          name => 'utf-8', bom => false,
        },
        {
          id => q<bom8.l=0>,
          in => "\xEF\xBB\xBF",
          out => [null],
          name => 'utf-8', bom => true,
        },
        {
          id => q<bom8.l=1>,
          in => "\xEF\xBB\xBFa",
          out => [null, "a", null],
          name => 'utf-8', bom => true,
        },
        {
          id => q<bom8.zwnbsp>,
          in => "\xEF\xBB\xBF\xEF\xBB\xBF",
          out => [null, "\x{FEFF}", null],
          name => 'utf-8', bom => true,
        },
        {
          id => q<bom16be.l=0>,
          in => "\xFE\xFF",
          out => [null],
          name => 'utf-16', bom => true,
        },
        {
          id => q<bom16le.l=0>,
          in => "\xFF\xFE",
          out => [null],
          name => 'utf-16', bom => true,
        },
        {
          id => q<bom16be.l=1>,
          in => "\xFE\xFFa",
          out => [null, "a", [<Q::cs|illegal-octets-error>]],
          name => 'utf-16', bom => true,
        },
        {
          id => q<bom16le.l=1>,
          in => "\xFF\xFEa",
          out => [null, "a", [<Q::cs|illegal-octets-error>]],
          name => 'utf-16', bom => true,
        },
        {
          id => q<bom16be.l=2>,
          in => "\xFE\xFF\x4E\x00",
          out => [null, "\x{4E00}", null],
          name => 'utf-16', bom => true,
        },
        {
          id => q<bom16le.l=2>,
          in => "\xFF\xFE\x00\x4E",
          out => [null, "\x{4E00}", null],
          name => 'utf-16', bom => true,
        },
        {
          id => q<bom16be.l=2lt>,
          in => "\xFE\xFF\x00<",
          out => [null, "<", null],
          name => 'utf-16', bom => true,
        },
        {
          id => q<bom16le.l=2lt>,
          in => "\xFF\xFE<\x00",
          out => [null, "<", null],
          name => 'utf-16', bom => true,
        },
        {
          id => q<bom16be.zwnbsp>,
          in => "\xFE\xFF\xFE\xFF",
          out => [null, "\x{FEFF}", null],
          name => 'utf-16', bom => true,
        },
        {
          id => q<bom16le.zwnbsp>,
          in => "\xFF\xFE\xFF\xFE",
          out => [null, "\x{FEFF}", null],
          name => 'utf-16', bom => true,
        },
        {
          id => q<bom32e3412.l=0>,
          in => "\xFE\xFF\x00\x00",
          out => [null, "\x00", null],
          name => 'utf-16', bom => true,
        },
        {
          id => q<bom32e4321.l=0>,
          in => "\xFF\xFE\x00\x00",
          out => [null, "\x00", null],
          name => 'utf-16', bom => true,
        },
        {
          id => q<bom16be.l=4ltq>,
          in => "\xFE\xFF\x00<\x00?",
          out => [null, "<", null, "?", null],
          name => 'utf-16', bom => true,
        },
        {
          id => q<bom16le.l=4ltq>,
          in => "\xFF\xFE<\x00?\x00",
          out => [null, "<", null, "?", null],
          name => 'utf-16', bom => true,
        },
        {
          id => q<bom16be.decl.1>,
          in => qq[\xFE\xFF\x00<\x00?\x00x\x00m\x00l\x00 \x00v\x00e\x00r].
                qq[\x00s\x00i\x00o\x00n\x00=\x00"\x001\x00.\x000\x00"].
                qq[\x00 \x00e\x00n\x00c\x00o\x00d\x00i\x00n\x00g\x00=].
                qq[\x00"\x00u\x00t\x00f\x00-\x001\x006\x00"\x00?\x00>],
          out => [null, "<", null, "?", null, "x", null, "m", null, "l", null,
                  " ", null, "v", null, "e", null, "r", null, "s", null,
                  "i", null, "o", null, "n", null, "=", null, '"', null,
                  "1", null, ".", null, "0", null, '"', null, " ", null,
                  "e", null, "n", null, "c", null, "o", null, "d", null,
                  "i", null, "n", null, "g", null, "=", null, '"', null,
                  "u", null, "t", null, "f", null, "-", null, "1", null,
                  "6", null, '"', null, "?", null, ">", null],
          name => 'utf-16', bom => true,
        },
        {
          id => q<bom16le.decl.1>,
          in => qq[\xFF\xFE<\x00?\x00x\x00m\x00l\x00 \x00v\x00e\x00r].
                qq[\x00s\x00i\x00o\x00n\x00=\x00"\x001\x00.\x000\x00"].
                qq[\x00 \x00e\x00n\x00c\x00o\x00d\x00i\x00n\x00g\x00=].
                qq[\x00"\x00u\x00t\x00f\x00-\x001\x006\x00"\x00?\x00>\x00],
          out => [null, "<", null, "?", null, "x", null, "m", null, "l", null,
                  " ", null, "v", null, "e", null, "r", null, "s", null,
                  "i", null, "o", null, "n", null, "=", null, '"', null,
                  "1", null, ".", null, "0", null, '"', null, " ", null,
                  "e", null, "n", null, "c", null, "o", null, "d", null,
                  "i", null, "n", null, "g", null, "=", null, '"', null,
                  "u", null, "t", null, "f", null, "-", null, "1", null,
                  "6", null, '"', null, "?", null, ">", null],
          name => 'utf-16', bom => true,
        },
        {
          id => q<utf16be.decl.1>,
          in => qq[\x00<\x00?\x00x\x00m\x00l\x00 \x00v\x00e\x00r].
                qq[\x00s\x00i\x00o\x00n\x00=\x00"\x001\x00.\x000\x00"].
                qq[\x00 \x00e\x00n\x00c\x00o\x00d\x00i\x00n\x00g\x00=].
                qq[\x00"\x00u\x00t\x00f\x00-\x001\x006\x00b\x00e\x00"\x00?\x00>],
          out => [null, "<", null, "?", null, "x", null, "m", null, "l", null,
                  " ", null, "v", null, "e", null, "r", null, "s", null,
                  "i", null, "o", null, "n", null, "=", null, '"', null,
                  "1", null, ".", null, "0", null, '"', null, " ", null,
                  "e", null, "n", null, "c", null, "o", null, "d", null,
                  "i", null, "n", null, "g", null, "=", null, '"', null,
                  "u", null, "t", null, "f", null, "-", null, "1", null,
                  "6", null, "b", null, "e", null, '"', null,
                  "?", null, ">", null],
          name => 'utf-16be', bom => false,
        },
        {
          id => q<utf16le.decl.1>,
          in => qq[<\x00?\x00x\x00m\x00l\x00 \x00v\x00e\x00r].
                qq[\x00s\x00i\x00o\x00n\x00=\x00"\x001\x00.\x000\x00"].
                qq[\x00 \x00e\x00n\x00c\x00o\x00d\x00i\x00n\x00g\x00=].
                qq[\x00"\x00u\x00t\x00f\x00-\x001\x006\x00l\x00e\x00"].
                qq[\x00?\x00>\x00],
          out => [null, "<", null, "?", null, "x", null, "m", null, "l", null,
                  " ", null, "v", null, "e", null, "r", null, "s", null,
                  "i", null, "o", null, "n", null, "=", null, '"', null,
                  "1", null, ".", null, "0", null, '"', null, " ", null,
                  "e", null, "n", null, "c", null, "o", null, "d", null,
                  "i", null, "n", null, "g", null, "=", null, '"', null,
                  "u", null, "t", null, "f", null, "-", null, "1", null,
                  "6", null, "l", null, "e", null, '"', null, "?", null,
                  ">", null],
          name => 'utf-16le', bom => false,
        },
        {
          id => q<16be.decl.1>,
          in => qq[\x00<\x00?\x00x\x00m\x00l\x00 \x00v\x00e\x00r].
                qq[\x00s\x00i\x00o\x00n\x00=\x00"\x001\x00.\x000\x00"].
                qq[\x00 \x00e\x00n\x00c\x00o\x00d\x00i\x00n\x00g\x00=].
                qq[\x00"\x00u\x00t\x00f\x00-\x001\x006\x00"\x00?\x00>],
          out => [[<Q::cs|charset-name-mismatch-error>],
                  "<", null, "?", null, "x", null, "m", null, "l", null,
                  " ", null, "v", null, "e", null, "r", null, "s", null,
                  "i", null, "o", null, "n", null, "=", null, '"', null,
                  "1", null, ".", null, "0", null, '"', null, " ", null,
                  "e", null, "n", null, "c", null, "o", null, "d", null,
                  "i", null, "n", null, "g", null, "=", null, '"', null,
                  "u", null, "t", null, "f", null, "-", null, "1", null,
                  "6", null, '"', null, "?", null, ">", null],
          name => 'utf-16', bom => false,
        },
        {
          id => q<16le.decl.1>,
          in => qq[<\x00?\x00x\x00m\x00l\x00 \x00v\x00e\x00r].
                qq[\x00s\x00i\x00o\x00n\x00=\x00"\x001\x00.\x000\x00"].
                qq[\x00 \x00e\x00n\x00c\x00o\x00d\x00i\x00n\x00g\x00=].
                qq[\x00"\x00u\x00t\x00f\x00-\x001\x006\x00"\x00?\x00>\x00],
          out => [[<Q::cs|charset-name-mismatch-error>],
                  "<", null, "?", null, "x", null, "m", null, "l", null,
                  " ", null, "v", null, "e", null, "r", null, "s", null,
                  "i", null, "o", null, "n", null, "=", null, '"', null,
                  "1", null, ".", null, "0", null, '"', null, " ", null,
                  "e", null, "n", null, "c", null, "o", null, "d", null,
                  "i", null, "n", null, "g", null, "=", null, '"', null,
                  "u", null, "t", null, "f", null, "-", null, "1", null,
                  "6", null, '"', null, "?", null, ">", null],
          name => 'utf-16', bom => false,
        },
        {
          id => q<8.decl.1>,
          in => qq[<?xml version="1.0" encoding="utf-8"?>],
          out => [null, "<", null, "?", null, "x", null, "m", null, "l", null,
                  " ", null, "v", null, "e", null, "r", null, "s", null,
                  "i", null, "o", null, "n", null, "=", null, '"', null,
                  "1", null, ".", null, "0", null, '"', null, " ", null,
                  "e", null, "n", null, "c", null, "o", null, "d", null,
                  "i", null, "n", null, "g", null, "=", null, '"', null,
                  "u", null, "t", null, "f", null, "-", null, "8", null,
                  '"', null, "?", null, ">", null],
          name => 'utf-8', bom => false,
        },
        {
          id => q<8.decl.2>,
          in => qq[<?xml encoding="utf-8"?>],
          out => [null, "<", null, "?", null, "x", null, "m", null, "l", null,
                  " ", null,
                  "e", null, "n", null, "c", null, "o", null, "d", null,
                  "i", null, "n", null, "g", null, "=", null, '"', null,
                  "u", null, "t", null, "f", null, "-", null, "8", null,
                  '"', null, "?", null, ">", null],
          name => 'utf-8', bom => false,
        },
        {
          id => q<8.decl.3>,
          in => qq[<?xml version="1.1" encoding="utf-8"?>],
          out => [null, "<", null, "?", null, "x", null, "m", null, "l", null,
                  " ", null, "v", null, "e", null, "r", null, "s", null,
                  "i", null, "o", null, "n", null, "=", null, '"', null,
                  "1", null, ".", null, "1", null, '"', null, " ", null,
                  "e", null, "n", null, "c", null, "o", null, "d", null,
                  "i", null, "n", null, "g", null, "=", null, '"', null,
                  "u", null, "t", null, "f", null, "-", null, "8", null,
                  '"', null, "?", null, ">", null],
          name => 'utf-8', bom => false,
        },
        {
          id => q<8.decl.4>,
          in => qq[<?xml version="1.0"?>],
          out => [null, "<", null, "?", null, "x", null, "m", null, "l", null,
                  " ", null, "v", null, "e", null, "r", null, "s", null,
                  "i", null, "o", null, "n", null, "=", null, '"', null,
                  "1", null, ".", null, "0", null, '"', null, 
                  "?", null, ">", null],
          name => 'utf-8', bom => false,
        },
        {
          id => q<bom8.decl.1>,
          in => qq[\xEF\xBB\xBF<?xml encoding="utf-8"?>],
          out => [null, "<", null, "?", null, "x", null, "m", null, "l", null,
                  " ", null,
                  "e", null, "n", null, "c", null, "o", null, "d", null,
                  "i", null, "n", null, "g", null, "=", null, '"', null,
                  "u", null, "t", null, "f", null, "-", null, "8", null,
                  '"', null, "?", null, ">", null],
          name => 'utf-8', bom => true,
        },
        {
          id => q<us-ascii.decl.1>,
          in => qq[<?xml encoding="us-ascii"?>],
          out => [null, "<", null, "?", null, "x", null, "m", null, "l", null,
                  " ", null,
                  "e", null, "n", null, "c", null, "o", null, "d", null,
                  "i", null, "n", null, "g", null, "=", null, '"', null,
                  "u", null, "s", null, "-", null, "a", null, "s", null,
                  "c", null, "i", null, "i", null,
                  '"', null, "?", null, ">", null],
          name => 'us-ascii', bom => false,
        },
        {
          id => q<us-ascii.decl.2>,
          in => qq[<?xml encoding="US-ascii"?>],
          out => [null, "<", null, "?", null, "x", null, "m", null, "l", null,
                  " ", null,
                  "e", null, "n", null, "c", null, "o", null, "d", null,
                  "i", null, "n", null, "g", null, "=", null, '"', null,
                  "U", null, "S", null, "-", null, "a", null, "s", null,
                  "c", null, "i", null, "i", null,
                  '"', null, "?", null, ">", null],
          name => 'us-ascii', bom => false,
        },
        {
          id => q<us-ascii.decl.3>,
          in => qq[<?xml encoding='us-ascii'?>],
          out => [null, "<", null, "?", null, "x", null, "m", null, "l", null,
                  " ", null,
                  "e", null, "n", null, "c", null, "o", null, "d", null,
                  "i", null, "n", null, "g", null, "=", null, "'", null,
                  "u", null, "s", null, "-", null, "a", null, "s", null,
                  "c", null, "i", null, "i", null,
                  "'", null, "?", null, ">", null],
          name => 'us-ascii', bom => false,
        },
      );

      for my $testdata (@testdata) {
        my $byte = $testdata->{in};
        my $error;
        my $i = 0;

        open my $fh, '<', \$byte;
        my $efh = $impl-><M::MCEncodeImplementation.createMCDecodeHandle>
                           (<Q::xml-auto-charset:>, $fh, sub {
                             my (null, null, $etype, %opt) = @_;
                             $error = [$etype, \%opt];
                           });

        $test->id ("$testdata->{id}.bom");
        my $tf = $testdata->{bom} ? 'assert_true' : 'assert_false';
        $test->$tf ($efh-><AG::MCDecodeHandle.hasBOM>);

        $test->id ("$testdata->{id}.name");
        $test->assert_equals ($efh-><AG::MCDecodeHandle.inputEncoding>,
                              $testdata->{name});

        while (@{$testdata->{out}}) {
          if ($i != 0) {
            my $c = shift @{$testdata->{out}};
            $test->id ("$testdata->{id}.$i");
            $test->assert_equals ($efh->getc, $c);
          }

          my $v = shift @{$testdata->{out}};
          $test->id ("$testdata->{id}.$i.error");
          if (defined $v) {
            $test->assert_not_null ($error);
            $test->assert_equals ($error->[0], $v->[0]);
          } else {
            $test->assert_null ($error->[0]);
          }
          $error = null;
          $i++;
        }

        $test->id ("$testdata->{id}.eof");
        $test->assert_null ($efh->getc);
        $test->assert_null ($error);
      } # testdata
##MCDecodeHandle

ResourceDef:
  @QName: String
  @AliasFor: f|MIString
  @For: ManakaiDOM|ManakaiDOM

PropDef:
  @QName: mce|onerror
  @mce:key: onerr

PropDef:
  @QName: mce|inputEncoding
  @mce:key: ie

PropDef:
  @QName: mce|hasBOM
  @mce:key: bom

PropDef:
  @QName: mce|continue
  @mce:key: cc
  @enDesc:
    Whether the <Q::mce|byteBuffer> contains octets that might
    be part of characters.

PropDef:
  @QName: mce|charset
  @mce:key: cs

PropDef:
  @QName: mce|perlEncodingName
  @mce:key: enc

PropDef:
  @QName: mce|filehandle
  @mce:key: fh

RPropDef:
  @QName: mce|key
  @subsetOf: DISPerl|propHashKey

PropDef:
  @QName: mce|characterQueue
  @mce:key: cq

PropDef:
  @QName: mce|byteBuffer
  @mce:key: bb

ElementTypeBinding: 
  @Name: PropDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISCore|Property
    @@ForCheck: =ManakaiDOM|all

ElementTypeBinding: 
  @Name: RPropDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISSource|ResourceProperty
    @@ForCheck: =ManakaiDOM|all


ElementTypeBinding:
  @Name: nullCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: ManakaiDOM|InCase
    @@Value:
      @@@is-null:1
      @@@ContentType: DISCore|String

ElementTypeBinding:
  @Name: TrueCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: ManakaiDOM|InCase
    @@Value:
      @@@@: 1
      @@@ContentType: DISCore|Boolean
    @@Type: idl|boolean||ManakaiDOM|all

ElementTypeBinding:
  @Name: FalseCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: ManakaiDOM|InCase
    @@Value:
      @@@@: 0
      @@@ContentType: DISCore|Boolean
    @@Type: idl|boolean||ManakaiDOM|all

ResourceDef:
  @DISCore:resourceType: cs|CharsetSet
  @cs:moduleRef: DISlib|Charset
