Module:
  @QName: MDOM|SimpleLS
  @Namespace:
    http://suika.fam.cx/~wakaba/archive/2004/dom/sls#

  @enFN: Simple Load and Save Module

  @enDesc:
    The <Module::MDOM|SimpleLS> module provides a simplified
    XML and HTML 5 parsers and serializers, which are 
    available to applications via <Module::MDOM|GenericLS>
    factory methods.

  @DISCore:author: DISCore|Wakaba
  @License: license|Perl+MPL
  @Date:
    $Date: 2006/12/30 08:27:45 $

  @Require:
    @@Module:
      @@@QName: MDOM|GenericLS
    @@Module:
      @@@QName: MDOM|TreeCore

Namespace:
  @dis:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#dis--
  @f:
    http://suika.fam.cx/~wakaba/archive/2004/dom/feature#
  @fe:
    http://suika.fam.cx/www/2006/feature/
  @gls:
    http://suika.fam.cx/~wakaba/archive/2004/dom/gls#
  @lang:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#
  @kwd:
    http://suika.fam.cx/~wakaba/archive/2005/rfc2119/
  @license:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/license#
  @ManakaiDOM:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#
  @MDOM:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#ManakaiDOM.
  @rdf:
    http://www.w3.org/1999/02/22-rdf-syntax-ns#
  @tc:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/DOM/TreeCore/
  @tcd:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/DOM/CharacterData/
  @td:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/DOM/Document/
  @te:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/DOM/Element/
  @tx:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/DOM/XML/
  @undef:
    http://suika.fam.cx/~wakaba/-temp/2003/09/27/undef
  @xml:
    http://www.w3.org/XML/1998/namespace
  @xmlns:
    http://www.w3.org/2000/xmlns/

ElementTypeBinding:
  @Name: PerlDef
  @ElementType:
    dis:Def
  @ShadowContent:
    @@ContentType:
      lang:Perl
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: FeatureDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: f|Feature
    @@For: =ManakaiDOM|all

ElementTypeBinding:
  @Name: FeatureVerDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: f|Feature

ElementTypeBinding:
  @Name: featureQName
  @ElementType:
    f:name
  @ShadowContent:
    @@ContentType: DISCore|QName

ElementTypeBinding:
  @Name: IFQName
  @ElementType:
    dis:QName
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForIF

ElementTypeBinding:
  @Name: ClsQName
  @ElementType:
    dis:QName
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: IFISA
  @ElementType:
    dis:ISA
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForIF

ElementTypeBinding:
  @Name: ClsISA
  @ElementType:
    dis:ISA
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: IFClsXDef
  @ElementType: 
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      @@@@: dis|MultipleResource
      @@@ForCheck: !ManakaiDOM|ForIF !ManakaiDOM|ForClass
    @@resourceFor: ManakaiDOM|ForIF
    @@resourceFor:
      @@@@: ManakaiDOM|ForClass

    @@rdf:type:
      @@@@: DISLang|Interface
      @@@ForCheck: ManakaiDOM|ForIF

    @@rdf:type:
      @@@@: DISLang|Class
      @@@ForCheck: ManakaiDOM|ForClass

    @@Implement:
      @@@@: ||+||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: Method
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Method

ElementTypeBinding:
  @Name: Param
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|MethodParameter

ElementTypeBinding:
  @Name: Return
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|MethodReturn

ElementTypeBinding:
  @Name: enDesc
  @ElementType:
    dis:Description
  @ShadowContent:
    @@lang:en

ElementTypeBinding:
  @Name: enFN
  @ElementType:
    dis:FullName
  @ShadowContent:
    @@lang:en

## -- Serializers

FeatureDef:
  @QName: fe|SerializeDocumentInstance
  @FeatureVerDef:
    @@QName: SerializeDocumentInstance10
    @@f:version: 1.0
    @@f:instanceOf: fe|SerializeDocumentInstance
    @@f:requires: tx|XMLVersionFeature10
    @@enDesc:
      {P:: To support this feature:
         \
         - the serializer class <kwd:MUST> implement the
           <IF::SimpleXMLSerializer>
           interface, i.e. it <kwd:MUST> have a 
           <M::SimpleXMLSerializer.writeToString> method.
         \
         - the <M::SimpleXMLSerializer.writeToString>
           method <kwd:MUST> accept a <IF::td|Document>
           node as its <P::nodeArg> parameter.  It <kwd:MAY>
           also accept other type of nodes as the parameter.
         \
         - the serialization <kwd:MUST> support the result
           being exact one parsed entity, i.e. a document entity without
           any external parsed entity reference. 
         \
         - the serializer <kwd:MUST> support the serialization
           of <IF::te|Element> nodes, <IF::te|Attr>
           nodes which support XML Namespaces and which are not
           namespace declaration attributes, and <IF::tcd|Text> nodes.
         \
         - the serializer <kwd:MUST> support the serialization
           of <IF::tx|CDATASection> nodes, but it does not have
           to result in XML <XML::CDATA> sections.  In other word, 
           the serializer <kwd:MAY> serialize a <IF::tx|CDATASection>
           as a sequence of characters and/or character references.
         \
         - the serializer <kwd:MAY> ignore <IF::tx|EntityReference>
           nodes and serialize their children if the <IF::tx|EntityReference>
           nodes are expanded.  Otherwise, it <kwd:MUST> 
           serialize them as (unexpanded) general entity references. 
           If the serializer supports the serialization of 
           document type declarations, it <kwd:MAY> generate
           general entity declarations.
         \
         - the serialization <kwd:MAY> serialize 
           or ignore <IF::tcd|Comment>, <IF::tx|ProcessingInstruction>,
           <IF::tx|DocumentType>, <IF::tx|Entity> and
           <IF::tx|Notation> nodes.
         \
         - if the <A::td|Document.xmlVersion> has a non-<DOM::null>
           value and it is different from <XML::1.0>, then
           the serializer <kwd:MUST> output an XML declaration.
         \
         - if the serializer does not support the XML version
           as specified by the <A::td|Document.xmlVersion>,
           then the serializer <kwd:MAY> report an exception
           or error.
         \
         - the serializer <kwd:SHOULD> try to ensure
           the result is namespace well-formed.  It <kwd:MAY>
           omit strict error checking.  For example, the serializer
           don't have to test whether an element type name
           is a legal XML <CODE::Name>.
         \
       }

IFClsXDef:
  @IFQName: SimpleXMLSerializer
  @ClsQName: ManakaiDOMSimpleXMLSerializer

  @enDesc:
    A simple XML serializer that only (or at least) supports
    document instance constructions such as elements and attributes.

  @DISLang:role: gls|SerializerRole

  @f:implements: SerializeDocumentInstance10

  @Method:
    @@Operator:
      @@@@:DISPerl|NewMethod
      @@@ContentType: DISCore|QName
    @@ManakaiDOM:isForInternal: 1
    @@Return:
      @@@Type: SimpleXMLSerializer
      @@@enDesc: Newly created serializer.
      @@@PerlDef:
        $r = <ClassName::ManakaiDOMSimpleXMLSerializer>;

  @Method:
    @@Name: writeToString
    @@enDesc:
      Serializes a document as an XML document entity.
    @@Param:
      @@@Name: nodeArg
      @@@Type: Node
      @@@enDesc:
        The document node to serialize.
    @@Return:
      @@@Type: DOMMain|DOMString
      @@@enDesc:
        An XML document entity string created from <P::nodeArg>.
        \
        {NOTE:: This string might not namespace well-formed
                (or even well-formed) if the original <P::nodeArg>
                contains ill-formed information property,
                e.g. illegal element type name.
        \
        }
      @@@PerlDef:
        my @src = ($nodeArg);
        my $nsbind = [{'' => '', xml => <Q::xml:>, xmlns => <Q::undef:>}];
        my $xescape = sub ($) {
          my $s = shift;
          $s =~ s/&/&amp;/g;
          $s =~ s/</&lt;/g;
          $s =~ s/>/&gt;/g;
          $s =~ s/"/&quot;/g;
          return $s;
        };
        while (defined (my $src = shift @src)) {
          if (ref $src eq 'ARRAY') {
            pop @$nsbind;  ## End tag
          } elsif (ref $src) {
            my $srcnt = $src->node_type;
            if ($srcnt == <C::Node.ELEMENT_NODE>) {
              my @csrc;
              my $etag;
              push @$nsbind, my $ns = {%{$nsbind->[-1]}};
              my %attrr;

              my @attrs = @{$src->attributes};
              my @nsattrs;
              my @gattrs;
              my @lattrs;

              for my $attr (@attrs) {
                my $nsuri = $attr->namespace_uri;
                if (not defined $nsuri) {
                  push @lattrs, $attr;
                } elsif ($nsuri eq <Q::xmlns:>) {
                  push @nsattrs, $attr;
                } else {
                  push @gattrs, $attr;
                }
              }

              ## Implied namespace prefixes
              my $etns = $src->namespace_uri;
              my $etpfx = $src->prefix;
              if (defined $etns and defined $etpfx and
                  not (defined $ns->{$etpfx} and $ns->{$etpfx} eq $etns)) {
                $ns->{$etpfx} = $etns;
                $attrr{'xmlns:'.$etpfx} = [$xescape->($etns)];
              }

              for my $attr (@gattrs) {
                my $atns = $attr->namespace_uri;
                my $atpfx = $attr->prefix;
                if (defined $atpfx and
                    not (defined $ns->{$atpfx} and $ns->{$atpfx} eq $atns)) {
                  $ns->{$atpfx} = $atns;
                  $attrr{'xmlns:'.$atpfx} = [$xescape->($atns)];
                }
              }

              ## Namespace attributes
              XA: for my $attr (@nsattrs) {
                my $attrval = $attr->value;
                my $lname = $attr->local_name;
                if ($lname eq 'xmlns') {
                  $ns->{''} = $attrval;
                  $attrr{xmlns} = [@{$attr->child_nodes}];
                } else {
                  if (length $attrval) {
                    $ns->{$lname} = $attrval;
                  } else {
                    $ns->{$lname} = <Q::undef:>;
                  }
                  $attrr{'xmlns:'.$lname} = [@{$attr->child_nodes}];
                }
              } # XA

              ## Per-element partition attributes
              for my $attr (@lattrs) {
                $attrr{$attr->local_name} = [@{$attr->child_nodes}];
              }

              ## Global partition attributes
              my $dns = $ns->{''};
              delete $ns->{''};
              my $nsrev = {reverse %$ns};
              $ns->{''} = $dns;
              delete $nsrev->{<Q::undef:>}; # for security reason
              for my $attr (@gattrs) {
                my $atns = $attr->namespace_uri;
                my $atpfx = $attr->prefix;
                if (not defined $atpfx or
                    $ns->{$atpfx} ne $atns) {
                  if (defined $nsrev->{$atns}) {
                    $atpfx = $nsrev->{$atns};
                  } else {
                    ## Prefix is not registered
                    my @uritxt = grep {/\A[A-Za-z][A-Za-z0-9_.-]*\z/}
                                 split /\W+/, $atns;
                    P: {
                      for my $pfx (reverse @uritxt) {
                        if (not defined $ns->{$pfx}) {
                          $atpfx = $pfx;
                          $ns->{$pfx} = $atns;
                          $nsrev->{$atns} = $atpfx;
                          $attrr{'xmlns:'.$atpfx} = [$xescape->($atns)];
                          last P;
                        }
                      }

                      my $i = 1;
                      $i++ while exists $ns->{'ns'.$i};
                      $atpfx = 'ns'.$i;
                      $ns->{$atpfx} = $atns;
                      $nsrev->{$atns} = $atpfx;
                      $attrr{'xmlns:ns'.$i} = [$xescape->($atns)];
                    } # P
                  }
                }

                $attrr{$atpfx.':'.$attr->local_name} = [@{$attr->child_nodes}];
              }

              ## Element type name
              if (defined $etns) {
                if (not defined $etpfx or
                    (defined $ns->{$etpfx} and $ns->{$etpfx} ne $etns)) {
                  if ($ns->{''} eq $etns) {
                    $etpfx = null;
                  } else {
                    $etpfx = $nsrev->{$etns};
                    unless (defined $etpfx) {
                      ## Prefix is not registered
                      my @uritxt = grep {/\A[A-Za-z][A-Za-z0-9_.-]*\z/}
                                   split /\W+/, $etns;
                      P: {
                        for my $pfx (reverse @uritxt) {
                          if (not defined $ns->{$pfx}) {
                            $etpfx = $pfx;
                            $ns->{$pfx} = $etns;
                            $nsrev->{$etns} = $etpfx;
                            $attrr{'xmlns:'.$etpfx} = [$xescape->($etns)];
                            last P;
                          }
                        }
  
                        my $i = 1;
                        $i++ while exists $ns->{'ns'.$i};
                        $etpfx = 'ns'.$i;
                        $ns->{$etpfx} = $etns;
                        $nsrev->{$etns} = $etpfx;
                        $attrr{'xmlns:ns'.$i} = [$xescape->($etns)];
                      } # P
                    }
                  }
                }
              } else {
                if ($ns->{''} ne '') {
                  $ns->{''} = '';
                  $attrr{xmlns} = [''];
                }
              }

              $r .= '<';
              $etag = '</';
              if (defined $etpfx) {
                $r .= $etpfx . ':';
                $etag .= $etpfx . ':';
              }
              my $etln = $src->local_name;
              $r .= $etln;
              $etag .= $etln . '>';
              
              ## Attribute specifications
              for my $an (sort keys %attrr) {
                push @csrc, ' ' . $an . '="', @{$attrr{$an}}, '"';
              }

              ## Children
              push @csrc, '>', @{$src->child_nodes}, $etag, [];
              unshift @src, @csrc;
            } elsif ($srcnt == <C::Node.TEXT_NODE>) {
              $r .= $xescape->($src->node_value);
            } elsif ($srcnt == <C::Node.CDATA_SECTION_NODE>) {
              my $text = $src->node_value;
              $text =~ s/]]>/]]]]>&gt;<![CDATA[/g;
              $r .= '<![CDATA[' . $text . ']]>';
            } elsif ($srcnt == <C::Node.ENTITY_REFERENCE_NODE>) {
              if ($src->manakai_expanded) {
                push @src, @{$src->child_nodes};
              } else {
                $r .= '&' . $src->node_name . ';';
              }
            } elsif ($srcnt == <C::Node.PROCESSING_INSTRUCTION_NODE>) {
              $r .= '<?' . $src->node_name;
              my $data = $src->node_value;
              if (length $data) {
                $data =~ s/\?>/?&gt;/g;
                $r .= ' ' . $data;
              }
              $r .= '?>';
            } elsif ($srcnt == <C::Node.COMMENT_NODE>) {
              my $data = $src->node_value;
              $data =~ s/--/- - /g;
              $r .= '<!--' . $data . '-->';
            } elsif ($srcnt == <C::Node.DOCUMENT_NODE>) {
              unshift @src, map {$_, "\x0A"} @{$src->child_nodes};
              ## ISSUE: |cfg:strict-document-children| cparam
            }
            # document type, entity, notation, etdef, atdef, df
          } else {
            $r .= $src;
          }
        }
##SimpleXMLSerializer

ResourceDef:
  @QName: Node
  @AliasFor: tc|Node
