Module:
  @QName: MDOM|XDoctype
  @Namespace:
    http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#
  
  @FullName:
    @@lang:en
    @@@:
      DOM XML Document Type Definition Module
  @enDesc:
    The <DFN::DOM XML Document Type Definition Module>,
    a manakai extension module, provides a set of
    interfaces via which applications can access
    to document type definitions of XML documents,
    including both read and write accesses.
  
  @DISCore:author: DISCore|Wakaba
  @License: license|Perl+MPL
  @Date:
    $Date: 2006/11/05 09:16:30 $
  
  @Require:
    @@Module:
      @@@QName: MDOM|TreeCore
      @@@WithFor: ManakaiDOM|ManakaiDOMLatest
    @@Module:
      @@@QName: MDOM|XML
      @@@WithFor: ManakaiDOM|ManakaiDOMLatest
    @@Module:
      @@@WithFor: ManakaiDOM|ManakaiDOMLatest
  @DefaultFor: ManakaiDOM|ManakaiDOMLatest
  
Namespace:
  @c:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#
  @cfg:
    http://suika.fam.cx/www/2006/dom-config/
  @d:
    http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#
  @dis:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#dis--
  @DOMMain:
    http://suika.fam.cx/~wakaba/archive/2004/dom/main#
  @domperl:
    http://suika.fam.cx/~wakaba/archive/2006/dom/perl/
  @dx:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#
  @f:
    http://suika.fam.cx/~wakaba/archive/2004/dom/feature#
  @fe:
    http://suika.fam.cx/www/2006/feature/
  @idl:
    http://suika.fam.cx/~wakaba/archive/2004/dis/IDL#
  @infoset:
    http://www.w3.org/2001/04/infoset#
  @lang:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#
  @license:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/license#
  @ManakaiDOM:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#
  @MDOM:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#ManakaiDOM.
  @MDOMX:
    http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#
  @mg:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Grove/
  @rdf:
    http://www.w3.org/1999/02/22-rdf-syntax-ns#
  @rdfs:
    http://www.w3.org/2000/01/rdf-schema#
  @t:
    http://suika.fam.cx/~wakaba/archive/2004/dom/tree#
  @tc:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/DOM/TreeCore/
  @tcd:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/DOM/CharacterData/
  @td:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/DOM/Document/
  @te:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/DOM/Element/
  @test:
    http://suika.fam.cx/~wakaba/archive/2004/dis/Test#
  @tx:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/DOM/XML/
  @xml:
    http://www.w3.org/XML/1998/namespace

## -- Features

ElementTypeBinding:
  @Name: FeatureDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: f|Feature
    @@For: =ManakaiDOM|all

ElementTypeBinding:
  @Name: FeatureVerDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: f|Feature

ElementTypeBinding:
  @Name: featureQName
  @ElementType:
    f:name
  @ShadowContent:
    @@ContentType: DISCore|QName

FeatureDef:
  @QName: d|Feature
  @featureQName: fe|XDoctype
  @FeatureVerDef:
    @@QName: d|Feature30
    @@f:instanceOf: d|Feature
    @@Version: 3.0

FeatureDef:
  @QName: d|DeclFeature
  @featureQName: fe|XDoctypeDeclaration
  @FeatureVerDef:
    @@QName: d|DeclFeature30
    @@f:instanceOf: d|DeclFeature
    @@Version: 3.0
    @@enImplNote:
      {ISSUE::
        Should it require <Q::d|Feature30>?
      }

ElementTypeBinding:
  @Name: ClsDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType:
      @@@@: dis|MultipleResource
      @@@ForCheck: !ManakaiDOM|ForIF !ManakaiDOM|ForClass
    @@resourceFor:
      @@@@: ManakaiDOM|ForClass
    @@For: ManakaiDOM|ManakaiDOMLatest

    @@DISCore:resourceType:
      @@@@: DISLang|Class
      @@@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: IFClsXDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      @@@@: dis|MultipleResource
      @@@ForCheck: !ManakaiDOM|ForIF !ManakaiDOM|ForClass
    @@resourceFor: ManakaiDOM|ForIF
    @@resourceFor:
      @@@@: ManakaiDOM|ForClass
      @@@ForCheck: ManakaiDOM|ManakaiDOM !=ManakaiDOM|ManakaiDOM
    @@For: ManakaiDOM|DOMLatest
    @@For: =ManakaiDOM|ManakaiDOM

    @@rdf:type:
      @@@@: DISLang|Interface
      @@@ForCheck: ManakaiDOM|ForIF

    @@rdf:type:
      @@@@: DISLang|Class
      @@@ForCheck: ManakaiDOM|ForClass

    @@Implement:
      @@@@: ||+||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames

ElementTypeBinding:
  @Name: PropDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: rdf|Property
    @@For: =ManakaiDOM|all

ElementTypeBinding:
  @Name: IFQName
  @ElementType:
    dis:QName
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForIF

ElementTypeBinding:
  @Name: ClsQName
  @ElementType:
    dis:QName
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: IFISA
  @ElementType:
    dis:ISA
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForIF

ElementTypeBinding:
  @Name: ClsISA
  @ElementType:
    dis:ISA
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: nullCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: ManakaiDOM|InCase
    @@Value:
      @@@is-null:1

ElementTypeBinding:
  @Name: InCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: ManakaiDOM|InCase

ElementTypeBinding:
  @Name: ShortConstGroup
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|ConstGroup
    @@ForCheck: ManakaiDOM|ForIF !=ManakaiDOM|ManakaiDOM
    @@Type: idl|unsignedShort||ManakaiDOM|all
    @@subsetOf: idl|unsignedShort||ManakaiDOM|all

ElementTypeBinding:
  @Name: Const
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Const

ElementTypeBinding:
  @Name: NodeReadOnlyError
  @ElementType:
    dx:raises
  @ShadowContent:
    @@@: MDOMX|NOMOD_THIS
    @@Description:
      @@@lang:en
      @@@@:
        The node is read-only.

ElementTypeBinding:
  @Name: PerlDef
  @ElementType:
    dis:Def
  @ShadowContent:
    @@ContentType: lang|Perl
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: PerlCDef
  @ElementType:
    dis:Def
  @ShadowContent:
    @@ContentType: lang|Perl

ElementTypeBinding:
  @Name: disDef
  @ElementType:
    dis:Def
  @ShadowContent:
    @@ContentType: lang|dis
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: CODE
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISPerl|BlockCode
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: Method
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Method
    @@ForCheck: !=ManakaiDOM|ManakaiDOM

ElementTypeBinding:
  @Name: CMethod
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Method
    @@ForCheck: !=ManakaiDOM|ManakaiDOM ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: IntMethod
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Method
    @@ForCheck:
      ManakaiDOM:ManakaiDOM !=ManakaiDOM:ManakaiDOM ManakaiDOM|ForClass
    @@ManakaiDOM:isForInternal: 1


ElementTypeBinding:
  @Name: Param
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|MethodParameter

ElementTypeBinding:
  @Name: Return
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|MethodReturn

ElementTypeBinding:
  @Name: Attr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Attribute
    @@ForCheck: !=ManakaiDOM|ManakaiDOM

ElementTypeBinding:
  @Name: CAttr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|Attribute
    @@ForCheck: !=ManakaiDOM|ManakaiDOM ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: IntAttr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Attribute
    @@ForCheck: ManakaiDOM|ForClass
    @@ManakaiDOM:isForInternal: 1

ElementTypeBinding:
  @Name: Get
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|AttributeGet

ElementTypeBinding:
  @Name: Set
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|AttributeSet

ElementTypeBinding:
  @Name: Test
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: test|StandaloneTest
    @@ForCheck: ManakaiDOM|ForClass

## -- DOM Implementation

ClsDef:
  @ClsQName: ManakaiDOMImplementationXDoctype

  @enDesc:
    The <Class::ManakaiDOMImplementationXDoctype> class implements
    a factory method to create DOM
    <IF::tx|DocumentType> defined in DOM Level 2 or higher.

  @domperl:classImplementedByObjectsOf: c|ManakaiDOMImplementation
  @Test:
    @@QName: DOMImplementationXDoctype.class.1.test
    @@PerlDef:
      $test->assert_true
          (<Class::c|ManakaiDOMImplementation>->isa
              (<ClassName::ManakaiDOMImplementationXDoctype>));

  @Test:
    @@QName: Impl.new.mg.test
    @@PerlDef:
      local $Message::Util::Grove::GCLatency = 0;

      my $impl;
      __CODE{tc|createImplForTest:: $impl => $impl}__;

      my $bag = $impl->{<H::mg|nodeBag>};
      my $id = $impl->{<H::mg|nodeIDReference>};
        
      $test->id ('interface');
      $test->assert_isa ($impl, <IFName::c|DOMImplementation>);
        
      $test->id ('class');
      $test->assert_isa ($impl, <ClassName::ManakaiDOMImplementationXDoctype>);

      undef $impl;

      $test->id ('gc');
      $test->assert_null ($bag->{$$id});

  @CMethod:
    @@Name: createDocumentType
    @@enDesc:
      Creates an empty <IF::tx|DocumentType> node.  Entity
      declarations and notations are not made available.
      Entity reference expansions and default attribute additions do
      not occur.
    @@DOMMain:isNamespaceAware: 1
    @@enImplNote:
      @@@ddid: xml2feature
      @@@@:
        The <CITE::DOM Level 2 Core> specification said that HTML-only 
        DOM Level 2 implementations does not need to implement this member. 
        The DOM Level 2 Errata withdraws it and it requires HTML-only 
        DOM implementations throw a <X::c|DOMException.NOT_SUPPORTED_ERR>. 
    @@enDesc:
      @@@ddid: manakai
      @@@For: ManakaiDOM|ManakaiDOM
      @@@@:
        In manakai, the method <M::c|DOMImplementation.createDocumentType>
        is <EM::deprecated>; use the method
        <M::DocumentX.createDocumentTypeDefinition> instead.
    @@Param:
      @@@Name: qualifiedName
      @@@Type: DOMString
      @@@enDesc:
        The XML Namespaces 1.0 <SRC::DOM2, DOM3> qualified name of
        the document type to be created.
    @@Param:
      @@@Name: publicId
      @@@Type: DOMString
      @@@enDesc:
        The public identifier of the external subset.
      @@@nullCase:
        @@@@enDesc:
          The external subset has no public identifier or
          the document type has no external subset.  <SRC::manakai>
    @@Param:
      @@@Name: systemId
      @@@Type: DOMString
      @@@enDesc:
        The system identifier of the external subset.
      @@@nullCase:
        @@@@enDesc:
          The external subset has no system identifier or
          the document type has no external subset.  <SRC::manakai>
    @@enImplNote:
      @@@ddid: badparam
      @@@@:
        Can <P::systemId> and / or <P::publicId> be <DOM::null>?

        What should happen if <P::publicId> is non-<DOM::null>
        and <P::systemId> is <DOM::null>?

        What should happen if <P::publicId> or <P::systemId> 
        is ill-formed?
    @@Return:
      @@@Type: tx|DocumentType
      @@@enDesc:
        The newly created <IF::tx|DocumentType> node with
        <A::Node.ownerDocument> set to <DOM::null>.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_BAD_NAME
        @@@@enDesc:
          If the <P::qualifiedName> is not an XML 1.0 <CODE::Name>
          <SRC::DOM3>.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_NS_MALFORMED_QNAME
        @@@@enDesc:
          If the <P::qualifiedName> is malformed.
      @@@enImplNote:
        @@@@ddid: strict
        @@@@@:
          The <A::Document.strictErrorChecking> attribute is
          <EM::not> applied to these errors, since it has no
          associated <IF::Document> node.
      @@@iRaises:
        @@@@@: MDOMX|MDOM_IMPL_NOSUPPORT_XMLNS
        @@@@enDesc:
          This exception may be raised if the implementation does not support 
          the feature <Feature::XML> and the language exposed through
          the document does not support XML namespaces.
        @@@@enImplNote:
          <QUOTE::Document>?  What document?
      @@@PerlDef:
        ## Validate |qualifiedName| - don't use |InputProcessor|
        ## since it refers |strictErrorChecking| attribute.
        unless (<Code::DOMMain|testXML10Name:: $INPUT = $qualifiedName>) {
          __EXCEPTION{MDOMX|MDOM_BAD_NAME::
            infoset|name => {$qualifiedName},
            MDOMX|param-name => 'qualifiedName',
            infoset|version => '1.0',
          }__;
        }
        unless (<Code::DOMMain|testXML10QName:: $INPUT = $qualifiedName>) {
          __EXCEPTION{MDOMX|MDOM_NS_MALFORMED_QNAME::
            infoset|name => {$qualifiedName},
            MDOMX|param-name => 'qualifiedName',
            infoset|version => '1.0',
          }__;
        }

        my $bag = <Code::mg|getNodeBag||ManakaiDOM|all:: $ref = $self>;
        my $stem;
        __CODE{mg|createNodeStem||ManakaiDOM|all::
          $bag => $bag,
          $stem => $stem,
          $class => {<ClassName::d|ManakaiDOMDocumentTypeDefinition>},
          $opt => {{
            <H::infoset|name> => \$qualifiedName,
            <H::f|implementation> => $self,
          }},
        }__;
        __CODE{mg|createNodeRef||ManakaiDOM|all::
          $bag => $bag,
          $stem => $stem,
          $ref => $r,
          $opt => {{}},
        }__;

        if (defined $publicId){ 
          $r-><AS::tx|DocumentType.publicId> ($publicId);
        }
        if (defined $systemId){ 
          $r-><AS::tx|DocumentType.systemId> ($systemId);
        }
        $r-><M::Node.manakaiSetReadOnly> (true, true);

    @@Test:
      @@@QName: DOMImplDoc.createDocumentType.ncname.test
      @@@PerlDef:
        my $impl;
        __CODE{tc|createImplForTest:: $impl => $impl}__;

        $test->id ('create');
        my $dtype = $impl-><M::c|DOMImplementation.createDocumentType> ('qname');
        $test->assert_isa ($dtype, <IFName::tx|DocumentType>);

        $test->id ('nodeName');
        $test->assert_equals ($dtype-><AG::Node.nodeName>, 'qname');
    @@Test:
      @@@QName: DOMImplDoc.createDocumentType.qname.test
      @@@PerlDef:
        my $impl;
        __CODE{tc|createImplForTest:: $impl => $impl}__;

        $test->id ('create');
        my $dtype = $impl-><M::c|DOMImplementation.createDocumentType>
                             ('pfx:qname');
        $test->assert_isa ($dtype, <IFName::tx|DocumentType>);

        $test->id ('nodeName');
        $test->assert_equals ($dtype-><AG::Node.nodeName>, 'pfx:qname');
    @@Test:
      @@@QName: DOMImplDoc.createDocumentType.non.name11.test
      @@@PerlDef:
        my $impl;
        __CODE{tc|createImplForTest:: $impl => $impl}__;

        $test->id ('create');
        $test->assert_exception (code => sub {
          $impl-><M::c|DOMImplementation.createDocumentType> ('12345');
        }, exception_subtype => <Q::MDOMX|MDOM_BAD_NAME>);
    @@Test:
      @@@QName: DOMImplDoc.createDocumentType.name11.non.name10.test
      @@@PerlDef:
        my $impl;
        __CODE{tc|createImplForTest:: $impl => $impl}__;

        $test->id ('create');
        $test->assert_exception (code => sub {
          $impl-><M::c|DOMImplementation.createDocumentType>
                   ("\x{3001}\x{3002}");
                   ## A Name in XML 1.1 but not in XML 1.0.
        }, exception_subtype => <Q::MDOMX|MDOM_BAD_NAME>);
    @@Test:
      @@@QName: DOMImplDoc.createDocumentType.non.qname11.test
      @@@PerlDef:
        my $impl;
        __CODE{tc|createImplForTest:: $impl => $impl}__;

        $test->id ('create');
        $test->assert_exception (code => sub {
          $impl-><M::c|DOMImplementation.createDocumentType> (':aa');
        }, exception_subtype => <Q::MDOMX|MDOM_NS_MALFORMED_QNAME>);
    @@Test:
      @@@QName: DOMImplDoc.createDocumentType.qname11.non.qname10.test
      @@@PerlDef:
        my $impl;
        __CODE{tc|createImplForTest:: $impl => $impl}__;

        $test->id ('create');
        $test->assert_exception (code => sub {
          $impl-><M::c|DOMImplementation.createDocumentType>
                   ("a:\x{3005}b");
                    ## A QName in XMLNames 1.1 but not in XMLNames 1.0.
        }, exception_subtype => <Q::MDOMX|MDOM_NS_MALFORMED_QNAME>);
    @@Test:
      @@@QName: DOMImplDoc.createDocumentType.pubid.sysid.test
      @@@PerlDef:
        my $impl;
        __CODE{tc|createImplForTest:: $impl => $impl}__;

        $test->id ('create');
        my $dtype = $impl-><M::c|DOMImplementation.createDocumentType>
                             ('qname', 'pubid', 'sysid');
        $test->assert_isa ($dtype, <IFName::tx|DocumentType>);

        $test->id ('nodeName');
        $test->assert_equals ($dtype-><AG::Node.nodeName>, 'qname');

        $test->id ('publicId');
        $test->assert_equals ($dtype-><AG::tx|DocumentType.publicId>, 'pubid');

        $test->id ('systemId');
        $test->assert_equals ($dtype-><AG::tx|DocumentType.systemId>, 'sysid');
##DOMImplementationXDoctype

ElementTypeBinding:
  @Name: iRaises
  @ElementType:
    dx:raises
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForIF

## -- Document

IFClsXDef:
  @IFQName: DocumentXDoctype
  @ClsQName: ManakaiDOMDocumentXDoctype

  @domperl:implementedByObjectsOf: td|Document
  @domperl:classImplementedByObjectsOf: td|ManakaiDOMDocument  

  @f:implements: d|Feature30
  @f:provides:
    @@@: d|Feature30
    @@f:through: c|ManakaiDOMImplementation
  
  @enDesc:
    The <IF::DocumentXDoctype> interface provides 
    methods to create definition nodes.
    
    Objects implementing <IF::DocumentXDoctype>
    interface <kwd:MUST> also implement the
    <IF::Document> interface.

  @CODE:
    @@QName: d|createEmptyDocumentXForTest
    @@PerlDef:
      my $__impl;
      __CODE{tc|createImplForTest:: $impl => $__impl}__;
      my $__doc = $__impl-><M::c|DOMImplementation.createDocument>;
      $docx = $__doc-><M::Node.getFeature> (<Q::fe|XDoctype>, '3.0');

  @Test:
    @@QName: DocumentXDoctype.interfaces.test
    @@PerlDef:
      my $doc;
      __CODE{d|createEmptyDocumentXForTest:: $docx => $doc}__;
       
      $test->id ('DocumentXDoctype');
      $test->assert_isa ($doc, <IFName::DocumentXDoctype>);

      $test->id ('Document');
      $test->assert_isa ($doc, <IFName::Document>);

      $test->id ('Node');
      $test->assert_isa ($doc, <IFName::Node>);

  @Test:
    @@QName: Document.getFeature.xdoctype.test
    @@PerlDef:
      my $node;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $node}__;

        for (
          [<Q::fe|XDoctype> => '3.0',
           <IFName::DocumentXDoctype||ManakaiDOM|ManakaiDOMLatest>],
        ) {
          $test->id ($_->[0].'.'.$_->[1]);
          my $sp = $node-><M::Node.getFeature> ($_->[0], $_->[1]);
          $test->assert_isa ($sp, $_->[2]);
        }
  @Test:
    @@QName: DocumentX.getFeature.xdoctype.test
    @@PerlDef:
      my $node;
      __CODE{d|createEmptyDocumentXForTest:: $docx => $node}__;

        for (
          [<Q::fe|XDoctype> => '3.0',
           <IFName::DocumentXDoctype||ManakaiDOM|ManakaiDOMLatest>],
        ) {
          $test->id ($_->[0].'.'.$_->[1]);
          my $sp = $node-><M::Node.getFeature> ($_->[0], $_->[1]);
          $test->assert_isa ($sp, $_->[2]);
        }
    
  @Method:
    @@Name: createDocumentTypeDefinition
    @@enDesc:
      Creates a <IF::DocumentTypeDefinition> node of the
      given name.
    @@enDesc:
      @@@ddid: decl
      @@@@:
        If the implementation supports the <Feature::fe|XDoctypeDeclaration>
        feature, the newly created object <kwd:MUST> also implement
        the <IF::DocumentTypeDeclaration> interface.  In addition,
        the object <kwd:MUST> contain general entity declarations
        for five predefined entities as specified in XML specifications.
    @@DOMMain:isNamespaceUnaware: 1
    @@Param:
      @@@Name: name
      @@@Type: DOMString
      @@@enDesc:
        The document type name of the node to create.
    @@Return:
      @@@Type: DocumentTypeDefinition
        {P:: The newly created <IF::DocumentTypeDefinition> node with:
        
          - <A::Node.nodeName>::: <P::name>.

          - <A::Node.ownerDocument>::: The <IF::Document>.

          - <A::Node.parentNode>::: <DOM::null>.

          - <A::Node.childNodes>::: An empty <IF::tc|NodeList>.

          - <A::DocumentTypeDefinition.elementTypes>:::
                An empty <IF::tc|NamedNodeMap>.

          - <A::DocumentTypeDefinition.generalEntities>:::
                An empty <IF::tc|NamedNodeMap>.

          - <A::DocumentTypeDefinition.notations>:::
                An empty <IF::tc|NamedNodeMap>.
 
          - <A::DocumentTypeDeclaration.publicId>::: <DOM::null>.

          - <A::DocumentTypeDeclaration.systemId>::: <DOM::null>.

          - <A::tx|DocumentType.internalSubset>::: <DOM::null>.

          - <A::Node.manakaiReadOnly>::: <DOM::false>.

        }
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_BAD_NAME
        @@@@enDesc:
          The <P::name> is not an XML <CODE::Name> according to
          the XML version in use specified in the 
          <A::Document.xmlVersion> attribute.

          Note that the <P::name> don't have to be a namespace
          qualified name.

          If the <A::Document.strictErrorChecking> attribute is
          set to <DOM::false>, the implementation is <EM::not>
          <kwd:REQUIRED> to throw this exception.
      @@@PerlDef:
        if ($self-><AG::Document.strictErrorChecking>) {
          my $version = $self-><AG::Document.xmlVersion>;
          __CODE{DOMMain|ensureXMLName::
            $INPUT => $name, $INPUT_PARAM_NAME => 'name',
            $XMLVERSION => $version,
          }__;
        }

        my $bag = <Code::mg|getNodeBag||ManakaiDOM|all:: $ref = $self>;
        my $stem;
        __CODE{mg|createNodeStem||ManakaiDOM|all::
          $bag => $bag,
          $stem => $stem,
          $class => {<ClassName::ManakaiDOMDocumentTypeDefinition>},
          $opt => {{
            <H::infoset|name> => \$name,
            <H::tc|ownerDocument> => $self,
          }},
        }__;
        __CODE{mg|createNodeRef||ManakaiDOM|all::
          $bag => $bag,
          $stem => $stem,
          $ref => $r,
          $opt => {{
          }},
        }__;
        __CODE{mg|setNodeStemPropValue||ManakaiDOM|all::
          $given => {true},
          $prop => {<H::d|hasLtDeclaration>},
          $ref => $self,
        }__;
        __CODE{mg|setNodeStemPropValue||ManakaiDOM|all::
          $given => {true},
          $prop => {<H::d|hasGtDeclaration>},
          $ref => $self,
        }__;
        __CODE{mg|setNodeStemPropValue||ManakaiDOM|all::
          $given => {true},
          $prop => {<H::d|hasAmpDeclaration>},
          $ref => $self,
        }__;
        __CODE{mg|setNodeStemPropValue||ManakaiDOM|all::
          $given => {true},
          $prop => {<H::d|hasAposDeclaration>},
          $ref => $self,
        }__;
        __CODE{mg|setNodeStemPropValue||ManakaiDOM|all::
          $given => {true},
          $prop => {<H::d|hasQuotDeclaration>},
          $ref => $self,
        }__;

    @@Test:
      @@@QName:
        ManakaiDocumentXDoctype.createDocumentTypeDefinition.success.test
      @@@PerlDef:
        my $doc;
        __CODE{d|createEmptyDocumentXForTest:: $docx => $doc}__;
        my $dtd = $doc-><M::DocumentXDoctype.createDocumentTypeDefinition>
                          ('abcdefg');
        
        $test->assert_not_null ($dtd);
        $test->assert_equals ($dtd-><AG::Node.nodeType>,
                              <C::Node.DOCUMENT_TYPE_NODE>); 
        $test->assert_string (actual_value => $dtd-><AG::Node.nodeName>,
                              expected_value => 'abcdefg'); 
        $test->assert_isa ($dtd, <IFName::DocumentTypeDefinition>);
    
    @@Test:
      @@@QName:
        ManakaiDocumentXDoctype.createDocumentTypeDefinition.badname.test
      @@@PerlDef:
        my $doc;
        __CODE{d|createEmptyDocumentXForTest:: $docx => $doc}__;
        $test->assert_exception
                 (code => sub {
                    my $dtd = $doc-><M::DocumentXDoctype
                                         .createDocumentTypeDefinition>
                                      ('0120');
                  },
                  exception_subtype => <Q::MDOMX|MDOM_BAD_NAME>);
    @@Test:
      @@@QName:
        ManakaiDocumentXDoctype.createDocumentTypeDefinition.badname.2.test
      @@@PerlDef:
        my $doc;
        __CODE{d|createEmptyDocumentXForTest:: $docx => $doc}__;
        $doc-><AS::Document.strictErrorChecking> (false);
        my $dtd = $doc-><M::DocumentXDoctype.createDocumentTypeDefinition>
                          ('0120');
        
        $test->assert_string (actual_value => $dtd-><AG::Node.nodeName>,
                              expected_value => '0120'); 

  @Method:
    @@Name: createElementTypeDefinition
    @@enDesc:
      Creates an <IF::ElementTypeDefinition> with the given
      element type name.
    @@DOMMain:isNamespaceUnaware: 1
    @@Param:
      @@@Name: name
      @@@Type: DOMString
      @@@enDesc:
        The element type name of the node to create.
    @@Return:
      @@@Type: ElementTypeDefinition
      @@@enDesc:
        {P:: The newly created <IF::ElementTypeDefinition> node with:
        
          - <A::Node.nodeName>::: <P::name>.

          - <A::Node.ownerDocument>::: The <IF::Document>.

          - <A::ElementTypeDefinition.ownerDocumentTypeDefinition>:::
                <DOM::null>.

          - <A::ElementTypeDefinition.attributeDefinitions>:::
                An empty <IF::tc|NamedNodeMap>.

          - <A::Node.manakaiReadOnly>::: <DOM::false>.

        }
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_BAD_NAME
        @@@@enDesc:
          The <P::name> is not an XML <CODE::Name> according to
          the XML version in use specified in the 
          <A::Document.xmlVersion> attribute.

          Note that the <P::name> don't have to be a namespace
          qualified name.

          If the <A::Document.strictErrorChecking> attribute is
          set to <DOM::false>, the implementation is <EM::not>
          <kwd:REQUIRED> to throw this exception.
      @@@PerlDef:
        if ($self-><AG::Document.strictErrorChecking>) {
          my $version = $self-><AG::Document.xmlVersion>;
          __CODE{DOMMain|ensureXMLName::
            $INPUT => $name, $INPUT_PARAM_NAME => 'name',
            $XMLVERSION => $version,
          }__;
        }

        my $bag = <Code::mg|getNodeBag||ManakaiDOM|all:: $ref = $self>;
        my $stem;
        __CODE{mg|createNodeStem||ManakaiDOM|all::
          $bag => $bag,
          $stem => $stem,
          $class => {<ClassName::ManakaiDOMElementTypeDefinition>},
          $opt => {{
            <H::infoset|name> => \$name,
            <H::tc|ownerDocument> => $self,
          }},
        }__;
        __CODE{mg|createNodeRef||ManakaiDOM|all::
          $bag => $bag,
          $stem => $stem,
          $ref => $r,
          $opt => {{
          }},
        }__;

    @@Test:
      @@@QName:
        ManakaiDocumentXDoctype.createElementTypeDefinition.success.test
      @@@PerlDef:
        my $doc;
        __CODE{d|createEmptyDocumentXForTest:: $docx => $doc}__;
        my $dtd = $doc-><M::DocumentXDoctype.createElementTypeDefinition>
                          ('abcdefg');
        
        $test->assert_not_null ($dtd);
        $test->assert_equals ($dtd-><AG::Node.nodeType>,
                              <C::Node.ELEMENT_TYPE_DEFINITION_NODE>); 
        $test->assert_string (actual_value => $dtd-><AG::Node.nodeName>,
                              expected_value => 'abcdefg'); 
    
    @@Test:
      @@@QName:
        ManakaiDocumentXDoctype.createElementTypeDefinition.badname.test
      @@@PerlDef:
        my $doc;
        __CODE{d|createEmptyDocumentXForTest:: $docx => $doc}__;
        $test->assert_exception
                 (code => sub {
                    my $dtd = $doc-><M::DocumentXDoctype
                                         .createElementTypeDefinition>
                                      ('0120');
                  },
                  exception_subtype => <Q::MDOMX|MDOM_BAD_NAME>);
    @@Test:
      @@@QName:
        ManakaiDocumentXDoctype.createElementTypeDefinition.badname.2.test
      @@@PerlDef:
        my $doc;
        __CODE{d|createEmptyDocumentXForTest:: $docx => $doc}__;
        $doc-><AS::Document.strictErrorChecking> (false);
        my $dtd = $doc-><M::DocumentXDoctype.createElementTypeDefinition>
                          ('0120');
        
        $test->assert_string (actual_value => $dtd-><AG::Node.nodeName>,
                              expected_value => '0120'); 
    
  @Method:
    @@Name: createAttributeDefinition
    @@enDesc:
      Creates an <IF::AttributeDefinition> with the given name.
    @@DOMMain:isNamespaceUnaware: 1
    @@Param:
      @@@Name: name
      @@@Type: DOMString
      @@@enDesc:
        The attribute name of the node to create.
    @@Return:
      @@@Type: AttributeDefinition
      @@@enDesc:
        {P:: The newly created <IF::AttributeDefinition> node with:
        
          - <A::Node.nodeName>::: <P::name>.

          - <A::Node.ownerDocument>::: The <IF::Document>.

          - <A::AttributeDefinition.ownerElementTypeDefinition>:::
                <DOM::null>.

          {LI:: <A::AttributeDefinition.declaredType>:::
                <C::AttributeDefinition.NO_TYPE_ATTR>.

                However, if the <cfg::cfg|xml-id> configuration
                parameter is set to <DOM::true> and the <P::name>
                is <XA::xml:id>, then the attribute is set to
                <C::AttributeDefinition.ID_ATTR>.

          }

          - <A::AttributeDefinition.defaultType>:::
                <C::AttributeDefinition.UNKNOWN_DEFAULT>.

          - <A::AttributeDefinition.allowedTokens>:::
                An empty <IF::c|DOMStringList>.

          - <A::Node.childNodes>::: An empty <IF::tc|NodeList>.

          - <A::Node.manakaiReadOnly>::: <DOM::false>.

        }
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_BAD_NAME
        @@@@enDesc:
          The <P::name> is not an XML <CODE::Name> according to
          the XML version in use specified in the 
          <A::Document.xmlVersion> attribute.

          Note that the <P::name> don't have to be a namespace
          qualified name.

          If the <A::Document.strictErrorChecking> attribute is
          set to <DOM::false>, the implementation is <EM::not>
          <kwd:REQUIRED> to throw this exception.
      @@@PerlDef:
        if ($self-><AG::Document.strictErrorChecking>) {
          my $version = $self-><AG::Document.xmlVersion>;
          __CODE{DOMMain|ensureXMLName::
            $INPUT => $name, $INPUT_PARAM_NAME => 'name',
            $XMLVERSION => $version,
          }__;
        }

        my $bag = <Code::mg|getNodeBag||ManakaiDOM|all:: $ref = $self>;
        my $stem;
        __CODE{mg|createNodeStem||ManakaiDOM|all::
          $bag => $bag,
          $stem => $stem,
          $class => {<ClassName::ManakaiDOMAttributeDefinition>},
          $opt => {{
            <H::infoset|name> => \$name,
            <H::tc|ownerDocument> => $self,
          }},
        }__;
        __CODE{mg|createNodeRef||ManakaiDOM|all::
          $bag => $bag,
          $stem => $stem,
          $ref => $r,
          $opt => {{
          }},
        }__;

        __DEEP{
          if ($name eq 'xml:id' and
              $self-><AG::Document.domConfig>
                   -><M::c|DOMConfiguration.getParameter> (<Q::cfg|xml-id>)) {
            $r-><AS::AttributeDefinition.declaredType>
                  (<C::AttributeDefinition.ID_ATTR>);
          }
        }__;

    @@Test:
      @@@QName:
        ManakaiDocumentXDoctype.createAttributeDefinition.success.test
      @@@PerlDef:
        my $doc;
        __CODE{d|createEmptyDocumentXForTest:: $docx => $doc}__;
        my $dtd = $doc-><M::DocumentXDoctype.createAttributeDefinition>
                          ('abcdefg');
        
        $test->assert_not_null ($dtd);
        $test->assert_equals ($dtd-><AG::Node.nodeType>,
                              <C::Node.ATTRIBUTE_DEFINITION_NODE>); 
        $test->assert_string (actual_value => $dtd-><AG::Node.nodeName>,
                              expected_value => 'abcdefg'); 
    
    @@Test:
      @@@QName:
        ManakaiDocumentXDoctype.createAttributeDefinition.badname.test
      @@@PerlDef:
        my $doc;
        __CODE{d|createEmptyDocumentXForTest:: $docx => $doc}__;
        $test->assert_exception
                 (code => sub {
                    my $dtd = $doc-><M::DocumentXDoctype
                                         .createAttributeDefinition>
                                      ('0120');
                  },
                  exception_subtype => <Q::MDOMX|MDOM_BAD_NAME>);
    @@Test:
      @@@QName:
        ManakaiDocumentXDoctype.createAttributeDefinition.badname.2.test
      @@@PerlDef:
        my $doc;
        __CODE{d|createEmptyDocumentXForTest:: $docx => $doc}__;
        $doc-><AS::Document.strictErrorChecking> (false);
        my $dtd = $doc-><M::DocumentXDoctype.createAttributeDefinition>
                          ('0120');
        
        $test->assert_string (actual_value => $dtd-><AG::Node.nodeName>,
                              expected_value => '0120'); 

    @@Test:
      @@@QName: DocXDoctype.createAtDef.xmlid.test
      @@@PerlDef:
        my $doc;
        __CODE{d|createEmptyDocumentXForTest:: $docx => $doc}__;

        my $cfg = $doc-><AG::Document.domConfig>;

        $cfg-><M::c|DOMConfiguration.setParameter> (<Q::cfg|xml-id> => true);

        $test->id ('id');
        my $at = $doc-><M::DocumentXDoctype.createAttributeDefinition>
                         ('xml:id');
        $test->assert_num_equals
                 (actual_value => $at-><AG::AttributeDefinition.declaredType>,
                  expected_value => <C::AttributeDefinition.ID_ATTR>);
        
        $cfg-><M::c|DOMConfiguration.setParameter> (<Q::cfg|xml-id> => false);

        $test->id ('nonid');
        my $at2 = $doc-><M::DocumentXDoctype.createAttributeDefinition>
                          ('xml:id');
        $test->assert_num_equals
                 (actual_value => $at2-><AG::AttributeDefinition.declaredType>,
                  expected_value => <C::AttributeDefinition.NO_TYPE_ATTR>);
    
  @Method:
    @@Name: createGeneralEntity
    @@enDesc:
      Creates an <IF::tx|Entity> node, which represents
      a general entity, with the given name.
    @@DOMMain:isNamespaceUnaware: 1
    @@Param:
      @@@Name: name
      @@@Type: DOMString
      @@@enDesc:
        The name of the general entity node to create.
    @@Return:
      @@@Type: tx|Entity
      @@@enDesc:
        {P:: The newly created <IF::tx|Entity> node with:
        
          - <A::Node.nodeName>::: <P::name>.

          - <A::Node.ownerDocument>::: The <IF::Document>.

          - <A::tx|Entity.ownerDocumentTypeDefinition>::: <DOM::null>.

          - <A::Node.childNodes>::: An empty <IF::tc|NodeList>.

          - <A::tx|Entity.manakaiHasReplacementTree>::: <DOM::false>.

          - <A::tx|Entity.publicId>::: <DOM::null>.

          - <A::tx|Entity.systemId>::: <DOM::null>.

          - <A::tx|Entity.notationName>::: <DOM::null>.

          - <A::tx|Entity.manakaiDeclarationBaseURI>::: No explicit
                value is set.

          - <A::tx|Entity.manakaiEntityURI>::: No explicit value is set.

          - <A::tx|Entity.manakaiEntityBaseURI>::: No explicit value
                is set.

          - <A::Node.manakaiReadOnly>::: <DOM::false>.

        }
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_BAD_NAME
        @@@@enDesc:
          The <P::name> is not an XML <CODE::Name> according to
          the XML version in use specified in the 
          <A::Document.xmlVersion> attribute.

          Note that the <P::name> don't have to be a namespace
          qualified name.

          Note also that it is not an error for the <P::name>
          to match to the name of one of predefined general
          parsed entities in XML or HTML.

          If the <A::Document.strictErrorChecking> attribute is
          set to <DOM::false>, the implementation is <EM::not>
          <kwd:REQUIRED> to throw this exception.
      @@@PerlDef:
        require Message::DOM::XML;

        if ($self-><AG::Document.strictErrorChecking>) {
          my $version = $self-><AG::Document.xmlVersion>;
          __CODE{DOMMain|ensureXMLName::
            $INPUT => $name, $INPUT_PARAM_NAME => 'name',
            $XMLVERSION => $version,
          }__;
        }

        my $bag = <Code::mg|getNodeBag||ManakaiDOM|all:: $ref = $self>;
        my $stem;
        __CODE{mg|createNodeStem||ManakaiDOM|all::
          $bag => $bag,
          $stem => $stem,
          $class => {<ClassName::tx|ManakaiDOMEntity>},
          $opt => {{
            <H::infoset|name> => \$name,
            <H::tc|ownerDocument> => $self,
          }},
        }__;
        __CODE{mg|createNodeRef||ManakaiDOM|all::
          $bag => $bag,
          $stem => $stem,
          $ref => $r,
          $opt => {{
          }},
        }__;

    @@Test:
      @@@QName:
        ManakaiDocumentXDoctype.createGeneralEntity.success.test
      @@@PerlDef:
        my $doc;
        __CODE{d|createEmptyDocumentXForTest:: $docx => $doc}__;
        my $dtd = $doc-><M::DocumentXDoctype.createGeneralEntity>
                          ('abcdefg');
        
        $test->assert_not_null ($dtd);
        $test->assert_equals ($dtd-><AG::Node.nodeType>,
                              <C::Node.ENTITY_NODE>); 
        $test->assert_string (actual_value => $dtd-><AG::Node.nodeName>,
                              expected_value => 'abcdefg'); 
    
    @@Test:
      @@@QName:
        ManakaiDocumentXDoctype.createGeneralEntity.badname.test
      @@@PerlDef:
        my $doc;
        __CODE{d|createEmptyDocumentXForTest:: $docx => $doc}__;
        $test->assert_exception
                 (code => sub {
                    my $dtd = $doc-><M::DocumentXDoctype.createGeneralEntity>
                                      ('0120');
                  },
                  exception_subtype => <Q::MDOMX|MDOM_BAD_NAME>);
    @@Test:
      @@@QName:
        ManakaiDocumentXDoctype.createGeneralEntity.badname.2.test
      @@@PerlDef:
        my $doc;
        __CODE{d|createEmptyDocumentXForTest:: $docx => $doc}__;
        $doc-><AS::Document.strictErrorChecking> (false);
        my $dtd = $doc-><M::DocumentXDoctype.createGeneralEntity>
                          ('0120');
        
        $test->assert_isa ($dtd, <IFName::tx|Entity>);
        $test->assert_equals ($dtd-><AG::Node.nodeType>,
                              <C::Node.ENTITY_NODE>); 
        $test->assert_string (actual_value => $dtd-><AG::Node.nodeName>,
                              expected_value => '0120'); 
    
  @Method:
    @@Name: createNotation
    @@enDesc:
      Creates a <IF::tx|Notation> node with the given name.
    @@DOMMain:isNamespaceUnaware: 1
    @@Param:
      @@@Name: name
      @@@Type: DOMString
      @@@enDesc:
        The name of the notation node to create.
    @@Return:
      @@@Type: tx|Notation
      @@@enDesc:
        {P:: The newly created <IF::tx|Notation> node with:
        
          - <A::Node.nodeName>::: <P::name>.

          - <A::Node.ownerDocument>::: The <IF::Document>.

          - <A::tx|Notation.ownerDocumentTypeDefinition>::: <DOM::null>.

          - <A::tx|Notation.publicId>::: <DOM::null>.

          - <A::tx|Notation.systemId>::: <DOM::null>.

          - <A::tx|Notation.manakaiDeclarationBaseURI>::: No explicit
                value is set.

          - <A::Node.manakaiReadOnly>::: <DOM::false>.

        }
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_BAD_NAME
        @@@@enDesc:
          The <P::name> is not an XML <CODE::Name> according to
          the XML version in use specified in the 
          <A::Document.xmlVersion> attribute.

          Note that the <P::name> don't have to be a namespace
          qualified name.

          If the <A::Document.strictErrorChecking> attribute is
          set to <DOM::false>, the implementation is <EM::not>
          <kwd:REQUIRED> to throw this exception.
      @@@PerlDef:
        require Message::DOM::XML;

        if ($self-><AG::Document.strictErrorChecking>) {
          my $version = $self-><AG::Document.xmlVersion>;
          __CODE{DOMMain|ensureXMLName::
            $INPUT => $name, $INPUT_PARAM_NAME => 'name',
            $XMLVERSION => $version,
          }__;
        }

        my $bag = <Code::mg|getNodeBag||ManakaiDOM|all:: $ref = $self>;
        my $stem;
        __CODE{mg|createNodeStem||ManakaiDOM|all::
          $bag => $bag,
          $stem => $stem,
          $class => {<ClassName::tx|ManakaiDOMNotation>},
          $opt => {{
            <H::infoset|name> => \$name,
            <H::tc|ownerDocument> => $self,
          }},
        }__;
        __CODE{mg|createNodeRef||ManakaiDOM|all::
          $bag => $bag,
          $stem => $stem,
          $ref => $r,
          $opt => {{
          }},
        }__;

    @@Test:
      @@@QName:
        ManakaiDocumentXDoctype.createNotation.success.test
      @@@PerlDef:
        my $doc;
        __CODE{d|createEmptyDocumentXForTest:: $docx => $doc}__;
        my $dtd = $doc-><M::DocumentXDoctype.createNotation>
                          ('abcdefg');
        
        $test->assert_isa ($dtd, <IFName::tx|Notation>);
        $test->assert_equals ($dtd-><AG::Node.nodeType>,
                              <C::Node.NOTATION_NODE>); 
        $test->assert_string (actual_value => $dtd-><AG::Node.nodeName>,
                              expected_value => 'abcdefg'); 
    
    @@Test:
      @@@QName:
        ManakaiDocumentXDoctype.createNotation.badname.test
      @@@PerlDef:
        my $doc;
        __CODE{d|createEmptyDocumentXForTest:: $docx => $doc}__;
        $test->assert_exception
                 (code => sub {
                    my $dtd = $doc-><M::DocumentXDoctype.createNotation>
                                      ('0120');
                  },
                  exception_subtype => <Q::MDOMX|MDOM_BAD_NAME>);
    @@Test:
      @@@QName:
        ManakaiDocumentXDoctype.createNotation.badname.2.test
      @@@PerlDef:
        my $doc;
        __CODE{d|createEmptyDocumentXForTest:: $docx => $doc}__;
        $doc-><AS::Document.strictErrorChecking> (false);
        my $dtd = $doc-><M::DocumentXDoctype.createNotation>
                          ('0120');
        
        $test->assert_isa ($dtd, <IFName::tx|Notation>);
        $test->assert_equals ($dtd-><AG::Node.nodeType>,
                              <C::Node.NOTATION_NODE>); 
        $test->assert_string (actual_value => $dtd-><AG::Node.nodeName>,
                              expected_value => '0120'); 
##DocumentXDoctype

IFClsXDef:
  @IFQName: DocumentTypeDefinition
  @ClsQName: ManakaiDOMDocumentTypeDefinition
  
  @ClsISA: ManakaiDOMDocumentTypeDeclaration
  @ClsISA: tc|ManakaiDOMNode

  @Implement: tx|DocumentType||ManakaiDOM|ManakaiDOM1
  @Implement: tx|DocumentType||ManakaiDOM|ManakaiDOM2
  @Implement: tx|DocumentType||ManakaiDOM|ManakaiDOM3
  @Implement: tx|DocumentType||ManakaiDOM|ManakaiDOMLatest
  
  @DISLang:role: tc|DocumentTypeRole

  @f:implements: d|Feature30
  
  @enDesc:
    A <IF::DocumentTypeDefinition> node represents
    a set of definitions for a document type.
    
    Objects implementing the <IF::DocumentTypeDefinition>
    interface <kwd:MAY> also implement the <IF::tx|DocumentType>
    interface and / or the <IF::DocumentTypeDeclaration> interface.
    Although some attributes are defined by two or three of these
    interfaces, objects implementing these interfaces have to
    implement them only once respectively.
    
    In DOM levels 1, 2, and 3, a <IF::tx|DocumentType> object
    can never have child node.  A <IF::DocumentTypeDefinition>
    node, however, <kwd:MAY> have <IF::tx|ProcessingInstruction>
    child nodes, as in <InfoProp::children> property of 
    <InfoItem::processing instruction information item> in
    XML Information Set.
    
    If a <IF::DocumentTypeDefinition> node is not associated
    with any document yet, then its <A::Node.ownerDocument>
    attribute value is <DOM::null>.  Otherwise, the
    attribute contains the attribute to which the node
    is associated.  Note that the
    <M::DocumentXDoctype.createDocumentTypeDefinition>
    method will set the document to the <A::Node.ownerDocument>
    attribute.
  
  @IntMethod:
    @@Operator: mg|CreateNodeStemMethod
    @@Param:
      @@@Name: bag
      @@@Type: HASH
    @@Param:
      @@@Name: obj
      @@@Type: HASH
    @@Param:
      @@@Name: opt
      @@@Type: HASH
    @@Return:
      @@@Type: HASH
      @@@PerlDef:
        __CODE{DISPerl|HashStringRef||ManakaiDOM|all::
          $result => {$obj->{<H::infoset|name>}},
          $given => {${$opt->{<H::infoset|name>}}},
        }__;
        if (defined $opt->{<H::tc|ownerDocument>}) {
          __CODE{mg|setOwnerProp||ManakaiDOM|all::
            $bag => $bag,
            $ownerref => {$opt->{<H::tc|ownerDocument>}},
            $ownee1hprop => {<H::tc|revOwnerDocument>},
            $ownee => {$obj},
            $owner0prop => {<H::tc|ownerDocument>},
          }__;
        } elsif (defined $opt->{<H::f|implementation>}) {
          __CODE{mg|setOwnerProp||ManakaiDOM|all::
            $bag => $bag,
            $ownerref => {$opt->{<H::f|implementation>}},
            $ownee1hprop => {<H::f|revImplementation>},
            $ownee => {$obj},
            $owner0prop => {<H::f|implementation>},
          }__;
        } else {
          ## TODO: Assertion
        }
        $obj->{<H::infoset|children>} = [];
        $obj->{<H::d|elementTypes>} = {};
        $obj->{<H::d|generalEntities>} = {};
        $obj->{<H::d|notations>} = {};
        $r = $obj;
  @mg:owner0: tc|ownerDocument
  @mg:origin0: infoset|parent
  @mg:subnode1a: infoset|children
  @mg:subnode1h: d|elementTypes
  @mg:subnode1h: d|generalEntities
  @mg:subnode1h: d|notations

  @enImplNote:
    {P:: Required internal properties::

      - <Q::infoset|name>.

      - <Q::d|elementTypes>, <Q::d|generalEntities>, <Q::d|notations>,
        <Q::infoset|children>.

    }

    {P:: Optional internal properties::

      - <Q::tc|ownerDocument> (required if the node
        contains one or more nodes).

      - <Q::f|implementation> (required if <Q::tc|ownerDocument>
        is <DOM::null>).

      - <Q::infoset|publicIdentifier>, <Q::infoset|systemIdentifier>.

      - <Q::d|hasLtDeclaration>, <Q::d|hasGtDeclaration>,
        <Q::d|hasAmpDeclaration>, <Q::d|hasAposDeclaration>,
        <Q::d|hasQuotDeclaration>.

      - <Q::c|read-only>.

    }

  @CODE:
    @@QName: d|createDTDefForTest
    @@PerlDef:
      my $__docx;
      __CODE{d|createEmptyDocumentXForTest:: $docx => $__docx}__;
      $dtdef = $__docx-><M::DocumentXDoctype.createDocumentTypeDefinition>
                        ('dtdef1');
  @CODE:
    @@QName: d|createDTForTest
    @@PerlDef:
      my $__impl;
      __CODE{tc|createImplForTest:: $impl => $__impl}__;
      $dt = $__impl-><M::c|DOMImplementation.createDocumentType> ('dt1');
      $dt-><M::Node.manakaiSetReadOnly> (false, true);
  @CODE:
    @@QName: d|createRODTForTest
    @@PerlDef:
      my $__impl;
      __CODE{tc|createImplForTest:: $impl => $__impl}__;
      $dt = $__impl-><M::c|DOMImplementation.createDocumentType> ('dt1');

  @CAttr:
    @@Name: nodeName
    @@enDesc:
      The document type name of the node.
    @@Type: DOMString
    @@Get:
      @@@disDef:
        @@@@DISPerl:cloneCode: tx|ManakaiDOMNotation.nodeName.get

    @@Test:
      @@@QName: DTDef.nodeName.1.test
      @@@PerlDef:
        my $docx;
        __CODE{d|createEmptyDocumentXForTest:: $docx => $docx}__;

        my $dtd = $docx-><M::DocumentXDoctype.createDocumentTypeDefinition>
                           ('dtdef1');

        $test->assert_equals ($dtd-><AG::Node.nodeName>, 'dtdef1');

    @@Test:
      @@@QName: DTDef.nodeName.2.test
      @@@PerlDef:
        my $impl;
        __CODE{tc|createImplForTest:: $impl => $impl}__;

        my $dtd = $impl-><M::c|DOMImplementation.createDocumentType>
                           ('dtdef1');

        $test->assert_equals ($dtd-><AG::Node.nodeName>, 'dtdef1');

  @CAttr:
    @@Name: nodeType
    @@Type: unsignedShort
    @@dis:actualType: tc|NodeType
    @@Get:
      @@@disDef:
        @@@@DISLang:constValue: Node.DOCUMENT_TYPE_NODE

    @@Test:
      @@@QName: DTDef.nodeType.1.test
      @@@PerlDef:
        my $text;
        __CODE{d|createDTDefForTest:: $dtdef => $text}__;

        $test->id ('nodeType');
        $test->assert_num_equals
                 (actual_value => $text-><AG::Node.nodeType>,
                  expected_value => <C::Node.DOCUMENT_TYPE_NODE>);

    @@Test:
      @@@QName: DTDef.nodeType.2.test
      @@@PerlDef:
        my $text;
        __CODE{d|createDTForTest:: $dt => $text}__;

        $test->id ('nodeType');
        $test->assert_num_equals
                 (actual_value => $text-><AG::Node.nodeType>,
                  expected_value => <C::Node.DOCUMENT_TYPE_NODE>);

  @CAttr:
    @@Name: textContent
    @@enDesc:
      The text content of the node.
    @@Type: DOMString
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          The text content of the node is defined to be <DOM::null>.
      @@@disDef:
        @@@@DISPerl:cloneCode: tx|ManakaiDOMNotation.textContent.get
    @@Set:
      @@@enDesc:
        Setting this attribute has no effect.
      @@@c:reports:
        @@@@@: c|setting-node-value-no-effect
        @@@@enDesc:
          Setting the attribute value has no effect, since the
          node value is defined as <DOM::null>.
        @@@@For: ManakaiDOM|ManakaiDOM
      @@@disDef:
        @@@@DISPerl:cloneCode: tx|ManakaiDOMNotation.textContent.set

  @CAttr:
    @@Name: baseURI
    @@enDesc:
      The base URI of the node, i.e. the base URI of the document.
    @@Type: DOMString
    @@dis:actualType: ManakaiDOM|ManakaiDOMURI
    @@Get:
      @@@enDesc:
        The base DOM URI of the node.
      @@@nullCase:
        @@@@enDesc:
          If no base DOM URI is available on the document or 
          the node does not belong to any document.
      @@@PerlDef:
        __DEEP{
          $r = $self-><AG::DocumentTypeDeclaration.declarationBaseURI>;
        }__;

    @@Test:
      @@@QName: Doctype.baseURI.test
      @@@PerlDef:
        my $impl;
        __CODE{tc|createImplForTest:: $impl => $impl}__;

        my $dtype = $impl-><M::c|DOMImplementation.createDocumentType>
                             ('type', 'pub', 'sys');
  
        $test->id ('initial');
        $test->assert_null ($dtype-><AG::Node.baseURI>);

        my $doc = $impl-><M::c|DOMImplementation.createDocument>;
        $doc-><M::Node.appendChild> ($dtype);
        $doc-><AS::Document.documentURI> (q<http://doc.test/>);
        $test->assert_equals ($dtype-><AG::Node.ownerDocument>,
                              $doc);

        $test->id ('doc');
        $test->assert_equals
                 ($dtype-><AG::Node.baseURI>,
                  q<http://doc.test/>);

  @CMethod:
    @@Name: appendChild
    @@enDesc:
      Adds a node to the end of the list of children of the node.
      If that node is already in the tree, it is first removed.
    @@Param:
      @@@Name: newChild
      @@@Type: Node
      @@@enDesc:
        The node to add.
      @@@InCase:
        @@@@Type: DocumentFragment
        @@@@enDesc:
          The entire contents of the document fragment are
          moved into the child list of the node.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node added.  If the <P::newChild> node is a <IF::DocumentFragment>
        node, then the <P::newChild> node <kwd:MUST> be returned.
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_BAD_TYPE
        @@@@enDesc:
          If the node is of a type that does not allow children of
          the type of the <P::newChild> node.
 
          If the <A::Document.strictErrorChecking> is set to <DOM::false>,
          this exception <kwd:MAY-NOT> be thrown.
      @@@dx:raises:
        @@@@@: c|DIFFERENT_DOCUMENT_ERR
        @@@@enDesc:
          If the <P::newChild> node was created from a different
          document than the one to which the node was created or
          the node does not belong to any document.

          If the <A::Document.strictErrorChecking> is set to <DOM::false>,
          this exception <kwd:MAY-NOT> be thrown.
      @@@dx:raises: 
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the node is read-only.

          If the <A::Document.strictErrorChecking> is set to <DOM::false>,
          this exception <kwd:MAY-NOT> be thrown.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_SRC_PARENT
        @@@@enDesc:
          If the previous parent of the <P::newChild> node is read-only
          <SRC::DOM 2 Errata, DOM 3>.

          If the <A::Document.strictErrorChecking> is set to <DOM::false>,
          this exception <kwd:MAY-NOT> be thrown.
      @@@PerlDef:
        my $self_od = $self-><AG::Node.ownerDocument>;
        unless ($self_od) {
          __EXCEPTION{c|DIFFERENT_DOCUMENT_ERR::
            MDOMX|param-name => 'newChild',
            c|node => {$newChild},
          }__;
        }
        my $child_od = $newChild-><AG::Node.ownerDocument>;
        my $child_nt = $newChild-><AG::Node.nodeType>;
        __CODE{tc|appendChildImpl1::
          $self => $self, $self_od => $self_od,
          $newChild => $newChild, $child_od => $child_od, $child_nt => $child_nt,
          $r => $r,
          $allowedNodeTypes => {{
            <C::Node.PROCESSING_INSTRUCTION_NODE> => true,
          }},
        }__;

  @CMethod:
    @@Name: insertBefore
    @@enDesc:
      Inserts a node before the existing child node of the node.

      Inserting a node before itself is implementation dependent.
    @@Param:
      @@@Name: newChild
      @@@Type: Node
      @@@enDesc:
        The node to insert.  If the <P::newChild> is already in 
        the tree, it is first removed.
      @@@InCase:
        @@@@Type: DocumentFragment
        @@@@enDesc:
          All of children of the <P::newChild> node are inserted,
          in the same order, before <P::refChild>.
    @@Param:
      @@@Name: refChild
      @@@Type: Node
      @@@enDesc:
        The reference node, i.e. the node before which the new node
        must be inserted.
      @@@nullCase:
        @@@@enDesc:
          The <P::newChild> node is inserted at the end of the list
          of children.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node being inserted.
      @@@enImplNote:
        What is returned if <P::newChild> is a <IF::DocumentFragment>?
        See also <M::Node.appendChild>'s return value.
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_BAD_TYPE
        @@@@enDesc:
          If the node is of a type that does not allow children of
          the type of the <P::newChild> node.
      @@@dx:raises:
        @@@@@: c|DIFFERENT_DOCUMENT_ERR
        @@@@enDesc:
          If the <P::newChild> node was created from a different
          document than the one that created the node.
        @@@@enImplNote:
          The DOM specification ignores the fact that <IF::Document>s
          and <IF::tx|DocumentType>s are created from 
          <IF::c|DOMImplementation> :-)
      @@@dx:raises: 
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the node is read-only.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_SRC_PARENT
        @@@@enDesc:
          If the previous parent of the <P::newChild> node is read-only
          <SRC::DOM 1 SE, DOM 2, 3>.
      @@@dx:raises:
        @@@@@: c|NOT_CHILD_ERR
        @@@@enDesc:
          If the <P::refChild> node is not a child of the node.
      @@@c:reports:
        @@@@@: t|insert-before-itself
        @@@@enDesc:
          If the <P::newChild> node is same as the <P::refChild> node.
          Then, the result is implementation dependent.
        @@@@For: ManakaiDOM|ManakaiDOM
      @@@PerlDef:
        my $self_od = $self-><AG::Node.ownerDocument>;
        unless ($self_od) {
          __EXCEPTION{c|DIFFERENT_DOCUMENT_ERR::
            MDOMX|param-name => 'newChild',
            c|node => {$newChild},
          }__;
        }
        my $child_od = $newChild-><AG::Node.ownerDocument>;
        my $child_nt = $newChild-><AG::Node.nodeType>;
        __CODE{tc|insertBeforeImpl1::
          $self => $self, $self_od => $self_od,
          $newChild => $newChild, $refChild => $refChild,
          $child_od => $child_od, $child_nt => $child_nt,
          $r => $r,
          $allowedNodeTypes => {{
            <C::Node.PROCESSING_INSTRUCTION_NODE> => true,
          }},
        }__;

  @CMethod:
    @@Name: replaceChild
    @@enDesc:
      Replaces a child node with another node.

      Replacing a node with itself is implementation dependent <SRC::DOM3>.
    @@Param:
      @@@Name: newChild
      @@@Type: Node
      @@@enDesc:
        The new node to put in the child list.

        If the <P::newChild> node is already in the tree,
        it is first removed.
      @@@InCase:
        @@@@Type: DocumentFragment
        @@@@enDesc:
          The <P::oldChild> node is replaced by all of the 
          <IF::DocumentFragment> children, which are inserted
          in the same order <SRC::DOM1 SE, DOM2, DOM3>.
    @@Param:
      @@@Name: oldChild
      @@@Type: Node
      @@@enDesc:
        The node being replaced in the list.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node replaced.
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_BAD_TYPE
        @@@@enDesc:
          If the node is of a type that does not allow children of
          the type of the <P::newChild> node.
      @@@dx:raises:
        @@@@@: c|DIFFERENT_DOCUMENT_ERR
        @@@@enDesc:
          If the <P::newChild> node was created from a different
          document than the one that created the node.
        @@@@enImplNote:
          The DOM specification ignores the fact that <IF::Document>s
          and <IF::tx|DocumentType>s are created from 
          <IF::c|DOMImplementation> :-)
      @@@dx:raises: 
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the node is read-only.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_SRC_PARENT
        @@@@enDesc:
          If the previous parent of the <P::newChild> node is read-only
          <SRC::DOM1 SE, DOM2, DOM3>.
      @@@dx:raises:
        @@@@@: c|NOT_CHILD_ERR
        @@@@enDesc:
          If the <P::oldChild> node is not a child of the node.
      @@@c:reports:
        @@@@@: t|replaced-by-itself
        @@@@enDesc:
          If the <P::newChild> node is same as the <P::oldChild> node.
          Then, the result is implementation dependent.
        @@@@For: ManakaiDOM|ManakaiDOM
      @@@PerlDef:
        my $self_od = $self-><AG::Node.ownerDocument>;
        unless ($self_od) {
          __EXCEPTION{c|DIFFERENT_DOCUMENT_ERR::
            MDOMX|param-name => 'newChild',
            c|node => {$newChild},
          }__;
        }
        my $child_od = $newChild-><AG::Node.ownerDocument>;
        my $child_nt = $newChild-><AG::Node.nodeType>;
        __CODE{tc|replaceChildImpl1::
          $self => $self, $self_od => $self_od,
          $newChild => $newChild, $refChild => $oldChild,
          $child_od => $child_od, $child_nt => $child_nt,
          $r => $r,
          $allowedNodeTypes => {{
            <C::Node.PROCESSING_INSTRUCTION_NODE> => true,
          }},
        }__;

    @@Test:
      @@@QName: Doctype.appendChild.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createDocumentTypeDefinition>
                           ('dt');
        my $pi = $doc-><M::Document.createProcessingInstruction> ('pi');

        my $return = $dtd-><M::Node.appendChild> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|ProcessingInstruction>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: Doctype.insertBefore.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createDocumentTypeDefinition>
                           ('dt');
        my $pi = $doc-><M::Document.createProcessingInstruction> ('pi');

        my $return = $dtd-><M::Node.insertBefore> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|ProcessingInstruction>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);

    @@Test:
      @@@QName: Doctype.appendChild.has.parent.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createDocumentTypeDefinition>
                           ('dt');

        my $piparent = $doc-><M::Document.createElementNS> (null, 'e');
        my $pi = $doc-><M::Document.createProcessingInstruction> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.appendChild> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|ProcessingInstruction>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);
        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: Doctype.insertBefore.has.parent.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createDocumentTypeDefinition>
                           ('dt');

        my $piparent = $doc-><M::Document.createElementNS> (null, 'e');
        my $pi = $doc-><M::Document.createProcessingInstruction> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.insertBefore> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|ProcessingInstruction>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi);

    @@Test:
      @@@QName: Doctype.appendChild.documentfragment.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createDocumentTypeDefinition>
                           ('dt');

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createProcessingInstruction> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.appendChild> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|ProcessingInstruction>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: Doctype.insertBefore.documentfragment.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createDocumentTypeDefinition>
                           ('dt');

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createProcessingInstruction> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.insertBefore> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|ProcessingInstruction>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: Doctype.replaceChild.documentfragment.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createDocumentTypeDefinition>
                           ('dt');
        my $pi0 = $doc-><M::Document.createProcessingInstruction> ('pi0');
        $dtd-><M::Node.appendChild> ($pi0);

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createProcessingInstruction> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.replaceChild> ($piparent, $pi0);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|ProcessingInstruction>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi0);

  @Test:
    @@QName: ManakaiDOMDTD.appendChild.pi.test
    @@PerlDef:
      my $dtd;
      __CODE{d|createDTDefForTest:: $dtdef => $dtd}__;
      
      my $doc = $dtd-><AG::Node.ownerDocument>;
      my $pi = $doc-><M::Document.createProcessingInstruction> ('pitarget');
      
      $dtd-><M::Node.appendChild> ($pi);

      my $fc = $dtd-><AG::Node.firstChild>;
      $test->assert_not_null ($fc);
      $test->assert_equals ($pi, $fc);
      $test->assert_string (actual_value => $pi-><AG::PI.target>,
                            expected_value => 'pitarget');
    @@Test:
      @@@QName: Doctype.appendChild.documentfragment.2.test
      @@@enDesc:
        Empty document fragment.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createDocumentTypeDefinition>
                           ('dt');

        my $piparent = $doc-><M::Document.createDocumentFragment>;

        my $return = $dtd-><M::Node.appendChild> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 0);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: Doctype.insertBefore.documentfragment.2.test
      @@@enDesc:
        Empty document fragment.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createDocumentTypeDefinition>
                           ('dt');

        my $piparent = $doc-><M::Document.createDocumentFragment>;

        my $return = $dtd-><M::Node.insertBefore> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 0);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: Doctype.replaceChild.documentfragment.2.test
      @@@enDesc:
        Empty document fragment.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createDocumentTypeDefinition>
                           ('dt');
        my $pi0 = $doc-><M::Document.createProcessingInstruction> ('pi0');
        $dtd-><M::Node.appendChild> ($pi0);

        my $piparent = $doc-><M::Document.createDocumentFragment>;

        my $return = $dtd-><M::Node.replaceChild> ($piparent, $pi0);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 0);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi0);

    @@Test:
      @@@QName: Doctype.appendChild.documentfragment.3.test
      @@@enDesc:
        Three PIs in document fragment.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createDocumentTypeDefinition>
                           ('dt');

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createProcessingInstruction> ('pi');
        my $pi2 = $doc-><M::Document.createProcessingInstruction> ('pi2');
        my $pi3 = $doc-><M::Document.createProcessingInstruction> ('pi3');
        $piparent-><M::Node.appendChild> ($pi);
        $piparent-><M::Node.appendChild> ($pi2);
        $piparent-><M::Node.appendChild> ($pi3);

        my $return = $dtd-><M::Node.appendChild> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 3);

        my $item = $child-><M::tc|NodeList.item> (0);
        my $item2 = $child-><M::tc|NodeList.item> (1);
        my $item3 = $child-><M::tc|NodeList.item> (2);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);
        $test->id ('child.item.node2');
        $test->assert_isa ($item2, <IFName::Node>);
        $test->id ('child.item.node3');
        $test->assert_isa ($item3, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|ProcessingInstruction>);
        $test->id ('child.item.pi2');
        $test->assert_isa ($item2, <IFName::tx|ProcessingInstruction>);
        $test->id ('child.item.pi3');
        $test->assert_isa ($item3, <IFName::tx|ProcessingInstruction>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);
        $test->id ('child.item.equals2');
        $test->assert_equals ($item2, $pi2);
        $test->id ('child.item.equals3');
        $test->assert_equals ($item3, $pi3);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi3);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);
        $test->id ('parent2');
        my $parent2 = $item2-><AG::Node.parentNode>;
        $test->assert_equals ($parent2, $dtd);
        $test->id ('parent3');
        my $parent3 = $item3-><AG::Node.parentNode>;
        $test->assert_equals ($parent3, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: Doctype.insertBefore.documentfragment.3.test
      @@@enDesc:
        Three PIs in document fragment.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createDocumentTypeDefinition>
                           ('dt');

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createProcessingInstruction> ('pi');
        my $pi2 = $doc-><M::Document.createProcessingInstruction> ('pi2');
        my $pi3 = $doc-><M::Document.createProcessingInstruction> ('pi3');
        $piparent-><M::Node.appendChild> ($pi);
        $piparent-><M::Node.appendChild> ($pi2);
        $piparent-><M::Node.appendChild> ($pi3);

        my $return = $dtd-><M::Node.insertBefore> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 3);

        my $item = $child-><M::tc|NodeList.item> (0);
        my $item2 = $child-><M::tc|NodeList.item> (1);
        my $item3 = $child-><M::tc|NodeList.item> (2);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);
        $test->id ('child.item.node2');
        $test->assert_isa ($item2, <IFName::Node>);
        $test->id ('child.item.node3');
        $test->assert_isa ($item3, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|ProcessingInstruction>);
        $test->id ('child.item.pi2');
        $test->assert_isa ($item2, <IFName::tx|ProcessingInstruction>);
        $test->id ('child.item.pi3');
        $test->assert_isa ($item3, <IFName::tx|ProcessingInstruction>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);
        $test->id ('child.item.equals2');
        $test->assert_equals ($item2, $pi2);
        $test->id ('child.item.equals3');
        $test->assert_equals ($item3, $pi3);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi3);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);
        $test->id ('parent2');
        my $parent2 = $item2-><AG::Node.parentNode>;
        $test->assert_equals ($parent2, $dtd);
        $test->id ('parent3');
        my $parent3 = $item3-><AG::Node.parentNode>;
        $test->assert_equals ($parent3, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: Doctype.replaceChild.documentfragment.3.test
      @@@enDesc:
        Three PIs in document fragment.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createDocumentTypeDefinition>
                           ('dt');
        my $pi0 = $doc-><M::Document.createProcessingInstruction> ('pi0');
        $dtd-><M::Node.appendChild> ($pi0);

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createProcessingInstruction> ('pi');
        my $pi2 = $doc-><M::Document.createProcessingInstruction> ('pi2');
        my $pi3 = $doc-><M::Document.createProcessingInstruction> ('pi3');
        $piparent-><M::Node.appendChild> ($pi);
        $piparent-><M::Node.appendChild> ($pi2);
        $piparent-><M::Node.appendChild> ($pi3);

        my $return = $dtd-><M::Node.replaceChild> ($piparent, $pi0);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 3);

        my $item = $child-><M::tc|NodeList.item> (0);
        my $item2 = $child-><M::tc|NodeList.item> (1);
        my $item3 = $child-><M::tc|NodeList.item> (2);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);
        $test->id ('child.item.node2');
        $test->assert_isa ($item2, <IFName::Node>);
        $test->id ('child.item.node3');
        $test->assert_isa ($item3, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|ProcessingInstruction>);
        $test->id ('child.item.pi2');
        $test->assert_isa ($item2, <IFName::tx|ProcessingInstruction>);
        $test->id ('child.item.pi3');
        $test->assert_isa ($item3, <IFName::tx|ProcessingInstruction>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);
        $test->id ('child.item.equals2');
        $test->assert_equals ($item2, $pi2);
        $test->id ('child.item.equals3');
        $test->assert_equals ($item3, $pi3);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi3);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);
        $test->id ('parent2');
        my $parent2 = $item2-><AG::Node.parentNode>;
        $test->assert_equals ($parent2, $dtd);
        $test->id ('parent3');
        my $parent3 = $item3-><AG::Node.parentNode>;
        $test->assert_equals ($parent3, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi0);

    @@Test:
      @@@QName: DTDef.appendChild.badtype.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $comment = $docx-><M::DocumentXDoctype.createDocumentTypeDefinition>
                               ('data');
        my $pi0 = $doc-><M::Document.createProcessingInstruction> ('pi0');
        $comment-><M::Node.appendChild> ($pi0);

        for my $node (
          $docx-><M::d|DocumentXDoctype.createDocumentTypeDefinition> ('d'),
          $doc-><M::Document.createEntityReference> ('ent'),
          $doc-><M::Document.createElement> ('e'),
          $doc-><M::Document.createAttribute> ('a'),
          $doc-><M::Document.createComment> ('c'),
          $doc-><M::Document.createTextNode> ('t'),
          $doc-><M::Document.createCDATASection> ('cs'),
          $docx-><M::d|DocumentXDoctype.createGeneralEntity> ('ge'),
          $docx-><M::d|DocumentXDoctype.createNotation> ('not'),
          $docx-><M::d|DocumentXDoctype.createElementTypeDefinition> ('et'),
          $docx-><M::d|DocumentXDoctype.createAttributeDefinition> ('at'),
          #test:nodeTypes
        ) {
          $test->id ('appendChild.'.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.appendChild> ($node);
          }, exception_subtype => <Q::MDOMX|HIERARCHY_BAD_TYPE>);

          $test->id ('insertBefore.'.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.insertBefore> ($node);
          }, exception_subtype => <Q::MDOMX|HIERARCHY_BAD_TYPE>);

          $test->id ('replaceChild.'.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.replaceChild> ($node, $pi0);
          }, exception_subtype => <Q::MDOMX|HIERARCHY_BAD_TYPE>);
        }

    @@Test:
      @@@QName: DTDef.appendChild.wrongdoc.test
      @@@PerlDef:
        my $doc0;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc0}__;
        my $docx0 = $doc0-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $comment = $docx0-><M::DocumentXDoctype.createDocumentTypeDefinition>
                                ('data');

        for my $node (
          $doc-><M::Document.createProcessingInstruction> ('pi'),
        ) {
          $test->id ('type='.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.appendChild> ($node);
          }, exception_subtype => <Q::c|DIFFERENT_DOCUMENT_ERR>);
        }
    @@Test:
      @@@QName: DTDef.insertBefore.wrongdoc.test
      @@@PerlDef:
        my $doc0;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc0}__;
        my $docx0 = $doc0-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $comment = $docx0-><M::DocumentXDoctype.createDocumentTypeDefinition>
                                ('data');
        my $pi0 = $doc0-><M::Document.createProcessingInstruction> ('pi0');
        $comment-><M::Node.appendChild> ($pi0);

        for my $node (
          $doc-><M::Document.createProcessingInstruction> ('pi'),
        ) {
          $test->id ('appendChild.'.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.appendChild> ($node);
          }, exception_subtype => <Q::c|DIFFERENT_DOCUMENT_ERR>);

          $test->id ('insertBefore.'.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.insertBefore> ($node);
          }, exception_subtype => <Q::c|DIFFERENT_DOCUMENT_ERR>);

          $test->id ('replaceChild.'.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.replaceChild> ($node, $pi0);
          }, exception_subtype => <Q::c|DIFFERENT_DOCUMENT_ERR>);
        }

    @@Test:
      @@@QName: DTDef.appendChild.wrongdoc.2.test
      @@@PerlDef:
        my $impl;
        __CODE{tc|createImplForTest:: $impl => $impl}__;

        my $dtype = $impl-><M::c|DOMImplementation.createDocumentType>
                             ('type', 'pub', 'sys');

        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $node = $doc-><M::Document.createProcessingInstruction> ('pi');

        $test->id ('appendChild'.$node-><AG::Node.nodeType>);
        $test->assert_exception (code => sub {
          $dtype-><M::Node.appendChild> ($node);
        }, exception_subtype => <Q::c|DIFFERENT_DOCUMENT_ERR>);

        $test->id ('insertBefore.'.$node-><AG::Node.nodeType>);
        $test->assert_exception (code => sub {
          $dtype-><M::Node.insertBefore> ($node);
        }, exception_subtype => <Q::c|DIFFERENT_DOCUMENT_ERR>);

        $test->id ('replaceChild.'.$node-><AG::Node.nodeType>);
        my $pi0 = $doc-><M::Document.createProcessingInstruction> ('pi0');
                     ## DocumentType with no ownerDocument cannot have children.
        $test->assert_exception (code => sub {
          $dtype-><M::Node.replaceChild> ($node, $pi0);
        }, exception_subtype => <Q::c|DIFFERENT_DOCUMENT_ERR>);

    @@Test:
      @@@QName: DTDef.appendChild.readonly.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createDocumentTypeDefinition>
                           ('d');
        my $pi0 = $doc-><M::Document.createProcessingInstruction> ('pi0');
        $dtd-><M::Node.appendChild> ($pi0);
        $dtd-><M::Node.manakaiSetReadOnly> (true);

        $test->id ('pi');
        my $node = $doc-><M::Document.createProcessingInstruction> ('pi');

        $test->assert_exception (code => sub {
          $dtd-><M::Node.appendChild> ($node);
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);

        $test->id ('pi.insertBefore');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.insertBefore> ($node);
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);

        $test->id ('pi.replaceChild');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.replaceChild> ($node, $pi0);
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);

        $test->id ('fragment');
        my $node2 = $doc-><M::Document.createDocumentFragment>;
        $node2-><M::Node.appendChild> ($node);

        $test->assert_exception (code => sub {
          $dtd-><M::Node.appendChild> ($node2);
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);

        $test->id ('fragment.insertBefore');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.insertBefore> ($node2);
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);

        $test->id ('fragment.replaceChild');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.replaceChild> ($node2, $pi0);
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);

    @@Test:
      @@@QName: DTDef.appendChild.readonly.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createDocumentTypeDefinition>
                           ('d');
        my $pi0 = $doc-><M::Document.createProcessingInstruction> ('pi0');
        $dtd-><M::Node.appendChild> ($pi0);

        $test->id ('pi');
        my $el = $doc-><M::Document.createElementNS> (null, 'e');
        my $node = $doc-><M::Document.createProcessingInstruction> ('pi');
        $el-><M::Node.appendChild> ($node);
        $el-><M::Node.manakaiSetReadOnly> (true);

        $test->assert_exception (code => sub {
          $dtd-><M::Node.appendChild> ($node);
        }, exception_subtype => <Q::MDOMX|NOMOD_SRC_PARENT>);

        $test->id ('pi.insertBefore');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.insertBefore> ($node);
        }, exception_subtype => <Q::MDOMX|NOMOD_SRC_PARENT>);

        $test->id ('pi.replaceChild');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.replaceChild> ($node, $pi0);
        }, exception_subtype => <Q::MDOMX|NOMOD_SRC_PARENT>);

        $test->id ('fragment');
        my $node2 = $doc-><M::Document.createDocumentFragment>;
        my $node3 = $doc-><M::Document.createProcessingInstruction> ('pi');
        $node2-><M::Node.appendChild> ($node3);
        $node2-><M::Node.manakaiSetReadOnly> (true);

        $test->assert_exception (code => sub {
          $dtd-><M::Node.appendChild> ($node2);
        }, exception_subtype => <Q::MDOMX|NOMOD_SRC_PARENT>);

        $test->id ('fragment.insertBefore');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.insertBefore> ($node2);
        }, exception_subtype => <Q::MDOMX|NOMOD_SRC_PARENT>);

        $test->id ('fragment.replaceChild');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.replaceChild> ($node2, $pi0);
        }, exception_subtype => <Q::MDOMX|NOMOD_SRC_PARENT>);

    @@Test:
      @@@QName: DTDef.insertBefore.refChild.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createDocumentTypeDefinition>
                           ('d');

        my $pi1 = $doc-><M::Document.createProcessingInstruction> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createProcessingInstruction> ('pi2');
        $dtd-><M::Node.insertBefore> ($pi2, $pi1);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi2);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi1);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: DTDef.insertBefore.refChild.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createDocumentTypeDefinition>
                           ('d');

        my $pi1 = $doc-><M::Document.createProcessingInstruction> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createProcessingInstruction> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createProcessingInstruction> ('pi3');
        $dtd-><M::Node.insertBefore> ($pi3, $pi2);

        # pi1, pi3, pi2

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi1);

        $test->id ('firstChild.nextSibling');
        $test->assert_equals ($dtd-><AG::Node.firstChild>
                                  -><AG::Node.nextSibling>, $pi3);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi2);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 3);

    @@Test:
      @@@QName: DTDef.insertBefore.refChild.3.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createDocumentTypeDefinition>
                           ('d');

        my $pi1 = $doc-><M::Document.createProcessingInstruction> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createProcessingInstruction> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createProcessingInstruction> ('pi3');
        $dtd-><M::Node.appendChild> ($pi3);

        # pi1, pi2, pi3

        $dtd-><M::Node.insertBefore> ($pi2, $pi1);
 
        # pi2, pi1, pi3

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi2);

        $test->id ('firstChild.nextSibling');
        $test->assert_equals ($dtd-><AG::Node.firstChild>
                                  -><AG::Node.nextSibling>, $pi1);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi3);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 3);

    @@Test:
      @@@QName: DTDef.insertBefore.refChild.4.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createDocumentTypeDefinition>
                           ('d');

        my $pi1 = $doc-><M::Document.createProcessingInstruction> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createProcessingInstruction> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createProcessingInstruction> ('pi3');
        $dtd-><M::Node.appendChild> ($pi3);

        # pi1, pi2, pi3

        $dtd-><M::Node.insertBefore> ($pi3, $pi1);
 
        # pi3, pi1, pi2

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi3);

        $test->id ('firstChild.nextSibling');
        $test->assert_equals ($dtd-><AG::Node.firstChild>
                                  -><AG::Node.nextSibling>, $pi1);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi2);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 3);

    @@Test:
      @@@QName: DTDef.insertBefore.refChild.not_found_err.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createDocumentTypeDefinition>
                           ('d');

        my $pi1 = $doc-><M::Document.createProcessingInstruction> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createProcessingInstruction> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createProcessingInstruction> ('pi3');

        my $pi4 = $doc-><M::Document.createProcessingInstruction> ('pi4');

        # pi1, pi2

        $test->assert_exception (code => sub {
          $dtd-><M::Node.insertBefore> ($pi4, $pi3);
        }, exception_subtype => <Q::c|NOT_CHILD_ERR>);

    @@Test:
      @@@QName: DTDef.insertBefore.refChild=newChild.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createDocumentTypeDefinition>
                           ('d');

        my $pi1 = $doc-><M::Document.createProcessingInstruction> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createProcessingInstruction> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        # pi1, pi2

        my $eh_called = false;
        my $cfg = $doc-><AG::Document.domConfig>;
        $cfg-><M::c|DOMConfiguration.setParameter> ('error-handler' => sub {
          my (undef, $err) = @_;
          $eh_called = true;
          $test->assert_equals ($err-><AG::c|DOMError.severity>,
                                <C::c|DOMError.SEVERITY_WARNING>);
          $test->assert_equals ($err-><AG::c|DOMError.type>,
                                <Q::t|insert-before-itself>);
          $test->assert_equals ($err-><AG::c|DOMError.relatedData>, $pi2);
          $test->assert_null ($err-><AG::c|DOMError.relatedException>);
          $test->assert_isa ($err-><AG::c|DOMError.location>,
                             <IFName::c|DOMLocator>);
          $test->assert_not_null ($err-><AG::c|DOMError.message>);
        });

        $test->assert_false ($eh_called);
        $dtd-><M::Node.insertBefore> ($pi2, $pi2);
        $test->assert_true ($eh_called);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi1);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi2);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: DTDef.replaceChild.oldChild=newChild.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createDocumentTypeDefinition>
                           ('d');

        my $pi1 = $doc-><M::Document.createProcessingInstruction> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createProcessingInstruction> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        # pi1, pi2

        my $eh_called = false;
        my $cfg = $doc-><AG::Document.domConfig>;
        $cfg-><M::c|DOMConfiguration.setParameter> ('error-handler' => sub {
          my (undef, $err) = @_;
          $eh_called = true;
          $test->assert_equals ($err-><AG::c|DOMError.severity>,
                                <C::c|DOMError.SEVERITY_WARNING>);
          $test->assert_equals ($err-><AG::c|DOMError.type>,
                                <Q::t|replace-by-itself>);
          $test->assert_equals ($err-><AG::c|DOMError.relatedData>, $pi2);
          $test->assert_null ($err-><AG::c|DOMError.relatedException>);
          $test->assert_isa ($err-><AG::c|DOMError.location>,
                             <IFName::c|DOMLocator>);
          $test->assert_not_null ($err-><AG::c|DOMError.message>);
        });

        $test->assert_false ($eh_called);
        $dtd-><M::Node.replaceChild> ($pi2, $pi2);
        $test->assert_true ($eh_called);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi1);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi2);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: DTDef.appendChild.sameparent.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createDocumentTypeDefinition>
                           ('d');

        my $pi1 = $doc-><M::Document.createProcessingInstruction> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createProcessingInstruction> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        # pi1, pi2

        my $return = $dtd-><M::Node.appendChild> ($pi1);

        # pi2, pi1

        $test->id ('return');
        $test->assert_equals ($return, $pi1);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi2);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi1);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: DTDef.insertBefore.sameparent.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createDocumentTypeDefinition>
                           ('d');

        my $pi1 = $doc-><M::Document.createProcessingInstruction> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createProcessingInstruction> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        # pi1, pi2

        my $return = $dtd-><M::Node.insertBefore> ($pi1);

        # pi2, pi1

        $test->id ('return');
        $test->assert_equals ($return, $pi1);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi2);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi1);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: DTDef.appendChild.sameparent.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createDocumentTypeDefinition>
                           ('d');

        my $pi1 = $doc-><M::Document.createProcessingInstruction> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createProcessingInstruction> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        # pi1, pi2

        my $return = $dtd-><M::Node.appendChild> ($pi2);

        # pi1, pi2

        $test->id ('return');
        $test->assert_equals ($return, $pi2);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi1);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi2);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: DTDef.insertBefore.sameparent.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createDocumentTypeDefinition>
                           ('d');

        my $pi1 = $doc-><M::Document.createProcessingInstruction> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createProcessingInstruction> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        # pi1, pi2

        my $return = $dtd-><M::Node.insertBefore> ($pi2);

        # pi1, pi2

        $test->id ('return');
        $test->assert_equals ($return, $pi2);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi1);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi2);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: DTDef.replaceChild.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createDocumentTypeDefinition>
                           ('d');

        my $pi1 = $doc-><M::Document.createProcessingInstruction> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createProcessingInstruction> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createProcessingInstruction> ('pi3');
        $dtd-><M::Node.appendChild> ($pi3);

        # pi1, pi2, pi3

        my $pi9 = $doc-><M::Document.createProcessingInstruction> ('pi9');
        my $return = $dtd-><M::Node.replaceChild> ($pi9, $pi1);

        # pi9, pi2, pi3

        $test->id ('return.node');
        $test->assert_isa ($return, <IFName::Node>);
        $test->id ('return.pi');
        $test->assert_isa ($return, <IFName::tx|ProcessingInstruction>);
        $test->id ('return');
        $test->assert_equals ($return, $pi1);

        my $c = $dtd-><AG::Node.childNodes>;

        $test->id ('length');
        $test->assert_num_equals (actual_value => 0+@$c, expected_value => 3);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi9);

        $test->id ('firstChild.nextSibling');
        $test->assert_equals ($dtd-><AG::Node.firstChild>
                                  -><AG::Node.nextSibling>, $pi2);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi3);
 
        $test->id ('parent');
        $test->assert_equals ($pi9-><AG::Node.parentNode>, $dtd);

        $test->id ('return.parent');
        $test->assert_null ($pi1-><AG::Node.parentNode>);

    @@Test:
      @@@QName: DTDef.replaceChild.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createDocumentTypeDefinition>
                           ('d');

        my $pi1 = $doc-><M::Document.createProcessingInstruction> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createProcessingInstruction> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createProcessingInstruction> ('pi3');
        $dtd-><M::Node.appendChild> ($pi3);

        # pi1, pi2, pi3

        my $pi9 = $doc-><M::Document.createProcessingInstruction> ('pi9');
        my $return = $dtd-><M::Node.replaceChild> ($pi9, $pi2);

        # pi1, pi9, pi3

        $test->id ('return.node');
        $test->assert_isa ($return, <IFName::Node>);
        $test->id ('return.pi');
        $test->assert_isa ($return, <IFName::tx|ProcessingInstruction>);
        $test->id ('return');
        $test->assert_equals ($return, $pi2);

        my $c = $dtd-><AG::Node.childNodes>;

        $test->id ('length');
        $test->assert_num_equals (actual_value => 0+@$c, expected_value => 3);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi1);

        $test->id ('firstChild.nextSibling');
        $test->assert_equals ($dtd-><AG::Node.firstChild>
                                  -><AG::Node.nextSibling>, $pi9);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi3);
 
        $test->id ('parent');
        $test->assert_equals ($pi9-><AG::Node.parentNode>, $dtd);

        $test->id ('return.parent');
        $test->assert_null ($pi2-><AG::Node.parentNode>);

    @@Test:
      @@@QName: DTDef.replaceChild.3.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createDocumentTypeDefinition>
                           ('d');

        my $pi1 = $doc-><M::Document.createProcessingInstruction> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createProcessingInstruction> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createProcessingInstruction> ('pi3');
        $dtd-><M::Node.appendChild> ($pi3);

        # pi1, pi2, pi3

        my $pi9 = $doc-><M::Document.createProcessingInstruction> ('pi9');
        my $return = $dtd-><M::Node.replaceChild> ($pi9, $pi3);

        # pi1, pi2, pi9

        $test->id ('return.node');
        $test->assert_isa ($return, <IFName::Node>);
        $test->id ('return.pi');
        $test->assert_isa ($return, <IFName::tx|ProcessingInstruction>);
        $test->id ('return');
        $test->assert_equals ($return, $pi3);

        my $c = $dtd-><AG::Node.childNodes>;

        $test->id ('length');
        $test->assert_num_equals (actual_value => 0+@$c, expected_value => 3);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi1);

        $test->id ('firstChild.nextSibling');
        $test->assert_equals ($dtd-><AG::Node.firstChild>
                                  -><AG::Node.nextSibling>, $pi2);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi9);
 
        $test->id ('parent');
        $test->assert_equals ($pi9-><AG::Node.parentNode>, $dtd);

        $test->id ('return.parent');
        $test->assert_null ($pi3-><AG::Node.parentNode>);

    @@Test:
      @@@QName: DTDef.replaceChild.sameparent.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createDocumentTypeDefinition>
                           ('d');

        my $pi1 = $doc-><M::Document.createProcessingInstruction> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createProcessingInstruction> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createProcessingInstruction> ('pi3');
        $dtd-><M::Node.appendChild> ($pi3);

        # pi1, pi2, pi3

        my $return = $dtd-><M::Node.replaceChild> ($pi3, $pi1);

        # pi3, pi2

        $test->id ('return.node');
        $test->assert_isa ($return, <IFName::Node>);
        $test->id ('return.pi');
        $test->assert_isa ($return, <IFName::tx|ProcessingInstruction>);
        $test->id ('return');
        $test->assert_equals ($return, $pi1);

        my $c = $dtd-><AG::Node.childNodes>;

        $test->id ('length');
        $test->assert_num_equals (actual_value => 0+@$c, expected_value => 2);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi3);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi2);
 
        $test->id ('parent');
        $test->assert_equals ($pi3-><AG::Node.parentNode>, $dtd);

        $test->id ('return.parent');
        $test->assert_null ($pi1-><AG::Node.parentNode>);

    @@Test:
      @@@QName: DTDef.replaceChild.sameparent.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createDocumentTypeDefinition>
                           ('d');

        my $pi1 = $doc-><M::Document.createProcessingInstruction> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createProcessingInstruction> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createProcessingInstruction> ('pi3');
        $dtd-><M::Node.appendChild> ($pi3);

        # pi1, pi2, pi3

        my $return = $dtd-><M::Node.replaceChild> ($pi1, $pi3);

        # pi2, pi1

        $test->id ('return.node');
        $test->assert_isa ($return, <IFName::Node>);
        $test->id ('return.pi');
        $test->assert_isa ($return, <IFName::tx|ProcessingInstruction>);
        $test->id ('return');
        $test->assert_equals ($return, $pi3);

        my $c = $dtd-><AG::Node.childNodes>;

        $test->id ('length');
        $test->assert_num_equals (actual_value => 0+@$c, expected_value => 2);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi2);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi1);
 
        $test->id ('parent');
        $test->assert_equals ($pi1-><AG::Node.parentNode>, $dtd);

        $test->id ('return.parent');
        $test->assert_null ($pi3-><AG::Node.parentNode>);

  @Test:
    @@QName: DocumentType..=.1.test
    @@PerlDef:
      my $doc;
      __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
      my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

      my $node = $docx-><M::DocumentXDoctype.createDocumentTypeDefinition> ('d');

      $node-><M::Node.manakaiAppendText> ('aaaa');
      $test->id ('1.class');
      $test->assert_isa ($node, <IFName::tx|DocumentType>);
      $test->id ('1.value');
      $test->assert_null ($node-><AG::Node.textContent>);

  @CMethod:
    @@Name: getFeature
    @@enDesc:
      Returns a specialized object that implements the specialized APIs.
    @@Param:
      @@@Name: feature
      @@@Type: DOMString
      @@@dis:actualType: f|FeatureNameString
    @@Param:
      @@@Name: version
      @@@Type: DOMString
      @@@dis:actualType: f|FeatureVersionString
    @@Return:
      @@@Type: DOMMain|DOMObject
      @@@nullCase:
      @@@PerlDef:
        $feature =~ s/^\+//;
        __CODE{f|getFeatureImpl::
          $self => $self,
          $feature => $feature, $version => $version, $r => $r,
          $base_class => {<ClassName::ManakaiDOMDocumentTypeDefinition>},
        }__;
        unless (defined $r) {
          __DEEP{
            $r = $self->SUPER::get_feature ($feature, $version);
          }__;
        }

    @@Test:
      @@@QName: DTDef.getFeature.1.test
      @@@PerlDef:
        my $node;
        __CODE{d|createDTDefForTest:: $dtdef => $node}__;

        for (
          [Core => '1.0', <IFName::tx|DocumentType||ManakaiDOM|ManakaiDOM1>],
          [Core => '2.0', <IFName::tx|DocumentType||ManakaiDOM|ManakaiDOM2>],
          [Core => '3.0', <IFName::tx|DocumentType||ManakaiDOM|ManakaiDOM3>],
          [XML => '1.0', <IFName::tx|DocumentType||ManakaiDOM|ManakaiDOM1>],
          [XML => '2.0', <IFName::tx|DocumentType||ManakaiDOM|ManakaiDOM2>],
          [XML => '3.0', <IFName::tx|DocumentType||ManakaiDOM|ManakaiDOM3>],
          [Core => '1.0', <IFName::DocumentTypeDefinition||ManakaiDOM|ManakaiDOMLatest>],
          [Core => '2.0', <IFName::DocumentTypeDefinition||ManakaiDOM|ManakaiDOMLatest>],
          [Core => '3.0', <IFName::DocumentTypeDefinition||ManakaiDOM|ManakaiDOMLatest>],
          [XML => '1.0', <IFName::DocumentTypeDefinition||ManakaiDOM|ManakaiDOMLatest>],
          [XML => '2.0', <IFName::DocumentTypeDefinition||ManakaiDOM|ManakaiDOMLatest>],
          [XML => '3.0', <IFName::DocumentTypeDefinition||ManakaiDOM|ManakaiDOMLatest>],
          [<Q::fe|XDoctype> => '3.0', <IFName::DocumentTypeDefinition||ManakaiDOM|ManakaiDOMLatest>],
          [<Q::fe|XDoctypeDeclaration> => '3.0', <IFName::DocumentTypeDeclaration||ManakaiDOM|ManakaiDOMLatest>],
        ) {
          $test->id ($_->[0].'.'.$_->[1]);
          my $sp = $node-><M::Node.getFeature> ($_->[0], $_->[1]);
          $test->assert_isa ($sp, $_->[2]);
        }

    @@Test:
      @@@QName: DTDef.getFeature.2.test
      @@@PerlDef:
        my $impl;
        __CODE{tc|createImplForTest:: $impl => $impl}__;

        my $node = $impl-><M::c|DOMImplementation.createDocumentType>
                            ('type', 'pub', 'sys');

        for (
          [Core => '1.0', <IFName::tx|DocumentType||ManakaiDOM|ManakaiDOM1>],
          [Core => '2.0', <IFName::tx|DocumentType||ManakaiDOM|ManakaiDOM2>],
          [Core => '3.0', <IFName::tx|DocumentType||ManakaiDOM|ManakaiDOM3>],
          [XML => '1.0', <IFName::tx|DocumentType||ManakaiDOM|ManakaiDOM1>],
          [XML => '2.0', <IFName::tx|DocumentType||ManakaiDOM|ManakaiDOM2>],
          [XML => '3.0', <IFName::tx|DocumentType||ManakaiDOM|ManakaiDOM3>],
          [Core => '1.0', <IFName::DocumentTypeDefinition||ManakaiDOM|ManakaiDOMLatest>],
          [Core => '2.0', <IFName::DocumentTypeDefinition||ManakaiDOM|ManakaiDOMLatest>],
          [Core => '3.0', <IFName::DocumentTypeDefinition||ManakaiDOM|ManakaiDOMLatest>],
          [XML => '1.0', <IFName::DocumentTypeDefinition||ManakaiDOM|ManakaiDOMLatest>],
          [XML => '2.0', <IFName::DocumentTypeDefinition||ManakaiDOM|ManakaiDOMLatest>],
          [XML => '3.0', <IFName::DocumentTypeDefinition||ManakaiDOM|ManakaiDOMLatest>],
          [<Q::fe|XDoctype> => '3.0', <IFName::DocumentTypeDefinition||ManakaiDOM|ManakaiDOMLatest>],
          [<Q::fe|XDoctypeDeclaration> => '3.0', <IFName::DocumentTypeDeclaration||ManakaiDOM|ManakaiDOMLatest>],
        ) {
          $test->id ($_->[0].'.'.$_->[1]);
          my $sp = $node-><M::Node.getFeature> ($_->[0], $_->[1]);
          $test->assert_isa ($sp, $_->[2]);
        }

  @CMethod:
    @@Name: removeChild
    @@enDesc:
      Removes a child node.
    @@Param:
      @@@Name: oldChild
      @@@Type: Node
    @@Return:
      @@@Type: Node
      @@@NodeReadOnlyError:
      @@@dx:raises:
        @@@@@: c|NOT_CHILD_ERR
        @@@@enDesc:
          If the <P::oldChild> is not a child of the node.
      @@@PerlDef:
        my $od = $self-><AG::Node.ownerDocument>;
        if ((not defined $od or
             $od-><AG::Document.strictErrorChecking>) and
            $self-><AG::Node.manakaiReadOnly>) {
          __EXCEPTION{MDOMX|NOMOD_THIS::
          }__;
        }
        __CODE{tc|removeChildImpl}__;

    @@Test:
      @@@QName: DTDef.removeChild.1.test
      @@@PerlDef:
        my $node;
        __CODE{d|createDTDefForTest:: $dtdef => $node}__;

        my $doc = $node-><AG::Node.ownerDocument>;

        my $c1 = $doc-><M::Document.createProcessingInstruction> ('e', '');
        $node-><M::Node.appendChild> ($c1);

        my $c2 = $doc-><M::Document.createProcessingInstruction> ('f', '');
        $node-><M::Node.appendChild> ($c2);

        my $c3 = $doc-><M::Document.createProcessingInstruction> ('g', '');
        $node-><M::Node.appendChild> ($c3);

        my $return = $node-><M::Node.removeChild> ($c1);

        $test->id ('return');
        $test->assert_equals ($return, $c1);

        $test->id ('parentNode');
        $test->assert_null ($c1-><AG::Node.parentNode>);

        $test->id ('firstChild');
        $test->assert_equals ($node-><AG::Node.firstChild>, $c2);

        $test->id ('lastChild');
        $test->assert_equals ($node-><AG::Node.lastChild>, $c3);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$node-><AG::Node.childNodes>},
                  expected_value => 2);
    @@Test:
      @@@QName: DTDef.removeChild.2.test
      @@@PerlDef:
        my $node;
        __CODE{d|createDTDefForTest:: $dtdef => $node}__;

        my $doc = $node-><AG::Node.ownerDocument>;

        my $c1 = $doc-><M::Document.createProcessingInstruction> ('e', '');
        $node-><M::Node.appendChild> ($c1);

        my $c2 = $doc-><M::Document.createProcessingInstruction> ('f', '');
        $node-><M::Node.appendChild> ($c2);

        my $c3 = $doc-><M::Document.createProcessingInstruction> ('g', '');
        $node-><M::Node.appendChild> ($c3);

        my $return = $node-><M::Node.removeChild> ($c2);

        $test->id ('return');
        $test->assert_equals ($return, $c2);

        $test->id ('parentNode');
        $test->assert_null ($c2-><AG::Node.parentNode>);

        $test->id ('firstChild');
        $test->assert_equals ($node-><AG::Node.firstChild>, $c1);

        $test->id ('lastChild');
        $test->assert_equals ($node-><AG::Node.lastChild>, $c3);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$node-><AG::Node.childNodes>},
                  expected_value => 2);
    @@Test:
      @@@QName: DTDef.removeChild.3.test
      @@@PerlDef:
        my $node;
        __CODE{d|createDTDefForTest:: $dtdef => $node}__;

        my $doc = $node-><AG::Node.ownerDocument>;

        my $c1 = $doc-><M::Document.createProcessingInstruction> ('e', '');
        $node-><M::Node.appendChild> ($c1);

        my $c2 = $doc-><M::Document.createProcessingInstruction> ('f', '');
        $node-><M::Node.appendChild> ($c2);

        my $c3 = $doc-><M::Document.createProcessingInstruction> ('g', '');
        $node-><M::Node.appendChild> ($c3);

        my $return = $node-><M::Node.removeChild> ($c3);

        $test->id ('return');
        $test->assert_equals ($return, $c3);

        $test->id ('parentNode');
        $test->assert_null ($c3-><AG::Node.parentNode>);

        $test->id ('firstChild');
        $test->assert_equals ($node-><AG::Node.firstChild>, $c1);

        $test->id ('lastChild');
        $test->assert_equals ($node-><AG::Node.lastChild>, $c2);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$node-><AG::Node.childNodes>},
                  expected_value => 2);
    @@Test:
      @@@QName: DTDef.removeChild.4.test
      @@@PerlDef:
        my $node;
        __CODE{d|createDTDefForTest:: $dtdef => $node}__;

        my $doc = $node-><AG::Node.ownerDocument>;

        my $c1 = $doc-><M::Document.createProcessingInstruction> ('e', '');
        $node-><M::Node.appendChild> ($c1);

        my $return = $node-><M::Node.removeChild> ($c1);

        $test->id ('return');
        $test->assert_equals ($return, $c1);

        $test->id ('parentNode');
        $test->assert_null ($c1-><AG::Node.parentNode>);

        $test->id ('firstChild');
        $test->assert_null ($node-><AG::Node.firstChild>);

        $test->id ('lastChild');
        $test->assert_null ($node-><AG::Node.lastChild>);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$node-><AG::Node.childNodes>},
                  expected_value => 0);

  @Attr:
    @@Name: elementTypes
    @@enDesc:
      A live <IF::tc|NamedNodeMap> that contains all 
      element types in the document type definition.

      What are contained in this collection depends on how
      the document type definition node is created.  If the
      node is created as the result of parsing of an XML
      document, it <kwd:MUST> contain all element types
      whose element type and / or attribute definition list
      declaration are encountered and provided to the DOM
      implementation from the XML processor.  Note that
      the XML processor might not provide part or entire of
      such information depending on the processor configuration.
      If more than one declarations for an element type or for
      an attribute is available at the time of definition node
      construction, then declarations other than the first ones
      <kwd:MUST> be discarded.
    @@Type: tc|NamedNodeMap
    @@Get:
      @@@enDesc:
        The returned collection <kwd:MUST> be read-only if and 
        only if the node is read-only.  Note that since
        the collection is live, a change of the read-only flag
        of the node immediately affects to the collection.
      @@@PerlDef:
        __CODE{tc|getElementTypeDefNodeMap::
          $node => $self,
          $map => $r,
        }__;

    @@Test:
      @@@QName: dtd.elementTypes.test
      @@@PerlDef:
        my $dtd;
        __CODE{d|createDTDefForTest:: $dtdef => $dtd}__;

        my $es = $dtd-><AG::DocumentTypeDefinition.elementTypes>;
        $test->assert_isa ($es, <IFName::tc|NamedNodeMap>);

  @Attr:
    @@Name: generalEntities
    @@enDesc:
      A live <IF::tc|NamedNodeMap> that contains all 
      general entities in the document type definition.

      All entities declared in the document type definition
      contained in or referenced from the document entity
      might not be exposed through this collection, depending
      on the information provided from the XML processor to
      the DOM implementation.  In particular, it might not
      contain any entity if entity references are expanded
      at the parse time.  An implementation <kwd:MUST-NOT>
      expose <IF::Entity> nodes whose <A::Node.localName>
      are equal to ones of five predefined general entities in XML
      through the collection as the result of parsing of an XML
      document that has no error.  Duplicate entity declarations
      are also discarded.
    @@Type: tc|NamedNodeMap
    @@Get:
      @@@enDesc:
        The returned collection <kwd:MUST> be read-only if and 
        only if the node is read-only.  Note that since
        the collection is live, a change of the read-only flag
        of the node immediately affects to the collection.
      @@@PerlDef:
        __CODE{tc|getEntityNodeMap::
          $node => $self,
          $map => $r,
        }__;

    @@Test:
      @@@QName: DocumentTypeDefinition.generalEntities.test
      @@@PerlDef:
        my $dtd;
        __CODE{d|createDTDefForTest:: $dtdef => $dtd}__;

        my $es = $dtd-><AG::DocumentTypeDefinition.generalEntities>;
        $test->assert_isa ($es, <IFName::tc|NamedNodeMap>);

  @CAttr:
    @@Name: entities
    @@Type: tc|NamedNodeMap
    @@Get:
      @@@disDef:
        @@@@DISPerl:cloneCode: .generalEntities.get

    @@Test:
      @@@QName: DocumentType.entities.get.test
      @@@PerlDef:
        my $impl;
        __CODE{tc|createImplForTest:: $impl => $impl}__;

        my $dtype = $impl-><M::c|DOMImplementation.createDocumentType>
                             ('type', 'pub', 'sys');
        my $ent = $dtype-><AG::tx|DocumentType.entities>;
        $test->assert_isa ($ent, <IFName::tc|NamedNodeMap>);
        $test->assert_num_equals
                 (actual_value => $ent-><AG::tc|NamedNodeMap.length>,
                  expected_value => 0);

  @Attr:
    @@Name: notations
    @@enDesc:
      A live <IF::tc|NamedNodeMap> that contains all 
      general entities in the document type definition.

      Duplicate notation declarations, if any, in DTD are not
      contained in the collection and only the first declaration
      is made available as a <IF::tx|Notation> node.

        {NOTE::
          This definition is based on one for the attribute
          <A::tx|DocumentType.notations> in DOM XML module.
          Since duplication is violation to the Validity Constraint,
          XML parsers might vary on how notations are notified to
          the application.  In particular, <InfoProp::notations>
          property of the <InfoItem::document information item>
          in the XML Information Set defines that in case <EM::any>
          notation is multiply declared then the property has no value.
        }
    @@Type: tc|NamedNodeMap
    @@Get:
      @@@enDesc:
        The returned collection <kwd:MUST> be read-only if and 
        only if the node is read-only.  Note that since
        the collection is live, a change of the read-only flag
        of the node immediately affects to the collection.
      @@@PerlDef:
        __CODE{tc|getNotationNodeMap::
          $node => $self,
          $map => $r,
        }__;

    @@Test:
      @@@QName: DocumentTypeDefinition.notations.test
      @@@PerlDef:
        my $dtd;
        __CODE{d|createDTDefForTest:: $dtdef => $dtd}__;

        my $es = $dtd-><AG::DocumentTypeDefinition.notations>;
        $test->assert_isa ($es, <IFName::tc|NamedNodeMap>);

    @@Test:
      @@@QName: DocumentType.notations.get.test
      @@@PerlDef:
        my $impl;
        __CODE{tc|createImplForTest:: $impl => $impl}__;

        my $dtype = $impl-><M::c|DOMImplementation.createDocumentType>
                             ('type', 'pub', 'sys');
        my $ent = $dtype-><AG::tx|DocumentType.notations>;
        $test->assert_isa ($ent, <IFName::tc|NamedNodeMap>);
        $test->assert_num_equals
                 (actual_value => $ent-><AG::tc|NamedNodeMap.length>,
                  expected_value => 0);
      
  @enImplNote:
    {TODO::
      Implement
      <A::.parameterEntities>.

      Test that:
        $a = $dtd->element_types;
        $b = $dtd->general_entities;
        $a is still a element type defs col.
      
      Implement get/set by name methods for parameter
      entities.
      
      Defines <M::Node.cloneNode>, <M::Node.importNode>,
      <M::Node.adoptNode>, namespace methods, ...
      
      In particular, document position for processing
      instruction children must be defined.
    }

  @Method:
    @@Name: getElementTypeDefinitionNode
    @@enDesc:
      Returns the definition for an element type.
    @@DOMMain:isNamespaceUnaware: 1
    @@Param:
      @@@Name: nameArg
      @@@Type: DOMString
      @@@enDesc:
        The name of the element type.
    @@Return:
      @@@Type: ElementTypeDefinition
      @@@enDesc:
        The element type definition for <P::nameArg>.
      @@@nullCase:
        @@@@enDesc:
          There is no definition for the element type <P::nameArg>.
      @@@PerlDef:
        my $v;
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $v,
          $prop => {<H::d|elementTypes>},
          $ref => $self,
        }__;
        if (defined $v->{$nameArg}) {
          __CODE{mg|createNodeRefFromID||ManakaiDOM|all::
            $bag => {<Code::mg|getNodeBag||ManakaiDOM|all:: $ref = $self>},
            $stemid => {$v->{$nameArg}},
            $ref => $r,
            $opt => {{
            }},
          }__;
        }

    @@Test:
      @@@PerlDef:
        my $dtd;
        __CODE{d|createDTDefForTest:: $dtdef => $dtd}__;
        $test->assert_null 
                 ($dtd-><M::DocumentTypeDefinition
                           .getElementTypeDefinitionNode> ('element'));

  @Method:
    @@Name: setElementTypeDefinitionNode
    @@enDesc:
      Sets an element type definition to the document type
      definition.
    @@Param:
      @@@Name: defNode
      @@@Type: ElementTypeDefinition
      @@@enDesc:
        The element type definition to set.  Its <A::Node.nodeName>
        attribute is used to set the node.  If it is already
        in use elsewhere, then it is first removed
        from there and then attached to the document type.
        If another element type definition with
        same <A::Node.nodeName> is attached to this document
        type definition, that association is removed.
        
        If <P::defNode> is already attached to this document
        type definition, then this method has no effect.
    @@Return:
      @@@Type: ElementTypeDefinition
      @@@enDesc:
        If there is already another element type definition
        with the same <A::Node.nodeName> as <P::defNode>,
        then that definition node is returned.
      @@@nullCase:
        @@@@enDesc:
          If there is no previous definition with the same
          name, or the <P::defNode> is already attached
          to the document type definition.
      @@@NodeReadOnlyError:
      @@@dx:raises:
        @@@@@: c|INUSE_DEFINITION_ERR
        @@@@enDesc:
          If <A::ElementTypeDefinition.ownerDocumentTypeDefinition>
          is not <DOM::null>.
      @@@dx:raises:
        @@@@@: c|DIFFERENT_DOCUMENT_ERR
        @@@@enDesc:
          The <P::defNode> node is created from different
          document than the <A::c|Node.ownerDocument> of
          the document type definition and the implementation
          does not support such definition node
          being attached to the document type definition.
      @@@PerlDef:
        __CODE{setDefinitionNode::
          $defNode => $defNode,
          $defNodeParamName => 'defNode',
          $key => {<H::d|elementTypes>},
          $self => $self, $r => $r,
        }__;

    @@Test:
      @@@QName: DTDef.setETDefNode.test
      @@@PerlDef:
        my $dtd;
        __CODE{d|createDTDefForTest:: $dtdef => $dtd}__;
        $test->assert_null 
                 ($dtd-><M::DocumentTypeDefinition
                           .getElementTypeDefinitionNode> ('et1'));

        my $et = $dtd-><AG::Node.ownerDocument>
                     -><M::Node.getFeature> (<Q::fe|XDoctype>)
                     -><M::DocumentXDoctype.createElementTypeDefinition>
                         ('et1');

        my $old1 = $dtd-><M::DocumentTypeDefinition
                           .setElementTypeDefinitionNode> ($et);
        $test->assert_null ($old1);

        my $ret = $dtd-><M::DocumentTypeDefinition
                           .getElementTypeDefinitionNode> ('et1');
        $test->assert_equals ($et, $ret);
        $test->assert_num_equals
                 (actual_value => $ret-><AG::Node.nodeType>,
                  expected_value => <C::Node.ELEMENT_TYPE_DEFINITION_NODE>);
        $test->assert_equals
                 ($et-><AG::ElementTypeDefinition.ownerDocumentTypeDefinition>,
                  $dtd);

        $test->id ('replace-same');

        my $old2 = $dtd-><M::DocumentTypeDefinition
                           .setElementTypeDefinitionNode> ($et);
        $test->assert_null ($old2);

        $test->id ('change-parent');

        my $dtd2 = $dtd-><AG::Node.ownerDocument>
                       -><M::Node.getFeature> (<Q::fe|XDoctype>)
                       -><M::DocumentXDoctype.createDocumentTypeDefinition>
                           ('dt2');
    
        $test->assert_exception (code => sub {
          $dtd2-><M::DocumentTypeDefinition
                            .setElementTypeDefinitionNode> ($et);
        }, exception_subtype => <Q::c|INUSE_DEFINITION_ERR>);
        
        $test->assert_equals
                 ($et-><AG::ElementTypeDefinition.ownerDocumentTypeDefinition>,
                  $dtd);
        $test->assert_equals
                 ($dtd-><M::DocumentTypeDefinition
                             .getElementTypeDefinitionNode>
                          ('et1'),
                  $et);
  
        $test->id ('rewrite');

        my $et2 = $dtd-><AG::Node.ownerDocument>
                      -><M::Node.getFeature> (<Q::fe|XDoctype>)
                      -><M::DocumentXDoctype.createElementTypeDefinition>
                          ('et1');
        $test->assert_not_equals ($et, $et2);

        my $old4 = $dtd-><M::DocumentTypeDefinition
                                .setElementTypeDefinitionNode> ($et2);
        $test->assert_equals ($old4, $et);
        $test->assert_equals
                 ($et2-><AG::ElementTypeDefinition.ownerDocumentTypeDefinition>,
                  $dtd);

    @@Test:
      @@@PerlDef:
        my $dtd;
        __CODE{d|createDTDefForTest:: $dtdef => $dtd}__;
        my $et;
        __CODE{d|createETDefForTest:: $etdef => $et}__;

        $test->assert_exception
          (code => sub {
            $dtd-><M::DocumentTypeDefinition
                     .setElementTypeDefinitionNode> ($et);
           },
           exception_subtype => <Q::c|DIFFERENT_DOCUMENT_ERR>);

  @Method:
    @@Name: getGeneralEntityNode
    @@enDesc:
      Returns the definition for a general entity.
    @@DOMMain:isNamespaceUnaware: 1
    @@Param:
      @@@Name: nameArg
      @@@Type: DOMString
      @@@enDesc:
        The name of the general entity.
    @@Return:
      @@@Type: tx|Entity
      @@@enDesc:
        The general entity whose name is <P::nameArg>.
      @@@nullCase:
        @@@@enDesc:
          There is no general entity <P::nameArg>.
      @@@PerlDef:
        my $v;
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $v,
          $prop => {<H::d|generalEntities>},
          $ref => $self,
        }__;
        if (defined $v->{$nameArg}) {
          __CODE{mg|createNodeRefFromID||ManakaiDOM|all::
            $bag => {<Code::mg|getNodeBag||ManakaiDOM|all:: $ref = $self>},
            $stemid => {$v->{$nameArg}},
            $ref => $r,
            $opt => {{
            }},
          }__;
        }
       
    @@Test:
      @@@QName: DocumentTypeDefinition.getGeneralEntityNode.test
      @@@PerlDef:
        my $dtd;
        __CODE{d|createDTDefForTest:: $dtdef => $dtd}__;
        $test->assert_null 
                 ($dtd-><M::DocumentTypeDefinition
                           .getGeneralEntityNode> ('element'));

  @Method:
    @@Name: setGeneralEntityNode
    @@enDesc:
      Sets a general entity to the document type
      definition.
    @@Param:
      @@@Name: defNode
      @@@Type: tx|Entity
      @@@enDesc:
        The general entity to set.  Its <A::Node.nodeName>
        attribute is used to set the node.

        If another general entity node with
        same <A::Node.nodeName> is attached to this document
        type definition, such association is removed.
        
        If <P::defNode> is already attached to this document
        type definition, then this method has no effect.
    @@Return:
      @@@Type: tx|Entity
      @@@enDesc:
        If there is already another general entity
        with the same <A::Node.nodeName> as <P::defNode>,
        then that node is returned.
      @@@nullCase:
        @@@@enDesc:
          If there is no previous definition with the same
          name, or the <P::defNode> is already attached
          to the document type definition.
      @@@NodeReadOnlyError:
      @@@dx:raises:
        @@@@@: c|INUSE_DEFINITION_ERR
        @@@@enDesc:
          If <A::tx|Entity.ownerDocumentTypeDefinition>
          is not <DOM::null>.
      @@@dx:raises:
        @@@@@: c|DIFFERENT_DOCUMENT_ERR
        @@@@enDesc:
          The <P::defNode> node is created from different
          document than the <A::c|Node.ownerDocument> of
          the document type definition and the implementation
          does not support such definition node
          being attached to the document type definition.
      @@@PerlDef:
        __CODE{setDefinitionNode::
          $defNode => $defNode,
          $defNodeParamName => 'defNode',
          $key => {<H::d|generalEntities>},
          $self => $self, $r => $r,
        }__;
    @@Test:
      @@@QName: DocumentTypeDefinition.setGeneralEntityNode.test
      @@@PerlDef:
        my $dtd;
        __CODE{d|createDTDefForTest:: $dtdef => $dtd}__;

        $test->id ('initial.empty');
        $test->assert_null 
                 ($dtd-><M::DocumentTypeDefinition
                           .getGeneralEntityNode> ('et1'));

        my $et = $dtd-><AG::Node.ownerDocument>
                     -><M::Node.getFeature> (<Q::fe|XDoctype>)
                     -><M::DocumentXDoctype.createGeneralEntity>
                         ('et1');

        $test->id ('set');
        my $old1 = $dtd-><M::DocumentTypeDefinition
                           .setGeneralEntityNode> ($et);
        $test->assert_null ($old1);

        $test->id ('get');
        my $ret = $dtd-><M::DocumentTypeDefinition
                           .getGeneralEntityNode> ('et1');
        $test->assert_equals ($et, $ret);
        $test->assert_num_equals
                 (actual_value => $ret-><AG::Node.nodeType>,
                  expected_value => <C::Node.ENTITY_NODE>);
        $test->assert_equals
                 ($et-><AG::tx|Entity.ownerDocumentTypeDefinition>,
                  $dtd);

        $test->id ('replace-same');
        my $old2 = $dtd-><M::DocumentTypeDefinition
                           .setGeneralEntityNode> ($et);
        $test->assert_null ($old2);

        $test->id ('change-parent');

        my $dtd2 = $dtd-><AG::Node.ownerDocument>
                       -><M::Node.getFeature> (<Q::fe|XDoctype>)
                       -><M::DocumentXDoctype.createDocumentTypeDefinition>
                           ('dt2');
    
        $test->assert_exception (code => sub {
          $dtd2-><M::DocumentTypeDefinition
                            .setGeneralEntityNode> ($et);
        }, exception_subtype => <Q::c|INUSE_DEFINITION_ERR>);
        
        $test->assert_equals
                 ($et-><AG::tx|Entity.ownerDocumentTypeDefinition>,
                  $dtd);
        $test->assert_equals
                 ($dtd-><M::DocumentTypeDefinition
                             .getGeneralEntityNode>
                          ('et1'),
                  $et);
  
        my $et2 = $dtd-><AG::Node.ownerDocument>
                      -><M::Node.getFeature> (<Q::fe|XDoctype>)
                      -><M::DocumentXDoctype.createGeneralEntity>
                          ('et1');
        $test->id ('new.ge.node');
        $test->assert_not_equals ($et, $et2);

        my $old4 = $dtd-><M::DocumentTypeDefinition
                                .setGeneralEntityNode> ($et2);
        $test->id ('old.ge.node');
        $test->assert_equals ($old4, $et);
        $test->id ('old.ge.node.owner');
        $test->assert_null ($et-><AG::tx|Entity.ownerDocumentTypeDefinition>);
        $test->id ('new.ge.node.owner');
        $test->assert_equals
                 ($et2-><AG::tx|Entity.ownerDocumentTypeDefinition>,
                  $dtd);

    @@Test:
      @@@QName: DocumentTypeDefinition.setGeneralEntityNode.DIFF_DOC_ERR.test
      @@@PerlDef:
        my $dtd;
        __CODE{d|createDTDefForTest:: $dtdef => $dtd}__;
        my $et;
        __CODE{tx|createGEForTest:: $gent => $et}__;

        $test->assert_exception
          (code => sub {
            $dtd-><M::DocumentTypeDefinition
                     .setGeneralEntityNode> ($et);
           },
           exception_subtype => <Q::c|DIFFERENT_DOCUMENT_ERR>);

  @Method:
    @@Name: getNotationNode
    @@enDesc:
      Returns the definition for a notation.
    @@DOMMain:isNamespaceUnaware: 1
    @@Param:
      @@@Name: nameArg
      @@@Type: DOMString
      @@@enDesc:
        The name of the notation.
    @@Return:
      @@@Type: tx|Notation
      @@@enDesc:
        The notation <P::nameArg>.
      @@@nullCase:
        @@@@enDesc:
          There is no notation <P::nameArg>.
      @@@PerlDef:
        my $v;
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $v,
          $prop => {<H::d|notations>},
          $ref => $self,
        }__;
        if (defined $v->{$nameArg}) {
          __CODE{mg|createNodeRefFromID||ManakaiDOM|all::
            $bag => {<Code::mg|getNodeBag||ManakaiDOM|all:: $ref = $self>},
            $stemid => {$v->{$nameArg}},
            $ref => $r,
            $opt => {{
            }},
          }__;
        }
    @@Test:
      @@@QName: DocumentTypeDefinition.getNotationNode.test
      @@@PerlDef:
        my $dtd;
        __CODE{d|createDTDefForTest:: $dtdef => $dtd}__;
        $test->assert_null 
                 ($dtd-><M::DocumentTypeDefinition
                           .getNotationNode> ('element'));

  @Method:
    @@Name: setNotationNode
    @@enDesc:
      Sets a notation to the document type
      definition.
    @@Param:
      @@@Name: defNode
      @@@Type: tx|Notation
      @@@enDesc:
        The notation to set.  Its <A::Node.nodeName>
        attribute is used to set the node.

        If another notation node with
        same <A::Node.nodeName> is attached to this document
        type definition, such association is removed.
        
        If <P::defNode> is already attached to this document
        type definition, then this method has no effect.
    @@Return:
      @@@Type: tx|Notation
      @@@enDesc:
        If there is already another notation
        with the same <A::Node.nodeName> as <P::defNode>,
        then that node is returned.
      @@@nullCase:
        @@@@enDesc:
          If there is no previous definition with the same
          name, or the <P::defNode> is already attached
          to the document type definition.
      @@@NodeReadOnlyError:
      @@@dx:raises:
        @@@@@: c|INUSE_DEFINITION_ERR
        @@@@enDesc:
          If <A::tx|Notation.ownerDocumentTypeDefinition>
          is not <DOM::null>.
      @@@dx:raises:
        @@@@@: c|DIFFERENT_DOCUMENT_ERR
        @@@@enDesc:
          The <P::defNode> node is created from different
          document than the <A::c|Node.ownerDocument> of
          the document type definition and the implementation
          does not support such definition node
          being attached to the document type definition.
      @@@PerlDef:
        __CODE{setDefinitionNode::
          $defNode => $defNode,
          $defNodeParamName => 'defNode',
          $key => {<H::d|notations>},
          $self => $self, $r => $r,
        }__;
    @@Test:
      @@@QName: DocumentTypeDefinition.setNotationNode.test
      @@@PerlDef:
        my $dtd;
        __CODE{d|createDTDefForTest:: $dtdef => $dtd}__;

        $test->id ('initial.empty');
        $test->assert_null 
                 ($dtd-><M::DocumentTypeDefinition
                           .getNotationNode> ('et1'));

        my $et = $dtd-><AG::Node.ownerDocument>
                     -><M::Node.getFeature> (<Q::fe|XDoctype>)
                     -><M::DocumentXDoctype.createNotation>
                         ('et1');

        $test->id ('set');
        my $old1 = $dtd-><M::DocumentTypeDefinition
                           .setNotationNode> ($et);
        $test->assert_null ($old1);

        $test->id ('get');
        my $ret = $dtd-><M::DocumentTypeDefinition
                           .getNotationNode> ('et1');
        $test->assert_equals ($et, $ret);
        $test->assert_num_equals
                 (actual_value => $ret-><AG::Node.nodeType>,
                  expected_value => <C::Node.NOTATION_NODE>);
        $test->assert_equals
                 ($et-><AG::tx|Notation.ownerDocumentTypeDefinition>,
                  $dtd);

        $test->id ('replace-same');
        my $old2 = $dtd-><M::DocumentTypeDefinition
                           .setNotationNode> ($et);
        $test->assert_null ($old2);

        $test->id ('change-parent');

        my $dtd2 = $dtd-><AG::Node.ownerDocument>
                       -><M::Node.getFeature> (<Q::fe|XDoctype>)
                       -><M::DocumentXDoctype.createDocumentTypeDefinition>
                           ('dt2');
    
        $test->assert_exception (code => sub {
          $dtd2-><M::DocumentTypeDefinition
                            .setNotationNode> ($et);
        }, exception_subtype => <Q::c|INUSE_DEFINITION_ERR>);
        
        $test->assert_equals
                 ($et-><AG::tx|Notation.ownerDocumentTypeDefinition>,
                  $dtd);
        $test->assert_equals
                 ($dtd-><M::DocumentTypeDefinition
                             .getNotationNode>
                          ('et1'),
                  $et);
  
        my $et2 = $dtd-><AG::Node.ownerDocument>
                      -><M::Node.getFeature> (<Q::fe|XDoctype>)
                      -><M::DocumentXDoctype.createNotation>
                          ('et1');
        $test->id ('new.notation.different');
        $test->assert_not_equals ($et, $et2);

        my $old4 = $dtd-><M::DocumentTypeDefinition
                                .setNotationNode> ($et2);
        $test->id ('old.notation.node');
        $test->assert_equals ($old4, $et);
        $test->id ('old.notation.node.ownerDTDef');
        $test->assert_null
                 ($et-><AG::tx|Notation.ownerDocumentTypeDefinition>);
        $test->id ('new.notation.node.ownerDTDef');
        $test->assert_equals
                 ($et2-><AG::tx|Notation.ownerDocumentTypeDefinition>,
                  $dtd);

    @@Test:
      @@@QName: DocumentTypeDefinition.setNotationNode.DIFF_DOC_ERR.test
      @@@PerlDef:
        my $dtd;
        __CODE{d|createDTDefForTest:: $dtdef => $dtd}__;
        my $et;
        __CODE{tx|createNotationForTest:: $not => $et}__;

        $test->assert_exception
          (code => sub {
            $dtd-><M::DocumentTypeDefinition
                     .setNotationNode> ($et);
           },
           exception_subtype => <Q::c|DIFFERENT_DOCUMENT_ERR>);

  @CAttr:
    @@Name: implementation
    @@enDesc:
      The <IF::c|DOMImplementation> object to which the node belongs.

      This attribute is a manakai extension.
    @@Type: c|DOMImplementation
    @@Get:
      @@@PerlDef:
        __CODE{mg|getNodeStemProp0Node||ManakaiDOM|all::
          $r => $r,
          $prop => {<H::f|implementation>},
          $ref => $self,
          $opt => {{}},
        }__;
        unless ($r) {
          __DEEP{
            $r = $self-><AG::Node.ownerDocument>
                      -><AG::Document.implementation>;
          }__;
        }

    @@Test:
      @@@QName: DTDef.impl.test
      @@@PerlDef:
        my $dtd;
        __CODE{d|createDTDefForTest:: $dtdef => $dtd}__;

        $test->assert_isa ($dtd-><AG::tx|DocumentType.implementation>,
                           <IFName::c|DOMImplementation>);

    @@Test:
      @@@QName: Doctype.impl.test
      @@@PerlDef:
        my $impl;
        __CODE{tc|createImplForTest:: $impl => $impl}__;

        my $dtype = $impl-><M::c|DOMImplementation.createDocumentType>
                             ('type', 'pub', 'sys');

        $test->id ('created');
        $test->assert_isa (my $i2 = $dtype-><AG::tx|DocumentType.implementation>,
                           <IFName::c|DOMImplementation>);
        $test->assert_equals ($i2, $impl);

        $test->id ('appended');
        my $doc = $impl-><M::c|DOMImplementation.createDocument>;
        $doc-><M::Node.appendChild> ($dtype);
        $test->assert_isa (my $i3 = $dtype-><AG::tx|DocumentType.implementation>,
                           <IFName::c|DOMImplementation>);
        $test->assert_equals ($i3, $impl);
##DocumentTypeDefinition

PropDef:
  @QName: d|hasLtDeclaration

PropDef:
  @QName: d|hasGtDeclaration

PropDef:
  @QName: d|hasAmpDeclaration

PropDef:
  @QName: d|hasAposDeclaration

PropDef:
  @QName: d|hasQuotDeclaration

enImplNote:
  Future version of this module might define a class for
  entity declarations.  Then these five properties will be removed.

IFClsXDef:
  @IFQName: DocumentTypeDeclaration
  @ClsQName: ManakaiDOMDocumentTypeDeclaration

  # This class is inherited by |ManakaiDOMDocumentTypeDeclaration|

  @f:implements: d|DeclFeature30
  @f:provides:
    @@@: d|DeclFeature30
    @@f:through: c|ManakaiDOMImplementation

  @enDesc:
    An object implementing the <IF::DocumentTypeDeclaration>
    interface represents a document type declaration contained
    in an XML document or a <InfoItem::document type declaration
    information item> in an XML infoset.

    An object implementing the <IF::DocumentTypeDeclaration>
    interface <kwd:MAY> also implement the <IF::DocumentTypeDefinition>
    interface and / or the <IF::tx|DocumentType> interface.

  @Attr:
    @@Name: systemId
    @@enDesc:
      The system identifier of the external subset, as it appears
      in the document type declaration, without any additional
      percent-encoding or relative reference resolving
      applied by the processor.
    @@Type: DOMString
    @@nullCase:
      @@@enDesc:
        If there is no system identifier specified.
    @@Get:
      @@@PerlDef:
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $r,
          $prop => {<H::infoset|systemIdentifier>},
          $ref => $self,
        }__;
    @@Set:
      @@@enDesc:
        Set the system identifier of the external subset.  No lexical
        validation is done.

        It does not lead any lexical or logical structure of the
        document being changed.  In particular, no attempt to
        load the external subset referenced by the new value
        is made.

          {NOTE:: Setting an invalid system identifier will make
                  the declaration unserializable.  Setting
                  a <DOM::null> system identifier to the declaration
                  whose external subset <EM::does> have the
                  public identifier will also make it unserializable.
          }
      @@@NodeReadOnlyError:
      @@@PerlDef:
        __CODE{tc|NodeReadOnlyError:: $node => $self}__;
        __CODE{mg|setNodeStemPropValue||ManakaiDOM|all::
          $given => $given,
          $prop => {<H::infoset|systemIdentifier>},
          $ref => $self,
        }__;

    @@Test:
      @@@QName: DTDef.systemId.test
      @@@PerlDef:
        my $dtd;
        __CODE{d|createDTDefForTest:: $dtdef => $dtd}__;

        $test->id ('initial');
        $test->assert_null ($dtd-><AG::DocumentTypeDeclaration.systemId>);

        $test->id ('set');
        $dtd-><AS::DocumentTypeDeclaration.systemId> ('sysId');
        $test->assert_equals ($dtd-><AG::DocumentTypeDeclaration.systemId>,
                              'sysId');

        $test->id ('set.illegal');
        $dtd-><AS::DocumentTypeDeclaration.systemId> (q<"sysId'>);
        $test->assert_equals ($dtd-><AG::DocumentTypeDeclaration.systemId>,
                              q<"sysId'>);

        $test->id ('set.null');
        $dtd-><AS::DocumentTypeDeclaration.systemId> (null);
        $test->assert_null ($dtd-><AG::DocumentTypeDeclaration.systemId>);

    @@Test:
      @@@QName: DocumentType.systemId.get.test
      @@@PerlDef:
        my $impl;
        __CODE{tc|createImplForTest:: $impl => $impl}__;

        my $dtype = $impl-><M::c|DOMImplementation.createDocumentType>
                             ('type', 'pub', 'sys');
        $test->assert_equals ($dtype-><AG::tx|DocumentType.systemId>, 'sys');

  @Attr:
    @@Name: publicId
    @@enDesc:
      The public identifier of the external subset, normalized as described
      in the XML specification.
    @@Type: DOMString
    @@nullCase:
      @@@enDesc:
        If there is no public identifier specified.
    @@Get:
      @@@PerlDef:
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $r,
          $prop => {<H::infoset|publicIdentifier>},
          $ref => $self,
        }__;
    @@Set:
      @@@enDesc:
        Set the given value to the attribute.  No normalization
        or lexical validation is done.

        It does not lead any lexical or logical structure of the
        document being changed.  In particular, no attempt to
        load the external subset referenced by the new value
        is made.

          {NOTE:: Setting an invalid public identifier or
                  an unnormalized public identifier will make
                  the declaration unserializable.  Setting
                  a public identifier to the declaration
                  whose external subset does not have any
                  system identifier will also make it unserializable.
          }
      @@@NodeReadOnlyError:
      @@@PerlDef:
        __CODE{tc|NodeReadOnlyError:: $node => $self}__;
        __CODE{mg|setNodeStemPropValue||ManakaiDOM|all::
          $given => $given,
          $prop => {<H::infoset|publicIdentifier>},
          $ref => $self,
        }__;

    @@Test:
      @@@QName: DTDef.publicId.test
      @@@PerlDef:
        my $dtd;
        __CODE{d|createDTDefForTest:: $dtdef => $dtd}__;

        $test->id ('initial');
        $test->assert_null ($dtd-><AG::DocumentTypeDeclaration.publicId>);

        $test->id ('set');
        $dtd-><AS::DocumentTypeDeclaration.publicId> ('sysId');
        $test->assert_equals ($dtd-><AG::DocumentTypeDeclaration.publicId>,
                              'sysId');

        $test->id ('set.illegal');
        $dtd-><AS::DocumentTypeDeclaration.publicId> (q<"sysId'>);
        $test->assert_equals ($dtd-><AG::DocumentTypeDeclaration.publicId>,
                              q<"sysId'>);

        $test->id ('set.null');
        $dtd-><AS::DocumentTypeDeclaration.publicId> (null);
        $test->assert_null ($dtd-><AG::DocumentTypeDeclaration.publicId>);

    @@Test:
      @@@QName: DocumentType.publicId.get.test
      @@@PerlDef:
        my $impl;
        __CODE{tc|createImplForTest:: $impl => $impl}__;

        my $dtype = $impl-><M::c|DOMImplementation.createDocumentType>
                             ('type', 'pub', 'sys');
        $test->assert_equals ($dtype-><AG::tx|DocumentType.publicId>, 'pub');

  @Attr:
    @@Name: name
    @@enDesc:
      The document type name.
    @@Type: DOMString
    @@dis:actualType: DOMMain|ManakaiDOMXMLName
    @@DOMMain:isNamespaceUnaware: 1
    @@Get:
      @@@disDef:
        @@@@DISPerl:cloneCode: d|ManakaiDOMDocumentTypeDefinition.nodeName.get

    @@Test:
      @@@QName: DTDef.name.get.test
      @@@PerlDef:
        my $docx;
        __CODE{d|createEmptyDocumentXForTest:: $docx => $docx}__;

        my $dtd = $docx-><M::DocumentXDoctype.createDocumentTypeDefinition>
                           ('dt1');

        $test->id ('initial');
        $test->assert_equals ($dtd-><AG::DocumentTypeDeclaration.name>, 'dt1');

    @@Test:
      @@@QName: DocumentType.name.get.test
      @@@PerlDef:
        my $impl;
        __CODE{tc|createImplForTest:: $impl => $impl}__;

        my $dtype = $impl-><M::c|DOMImplementation.createDocumentType>
                             ('type', 'pub', 'sys');
        $test->assert_equals ($dtype-><AG::tx|DocumentType.name>, 'type');

  @Attr:
    @@Name: declarationBaseURI
    @@enDesc:
      The base URI of the document type declaration.

      If the declaration implements the <IF::Node> interface 
      and <A::Node.ownerDocument> is different from <DOM::null>,
      then the base URI of the declaration is the base URI
      of that document.
    @@Type: DOMString
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          If the declaration has no owner document or if the
          document has no base URI.
      @@@PerlDef:
        __DEEP{
          my $od = $self-><AG::Node.ownerDocument>;
          if ($od) {
            $r = $od-><AG::Node.baseURI>;
          } else {
            $r = null;
          }
        }__;
    @@Set:
      @@@enDesc:
        Setting this attribute has no effect.
      @@@nullCase:
      @@@PerlDef:

    @@Test:
      @@@QName: DTDef.declarationBaseURI.get.test
      @@@PerlDef:
        my $dtd;
        __CODE{d|createDTDefForTest:: $dtdef => $dtd}__;

        $test->id ('initial');
        $test->assert_null
                 ($dtd-><AG::DocumentTypeDeclaration.declarationBaseURI>);

        $test->id ('doc');
        $dtd-><AG::Node.ownerDocument>-><AS::Document.documentURI>
                                          (q<http://doc.test/>);
        $test->assert_equals
                 ($dtd-><AG::DocumentTypeDeclaration.declarationBaseURI>,
                  q<http://doc.test/>);

  @Attr:
    @@Name: manakaiDeclarationBaseURI
    @@enDesc:
      The base URI of the document type declaration corresponding
      to the node, i.e. the base URI that is used to resolve
      the system identifier of the declaration.
    @@Type: DOMString
    @@dis:actualType: ManakaiDOM|ManakaiDOMURI
    @@Get:
      @@@enDesc:
        The <A::DocumentTypeDeclaration.declarationBaseURI> value.
      @@@nullCase:
        @@@@enDesc:
          If <A::DocumentTypeDeclaration.declarationBaseURI> is <DOM::null>.
      @@@PerlDef:
        __DEEP{
          $r = $self-><AG::DocumentTypeDeclaration.declarationBaseURI>;
        }__;
    @@Set:
      @@@enDesc:
        Setting this attribute has no effect.
      @@@nullCase:
      @@@PerlDef:

  @CAttr:
    @@Name: internalSubset
    @@Type: DOMString
    @@Get:
      @@@PerlDef:
        $r = null;

  @enImplNote:
    @@ddid: todo
    @@@:
      {TODO::
        Implement <A::tx|DocumentType.internalSubset>.

        External subset entity node?

        Internal subset pseudo-entity node?
      }
##DocumentTypeDeclaration

PropDef:
  @QName: d|elementTypes

PropDef:
  @QName: d|generalEntities

PropDef:
  @QName: d|parameterEntities

PropDef:
  @QName: d|notations

IFClsXDef:
  @IFQName: ElementTypeDefinition
  @ClsQName: ManakaiDOMElementTypeDefinition
  
  @IFISA: tc|Node
  @ClsISA: tc|ManakaiDOMNode
  
  @DISLang:role: tc|ElementTypeDefinitionRole

  @f:implements: d|Feature30
  
  @enDesc:
    An <IF::ElementTypeDefinition> node represents
    the definition for an element type.
    
      {NOTE:: Although an <IF::ElementTypeDefinition>
              can be constructed from an element
              type declaration in XML DTD, the
              <IF::ElementTypeDefinition> interface is
              not intended to represent element
              type declaration itself.
      }

  @IntMethod:
    @@Operator: mg|CreateNodeStemMethod
    @@Param:
      @@@Name: bag
      @@@Type: HASH
    @@Param:
      @@@Name: obj
      @@@Type: HASH
    @@Param:
      @@@Name: opt
      @@@Type: HASH
    @@Return:
      @@@Type: HASH
      @@@PerlDef:
        __CODE{DISPerl|HashStringRef||ManakaiDOM|all::
          $result => {$obj->{<H::infoset|name>}},
          $given => {${$opt->{<H::infoset|name>}}},
        }__;
        __CODE{mg|setOwnerProp||ManakaiDOM|all::
          $bag => $bag,
          $ownerref => {$opt->{<H::tc|ownerDocument>}},
          $ownee1hprop => {<H::tc|revOwnerDocument>},
          $ownee => {$obj},
          $owner0prop => {<H::tc|ownerDocument>},
        }__;
        $obj->{<H::d|attributeDefinitions>} = {};
        $r = $obj;
  @mg:owner0: tc|ownerDocument
  @mg:origin0: d|ownerDefinition
  @mg:subnode1h: d|attributeDefinitions

  @enImplNote:
    @@ddid: props
    @@@:
      {P:: Required internal properties:

        - <Q::tc|ownerDocument>.

        - <Q::infoset|name>.

        - <Q::d|attributeDefinitions>.

      }

      {P:: Optional internal properties:

        - <Q::d|ownerDefinitions>.

        - <Q::c|read-only>.
   
        - <Q::c|userData>.

      }

  @CODE:
    @@QName: d|createETDefForTest
    @@PerlDef:
      my $__docx;
      __CODE{d|createEmptyDocumentXForTest:: $docx => $__docx}__;
      $etdef = $__docx-><M::DocumentXDoctype.createElementTypeDefinition> ('et');

  @Attr:
    @@ForCheck: ManakaiDOM|ForClass
    @@Name: nodeType
    @@enDesc:
      The type of the node.
    @@Type: idl|unsignedShort||ManakaiDOM|all
    @@dis:actualType: tc|NodeType
    @@Get:
      @@@disDef:
        @@@@DISLang:constValue: Node.ELEMENT_TYPE_DEFINITION_NODE
    @@Test:
      @@@PerlDef:
        my $et;
        __CODE{d|createETDefForTest:: $etdef => $et}__;
        $test->assert_not_null ($et);
        $test->assert_num_equals 
                 (actual_value => $et-><AG::Node.nodeType>,
                  expected_value => <C::Node.ELEMENT_TYPE_DEFINITION_NODE>);

    @@Test:
      @@@QName: DocumentType.nodeType.get.test
      @@@PerlDef:
        my $impl;
        __CODE{tc|createImplForTest:: $impl => $impl}__;

        my $dtype = $impl-><M::c|DOMImplementation.createDocumentType>
                             ('type', 'pub', 'sys');
        $test->assert_num_equals
                 (actual_value => $dtype-><AG::Node.nodeType>,
                  expected_value => <C::Node.DOCUMENT_TYPE_NODE>);

  @CAttr:
    @@Name: nodeName
    @@enDesc:
      The element type name of the node.
    @@DOMMain:isNamespaceUnaware: 1
    @@Type: DOMString
    @@Get:
      @@@disDef:
        @@@@DISPerl:cloneCode: tx|ManakaiDOMNotation.nodeName.get

    @@Test:
      @@@QName: ETDef.nodeName.test
      @@@PerlDef:
        my $docx;
        __CODE{d|createEmptyDocumentXForTest:: $docx => $docx}__;

        my $et = $docx-><M::DocumentXDoctype.createElementTypeDefinition>
                          ('et1');

        $test->assert_equals ($et-><AG::Node.nodeName>, 'et1');

  @CAttr:
    @@Name: textContent
    @@enDesc:
      The text content of the node.
    @@Type: DOMString
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          The text content of the node is defined to be <DOM::null>.
      @@@disDef:
        @@@@DISPerl:cloneCode: tx|ManakaiDOMNotation.textContent.get
    @@Set:
      @@@enDesc:
        Setting this attribute has no effect.
      @@@c:reports:
        @@@@@: c|setting-node-value-no-effect
        @@@@enDesc:
          Setting the attribute value has no effect, since the
          node value is defined as <DOM::null>.
        @@@@For: ManakaiDOM|ManakaiDOM
      @@@disDef:
        @@@@DISPerl:cloneCode: tx|ManakaiDOMNotation.textContent.set

  @CAttr:
    @@Name: childNodes
    @@enDesc:
      A list of nodes that contains all children of the node.
    @@Get:
      @@@Type: tc|NodeList
      @@@enDesc:
        The node list that is always empty.
      @@@disDef:
        @@@@DISPerl:cloneCode: tcd|ManakaiDOMCharacterData.childNodes.get

  @CAttr:
    @@Name: baseURI
    @@enDesc:
      The base DOM URI of the node.  It <kwd:MUST> be the same
      value as the <A::Node.baseURI> attribute value of the
      <A::Node.ownerDocument> node of the node.
    @@Type: DOMString
    @@dis:actualType: ManakaiDOM|ManakaiDOMURI
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          If <A::Node.baseURI> of the <A::Node.ownerDocument> is
          <DOM::null>.
      @@@PerlDef:
        __DEEP{
          $r = $self-><AG::Node.ownerDocument>-><AG::Node.baseURI>;
        }__;

    @@Test:
      @@@QName: ETDef.baseURI.test
      @@@PerlDef:
        my $et;
        __CODE{d|createETDefForTest:: $etdef => $et}__;
 
        my $doc = $et-><AG::Node.ownerDocument>;
 
        $test->id ('initial');
        $test->assert_null ($et-><AG::Node.baseURI>);

        $test->id ('doc');
        $doc-><AS::Document.documentURI> (q<http://doc.test/>);
        $test->assert_equals
                 ($et-><AG::Node.baseURI>,
                  q<http://doc.test/>);
 
  @CMethod:
    @@Name: appendChild
    @@enDesc:
      Adds a node to the end of the list of children of the node.
      If that node is already in the tree, it is first removed.
    @@Param:
      @@@Name: newChild
      @@@Type: Node
      @@@enDesc:
        The node to add.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node added.
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_BAD_TYPE
        @@@@enDesc:
          The type of the node does not allow any children.
      @@@disDef:
        @@@@DISPerl:cloneCode: tcd|ManakaiDOMCharacterData.appendChild

  @CMethod:
    @@Name: insertBefore
    @@enDesc:
      Inserts a node before the existing child node of the node.
    @@Param:
      @@@Name: newChild
      @@@Type: Node
      @@@enDesc:
        The node to add.
    @@Param:
      @@@Name: refChild
      @@@Type: Node
      @@@enDesc:
        The node before which the <P::newChild> node is inserted.
      @@@nullCase:
        @@@@enDesc:
          The <P::newChild> node is inserted at the end.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node added.
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_BAD_TYPE
        @@@@enDesc:
          The type of the node does not allow any children.
      @@@disDef:
        @@@@DISPerl:cloneCode: tcd|ManakaiDOMCharacterData.insertBefore

  @CMethod:
    @@Name: replaceChild
    @@enDesc:
      Replaces a node by another node.
    @@Param:
      @@@Name: newChild
      @@@Type: Node
      @@@enDesc:
        The node to add.
    @@Param:
      @@@Name: oldChild
      @@@Type: Node
      @@@enDesc:
        The node to remove.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node replaced.
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_BAD_TYPE
        @@@@enDesc:
          The type of the node does not allow any children.
      @@@disDef:
        @@@@DISPerl:cloneCode: tcd|ManakaiDOMCharacterData.replaceChild

    @@Test:
      @@@QName: ETDef.appendChild.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $comment = $docx-><M::DocumentXDoctype.createElementTypeDefinition>
                               ('data');
        my $node2 = $doc-><M::Document.createTextNode> ('2');

        for my $node (
          $doc-><AG::Document.implementation>
              -><M::c|DOMImplementation.createDocument>,
          $doc-><M::Document.createDocumentFragment>,
          $doc-><AG::Document.implementation>
              -><M::c|DOMImplementation.createDocumentType> ('d'),
          $docx-><M::d|DocumentXDoctype.createDocumentTypeDefinition> ('d'),
          $doc-><M::Document.createEntityReference> ('ent'),
          $doc-><M::Document.createElement> ('e'),
          $doc-><M::Document.createAttribute> ('a'),
          $doc-><M::Document.createProcessingInstruction> ('pi'),
          $doc-><M::Document.createComment> ('c'),
          $doc-><M::Document.createTextNode> ('t'),
          $doc-><M::Document.createCDATASection> ('cs'),
          $docx-><M::d|DocumentXDoctype.createGeneralEntity> ('ge'),
          $docx-><M::d|DocumentXDoctype.createNotation> ('not'),
          $docx-><M::d|DocumentXDoctype.createElementTypeDefinition> ('et'),
          $docx-><M::d|DocumentXDoctype.createAttributeDefinition> ('at'),
          #test:nodeTypes
        ) {
          $test->id ('appendChild.'.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.appendChild> ($node);
          }, exception_subtype => <Q::MDOMX|HIERARCHY_BAD_TYPE>);

          $test->id ('insertBefore.'.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.insertBefore> ($node);
          }, exception_subtype => <Q::MDOMX|HIERARCHY_BAD_TYPE>);

          $test->id ('replaceChild.'.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.replaceChild> ($node, $node2);
          }, exception_subtype => <Q::MDOMX|HIERARCHY_BAD_TYPE>);
        }

  @Test:
    @@QName: ETDef..=.1.test
    @@PerlDef:
      my $doc;
      __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
      my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

      my $node = $docx-><M::DocumentXDoctype.createElementTypeDefinition> ('d');

      $node-><M::Node.manakaiAppendText> ('aaaa');
      $test->id ('1.class');
      $test->assert_isa ($node, <IFName::ElementTypeDefinition>);
      $test->id ('1.value');
      $test->assert_null ($node-><AG::Node.textContent>);

  @CMethod:
    @@Name: getFeature
    @@enDesc:
      Returns a specialized object that implements the specialized APIs.
    @@Param:
      @@@Name: feature
      @@@Type: DOMString
      @@@dis:actualType: f|FeatureNameString
    @@Param:
      @@@Name: version
      @@@Type: DOMString
      @@@dis:actualType: f|FeatureVersionString
    @@Return:
      @@@Type: DOMMain|DOMObject
      @@@nullCase:
      @@@PerlDef:
        $feature =~ s/^\+//;
        __CODE{f|getFeatureImpl::
          $self => $self,
          $feature => $feature, $version => $version, $r => $r,
          $base_class => {<ClassName::ManakaiDOMElementTypeDefinition>},
        }__;
        unless (defined $r) {
          __DEEP{
            $r = $self->SUPER::get_feature ($feature, $version);
          }__;
        }

    @@Test:
      @@@QName: ETDef.getFeature.test
      @@@PerlDef:
        my $node;
        __CODE{d|createETDefForTest:: $etdef => $node}__;

        for (
          [Core => '1.0', <IFName::ElementTypeDefinition||ManakaiDOM|ManakaiDOMLatest>],
          [Core => '2.0', <IFName::ElementTypeDefinition||ManakaiDOM|ManakaiDOMLatest>],
          [Core => '3.0', <IFName::ElementTypeDefinition||ManakaiDOM|ManakaiDOMLatest>],
          [XML => '1.0', <IFName::ElementTypeDefinition||ManakaiDOM|ManakaiDOMLatest>],
          [XML => '2.0', <IFName::ElementTypeDefinition||ManakaiDOM|ManakaiDOMLatest>],
          [XML => '3.0', <IFName::ElementTypeDefinition||ManakaiDOM|ManakaiDOMLatest>],
          [<Q::fe|XDoctype> => '3.0', <IFName::ElementTypeDefinition||ManakaiDOM|ManakaiDOMLatest>],
        ) {
          $test->id ($_->[0].'.'.$_->[1]);
          my $sp = $node-><M::Node.getFeature> ($_->[0], $_->[1]);
          $test->assert_isa ($sp, $_->[2]);
        }

  @enImplNote:
    {TODO:: Content model attributes are required.
    }

  @Attr:
    @@Name: attributeDefinitions
    @@enDesc:
      A live <IF::tc|NamedNodeMap> that contains all
      general entities in the document type definition.

      Duplicate attribute definitions in attribute
      definition list declarations are discarded.
    @@Type: tc|NamedNodeMap
    @@Get:
      @@@enDesc:
        The returned collection <kwd:MUST> be read-only if and 
        only if the node is read-only.  Note that since
        the collection is live, a change of the read-only flag
        of the node immediately affects to the collection.
      @@@PerlDef:
        __CODE{tc|getAttrDefNodeMap::
          $node => $self,
          $map => $r,
        }__;

    @@Test:
      @@@QName: elementTypeDef.attrDefs.test
      @@@PerlDef:
        my $et;
        __CODE{d|createETDefForTest:: $etdef => $et}__;

        my $as = $et-><AG::ElementTypeDefinition.attributeDefinitions>;
        $test->assert_isa ($as, <IFName::tc|NamedNodeMap>);
        $test->assert_num_equals
                 (actual_value => $as-><AG::tc|NamedNodeMap.length>,
                  expected_value => 0);

  @Method:
    @@Name: getAttributeDefinitionNode
    @@enDesc:
      Returns the definition for an attribute.
    @@DOMMain:isNamespaceUnaware: 1
    @@Param:
      @@@Name: nameArg
      @@@Type: DOMString
      @@@enDesc:
        The name of the attribute.
    @@Return:
      @@@Type: AttributeDefinition
      @@@enDesc:
        The attribute definition for <P::nameArg>.
      @@@nullCase:
        @@@@enDesc:
          There is no definition for the attribute <P::nameArg>.
      @@@PerlDef:
        my $v;
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $v,
          $prop => {<H::d|attributeDefinitions>},
          $ref => $self,
        }__;
        if (defined $v->{$nameArg}) {
          __CODE{mg|createNodeRefFromID||ManakaiDOM|all::
            $bag => {<Code::mg|getNodeBag||ManakaiDOM|all:: $ref = $self>},
            $stemid => {$v->{$nameArg}},
            $ref => $r,
            $opt => {{
            }},
          }__;
        }

    @@Test:
      @@@PerlDef:
        my $et;
        __CODE{d|createETDefForTest:: $etdef => $et}__;
        my $an = $et-><M::ElementTypeDefinition.getAttributeDefinitionNode>
                        ('at1');
        $test->assert_null ($an);

  @Method:
    @@Name: setAttributeDefinitionNode
    @@enDesc:
      Sets an attribute definition to the element
      definition.
    @@Param:
      @@@Name: attrDef
      @@@Type: AttributeDefinition
      @@@enDesc:
        The attribute definition to set.  Its <A::Node.nodeName>
        attribute is used to set the node.  If it is already
        in use for other element type, then it is first removed
        from that element type and then attached to this
        element type.  If another attribute definition with
        same <A::Node.nodeName> is attached to this element
        type definition, that association is removed.
        
        If <P::attrDef> is already attached to this element
        type definition, then this method has no effect.
    @@Return:
      @@@Type: AttributeDefinition
      @@@enDesc:
        If there is already another attribute definition
        with the same <A::Node.nodeName> as <P::attrDef>,
        then that definition node is returned.
      @@@nullCase:
        @@@@enDesc:
          If there is no previous definition with the same
          name, or the <P::attrDef> is already attached
          to the element type definition.
      @@@NodeReadOnlyError:
      @@@dx:raises:
        @@@@@: c|INUSE_DEFINITION_ERR
        @@@@enDesc:
          If <A::AttributeDefinition.ownerElementTypeDefinition>
          is not <DOM::null>.
      @@@dx:raises:
        @@@@@: c|DIFFERENT_DOCUMENT_ERR
        @@@@enDesc:
          The <P::attrDef> node is created from different
          document than the <A::c|Node.ownerDocument> of
          the element type definition and the implementation
          does not support such attribute definition node
          being attached to the element type definition.
      @@@PerlDef:
        __CODE{setDefinitionNodeAttr::
          $defNode => $attrDef,
          $defNodeParamName => 'attrDef',
          $key => {<H::d|attributeDefinitions>},
          $self => $self, $r => $r,
        }__;
    @@Test:
      @@@PerlDef:
        my $et;
        __CODE{d|createETDefForTest:: $etdef => $et}__;
        my $an = $et-><M::ElementTypeDefinition.getAttributeDefinitionNode>
                        ('at1');
        $test->assert_null ($an);

        my $can = $et-><AG::Node.ownerDocument>
                     -><M::Node.getFeature> (<Q::fe|XDoctype>)
                     -><M::DocumentXDoctype.createAttributeDefinition> ('at1');
        $et-><M::ElementTypeDefinition.setAttributeDefinitionNode> ($can);

        my $an2 = $et-><M::ElementTypeDefinition.getAttributeDefinitionNode>
                         ('at1');
        $test->assert_not_null ($an2);
        $test->assert_equals ($an2, $can);
        $test->assert_string
                 (actual_value => $an2-><AG::Node.nodeName>,
                  expected_value => 'at1');
  
  @Attr:
    @@Name: ownerDocumentTypeDefinition
    @@enDesc:
      The document type definition node to which
      the definition is attached.
    @@Type: DocumentTypeDefinition
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          The definition is not attached to any
          document type.
      @@@disDef:
        @@@@DISPerl:cloneCode:
          tx|ManakaiDOMNotation.ownerDocumentTypeDefinition.get

    @@Test:
      @@@PerlDef:
        my $et;
        __CODE{d|createETDefForTest:: $etdef => $et}__;
 
        my $odt = $et-><AG::ElementTypeDefinition.ownerDocumentTypeDefinition>;
        $test->assert_null ($odt);

        my $dt = $et-><AG::Node.ownerDocument>
                     -><M::Node.getFeature> (<Q::fe|XDoctype>)
                     -><M::DocumentXDoctype.createDocumentTypeDefinition>
                         ('dt1');
        $test->assert_not_null ($dt);
        $dt-><M::DocumentTypeDefinition.setElementTypeDefinitionNode> ($et);

        my $odt2 = $et-><AG::ElementTypeDefinition
                            .ownerDocumentTypeDefinition>;
        $test->assert_not_null ($odt2);
        $test->assert_isa ($odt2, <IFName::DocumentTypeDefinition>);
        $test->assert_equals ($odt2, $dt);
##ElementTypeDefinition

ForDef:
  @QName: ForDT
  @ISA: ManakaiDOM|ForClass

ForDef:
  @QName: ForAttr
  @ISA: ManakaiDOM|ForClass

ResourceDef:
  @For: ManakaiDOM|ManakaiDOM
  @rdf:type:
    @@@: dis|MultipleResource
    @@ForCheck: !ForDT !ForAttr
  @resourceFor: ForDT
  @resourceFor: ForAttr
  
  @rdf:type:
    @@@: DISPerl|BlockCode
    @@ForCheck: ManakaiDOM|ForClass
  
  @QName:
    @@@: setDefinitionNode
    @@ForCheck: ForDT
  @QName:
    @@@: setDefinitionNodeAttr
    @@ForCheck: ForAttr

  @enImplNote:
    Currently <IF::tx|DocumentType> nodes with no <A::Node.ownerDocument>
    are not allowed to contain any child or definition nodes.  It is
    also possible to set <A::Node.ownerDocument> of the <IF::tx|DocumentType>
    when a node is appended or set to the slot in the <IF::tx|DocumentType>.

    Future version of manakai might support implicit adoptation of 
    external nodes as Web browsers does.  In such an implementation
    setting <IF::tx|DocumentType>'s <A::Node.ownerDocument> would be
    more desired than <X::c|DOMException.WRONG_DOCUMENT_ERR>.
  
  @PerlDef:
    my $__aname = $defNode-><AG::Node.nodeName>;
    my $__list;
    __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
      $r => $__list,
      $prop => $key,
      $ref => $self,
    }__;
    if (defined $__list->{$__aname}) {
      __CODE{mg|createNodeRefFromID||ManakaiDOM|all::
        $bag => {<Code::mg|getNodeBag||ManakaiDOM|all:: $ref = $self>},
        $stemid => {$__list->{$__aname}},
        $ref => $r,
        $opt => {{
        }},
      }__;
    }
    SET: {
      if (defined $r and $r eq $defNode) {
        undef $r;
        last SET; # no effect
      }
      __CODE{tc|NodeReadOnlyError:: $node => $self}__;
      unless ($defNode-><AG::Node.ownerDocument>
                  eq $self-><AG::Node.ownerDocument>) {
        __EXCEPTION{c|DIFFERENT_DOCUMENT_ERR::
          MDOMX|param-name => {$defNodeParamName},
          c|node => {$defNode},
        }__;
      }
      my $__owner;
      __FOR{!ForAttr::
        $__owner = $defNode-><AG::ElementTypeDefinition
                                 .ownerDocumentTypeDefinition>;
      }__;
      __FOR{ForAttr::
        $__owner = $defNode-><AG::AttributeDefinition
                                 .ownerElementTypeDefinition>;
      }__;
      if ($__owner) {
        __EXCEPTION{c|INUSE_DEFINITION_ERR::
          MDOMX|param-name => {$defNodeParamName},
          c|node => {$defNode},
        }__;
      }
          
      if (defined $r) {
        __CODE{mg|deleteNodeStemPropValue||ManakaiDOM|all::
          $prop => {<H::d|ownerDefinition>},
          $ref => $r,
        }__;
      }

      $__list->{$__aname} = <Code::mg|getNodeID||ManakaiDOM|all::
                                       $ref = $defNode>;
      __CODE{mg|setNodeStemProp0Node||ManakaiDOM|all::
        $prop => {<H::d|ownerDefinition>},
        $ref => $defNode,
        $given => $self,
      }__;
    } # SET
##setDefinitionNode

IFClsXDef:
  @IFQName: AttributeDefinition
  @ClsQName: ManakaiDOMAttributeDefinition
  
  @IFISA: tc|Node
  @ClsISA: tc|ManakaiDOMNode
  
  @DISLang:role: tc|AttributeDefinitionRole

  @f:implements: d|Feature30
  
  @enDesc:
    An <IF::AttributeDefinition> attribute represents
    the definition for an attribute.
    
    The child list of an <IF::AttributeDefinition>
    represents the default value for the attribute.
    It can contain the same types of nodes as
    <IF::Attr> nodes.  It is ignored for the
    purposes of e.g. default value suppliment and
    serialization, if <A::AttributeDefinition.defaultType>
    has values other than 
    <C::AttributeDefinition.EXPLICIT_DEFAULT> or
    <C::AttributeDefinition.FIXED_DEFAULT>.

  @IntMethod:
    @@Operator: mg|CreateNodeStemMethod
    @@Param:
      @@@Name: bag
      @@@Type: HASH
    @@Param:
      @@@Name: obj
      @@@Type: HASH
    @@Param:
      @@@Name: opt
      @@@Type: HASH
    @@Return:
      @@@Type: HASH
      @@@PerlDef:
        __CODE{DISPerl|HashStringRef||ManakaiDOM|all::
          $result => {$obj->{<H::infoset|name>}},
          $given => {${$opt->{<H::infoset|name>}}},
        }__;
        $obj->{<H::d|declaredType>} = <C::AttributeDefinition.NO_TYPE_ATTR>;
        $obj->{<H::d|defaultType>} = <C::AttributeDefinition.UNKNOWN_DEFAULT>;
        __CODE{mg|setOwnerProp||ManakaiDOM|all::
          $bag => $bag,
          $ownerref => {$opt->{<H::tc|ownerDocument>}},
          $ownee1hprop => {<H::tc|revOwnerDocument>},
          $ownee => {$obj},
          $owner0prop => {<H::tc|ownerDocument>},
        }__;
        $obj->{<H::infoset|children>} = [];
        $obj->{<H::d|allowedTokens>} = [];
        $r = $obj;
  @mg:owner0: tc|ownerDocument
  @mg:origin0: d|ownerDefinition
  @mg:subnode1a: infoset|children

  @enImplNote:
    @@ddid: props
    @@@:
      {P:: Required internal properties:

        - <Q::tc|ownerDocument>.

        - <Q::infoset|name>.

        - <Q::d|declaredType>, <Q::d|defaultType>.

        - <Q::infoset|children>, <Q::d|allowedTokens>.

      }
      
      {P:: Optional internal properties:

        - <Q::d|ownerDefinition>.

        - <Q::c|read-only>.

      }

  @CODE:
    @@QName: d|createATDefForTest
    @@PerlDef:
      my $__docx;
      __CODE{d|createEmptyDocumentXForTest:: $docx => $__docx}__;
      $atdef = $__docx-><M::DocumentXDoctype.createAttributeDefinition> ('at');

  @CAttr:
    @@Name: nodeType
    @@enDesc:
      The type of the node.
    @@Type: idl|unsignedShort||ManakaiDOM|all
    @@dis:actualType: tc|NodeType
    @@Get:
      @@@disDef:
        @@@@DISLang:constValue: Node.ATTRIBUTE_DEFINITION_NODE

    @@Test:
      @@@QName: ATDef.nodeType.test
      @@@PerlDef:
        my $at;
        __CODE{d|createATDefForTest:: $atdef => $at}__;

        $test->assert_num_equals
                 (actual_value => $at-><AG::Node.nodeType>,
                  expected_value => <C::Node.ATTRIBUTE_DEFINITION_NODE>);
      
  @CAttr:
    @@Name: nodeName
    @@enDesc:
      The name of the attribute.
    @@DOMMain:isNamespaceUnaware: 1
    @@Type: DOMString
    @@Get:
      @@@disDef:
        @@@@DISPerl:cloneCode: tx|ManakaiDOMNotation.nodeName.get

    @@Test:
      @@@QName: ATDef.nodeName.test
      @@@PerlDef:
        my $docx;
        __CODE{d|createEmptyDocumentXForTest:: $docx => $docx}__;

        my $et = $docx-><M::DocumentXDoctype.createAttributeDefinition>
                          ('et1');

        $test->assert_equals ($et-><AG::Node.nodeName>, 'et1');
  
  @CAttr:
    @@Name: nodeValue
    @@enDesc:
      The normalized default value of the attribute.
    @@Type: DOMString
    @@Get:
      @@@nullCase:
      @@@PerlDef:
        __DEEP{
          my $dt = $self-><AG::AttributeDefinition.defaultType>;
          if ($dt == <C::AttributeDefinition.EXPLICIT_DEFAULT> or
              $dt == <C::AttributeDefinition.FIXED_DEFAULT>) {
            for my $child (@{$self-><AG::tc|Node.childNodes>}) {
              if ($child-><AG::Node.nodeType> ==
                  <C::Node.ENTITY_REFERENCE_NODE>) {
                my $v = $child-><AG::Node.textContent>;
                $v =~ s/[\x09\x0A\x0D]/ /;
                $r .= $v;
              } else {
                $r .= $child-><AG::Node.textContent>;
              }
            } # childNodes
            my $vt = $self-><AG::AttributeDefinition.declaredType>;
            unless ($vt == <C::AttributeDefinition.NO_TYPE_ATTR> or
                    $vt == <C::AttributeDefinition.UNKNOWN_ATTR> or
                    $vt == <C::AttributeDefinition.CDATA_ATTR>) {
              $r =~ s/\A\x20+//;
              $r =~ s/\x20+\z//;
              $r =~ s/\x20+/ /g;
            }
          } else {
            $r = null;
          }
        }__;
    @@Set:
      @@@NodeReadOnlyError:
      @@@PerlDef:
        __DEEP{
          my $dt = $self-><AG::AttributeDefinition.defaultType>;
          if ($dt == <C::AttributeDefinition.EXPLICIT_DEFAULT> or
              $dt == <C::AttributeDefinition.FIXED_DEFAULT>) {
            __UNDEEP{
              __CODE{tc|NodeReadOnlyError:: $node => $self}__;
            }__;
            my @children = @{$self-><AG::Node.childNodes>};
            for my $child (@children) {
              $self-><M::Node.removeChild> ($child);
            } # childNodes
            if (defined $given and length $given) {
              $self-><M::Node.appendChild>
                ($self-><AG::Node.ownerDocument>
                      -><M::Document.createTextNode>
                          ($given));
            }
          }
        }__;

    @@Test:
      @@@QName: ATDef.nodeValue.1.test
      @@@PerlDef:
        my $docx;
        __CODE{d|createEmptyDocumentXForTest:: $docx => $docx}__;
  
        for my $dt (
          <C::AttributeDefinition.EXPLICIT_DEFAULT>,
          <C::AttributeDefinition.FIXED_DEFAULT>,
        ) {
          my $node = $docx-><M::DocumentXDoctype.createAttributeDefinition>
                              ('attr');
          $node-><AS::AttributeDefinition.defaultType> ($dt);

          $test->id ($dt.'.nodeValue.get');
          $test->assert_equals ($node-><AG::Node.nodeValue>, '');

          $node-><M::Node.manakaiSetReadOnly> (false);

          $node-><AS::Node.nodeValue> ('value1');

          $test->id ($dt.'.nodeValue.set.nodeValue');
          $test->assert_equals ($node-><AG::Node.nodeValue>, 'value1');

          $node-><AS::Node.nodeValue> ('');

          $test->id ($dt.'.nodeValue.empty.nodeValue');
          $test->assert_equals ($node-><AG::Node.nodeValue>, '');

          $node-><M::Node.manakaiSetReadOnly> (true);

          $test->id ($dt.'.nodeValue.set.ro');
          $test->assert_exception (code => sub {
            $node-><AS::Node.nodeValue> ('value1');
          }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);
          $test->assert_equals ($node-><AG::Node.nodeValue>, '');
        }

    @@Test:
      @@@QName: ATDef.nodeValue.2.test
      @@@PerlDef:
        my $docx;
        __CODE{d|createEmptyDocumentXForTest:: $docx => $docx}__;
  
        for my $dt (
          <C::AttributeDefinition.UNKNOWN_DEFAULT>,
          <C::AttributeDefinition.IMPLIED_DEFAULT>,
          <C::AttributeDefinition.REQUIRED_DEFAULT>,
        ) {
          my $node = $docx-><M::DocumentXDoctype.createAttributeDefinition>
                              ('attr');
          $node-><AS::AttributeDefinition.defaultType> ($dt);

          $test->id ($dt.'get');
          $test->assert_null ($node-><AG::Node.nodeValue>);

          $node-><M::Node.manakaiSetReadOnly> (false);

          $test->id ($dt.'set');
          $node-><AS::Node.nodeValue> ('node-value');
          $test->assert_null ($node-><AG::Node.nodeValue>);

          $node-><M::Node.manakaiSetReadOnly> (true);

          $test->id ($dt.'roset');
          $node-><AS::Node.nodeValue> ('node-value');
          $test->assert_null ($node-><AG::Node.nodeValue>);
        }

    @@Test:
      @@@QName: ATDef.nodeValue.get.1.test
      @@@PerlDef:
        my $at;
        __CODE{d|createATDefForTest:: $atdef => $at}__;

        $test->id ('get-empty-content');

        $at-><AS::AttributeDefinition.defaultType>
               (<C::AttributeDefinition.UNKNOWN_DEFAULT>);
        $test->assert_null ($at-><AG::Node.nodeValue>);
        $at-><AS::AttributeDefinition.defaultType>
               (<C::AttributeDefinition.IMPLIED_DEFAULT>);
        $test->assert_null ($at-><AG::Node.nodeValue>);
        $at-><AS::AttributeDefinition.defaultType>
               (<C::AttributeDefinition.REQUIRED_DEFAULT>);
        $test->assert_null ($at-><AG::Node.nodeValue>);
        $at-><AS::AttributeDefinition.defaultType>
               (<C::AttributeDefinition.EXPLICIT_DEFAULT>);
        $test->assert_string
                 (actual_value => $at-><AG::Node.nodeValue>,
                  expected_value => '');
        $at-><AS::AttributeDefinition.defaultType>
               (<C::AttributeDefinition.FIXED_DEFAULT>);
        $test->assert_string
                 (actual_value => $at-><AG::Node.nodeValue>,
                  expected_value => '');

        $test->id ('get-string-content');

        my $doc = $at-><AG::Node.ownerDocument>;
        $at-><M::Node.appendChild>
               ($doc-><M::Document.createTextNode> ('  abcdefg'));

        $at-><AS::AttributeDefinition.defaultType>
               (<C::AttributeDefinition.UNKNOWN_DEFAULT>);
        $test->assert_null ($at-><AG::Node.nodeValue>);
        $at-><AS::AttributeDefinition.defaultType>
               (<C::AttributeDefinition.IMPLIED_DEFAULT>);
        $test->assert_null ($at-><AG::Node.nodeValue>);
        $at-><AS::AttributeDefinition.defaultType>
               (<C::AttributeDefinition.REQUIRED_DEFAULT>);
        $test->assert_null ($at-><AG::Node.nodeValue>);
        $at-><AS::AttributeDefinition.defaultType>
               (<C::AttributeDefinition.EXPLICIT_DEFAULT>);
        $test->assert_string
                 (actual_value => $at-><AG::Node.nodeValue>,
                  expected_value => '  abcdefg');
        $at-><AS::AttributeDefinition.defaultType>
               (<C::AttributeDefinition.FIXED_DEFAULT>);
        $test->assert_string
                 (actual_value => $at-><AG::Node.nodeValue>,
                  expected_value => '  abcdefg');

        $test->id ('multiple-text-nodes');
  
        $at-><M::Node.appendChild>
               ($doc-><M::Document.createTextNode> ('ABCDEFG '));
        $test->assert_string
                 (actual_value => $at-><AG::Node.nodeValue>,
                  expected_value => '  abcdefgABCDEFG ');

        $test->id ('white-space');

        $at-><M::Node.appendChild>
               ($doc-><M::Document.createTextNode>
                        ("\x20\x20,\x20\x09,\x20\x0A,\x20\x0D,  "));

        $at-><AS::AttributeDefinition.declaredType>
               (<C::AttributeDefinition.UNKNOWN_ATTR>);
        $test->assert_string
                 (actual_value => $at-><AG::Node.nodeValue>,
                  expected_value => "  abcdefgABCDEFG   , \x09, \x0A, \x0D,  ");
        $at-><AS::AttributeDefinition.declaredType>
               (<C::AttributeDefinition.CDATA_ATTR>);
        $test->assert_string
                 (actual_value => $at-><AG::Node.nodeValue>,
                  expected_value => "  abcdefgABCDEFG   , \x09, \x0A, \x0D,  ");
        $at-><AS::AttributeDefinition.declaredType>
               (<C::AttributeDefinition.ID_ATTR>);
        $test->assert_string
                 (actual_value => $at-><AG::Node.nodeValue>,
                  expected_value => "abcdefgABCDEFG , \x09, \x0A, \x0D,");
        $at-><AS::AttributeDefinition.declaredType>
               (<C::AttributeDefinition.IDREF_ATTR>);
        $test->assert_string
                 (actual_value => $at-><AG::Node.nodeValue>,
                  expected_value => "abcdefgABCDEFG , \x09, \x0A, \x0D,");
          $at-><AS::AttributeDefinition.declaredType>
               (<C::AttributeDefinition.IDREFS_ATTR>);
        $test->assert_string
                 (actual_value => $at-><AG::Node.nodeValue>,
                  expected_value => "abcdefgABCDEFG , \x09, \x0A, \x0D,");
        $at-><AS::AttributeDefinition.declaredType>
               (<C::AttributeDefinition.ENTITY_ATTR>);
        $test->assert_string
                 (actual_value => $at-><AG::Node.nodeValue>,
                  expected_value => "abcdefgABCDEFG , \x09, \x0A, \x0D,");
        $at-><AS::AttributeDefinition.declaredType>
               (<C::AttributeDefinition.ENTITIES_ATTR>);
        $test->assert_string
                 (actual_value => $at-><AG::Node.nodeValue>,
                  expected_value => "abcdefgABCDEFG , \x09, \x0A, \x0D,");
        $at-><AS::AttributeDefinition.declaredType>
               (<C::AttributeDefinition.NMTOKEN_ATTR>);
        $test->assert_string
                 (actual_value => $at-><AG::Node.nodeValue>,
                  expected_value => "abcdefgABCDEFG , \x09, \x0A, \x0D,");
        $at-><AS::AttributeDefinition.declaredType>
               (<C::AttributeDefinition.NMTOKENS_ATTR>);
        $test->assert_string
                 (actual_value => $at-><AG::Node.nodeValue>,
                  expected_value => "abcdefgABCDEFG , \x09, \x0A, \x0D,");
        $at-><AS::AttributeDefinition.declaredType>
               (<C::AttributeDefinition.NOTATION_ATTR>);
        $test->assert_string
                 (actual_value => $at-><AG::Node.nodeValue>,
                  expected_value => "abcdefgABCDEFG , \x09, \x0A, \x0D,");
        $at-><AS::AttributeDefinition.declaredType>
               (<C::AttributeDefinition.ENUMERATION_ATTR>);
        $test->assert_string
                 (actual_value => $at-><AG::Node.nodeValue>,
                  expected_value => "abcdefgABCDEFG , \x09, \x0A, \x0D,");
    @@Test:
      @@@QName: ATDef.nodeValue.set.1.test
      @@@PerlDef:
        my $at;
        __CODE{d|createATDefForTest:: $atdef => $at}__;
        my $doc = $at-><AG::Node.ownerDocument>;

        $test->id ('set-no-effect');

        $at-><M::Node.appendChild>
               (my $t = $doc-><M::Document.createTextNode> ('abcdefg'));

        $test->assert_not_null ($t-><AG::Node.parentNode>);

        $at-><AS::AttributeDefinition.defaultType>
               (<C::AttributeDefinition.UNKNOWN_DEFAULT>);
        $at-><AS::Node.nodeValue> ('VWXYZ');
        $test->assert_not_null ($t-><AG::Node.parentNode>);

        $at-><AS::AttributeDefinition.defaultType>
               (<C::AttributeDefinition.IMPLIED_DEFAULT>);
        $at-><AS::Node.nodeValue> ('VWXYZ');
        $test->assert_not_null ($t-><AG::Node.parentNode>);

        $at-><AS::AttributeDefinition.defaultType>
               (<C::AttributeDefinition.REQUIRED_DEFAULT>);
        $at-><AS::Node.nodeValue> ('VWXYZ');
        $test->assert_not_null ($t-><AG::Node.parentNode>);

        $test->id ('set-value');

        $at-><AS::AttributeDefinition.defaultType>
               (<C::AttributeDefinition.EXPLICIT_DEFAULT>);
        $at-><AS::Node.nodeValue> ('VWXYZ');
        $test->assert_null ($t-><AG::Node.parentNode>);
        $test->assert_string
                 (actual_value => $at-><AG::Node.nodeValue>,
                  expected_value => 'VWXYZ');

        $at-><M::Node.appendChild> ($t);
        $test->assert_not_null ($t-><AG::Node.parentNode>);

        $at-><AS::AttributeDefinition.defaultType>
               (<C::AttributeDefinition.FIXED_DEFAULT>);
        $at-><AS::Node.nodeValue> ('VWXYZ');
        $test->assert_null ($t-><AG::Node.parentNode>);
        $test->assert_string
                 (actual_value => $at-><AG::Node.nodeValue>,
                  expected_value => 'VWXYZ');

        $at-><AS::Node.nodeValue> ('');
        $test->assert_false ($at-><M::Node.hasChildNodes>);
        
        $at-><M::Node.appendChild> ($t);

        $at-><AS::Node.nodeValue> (null);
        $test->assert_false ($at-><M::Node.hasChildNodes>);

    @@Test:
      @@@QName: ATDef.textContent.get.test
      @@@PerlDef:
        my $at;
        __CODE{d|createATDefForTest:: $atdef => $at}__;

        $test->id ('get-empty-content');

        $test->assert_string
                 (actual_value => $at-><AG::Node.textContent>,
                  expected_value => '');

        $test->id ('get-string-content');

        my $doc = $at-><AG::Node.ownerDocument>;
        $at-><M::Node.appendChild>
               ($doc-><M::Document.createTextNode> ('  abcdefg'));

        $test->assert_string
                 (actual_value => $at-><AG::Node.textContent>,
                  expected_value => '  abcdefg');

        $test->id ('multiple-text-nodes');
  
        $at-><M::Node.appendChild>
               ($doc-><M::Document.createTextNode> ('ABCDEFG '));
        $test->assert_string
                 (actual_value => $at-><AG::Node.textContent>,
                  expected_value => '  abcdefgABCDEFG ');

        $test->id ('white-space');

        $at-><M::Node.appendChild>
               ($doc-><M::Document.createTextNode>
                        ("\x20\x20,\x20\x09,\x20\x0A,\x20\x0D,  "));

        $at-><AS::AttributeDefinition.declaredType>
               (<C::AttributeDefinition.CDATA_ATTR>);
        $test->assert_string
                 (actual_value => $at-><AG::Node.textContent>,
                  expected_value => "  abcdefgABCDEFG   , \x09, \x0A, \x0D,  ");
        $at-><AS::AttributeDefinition.declaredType>
               (<C::AttributeDefinition.ID_ATTR>);
        $test->assert_string
                 (actual_value => $at-><AG::Node.textContent>,
                  expected_value => "  abcdefgABCDEFG   , \x09, \x0A, \x0D,  ");
    @@Test:
      @@@QName: ATDef.textContent.set.test
      @@@PerlDef:
        my $at;
        __CODE{createATDefForTest:: $atdef => $at}__;
        my $doc = $at-><AG::Node.ownerDocument>;

        $test->id ('set-no-effect');

        $at-><M::Node.appendChild>
               (my $t = $doc-><M::Document.createTextNode> ('abcdefg'));

        $test->assert_not_null ($t-><AG::Node.parentNode>);

        $test->id ('textContent.set.previous.parentNode');
        $at-><AS::AttributeDefinition.defaultType>
               (<C::AttributeDefinition.UNKNOWN_DEFAULT>);
        $at-><AS::Node.textContent> ('VWXYZ');
        $test->assert_null ($t-><AG::Node.parentNode>);

        $test->id ('set-value');

        $at-><AS::AttributeDefinition.defaultType>
               (<C::AttributeDefinition.EXPLICIT_DEFAULT>);
        $at-><AS::Node.textContent> ('VWXYZ');
        $test->assert_null ($t-><AG::Node.parentNode>);
        $test->assert_string
                 (actual_value => $at-><AG::Node.textContent>,
                  expected_value => 'VWXYZ');

        $at-><AS::Node.textContent> ('');
        $test->assert_false ($at-><M::Node.hasChildNodes>);
        
        $at-><M::Node.appendChild> ($t);

        $at-><AS::Node.textContent> (null);
        $test->assert_false ($at-><M::Node.hasChildNodes>);

  @CAttr:
    @@Name: baseURI
    @@enDesc:
      The base DOM URI of the node.  It <kwd:MUST> be the same
      value as the <A::Node.baseURI> attribute value of the
      <A::Node.ownerDocument> node of the node.
    @@Type: DOMString
    @@dis:actualType: ManakaiDOM|ManakaiDOMURI
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          If <A::Node.baseURI> of the <A::Node.ownerDocument> is
          <DOM::null>.
      @@@PerlDef:
        __DEEP{
          $r = $self-><AG::Node.ownerDocument>-><AG::Node.baseURI>;
        }__;

    @@Test:
      @@@QName: ATDef.baseURI.test
      @@@PerlDef:
        my $et;
        __CODE{d|createATDefForTest:: $atdef => $et}__;
 
        my $doc = $et-><AG::Node.ownerDocument>;
 
        $test->id ('initial');
        $test->assert_null ($et-><AG::Node.baseURI>);

        $test->id ('doc');
        $doc-><AS::Document.documentURI> (q<http://doc.test/>);
        $test->assert_equals
                 ($et-><AG::Node.baseURI>,
                  q<http://doc.test/>);

  @CMethod:
    @@Name: appendChild
    @@enDesc:
      Adds a node to the end of the list of children of the node.
      If that node is already in the tree, it is first removed.
    @@Param:
      @@@Name: newChild
      @@@Type: Node
      @@@enDesc:
        The node to add.
      @@@InCase:
        @@@@Type: DocumentFragment
        @@@@enDesc:
          The entire contents of the document fragment are
          moved into the child list of the node.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node added.  If the <P::newChild> node is a <IF::DocumentFragment>
        node, then the <P::newChild> node <kwd:MUST> be returned.
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_BAD_TYPE
        @@@@enDesc:
          If the node is of a type that does not allow children of
          the type of the <P::newChild> node.
 
          If the <A::Document.strictErrorChecking> is set to <DOM::false>,
          this exception <kwd:MAY-NOT> be thrown.
      @@@dx:raises:
        @@@@@: c|DIFFERENT_DOCUMENT_ERR
        @@@@enDesc:
          If the <P::newChild> node was created from a different
          document than the one to which the node was created or
          the node does not belong to any document.

          If the <A::Document.strictErrorChecking> is set to <DOM::false>,
          this exception <kwd:MAY-NOT> be thrown.
      @@@dx:raises: 
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the node is read-only.

          If the <A::Document.strictErrorChecking> is set to <DOM::false>,
          this exception <kwd:MAY-NOT> be thrown.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_SRC_PARENT
        @@@@enDesc:
          If the previous parent of the <P::newChild> node is read-only
          <SRC::DOM 2 Errata, DOM 3>.

          If the <A::Document.strictErrorChecking> is set to <DOM::false>,
          this exception <kwd:MAY-NOT> be thrown.
      @@@PerlDef:
        my $self_od = $self-><AG::Node.ownerDocument>;
        my $child_od = $newChild-><AG::Node.ownerDocument>;
        my $child_nt = $newChild-><AG::Node.nodeType>;
        __CODE{tc|appendChildImpl1::
          $self => $self, $self_od => $self_od,
          $newChild => $newChild, $child_od => $child_od, $child_nt => $child_nt,
          $r => $r,
          $allowedNodeTypes => {{
            <C::Node.TEXT_NODE> => true,
            <C::Node.ENTITY_REFERENCE_NODE> => true,
          }},
        }__;

  @CMethod:
    @@Name: insertBefore
    @@enDesc:
      Inserts a node before the existing child node of the node.

      Inserting a node before itself is implementation dependent.
    @@Param:
      @@@Name: newChild
      @@@Type: Node
      @@@enDesc:
        The node to insert.  If the <P::newChild> is already in 
        the tree, it is first removed.
      @@@InCase:
        @@@@Type: DocumentFragment
        @@@@enDesc:
          All of children of the <P::newChild> node are inserted,
          in the same order, before <P::refChild>.
    @@Param:
      @@@Name: refChild
      @@@Type: Node
      @@@enDesc:
        The reference node, i.e. the node before which the new node
        must be inserted.
      @@@nullCase:
        @@@@enDesc:
          The <P::newChild> node is inserted at the end of the list
          of children.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node being inserted.
      @@@enImplNote:
        What is returned if <P::newChild> is a <IF::DocumentFragment>?
        See also <M::Node.appendChild>'s return value.
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_BAD_TYPE
        @@@@enDesc:
          If the node is of a type that does not allow children of
          the type of the <P::newChild> node.
      @@@dx:raises:
        @@@@@: c|DIFFERENT_DOCUMENT_ERR
        @@@@enDesc:
          If the <P::newChild> node was created from a different
          document than the one that created the node.
        @@@@enImplNote:
          The DOM specification ignores the fact that <IF::Document>s
          and <IF::tx|DocumentType>s are created from 
          <IF::c|DOMImplementation> :-)
      @@@dx:raises: 
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the node is read-only.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_SRC_PARENT
        @@@@enDesc:
          If the previous parent of the <P::newChild> node is read-only
          <SRC::DOM 1 SE, DOM 2, 3>.
      @@@dx:raises:
        @@@@@: c|NOT_CHILD_ERR
        @@@@enDesc:
          If the <P::refChild> node is not a child of the node.
      @@@c:reports:
        @@@@@: t|insert-before-itself
        @@@@enDesc:
          If the <P::newChild> node is same as the <P::refChild> node.
          Then, the result is implementation dependent.
        @@@@For: ManakaiDOM|ManakaiDOM
      @@@PerlDef:
        my $self_od = $self-><AG::Node.ownerDocument>; 
        my $child_od = $newChild-><AG::Node.ownerDocument>;
        my $child_nt = $newChild-><AG::Node.nodeType>;
        __CODE{tc|insertBeforeImpl1::
          $self => $self, $self_od => $self_od,
          $newChild => $newChild, $refChild => $refChild,
          $child_od => $child_od, $child_nt => $child_nt,
          $r => $r,
          $allowedNodeTypes => {{
            <C::Node.TEXT_NODE> => true,
            <C::Node.ENTITY_REFERENCE_NODE> => true,
          }},
        }__;

  @CMethod:
    @@Name: replaceChild
    @@enDesc:
      Replaces a child node with another node.

      Replacing a node with itself is implementation dependent <SRC::DOM3>.
    @@Param:
      @@@Name: newChild
      @@@Type: Node
      @@@enDesc:
        The new node to put in the child list.

        If the <P::newChild> node is already in the tree,
        it is first removed.
      @@@InCase:
        @@@@Type: DocumentFragment
        @@@@enDesc:
          The <P::oldChild> node is replaced by all of the 
          <IF::DocumentFragment> children, which are inserted
          in the same order <SRC::DOM1 SE, DOM2, DOM3>.
    @@Param:
      @@@Name: oldChild
      @@@Type: Node
      @@@enDesc:
        The node being replaced in the list.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node replaced.
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_BAD_TYPE
        @@@@enDesc:
          If the node is of a type that does not allow children of
          the type of the <P::newChild> node.
      @@@dx:raises:
        @@@@@: c|DIFFERENT_DOCUMENT_ERR
        @@@@enDesc:
          If the <P::newChild> node was created from a different
          document than the one that created the node.
        @@@@enImplNote:
          The DOM specification ignores the fact that <IF::Document>s
          and <IF::tx|DocumentType>s are created from 
          <IF::c|DOMImplementation> :-)
      @@@dx:raises: 
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the node is read-only.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_SRC_PARENT
        @@@@enDesc:
          If the previous parent of the <P::newChild> node is read-only
          <SRC::DOM1 SE, DOM2, DOM3>.
      @@@dx:raises:
        @@@@@: c|NOT_CHILD_ERR
        @@@@enDesc:
          If the <P::oldChild> node is not a child of the node.
      @@@c:reports:
        @@@@@: t|replaced-by-itself
        @@@@enDesc:
          If the <P::newChild> node is same as the <P::oldChild> node.
          Then, the result is implementation dependent.
        @@@@For: ManakaiDOM|ManakaiDOM
      @@@PerlDef:
        my $self_od = $self-><AG::Node.ownerDocument>;
        my $child_od = $newChild-><AG::Node.ownerDocument>;
        my $child_nt = $newChild-><AG::Node.nodeType>;
        __CODE{tc|replaceChildImpl1::
          $self => $self, $self_od => $self_od,
          $newChild => $newChild, $refChild => $oldChild,
          $child_od => $child_od, $child_nt => $child_nt,
          $r => $r,
          $allowedNodeTypes => {{
            <C::Node.TEXT_NODE> => true,
            <C::Node.ENTITY_REFERENCE_NODE> => true,
          }},
        }__;

    @@Test:
      @@@QName: AttrDef.appendChild.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createAttributeDefinition> ('dt');
        my $pi = $doc-><M::Document.createTextNode> ('pi');

        my $return = $dtd-><M::Node.appendChild> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: AttrDef.appendChild.1.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createAttributeDefinition> ('dt');
        my $pi = $doc-><M::Document.createEntityReference> ('pi');

        my $return = $dtd-><M::Node.appendChild> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|EntityReference>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: AttrDef.insertBefore.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createAttributeDefinition> ('dt');
        my $pi = $doc-><M::Document.createTextNode> ('pi');

        my $return = $dtd-><M::Node.insertBefore> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: AttrDef.insertBefore.1.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createAttributeDefinition> ('dt');
        my $pi = $doc-><M::Document.createEntityReference> ('pi');

        my $return = $dtd-><M::Node.insertBefore> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|EntityReference>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);

    @@Test:
      @@@QName: AttrDef.appendChild.has.parent.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createAttributeDefinition> ('dt');

        my $piparent = $doc-><M::Document.createElementNS> (null, 'e');
        my $pi = $doc-><M::Document.createTextNode> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.appendChild> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: AttrDef.appendChild.has.parent.1.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createAttributeDefinition> ('dt');

        my $piparent = $doc-><M::Document.createElementNS> (null, 'e');
        my $pi = $doc-><M::Document.createEntityReference> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.appendChild> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|EntityReference>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: AttrDef.insertBefore.has.parent.1.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createAttributeDefinition> ('dt');

        my $piparent = $doc-><M::Document.createElementNS> (null, 'e');
        my $pi = $doc-><M::Document.createTextNode> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.insertBefore> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: AttrDef.insertBefore.has.parent.1.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createAttributeDefinition> ('dt');

        my $piparent = $doc-><M::Document.createElementNS> (null, 'e');
        my $pi = $doc-><M::Document.createEntityReference> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.insertBefore> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|EntityReference>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi);

    @@Test:
      @@@QName: AttrDef.appendChild.documentfragment.1.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createAttributeDefinition> ('dt');

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createTextNode> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.appendChild> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: AttrDef.appendChild.documentfragment.1.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createAttributeDefinition> ('dt');

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createEntityReference> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.appendChild> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|EntityReference>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: AttrDef.insertBefore.documentfragment.1.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createAttributeDefinition> ('dt');

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createTextNode> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.insertBefore> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: AttrDef.insertBefore.documentfragment.1.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createAttributeDefinition> ('dt');

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createEntityReference> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.insertBefore> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|EntityReference>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: AttrDef.replaceChild.documentfragment.1.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createAttributeDefinition> ('dt');
        my $pi0 = $doc-><M::Document.createTextNode> ('pi0');
        $dtd-><M::Node.appendChild> ($pi0);

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createTextNode> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.replaceChild> ($piparent, $pi0);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi0);
    @@Test:
      @@@QName: AttrDef.replaceChild.documentfragment.1.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createAttributeDefinition> ('dt');
        my $pi0 = $doc-><M::Document.createTextNode> ('pi0');
        $dtd-><M::Node.appendChild> ($pi0);

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createEntityReference> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.replaceChild> ($piparent, $pi0);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|EntityReference>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi0);

    @@Test:
      @@@QName: AttrDef.appendChild.documentfragment.2.1.test
      @@@enDesc:
        Empty document fragment.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createAttributeDefinition> ('dt');

        my $piparent = $doc-><M::Document.createDocumentFragment>;

        my $return = $dtd-><M::Node.appendChild> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 0);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: AttrDef.insertBefore.documentfragment.2.test
      @@@enDesc:
        Empty document fragment.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createAttributeDefinition> ('dt');

        my $piparent = $doc-><M::Document.createDocumentFragment>;

        my $return = $dtd-><M::Node.insertBefore> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 0);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: AttrDef.replaceChild.documentfragment.2.test
      @@@enDesc:
        Empty document fragment.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createAttributeDefinition> ('dt');
        my $pi0 = $doc-><M::Document.createTextNode> ('pi0');
        $dtd-><M::Node.appendChild> ($pi0);

        my $piparent = $doc-><M::Document.createDocumentFragment>;

        my $return = $dtd-><M::Node.replaceChild> ($piparent, $pi0);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 0);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi0);

    @@Test:
      @@@QName: AttrDef.appendChild.documentfragment.3.test
      @@@enDesc:
        Three PIs in document fragment.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createAttributeDefinition> ('dt');

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createTextNode> ('pi');
        my $pi2 = $doc-><M::Document.createEntityReference> ('pi2');
        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $piparent-><M::Node.appendChild> ($pi);
        $piparent-><M::Node.appendChild> ($pi2);
        $piparent-><M::Node.appendChild> ($pi3);

        my $return = $dtd-><M::Node.appendChild> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 3);

        my $item = $child-><M::tc|NodeList.item> (0);
        my $item2 = $child-><M::tc|NodeList.item> (1);
        my $item3 = $child-><M::tc|NodeList.item> (2);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);
        $test->id ('child.item.node2');
        $test->assert_isa ($item2, <IFName::Node>);
        $test->id ('child.item.node3');
        $test->assert_isa ($item3, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);
        $test->id ('child.item.pi2');
        $test->assert_isa ($item2, <IFName::tx|EntityReference>);
        $test->id ('child.item.pi3');
        $test->assert_isa ($item3, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);
        $test->id ('child.item.equals2');
        $test->assert_equals ($item2, $pi2);
        $test->id ('child.item.equals3');
        $test->assert_equals ($item3, $pi3);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi3);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);
        $test->id ('parent2');
        my $parent2 = $item2-><AG::Node.parentNode>;
        $test->assert_equals ($parent2, $dtd);
        $test->id ('parent3');
        my $parent3 = $item3-><AG::Node.parentNode>;
        $test->assert_equals ($parent3, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: AttrDef.insertBefore.documentfragment.3.test
      @@@enDesc:
        Three PIs in document fragment.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createAttributeDefinition> ('dt');

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createTextNode> ('pi');
        my $pi2 = $doc-><M::Document.createEntityReference> ('pi2');
        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $piparent-><M::Node.appendChild> ($pi);
        $piparent-><M::Node.appendChild> ($pi2);
        $piparent-><M::Node.appendChild> ($pi3);

        my $return = $dtd-><M::Node.insertBefore> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 3);

        my $item = $child-><M::tc|NodeList.item> (0);
        my $item2 = $child-><M::tc|NodeList.item> (1);
        my $item3 = $child-><M::tc|NodeList.item> (2);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);
        $test->id ('child.item.node2');
        $test->assert_isa ($item2, <IFName::Node>);
        $test->id ('child.item.node3');
        $test->assert_isa ($item3, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);
        $test->id ('child.item.pi2');
        $test->assert_isa ($item2, <IFName::tx|EntityReference>);
        $test->id ('child.item.pi3');
        $test->assert_isa ($item3, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);
        $test->id ('child.item.equals2');
        $test->assert_equals ($item2, $pi2);
        $test->id ('child.item.equals3');
        $test->assert_equals ($item3, $pi3);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi3);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);
        $test->id ('parent2');
        my $parent2 = $item2-><AG::Node.parentNode>;
        $test->assert_equals ($parent2, $dtd);
        $test->id ('parent3');
        my $parent3 = $item3-><AG::Node.parentNode>;
        $test->assert_equals ($parent3, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: AttrDef.replaceChild.documentfragment.3.test
      @@@enDesc:
        Three PIs in document fragment.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createAttributeDefinition> ('dt');
        my $pi0 = $doc-><M::Document.createTextNode> ('pi0');
        $dtd-><M::Node.appendChild> ($pi0);

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createTextNode> ('pi');
        my $pi2 = $doc-><M::Document.createEntityReference> ('pi2');
        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $piparent-><M::Node.appendChild> ($pi);
        $piparent-><M::Node.appendChild> ($pi2);
        $piparent-><M::Node.appendChild> ($pi3);

        my $return = $dtd-><M::Node.replaceChild> ($piparent, $pi0);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 3);

        my $item = $child-><M::tc|NodeList.item> (0);
        my $item2 = $child-><M::tc|NodeList.item> (1);
        my $item3 = $child-><M::tc|NodeList.item> (2);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);
        $test->id ('child.item.node2');
        $test->assert_isa ($item2, <IFName::Node>);
        $test->id ('child.item.node3');
        $test->assert_isa ($item3, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);
        $test->id ('child.item.pi2');
        $test->assert_isa ($item2, <IFName::tx|EntityReference>);
        $test->id ('child.item.pi3');
        $test->assert_isa ($item3, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);
        $test->id ('child.item.equals2');
        $test->assert_equals ($item2, $pi2);
        $test->id ('child.item.equals3');
        $test->assert_equals ($item3, $pi3);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi3);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);
        $test->id ('parent2');
        my $parent2 = $item2-><AG::Node.parentNode>;
        $test->assert_equals ($parent2, $dtd);
        $test->id ('parent3');
        my $parent3 = $item3-><AG::Node.parentNode>;
        $test->assert_equals ($parent3, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi0);

    @@Test:
      @@@QName: AttrDef.appendChild.badtype.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $comment = $docx-><M::DocumentXDoctype.createAttributeDefinition>
                               ('data');
        my $pi0 = $doc-><M::Document.createTextNode> ('pi0');
        $comment-><M::Node.appendChild> ($pi0);

        for my $node (
          $docx-><M::d|DocumentXDoctype.createDocumentTypeDefinition> ('d'),
          $doc-><M::Document.createProcessingInstruction> ('ent'),
          $doc-><M::Document.createElement> ('e'),
          $doc-><M::Document.createAttribute> ('a'),
          $doc-><M::Document.createComment> ('c'),
          $doc-><M::Document.createCDATASection> ('cs'),
          $docx-><M::d|DocumentXDoctype.createGeneralEntity> ('ge'),
          $docx-><M::d|DocumentXDoctype.createNotation> ('not'),
          $docx-><M::d|DocumentXDoctype.createElementTypeDefinition> ('et'),
          $docx-><M::d|DocumentXDoctype.createAttributeDefinition> ('at'),
          #test:nodeTypes
        ) {
          $test->id ('appendChild.'.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.appendChild> ($node);
          }, exception_subtype => <Q::MDOMX|HIERARCHY_BAD_TYPE>);

          $test->id ('insertBefore.'.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.insertBefore> ($node);
          }, exception_subtype => <Q::MDOMX|HIERARCHY_BAD_TYPE>);

          $test->id ('replaceChild.'.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.replaceChild> ($node, $pi0);
          }, exception_subtype => <Q::MDOMX|HIERARCHY_BAD_TYPE>);
        }

    @@Test:
      @@@QName: AttrDef.appendChild.wrongdoc.test
      @@@PerlDef:
        my $doc0;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc0}__;
        my $docx0 = $doc0-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $comment = $docx0-><M::DocumentXDoctype.createAttributeDefinition>
                                ('data');

        for my $node (
          $doc-><M::Document.createTextNode> ('pi'),
          $doc-><M::Document.createEntityReference> ('e'),
        ) {
          $test->id ('type='.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.appendChild> ($node);
          }, exception_subtype => <Q::c|DIFFERENT_DOCUMENT_ERR>);
        }
    @@Test:
      @@@QName: AttrDef.insertBefore.wrongdoc.test
      @@@PerlDef:
        my $doc0;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc0}__;
        my $docx0 = $doc0-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $comment = $docx0-><M::DocumentXDoctype.createAttributeDefinition>
                                ('data');
        my $pi0 = $doc0-><M::Document.createTextNode> ('pi0');
        $comment-><M::Node.appendChild> ($pi0);

        for my $node (
          $doc-><M::Document.createTextNode> ('pi'),
          $doc-><M::Document.createEntityReference> ('ent'),
        ) {
          $test->id ('appendChild.'.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.appendChild> ($node);
          }, exception_subtype => <Q::c|DIFFERENT_DOCUMENT_ERR>);

          $test->id ('insertBefore.'.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.insertBefore> ($node);
          }, exception_subtype => <Q::c|DIFFERENT_DOCUMENT_ERR>);

          $test->id ('replaceChild.'.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.replaceChild> ($node, $pi0);
          }, exception_subtype => <Q::c|DIFFERENT_DOCUMENT_ERR>);
        }

    @@Test:
      @@@QName: AttrDef.appendChild.readonly.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createAttributeDefinition> ('d');
        my $pi0 = $doc-><M::Document.createTextNode> ('pi0');
        $dtd-><M::Node.appendChild> ($pi0);
        $dtd-><M::Node.manakaiSetReadOnly> (true, true);

        $test->id ('pi');
        my $node = $doc-><M::Document.createTextNode> ('pi');

        $test->assert_exception (code => sub {
          $dtd-><M::Node.appendChild> ($node);
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);

        $test->id ('pi.insertBefore');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.insertBefore> ($node);
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);

        $test->id ('pi.replaceChild');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.replaceChild> ($node, $pi0);
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);

        $test->id ('fragment');
        my $node2 = $doc-><M::Document.createDocumentFragment>;
        $node2-><M::Node.appendChild> ($node);

        $test->assert_exception (code => sub {
          $dtd-><M::Node.appendChild> ($node2);
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);

        $test->id ('fragment.insertBefore');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.insertBefore> ($node2);
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);

        $test->id ('fragment.replaceChild');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.replaceChild> ($node2, $pi0);
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);

    @@Test:
      @@@QName: AttrDef.appendChild.readonly.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createAttributeDefinition> ('d');
        my $pi0 = $doc-><M::Document.createTextNode> ('pi0');
        $dtd-><M::Node.appendChild> ($pi0);

        $test->id ('pi');
        my $el = $doc-><M::Document.createElementNS> (null, 'e');
        my $node = $doc-><M::Document.createTextNode> ('pi');
        $el-><M::Node.appendChild> ($node);
        $el-><M::Node.manakaiSetReadOnly> (true, true);

        $test->assert_exception (code => sub {
          $dtd-><M::Node.appendChild> ($node);
        }, exception_subtype => <Q::MDOMX|NOMOD_SRC_PARENT>);

        $test->id ('pi.insertBefore');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.insertBefore> ($node);
        }, exception_subtype => <Q::MDOMX|NOMOD_SRC_PARENT>);

        $test->id ('pi.replaceChild');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.replaceChild> ($node, $pi0);
        }, exception_subtype => <Q::MDOMX|NOMOD_SRC_PARENT>);

        $test->id ('fragment');
        my $node2 = $doc-><M::Document.createDocumentFragment>;
        my $node3 = $doc-><M::Document.createTextNode> ('pi');
        $node2-><M::Node.appendChild> ($node3);
        $node2-><M::Node.manakaiSetReadOnly> (true, true);

        $test->assert_exception (code => sub {
          $dtd-><M::Node.appendChild> ($node2);
        }, exception_subtype => <Q::MDOMX|NOMOD_SRC_PARENT>);

        $test->id ('fragment.insertBefore');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.insertBefore> ($node2);
        }, exception_subtype => <Q::MDOMX|NOMOD_SRC_PARENT>);

        $test->id ('fragment.replaceChild');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.replaceChild> ($node2, $pi0);
        }, exception_subtype => <Q::MDOMX|NOMOD_SRC_PARENT>);

    @@Test:
      @@@QName: AttrDef.insertBefore.refChild.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createAttributeDefinition> ('d');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.insertBefore> ($pi2, $pi1);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi2);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi1);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: AttrDef.insertBefore.refChild.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createAttributeDefinition> ('d');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $dtd-><M::Node.insertBefore> ($pi3, $pi2);

        # pi1, pi3, pi2

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi1);

        $test->id ('firstChild.nextSibling');
        $test->assert_equals ($dtd-><AG::Node.firstChild>
                                  -><AG::Node.nextSibling>, $pi3);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi2);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 3);

    @@Test:
      @@@QName: AttrDef.insertBefore.refChild.3.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createAttributeDefinition> ('d');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $dtd-><M::Node.appendChild> ($pi3);

        # pi1, pi2, pi3

        $dtd-><M::Node.insertBefore> ($pi2, $pi1);
 
        # pi2, pi1, pi3

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi2);

        $test->id ('firstChild.nextSibling');
        $test->assert_equals ($dtd-><AG::Node.firstChild>
                                  -><AG::Node.nextSibling>, $pi1);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi3);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 3);

    @@Test:
      @@@QName: AttrDef.insertBefore.refChild.4.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createAttributeDefinition> ('d');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $dtd-><M::Node.appendChild> ($pi3);

        # pi1, pi2, pi3

        $dtd-><M::Node.insertBefore> ($pi3, $pi1);
 
        # pi3, pi1, pi2

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi3);

        $test->id ('firstChild.nextSibling');
        $test->assert_equals ($dtd-><AG::Node.firstChild>
                                  -><AG::Node.nextSibling>, $pi1);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi2);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 3);

    @@Test:
      @@@QName: AttrDef.insertBefore.refChild.not_found_err.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createAttributeDefinition> ('d');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');

        my $pi4 = $doc-><M::Document.createTextNode> ('pi4');

        # pi1, pi2

        $test->assert_exception (code => sub {
          $dtd-><M::Node.insertBefore> ($pi4, $pi3);
        }, exception_subtype => <Q::c|NOT_CHILD_ERR>);

    @@Test:
      @@@QName: AttrDef.insertBefore.refChild=newChild.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createAttributeDefinition> ('d');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        # pi1, pi2

        my $eh_called = false;
        my $cfg = $doc-><AG::Document.domConfig>;
        $cfg-><M::c|DOMConfiguration.setParameter> ('error-handler' => sub {
          my (undef, $err) = @_;
          $eh_called = true;
          $test->assert_equals ($err-><AG::c|DOMError.severity>,
                                <C::c|DOMError.SEVERITY_WARNING>);
          $test->assert_equals ($err-><AG::c|DOMError.type>,
                                <Q::t|insert-before-itself>);
          $test->assert_equals ($err-><AG::c|DOMError.relatedData>, $pi2);
          $test->assert_null ($err-><AG::c|DOMError.relatedException>);
          $test->assert_isa ($err-><AG::c|DOMError.location>,
                             <IFName::c|DOMLocator>);
          $test->assert_not_null ($err-><AG::c|DOMError.message>);
        });

        $test->assert_false ($eh_called);
        $dtd-><M::Node.insertBefore> ($pi2, $pi2);
        $test->assert_true ($eh_called);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi1);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi2);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: AttrDef.replaceChild.oldChild=newChild.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createAttributeDefinition> ('d');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        # pi1, pi2

        my $eh_called = false;
        my $cfg = $doc-><AG::Document.domConfig>;
        $cfg-><M::c|DOMConfiguration.setParameter> ('error-handler' => sub {
          my (undef, $err) = @_;
          $eh_called = true;
          $test->assert_equals ($err-><AG::c|DOMError.severity>,
                                <C::c|DOMError.SEVERITY_WARNING>);
          $test->assert_equals ($err-><AG::c|DOMError.type>,
                                <Q::t|replace-by-itself>);
          $test->assert_equals ($err-><AG::c|DOMError.relatedData>, $pi2);
          $test->assert_null ($err-><AG::c|DOMError.relatedException>);
          $test->assert_isa ($err-><AG::c|DOMError.location>,
                             <IFName::c|DOMLocator>);
          $test->assert_not_null ($err-><AG::c|DOMError.message>);
        });

        $test->assert_false ($eh_called);
        $dtd-><M::Node.replaceChild> ($pi2, $pi2);
        $test->assert_true ($eh_called);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi1);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi2);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: AttrDef.appendChild.sameparent.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createAttributeDefinition> ('d');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        # pi1, pi2

        my $return = $dtd-><M::Node.appendChild> ($pi1);

        # pi2, pi1

        $test->id ('return');
        $test->assert_equals ($return, $pi1);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi2);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi1);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: AttrDef.insertBefore.sameparent.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createAttributeDefinition> ('d');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        # pi1, pi2

        my $return = $dtd-><M::Node.insertBefore> ($pi1);

        # pi2, pi1

        $test->id ('return');
        $test->assert_equals ($return, $pi1);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi2);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi1);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: AttrDef.appendChild.sameparent.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createAttributeDefinition> ('d');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        # pi1, pi2

        my $return = $dtd-><M::Node.appendChild> ($pi2);

        # pi1, pi2

        $test->id ('return');
        $test->assert_equals ($return, $pi2);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi1);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi2);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: AttrDef.insertBefore.sameparent.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createAttributeDefinition> ('d');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        # pi1, pi2

        my $return = $dtd-><M::Node.insertBefore> ($pi2);

        # pi1, pi2

        $test->id ('return');
        $test->assert_equals ($return, $pi2);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi1);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi2);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: AttrDef.replaceChild.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createAttributeDefinition> ('d');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $dtd-><M::Node.appendChild> ($pi3);

        # pi1, pi2, pi3

        my $pi9 = $doc-><M::Document.createTextNode> ('pi9');
        my $return = $dtd-><M::Node.replaceChild> ($pi9, $pi1);

        # pi9, pi2, pi3

        $test->id ('return.node');
        $test->assert_isa ($return, <IFName::Node>);
        $test->id ('return.pi');
        $test->assert_isa ($return, <IFName::Text>);
        $test->id ('return');
        $test->assert_equals ($return, $pi1);

        my $c = $dtd-><AG::Node.childNodes>;

        $test->id ('length');
        $test->assert_num_equals (actual_value => 0+@$c, expected_value => 3);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi9);

        $test->id ('firstChild.nextSibling');
        $test->assert_equals ($dtd-><AG::Node.firstChild>
                                  -><AG::Node.nextSibling>, $pi2);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi3);
 
        $test->id ('parent');
        $test->assert_equals ($pi9-><AG::Node.parentNode>, $dtd);

        $test->id ('return.parent');
        $test->assert_null ($pi1-><AG::Node.parentNode>);

    @@Test:
      @@@QName: AttrDef.replaceChild.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createAttributeDefinition> ('d');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $dtd-><M::Node.appendChild> ($pi3);

        # pi1, pi2, pi3

        my $pi9 = $doc-><M::Document.createTextNode> ('pi9');
        my $return = $dtd-><M::Node.replaceChild> ($pi9, $pi2);

        # pi1, pi9, pi3

        $test->id ('return.node');
        $test->assert_isa ($return, <IFName::Node>);
        $test->id ('return.pi');
        $test->assert_isa ($return, <IFName::Text>);
        $test->id ('return');
        $test->assert_equals ($return, $pi2);

        my $c = $dtd-><AG::Node.childNodes>;

        $test->id ('length');
        $test->assert_num_equals (actual_value => 0+@$c, expected_value => 3);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi1);

        $test->id ('firstChild.nextSibling');
        $test->assert_equals ($dtd-><AG::Node.firstChild>
                                  -><AG::Node.nextSibling>, $pi9);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi3);
 
        $test->id ('parent');
        $test->assert_equals ($pi9-><AG::Node.parentNode>, $dtd);

        $test->id ('return.parent');
        $test->assert_null ($pi2-><AG::Node.parentNode>);

    @@Test:
      @@@QName: AttrDef.replaceChild.3.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createAttributeDefinition> ('d');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $dtd-><M::Node.appendChild> ($pi3);

        # pi1, pi2, pi3

        my $pi9 = $doc-><M::Document.createTextNode> ('pi9');
        my $return = $dtd-><M::Node.replaceChild> ($pi9, $pi3);

        # pi1, pi2, pi9

        $test->id ('return.node');
        $test->assert_isa ($return, <IFName::Node>);
        $test->id ('return.pi');
        $test->assert_isa ($return, <IFName::Text>);
        $test->id ('return');
        $test->assert_equals ($return, $pi3);

        my $c = $dtd-><AG::Node.childNodes>;

        $test->id ('length');
        $test->assert_num_equals (actual_value => 0+@$c, expected_value => 3);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi1);

        $test->id ('firstChild.nextSibling');
        $test->assert_equals ($dtd-><AG::Node.firstChild>
                                  -><AG::Node.nextSibling>, $pi2);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi9);
 
        $test->id ('parent');
        $test->assert_equals ($pi9-><AG::Node.parentNode>, $dtd);

        $test->id ('return.parent');
        $test->assert_null ($pi3-><AG::Node.parentNode>);

    @@Test:
      @@@QName: AttrDef.replaceChild.sameparent.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createAttributeDefinition> ('d');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $dtd-><M::Node.appendChild> ($pi3);

        # pi1, pi2, pi3

        my $return = $dtd-><M::Node.replaceChild> ($pi3, $pi1);

        # pi3, pi2

        $test->id ('return.node');
        $test->assert_isa ($return, <IFName::Node>);
        $test->id ('return.pi');
        $test->assert_isa ($return, <IFName::Text>);
        $test->id ('return');
        $test->assert_equals ($return, $pi1);

        my $c = $dtd-><AG::Node.childNodes>;

        $test->id ('length');
        $test->assert_num_equals (actual_value => 0+@$c, expected_value => 2);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi3);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi2);
 
        $test->id ('parent');
        $test->assert_equals ($pi3-><AG::Node.parentNode>, $dtd);

        $test->id ('return.parent');
        $test->assert_null ($pi1-><AG::Node.parentNode>);

    @@Test:
      @@@QName: AttrDef.replaceChild.sameparent.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createAttributeDefinition> ('d');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $dtd-><M::Node.appendChild> ($pi3);

        # pi1, pi2, pi3

        my $return = $dtd-><M::Node.replaceChild> ($pi1, $pi3);

        # pi2, pi1

        $test->id ('return.node');
        $test->assert_isa ($return, <IFName::Node>);
        $test->id ('return.pi');
        $test->assert_isa ($return, <IFName::Text>);
        $test->id ('return');
        $test->assert_equals ($return, $pi3);

        my $c = $dtd-><AG::Node.childNodes>;

        $test->id ('length');
        $test->assert_num_equals (actual_value => 0+@$c, expected_value => 2);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi2);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi1);
 
        $test->id ('parent');
        $test->assert_equals ($pi1-><AG::Node.parentNode>, $dtd);

        $test->id ('return.parent');
        $test->assert_null ($pi3-><AG::Node.parentNode>);

  @CMethod:
    @@Name: manakaiAppendText
    @@Param:
      @@@Name: string
      @@@Type: DOMString
      @@@enDesc:
        The string to append.
      @@@InCase:
        @@@@Type: DISPerl|SCALAR||ManakaiDOM|all
        @@@@enDesc:
          A copy of the string value referenced from the value
          is appended.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node itself.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the node to insert the string or a <IF::Text> node
          is read-only.
      @@@disDef:
        @@@@DISPerl:cloneCode: te|ManakaiDOMAttr.manakaiAppendText

    @@Test:
      @@@QName: ATDef..=.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $node = $docx-><M::DocumentXDoctype.createAttributeDefinition>
                            ('node');

        $node-><M::Node.manakaiAppendText> ('string');
        $test->id ('1.class');
        $test->assert_isa ($node, <IFName::AttributeDefinition>);
        $test->id ('1.value');
        $test->assert_equals ($node-><AG::Node.textContent>, 'string');
        $test->id ('1.length');
        $test->assert_num_equals
                 (expected_value => 1,
                  actual_value => 0+@{$node-><AG::Node.childNodes>});

        $test->id (2);
        $node-><M::Node.manakaiAppendText> ('STRING');
        $test->assert_equals ($node-><AG::Node.textContent>, 'stringSTRING');
        $test->assert_num_equals
                 (expected_value => 1,
                  actual_value => 0+@{$node-><AG::Node.childNodes>});

        $node-><M::Node.appendChild>
                 ($doc-><M::Document.createEntityReference> ('er'));

        $test->id (3);
        $node-><M::Node.manakaiAppendText> ('text');
        $test->assert_equals ($node-><AG::Node.textContent>, 'stringSTRINGtext');
        $test->assert_num_equals
                 (expected_value => 3,
                  actual_value => 0+@{$node-><AG::Node.childNodes>});

  @CMethod:
    @@Name: getFeature
    @@enDesc:
      Returns a specialized object that implements the specialized APIs.
    @@Param:
      @@@Name: feature
      @@@Type: DOMString
      @@@dis:actualType: f|FeatureNameString
    @@Param:
      @@@Name: version
      @@@Type: DOMString
      @@@dis:actualType: f|FeatureVersionString
    @@Return:
      @@@Type: DOMMain|DOMObject
      @@@nullCase:
      @@@PerlDef:
        $feature =~ s/^\+//;
        __CODE{f|getFeatureImpl::
          $self => $self,
          $feature => $feature, $version => $version, $r => $r,
          $base_class => {<ClassName::ManakaiDOMAttributeDefinition>},
        }__;
        unless (defined $r) {
          __DEEP{
            $r = $self->SUPER::get_feature ($feature, $version);
          }__;
        }

    @@Test:
      @@@QName: ATDef.getFeature.test
      @@@PerlDef:
        my $node;
        __CODE{d|createATDefForTest:: $atdef => $node}__;

        for (
          [Core => '1.0', <IFName::AttributeDefinition||ManakaiDOM|ManakaiDOMLatest>],
          [Core => '2.0', <IFName::AttributeDefinition||ManakaiDOM|ManakaiDOMLatest>],
          [Core => '3.0', <IFName::AttributeDefinition||ManakaiDOM|ManakaiDOMLatest>],
          [XML => '1.0', <IFName::AttributeDefinition||ManakaiDOM|ManakaiDOMLatest>],
          [XML => '2.0', <IFName::AttributeDefinition||ManakaiDOM|ManakaiDOMLatest>],
          [XML => '3.0', <IFName::AttributeDefinition||ManakaiDOM|ManakaiDOMLatest>],
          [<Q::fe|XDoctype> => '3.0', <IFName::AttributeDefinition||ManakaiDOM|ManakaiDOMLatest>],
        ) {
          $test->id ($_->[0].'.'.$_->[1]);
          my $sp = $node-><M::Node.getFeature> ($_->[0], $_->[1]);
          $test->assert_isa ($sp, $_->[2]);
        }
  
  @Attr:
    @@Name: ownerElementTypeDefinition
    @@enDesc:
      The element type definition for which
      the attribute is defined.
    @@Type: ElementTypeDefinition
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          If the attribute definition is not associated
          with any element type.
      @@@disDef:
        @@@@DISPerl:cloneCode: 
          tx|ManakaiDOMNotation.ownerDocumentTypeDefinition.get

    @@Test:
      @@@QName: 
        ManakaiDOMAttributeDefinition.ownerElementTypeDefinition.get.test
      @@@PerlDef:
        my $at;
        __CODE{d|createATDefForTest:: $atdef => $at}__;
        my $doc = $at-><AG::Node.ownerDocument>
                     -><M::Node.getFeature> (<Q::fe|XDoctype>);

        $test->assert_null
                 ($at-><AG::AttributeDefinition.ownerElementTypeDefinition>);

        my $et = $doc-><M::DocumentXDoctype.createElementTypeDefinition>
                         ('et1');
        $et-><M::ElementTypeDefinition.setAttributeDefinitionNode> ($at);
        
        $test->assert_equals
                 ($at-><AG::AttributeDefinition.ownerElementTypeDefinition>,
                  $et);

        $test->assert_isa
                 ($at-><AG::AttributeDefinition.ownerElementTypeDefinition>,
                  <IFName::ElementTypeDefinition>);
  
  @ShortConstGroup:
    @@IFQName: DeclaredValueType
    @@enDesc:
      An integer that indicates the type of
      attribute value.
    
    @@Const:
      @@@Name: NO_TYPE_ATTR
      @@@intValue: 0
      @@@enDesc:
        The attribute value type is <QUOTE::no value> (see XML Infoset).

        If no attribute type information is provided, or
        if the source of that information does not distingulish
        <QUOTE::no value> and <QUOTE::unknown>, then the
        <C::AttributeDefinition.NO_TYPE_ATTR> value <kwd:MUST> be used.
    @@Const:
      @@@Name: CDATA_ATTR
      @@@intValue: 1
      @@@enDesc:
        The attribute value type is <XML::CDATA>.

        If the source of the attribute type information does not
        distingulish <QUOTE::no value> and / or <QUOTE::unknown>
        and <XML::CDATA>, then the <C::AttributeDefinition.CDATA_ATTR>
        value <kwd:MUST> be used.
    @@Const:
      @@@Name: ID_ATTR
      @@@intValue: 2
      @@@enDesc:
        The attribute value type is <XML::ID>.
    @@Const:
      @@@Name: IDREF_ATTR
      @@@intValue: 3
      @@@enDesc:
        The attribute value type is <XML::IDREF>.
    @@Const:
      @@@Name: IDREFS_ATTR
      @@@intValue: 4
      @@@enDesc:
        The attribute value type is <XML::IDREFS>.
    @@Const:
      @@@Name: ENTITY_ATTR
      @@@intValue: 5
      @@@enDesc:
        The attribute value type is <XML::ENTITY>;
    @@Const:
      @@@Name: ENTITIES_ATTR
      @@@intValue: 6
      @@@enDesc:
        The attribute value type is <XML::ENTITIES>.
    @@Const:
      @@@Name: NMTOKEN_ATTR
      @@@intValue: 7
      @@@enDesc:
        The attribute value type is <XML::NMTOKEN>.
    @@Const:
      @@@Name: NMTOKENS_ATTR
      @@@intValue: 8
      @@@enDesc:
        The attribute value type is <XML::NMTOKENS>.
    @@Const:
      @@@Name: NOTATION_ATTR
      @@@intValue: 9
      @@@enDesc:
        The attribute value is <XML::NOTATION> enumerated
        type.
    @@Const:
      @@@Name: ENUMERATION_ATTR
      @@@intValue: 10
      @@@enDesc:
        The attribute value is enumuration type.
    @@Const:
      @@@Name: UNKNOWN_ATTR
      @@@intValue: 11
      @@@enDesc:
        The attribute value is unknown, because no declaration
        for the attribute has been read but not <InfoProp::all declareations
        processed>.
  
  @Attr:
    @@Name: declaredType
    @@enDesc:
      The type of attribute value.
    @@Type: idl|unsignedShort||ManakaiDOM|all
    @@dis:actualType: DeclaredValueType
    @@Get:
      @@@PerlDef:
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $r,
          $prop => {<H::d|declaredType>},
          $ref => $self,
        }__;
    @@Set:
      @@@NodeReadOnlyError:
      @@@PerlDef:
        __CODE{tc|NodeReadOnlyError:: $node => $self}__;
        __CODE{mg|setNodeStemPropValue||ManakaiDOM|all::
          $given => $given,
          $prop => {<H::d|declaredType>},
          $ref => $self,
        }__;

    @@Test:
      @@@QName: 
        ManakaiDOMAttributeDefinition.declaredType.test
      @@@PerlDef:
        my $at;
        __CODE{d|createATDefForTest:: $atdef => $at}__;

        $test->assert_num_equals
                 (actual_value => $at-><AG::AttributeDefinition.defaultType>,
                  expected_value => <C::AttributeDefinition.NO_TYPE_ATTR>);

        $at-><AS::AttributeDefinition.defaultType>
               (<C::AttributeDefinition.ID_ATTR>);
        $test->assert_num_equals
                 (actual_value => $at-><AG::AttributeDefinition.defaultType>,
                  expected_value => <C::AttributeDefinition.ID_ATTR>);

  @ShortConstGroup:
    @@IFQName: DefaultValueType
    @@enDesc:
      An integer indicating the type of default value.
    
    @@Const:
      @@@Name: UNKNOWN_DEFAULT
      @@@intValue: 0
      @@@enDesc:
        The default value is unknown.
    @@Const:
      @@@Name: FIXED_DEFAULT
      @@@intValue: 1
      @@@enDesc:
        The default value is <XML::#FIXED>.
    @@Const:
      @@@Name: REQUIRED_DEFAULT
      @@@intValue: 2
      @@@enDesc:
        An attribute specification is required
        for the attribute.
    @@Const:
      @@@Name: IMPLIED_DEFAULT
      @@@intValue: 3
      @@@enDesc:
        The default value is <XML::#IMPLIED>.

        If the source of the attribute default value type does
        not distingulish the <XML::#IMPLIED> default and
        unknown default, then the <C::AttributeDefinition.IMPLIED_DEFAULT>
        value <kwd:MUST> be used.
    @@Const:
      @@@Name: EXPLICIT_DEFAULT
      @@@intValue: 4
      @@@enDesc:
        An explicit but not fixed default value
        is provided.
  
  @Attr:
    @@Name: defaultType
    @@enDesc:
      The type of attribute default value.
    @@Type: idl|unsignedShort||ManakaiDOM|all
    @@dis:actualType: DefaultValueType
    @@Get:
      @@@PerlDef:
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $r,
          $prop => {<H::d|defaultType>},
          $ref => $self,
        }__;
    @@Set:
      @@@NodeReadOnlyError:
      @@@PerlDef:
        __CODE{tc|NodeReadOnlyError:: $node => $self}__;
        __CODE{mg|setNodeStemPropValue||ManakaiDOM|all::
          $given => $given,
          $prop => {<H::d|defaultType>},
          $ref => $self,
        }__;

    @@Test:
      @@@QName: 
        ManakaiDOMAttributeDefinition.defaultType.test
      @@@PerlDef:
        my $at;
        __CODE{d|createATDefForTest:: $atdef => $at}__;

        $test->assert_num_equals
                 (actual_value => $at-><AG::AttributeDefinition.defaultType>,
                  expected_value => <C::AttributeDefinition.UNKNOWN_DEFAULT>);

        $at-><AS::AttributeDefinition.defaultType>
               (<C::AttributeDefinition.EXPLICIT_DEFAULT>);
        $test->assert_num_equals
                 (actual_value => $at-><AG::AttributeDefinition.defaultType>,
                  expected_value => <C::AttributeDefinition.EXPLICIT_DEFAULT>);

  @Attr:
    @@Name: allowedTokens
    @@enDesc:
      The live list of the allowed tokens for the
      attribute.
      
      The list <kwd:MAY> be empty even if 
      the <A::Attribute.declaredType> is 
      <C::AttributeDefinition.NOTATION_ATTR> or
      <C::AttributeDefinition.ENUMERATION_ATTR>.
      Then, validation using this definition never
      success.
      
      The list <kwd:MAY> be non-empty even if 
      the <A::Attribute.declaredType> is different
      from <C::AttributeDefinition.NOTATION_ATTR> or
      <C::AttributeDefinition.ENUMERATION_ATTR>.  This
      attribute is ignored for the purposes of
      e,g, validation and serialization in such cases.
      
      The list <kwd:MAY> contain a string that does
      not match to the production <CODE::Name> or
      <CODE::Nmtoken>.
      
      The list <kwd:MAY> contain duplications.
      
      The result of processing using the attribute
      definition, e.g. validation or serialization,
      is implementation dependent unless otherwise specified
      if one or more errors defined above is detected.
      That is, implementations <kwd:MAY> ignore erroreous
      value, <kwd:MAY> validate a value that is actually
      invalid, <kwd:MAY> report an error by <IF::c|DOMError>,
      or <kwd:MAY> choose any other possible error
      recovery method.  However, it <kwd:MUST> recover
      from the error gracefully.  Note that the validation
      of the attribute definition itself is not a case.
      For example, dupulication of values must be
      reported as a validity constraint violation by
      validity checker for the attribute definition.
    @@Type: c|DOMStringList
    @@Get:
      @@@enDesc:
        The returned list <kwd:MUST> be read-only if and 
        only if the node is read-only.  Note that since
        the list is live, a change of the read-only flag
        of the node immediately affects to the list.
      @@@PerlDef:
        __CODE{c|createNodeDOMStringList::
          $node => $self, $r => $r,
          $key => {<H::d|allowedTokens>},
        }__;

    @@Test:
      @@@QName: 
        ManakaiDOMAttributeDefinition.allowedTokens.get.test
      @@@PerlDef:
        my $at;
        __CODE{d|createATDefForTest:: $atdef => $at}__;

        my $list = $at-><AG::AttributeDefinition.allowedTokens>;
        $test->assert_not_null ($list);
        $test->assert_isa ($list, <IFName::c|DOMStringList>);

        $test->assert_num_equals
                 (actual_value => 0 + @$list,
                  expected_value => 0);
      
        push @$list, 'NMTOKEN1';
        $test->assert_string
                 (actual_value => $list->[0],
                  expected_value => 'NMTOKEN1');
        undef $list;

        my $list2 = $at-><AG::AttributeDefinition.allowedTokens>;
        $test->assert_string
                 (actual_value => $list2->[0],
                  expected_value => 'NMTOKEN1');

  @IntMethod:
    @@Name: checkReadOnly
    @@enDesc:
      Throws an exception if the node is read-only.

        {NOTE::
          This method is provided for <IF::c|DOMStringList>.
        }
    @@Return:
      @@@NodeReadOnlyError:
      @@@PerlDef:
        __CODE{tc|NodeReadOnlyError:: $node => $self}__;
##AttributeDefinition

PropDef:
  @QName: d|allowedTokens

ElementTypeBinding:
  @Name: intValue
  @ElementType:
    dis:Value
  @ShadowContent:
    @@ContentType: DISCore|Integer

ElementTypeBinding:
  @Name: enImplNote
  @ElementType:
    dis:ImplNote
  @ShadowContent:
    @@lang:en

ElementTypeBinding:
  @Name: enDesc
  @ElementType:
    dis:Description
  @ShadowContent:
    @@lang:en

enImplNote:
  {TODO::
    
    - Define <M::Node.cloneNode>, <M::Node.adoptNode>,
      <M::Node.importNode>, <M::Node.isEqualNode>,
      <M::Node.compareDocumentPosition>,
      for the new node types.
    
  }

ResourceDef:
  @QName: DOMString
  @AliasFor: DOMMain|DOMString
  @For: ManakaiDOM|DOM

PropDef:
  @QName: d|ownerDefinition
  @enDesc:
    <A::ElementTypeDefinition.ownerDocumentTypeDefinition>,
    <A::AttributeDefinition.ownerElementTypeDefinition>,
    <A::EntityDefinition.ownerDocumentTypeDefinition>, or
    <A::NotationDefinition.ownerDocumentTypeDefinition>.

PropDef:
  @QName: d|attributeDefinitions

PropDef:
  @QName: d|declaredType

PropDef:
  @QName: d|defaultType

ResourceDef:
  @QName: Node
  @AliasFor: tc|Node
  @For: ManakaiDOM|DOM

ResourceDef:
  @QName: Document
  @AliasFor: td|Document
  @For: ManakaiDOM|DOM

ResourceDef:
  @QName: Element
  @AliasFor: te|Element
  @For: ManakaiDOM|DOM

ResourceDef:
  @QName: Attr
  @AliasFor: te|Attr
  @For: ManakaiDOM|DOM

ResourceDef:
  @QName: Text
  @AliasFor: tcd|Text
  @For: ManakaiDOM|DOM

ResourceDef:
  @QName: DocumentFragment
  @AliasFor: td|DocumentFragment
  @For: ManakaiDOM|DOM

ResourceDef:
  @QName: PI
  @AliasFor: tx|ProcessingInstruction
  @For: ManakaiDOM|DOM
