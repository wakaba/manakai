Module:
  @QName: MDOM|XDoctype
  @Namespace:
    http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#
  
  @FullName:
    @@lang:en
    @@@:
      DOM XML Document Type Definition Module
  @enDesc:
    The <DFN::DOM XML Document Type Definition Module>,
    a manakai extension module, provides a set of
    interfaces via which applications can access
    to document type definitions of XML documents,
    including both read and write accesses.
  
  @DISCore:author: DISCore|Wakaba
  @License: license|Perl+MPL
  @Date:
    $Date: 2006/03/08 11:43:07 $
  
  @DefaultFor: ManakaiDOM|ManakaiDOMLatest
  
  @Require:
    @@Module:
      @@@QName: MDOM|DOMXML
  
Namespace:
  @c:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#
  @cfg:
    http://suika.fam.cx/www/2006/dom-config/
  @d:
    http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#
  @dis:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#dis--
  @DOMMain:
    http://suika.fam.cx/~wakaba/archive/2004/dom/main#
  @dx:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#
  @ecore:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/Core/
  @f:
    http://suika.fam.cx/~wakaba/archive/2004/dom/feature#
  @fe:
    http://suika.fam.cx/www/2006/feature/
  @idl:
    http://suika.fam.cx/~wakaba/archive/2004/dis/IDL#
  @infoset:
     http://www.w3.org/2001/04/infoset#
  @lang:
     http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#
  @license:
     http://suika.fam.cx/~wakaba/archive/2004/8/18/license#
  @LSEV:
    http://www.w3.org/2002/DOMLS
  @ManakaiDOM:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#
  @ManakaiDOMLS:
    http://suika.fam.cx/~wakaba/archive/2004/mdom-ls#
  @MDOM:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#ManakaiDOM.
  @MDOMX:
    http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#
  @mn:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/ManakaiNode#
  @rdf:
    http://www.w3.org/1999/02/22-rdf-syntax-ns#
  @rdfs:
    http://www.w3.org/2000/01/rdf-schema#
  @t:
    http://suika.fam.cx/~wakaba/archive/2004/dom/tree#
  @test:
    http://suika.fam.cx/~wakaba/archive/2004/dis/Test#
  @x:
    http://suika.fam.cx/~wakaba/archive/2004/dom/xml#
  @xml:
    http://www.w3.org/XML/1998/namespace
  @xmlns:
    http://www.w3.org/2000/xmlns/

## -- Features

ElementTypeBinding:
  @Name: FeatureDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: f|Feature
    @@For: =ManakaiDOM|all

ElementTypeBinding:
  @Name: FeatureVerDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: f|Feature

ElementTypeBinding:
  @Name: featureQName
  @ElementType:
    f:name
  @ShadowContent:
    @@ContentType: DISCore|QName

FeatureDef:
  @QName: d|Feature
  @featureQName: fe|XDoctype
  @featureQName: ManakaiDOM|XDoctype
  @FeatureVerDef:
    @@QName: d|Feature30
    @@f:instanceOf: d|Feature
    @@Version: 3.0

FeatureDef:
  @QName: d|DeclFeature
  @featureQName: fe|XDoctypeDeclaration
  @FeatureVerDef:
    @@QName: d|DeclFeature30
    @@f:instanceOf: d|DeclFeature
    @@Version: 3.0
    @@enImplNote:
      {ISSUE::
        Should it require <Q::d|Feature30>?
      }

ElementTypeBinding:
  @Name: IFClsXDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      @@@@: dis|MultipleResource
      @@@ForCheck: !ManakaiDOM|ForIF !ManakaiDOM|ForClass
    @@resourceFor: ManakaiDOM|ForIF
    @@resourceFor:
      @@@@: ManakaiDOM|ForClass
      @@@ForCheck: ManakaiDOM|ManakaiDOM !=ManakaiDOM|ManakaiDOM
    @@For: ManakaiDOM|DOMLatest
    @@For: =ManakaiDOM|ManakaiDOM

    @@rdf:type:
      @@@@: DISLang|Interface
      @@@ForCheck: ManakaiDOM|ForIF

    @@rdf:type:
      @@@@: DISLang|Class
      @@@ForCheck: ManakaiDOM|ForClass

    @@Implement:
      @@@@: ||+||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames

ElementTypeBinding:
  @Name: PropDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: rdf|Property
    @@For: =ManakaiDOM|all

ElementTypeBinding:
  @Name: IFQName
  @ElementType:
    dis:QName
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForIF

ElementTypeBinding:
  @Name: ClsQName
  @ElementType:
    dis:QName
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: IFISA
  @ElementType:
    dis:ISA
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForIF

ElementTypeBinding:
  @Name: ClsISA
  @ElementType:
    dis:ISA
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: nullCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: ManakaiDOM|InCase
    @@Value:
      @@@is-null:1

ElementTypeBinding:
  @Name: InCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: ManakaiDOM|InCase

ElementTypeBinding:
  @Name: ShortConstGroup
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|ConstGroup
    @@ForCheck: ManakaiDOM|ForIF !=ManakaiDOM|ManakaiDOM
    @@Type: idl|unsignedShort||ManakaiDOM|all
    @@rdfs:subClassOf: idl|unsignedShort||ManakaiDOM|all

ElementTypeBinding:
  @Name: Const
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Const

ElementTypeBinding:
  @Name: NodeReadOnlyError
  @ElementType:
    dx:raises
  @ShadowContent:
    @@@: MDOMX|NOMOD_THIS
    @@Description:
      @@@lang:en
      @@@@:
        The node is read-only.

ResourceDef:
  @QName: NodeReadOnlyError
  @rdf:type: DISPerl|BlockCode
  @For: ManakaiDOM|ManakaiDOM
  @PerlCDef:
    if ($self->{<H::mn:node>}->{<H::c|read-only>}) {
      __EXCEPTION{MDOMX|NOMOD_THIS::
      }__;
    }

ResourceDef:
  @QName: d|getRef
  @AliasFor: mn|getNewReference||ManakaiDOM|Perl
  @For: ManakaiDOM|ManakaiDOM !=ManakaiDOM|ManakaiDOM

ElementTypeBinding:
  @Name: PerlDef
  @ElementType:
    dis:Def
  @ShadowContent:
    @@ContentType: lang|Perl
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: PerlCDef
  @ElementType:
    dis:Def
  @ShadowContent:
    @@ContentType: lang|Perl

ElementTypeBinding:
  @Name: disDef
  @ElementType:
    dis:Def
  @ShadowContent:
    @@ContentType: lang|dis
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: Method
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Method
    @@ForCheck: !=ManakaiDOM|ManakaiDOM

ElementTypeBinding:
  @Name: CMethod
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Method
    @@ForCheck: !=ManakaiDOM|ManakaiDOM ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: IntMethod
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Method
    @@ForCheck:
      ManakaiDOM:ManakaiDOM !=ManakaiDOM:ManakaiDOM ManakaiDOM|ForClass
    @@ManakaiDOM:isForInternal: 1


ElementTypeBinding:
  @Name: Param
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|MethodParameter


ElementTypeBinding:
  @Name: Return
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|MethodReturn

ElementTypeBinding:
  @Name: Attr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Attribute
    @@ForCheck: !=ManakaiDOM|ManakaiDOM

ElementTypeBinding:
  @Name: CAttr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|Attribute
    @@ForCheck: !=ManakaiDOM|ManakaiDOM ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: IntAttr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Attribute
    @@ForCheck: ManakaiDOM|ForClass
    @@ManakaiDOM:isForInternal: 1


ElementTypeBinding:
  @Name: Get
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|AttributeGet

ElementTypeBinding:
  @Name: Set
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|AttributeSet

ElementTypeBinding:
  @Name: Test
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: test|StandaloneTest
    @@ForCheck: ManakaiDOM|ForClass

IFClsXDef:
  @IFQName: DocumentXDoctype
  @ClsQName: ManakaiDOMDocumentXDoctype
  
  @ClsISA: c|ManakaiDOMDocument

  @f:implements: d|Feature30
  @f:provides:
    @@@: d|Feature30
    @@f:through: c|ManakaiDOMImplementation
  
  @enDesc:
    The <IF::DocumentXDoctype> interface provides 
    methods to create definition nodes.
    
    Objects implementing <IF::DocumentXDoctype>
    interface <kwd:MUST> also implement the
    <IF::t|Document> interface.

  @ResourceDef:
    @@ForCheck: ManakaiDOM|ForClass
    @@QName: newDocumentForTest
    @@rdf:type: DISPerl|BlockCode
    @@PerlDef:
      my $__impl = <Class::c|ManakaiDOMImplementation>->_new;
      $doc = $__impl-><M::c|DOMImplementation.createDocument>;
      bless $doc, <ClassName::ManakaiDOMDocumentXDoctype>;

  @Test:
    @@PerlDef:
      my $doc;
      __CODE{newDocumentForTest}__;
       
      $test->assert_not_null ($doc);
      $test->assert_isa ($doc, <IFName::DocumentXDoctype>);
      $test->assert_isa ($doc, <IFName::Document>);
      $test->assert_isa ($doc, <IFName::Node>);
      $test->assert_isa ($doc, <ClassName::ManakaiDOM|ManakaiDOMObject>);

      ## TODO: Add test for implemented features
    
  @Method:
    @@Name: createDocumentTypeDefinition
    @@enDesc:
      Creates a <IF::DocumentTypeDefinition>.
    @@enDesc:
      @@@ddid: decl
      @@@@:
        If the implementation supports the <Feature::fe|XDoctypeDeclaration>
        feature, the newly created object <kwd:MUST> also implement
        the <IF::DocumentTypeDeclaration> interface.  In addition,
        the object <kwd:MUST> contains general entity declarations
        for five predefined entities specified in XML specifications.
    @@DOMMain:isNamespaceUnaware: 1
    @@Param:
      @@@Name: nameArg
      @@@Type: DOMString
      @@@enDesc:
        The document type name of the definition.
    @@Return:
      @@@Type: DocumentTypeDefinition
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_BAD_NAME
        @@@@enDesc:
          The <P::nameArg> is not a legal <CODE::Name>
          according to the XML version of the document.

          If the <A::Document.strictErrorChecking> attribute is
          set to <DOM::false>, the implementation is not
          <kwd:REQUIRED> to throw this exception.
      @@@PerlDef:
        my $doc = $self->{<H::mn:node>};
        if (<Code::t|doStrictErrorChecking:: $nodeRef = $self>) {
          my $ver = <Code::t|getDocumentXMLVersion::
                      $DOCOBJ = $doc>;
          __CODE{DOMMain:ensureXMLName::
            $INPUT => $nameArg,
            $INPUT_PARAM_NAME => 'nameArg',
            $XMLVERSION => $ver,
          }__;
        }
        my $obj
          = <ClassM::ManakaiDOMDocumentTypeDefinition.newObject>;
        __CODE{mn|setXRefNode||ManakaiDOM|Perl::
          $referrer => $obj,
          $propName => {<H::c|ownerDocument>},
          $referent => $doc,
        }__;
        $obj->{<H::c|name>} = $nameArg;
        $obj->{<H::d|hasLtDeclaration>} = true;
        $obj->{<H::d|hasGtDeclaration>} = true;
        $obj->{<H::d|hasAmpDeclaration>} = true;
        $obj->{<H::d|hasAposDeclaration>} = true;
        $obj->{<H::d|hasQuotDeclaration>} = true;
        $r = <ClassM::t|ManakaiDOMNode.getNodeReference>
               ($obj, <IFName::DocumentTypeDefinition>);

    @@Test:
      @@@QName:
        ManakaiDocumentXDoctype.createDocumentTypeDefinition.success.test
      @@@PerlDef:
        my $doc;
        __CODE{newDocumentForTest}__;
        my $dtd = $doc-><M::DocumentXDoctype.createDocumentTypeDefinition>
                          ('abcdefg');
        
        $test->assert_not_null ($dtd);
        $test->assert_equals ($dtd-><AG::t|Node.nodeType>,
                              <C::t|Node.DOCUMENT_TYPE_NODE>); 
        $test->assert_string (actual_value => $dtd-><AG::Node.nodeName>,
                              expected_value => 'abcdefg'); 
        $test->assert_isa ($dtd, <IFName::DocumentTypeDefinition>);
    
    @@Test:
      @@@QName:
        ManakaiDocumentXDoctype.createDocumentTypeDefinition.badname.test
      @@@PerlDef:
        my $doc;
        __CODE{newDocumentForTest}__;
        $test->assert_exception
                 (code => sub {
                    my $dtd = $doc-><M::DocumentXDoctype
                                         .createDocumentTypeDefinition>
                                      ('0120');
                  },
                  exception_subtype => <Q::MDOMX|MDOM_BAD_NAME>);
    @@Test:
      @@@QName:
        ManakaiDocumentXDoctype.createDocumentTypeDefinition.badname.2.test
      @@@PerlDef:
        my $doc;
        __CODE{newDocumentForTest}__;
        $doc-><AS::Document.strictErrorChecking> (false);
        my $dtd = $doc-><M::DocumentXDoctype.createDocumentTypeDefinition>
                          ('0120');
        
        $test->assert_string (actual_value => $dtd-><AG::Node.nodeName>,
                              expected_value => '0120'); 

  @Method:
    @@Name: createElementTypeDefinition
    @@enDesc:
      Creates an <IF::ElementTypeDefinition>.
    @@DOMMain:isNamespaceUnaware: 1
    @@Param:
      @@@Name: nameArg
      @@@Type: DOMString
      @@@enDesc:
        The element type name of the definition.
    @@Return:
      @@@Type: ElementTypeDefinition
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_BAD_NAME
        @@@@enDesc:
          The <P::nameArg> is not a legal <CODE::Name>
          according to the XML version of the document.

          If the <A::Document.strictErrorChecking> attribute is
          set to <DOM::false>, the implementation is not
          <kwd:REQUIRED> to throw this exception.
      @@@PerlDef:
        my $doc = $self->{<H::mn:node>};
        if (<Code::t|doStrictErrorChecking:: $nodeRef = $self>) {
          my $ver = <Code::t|getDocumentXMLVersion::
                      $DOCOBJ = $doc>;
          __CODE{DOMMain:ensureXMLName::
            $INPUT => $nameArg,
            $INPUT_PARAM_NAME => 'nameArg',
            $XMLVERSION => $ver,
          }__;
        }
        my $obj
          = <ClassM::ManakaiDOMElementTypeDefinition.newObject>;
        __CODE{mn|setXRefNode||ManakaiDOM|Perl::
          $referrer => $obj,
          $propName => {<H::c|ownerDocument>},
          $referent => $doc,
        }__;
        $obj->{<H::c|name>} = $nameArg;
        $r = <ClassM::t|ManakaiDOMNode.getNodeReference> ($obj);

    @@Test:
      @@@QName:
        ManakaiDocumentXDoctype.createElementTypeDefinition.success.test
      @@@PerlDef:
        my $doc;
        __CODE{newDocumentForTest}__;
        my $dtd = $doc-><M::DocumentXDoctype.createElementTypeDefinition>
                          ('abcdefg');
        
        $test->assert_not_null ($dtd);
        $test->assert_equals ($dtd-><AG::t|Node.nodeType>,
                              <C::t|Node.ELEMENT_TYPE_DEFINITION_NODE>); 
        $test->assert_string (actual_value => $dtd-><AG::Node.nodeName>,
                              expected_value => 'abcdefg'); 
    
    @@Test:
      @@@QName:
        ManakaiDocumentXDoctype.createElementTypeDefinition.badname.test
      @@@PerlDef:
        my $doc;
        __CODE{newDocumentForTest}__;
        $test->assert_exception
                 (code => sub {
                    my $dtd = $doc-><M::DocumentXDoctype
                                         .createElementTypeDefinition>
                                      ('0120');
                  },
                  exception_subtype => <Q::MDOMX|MDOM_BAD_NAME>);
    @@Test:
      @@@QName:
        ManakaiDocumentXDoctype.createElementTypeDefinition.badname.2.test
      @@@PerlDef:
        my $doc;
        __CODE{newDocumentForTest}__;
        $doc-><AS::Document.strictErrorChecking> (false);
        my $dtd = $doc-><M::DocumentXDoctype.createElementTypeDefinition>
                          ('0120');
        
        $test->assert_string (actual_value => $dtd-><AG::Node.nodeName>,
                              expected_value => '0120'); 
    
  @Method:
    @@Name: createAttributeDefinition
    @@enDesc:
      Creates an <IF::AttributeDefinition>.
    @@DOMMain:isNamespaceUnaware: 1
    @@Param:
      @@@Name: nameArg
      @@@Type: DOMString
      @@@enDesc:
        The attribute name of the definition.
    @@Return:
      @@@Type: AttributeDefinition
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_BAD_NAME
        @@@@enDesc:
          The <P::nameArg> is not a legal <CODE::Name>
          according to the XML version of the document.

          If the <A::Document.strictErrorChecking> attribute is
          set to <DOM::false>, the implementation is not
          <kwd:REQUIRED> to throw this exception.
      @@@PerlDef:
        my $doc = $self->{<H::mn:node>};
        if (<Code::t|doStrictErrorChecking:: $nodeRef = $self>) {
          my $ver = <Code::t|getDocumentXMLVersion::
                      $DOCOBJ = $doc>;
          __CODE{DOMMain:ensureXMLName::
            $INPUT => $nameArg,
            $INPUT_PARAM_NAME => 'nameArg',
            $XMLVERSION => $ver,
          }__;
        }
        my $obj = <ClassM::ManakaiDOMAttributeDefinition.newObject>;
        __CODE{mn|setXRefNode||ManakaiDOM|Perl::
          $referrer => $obj,
          $propName => {<H::c|ownerDocument>},
          $referent => $doc,
        }__;
        $obj->{<H::c|name>} = $nameArg;
        $r = <ClassM::t|ManakaiDOMNode.getNodeReference> ($obj);

        __DEEP{
          if ($nameArg eq 'xml:id' and
              $self-><AG::Document.domConfig>
                   -><M::c|DOMConfiguration.getParameter> (<Q::cfg|xml-id>)) {
            $r-><AS::AttributeDefinition.declaredType>
                  (<C::AttributeDefinition.ID_ATTR>);
          }
        }__;

    @@Test:
      @@@QName:
        ManakaiDocumentXDoctype.createAttributeDefinition.success.test
      @@@PerlDef:
        my $doc;
        __CODE{newDocumentForTest}__;
        my $dtd = $doc-><M::DocumentXDoctype.createAttributeDefinition>
                          ('abcdefg');
        
        $test->assert_not_null ($dtd);
        $test->assert_equals ($dtd-><AG::t|Node.nodeType>,
                              <C::t|Node.ATTRIBUTE_DEFINITION_NODE>); 
        $test->assert_string (actual_value => $dtd-><AG::Node.nodeName>,
                              expected_value => 'abcdefg'); 
    
    @@Test:
      @@@QName:
        ManakaiDocumentXDoctype.createAttributeDefinition.badname.test
      @@@PerlDef:
        my $doc;
        __CODE{newDocumentForTest}__;
        $test->assert_exception
                 (code => sub {
                    my $dtd = $doc-><M::DocumentXDoctype
                                         .createAttributeDefinition>
                                      ('0120');
                  },
                  exception_subtype => <Q::MDOMX|MDOM_BAD_NAME>);
    @@Test:
      @@@QName:
        ManakaiDocumentXDoctype.createAttributeDefinition.badname.2.test
      @@@PerlDef:
        my $doc;
        __CODE{newDocumentForTest}__;
        $doc-><AS::Document.strictErrorChecking> (false);
        my $dtd = $doc-><M::DocumentXDoctype.createAttributeDefinition>
                          ('0120');
        
        $test->assert_string (actual_value => $dtd-><AG::Node.nodeName>,
                              expected_value => '0120'); 

    @@Test:
      @@@QName: DocXDoctype.createAtDef.xmlid.test
      @@@PerlDef:
        my $doc;
        __CODE{newDocumentForTest}__;

        my $cfg = $doc-><AG::Document.domConfig>;

        $cfg-><M::c|DOMConfiguration.setParameter> (<Q::cfg|xml-id> => true);

        $test->id ('id');
        my $at = $doc-><M::DocumentXDoctype.createAttributeDefinition>
                         ('xml:id');
        $test->assert_num_equals
                 (actual_value => $at-><AG::AttributeDefinition.declaredType>,
                  expected_value => <C::AttributeDefinition.ID_ATTR>);
        
        $cfg-><M::c|DOMConfiguration.setParameter> (<Q::cfg|xml-id> => false);

        $test->id ('nonid');
        my $at2 = $doc-><M::DocumentXDoctype.createAttributeDefinition>
                          ('xml:id');
        $test->assert_num_equals
                 (actual_value => $at2-><AG::AttributeDefinition.declaredType>,
                  expected_value => <C::AttributeDefinition.NO_TYPE_ATTR>);
    
  @Method:
    @@Name: createGeneralEntity
    @@enDesc:
      Creates a general <IF::x|Entity> node.
    @@DOMMain:isNamespaceUnaware: 1
    @@Param:
      @@@Name: nameArg
      @@@Type: DOMString
      @@@enDesc:
        The name of the general entity.
    @@Return:
      @@@Type: x|Entity
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_BAD_NAME
        @@@@enDesc:
          The <P::nameArg> is not a legal <CODE::Name>
          according to the XML version of the document.

          If the <A::Document.strictErrorChecking> attribute is
          set to <DOM::false>, the implementation is not
          <kwd:REQUIRED> to throw this exception.
      @@@PerlDef:
        my $doc = $self->{<H::mn:node>};
        if (<Code::t|doStrictErrorChecking:: $nodeRef = $self>) {
          my $ver = <Code::t|getDocumentXMLVersion::
                      $DOCOBJ = $doc>;
          __CODE{DOMMain:ensureXMLName::
            $INPUT => $nameArg,
            $INPUT_PARAM_NAME => 'nameArg',
            $XMLVERSION => $ver,
          }__;
        }
        my $obj = <ClassM::x|ManakaiDOMEntity.newObject>;
        __CODE{mn|setXRefNode||ManakaiDOM|Perl::
          $referrer => $obj,
          $propName => {<H::c|ownerDocument>},
          $referent => $doc,
        }__;
        $obj->{<H::c|name>} = $nameArg;
        $r = <ClassM::t|ManakaiDOMNode.getNodeReference> ($obj);

    @@Test:
      @@@QName:
        ManakaiDocumentXDoctype.createGeneralEntity.success.test
      @@@PerlDef:
        my $doc;
        __CODE{newDocumentForTest}__;
        my $dtd = $doc-><M::DocumentXDoctype.createGeneralEntity>
                          ('abcdefg');
        
        $test->assert_not_null ($dtd);
        $test->assert_equals ($dtd-><AG::t|Node.nodeType>,
                              <C::t|Node.ENTITY_NODE>); 
        $test->assert_string (actual_value => $dtd-><AG::Node.nodeName>,
                              expected_value => 'abcdefg'); 
    
    @@Test:
      @@@QName:
        ManakaiDocumentXDoctype.createGeneralEntity.badname.test
      @@@PerlDef:
        my $doc;
        __CODE{newDocumentForTest}__;
        $test->assert_exception
                 (code => sub {
                    my $dtd = $doc-><M::DocumentXDoctype.createGeneralEntity>
                                      ('0120');
                  },
                  exception_subtype => <Q::MDOMX|MDOM_BAD_NAME>);
    @@Test:
      @@@QName:
        ManakaiDocumentXDoctype.createGeneralEntity.badname.2.test
      @@@PerlDef:
        my $doc;
        __CODE{newDocumentForTest}__;
        $doc-><AS::Document.strictErrorChecking> (false);
        my $dtd = $doc-><M::DocumentXDoctype.createGeneralEntity>
                          ('0120');
        
        $test->assert_isa ($dtd, <IFName::x|Entity>);
        $test->assert_equals ($dtd-><AG::t|Node.nodeType>,
                              <C::t|Node.ENTITY_NODE>); 
        $test->assert_string (actual_value => $dtd-><AG::Node.nodeName>,
                              expected_value => '0120'); 
    
  @Method:
    @@Name: createNotation
    @@enDesc:
      Creates a <IF::x|Notation> node.
    @@DOMMain:isNamespaceUnaware: 1
    @@Param:
      @@@Name: nameArg
      @@@Type: DOMString
      @@@enDesc:
        The name of the notation.
    @@Return:
      @@@Type: x|Notation
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_BAD_NAME
        @@@@enDesc:
          The <P::nameArg> is not a legal <CODE::Name>
          according to the XML version of the document.

          If the <A::Document.strictErrorChecking> attribute is
          set to <DOM::false>, the implementation is not
          <kwd:REQUIRED> to throw this exception.
      @@@PerlDef:
        my $doc = $self->{<H::mn:node>};
        if (<Code::t|doStrictErrorChecking:: $nodeRef = $self>) {
          my $ver = <Code::t|getDocumentXMLVersion::
                      $DOCOBJ = $doc>;
          __CODE{DOMMain:ensureXMLName::
            $INPUT => $nameArg,
            $INPUT_PARAM_NAME => 'nameArg',
            $XMLVERSION => $ver,
          }__;
        }
        my $obj = <ClassM::x|ManakaiDOMNotation.newObject>;
        __CODE{mn|setXRefNode||ManakaiDOM|Perl::
          $referrer => $obj,
          $propName => {<H::c|ownerDocument>},
          $referent => $doc,
        }__;
        $obj->{<H::c|name>} = $nameArg;
        $r = <ClassM::t|ManakaiDOMNode.getNodeReference> ($obj);

    @@Test:
      @@@QName:
        ManakaiDocumentXDoctype.createNotation.success.test
      @@@PerlDef:
        my $doc;
        __CODE{newDocumentForTest}__;
        my $dtd = $doc-><M::DocumentXDoctype.createNotation>
                          ('abcdefg');
        
        $test->assert_isa ($dtd, <IFName::x|Notation>);
        $test->assert_equals ($dtd-><AG::t|Node.nodeType>,
                              <C::t|Node.NOTATION_NODE>); 
        $test->assert_string (actual_value => $dtd-><AG::Node.nodeName>,
                              expected_value => 'abcdefg'); 
    
    @@Test:
      @@@QName:
        ManakaiDocumentXDoctype.createNotation.badname.test
      @@@PerlDef:
        my $doc;
        __CODE{newDocumentForTest}__;
        $test->assert_exception
                 (code => sub {
                    my $dtd = $doc-><M::DocumentXDoctype.createNotation>
                                      ('0120');
                  },
                  exception_subtype => <Q::MDOMX|MDOM_BAD_NAME>);
    @@Test:
      @@@QName:
        ManakaiDocumentXDoctype.createNotation.badname.2.test
      @@@PerlDef:
        my $doc;
        __CODE{newDocumentForTest}__;
        $doc-><AS::Document.strictErrorChecking> (false);
        my $dtd = $doc-><M::DocumentXDoctype.createNotation>
                          ('0120');
        
        $test->assert_isa ($dtd, <IFName::x|Notation>);
        $test->assert_equals ($dtd-><AG::t|Node.nodeType>,
                              <C::t|Node.NOTATION_NODE>); 
        $test->assert_string (actual_value => $dtd-><AG::Node.nodeName>,
                              expected_value => '0120'); 
##DocumentXDoctype

ResourceDef:
  @QName: NodeStem
  @AliasFor: ManakaiNode|NodeStem||ManakaiDOM|Perl
  @For: ManakaiDOM|ManakaiDOM !=ManakaiDOM|ManakaiDOM

IFClsXDef:
  @IFQName: DocumentTypeDefinition
  @ClsQName: ManakaiDOMDocumentTypeDefinition
  
  @ClsISA: ManakaiDOMDocumentTypeDeclaration
  @ClsISA: t|ManakaiDOMNode

  @Implement: x|DocumentType||ManakaiDOM|ManakaiDOM1
  @Implement: x|DocumentType||ManakaiDOM|ManakaiDOM2
  @Implement: x|DocumentType||ManakaiDOM|ManakaiDOM3
  @Implement: x|DocumentType||ManakaiDOM|ManakaiDOMLatest
  
  @DISLang:role: c|DocumentTypeRole

  @f:implements: d|Feature30
  
  @enDesc:
    A <IF::DocumentTypeDefinition> node represents
    a set of definitions for a document type.
    
    Objects implementing the <IF::DocumentTypeDefinition>
    interface <kwd:MAY> also implement the <IF::x|DocumentType>
    interface and / or the <IF::DocumentTypeDeclaration> interface.
    Although some attributes are defined by two or three of these
    interfaces, objects only have to implement them once.
    
    In DOM levels 1, 2, and 3, a <IF::x|DocumentType> object
    can never have child node.  A <IF::DocumentTypeDefinition>
    node, however, <kwd:MAY> have <IF::x|ProcessingInstruction>
    nodes, as <InfoProp::children> property of 
    <InfoItem::processing instruction information item>.
    
    If a <IF::DocumentTypeDefinition> node is not associated
    with any document yet, then its <A::t|Node.ownerDocument>
    attribute value is <DOM::null>.  Otherwise, the
    attribute contains the attribute to which the node
    is associated.  Note that the
    <M::DocumentXDoctype.createDocumentTypeDefinition>
    method will assign the attribute to that document.

  @enImplNote:
    In current manakai implementation, a <IF::DocumentTypeDefinition>
    object <kwd:MUST> also implement the <IF::x|DocumentType>
    interface (because of <M::t|ManakaiDOMNode.getNodeReference>
    implementation).

  @ResourceDef:
    @@ForCheck: ManakaiDOM|ForClass
    @@QName: newDoctypeForTest
    @@rdf:type: DISPerl|BlockCode
    @@PerlDef:
      my $doc;
      __CODE{newDocumentForTest}__;
      $dtd = $doc-><M::DocumentXDoctype.createDocumentTypeDefinition>
                          ('dt1');

  @Test:
    @@QName: ManakaiDOMDTD.ownerDocument.test
    @@PerlDef:
      my $dtd;
      __CODE{newDoctypeForTest}__;
      $test->assert_not_null ($dtd);
      $test->assert_isa ($dtd, <IFName::DocumentTypeDefinition>);
      $test->assert_isa ($dtd, <IFName::x|DocumentType>);
      $test->assert_isa ($dtd, <IFName::Node>);
      $test->assert_isa ($dtd, <ClassName::ManakaiDOM|ManakaiDOMObject>);

      my $od = $dtd-><AG::Node.ownerDocument>;
      $test->assert_not_null ($od);
      $test->assert_not_null
               ($od-><M::Node.getFeature> (<Q::ManakaiDOM:XDoctype>, '3.0'));

  @Test:
    @@QName: ManakaiDOMDTD.appendChild.pi.test
    @@PerlDef:
      my $dtd;
      __CODE{newDoctypeForTest}__;
      
      my $doc = $dtd-><AG::Node.ownerDocument>;
      my $pi = $doc-><M::Document.createProcessingInstruction> ('pitarget');
      
      $dtd-><M::Node.appendChild> ($pi);

      my $fc = $dtd-><AG::Node.firstChild>;
      $test->assert_not_null ($fc);
      $test->assert_equals ($pi, $fc);
      $test->assert_string (actual_value => $pi-><AG::PI.target>,
                            expected_value => 'pitarget');

  @Attr:
    @@ForCheck: ManakaiDOM|ForClass
    @@Name: nodeName
    @@enDesc:
      The document type name of the node.
    @@Type: DOMString
    @@Get:
      @@@PerlDef:
        if (defined $self->{<H::mn:node>}
                         ->{<H::infoset:localName>}) {
          if (defined $self->{<H::mn:node>}->{<H::infoset:prefix>}) {
            $r = $self->{<H::mn:node>}->{<H::infoset:prefix>}
               . ':'
               . $self->{<H::mn:node>}->{<H::infoset:localName>};
          } else {
            $r = $self->{<H::mn:node>}->{<H::infoset:localName>};
          }
        } else {
          $r = $self->{<H::mn:node>}->{<H::c|name>};
        }
    @@Test:
      @@@PerlDef:
        my $dtd;
        __CODE{newDoctypeForTest}__;
        $test->assert_equals
                 ($dtd-><AG::Node.nodeName>, 'dt1');

  @Attr:
    @@ForCheck: ManakaiDOM|ForClass
    @@Name: localName
    @@enDesc:
      The local name of the document type name.
      
      If the node is created by namespace aware method
      such as <M::c|DOMImplementation.createDocumentType>,
      then this attribute contains a non-<DOM::null> value.
      Otherwise, the attribute value is <DOM::null>.
      
        {NOTE:: This is a manakai extension.  In other
                implementation, <A::t|Node.localName>
                of a <IF::x|DocumentType> is always <DOM::null>.
        }
    @@Type: DOMString
    @@DOMMain:isNamespaceAware: 1
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          If the node is namespace unaware.
      @@@disDef:
        @@@@GetProp: infoset|localName
    @@Test:
      @@@PerlDef:
        my $dtd;
        __CODE{newDoctypeForTest}__;
        $test->assert_null ($dtd-><AG::Node.localName>);
      
  @Attr:
    @@ForCheck: ManakaiDOM|ForClass
    @@Name: prefix
    @@enDesc:
      The namespace prefix of the document type name.
      
      If the node is created by a namespace aware method
      such as <M::c|DOMImplementation.createDocumentType>,
      then the node might have a namespace prefix.
      Otherwise, it is always <DOM::null>.
      
        {NOTE:: This is a manakai extension; in other 
                implementations, <A::t|Node.prefix> of
                a <IF::x|DocumentType> node will be always 
                <DOM::null>.
        }
    @@Type: DOMString
    @@dis:actualType: DOMMain|ManakaiDOMNamespacePrefix
    @@DOMMain:isNamespaceAware: 1
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          If the node is <EM::not> namespace aware, or
          if the document type name belongs to the default
          namespace.
      @@@disDef:
        @@@@GetProp: infoset|prefix
    @@Set:
      @@@enDesc:
        If the node is <EM::not> namespace aware, then
        setting the node has no effect, even if the node
        is read-only.
      @@@InCase:
        @@@@Value:
          @@@@@@: \
          @@@@@ContentType: DISCore|String
        @@@@enDesc:
          The result is implementation dependent.
      @@@nullCase:
        @@@@enDesc:
          The document type name has no prefix.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_BAD_NAME
        @@@@enDesc:
          If the new value is not a legal <CODE::Name>
          according to the XML version of the document.
        
            {NOTE:: If the XML version of the document
                    is not available, then it is validated
                    against XML 1.1.
            }
      @@@NodeReadOnlyError:
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_NS_BAD_NCNAME
        @@@@enDesc:
          If the new value is not a legal <CODE::NCName>
          according to the XML version of the document.
          
            {NOTE:: If the XML version of the document
                    is not available, then it is validated
                    against XML 1.1.
            }
      @@@c:reports:
        @@@@@: t|setting-prefix-no-effect-because-of-node
        @@@@enDesc:
          If the node is <EM::not> namespace aware so that
          setting the attribute value has no effect.
        @@@@For: ManakaiDOM|ManakaiDOM
      @@@PerlDef:
        if (defined $self->{<H::mn:node>}
                         ->{<H::infoset:localName>}) {
          __CODE{NodeReadOnlyError}__;
          my $doc = $self->{<H::infoset:parent>};
          my $ver = $doc
                      ? (<Code::t|getDocumentXMLVersion::
                           $DOCOBJ = $doc>)
                      : '1.1';
          __CODE{DOMMain:ensureNamespacePrefix::
            $INPUT => $given,
            $INPUT_PARAM_NAME => '',
            $XMLVERSION => $ver,
          }__;
          $self->{<H::mn:node>}->{<H::infoset:prefix>} = $given;
        }
    @@Test:
      @@@PerlDef:
        my $dtd;
        __CODE{newDoctypeForTest}__;
        $test->assert_null ($dtd-><AG::Node.prefix>);
        $dtd-><AS::Node.prefix> ('prefix');
        $test->assert_null ($dtd-><AG::Node.prefix>);
        $dtd-><AS::Node.prefix> ('0120444444');
        $test->assert_null ($dtd-><AG::Node.prefix>);

  @Attr:
    @@Name: elementTypes
    @@enDesc:
      The live collection of the element types contained
      in the document type definition.
    @@Type: t|NamedNodeMap
    @@Get:
      @@@PerlDef:
        __CODE{t|getElementTypeDefNodeMap::
          $node => $self,
          $map => $r,
        }__;

    @@Test:
      @@@QName: dtd.elementTypes.test
      @@@PerlDef:
        my $dtd;
        __CODE{newDoctypeForTest}__;

        my $es = $dtd-><AG::DocumentTypeDefinition.elementTypes>;
        $test->assert_isa ($es, <IFName::t|NamedNodeMap>);

  @Attr:
    @@Name: generalEntities
    @@enDesc:
      The live collection of the general entities contained
      in the document type definition.
    @@Type: t|NamedNodeMap
    @@Get:
      @@@PerlDef:
        __CODE{t|getEntityNodeMap::
          $node => $self,
          $map => $r,
        }__;

    @@Test:
      @@@QName: DocumentTypeDefinition.generalEntities.test
      @@@PerlDef:
        my $dtd;
        __CODE{newDoctypeForTest}__;

        my $es = $dtd-><AG::DocumentTypeDefinition.generalEntities>;
        $test->assert_isa ($es, <IFName::t|NamedNodeMap>);

  @Attr:
    @@ForCheck: ManakaiDOM|ForClass
    @@Name: entities
      The live collection of the general entities contained
      in the document type definition.
    @@Type: t|NamedNodeMap
    @@Get:
      @@@disDef:
        @@@@DISPerl:cloneCode: .generalEntities.get

    @@Test:
      @@@QName: DocumentType.entities.get.test
      @@@PerlDef:
        my $impl;
        __CODE{t|createDOMImplForTest:: $impl => $impl}__;

        my $dtype = $impl-><M::c|DOMImplementation.createDocumentType>
                             ('type', 'pub', 'sys');
        my $ent = $dtype-><AG::x|DocumentType.entities>;
        $test->assert_isa ($ent, <IFName::t|NamedNodeMap>);
        $test->assert_num_equals
                 (actual_value => $ent-><AG::t|NamedNodeMap.length>,
                  expected_value => 0);

  @Attr:
    @@Name: notations
    @@enDesc:
      The live collection of the notations contained
      in the document type definition.

      Duplicate notation declarations, if any, in DTD are not
      contained in the collection and only the first declaration
      is made available as a <IF::x|Notation> node.

        {NOTE::
          This definition is based on one for the attribute
          <A::x|DocumentType.notations> in DOM XML module.
          Since duplication is violation to the Validity Constraint,
          XML parsers might vary on how notations are notified to
          the application.  In particular, <InfoProp::notations>
          property of the <InfoItem::document information item>
          in the XML Information Set defines that in case <EM::any>
          notation is multiply declared then the property has no value.
        }
    @@Type: t|NamedNodeMap
    @@Get:
      @@@PerlDef:
        __CODE{t|getNotationNodeMap::
          $node => $self,
          $map => $r,
        }__;

    @@Test:
      @@@QName: DocumentTypeDefinition.notations.test
      @@@PerlDef:
        my $dtd;
        __CODE{newDoctypeForTest}__;

        my $es = $dtd-><AG::DocumentTypeDefinition.notations>;
        $test->assert_isa ($es, <IFName::t|NamedNodeMap>);

    @@Test:
      @@@QName: DocumentType.notations.get.test
      @@@PerlDef:
        my $impl;
        __CODE{t|createDOMImplForTest:: $impl => $impl}__;

        my $dtype = $impl-><M::c|DOMImplementation.createDocumentType>
                             ('type', 'pub', 'sys');
        my $ent = $dtype-><AG::x|DocumentType.notations>;
        $test->assert_isa ($ent, <IFName::t|NamedNodeMap>);
        $test->assert_num_equals
                 (actual_value => $ent-><AG::t|NamedNodeMap.length>,
                  expected_value => 0);
      
  @enImplNote:
    {TODO::
      Implement
      <A::.parameterEntities>.

      Test that:
        $a = $dtd->element_types;
        $b = $dtd->general_entities;
        $a is still a element type defs col.
      
      Implement get/set by name methods for parameter
      entities and notations.
      
      Defines <M::t|Node.cloneNode>, <M::t|Node.importNode>,
      <M::t|Node.adoptNode>, namespace methods, ...
      
      In particular, document position for processing
      instruction children must be defined.

      Test for namespace aware doctype (is namespace aware doctype
      really required?)
    }

  @Method:
    @@Name: getElementTypeDefinitionNode
    @@enDesc:
      Returns the definition for an element type.
    @@DOMMain:isNamespaceUnaware: 1
    @@Param:
      @@@Name: nameArg
      @@@Type: DOMString
      @@@enDesc:
        The name of the element type.
    @@Return:
      @@@Type: ElementTypeDefinition
      @@@enDesc:
        The element type definition for <P::nameArg>.
      @@@nullCase:
        @@@@enDesc:
          There is no definition for the element type <P::nameArg>.
      @@@PerlDef:
        my $n = $self->{<H::mn:node>}
                     ->{<H::d|elementTypes>}
                     ->{$nameArg};
        if ($n) {
          $r = <ClassM::t|ManakaiDOMNode.getNodeReference> ($n);
        }
    @@Test:
      @@@PerlDef:
        my $dtd;
        __CODE{newDoctypeForTest}__;
        $test->assert_null 
                 ($dtd-><M::DocumentTypeDefinition
                           .getElementTypeDefinitionNode> ('element'));

  @Method:
    @@Name: setElementTypeDefinitionNode
    @@enDesc:
      Sets an element type definition to the document type
      definition.
    @@Param:
      @@@Name: defNode
      @@@Type: ElementTypeDefinition
      @@@enDesc:
        The element type definition to set.  Its <A::t|Node.nodeName>
        attribute is used to set the node.  If it is already
        in use elsewhere, then it is first removed
        from there and then attached to the document type.
        If another element type definition with
        same <A::t|Node.nodeName> is attached to this document
        type definition, that association is removed.
        
        If <P::defNode> is already attached to this document
        type definition, then this method has no effect.
    @@Return:
      @@@Type: ElementTypeDefinition
      @@@enDesc:
        If there is already another element type definition
        with the same <A::t|Node.nodeName> as <P::defNode>,
        then that definition node is returned.
      @@@nullCase:
        @@@@enDesc:
          If there is no previous definition with the same
          name, or the <P::defNode> is already attached
          to the document type definition.
      @@@NodeReadOnlyError:
      @@@dx:raises:
        @@@@@: c|INUSE_DEFINITION_ERR
        @@@@enDesc:
          If <A::ElementTypeDefinition.ownerDocumentTypeDefinition>
          is not <DOM::null>.
      @@@dx:raises:
        @@@@@: c|DIFFERENT_DOCUMENT_ERR
        @@@@enDesc:
          The <P::defNode> node is created from different
          document than the <A::c|Node.ownerDocument> of
          the document type definition and the implementation
          does not support such definition node
          being attached to the document type definition.
      @@@PerlDef:
        __CODE{setDefinitionNode::
          $defNode => $defNode,
          $defNodeParamName => 'defNode',
          $key => {<H::d|elementTypes>},
        }__;
    @@Test:
      @@@PerlDef:
        my $dtd;
        __CODE{newDoctypeForTest}__;
        $test->assert_null 
                 ($dtd-><M::DocumentTypeDefinition
                           .getElementTypeDefinitionNode> ('et1'));

        my $et = $dtd-><AG::Node.ownerDocument>
                     -><M::Node.getFeature> (<Q::ManakaiDOM|XDoctype>)
                     -><M::DocumentXDoctype.createElementTypeDefinition>
                         ('et1');

        my $old1 = $dtd-><M::DocumentTypeDefinition
                           .setElementTypeDefinitionNode> ($et);
        $test->assert_null ($old1);

        my $ret = $dtd-><M::DocumentTypeDefinition
                           .getElementTypeDefinitionNode> ('et1');
        $test->assert_equals ($et, $ret);
        $test->assert_num_equals
                 (actual_value => $ret-><AG::Node.nodeType>,
                  expected_value => <C::Node.ELEMENT_TYPE_DEFINITION_NODE>);
        $test->assert_equals
                 ($et-><AG::ElementTypeDefinition.ownerDocumentTypeDefinition>,
                  $dtd);

        $test->id ('replace-same');

        my $old2 = $dtd-><M::DocumentTypeDefinition
                           .setElementTypeDefinitionNode> ($et);
        $test->assert_null ($old2);

        $test->id ('change-parent');

        my $dtd2 = $dtd-><AG::Node.ownerDocument>
                       -><M::Node.getFeature> (<Q::ManakaiDOM|XDoctype>)
                       -><M::DocumentXDoctype.createDocumentTypeDefinition>
                           ('dt2');
    
        $test->assert_exception (code => sub {
          $dtd2-><M::DocumentTypeDefinition
                            .setElementTypeDefinitionNode> ($et);
        }, exception_subtype => <Q::c|INUSE_DEFINITION_ERR>);
        
        $test->assert_equals
                 ($et-><AG::ElementTypeDefinition.ownerDocumentTypeDefinition>,
                  $dtd);
        $test->assert_equals
                 ($dtd-><M::DocumentTypeDefinition
                             .getElementTypeDefinitionNode>
                          ('et1'),
                  $et);
  
        $test->id ('rewrite');

        my $et2 = $dtd-><AG::Node.ownerDocument>
                      -><M::Node.getFeature> (<Q::ManakaiDOM|XDoctype>)
                      -><M::DocumentXDoctype.createElementTypeDefinition>
                          ('et1');
        $test->assert_not_equals ($et, $et2);

        my $old4 = $dtd-><M::DocumentTypeDefinition
                                .setElementTypeDefinitionNode> ($et2);
        $test->assert_equals ($old4, $et);
        $test->assert_equals
                 ($et2-><AG::ElementTypeDefinition.ownerDocumentTypeDefinition>,
                  $dtd);

    @@Test:
      @@@PerlDef:
        my $dtd;
        __CODE{newDoctypeForTest}__;
        my $et;
        __CODE{newETForTest}__;

        $test->assert_exception
          (code => sub {
            $dtd-><M::DocumentTypeDefinition
                     .setElementTypeDefinitionNode> ($et);
           },
           exception_subtype => <Q::c|DIFFERENT_DOCUMENT_ERR>);

  @Method:
    @@Name: getGeneralEntityNode
    @@enDesc:
      Returns the definition for a general entity.
    @@DOMMain:isNamespaceUnaware: 1
    @@Param:
      @@@Name: nameArg
      @@@Type: DOMString
      @@@enDesc:
        The name of the general entity.
    @@Return:
      @@@Type: x|Entity
      @@@enDesc:
        The general entity <P::nameArg>.
      @@@nullCase:
        @@@@enDesc:
          There is no general entity <P::nameArg>.
      @@@PerlDef:
        my $n = $self->{<H::mn:node>}
                     ->{<H::d|generalEntities>}
                     ->{$nameArg};
        if ($n) {
          $r = <ClassM::t|ManakaiDOMNode.getNodeReference> ($n);
        }
    @@Test:
      @@@QName: DocumentTypeDefinition.getGeneralEntityNode.test
      @@@PerlDef:
        my $dtd;
        __CODE{newDoctypeForTest}__;
        $test->assert_null 
                 ($dtd-><M::DocumentTypeDefinition
                           .getGeneralEntityNode> ('element'));

  @Method:
    @@Name: setGeneralEntityNode
    @@enDesc:
      Sets a general entity to the document type
      definition.
    @@Param:
      @@@Name: defNode
      @@@Type: x|Entity
      @@@enDesc:
        The general entity to set.  Its <A::t|Node.nodeName>
        attribute is used to set the node.

        If another general entity node with
        same <A::t|Node.nodeName> is attached to this document
        type definition, such association is removed.
        
        If <P::defNode> is already attached to this document
        type definition, then this method has no effect.
    @@Return:
      @@@Type: x|Entity
      @@@enDesc:
        If there is already another general entity
        with the same <A::t|Node.nodeName> as <P::defNode>,
        then that node is returned.
      @@@nullCase:
        @@@@enDesc:
          If there is no previous definition with the same
          name, or the <P::defNode> is already attached
          to the document type definition.
      @@@NodeReadOnlyError:
      @@@dx:raises:
        @@@@@: c|INUSE_DEFINITION_ERR
        @@@@enDesc:
          If <A::x|Entity.ownerDocumentTypeDefinition>
          is not <DOM::null>.
      @@@dx:raises:
        @@@@@: c|DIFFERENT_DOCUMENT_ERR
        @@@@enDesc:
          The <P::defNode> node is created from different
          document than the <A::c|Node.ownerDocument> of
          the document type definition and the implementation
          does not support such definition node
          being attached to the document type definition.
      @@@PerlDef:
        __CODE{setDefinitionNode::
          $defNode => $defNode,
          $defNodeParamName => 'defNode',
          $key => {<H::d|generalEntities>},
        }__;
    @@Test:
      @@@QName: DocumentTypeDefinition.setGeneralEntityNode.test
      @@@PerlDef:
        my $dtd;
        __CODE{newDoctypeForTest}__;

        $test->id ('initial.empty');
        $test->assert_null 
                 ($dtd-><M::DocumentTypeDefinition
                           .getGeneralEntityNode> ('et1'));

        my $et = $dtd-><AG::Node.ownerDocument>
                     -><M::Node.getFeature> (<Q::ManakaiDOM|XDoctype>)
                     -><M::DocumentXDoctype.createGeneralEntity>
                         ('et1');

        $test->id ('set');
        my $old1 = $dtd-><M::DocumentTypeDefinition
                           .setGeneralEntityNode> ($et);
        $test->assert_null ($old1);

        $test->id ('get');
        my $ret = $dtd-><M::DocumentTypeDefinition
                           .getGeneralEntityNode> ('et1');
        $test->assert_equals ($et, $ret);
        $test->assert_num_equals
                 (actual_value => $ret-><AG::Node.nodeType>,
                  expected_value => <C::Node.ENTITY_NODE>);
        $test->assert_equals
                 ($et-><AG::x|Entity.ownerDocumentTypeDefinition>,
                  $dtd);

        $test->id ('replace-same');
        my $old2 = $dtd-><M::DocumentTypeDefinition
                           .setGeneralEntityNode> ($et);
        $test->assert_null ($old2);

        $test->id ('change-parent');

        my $dtd2 = $dtd-><AG::Node.ownerDocument>
                       -><M::Node.getFeature> (<Q::ManakaiDOM|XDoctype>)
                       -><M::DocumentXDoctype.createDocumentTypeDefinition>
                           ('dt2');
    
        $test->assert_exception (code => sub {
          $dtd2-><M::DocumentTypeDefinition
                            .setGeneralEntityNode> ($et);
        }, exception_subtype => <Q::c|INUSE_DEFINITION_ERR>);
        
        $test->assert_equals
                 ($et-><AG::x|Entity.ownerDocumentTypeDefinition>,
                  $dtd);
        $test->assert_equals
                 ($dtd-><M::DocumentTypeDefinition
                             .getGeneralEntityNode>
                          ('et1'),
                  $et);
  
        $test->id ('rewrite');

        my $et2 = $dtd-><AG::Node.ownerDocument>
                      -><M::Node.getFeature> (<Q::ManakaiDOM|XDoctype>)
                      -><M::DocumentXDoctype.createGeneralEntity>
                          ('et1');
        $test->assert_not_equals ($et, $et2);

        my $old4 = $dtd-><M::DocumentTypeDefinition
                                .setGeneralEntityNode> ($et2);
        $test->assert_equals ($old4, $et);
        $test->assert_equals
                 ($et2-><AG::x|Entity.ownerDocumentTypeDefinition>,
                  $dtd);

    @@Test:
      @@@QName: DocumentTypeDefinition.setGeneralEntityNode.DIFF_DOC_ERR.test
      @@@PerlDef:
        my $dtd;
        __CODE{newDoctypeForTest}__;
        my $et;
        __CODE{newGeneralEntityForTest}__;

        $test->assert_exception
          (code => sub {
            $dtd-><M::DocumentTypeDefinition
                     .setGeneralEntityNode> ($et);
           },
           exception_subtype => <Q::c|DIFFERENT_DOCUMENT_ERR>);

  @Method:
    @@Name: getNotationNode
    @@enDesc:
      Returns the definition for a notation.
    @@DOMMain:isNamespaceUnaware: 1
    @@Param:
      @@@Name: nameArg
      @@@Type: DOMString
      @@@enDesc:
        The name of the notation.
    @@Return:
      @@@Type: x|Notation
      @@@enDesc:
        The notation <P::nameArg>.
      @@@nullCase:
        @@@@enDesc:
          There is no notation <P::nameArg>.
      @@@PerlDef:
        my $n = $self->{<H::mn:node>}
                     ->{<H::d|notations>}
                     ->{$nameArg};
        if ($n) {
          $r = <ClassM::t|ManakaiDOMNode.getNodeReference> ($n);
        }
    @@Test:
      @@@QName: DocumentTypeDefinition.getNotationNode.test
      @@@PerlDef:
        my $dtd;
        __CODE{newDoctypeForTest}__;
        $test->assert_null 
                 ($dtd-><M::DocumentTypeDefinition
                           .getNotationNode> ('element'));

  @Method:
    @@Name: setNotationNode
    @@enDesc:
      Sets a notation to the document type
      definition.
    @@Param:
      @@@Name: defNode
      @@@Type: x|Notation
      @@@enDesc:
        The notation to set.  Its <A::t|Node.nodeName>
        attribute is used to set the node.

        If another notation node with
        same <A::t|Node.nodeName> is attached to this document
        type definition, such association is removed.
        
        If <P::defNode> is already attached to this document
        type definition, then this method has no effect.
    @@Return:
      @@@Type: x|Notation
      @@@enDesc:
        If there is already another notation
        with the same <A::t|Node.nodeName> as <P::defNode>,
        then that node is returned.
      @@@nullCase:
        @@@@enDesc:
          If there is no previous definition with the same
          name, or the <P::defNode> is already attached
          to the document type definition.
      @@@NodeReadOnlyError:
      @@@dx:raises:
        @@@@@: c|INUSE_DEFINITION_ERR
        @@@@enDesc:
          If <A::x|Notation.ownerDocumentTypeDefinition>
          is not <DOM::null>.
      @@@dx:raises:
        @@@@@: c|DIFFERENT_DOCUMENT_ERR
        @@@@enDesc:
          The <P::defNode> node is created from different
          document than the <A::c|Node.ownerDocument> of
          the document type definition and the implementation
          does not support such definition node
          being attached to the document type definition.
      @@@PerlDef:
        __CODE{setDefinitionNode::
          $defNode => $defNode,
          $defNodeParamName => 'defNode',
          $key => {<H::d|notations>},
        }__;
    @@Test:
      @@@QName: DocumentTypeDefinition.setNotationNode.test
      @@@PerlDef:
        my $dtd;
        __CODE{newDoctypeForTest}__;

        $test->id ('initial.empty');
        $test->assert_null 
                 ($dtd-><M::DocumentTypeDefinition
                           .getNotationNode> ('et1'));

        my $et = $dtd-><AG::Node.ownerDocument>
                     -><M::Node.getFeature> (<Q::fe|XDoctype>)
                     -><M::DocumentXDoctype.createNotation>
                         ('et1');

        $test->id ('set');
        my $old1 = $dtd-><M::DocumentTypeDefinition
                           .setNotationNode> ($et);
        $test->assert_null ($old1);

        $test->id ('get');
        my $ret = $dtd-><M::DocumentTypeDefinition
                           .getNotationNode> ('et1');
        $test->assert_equals ($et, $ret);
        $test->assert_num_equals
                 (actual_value => $ret-><AG::Node.nodeType>,
                  expected_value => <C::Node.NOTATION_NODE>);
        $test->assert_equals
                 ($et-><AG::x|Notation.ownerDocumentTypeDefinition>,
                  $dtd);

        $test->id ('replace-same');
        my $old2 = $dtd-><M::DocumentTypeDefinition
                           .setNotationNode> ($et);
        $test->assert_null ($old2);

        $test->id ('change-parent');

        my $dtd2 = $dtd-><AG::Node.ownerDocument>
                       -><M::Node.getFeature> (<Q::fe|XDoctype>)
                       -><M::DocumentXDoctype.createDocumentTypeDefinition>
                           ('dt2');
    
        $test->assert_exception (code => sub {
          $dtd2-><M::DocumentTypeDefinition
                            .setNotationNode> ($et);
        }, exception_subtype => <Q::c|INUSE_DEFINITION_ERR>);
        
        $test->assert_equals
                 ($et-><AG::x|Notation.ownerDocumentTypeDefinition>,
                  $dtd);
        $test->assert_equals
                 ($dtd-><M::DocumentTypeDefinition
                             .getNotationNode>
                          ('et1'),
                  $et);
  
        $test->id ('rewrite');

        my $et2 = $dtd-><AG::Node.ownerDocument>
                      -><M::Node.getFeature> (<Q::fe|XDoctype>)
                      -><M::DocumentXDoctype.createNotation>
                          ('et1');
        $test->assert_not_equals ($et, $et2);

        my $old4 = $dtd-><M::DocumentTypeDefinition
                                .setNotationNode> ($et2);
        $test->assert_equals ($old4, $et);
        $test->assert_equals
                 ($et2-><AG::x|Notation.ownerDocumentTypeDefinition>,
                  $dtd);

    @@Test:
      @@@QName: DocumentTypeDefinition.setNotationNode.DIFF_DOC_ERR.test
      @@@PerlDef:
        my $dtd;
        __CODE{newDoctypeForTest}__;
        my $et;
        __CODE{newNotationForTest}__;

        $test->assert_exception
          (code => sub {
            $dtd-><M::DocumentTypeDefinition
                     .setNotationNode> ($et);
           },
           exception_subtype => <Q::c|DIFFERENT_DOCUMENT_ERR>);

  @CAttr:
    @@Name: implementation
    @@enDesc:
      The <IF::c|DOMImplementation> object to which the node belongs.

      This attribute is a manakai extension.
    @@Type: c|DOMImplementation
    @@Get:
      @@@PerlDef:
        $r = $self->{<H::mn:node>}->{<H::c|implementation>};
        unless ($r) {
          __DEEP{
            $r = $self-><AG::Node.ownerDocument>-><AG::Document.implementation>;
          }__;
        }

    @@Test:
      @@@QName: DTDef.impl.test
      @@@PerlDef:
        my $dtd;
        __CODE{newDoctypeForTest}__;

        $test->assert_isa ($dtd-><AG::x|DocumentType.implementation>,
                           <IFName::c|DOMImplementation>);

    @@Test:
      @@@QName: Doctype.impl.test
      @@@PerlDef:
        my $impl;
        __CODE{t|createDOMImplForTest:: $impl => $impl}__;

        my $dtype = $impl-><M::c|DOMImplementation.createDocumentType>
                             ('type', 'pub', 'sys');

        $test->id ('created');
        $test->assert_isa (my $i2 = $dtype-><AG::x|DocumentType.implementation>,
                           <IFName::c|DOMImplementation>);
        $test->assert_equals ($i2, $impl);

        $test->id ('appended');
        my $doc = $impl-><M::c|DOMImplementation.createDocument>;
        $doc-><M::Node.appendChild> ($dtype);
        $test->assert_isa (my $i3 = $dtype-><AG::x|DocumentType.implementation>,
                           <IFName::c|DOMImplementation>);
        $test->assert_equals ($i3, $impl);

  @Method:
    @@ForCheck: ManakaiDOM|ForClass
    @@Name: lookupPrefix
    @@enDesc:
      Looks up the namespace prefix associated to the given
      namespace URI, starting from this node.
    @@DOMMain:isNamespaceAware: 1
    @@Param:
      @@@Name: namespaceURI
      @@@Type: DOMString
      @@@dis:actualType: ManakaiDOM|ManakaiDOMNamespaceURI
      @@@enDesc:
        The namespace URI to look for.
    @@Return:
      @@@Type: DOMString
      @@@enDesc:
        An associated namespace prefix.
      @@@nullCase:
        @@@@enDesc:
          No namespace prefix is found.  For <IF::x|DocumentType>
          node the method always returns <DOM::null>.
      @@@PerlDef: $r = null;

    @@Test:
      @@@QName: DTDef.lookupPrefix.test
      @@@PerlDef:
        my $dtd;
        __CODE{newDoctypeForTest}__;

        $test->assert_null ($dtd-><M::Node.lookupPrefix> ('abcdefg'));

    @@Test:
      @@@QName: DocumentType.lookupPrefix.test
      @@@PerlDef:
        my $impl;
        __CODE{t|createDOMImplForTest:: $impl => $impl}__;

        my $dtype = $impl-><M::c|DOMImplementation.createDocumentType>
                             ('type', 'pub', 'sys');
        $test->assert_null ($dtype-><M::Node.lookupPrefix> ('about:'));
  
  @Method:
    @@ForCheck: ManakaiDOM|ForClass
    @@Name: getFeature
    @@enDesc:
      Returns a specialized object that implements the specialized
      interfaces of the specified feature and version.
    @@Param:
      @@@Name: feature
      @@@Type: DOMString
      @@@dis:actualType: f|FeatureNameString
      @@@enDesc:
        The feature name to request.
      @@@InCase:
        @@@@Label:
          @@@@@lang:en
          @@@@@@:
            Feature name preceded by a <CHAR::PLUS SIGN>
    @@Param:
      @@@Name: version
      @@@Type: DOMString
      @@@dis:actualType: f|FeatureVersionString
      @@@enDesc:
        The feature version to request.
      @@@nullCase:
        @@@@enDesc:
          No specific version is requested.
    @@Return:
      @@@Type: DOMMain|DOMObject
      @@@enDesc:
        An object implementing the specialized interface.
        Note that the specialized object may or may nor
        implement the <IF::t|Node> interface.
      @@@nullCase:
        @@@@enDesc:
          There is no object available that implements the 
          specialized interface.
      @@@PerlDef:
        $feature =~ s/^\+//;
        if ($Message::DOM::ClassFeature{ref $self}->{$feature}->{$version}) {
          ## This class
          $r = $self;
        } else {
          ## Document type dependent classes
            ## TODO:
          ## Document type independent classes
          CLASS: for my $class (grep {
            $Message::DOM::ManakaiDOMDocumentType::CompatClass{$_}
          } keys %Message::DOM::ManakaiDOMDocumentType::CompatClass) {
            if ($Message::DOM::ClassFeature{$class}->{$feature}->{$version}) {
              __CODE{DOMCore|getNodeRef::
                $object => {$self->{<H::mn:node>}},
                $ref => $r,
                $class => $class,
              }__;
              last CLASS;
            }
          }
        }

    @@Test:
      @@@QName: DTDef.getFeature.core.1.0.test
      @@@PerlDef:
        my $dtd;
        __CODE{newDoctypeForTest}__;

        my $obj = $dtd-><M::Node.getFeature> (Core => '1.0');
        $test->assert_isa ($obj, <IFName::t|Node||ManakaiDOM|ManakaiDOM1>);
    @@Test:
      @@@QName: DTDef.getFeature.core.2.0.test
      @@@PerlDef:
        my $dtd;
        __CODE{newDoctypeForTest}__;

        my $obj = $dtd-><M::Node.getFeature> (Core => '2.0');
        $test->assert_isa ($obj, <IFName::t|Node||ManakaiDOM|ManakaiDOM2>);
    @@Test:
      @@@QName: DTDef.getFeature.core.3.0.test
      @@@PerlDef:
        my $dtd;
        __CODE{newDoctypeForTest}__;

        my $obj = $dtd-><M::Node.getFeature> (Core => '3.0');
        $test->assert_isa
                 ($obj, <IFName::t|Node||ManakaiDOM|ManakaiDOM3>);
    @@Test:
      @@@QName: DTDef.getFeature.xml.1.0.test
      @@@PerlDef:
        my $dtd;
        __CODE{newDoctypeForTest}__;

        my $obj = $dtd-><M::Node.getFeature> (XML => '1.0');
        $test->assert_isa
                 ($obj, <IFName::x|DocumentType||ManakaiDOM|ManakaiDOM1>);
    @@Test:
      @@@QName: DTDef.getFeature.xml.2.0.test
      @@@PerlDef:
        my $dtd;
        __CODE{newDoctypeForTest}__;

        my $obj = $dtd-><M::Node.getFeature> (XML => '2.0');
        $test->assert_isa
                 ($obj, <IFName::x|DocumentType||ManakaiDOM|ManakaiDOM2>);
    @@Test:
      @@@QName: DTDef.getFeature.xml.3.0.test
      @@@PerlDef:
        my $dtd;
        __CODE{newDoctypeForTest}__;

        my $obj = $dtd-><M::Node.getFeature> (XML => '3.0');
        $test->assert_isa
                 ($obj, <IFName::x|DocumentType||ManakaiDOM|ManakaiDOM3>);
    @@Test:
      @@@QName: DTDef.getFeature.xdoctype.3.0.test
      @@@PerlDef:
        my $dtd;
        __CODE{newDoctypeForTest}__;

        my $obj = $dtd-><M::Node.getFeature> (<Q::fe|XDoctype> => '3.0');
        $test->assert_isa ($obj, <IFName::d|DocumentTypeDefinition>);
    @@Test:
      @@@QName: DTDef.getFeature.xdoctypedecl.3.0.test
      @@@PerlDef:
        my $dtd;
        __CODE{newDoctypeForTest}__;

        my $obj = $dtd-><M::Node.getFeature>
                          (<Q::fe|XDoctypeDeclaration> => '3.0');
        $test->assert_isa ($obj, <IFName::d|DocumentTypeDeclaration>);

    @@Test:
      @@@QName: DocumentType.getFeature.core.1.0.test
      @@@PerlDef:
        my $impl;
        __CODE{t|createDOMImplForTest:: $impl => $impl}__;

        my $dtype = $impl-><M::c|DOMImplementation.createDocumentType>
                             ('type', 'pub', 'sys');
        my $obj = $dtype-><M::Node.getFeature> (Core => '1.0');

        $test->assert_isa ($obj, <IFName::t|Node||ManakaiDOM|ManakaiDOM1>);
        $test->assert_isa
                 ($obj, <IFName::x|DocumentType||ManakaiDOM|ManakaiDOM1>);
    @@Test:
      @@@QName: DocumentType.getFeature.core.2.0.test
      @@@PerlDef:
        my $impl;
        __CODE{t|createDOMImplForTest:: $impl => $impl}__;

        my $dtype = $impl-><M::c|DOMImplementation.createDocumentType>
                             ('type', 'pub', 'sys');
        my $obj = $dtype-><M::Node.getFeature> (Core => '2.0');

        $test->assert_isa ($obj, <IFName::t|Node||ManakaiDOM|ManakaiDOM2>);
        $test->assert_isa
                 ($obj, <IFName::x|DocumentType||ManakaiDOM|ManakaiDOM2>);
    @@Test:
      @@@QName: DocumentType.getFeature.core.3.0.test
      @@@PerlDef:
        my $impl;
        __CODE{t|createDOMImplForTest:: $impl => $impl}__;

        my $dtype = $impl-><M::c|DOMImplementation.createDocumentType>
                             ('type', 'pub', 'sys');
        my $obj = $dtype-><M::Node.getFeature> (Core => '3.0');

        $test->assert_isa ($obj, <IFName::t|Node||ManakaiDOM|ManakaiDOM3>);
        $test->assert_isa
                 ($obj, <IFName::x|DocumentType||ManakaiDOM|ManakaiDOM3>);
    @@Test:
      @@@QName: DocumentType.getFeature.xml.1.0.test
      @@@PerlDef:
        my $impl;
        __CODE{t|createDOMImplForTest:: $impl => $impl}__;

        my $dtype = $impl-><M::c|DOMImplementation.createDocumentType>
                             ('type', 'pub', 'sys');
        my $obj = $dtype-><M::Node.getFeature> (XML => '1.0');

        $test->assert_isa
                 ($obj, <IFName::x|DocumentType||ManakaiDOM|ManakaiDOM1>);
    @@Test:
      @@@QName: DocumentType.getFeature.xml.2.0.test
      @@@PerlDef:
        my $impl;
        __CODE{t|createDOMImplForTest:: $impl => $impl}__;

        my $dtype = $impl-><M::c|DOMImplementation.createDocumentType>
                             ('type', 'pub', 'sys');
        my $obj = $dtype-><M::Node.getFeature> (XML => '2.0');

        $test->assert_isa
                 ($obj, <IFName::x|DocumentType||ManakaiDOM|ManakaiDOM2>);
    @@Test:
      @@@QName: DocumentType.getFeature.xml.3.0.test
      @@@PerlDef:
        my $impl;
        __CODE{t|createDOMImplForTest:: $impl => $impl}__;

        my $dtype = $impl-><M::c|DOMImplementation.createDocumentType>
                             ('type', 'pub', 'sys');
        my $obj = $dtype-><M::Node.getFeature> (XML => '3.0');

        $test->assert_isa
                 ($obj, <IFName::x|DocumentType||ManakaiDOM|ManakaiDOM3>);

  @Attr:
    @@ForCheck: ManakaiDOM|ForClass
    @@Name: nodeType
    @@enDesc:
      The type of the node.
    @@Type: idl|unsignedShort||ManakaiDOM|all
    @@dis:actualType: t|NodeType
    @@Get:
      @@@InCase:
        @@@@Label:
          <C::t|Node.DOCUMENT_TYPE_NODE>
        @@@@enDesc:
          The node is a <IF::x|DocumentType>.
      @@@disDef:
        @@@@DISLang:constValue: t|Node.DOCUMENT_TYPE_NODE

    @@Test:
      @@@QName: DTDef.nodeType.get.test
      @@@PerlDef:
        my $dtd;
        __CODE{newDoctypeForTest}__;

        $test->assert_num_equals
                 (actual_value => $dtd-><AG::Node.nodeType>,
                  expected_value => <C::Node.DOCUMENT_TYPE_NODE>);

  @Attr:
    @@ForCheck: ManakaiDOM|ForClass
    @@Name: textContent
    @@enDesc:
      The text content of the node and its descendants.
    @@Type: DOMString
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          The text content of the node is defined to be <DOM::null>.
      @@@PerlDef: $r = null;
    @@Set:
      @@@enDesc:
        Setting this attribute has no effect.
      @@@c:reports:
        @@@@@: c|setting-node-value-no-effect
        @@@@enDesc:
          Setting the attribute value has no effect, since the
          node value is defined as <DOM::null>.
        @@@@For: ManakaiDOM|ManakaiDOM
      @@@disDef:
        @@@@DISPerl:cloneCode: t|ManakaiDOMNode.nodeValue.set

    @@Test:
      @@@QName: DTDef.textContent.get.test
      @@@PerlDef:
        my $dtd;
        __CODE{newDoctypeForTest}__;

        $test->assert_null ($dtd-><AG::Node.textContent>);
    @@Test:
      @@@QName: DTDef.textContent.set.test
      @@@PerlDef:
        my $dtd;
        __CODE{newDoctypeForTest}__;

        $test->id ('set.non.null');
        $dtd-><AS::Node.textContent> ('abcdefg');
        $test->assert_null ($dtd-><AG::Node.textContent>);

        $test->id ('set.null');
        $dtd-><AS::Node.textContent> (null);
        $test->assert_null ($dtd-><AG::Node.textContent>);

  @CAttr:
    @@Name: baseURI
    @@enDesc:
      The base URI of the node, i.e. the base URI of the document.
    @@Type: DOMString
    @@dis:actualType: ManakaiDOM|ManakaiDOMURI
    @@Get:
      @@@enDesc:
        The base DOM URI of the node.
      @@@nullCase:
        @@@@enDesc:
          If no base DOM URI is available on the document or 
          the node does not belong to any document.
      @@@PerlDef:
        __DEEP{
          $r = $self-><AG::DocumentTypeDeclaration.declarationBaseURI>;
        }__;

    @@Test:
      @@@ForCheck: !ManakaiDOM|all
      @@@enImplNote:
        {TODO::
          Enable this test after appendchild(doctype) is really implemented
        }
      @@@QName: Doctype.baseURI.test
      @@@PerlDef:
        my $impl;
        __CODE{t|createDOMImplForTest:: $impl => $impl}__;

        my $dtype = $impl-><M::c|DOMImplementation.createDocumentType>
                             ('type', 'pub', 'sys');
  
        $test->id ('initial');
        $test->assert_null ($dtype-><AG::Node.baseURI>);

        my $doc = $impl-><M::c|DOMImplementation.createDocument>;
        $doc-><M::Node.appendChild> ($dtype);
        $doc-><AS::Document.documentURI> (q<http://doc.test/>);
        $test->assert_equals ($dtype-><AG::Node.ownerDocument>,
                              $doc);

        $test->id ('doc');
        $test->assert_equals
                 ($dtype-><AG::Node.baseURI>,
                  q<http://doc.test/>);

  @CMethod:
    @@Name: appendChild
    @@enDesc:
      Adds a node to the end of the list of children of the node.
      If that node is already in the tree, it is first removed.
    @@Param:
      @@@Name: newChild
      @@@Type: Node
      @@@enDesc:
        The node to add.
      @@@InCase:
        @@@@Type: DocumentFragment
        @@@@enDesc:
          The entire contents of the document fragment are
          moved into the child list of the node.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node added.  If the <P::newChild> node is a <IF::DocumentFragment>
        node, then the <P::newChild> node <kwd:MUST> be returned.
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_BAD_TYPE
        @@@@enDesc:
          If the node is of a type that does not allow children of
          the type of the <P::newChild> node.
 
          If the <A::Document.strictErrorChecking> is set to <DOM::false>,
          this exception <kwd:MAY-NOT> be thrown.
      @@@dx:raises:
        @@@@@: c|DIFFERENT_DOCUMENT_ERR
        @@@@enDesc:
          If the <P::newChild> node was created from a different
          document than the one to which the node was created or
          the node does not belong to any document.

          If the <A::Document.strictErrorChecking> is set to <DOM::false>,
          this exception <kwd:MAY-NOT> be thrown.
      @@@dx:raises: 
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the node is read-only.

          If the <A::Document.strictErrorChecking> is set to <DOM::false>,
          this exception <kwd:MAY-NOT> be thrown.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_SRC_PARENT
        @@@@enDesc:
          If the previous parent of the <P::newChild> node is read-only
          <SRC::DOM 2 Errata, DOM 3>.

          If the <A::Document.strictErrorChecking> is set to <DOM::false>,
          this exception <kwd:MAY-NOT> be thrown.
      @@@PerlDef:
        my $self_od = $self-><AG::Node.ownerDocument>;
        unless ($self_od) {
          __EXCEPTION{c|DIFFERENT_DOCUMENT_ERR::
            MDOMX|param-name => 'newChild',
            c|node => {$newChild},
          }__;
        }
        __CODE{t|appendChildImpl1::
          $self => $self, $self_od => $self_od,
          $newChild => $newChild,
          $r => $r,
          $allowedNodeTypes => {{
            <C::Node.PROCESSING_INSTRUCTION_NODE> => true,
          }},
        }__;

  @CMethod:
    @@Name: insertBefore
    @@enDesc:
      Inserts a node before the existing child node of the node.

      Inserting a node before itself is implementation dependent.
    @@Param:
      @@@Name: newChild
      @@@Type: Node
      @@@enDesc:
        The node to insert.  If the <P::newChild> is already in 
        the tree, it is first removed.
      @@@InCase:
        @@@@Type: DocumentFragment
        @@@@enDesc:
          All of children of the <P::newChild> node are inserted,
          in the same order, before <P::refChild>.
    @@Param:
      @@@Name: refChild
      @@@Type: Node
      @@@enDesc:
        The reference node, i.e. the node before which the new node
        must be inserted.
      @@@nullCase:
        @@@@enDesc:
          The <P::newChild> node is inserted at the end of the list
          of children.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node being inserted.
      @@@enImplNote:
        What is returned if <P::newChild> is a <IF::DocumentFragment>?
        See also <M::Node.appendChild>'s return value.
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_BAD_TYPE
        @@@@enDesc:
          If the node is of a type that does not allow children of
          the type of the <P::newChild> node.
      @@@dx:raises:
        @@@@@: c|DIFFERENT_DOCUMENT_ERR
        @@@@enDesc:
          If the <P::newChild> node was created from a different
          document than the one that created the node.
        @@@@enImplNote:
          The DOM specification ignores the fact that <IF::Document>s
          and <IF::x|DocumentType>s are created from 
          <IF::c|DOMImplementation> :-)
      @@@dx:raises: 
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the node is read-only.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_SRC_PARENT
        @@@@enDesc:
          If the previous parent of the <P::newChild> node is read-only
          <SRC::DOM 1 SE, DOM 2, 3>.
      @@@dx:raises:
        @@@@@: c|NOT_CHILD_ERR
        @@@@enDesc:
          If the <P::refChild> node is not a child of the node.
      @@@c:reports:
        @@@@@: t|insert-before-itself
        @@@@enDesc:
          If the <P::newChild> node is same as the <P::refChild> node.
          Then, the result is implementation dependent.
        @@@@For: ManakaiDOM|ManakaiDOM
      @@@PerlDef:
        my $self_od = $self-><AG::Node.ownerDocument>;
        unless ($self_od) {
          __EXCEPTION{c|DIFFERENT_DOCUMENT_ERR::
            MDOMX|param-name => 'newChild',
            c|node => {$newChild},
          }__;
        }
        __CODE{t|insertBeforeImpl1::
          $self => $self, $self_od => $self_od,
          $newChild => $newChild, $refChild => $refChild,
          $r => $r,
          $allowedNodeTypes => {{
            <C::Node.PROCESSING_INSTRUCTION_NODE> => true,
          }},
        }__;

  @CMethod:
    @@Name: replaceChild
    @@enDesc:
      Replaces a child node with another node.

      Replacing a node with itself is implementation dependent <SRC::DOM3>.
    @@Param:
      @@@Name: newChild
      @@@Type: Node
      @@@enDesc:
        The new node to put in the child list.

        If the <P::newChild> node is already in the tree,
        it is first removed.
      @@@InCase:
        @@@@Type: DocumentFragment
        @@@@enDesc:
          The <P::oldChild> node is replaced by all of the 
          <IF::DocumentFragment> children, which are inserted
          in the same order <SRC::DOM1 SE, DOM2, DOM3>.
    @@Param:
      @@@Name: oldChild
      @@@Type: Node
      @@@enDesc:
        The node being replaced in the list.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node replaced.
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_BAD_TYPE
        @@@@enDesc:
          If the node is of a type that does not allow children of
          the type of the <P::newChild> node.
      @@@dx:raises:
        @@@@@: c|DIFFERENT_DOCUMENT_ERR
        @@@@enDesc:
          If the <P::newChild> node was created from a different
          document than the one that created the node.
        @@@@enImplNote:
          The DOM specification ignores the fact that <IF::Document>s
          and <IF::x|DocumentType>s are created from 
          <IF::c|DOMImplementation> :-)
      @@@dx:raises: 
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the node is read-only.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_SRC_PARENT
        @@@@enDesc:
          If the previous parent of the <P::newChild> node is read-only
          <SRC::DOM1 SE, DOM2, DOM3>.
      @@@dx:raises:
        @@@@@: c|NOT_CHILD_ERR
        @@@@enDesc:
          If the <P::oldChild> node is not a child of the node.
      @@@c:reports:
        @@@@@: t|replaced-by-itself
        @@@@enDesc:
          If the <P::newChild> node is same as the <P::oldChild> node.
          Then, the result is implementation dependent.
        @@@@For: ManakaiDOM|ManakaiDOM
      @@@PerlDef:
        my $self_od = $self-><AG::Node.ownerDocument>;
        unless ($self_od) {
          __EXCEPTION{c|DIFFERENT_DOCUMENT_ERR::
            MDOMX|param-name => 'newChild',
            c|node => {$newChild},
          }__;
        }
        __CODE{t|replaceChildImpl1::
          $self => $self, $self_od => $self_od,
          $newChild => $newChild, $refChild => $oldChild,
          $r => $r,
          $allowedNodeTypes => {{
            <C::Node.PROCESSING_INSTRUCTION_NODE> => true,
          }},
        }__;

    @@ResourceDef:
      @@@DISCore:resourceType:
        @@@@@: dis|MultipleResource
        @@@@ForCheck:
          ManakaiDOM|ForClass
          !t|ForAppendChild !t|ForInsertBefore !t|ForReplaceChild
      @@@resourceFor: t|ForAppendChild
      @@@resourceFor: t|ForInsertBefore
      @@@resourceFor: t|ForReplaceChild

      @@@QName:
        @@@@@: t|appendChildImpl1
        @@@@ForCheck: t|ForAppendChild
      @@@QName:
        @@@@@: t|insertBeforeImpl1
        @@@@ForCheck: t|ForInsertBefore
      @@@QName:
        @@@@@: t|replaceChildImpl1
        @@@@ForCheck: t|ForReplaceChild

      @@@DISCore:resourceType: DISPerl|BlockCode

      @@@enDesc:
        <Perl::$self>, <Perl::$newChild>, <Perl::$refChild> (insertBefore
        or replaceChild : <CODE::oldChild>),
        <Perl::$r>, <Perl::$allowedNodeTypes>, <Perl::$self_od>.
  
      @@@PerlDef:
        __DEEP{
          my $strict = $self_od-><AG::Document.strictErrorChecking>;
          my $child_od = $newChild-><AG::Node.ownerDocument>;
          my $child_nt = $newChild-><AG::Node.nodeType>;

          ## -- Node Type check
          my @new_child;
          if ($allowedNodeTypes->{$child_nt}) {
            push @new_child, $newChild;
          } elsif ($child_nt == <C::Node.DOCUMENT_FRAGMENT_NODE>) {
            for my $cn (@{$newChild-><AG::Node.childNodes>}) {
              unless ($allowedNodeTypes->{$cn-><AG::Node.nodeType>}) {
                __UNDEEP{__EXCEPTION{MDOMX|HIERARCHY_BAD_TYPE::
                  MDOMX|param-name => 'newChild',
                  c|node => {$newChild},
                }__}__;
              }
              push @new_child, $cn;
            }
          } else {
            __UNDEEP{__EXCEPTION{MDOMX|HIERARCHY_BAD_TYPE::
              MDOMX|param-name => 'newChild',
              c|node => {$newChild},
            }__}__;
          }

          my $nc_parent = @new_child ? $new_child[0]-><AG::Node.parentNode>
                                     : null;
          if ($strict) {
            ## -- Wrong-document check
            unless ($self_od eq $child_od) {
              __UNDEEP{__EXCEPTION{c|DIFFERENT_DOCUMENT_ERR::
                MDOMX|param-name => 'newChild',
                c|node => {$newChild},
              }__}__;
            }

            ## -- Read-onlyness check
            if ($self->{<H::mn|node>}->{<H::c|read-only>}) {
              __UNDEEP{__EXCEPTION{MDOMX|NOMOD_THIS::
              }__}__;
            }
            if (@new_child) {
              if ($nc_parent and
                  $nc_parent->{<H::mn|node>}->{<H::c|read-only>}) {
                __UNDEEP{__EXCEPTION{MDOMX|NOMOD_SRC_PARENT::
                }__}__;
              }
            }
          }

          ## -- Insert at...
          my $index = -1; # last
          __FOR{!t:ForAppendChild:: # t:ForAppendChild & t:ForReplaceChild
            if (defined $refChild) {
              if ($refChild eq $newChild) {
                __FOR{t:ForInsertBefore::
                  __UNDEEP{__c|ERROR{t|insert-before-itself::
                    c|relatedData => {$refChild},
                  }__}__;
                }__;
                __FOR{t:ForReplaceChild::
                  __UNDEEP{__c|ERROR{t|replace-by-itself::
                    c|relatedData => {$refChild},
                  }__}__;
                }__;
              }

              my $cns = $self-><AG::Node.childNodes>;
              my $cnsl = @$cns;
              C: {
                $index = 0;
                for my $i (0..($cnsl-1)) {
                  my $cn = $cns->[$i];
                  if ($cn eq $refChild) {
                    $index += $i;
                    last C;
                  } elsif ($cn eq $newChild) {
                    $index = -1; # offset
                  }
                }
                __FOR{t:ForInsertBefore::
                  __UNDEEP{__EXCEPTION{c|NOT_CHILD_ERR::
                    MDOMX|param-name => 'refChild',
                    c|node => {$refChild},
                  }__}__;
                }__;
                __FOR{t:ForReplaceChild::
                  __UNDEEP{__EXCEPTION{c|NOT_CHILD_ERR::
                    MDOMX|param-name => 'oldChild',
                    c|node => {$refChild},
                  }__}__;
                }__;
              } # C
            } else { # |oldChild| is not defined
              __FOR{t:ForReplaceChild::
                __UNDEEP{__EXCEPTION{c|NOT_CHILD_ERR::
                  MDOMX|param-name => 'oldChild',
                  c|node => {$refChild},
                }__}__;
              }__;
            }
          }__; # FOR !t:ForAppendChild

          ## -- Removes from parent
          if ($nc_parent) {
            if ($child_nt == <C::Node.DOCUMENT_FRAGMENT_NODE>) {
              $newChild->{<H::mn|node>}->{<H::infoset|children>} = [];
            } else {
              RP: for my $i (0..$#{$nc_parent->{<H::mn|node>}
                                             ->{<H::infoset|children>}}) {
                if ($nc_parent->{<H::mn|node>}->{<H::infoset|children>}->[$i]
                              ->{<H::mn|nodeID>}
                        eq $new_child[0]->{<H::mn|node>}->{<H::mn|nodeID>}) {
                  splice @{$nc_parent->{<H::mn|node>}->{<H::infoset|children>}},
                         $i, 1, ();
                  last RP;
                }
              } # RP
            }
          }

          for my $nc (@new_child) {
            my $ncs = $nc->{<H::mn|node>};
            delete $ncs->{<H::infoset|parent>};
            $self->{<H::mn|node>}-><M::NodeStem.importTree> ($ncs);
            $ncs->{<H::infoset|parent>} = $self->{<H::mn|node>};
          }

          __FOR{t:ForAppendChild::
            ## -- Adds to children list
            push @{$self->{<H::mn|node>}->{<H::infoset|children>}},
                 map {$_->{<H::mn|node>}} @new_child;
            $r = $newChild;
          }__;

          __FOR{t:ForInsertBefore::
            ## -- Adds to children list
            if ($index == -1) {
              push @{$self->{<H::mn|node>}->{<H::infoset|children>}},
                   map {$_->{<H::mn|node>}} @new_child;
            } else {
              splice @{$self->{<H::mn|node>}->{<H::infoset|children>}},
                     $index, 0, map {$_->{<H::mn|node>}} @new_child;
            }
            $r = $newChild;
          }__;

          __FOR{t:ForReplaceChild::
            ## -- Replaces the node
            splice @{$self->{<H::mn|node>}->{<H::infoset|children>}},
                   $index, 1, map {$_->{<H::mn|node>}} @new_child;
            delete $refChild->{<H::mn|node>}->{<H::infoset|parent>};
            $refChild->{<H::mn|node>}-><M::NodeStem.orphanate>;
            $r = $refChild;
          }__;
        }__;

    @@Test:
      @@@QName: Doctype.appendChild.1.test
      @@@PerlDef:
        my $doc;
        __CODE{t|createDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createDocumentTypeDefinition>
                           ('dt');
        my $pi = $doc-><M::Document.createProcessingInstruction> ('pi');

        my $return = $dtd-><M::Node.appendChild> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::t|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::x|ProcessingInstruction>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('treeid');
        $test->assert_equals
                 ($item->{<H::mn|node>}->{<H::mn|treeID>},
                  $dtd->{<H::mn|node>}->{<H::mn|treeID>});

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: Doctype.insertBefore.1.test
      @@@PerlDef:
        my $doc;
        __CODE{t|createDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createDocumentTypeDefinition>
                           ('dt');
        my $pi = $doc-><M::Document.createProcessingInstruction> ('pi');

        my $return = $dtd-><M::Node.insertBefore> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::t|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::x|ProcessingInstruction>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('treeid');
        $test->assert_equals
                 ($item->{<H::mn|node>}->{<H::mn|treeID>},
                  $dtd->{<H::mn|node>}->{<H::mn|treeID>});

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);

    @@Test:
      @@@QName: Doctype.appendChild.has.parent.1.test
      @@@PerlDef:
        my $doc;
        __CODE{t|createDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createDocumentTypeDefinition>
                           ('dt');

        my $piparent = $doc-><M::Document.createElementNS> (null, 'e');
        my $pi = $doc-><M::Document.createProcessingInstruction> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.appendChild> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::t|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::x|ProcessingInstruction>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('treeid');
        $test->assert_equals
                 ($item->{<H::mn|node>}->{<H::mn|treeID>},
                  $dtd->{<H::mn|node>}->{<H::mn|treeID>});

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: Doctype.insertBefore.has.parent.1.test
      @@@PerlDef:
        my $doc;
        __CODE{t|createDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createDocumentTypeDefinition>
                           ('dt');

        my $piparent = $doc-><M::Document.createElementNS> (null, 'e');
        my $pi = $doc-><M::Document.createProcessingInstruction> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.insertBefore> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::t|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::x|ProcessingInstruction>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('treeid');
        $test->assert_equals
                 ($item->{<H::mn|node>}->{<H::mn|treeID>},
                  $dtd->{<H::mn|node>}->{<H::mn|treeID>});

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi);

    @@Test:
      @@@QName: Doctype.appendChild.documentfragment.1.test
      @@@PerlDef:
        my $doc;
        __CODE{t|createDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createDocumentTypeDefinition>
                           ('dt');

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createProcessingInstruction> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.appendChild> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::t|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::x|ProcessingInstruction>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('treeid');
        $test->assert_equals
                 ($item->{<H::mn|node>}->{<H::mn|treeID>},
                  $dtd->{<H::mn|node>}->{<H::mn|treeID>});

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: Doctype.insertBefore.documentfragment.1.test
      @@@PerlDef:
        my $doc;
        __CODE{t|createDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createDocumentTypeDefinition>
                           ('dt');

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createProcessingInstruction> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.insertBefore> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::t|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::x|ProcessingInstruction>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('treeid');
        $test->assert_equals
                 ($item->{<H::mn|node>}->{<H::mn|treeID>},
                  $dtd->{<H::mn|node>}->{<H::mn|treeID>});

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: Doctype.replaceChild.documentfragment.1.test
      @@@PerlDef:
        my $doc;
        __CODE{t|createDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createDocumentTypeDefinition>
                           ('dt');
        my $pi0 = $doc-><M::Document.createProcessingInstruction> ('pi0');
        $dtd-><M::Node.appendChild> ($pi0);

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createProcessingInstruction> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.replaceChild> ($piparent, $pi0);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::t|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::x|ProcessingInstruction>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('treeid');
        $test->assert_equals
                 ($item->{<H::mn|node>}->{<H::mn|treeID>},
                  $dtd->{<H::mn|node>}->{<H::mn|treeID>});

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi0);

    @@Test:
      @@@QName: Doctype.appendChild.documentfragment.2.test
      @@@enDesc:
        Empty document fragment.
      @@@PerlDef:
        my $doc;
        __CODE{t|createDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createDocumentTypeDefinition>
                           ('dt');

        my $piparent = $doc-><M::Document.createDocumentFragment>;

        my $return = $dtd-><M::Node.appendChild> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 0);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: Doctype.insertBefore.documentfragment.2.test
      @@@enDesc:
        Empty document fragment.
      @@@PerlDef:
        my $doc;
        __CODE{t|createDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createDocumentTypeDefinition>
                           ('dt');

        my $piparent = $doc-><M::Document.createDocumentFragment>;

        my $return = $dtd-><M::Node.insertBefore> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 0);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: Doctype.replaceChild.documentfragment.2.test
      @@@enDesc:
        Empty document fragment.
      @@@PerlDef:
        my $doc;
        __CODE{t|createDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createDocumentTypeDefinition>
                           ('dt');
        my $pi0 = $doc-><M::Document.createProcessingInstruction> ('pi0');
        $dtd-><M::Node.appendChild> ($pi0);

        my $piparent = $doc-><M::Document.createDocumentFragment>;

        my $return = $dtd-><M::Node.replaceChild> ($piparent, $pi0);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 0);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi0);

    @@Test:
      @@@QName: Doctype.appendChild.documentfragment.3.test
      @@@enDesc:
        Three PIs in document fragment.
      @@@PerlDef:
        my $doc;
        __CODE{t|createDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createDocumentTypeDefinition>
                           ('dt');

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createProcessingInstruction> ('pi');
        my $pi2 = $doc-><M::Document.createProcessingInstruction> ('pi2');
        my $pi3 = $doc-><M::Document.createProcessingInstruction> ('pi3');
        $piparent-><M::Node.appendChild> ($pi);
        $piparent-><M::Node.appendChild> ($pi2);
        $piparent-><M::Node.appendChild> ($pi3);

        my $return = $dtd-><M::Node.appendChild> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 3);

        my $item = $child-><M::t|NodeList.item> (0);
        my $item2 = $child-><M::t|NodeList.item> (1);
        my $item3 = $child-><M::t|NodeList.item> (2);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);
        $test->id ('child.item.node2');
        $test->assert_isa ($item2, <IFName::Node>);
        $test->id ('child.item.node3');
        $test->assert_isa ($item3, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::x|ProcessingInstruction>);
        $test->id ('child.item.pi2');
        $test->assert_isa ($item2, <IFName::x|ProcessingInstruction>);
        $test->id ('child.item.pi3');
        $test->assert_isa ($item3, <IFName::x|ProcessingInstruction>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);
        $test->id ('child.item.equals2');
        $test->assert_equals ($item2, $pi2);
        $test->id ('child.item.equals3');
        $test->assert_equals ($item3, $pi3);

        $test->id ('treeid');
        $test->assert_equals
                 ($item->{<H::mn|node>}->{<H::mn|treeID>},
                  $dtd->{<H::mn|node>}->{<H::mn|treeID>});
        $test->id ('treeid2');
        $test->assert_equals
                 ($item2->{<H::mn|node>}->{<H::mn|treeID>},
                  $dtd->{<H::mn|node>}->{<H::mn|treeID>});
        $test->id ('treeid3');
        $test->assert_equals
                 ($item3->{<H::mn|node>}->{<H::mn|treeID>},
                  $dtd->{<H::mn|node>}->{<H::mn|treeID>});

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi3);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);
        $test->id ('parent2');
        my $parent2 = $item2-><AG::Node.parentNode>;
        $test->assert_equals ($parent2, $dtd);
        $test->id ('parent3');
        my $parent3 = $item3-><AG::Node.parentNode>;
        $test->assert_equals ($parent3, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: Doctype.insertBefore.documentfragment.3.test
      @@@enDesc:
        Three PIs in document fragment.
      @@@PerlDef:
        my $doc;
        __CODE{t|createDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createDocumentTypeDefinition>
                           ('dt');

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createProcessingInstruction> ('pi');
        my $pi2 = $doc-><M::Document.createProcessingInstruction> ('pi2');
        my $pi3 = $doc-><M::Document.createProcessingInstruction> ('pi3');
        $piparent-><M::Node.appendChild> ($pi);
        $piparent-><M::Node.appendChild> ($pi2);
        $piparent-><M::Node.appendChild> ($pi3);

        my $return = $dtd-><M::Node.insertBefore> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 3);

        my $item = $child-><M::t|NodeList.item> (0);
        my $item2 = $child-><M::t|NodeList.item> (1);
        my $item3 = $child-><M::t|NodeList.item> (2);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);
        $test->id ('child.item.node2');
        $test->assert_isa ($item2, <IFName::Node>);
        $test->id ('child.item.node3');
        $test->assert_isa ($item3, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::x|ProcessingInstruction>);
        $test->id ('child.item.pi2');
        $test->assert_isa ($item2, <IFName::x|ProcessingInstruction>);
        $test->id ('child.item.pi3');
        $test->assert_isa ($item3, <IFName::x|ProcessingInstruction>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);
        $test->id ('child.item.equals2');
        $test->assert_equals ($item2, $pi2);
        $test->id ('child.item.equals3');
        $test->assert_equals ($item3, $pi3);

        $test->id ('treeid');
        $test->assert_equals
                 ($item->{<H::mn|node>}->{<H::mn|treeID>},
                  $dtd->{<H::mn|node>}->{<H::mn|treeID>});
        $test->id ('treeid2');
        $test->assert_equals
                 ($item2->{<H::mn|node>}->{<H::mn|treeID>},
                  $dtd->{<H::mn|node>}->{<H::mn|treeID>});
        $test->id ('treeid3');
        $test->assert_equals
                 ($item3->{<H::mn|node>}->{<H::mn|treeID>},
                  $dtd->{<H::mn|node>}->{<H::mn|treeID>});

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi3);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);
        $test->id ('parent2');
        my $parent2 = $item2-><AG::Node.parentNode>;
        $test->assert_equals ($parent2, $dtd);
        $test->id ('parent3');
        my $parent3 = $item3-><AG::Node.parentNode>;
        $test->assert_equals ($parent3, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: Doctype.replaceChild.documentfragment.3.test
      @@@enDesc:
        Three PIs in document fragment.
      @@@PerlDef:
        my $doc;
        __CODE{t|createDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createDocumentTypeDefinition>
                           ('dt');
        my $pi0 = $doc-><M::Document.createProcessingInstruction> ('pi0');
        $dtd-><M::Node.appendChild> ($pi0);

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createProcessingInstruction> ('pi');
        my $pi2 = $doc-><M::Document.createProcessingInstruction> ('pi2');
        my $pi3 = $doc-><M::Document.createProcessingInstruction> ('pi3');
        $piparent-><M::Node.appendChild> ($pi);
        $piparent-><M::Node.appendChild> ($pi2);
        $piparent-><M::Node.appendChild> ($pi3);

        my $return = $dtd-><M::Node.replaceChild> ($piparent, $pi0);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 3);

        my $item = $child-><M::t|NodeList.item> (0);
        my $item2 = $child-><M::t|NodeList.item> (1);
        my $item3 = $child-><M::t|NodeList.item> (2);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);
        $test->id ('child.item.node2');
        $test->assert_isa ($item2, <IFName::Node>);
        $test->id ('child.item.node3');
        $test->assert_isa ($item3, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::x|ProcessingInstruction>);
        $test->id ('child.item.pi2');
        $test->assert_isa ($item2, <IFName::x|ProcessingInstruction>);
        $test->id ('child.item.pi3');
        $test->assert_isa ($item3, <IFName::x|ProcessingInstruction>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);
        $test->id ('child.item.equals2');
        $test->assert_equals ($item2, $pi2);
        $test->id ('child.item.equals3');
        $test->assert_equals ($item3, $pi3);

        $test->id ('treeid');
        $test->assert_equals
                 ($item->{<H::mn|node>}->{<H::mn|treeID>},
                  $dtd->{<H::mn|node>}->{<H::mn|treeID>});
        $test->id ('treeid2');
        $test->assert_equals
                 ($item2->{<H::mn|node>}->{<H::mn|treeID>},
                  $dtd->{<H::mn|node>}->{<H::mn|treeID>});
        $test->id ('treeid3');
        $test->assert_equals
                 ($item3->{<H::mn|node>}->{<H::mn|treeID>},
                  $dtd->{<H::mn|node>}->{<H::mn|treeID>});

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi3);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);
        $test->id ('parent2');
        my $parent2 = $item2-><AG::Node.parentNode>;
        $test->assert_equals ($parent2, $dtd);
        $test->id ('parent3');
        my $parent3 = $item3-><AG::Node.parentNode>;
        $test->assert_equals ($parent3, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi0);

    @@Test:
      @@@QName: DTDef.appendChild.badtype.test
      @@@PerlDef:
        my $doc;
        __CODE{t|createDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $comment = $docx-><M::DocumentXDoctype.createDocumentTypeDefinition>
                               ('data');
        my $pi0 = $doc-><M::Document.createProcessingInstruction> ('pi0');
        $comment-><M::Node.appendChild> ($pi0);

        for my $node (
          $docx-><M::d|DocumentXDoctype.createDocumentTypeDefinition> ('d'),
          $doc-><M::Document.createEntityReference> ('ent'),
          $doc-><M::Document.createElement> ('e'),
          $doc-><M::Document.createAttribute> ('a'),
          $doc-><M::Document.createComment> ('c'),
          $doc-><M::Document.createTextNode> ('t'),
          $doc-><M::Document.createCDATASection> ('cs'),
          $docx-><M::d|DocumentXDoctype.createGeneralEntity> ('ge'),
          $docx-><M::d|DocumentXDoctype.createNotation> ('not'),
          $docx-><M::d|DocumentXDoctype.createElementTypeDefinition> ('et'),
          $docx-><M::d|DocumentXDoctype.createAttributeDefinition> ('at'),
          #test:nodeTypes
        ) {
          $test->id ('appendChild.'.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.appendChild> ($node);
          }, exception_subtype => <Q::MDOMX|HIERARCHY_BAD_TYPE>);

          $test->id ('insertBefore.'.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.insertBefore> ($node);
          }, exception_subtype => <Q::MDOMX|HIERARCHY_BAD_TYPE>);

          $test->id ('replaceChild.'.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.replaceChild> ($node, $pi0);
          }, exception_subtype => <Q::MDOMX|HIERARCHY_BAD_TYPE>);
        }

    @@Test:
      @@@QName: DTDef.appendChild.wrongdoc.test
      @@@PerlDef:
        my $doc0;
        __CODE{t|createDocumentForTest:: $doc => $doc0}__;
        my $docx0 = $doc0-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $doc;
        __CODE{t|createDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $comment = $docx0-><M::DocumentXDoctype.createDocumentTypeDefinition>
                                ('data');

        for my $node (
          $doc-><M::Document.createProcessingInstruction> ('pi'),
        ) {
          $test->id ('type='.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.appendChild> ($node);
          }, exception_subtype => <Q::c|DIFFERENT_DOCUMENT_ERR>);
        }
    @@Test:
      @@@QName: DTDef.insertBefore.wrongdoc.test
      @@@PerlDef:
        my $doc0;
        __CODE{t|createDocumentForTest:: $doc => $doc0}__;
        my $docx0 = $doc0-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $doc;
        __CODE{t|createDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $comment = $docx0-><M::DocumentXDoctype.createDocumentTypeDefinition>
                                ('data');
        my $pi0 = $doc0-><M::Document.createProcessingInstruction> ('pi0');
        $comment-><M::Node.appendChild> ($pi0);

        for my $node (
          $doc-><M::Document.createProcessingInstruction> ('pi'),
        ) {
          $test->id ('appendChild.'.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.appendChild> ($node);
          }, exception_subtype => <Q::c|DIFFERENT_DOCUMENT_ERR>);

          $test->id ('insertBefore.'.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.insertBefore> ($node);
          }, exception_subtype => <Q::c|DIFFERENT_DOCUMENT_ERR>);

          $test->id ('replaceChild.'.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.replaceChild> ($node, $pi0);
          }, exception_subtype => <Q::c|DIFFERENT_DOCUMENT_ERR>);
        }

    @@Test:
      @@@QName: DTDef.appendChild.wrongdoc.2.test
      @@@PerlDef:
        my $impl;
        __CODE{t|createDOMImplForTest:: $impl => $impl}__;

        my $dtype = $impl-><M::c|DOMImplementation.createDocumentType>
                             ('type', 'pub', 'sys');

        my $doc;
        __CODE{t|createDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $node = $doc-><M::Document.createProcessingInstruction> ('pi');

        $test->id ('appendChild'.$node-><AG::Node.nodeType>);
        $test->assert_exception (code => sub {
          $dtype-><M::Node.appendChild> ($node);
        }, exception_subtype => <Q::c|DIFFERENT_DOCUMENT_ERR>);

        $test->id ('insertBefore.'.$node-><AG::Node.nodeType>);
        $test->assert_exception (code => sub {
          $dtype-><M::Node.insertBefore> ($node);
        }, exception_subtype => <Q::c|DIFFERENT_DOCUMENT_ERR>);

        $test->id ('replaceChild.'.$node-><AG::Node.nodeType>);
        my $pi0 = $doc-><M::Document.createProcessingInstruction> ('pi0');
                     ## DocumentType with no ownerDocument cannot have children.
        $test->assert_exception (code => sub {
          $dtype-><M::Node.replaceChild> ($node, $pi0);
        }, exception_subtype => <Q::c|DIFFERENT_DOCUMENT_ERR>);

    @@Test:
      @@@QName: DTDef.appendChild.readonly.1.test
      @@@PerlDef:
        my $doc;
        __CODE{t|createDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createDocumentTypeDefinition>
                           ('d');
        my $pi0 = $doc-><M::Document.createProcessingInstruction> ('pi0');
        $dtd-><M::Node.appendChild> ($pi0);
        $dtd->{<H::mn|node>}->{<H::c|read-only>} = true;

        $test->id ('pi');
        my $node = $doc-><M::Document.createProcessingInstruction> ('pi');

        $test->assert_exception (code => sub {
          $dtd-><M::Node.appendChild> ($node);
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);

        $test->id ('pi.insertBefore');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.insertBefore> ($node);
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);

        $test->id ('pi.replaceChild');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.replaceChild> ($node, $pi0);
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);

        $test->id ('fragment');
        my $node2 = $doc-><M::Document.createDocumentFragment>;
        $node2-><M::Node.appendChild> ($node);

        $test->assert_exception (code => sub {
          $dtd-><M::Node.appendChild> ($node2);
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);

        $test->id ('fragment.insertBefore');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.insertBefore> ($node2);
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);

        $test->id ('fragment.replaceChild');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.replaceChild> ($node2, $pi0);
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);

    @@Test:
      @@@QName: DTDef.appendChild.readonly.2.test
      @@@PerlDef:
        my $doc;
        __CODE{t|createDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createDocumentTypeDefinition>
                           ('d');
        my $pi0 = $doc-><M::Document.createProcessingInstruction> ('pi0');
        $dtd-><M::Node.appendChild> ($pi0);

        $test->id ('pi');
        my $el = $doc-><M::Document.createElementNS> (null, 'e');
        my $node = $doc-><M::Document.createProcessingInstruction> ('pi');
        $el-><M::Node.appendChild> ($node);
        $el->{<H::mn|node>}->{<H::c|read-only>} = true;

        $test->assert_exception (code => sub {
          $dtd-><M::Node.appendChild> ($node);
        }, exception_subtype => <Q::MDOMX|NOMOD_SRC_PARENT>);

        $test->id ('pi.insertBefore');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.insertBefore> ($node);
        }, exception_subtype => <Q::MDOMX|NOMOD_SRC_PARENT>);

        $test->id ('pi.replaceChild');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.replaceChild> ($node, $pi0);
        }, exception_subtype => <Q::MDOMX|NOMOD_SRC_PARENT>);

        $test->id ('fragment');
        my $node2 = $doc-><M::Document.createDocumentFragment>;
        my $node3 = $doc-><M::Document.createProcessingInstruction> ('pi');
        $node2-><M::Node.appendChild> ($node3);
        $node2->{<H::mn|node>}->{<H::c|read-only>} = true;

        $test->assert_exception (code => sub {
          $dtd-><M::Node.appendChild> ($node2);
        }, exception_subtype => <Q::MDOMX|NOMOD_SRC_PARENT>);

        $test->id ('fragment.insertBefore');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.insertBefore> ($node2);
        }, exception_subtype => <Q::MDOMX|NOMOD_SRC_PARENT>);

        $test->id ('fragment.replaceChild');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.replaceChild> ($node2, $pi0);
        }, exception_subtype => <Q::MDOMX|NOMOD_SRC_PARENT>);

    @@Test:
      @@@QName: DTDef.insertBefore.refChild.1.test
      @@@PerlDef:
        my $doc;
        __CODE{t|createDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createDocumentTypeDefinition>
                           ('d');

        my $pi1 = $doc-><M::Document.createProcessingInstruction> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createProcessingInstruction> ('pi2');
        $dtd-><M::Node.insertBefore> ($pi2, $pi1);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi2);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi1);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: DTDef.insertBefore.refChild.2.test
      @@@PerlDef:
        my $doc;
        __CODE{t|createDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createDocumentTypeDefinition>
                           ('d');

        my $pi1 = $doc-><M::Document.createProcessingInstruction> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createProcessingInstruction> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createProcessingInstruction> ('pi3');
        $dtd-><M::Node.insertBefore> ($pi3, $pi2);

        # pi1, pi3, pi2

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi1);

        $test->id ('firstChild.nextSibling');
        $test->assert_equals ($dtd-><AG::Node.firstChild>
                                  -><AG::Node.nextSibling>, $pi3);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi2);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 3);

    @@Test:
      @@@QName: DTDef.insertBefore.refChild.3.test
      @@@PerlDef:
        my $doc;
        __CODE{t|createDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createDocumentTypeDefinition>
                           ('d');

        my $pi1 = $doc-><M::Document.createProcessingInstruction> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createProcessingInstruction> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createProcessingInstruction> ('pi3');
        $dtd-><M::Node.appendChild> ($pi3);

        # pi1, pi2, pi3

        $dtd-><M::Node.insertBefore> ($pi2, $pi1);
 
        # pi2, pi1, pi3

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi2);

        $test->id ('firstChild.nextSibling');
        $test->assert_equals ($dtd-><AG::Node.firstChild>
                                  -><AG::Node.nextSibling>, $pi1);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi3);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 3);

    @@Test:
      @@@QName: DTDef.insertBefore.refChild.4.test
      @@@PerlDef:
        my $doc;
        __CODE{t|createDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createDocumentTypeDefinition>
                           ('d');

        my $pi1 = $doc-><M::Document.createProcessingInstruction> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createProcessingInstruction> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createProcessingInstruction> ('pi3');
        $dtd-><M::Node.appendChild> ($pi3);

        # pi1, pi2, pi3

        $dtd-><M::Node.insertBefore> ($pi3, $pi1);
 
        # pi3, pi1, pi2

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi3);

        $test->id ('firstChild.nextSibling');
        $test->assert_equals ($dtd-><AG::Node.firstChild>
                                  -><AG::Node.nextSibling>, $pi1);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi2);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 3);

    @@Test:
      @@@QName: DTDef.insertBefore.refChild.not_found_err.1.test
      @@@PerlDef:
        my $doc;
        __CODE{t|createDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createDocumentTypeDefinition>
                           ('d');

        my $pi1 = $doc-><M::Document.createProcessingInstruction> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createProcessingInstruction> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createProcessingInstruction> ('pi3');

        my $pi4 = $doc-><M::Document.createProcessingInstruction> ('pi4');

        # pi1, pi2

        $test->assert_exception (code => sub {
          $dtd-><M::Node.insertBefore> ($pi4, $pi3);
        }, exception_subtype => <Q::c|NOT_CHILD_ERR>);

    @@Test:
      @@@QName: DTDef.insertBefore.refChild=newChild.test
      @@@PerlDef:
        my $doc;
        __CODE{t|createDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createDocumentTypeDefinition>
                           ('d');

        my $pi1 = $doc-><M::Document.createProcessingInstruction> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createProcessingInstruction> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        # pi1, pi2

        my $eh_called = false;
        my $cfg = $doc-><AG::Document.domConfig>;
        $cfg-><M::c|DOMConfiguration.setParameter> ('error-handler' => sub {
          my (undef, $err) = @_;
          $eh_called = true;
          $test->assert_equals ($err-><AG::c|DOMError.severity>,
                                <C::c|DOMError.SEVERITY_WARNING>);
          $test->assert_equals ($err-><AG::c|DOMError.type>,
                                <Q::t|insert-before-itself>);
          $test->assert_equals ($err-><AG::c|DOMError.relatedData>, $pi2);
          $test->assert_null ($err-><AG::c|DOMError.relatedException>);
          $test->assert_isa ($err-><AG::c|DOMError.location>,
                             <IFName::c|DOMLocator>);
          $test->assert_not_null ($err-><AG::c|DOMError.message>);
        });

        $test->assert_false ($eh_called);
        $dtd-><M::Node.insertBefore> ($pi2, $pi2);
        $test->assert_true ($eh_called);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi1);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi2);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: DTDef.replaceChild.oldChild=newChild.test
      @@@PerlDef:
        my $doc;
        __CODE{t|createDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createDocumentTypeDefinition>
                           ('d');

        my $pi1 = $doc-><M::Document.createProcessingInstruction> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createProcessingInstruction> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        # pi1, pi2

        my $eh_called = false;
        my $cfg = $doc-><AG::Document.domConfig>;
        $cfg-><M::c|DOMConfiguration.setParameter> ('error-handler' => sub {
          my (undef, $err) = @_;
          $eh_called = true;
          $test->assert_equals ($err-><AG::c|DOMError.severity>,
                                <C::c|DOMError.SEVERITY_WARNING>);
          $test->assert_equals ($err-><AG::c|DOMError.type>,
                                <Q::t|replace-by-itself>);
          $test->assert_equals ($err-><AG::c|DOMError.relatedData>, $pi2);
          $test->assert_null ($err-><AG::c|DOMError.relatedException>);
          $test->assert_isa ($err-><AG::c|DOMError.location>,
                             <IFName::c|DOMLocator>);
          $test->assert_not_null ($err-><AG::c|DOMError.message>);
        });

        $test->assert_false ($eh_called);
        $dtd-><M::Node.replaceChild> ($pi2, $pi2);
        $test->assert_true ($eh_called);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi1);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi2);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: DTDef.appendChild.sameparent.1.test
      @@@PerlDef:
        my $doc;
        __CODE{t|createDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createDocumentTypeDefinition>
                           ('d');

        my $pi1 = $doc-><M::Document.createProcessingInstruction> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createProcessingInstruction> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        # pi1, pi2

        my $return = $dtd-><M::Node.appendChild> ($pi1);

        # pi2, pi1

        $test->id ('return');
        $test->assert_equals ($return, $pi1);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi2);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi1);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: DTDef.insertBefore.sameparent.1.test
      @@@PerlDef:
        my $doc;
        __CODE{t|createDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createDocumentTypeDefinition>
                           ('d');

        my $pi1 = $doc-><M::Document.createProcessingInstruction> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createProcessingInstruction> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        # pi1, pi2

        my $return = $dtd-><M::Node.insertBefore> ($pi1);

        # pi2, pi1

        $test->id ('return');
        $test->assert_equals ($return, $pi1);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi2);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi1);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: DTDef.appendChild.sameparent.2.test
      @@@PerlDef:
        my $doc;
        __CODE{t|createDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createDocumentTypeDefinition>
                           ('d');

        my $pi1 = $doc-><M::Document.createProcessingInstruction> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createProcessingInstruction> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        # pi1, pi2

        my $return = $dtd-><M::Node.appendChild> ($pi2);

        # pi1, pi2

        $test->id ('return');
        $test->assert_equals ($return, $pi2);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi1);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi2);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: DTDef.insertBefore.sameparent.2.test
      @@@PerlDef:
        my $doc;
        __CODE{t|createDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createDocumentTypeDefinition>
                           ('d');

        my $pi1 = $doc-><M::Document.createProcessingInstruction> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createProcessingInstruction> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        # pi1, pi2

        my $return = $dtd-><M::Node.insertBefore> ($pi2);

        # pi1, pi2

        $test->id ('return');
        $test->assert_equals ($return, $pi2);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi1);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi2);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: DTDef.replaceChild.1.test
      @@@PerlDef:
        my $doc;
        __CODE{t|createDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createDocumentTypeDefinition>
                           ('d');

        my $pi1 = $doc-><M::Document.createProcessingInstruction> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createProcessingInstruction> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createProcessingInstruction> ('pi3');
        $dtd-><M::Node.appendChild> ($pi3);

        # pi1, pi2, pi3

        my $pi9 = $doc-><M::Document.createProcessingInstruction> ('pi9');
        my $return = $dtd-><M::Node.replaceChild> ($pi9, $pi1);

        # pi9, pi2, pi3

        $test->id ('return.node');
        $test->assert_isa ($return, <IFName::Node>);
        $test->id ('return.pi');
        $test->assert_isa ($return, <IFName::x|ProcessingInstruction>);
        $test->id ('return');
        $test->assert_equals ($return, $pi1);

        my $c = $dtd-><AG::Node.childNodes>;

        $test->id ('length');
        $test->assert_num_equals (actual_value => 0+@$c, expected_value => 3);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi9);

        $test->id ('firstChild.nextSibling');
        $test->assert_equals ($dtd-><AG::Node.firstChild>
                                  -><AG::Node.nextSibling>, $pi2);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi3);
 
        $test->id ('parent');
        $test->assert_equals ($pi9-><AG::Node.parentNode>, $dtd);

        $test->id ('return.parent');
        $test->assert_null ($pi1-><AG::Node.parentNode>);

    @@Test:
      @@@QName: DTDef.replaceChild.2.test
      @@@PerlDef:
        my $doc;
        __CODE{t|createDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createDocumentTypeDefinition>
                           ('d');

        my $pi1 = $doc-><M::Document.createProcessingInstruction> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createProcessingInstruction> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createProcessingInstruction> ('pi3');
        $dtd-><M::Node.appendChild> ($pi3);

        # pi1, pi2, pi3

        my $pi9 = $doc-><M::Document.createProcessingInstruction> ('pi9');
        my $return = $dtd-><M::Node.replaceChild> ($pi9, $pi2);

        # pi1, pi9, pi3

        $test->id ('return.node');
        $test->assert_isa ($return, <IFName::Node>);
        $test->id ('return.pi');
        $test->assert_isa ($return, <IFName::x|ProcessingInstruction>);
        $test->id ('return');
        $test->assert_equals ($return, $pi2);

        my $c = $dtd-><AG::Node.childNodes>;

        $test->id ('length');
        $test->assert_num_equals (actual_value => 0+@$c, expected_value => 3);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi1);

        $test->id ('firstChild.nextSibling');
        $test->assert_equals ($dtd-><AG::Node.firstChild>
                                  -><AG::Node.nextSibling>, $pi9);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi3);
 
        $test->id ('parent');
        $test->assert_equals ($pi9-><AG::Node.parentNode>, $dtd);

        $test->id ('return.parent');
        $test->assert_null ($pi2-><AG::Node.parentNode>);

    @@Test:
      @@@QName: DTDef.replaceChild.3.test
      @@@PerlDef:
        my $doc;
        __CODE{t|createDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createDocumentTypeDefinition>
                           ('d');

        my $pi1 = $doc-><M::Document.createProcessingInstruction> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createProcessingInstruction> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createProcessingInstruction> ('pi3');
        $dtd-><M::Node.appendChild> ($pi3);

        # pi1, pi2, pi3

        my $pi9 = $doc-><M::Document.createProcessingInstruction> ('pi9');
        my $return = $dtd-><M::Node.replaceChild> ($pi9, $pi3);

        # pi1, pi2, pi9

        $test->id ('return.node');
        $test->assert_isa ($return, <IFName::Node>);
        $test->id ('return.pi');
        $test->assert_isa ($return, <IFName::x|ProcessingInstruction>);
        $test->id ('return');
        $test->assert_equals ($return, $pi3);

        my $c = $dtd-><AG::Node.childNodes>;

        $test->id ('length');
        $test->assert_num_equals (actual_value => 0+@$c, expected_value => 3);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi1);

        $test->id ('firstChild.nextSibling');
        $test->assert_equals ($dtd-><AG::Node.firstChild>
                                  -><AG::Node.nextSibling>, $pi2);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi9);
 
        $test->id ('parent');
        $test->assert_equals ($pi9-><AG::Node.parentNode>, $dtd);

        $test->id ('return.parent');
        $test->assert_null ($pi3-><AG::Node.parentNode>);

    @@Test:
      @@@QName: DTDef.replaceChild.sameparent.1.test
      @@@PerlDef:
        my $doc;
        __CODE{t|createDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createDocumentTypeDefinition>
                           ('d');

        my $pi1 = $doc-><M::Document.createProcessingInstruction> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createProcessingInstruction> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createProcessingInstruction> ('pi3');
        $dtd-><M::Node.appendChild> ($pi3);

        # pi1, pi2, pi3

        my $return = $dtd-><M::Node.replaceChild> ($pi3, $pi1);

        # pi3, pi2

        $test->id ('return.node');
        $test->assert_isa ($return, <IFName::Node>);
        $test->id ('return.pi');
        $test->assert_isa ($return, <IFName::x|ProcessingInstruction>);
        $test->id ('return');
        $test->assert_equals ($return, $pi1);

        my $c = $dtd-><AG::Node.childNodes>;

        $test->id ('length');
        $test->assert_num_equals (actual_value => 0+@$c, expected_value => 2);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi3);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi2);
 
        $test->id ('parent');
        $test->assert_equals ($pi3-><AG::Node.parentNode>, $dtd);

        $test->id ('return.parent');
        $test->assert_null ($pi1-><AG::Node.parentNode>);

    @@Test:
      @@@QName: DTDef.replaceChild.sameparent.2.test
      @@@PerlDef:
        my $doc;
        __CODE{t|createDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentXDoctype.createDocumentTypeDefinition>
                           ('d');

        my $pi1 = $doc-><M::Document.createProcessingInstruction> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createProcessingInstruction> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createProcessingInstruction> ('pi3');
        $dtd-><M::Node.appendChild> ($pi3);

        # pi1, pi2, pi3

        my $return = $dtd-><M::Node.replaceChild> ($pi1, $pi3);

        # pi2, pi1

        $test->id ('return.node');
        $test->assert_isa ($return, <IFName::Node>);
        $test->id ('return.pi');
        $test->assert_isa ($return, <IFName::x|ProcessingInstruction>);
        $test->id ('return');
        $test->assert_equals ($return, $pi3);

        my $c = $dtd-><AG::Node.childNodes>;

        $test->id ('length');
        $test->assert_num_equals (actual_value => 0+@$c, expected_value => 2);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi2);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi1);
 
        $test->id ('parent');
        $test->assert_equals ($pi1-><AG::Node.parentNode>, $dtd);

        $test->id ('return.parent');
        $test->assert_null ($pi3-><AG::Node.parentNode>);

  @Method:
    @@ForCheck: ManakaiDOM|ForClass
    @@ManakaiDOM:isForInternal: 1
    @@Name: newObject
    @@NewObjectRefNodeParam:
    @@Return:
      @@@Type: NodeStem
      @@@PerlDef:
        $r = <ClassM::t|ManakaiDOMNode.newObject> ($self, $refNode);
        $r->{<H::c|nodeType>} = <H::infoset|DocumentTypeDeclaration>;
        $r->{<H::d|elementTypes>} = {};
        $r->{<H::d|generalEntities>} = {};
        $r->{<H::d|parameterEntities>} = {};
        $r->{<H::d|notations>} = {};
        $r->{<H::infoset|children>} = [];
    @@enImplNote:
      Required properties:
        <Q::c|nodeType>, <Q::c|ownerDocument>,
        either <Q::c|name> or <Q::infoset|localName>,
        <Q::d|elementTypes>, <Q::d|generalEntities>,
        <Q::d|parameterEntities>, <Q::d|notations>,
        <Q::infoset|children>.
      
      Optional properties (common):
        <Q::c|read-only>,
        <Q::d|ownerDocument>,
        <Q::infoset|prefix>.
        <Q::c|implementation>, <Q::ManakaiDOM|implID>.

      Optional properties (declaration):
        <Q::infoset:publicIdentifier>,
        <Q::infoset:systemIdentifier>,
        <Q::d|hasLtDeclaration>,
        <Q::d|hasGtDeclaration>,
        <Q::d|hasAmpDeclaration>,
        <Q::d|hasAposDeclaration>,
        <Q::d|hasQuotDeclaration>.
      
      Since a <IF::x|DocumentType> might not be associated
      with any <IF::c|Document>, a <IF::x|DocumentType>
      node created by the manakai DOM implementation contains
      a reference to the <IF::c|DOMImplementation> object
      in the <Q::c|implementation> property and the implementation
      identifier in the <Q::ManakaiDOM|implID> at least as long as
      the node does not have any owner document.
      
      DOM2 Core <M::c|DOMImplementation.createDocumentType>
      method is namespace aware, so the manakai implementation
      preserves the document type name by <Q::infoset|localName>
      property with optional <Q::infoset|prefix> property.
      Note that document type name never has namespace URI.
      
      <M::DocumentXDoctype.createDocumentTypeDefinition>
      is <EM::not> namespace aware and the document type
      name is kept by <Q::c|name> property.
  @mn:xrefnode0: c|ownerDocument
  @mn:subnode1: d|elementTypes
  @mn:subnode1: d|generalEntities
  @mn:subnode1: d|parameterEntities
  @mn:subnode1: d|notations
  @mn:subnode1: infoset|children
  @mn:origin0: infoset|parent
##DocumentTypeDefinition

PropDef:
  @QName: d|hasLtDeclaration

PropDef:
  @QName: d|hasGtDeclaration

PropDef:
  @QName: d|hasAmpDeclaration

PropDef:
  @QName: d|hasAposDeclaration

PropDef:
  @QName: d|hasQuotDeclaration

enImplNote:
  Future version of this module might define a class for
  entity declarations.  Then these five properties will be removed.

IFClsXDef:
  @IFQName: DocumentTypeDeclaration
  @ClsQName: ManakaiDOMDocumentTypeDeclaration

  # This class is inherited by |ManakaiDOMDocumentTypeDeclaration|

  @f:implements: d|DeclFeature30
  @f:provides:
    @@@: d|DeclFeature30
    @@f:through: c|ManakaiDOMImplementation

  @enDesc:
    An object implementing the <IF::DocumentTypeDeclaration>
    interface represents a document type declaration contained
    in an XML document or a <InfoItem::document type declaration
    information item> in an XML infoset.

    An object implementing the <IF::DocumentTypeDeclaration>
    interface <kwd:MAY> also implement the <IF::DocumentTypeDefinition>
    interface and / or the <IF::x|DocumentType> interface.

  @ResourceDef:
    @@ForCheck: ManakaiDOM|ForClass
    @@QName: newDTDeclForTest
    @@AliasFor: newDoctypeForTest

  @Attr:
    @@Name: systemId
    @@enDesc:
      The system identifier of the external subset, as it appears
      in the document type declaration, without any additional
      percent-encoding or relative reference resolving
      applied by the processor.
    @@Type: DOMString
    @@nullCase:
      @@@enDesc:
        If there is no system identifier specified.
    @@Get:
      @@@disDef:
        @@@@GetProp: infoset|systemIdentifier
    @@Set:
      @@@enDesc:
        Set the system identifier of the external subset.  No lexical
        validation is done.

        It does not lead any lexical or logical structure of the
        document being changed.  In particular, no attempt to
        load the external subset referenced by the new value
        is made.

          {NOTE:: Setting an invalid system identifier will make
                  the declaration unserializable.  Setting
                  a <DOM::null> system identifier to the declaration
                  whose external subset <EM::does> have the
                  public identifier will also make it unserializable.
          }
      @@@NodeReadOnlyError:
      @@@disDef:
        @@@@SetProp:
          @@@@@@: infoset|systemIdentifier
          @@@@@CheckReadOnly: 1

    @@Test:
      @@@QName: DTDef.systemId.test
      @@@PerlDef:
        my $dtd;
        __CODE{newDTDeclForTest}__;

        $test->id ('initial');
        $test->assert_null ($dtd-><AG::DocumentTypeDeclaration.systemId>);

        $test->id ('set');
        $dtd-><AS::DocumentTypeDeclaration.systemId> ('sysId');
        $test->assert_equals ($dtd-><AG::DocumentTypeDeclaration.systemId>,
                              'sysId');

        $test->id ('set.illegal');
        $dtd-><AS::DocumentTypeDeclaration.systemId> (q<"sysId'>);
        $test->assert_equals ($dtd-><AG::DocumentTypeDeclaration.systemId>,
                              q<"sysId'>);

        $test->id ('set.null');
        $dtd-><AS::DocumentTypeDeclaration.systemId> (null);
        $test->assert_null ($dtd-><AG::DocumentTypeDeclaration.systemId>);

    @@Test:
      @@@QName: DocumentType.systemId.get.test
      @@@PerlDef:
        my $impl;
        __CODE{t|createDOMImplForTest:: $impl => $impl}__;

        my $dtype = $impl-><M::c|DOMImplementation.createDocumentType>
                             ('type', 'pub', 'sys');
        $test->assert_equals ($dtype-><AG::x|DocumentType.systemId>, 'sys');

  @Attr:
    @@Name: publicId
    @@enDesc:
      The public identifier of the external subset, normalized as described
      in the XML specification.
    @@Type: DOMString
    @@nullCase:
      @@@enDesc:
        If there is no public identifier specified.
    @@Get:
      @@@disDef:
        @@@@GetProp: infoset|publicIdentifier
    @@Set:
      @@@enDesc:
        Set the given value to the attribute.  No normalization
        or lexical validation is done.

        It does not lead any lexical or logical structure of the
        document being changed.  In particular, no attempt to
        load the external subset referenced by the new value
        is made.

          {NOTE:: Setting an invalid public identifier or
                  an unnormalized public identifier will make
                  the declaration unserializable.  Setting
                  a public identifier to the declaration
                  whose external subset does not have any
                  system identifier will also make it unserializable.
          }
      @@@NodeReadOnlyError:
      @@@disDef:
        @@@@SetProp:
          @@@@@@: infoset|publicIdentifier
          @@@@@CheckReadOnly: 1

    @@Test:
      @@@QName: DTDef.publicId.test
      @@@PerlDef:
        my $dtd;
        __CODE{newDTDeclForTest}__;

        $test->id ('initial');
        $test->assert_null ($dtd-><AG::DocumentTypeDeclaration.publicId>);

        $test->id ('set');
        $dtd-><AS::DocumentTypeDeclaration.publicId> ('sysId');
        $test->assert_equals ($dtd-><AG::DocumentTypeDeclaration.publicId>,
                              'sysId');

        $test->id ('set.illegal');
        $dtd-><AS::DocumentTypeDeclaration.publicId> (q<"sysId'>);
        $test->assert_equals ($dtd-><AG::DocumentTypeDeclaration.publicId>,
                              q<"sysId'>);

        $test->id ('set.null');
        $dtd-><AS::DocumentTypeDeclaration.publicId> (null);
        $test->assert_null ($dtd-><AG::DocumentTypeDeclaration.publicId>);

    @@Test:
      @@@QName: DocumentType.publicId.get.test
      @@@PerlDef:
        my $impl;
        __CODE{t|createDOMImplForTest:: $impl => $impl}__;

        my $dtype = $impl-><M::c|DOMImplementation.createDocumentType>
                             ('type', 'pub', 'sys');
        $test->assert_equals ($dtype-><AG::x|DocumentType.publicId>, 'pub');

  @Attr:
    @@Name: name
    @@enDesc:
      The document type name.
    @@Type: DOMString
    @@dis:actualType: DOMMain|ManakaiDOMXMLName
    @@DOMMain:isNamespaceUnaware: 1
    @@Get:
      @@@disDef:
        @@@@DISPerl:cloneCode: d|ManakaiDOMDocumentTypeDefinition.nodeName.get

    @@Test:
      @@@QName: DTDef.name.get.test
      @@@PerlDef:
        my $dtd;
        __CODE{newDTDeclForTest}__;

        $test->id ('initial');
        $test->assert_equals ($dtd-><AG::DocumentTypeDeclaration.name>, 'dt1');

    @@Test:
      @@@QName: DocumentType.name.get.test
      @@@PerlDef:
        my $impl;
        __CODE{t|createDOMImplForTest:: $impl => $impl}__;

        my $dtype = $impl-><M::c|DOMImplementation.createDocumentType>
                             ('type', 'pub', 'sys');
        $test->assert_equals ($dtype-><AG::x|DocumentType.name>, 'type');

  @Attr:
    @@Name: declarationBaseURI
    @@enDesc:
      The base URI of the document type declaration.

      If the declaration implements the <IF::Node> interface 
      and <A::Node.ownerDocument> is different from <DOM::null>,
      then the base URI of the declaration is the base URI
      of that document.
    @@Type: DOMString
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          If the declaration has no owner document or if the
          document has no base URI.
      @@@PerlDef:
        __DEEP{
          my $od = $self-><AG::Node.ownerDocument>;
          if ($od) {
            $r = $od-><AG::Node.baseURI>;
          } else {
            $r = null;
          }
        }__;
    @@Set:
      @@@enDesc:
        Setting this attribute has no effect.
      @@@PerlDef:

    @@Test:
      @@@QName: DTDef.declarationBaseURI.get.test
      @@@PerlDef:
        my $dtd;
        __CODE{newDTDeclForTest}__;

        $test->id ('initial');
        $test->assert_null
                 ($dtd-><AG::DocumentTypeDeclaration.declarationBaseURI>);

        $test->id ('doc');
        $dtd-><AG::Node.ownerDocument>-><AS::Document.documentURI>
                                          (q<http://doc.test/>);
        $test->assert_equals
                 ($dtd-><AG::DocumentTypeDeclaration.declarationBaseURI>,
                  q<http://doc.test/>);

  @Attr:
    @@Name: manakaiDeclarationBaseURI
    @@enDesc:
      The base URI of the document type declaration corresponding
      to the node, i.e. the base URI that is used to resolve
      the system identifier of the declaration.
    @@Type: DOMString
    @@dis:actualType: ManakaiDOM|ManakaiDOMURI
    @@Get:
      @@@enDesc:
        The <A::DocumentTypeDeclaration.declarationBaseURI> value.
      @@@nullCase:
        @@@@enDesc:
          If <A::DocumentTypeDeclaration.declarationBaseURI> is <DOM::null>.
      @@@PerlDef:
        __DEEP{
          $r = $self-><AG::DocumentTypeDeclaration.declarationBaseURI>;
        }__;
    @@Set:
      @@@enDesc:
        Setting this attribute has no effect.
      @@@PerlDef:

  @CAttr:
    @@Name: internalSubset
    @@Type: DOMString
    @@Get:
      @@@PerlDef:
        $r = null;

  @enImplNote:
    @@ddid: todo
    @@@:
      {TODO::
        Implement <A::x|DocumentType.internalSubset>.

        External subset entity node?

        Internal subset pseudo-entity node?
      }
##DocumentTypeDeclaration

PropDef:
  @QName: d|elementTypes

PropDef:
  @QName: d|generalEntities

PropDef:
  @QName: d|parameterEntities

PropDef:
  @QName: d|notations

IFClsXDef:
  @IFQName: ElementTypeDefinition
  @ClsQName: ManakaiDOMElementTypeDefinition
  
  @IFISA: t|Node
  @ClsISA: t|ManakaiDOMNode
  
  @DISLang:role: c|ElementTypeDefinitionRole

  @f:implements: d|Feature30
  
  @enDesc:
    An <IF::ElementTypeDefinition> node represents
    the definition for an element type.
    
      {NOTE:: Although an <IF::ElementTypeDefinition>
              can be constructed from an element
              type declaration in XML DTD, the
              <IF::ElementTypeDefinition> interface is
              not intended to represent element
              type declaration itself.
      }

  @ResourceDef:
    @@ForCheck: ManakaiDOM|ForClass
    @@QName: newETForTest
    @@rdf:type: DISPerl|BlockCode
    @@PerlDef:
      my $doc;
      __CODE{newDocumentForTest}__;
      $et = $doc-><M::DocumentXDoctype.createElementTypeDefinition>
                          ('et1');

  @ResourceDef:
    @@ForCheck: ManakaiDOM|ForClass
    @@QName: newGeneralEntityForTest
    @@rdf:type: DISPerl|BlockCode
    @@PerlDef:
      my $doc;
      __CODE{newDocumentForTest}__;
      $et = $doc-><M::DocumentXDoctype.createGeneralEntity>
                          ('et1');

  @ResourceDef:
    @@ForCheck: ManakaiDOM|ForClass
    @@QName: newNotationForTest
    @@rdf:type: DISPerl|BlockCode
    @@PerlDef:
      my $doc;
      __CODE{newDocumentForTest}__;
      $et = $doc-><M::DocumentXDoctype.createNotation>
                          ('n1');

  @Test:
    @@PerlDef:
      my $et;
      __CODE{newETForTest}__;
      $test->assert_not_null ($et);
      my $od = $et-><AG::Node.ownerDocument>;
      $test->assert_not_null ($od);
      $test->assert_not_null
               ($od-><M::Node.getFeature> (<Q::ManakaiDOM:XDoctype>, '3.0'));

  @Attr:
    @@ForCheck: ManakaiDOM|ForClass
    @@Name: nodeType
    @@enDesc:
      The type of the node.
    @@Type: idl|unsignedShort||ManakaiDOM|all
    @@dis:actualType: t|NodeType
    @@Get:
      @@@disDef:
        @@@@DISLang:constValue:
          t|Node.ELEMENT_TYPE_DEFINITION_NODE
    @@Test:
      @@@PerlDef:
        my $et;
        __CODE{newETForTest}__;
        $test->assert_not_null ($et);
        $test->assert_num_equals 
                 (actual_value => $et-><AG::Node.nodeType>,
                  expected_value => <C::Node.ELEMENT_TYPE_DEFINITION_NODE>);

    @@Test:
      @@@QName: DocumentType.nodeType.get.test
      @@@PerlDef:
        my $impl;
        __CODE{t|createDOMImplForTest:: $impl => $impl}__;

        my $dtype = $impl-><M::c|DOMImplementation.createDocumentType>
                             ('type', 'pub', 'sys');
        $test->assert_num_equals
                 (actual_value => $dtype-><AG::Node.nodeType>,
                  expected_value => <C::Node.DOCUMENT_TYPE_NODE>);

  @Attr:
    @@ForCheck: ManakaiDOM|ForClass
    @@Name: nodeName
    @@enDesc:
      The element type name of the node.
    @@DOMMain:isNamespaceUnaware: 1
    @@Type: DOMString
    @@Get:
      @@@disDef:
        @@@@GetProp: c|name
    @@Test:
      @@@PerlDef:
        my $et;
        __CODE{newETForTest}__;
        $test->assert_not_null ($et);
        $test->assert_equals 
                 ($et-><AG::Node.nodeName> => 'et1');

    @@Test:
      @@@QName: DocumentType.nodeName.get.test
      @@@PerlDef:
        my $impl;
        __CODE{t|createDOMImplForTest:: $impl => $impl}__;

        my $dtype = $impl-><M::c|DOMImplementation.createDocumentType>
                             ('type', 'pub', 'sys');
        $test->assert_equals ($dtype-><AG::Node.nodeName>, 'type');

  @Attr:
    @@ForCheck: ManakaiDOM|ForClass
    @@Name: nodeValue
    @@enDesc:
      Defined as <DOM::null>.
    @@Type: DOMString
    @@Get:
      @@@nullCase:
        @@@@enDesc: Always.
      @@@DefaultValue:
        @@@@is-null: 1
      @@@PerlDef:
    @@Set:
      @@@enDesc:
        Setting the value has no effect.
      @@@PerlDef:
    @@Test:
      @@@PerlDef:
        my $et;
        __CODE{newETForTest}__;
        $test->assert_not_null ($et);
        $test->assert_null ($et-><AG::Node.nodeValue>);
        $et-><AS::Node.nodeValue> ('non-undef-value');
        $test->assert_null ($et-><AG::Node.nodeValue>);

  @Attr:
    @@ForCheck: ManakaiDOM|ForClass
    @@Name: textContent
    @@enDesc:
      Defined as <DOM::null>.
    @@Type: DOMString
    @@Get:
      @@@nullCase:
        @@@@enDesc: Always.
      @@@DefaultValue:
        @@@@is-null: 1
      @@@PerlDef:
    @@Set:
      @@@enDesc:
        Setting the value has no effect.
      @@@PerlDef:
    @@Test:
      @@@PerlDef:
        my $et;
        __CODE{newETForTest}__;
        $test->assert_not_null ($et);
        $test->assert_null ($et-><AG::Node.textContent>);
        $et-><AS::Node.textContent> ('non-undef-value');
        $test->assert_null ($et-><AG::Node.textContent>);

    @@Test:
      @@@QName: DocumentType.textContent.get.test
      @@@PerlDef:
        my $impl;
        __CODE{t|createDOMImplForTest:: $impl => $impl}__;

        my $dtype = $impl-><M::c|DOMImplementation.createDocumentType>
                             ('type', 'pub', 'sys');
        $test->assert_null ($dtype-><AG::Node.textContent>);
    @@Test:
      @@@QName: DocumentType.textContent.set.test
      @@@PerlDef:
        my $impl;
        __CODE{t|createDOMImplForTest:: $impl => $impl}__;

        my $dtype = $impl-><M::c|DOMImplementation.createDocumentType>
                             ('type', 'pub', 'sys');

        $test->id ('set.non.null');
        $dtype-><AS::Node.textContent> ('abcdefg');
        $test->assert_null ($dtype-><AG::Node.textContent>);

        $test->id ('set.null');
        $dtype-><AS::Node.textContent> (null);
        $test->assert_null ($dtype-><AG::Node.textContent>);

  @enImplNote:
    {TODO:: Content model attributes are required.
    }

  @Attr:
    @@Name: attributeDefinitions
    @@enDesc:
      A live collection of the attribute definitions
      contained by the element type definition.
    @@Type: t|NamedNodeMap
    @@Get:
      @@@PerlDef:
        __CODE{t|getAttrDefNodeMap::
          $node => $self,
          $map => $r,
        }__;

    @@Test:
      @@@QName: elementTypeDef.attrDefs.test
      @@@PerlDef:
        my $et;
        __CODE{newETForTest}__;

        my $as = $et-><AG::ElementTypeDefinition.attributeDefinitions>;
        $test->assert_isa ($as, <IFName::t|NamedNodeMap>);
        $test->assert_num_equals
                 (actual_value => $as-><AG::t|NamedNodeMap.length>,
                  expected_value => 0);

  @Attr:
    @@ForCheck: ManakaiDOM|ForClass
    @@Name: childNodes
    @@enDesc:
      A list of nodes that contains all children of the node.
    @@Get:
      @@@Type: t|NodeList
      @@@actualType: c|ManakaiDOMEmptyNodeList
      @@@enDesc:
        The node list that is always empty.
      @@@PerlDef:
        $r = <Class::c|ManakaiDOMEmptyNodeList>->new;
    @@Test:
      @@@PerlDef:
        my $et;
        __CODE{newETForTest}__;
        my $cl = $et-><AG::Node.childNodes>;
        $test->assert_isa ($cl, <IFName::t|NodeList>);
        $test->assert_num_equals
                 (actual_value => $cl-><AG::t|NodeList.length>,
                  expected_value => 0);

  @Method:
    @@Name: getAttributeDefinitionNode
    @@enDesc:
      Returns the definition for an attribute.
    @@DOMMain:isNamespaceUnaware: 1
    @@Param:
      @@@Name: nameArg
      @@@Type: DOMString
      @@@enDesc:
        The name of the attribute.
    @@Return:
      @@@Type: AttributeDefinition
      @@@enDesc:
        The attribute definition for <P::nameArg>.
      @@@nullCase:
        @@@@enDesc:
          There is no definition for the attribute <P::nameArg>.
      @@@PerlDef:
        my $n = $self->{<H::mn:node>}
                     ->{<H::d|attributeDefinitions>}
                     ->{$nameArg};
        if ($n) {
          $r = <ClassM::t|ManakaiDOMNode.getNodeReference> ($n);
        }
    @@Test:
      @@@PerlDef:
        my $et;
        __CODE{newETForTest}__;
        my $an = $et-><M::ElementTypeDefinition.getAttributeDefinitionNode>
                        ('at1');
        $test->assert_null ($an);

  @Method:
    @@Name: setAttributeDefinitionNode
    @@enDesc:
      Sets an attribute definition to the element
      definition.
    @@Param:
      @@@Name: attrDef
      @@@Type: AttributeDefinition
      @@@enDesc:
        The attribute definition to set.  Its <A::t|Node.nodeName>
        attribute is used to set the node.  If it is already
        in use for other element type, then it is first removed
        from that element type and then attached to this
        element type.  If another attribute definition with
        same <A::t|Node.nodeName> is attached to this element
        type definition, that association is removed.
        
        If <P::attrDef> is already attached to this element
        type definition, then this method has no effect.
    @@Return:
      @@@Type: AttributeDefinition
      @@@enDesc:
        If there is already another attribute definition
        with the same <A::t|Node.nodeName> as <P::attrDef>,
        then that definition node is returned.
      @@@nullCase:
        @@@@enDesc:
          If there is no previous definition with the same
          name, or the <P::attrDef> is already attached
          to the element type definition.
      @@@NodeReadOnlyError:
      @@@dx:raises:
        @@@@@: c|INUSE_DEFINITION_ERR
        @@@@enDesc:
          If <A::AttributeDefinition.ownerElementTypeDefinition>
          is not <DOM::null>.
      @@@dx:raises:
        @@@@@: c|DIFFERENT_DOCUMENT_ERR
        @@@@enDesc:
          The <P::attrDef> node is created from different
          document than the <A::c|Node.ownerDocument> of
          the element type definition and the implementation
          does not support such attribute definition node
          being attached to the element type definition.
      @@@PerlDef:
        __CODE{setDefinitionNodeAttr::
          $defNode => $attrDef,
          $defNodeParamName => 'attrDef',
          $key => {<H::d|attributeDefinitions>},
        }__;
    @@Test:
      @@@PerlDef:
        my $et;
        __CODE{newETForTest}__;
        my $an = $et-><M::ElementTypeDefinition.getAttributeDefinitionNode>
                        ('at1');
        $test->assert_null ($an);

        my $can = $et-><AG::Node.ownerDocument>
                     -><M::Node.getFeature> (<Q::ManakaiDOM:XDoctype>)
                     -><M::DocumentXDoctype.createAttributeDefinition> ('at1');
        $et-><M::ElementTypeDefinition.setAttributeDefinitionNode> ($can);

        my $an2 = $et-><M::ElementTypeDefinition.getAttributeDefinitionNode>
                         ('at1');
        $test->assert_not_null ($an2);
        $test->assert_equals ($an2, $can);
        $test->assert_string
                 (actual_value => $an2-><AG::Node.nodeName>,
                  expected_value => 'at1');
  
  @Attr:
    @@Name: ownerDocumentTypeDefinition
    @@enDesc:
      The document type definition node to which
      the definition is attached.
    @@Type: DocumentTypeDefinition
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          The definition is not attached to any
          document type.
      @@@PerlDef:
        $r = <ClassM::t|ManakaiDOMNode.getNodeReference>
               ($self->{<H::mn:node>}->{<H::d|ownerDefinition>})
          if $self->{<H::mn:node>}->{<H::d|ownerDefinition>};
    @@Test:
      @@@PerlDef:
        my $et;
        __CODE{newETForTest}__;
 
        my $odt = $et-><AG::ElementTypeDefinition.ownerDocumentTypeDefinition>;
        $test->assert_null ($odt);

        my $dt = $et-><AG::Node.ownerDocument>
                     -><M::Node.getFeature> (<Q::ManakaiDOM:XDoctype>)
                     -><M::DocumentXDoctype.createDocumentTypeDefinition>
                         ('dt1');
        $test->assert_not_null ($dt);
        $dt-><M::DocumentTypeDefinition.setElementTypeDefinitionNode> ($et);

        my $odt2 = $et-><AG::ElementTypeDefinition
                            .ownerDocumentTypeDefinition>;
        $test->assert_not_null ($odt2);
        $test->assert_isa ($odt2, <IFName::DocumentTypeDefinition>);
        $test->assert_equals ($odt2, $dt);

  @CAttr:
    @@Name: baseURI
    @@enDesc:
      The base DOM URI of the node.  It <kwd:MUST> be the same
      value as the <A::Node.baseURI> attribute value of the
      <A::Node.ownerDocument> node of the node.
    @@Type: DOMString
    @@dis:actualType: ManakaiDOM|ManakaiDOMURI
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          If <A::Node.baseURI> of the <A::Node.ownerDocument> is
          <DOM::null>.
      @@@PerlDef:
        __DEEP{
          $r = $self-><AG::Node.ownerDocument>-><AG::Node.baseURI>;
        }__;

    @@Test:
      @@@QName: ETDef.baseURI.test
      @@@PerlDef:
        my $et;
        __CODE{newETForTest:: $et => $et}__;
 
        my $doc = $et-><AG::Node.ownerDocument>;
 
        $test->id ('initial');
        $test->assert_null ($et-><AG::Node.baseURI>);

        $test->id ('doc');
        $doc-><AS::Document.documentURI> (q<http://doc.test/>);
        $test->assert_equals
                 ($et-><AG::Node.baseURI>,
                  q<http://doc.test/>);
 
  @CMethod:
    @@Name: appendChild
    @@enDesc:
      Adds a node to the end of the list of children of the node.
      If that node is already in the tree, it is first removed.
    @@Param:
      @@@Name: newChild
      @@@Type: Node
      @@@enDesc:
        The node to add.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node added.
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_BAD_TYPE
        @@@@enDesc:
          The type of the node does not allow any children.
      @@@disDef:
        @@@@DISPerl:cloneCode: t|ManakaiDOMCharacterData.appendChild

  @CMethod:
    @@Name: insertBefore
    @@enDesc:
      Inserts a node before the existing child node of the node.
    @@Param:
      @@@Name: newChild
      @@@Type: Node
      @@@enDesc:
        The node to add.
    @@Param:
      @@@Name: refChild
      @@@Type: Node
      @@@enDesc:
        The node before which the <P::newChild> node is inserted.
      @@@nullCase:
        @@@@enDesc:
          The <P::newChild> node is inserted at the end.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node added.
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_BAD_TYPE
        @@@@enDesc:
          The type of the node does not allow any children.
      @@@disDef:
        @@@@DISPerl:cloneCode: t|ManakaiDOMCharacterData.insertBefore

  @CMethod:
    @@Name: replaceChild
    @@enDesc:
      Replaces a node by another node.
    @@Param:
      @@@Name: newChild
      @@@Type: Node
      @@@enDesc:
        The node to add.
    @@Param:
      @@@Name: oldChild
      @@@Type: Node
      @@@enDesc:
        The node to remove.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node replaced.
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_BAD_TYPE
        @@@@enDesc:
          The type of the node does not allow any children.
      @@@disDef:
        @@@@DISPerl:cloneCode: t|ManakaiDOMCharacterData.replaceChild

    @@Test:
      @@@QName: ETDef.appendChild.test
      @@@PerlDef:
        my $doc;
        __CODE{t|createDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $comment = $docx-><M::DocumentXDoctype.createElementTypeDefinition>
                               ('data');
        my $node2 = $doc-><M::Document.createTextNode> ('2');

        for my $node (
          $doc-><AG::Document.implementation>
              -><M::c|DOMImplementation.createDocument>,
          $doc-><M::Document.createDocumentFragment>,
          $doc-><AG::Document.implementation>
              -><M::c|DOMImplementation.createDocumentType> ('d'),
          $docx-><M::d|DocumentXDoctype.createDocumentTypeDefinition> ('d'),
          $doc-><M::Document.createEntityReference> ('ent'),
          $doc-><M::Document.createElement> ('e'),
          $doc-><M::Document.createAttribute> ('a'),
          $doc-><M::Document.createProcessingInstruction> ('pi'),
          $doc-><M::Document.createComment> ('c'),
          $doc-><M::Document.createTextNode> ('t'),
          $doc-><M::Document.createCDATASection> ('cs'),
          $docx-><M::d|DocumentXDoctype.createGeneralEntity> ('ge'),
          $docx-><M::d|DocumentXDoctype.createNotation> ('not'),
          $docx-><M::d|DocumentXDoctype.createElementTypeDefinition> ('et'),
          $docx-><M::d|DocumentXDoctype.createAttributeDefinition> ('at'),
          #test:nodeTypes
        ) {
          $test->id ('appendChild.'.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.appendChild> ($node);
          }, exception_subtype => <Q::MDOMX|HIERARCHY_BAD_TYPE>);

          $test->id ('insertBefore.'.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.insertBefore> ($node);
          }, exception_subtype => <Q::MDOMX|HIERARCHY_BAD_TYPE>);

          $test->id ('replaceChild.'.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.replaceChild> ($node, $node2);
          }, exception_subtype => <Q::MDOMX|HIERARCHY_BAD_TYPE>);
        }

  @Method:
    @@ForCheck: ManakaiDOM|ForClass
    @@ManakaiDOM:isForInternal: 1
    @@Name: newObject
    @@NewObjectRefNodeParam:
    @@Return:
      @@@Type: NodeStem
      @@@PerlDef:
        $r = <ClassM::t|ManakaiDOMNode.newObject> ($self, $refNode);
        $r->{<H::c|nodeType>} = <H::d|ElementTypeDefinitionNodeType>;
        $r->{<H::d|attributeDefinitions>} = {};
    @@enImplNote:
      Required properties:
        <Q::c|nodeType>, <Q::c|ownerDocument>,
        <Q::c|name>,
        <Q::d|attributeDefinitions>.
      
      Optional properties:
        <Q::c|read-only>,
        <Q::d|ownerDefinition>.
  @mn:xrefnode0: c|ownerDocument
  @mn:subnode1: d|attributeDefinitions
  @mn:origin0: d|ownerDefinition
##ElementTypeDefinition

ForDef:
  @QName: ForDT
  @ISA: ManakaiDOM|ForClass

ForDef:
  @QName: ForAttr
  @ISA: ManakaiDOM|ForClass

ResourceDef:
  @For: ManakaiDOM|ManakaiDOM
  @rdf:type:
    @@@: dis|MultipleResource
    @@ForCheck: !ForDT !ForAttr
  @resourceFor: ForDT
  @resourceFor: ForAttr
  
  @rdf:type:
    @@@: DISPerl|BlockCode
    @@ForCheck: ManakaiDOM|ForClass
  
  @QName:
    @@@: setDefinitionNode
    @@ForCheck: ForDT
  @QName:
    @@@: setDefinitionNodeAttr
    @@ForCheck: ForAttr

  @enImplNote:
    Currently <IF::x|DocumentType> nodes with no <A::Node.ownerDocument>
    are not allowed to contain any child or definition nodes.  It is
    also possible to set <A::Node.ownerDocument> of the <IF::x|DocumentType>
    when a node is appended or set to the slot in the <IF::x|DocumentType>.

    Future version of manakai might support implicit adoptation of 
    external nodes as Web browsers does.  In such an implementation
    setting <IF::x|DocumentType>'s <A::Node.ownerDocument> would be
    more desired than <X::c|DOMException.WRONG_DOCUMENT_ERR>.
  
  @PerlDef:
        my $__aname = $defNode-><AG::t|Node.nodeName>;
        my $__n = $self->{<H::mn:node>}->{$key}->{$__aname};
        SET: {
          if ($__n and $__n eq $defNode->{<H::mn:node>}) {
            last SET; # no effect
          }
          __CODE{NodeReadOnlyError}__;
           unless ($defNode-><AG::t|Node.ownerDocument> eq
                   $self-><AG::t|Node.ownerDocument>) {
             __EXCEPTION{c|DIFFERENT_DOCUMENT_ERR::
               MDOMX|param-name => {$defNodeParamName},
               c|node => {$defNode},
             }__;
          }
          my $__owner;
          __FOR{!ForAttr::
            $__owner = $defNode-><AG::ElementTypeDefinition
                                     .ownerDocumentTypeDefinition>;
          }__;
          __FOR{ForAttr::
            $__owner = $defNode-><AG::AttributeDefinition
                                     .ownerElementTypeDefinition>;
          }__;
          if ($__owner) {
            __EXCEPTION{c|INUSE_DEFINITION_ERR::
              MDOMX|param-name => {$defNodeParamName},
              c|node => {$defNode},
            }__;
          }
          
          if ($__n) {
            if (defined wantarray) {
              $r = <ClassM::t|ManakaiDOMNode.getNodeReference> ($__n);
            }
            CORE::delete $__n->{<H::d|ownerDefinition>};
            $__n-><M::NodeStem.orphanate>;
          }
          
          $self->{<H::mn:node>}-><M::NodeStem.importTree>
                                   ($defNode->{<H::mn:node>});
          $defNode->{<H::mn:node>}
                  ->{<H::d|ownerDefinition>}
            = $self->{<H::mn:node>};
          $self->{<H::mn:node>}
               ->{$key}->{$__aname} = $defNode->{<H::mn:node>};
        } # SET
##setDefinitionNode

IFClsXDef:
  @IFQName: AttributeDefinition
  @ClsQName: ManakaiDOMAttributeDefinition
  
  @IFISA: t|Node
  @ClsISA: t|ManakaiDOMNode
  
  @DISLang:role: c|AttributeRole

  @f:implements: d|Feature30
  
  @enDesc:
    An <IF::AttributeDefinition> attribute represents
    the definition for an attribute.
    
    The child list of an <IF::AttributeDefinition>
    represents the default value for the attribute.
    It can contain the same types of nodes as
    <IF::t|Attr> nodes.  It is ignored for the
    purposes of e.g. default value suppliment and
    serialization, if <A::AttributeDefinition.defaultType>
    has values other than 
    <C::AttributeDefinition.EXPLICIT_DEFAULT> or
    <C::AttributeDefinition.FIXED_DEFAULT>.

  @ResourceDef:
    @@ForCheck: ManakaiDOM|ForClass
    @@QName: newATForTest
    @@rdf:type: DISPerl|BlockCode
    @@PerlDef:
      my $doc;
      __CODE{newDocumentForTest}__;
      $at = $doc-><M::DocumentXDoctype.createAttributeDefinition>
                          ('at1');

  @Test:
    @@PerlDef:
      my $at;
      __CODE{newATForTest}__;

      $test->assert_not_null ($at);
      $test->assert_isa ($at, <IFName::AttributeDefinition>);

      my $od = $at-><AG::Node.ownerDocument>;
      $test->assert_not_null ($od);
      $test->assert_not_null ($od-><M::Node.getFeature>
                                     (<Q::ManakaiDOM|XDoctype>));

  @Attr:
    @@ForCheck: ManakaiDOM|ForClass
    @@Name: nodeType
    @@enDesc:
      The type of the node.
    @@Type: idl|unsignedShort||ManakaiDOM|all
    @@dis:actualType: t|NodeType
    @@Get:
      @@@disDef:
        @@@@DISLang:constValue: t|Node.ATTRIBUTE_DEFINITION_NODE
    @@Test:
      @@@PerlDef:
        my $at;
        __CODE{newATForTest}__;

        $test->assert_num_equals
                 (actual_value => $at-><AG::Node.nodeType>,
                  expected_value => <C::Node.ATTRIBUTE_DEFINITION_NODE>);
      
  @Attr:
    @@ForCheck: ManakaiDOM|ForClass
    @@Name: nodeName
    @@enDesc:
      The name of the attribute.
    @@DOMMain:isNamespaceUnaware: 1
    @@Type: DOMString
    @@Get:
      @@@disDef:
        @@@@GetProp: c|name
    @@Test:
      @@@PerlDef:
        my $at;
        __CODE{newATForTest}__;

        $test->assert_equals ($at-><AG::Node.nodeName>, 'at1');
  
  @Attr:
    @@ForCheck: ManakaiDOM|ForClass
    @@Name: nodeValue
    @@enDesc:
      The normalized default value of the attribute.
    @@Type: DOMString
    @@Get:
      @@@enDesc:
        The concatenation of the text content of every
        child node.  For <IF::t|Text> children, the
        text content of a node is the <A::t|Node.textContent>
        attribute value.  For <IF::x|EntityReference>
        children, the text content of a node is the
        <A::t|Node.textContent> attribute value with
        any <CODE::U+0009>, <CODE::U+000A>, and
        <CODE::U+000D> replaced by <CODE::U+0020>.
        
        If the <A::AttributeDefinition.declaredType>
        of the node is different from 
        <C::AttributeDefinition.NO_TYPE_ATTR>,
        <C::AttributeDefinition.UNKNOWN_ATTR>, or
        <C::AttributeDefinition,CDATA_ATTR>, the value
        is further modified by discarding any leading
        and trailing <CODE::U+0020> characters and
        by replacing sequences of <CODE::U+0020> characters
        by a single <CODE::U+0020> character.
      @@@nullCase:
        @@@@enDesc:
          If the <A::AttributeDefinition.defaultType>
          is different from <C::AttributeDefinition.FIXED_DEFAULT>
          or <C::AttributeDefinition.EXPLICIT_DEFAULT>.
      @@@PerlDef:
        __DEEP{
          my $dt = $self-><AG::AttributeDefinition.defaultType>;
          if ($dt == <C::AttributeDefinition.EXPLICIT_DEFAULT> or
              $dt == <C::AttributeDefinition.FIXED_DEFAULT>) {
            for my $child (@{$self-><AG::t|Node.childNodes>}) {
              if ($child-><AG::t|Node.nodeType> ==
                  <C::t|Node.ENTITY_REFERENCE_NODE>) {
                my $v = $child-><AG::t|Node.textContent>;
                $v =~ s/[\x09\x0A\x0D]/ /;
                $r .= $v;
              } else {
                $r .= $child-><AG::t|Node.textContent>;
              }
            } # childNodes
            my $vt = $self-><AG::AttributeDefinition.declaredType>;
            unless ($vt == <C::AttributeDefinition.NO_TYPE_ATTR> or
                    $vt == <C::AttributeDefinition.UNKNOWN_ATTR> or
                    $vt == <C::AttributeDefinition.CDATA_ATTR>) {
              $r =~ s/\A\x20+//;
              $r =~ s/\x20+\z//;
              $r =~ s/\x20+/ /g;
            }
          } else {
            $r = null;
          }
        }__;
    @@Set:
      @@@enDesc:
        Any children are removed and if the new value
        is not empty or <DOM::null>, replaced by a single
        <IF::t|Text> node containgin the value the
        attribute is set to.
        
        If the <A::AttributeDefinition.defaultType>
        is different from <C::AttributeDefinition.FIXED_DEFAULT>
        or <C::AttributeDefinition.EXPLICIT_DEFAULT>, however,
        setting the attribute has no effect.
      @@@NodeReadOnlyError:
      @@@PerlDef:
        __DEEP{
          my $dt = $self-><AG::AttributeDefinition.defaultType>;
          if ($dt == <C::AttributeDefinition.EXPLICIT_DEFAULT> or
              $dt == <C::AttributeDefinition.FIXED_DEFAULT>) {
            __UNDEEP{
              __CODE{NodeReadOnlyError}__;
            }__;
            my @children = @{$self-><AG::t|Node.childNodes>};
            for my $child (@children) {
              $self-><M::t|Node.removeChild> ($child);
            } # childNodes
            if (defined $given and length $given) {
              $self-><M::t|Node.appendChild>
                ($self-><AG::t|Node.ownerDocument>
                      -><M::t|Document.createTextNode>
                          ($given));
            }
          }
        }__;
    @@Test:
      @@@QName: 
        ManakaiDOMAttributeDefinition.nodeValue.get.test
      @@@PerlDef:
        my $at;
        __CODE{newATForTest}__;

        $test->id ('get-empty-content');

        $at-><AS::AttributeDefinition.defaultType>
               (<C::AttributeDefinition.UNKNOWN_DEFAULT>);
        $test->assert_null ($at-><AG::Node.nodeValue>);
        $at-><AS::AttributeDefinition.defaultType>
               (<C::AttributeDefinition.IMPLIED_DEFAULT>);
        $test->assert_null ($at-><AG::Node.nodeValue>);
        $at-><AS::AttributeDefinition.defaultType>
               (<C::AttributeDefinition.REQUIRED_DEFAULT>);
        $test->assert_null ($at-><AG::Node.nodeValue>);
        $at-><AS::AttributeDefinition.defaultType>
               (<C::AttributeDefinition.EXPLICIT_DEFAULT>);
        $test->assert_string
                 (actual_value => $at-><AG::Node.nodeValue>,
                  expected_value => '');
        $at-><AS::AttributeDefinition.defaultType>
               (<C::AttributeDefinition.FIXED_DEFAULT>);
        $test->assert_string
                 (actual_value => $at-><AG::Node.nodeValue>,
                  expected_value => '');

        $test->id ('get-string-content');

        my $doc = $at-><AG::Node.ownerDocument>;
        $at-><M::Node.appendChild>
               ($doc-><M::Document.createTextNode> ('  abcdefg'));

        $at-><AS::AttributeDefinition.defaultType>
               (<C::AttributeDefinition.UNKNOWN_DEFAULT>);
        $test->assert_null ($at-><AG::Node.nodeValue>);
        $at-><AS::AttributeDefinition.defaultType>
               (<C::AttributeDefinition.IMPLIED_DEFAULT>);
        $test->assert_null ($at-><AG::Node.nodeValue>);
        $at-><AS::AttributeDefinition.defaultType>
               (<C::AttributeDefinition.REQUIRED_DEFAULT>);
        $test->assert_null ($at-><AG::Node.nodeValue>);
        $at-><AS::AttributeDefinition.defaultType>
               (<C::AttributeDefinition.EXPLICIT_DEFAULT>);
        $test->assert_string
                 (actual_value => $at-><AG::Node.nodeValue>,
                  expected_value => '  abcdefg');
        $at-><AS::AttributeDefinition.defaultType>
               (<C::AttributeDefinition.FIXED_DEFAULT>);
        $test->assert_string
                 (actual_value => $at-><AG::Node.nodeValue>,
                  expected_value => '  abcdefg');

        $test->id ('multiple-text-nodes');
  
        $at-><M::Node.appendChild>
               ($doc-><M::Document.createTextNode> ('ABCDEFG '));
        $test->assert_string
                 (actual_value => $at-><AG::Node.nodeValue>,
                  expected_value => '  abcdefgABCDEFG ');

        $test->id ('white-space');

        $at-><M::Node.appendChild>
               ($doc-><M::Document.createTextNode>
                        ("\x20\x20,\x20\x09,\x20\x0A,\x20\x0D,  "));

        $at-><AS::AttributeDefinition.declaredType>
               (<C::AttributeDefinition.UNKNOWN_ATTR>);
        $test->assert_string
                 (actual_value => $at-><AG::Node.nodeValue>,
                  expected_value => "  abcdefgABCDEFG   , \x09, \x0A, \x0D,  ");
        $at-><AS::AttributeDefinition.declaredType>
               (<C::AttributeDefinition.CDATA_ATTR>);
        $test->assert_string
                 (actual_value => $at-><AG::Node.nodeValue>,
                  expected_value => "  abcdefgABCDEFG   , \x09, \x0A, \x0D,  ");
        $at-><AS::AttributeDefinition.declaredType>
               (<C::AttributeDefinition.ID_ATTR>);
        $test->assert_string
                 (actual_value => $at-><AG::Node.nodeValue>,
                  expected_value => "abcdefgABCDEFG , \x09, \x0A, \x0D,");
        $at-><AS::AttributeDefinition.declaredType>
               (<C::AttributeDefinition.IDREF_ATTR>);
        $test->assert_string
                 (actual_value => $at-><AG::Node.nodeValue>,
                  expected_value => "abcdefgABCDEFG , \x09, \x0A, \x0D,");
          $at-><AS::AttributeDefinition.declaredType>
               (<C::AttributeDefinition.IDREFS_ATTR>);
        $test->assert_string
                 (actual_value => $at-><AG::Node.nodeValue>,
                  expected_value => "abcdefgABCDEFG , \x09, \x0A, \x0D,");
        $at-><AS::AttributeDefinition.declaredType>
               (<C::AttributeDefinition.ENTITY_ATTR>);
        $test->assert_string
                 (actual_value => $at-><AG::Node.nodeValue>,
                  expected_value => "abcdefgABCDEFG , \x09, \x0A, \x0D,");
        $at-><AS::AttributeDefinition.declaredType>
               (<C::AttributeDefinition.ENTITIES_ATTR>);
        $test->assert_string
                 (actual_value => $at-><AG::Node.nodeValue>,
                  expected_value => "abcdefgABCDEFG , \x09, \x0A, \x0D,");
        $at-><AS::AttributeDefinition.declaredType>
               (<C::AttributeDefinition.NMTOKEN_ATTR>);
        $test->assert_string
                 (actual_value => $at-><AG::Node.nodeValue>,
                  expected_value => "abcdefgABCDEFG , \x09, \x0A, \x0D,");
        $at-><AS::AttributeDefinition.declaredType>
               (<C::AttributeDefinition.NMTOKENS_ATTR>);
        $test->assert_string
                 (actual_value => $at-><AG::Node.nodeValue>,
                  expected_value => "abcdefgABCDEFG , \x09, \x0A, \x0D,");
        $at-><AS::AttributeDefinition.declaredType>
               (<C::AttributeDefinition.NOTATION_ATTR>);
        $test->assert_string
                 (actual_value => $at-><AG::Node.nodeValue>,
                  expected_value => "abcdefgABCDEFG , \x09, \x0A, \x0D,");
        $at-><AS::AttributeDefinition.declaredType>
               (<C::AttributeDefinition.ENUMERATION_ATTR>);
        $test->assert_string
                 (actual_value => $at-><AG::Node.nodeValue>,
                  expected_value => "abcdefgABCDEFG , \x09, \x0A, \x0D,");
    @@Test:
      @@@QName: 
        ManakaiDOMAttributeDefinition.nodeValue.set.test
      @@@PerlDef:
        my $at;
        __CODE{newATForTest}__;
        my $doc = $at-><AG::Node.ownerDocument>;

        $test->id ('set-no-effect');

        $at-><M::Node.appendChild>
               (my $t = $doc-><M::Document.createTextNode> ('abcdefg'));

        $test->assert_not_null ($t-><AG::Node.parentNode>);

        $at-><AS::AttributeDefinition.defaultType>
               (<C::AttributeDefinition.UNKNOWN_DEFAULT>);
        $at-><AS::Node.nodeValue> ('VWXYZ');
        $test->assert_not_null ($t-><AG::Node.parentNode>);

        $at-><AS::AttributeDefinition.defaultType>
               (<C::AttributeDefinition.IMPLIED_DEFAULT>);
        $at-><AS::Node.nodeValue> ('VWXYZ');
        $test->assert_not_null ($t-><AG::Node.parentNode>);

        $at-><AS::AttributeDefinition.defaultType>
               (<C::AttributeDefinition.REQUIRED_DEFAULT>);
        $at-><AS::Node.nodeValue> ('VWXYZ');
        $test->assert_not_null ($t-><AG::Node.parentNode>);

        $test->id ('set-value');

        $at-><AS::AttributeDefinition.defaultType>
               (<C::AttributeDefinition.EXPLICIT_DEFAULT>);
        $at-><AS::Node.nodeValue> ('VWXYZ');
        $test->assert_null ($t-><AG::Node.parentNode>);
        $test->assert_string
                 (actual_value => $at-><AG::Node.nodeValue>,
                  expected_value => 'VWXYZ');

        $at-><M::Node.appendChild> ($t);
        $test->assert_not_null ($t-><AG::Node.parentNode>);

        $at-><AS::AttributeDefinition.defaultType>
               (<C::AttributeDefinition.FIXED_DEFAULT>);
        $at-><AS::Node.nodeValue> ('VWXYZ');
        $test->assert_null ($t-><AG::Node.parentNode>);
        $test->assert_string
                 (actual_value => $at-><AG::Node.nodeValue>,
                  expected_value => 'VWXYZ');

        $at-><AS::Node.nodeValue> ('');
        $test->assert_false ($at-><M::Node.hasChildNodes>);
        
        $at-><M::Node.appendChild> ($t);

        $at-><AS::Node.nodeValue> (null);
        $test->assert_false ($at-><M::Node.hasChildNodes>);

  @Attr:
    @@ForCheck: ManakaiDOM|ForClass
    @@Name: textContent
    @@enDesc:
      The normalized default value of the attribute.
    @@Type: DOMString
    @@Get:
      @@@enDesc:
        The concatenation of the <A::t|Node.textContent>
        of every child node.
      @@@PerlDef:
        __DEEP{
          for my $child (@{$self-><AG::t|Node.childNodes>}) {
            $r .= $child-><AG::t|Node.textContent>;
          } # childNodes
        }__;
    @@Set:
      @@@enDesc:
        Setting on this attribute has the same effect
        as <A::t|Node.nodeValue>.
      @@@NodeReadOnlyError:
      @@@disDef:
        @@@@DISPerl:cloneCode:
          ManakaiDOMAttributeDefinition.nodeValue.set
    @@Test:
      @@@QName: 
        ManakaiDOMAttributeDefinition.textContent.get.test
      @@@PerlDef:
        my $at;
        __CODE{newATForTest}__;

        $test->id ('get-empty-content');

        $test->assert_string
                 (actual_value => $at-><AG::Node.textContent>,
                  expected_value => '');

        $test->id ('get-string-content');

        my $doc = $at-><AG::Node.ownerDocument>;
        $at-><M::Node.appendChild>
               ($doc-><M::Document.createTextNode> ('  abcdefg'));

        $test->assert_string
                 (actual_value => $at-><AG::Node.textContent>,
                  expected_value => '  abcdefg');

        $test->id ('multiple-text-nodes');
  
        $at-><M::Node.appendChild>
               ($doc-><M::Document.createTextNode> ('ABCDEFG '));
        $test->assert_string
                 (actual_value => $at-><AG::Node.textContent>,
                  expected_value => '  abcdefgABCDEFG ');

        $test->id ('white-space');

        $at-><M::Node.appendChild>
               ($doc-><M::Document.createTextNode>
                        ("\x20\x20,\x20\x09,\x20\x0A,\x20\x0D,  "));

        $at-><AS::AttributeDefinition.declaredType>
               (<C::AttributeDefinition.CDATA_ATTR>);
        $test->assert_string
                 (actual_value => $at-><AG::Node.textContent>,
                  expected_value => "  abcdefgABCDEFG   , \x09, \x0A, \x0D,  ");
        $at-><AS::AttributeDefinition.declaredType>
               (<C::AttributeDefinition.ID_ATTR>);
        $test->assert_string
                 (actual_value => $at-><AG::Node.textContent>,
                  expected_value => "  abcdefgABCDEFG   , \x09, \x0A, \x0D,  ");
    @@Test:
      @@@QName: 
        ManakaiDOMAttributeDefinition.textContent.set.test
      @@@PerlDef:
        my $at;
        __CODE{newATForTest}__;
        my $doc = $at-><AG::Node.ownerDocument>;

        $test->id ('set-no-effect');

        $at-><M::Node.appendChild>
               (my $t = $doc-><M::Document.createTextNode> ('abcdefg'));

        $test->assert_not_null ($t-><AG::Node.parentNode>);

        $at-><AS::AttributeDefinition.defaultType>
               (<C::AttributeDefinition.UNKNOWN_DEFAULT>);
        $at-><AS::Node.textContent> ('VWXYZ');
        $test->assert_not_null ($t-><AG::Node.parentNode>);

        $test->id ('set-value');

        $at-><AS::AttributeDefinition.defaultType>
               (<C::AttributeDefinition.EXPLICIT_DEFAULT>);
        $at-><AS::Node.textContent> ('VWXYZ');
        $test->assert_null ($t-><AG::Node.parentNode>);
        $test->assert_string
                 (actual_value => $at-><AG::Node.textContent>,
                  expected_value => 'VWXYZ');

        $at-><AS::Node.textContent> ('');
        $test->assert_false ($at-><M::Node.hasChildNodes>);
        
        $at-><M::Node.appendChild> ($t);

        $at-><AS::Node.textContent> (null);
        $test->assert_false ($at-><M::Node.hasChildNodes>);
  
  @Attr:
    @@Name: ownerElementTypeDefinition
    @@enDesc:
      The element type definition for which
      the attribute is defined.
    @@Type: ElementTypeDefinition
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          If the attribute definition is not associated
          with any element type.
      @@@disDef:
        @@@@GetPropNode: d|ownerDefinition
    @@Test:
      @@@QName: 
        ManakaiDOMAttributeDefinition.ownerElementTypeDefinition.get.test
      @@@PerlDef:
        my $at;
        __CODE{newATForTest}__;
        my $doc = $at-><AG::Node.ownerDocument>
                     -><M::Node.getFeature> (<Q::ManakaiDOM|XDoctype>);

        $test->assert_null
                 ($at-><AG::AttributeDefinition.ownerElementTypeDefinition>);

        my $et = $doc-><M::DocumentXDoctype.createElementTypeDefinition>
                         ('et1');
        $et-><M::ElementTypeDefinition.setAttributeDefinitionNode> ($at);
        
        $test->assert_equals
                 ($at-><AG::AttributeDefinition.ownerElementTypeDefinition>,
                  $et);

        $test->assert_isa
                 ($at-><AG::AttributeDefinition.ownerElementTypeDefinition>,
                  <IFName::ElementTypeDefinition>);
  
  @ShortConstGroup:
    @@IFQName: DeclaredValueType
    @@enDesc:
      An integer that indicates the type of
      attribute value.
    
    @@Const:
      @@@Name: NO_TYPE_ATTR
      @@@intValue: 0
      @@@enDesc:
        The attribute value type is <QUOTE::no value> (see XML Infoset).
    @@Const:
      @@@Name: CDATA_ATTR
      @@@intValue: 1
      @@@enDesc:
        The attribute value type is <XML::CDATA>.
    @@Const:
      @@@Name: ID_ATTR
      @@@intValue: 2
      @@@enDesc:
        The attribute value type is <XML::ID>.
    @@Const:
      @@@Name: IDREF_ATTR
      @@@intValue: 3
      @@@enDesc:
        The attribute value type is <XML::IDREF>.
    @@Const:
      @@@Name: IDREFS_ATTR
      @@@intValue: 4
      @@@enDesc:
        The attribute value type is <XML::IDREFS>.
    @@Const:
      @@@Name: ENTITY_ATTR
      @@@intValue: 5
      @@@enDesc:
        The attribute value type is <XML::ENTITY>;
    @@Const:
      @@@Name: ENTITIES_ATTR
      @@@intValue: 6
      @@@enDesc:
        The attribute value type is <XML::ENTITIES>.
    @@Const:
      @@@Name: NMTOKEN_ATTR
      @@@intValue: 7
      @@@enDesc:
        The attribute value type is <XML::NMTOKEN>.
    @@Const:
      @@@Name: NMTOKENS_ATTR
      @@@intValue: 8
      @@@enDesc:
        The attribute value type is <XML::NMTOKENS>.
    @@Const:
      @@@Name: NOTATION_ATTR
      @@@intValue: 9
      @@@enDesc:
        The attribute value is <XML::NOTATION> enumerated
        type.
    @@Const:
      @@@Name: ENUMERATION_ATTR
      @@@intValue: 10
      @@@enDesc:
        The attribute value is enumuration type.
    @@Const:
      @@@Name: UNKNOWN_ATTR
      @@@intValue: 11
      @@@enDesc:
        The attribute value is unknown, because no declaration
        for the attribute has been read but not <InfoProp::all declareations
        processed>.
  
  @Attr:
    @@Name: declaredType
    @@enDesc:
      The type of attribute value.
    @@Type: idl|unsignedShort||ManakaiDOM|all
    @@dis:actualType: DeclaredValueType
    @@Get:
      @@@disDef:
        @@@@GetProp: d|declaredType
    @@Set:
      @@@NodeReadOnlyError:
      @@@disDef:
        @@@@SetProp:
          @@@@@@: d|declaredType
          @@@@@CheckReadOnly: 1
    @@Test:
      @@@QName: 
        ManakaiDOMAttributeDefinition.declaredType.test
      @@@PerlDef:
        my $at;
        __CODE{newATForTest}__;

        $test->assert_num_equals
                 (actual_value => $at-><AG::AttributeDefinition.defaultType>,
                  expected_value => <C::AttributeDefinition.NO_TYPE_ATTR>);

        $at-><AS::AttributeDefinition.defaultType>
               (<C::AttributeDefinition.ID_ATTR>);
        $test->assert_num_equals
                 (actual_value => $at-><AG::AttributeDefinition.defaultType>,
                  expected_value => <C::AttributeDefinition.ID_ATTR>);

  @ShortConstGroup:
    @@IFQName: DefaultValueType
    @@enDesc:
      An integer indicating the type of default value.
    
    @@Const:
      @@@Name: UNKNOWN_DEFAULT
      @@@intValue: 0
      @@@enDesc:
        The default value is unknown.
    @@Const:
      @@@Name: FIXED_DEFAULT
      @@@intValue: 1
      @@@enDesc:
        The default value is <XML::#FIXED>.
    @@Const:
      @@@Name: REQUIRED_DEFAULT
      @@@intValue: 2
      @@@enDesc:
        An attribute specification is required
        for the attribute.
    @@Const:
      @@@Name: IMPLIED_DEFAULT
      @@@intValue: 3
      @@@enDesc:
        The default value is <XML::#IMPLIED>.
    @@Const:
      @@@Name: EXPLICIT_DEFAULT
      @@@intValue: 4
      @@@enDesc:
        An explicit but not fixed default value
        is provided.
  
  @Attr:
    @@Name: defaultType
    @@enDesc:
      The type of attribute default value.
    @@Type: idl|unsignedShort||ManakaiDOM|all
    @@dis:actualType: DefaultValueType
    @@Get:
      @@@disDef:
        @@@@GetProp: d|defaultType
    @@Set:
      @@@NodeReadOnlyError:
      @@@disDef:
        @@@@SetProp:
          @@@@@@: d|defaultType
          @@@@@CheckReadOnly: 1
    @@Test:
      @@@QName: 
        ManakaiDOMAttributeDefinition.defaultType.test
      @@@PerlDef:
        my $at;
        __CODE{newATForTest}__;

        $test->assert_num_equals
                 (actual_value => $at-><AG::AttributeDefinition.defaultType>,
                  expected_value => <C::AttributeDefinition.UNKNOWN_DEFAULT>);

        $at-><AS::AttributeDefinition.defaultType>
               (<C::AttributeDefinition.EXPLICIT_DEFAULT>);
        $test->assert_num_equals
                 (actual_value => $at-><AG::AttributeDefinition.defaultType>,
                  expected_value => <C::AttributeDefinition.EXPLICIT_DEFAULT>);

  @Attr:
    @@Name: allowedTokens
    @@enDesc:
      The live list of the allowed tokens for the
      attribute.
      
      The list <kwd:MAY> be empty even if 
      the <A::Attribute.declaredType> is 
      <C::AttributeDefinition.NOTATION_ATTR> or
      <C::AttributeDefinition.ENUMERATION_ATTR>.
      Then, validation using this definition never
      success.
      
      The list <kwd:MAY> be non-empty even if 
      the <A::Attribute.declaredType> is different
      from <C::AttributeDefinition.NOTATION_ATTR> or
      <C::AttributeDefinition.ENUMERATION_ATTR>.  This
      attribute is ignored for the purposes of
      e,g, validation and serialization in such cases.
      
      The list <kwd:MAY> contain a string that does
      not match to the production <CODE::Name> or
      <CODE::Nmtoken>.
      
      The list <kwd:MAY> contain duplications.
      
      The result of processing using the attribute
      definition, e.g. validation or serialization,
      is implementation dependent unless otherwise specified
      if one or more errors defined above is detected.
      That is, implementations <kwd:MAY> ignore erroreous
      value, <kwd:MAY> validate a value that is actually
      invalid, <kwd:MAY> report an error by <IF::c|DOMError>,
      or <kwd:MAY> choose any other possible error
      recovery method.  However, it <kwd:MUST> recover
      from the error gracefully.  Note that the validation
      of the attribute definition itself is not a case.
      For example, dupulication of values must be
      reported as a validity constraint violation by
      validity checker for the attribute definition.
    @@Type: c|DOMStringList
    @@Get:
      @@@PerlDef:
        __CODE{d|getRef::
          $object => {$self->{<H::mn:node>}},
          $ref => {$r},
          $class => {<ClassName::c|ManakaiDOMStringList>},
        }__;
        $r->{<H::c|key>} = <H::d|allowedTokens>;
    @@Test:
      @@@QName: 
        ManakaiDOMAttributeDefinition.allowedTokens.get.test
      @@@PerlDef:
        my $at;
        __CODE{newATForTest}__;

        my $list = $at-><AG::AttributeDefinition.allowedTokens>;
        $test->assert_not_null ($list);
        $test->assert_isa ($list, <IFName::c|DOMStringList>);

        $test->assert_num_equals
                 (actual_value => 0 + @$list,
                  expected_value => 0);
      
        push @$list, 'NMTOKEN1';
        $test->assert_string
                 (actual_value => $list->[0],
                  expected_value => 'NMTOKEN1');
        undef $list;

        my $list2 = $at-><AG::AttributeDefinition.allowedTokens>;
        $test->assert_string
                 (actual_value => $list2->[0],
                  expected_value => 'NMTOKEN1');

  @CAttr:
    @@Name: baseURI
    @@enDesc:
      The base DOM URI of the node.  It <kwd:MUST> be the same
      value as the <A::Node.baseURI> attribute value of the
      <A::Node.ownerDocument> node of the node.
    @@Type: DOMString
    @@dis:actualType: ManakaiDOM|ManakaiDOMURI
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          If <A::Node.baseURI> of the <A::Node.ownerDocument> is
          <DOM::null>.
      @@@PerlDef:
        __DEEP{
          $r = $self-><AG::Node.ownerDocument>-><AG::Node.baseURI>;
        }__;

    @@Test:
      @@@QName: ATDef.baseURI.test
      @@@PerlDef:
        my $et;
        __CODE{newATForTest:: $at => $et}__;
 
        my $doc = $et-><AG::Node.ownerDocument>;
 
        $test->id ('initial');
        $test->assert_null ($et-><AG::Node.baseURI>);

        $test->id ('doc');
        $doc-><AS::Document.documentURI> (q<http://doc.test/>);
        $test->assert_equals
                 ($et-><AG::Node.baseURI>,
                  q<http://doc.test/>);

  @Method:
    @@ForCheck: ManakaiDOM|ForClass
    @@ManakaiDOM:isForInternal: 1
    @@Name: newObject
    @@NewObjectRefNodeParam:
    @@Return:
      @@@Type: NodeStem
      @@@PerlDef:
        $r = <ClassM::t|ManakaiDOMNode.newObject> ($self, $refNode);
        $r->{<H::c|nodeType>} = <H::d|AttributeDefinitionNodeType>;
        $r->{<H::d|declaredType>}
          = <C::AttributeDefinition.NO_TYPE_ATTR>;
        $r->{<H::d|allowedTokens>} = [];
        $r->{<H::d|defaultType>}
          = <C::AttributeDefinition.UNKNOWN_DEFAULT>;
        $r->{<H::infoset:children>} = [];
    @@enImplNote:
      Required properties:
        <Q::c|nodeType>, <Q::c|ownerDocument>,
        <Q::c|name>, <Q::d|declaredType>, <Q::d|allowedTokens>,
        <Q::d|defaultType>, <Q::infoset:children>.
      
      Optional properties:
        <Q::c|read-only>,
        <Q::d|ownerDefinition>.
  @mn:xrefnode0: c|ownerDocument
  @mn:origin0: d|ownerDefinition
  @mn:subnode1: infoset|children
##AttributeDefinition

ResourceDef:
  @For: =ManakaiDOM|all
  @QName: d|ElementTypeDefinitionNodeType
  @rdf:type: rdfs|Resource

ResourceDef:
  @For: =ManakaiDOM|all
  @QName: d|AttributeDefinitionNodeType
  @rdf:type: rdfs|Resource

PropDef:
  @QName: d|allowedTokens

ElementTypeBinding:
  @Name: intValue
  @ElementType:
    dis:Value
  @ShadowContent:
    @@ContentType: DISCore|Integer

ElementTypeBinding:
  @Name: NewObjectRefNodeParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@Name: refNode
    @@Type: NodeStem
    @@Description:
      @@@lang:en
      @@@@:
        A node from the tree to which the new node will belong.
    @@rdf:type: DISLang|MethodParameter
    @@ResourceDef:
      @@@rdf:type: ManakaiDOM|InCase
      @@@Value:
        @@@@is-null:1
      @@@Description:
        @@@@lang:en
        @@@@@:
          The node belongs to a new tree.

ElementTypeBinding:
  @Name: enImplNote
  @ElementType:
    dis:ImplNote
  @ShadowContent:
    @@lang:en

ElementTypeBinding:
  @Name: enDesc
  @ElementType:
    dis:Description
  @ShadowContent:
    @@lang:en

enImplNote:
  {TODO::
    
    - Define <M::t|Node.cloneNode>, <M::t|Node.adoptNode>,
      <M::t|Node.importNode>, <M::t|Node.isEqualNode>,
      <M::t|Node.compareDocumentPosition>,
      namespace lookup methods
      for the new node types.
    
    - Implement <M::t|Node.getFeature>, <M::t|Node.hasFeature>,
      <M::f|GetFeature.hasFeature>.
    
  }

ResourceDef:
  @QName: DOMString
  @AliasFor: DOMMain|DOMString
  @For: ManakaiDOM|DOM

PropDef:
  @QName: d|ownerDefinition
  @enDesc:
    <A::ElementTypeDefinition.ownerDocumentTypeDefinition>,
    <A::AttributeDefinition.ownerElementTypeDefinition>,
    <A::EntityDefinition.ownerDocumentTypeDefinition>, or
    <A::NotationDefinition.ownerDocumentTypeDefinition>.

PropDef:
  @QName: d|attributeDefinitions

PropDef:
  @QName: d|declaredType

PropDef:
  @QName: d|defaultType

ResourceDef:
  @QName: Node
  @AliasFor: t|Node
  @For: ManakaiDOM|DOM

ResourceDef:
  @QName: Document
  @AliasFor: t|Document
  @For: ManakaiDOM|DOM

ResourceDef:
  @QName: Element
  @AliasFor: t|Element
  @For: ManakaiDOM|DOM

ResourceDef:
  @QName: Attr
  @AliasFor: t|Attr
  @For: ManakaiDOM|DOM

ResourceDef:
  @QName: PI
  @AliasFor: x|ProcessingInstruction
  @For: ManakaiDOM|DOM

ResourceDef:
  @QName: EntRef
  @AliasFor: x|EntityReference
  @For: ManakaiDOM|DOM
