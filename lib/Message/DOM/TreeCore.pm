#!/usr/bin/perl 
## This file is automatically generated
## 	at 2007-05-13T03:54:25+00:00,
## 	from file "TreeCore.dis",
## 	module <http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#ManakaiDOM.TreeCore>.
## Don't edit by hand!
use strict;
require Message::DOM::DOMCore;
require Message::DOM::DOMFeature;
require Message::Util::Error::DOMException;
require Tie::Array;
package Message::DOM::TreeCore;
our $VERSION = 20070513.0354;
$Message::DOM::DOMCore::ManakaiDOMConfiguration{'Message::DOM::IF::Document'}->{'http://suika.fam.cx/www/2006/dom-config/clone-entity-reference-subtree'} = {'iname',
'cerst',
'type',
'boolean',
'vsupport',
['1',
'1']};
$Message::DOM::DOMCore::ManakaiDOMConfiguration{'Message::DOM::IF::Document'}->{'http://suika.fam.cx/www/2006/dom-config/dtd-default-attribute'} = {'default',
'1',
'iname',
'dtddefault',
'type',
'boolean',
'vsupport',
['1',
'1']};
$Message::DOM::DOMCore::ManakaiDOMConfiguration{'Message::DOM::IF::Document'}->{'http://suika.fam.cx/www/2006/dom-config/dtd-attribute-type'} = {'default',
'1',
'iname',
'dtdattrtype',
'type',
'boolean',
'vsupport',
['1',
'1']};
$Message::DOM::DOMCore::ManakaiDOMConfiguration{'Message::DOM::IF::Document'}->{'http://suika.fam.cx/www/2006/dom-config/xml-id'} = {'default',
'1',
'iname',
'xmlid',
'type',
'boolean',
'vsupport',
['1',
'1']};
$Message::DOM::DOMCore::ManakaiDOMConfiguration{'Message::DOM::IF::Document'}->{'http://suika.fam.cx/www/2006/dom-config/strict-document-children'} = {'default',
'1',
'iname',
'sdocchild',
'type',
'boolean',
'vsupport',
['1',
'1']};
$Message::DOM::DOMCore::ManakaiDOMError::Def{'http://suika.fam.cx/~wakaba/archive/2005/manakai/DOM/TreeCore/wf-invalid-character-in-node-name'} = {'description',
'If the <cfg::c|well-formed> configuration parameter is set to <DOM::true> and a <A::Node.nodeName> contains invalid character according to its node type. Or, in <IF::DOMLS|LSSerializer>, if a character that cannot be represented in the output character encoding is occurred within markup.',
'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/Core/textFormatter',
'Message::Util::Error::formatter',
'sev',
'2',
't',
'wf-invalid-character-in-node-name'};
$Message::DOM::DOMCore::ManakaiDOMError::Def{'http://suika.fam.cx/~wakaba/archive/2005/manakai/DOM/TreeCore/wf-invalid-character'} = {'description',
'If the <cfg::well-formed> configuration parameter is set to <DOM::true> and the text content inside <IF::Attr>, <IF::Element>, <IF::Comment>, <IF::Text>, or <IF::tx|CDATASection> node or the data inside <IF::tx|ProcessingInstruction> node contains invalid characters. Or, in <IF::DOMLS:LSSerializer>, if the <cfg::split-cdata-sections> parameter is set to <DOM::false> and a <IF::tx|CDATASection> node contains characters that cannot be represented in the specified output encoding. This error is not recoverable.',
'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/Core/textFormatter',
'Message::Util::Error::formatter',
'sev',
'2',
't',
'wf-invalid-character'};
$Message::DOM::DOMCore::ManakaiDOMError::Def{'http://suika.fam.cx/~wakaba/archive/2004/dom/tree#setting-node-value-no-effect'} = {'description',
'An attempt is made to set the <A::Node.nodeValue> that is defined as <DOM::null>. The operation has no effect.',
'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/Core/textFormatter',
'Message::Util::Error::formatter',
'sev',
'1',
't',
'http://suika.fam.cx/~wakaba/archive/2004/dom/tree#setting-node-value-no-effect'};
$Message::DOM::DOMCore::ManakaiDOMError::Def{'http://suika.fam.cx/~wakaba/archive/2004/dom/tree#insert-before-itself'} = {'description',
'An attempt is made to insert a node before itself. The result is implementation dependent; it has no effect in manakai.',
'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/Core/textFormatter',
'Message::Util::Error::formatter',
'sev',
'1',
't',
'http://suika.fam.cx/~wakaba/archive/2004/dom/tree#insert-before-itself'};
$Message::DOM::DOMCore::ManakaiDOMError::Def{'http://suika.fam.cx/~wakaba/archive/2004/dom/tree#replace-by-itself'} = {'description',
'An attempt is made to replace a node by itself. The result is implementation dependent; it has no effect in manakai.',
'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/Core/textFormatter',
'Message::Util::Error::formatter',
'sev',
'1',
't',
'http://suika.fam.cx/~wakaba/archive/2004/dom/tree#replace-by-itself'};
$Message::DOM::DOMCore::ManakaiDOMError::Def{'http://suika.fam.cx/~wakaba/archive/2004/dom/tree#setting-prefix-no-effect-because-of-node'} = {'description',
'An attempt is made to set the <A::Node.prefix> that is defined as <DOM::null> since it is not an <IF::Element> or <IF::Attr> node or since it is a DOM Level 1 (i.e. namespace unaware) node. The operation has no effect.',
'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/Core/textFormatter',
'Message::Util::Error::formatter',
'sev',
'1',
't',
'http://suika.fam.cx/~wakaba/archive/2004/dom/tree#setting-prefix-no-effect-because-of-node'};
$Message::DOM::DOMCore::ManakaiDOMError::Def{'http://suika.fam.cx/~wakaba/archive/2004/dom/tree#setting-prefix-no-effect-because-of-document'} = {'description',
'An attempt is made to set the <A::Node.prefix> that is defined as <DOM::null> since its owner document does not support XML namespaces. The operation has no effect.',
'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/Core/textFormatter',
'Message::Util::Error::formatter',
'sev',
'1',
't',
'http://suika.fam.cx/~wakaba/archive/2004/dom/tree#setting-prefix-no-effect-because-of-document'};
sub ATTRIBUTE_DEFINITION_NODE ();
sub ATTRIBUTE_NODE ();
sub CDATA_SECTION_NODE ();
sub COMMENT_NODE ();
sub DOCUMENT_FRAGMENT_NODE ();
sub DOCUMENT_NODE ();
sub DOCUMENT_POSITION_CONTAINED_BY ();
sub DOCUMENT_POSITION_CONTAINS ();
sub DOCUMENT_POSITION_DISCONNECTED ();
sub DOCUMENT_POSITION_FOLLOWING ();
sub DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC ();
sub DOCUMENT_POSITION_PRECEDING ();
sub DOCUMENT_TYPE_NODE ();
sub ELEMENT_NODE ();
sub ELEMENT_TYPE_DEFINITION_NODE ();
sub ENTITY_NODE ();
sub ENTITY_REFERENCE_NODE ();
sub NODE_ADOPTED ();
sub NODE_CLONED ();
sub NODE_DELETED ();
sub NODE_IMPORTED ();
sub NODE_RENAMED ();
sub NOTATION_NODE ();
sub PROCESSING_INSTRUCTION_NODE ();
sub TEXT_NODE ();
sub AUTOLOAD {


        my $al = our $AUTOLOAD;
        $al =~ s/.+:://;
        if ({'ATTRIBUTE_DEFINITION_NODE',
'Message::DOM::IF::Node::ATTRIBUTE_DEFINITION_NODE',
'ATTRIBUTE_NODE',
'Message::DOM::IF::Node::ATTRIBUTE_NODE',
'CDATA_SECTION_NODE',
'Message::DOM::IF::Node::CDATA_SECTION_NODE',
'COMMENT_NODE',
'Message::DOM::IF::Node::COMMENT_NODE',
'DOCUMENT_FRAGMENT_NODE',
'Message::DOM::IF::Node::DOCUMENT_FRAGMENT_NODE',
'DOCUMENT_NODE',
'Message::DOM::IF::Node::DOCUMENT_NODE',
'DOCUMENT_POSITION_CONTAINED_BY',
'Message::DOM::IF::Node::DOCUMENT_POSITION_CONTAINED_BY',
'DOCUMENT_POSITION_CONTAINS',
'Message::DOM::IF::Node::DOCUMENT_POSITION_CONTAINS',
'DOCUMENT_POSITION_DISCONNECTED',
'Message::DOM::IF::Node::DOCUMENT_POSITION_DISCONNECTED',
'DOCUMENT_POSITION_FOLLOWING',
'Message::DOM::IF::Node::DOCUMENT_POSITION_FOLLOWING',
'DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC',
'Message::DOM::IF::Node::DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC',
'DOCUMENT_POSITION_PRECEDING',
'Message::DOM::IF::Node::DOCUMENT_POSITION_PRECEDING',
'DOCUMENT_TYPE_NODE',
'Message::DOM::IF::Node::DOCUMENT_TYPE_NODE',
'ELEMENT_NODE',
'Message::DOM::IF::Node::ELEMENT_NODE',
'ELEMENT_TYPE_DEFINITION_NODE',
'Message::DOM::IF::Node::ELEMENT_TYPE_DEFINITION_NODE',
'ENTITY_NODE',
'Message::DOM::IF::Node::ENTITY_NODE',
'ENTITY_REFERENCE_NODE',
'Message::DOM::IF::Node::ENTITY_REFERENCE_NODE',
'NODE_ADOPTED',
'Message::DOM::IF::UserDataHandler::NODE_ADOPTED',
'NODE_CLONED',
'Message::DOM::IF::UserDataHandler::NODE_CLONED',
'NODE_DELETED',
'Message::DOM::IF::UserDataHandler::NODE_DELETED',
'NODE_IMPORTED',
'Message::DOM::IF::UserDataHandler::NODE_IMPORTED',
'NODE_RENAMED',
'Message::DOM::IF::UserDataHandler::NODE_RENAMED',
'NOTATION_NODE',
'Message::DOM::IF::Node::NOTATION_NODE',
'PROCESSING_INSTRUCTION_NODE',
'Message::DOM::IF::Node::PROCESSING_INSTRUCTION_NODE',
'TEXT_NODE',
'Message::DOM::IF::Node::TEXT_NODE'}->{$al}) {
          no strict 'refs';
          *{$AUTOLOAD} = \&{{'ATTRIBUTE_DEFINITION_NODE',
'Message::DOM::IF::Node::ATTRIBUTE_DEFINITION_NODE',
'ATTRIBUTE_NODE',
'Message::DOM::IF::Node::ATTRIBUTE_NODE',
'CDATA_SECTION_NODE',
'Message::DOM::IF::Node::CDATA_SECTION_NODE',
'COMMENT_NODE',
'Message::DOM::IF::Node::COMMENT_NODE',
'DOCUMENT_FRAGMENT_NODE',
'Message::DOM::IF::Node::DOCUMENT_FRAGMENT_NODE',
'DOCUMENT_NODE',
'Message::DOM::IF::Node::DOCUMENT_NODE',
'DOCUMENT_POSITION_CONTAINED_BY',
'Message::DOM::IF::Node::DOCUMENT_POSITION_CONTAINED_BY',
'DOCUMENT_POSITION_CONTAINS',
'Message::DOM::IF::Node::DOCUMENT_POSITION_CONTAINS',
'DOCUMENT_POSITION_DISCONNECTED',
'Message::DOM::IF::Node::DOCUMENT_POSITION_DISCONNECTED',
'DOCUMENT_POSITION_FOLLOWING',
'Message::DOM::IF::Node::DOCUMENT_POSITION_FOLLOWING',
'DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC',
'Message::DOM::IF::Node::DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC',
'DOCUMENT_POSITION_PRECEDING',
'Message::DOM::IF::Node::DOCUMENT_POSITION_PRECEDING',
'DOCUMENT_TYPE_NODE',
'Message::DOM::IF::Node::DOCUMENT_TYPE_NODE',
'ELEMENT_NODE',
'Message::DOM::IF::Node::ELEMENT_NODE',
'ELEMENT_TYPE_DEFINITION_NODE',
'Message::DOM::IF::Node::ELEMENT_TYPE_DEFINITION_NODE',
'ENTITY_NODE',
'Message::DOM::IF::Node::ENTITY_NODE',
'ENTITY_REFERENCE_NODE',
'Message::DOM::IF::Node::ENTITY_REFERENCE_NODE',
'NODE_ADOPTED',
'Message::DOM::IF::UserDataHandler::NODE_ADOPTED',
'NODE_CLONED',
'Message::DOM::IF::UserDataHandler::NODE_CLONED',
'NODE_DELETED',
'Message::DOM::IF::UserDataHandler::NODE_DELETED',
'NODE_IMPORTED',
'Message::DOM::IF::UserDataHandler::NODE_IMPORTED',
'NODE_RENAMED',
'Message::DOM::IF::UserDataHandler::NODE_RENAMED',
'NOTATION_NODE',
'Message::DOM::IF::Node::NOTATION_NODE',
'PROCESSING_INSTRUCTION_NODE',
'Message::DOM::IF::Node::PROCESSING_INSTRUCTION_NODE',
'TEXT_NODE',
'Message::DOM::IF::Node::TEXT_NODE'}->{$al}};
          goto &{$AUTOLOAD};
        } else {
          require Carp;
          Carp::croak (qq<Can't locate method "$AUTOLOAD">);
        }
      
}
sub import {


        my $self = shift;
        if (@_) {
          local $Exporter::ExportLevel = $Exporter::ExportLevel + 1;
          $self->SUPER::import (@_);
          for (grep {not /\W/} @_) {
            eval qq{$_};
          }
        }
      
}
our %EXPORT_TAG = ('DocumentPosition',
['DOCUMENT_POSITION_CONTAINED_BY',
'DOCUMENT_POSITION_CONTAINS',
'DOCUMENT_POSITION_DISCONNECTED',
'DOCUMENT_POSITION_FOLLOWING',
'DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC',
'DOCUMENT_POSITION_PRECEDING'],
'NodeType',
['ATTRIBUTE_DEFINITION_NODE',
'ATTRIBUTE_NODE',
'CDATA_SECTION_NODE',
'COMMENT_NODE',
'DOCUMENT_FRAGMENT_NODE',
'DOCUMENT_NODE',
'DOCUMENT_TYPE_NODE',
'ELEMENT_NODE',
'ELEMENT_TYPE_DEFINITION_NODE',
'ENTITY_NODE',
'ENTITY_REFERENCE_NODE',
'NOTATION_NODE',
'PROCESSING_INSTRUCTION_NODE',
'TEXT_NODE'],
'OperationType',
['NODE_ADOPTED',
'NODE_CLONED',
'NODE_DELETED',
'NODE_IMPORTED',
'NODE_RENAMED']);
our @EXPORT_OK = ('DOCUMENT_POSITION_CONTAINED_BY',
'DOCUMENT_POSITION_CONTAINS',
'DOCUMENT_POSITION_DISCONNECTED',
'DOCUMENT_POSITION_FOLLOWING',
'DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC',
'DOCUMENT_POSITION_PRECEDING',
'ATTRIBUTE_DEFINITION_NODE',
'ATTRIBUTE_NODE',
'CDATA_SECTION_NODE',
'COMMENT_NODE',
'DOCUMENT_FRAGMENT_NODE',
'DOCUMENT_NODE',
'DOCUMENT_TYPE_NODE',
'ELEMENT_NODE',
'ELEMENT_TYPE_DEFINITION_NODE',
'ENTITY_NODE',
'ENTITY_REFERENCE_NODE',
'NOTATION_NODE',
'PROCESSING_INSTRUCTION_NODE',
'TEXT_NODE',
'NODE_ADOPTED',
'NODE_CLONED',
'NODE_DELETED',
'NODE_IMPORTED',
'NODE_RENAMED');
use Exporter; push our @ISA, 'Exporter';
package Message::DOM::IF::Node;
our $VERSION = 20070513.0354;
sub ELEMENT_NODE () {
1}
sub ATTRIBUTE_NODE () {
2}
sub TEXT_NODE () {
3}
sub CDATA_SECTION_NODE () {
4}
sub ENTITY_REFERENCE_NODE () {
5}
sub ENTITY_NODE () {
6}
sub PROCESSING_INSTRUCTION_NODE () {
7}
sub COMMENT_NODE () {
8}
sub DOCUMENT_NODE () {
9}
sub DOCUMENT_TYPE_NODE () {
10}
sub DOCUMENT_FRAGMENT_NODE () {
11}
sub NOTATION_NODE () {
12}
sub ELEMENT_TYPE_DEFINITION_NODE () {
81001}
sub ATTRIBUTE_DEFINITION_NODE () {
81002}
sub DOCUMENT_POSITION_DISCONNECTED () {
1}
sub DOCUMENT_POSITION_PRECEDING () {
2}
sub DOCUMENT_POSITION_FOLLOWING () {
4}
sub DOCUMENT_POSITION_CONTAINS () {
8}
sub DOCUMENT_POSITION_CONTAINED_BY () {
16}
sub DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC () {
32}
package Message::DOM::TreeCore::ManakaiDOMNode;
our $VERSION = 20070513.0354;
push our @ISA, 'Message::DOM::DOMFeature::ManakaiHasFeatureByGetFeature',
'Message::DOM::IF::Node',
'Message::Util::Error::MUErrorTarget';
sub DESTROY ($) {
my ($self) = @_;

{

my 
$unload = $$self->{
'udbeforefree'
};
if ($unload) {
  

{

local $Error::Depth = $Error::Depth + 1;

{



    $unload->($self);
  


}


;}

;
}


}
}
sub ___report_error ($$) {
my ($self, $err) = @_;
my $r;

{

if 
($err->isa (
'Message::DOM::IF::DOMError'
)) {
  

{

local $Error::Depth = $Error::Depth + 1;

{


    A: 
{
      my $doc = $self->
owner_document
;
      if (not defined $doc) {
        if ($self->
node_type
 == 
9
) {
          $doc = $self;
        } else {  ## DOCUMENT_TYPE_NODE
          CORE::warn $err;
          last A;
        }
      }
      my $cfg = $doc->
dom_config
;
      my $h = $cfg->
get_parameter

                       ('error-handler');
      $r = $h->
handle_error
 ($err);
    } # A
  


}


;}

;
} else {
  $err->
throw
;
}


}
$r}
sub node_type ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r = 0;

{


;## TODO: Assertion


}
$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMNode', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'node_type';
}
}
sub local_name ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r = '';

{

my 
$v = $$self->{
'ln'
};
$r = defined $v ? $$v : undef;


}
$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMNode', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'local_name';
}
}
sub manakai_local_name ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r = '';

{

my 
$v = $$self->{
'ln'
};
$r = defined $v ? $$v : undef;


}
$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMNode', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'manakai_local_name';
}
}
sub namespace_uri ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r = '';

{

my 
$v = $$self->{
'ns'
};
$r = defined $v ? $$v : undef;


}
$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMNode', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'namespace_uri';
}
}
sub prefix ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r = '';

{


$r = 
undef
;


}
$r;
} else {my ($self, $given) = @_;

{

report Message::DOM::DOMCore::ManakaiDOMError -object => $self, '-type' => 'http://suika.fam.cx/~wakaba/archive/2004/dom/tree#setting-prefix-no-effect-because-of-node', 'rdata' => $self, 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'set', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMNode', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'prefix';

;


}
}
}
sub parent_node ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r;

{


$r = $$self->{
'parent'
};


}
$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMNode', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'parent_node';
}
}
sub owner_document ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r;

{


$r = $$self->{
'od'
};


}
$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMNode', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'owner_document';
}
}
sub is_same_node ($$) {
my ($self, $other) = @_;
my $r = 0;

{


$r = (UNIVERSAL::isa ($other, 
'Message::DOM::TreeCore::ManakaiDOMNode'
) and
    $$self eq $$other);


}
$r}
sub manakai_read_only ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r = 0;

{


$r = $$self->{
'ro'
};


}
$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMNode', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'manakai_read_only';
}
}
sub manakai_set_read_only ($$;$) {
my ($self, $newValue, $deep) = @_;

{

if 
($deep) {
  my @target = ($self);
  while (@target) {
    my $target = shift @target;
    $$target->{
'ro'
} = $newValue;

    push @target, @{$target->
child_nodes
};

    my $nt = $target->
node_type
;
    if ($nt == 
1
) {
      push @target, @{$target->
attributes
};
    } elsif ($nt == 
81001
) {
      push @target, @{$target->
attribute_definitions
};
    } elsif ($nt == 
10
) {
      my $targetx = $target->
get_feature

                               (
'http://suika.fam.cx/www/2006/feature/XDoctype'
, '3.0');
      push @target, @{$targetx->
element_types
};
      push @target, @{$targetx->
general_entities
};
      push @target, @{$targetx->
notations
};
    }
  }
} else { # not deep
  $$self->{
'ro'
} = $newValue;
}


}
}
sub child_nodes ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r;

{


$r = bless \\($self), 
'Message::DOM::TreeCore::ManakaiDOMChildNodeList'
;


}
$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMNode', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'child_nodes';
}
}
sub first_child ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r;

{

my 
$v = $$self->{
'child'
};
if (defined $v and defined $v->[0]) {
  $r = $v->[0];
}


}
$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMNode', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'first_child';
}
}
sub last_child ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r;

{

my 
$v = $$self->{
'child'
};
if (defined $v and defined $v->[0]) {
  $r = $v->[-1]; # There is $v->[-1] iff there is $v->[0].
}


}
$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMNode', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'last_child';
}
}
sub previous_sibling ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r;

{


{

local $Error::Depth = $Error::Depth + 1;

{


  my 
$parent = $self->
parent_node
;
  if (defined $parent) {
    S: for my $sib (@{$parent->
child_nodes
}) {
      if ($sib eq $self) {
        last S;
      } else {
        $r = $sib;
      }
    }
  }



}


;}

;


}
$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMNode', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'previous_sibling';
}
}
sub next_sibling ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r;

{


{

local $Error::Depth = $Error::Depth + 1;

{


  my 
$parent = $self->
parent_node
;
  if (defined $parent) {
    my $next;
    S: for my $sib (@{$parent->
child_nodes
}) {
      if ($next) {
        $r = $sib;
        last S;
      } elsif ($sib eq $self) {
        $next = 
1
;
      }
    }
  }



}


;}

;


}
$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMNode', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'next_sibling';
}
}
sub append_child ($$) {
my ($self, $newChild) = @_;
my $r;

{


;## TODO: Assertion


}
$r}
sub insert_before ($$;$) {
my ($self, $newChild, $refChild) = @_;
my $r;

{


;## TODO: Assertion


}
$r}
sub replace_child ($$$) {
my ($self, $newChild, $oldChild) = @_;
my $r;

{


;## TODO: Assertion


}
$r}
sub manakai_append_text ($$) {
my ($self, $string) = @_;
my $r;

{


$r = $self;


}
$r}
sub remove_child ($$) {
my ($self, $oldChild) = @_;
my $r;

{

if 
($self->
owner_document

         ->
strict_error_checking and
    
$self->
manakai_read_only
) {
  
report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'remove_child', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#NOMOD_THIS', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMNode';

;
}


{

F: 
{
  my $i = -1;
  my $v = $$self->{
'child'
};
  for my $cld (@$v) {
    $i++;
    if ($cld eq $oldChild) {
      splice @$v, $i, 1, ();
      CORE::delete $$oldChild->{
'parent'
};
      $r = $oldChild;
      last F;
    }
  }
  
report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'NOT_FOUND_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#NOT_CHILD_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/DOM/TreeCore/removeChildImpl', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#param-name' => 'oldChild', 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#node' => $oldChild;

;
} # F


}

;


}
$r}
sub attributes ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r;


$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMNode', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'attributes';
}
}
sub node_name ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r = '';

{


;## TODO: Assertion


}
$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMNode', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'node_name';
}
}
sub node_value ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r = '';

{


$r = 
undef
;


}
$r;
} else {my ($self, $given) = @_;

{

report Message::DOM::DOMCore::ManakaiDOMError -object => $self, '-type' => 'http://suika.fam.cx/~wakaba/archive/2004/dom/tree#setting-node-value-no-effect', 'rdata' => $self, 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'set', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMNode', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'node_value';

;


}
}
}
sub text_content ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r = '';

{


{

local $Error::Depth = $Error::Depth + 1;

{



  $r = '';
  my @target = @{$self->
child_nodes
};
  C: while (@target) {
    my $node = shift @target;
    my $nt = $node->
node_type
;
    if ($nt == 
3 or
        
$nt == 
4
) {
      $r .= $node->
data
        unless 
$node->
is_element_content_whitespace
;
    } elsif ($nt == 
1 or
             
$nt == 
5
) {
      unshift @target, @{$node->
child_nodes
};
    }
  }



}


;}

;


}
$r;
} else {my ($self, $given) = @_;

{


{


{

if 
($self->
manakai_read_only
) {
  
report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#NOMOD_THIS', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/DOM/TreeCore/NodeReadOnlyError';

;
}


}

;

for my $__old_child (@{${$self}->{
'child'
}}) {
  CORE::delete $$__old_child->{
'parent'
};
}

my @__new_children;
if (defined $given and length $given) {
  my $__text = $self->owner_document->
create_text_node
 ($given);
  push @__new_children, $__text;
  $$__text->{
'parent'
} = $self;
  Scalar::Util::weaken ($$__text->{
'parent'
});
}

${$self}->{
'child'
} = \@__new_children;


}

;


}
}
}
sub clone ($;$) {
my ($self, $deep) = @_;
my $r;

{


{

local $Error::Depth = $Error::Depth + 1;

{


  my 
$od = $self->
owner_document
;
  my $strict_check = $od->
strict_error_checking
;
  $od->
strict_error_checking
 (
0
);
  my $cfg = $od->
dom_config
;
  my $er_copy_asis = $cfg->
get_parameter

                             (
'http://suika.fam.cx/www/2006/dom-config/clone-entity-reference-subtree'
);
  my @udh;
  my @node = ([$self]);
  while (@node) {
    my ($node, $parent) = @{shift @node};
    my $nt = $node->
node_type
;
    my $clone;
    if ($nt == 
1
) {
      $clone = $od->
create_element_ns

                      ($node->
namespace_uri
,
                       [$node->
prefix
,
                        $node->
local_name
]);
      if ($parent) {
        $parent->
append_child
 ($clone);
      } else {
        $r = $clone;
      }
      my $attrs = $node->
attributes
;
      my $attrsMax = $attrs->
length
 - 1;
      for my $i (0..$attrsMax) {
        my $attr = $attrs->
item
 ($i);
        push @node, [$attr, $clone] if $attr->
specified
;
      }
      if ($deep) {
        push @node, map {[$_, $clone]} @{$node->
child_nodes
};
      }
    } elsif ($nt == 
3
) {
      $clone = $od->
create_text_node

                      ($node->
data
);
      if ($parent) {
        $parent->
append_child
 ($clone);
      } else {
        $r = $clone;
      }
      $clone->
is_element_content_whitespace
 (
1
)
        if $node->
is_element_content_whitespace
;
    } elsif ($nt == 
2
) {
      $clone = $od->
create_attribute_ns

                      ($node->
namespace_uri
,
                       [$node->
prefix
,
                        $node->
local_name
]);
      if ($parent) {
        $parent->
set_attribute_node_ns
 ($clone);
      } else {
        $r = $clone;
      }
      $clone->
specified
 (
1
);
      push @node, map {[$_, $clone]} @{$node->
child_nodes
};
    } elsif ($nt == 
8
) {
      $clone = $od->
create_comment

                      ($node->
data
);
      if ($parent) {
        $parent->
append_child
 ($clone);
      } else {
        $r = $clone;
      }
    } elsif ($nt == 
4
) {
      $clone = $od->
create_cdata_section

                      ($node->
data
);
      if ($parent) {
        $parent->
append_child
 ($clone);
      } else {
        $r = $clone;
      }
    } elsif ($nt == 
7
) {
      $clone = $od->
create_processing_instruction

                      ($node->
target
,
                       $node->
data
);
      if ($parent) {
        $parent->
append_child
 ($clone);
      } else {
        $r = $clone;
      }
    } elsif ($nt == 
5
) {
      $clone = $od->
create_entity_reference

                      ($node->
node_name
);
      if ($er_copy_asis) {
        $clone->
manakai_set_read_only
 (
0
);
        $clone->
text_content
 ('');
        for (@{$node->
child_nodes
}) {
          $clone->
append_child

                    ($_->
clone_node
 (
1
));
        }
        $clone->
manakai_expanded

                  ($node->
manakai_expanded
);
        $clone->
manakai_set_read_only
 (
1
, 
1
);
      } # copy asis
      if ($parent) {
        $parent->
append_child
 ($clone);
      } else {
        $r = $clone;
      }
    } elsif ($nt == 
11
) {
      $clone = $od->
create_document_fragment
;
      $r = $clone;
      push @node, map {[$_, $clone]} @{$node->
child_nodes
};
    } elsif ($nt == 
9
) {
      $od->
strict_error_checking
 ($strict_check);
      

{

local $Error::Depth = $Error::Depth - 1;

{

report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'NOT_SUPPORTED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'clone_node', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#CLONE_NODE_TYPE_NOT_SUPPORTED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMNode', 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#node' => 'node';


}


;}

;
    } elsif ($nt == 
10
) {
      $od->
strict_error_checking
 ($strict_check);
      

{

local $Error::Depth = $Error::Depth - 1;

{

report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'NOT_SUPPORTED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'clone_node', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#CLONE_NODE_TYPE_NOT_SUPPORTED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMNode', 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#node' => 'node';


}


;}

;
    } elsif ($nt == 
6
) {
      $od->
strict_error_checking
 ($strict_check);
      

{

local $Error::Depth = $Error::Depth - 1;

{

report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'NOT_SUPPORTED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'clone_node', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#CLONE_NODE_TYPE_NOT_SUPPORTED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMNode', 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#node' => 'node';


}


;}

;
    } elsif ($nt == 
12
) {
      $od->
strict_error_checking
 ($strict_check);
      

{

local $Error::Depth = $Error::Depth - 1;

{

report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'NOT_SUPPORTED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'clone_node', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#CLONE_NODE_TYPE_NOT_SUPPORTED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMNode', 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#node' => 'node';


}


;}

;
    } else {
      ## TODO: Assertion
    }

    my $udhs = $$self->{
'ud'
};
    push @udh, [$node => $clone, $udhs] if $udhs and %$udhs;
  } # @node
  $od->
strict_error_checking
 (
1
) if $strict_check;

  ## Calling user data handlers if any
  for my $sd (@udh) {
    my $src = $sd->[0];
    my $src_ud = $sd->[2];
    for my $key (keys %{$src_ud}) {
      my $dh = $src_ud->{$key}->[1];
      if ($dh) {
        $dh->
handle

                (
1
,
                 $key, $src_ud->{$key}->[0], $src, $sd->[1]);
      }
    }
  }



}


;}

;


}
$r}
*clone_node = \&clone;
sub get_feature ($$$) {
my ($self, $feature, $version) = @_;

{


$feature = lc $feature;


}

{


$version = '' unless defined $version;


}
my $r;

{


$feature =~ s/^\+//;


{

if 
($Message::Util::AutoLoad::Registry::Feature->{$feature}->{$version}) {
  $r = $self;
}


}

;


}
$r}
sub get_user_data ($$) {
my ($self, $key) = @_;
my $r;

{

my 
$v = $$self->{
'ud'
};
$r = $v->{$key}->[0];


}
$r}
sub set_user_data ($$;$$) {
my ($self, $key, $data, $handler) = @_;

{


$handler = bless $handler, 
'Message::DOM::TreeCore::ManakaiDOMUserDataHandler'
  if 
ref $handler eq 'CODE';


}
my $r;

{

my 
$v = ($$self->{
'ud'
} ||= {});
$r = $v->{$key}->[0];

if (defined $data) {
  $v->{$key} = [$data, $handler];

  if (defined $handler) {
    $$self->{
'udbeforefree'
} = sub ($) {
      my ($node) = @_;
      my $uds = $$node->{
'ud'
};
      for my $key (keys %$uds) {
        if (defined $uds->{$key}->[1]) {
          $uds->{$key}->[1]->($uds->{$key}->[1],
                              
3
,
                              $key, $uds->{$key}->[0]);
        }
      }
    }; # rc
  }
} else {
  CORE::delete $v->{$key};
}


}
$r}
sub has_attributes ($) {
my ($self) = @_;
my $r = 0;

{

A: 
for (values %{$$self->{
'attr'
} or {}}) {
  if (keys %$_) {
    $r = 1;
    last A;
  }
}


}
$r}
sub has_child_nodes ($) {
my ($self) = @_;
my $r = 0;

{


$r = (@{$$self->{
'child'
} or []} > 0);


}
$r}
sub base_uri ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r = '';

{


$r = 
undef
;


}
$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMNode', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'base_uri';
}
}
sub compare_document_position ($$) {
my ($self, $other) = @_;
my $r = 0;

{


{

local $Error::Depth = $Error::Depth + 1;

{


  R: 
{
    my @acontainer = ($self);
    my @bcontainer = ($other);
    F: {
      A: while (
1
) {
        if ($acontainer[-1] eq $bcontainer[-1]) {
          last F;
        } else {
          my $ap;
          my $atype = $acontainer[-1]->
node_type
;
          if ($atype == 
2
) {
            $ap = $acontainer[-1]->
owner_element
;
          } elsif ($atype == 
6
) {
            $ap = $acontainer[-1]
                      ->
owner_document_type_definition
;
          } elsif ($atype == 
12
) {
            $ap = $acontainer[-1]
                      ->
owner_document_type_definition
;
          } elsif ($atype == 
81001
) {
            $ap = $acontainer[-1]
                      ->
owner_document_type_definition
;
          } elsif ($atype == 
81002
) {
            $ap = $acontainer[-1]
                      ->
owner_element_type_definition
;
          } else {
            $ap = $acontainer[-1]->
parent_node
;
          }
          if (defined $ap) {
            push @acontainer, $ap;
          } else {
            last A;
          }
        }
      } # A

      B: while (
1
) {
        if ($acontainer[-1] eq $bcontainer[-1]) {
          last F;
        } else {
          my $bp;
          my $btype = $bcontainer[-1]->
node_type
;
          if ($btype == 
2
) {
            $bp = $bcontainer[-1]->
owner_element
;
          } elsif ($btype == 
6
) {
            $bp = $bcontainer[-1]
                      ->
owner_document_type_definition
;
          } elsif ($btype == 
12
) {
            $bp = $bcontainer[-1]
                      ->
owner_document_type_definition
;
          } elsif ($btype == 
81001
) {
            $bp = $bcontainer[-1]
                      ->
owner_document_type_definition
;
          } elsif ($btype == 
81002
) {
            $bp = $bcontainer[-1]
                      ->
owner_element_type_definition
;
          } else {
            $bp = $bcontainer[-1]->
parent_node
;
          }
          if (defined $bp) {
            push @bcontainer, $bp;
          } else {
            last B;
          }
        }
      } # B

      ## Disconnected
      if ($bcontainer[-1]->isa (
'Message::DOM::IF::Node'
)) {
        $r = 
1

           | 
32

           | ((${$acontainer[-1]} cmp ${$bcontainer[-1]})
                  > 0 ? 
4
                      : 

2
);
      } else {
        $r = 
1

           | 
32

           | 
4
;
        last F;
      }
      last R;
    } # F

    ## Common container found
    if (@acontainer >= 2) {
      if (@bcontainer >= 2) {
        my $acnt = $acontainer[-2]->
node_type
;
        my $bcnt = $bcontainer[-2]->
node_type
;
        if ($acnt == 
2 or
            
$acnt == 
6 or
            
$acnt == 
12 or
            
$acnt == 
81001 or
            
$acnt == 
81002
) {
          if ($acnt == $bcnt) {
            $r = 
32

               | (($acontainer[-2]->
node_name cmp
                   
$bcontainer[-2]->
node_name
)
                      > 0 ? 
4
                          : 

2
);
          } elsif ($bcnt == 
2 or
                   
$bcnt == 
6 or
                   
$bcnt == 
12 or
                   
$bcnt == 
81001 or
                   
$bcnt == 
81002
) {
            $r = (($acnt < $bcnt)
                          ? 
4
                          : 

2
);
          } else {
            ## A: Non-child and B: child
            $r = 
4
;
          }
        } elsif ($bcnt == 
2 or
                 
$bcnt == 
6 or
                 
$bcnt == 
12 or
                 
$bcnt == 
81001 or
                 
$bcnt == 
81002
) {
          ## A: Child and B: non-child
          $r = 
2
;
        } else {
          ## A and B are both children
          for my $cn (@{$acontainer[-1]->
child_nodes
}) {
            if ($cn eq $acontainer[-2]) {
              $r = 
4
;
              last R;
            } elsif ($cn eq $bcontainer[-2]) {
              $r = 
2
;
              last R;
            }
          }
          ## TODO: Assertion
        }
      } else {
        ## B contains A
        $r = 
8

           | 
2
;
      }
    } else {
      if (@bcontainer >= 2) {
        ## A contains B
        $r = 
16

           | 
4
;
      } else {
        ## A eq B
        $r = 0;
      }
    }
  } # R



}


;}

;


}
$r}
sub lookup_namespace_uri ($;$) {
my ($self, $prefix) = @_;
my $r = '';

{


{

local $Error::Depth = $Error::Depth + 1;

{



  $prefix = 
undef if 
defined $prefix and $prefix eq '';
      # implementation dependent
  my $nt = $self->
node_type
;
  if ($nt == 
1
) {
    my $el = $self;
    EL: {
      my $elns = $el->
namespace_uri
;
      if (defined $elns) {
        my $elpfx = $el->
prefix
;
        if ((not defined $prefix and not defined $elpfx) or
            (defined $prefix and defined $elpfx and $prefix eq $elpfx)) {
          $r = $elns;
          last EL;
        }
      }
      AT: for my $attr (@{$el->
attributes
}) {
        my $attrns = $attr->
namespace_uri
;
        next AT if not defined $attrns or $attrns ne 
'http://www.w3.org/2000/xmlns/'
;
        my $attrpfx = $attr->
prefix
;
        if (not defined $prefix) {
          my $attrln = $attr->
local_name
;
          if ($attrln eq 'xmlns') {
            my $attrval = $attr->
value
;
            $r = length $attrval ? $attrval : 
undef
;
            last EL;
          }
        } elsif (defined $prefix and
                 defined $attrpfx and $attrpfx eq 'xmlns') {
          my $attrln = $attr->
local_name
;
          if ($attrln eq $prefix) {
            my $attrval = $attr->
value
;
            $r = length $attrval ? $attrval : 
undef
;
            last EL;
          }
        }
      } # AT
      $el = $el->
manakai_parent_element
;
      redo EL if defined $el;
      $r = 
undef
;
    } # EL;
  } else {
    my $el = $nt == 
9

               ? $self->
document_element :
             
$nt == 
2

               ? $self->
owner_element :
             
$self->
manakai_parent_element
;
    if (defined $el) {
      $r = $el->
lookup_namespace_uri
 ($prefix);
    } else {
      $r = 
undef
;
    }
  }



}


;}

;


}
$r}
sub lookup_prefix ($;$) {
my ($self, $namespaceURI) = @_;

{

if 
(CORE::defined $namespaceURI and CORE::length $namespaceURI == 0) {
  require Message::DOM::DOMMain;
  
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, '-type' => 'http://suika.fam.cx/~wakaba/archive/2004/dom/main#empty-namespace-uri', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'http://suika.fam.cx/~wakaba/archive/2004/dom/main#DOMNamespaceURIInputProcessor';

;

  $namespaceURI = undef;
}


}
my $r = '';

{

unless 
(defined $namespaceURI) {
  $r = 
undef
;
} else {
  

{

local $Error::Depth = $Error::Depth + 1;

{


    my 
$nt = $self->
node_type
;
    if ($nt == 
1
) {
      my $el = $self;
      EL: {
        my $elns = $el->
namespace_uri
;
        if (defined $elns and $elns eq $namespaceURI) {
          my $elpfx = $el->
prefix
;
          if (defined $elpfx) {
            my $oelpfx = $self->
lookup_namespace_uri
 ($elpfx);
            if (defined $oelpfx and $oelpfx eq $elpfx) {
              $r = $elpfx;
              last EL;
            }
          }
        }
        AT: for my $attr (@{$el->
attributes
}) {
          my $attrpfx = $attr->
prefix
;
          next AT if not defined $attrpfx or $attrpfx ne 'xmlns';
          my $attrns = $attr->
namespace_uri
;
          next AT if not defined $attrns or $attrns ne 
'http://www.w3.org/2000/xmlns/'
;
          my $attrln = $attr->
local_name
;
          my $oelpfx = $self->
lookup_namespace_uri
 ($attrln);
          next AT unless defined $oelpfx;
          if ($oelpfx eq $attrln) {
            $r = $attrln;
            last EL;
          }
        }
        $el = $el->
manakai_parent_element
;
        redo EL if defined $el;
        $r = 
undef
;
      } # EL
    } else {
      my $el = $nt == 
9

                 ? $self->
document_element :
               
$nt == 
2

                 ? $self->
owner_element :
               
$self->
manakai_parent_element
;
      if (defined $el) {
        $r = $el->
lookup_prefix
 ($namespaceURI);
      } else { 
        $r = 
undef
;
      }
    }
  


}


;}

;
}


}
$r}
sub is_default_namespace ($$) {
my ($self, $namespaceURI) = @_;

{

if 
(CORE::defined $namespaceURI and CORE::length $namespaceURI == 0) {
  require Message::DOM::DOMMain;
  
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, '-type' => 'http://suika.fam.cx/~wakaba/archive/2004/dom/main#empty-namespace-uri', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'http://suika.fam.cx/~wakaba/archive/2004/dom/main#DOMNamespaceURIInputProcessor';

;

  $namespaceURI = undef;
}


}
my $r = 0;

{


{

local $Error::Depth = $Error::Depth + 1;

{


  my 
$nt = $self->
node_type
;
  if ($nt == 
1
) {
    my $el = $self;
    EL: {
      my $elpfx = $el->
prefix
;
      unless (defined $elpfx) {
        my $elns = $el->
namespace_uri
;
        if (defined $namespaceURI and defined $elns) {
          $r = ($namespaceURI eq $elns);
        } else {
          $r = not (defined $namespaceURI or defined $elns);
        }
        last EL;
      }
      my $xmlns = $el->
get_attribute_ns

                         (
'http://www.w3.org/2000/xmlns/'
, 'xmlns');
      if (defined $xmlns) {
        if (defined $namespaceURI) {
          $r = ($namespaceURI eq $xmlns);
        } else {
          $r = ($xmlns eq '');
        }
        last EL;
      }
      $el = $el->
manakai_parent_element
;
      redo EL if defined $el;
      $r = 0;
    } # EL;
  } else {
    my $el = $nt == 
9

               ? $self->
document_element :
             
$nt == 
2

               ? $self->
owner_element :
             
$self->
manakai_parent_element
;
    if (defined $el) {
      $r = $el->
is_default_namespace
 ($namespaceURI);
    } else {
      $r = 0;
    }
  }



}


;}

;


}
$r}
sub manakai_parent_element ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r;

{

my 
$n = $self->
parent_node
;
N: while (defined $n) {
  if ($n->
node_type
 == 
1
) {
    $r = $n;
    last N;
  } else {
    $n = $n->
parent_node
;
  }
} # N


}
$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMNode', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'manakai_parent_element';
}
}
sub normalize ($) {
my ($self) = @_;

{


{

local $Error::Depth = $Error::Depth + 1;

{


  my 
$ptext;

  ## Children
  my @remove;
  for my $cn (@{$self->
child_nodes
}) {
    if ($cn->
node_type
 == 
3
) {
      my $nv = $cn->
node_value
;
      if (length $nv) {
        if (defined $ptext) {
          $ptext->
manakai_append_text
 ($nv);
          $ptext->
is_element_content_whitespace
 (
1
) 
            if $cn->
is_element_content_whitespace and
               
$ptext->
is_element_content_whitespace
;
          push @remove, $cn;
        } else {
          $ptext = $cn;
        }
      } else {
        push @remove, $cn;
      }
    } else {
      $cn->
normalize
;
      undef $ptext;
    }
  }
  for (@remove) {
    $self->
remove_child
 ($_);
  }

  my $nt = $self->
node_type
;
  if ($nt == 
1
) {
    ## Attributes
    my $attrs = $self->
attributes
;
    for my $attr (@{$attrs}) {
      $attr->
normalize
;
    }
  } elsif ($nt == 
10
) {
    ## Element type definitions
    my $ets = $self->
element_types
;
    for my $et (@{$ets}) {
      $et->
normalize
;
    }
  } elsif ($nt == 
81001
) {
    ## Attribute definitions
    my $ats = $self->
attribute_definitions
;
    for my $at (@{$ats}) {
      $at->
normalize
;
    }
  }



}


;}

;


}
}
sub is_supported ($$;$) {
my ($self, $feature, $version) = @_;

{


$feature = lc $feature;


}

{


$version = '' unless defined $version;


}
my $r = 0;

{


{

local $Error::Depth = $Error::Depth + 1;

{



  $r = $self->
has_feature
 ($feature, $version);



}


;}

;


}
$r}
sub is_equal_node ($$) {
my ($self, $arg) = @_;
my $r = 0;

{


{

local $Error::Depth = $Error::Depth + 1;

{


  EQ: 
{
    last EQ unless UNIVERSAL::isa
                     ($arg, 
'Message::DOM::IF::Node'
);
    my $nt = $self->
node_type
;
    last EQ unless $nt == $arg->
node_type
;

    my @str_attr = qw/node_name local_name namespace_uri
                      prefix node_value/;
    push @str_attr, qw/public_id system_id internal_subset/
        if $nt == 
10
;
    for my $attr_name (@str_attr) {
      my $v1 = $self->can ($attr_name) ? $self->$attr_name : 
undef
;
      my $v2 = $arg->can ($attr_name) ? $arg->$attr_name : 
undef
;
      if (defined $v1 and defined $v2) {
        last EQ unless ''.$v1 eq ''.$v2;
      } elsif (defined $v1 or defined $v2) {
        last EQ;
      }
    }

    my @num_eq_attr = qw/child_nodes attributes/;
    push @num_eq_attr, qw/entities notations/
        if $nt == 
10
;
    push @num_eq_attr, qw/attribute_definitions/
        if $nt == 
81001
;
    push @num_eq_attr, qw/declared_type default_type allowed_tokens/
        if $nt == 
81002
;
    for my $attr_name (@num_eq_attr) {
      my $v1 = $self->can ($attr_name) ? $self->$attr_name : 
undef
;
      my $v2 = $arg->can ($attr_name) ? $arg->$attr_name : 
undef
;
      if (defined $v1 and defined $v2) {
        last EQ unless $v1 == $v2;
      } elsif (defined $v1 or defined $v2) {
        last EQ;
      }
    }

    if ($nt == 
10
) {
      my $dt1 = $self->
get_feature
 (
'http://suika.fam.cx/www/2006/feature/XDoctype'
, '3.0');
      my $dt2 = $arg->can ('get_feature')
                  ? $arg->
get_feature
 (
'http://suika.fam.cx/www/2006/feature/XDoctype'
, '3.0')
                  : 
undef
;
      if (defined $dt1 and defined $dt2) {
        last EQ unless $dt1->
element_types

                           == $dt2->
element_types
;
      } elsif (defined $dt1) {
        last EQ unless $dt1->
element_types

                           ->
length
 == 0;
      } elsif (defined $dt2) {
        last EQ unless $dt2->
element_types

                           ->
length
 == 0;
      }
    }

    $r = 
1
;
  } # EQ



}


;}

;


}
$r}
sub manakai_expanded_uri ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r = '';

{


{

local $Error::Depth = $Error::Depth + 1;

{


  my 
$ln = $self->
local_name
;
  if (defined $ln) {
    $r = $self->
namespace_uri
;
    if (defined $r) {
      $r .= $ln;
    } else {
      $r = $ln;
    }
  } else {
    $r = 
undef
;
  }



}


;}

;


}
$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMNode', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'manakai_expanded_uri';
}
}
sub manakai_language ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r = '';

{

my 
$target = $self;
L: {
  while (defined $target) {
    if ($target->
node_type
 == 
1
) {
      $r = $target->
get_attribute_ns
 (
'http://www.w3.org/XML/1998/namespace'
, 'lang');
      last L if defined $r;

      $r = $target->
get_attribute_ns
 (
undef
, 'xml:lang');
      last L if defined $r;
    }
    $target = $target->
parent_node
;
  }

  ## TODO: from ownerDocument
  ## TODO: from upper-level protocol

  $r = '';
} # L


}
$r;
} else {my ($self, $given) = @_;

{


{

local $Error::Depth = $Error::Depth + 1;

{


  if 
($self->
node_type
 == 
1
) {
    if (defined $given) {
      if ($self->
has_attribute_ns
 (
undef
, 'xml:lang')) {
        $self->
set_attribute_ns

                 (
undef
, [
undef
, 'xml:lang'], $given);
      } else {
        $self->
set_attribute_ns

                 (
'http://www.w3.org/XML/1998/namespace'
, 'xml:lang', $given);
      }
    } else {
      $self->
remove_attribute_ns
 (
'http://www.w3.org/XML/1998/namespace'
, 'lang');
      $self->
remove_attribute_ns
 (
undef
, 'xml:lang');
    }
  }



}


;}

;


}
}
}
use overload 
bool => sub () {1}, 
'eq' => 'is_same_node', 
'==' => 'is_equal_node', 
fallback => 1;
$Message::DOM::DOMFeature::ClassInfo->{q<Message::DOM::TreeCore::ManakaiDOMNode>}->{has_feature} = {'core',
{'',
'1',
'1.0',
'1',
'2.0',
'1',
'3.0',
'1'},
'xml',
{'',
'1',
'1.0',
'1',
'2.0',
'1',
'3.0',
'1'},
'xmlversion',
{'',
'1',
'1.0',
'1',
'1.1',
'1'}};
$Message::DOM::ClassPoint{q<Message::DOM::TreeCore::ManakaiDOMNode>} = 14.1;
package Message::DOM::IF::NodeList;
our $VERSION = 20070513.0354;
package Message::DOM::TreeCore::ManakaiDOMChildNodeList;
our $VERSION = 20070513.0354;
push our @ISA, 'Tie::Array',
'Message::DOM::IF::NodeList';
sub FETCH ($$) {
my ($self, $index) = @_;
my $r;

{

my 
$v = ${$$$self}->{
'child'
};
if ($index >= 0 and defined $v->[$index]) {
  $r = $v->[$index];
}


}
$r}
*item = \&FETCH;
sub STORE ($$$) {
my ($self, $index, $value) = @_;
my $r;

{


{

local $Error::Depth = $Error::Depth + 1;

{


  my 
$current = $self->[$index];
  if ($current) {
    $r = $$$self->
replace_child
 ($value, $current);
  } else {
    $$$self->
append_child
 ($value);
  }



}


;}

;


}
$r}
sub DELETE ($$) {
my ($self, $index) = @_;
my $r;

{


{

local $Error::Depth = $Error::Depth + 1;

{


  my 
$current = $self->[$index];
  if ($current) {
    $r = $$$self->
remove_child
 ($current);
  }



}


;}

;


}
$r}
sub FETCHSIZE ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r = 0;

{


$r = @{${$$$self}->{
'child'
}};


}
$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMChildNodeList', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'length';
}
}
*length = \&FETCHSIZE;
sub STORESIZE ($$) {
my ($self, $count) = @_;

{


{

local $Error::Depth = $Error::Depth + 1;

{


  my 
$current_length = @$self;
  if ($current_length > $count) {
    for (my $i = $current_length - 1; $i >= $count; $i--) {
      $$$self->
remove_child
 ($self->[$i]);
    }
  }



}


;}

;


}
}
sub EXISTS ($$) {
my ($self, $index) = @_;
my $r = 0;

{


$r = CORE::exists ${$$$self}->{
'child'
}->[$index];


}
$r}
sub TIEARRAY ($$) {
my ($self, $nodeList) = @_;
my $r;

{


$r = $nodeList;


}
$r}
sub CLEAR ($) {
my ($self) = @_;

{


{

local $Error::Depth = $Error::Depth + 1;

{


  my 
$length = @$self;
  for (1..$length) {
    $$$self->
remove_child
 ($$$self->
first_child
);
  }



}


;}

;


}
}
sub manakai_read_only ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r = 0;

{


$r = ($$$self)->
manakai_read_only
;


}
$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMChildNodeList', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'manakai_read_only';
}
}
use overload 
bool => sub () {1}, 
'==' => sub ($$) {
my ($self, $arg) = @_;
my $r = 0;

{


{

local $Error::Depth = $Error::Depth + 1;

{


  EQ: 
{
    last EQ unless UNIVERSAL::isa ($arg, 
'Message::DOM::IF::NodeList'
);

    my $length1 = $self->
length
;
    my $length2 = $arg->
length
;
    last EQ unless $length1 == $length2;

    for my $i (0..($length1-1)) {
      unless ($self->
item
 ($i)
                  == $arg->
item
 ($i)) {
        last EQ;
      }
    }

    $r = 
1
;
  } # EQ



}


;}

;


}
$r}
, 
'@{}' => sub ($) {
my ($self) = @_;
my $r = [];

{

tie 
my @list, ref $self, $self;
$r = \@list;


}
$r}
, 
fallback => 1;
$Message::DOM::DOMFeature::ClassInfo->{q<Message::DOM::TreeCore::ManakaiDOMChildNodeList>}->{has_feature} = {'core',
{'',
'1',
'1.0',
'1',
'2.0',
'1',
'3.0',
'1'}};
$Message::DOM::ClassPoint{q<Message::DOM::TreeCore::ManakaiDOMChildNodeList>} = 6;
package Message::DOM::TreeCore::ManakaiDOMGetElementsNodeList;
our $VERSION = 20070513.0354;
push our @ISA, 'Tie::Array',
'Message::DOM::IF::NodeList';
sub FETCH ($$) {
my ($self, $index) = @_;
my $r;

{


{

local $Error::Depth = $Error::Depth + 1;

{


  my 
@target = @{$$self->[0]->
child_nodes
};
  my $i = -1;
  T: while (@target) {
    my $target = shift @target;
    my $nt = $target->
node_type
;
    if ($nt == 
1
) {
      if ($$self->[1]->($target)) {
        if (++$i == $index) {
          $r = $target;
          last T;
        }
      }
    }
    unshift @target, @{$target->
child_nodes
};
  } # T



}


;}

;


}
$r}
*item = \&FETCH;
sub STORE ($$$) {
my ($self, $index, $value) = @_;
my $r;

{

report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'STORE', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#NOMOD_NODELIST_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMGetElementsNodeList';

;


}
$r}
sub DELETE ($$) {
my ($self, $index) = @_;
my $r;

{

report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'DELETE', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#NOMOD_NODELIST_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMGetElementsNodeList';

;


}
$r}
sub FETCHSIZE ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r = 0;

{


{

local $Error::Depth = $Error::Depth + 1;

{


  my 
@target = @{$$self->[0]->
child_nodes
};
  $r = 0;
  T: while (@target) {
    my $target = shift @target;
    my $nt = $target->
node_type
;
    if ($nt == 
1
) {
      if ($$self->[1]->($target)) {
        $r++;
      }
    }
    unshift @target, @{$target->
child_nodes
};
  } # T



}


;}

;


}
$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMGetElementsNodeList', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'length';
}
}
*length = \&FETCHSIZE;
sub STORESIZE ($$) {
my ($self, $count) = @_;

{

report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'STORESIZE', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#NOMOD_NODELIST_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMGetElementsNodeList';

;


}
}
sub EXISTS ($$) {
my ($self, $index) = @_;
my $r = 0;

{


{

local $Error::Depth = $Error::Depth + 1;

{



  $r = (defined $self->
item
 ($index));



}


;}

;


}
$r}
sub TIEARRAY ($$) {
my ($self, $nodeList) = @_;
my $r;

{


$r = $nodeList;


}
$r}
sub CLEAR ($) {
my ($self) = @_;

{

report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'CLEAR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#NOMOD_NODELIST_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMGetElementsNodeList';

;


}
}
sub manakai_read_only ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r = 0;

{


$r = 
1
;


}
$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMGetElementsNodeList', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'manakai_read_only';
}
}
use overload 
bool => sub () {1}, 
'==' => sub ($$) {
my ($self, $arg) = @_;
my $r = 0;

{


{

local $Error::Depth = $Error::Depth + 1;

{


  EQ: 
{
    last EQ unless UNIVERSAL::isa ($arg, 
'Message::DOM::IF::NodeList'
);

    my $length1 = $self->
length
;
    my $length2 = $arg->
length
;
    last EQ unless $length1 == $length2;

    for my $i (0..($length1-1)) {
      unless ($self->
item
 ($i)
                  == $arg->
item
 ($i)) {
        last EQ;
      }
    }

    $r = 
1
;
  } # EQ



}


;}

;


}
$r}
, 
'@{}' => sub ($) {
my ($self) = @_;
my $r = [];

{

tie 
my @list, ref $self, $self;
$r = \@list;


}
$r}
, 
fallback => 1;
$Message::DOM::DOMFeature::ClassInfo->{q<Message::DOM::TreeCore::ManakaiDOMGetElementsNodeList>}->{has_feature} = {'core',
{'',
'1',
'1.0',
'1',
'2.0',
'1',
'3.0',
'1'}};
$Message::DOM::ClassPoint{q<Message::DOM::TreeCore::ManakaiDOMGetElementsNodeList>} = 6;
package Message::DOM::TreeCore::ManakaiDOMEmptyNodeList;
our $VERSION = 20070513.0354;
push our @ISA, 'Message::DOM::IF::NodeList';
sub FETCH ($$) {
my ($self, $index) = @_;
my $r;


$r}
*item = \&FETCH;
sub STORE ($$$) {
my ($self, $index, $value) = @_;
my $r;

{

report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'STORE', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#NOMOD_NODELIST_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMEmptyNodeList';

;


}
$r}
sub DELETE ($$) {
my ($self, $index) = @_;
my $r;

{

report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'DELETE', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#NOMOD_NODELIST_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMEmptyNodeList';

;


}
$r}
sub FETCHSIZE ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r = 0;


$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMEmptyNodeList', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'length';
}
}
*length = \&FETCHSIZE;
sub STORESIZE ($$) {
my ($self, $count) = @_;

{

report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'STORESIZE', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#NOMOD_NODELIST_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMEmptyNodeList';

;


}
}
sub EXISTS ($$) {
my ($self, $index) = @_;
my $r = 0;


$r}
sub CLEAR ($) {
my ($self) = @_;

{

report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'CLEAR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#NOMOD_NODELIST_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMEmptyNodeList';

;


}
}
sub manakai_read_only ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r = 0;

{


$r = 
1
;


}
$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMEmptyNodeList', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'manakai_read_only';
}
}
use overload 
bool => sub () {1}, 
'==' => sub ($$) {
my ($self, $arg) = @_;
my $r = 0;

{


{

local $Error::Depth = $Error::Depth + 1;

{


  EQ: 
{
    last EQ unless UNIVERSAL::isa ($arg, 
'Message::DOM::IF::NodeList'
);

    my $length1 = $self->
length
;
    my $length2 = $arg->
length
;
    last EQ unless $length1 == $length2;

    for my $i (0..($length1-1)) {
      unless ($self->
item
 ($i)
                  == $arg->
item
 ($i)) {
        last EQ;
      }
    }

    $r = 
1
;
  } # EQ



}


;}

;


}
$r}
, 
'@{}' => sub ($) {
my ($self) = @_;
my $r = [];


$r}
, 
fallback => 1;
$Message::DOM::DOMFeature::ClassInfo->{q<Message::DOM::TreeCore::ManakaiDOMEmptyNodeList>}->{has_feature} = {'core',
{'',
'1',
'1.0',
'1',
'2.0',
'1',
'3.0',
'1'}};
$Message::DOM::ClassPoint{q<Message::DOM::TreeCore::ManakaiDOMEmptyNodeList>} = 6;
package Message::DOM::IF::StaticNodeList;
our $VERSION = 20070513.0354;
package Message::DOM::TreeCore::ManakaiDOMStaticNodeList;
our $VERSION = 20070513.0354;
push our @ISA, 'Message::DOM::IF::NodeList',
'Message::DOM::IF::StaticNodeList';
sub length ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r = 0;

{


$r = @$self;


}
$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMStaticNodeList', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'length';
}
}
sub item ($$) {
my ($self, $index) = @_;
my $r;

{


$r = $self->[$index] if $index >= 0;


}
$r}
sub manakai_read_only ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r = 0;

{


$r = 
0
;


}
$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMStaticNodeList', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'manakai_read_only';
}
}
use overload 
bool => sub () {1}, 
'==' => sub ($$) {
my ($self, $arg) = @_;
my $r = 0;

{


{

local $Error::Depth = $Error::Depth + 1;

{


  EQ: 
{
    last EQ unless UNIVERSAL::isa ($arg, 
'Message::DOM::IF::NodeList'
);

    my $length1 = $self->
length
;
    my $length2 = $arg->
length
;
    last EQ unless $length1 == $length2;

    for my $i (0..($length1-1)) {
      unless ($self->
item
 ($i)
                  == $arg->
item
 ($i)) {
        last EQ;
      }
    }

    $r = 
1
;
  } # EQ



}


;}

;


}
$r}
, 
fallback => 1;
$Message::DOM::DOMFeature::ClassInfo->{q<Message::DOM::TreeCore::ManakaiDOMStaticNodeList>}->{has_feature} = {};
$Message::DOM::ClassPoint{q<Message::DOM::TreeCore::ManakaiDOMStaticNodeList>} = 0;
package Message::DOM::IF::NamedNodeMap;
our $VERSION = 20070513.0354;
package Message::DOM::TreeCore::ManakaiDOMAttrMap;
our $VERSION = 20070513.0354;
push our @ISA, 'Tie::Array',
'Message::DOM::IF::NamedNodeMap';
use Message::Util::Error;
sub FETCH ($$) {
my ($self, $name) = @_;
my $r;

{


{

local $Error::Depth = $Error::Depth + 1;

{



  $r = ($$$self)->
get_attribute_node
 ($name);



}


;}

;


}
$r}
*get_named_item = \&FETCH;
sub set_named_item ($$) {
my ($self, $arg) = @_;
my $r;

{


{

local $Error::Depth = $Error::Depth + 1;

{



  $r = ($$$self)->
set_attribute_node
 ($arg);



}


;}

;


}
$r}
sub remove_named_item ($$) {
my ($self, $name) = @_;
my $r;

{

my 
$el = $$$self;


{

local $Error::Depth = $Error::Depth + 1;

{


 
  $r = $el->
get_attribute_node
 ($name);



}


;}

;
unless ($r) {
  
report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'NOT_FOUND_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'remove_named_item', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#NO_NAMED_NODE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMAttrMap', 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#name' => $name, 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#param-name' => 'name';

;
}


{

local $Error::Depth = $Error::Depth + 1;

{



  $r = $el->
remove_attribute_node
 ($r);



}


;}

;


}
$r}
sub DELETE ($$) {
my ($self, $key) = @_;
my $r;

{




try {local $Error::Depth = $Error::Depth + 3;


  $r = $self->
remove_named_item
 ($key);
} catch 
Message::DOM::IF::DOMException with 
{
  my $err = shift;
  unless ($err->subtype eq 
'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#NO_NAMED_NODE_ERR'
) {
    $err->throw;
  }
};


}
$r}
sub item ($$) {
my ($self, $index) = @_;
my $r;

{


## Update the sorted content attribute name list
my $list = ${$$$self}->{
'sattrs'
};
my $attrs = ${$$$self}->{
'attr'
};
unless (defined $list) {
  $list = [];
  for my $ns (sort {$a cmp $b} keys %{$attrs}) {
    push @$list,
        map {[$ns => $_]} sort {$a cmp $b} keys %{$attrs->{$ns}};
  }
  ${$$$self}->{
'sattrs'
} = $list;
}

$r = $attrs->{$list->[$index]->[0]}->{$list->[$index]->[1]}
    if $index >= 0 and $list->[$index];


}
$r}
sub FETCHSIZE ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r = 0;

{

my 
$list = ${$$$self}->{
'sattrs'
};
if (defined $list) {
  $r = @$list;
} else {
  my $list = ${$$$self}->{
'attr'
};
  for my $l (values %$list) {
    $r += grep {$l->{$_}} keys %$l;
  }
}


}
$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMAttrMap', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'length';
}
}
*length = \&FETCHSIZE;
sub STORESIZE ($$) {
my ($self, $count) = @_;

{


{

local $Error::Depth = $Error::Depth + 1;

{


  my 
$length = $self->
length
;
  if ($length > $count) {
    for (my $i = $length - 1; $i >= $count; $i--) {
      my $item = $self->
item
 ($i);
      $self->
remove_named_item

               ($item->
node_name
);
    }
  }



}


;}

;


}
}
sub EXISTS ($$) {
my ($self, $key) = @_;
my $r = 0;

{


{

local $Error::Depth = $Error::Depth + 1;

{



  $r = defined ($self->
get_named_item
 ($key));



}


;}

;


}
$r}
sub FIRSTKEY ($) {
my ($self) = @_;
my $r = '';

{


{

local $Error::Depth = $Error::Depth + 1;

{


  my 
$node = $self->
item
 (0);
  $r = $node ? $node->
node_name : 

undef
;
  ${$$$self}->{
'hpos'
} = 1;



}


;}

;


}
$r}
sub NEXTKEY ($$) {
my ($self, $lastkey) = @_;
my $r = '';

{


{

local $Error::Depth = $Error::Depth + 1;

{


  my 
$i = ${$$$self}->{
'hpos'
}++;
  my $node = $self->
item
 ($i);
  $r = $node ? $node->
node_name : 

undef
;



}


;}

;


}
$r}
sub get_named_item_ns ($$$) {
my ($self, $namespaceURI, $localName) = @_;

{

if 
(CORE::defined $namespaceURI and CORE::length $namespaceURI == 0) {
  require Message::DOM::DOMMain;
  
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, '-type' => 'http://suika.fam.cx/~wakaba/archive/2004/dom/main#empty-namespace-uri', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'http://suika.fam.cx/~wakaba/archive/2004/dom/main#DOMNamespaceURIInputProcessor';

;

  $namespaceURI = undef;
}


}
my $r;

{


{

local $Error::Depth = $Error::Depth + 1;

{



  $r = ($$$self)->
get_attribute_node_ns

                    ($namespaceURI, $localName);



}


;}

;


}
$r}
sub set_named_item_ns ($$) {
my ($self, $arg) = @_;
my $r;

{


{

local $Error::Depth = $Error::Depth + 1;

{



  $r = ($$$self)->
set_attribute_node_ns
 ($arg);



}


;}

;


}
$r}
sub remove_named_item_ns ($$$) {
my ($self, $namespaceURI, $localName) = @_;

{

if 
(CORE::defined $namespaceURI and CORE::length $namespaceURI == 0) {
  require Message::DOM::DOMMain;
  
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, '-type' => 'http://suika.fam.cx/~wakaba/archive/2004/dom/main#empty-namespace-uri', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'http://suika.fam.cx/~wakaba/archive/2004/dom/main#DOMNamespaceURIInputProcessor';

;

  $namespaceURI = undef;
}


}
my $r;

{

my 
$el = $$$self;


{

local $Error::Depth = $Error::Depth + 1;

{


 
  $r = $el->
get_attribute_node_ns

              ($namespaceURI, $localName);



}


;}

;
unless ($r) {
  
report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'NOT_FOUND_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'remove_named_item_ns', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMAttrMap', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#param-name' => 'name', 'http://www.w3.org/2001/04/infoset#localName' => $localName, 'http://www.w3.org/2001/04/infoset#namespaceName' => $namespaceURI, 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#name' => $localName, 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#NO_NAMED_NODE_NS_ERR';

;
}


{

local $Error::Depth = $Error::Depth + 1;

{



  $r = $el->
remove_attribute_node
 ($r);



}


;}

;


}
$r}
sub ___report_error ($$) {
my ($self, $err) = @_;
my $r;

{


{

local $Error::Depth = $Error::Depth + 1;

{



  $r = ($$$self)->___report_error ($err);



}


;}

;


}
$r}
sub TIEARRAY ($$) {
my ($self, $map) = @_;
my $r;

{


$r = bless \\($$$map), $self;


}
$r}
sub TIEHASH ($$) {
my ($self, $map) = @_;
my $r;

{


$r = $map;


}
$r}
sub manakai_read_only ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r = 0;

{


$r = ($$$self)->
manakai_read_only
;


}
$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMAttrMap', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'manakai_read_only';
}
}
use overload 
bool => sub () {1}, 
'%{}' => sub ($) {
my ($self) = @_;
my $r = {};

{

tie 
my %list, ref $self, $self;
$r = \%list;


}
$r}
, 
'@{}' => sub ($) {
my ($self) = @_;
my $r = [];

{

tie 
my @list, 
'Message::DOM::TreeCore::ManakaiDOMAttrMapArray'
, $self;
$r = \@list;


}
$r}
, 
'==' => sub ($$) {
my ($self, $arg) = @_;
my $r = 0;

{


{

local $Error::Depth = $Error::Depth + 1;

{


  my 
$length1 = $self->
length
;
  my $length2 = $arg->
length
;
  if ($length1 == $length2) {
    CHK: {
      for my $i (0..$length1-1) {
        my $node1 = $self->
item
 ($i);
        my $node2 = $arg->
item
 ($i);
        unless ($node1 == $node2) {
          last CHK;
        }
      }
      $r = 
1
;
    } # CHK
  }



}


;}

;


}
$r}
, 
fallback => 1;
$Message::DOM::DOMFeature::ClassInfo->{q<Message::DOM::TreeCore::ManakaiDOMAttrMap>}->{has_feature} = {'core',
{'',
'1',
'1.0',
'1',
'2.0',
'1',
'3.0',
'1'}};
$Message::DOM::ClassPoint{q<Message::DOM::TreeCore::ManakaiDOMAttrMap>} = 6;
package Message::DOM::TreeCore::ManakaiDOMElementTypeDefMap;
our $VERSION = 20070513.0354;
push our @ISA, 'Tie::Array',
'Message::DOM::IF::NamedNodeMap';
use Message::Util::Error;
sub FETCH ($$) {
my ($self, $name) = @_;
my $r;

{

my 
$list;


{


$list = ${$$$self}->{
'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#elementTypes'
};



}

;


;


;


;
$r = $list->{$name};


}
$r}
*get_named_item = \&FETCH;
sub set_named_item ($$) {
my ($self, $arg) = @_;
my $r;

{

my 
$list;
my $expected_type;


{


$list = ${$$$self}->{
'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#elementTypes'
};
  $expected_type = 
81001
;



}

;


;


;


;
if ($$$self->
owner_document

           ->
strict_error_checking
) {
  unless ($arg->
owner_document
              eq 
$$$self->
owner_document
) {
    
report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'WRONG_DOCUMENT_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'set_named_item', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#DIFFERENT_DOCUMENT_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMElementTypeDefMap';

;
  }
  if ($$$self->
manakai_read_only
) {
    
report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'set_named_item', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#NOMOD_NAMEDNODEMAP_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMElementTypeDefMap';

;
  }
  my $owner_def = $$arg->{
'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#ownerDefinition'
};
  if ($owner_def and not $owner_def eq $$$self) {
    
report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'INUSE_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'set_named_item', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#INUSE_DEFINITION_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMElementTypeDefMap', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#param-name' => 'arg', 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#node' => $arg;

;
    ## NOTE: If equals to owner, then replace-by-itself error.
  }
  if ($arg->
node_type
 != $expected_type) {
    
report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'HIERARCHY_REQUEST_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'set_named_item', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#HIERARCHY_BAD_TYPE', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMElementTypeDefMap', 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#nodeType' => $arg->node_type, 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#param-name' => 'arg';

;
  }
} # strictErrorChecking
SET: {
  my $name = $arg->
node_name
;
  if (defined $list->{$name}) {
    $r = $list->{$name};
    if ($r eq $arg) {
      
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, '-type' => 'http://suika.fam.cx/~wakaba/archive/2004/dom/tree#replace-by-itself', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'set_named_item', 'rdata' => $arg, 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMElementTypeDefMap';

;
      undef $r; # no return value
      last SET;
    }
  }
  $list->{$name} = $arg;
  $$arg->{
'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#ownerDefinition'
} = $$$self;
  Scalar::Util::weaken ($$arg->{
'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#ownerDefinition'
});
} # SET


}
$r}
sub remove_named_item ($$) {
my ($self, $name) = @_;
my $r;

{

my 
$list;
my $ifs;


{


$list = ${$$$self}->{
'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#elementTypes'
};
  $ifs = [
'Message::DOM::IF::ElementTypeDefinition'
];



}

;


;


;


;
if ($$$self->
owner_document

           ->
strict_error_checking
) {
  if ($$$self->
manakai_read_only
) {
    
report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'remove_named_item', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#NOMOD_NAMEDNODEMAP_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMElementTypeDefMap';

;
  }
} # strictErrorChecking

if (defined $list->{$name}) {
  $r = $list->{$name};
  CORE::delete $$r->{
'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#ownerDefinition'
};
  CORE::delete $list->{$name};
} else {
  
report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'NOT_FOUND_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'remove_named_item', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#NO_NAMED_NODE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMElementTypeDefMap', 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#name' => $name, 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#param-name' => 'name';

;
}


}
$r}
sub DELETE ($$) {
my ($self, $key) = @_;
my $r;

{




try {local $Error::Depth = $Error::Depth + 3;


  $r = $self->
remove_named_item
 ($key);
} catch 
Message::DOM::IF::DOMException with 
{
  my $err = shift;
  unless ($err->subtype eq 
'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#NO_NAMED_NODE_ERR'
) {
    $err->throw;
  }
};


}
$r}
sub item ($$) {
my ($self, $index) = @_;
my $r;

{

my 
$list;
my $ifs;


{


$list = ${$$$self}->{
'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#elementTypes'
};



}

;


;


;


;
my $key = $index >= 0 ? [sort {$a cmp $b} keys %$list]->[$index]
                      : 
undef
;
if (defined $key and defined $list->{$key}) {
  $r = $list->{$key};
}


}
$r}
sub FETCHSIZE ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r = 0;

{

my 
$list = ${$$$self}->{
'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#elementTypes'
};
$r = @{[map {$_} values %$list]};


}
$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMElementTypeDefMap', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'length';
}
}
*length = \&FETCHSIZE;
sub STORESIZE ($$) {
my ($self, $count) = @_;

{


{

local $Error::Depth = $Error::Depth + 1;

{


  my 
$length = $self->
length
;
  if ($length > $count) {
    for (my $i = $length - 1; $i >= $count; $i--) {
      my $item = $self->
item
 ($i);
      $self->
remove_named_item

               ($item->
node_name
);
    }
  }



}


;}

;


}
}
sub EXISTS ($$) {
my ($self, $key) = @_;
my $r = 0;

{

my 
$list = ${$$$self}->{
'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#elementTypes'
};
$r = exists $list->{$key};


}
$r}
sub FIRSTKEY ($) {
my ($self) = @_;
my $r = '';

{

my 
$list = ${$$$self}->{
'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#elementTypes'
};
my $a = keys %$list; # reset
$r = each %$list;


}
$r}
sub NEXTKEY ($$) {
my ($self, $lastkey) = @_;
my $r = '';

{

my 
$list = ${$$$self}->{
'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#elementTypes'
};
$r = each %$list;


}
$r}
sub SCALAR ($) {
my ($self) = @_;
my $r = '';

{

my 
$list = ${$$$self}->{
'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#elementTypes'
};
$r = scalar %$list;


}
$r}
sub get_named_item_ns ($$$) {
my ($self, $namespaceURI, $localName) = @_;

{

if 
(CORE::defined $namespaceURI and CORE::length $namespaceURI == 0) {
  require Message::DOM::DOMMain;
  
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, '-type' => 'http://suika.fam.cx/~wakaba/archive/2004/dom/main#empty-namespace-uri', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'http://suika.fam.cx/~wakaba/archive/2004/dom/main#DOMNamespaceURIInputProcessor';

;

  $namespaceURI = undef;
}


}
my $r;


$r}
sub set_named_item_ns ($$) {
my ($self, $arg) = @_;
my $r;

{

report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'NAMESPACE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'set_named_item_ns', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#NO_NS_NAMEDNODEMAP_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMElementTypeDefMap';

;


}
$r}
sub remove_named_item_ns ($$$) {
my ($self, $namespaceURI, $localName) = @_;

{

if 
(CORE::defined $namespaceURI and CORE::length $namespaceURI == 0) {
  require Message::DOM::DOMMain;
  
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, '-type' => 'http://suika.fam.cx/~wakaba/archive/2004/dom/main#empty-namespace-uri', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'http://suika.fam.cx/~wakaba/archive/2004/dom/main#DOMNamespaceURIInputProcessor';

;

  $namespaceURI = undef;
}


}
my $r;

{

report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'NOT_FOUND_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'remove_named_item_ns', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#NO_NAMED_NODE_NS_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMElementTypeDefMap';

;


}
$r}
sub ___report_error ($$) {
my ($self, $err) = @_;
my $r;

{


{

local $Error::Depth = $Error::Depth + 1;

{



  $r = ($$$self)->___report_error ($err);



}


;}

;


}
$r}
sub TIEARRAY ($$) {
my ($self, $map) = @_;
my $r;

{


$r = bless \\($$$map), $self;


}
$r}
sub TIEHASH ($$) {
my ($self, $map) = @_;
my $r;

{


$r = $map;


}
$r}
sub manakai_read_only ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r = 0;

{


$r = ($$$self)->
manakai_read_only
;


}
$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMElementTypeDefMap', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'manakai_read_only';
}
}
use overload 
bool => sub () {1}, 
'%{}' => sub ($) {
my ($self) = @_;
my $r = {};

{

tie 
my %list, ref $self, $self;
$r = \%list;


}
$r}
, 
'@{}' => sub ($) {
my ($self) = @_;
my $r = [];

{

tie 
my @list, 
'Message::DOM::TreeCore::ManakaiDOMElementTypeDefMapArray'
, $self;
$r = \@list;


}
$r}
, 
'==' => sub ($$) {
my ($self, $arg) = @_;
my $r = 0;

{


{

local $Error::Depth = $Error::Depth + 1;

{


  my 
$length1 = $self->
length
;
  my $length2 = $arg->
length
;
  if ($length1 == $length2) {
    CHK: {
      for my $i (0..$length1-1) {
        my $node1 = $self->
item
 ($i);
        my $node2 = $arg->
item
 ($i);
        unless ($node1 == $node2) {
          last CHK;
        }
      }
      $r = 
1
;
    } # CHK
  }



}


;}

;


}
$r}
, 
fallback => 1;
$Message::DOM::DOMFeature::ClassInfo->{q<Message::DOM::TreeCore::ManakaiDOMElementTypeDefMap>}->{has_feature} = {'core',
{'',
'1',
'1.0',
'1',
'2.0',
'1',
'3.0',
'1'},
'http://suika.fam.cx/www/2006/feature/xdoctype',
{'',
'1',
'3.0',
'1'}};
$Message::DOM::ClassPoint{q<Message::DOM::TreeCore::ManakaiDOMElementTypeDefMap>} = 9;
package Message::DOM::TreeCore::ManakaiDOMAttrDefMap;
our $VERSION = 20070513.0354;
push our @ISA, 'Tie::Array',
'Message::DOM::IF::NamedNodeMap';
use Message::Util::Error;
sub FETCH ($$) {
my ($self, $name) = @_;
my $r;

{

my 
$list;


;


{


$list = ${$$$self}->{
'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#attributeDefinitions'
};



}

;


;


;
$r = $list->{$name};


}
$r}
*get_named_item = \&FETCH;
sub set_named_item ($$) {
my ($self, $arg) = @_;
my $r;

{

my 
$list;
my $expected_type;


;


{


$list = ${$$$self}->{
'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#attributeDefinitions'
};
  $expected_type = 
81002
;



}

;


;


;
if ($$$self->
owner_document

           ->
strict_error_checking
) {
  unless ($arg->
owner_document
              eq 
$$$self->
owner_document
) {
    
report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'WRONG_DOCUMENT_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'set_named_item', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#DIFFERENT_DOCUMENT_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMAttrDefMap';

;
  }
  if ($$$self->
manakai_read_only
) {
    
report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'set_named_item', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#NOMOD_NAMEDNODEMAP_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMAttrDefMap';

;
  }
  my $owner_def = $$arg->{
'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#ownerDefinition'
};
  if ($owner_def and not $owner_def eq $$$self) {
    
report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'INUSE_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'set_named_item', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#INUSE_DEFINITION_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMAttrDefMap', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#param-name' => 'arg', 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#node' => $arg;

;
    ## NOTE: If equals to owner, then replace-by-itself error.
  }
  if ($arg->
node_type
 != $expected_type) {
    
report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'HIERARCHY_REQUEST_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'set_named_item', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#HIERARCHY_BAD_TYPE', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMAttrDefMap', 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#nodeType' => $arg->node_type, 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#param-name' => 'arg';

;
  }
} # strictErrorChecking
SET: {
  my $name = $arg->
node_name
;
  if (defined $list->{$name}) {
    $r = $list->{$name};
    if ($r eq $arg) {
      
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, '-type' => 'http://suika.fam.cx/~wakaba/archive/2004/dom/tree#replace-by-itself', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'set_named_item', 'rdata' => $arg, 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMAttrDefMap';

;
      undef $r; # no return value
      last SET;
    }
  }
  $list->{$name} = $arg;
  $$arg->{
'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#ownerDefinition'
} = $$$self;
  Scalar::Util::weaken ($$arg->{
'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#ownerDefinition'
});
} # SET


}
$r}
sub remove_named_item ($$) {
my ($self, $name) = @_;
my $r;

{

my 
$list;
my $ifs;


;


{


$list = ${$$$self}->{
'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#attributeDefinitions'
};
  $ifs = [
'Message::DOM::IF::AttributeDefinition'
];



}

;


;


;
if ($$$self->
owner_document

           ->
strict_error_checking
) {
  if ($$$self->
manakai_read_only
) {
    
report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'remove_named_item', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#NOMOD_NAMEDNODEMAP_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMAttrDefMap';

;
  }
} # strictErrorChecking

if (defined $list->{$name}) {
  $r = $list->{$name};
  CORE::delete $$r->{
'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#ownerDefinition'
};
  CORE::delete $list->{$name};
} else {
  
report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'NOT_FOUND_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'remove_named_item', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#NO_NAMED_NODE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMAttrDefMap', 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#name' => $name, 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#param-name' => 'name';

;
}


}
$r}
sub DELETE ($$) {
my ($self, $key) = @_;
my $r;

{




try {local $Error::Depth = $Error::Depth + 3;


  $r = $self->
remove_named_item
 ($key);
} catch 
Message::DOM::IF::DOMException with 
{
  my $err = shift;
  unless ($err->subtype eq 
'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#NO_NAMED_NODE_ERR'
) {
    $err->throw;
  }
};


}
$r}
sub item ($$) {
my ($self, $index) = @_;
my $r;

{

my 
$list;
my $ifs;


;


{


$list = ${$$$self}->{
'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#attributeDefinitions'
};



}

;


;


;
my $key = $index >= 0 ? [sort {$a cmp $b} keys %$list]->[$index]
                      : 
undef
;
if (defined $key and defined $list->{$key}) {
  $r = $list->{$key};
}


}
$r}
sub FETCHSIZE ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r = 0;

{

my 
$list = ${$$$self}->{
'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#attributeDefinitions'
};
$r = @{[map {$_} values %$list]};


}
$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMAttrDefMap', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'length';
}
}
*length = \&FETCHSIZE;
sub STORESIZE ($$) {
my ($self, $count) = @_;

{


{

local $Error::Depth = $Error::Depth + 1;

{


  my 
$length = $self->
length
;
  if ($length > $count) {
    for (my $i = $length - 1; $i >= $count; $i--) {
      my $item = $self->
item
 ($i);
      $self->
remove_named_item

               ($item->
node_name
);
    }
  }



}


;}

;


}
}
sub EXISTS ($$) {
my ($self, $key) = @_;
my $r = 0;

{

my 
$list = ${$$$self}->{
'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#attributeDefinitions'
};
$r = exists $list->{$key};


}
$r}
sub FIRSTKEY ($) {
my ($self) = @_;
my $r = '';

{

my 
$list = ${$$$self}->{
'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#attributeDefinitions'
};
my $a = keys %$list; # reset
$r = each %$list;


}
$r}
sub NEXTKEY ($$) {
my ($self, $lastkey) = @_;
my $r = '';

{

my 
$list = ${$$$self}->{
'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#attributeDefinitions'
};
$r = each %$list;


}
$r}
sub SCALAR ($) {
my ($self) = @_;
my $r = '';

{

my 
$list = ${$$$self}->{
'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#attributeDefinitions'
};
$r = scalar %$list;


}
$r}
sub get_named_item_ns ($$$) {
my ($self, $namespaceURI, $localName) = @_;

{

if 
(CORE::defined $namespaceURI and CORE::length $namespaceURI == 0) {
  require Message::DOM::DOMMain;
  
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, '-type' => 'http://suika.fam.cx/~wakaba/archive/2004/dom/main#empty-namespace-uri', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'http://suika.fam.cx/~wakaba/archive/2004/dom/main#DOMNamespaceURIInputProcessor';

;

  $namespaceURI = undef;
}


}
my $r;


$r}
sub set_named_item_ns ($$) {
my ($self, $arg) = @_;
my $r;

{

report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'NAMESPACE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'set_named_item_ns', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#NO_NS_NAMEDNODEMAP_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMAttrDefMap';

;


}
$r}
sub remove_named_item_ns ($$$) {
my ($self, $namespaceURI, $localName) = @_;

{

if 
(CORE::defined $namespaceURI and CORE::length $namespaceURI == 0) {
  require Message::DOM::DOMMain;
  
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, '-type' => 'http://suika.fam.cx/~wakaba/archive/2004/dom/main#empty-namespace-uri', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'http://suika.fam.cx/~wakaba/archive/2004/dom/main#DOMNamespaceURIInputProcessor';

;

  $namespaceURI = undef;
}


}
my $r;

{

report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'NOT_FOUND_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'remove_named_item_ns', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#NO_NAMED_NODE_NS_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMAttrDefMap';

;


}
$r}
sub ___report_error ($$) {
my ($self, $err) = @_;
my $r;

{


{

local $Error::Depth = $Error::Depth + 1;

{



  $r = ($$$self)->___report_error ($err);



}


;}

;


}
$r}
sub TIEARRAY ($$) {
my ($self, $map) = @_;
my $r;

{


$r = bless \\($$$map), $self;


}
$r}
sub TIEHASH ($$) {
my ($self, $map) = @_;
my $r;

{


$r = $map;


}
$r}
sub manakai_read_only ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r = 0;

{


$r = ($$$self)->
manakai_read_only
;


}
$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMAttrDefMap', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'manakai_read_only';
}
}
use overload 
bool => sub () {1}, 
'%{}' => sub ($) {
my ($self) = @_;
my $r = {};

{

tie 
my %list, ref $self, $self;
$r = \%list;


}
$r}
, 
'@{}' => sub ($) {
my ($self) = @_;
my $r = [];

{

tie 
my @list, 
'Message::DOM::TreeCore::ManakaiDOMAttrDefMapArray'
, $self;
$r = \@list;


}
$r}
, 
'==' => sub ($$) {
my ($self, $arg) = @_;
my $r = 0;

{


{

local $Error::Depth = $Error::Depth + 1;

{


  my 
$length1 = $self->
length
;
  my $length2 = $arg->
length
;
  if ($length1 == $length2) {
    CHK: {
      for my $i (0..$length1-1) {
        my $node1 = $self->
item
 ($i);
        my $node2 = $arg->
item
 ($i);
        unless ($node1 == $node2) {
          last CHK;
        }
      }
      $r = 
1
;
    } # CHK
  }



}


;}

;


}
$r}
, 
fallback => 1;
$Message::DOM::DOMFeature::ClassInfo->{q<Message::DOM::TreeCore::ManakaiDOMAttrDefMap>}->{has_feature} = {'core',
{'',
'1',
'1.0',
'1',
'2.0',
'1',
'3.0',
'1'},
'http://suika.fam.cx/www/2006/feature/xdoctype',
{'',
'1',
'3.0',
'1'}};
$Message::DOM::ClassPoint{q<Message::DOM::TreeCore::ManakaiDOMAttrDefMap>} = 9;
package Message::DOM::TreeCore::ManakaiDOMEntityMap;
our $VERSION = 20070513.0354;
push our @ISA, 'Tie::Array',
'Message::DOM::IF::NamedNodeMap';
use Message::Util::Error;
sub FETCH ($$) {
my ($self, $name) = @_;
my $r;

{

my 
$list;


;


;


{


$list = ${$$$self}->{
'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#generalEntities'
};



}

;


;
$r = $list->{$name};


}
$r}
*get_named_item = \&FETCH;
sub set_named_item ($$) {
my ($self, $arg) = @_;
my $r;

{

my 
$list;
my $expected_type;


;


;


{


$list = ${$$$self}->{
'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#generalEntities'
};
  $expected_type = 
6
;



}

;


;
if ($$$self->
owner_document

           ->
strict_error_checking
) {
  unless ($arg->
owner_document
              eq 
$$$self->
owner_document
) {
    
report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'WRONG_DOCUMENT_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'set_named_item', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#DIFFERENT_DOCUMENT_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMEntityMap';

;
  }
  if ($$$self->
manakai_read_only
) {
    
report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'set_named_item', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#NOMOD_NAMEDNODEMAP_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMEntityMap';

;
  }
  my $owner_def = $$arg->{
'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#ownerDefinition'
};
  if ($owner_def and not $owner_def eq $$$self) {
    
report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'INUSE_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'set_named_item', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#INUSE_DEFINITION_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMEntityMap', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#param-name' => 'arg', 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#node' => $arg;

;
    ## NOTE: If equals to owner, then replace-by-itself error.
  }
  if ($arg->
node_type
 != $expected_type) {
    
report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'HIERARCHY_REQUEST_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'set_named_item', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#HIERARCHY_BAD_TYPE', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMEntityMap', 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#nodeType' => $arg->node_type, 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#param-name' => 'arg';

;
  }
} # strictErrorChecking
SET: {
  my $name = $arg->
node_name
;
  if (defined $list->{$name}) {
    $r = $list->{$name};
    if ($r eq $arg) {
      
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, '-type' => 'http://suika.fam.cx/~wakaba/archive/2004/dom/tree#replace-by-itself', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'set_named_item', 'rdata' => $arg, 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMEntityMap';

;
      undef $r; # no return value
      last SET;
    }
  }
  $list->{$name} = $arg;
  $$arg->{
'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#ownerDefinition'
} = $$$self;
  Scalar::Util::weaken ($$arg->{
'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#ownerDefinition'
});
} # SET


}
$r}
sub remove_named_item ($$) {
my ($self, $name) = @_;
my $r;

{

my 
$list;
my $ifs;


;


;


{


$list = ${$$$self}->{
'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#generalEntities'
};
  $ifs = [
'Message::DOM::IF::Entity'
];



}

;


;
if ($$$self->
owner_document

           ->
strict_error_checking
) {
  if ($$$self->
manakai_read_only
) {
    
report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'remove_named_item', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#NOMOD_NAMEDNODEMAP_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMEntityMap';

;
  }
} # strictErrorChecking

if (defined $list->{$name}) {
  $r = $list->{$name};
  CORE::delete $$r->{
'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#ownerDefinition'
};
  CORE::delete $list->{$name};
} else {
  
report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'NOT_FOUND_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'remove_named_item', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#NO_NAMED_NODE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMEntityMap', 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#name' => $name, 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#param-name' => 'name';

;
}


}
$r}
sub DELETE ($$) {
my ($self, $key) = @_;
my $r;

{




try {local $Error::Depth = $Error::Depth + 3;


  $r = $self->
remove_named_item
 ($key);
} catch 
Message::DOM::IF::DOMException with 
{
  my $err = shift;
  unless ($err->subtype eq 
'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#NO_NAMED_NODE_ERR'
) {
    $err->throw;
  }
};


}
$r}
sub item ($$) {
my ($self, $index) = @_;
my $r;

{

my 
$list;
my $ifs;


;


;


{


$list = ${$$$self}->{
'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#generalEntities'
};



}

;


;
my $key = $index >= 0 ? [sort {$a cmp $b} keys %$list]->[$index]
                      : 
undef
;
if (defined $key and defined $list->{$key}) {
  $r = $list->{$key};
}


}
$r}
sub FETCHSIZE ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r = 0;

{

my 
$list = ${$$$self}->{
'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#generalEntities'
};
$r = @{[map {$_} values %$list]};


}
$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMEntityMap', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'length';
}
}
*length = \&FETCHSIZE;
sub STORESIZE ($$) {
my ($self, $count) = @_;

{


{

local $Error::Depth = $Error::Depth + 1;

{


  my 
$length = $self->
length
;
  if ($length > $count) {
    for (my $i = $length - 1; $i >= $count; $i--) {
      my $item = $self->
item
 ($i);
      $self->
remove_named_item

               ($item->
node_name
);
    }
  }



}


;}

;


}
}
sub EXISTS ($$) {
my ($self, $key) = @_;
my $r = 0;

{

my 
$list = ${$$$self}->{
'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#generalEntities'
};
$r = exists $list->{$key};


}
$r}
sub FIRSTKEY ($) {
my ($self) = @_;
my $r = '';

{

my 
$list = ${$$$self}->{
'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#generalEntities'
};
my $a = keys %$list; # reset
$r = each %$list;


}
$r}
sub NEXTKEY ($$) {
my ($self, $lastkey) = @_;
my $r = '';

{

my 
$list = ${$$$self}->{
'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#generalEntities'
};
$r = each %$list;


}
$r}
sub SCALAR ($) {
my ($self) = @_;
my $r = '';

{

my 
$list = ${$$$self}->{
'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#generalEntities'
};
$r = scalar %$list;


}
$r}
sub get_named_item_ns ($$$) {
my ($self, $namespaceURI, $localName) = @_;

{

if 
(CORE::defined $namespaceURI and CORE::length $namespaceURI == 0) {
  require Message::DOM::DOMMain;
  
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, '-type' => 'http://suika.fam.cx/~wakaba/archive/2004/dom/main#empty-namespace-uri', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'http://suika.fam.cx/~wakaba/archive/2004/dom/main#DOMNamespaceURIInputProcessor';

;

  $namespaceURI = undef;
}


}
my $r;


$r}
sub set_named_item_ns ($$) {
my ($self, $arg) = @_;
my $r;

{

report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'NAMESPACE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'set_named_item_ns', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#NO_NS_NAMEDNODEMAP_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMEntityMap';

;


}
$r}
sub remove_named_item_ns ($$$) {
my ($self, $namespaceURI, $localName) = @_;

{

if 
(CORE::defined $namespaceURI and CORE::length $namespaceURI == 0) {
  require Message::DOM::DOMMain;
  
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, '-type' => 'http://suika.fam.cx/~wakaba/archive/2004/dom/main#empty-namespace-uri', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'http://suika.fam.cx/~wakaba/archive/2004/dom/main#DOMNamespaceURIInputProcessor';

;

  $namespaceURI = undef;
}


}
my $r;

{

report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'NOT_FOUND_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'remove_named_item_ns', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#NO_NAMED_NODE_NS_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMEntityMap';

;


}
$r}
sub ___report_error ($$) {
my ($self, $err) = @_;
my $r;

{


{

local $Error::Depth = $Error::Depth + 1;

{



  $r = ($$$self)->___report_error ($err);



}


;}

;


}
$r}
sub TIEARRAY ($$) {
my ($self, $map) = @_;
my $r;

{


$r = bless \\($$$map), $self;


}
$r}
sub TIEHASH ($$) {
my ($self, $map) = @_;
my $r;

{


$r = $map;


}
$r}
sub manakai_read_only ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r = 0;

{


$r = ($$$self)->
manakai_read_only
;


}
$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMEntityMap', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'manakai_read_only';
}
}
use overload 
bool => sub () {1}, 
'%{}' => sub ($) {
my ($self) = @_;
my $r = {};

{

tie 
my %list, ref $self, $self;
$r = \%list;


}
$r}
, 
'@{}' => sub ($) {
my ($self) = @_;
my $r = [];

{

tie 
my @list, 
'Message::DOM::TreeCore::ManakaiDOMEntityMapArray'
, $self;
$r = \@list;


}
$r}
, 
'==' => sub ($$) {
my ($self, $arg) = @_;
my $r = 0;

{


{

local $Error::Depth = $Error::Depth + 1;

{


  my 
$length1 = $self->
length
;
  my $length2 = $arg->
length
;
  if ($length1 == $length2) {
    CHK: {
      for my $i (0..$length1-1) {
        my $node1 = $self->
item
 ($i);
        my $node2 = $arg->
item
 ($i);
        unless ($node1 == $node2) {
          last CHK;
        }
      }
      $r = 
1
;
    } # CHK
  }



}


;}

;


}
$r}
, 
fallback => 1;
$Message::DOM::DOMFeature::ClassInfo->{q<Message::DOM::TreeCore::ManakaiDOMEntityMap>}->{has_feature} = {'core',
{'',
'1',
'1.0',
'1',
'2.0',
'1',
'3.0',
'1'},
'xml',
{'',
'1',
'1.0',
'1',
'2.0',
'1',
'3.0',
'1'},
'xmlversion',
{'',
'1',
'1.0',
'1',
'1.1',
'1'}};
$Message::DOM::ClassPoint{q<Message::DOM::TreeCore::ManakaiDOMEntityMap>} = 14.1;
package Message::DOM::TreeCore::ManakaiDOMNotationMap;
our $VERSION = 20070513.0354;
push our @ISA, 'Tie::Array',
'Message::DOM::IF::NamedNodeMap';
use Message::Util::Error;
sub FETCH ($$) {
my ($self, $name) = @_;
my $r;

{

my 
$list;


;


;


;


{


$list = ${$$$self}->{
'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#notations'
};



}

;
$r = $list->{$name};


}
$r}
*get_named_item = \&FETCH;
sub set_named_item ($$) {
my ($self, $arg) = @_;
my $r;

{

my 
$list;
my $expected_type;


;


;


;


{


$list = ${$$$self}->{
'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#notations'
};
  $expected_type = 
12
;



}

;
if ($$$self->
owner_document

           ->
strict_error_checking
) {
  unless ($arg->
owner_document
              eq 
$$$self->
owner_document
) {
    
report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'WRONG_DOCUMENT_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'set_named_item', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#DIFFERENT_DOCUMENT_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMNotationMap';

;
  }
  if ($$$self->
manakai_read_only
) {
    
report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'set_named_item', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#NOMOD_NAMEDNODEMAP_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMNotationMap';

;
  }
  my $owner_def = $$arg->{
'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#ownerDefinition'
};
  if ($owner_def and not $owner_def eq $$$self) {
    
report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'INUSE_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'set_named_item', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#INUSE_DEFINITION_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMNotationMap', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#param-name' => 'arg', 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#node' => $arg;

;
    ## NOTE: If equals to owner, then replace-by-itself error.
  }
  if ($arg->
node_type
 != $expected_type) {
    
report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'HIERARCHY_REQUEST_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'set_named_item', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#HIERARCHY_BAD_TYPE', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMNotationMap', 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#nodeType' => $arg->node_type, 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#param-name' => 'arg';

;
  }
} # strictErrorChecking
SET: {
  my $name = $arg->
node_name
;
  if (defined $list->{$name}) {
    $r = $list->{$name};
    if ($r eq $arg) {
      
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, '-type' => 'http://suika.fam.cx/~wakaba/archive/2004/dom/tree#replace-by-itself', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'set_named_item', 'rdata' => $arg, 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMNotationMap';

;
      undef $r; # no return value
      last SET;
    }
  }
  $list->{$name} = $arg;
  $$arg->{
'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#ownerDefinition'
} = $$$self;
  Scalar::Util::weaken ($$arg->{
'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#ownerDefinition'
});
} # SET


}
$r}
sub remove_named_item ($$) {
my ($self, $name) = @_;
my $r;

{

my 
$list;
my $ifs;


;


;


;


{


$list = ${$$$self}->{
'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#notations'
};
  $ifs = [
'Message::DOM::IF::Notation'
];



}

;
if ($$$self->
owner_document

           ->
strict_error_checking
) {
  if ($$$self->
manakai_read_only
) {
    
report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'remove_named_item', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#NOMOD_NAMEDNODEMAP_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMNotationMap';

;
  }
} # strictErrorChecking

if (defined $list->{$name}) {
  $r = $list->{$name};
  CORE::delete $$r->{
'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#ownerDefinition'
};
  CORE::delete $list->{$name};
} else {
  
report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'NOT_FOUND_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'remove_named_item', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#NO_NAMED_NODE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMNotationMap', 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#name' => $name, 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#param-name' => 'name';

;
}


}
$r}
sub DELETE ($$) {
my ($self, $key) = @_;
my $r;

{




try {local $Error::Depth = $Error::Depth + 3;


  $r = $self->
remove_named_item
 ($key);
} catch 
Message::DOM::IF::DOMException with 
{
  my $err = shift;
  unless ($err->subtype eq 
'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#NO_NAMED_NODE_ERR'
) {
    $err->throw;
  }
};


}
$r}
sub item ($$) {
my ($self, $index) = @_;
my $r;

{

my 
$list;
my $ifs;


;


;


;


{


$list = ${$$$self}->{
'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#notations'
};



}

;
my $key = $index >= 0 ? [sort {$a cmp $b} keys %$list]->[$index]
                      : 
undef
;
if (defined $key and defined $list->{$key}) {
  $r = $list->{$key};
}


}
$r}
sub FETCHSIZE ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r = 0;

{

my 
$list = ${$$$self}->{
'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#notations'
};
$r = @{[map {$_} values %$list]};


}
$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMNotationMap', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'length';
}
}
*length = \&FETCHSIZE;
sub STORESIZE ($$) {
my ($self, $count) = @_;

{


{

local $Error::Depth = $Error::Depth + 1;

{


  my 
$length = $self->
length
;
  if ($length > $count) {
    for (my $i = $length - 1; $i >= $count; $i--) {
      my $item = $self->
item
 ($i);
      $self->
remove_named_item

               ($item->
node_name
);
    }
  }



}


;}

;


}
}
sub EXISTS ($$) {
my ($self, $key) = @_;
my $r = 0;

{

my 
$list = ${$$$self}->{
'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#notations'
};
$r = exists $list->{$key};


}
$r}
sub FIRSTKEY ($) {
my ($self) = @_;
my $r = '';

{

my 
$list = ${$$$self}->{
'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#notations'
};
my $a = keys %$list; # reset
$r = each %$list;


}
$r}
sub NEXTKEY ($$) {
my ($self, $lastkey) = @_;
my $r = '';

{

my 
$list = ${$$$self}->{
'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#notations'
};
$r = each %$list;


}
$r}
sub SCALAR ($) {
my ($self) = @_;
my $r = '';

{

my 
$list = ${$$$self}->{
'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#notations'
};
$r = scalar %$list;


}
$r}
sub get_named_item_ns ($$$) {
my ($self, $namespaceURI, $localName) = @_;

{

if 
(CORE::defined $namespaceURI and CORE::length $namespaceURI == 0) {
  require Message::DOM::DOMMain;
  
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, '-type' => 'http://suika.fam.cx/~wakaba/archive/2004/dom/main#empty-namespace-uri', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'http://suika.fam.cx/~wakaba/archive/2004/dom/main#DOMNamespaceURIInputProcessor';

;

  $namespaceURI = undef;
}


}
my $r;


$r}
sub set_named_item_ns ($$) {
my ($self, $arg) = @_;
my $r;

{

report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'NAMESPACE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'set_named_item_ns', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#NO_NS_NAMEDNODEMAP_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMNotationMap';

;


}
$r}
sub remove_named_item_ns ($$$) {
my ($self, $namespaceURI, $localName) = @_;

{

if 
(CORE::defined $namespaceURI and CORE::length $namespaceURI == 0) {
  require Message::DOM::DOMMain;
  
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, '-type' => 'http://suika.fam.cx/~wakaba/archive/2004/dom/main#empty-namespace-uri', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'http://suika.fam.cx/~wakaba/archive/2004/dom/main#DOMNamespaceURIInputProcessor';

;

  $namespaceURI = undef;
}


}
my $r;

{

report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'NOT_FOUND_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'remove_named_item_ns', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#NO_NAMED_NODE_NS_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMNotationMap';

;


}
$r}
sub ___report_error ($$) {
my ($self, $err) = @_;
my $r;

{


{

local $Error::Depth = $Error::Depth + 1;

{



  $r = ($$$self)->___report_error ($err);



}


;}

;


}
$r}
sub TIEARRAY ($$) {
my ($self, $map) = @_;
my $r;

{


$r = bless \\($$$map), $self;


}
$r}
sub TIEHASH ($$) {
my ($self, $map) = @_;
my $r;

{


$r = $map;


}
$r}
sub manakai_read_only ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r = 0;

{


$r = ($$$self)->
manakai_read_only
;


}
$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMNotationMap', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'manakai_read_only';
}
}
use overload 
bool => sub () {1}, 
'%{}' => sub ($) {
my ($self) = @_;
my $r = {};

{

tie 
my %list, ref $self, $self;
$r = \%list;


}
$r}
, 
'@{}' => sub ($) {
my ($self) = @_;
my $r = [];

{

tie 
my @list, 
'Message::DOM::TreeCore::ManakaiDOMNotationMapArray'
, $self;
$r = \@list;


}
$r}
, 
'==' => sub ($$) {
my ($self, $arg) = @_;
my $r = 0;

{


{

local $Error::Depth = $Error::Depth + 1;

{


  my 
$length1 = $self->
length
;
  my $length2 = $arg->
length
;
  if ($length1 == $length2) {
    CHK: {
      for my $i (0..$length1-1) {
        my $node1 = $self->
item
 ($i);
        my $node2 = $arg->
item
 ($i);
        unless ($node1 == $node2) {
          last CHK;
        }
      }
      $r = 
1
;
    } # CHK
  }



}


;}

;


}
$r}
, 
fallback => 1;
$Message::DOM::DOMFeature::ClassInfo->{q<Message::DOM::TreeCore::ManakaiDOMNotationMap>}->{has_feature} = {'core',
{'',
'1',
'1.0',
'1',
'2.0',
'1',
'3.0',
'1'},
'xml',
{'',
'1',
'1.0',
'1',
'2.0',
'1',
'3.0',
'1'},
'xmlversion',
{'',
'1',
'1.0',
'1',
'1.1',
'1'}};
$Message::DOM::ClassPoint{q<Message::DOM::TreeCore::ManakaiDOMNotationMap>} = 14.1;
package Message::DOM::TreeCore::ManakaiDOMAttrMapArray;
our $VERSION = 20070513.0354;
push our @ISA, 'Message::DOM::TreeCore::ManakaiDOMAttrMap',
'Tie::Array';
sub FETCH ($$) {
my ($self, $index) = @_;
my $r;

{


{

local $Error::Depth = $Error::Depth + 1;

{



  $r = $self->
item
 ($index);



}


;}

;


}
$r}
sub EXISTS ($$) {
my ($self, $index) = @_;
my $r = 0;

{


{

local $Error::Depth = $Error::Depth + 1;

{


  my 
$length = $self->
length
;
  $r = ($index < $length);



}


;}

;


}
$r}
sub DELETE ($$) {
my ($self, $index) = @_;
my $r;

{


{

local $Error::Depth = $Error::Depth + 1;

{


  my 
$item = $self->
item
 ($index);
  if ($item) {
    $r = $self->
remove_named_item

                    ($item->
node_name
);
  }



}


;}

;


}
$r}
$Message::DOM::DOMFeature::ClassInfo->{q<Message::DOM::TreeCore::ManakaiDOMAttrMapArray>}->{has_feature} = {'core',
{'',
'1',
'1.0',
'1',
'2.0',
'1',
'3.0',
'1'}};
$Message::DOM::ClassPoint{q<Message::DOM::TreeCore::ManakaiDOMAttrMapArray>} = 6;
package Message::DOM::TreeCore::ManakaiDOMElementTypeDefMapArray;
our $VERSION = 20070513.0354;
push our @ISA, 'Message::DOM::TreeCore::ManakaiDOMElementTypeDefMap',
'Tie::Array';
sub FETCH ($$) {
my ($self, $index) = @_;
my $r;

{


{

local $Error::Depth = $Error::Depth + 1;

{



  $r = $self->
item
 ($index);



}


;}

;


}
$r}
sub EXISTS ($$) {
my ($self, $index) = @_;
my $r = 0;

{


{

local $Error::Depth = $Error::Depth + 1;

{


  my 
$length = $self->
length
;
  $r = ($index < $length);



}


;}

;


}
$r}
sub DELETE ($$) {
my ($self, $index) = @_;
my $r;

{


{

local $Error::Depth = $Error::Depth + 1;

{


  my 
$item = $self->
item
 ($index);
  if ($item) {
    $r = $self->
remove_named_item

                    ($item->
node_name
);
  }



}


;}

;


}
$r}
$Message::DOM::DOMFeature::ClassInfo->{q<Message::DOM::TreeCore::ManakaiDOMElementTypeDefMapArray>}->{has_feature} = {'core',
{'',
'1',
'1.0',
'1',
'2.0',
'1',
'3.0',
'1'},
'http://suika.fam.cx/www/2006/feature/xdoctype',
{'',
'1',
'3.0',
'1'}};
$Message::DOM::ClassPoint{q<Message::DOM::TreeCore::ManakaiDOMElementTypeDefMapArray>} = 9;
package Message::DOM::TreeCore::ManakaiDOMAttrDefMapArray;
our $VERSION = 20070513.0354;
push our @ISA, 'Message::DOM::TreeCore::ManakaiDOMAttrDefMap',
'Tie::Array';
sub FETCH ($$) {
my ($self, $index) = @_;
my $r;

{


{

local $Error::Depth = $Error::Depth + 1;

{



  $r = $self->
item
 ($index);



}


;}

;


}
$r}
sub EXISTS ($$) {
my ($self, $index) = @_;
my $r = 0;

{


{

local $Error::Depth = $Error::Depth + 1;

{


  my 
$length = $self->
length
;
  $r = ($index < $length);



}


;}

;


}
$r}
sub DELETE ($$) {
my ($self, $index) = @_;
my $r;

{


{

local $Error::Depth = $Error::Depth + 1;

{


  my 
$item = $self->
item
 ($index);
  if ($item) {
    $r = $self->
remove_named_item

                    ($item->
node_name
);
  }



}


;}

;


}
$r}
$Message::DOM::DOMFeature::ClassInfo->{q<Message::DOM::TreeCore::ManakaiDOMAttrDefMapArray>}->{has_feature} = {'core',
{'',
'1',
'1.0',
'1',
'2.0',
'1',
'3.0',
'1'},
'http://suika.fam.cx/www/2006/feature/xdoctype',
{'',
'1',
'3.0',
'1'}};
$Message::DOM::ClassPoint{q<Message::DOM::TreeCore::ManakaiDOMAttrDefMapArray>} = 9;
package Message::DOM::TreeCore::ManakaiDOMEntityMapArray;
our $VERSION = 20070513.0354;
push our @ISA, 'Message::DOM::TreeCore::ManakaiDOMEntityMap',
'Tie::Array';
sub FETCH ($$) {
my ($self, $index) = @_;
my $r;

{


{

local $Error::Depth = $Error::Depth + 1;

{



  $r = $self->
item
 ($index);



}


;}

;


}
$r}
sub EXISTS ($$) {
my ($self, $index) = @_;
my $r = 0;

{


{

local $Error::Depth = $Error::Depth + 1;

{


  my 
$length = $self->
length
;
  $r = ($index < $length);



}


;}

;


}
$r}
sub DELETE ($$) {
my ($self, $index) = @_;
my $r;

{


{

local $Error::Depth = $Error::Depth + 1;

{


  my 
$item = $self->
item
 ($index);
  if ($item) {
    $r = $self->
remove_named_item

                    ($item->
node_name
);
  }



}


;}

;


}
$r}
$Message::DOM::DOMFeature::ClassInfo->{q<Message::DOM::TreeCore::ManakaiDOMEntityMapArray>}->{has_feature} = {'core',
{'',
'1',
'1.0',
'1',
'2.0',
'1',
'3.0',
'1'},
'xml',
{'',
'1',
'1.0',
'1',
'2.0',
'1',
'3.0',
'1'},
'xmlversion',
{'',
'1',
'1.0',
'1',
'1.1',
'1'}};
$Message::DOM::ClassPoint{q<Message::DOM::TreeCore::ManakaiDOMEntityMapArray>} = 14.1;
package Message::DOM::TreeCore::ManakaiDOMNotationMapArray;
our $VERSION = 20070513.0354;
push our @ISA, 'Message::DOM::TreeCore::ManakaiDOMNotationMap',
'Tie::Array';
sub FETCH ($$) {
my ($self, $index) = @_;
my $r;

{


{

local $Error::Depth = $Error::Depth + 1;

{



  $r = $self->
item
 ($index);



}


;}

;


}
$r}
sub EXISTS ($$) {
my ($self, $index) = @_;
my $r = 0;

{


{

local $Error::Depth = $Error::Depth + 1;

{


  my 
$length = $self->
length
;
  $r = ($index < $length);



}


;}

;


}
$r}
sub DELETE ($$) {
my ($self, $index) = @_;
my $r;

{


{

local $Error::Depth = $Error::Depth + 1;

{


  my 
$item = $self->
item
 ($index);
  if ($item) {
    $r = $self->
remove_named_item

                    ($item->
node_name
);
  }



}


;}

;


}
$r}
$Message::DOM::DOMFeature::ClassInfo->{q<Message::DOM::TreeCore::ManakaiDOMNotationMapArray>}->{has_feature} = {'core',
{'',
'1',
'1.0',
'1',
'2.0',
'1',
'3.0',
'1'},
'xml',
{'',
'1',
'1.0',
'1',
'2.0',
'1',
'3.0',
'1'},
'xmlversion',
{'',
'1',
'1.0',
'1',
'1.1',
'1'}};
$Message::DOM::ClassPoint{q<Message::DOM::TreeCore::ManakaiDOMNotationMapArray>} = 14.1;
package Message::DOM::IF::UserDataHandler;
our $VERSION = 20070513.0354;
sub NODE_CLONED () {
1}
sub NODE_IMPORTED () {
2}
sub NODE_DELETED () {
3}
sub NODE_RENAMED () {
4}
sub NODE_ADOPTED () {
5}
package Message::DOM::TreeCore::ManakaiDOMUserDataHandler;
our $VERSION = 20070513.0354;
push our @ISA, 'Message::DOM::IF::UserDataHandler';
sub handle ($$$$;$$) {
my ($self, $operation, $key, $data, $src, $dst) = @_;

{

goto 
&$self;


}
}
$Message::DOM::DOMFeature::ClassInfo->{q<Message::DOM::TreeCore::ManakaiDOMUserDataHandler>}->{has_feature} = {'core',
{'',
'1',
'3.0',
'1'},
'xml',
{'',
'1',
'3.0',
'1'},
'xmlversion',
{'',
'1',
'1.0',
'1',
'1.1',
'1'}};
$Message::DOM::ClassPoint{q<Message::DOM::TreeCore::ManakaiDOMUserDataHandler>} = 8.1;
for ($Message::Util::Error::MUErrorTarget::){}
## License: <http://suika.fam.cx/~wakaba/archive/2004/8/18/license#Perl+MPL>
1;
