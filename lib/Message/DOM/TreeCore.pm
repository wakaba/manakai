#!/usr/bin/perl 
## This file is automatically generated
## 	at 2006-11-03T17:21:27+00:00,
## 	from file "TreeCore.dis",
## 	module <http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#ManakaiDOM.TreeCore>,
## 	for <http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#ManakaiDOMLatest>.
## Don't edit by hand!
use strict;
require Message::DOM::DOMCore;
require Message::DOM::DOMFeature;
require Message::Util::Error::DOMException;
require Tie::Array;
package Message::DOM::TreeCore;
our $VERSION = 20061103.1721;
$Message::DOM::DOMCore::ManakaiDOMConfiguration{'Message::DOM::IFLatest::Document'}->{'http://suika.fam.cx/www/2006/dom-config/clone-entity-reference-subtree'} = {'iname',
'cerst',
'type',
'boolean',
'vsupport',
['1',
'1']};
$Message::DOM::DOMCore::ManakaiDOMConfiguration{'Message::DOM::IFLatest::Document'}->{'http://suika.fam.cx/www/2006/dom-config/dtd-default-attribute'} = {'default',
'1',
'iname',
'dtddefault',
'type',
'boolean',
'vsupport',
['1',
'1']};
$Message::DOM::DOMCore::ManakaiDOMConfiguration{'Message::DOM::IFLatest::Document'}->{'http://suika.fam.cx/www/2006/dom-config/dtd-attribute-type'} = {'default',
'1',
'iname',
'dtdattrtype',
'type',
'boolean',
'vsupport',
['1',
'1']};
$Message::DOM::DOMCore::ManakaiDOMConfiguration{'Message::DOM::IFLatest::Document'}->{'http://suika.fam.cx/www/2006/dom-config/xml-id'} = {'default',
'1',
'iname',
'xmlid',
'type',
'boolean',
'vsupport',
['1',
'1']};
$Message::DOM::DOMCore::ManakaiDOMConfiguration{'Message::DOM::IFLatest::Document'}->{'http://suika.fam.cx/www/2006/dom-config/strict-document-children'} = {'default',
'1',
'iname',
'sdocchild',
'type',
'boolean',
'vsupport',
['1',
'1']};
$Message::DOM::DOMCore::ManakaiDOMError::Def{'http://suika.fam.cx/~wakaba/archive/2005/manakai/DOM/TreeCore/wf-invalid-character-in-node-name'} = {'description',
'If the <cfg::c|well-formed> configuration parameter is set to <DOM::true> and a <A::Node.nodeName> contains invalid character according to its node type. Or, in <IF::DOMLS|LSSerializer>, if a character that cannot be represented in the output character encoding is occurred within markup.',
'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/Core/textFormatter',
'Message::Util::Error::formatter',
'sev',
'2',
't',
'wf-invalid-character-in-node-name'};
$Message::DOM::DOMCore::ManakaiDOMError::Def{'http://suika.fam.cx/~wakaba/archive/2005/manakai/DOM/TreeCore/wf-invalid-character'} = {'description',
'If the <cfg::well-formed> configuration parameter is set to <DOM::true> and the text content inside <IF::Attr>, <IF::Element>, <IF::Comment>, <IF::Text>, or <IF::tx|CDATASection> node or the data inside <IF::tx|ProcessingInstruction> node contains invalid characters. Or, in <IF::DOMLS:LSSerializer>, if the <cfg::split-cdata-sections> parameter is set to <DOM::false> and a <IF::tx|CDATASection> node contains characters that cannot be represented in the specified output encoding. This error is not recoverable.',
'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/Core/textFormatter',
'Message::Util::Error::formatter',
'sev',
'2',
't',
'wf-invalid-character'};
$Message::DOM::DOMCore::ManakaiDOMError::Def{'http://suika.fam.cx/~wakaba/archive/2004/dom/tree#setting-node-value-no-effect'} = {'description',
'An attempt is made to set the <A::Node.nodeValue> that is defined as <DOM::null>. The operation has no effect.',
'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/Core/textFormatter',
'Message::Util::Error::formatter',
'sev',
'1',
't',
'http://suika.fam.cx/~wakaba/archive/2004/dom/tree#setting-node-value-no-effect'};
$Message::DOM::DOMCore::ManakaiDOMError::Def{'http://suika.fam.cx/~wakaba/archive/2004/dom/tree#insert-before-itself'} = {'description',
'An attempt is made to insert a node before itself. The result is implementation dependent; it has no effect in manakai.',
'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/Core/textFormatter',
'Message::Util::Error::formatter',
'sev',
'1',
't',
'http://suika.fam.cx/~wakaba/archive/2004/dom/tree#insert-before-itself'};
$Message::DOM::DOMCore::ManakaiDOMError::Def{'http://suika.fam.cx/~wakaba/archive/2004/dom/tree#replace-by-itself'} = {'description',
'An attempt is made to replace a node by itself. The result is implementation dependent; it has no effect in manakai.',
'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/Core/textFormatter',
'Message::Util::Error::formatter',
'sev',
'1',
't',
'http://suika.fam.cx/~wakaba/archive/2004/dom/tree#replace-by-itself'};
$Message::DOM::DOMCore::ManakaiDOMError::Def{'http://suika.fam.cx/~wakaba/archive/2004/dom/tree#setting-prefix-no-effect-because-of-node'} = {'description',
'An attempt is made to set the <A::Node.prefix> that is defined as <DOM::null> since it is not an <IF::Element> or <IF::Attr> node or since it is a DOM Level 1 (i.e. namespace unaware) node. The operation has no effect.',
'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/Core/textFormatter',
'Message::Util::Error::formatter',
'sev',
'1',
't',
'http://suika.fam.cx/~wakaba/archive/2004/dom/tree#setting-prefix-no-effect-because-of-node'};
$Message::DOM::DOMCore::ManakaiDOMError::Def{'http://suika.fam.cx/~wakaba/archive/2004/dom/tree#setting-prefix-no-effect-because-of-document'} = {'description',
'An attempt is made to set the <A::Node.prefix> that is defined as <DOM::null> since its owner document does not support XML namespaces. The operation has no effect.',
'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/Core/textFormatter',
'Message::Util::Error::formatter',
'sev',
'1',
't',
'http://suika.fam.cx/~wakaba/archive/2004/dom/tree#setting-prefix-no-effect-because-of-document'};
sub ATTRIBUTE_DEFINITION_NODE ();
sub ATTRIBUTE_NODE ();
sub CDATA_SECTION_NODE ();
sub COMMENT_NODE ();
sub DOCUMENT_FRAGMENT_NODE ();
sub DOCUMENT_NODE ();
sub DOCUMENT_POSITION_CONTAINED_BY ();
sub DOCUMENT_POSITION_CONTAINS ();
sub DOCUMENT_POSITION_DISCONNECTED ();
sub DOCUMENT_POSITION_FOLLOWING ();
sub DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC ();
sub DOCUMENT_POSITION_PRECEDING ();
sub DOCUMENT_TYPE_NODE ();
sub ELEMENT_NODE ();
sub ELEMENT_TYPE_DEFINITION_NODE ();
sub ENTITY_NODE ();
sub ENTITY_REFERENCE_NODE ();
sub NOTATION_NODE ();
sub PROCESSING_INSTRUCTION_NODE ();
sub TEXT_NODE ();
sub AUTOLOAD {


        my $al = our $AUTOLOAD;
        $al =~ s/.+:://;
        if ({'ATTRIBUTE_DEFINITION_NODE',
'Message::DOM::IFLatest::Node::ATTRIBUTE_DEFINITION_NODE',
'ATTRIBUTE_NODE',
'Message::DOM::IFLatest::Node::ATTRIBUTE_NODE',
'CDATA_SECTION_NODE',
'Message::DOM::IFLatest::Node::CDATA_SECTION_NODE',
'COMMENT_NODE',
'Message::DOM::IFLatest::Node::COMMENT_NODE',
'DOCUMENT_FRAGMENT_NODE',
'Message::DOM::IFLatest::Node::DOCUMENT_FRAGMENT_NODE',
'DOCUMENT_NODE',
'Message::DOM::IFLatest::Node::DOCUMENT_NODE',
'DOCUMENT_POSITION_CONTAINED_BY',
'Message::DOM::IFLatest::Node::DOCUMENT_POSITION_CONTAINED_BY',
'DOCUMENT_POSITION_CONTAINS',
'Message::DOM::IFLatest::Node::DOCUMENT_POSITION_CONTAINS',
'DOCUMENT_POSITION_DISCONNECTED',
'Message::DOM::IFLatest::Node::DOCUMENT_POSITION_DISCONNECTED',
'DOCUMENT_POSITION_FOLLOWING',
'Message::DOM::IFLatest::Node::DOCUMENT_POSITION_FOLLOWING',
'DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC',
'Message::DOM::IFLatest::Node::DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC',
'DOCUMENT_POSITION_PRECEDING',
'Message::DOM::IFLatest::Node::DOCUMENT_POSITION_PRECEDING',
'DOCUMENT_TYPE_NODE',
'Message::DOM::IFLatest::Node::DOCUMENT_TYPE_NODE',
'ELEMENT_NODE',
'Message::DOM::IFLatest::Node::ELEMENT_NODE',
'ELEMENT_TYPE_DEFINITION_NODE',
'Message::DOM::IFLatest::Node::ELEMENT_TYPE_DEFINITION_NODE',
'ENTITY_NODE',
'Message::DOM::IFLatest::Node::ENTITY_NODE',
'ENTITY_REFERENCE_NODE',
'Message::DOM::IFLatest::Node::ENTITY_REFERENCE_NODE',
'NOTATION_NODE',
'Message::DOM::IFLatest::Node::NOTATION_NODE',
'PROCESSING_INSTRUCTION_NODE',
'Message::DOM::IFLatest::Node::PROCESSING_INSTRUCTION_NODE',
'TEXT_NODE',
'Message::DOM::IFLatest::Node::TEXT_NODE'}->{$al}) {
          no strict 'refs';
          *{$AUTOLOAD} = \&{{'ATTRIBUTE_DEFINITION_NODE',
'Message::DOM::IFLatest::Node::ATTRIBUTE_DEFINITION_NODE',
'ATTRIBUTE_NODE',
'Message::DOM::IFLatest::Node::ATTRIBUTE_NODE',
'CDATA_SECTION_NODE',
'Message::DOM::IFLatest::Node::CDATA_SECTION_NODE',
'COMMENT_NODE',
'Message::DOM::IFLatest::Node::COMMENT_NODE',
'DOCUMENT_FRAGMENT_NODE',
'Message::DOM::IFLatest::Node::DOCUMENT_FRAGMENT_NODE',
'DOCUMENT_NODE',
'Message::DOM::IFLatest::Node::DOCUMENT_NODE',
'DOCUMENT_POSITION_CONTAINED_BY',
'Message::DOM::IFLatest::Node::DOCUMENT_POSITION_CONTAINED_BY',
'DOCUMENT_POSITION_CONTAINS',
'Message::DOM::IFLatest::Node::DOCUMENT_POSITION_CONTAINS',
'DOCUMENT_POSITION_DISCONNECTED',
'Message::DOM::IFLatest::Node::DOCUMENT_POSITION_DISCONNECTED',
'DOCUMENT_POSITION_FOLLOWING',
'Message::DOM::IFLatest::Node::DOCUMENT_POSITION_FOLLOWING',
'DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC',
'Message::DOM::IFLatest::Node::DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC',
'DOCUMENT_POSITION_PRECEDING',
'Message::DOM::IFLatest::Node::DOCUMENT_POSITION_PRECEDING',
'DOCUMENT_TYPE_NODE',
'Message::DOM::IFLatest::Node::DOCUMENT_TYPE_NODE',
'ELEMENT_NODE',
'Message::DOM::IFLatest::Node::ELEMENT_NODE',
'ELEMENT_TYPE_DEFINITION_NODE',
'Message::DOM::IFLatest::Node::ELEMENT_TYPE_DEFINITION_NODE',
'ENTITY_NODE',
'Message::DOM::IFLatest::Node::ENTITY_NODE',
'ENTITY_REFERENCE_NODE',
'Message::DOM::IFLatest::Node::ENTITY_REFERENCE_NODE',
'NOTATION_NODE',
'Message::DOM::IFLatest::Node::NOTATION_NODE',
'PROCESSING_INSTRUCTION_NODE',
'Message::DOM::IFLatest::Node::PROCESSING_INSTRUCTION_NODE',
'TEXT_NODE',
'Message::DOM::IFLatest::Node::TEXT_NODE'}->{$al}};
          goto &{$AUTOLOAD};
        } else {
          require Carp;
          Carp::croak (qq<Can't locate method "$AUTOLOAD">);
        }
      
}
sub import {


        my $self = shift;
        if (@_) {
          local $Exporter::ExportLevel = $Exporter::ExportLevel + 1;
          $self->SUPER::import (@_);
          for (grep {not /\W/} @_) {
            eval qq{$_};
          }
        }
      
}
our %EXPORT_TAG = ('DocumentPosition',
['DOCUMENT_POSITION_CONTAINED_BY',
'DOCUMENT_POSITION_CONTAINS',
'DOCUMENT_POSITION_DISCONNECTED',
'DOCUMENT_POSITION_FOLLOWING',
'DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC',
'DOCUMENT_POSITION_PRECEDING'],
'NodeType',
['ATTRIBUTE_DEFINITION_NODE',
'ATTRIBUTE_NODE',
'CDATA_SECTION_NODE',
'COMMENT_NODE',
'DOCUMENT_FRAGMENT_NODE',
'DOCUMENT_NODE',
'DOCUMENT_TYPE_NODE',
'ELEMENT_NODE',
'ELEMENT_TYPE_DEFINITION_NODE',
'ENTITY_NODE',
'ENTITY_REFERENCE_NODE',
'NOTATION_NODE',
'PROCESSING_INSTRUCTION_NODE',
'TEXT_NODE']);
our @EXPORT_OK = ('DOCUMENT_POSITION_CONTAINED_BY',
'DOCUMENT_POSITION_CONTAINS',
'DOCUMENT_POSITION_DISCONNECTED',
'DOCUMENT_POSITION_FOLLOWING',
'DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC',
'DOCUMENT_POSITION_PRECEDING',
'ATTRIBUTE_DEFINITION_NODE',
'ATTRIBUTE_NODE',
'CDATA_SECTION_NODE',
'COMMENT_NODE',
'DOCUMENT_FRAGMENT_NODE',
'DOCUMENT_NODE',
'DOCUMENT_TYPE_NODE',
'ELEMENT_NODE',
'ELEMENT_TYPE_DEFINITION_NODE',
'ENTITY_NODE',
'ENTITY_REFERENCE_NODE',
'NOTATION_NODE',
'PROCESSING_INSTRUCTION_NODE',
'TEXT_NODE');
use Exporter; push our @ISA, 'Exporter';
package Message::DOM::TreeCore::ManakaiDOMImplementationTC;
our $VERSION = 20061103.1721;
push @Message::DOM::DOMCore::ManakaiDOMImplementation::ISA, q<Message::DOM::TreeCore::ManakaiDOMImplementationTC>;
use Char::Class::XML 'InXMLNCNameChar10',
'InXMLNameChar10',
'InXML_NCNameStartChar10',
'InXML_NameStartChar10';
sub create_document ($;$$$) {
my ($self, $namespaceURI, $qualifiedName, $doctype) = @_;

{

if 
(CORE::defined $namespaceURI and CORE::length $namespaceURI == 0) {
  
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, '-type' => 'http://suika.fam.cx/~wakaba/archive/2004/dom/main#empty-namespace-uri', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:tag:suika.fam.cx,2005-09:1155900988:15957:sNawY14855+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;

  

{


$namespaceURI = undef;
  


}

;
}


}
my $r;

{

require 
Message::DOM::Document;

my $bag = 
$self->{'b'}
;
my $stem;


{


$stem = 'Message::DOM::Document::ManakaiDOMDocument'->___create_node_stem ($bag, {
  
'rc'
 => 0,
  
'id'
 => \
(
  'tag:suika.fam.cx,2005-09:' . time . ':' . $$ . ':' .
  (++$Message::Util::ManakaiNode::UniqueIDN)
)
,
}, {
    'impl' => $self,
  });


{

if 
(defined 'Message::DOM::Document::ManakaiDOMDocument') {
  if (ref 'Message::DOM::Document::ManakaiDOMDocument' eq 'SCALAR') {
    $stem->{'cls'} = 'Message::DOM::Document::ManakaiDOMDocument';
  } elsif (defined $Message::Util::ManakaiStringRef::Value{'Message::DOM::Document::ManakaiDOMDocument'}) {
    $stem->{'cls'} = $Message::Util::ManakaiStringRef::Value{'Message::DOM::Document::ManakaiDOMDocument'};
  } else {
    require Scalar::Util;
    $stem->{'cls'} = $Message::Util::ManakaiStringRef::Value{'Message::DOM::Document::ManakaiDOMDocument'} = \('Message::DOM::Document::ManakaiDOMDocument');
    Scalar::Util::weaken ($Message::Util::ManakaiStringRef::Value{'Message::DOM::Document::ManakaiDOMDocument'});
  }
} else {
  CORE::delete $stem->{'cls'};
}


}

;
$bag->{${$stem->{
'id'
}}} = $stem;


}

;


{


$r = ${$stem->{
'cls'
}}->___create_node_ref ({
  
'id'
 => $stem->{
'id'
},
  
'b'
 => $bag,
}, {
  });
$stem->{
'rc'
}++;


}

;

if (defined $doctype) {
  

{

local $Error::Depth = $Error::Depth + 1;

{



    $r->
append_child
 ($doctype);
  


}


;}

;
}

if (defined $qualifiedName) {
  

{

local $Error::Depth = $Error::Depth + 1;

{


    my 
$el = $r->
create_element_ns

                   ($namespaceURI, $qualifiedName);
    $r->
append_child
 ($el);
    $r = $el->
owner_document
;
           ## Choose the class based on document element type
  


}


;}

;
} elsif (defined $namespaceURI) {
  
report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'NAMESPACE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'create_document', 'http://www.w3.org/2001/04/infoset#namespaceURI' => $namespaceURI, 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#MDOM_NS_NULL_QNAME_WITH_NON_NULL_URI', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMImplementationTC', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#param-name' => 'namespaceURI';

;
}


}
$r}
sub create_document_type ($$;$$) {
my ($self, $qualifiedName, $publicId, $systemId) = @_;
my $r;

{


## Validate |qualifiedName| - don't use |InputProcessor|
## since it refers |strictErrorChecking| attribute.
unless (
($qualifiedName =~ /\A\p{InXML_NameStartChar10}\p{InXMLNameChar10}*\z/)
) {
  
report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'INVALID_CHARACTER_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'create_document_type', 'http://www.w3.org/2001/04/infoset#name' => $qualifiedName, 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#MDOM_BAD_NAME', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMImplementationTC', 'http://www.w3.org/2001/04/infoset#version' => '1.0', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#param-name' => 'qualifiedName';

;
}
unless (
($qualifiedName =~ /\A\p{InXML_NCNameStartChar10}\p{InXMLNCNameChar10}*(?::\p{InXML_NCNameStartChar10}\p{InXMLNCNameChar10}*)?\z/)
) {
  
report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'NAMESPACE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'create_document_type', 'http://www.w3.org/2001/04/infoset#name' => $qualifiedName, 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#MDOM_NS_MALFORMED_QNAME', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMImplementationTC', 'http://www.w3.org/2001/04/infoset#version' => '1.0', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#param-name' => 'qualifiedName';

;
}

require Message::DOM::XDoctype;
my $bag = 
$self->{'b'}
;
my $stem;


{


$stem = 'Message::DOM::XDoctype::ManakaiDOMDocumentTypeDefinition'->___create_node_stem ($bag, {
  
'rc'
 => 0,
  
'id'
 => \
(
  'tag:suika.fam.cx,2005-09:' . time . ':' . $$ . ':' .
  (++$Message::Util::ManakaiNode::UniqueIDN)
)
,
}, {
    'xname' => \$qualifiedName,
    'impl' => $self,
  });


{

if 
(defined 'Message::DOM::XDoctype::ManakaiDOMDocumentTypeDefinition') {
  if (ref 'Message::DOM::XDoctype::ManakaiDOMDocumentTypeDefinition' eq 'SCALAR') {
    $stem->{'cls'} = 'Message::DOM::XDoctype::ManakaiDOMDocumentTypeDefinition';
  } elsif (defined $Message::Util::ManakaiStringRef::Value{'Message::DOM::XDoctype::ManakaiDOMDocumentTypeDefinition'}) {
    $stem->{'cls'} = $Message::Util::ManakaiStringRef::Value{'Message::DOM::XDoctype::ManakaiDOMDocumentTypeDefinition'};
  } else {
    require Scalar::Util;
    $stem->{'cls'} = $Message::Util::ManakaiStringRef::Value{'Message::DOM::XDoctype::ManakaiDOMDocumentTypeDefinition'} = \('Message::DOM::XDoctype::ManakaiDOMDocumentTypeDefinition');
    Scalar::Util::weaken ($Message::Util::ManakaiStringRef::Value{'Message::DOM::XDoctype::ManakaiDOMDocumentTypeDefinition'});
  }
} else {
  CORE::delete $stem->{'cls'};
}


}

;
$bag->{${$stem->{
'id'
}}} = $stem;


}

;


{


$r = ${$stem->{
'cls'
}}->___create_node_ref ({
  
'id'
 => $stem->{
'id'
},
  
'b'
 => $bag,
}, {
    'nrifs' => ['Message::DOM::IFLatest::DocumentType'],
  });
$stem->{
'rc'
}++;


}

;

if (defined $publicId){ 
  $r->
public_id
 ($publicId);
}
if (defined $systemId){ 
  $r->
system_id
 ($systemId);
}
$r->
manakai_set_read_only
 (
1
, 
1
);


}
$r}
$Message::DOM::DOMFeature::ClassInfo->{q<Message::DOM::TreeCore::ManakaiDOMImplementationTC>}->{has_feature} = {};
$Message::DOM::ClassPoint{q<Message::DOM::TreeCore::ManakaiDOMImplementationTC>} = 0;
package Message::DOM::IFLatest::Node;
our $VERSION = 20061103.1721;
sub ELEMENT_NODE () {
1}
sub ATTRIBUTE_NODE () {
2}
sub TEXT_NODE () {
3}
sub CDATA_SECTION_NODE () {
4}
sub ENTITY_REFERENCE_NODE () {
5}
sub ENTITY_NODE () {
6}
sub PROCESSING_INSTRUCTION_NODE () {
7}
sub COMMENT_NODE () {
8}
sub DOCUMENT_NODE () {
9}
sub DOCUMENT_TYPE_NODE () {
10}
sub DOCUMENT_FRAGMENT_NODE () {
11}
sub NOTATION_NODE () {
12}
sub ELEMENT_TYPE_DEFINITION_NODE () {
81001}
sub ATTRIBUTE_DEFINITION_NODE () {
81002}
sub DOCUMENT_POSITION_DISCONNECTED () {
1}
sub DOCUMENT_POSITION_PRECEDING () {
2}
sub DOCUMENT_POSITION_FOLLOWING () {
4}
sub DOCUMENT_POSITION_CONTAINS () {
8}
sub DOCUMENT_POSITION_CONTAINED_BY () {
16}
sub DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC () {
32}
package Message::DOM::TreeCore::ManakaiDOMNode;
our $VERSION = 20061103.1721;
push our @ISA, 'Message::DOM::DOMFeature::ManakaiHasFeatureByGetFeature',
'Message::DOM::IF::Node',
'Message::DOM::IFLatest::Node',
'Message::DOM::IFLevel1::Node',
'Message::DOM::IFLevel2::Node',
'Message::DOM::IFLevel3::Node',
'Message::Util::Error::MUErrorTarget';
sub ___create_node_ref ($$$) {
my ($self, $obj, $opt) = @_;
my $r;

{

my 
$class;
CLS: {
  if (defined $opt->{
'nrcls'
}) {
    $class = $opt->{
'nrcls'
};
    IFCHK: {
      for (@{$opt->{
'nrifs'
} or []}) {
        last IFCHK unless $$class->isa ($_);
      }
      last CLS;
    } # IFCHK
  }
  $class = \$self;
} # CLS
$r = bless $obj, $$class;


}
$r}
sub ___create_node_stem ($$$$) {
my ($self, $bag, $obj, $opt) = @_;
my $r = {};

{


{


$obj->{'od'} = $opt->{'od'}->{
'id'
};
$bag->{${$opt->{'od'}->{
'id'
}}}
    ->{'do'}->{${$obj->{
'id'
}}}
  = $obj->{
'id'
};


}

;
$r = $obj;


}
$r}
sub DESTROY ($) {
my ($self) = @_;

{

my 
$bag = $self->{
'b'
};
my $nid = $self->{
'id'
};
my $gtstem = $bag->{$$nid};
if (--($gtstem->{
'rc'
}) < 1) {
  if (++($bag->{
'm'
})
          > (defined $Message::Util::Grove::GCLatency
               ? $Message::Util::Grove::GCLatency : 50000)) {
    

{

my 
@has_xref_group = ([]);
my @other_group = ([]);
my %done = (
'm'
 => 
1
);
TARGET: while (defined (my $target = each %{$bag})) {
  next TARGET if $done{$target};
  my $has_xref;
  my %grove;
  my %xgref;
  my @gtarget = ($target);
  GTARGET: while (defined (my $gtarget = shift @gtarget)) {
    $done{$gtarget} = 
1
;

    next GTARGET if $grove{$gtarget};
    $grove{$gtarget} = 
1
;

    my $gtstem = $bag->{$gtarget};
    my $clsprop = $Message::Util::Grove::ClassProp{
                    ${$gtstem->{
'cls'
}}
                  };
    
    $has_xref = 
1 if 
$gtstem->{
'rc'
};

    for my $key (@{$clsprop->{
'o0'
} or []}) {
      push @gtarget, ${$gtstem->{$key}} if defined $gtstem->{$key};
    }

    for my $key (@{$clsprop->{
's1h'
} or []}) {
      for (values %{$gtstem->{$key} or {}}) {
        push @gtarget, $$_;
      }
    }

    for my $key (@{$clsprop->{
's1a'
} or []}) {
      for (@{$gtstem->{$key}}) {
        push @gtarget, $$_;
      }
    }

    for my $key (@{$clsprop->{
's2hh'
} or []}) {
      for my $v (values %{$gtstem->{$key} or {}}) {
        for (values %{$v or {}}) {
          push @gtarget, $$_;
        }
      }
    }

    for my $key (@{$clsprop->{
'w0'
} or []}) {
      $xgref{${$gtstem->{$key}}} = 
1 if 
defined $gtstem->{$key};
    }
  } # GTARGET

  for my $xgref (keys %xgref) {
    CORE::delete $xgref{$xgref} if $grove{$xgref};
  }

  if ($has_xref) {
    push @{$has_xref_group[0]}, [\%grove, \%xgref];
  } else {
    push @{$other_group[0]}, [\%grove, \%xgref];
  }
} # target

my $i = 0; 
GI: {
  $has_xref_group[$i+1] = [];
  $other_group[$i+1] = [];

  OG: while (@{$other_group[$i]}) {
    my $other_group = shift @{$other_group[$i]};
    for my $has_group (@{$has_xref_group[$i]}) {
      for (keys %{$has_group->[1]}) {
        if ($other_group->[0]->{$_}) {
          push @{$has_xref_group[$i+1]}, $other_group;
          CORE::delete $has_group->[1]->{$_};
          next OG;
        }
      }
    }
    push @{$other_group[$i+1]}, $other_group;
  } # OG
  
  $i++;
  if (@{$has_xref_group[$i]}) { # changed
    redo GI;
  }
} # GI

for my $nid (map {keys %{$_->[0]}} @{$other_group[$i]}) {
  if ($bag->{$nid}->{
'beforefree'
}) {
    $bag->{$nid}->{
'beforefree'
}->($bag, \$nid);
  }
  CORE::delete $bag->{$nid};
}

$bag->{
'm'
} = 0;


}

;
  } else {
    HASREF: {
      my $clsprop = $Message::Util::Grove::ClassProp{
                      ${$gtstem->{
'cls'
}}
                    };
  
      for my $key (@{$clsprop->{
'o0'
} or []}) {
        last HASREF if defined $gtstem->{$key};
      }

      for my $key ((@{$clsprop->{
's1h'
} or []}),
                   (@{$clsprop->{
'v1h'
} or []})) {
        last HASREF if keys %{$gtstem->{$key}};
      }

      for my $key (@{$clsprop->{
's1a'
} or []}) {
        last HASREF if @{$gtstem->{$key}};
      }

      for my $key (@{$clsprop->{
's2hh'
} or []}) {
        for my $v (values %{$gtstem->{$key}}) {
          last HASREF if keys %$v;
        }
      }

      # No reference - i.e. not referenced
      if ($gtstem->{
'beforefree'
}) {
        $gtstem->{
'beforefree'
}->($bag, $nid);
      }
      CORE::delete $bag->{$$nid};
    } # HASREF
  }
}


}
}
sub ___report_error ($$) {
my ($self, $err) = @_;
my $r;

{

if 
($err->isa (
'Message::DOM::IF::DOMError'
)) {
  

{

local $Error::Depth = $Error::Depth + 1;

{


    A: 
{
      my $doc = $self->
owner_document
;
      if (not defined $doc) {
        if ($self->
node_type
 == 
9
) {
          $doc = $self;
        } else {  ## DOCUMENT_TYPE_NODE
          CORE::warn $err;
          last A;
        }
      }
      my $cfg = $doc->
dom_config
;
      my $h = $cfg->
get_parameter

                       ('error-handler');
      $r = $h->
handle_error
 ($err);
    } # A
  


}


;}

;
} else {
  $err->
throw
;
}


}
$r}
sub node_type ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r = 0;

{


;## TODO: Assertion


}
$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMNode', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'node_type';
}
}
sub local_name ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r = '';

{

my 
$v;


{


$v = $self->{
'b'
}->{${$self->{
'id'
}}}
         ->{'ln'};


}

;
$r = defined $v ? $$v : 
undef
;


}
$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMNode', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'local_name';
}
}
sub namespace_uri ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r = '';

{

my 
$v;


{


$v = $self->{
'b'
}->{${$self->{
'id'
}}}
         ->{'ns'};


}

;
$r = defined $v ? $$v : 
undef
;


}
$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMNode', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'namespace_uri';
}
}
sub prefix ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r = '';

{


$r = 
undef
;


}
$r;
} else {my ($self, $given) = @_;

{

report Message::DOM::DOMCore::ManakaiDOMError -object => $self, '-type' => 'http://suika.fam.cx/~wakaba/archive/2004/dom/tree#setting-prefix-no-effect-because-of-node', 'rdata' => $self, 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'set', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMNode', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'prefix';

;


}
}
}
sub parent_node ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r;

{


{

my 
$__v = $self->{
'b'
}->{${$self->{
'id'
}}}
              ->{'parent'};
if (defined $__v) {
  

{


$r = ${$self->{'b'}->{${$__v}}->{
'cls'
}}->___create_node_ref ({
  
'id'
 => $__v,
  
'b'
 => $self->{'b'},
}, {
  });
$self->{'b'}->{${$__v}}->{
'rc'
}++;


}

;
}


}

;


}
$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMNode', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'parent_node';
}
}
sub owner_document ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r;

{


{

my 
$__v = $self->{
'b'
}->{${$self->{
'id'
}}}
              ->{'od'};
if (defined $__v) {
  

{


$r = ${$self->{'b'}->{${$__v}}->{
'cls'
}}->___create_node_ref ({
  
'id'
 => $__v,
  
'b'
 => $self->{'b'},
}, {
  });
$self->{'b'}->{${$__v}}->{
'rc'
}++;


}

;
}


}

;


}
$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMNode', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'owner_document';
}
}
sub is_same_node ($$) {
my ($self, $other) = @_;
my $r = 0;

{

if 
(UNIVERSAL::isa ($other, 
'Message::DOM::IF::Node'
) and
    $other->isa ('HASH') and
    exists $other->{
'id'
}) {
  $r = ($other->{
'id'
}
            eq $self->{
'id'
});
}


}
$r}
sub manakai_read_only ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r = 0;

{


{


$r = $self->{
'b'
}->{${$self->{
'id'
}}}
         ->{'ro'};


}

;


}
$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMNode', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'manakai_read_only';
}
}
sub manakai_set_read_only ($$;$) {
my ($self, $newValue, $deep) = @_;

{

if 
($deep) {
  my @target = ($self);
  while (@target) {
    my $target = shift @target;

    

{


$target->{
'b'
}->{${$target->{
'id'
}}}
    ->{'ro'} = $newValue;


}

;

    push @target, @{$target->
child_nodes
};

    my $nt = $target->
node_type
;
    if ($nt == 
1
) {
      push @target, @{$target->
attributes
};
    } elsif ($nt == 
81001
) {
      push @target, @{$target->
attribute_definitions
};
    } elsif ($nt == 
10
) {
      my $targetx = $target->
get_feature

                               (
'http://suika.fam.cx/www/2006/feature/XDoctype'
, '3.0');
      push @target, @{$targetx->
element_types
};
      push @target, @{$targetx->
general_entities
};
      push @target, @{$targetx->
notations
};
    }
  }
} else { # not deep
  

{


$self->{
'b'
}->{${$self->{
'id'
}}}
    ->{'ro'} = $newValue;


}

;
}


}
}
sub child_nodes ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r;

{


{


$r = bless \\($self), 
'Message::DOM::TreeCore::ManakaiDOMChildNodeList'
;


}

;


}
$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMNode', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'child_nodes';
}
}
sub first_child ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r;

{

my 
$v;


{


$v = $self->{
'b'
}->{${$self->{
'id'
}}}
         ->{'child'};


}

;
if (defined $v and defined $v->[0]) {
  

{


$r = ${($self->{'b'})->{${$v->[0]}}->{
'cls'
}}->___create_node_ref ({
  
'id'
 => $v->[0],
  
'b'
 => ($self->{'b'}),
}, {
    });
($self->{'b'})->{${$v->[0]}}->{
'rc'
}++;


}

;
}


}
$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMNode', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'first_child';
}
}
sub last_child ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r;

{

my 
$v;


{


$v = $self->{
'b'
}->{${$self->{
'id'
}}}
         ->{'child'};


}

;
if (defined $v and defined $v->[0]) { # If 0, then there is -1
  

{


$r = ${($self->{'b'})->{${$v->[-1]}}->{
'cls'
}}->___create_node_ref ({
  
'id'
 => $v->[-1],
  
'b'
 => ($self->{'b'}),
}, {
    });
($self->{'b'})->{${$v->[-1]}}->{
'rc'
}++;


}

;
}


}
$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMNode', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'last_child';
}
}
sub previous_sibling ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r;

{


{

local $Error::Depth = $Error::Depth + 1;

{


  my 
$parent = $self->
parent_node
;
  if (defined $parent) {
    S: for my $sib (@{$parent->
child_nodes
}) {
      if ($sib eq $self) {
        last S;
      } else {
        $r = $sib;
      }
    }
  }



}


;}

;


}
$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMNode', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'previous_sibling';
}
}
sub next_sibling ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r;

{


{

local $Error::Depth = $Error::Depth + 1;

{


  my 
$parent = $self->
parent_node
;
  if (defined $parent) {
    my $next;
    S: for my $sib (@{$parent->
child_nodes
}) {
      if ($next) {
        $r = $sib;
        last S;
      } elsif ($sib eq $self) {
        $next = 
1
;
      }
    }
  }



}


;}

;


}
$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMNode', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'next_sibling';
}
}
sub append_child ($$) {
my ($self, $newChild) = @_;
my $r;

{


;## TODO: Assertion


}
$r}
sub insert_before ($$;$) {
my ($self, $newChild, $refChild) = @_;
my $r;

{


;## TODO: Assertion


}
$r}
sub replace_child ($$$) {
my ($self, $newChild, $oldChild) = @_;
my $r;

{


;## TODO: Assertion


}
$r}
sub manakai_append_text ($$) {
my ($self, $string) = @_;
my $r;

{


$r = $self;


}
$r}
sub remove_child ($$) {
my ($self, $oldChild) = @_;
my $r;

{

if 
($self->
owner_document

         ->
strict_error_checking and
    
$self->
manakai_read_only
) {
  
report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'remove_child', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#NOMOD_THIS', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMNode';

;
}


{

F: 
{
  my $i = -1;
  for my $cld (@{$self->
child_nodes
}) {
    $i++;
    if ($cld eq $oldChild) {
      my $v;
      

{


$v = $self->{
'b'
}->{${$self->{
'id'
}}}
         ->{'child'};


}

;
      splice @$v, $i, 1, ();
      

{

CORE::delete 
$oldChild->{
'b'
}->{${$oldChild->{
'id'
}}}
                 ->{'parent'};


}

;
      $r = $oldChild;
      last F;
    }
  }
  
report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'NOT_FOUND_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#NOT_CHILD_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/DOM/TreeCore/removeChildImpl+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#param-name' => 'oldChild', 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#node' => $oldChild;

;
} # F


}

;


}
$r}
sub attributes ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r;


$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMNode', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'attributes';
}
}
sub node_name ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r = '';

{


;## TODO: Assertion


}
$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMNode', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'node_name';
}
}
sub node_value ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r = '';

{


$r = 
undef
;


}
$r;
} else {my ($self, $given) = @_;

{

report Message::DOM::DOMCore::ManakaiDOMError -object => $self, '-type' => 'http://suika.fam.cx/~wakaba/archive/2004/dom/tree#setting-node-value-no-effect', 'rdata' => $self, 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'set', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMNode', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'node_value';

;


}
}
}
sub text_content ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r = '';

{


{

local $Error::Depth = $Error::Depth + 1;

{



  $r = '';
  my @target = @{$self->
child_nodes
};
  C: while (@target) {
    my $node = shift @target;
    my $nt = $node->
node_type
;
    if ($nt == 
3 or
        
$nt == 
4
) {
      $r .= $node->
data
        unless 
$node->
is_element_content_whitespace
;
    } elsif ($nt == 
1 or
             
$nt == 
5
) {
      unshift @target, @{$node->
child_nodes
};
    }
  }



}


;}

;


}
$r;
} else {my ($self, $given) = @_;

{


{


{

if 
($self->
manakai_read_only
) {
  
report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#NOMOD_THIS', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:http://suika.fam.cx/~wakaba/archive/2005/manakai/DOM/TreeCore/NodeReadOnlyError+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;
}


}

;

my @__old_children = @{$self->
child_nodes
};
for my $__old_child (@__old_children) {
  

{

CORE::delete 
$__old_child->{
'b'
}->{${$__old_child->{
'id'
}}}
                 ->{'parent'};


}

;
}

my @__new_children;
if (defined $given and length $given) {
  my $__text = $self->owner_document->
create_text_node
 ($given);
  push @__new_children, 
$__text->{'id'}
;
  

{


$__text->{
'b'
}->{${$__text->{
'id'
}}}
    ->{'parent'} = $self->{
'id'
};


}

;
}



{


$self->{
'b'
}->{${$self->{
'id'
}}}
    ->{'child'} = \@__new_children;


}

;


}

;


}
}
}
sub clone ($;$) {
my ($self, $deep) = @_;
my $r;

{


{

local $Error::Depth = $Error::Depth + 1;

{


  my 
$od = $self->
owner_document
;
  my $strict_check = $od->
strict_error_checking
;
  $od->
strict_error_checking
 (
0
);
  my $cfg = $od->
dom_config
;
  my $er_copy_asis = $cfg->
get_parameter

                             (
'http://suika.fam.cx/www/2006/dom-config/clone-entity-reference-subtree'
);
  my @udh;
  my @node = ([$self]);
  while (@node) {
    my ($node, $parent) = @{shift @node};
    my $nt = $node->
node_type
;
    my $clone;
    if ($nt == 
1
) {
      $clone = $od->
create_element_ns

                      ($node->
namespace_uri
,
                       [$node->
prefix
,
                        $node->
local_name
]);
      if ($parent) {
        $parent->
append_child
 ($clone);
      } else {
        $r = $clone;
      }
      my $attrs = $node->
attributes
;
      my $attrsMax = $attrs->
length
 - 1;
      for my $i (0..$attrsMax) {
        my $attr = $attrs->
item
 ($i);
        push @node, [$attr, $clone] if $attr->
specified
;
      }
      if ($deep) {
        push @node, map {[$_, $clone]} @{$node->
child_nodes
};
      }
    } elsif ($nt == 
3
) {
      $clone = $od->
create_text_node

                      ($node->
data
);
      if ($parent) {
        $parent->
append_child
 ($clone);
      } else {
        $r = $clone;
      }
      $clone->
is_element_content_whitespace
 (
1
)
        if $node->
is_element_content_whitespace
;
    } elsif ($nt == 
2
) {
      $clone = $od->
create_attribute_ns

                      ($node->
namespace_uri
,
                       [$node->
prefix
,
                        $node->
local_name
]);
      if ($parent) {
        $parent->
set_attribute_node_ns
 ($clone);
      } else {
        $r = $clone;
      }
      $clone->
specified
 (
1
);
      push @node, map {[$_, $clone]} @{$node->
child_nodes
};
    } elsif ($nt == 
8
) {
      $clone = $od->
create_comment

                      ($node->
data
);
      if ($parent) {
        $parent->
append_child
 ($clone);
      } else {
        $r = $clone;
      }
    } elsif ($nt == 
4
) {
      $clone = $od->
create_cdata_section

                      ($node->
data
);
      if ($parent) {
        $parent->
append_child
 ($clone);
      } else {
        $r = $clone;
      }
    } elsif ($nt == 
7
) {
      $clone = $od->
create_processing_instruction

                      ($node->
target
,
                       $node->
data
);
      if ($parent) {
        $parent->
append_child
 ($clone);
      } else {
        $r = $clone;
      }
    } elsif ($nt == 
5
) {
      $clone = $od->
create_entity_reference

                      ($node->
node_name
);
      if ($er_copy_asis) {
        $clone->
manakai_set_read_only
 (
0
);
        $clone->
text_content
 ('');
        for (@{$node->
child_nodes
}) {
          $clone->
append_child

                    ($_->
clone_node
 (
1
));
        }
        $clone->
manakai_expanded

                  ($node->
manakai_expanded
);
        $clone->
manakai_set_read_only
 (
1
, 
1
);
      } # copy asis
      if ($parent) {
        $parent->
append_child
 ($clone);
      } else {
        $r = $clone;
      }
    } elsif ($nt == 
11
) {
      $clone = $od->
create_document_fragment
;
      $r = $clone;
      push @node, map {[$_, $clone]} @{$node->
child_nodes
};
    } elsif ($nt == 
9
) {
      $od->
strict_error_checking
 ($strict_check);
      

{

local $Error::Depth = $Error::Depth - 1;

{

report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'NOT_SUPPORTED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'clone_node', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#CLONE_NODE_TYPE_NOT_SUPPORTED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMNode', 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#node' => 'node';


}


;}

;
    } elsif ($nt == 
10
) {
      $od->
strict_error_checking
 ($strict_check);
      

{

local $Error::Depth = $Error::Depth - 1;

{

report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'NOT_SUPPORTED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'clone_node', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#CLONE_NODE_TYPE_NOT_SUPPORTED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMNode', 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#node' => 'node';


}


;}

;
    } elsif ($nt == 
6
) {
      $od->
strict_error_checking
 ($strict_check);
      

{

local $Error::Depth = $Error::Depth - 1;

{

report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'NOT_SUPPORTED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'clone_node', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#CLONE_NODE_TYPE_NOT_SUPPORTED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMNode', 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#node' => 'node';


}


;}

;
    } elsif ($nt == 
12
) {
      $od->
strict_error_checking
 ($strict_check);
      

{

local $Error::Depth = $Error::Depth - 1;

{

report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'NOT_SUPPORTED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'clone_node', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#CLONE_NODE_TYPE_NOT_SUPPORTED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMNode', 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#node' => 'node';


}


;}

;
    } else {
      ## TODO: Assertion
    }

    my $udhs;
    

{


$udhs = $self->{
'b'
}->{${$self->{
'id'
}}}
         ->{'ud'};


}

;
    push @udh, [$node => $clone, $udhs] if $udhs and %$udhs;
  } # @node
  $od->
strict_error_checking
 (
1
) if $strict_check;

  ## Calling user data handlers if any
  for my $sd (@udh) {
    my $src = $sd->[0];
    my $src_ud = $sd->[2];
    for my $key (keys %{$src_ud}) {
      my $dh = $src_ud->{$key}->[1];
      if ($dh) {
        $dh->
handle

                (
1
,
                 $key, $src_ud->{$key}->[0], $src, $sd->[1]);
      }
    }
  }



}


;}

;


}
$r}
*clone_node = \&clone;
sub get_feature ($$$) {
my ($self, $feature, $version) = @_;

{


$feature = lc $feature;


}

{


$version = '' unless defined $version;


}
my $r;

{


$feature =~ s/^\+//;


{

if 
($Message::DOM::DOMFeature::ClassInfo->{ref $self}
      ->{has_feature}->{$feature}->{$version}) {
  $r = $self;
} else {
  CLASS: for my $__class (sort {
    $Message::DOM::ClassPoint{$b} <=> $Message::DOM::ClassPoint{$a}
  } grep {
    $Message::DOM::DOMFeature::ClassInfo->{'Message::DOM::TreeCore::ManakaiDOMNode'}
        ->{compat_class}->{$_}
  } keys %{$Message::DOM::DOMFeature::ClassInfo->{'Message::DOM::TreeCore::ManakaiDOMNode'}
               ->{compat_class} or {}}) {
    if ($Message::DOM::DOMFeature::ClassInfo->{$__class}
            ->{has_feature}->{$feature}->{$version}) {
      

{


$r = ${($self->{'b'})->{${($self->{'id'})}}->{
'cls'
}}->___create_node_ref ({
  
'id'
 => ($self->{'id'}),
  
'b'
 => ($self->{'b'}),
}, {
          'nrcls' => \$__class,
        });
($self->{'b'})->{${($self->{'id'})}}->{
'rc'
}++;


}

;
      last CLASS;
    }
  } # CLASS
}


}

;


}
$r}
sub get_user_data ($$) {
my ($self, $key) = @_;
my $r;

{

my 
$v;


{


$v = $self->{
'b'
}->{${$self->{
'id'
}}}
         ->{'ud'};


}

;
$r = $v->{$key}->[0];


}
$r}
sub set_user_data ($$;$$) {
my ($self, $key, $data, $handler) = @_;

{


$handler = bless $handler, 
'Message::DOM::DOMCore::ManakaiDOMUserDataHandler'
  if 
ref $handler eq 'CODE';


}
my $r;

{


{


$self->{
'b'
}->{${$self->{
'id'
}}}
    ->{'ud'} ||= {};


}

;
my $v;


{


$v = $self->{
'b'
}->{${$self->{
'id'
}}}
         ->{'ud'};


}

;
$r = $v->{$key}->[0];

if (defined $data) {
  $v->{$key} = [$data, $handler];

  if (defined $handler) {
    my $rc = sub {
      my ($bag, $nid) = @_;
      my $nh = 
{
  'id' => $nid,
  'b' => $bag,
}
;
      my $uds;
      

{


$uds = $nh->{
'b'
}->{${$nh->{
'id'
}}}
         ->{'ud'};


}

;
      for my $key (keys %$uds) {
        if (defined $uds->{$key}->[1]) {
          $uds->{$key}->[1]->($uds->{$key}->[1],
                              
3
,
                              $key, $uds->{$key}->[0]);
        }
      }
    }; # rc
    

{


$self->{
'b'
}->{${$self->{
'id'
}}}
    ->{'beforefree'} = $rc;


}

;
  }
} else {
  CORE::delete $v->{$key};
}


}
$r}
sub has_attributes ($) {
my ($self) = @_;
my $r = 0;

{

my 
$attrs;


{


$attrs = $self->{
'b'
}->{${$self->{
'id'
}}}
         ->{'attr'};


}

;
A: for (values %{$attrs or {}}) {
  if (keys %$_) {
    $r = 
1
;
    last A;
  }
}


}
$r}
sub has_child_nodes ($) {
my ($self) = @_;
my $r = 0;

{

my 
$v;


{


$v = $self->{
'b'
}->{${$self->{
'id'
}}}
         ->{'child'};


}

;
$r = (@{$v or []} > 0);


}
$r}
sub base_uri ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r = '';

{


$r = 
undef
;


}
$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMNode', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'base_uri';
}
}
sub compare_document_position ($$) {
my ($self, $other) = @_;
my $r = 0;

{


{

local $Error::Depth = $Error::Depth + 1;

{


  R: 
{
    my @acontainer = ($self);
    my @bcontainer = ($other);
    F: {
      A: while (
1
) {
        if ($acontainer[-1] eq $bcontainer[-1]) {
          last F;
        } else {
          my $ap;
          my $atype = $acontainer[-1]->
node_type
;
          if ($atype == 
2
) {
            $ap = $acontainer[-1]->
owner_element
;
          } elsif ($atype == 
6
) {
            $ap = $acontainer[-1]
                      ->
owner_document_type_definition
;
          } elsif ($atype == 
12
) {
            $ap = $acontainer[-1]
                      ->
owner_document_type_definition
;
          } elsif ($atype == 
81001
) {
            $ap = $acontainer[-1]
                      ->
owner_document_type_definition
;
          } elsif ($atype == 
81002
) {
            $ap = $acontainer[-1]
                      ->
owner_element_type_definition
;
          } else {
            $ap = $acontainer[-1]->
parent_node
;
          }
          if (defined $ap) {
            push @acontainer, $ap;
          } else {
            last A;
          }
        }
      } # A

      B: while (
1
) {
        if ($acontainer[-1] eq $bcontainer[-1]) {
          last F;
        } else {
          my $bp;
          my $btype = $bcontainer[-1]->
node_type
;
          if ($btype == 
2
) {
            $bp = $bcontainer[-1]->
owner_element
;
          } elsif ($btype == 
6
) {
            $bp = $bcontainer[-1]
                      ->
owner_document_type_definition
;
          } elsif ($btype == 
12
) {
            $bp = $bcontainer[-1]
                      ->
owner_document_type_definition
;
          } elsif ($btype == 
81001
) {
            $bp = $bcontainer[-1]
                      ->
owner_document_type_definition
;
          } elsif ($btype == 
81002
) {
            $bp = $bcontainer[-1]
                      ->
owner_element_type_definition
;
          } else {
            $bp = $bcontainer[-1]->
parent_node
;
          }
          if (defined $bp) {
            push @bcontainer, $bp;
          } else {
            last B;
          }
        }
      } # B

      ## Disconnected
      if ($bcontainer[-1]->isa (
'Message::DOM::IFLatest::Node'
)) {
        $r = 
1

           | 
32

           | ((${
$acontainer[-1]->{'id'}
} cmp
               ${
$bcontainer[-1]->{'id'}
})
                  > 0 ? 
4
                      : 

2
);
      } else {
        $r = 
1

           | 
32

           | 
4
;
        last F;
      }
      last R;
    } # F

    ## Common container found
    if (@acontainer >= 2) {
      if (@bcontainer >= 2) {
        my $acnt = $acontainer[-2]->
node_type
;
        my $bcnt = $bcontainer[-2]->
node_type
;
        if ($acnt == 
2 or
            
$acnt == 
6 or
            
$acnt == 
12 or
            
$acnt == 
81001 or
            
$acnt == 
81002
) {
          if ($acnt == $bcnt) {
            $r = 
32

               | (($acontainer[-2]->
node_name cmp
                   
$bcontainer[-2]->
node_name
)
                      > 0 ? 
4
                          : 

2
);
          } elsif ($bcnt == 
2 or
                   
$bcnt == 
6 or
                   
$bcnt == 
12 or
                   
$bcnt == 
81001 or
                   
$bcnt == 
81002
) {
            $r = (($acnt < $bcnt)
                          ? 
4
                          : 

2
);
          } else {
            ## A: Non-child and B: child
            $r = 
4
;
          }
        } elsif ($bcnt == 
2 or
                 
$bcnt == 
6 or
                 
$bcnt == 
12 or
                 
$bcnt == 
81001 or
                 
$bcnt == 
81002
) {
          ## A: Child and B: non-child
          $r = 
2
;
        } else {
          ## A and B are both children
          for my $cn (@{$acontainer[-1]->
child_nodes
}) {
            if ($cn eq $acontainer[-2]) {
              $r = 
4
;
              last R;
            } elsif ($cn eq $bcontainer[-2]) {
              $r = 
2
;
              last R;
            }
          }
          ## TODO: Assertion
        }
      } else {
        ## B contains A
        $r = 
8

           | 
2
;
      }
    } else {
      if (@bcontainer >= 2) {
        ## A contains B
        $r = 
16

           | 
4
;
      } else {
        ## A eq B
        $r = 0;
      }
    }
  } # R



}


;}

;


}
$r}
sub lookup_namespace_uri ($;$) {
my ($self, $prefix) = @_;
my $r = '';

{


{

local $Error::Depth = $Error::Depth + 1;

{



  $prefix = 
undef if 
defined $prefix and $prefix eq '';
      # implementation dependent
  my $nt = $self->
node_type
;
  if ($nt == 
1
) {
    my $el = $self;
    EL: {
      my $elns = $el->
namespace_uri
;
      if (defined $elns) {
        my $elpfx = $el->
prefix
;
        if ((not defined $prefix and not defined $elpfx) or
            (defined $prefix and defined $elpfx and $prefix eq $elpfx)) {
          $r = $elns;
          last EL;
        }
      }
      AT: for my $attr (@{$el->
attributes
}) {
        my $attrns = $attr->
namespace_uri
;
        next AT if not defined $attrns or $attrns ne 
'http://www.w3.org/2000/xmlns/'
;
        my $attrpfx = $attr->
prefix
;
        if (not defined $prefix) {
          my $attrln = $attr->
local_name
;
          if ($attrln eq 'xmlns') {
            my $attrval = $attr->
value
;
            $r = length $attrval ? $attrval : 
undef
;
            last EL;
          }
        } elsif (defined $prefix and
                 defined $attrpfx and $attrpfx eq 'xmlns') {
          my $attrln = $attr->
local_name
;
          if ($attrln eq $prefix) {
            my $attrval = $attr->
value
;
            $r = length $attrval ? $attrval : 
undef
;
            last EL;
          }
        }
      } # AT
      $el = $el->
manakai_parent_element
;
      redo EL if defined $el;
      $r = 
undef
;
    } # EL;
  } else {
    my $el = $nt == 
9

               ? $self->
document_element :
             
$nt == 
2

               ? $self->
owner_element :
             
$self->
manakai_parent_element
;
    if (defined $el) {
      $r = $el->
lookup_namespace_uri
 ($prefix);
    } else {
      $r = 
undef
;
    }
  }



}


;}

;


}
$r}
sub lookup_prefix ($;$) {
my ($self, $namespaceURI) = @_;

{

if 
(CORE::defined $namespaceURI and CORE::length $namespaceURI == 0) {
  
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, '-type' => 'http://suika.fam.cx/~wakaba/archive/2004/dom/main#empty-namespace-uri', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:tag:suika.fam.cx,2005-09:1155900988:15957:sNawY14855+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;

  

{


$namespaceURI = undef;
  


}

;
}


}
my $r = '';

{

unless 
(defined $namespaceURI) {
  $r = 
undef
;
} else {
  

{

local $Error::Depth = $Error::Depth + 1;

{


    my 
$nt = $self->
node_type
;
    if ($nt == 
1
) {
      my $el = $self;
      EL: {
        my $elns = $el->
namespace_uri
;
        if (defined $elns and $elns eq $namespaceURI) {
          my $elpfx = $el->
prefix
;
          if (defined $elpfx) {
            my $oelpfx = $self->
lookup_namespace_uri
 ($elpfx);
            if (defined $oelpfx and $oelpfx eq $elpfx) {
              $r = $elpfx;
              last EL;
            }
          }
        }
        AT: for my $attr (@{$el->
attributes
}) {
          my $attrpfx = $attr->
prefix
;
          next AT if not defined $attrpfx or $attrpfx ne 'xmlns';
          my $attrns = $attr->
namespace_uri
;
          next AT if not defined $attrns or $attrns ne 
'http://www.w3.org/2000/xmlns/'
;
          my $attrln = $attr->
local_name
;
          my $oelpfx = $self->
lookup_namespace_uri
 ($attrln);
          next AT unless defined $oelpfx;
          if ($oelpfx eq $attrln) {
            $r = $attrln;
            last EL;
          }
        }
        $el = $el->
manakai_parent_element
;
        redo EL if defined $el;
        $r = 
undef
;
      } # EL
    } else {
      my $el = $nt == 
9

                 ? $self->
document_element :
               
$nt == 
2

                 ? $self->
owner_element :
               
$self->
manakai_parent_element
;
      if (defined $el) {
        $r = $el->
lookup_prefix
 ($namespaceURI);
      } else { 
        $r = 
undef
;
      }
    }
  


}


;}

;
}


}
$r}
sub is_default_namespace ($$) {
my ($self, $namespaceURI) = @_;

{

if 
(CORE::defined $namespaceURI and CORE::length $namespaceURI == 0) {
  
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, '-type' => 'http://suika.fam.cx/~wakaba/archive/2004/dom/main#empty-namespace-uri', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:tag:suika.fam.cx,2005-09:1155900988:15957:sNawY14855+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;

  

{


$namespaceURI = undef;
  


}

;
}


}
my $r = 0;

{


{

local $Error::Depth = $Error::Depth + 1;

{


  my 
$nt = $self->
node_type
;
  if ($nt == 
1
) {
    my $el = $self;
    EL: {
      my $elpfx = $el->
prefix
;
      unless (defined $elpfx) {
        my $elns = $el->
namespace_uri
;
        if (defined $namespaceURI and defined $elns) {
          $r = ($namespaceURI eq $elns);
        } else {
          $r = not (defined $namespaceURI or defined $elns);
        }
        last EL;
      }
      my $xmlns = $el->
get_attribute_ns

                         (
'http://www.w3.org/2000/xmlns/'
, 'xmlns');
      if (defined $xmlns) {
        if (defined $namespaceURI) {
          $r = ($namespaceURI eq $xmlns);
        } else {
          $r = ($xmlns eq '');
        }
        last EL;
      }
      $el = $el->
manakai_parent_element
;
      redo EL if defined $el;
      $r = 
undef
;
    } # EL;
  } else {
    my $el = $nt == 
9

               ? $self->
document_element :
             
$nt == 
2

               ? $self->
owner_element :
             
$self->
manakai_parent_element
;
    if (defined $el) {
      $r = $el->
is_default_namespace
 ($namespaceURI);
    } else {
      $r = 
undef
;
    }
  }



}


;}

;


}
$r}
sub manakai_parent_element ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r;

{

my 
$n = $self->
parent_node
;
N: while (defined $n) {
  if ($n->
node_type
 == 
1
) {
    $r = $n;
    last N;
  } else {
    $n = $n->
parent_node
;
  }
} # N


}
$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMNode', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'manakai_parent_element';
}
}
sub normalize ($) {
my ($self) = @_;

{


{

local $Error::Depth = $Error::Depth + 1;

{


  my 
$ptext;

  ## Children
  my @remove;
  for my $cn (@{$self->
child_nodes
}) {
    if ($cn->
node_type
 == 
3
) {
      my $nv = $cn->
node_value
;
      if (length $nv) {
        if (defined $ptext) {
          $ptext->
manakai_append_text
 ($nv);
          $ptext->
is_element_content_whitespace
 (
1
) 
            if $cn->
is_element_content_whitespace and
               
$ptext->
is_element_content_whitespace
;
          push @remove, $cn;
        } else {
          $ptext = $cn;
        }
      } else {
        push @remove, $cn;
      }
    } else {
      $cn->
normalize
;
      undef $ptext;
    }
  }
  for (@remove) {
    $self->
remove_child
 ($_);
  }

  my $nt = $self->
node_type
;
  if ($nt == 
1
) {
    ## Attributes
    my $attrs = $self->
attributes
;
    for my $attr (@{$attrs}) {
      $attr->
normalize
;
    }
  } elsif ($nt == 
10
) {
    ## Element type definitions
    my $ets = $self->
element_types
;
    for my $et (@{$ets}) {
      $et->
normalize
;
    }
  } elsif ($nt == 
81001
) {
    ## Attribute definitions
    my $ats = $self->
attribute_definitions
;
    for my $at (@{$ats}) {
      $at->
normalize
;
    }
  }



}


;}

;


}
}
sub is_supported ($$;$) {
my ($self, $feature, $version) = @_;

{


$feature = lc $feature;


}

{


$version = '' unless defined $version;


}
my $r = 0;

{


{

local $Error::Depth = $Error::Depth + 1;

{



  $r = $self->
has_feature
 ($feature, $version);



}


;}

;


}
$r}
sub is_equal_node ($$) {
my ($self, $arg) = @_;
my $r = 0;

{


{

local $Error::Depth = $Error::Depth + 1;

{


  EQ: 
{
    last EQ unless UNIVERSAL::isa
                     ($arg, 
'Message::DOM::IF::Node'
);
    my $nt = $self->
node_type
;
    last EQ unless $nt == $arg->
node_type
;

    my @str_attr = qw/node_name local_name namespace_uri
                      prefix node_value/;
    push @str_attr, qw/public_id system_id internal_subset/
        if $nt == 
10
;
    for my $attr_name (@str_attr) {
      my $v1 = $self->can ($attr_name) ? $self->$attr_name : 
undef
;
      my $v2 = $arg->can ($attr_name) ? $arg->$attr_name : 
undef
;
      if (defined $v1 and defined $v2) {
        last EQ unless ''.$v1 eq ''.$v2;
      } elsif (defined $v1 or defined $v2) {
        last EQ;
      }
    }

    my @num_eq_attr = qw/child_nodes attributes/;
    push @num_eq_attr, qw/entities notations/
        if $nt == 
10
;
    push @num_eq_attr, qw/attribute_definitions/
        if $nt == 
81001
;
    push @num_eq_attr, qw/declared_type default_type allowed_tokens/
        if $nt == 
81002
;
    for my $attr_name (@num_eq_attr) {
      my $v1 = $self->can ($attr_name) ? $self->$attr_name : 
undef
;
      my $v2 = $arg->can ($attr_name) ? $arg->$attr_name : 
undef
;
      if (defined $v1 and defined $v2) {
        last EQ unless $v1 == $v2;
      } elsif (defined $v1 or defined $v2) {
        last EQ;
      }
    }

    if ($nt == 
10
) {
      my $dt1 = $self->
get_feature
 (
'http://suika.fam.cx/www/2006/feature/XDoctype'
, '3.0');
      my $dt2 = $arg->can ('get_feature')
                  ? $arg->
get_feature
 (
'http://suika.fam.cx/www/2006/feature/XDoctype'
, '3.0')
                  : 
undef
;
      if (defined $dt1 and defined $dt2) {
        last EQ unless $dt1->
element_types

                           == $dt2->
element_types
;
      } elsif (defined $dt1) {
        last EQ unless $dt1->
element_types

                           ->
length
 == 0;
      } elsif (defined $dt2) {
        last EQ unless $dt2->
element_types

                           ->
length
 == 0;
      }
    }

    $r = 
1
;
  } # EQ



}


;}

;


}
$r}
sub manakai_expanded_uri ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r = '';

{


{

local $Error::Depth = $Error::Depth + 1;

{


  my 
$ln = $self->
local_name
;
  if (defined $ln) {
    $r = $self->
namespace_uri
;
    if (defined $r) {
      $r .= $ln;
    } else {
      $r = $ln;
    }
  } else {
    $r = 
undef
;
  }



}


;}

;


}
$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMNode', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'manakai_expanded_uri';
}
}
sub manakai_language ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r = '';

{

my 
$target = $self;
L: {
  while (defined $target) {
    if ($target->
node_type
 == 
1
) {
      $r = $target->
get_attribute_ns
 (
'http://www.w3.org/XML/1998/namespace'
, 'lang');
      last L if defined $r;

      $r = $target->
get_attribute_ns
 (
undef
, 'xml:lang');
      last L if defined $r;
    }
    $target = $target->
parent_node
;
  }

  ## TODO: from ownerDocument
  ## TODO: from upper-level protocol

  $r = '';
} # L


}
$r;
} else {my ($self, $given) = @_;

{


{

local $Error::Depth = $Error::Depth + 1;

{


  if 
($self->
node_type
 == 
1
) {
    if (defined $given) {
      if ($self->
has_attribute_ns
 (
undef
, 'xml:lang')) {
        $self->
set_attribute_ns

                 (
undef
, [
undef
, 'xml:lang'], $given);
      } else {
        $self->
set_attribute_ns

                 (
'http://www.w3.org/XML/1998/namespace'
, 'xml:lang', $given);
      }
    } else {
      $self->
remove_attribute_ns
 (
'http://www.w3.org/XML/1998/namespace'
, 'lang');
      $self->
remove_attribute_ns
 (
undef
, 'xml:lang');
    }
  }



}


;}

;


}
}
}
use overload 
bool => sub () {1}, 
'eq' => 'is_same_node', 
'==' => 'is_equal_node', 
fallback => 1;
$Message::DOM::DOMFeature::ClassInfo->{q<Message::DOM::TreeCore::ManakaiDOMNode>}->{has_feature} = {'core',
{'',
'1',
'1.0',
'1',
'2.0',
'1',
'3.0',
'1'},
'xml',
{'',
'1',
'1.0',
'1',
'2.0',
'1',
'3.0',
'1'},
'xmlversion',
{'',
'1',
'1.0',
'1',
'1.1',
'1'}};
$Message::DOM::ClassPoint{q<Message::DOM::TreeCore::ManakaiDOMNode>} = 14.1;
$Message::Util::Grove::ClassProp{q<Message::DOM::TreeCore::ManakaiDOMNode>} = {};
package Message::DOM::IFLatest::NodeList;
our $VERSION = 20061103.1721;
package Message::DOM::TreeCore::ManakaiDOMChildNodeList;
our $VERSION = 20061103.1721;
push our @ISA, 'Tie::Array',
'Message::DOM::IF::NodeList',
'Message::DOM::IFLatest::NodeList',
'Message::DOM::IFLevel1::NodeList',
'Message::DOM::IFLevel2::NodeList',
'Message::DOM::IFLevel3::NodeList';
sub FETCH ($$) {
my ($self, $index) = @_;
my $r;

{

my 
$v;


{


$v = $$$self->{
'b'
}->{${$$$self->{
'id'
}}}
         ->{'child'};


}

;
if ($index >= 0 and defined $v->[$index]) {
  

{


$r = ${($$$self->{'b'})->{${$v->[$index]}}->{
'cls'
}}->___create_node_ref ({
  
'id'
 => $v->[$index],
  
'b'
 => ($$$self->{'b'}),
}, {
    });
($$$self->{'b'})->{${$v->[$index]}}->{
'rc'
}++;


}

;
}


}
$r}
*item = \&FETCH;
sub STORE ($$$) {
my ($self, $index, $value) = @_;
my $r;

{


{

local $Error::Depth = $Error::Depth + 1;

{


  my 
$current = $self->[$index];
  if ($current) {
    $r = $$$self->
replace_child
 ($value, $current);
  } else {
    $$$self->
append_child
 ($value);
  }



}


;}

;


}
$r}
sub DELETE ($$) {
my ($self, $index) = @_;
my $r;

{


{

local $Error::Depth = $Error::Depth + 1;

{


  my 
$current = $self->[$index];
  if ($current) {
    $r = $$$self->
remove_child
 ($current);
  }



}


;}

;


}
$r}
sub FETCHSIZE ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r = 0;

{

my 
$v;


{


$v = $$$self->{
'b'
}->{${$$$self->{
'id'
}}}
         ->{'child'};


}

;
$r = @$v;


}
$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMChildNodeList', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'length';
}
}
*length = \&FETCHSIZE;
sub STORESIZE ($$) {
my ($self, $count) = @_;

{


{

local $Error::Depth = $Error::Depth + 1;

{


  my 
$current_length = @$self;
  if ($current_length > $count) {
    for (my $i = $current_length - 1; $i >= $count; $i--) {
      $$$self->
remove_child
 ($self->[$i]);
    }
  }



}


;}

;


}
}
sub EXISTS ($$) {
my ($self, $index) = @_;
my $r = 0;

{

my 
$v;


{


$v = $$$self->{
'b'
}->{${$$$self->{
'id'
}}}
         ->{'child'};


}

;
$r = CORE::exists $v->[$index];


}
$r}
sub TIEARRAY ($$) {
my ($self, $nodeList) = @_;
my $r;

{


$r = $nodeList;


}
$r}
sub CLEAR ($) {
my ($self) = @_;

{


{

local $Error::Depth = $Error::Depth + 1;

{


  my 
$length = @$self;
  for (1..$length) {
    $$$self->
remove_child
 ($$$self->
first_child
);
  }



}


;}

;


}
}
sub manakai_read_only ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r = 0;

{


$r = ($$$self)->
manakai_read_only
;


}
$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMChildNodeList', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'manakai_read_only';
}
}
use overload 
bool => sub () {1}, 
'==' => sub ($$) {
my ($self, $arg) = @_;
my $r = 0;

{


{

local $Error::Depth = $Error::Depth + 1;

{


  EQ: 
{
    last EQ unless UNIVERSAL::isa ($arg, 
'Message::DOM::IFLatest::NodeList'
);

    my $length1 = $self->
length
;
    my $length2 = $arg->
length
;
    last EQ unless $length1 == $length2;

    for my $i (0..($length1-1)) {
      unless ($self->
item
 ($i)
                  == $arg->
item
 ($i)) {
        last EQ;
      }
    }

    $r = 
1
;
  } # EQ



}


;}

;


}
$r}
, 
'@{}' => sub ($) {
my ($self) = @_;
my $r = [];

{

tie 
my @list, ref $self, $self;
$r = \@list;


}
$r}
, 
fallback => 1;
$Message::DOM::DOMFeature::ClassInfo->{q<Message::DOM::TreeCore::ManakaiDOMChildNodeList>}->{has_feature} = {'core',
{'',
'1',
'1.0',
'1',
'2.0',
'1',
'3.0',
'1'}};
$Message::DOM::ClassPoint{q<Message::DOM::TreeCore::ManakaiDOMChildNodeList>} = 6;
package Message::DOM::TreeCore::ManakaiDOMGetElementsNodeList;
our $VERSION = 20061103.1721;
push our @ISA, 'Tie::Array',
'Message::DOM::IF::NodeList',
'Message::DOM::IFLatest::NodeList',
'Message::DOM::IFLevel1::NodeList',
'Message::DOM::IFLevel2::NodeList',
'Message::DOM::IFLevel3::NodeList';
sub FETCH ($$) {
my ($self, $index) = @_;
my $r;

{


{

local $Error::Depth = $Error::Depth + 1;

{


  my 
@target = @{$$self->[0]->
child_nodes
};
  my $i = -1;
  T: while (@target) {
    my $target = shift @target;
    my $nt = $target->
node_type
;
    if ($nt == 
1
) {
      if ($$self->[1]->($target)) {
        if (++$i == $index) {
          $r = $target;
          last T;
        }
      }
    }
    unshift @target, @{$target->
child_nodes
};
  } # T



}


;}

;


}
$r}
*item = \&FETCH;
sub STORE ($$$) {
my ($self, $index, $value) = @_;
my $r;

{

report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'STORE', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#NOMOD_NODELIST_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMGetElementsNodeList';

;


}
$r}
sub DELETE ($$) {
my ($self, $index) = @_;
my $r;

{

report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'DELETE', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#NOMOD_NODELIST_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMGetElementsNodeList';

;


}
$r}
sub FETCHSIZE ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r = 0;

{


{

local $Error::Depth = $Error::Depth + 1;

{


  my 
@target = @{$$self->[0]->
child_nodes
};
  $r = 0;
  T: while (@target) {
    my $target = shift @target;
    my $nt = $target->
node_type
;
    if ($nt == 
1
) {
      if ($$self->[1]->($target)) {
        $r++;
      }
    }
    unshift @target, @{$target->
child_nodes
};
  } # T



}


;}

;


}
$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMGetElementsNodeList', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'length';
}
}
*length = \&FETCHSIZE;
sub STORESIZE ($$) {
my ($self, $count) = @_;

{

report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'STORESIZE', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#NOMOD_NODELIST_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMGetElementsNodeList';

;


}
}
sub EXISTS ($$) {
my ($self, $index) = @_;
my $r = 0;

{


{

local $Error::Depth = $Error::Depth + 1;

{



  $r = (defined $self->
item
 ($index));



}


;}

;


}
$r}
sub TIEARRAY ($$) {
my ($self, $nodeList) = @_;
my $r;

{


$r = $nodeList;


}
$r}
sub CLEAR ($) {
my ($self) = @_;

{

report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'CLEAR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#NOMOD_NODELIST_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMGetElementsNodeList';

;


}
}
sub manakai_read_only ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r = 0;

{


$r = 
1
;


}
$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMGetElementsNodeList', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'manakai_read_only';
}
}
use overload 
bool => sub () {1}, 
'==' => sub ($$) {
my ($self, $arg) = @_;
my $r = 0;

{


{

local $Error::Depth = $Error::Depth + 1;

{


  EQ: 
{
    last EQ unless UNIVERSAL::isa ($arg, 
'Message::DOM::IFLatest::NodeList'
);

    my $length1 = $self->
length
;
    my $length2 = $arg->
length
;
    last EQ unless $length1 == $length2;

    for my $i (0..($length1-1)) {
      unless ($self->
item
 ($i)
                  == $arg->
item
 ($i)) {
        last EQ;
      }
    }

    $r = 
1
;
  } # EQ



}


;}

;


}
$r}
, 
'@{}' => sub ($) {
my ($self) = @_;
my $r = [];

{

tie 
my @list, ref $self, $self;
$r = \@list;


}
$r}
, 
fallback => 1;
$Message::DOM::DOMFeature::ClassInfo->{q<Message::DOM::TreeCore::ManakaiDOMGetElementsNodeList>}->{has_feature} = {'core',
{'',
'1',
'1.0',
'1',
'2.0',
'1',
'3.0',
'1'}};
$Message::DOM::ClassPoint{q<Message::DOM::TreeCore::ManakaiDOMGetElementsNodeList>} = 6;
package Message::DOM::TreeCore::ManakaiDOMEmptyNodeList;
our $VERSION = 20061103.1721;
push our @ISA, 'Message::DOM::IF::NodeList',
'Message::DOM::IFLatest::NodeList',
'Message::DOM::IFLevel1::NodeList',
'Message::DOM::IFLevel2::NodeList',
'Message::DOM::IFLevel3::NodeList';
sub FETCH ($$) {
my ($self, $index) = @_;
my $r;


$r}
*item = \&FETCH;
sub STORE ($$$) {
my ($self, $index, $value) = @_;
my $r;

{

report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'STORE', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#NOMOD_NODELIST_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMEmptyNodeList';

;


}
$r}
sub DELETE ($$) {
my ($self, $index) = @_;
my $r;

{

report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'DELETE', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#NOMOD_NODELIST_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMEmptyNodeList';

;


}
$r}
sub FETCHSIZE ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r = 0;


$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMEmptyNodeList', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'length';
}
}
*length = \&FETCHSIZE;
sub STORESIZE ($$) {
my ($self, $count) = @_;

{

report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'STORESIZE', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#NOMOD_NODELIST_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMEmptyNodeList';

;


}
}
sub EXISTS ($$) {
my ($self, $index) = @_;
my $r = 0;


$r}
sub CLEAR ($) {
my ($self) = @_;

{

report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'CLEAR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#NOMOD_NODELIST_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMEmptyNodeList';

;


}
}
sub manakai_read_only ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r = 0;

{


$r = 
1
;


}
$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMEmptyNodeList', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'manakai_read_only';
}
}
use overload 
bool => sub () {1}, 
'==' => sub ($$) {
my ($self, $arg) = @_;
my $r = 0;

{


{

local $Error::Depth = $Error::Depth + 1;

{


  EQ: 
{
    last EQ unless UNIVERSAL::isa ($arg, 
'Message::DOM::IFLatest::NodeList'
);

    my $length1 = $self->
length
;
    my $length2 = $arg->
length
;
    last EQ unless $length1 == $length2;

    for my $i (0..($length1-1)) {
      unless ($self->
item
 ($i)
                  == $arg->
item
 ($i)) {
        last EQ;
      }
    }

    $r = 
1
;
  } # EQ



}


;}

;


}
$r}
, 
'@{}' => sub ($) {
my ($self) = @_;
my $r = [];


$r}
, 
fallback => 1;
$Message::DOM::DOMFeature::ClassInfo->{q<Message::DOM::TreeCore::ManakaiDOMEmptyNodeList>}->{has_feature} = {'core',
{'',
'1',
'1.0',
'1',
'2.0',
'1',
'3.0',
'1'}};
$Message::DOM::ClassPoint{q<Message::DOM::TreeCore::ManakaiDOMEmptyNodeList>} = 6;
package Message::DOM::IFLatest::StaticNodeList;
our $VERSION = 20061103.1721;
package Message::DOM::TreeCore::ManakaiDOMStaticNodeList;
our $VERSION = 20061103.1721;
push our @ISA, 'Message::DOM::IF::NodeList',
'Message::DOM::IF::StaticNodeList',
'Message::DOM::IFLatest::NodeList',
'Message::DOM::IFLatest::StaticNodeList';
sub length ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r = 0;

{


$r = @$self;


}
$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMStaticNodeList', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'length';
}
}
sub item ($$) {
my ($self, $index) = @_;
my $r;

{


$r = $self->[$index] if $index >= 0;


}
$r}
sub manakai_read_only ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r = 0;

{


$r = 
0
;


}
$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMStaticNodeList', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'manakai_read_only';
}
}
use overload 
bool => sub () {1}, 
'==' => sub ($$) {
my ($self, $arg) = @_;
my $r = 0;

{


{

local $Error::Depth = $Error::Depth + 1;

{


  EQ: 
{
    last EQ unless UNIVERSAL::isa ($arg, 
'Message::DOM::IFLatest::NodeList'
);

    my $length1 = $self->
length
;
    my $length2 = $arg->
length
;
    last EQ unless $length1 == $length2;

    for my $i (0..($length1-1)) {
      unless ($self->
item
 ($i)
                  == $arg->
item
 ($i)) {
        last EQ;
      }
    }

    $r = 
1
;
  } # EQ



}


;}

;


}
$r}
, 
fallback => 1;
$Message::DOM::DOMFeature::ClassInfo->{q<Message::DOM::TreeCore::ManakaiDOMStaticNodeList>}->{has_feature} = {};
$Message::DOM::ClassPoint{q<Message::DOM::TreeCore::ManakaiDOMStaticNodeList>} = 0;
package Message::DOM::IFLatest::NamedNodeMap;
our $VERSION = 20061103.1721;
package Message::DOM::TreeCore::ManakaiDOMAttrMap;
our $VERSION = 20061103.1721;
push our @ISA, 'Tie::Array',
'Message::DOM::IF::NamedNodeMap',
'Message::DOM::IFLatest::NamedNodeMap',
'Message::DOM::IFLevel1::NamedNodeMap',
'Message::DOM::IFLevel2::NamedNodeMap',
'Message::DOM::IFLevel3::NamedNodeMap';
use Message::Util::Error;
sub FETCH ($$) {
my ($self, $name) = @_;
my $r;

{


{

local $Error::Depth = $Error::Depth + 1;

{



  $r = ($$$self)->
get_attribute_node
 ($name);



}


;}

;


}
$r}
*get_named_item = \&FETCH;
sub set_named_item ($$) {
my ($self, $arg) = @_;
my $r;

{


{

local $Error::Depth = $Error::Depth + 1;

{



  $r = ($$$self)->
set_attribute_node
 ($arg);



}


;}

;


}
$r}
sub remove_named_item ($$) {
my ($self, $name) = @_;
my $r;

{

my 
$el = $$$self;


{

local $Error::Depth = $Error::Depth + 1;

{


 
  $r = $el->
get_attribute_node
 ($name);



}


;}

;
unless ($r) {
  
report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'NOT_FOUND_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'remove_named_item', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#NO_NAMED_NODE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMAttrMap', 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#name' => $name, 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#param-name' => 'name';

;
}


{

local $Error::Depth = $Error::Depth + 1;

{



  $r = $el->
remove_attribute_node
 ($r);



}


;}

;


}
$r}
sub DELETE ($$) {
my ($self, $key) = @_;
my $r;

{




try {local $Error::Depth = $Error::Depth + 3;


  $r = $self->
remove_named_item
 ($key);
} catch 
Message::DOM::IFLatest::DOMException with 
{
  my $err = shift;
  unless ($err->subtype eq 
'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#NO_NAMED_NODE_ERR'
) {
    $err->throw;
  }
};


}
$r}
sub item ($$) {
my ($self, $index) = @_;
my $r;

{

FIND: 
{
  my $i = 0;
  my $attrs;
  

{


$attrs = $$$self->{
'b'
}->{${$$$self->{
'id'
}}}
         ->{'attr'};


}

;
  for my $ns (sort {$a cmp $b} keys %{$attrs}) {
    for my $ln (sort {$a cmp $b} keys %{$attrs->{$ns}}) {
      if ($i++ == $index) {
        

{


$r = ${($$$self->{'b'})->{${$attrs->{$ns}->{$ln}}}->{
'cls'
}}->___create_node_ref ({
  
'id'
 => $attrs->{$ns}->{$ln},
  
'b'
 => ($$$self->{'b'}),
}, {
          });
($$$self->{'b'})->{${$attrs->{$ns}->{$ln}}}->{
'rc'
}++;


}

;
        last FIND;
      }
    }
  }
} # FIND


}
$r}
sub FETCHSIZE ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r = 0;

{

my 
$list;


{


$list = $$$self->{
'b'
}->{${$$$self->{
'id'
}}}
         ->{'attr'};


}

;
for my $l (values %$list) {
  $r += grep {$l->{$_}} keys %$l;
}


}
$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMAttrMap', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'length';
}
}
*length = \&FETCHSIZE;
sub STORESIZE ($$) {
my ($self, $count) = @_;

{


{

local $Error::Depth = $Error::Depth + 1;

{


  my 
$length = $self->
length
;
  if ($length > $count) {
    for (my $i = $length - 1; $i >= $count; $i--) {
      my $item = $self->
item
 ($i);
      $self->
remove_named_item

               ($item->
node_name
);
    }
  }



}


;}

;


}
}
sub EXISTS ($$) {
my ($self, $key) = @_;
my $r = 0;

{


{

local $Error::Depth = $Error::Depth + 1;

{



  $r = defined ($self->
get_named_item
 ($key));



}


;}

;


}
$r}
sub FIRSTKEY ($) {
my ($self) = @_;
my $r = '';

{


{

local $Error::Depth = $Error::Depth + 1;

{


  my 
$node = $self->
item
 (0);
  $r = $node ? $node->
node_name : 

undef
;
  

{


$$$self->{
'b'
}->{${$$$self->{
'id'
}}}
    ->{'hpos'} = 1;


}

;



}


;}

;


}
$r}
sub NEXTKEY ($$) {
my ($self, $lastkey) = @_;
my $r = '';

{


{

local $Error::Depth = $Error::Depth + 1;

{


  my 
$i;
  

{


$i = $$$self->{
'b'
}->{${$$$self->{
'id'
}}}
         ->{'hpos'}++;


}

;
  my $node = $self->
item
 ($i);
  $r = $node ? $node->
node_name : 

undef
;



}


;}

;


}
$r}
sub get_named_item_ns ($$$) {
my ($self, $namespaceURI, $localName) = @_;

{

if 
(CORE::defined $namespaceURI and CORE::length $namespaceURI == 0) {
  
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, '-type' => 'http://suika.fam.cx/~wakaba/archive/2004/dom/main#empty-namespace-uri', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:tag:suika.fam.cx,2005-09:1155900988:15957:sNawY14855+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;

  

{


$namespaceURI = undef;
  


}

;
}


}
my $r;

{


{

local $Error::Depth = $Error::Depth + 1;

{



  $r = ($$$self)->
get_attribute_node_ns

                    ($namespaceURI, $localName);



}


;}

;


}
$r}
sub set_named_item_ns ($$) {
my ($self, $arg) = @_;
my $r;

{


{

local $Error::Depth = $Error::Depth + 1;

{



  $r = ($$$self)->
set_attribute_node_ns
 ($arg);



}


;}

;


}
$r}
sub remove_named_item_ns ($$$) {
my ($self, $namespaceURI, $localName) = @_;

{

if 
(CORE::defined $namespaceURI and CORE::length $namespaceURI == 0) {
  
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, '-type' => 'http://suika.fam.cx/~wakaba/archive/2004/dom/main#empty-namespace-uri', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:tag:suika.fam.cx,2005-09:1155900988:15957:sNawY14855+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;

  

{


$namespaceURI = undef;
  


}

;
}


}
my $r;

{

my 
$el = $$$self;


{

local $Error::Depth = $Error::Depth + 1;

{


 
  $r = $el->
get_attribute_node_ns

              ($namespaceURI, $localName);



}


;}

;
unless ($r) {
  
report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'NOT_FOUND_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'remove_named_item_ns', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMAttrMap', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#param-name' => 'name', 'http://www.w3.org/2001/04/infoset#localName' => $localName, 'http://www.w3.org/2001/04/infoset#namespaceName' => $namespaceURI, 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#name' => $localName, 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#NO_NAMED_NODE_NS_ERR';

;
}


{

local $Error::Depth = $Error::Depth + 1;

{



  $r = $el->
remove_attribute_node
 ($r);



}


;}

;


}
$r}
sub ___report_error ($$) {
my ($self, $err) = @_;
my $r;

{


{

local $Error::Depth = $Error::Depth + 1;

{



  $r = ($$$self)->___report_error ($err);



}


;}

;


}
$r}
sub TIEARRAY ($$) {
my ($self, $map) = @_;
my $r;

{


$r = bless \\($$$map), $self;


}
$r}
sub TIEHASH ($$) {
my ($self, $map) = @_;
my $r;

{


$r = $map;


}
$r}
sub manakai_read_only ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r = 0;

{


$r = ($$$self)->
manakai_read_only
;


}
$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMAttrMap', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'manakai_read_only';
}
}
use overload 
bool => sub () {1}, 
'%{}' => sub ($) {
my ($self) = @_;
my $r = {};

{

tie 
my %list, ref $self, $self;
$r = \%list;


}
$r}
, 
'@{}' => sub ($) {
my ($self) = @_;
my $r = [];

{

tie 
my @list, 
'Message::DOM::TreeCore::ManakaiDOMAttrMapArray'
, $self;
$r = \@list;


}
$r}
, 
'==' => sub ($$) {
my ($self, $arg) = @_;
my $r = 0;

{


{

local $Error::Depth = $Error::Depth + 1;

{


  my 
$length1 = $self->
length
;
  my $length2 = $arg->
length
;
  if ($length1 == $length2) {
    CHK: {
      for my $i (0..$length1-1) {
        my $node1 = $self->
item
 ($i);
        my $node2 = $arg->
item
 ($i);
        unless ($node1 == $node2) {
          last CHK;
        }
      }
      $r = 
1
;
    } # CHK
  }



}


;}

;


}
$r}
, 
fallback => 1;
$Message::DOM::DOMFeature::ClassInfo->{q<Message::DOM::TreeCore::ManakaiDOMAttrMap>}->{has_feature} = {'core',
{'',
'1',
'1.0',
'1',
'2.0',
'1',
'3.0',
'1'}};
$Message::DOM::ClassPoint{q<Message::DOM::TreeCore::ManakaiDOMAttrMap>} = 6;
package Message::DOM::TreeCore::ManakaiDOMElementTypeDefMap;
our $VERSION = 20061103.1721;
push our @ISA, 'Tie::Array',
'Message::DOM::IF::NamedNodeMap',
'Message::DOM::IFLatest::NamedNodeMap',
'Message::DOM::IFLevel1::NamedNodeMap',
'Message::DOM::IFLevel2::NamedNodeMap',
'Message::DOM::IFLevel3::NamedNodeMap';
use Message::Util::Error;
sub FETCH ($$) {
my ($self, $name) = @_;
my $r;

{

my 
$list;


{


{


$list = $$$self->{
'b'
}->{${$$$self->{
'id'
}}}
         ->{'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#elementTypes'};


}

;



}

;


;


;


;
if (defined $list->{$name}) {
  

{


$r = ${($$$self->{'b'})->{${$list->{$name}}}->{
'cls'
}}->___create_node_ref ({
  
'id'
 => $list->{$name},
  
'b'
 => ($$$self->{'b'}),
}, { 
    });
($$$self->{'b'})->{${$list->{$name}}}->{
'rc'
}++;


}

;
}


}
$r}
*get_named_item = \&FETCH;
sub set_named_item ($$) {
my ($self, $arg) = @_;
my $r;

{

my 
$list;
my $expected_type;


{


{


$list = $$$self->{
'b'
}->{${$$$self->{
'id'
}}}
         ->{'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#elementTypes'};


}

;
  $expected_type = 
81001
;



}

;


;


;


;
if ($$$self->
owner_document

           ->
strict_error_checking
) {
  unless ($arg->
owner_document
              eq 
$$$self->
owner_document
) {
    
report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'WRONG_DOCUMENT_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'set_named_item', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#DIFFERENT_DOCUMENT_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMElementTypeDefMap';

;
  }
  if ($$$self->
manakai_read_only
) {
    
report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'set_named_item', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#NOMOD_NAMEDNODEMAP_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMElementTypeDefMap';

;
  }
  my $owner_def;
  

{

my 
$__v = $arg->{
'b'
}->{${$arg->{
'id'
}}}
              ->{'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#ownerDefinition'};
if (defined $__v) {
  

{


$owner_def = ${$arg->{'b'}->{${$__v}}->{
'cls'
}}->___create_node_ref ({
  
'id'
 => $__v,
  
'b'
 => $arg->{'b'},
}, {
    });
$arg->{'b'}->{${$__v}}->{
'rc'
}++;


}

;
}


}

;
  if ($owner_def and not $owner_def eq $$$self) {
    
report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'INUSE_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'set_named_item', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#INUSE_DEFINITION_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMElementTypeDefMap', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#param-name' => 'arg', 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#node' => $arg;

;
    ## NOTE: If equals to owner, then replace-by-itself error.
  }
  if ($arg->
node_type
 != $expected_type) {
    
report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'HIERARCHY_REQUEST_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'set_named_item', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#HIERARCHY_BAD_TYPE', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMElementTypeDefMap', 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#nodeType' => $arg->node_type, 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#param-name' => 'arg';

;
  }
} # strictErrorChecking
SET: {
  my $name = $arg->
node_name
;
  if (defined $list->{$name}) {
    

{


$r = ${($$$self->{'b'})->{${$list->{$name}}}->{
'cls'
}}->___create_node_ref ({
  
'id'
 => $list->{$name},
  
'b'
 => ($$$self->{'b'}),
}, {
      });
($$$self->{'b'})->{${$list->{$name}}}->{
'rc'
}++;


}

;
    if ($r eq $arg) {
      
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, '-type' => 'http://suika.fam.cx/~wakaba/archive/2004/dom/tree#replace-by-itself', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'set_named_item', 'rdata' => $arg, 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMElementTypeDefMap';

;
      undef $r; # no return value
      last SET;
    }
  }
  $list->{$name} = 
$arg->{'id'}
;
  

{


$arg->{
'b'
}->{${$arg->{
'id'
}}}
    ->{'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#ownerDefinition'} = $$$self->{
'id'
};


}

;
} # SET


}
$r}
sub remove_named_item ($$) {
my ($self, $name) = @_;
my $r;

{

my 
$list;
my $ifs;


{


{


$list = $$$self->{
'b'
}->{${$$$self->{
'id'
}}}
         ->{'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#elementTypes'};


}

;
  $ifs = [
'Message::DOM::IFLatest::ElementTypeDefinition'
];



}

;


;


;


;
if ($$$self->
owner_document

           ->
strict_error_checking
) {
  if ($$$self->
manakai_read_only
) {
    
report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'remove_named_item', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#NOMOD_NAMEDNODEMAP_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMElementTypeDefMap';

;
  }
} # strictErrorChecking

if (defined $list->{$name}) {
  

{


$r = ${($$$self->{'b'})->{${$list->{$name}}}->{
'cls'
}}->___create_node_ref ({
  
'id'
 => $list->{$name},
  
'b'
 => ($$$self->{'b'}),
}, {
    });
($$$self->{'b'})->{${$list->{$name}}}->{
'rc'
}++;


}

;
  

{

CORE::delete 
$r->{
'b'
}->{${$r->{
'id'
}}}
                 ->{'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#ownerDefinition'};


}

;
  CORE::delete $list->{$name};
} else {
  
report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'NOT_FOUND_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'remove_named_item', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#NO_NAMED_NODE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMElementTypeDefMap', 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#name' => $name, 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#param-name' => 'name';

;
}


}
$r}
sub DELETE ($$) {
my ($self, $key) = @_;
my $r;

{




try {local $Error::Depth = $Error::Depth + 3;


  $r = $self->
remove_named_item
 ($key);
} catch 
Message::DOM::IFLatest::DOMException with 
{
  my $err = shift;
  unless ($err->subtype eq 
'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#NO_NAMED_NODE_ERR'
) {
    $err->throw;
  }
};


}
$r}
sub item ($$) {
my ($self, $index) = @_;
my $r;

{

my 
$list;
my $ifs;


{


{


$list = $$$self->{
'b'
}->{${$$$self->{
'id'
}}}
         ->{'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#elementTypes'};


}

;



}

;


;


;


;
my $key = $index >= 0 ? [sort {$a cmp $b} keys %$list]->[$index]
                      : 
undef
;
if (defined $key and defined $list->{$key}) {
  

{


$r = ${($$$self->{'b'})->{${$list->{$key}}}->{
'cls'
}}->___create_node_ref ({
  
'id'
 => $list->{$key},
  
'b'
 => ($$$self->{'b'}),
}, {
    });
($$$self->{'b'})->{${$list->{$key}}}->{
'rc'
}++;


}

;
}


}
$r}
sub FETCHSIZE ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r = 0;

{

my 
$list;


{


$list = $$$self->{
'b'
}->{${$$$self->{
'id'
}}}
         ->{'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#elementTypes'};


}

;
$r = @{[map {$_} values %$list]};


}
$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMElementTypeDefMap', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'length';
}
}
*length = \&FETCHSIZE;
sub STORESIZE ($$) {
my ($self, $count) = @_;

{


{

local $Error::Depth = $Error::Depth + 1;

{


  my 
$length = $self->
length
;
  if ($length > $count) {
    for (my $i = $length - 1; $i >= $count; $i--) {
      my $item = $self->
item
 ($i);
      $self->
remove_named_item

               ($item->
node_name
);
    }
  }



}


;}

;


}
}
sub EXISTS ($$) {
my ($self, $key) = @_;
my $r = 0;

{

my 
$list;


{


$list = $$$self->{
'b'
}->{${$$$self->{
'id'
}}}
         ->{'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#elementTypes'};


}

;
$r = exists $list->{$key};


}
$r}
sub FIRSTKEY ($) {
my ($self) = @_;
my $r = '';

{

my 
$list;


{


$list = $$$self->{
'b'
}->{${$$$self->{
'id'
}}}
         ->{'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#elementTypes'};


}

;
my $a = keys %$list; # reset
$r = each %$list;


}
$r}
sub NEXTKEY ($$) {
my ($self, $lastkey) = @_;
my $r = '';

{

my 
$list;


{


$list = $$$self->{
'b'
}->{${$$$self->{
'id'
}}}
         ->{'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#elementTypes'};


}

;
$r = each %$list;


}
$r}
sub SCALAR ($) {
my ($self) = @_;
my $r = '';

{

my 
$list;


{


$list = $$$self->{
'b'
}->{${$$$self->{
'id'
}}}
         ->{'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#elementTypes'};


}

;
$r = scalar %$list;


}
$r}
sub get_named_item_ns ($$$) {
my ($self, $namespaceURI, $localName) = @_;

{

if 
(CORE::defined $namespaceURI and CORE::length $namespaceURI == 0) {
  
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, '-type' => 'http://suika.fam.cx/~wakaba/archive/2004/dom/main#empty-namespace-uri', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:tag:suika.fam.cx,2005-09:1155900988:15957:sNawY14855+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;

  

{


$namespaceURI = undef;
  


}

;
}


}
my $r;


$r}
sub set_named_item_ns ($$) {
my ($self, $arg) = @_;
my $r;

{

report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'NAMESPACE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'set_named_item_ns', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#NO_NS_NAMEDNODEMAP_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMElementTypeDefMap';

;


}
$r}
sub remove_named_item_ns ($$$) {
my ($self, $namespaceURI, $localName) = @_;

{

if 
(CORE::defined $namespaceURI and CORE::length $namespaceURI == 0) {
  
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, '-type' => 'http://suika.fam.cx/~wakaba/archive/2004/dom/main#empty-namespace-uri', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:tag:suika.fam.cx,2005-09:1155900988:15957:sNawY14855+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;

  

{


$namespaceURI = undef;
  


}

;
}


}
my $r;

{

report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'NOT_FOUND_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'remove_named_item_ns', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#NO_NAMED_NODE_NS_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMElementTypeDefMap';

;


}
$r}
sub ___report_error ($$) {
my ($self, $err) = @_;
my $r;

{


{

local $Error::Depth = $Error::Depth + 1;

{



  $r = ($$$self)->___report_error ($err);



}


;}

;


}
$r}
sub TIEARRAY ($$) {
my ($self, $map) = @_;
my $r;

{


$r = bless \\($$$map), $self;


}
$r}
sub TIEHASH ($$) {
my ($self, $map) = @_;
my $r;

{


$r = $map;


}
$r}
sub manakai_read_only ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r = 0;

{


$r = ($$$self)->
manakai_read_only
;


}
$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMElementTypeDefMap', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'manakai_read_only';
}
}
use overload 
bool => sub () {1}, 
'%{}' => sub ($) {
my ($self) = @_;
my $r = {};

{

tie 
my %list, ref $self, $self;
$r = \%list;


}
$r}
, 
'@{}' => sub ($) {
my ($self) = @_;
my $r = [];

{

tie 
my @list, 
'Message::DOM::TreeCore::ManakaiDOMElementTypeDefMapArray'
, $self;
$r = \@list;


}
$r}
, 
'==' => sub ($$) {
my ($self, $arg) = @_;
my $r = 0;

{


{

local $Error::Depth = $Error::Depth + 1;

{


  my 
$length1 = $self->
length
;
  my $length2 = $arg->
length
;
  if ($length1 == $length2) {
    CHK: {
      for my $i (0..$length1-1) {
        my $node1 = $self->
item
 ($i);
        my $node2 = $arg->
item
 ($i);
        unless ($node1 == $node2) {
          last CHK;
        }
      }
      $r = 
1
;
    } # CHK
  }



}


;}

;


}
$r}
, 
fallback => 1;
$Message::DOM::DOMFeature::ClassInfo->{q<Message::DOM::TreeCore::ManakaiDOMElementTypeDefMap>}->{has_feature} = {'core',
{'',
'1',
'1.0',
'1',
'2.0',
'1',
'3.0',
'1'},
'http://suika.fam.cx/www/2006/feature/xdoctype',
{'',
'1',
'3.0',
'1'}};
$Message::DOM::ClassPoint{q<Message::DOM::TreeCore::ManakaiDOMElementTypeDefMap>} = 9;
package Message::DOM::TreeCore::ManakaiDOMAttrDefMap;
our $VERSION = 20061103.1721;
push our @ISA, 'Tie::Array',
'Message::DOM::IF::NamedNodeMap',
'Message::DOM::IFLatest::NamedNodeMap',
'Message::DOM::IFLevel1::NamedNodeMap',
'Message::DOM::IFLevel2::NamedNodeMap',
'Message::DOM::IFLevel3::NamedNodeMap';
use Message::Util::Error;
sub FETCH ($$) {
my ($self, $name) = @_;
my $r;

{

my 
$list;


;


{


{


$list = $$$self->{
'b'
}->{${$$$self->{
'id'
}}}
         ->{'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#attributeDefinitions'};


}

;



}

;


;


;
if (defined $list->{$name}) {
  

{


$r = ${($$$self->{'b'})->{${$list->{$name}}}->{
'cls'
}}->___create_node_ref ({
  
'id'
 => $list->{$name},
  
'b'
 => ($$$self->{'b'}),
}, { 
    });
($$$self->{'b'})->{${$list->{$name}}}->{
'rc'
}++;


}

;
}


}
$r}
*get_named_item = \&FETCH;
sub set_named_item ($$) {
my ($self, $arg) = @_;
my $r;

{

my 
$list;
my $expected_type;


;


{


{


$list = $$$self->{
'b'
}->{${$$$self->{
'id'
}}}
         ->{'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#attributeDefinitions'};


}

;
  $expected_type = 
81002
;



}

;


;


;
if ($$$self->
owner_document

           ->
strict_error_checking
) {
  unless ($arg->
owner_document
              eq 
$$$self->
owner_document
) {
    
report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'WRONG_DOCUMENT_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'set_named_item', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#DIFFERENT_DOCUMENT_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMAttrDefMap';

;
  }
  if ($$$self->
manakai_read_only
) {
    
report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'set_named_item', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#NOMOD_NAMEDNODEMAP_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMAttrDefMap';

;
  }
  my $owner_def;
  

{

my 
$__v = $arg->{
'b'
}->{${$arg->{
'id'
}}}
              ->{'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#ownerDefinition'};
if (defined $__v) {
  

{


$owner_def = ${$arg->{'b'}->{${$__v}}->{
'cls'
}}->___create_node_ref ({
  
'id'
 => $__v,
  
'b'
 => $arg->{'b'},
}, {
    });
$arg->{'b'}->{${$__v}}->{
'rc'
}++;


}

;
}


}

;
  if ($owner_def and not $owner_def eq $$$self) {
    
report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'INUSE_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'set_named_item', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#INUSE_DEFINITION_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMAttrDefMap', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#param-name' => 'arg', 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#node' => $arg;

;
    ## NOTE: If equals to owner, then replace-by-itself error.
  }
  if ($arg->
node_type
 != $expected_type) {
    
report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'HIERARCHY_REQUEST_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'set_named_item', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#HIERARCHY_BAD_TYPE', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMAttrDefMap', 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#nodeType' => $arg->node_type, 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#param-name' => 'arg';

;
  }
} # strictErrorChecking
SET: {
  my $name = $arg->
node_name
;
  if (defined $list->{$name}) {
    

{


$r = ${($$$self->{'b'})->{${$list->{$name}}}->{
'cls'
}}->___create_node_ref ({
  
'id'
 => $list->{$name},
  
'b'
 => ($$$self->{'b'}),
}, {
      });
($$$self->{'b'})->{${$list->{$name}}}->{
'rc'
}++;


}

;
    if ($r eq $arg) {
      
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, '-type' => 'http://suika.fam.cx/~wakaba/archive/2004/dom/tree#replace-by-itself', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'set_named_item', 'rdata' => $arg, 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMAttrDefMap';

;
      undef $r; # no return value
      last SET;
    }
  }
  $list->{$name} = 
$arg->{'id'}
;
  

{


$arg->{
'b'
}->{${$arg->{
'id'
}}}
    ->{'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#ownerDefinition'} = $$$self->{
'id'
};


}

;
} # SET


}
$r}
sub remove_named_item ($$) {
my ($self, $name) = @_;
my $r;

{

my 
$list;
my $ifs;


;


{


{


$list = $$$self->{
'b'
}->{${$$$self->{
'id'
}}}
         ->{'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#attributeDefinitions'};


}

;
  $ifs = [
'Message::DOM::IFLatest::AttributeDefinition'
];



}

;


;


;
if ($$$self->
owner_document

           ->
strict_error_checking
) {
  if ($$$self->
manakai_read_only
) {
    
report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'remove_named_item', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#NOMOD_NAMEDNODEMAP_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMAttrDefMap';

;
  }
} # strictErrorChecking

if (defined $list->{$name}) {
  

{


$r = ${($$$self->{'b'})->{${$list->{$name}}}->{
'cls'
}}->___create_node_ref ({
  
'id'
 => $list->{$name},
  
'b'
 => ($$$self->{'b'}),
}, {
    });
($$$self->{'b'})->{${$list->{$name}}}->{
'rc'
}++;


}

;
  

{

CORE::delete 
$r->{
'b'
}->{${$r->{
'id'
}}}
                 ->{'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#ownerDefinition'};


}

;
  CORE::delete $list->{$name};
} else {
  
report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'NOT_FOUND_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'remove_named_item', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#NO_NAMED_NODE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMAttrDefMap', 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#name' => $name, 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#param-name' => 'name';

;
}


}
$r}
sub DELETE ($$) {
my ($self, $key) = @_;
my $r;

{




try {local $Error::Depth = $Error::Depth + 3;


  $r = $self->
remove_named_item
 ($key);
} catch 
Message::DOM::IFLatest::DOMException with 
{
  my $err = shift;
  unless ($err->subtype eq 
'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#NO_NAMED_NODE_ERR'
) {
    $err->throw;
  }
};


}
$r}
sub item ($$) {
my ($self, $index) = @_;
my $r;

{

my 
$list;
my $ifs;


;


{


{


$list = $$$self->{
'b'
}->{${$$$self->{
'id'
}}}
         ->{'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#attributeDefinitions'};


}

;



}

;


;


;
my $key = $index >= 0 ? [sort {$a cmp $b} keys %$list]->[$index]
                      : 
undef
;
if (defined $key and defined $list->{$key}) {
  

{


$r = ${($$$self->{'b'})->{${$list->{$key}}}->{
'cls'
}}->___create_node_ref ({
  
'id'
 => $list->{$key},
  
'b'
 => ($$$self->{'b'}),
}, {
    });
($$$self->{'b'})->{${$list->{$key}}}->{
'rc'
}++;


}

;
}


}
$r}
sub FETCHSIZE ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r = 0;

{

my 
$list;


{


$list = $$$self->{
'b'
}->{${$$$self->{
'id'
}}}
         ->{'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#attributeDefinitions'};


}

;
$r = @{[map {$_} values %$list]};


}
$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMAttrDefMap', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'length';
}
}
*length = \&FETCHSIZE;
sub STORESIZE ($$) {
my ($self, $count) = @_;

{


{

local $Error::Depth = $Error::Depth + 1;

{


  my 
$length = $self->
length
;
  if ($length > $count) {
    for (my $i = $length - 1; $i >= $count; $i--) {
      my $item = $self->
item
 ($i);
      $self->
remove_named_item

               ($item->
node_name
);
    }
  }



}


;}

;


}
}
sub EXISTS ($$) {
my ($self, $key) = @_;
my $r = 0;

{

my 
$list;


{


$list = $$$self->{
'b'
}->{${$$$self->{
'id'
}}}
         ->{'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#attributeDefinitions'};


}

;
$r = exists $list->{$key};


}
$r}
sub FIRSTKEY ($) {
my ($self) = @_;
my $r = '';

{

my 
$list;


{


$list = $$$self->{
'b'
}->{${$$$self->{
'id'
}}}
         ->{'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#attributeDefinitions'};


}

;
my $a = keys %$list; # reset
$r = each %$list;


}
$r}
sub NEXTKEY ($$) {
my ($self, $lastkey) = @_;
my $r = '';

{

my 
$list;


{


$list = $$$self->{
'b'
}->{${$$$self->{
'id'
}}}
         ->{'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#attributeDefinitions'};


}

;
$r = each %$list;


}
$r}
sub SCALAR ($) {
my ($self) = @_;
my $r = '';

{

my 
$list;


{


$list = $$$self->{
'b'
}->{${$$$self->{
'id'
}}}
         ->{'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#attributeDefinitions'};


}

;
$r = scalar %$list;


}
$r}
sub get_named_item_ns ($$$) {
my ($self, $namespaceURI, $localName) = @_;

{

if 
(CORE::defined $namespaceURI and CORE::length $namespaceURI == 0) {
  
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, '-type' => 'http://suika.fam.cx/~wakaba/archive/2004/dom/main#empty-namespace-uri', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:tag:suika.fam.cx,2005-09:1155900988:15957:sNawY14855+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;

  

{


$namespaceURI = undef;
  


}

;
}


}
my $r;


$r}
sub set_named_item_ns ($$) {
my ($self, $arg) = @_;
my $r;

{

report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'NAMESPACE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'set_named_item_ns', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#NO_NS_NAMEDNODEMAP_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMAttrDefMap';

;


}
$r}
sub remove_named_item_ns ($$$) {
my ($self, $namespaceURI, $localName) = @_;

{

if 
(CORE::defined $namespaceURI and CORE::length $namespaceURI == 0) {
  
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, '-type' => 'http://suika.fam.cx/~wakaba/archive/2004/dom/main#empty-namespace-uri', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:tag:suika.fam.cx,2005-09:1155900988:15957:sNawY14855+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;

  

{


$namespaceURI = undef;
  


}

;
}


}
my $r;

{

report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'NOT_FOUND_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'remove_named_item_ns', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#NO_NAMED_NODE_NS_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMAttrDefMap';

;


}
$r}
sub ___report_error ($$) {
my ($self, $err) = @_;
my $r;

{


{

local $Error::Depth = $Error::Depth + 1;

{



  $r = ($$$self)->___report_error ($err);



}


;}

;


}
$r}
sub TIEARRAY ($$) {
my ($self, $map) = @_;
my $r;

{


$r = bless \\($$$map), $self;


}
$r}
sub TIEHASH ($$) {
my ($self, $map) = @_;
my $r;

{


$r = $map;


}
$r}
sub manakai_read_only ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r = 0;

{


$r = ($$$self)->
manakai_read_only
;


}
$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMAttrDefMap', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'manakai_read_only';
}
}
use overload 
bool => sub () {1}, 
'%{}' => sub ($) {
my ($self) = @_;
my $r = {};

{

tie 
my %list, ref $self, $self;
$r = \%list;


}
$r}
, 
'@{}' => sub ($) {
my ($self) = @_;
my $r = [];

{

tie 
my @list, 
'Message::DOM::TreeCore::ManakaiDOMAttrDefMapArray'
, $self;
$r = \@list;


}
$r}
, 
'==' => sub ($$) {
my ($self, $arg) = @_;
my $r = 0;

{


{

local $Error::Depth = $Error::Depth + 1;

{


  my 
$length1 = $self->
length
;
  my $length2 = $arg->
length
;
  if ($length1 == $length2) {
    CHK: {
      for my $i (0..$length1-1) {
        my $node1 = $self->
item
 ($i);
        my $node2 = $arg->
item
 ($i);
        unless ($node1 == $node2) {
          last CHK;
        }
      }
      $r = 
1
;
    } # CHK
  }



}


;}

;


}
$r}
, 
fallback => 1;
$Message::DOM::DOMFeature::ClassInfo->{q<Message::DOM::TreeCore::ManakaiDOMAttrDefMap>}->{has_feature} = {'core',
{'',
'1',
'1.0',
'1',
'2.0',
'1',
'3.0',
'1'},
'http://suika.fam.cx/www/2006/feature/xdoctype',
{'',
'1',
'3.0',
'1'}};
$Message::DOM::ClassPoint{q<Message::DOM::TreeCore::ManakaiDOMAttrDefMap>} = 9;
package Message::DOM::TreeCore::ManakaiDOMEntityMap;
our $VERSION = 20061103.1721;
push our @ISA, 'Tie::Array',
'Message::DOM::IF::NamedNodeMap',
'Message::DOM::IFLatest::NamedNodeMap',
'Message::DOM::IFLevel1::NamedNodeMap',
'Message::DOM::IFLevel2::NamedNodeMap',
'Message::DOM::IFLevel3::NamedNodeMap';
use Message::Util::Error;
sub FETCH ($$) {
my ($self, $name) = @_;
my $r;

{

my 
$list;


;


;


{


{


$list = $$$self->{
'b'
}->{${$$$self->{
'id'
}}}
         ->{'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#generalEntities'};


}

;



}

;


;
if (defined $list->{$name}) {
  

{


$r = ${($$$self->{'b'})->{${$list->{$name}}}->{
'cls'
}}->___create_node_ref ({
  
'id'
 => $list->{$name},
  
'b'
 => ($$$self->{'b'}),
}, { 
    });
($$$self->{'b'})->{${$list->{$name}}}->{
'rc'
}++;


}

;
}


}
$r}
*get_named_item = \&FETCH;
sub set_named_item ($$) {
my ($self, $arg) = @_;
my $r;

{

my 
$list;
my $expected_type;


;


;


{


{


$list = $$$self->{
'b'
}->{${$$$self->{
'id'
}}}
         ->{'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#generalEntities'};


}

;
  $expected_type = 
6
;



}

;


;
if ($$$self->
owner_document

           ->
strict_error_checking
) {
  unless ($arg->
owner_document
              eq 
$$$self->
owner_document
) {
    
report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'WRONG_DOCUMENT_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'set_named_item', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#DIFFERENT_DOCUMENT_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMEntityMap';

;
  }
  if ($$$self->
manakai_read_only
) {
    
report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'set_named_item', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#NOMOD_NAMEDNODEMAP_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMEntityMap';

;
  }
  my $owner_def;
  

{

my 
$__v = $arg->{
'b'
}->{${$arg->{
'id'
}}}
              ->{'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#ownerDefinition'};
if (defined $__v) {
  

{


$owner_def = ${$arg->{'b'}->{${$__v}}->{
'cls'
}}->___create_node_ref ({
  
'id'
 => $__v,
  
'b'
 => $arg->{'b'},
}, {
    });
$arg->{'b'}->{${$__v}}->{
'rc'
}++;


}

;
}


}

;
  if ($owner_def and not $owner_def eq $$$self) {
    
report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'INUSE_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'set_named_item', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#INUSE_DEFINITION_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMEntityMap', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#param-name' => 'arg', 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#node' => $arg;

;
    ## NOTE: If equals to owner, then replace-by-itself error.
  }
  if ($arg->
node_type
 != $expected_type) {
    
report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'HIERARCHY_REQUEST_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'set_named_item', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#HIERARCHY_BAD_TYPE', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMEntityMap', 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#nodeType' => $arg->node_type, 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#param-name' => 'arg';

;
  }
} # strictErrorChecking
SET: {
  my $name = $arg->
node_name
;
  if (defined $list->{$name}) {
    

{


$r = ${($$$self->{'b'})->{${$list->{$name}}}->{
'cls'
}}->___create_node_ref ({
  
'id'
 => $list->{$name},
  
'b'
 => ($$$self->{'b'}),
}, {
      });
($$$self->{'b'})->{${$list->{$name}}}->{
'rc'
}++;


}

;
    if ($r eq $arg) {
      
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, '-type' => 'http://suika.fam.cx/~wakaba/archive/2004/dom/tree#replace-by-itself', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'set_named_item', 'rdata' => $arg, 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMEntityMap';

;
      undef $r; # no return value
      last SET;
    }
  }
  $list->{$name} = 
$arg->{'id'}
;
  

{


$arg->{
'b'
}->{${$arg->{
'id'
}}}
    ->{'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#ownerDefinition'} = $$$self->{
'id'
};


}

;
} # SET


}
$r}
sub remove_named_item ($$) {
my ($self, $name) = @_;
my $r;

{

my 
$list;
my $ifs;


;


;


{


{


$list = $$$self->{
'b'
}->{${$$$self->{
'id'
}}}
         ->{'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#generalEntities'};


}

;
  $ifs = [
'Message::DOM::IFLatest::Entity'
];



}

;


;
if ($$$self->
owner_document

           ->
strict_error_checking
) {
  if ($$$self->
manakai_read_only
) {
    
report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'remove_named_item', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#NOMOD_NAMEDNODEMAP_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMEntityMap';

;
  }
} # strictErrorChecking

if (defined $list->{$name}) {
  

{


$r = ${($$$self->{'b'})->{${$list->{$name}}}->{
'cls'
}}->___create_node_ref ({
  
'id'
 => $list->{$name},
  
'b'
 => ($$$self->{'b'}),
}, {
    });
($$$self->{'b'})->{${$list->{$name}}}->{
'rc'
}++;


}

;
  

{

CORE::delete 
$r->{
'b'
}->{${$r->{
'id'
}}}
                 ->{'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#ownerDefinition'};


}

;
  CORE::delete $list->{$name};
} else {
  
report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'NOT_FOUND_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'remove_named_item', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#NO_NAMED_NODE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMEntityMap', 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#name' => $name, 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#param-name' => 'name';

;
}


}
$r}
sub DELETE ($$) {
my ($self, $key) = @_;
my $r;

{




try {local $Error::Depth = $Error::Depth + 3;


  $r = $self->
remove_named_item
 ($key);
} catch 
Message::DOM::IFLatest::DOMException with 
{
  my $err = shift;
  unless ($err->subtype eq 
'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#NO_NAMED_NODE_ERR'
) {
    $err->throw;
  }
};


}
$r}
sub item ($$) {
my ($self, $index) = @_;
my $r;

{

my 
$list;
my $ifs;


;


;


{


{


$list = $$$self->{
'b'
}->{${$$$self->{
'id'
}}}
         ->{'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#generalEntities'};


}

;



}

;


;
my $key = $index >= 0 ? [sort {$a cmp $b} keys %$list]->[$index]
                      : 
undef
;
if (defined $key and defined $list->{$key}) {
  

{


$r = ${($$$self->{'b'})->{${$list->{$key}}}->{
'cls'
}}->___create_node_ref ({
  
'id'
 => $list->{$key},
  
'b'
 => ($$$self->{'b'}),
}, {
    });
($$$self->{'b'})->{${$list->{$key}}}->{
'rc'
}++;


}

;
}


}
$r}
sub FETCHSIZE ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r = 0;

{

my 
$list;


{


$list = $$$self->{
'b'
}->{${$$$self->{
'id'
}}}
         ->{'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#generalEntities'};


}

;
$r = @{[map {$_} values %$list]};


}
$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMEntityMap', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'length';
}
}
*length = \&FETCHSIZE;
sub STORESIZE ($$) {
my ($self, $count) = @_;

{


{

local $Error::Depth = $Error::Depth + 1;

{


  my 
$length = $self->
length
;
  if ($length > $count) {
    for (my $i = $length - 1; $i >= $count; $i--) {
      my $item = $self->
item
 ($i);
      $self->
remove_named_item

               ($item->
node_name
);
    }
  }



}


;}

;


}
}
sub EXISTS ($$) {
my ($self, $key) = @_;
my $r = 0;

{

my 
$list;


{


$list = $$$self->{
'b'
}->{${$$$self->{
'id'
}}}
         ->{'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#generalEntities'};


}

;
$r = exists $list->{$key};


}
$r}
sub FIRSTKEY ($) {
my ($self) = @_;
my $r = '';

{

my 
$list;


{


$list = $$$self->{
'b'
}->{${$$$self->{
'id'
}}}
         ->{'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#generalEntities'};


}

;
my $a = keys %$list; # reset
$r = each %$list;


}
$r}
sub NEXTKEY ($$) {
my ($self, $lastkey) = @_;
my $r = '';

{

my 
$list;


{


$list = $$$self->{
'b'
}->{${$$$self->{
'id'
}}}
         ->{'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#generalEntities'};


}

;
$r = each %$list;


}
$r}
sub SCALAR ($) {
my ($self) = @_;
my $r = '';

{

my 
$list;


{


$list = $$$self->{
'b'
}->{${$$$self->{
'id'
}}}
         ->{'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#generalEntities'};


}

;
$r = scalar %$list;


}
$r}
sub get_named_item_ns ($$$) {
my ($self, $namespaceURI, $localName) = @_;

{

if 
(CORE::defined $namespaceURI and CORE::length $namespaceURI == 0) {
  
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, '-type' => 'http://suika.fam.cx/~wakaba/archive/2004/dom/main#empty-namespace-uri', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:tag:suika.fam.cx,2005-09:1155900988:15957:sNawY14855+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;

  

{


$namespaceURI = undef;
  


}

;
}


}
my $r;


$r}
sub set_named_item_ns ($$) {
my ($self, $arg) = @_;
my $r;

{

report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'NAMESPACE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'set_named_item_ns', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#NO_NS_NAMEDNODEMAP_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMEntityMap';

;


}
$r}
sub remove_named_item_ns ($$$) {
my ($self, $namespaceURI, $localName) = @_;

{

if 
(CORE::defined $namespaceURI and CORE::length $namespaceURI == 0) {
  
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, '-type' => 'http://suika.fam.cx/~wakaba/archive/2004/dom/main#empty-namespace-uri', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:tag:suika.fam.cx,2005-09:1155900988:15957:sNawY14855+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;

  

{


$namespaceURI = undef;
  


}

;
}


}
my $r;

{

report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'NOT_FOUND_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'remove_named_item_ns', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#NO_NAMED_NODE_NS_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMEntityMap';

;


}
$r}
sub ___report_error ($$) {
my ($self, $err) = @_;
my $r;

{


{

local $Error::Depth = $Error::Depth + 1;

{



  $r = ($$$self)->___report_error ($err);



}


;}

;


}
$r}
sub TIEARRAY ($$) {
my ($self, $map) = @_;
my $r;

{


$r = bless \\($$$map), $self;


}
$r}
sub TIEHASH ($$) {
my ($self, $map) = @_;
my $r;

{


$r = $map;


}
$r}
sub manakai_read_only ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r = 0;

{


$r = ($$$self)->
manakai_read_only
;


}
$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMEntityMap', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'manakai_read_only';
}
}
use overload 
bool => sub () {1}, 
'%{}' => sub ($) {
my ($self) = @_;
my $r = {};

{

tie 
my %list, ref $self, $self;
$r = \%list;


}
$r}
, 
'@{}' => sub ($) {
my ($self) = @_;
my $r = [];

{

tie 
my @list, 
'Message::DOM::TreeCore::ManakaiDOMEntityMapArray'
, $self;
$r = \@list;


}
$r}
, 
'==' => sub ($$) {
my ($self, $arg) = @_;
my $r = 0;

{


{

local $Error::Depth = $Error::Depth + 1;

{


  my 
$length1 = $self->
length
;
  my $length2 = $arg->
length
;
  if ($length1 == $length2) {
    CHK: {
      for my $i (0..$length1-1) {
        my $node1 = $self->
item
 ($i);
        my $node2 = $arg->
item
 ($i);
        unless ($node1 == $node2) {
          last CHK;
        }
      }
      $r = 
1
;
    } # CHK
  }



}


;}

;


}
$r}
, 
fallback => 1;
$Message::DOM::DOMFeature::ClassInfo->{q<Message::DOM::TreeCore::ManakaiDOMEntityMap>}->{has_feature} = {'core',
{'',
'1',
'1.0',
'1',
'2.0',
'1',
'3.0',
'1'},
'xml',
{'',
'1',
'1.0',
'1',
'2.0',
'1',
'3.0',
'1'},
'xmlversion',
{'',
'1',
'1.0',
'1',
'1.1',
'1'}};
$Message::DOM::ClassPoint{q<Message::DOM::TreeCore::ManakaiDOMEntityMap>} = 14.1;
package Message::DOM::TreeCore::ManakaiDOMNotationMap;
our $VERSION = 20061103.1721;
push our @ISA, 'Tie::Array',
'Message::DOM::IF::NamedNodeMap',
'Message::DOM::IFLatest::NamedNodeMap',
'Message::DOM::IFLevel1::NamedNodeMap',
'Message::DOM::IFLevel2::NamedNodeMap',
'Message::DOM::IFLevel3::NamedNodeMap';
use Message::Util::Error;
sub FETCH ($$) {
my ($self, $name) = @_;
my $r;

{

my 
$list;


;


;


;


{


{


$list = $$$self->{
'b'
}->{${$$$self->{
'id'
}}}
         ->{'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#notations'};


}

;



}

;
if (defined $list->{$name}) {
  

{


$r = ${($$$self->{'b'})->{${$list->{$name}}}->{
'cls'
}}->___create_node_ref ({
  
'id'
 => $list->{$name},
  
'b'
 => ($$$self->{'b'}),
}, { 
    });
($$$self->{'b'})->{${$list->{$name}}}->{
'rc'
}++;


}

;
}


}
$r}
*get_named_item = \&FETCH;
sub set_named_item ($$) {
my ($self, $arg) = @_;
my $r;

{

my 
$list;
my $expected_type;


;


;


;


{


{


$list = $$$self->{
'b'
}->{${$$$self->{
'id'
}}}
         ->{'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#notations'};


}

;
  $expected_type = 
12
;



}

;
if ($$$self->
owner_document

           ->
strict_error_checking
) {
  unless ($arg->
owner_document
              eq 
$$$self->
owner_document
) {
    
report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'WRONG_DOCUMENT_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'set_named_item', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#DIFFERENT_DOCUMENT_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMNotationMap';

;
  }
  if ($$$self->
manakai_read_only
) {
    
report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'set_named_item', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#NOMOD_NAMEDNODEMAP_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMNotationMap';

;
  }
  my $owner_def;
  

{

my 
$__v = $arg->{
'b'
}->{${$arg->{
'id'
}}}
              ->{'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#ownerDefinition'};
if (defined $__v) {
  

{


$owner_def = ${$arg->{'b'}->{${$__v}}->{
'cls'
}}->___create_node_ref ({
  
'id'
 => $__v,
  
'b'
 => $arg->{'b'},
}, {
    });
$arg->{'b'}->{${$__v}}->{
'rc'
}++;


}

;
}


}

;
  if ($owner_def and not $owner_def eq $$$self) {
    
report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'INUSE_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'set_named_item', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#INUSE_DEFINITION_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMNotationMap', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#param-name' => 'arg', 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#node' => $arg;

;
    ## NOTE: If equals to owner, then replace-by-itself error.
  }
  if ($arg->
node_type
 != $expected_type) {
    
report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'HIERARCHY_REQUEST_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'set_named_item', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#HIERARCHY_BAD_TYPE', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMNotationMap', 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#nodeType' => $arg->node_type, 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#param-name' => 'arg';

;
  }
} # strictErrorChecking
SET: {
  my $name = $arg->
node_name
;
  if (defined $list->{$name}) {
    

{


$r = ${($$$self->{'b'})->{${$list->{$name}}}->{
'cls'
}}->___create_node_ref ({
  
'id'
 => $list->{$name},
  
'b'
 => ($$$self->{'b'}),
}, {
      });
($$$self->{'b'})->{${$list->{$name}}}->{
'rc'
}++;


}

;
    if ($r eq $arg) {
      
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, '-type' => 'http://suika.fam.cx/~wakaba/archive/2004/dom/tree#replace-by-itself', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'set_named_item', 'rdata' => $arg, 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMNotationMap';

;
      undef $r; # no return value
      last SET;
    }
  }
  $list->{$name} = 
$arg->{'id'}
;
  

{


$arg->{
'b'
}->{${$arg->{
'id'
}}}
    ->{'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#ownerDefinition'} = $$$self->{
'id'
};


}

;
} # SET


}
$r}
sub remove_named_item ($$) {
my ($self, $name) = @_;
my $r;

{

my 
$list;
my $ifs;


;


;


;


{


{


$list = $$$self->{
'b'
}->{${$$$self->{
'id'
}}}
         ->{'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#notations'};


}

;
  $ifs = [
'Message::DOM::IFLatest::Notation'
];



}

;
if ($$$self->
owner_document

           ->
strict_error_checking
) {
  if ($$$self->
manakai_read_only
) {
    
report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'remove_named_item', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#NOMOD_NAMEDNODEMAP_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMNotationMap';

;
  }
} # strictErrorChecking

if (defined $list->{$name}) {
  

{


$r = ${($$$self->{'b'})->{${$list->{$name}}}->{
'cls'
}}->___create_node_ref ({
  
'id'
 => $list->{$name},
  
'b'
 => ($$$self->{'b'}),
}, {
    });
($$$self->{'b'})->{${$list->{$name}}}->{
'rc'
}++;


}

;
  

{

CORE::delete 
$r->{
'b'
}->{${$r->{
'id'
}}}
                 ->{'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#ownerDefinition'};


}

;
  CORE::delete $list->{$name};
} else {
  
report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'NOT_FOUND_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'remove_named_item', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#NO_NAMED_NODE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMNotationMap', 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#name' => $name, 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#param-name' => 'name';

;
}


}
$r}
sub DELETE ($$) {
my ($self, $key) = @_;
my $r;

{




try {local $Error::Depth = $Error::Depth + 3;


  $r = $self->
remove_named_item
 ($key);
} catch 
Message::DOM::IFLatest::DOMException with 
{
  my $err = shift;
  unless ($err->subtype eq 
'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#NO_NAMED_NODE_ERR'
) {
    $err->throw;
  }
};


}
$r}
sub item ($$) {
my ($self, $index) = @_;
my $r;

{

my 
$list;
my $ifs;


;


;


;


{


{


$list = $$$self->{
'b'
}->{${$$$self->{
'id'
}}}
         ->{'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#notations'};


}

;



}

;
my $key = $index >= 0 ? [sort {$a cmp $b} keys %$list]->[$index]
                      : 
undef
;
if (defined $key and defined $list->{$key}) {
  

{


$r = ${($$$self->{'b'})->{${$list->{$key}}}->{
'cls'
}}->___create_node_ref ({
  
'id'
 => $list->{$key},
  
'b'
 => ($$$self->{'b'}),
}, {
    });
($$$self->{'b'})->{${$list->{$key}}}->{
'rc'
}++;


}

;
}


}
$r}
sub FETCHSIZE ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r = 0;

{

my 
$list;


{


$list = $$$self->{
'b'
}->{${$$$self->{
'id'
}}}
         ->{'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#notations'};


}

;
$r = @{[map {$_} values %$list]};


}
$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMNotationMap', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'length';
}
}
*length = \&FETCHSIZE;
sub STORESIZE ($$) {
my ($self, $count) = @_;

{


{

local $Error::Depth = $Error::Depth + 1;

{


  my 
$length = $self->
length
;
  if ($length > $count) {
    for (my $i = $length - 1; $i >= $count; $i--) {
      my $item = $self->
item
 ($i);
      $self->
remove_named_item

               ($item->
node_name
);
    }
  }



}


;}

;


}
}
sub EXISTS ($$) {
my ($self, $key) = @_;
my $r = 0;

{

my 
$list;


{


$list = $$$self->{
'b'
}->{${$$$self->{
'id'
}}}
         ->{'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#notations'};


}

;
$r = exists $list->{$key};


}
$r}
sub FIRSTKEY ($) {
my ($self) = @_;
my $r = '';

{

my 
$list;


{


$list = $$$self->{
'b'
}->{${$$$self->{
'id'
}}}
         ->{'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#notations'};


}

;
my $a = keys %$list; # reset
$r = each %$list;


}
$r}
sub NEXTKEY ($$) {
my ($self, $lastkey) = @_;
my $r = '';

{

my 
$list;


{


$list = $$$self->{
'b'
}->{${$$$self->{
'id'
}}}
         ->{'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#notations'};


}

;
$r = each %$list;


}
$r}
sub SCALAR ($) {
my ($self) = @_;
my $r = '';

{

my 
$list;


{


$list = $$$self->{
'b'
}->{${$$$self->{
'id'
}}}
         ->{'http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#notations'};


}

;
$r = scalar %$list;


}
$r}
sub get_named_item_ns ($$$) {
my ($self, $namespaceURI, $localName) = @_;

{

if 
(CORE::defined $namespaceURI and CORE::length $namespaceURI == 0) {
  
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, '-type' => 'http://suika.fam.cx/~wakaba/archive/2004/dom/main#empty-namespace-uri', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:tag:suika.fam.cx,2005-09:1155900988:15957:sNawY14855+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;

  

{


$namespaceURI = undef;
  


}

;
}


}
my $r;


$r}
sub set_named_item_ns ($$) {
my ($self, $arg) = @_;
my $r;

{

report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'NAMESPACE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'set_named_item_ns', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#NO_NS_NAMEDNODEMAP_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMNotationMap';

;


}
$r}
sub remove_named_item_ns ($$$) {
my ($self, $namespaceURI, $localName) = @_;

{

if 
(CORE::defined $namespaceURI and CORE::length $namespaceURI == 0) {
  
report Message::DOM::DOMCore::ManakaiDOMError -object => $self, '-type' => 'http://suika.fam.cx/~wakaba/archive/2004/dom/main#empty-namespace-uri', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#resourceURI' => 'tag:suika.fam.cx,2005-09:tag:suika.fam.cx,2005-09:1155900988:15957:sNawY14855+http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom%23ManakaiDOMLatest';

;

  

{


$namespaceURI = undef;
  


}

;
}


}
my $r;

{

report Message::DOM::DOMCore::ManakaiDOMException -object => $self, '-type' => 'NOT_FOUND_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#method' => 'remove_named_item_ns', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#NO_NAMED_NODE_NS_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMNotationMap';

;


}
$r}
sub ___report_error ($$) {
my ($self, $err) = @_;
my $r;

{


{

local $Error::Depth = $Error::Depth + 1;

{



  $r = ($$$self)->___report_error ($err);



}


;}

;


}
$r}
sub TIEARRAY ($$) {
my ($self, $map) = @_;
my $r;

{


$r = bless \\($$$map), $self;


}
$r}
sub TIEHASH ($$) {
my ($self, $map) = @_;
my $r;

{


$r = $map;


}
$r}
sub manakai_read_only ($;$) {
if (@_ == 1) {my ($self) = @_;
my $r = 0;

{


$r = ($$$self)->
manakai_read_only
;


}
$r;
} else {my ($self) = @_;
report Message::Util::Error::DOMException::CoreException -object => $self, '-type' => 'NO_MODIFICATION_ALLOWED_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#on' => 'get', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#subtype' => 'http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#READ_ONLY_ATTRIBUTE_ERR', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#class' => 'Message::DOM::TreeCore::ManakaiDOMNotationMap', 'http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#attr' => 'manakai_read_only';
}
}
use overload 
bool => sub () {1}, 
'%{}' => sub ($) {
my ($self) = @_;
my $r = {};

{

tie 
my %list, ref $self, $self;
$r = \%list;


}
$r}
, 
'@{}' => sub ($) {
my ($self) = @_;
my $r = [];

{

tie 
my @list, 
'Message::DOM::TreeCore::ManakaiDOMNotationMapArray'
, $self;
$r = \@list;


}
$r}
, 
'==' => sub ($$) {
my ($self, $arg) = @_;
my $r = 0;

{


{

local $Error::Depth = $Error::Depth + 1;

{


  my 
$length1 = $self->
length
;
  my $length2 = $arg->
length
;
  if ($length1 == $length2) {
    CHK: {
      for my $i (0..$length1-1) {
        my $node1 = $self->
item
 ($i);
        my $node2 = $arg->
item
 ($i);
        unless ($node1 == $node2) {
          last CHK;
        }
      }
      $r = 
1
;
    } # CHK
  }



}


;}

;


}
$r}
, 
fallback => 1;
$Message::DOM::DOMFeature::ClassInfo->{q<Message::DOM::TreeCore::ManakaiDOMNotationMap>}->{has_feature} = {'core',
{'',
'1',
'1.0',
'1',
'2.0',
'1',
'3.0',
'1'},
'xml',
{'',
'1',
'1.0',
'1',
'2.0',
'1',
'3.0',
'1'},
'xmlversion',
{'',
'1',
'1.0',
'1',
'1.1',
'1'}};
$Message::DOM::ClassPoint{q<Message::DOM::TreeCore::ManakaiDOMNotationMap>} = 14.1;
package Message::DOM::TreeCore::ManakaiDOMAttrMapArray;
our $VERSION = 20061103.1721;
push our @ISA, 'Message::DOM::TreeCore::ManakaiDOMAttrMap',
'Tie::Array';
sub FETCH ($$) {
my ($self, $index) = @_;
my $r;

{


{

local $Error::Depth = $Error::Depth + 1;

{



  $r = $self->
item
 ($index);



}


;}

;


}
$r}
sub EXISTS ($$) {
my ($self, $index) = @_;
my $r = 0;

{


{

local $Error::Depth = $Error::Depth + 1;

{


  my 
$length = $self->
length
;
  $r = ($index < $length);



}


;}

;


}
$r}
sub DELETE ($$) {
my ($self, $index) = @_;
my $r;

{


{

local $Error::Depth = $Error::Depth + 1;

{


  my 
$item = $self->
item
 ($index);
  if ($item) {
    $r = $self->
remove_named_item

                    ($item->
node_name
);
  }



}


;}

;


}
$r}
$Message::DOM::DOMFeature::ClassInfo->{q<Message::DOM::TreeCore::ManakaiDOMAttrMapArray>}->{has_feature} = {'core',
{'',
'1',
'1.0',
'1',
'2.0',
'1',
'3.0',
'1'}};
$Message::DOM::ClassPoint{q<Message::DOM::TreeCore::ManakaiDOMAttrMapArray>} = 6;
package Message::DOM::TreeCore::ManakaiDOMElementTypeDefMapArray;
our $VERSION = 20061103.1721;
push our @ISA, 'Message::DOM::TreeCore::ManakaiDOMElementTypeDefMap',
'Tie::Array';
sub FETCH ($$) {
my ($self, $index) = @_;
my $r;

{


{

local $Error::Depth = $Error::Depth + 1;

{



  $r = $self->
item
 ($index);



}


;}

;


}
$r}
sub EXISTS ($$) {
my ($self, $index) = @_;
my $r = 0;

{


{

local $Error::Depth = $Error::Depth + 1;

{


  my 
$length = $self->
length
;
  $r = ($index < $length);



}


;}

;


}
$r}
sub DELETE ($$) {
my ($self, $index) = @_;
my $r;

{


{

local $Error::Depth = $Error::Depth + 1;

{


  my 
$item = $self->
item
 ($index);
  if ($item) {
    $r = $self->
remove_named_item

                    ($item->
node_name
);
  }



}


;}

;


}
$r}
$Message::DOM::DOMFeature::ClassInfo->{q<Message::DOM::TreeCore::ManakaiDOMElementTypeDefMapArray>}->{has_feature} = {'core',
{'',
'1',
'1.0',
'1',
'2.0',
'1',
'3.0',
'1'},
'http://suika.fam.cx/www/2006/feature/xdoctype',
{'',
'1',
'3.0',
'1'}};
$Message::DOM::ClassPoint{q<Message::DOM::TreeCore::ManakaiDOMElementTypeDefMapArray>} = 9;
package Message::DOM::TreeCore::ManakaiDOMAttrDefMapArray;
our $VERSION = 20061103.1721;
push our @ISA, 'Message::DOM::TreeCore::ManakaiDOMAttrDefMap',
'Tie::Array';
sub FETCH ($$) {
my ($self, $index) = @_;
my $r;

{


{

local $Error::Depth = $Error::Depth + 1;

{



  $r = $self->
item
 ($index);



}


;}

;


}
$r}
sub EXISTS ($$) {
my ($self, $index) = @_;
my $r = 0;

{


{

local $Error::Depth = $Error::Depth + 1;

{


  my 
$length = $self->
length
;
  $r = ($index < $length);



}


;}

;


}
$r}
sub DELETE ($$) {
my ($self, $index) = @_;
my $r;

{


{

local $Error::Depth = $Error::Depth + 1;

{


  my 
$item = $self->
item
 ($index);
  if ($item) {
    $r = $self->
remove_named_item

                    ($item->
node_name
);
  }



}


;}

;


}
$r}
$Message::DOM::DOMFeature::ClassInfo->{q<Message::DOM::TreeCore::ManakaiDOMAttrDefMapArray>}->{has_feature} = {'core',
{'',
'1',
'1.0',
'1',
'2.0',
'1',
'3.0',
'1'},
'http://suika.fam.cx/www/2006/feature/xdoctype',
{'',
'1',
'3.0',
'1'}};
$Message::DOM::ClassPoint{q<Message::DOM::TreeCore::ManakaiDOMAttrDefMapArray>} = 9;
package Message::DOM::TreeCore::ManakaiDOMEntityMapArray;
our $VERSION = 20061103.1721;
push our @ISA, 'Message::DOM::TreeCore::ManakaiDOMEntityMap',
'Tie::Array';
sub FETCH ($$) {
my ($self, $index) = @_;
my $r;

{


{

local $Error::Depth = $Error::Depth + 1;

{



  $r = $self->
item
 ($index);



}


;}

;


}
$r}
sub EXISTS ($$) {
my ($self, $index) = @_;
my $r = 0;

{


{

local $Error::Depth = $Error::Depth + 1;

{


  my 
$length = $self->
length
;
  $r = ($index < $length);



}


;}

;


}
$r}
sub DELETE ($$) {
my ($self, $index) = @_;
my $r;

{


{

local $Error::Depth = $Error::Depth + 1;

{


  my 
$item = $self->
item
 ($index);
  if ($item) {
    $r = $self->
remove_named_item

                    ($item->
node_name
);
  }



}


;}

;


}
$r}
$Message::DOM::DOMFeature::ClassInfo->{q<Message::DOM::TreeCore::ManakaiDOMEntityMapArray>}->{has_feature} = {'core',
{'',
'1',
'1.0',
'1',
'2.0',
'1',
'3.0',
'1'},
'xml',
{'',
'1',
'1.0',
'1',
'2.0',
'1',
'3.0',
'1'},
'xmlversion',
{'',
'1',
'1.0',
'1',
'1.1',
'1'}};
$Message::DOM::ClassPoint{q<Message::DOM::TreeCore::ManakaiDOMEntityMapArray>} = 14.1;
package Message::DOM::TreeCore::ManakaiDOMNotationMapArray;
our $VERSION = 20061103.1721;
push our @ISA, 'Message::DOM::TreeCore::ManakaiDOMNotationMap',
'Tie::Array';
sub FETCH ($$) {
my ($self, $index) = @_;
my $r;

{


{

local $Error::Depth = $Error::Depth + 1;

{



  $r = $self->
item
 ($index);



}


;}

;


}
$r}
sub EXISTS ($$) {
my ($self, $index) = @_;
my $r = 0;

{


{

local $Error::Depth = $Error::Depth + 1;

{


  my 
$length = $self->
length
;
  $r = ($index < $length);



}


;}

;


}
$r}
sub DELETE ($$) {
my ($self, $index) = @_;
my $r;

{


{

local $Error::Depth = $Error::Depth + 1;

{


  my 
$item = $self->
item
 ($index);
  if ($item) {
    $r = $self->
remove_named_item

                    ($item->
node_name
);
  }



}


;}

;


}
$r}
$Message::DOM::DOMFeature::ClassInfo->{q<Message::DOM::TreeCore::ManakaiDOMNotationMapArray>}->{has_feature} = {'core',
{'',
'1',
'1.0',
'1',
'2.0',
'1',
'3.0',
'1'},
'xml',
{'',
'1',
'1.0',
'1',
'2.0',
'1',
'3.0',
'1'},
'xmlversion',
{'',
'1',
'1.0',
'1',
'1.1',
'1'}};
$Message::DOM::ClassPoint{q<Message::DOM::TreeCore::ManakaiDOMNotationMapArray>} = 14.1;
for ($Message::DOM::IF::NamedNodeMap::, $Message::DOM::IF::Node::, $Message::DOM::IF::NodeList::, $Message::DOM::IF::StaticNodeList::, $Message::DOM::IFLevel1::NamedNodeMap::, $Message::DOM::IFLevel1::Node::, $Message::DOM::IFLevel1::NodeList::, $Message::DOM::IFLevel2::NamedNodeMap::, $Message::DOM::IFLevel2::Node::, $Message::DOM::IFLevel2::NodeList::, $Message::DOM::IFLevel3::NamedNodeMap::, $Message::DOM::IFLevel3::Node::, $Message::DOM::IFLevel3::NodeList::, $Message::Util::Error::MUErrorTarget::){}
## License: <http://suika.fam.cx/~wakaba/archive/2004/8/18/license#Perl+MPL>
1;
