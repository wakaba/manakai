Module:
  @QName: MDOM|XML
  @enFN:
    DOM XML Module

  @Namespace:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/DOM/XML/

  @enDesc:
    The <DFN::Extended Interfaces> in the DOM Core specifications,
    which is also known as the <DFN::XML Module> in DOM Level 3,
    form part of the DOM Core specifications, but objects that
    expose those interfaces will never be encountered in a DOM
    implementation that deals only with HTML.

    THe interfaces found within that module are not mandatory.

  @DISCore:author: DISCore|Wakaba
  @License: license|Perl+MPL
  @Date:
    $Date: 2006/12/03 05:40:34 $

  @Require:
    @@Module:
      @@@QName: MDOM|TreeCore
      @@@WithFor: ManakaiDOM|ManakaiDOMLatest
    @@Module:
      @@@QName: MDOM|XDoctype
      @@@WithFor: ManakaiDOM|ManakaiDOMLatest
    @@Module:
      @@@WithFor: ManakaiDOM|ManakaiDOM
    @@Module:
      @@@WithFor: ManakaiDOM|ManakaiDOM1
    @@Module:
      @@@WithFor: ManakaiDOM|ManakaiDOM2
    @@Module:
      @@@WithFor: ManakaiDOM|ManakaiDOM3
    @@Module:
      @@@WithFor: ManakaiDOM|ManakaiDOMLatest
    @@Module:
      @@@QName: DISlib|DISMarkup
      @@@WithFor: ManakaiDOM|all
  @DefaultFor: ManakaiDOM|ManakaiDOMLatest

Namespace:
  @c:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#
  @cfg:
    http://suika.fam.cx/www/2006/dom-config/
  @d:
    http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#
  @dis:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#dis--
  @DISlib:
    http://suika.fam.cx/~wakaba/archive/2004/dis/
  @DOMMain:
    http://suika.fam.cx/~wakaba/archive/2004/dom/main#
  @domperl:
    http://suika.fam.cx/~wakaba/archive/2006/dom/perl/
  @dx:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#
  @f:
    http://suika.fam.cx/~wakaba/archive/2004/dom/feature#
  @fe:
    http://suika.fam.cx/www/2006/feature/
  @idl:
    http://suika.fam.cx/~wakaba/archive/2004/dis/IDL#
  @infoset:
    http://www.w3.org/2001/04/infoset#
  @kwd:
    http://suika.fam.cx/~wakaba/archive/2005/rfc2119/
  @lang:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#
  @license:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/license#
  @ManakaiDOM:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#
  @MDOM:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#ManakaiDOM.
  @MDOMX:
    http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#
  @mg:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Grove/
  @rdf:
    http://www.w3.org/1999/02/22-rdf-syntax-ns#
  @s:
    http://suika.fam.cx/~wakaba/archive/2004/dis/Markup#
  @sw010:
    urn:x-suika-fam-cx:markup:suikawiki:0:10:
  @t:
    http://suika.fam.cx/~wakaba/archive/2004/dom/tree#
  @tc:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/DOM/TreeCore/
  @tcd:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/DOM/CharacterData/
  @td:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/DOM/Document/
  @te:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/DOM/Element/
  @test:
    http://suika.fam.cx/~wakaba/archive/2004/dis/Test#
  @tx:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/DOM/XML/
  @urigen:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/URI/Generic/
  @Util:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/
  @xml:
    http://www.w3.org/XML/1998/namespace

ElementTypeBinding:
  @Name: ClsDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType:
      @@@@: dis|MultipleResource
      @@@ForCheck: !ManakaiDOM|ForIF !ManakaiDOM|ForClass
    @@resourceFor:
      @@@@: ManakaiDOM|ForClass
    @@For: ManakaiDOM|ManakaiDOMLatest

    @@DISCore:resourceType:
      @@@@: DISLang|Class
      @@@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: CODE
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISPerl|BlockCode
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: Method
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Method
    @@ForCheck: !=ManakaiDOM|ManakaiDOM

ElementTypeBinding:
  @Name: CMethod
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Method
    @@ForCheck: !=ManakaiDOM|ManakaiDOM ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: L2Method
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Method
    @@ForCheck: !=ManakaiDOM|ManakaiDOM ManakaiDOM|DOM2

ElementTypeBinding:
  @Name: L3Method
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Method
    @@ForCheck: !=ManakaiDOM|ManakaiDOM ManakaiDOM|DOM3

ElementTypeBinding:
  @Name: CL3Method
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Method
    @@ForCheck: !=ManakaiDOM|ManakaiDOM ManakaiDOM|DOM3 ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: IntMethod
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Method
    @@ForCheck:
      ManakaiDOM:ManakaiDOM !=ManakaiDOM:ManakaiDOM ManakaiDOM|ForClass
    @@ManakaiDOM:isForInternal: 1

ElementTypeBinding:
  @Name: Param
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|MethodParameter

ElementTypeBinding:
  @Name: Return
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|MethodReturn

ElementTypeBinding:
  @Name: Attr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Attribute
    @@ForCheck: !=ManakaiDOM|ManakaiDOM

ElementTypeBinding:
  @Name: CAttr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|Attribute
    @@ForCheck: !=ManakaiDOM|ManakaiDOM ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: IntAttr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Attribute
    @@ForCheck: ManakaiDOM|ForClass
    @@ManakaiDOM:isForInternal: 1

ElementTypeBinding:
  @Name: L2Attr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Attribute
    @@ForCheck: !=ManakaiDOM|ManakaiDOM ManakaiDOM|DOM2

ElementTypeBinding:
  @Name: CL2Attr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Attribute
    @@ForCheck: !=ManakaiDOM|ManakaiDOM ManakaiDOM|DOM2 ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: L3Attr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Attribute
    @@ForCheck: !=ManakaiDOM|ManakaiDOM ManakaiDOM|DOM3
  ## Note that there are attributes introduced in DOM Level 3
  ## but also defined for lower levels as internal attributes
  ## for the purpose of internal use.

ElementTypeBinding:
  @Name: CL3Attr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Attribute
    @@ForCheck: !=ManakaiDOM|ManakaiDOM ManakaiDOM|DOM3 ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: LXAttr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Attribute
    @@ForCheck: !=ManakaiDOM|ManakaiDOM ManakaiDOM|ManakaiDOMLatest

ElementTypeBinding:
  @Name: Get
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|AttributeGet

ElementTypeBinding:
  @Name: Set
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|AttributeSet

ElementTypeBinding:
  @Name: LXSet
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|AttributeSet
    @@ForCheck: ManakaiDOM|ManakaiDOMLatest

ElementTypeBinding:
  @Name: InCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:InCase

ElementTypeBinding:
  @Name: nullCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:InCase
    @@Value:
      @@@is-null:1

ElementTypeBinding:
  @Name: PerlDef
  @ElementType:
    dis:Def
  @ShadowContent:
    @@ContentType:
      lang:Perl
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: NodeReadOnlyError
  @ElementType:
    dx:raises
  @ShadowContent:
    @@@: MDOMX|NOMOD_THIS
    @@Description:
      @@@lang:en
      @@@@:
        The node is read-only.

ElementTypeBinding:
  @Name: XML2Feature
  @ElementType:
    dis:ImplNote
  @ShadowContent:
    @@ImplNote:
      @@@lang:en
      @@@@:
        The <CITE::DOM Level 2 Core> specification said that HTML-only 
        DOM Level 2 implementations does not need to implement this member. 
        The DOM Level 2 Errata withdraws it and it requires HTML-only 
        DOM implementations throw a <X::DOMException.NOT_SUPPORTED_ERR>. 

ElementTypeBinding:
  @Name: enDesc
  @ElementType:
    dis:Description
  @ShadowContent:
    @@lang:en

ElementTypeBinding:
  @Name: enImplNote
  @ElementType:
    dis:ImplNote
  @ShadowContent:
    @@lang:en

ElementTypeBinding:
  @Name: enFN
  @ElementType:
    dis:FullName
  @ShadowContent:
    @@lang:en

ElementTypeBinding:
  @Name: NodeTypeDef
  @ElementType: 
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      @@@@: dis|MultipleResource
      @@@ForCheck: !ManakaiDOM|ForIF !ManakaiDOM|ForClass
    @@resourceFor: ManakaiDOM|ForIF
    @@resourceFor:
      @@@@: ManakaiDOM|ForClass
      @@@ForCheck: ManakaiDOM|ManakaiDOMLatest
    @@For: ManakaiDOM|DOM1
    @@For: =ManakaiDOM|ManakaiDOM

    @@DISCore:resourceType:
      @@@@: DISLang|Interface
      @@@ForCheck: ManakaiDOM|ForIF

    @@DISCore:resourceType:
      @@@@: DISLang|Class
      @@@ForCheck: ManakaiDOM|ForClass

    @@ISA:
      @@@@: tc|Node
      @@@ForCheck: ManakaiDOM|ForIF
    @@ISA:
      @@@@: tc|ManakaiDOMNode
      @@@ForCheck: ManakaiDOM|ForClass

    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOM||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOM1||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM1
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOM2||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM2
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOM3||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM3
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOMLatest||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOMLatest

    @@f:implements:
      @@@@: tx|XMLFeature10
      @@@For: ManakaiDOM|DOM1
    @@f:implements:
      @@@@: tx|XMLFeature20
      @@@For: ManakaiDOM|DOM2
    @@f:implements:
      @@@@: tx|XMLFeature30
      @@@For: ManakaiDOM|DOM3
    @@f:implements:
      @@@@: tx|XMLVersionFeature10
      @@@For: ManakaiDOM|DOM3
    @@f:implements:
      @@@@: tx|XMLVersionFeature11
      @@@For: ManakaiDOM|DOM3

ElementTypeBinding:
  @Name: TrueCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType:
      ManakaiDOM:InCase
    @@Value:
      @@@@: 1
      @@@ContentType: DISCore|Boolean
    @@Type: idl|boolean||ManakaiDOM|all

ElementTypeBinding:
  @Name: FalseCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType:
      ManakaiDOM:InCase
    @@Value:
      @@@@: 0
      @@@ContentType: DISCore|Boolean
    @@Type: idl|boolean||ManakaiDOM|all

ElementTypeBinding:
  @Name: NodeTypeIFDef
  @ElementType: 
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      @@@@: dis|MultipleResource
      @@@ForCheck: !ManakaiDOM|ForIF !ManakaiDOM|ForClass
    @@resourceFor: ManakaiDOM|ForIF
    @@For: ManakaiDOM|DOM1
    @@For: =ManakaiDOM|ManakaiDOM

    @@DISCore:resourceType:
      @@@@: DISLang|Interface
      @@@ForCheck: ManakaiDOM|ForIF

    @@ISA:
      @@@@: tc|Node
      @@@ForCheck: ManakaiDOM|ForIF

    @@f:implements:
      @@@@: tx|XMLFeature10
      @@@For: ManakaiDOM|DOM1
    @@f:implements:
      @@@@: tx|XMLFeature20
      @@@For: ManakaiDOM|DOM2
    @@f:implements:
      @@@@: tx|XMLFeature30
      @@@For: ManakaiDOM|DOM3
    @@f:implements:
      @@@@: tx|XMLVersionFeature10
      @@@For: ManakaiDOM|DOM3
    @@f:implements:
      @@@@: tx|XMLVersionFeature11
      @@@For: ManakaiDOM|DOM3

ElementTypeBinding:
  @Name: IFCls1Def
  @ElementType: 
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      @@@@: dis|MultipleResource
      @@@ForCheck: !ManakaiDOM|ForIF !ManakaiDOM|ForClass
    @@resourceFor: ManakaiDOM|ForIF
    @@resourceFor:
      @@@@: ManakaiDOM|ForClass
      @@@ForCheck: ManakaiDOM|ManakaiDOMLatest
    @@For: ManakaiDOM|DOM1
    @@For: =ManakaiDOM|ManakaiDOM

    @@rdf:type:
      @@@@: DISLang|Interface
      @@@ForCheck: ManakaiDOM|ForIF

    @@rdf:type:
      @@@@: DISLang|Class
      @@@ForCheck: ManakaiDOM|ForClass
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOM||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOM1||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM1
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOM2||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM2
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOM3||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM3
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOMLatest||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOMLatest

    @@f:implements:
      @@@@: tx|XMLFeature10
      @@@For: ManakaiDOM|DOM1
    @@f:implements:
      @@@@: tx|XMLFeature20
      @@@For: ManakaiDOM|DOM2
    @@f:implements:
      @@@@: tx|XMLFeature30
      @@@For: ManakaiDOM|DOM3
    @@f:implements:
      @@@@: tx|XMLVersionFeature10
      @@@For: ManakaiDOM|DOM3
    @@f:implements:
      @@@@: tx|XMLVersionFeature11
      @@@For: ManakaiDOM|DOM3

ElementTypeBinding:
  @Name: IFQName
  @ElementType:
    dis:QName
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForIF

ElementTypeBinding:
  @Name: ClsQName
  @ElementType:
    dis:QName
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: IFISA
  @ElementType:
    dis:ISA
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForIF

ElementTypeBinding:
  @Name: ClsISA
  @ElementType:
    dis:ISA
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: disDef
  @ElementType:
    dis:Def
  @ShadowContent:
    @@ContentType:
      lang:dis
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: Code
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISPerl|InlineCode
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: IntPropDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISCore|Property
    @@For: =ManakaiDOM|all

ElementTypeBinding:
  @Name: RPropDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISSource|ResourceProperty
    @@For: =ManakaiDOM|all

ElementTypeBinding:
  @Name: Test
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: test|StandaloneTest
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: L2Test
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: test|StandaloneTest
    @@ForCheck: ManakaiDOM|ForClass ManakaiDOM|DOM2

ElementTypeBinding:
  @Name: L3Test
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: test|StandaloneTest
    @@ForCheck: ManakaiDOM|ForClass ManakaiDOM|DOM3

ElementTypeBinding:
  @Name: LXTest
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: test|StandaloneTest
    @@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOMLatest

ElementTypeBinding:
  @Name: XDTest
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: test|StandaloneTest
    @@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOMLatest

## -- Feature

ElementTypeBinding:
  @Name: FeatureDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: f|Feature
    @@For: =ManakaiDOM|all

ElementTypeBinding:
  @Name: FeatureVerDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: f|Feature

ElementTypeBinding:
  @Name: featureName
  @ElementType:
    f:name
  @ShadowContent:
    @@ContentType: DISCore|String

ElementTypeBinding:
  @Name: featureQName
  @ElementType:
    f:name
  @ShadowContent:
    @@ContentType: DISCore|QName

FeatureDef:
  @featureName: XML
  @QName: XMLFeature
  @FeatureVerDef:
    @@Version: 1.0
    @@QName: XMLFeature10
    @@f:instanceOf: XMLFeature
    @@f:requires: c|CoreFeature10
    @@Description:
      @@@lang:en
      @@@@:
        The DOM XML Module, Level 1.
  @FeatureVerDef:
    @@Version: 2.0
    @@QName: XMLFeature20
    @@f:extends: XMLFeature10
    @@f:requires: c|CoreFeature20
    @@Description:
      @@@lang:en
      @@@@:
        The DOM XML Module, Level 2.
  @FeatureVerDef:
    @@Version: 3.0
    @@QName: XMLFeature30
    @@f:extends: XMLFeature20
    @@f:requires: c|CoreFeature30
    @@f:requires: XMLVersionFeature10
    @@Description:
      @@@lang:en
      @@@@:
        The DOM XML Module, Level 3.

FeatureDef:
  @featureName: XMLVersion
  @QName: XMLVersionFeature
  @FeatureVerDef:
    @@Version: 1.0
    @@QName: XMLVersionFeature10
    @@f:instanceOf: XMLVersionFeature
    @@Description:
      @@@lang:en
      @@@@: The Extensible Markup Language (XML) 1.0. 
  @FeatureVerDef:
    @@Version: 1.1
    @@QName: XMLVersionFeature11
    @@f:instanceOf: XMLVersionFeature
    @@Description:
      @@@lang:en
      @@@@: The Extensible Markup Language (XML) 1.1.

ResourceDef:
  @QName: DOMString
  @AliasFor: DOMMain|DOMString
  @For: ManakaiDOM|DOM

ResourceDef:
  @QName: DOMImpl
  @AliasFor: c|DOMImplementation
  @For: ManakaiDOM|DOM

ResourceDef:
  @QName: boolean
  @AliasFor: idl|boolean||ManakaiDOM|all

ResourceDef:
  @QName: unsignedLong
  @AliasFor: idl|unsignedLong||ManakaiDOM|all

ResourceDef:
  @QName: unsignedShort
  @AliasFor: idl|unsignedShort||ManakaiDOM|all

ResourceDef:
  @QName: HASH
  @AliasFor: DISPerl|HASH||ManakaiDOM|all

ResourceDef:
  @QName: DTDef
  @AliasFor: d|DocumentTypeDefinition
  @For: ManakaiDOM|ManakaiDOMLatest

ResourceDef:
  @QName: ATDef
  @AliasFor: d|AttributeDefinition
  @For: ManakaiDOM|ManakaiDOMLatest

IntPropDef:
  @QName: tx|entityURI
  @enDesc:
    The DOM URI of the entity.
  @tc:nodeStemKey: enturi

IntPropDef:
  @QName: tx|entityBaseURI
  @enDesc:
    The base DOM URI of the entity.
  @tc:nodeStemKey: entburi

IntPropDef:
  @QName: tx|hasReplacementTree
  @enDesc:
    Whether an entity node has its replacement tree or not.
  @tc:nodeStemKey: reptree

IntPropDef:
  @QName: tx|externalDeclaration
  @enDesc:
    Declared by an external markup declaration.
  @tc:nodeStemKey: xdecled

IntPropDef:
  @QName: tx|isExternalEntity
  @enDesc:
    Is an external entity.
  @tc:nodeStemKey: extent

IntPropDef:
  @QName: tx|expanded
  @enDesc:
    Is the entity reference expanded.
  @tc:nodeStemKey: xpnded

## -- Document

ClsDef:
  @ClsQName: ManakaiDOMXMLDocument

  @domperl:classImplementedByObjectsOf: td|ManakaiDOMDocument
  @Test:
    @@QName: XMLDocument.class.1.test
    @@PerlDef:
      $test->assert_true
          (<Class::td|ManakaiDOMDocument>->isa
              (<ClassName::ManakaiDOMXMLDocument>));

  @CMethod:
    @@Name: createCDATASection
    @@enDesc:
      Creates a <IF::tx|CDATASection> node.
    @@Param:
      @@@Name: data
      @@@Type: DOMString
      @@@enDesc:
        The data for the <IF::tx|CDATASection> content.
    @@Return:
      @@@Type: tx|CDATASection
      @@@enDesc:
        The newly created <IF::tx|CDATASection> node.
      @@@iRaises:
        @@@@@: MDOMX|MDOM_DOC_NOSUPPORT_XML
        @@@@enDesc:
          If the document is an HTML document.
      @@@PerlDef:
        my $bag = <Code::mg|getNodeBag||ManakaiDOM|all:: $ref = $self>;
        my $stem;
        __CODE{mg|createNodeStem||ManakaiDOM|all::
          $bag => $bag,
          $stem => $stem,
          $class => {<ClassName::tx|ManakaiDOMCDATASection>},
          $opt => {{
            <H::tc|ownerDocument> => $self,
            <H::infoset|content> => \$data,
          }},
        }__;
        __CODE{mg|createNodeRef||ManakaiDOM|all::
          $bag => $bag,
          $stem => $stem,
          $ref => $r,
          $opt => {{
          }},
        }__;

    @@Test:
      @@@QName: Document.createCDATASection.mg.1.test
      @@@PerlDef:
        local $Message::Util::Grove::GCLatency = 0;

        my $impl;
        __CODE{tc|createImplForTest:: $impl => $impl}__;

        my $bag = $impl->{<H::mg|nodeBag>};
        my $id = $impl->{<H::mg|nodeIDReference>};

        my $doc = $impl-><M::c|DOMImplementation.createDocument>;

        my $el = $doc-><M::Document.createCDATASection> ('textdata');
        
        $test->id ('interface');
        $test->assert_isa ($el, <IFName::tx|CDATASection>);
        
        $test->id ('class');
        $test->assert_isa ($el, <ClassName::tx|ManakaiDOMCDATASection>);

        my $doc_id = $doc->{<H::mg|nodeIDReference>};
        my $el_id = $el->{<H::mg|nodeIDReference>};

        undef $impl;

        $test->id ('gc.impl.1');
        $test->assert_not_null ($bag->{$$id});

        $test->id ('gc.doc.1');
        $test->assert_not_null ($bag->{$$doc_id});

        $test->id ('gc.el.1');
        $test->assert_not_null ($bag->{$$el_id});

        undef $doc;

        $test->id ('gc.impl.2');
        $test->assert_not_null ($bag->{$$id});

        $test->id ('gc.doc.2');
        $test->assert_not_null ($bag->{$$doc_id});

        $test->id ('gc.el.2');
        $test->assert_not_null ($bag->{$$el_id});

        undef $el;

        $test->id ('gc.impl.3');
        $test->assert_null ($bag->{$$id});

        $test->id ('gc.doc.3');
        $test->assert_null ($bag->{$$doc_id});

        $test->id ('gc.el.3');
        $test->assert_null ($bag->{$$el_id});

  @CMethod:
    @@Name: createEntityReference
    @@enDesc:
      Creates an <IF::tx|EntityReference> node.

      In addition, if the referenced entity is known, the child
      list of the <IF::tx|EntityReference> node is made the same
      as that of the corresponding <IF::tx|Entity> node.

      Note that if any descendant of the <IF::tx|Entity> node has
      an unbound namespace prefix, the corresponding descendant of 
      the created <IF::tx|EntityReference> node is also unbound,
      i.e. its <A::Node.namespaceURI> is <DOM::null>.  DOM levels
      2 and 3 do not support any mechanism to resolve namespace
      prefixes in this case.  <SRC::DOM2, DOM3>
    @@DOMMain:isNamespaceUnaware: 1
    @@Param:
      @@@Name: name
      @@@Type: DOMString
      @@@enDesc:
        The name of the entity to reference.

          {NOTE:: Namespace well-formedness check is not performed.
          }
      @@@enImplNote:
        {ISSUE::
           What would be made if the <P::name> is the name of one of
           predefined entities?
        }
    @@Return:
      @@@Type: tx|EntityReference
      @@@enDesc:
        The newly created <IF::tx|EntityReference> node.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_BAD_NAME
        @@@@enDesc:
          If the <P::name> is not an XML <CODE::Name> according
          to the XML version in use specified in the
          <A::Document.xmlVersion> attribute.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_DOC_NOSUPPORT_XML
        @@@@enDesc:
          If it is an HTML document.
      @@@PerlDef:
        our $CreateEntityReference_OpenEntity;
          ## NOTE: Multithread unsafe

        my $orig_strict = $self-><AG::Document.strictErrorChecking>;
        if ($orig_strict) {
          my $version = $self-><AG::Document.xmlVersion>;
          __CODE{DOMMain|ensureXMLName::
            $INPUT => $name, $INPUT_PARAM_NAME => 'name',
            $XMLVERSION => $version,
          }__;
        }

        my $bag = <Code::mg|getNodeBag||ManakaiDOM|all:: $ref = $self>;
        my $stem;
        __CODE{mg|createNodeStem||ManakaiDOM|all::
          $bag => $bag,
          $stem => $stem,
          $class => {<ClassName::tx|ManakaiDOMEntityReference>},
          $opt => {{
            <H::infoset|name> => \$name,
            <H::tc|ownerDocument> => $self,
          }},
        }__;
        __CODE{mg|createNodeRef||ManakaiDOM|all::
          $bag => $bag,
          $stem => $stem,
          $ref => $r,
          $opt => {{
          }},
        }__;

        ## Expansion
        __DEEP{
          unless ($CreateEntityReference_OpenEntity->{$name}) {
            local $CreateEntityReference_OpenEntity->{$name} = true;
            my $__doctype = $self-><AG::Document.doctype>;
            $__doctype = $__doctype-><M::Node.getFeature>
                                     (<Q::fe|XDoctype> => '3.0')
              if $__doctype;
            if ($__doctype) {
              my $__et = $__doctype-><M::DTDef.getGeneralEntityNode> ($name);
              if ($__et) {
                $self-><AS::Document.strictErrorChecking> (false);
                my @node;
                for my $c (@{$__et-><AG::Node.childNodes>}) {
                  my $clone = $c-><M::Node.cloneNode> (true);
                  $r-><M::Node.appendChild> ($clone);
                  push @node, $clone;
                }
                $r-><AS::tx|EntityReference.manakaiExpanded>
                      ($__et-><AG::tx|Entity.hasReplacementTree>);
                $self-><AS::Document.strictErrorChecking> ($orig_strict);
              } # entity
            } # doctype
          }
          $r-><M::Node.manakaiSetReadOnly> (true, true);
        }__;

    @@Test:
      @@@QName: Document.createER.mg.1.test
      @@@PerlDef:
        local $Message::Util::Grove::GCLatency = 0;

        my $impl;
        __CODE{tc|createImplForTest:: $impl => $impl}__;

        my $bag = $impl->{<H::mg|nodeBag>};
        my $id = $impl->{<H::mg|nodeIDReference>};

        my $doc = $impl-><M::c|DOMImplementation.createDocument>;

        my $el = $doc-><M::Document.createEntityReference> ('entity');
        
        $test->id ('interface');
        $test->assert_isa ($el, <IFName::tx|EntityReference>);
        
        $test->id ('class');
        $test->assert_isa ($el, <ClassName::tx|ManakaiDOMEntityReference>);

        my $doc_id = $doc->{<H::mg|nodeIDReference>};
        my $el_id = $el->{<H::mg|nodeIDReference>};

        undef $impl;

        $test->id ('gc.impl.1');
        $test->assert_not_null ($bag->{$$id});

        $test->id ('gc.doc.1');
        $test->assert_not_null ($bag->{$$doc_id});

        $test->id ('gc.el.1');
        $test->assert_not_null ($bag->{$$el_id});

        undef $doc;

        $test->id ('gc.impl.2');
        $test->assert_not_null ($bag->{$$id});

        $test->id ('gc.doc.2');
        $test->assert_not_null ($bag->{$$doc_id});

        $test->id ('gc.el.2');
        $test->assert_not_null ($bag->{$$el_id});

        undef $el;

        $test->id ('gc.impl.3');
        $test->assert_null ($bag->{$$id});

        $test->id ('gc.doc.3');
        $test->assert_null ($bag->{$$doc_id});

        $test->id ('gc.el.3');
        $test->assert_null ($bag->{$$el_id});
    @@XDTest:
      @@@QName: Document.createER.nodef.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $ent = $doc-><M::Document.createEntityReference> ('ent1');
        $test->assert_isa ($ent, <IFName::tx|EntityReference>);
        
        $test->id ('node.name');
        $test->assert_equals ($ent-><AG::Node.nodeName>, 'ent1');

        $test->id ('not.expanded');
        $test->assert_false ($ent-><AG::tx|EntityReference.manakaiExpanded>);

        $test->id ('empty');
        $test->assert_false ($ent-><M::Node.hasChildNodes>);

        $test->id ('readonly');
        $test->assert_true ($ent-><AG::Node.manakaiReadOnly>);
    @@XDTest:
      @@@QName: Document.createER.hasdef.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docd = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>, '3.0');
        my $dtd = $docd-><M::d|DocumentXDoctype.createDocumentTypeDefinition>
                           ('doctype');
          my $et = $docd-><M::d|DocumentXDoctype.createGeneralEntity>
                             ('ent1');
          $et-><AS::Node.textContent> ('replacement text content');
          $et-><AS::tx|Entity.hasReplacementTree> (true);
        $dtd-><M::DTDef.setGeneralEntityNode> ($et);
        $doc-><M::Node.appendChild> ($dtd);

        my $ent = $doc-><M::Document.createEntityReference> ('ent1');
        $test->assert_isa ($ent, <IFName::tx|EntityReference>);
        
        $test->id ('node.name');
        $test->assert_equals ($ent-><AG::Node.nodeName>, 'ent1');

        $test->id ('expanded');
        $test->assert_true ($ent-><AG::tx|EntityReference.manakaiExpanded>);

        $test->id ('not.empty');
        $test->assert_true ($ent-><M::Node.hasChildNodes>);

        $test->id ('text.content');
        $test->assert_equals ($ent-><AG::Node.textContent>,
                              'replacement text content');

        $test->id ('is.read.only');
        $test->assert_exception (code => sub {
          $ent-><AS::Node.textContent> ('new value');
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);
    @@XDTest:
      @@@QName: Document.createER.hasdef.no-read-only.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docd = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>, '3.0');
        my $dtd = $docd-><M::d|DocumentXDoctype.createDocumentTypeDefinition>
                           ('doctype');
          my $et = $docd-><M::d|DocumentXDoctype.createGeneralEntity>
                             ('ent1');
          $et-><AS::Node.textContent> ('replacement text content');
          $et-><AS::tx|Entity.hasReplacementTree> (true);
        $dtd-><M::DTDef.setGeneralEntityNode> ($et);
        $doc-><M::Node.appendChild> ($dtd);

        my $ent = $doc-><M::Document.createEntityReference> ('ent1');
        $test->assert_isa ($ent, <IFName::tx|EntityReference>);
        $ent-><M::Node.manakaiSetReadOnly> (false, true);
        
        $test->id ('node.name');
        $test->assert_equals ($ent-><AG::Node.nodeName>, 'ent1');

        $test->id ('expanded');
        $test->assert_true ($ent-><AG::tx|EntityReference.manakaiExpanded>);

        $test->id ('not.empty');
        $test->assert_true ($ent-><M::Node.hasChildNodes>);

        $test->id ('text.content');
        $test->assert_equals ($ent-><AG::Node.textContent>,
                              'replacement text content');

        $test->id ('is.not.read.only');
        $ent-><AS::Node.textContent> ('new value');
        $test->assert_equals ($ent-><AG::Node.textContent>,
                              'new value');
    @@XDTest:
      @@@QName: Document.createER.hasdef.recursive.direct.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docd = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>, '3.0');
        my $dtd = $docd-><M::d|DocumentXDoctype.createDocumentTypeDefinition>
                           ('doctype');
          my $ent0 = $doc-><M::Document.createEntityReference> ('ent1');
          $test->assert_false ($ent0-><AG::tx|EntityReference.manakaiExpanded>);
          my $et = $docd-><M::d|DocumentXDoctype.createGeneralEntity>
                             ('ent1');
          $et-><M::Node.appendChild> ($ent0);
          $et-><AS::tx|Entity.hasReplacementTree> (true);
        $dtd-><M::DTDef.setGeneralEntityNode> ($et);
        $doc-><M::Node.appendChild> ($dtd);

        $test->id ('create');
        my $ent = $doc-><M::Document.createEntityReference> ('ent1');
        $test->assert_isa ($ent, <IFName::tx|EntityReference>);
        $test->assert_true ($ent-><AG::tx|EntityReference.manakaiExpanded>);

        $test->id ('firstChild');
        $test->assert_not_null ($ent-><AG::Node.firstChild>);
        $test->assert_false ($ent-><AG::Node.firstChild>
                                 -><AG::tx|EntityReference.manakaiExpanded>);
    @@XDTest:
      @@@QName: Document.createER.hasdef.recursive.indirect.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docd = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>, '3.0');
        my $dtd = $docd-><M::d|DocumentXDoctype.createDocumentTypeDefinition>
                           ('doctype');
          my $ent0 = $doc-><M::Document.createEntityReference> ('ent2');
          $test->assert_false ($ent0-><AG::tx|EntityReference.manakaiExpanded>);
          my $et = $docd-><M::d|DocumentXDoctype.createGeneralEntity>
                             ('ent1');
          $et-><M::Node.appendChild> ($ent0);
          $et-><AS::tx|Entity.hasReplacementTree> (true);

          my $ent0_2 = $doc-><M::Document.createEntityReference> ('ent1');
          my $et_2 = $docd-><M::d|DocumentXDoctype.createGeneralEntity>
                             ('ent2');
          $et_2-><M::Node.appendChild> ($ent0_2);
          $et_2-><AS::tx|Entity.hasReplacementTree> (true);
        $dtd-><M::DTDef.setGeneralEntityNode> ($et);
        $doc-><M::Node.appendChild> ($dtd);

        $test->id ('create');
        my $ent = $doc-><M::Document.createEntityReference> ('ent1');
        $test->assert_isa ($ent, <IFName::tx|EntityReference>);
        $test->assert_true ($ent-><AG::tx|EntityReference.manakaiExpanded>);

        $test->id ('firstChild');
        $test->assert_not_null ($ent-><AG::Node.firstChild>);
        $test->assert_false ($ent-><AG::Node.firstChild>
                                 -><AG::tx|EntityReference.manakaiExpanded>);

  @CMethod:
    @@Name: createProcessingInstruction
    @@enDesc:
      Creates a <IF::tx|ProcessingInstruction> node given the
      specified name and data strings.
    @@Param:
      @@@Name: target
      @@@Type: DOMString
      @@@enDesc:
        The target part of the processing instruction.
    @@Param:
      @@@Name: data
      @@@Type: DOMString
      @@@enDesc:
        The data for the node.
    @@Return:
      @@@Type: tx|ProcessingInstruction
      @@@enDesc:
        The newly created <IF::tx|ProcessingInstruction> node.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_BAD_NAME
        @@@@enDesc:
          If the <P::name> is not an XML <CODE::Name> according
          to the XML version in use specified in the
          <A::Document.xmlVersion> attribute.
        @@@@UnlessStrictErrorChecking:
        @@@@enImplNote:
          <ABNF::"XML"> is not allowed as a target in XML
          but it is not forbidden in DOM.
          <URI::http://lists.w3.org/Archives/Public/www-dom/2001JanMar/thread.html#77>
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_DOC_NOSUPPORT_XML
        @@@@enDesc:
          If the document is an HTML document.
      @@@PerlDef:
        if ($self-><AG::Document.strictErrorChecking>) {
          my $version = $self-><AG::Document.xmlVersion>;
          __CODE{DOMMain|ensureXMLName::
            $INPUT => $target, $INPUT_PARAM_NAME => 'target',
            $XMLVERSION => $version,
          }__;
        }

        my $bag = <Code::mg|getNodeBag||ManakaiDOM|all:: $ref = $self>;
        $data = '' unless defined $data;
        my $stem;
        __CODE{mg|createNodeStem||ManakaiDOM|all::
          $bag => $bag,
          $stem => $stem,
          $class => {<ClassName::tx|ManakaiDOMProcessingInstruction>},
          $opt => {{
            <H::infoset|target> => \$target,
            <H::infoset|content> => \$data,
            <H::tc|ownerDocument> => $self,
          }},
        }__;
        __CODE{mg|createNodeRef||ManakaiDOM|all::
          $bag => $bag,
          $stem => $stem,
          $ref => $r,
          $opt => {{
          }},
        }__;

    @@Test:
      @@@QName: Document.createPI.mg.1.test
      @@@PerlDef:
        local $Message::Util::Grove::GCLatency = 0;

        my $impl;
        __CODE{tc|createImplForTest:: $impl => $impl}__;

        my $bag = $impl->{<H::mg|nodeBag>};
        my $id = $impl->{<H::mg|nodeIDReference>};

        my $doc = $impl-><M::c|DOMImplementation.createDocument>;

        my $el = $doc-><M::Document.createProcessingInstruction> ('pi', 'data');
        
        $test->id ('interface');
        $test->assert_isa ($el, <IFName::tx|ProcessingInstruction>);
        
        $test->id ('class');
        $test->assert_isa ($el, <ClassName::tx|ManakaiDOMProcessingInstruction>);

        my $doc_id = $doc->{<H::mg|nodeIDReference>};
        my $el_id = $el->{<H::mg|nodeIDReference>};

        undef $impl;

        $test->id ('gc.impl.1');
        $test->assert_not_null ($bag->{$$id});

        $test->id ('gc.doc.1');
        $test->assert_not_null ($bag->{$$doc_id});

        $test->id ('gc.el.1');
        $test->assert_not_null ($bag->{$$el_id});

        undef $doc;

        $test->id ('gc.impl.2');
        $test->assert_not_null ($bag->{$$id});

        $test->id ('gc.doc.2');
        $test->assert_not_null ($bag->{$$doc_id});

        $test->id ('gc.el.2');
        $test->assert_not_null ($bag->{$$el_id});

        undef $el;

        $test->id ('gc.impl.3');
        $test->assert_null ($bag->{$$id});

        $test->id ('gc.doc.3');
        $test->assert_null ($bag->{$$doc_id});

        $test->id ('gc.el.3');
        $test->assert_null ($bag->{$$el_id});
    @@Test:
      @@@QName: Document.createProcessingInstruction.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $pi = $doc-><M::Document.createProcessingInstruction>
                          ('target', 'data');

        $test->id ('interface');
        $test->assert_isa ($pi, <IFName::tx|ProcessingInstruction>);

        $test->id ('nodeName');
        $test->assert_equals ($pi-><AG::Node.nodeName>, 'target');

        $test->id ('nodeValue');
        $test->assert_equals ($pi-><AG::Node.nodeValue>, 'data');
    @@Test:
      @@@QName: Document.createProcessingInstruction.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $pi = $doc-><M::Document.createProcessingInstruction>
                          ('target:name', '');

        $test->id ('interface');
        $test->assert_isa ($pi, <IFName::tx|ProcessingInstruction>);

        $test->id ('nodeName');
        $test->assert_equals ($pi-><AG::Node.nodeName>, 'target:name');

        $test->id ('nodeValue');
        $test->assert_equals ($pi-><AG::Node.nodeValue>, '');
##XMLDocument

ElementTypeBinding:
  @Name: UnlessStrictErrorChecking
  @ElementType:
    dis:Description
  @ShadowContent:
    @@ddid: unlessStrictErrorChecking
    @@For: ManakaiDOM|ManakaiDOM3
    @@@:
      In manakai implementation, this exception is not thrown
      when <A::Document.strictErrorChecking> attribute is set to
      <DOM::false>.

ElementTypeBinding:
  @Name: iRaises
  @ElementType:
    dx:raises
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForIF

## -- CDATASection

IFCls1Def:
  @IFQName: CDATASection
  @ClsQName: ManakaiDOMCDATASection

  @IFISA: tc|Text
  @ClsISA: tcd|ManakaiDOMText

  @enDesc:
    A <IF::CDATASection> object represents a <XML::CDATA> section,
    which is used to escape blocks of text containing characters
    that would otherwise be regarded as markup.

    The <A::tcd|CharacterData.data> attribute holds the text that
    is contained by the <XML::CDATA> section.  No lexical checking
    is done on the content of a <XML::CDATA> section and it is therefore
    possible to have the character sequence <XML::]]<gt>> in
     the content, which is illegal in a <XML::CDATA> section.

  @enImplNote:
    @@ddid: props
    @@@:
      {P:: Required internal properties:

        - <Q::tc|ownerDocument>.

        - <Q::infoset|content>.
      
      }

      {P:: Optional internal properties:

        - <Q::infoset|parent>.

        - <Q::c|read-only>.

      }

  @CODE:
    @@QName: tx|createCDATASectionForTest
    @@PerlDef:
      my $__doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $__doc}__;
      $text = $__doc-><M::Document.createCDATASection> ('text');

  @Test:
    @@QName: CDATASection.interfaces.test
    @@PerlDef:
      my $text;
      __CODE{tx|createCDATASectionForTest:: $text => $text}__;

      $test->id ('CDATASection');
      $test->assert_isa ($text, <IFName::CDATASection>);

      $test->id ('Text');
      $test->assert_isa ($text, <IFName::Text>);

      $test->id ('CharacterData');
      $test->assert_isa ($text, <IFName::tcd|CharacterData>);

      $test->id ('Node');
      $test->assert_isa ($text, <IFName::Node>);

      $test->id ('GetFeature');
      $test->assert_isa ($text, <IFName::f|GetFeature>);


  @CAttr:
    @@Name: nodeType
    @@Type: unsignedShort
    @@dis:actualType: tc|NodeType
    @@Get:
      @@@disDef:
        @@@@DISLang:constValue: Node.CDATA_SECTION_NODE

    @@Test:
      @@@QName: CDATASection.nodeType.test
      @@@PerlDef:
        my $text;
        __CODE{tx|createCDATASectionForTest:: $text => $text}__;

        $test->id ('nodeType');
        $test->assert_num_equals
                 (actual_value => $text-><AG::Node.nodeType>,
                  expected_value => <C::Node.CDATA_SECTION_NODE>);

  @Test:
    @@QName: CDATASection.parentNode.1.test
    @@PerlDef:
      my $text;
      __CODE{tc|createTextForTest:: $text => $text}__;

      $test->assert_null ($text-><AG::Node.parentNode>);

  @Test:
    @@QName: CDATASection.isSameNode.1.test
    @@PerlDef:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

      my $el = $doc-><M::Document.createCDATASection> ('a');

      my $el2 = $doc-><M::Document.createCDATASection> ('a');
      
      $test->id ('same');
      $test->assert_equals ($el, $el);
      
      $test->id ('diff');
      $test->assert_not_equals ($el, $el2);
      
      $test->id ('doc');
      $test->assert_not_equals ($el, $doc);
  @Test:
    @@QName: CDATASection.isSameNode.2.test
    @@PerlDef:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

      my $el = $doc-><M::Document.createCDATASection> ('a');

      my $el2 = $doc-><M::Document.createCDATASection> ('a');
      
      $test->id ('same');
      $test->assert_true ($el-><M::Node.isSameNode> ($el));
      
      $test->id ('diff');
      $test->assert_false ($el-><M::Node.isSameNode> ($el2));
      
      $test->id ('doc');
      $test->assert_false ($el-><M::Node.isSameNode> ($doc));

  @LXTest:
    @@QName: CDATASection.readOnly.test
    @@PerlDef:
      my $text;
      __CODE{tx|createCDATASectionForTest:: $text => $text}__;

      $test->id ('default');
      $test->assert_false ($text-><AG::Node.manakaiReadOnly>);

  @CMethod:
    @@Name: appendChild
    @@enDesc:
      Adds a node to the end of the list of children of the node.
      If that node is already in the tree, it is first removed.
    @@Param:
      @@@Name: newChild
      @@@Type: Node
      @@@enDesc:
        The node to add.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node added.
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_BAD_TYPE
        @@@@enDesc:
          The type of the node does not allow any children.
      @@@disDef:
        @@@@DISPerl:cloneCode: tcd|ManakaiDOMCharacterData.appendChild

  @CMethod:
    @@Name: insertBefore
    @@enDesc:
      Inserts a node before the existing child node of the node.
    @@Param:
      @@@Name: newChild
      @@@Type: Node
      @@@enDesc:
        The node to add.
    @@Param:
      @@@Name: refChild
      @@@Type: Node
      @@@enDesc:
        The node before which the <P::newChild> node is inserted.
      @@@nullCase:
        @@@@enDesc:
          The <P::newChild> node is inserted at the end.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node added.
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_BAD_TYPE
        @@@@enDesc:
          The type of the node does not allow any children.
      @@@disDef:
        @@@@DISPerl:cloneCode: tcd|ManakaiDOMCharacterData.insertBefore

  @CMethod:
    @@Name: replaceChild
    @@enDesc:
      Replaces a node by another node.
    @@Param:
      @@@Name: newChild
      @@@Type: Node
      @@@enDesc:
        The node to add.
    @@Param:
      @@@Name: oldChild
      @@@Type: Node
      @@@enDesc:
        The node to remove.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node added.
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_BAD_TYPE
        @@@@enDesc:
          The type of the node does not allow any children.
      @@@disDef:
        @@@@DISPerl:cloneCode: tcd|ManakaiDOMCharacterData.replaceChild

  @Test:
    @@QName: CDATASection.appendChild.test
    @@PerlDef:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
      my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

      my $comment = $doc-><M::Document.createCDATASection> ('data');
      my $node2 = $doc-><M::Document.createCDATASection> ('data');

      for my $node (<Code::tc|createNodesForTest+dt>) {
        $test->id ('appendChild.'.$node-><AG::Node.nodeType>);
        $test->assert_exception (code => sub {
          $comment-><M::Node.appendChild> ($node);
        }, exception_subtype => <Q::MDOMX|HIERARCHY_BAD_TYPE>);

        $test->id ('insertBefore.'.$node-><AG::Node.nodeType>);
        $test->assert_exception (code => sub {
          $comment-><M::Node.insertBefore> ($node);
        }, exception_subtype => <Q::MDOMX|HIERARCHY_BAD_TYPE>);

        $test->id ('replaceChild.'.$node-><AG::Node.nodeType>);
        $test->assert_exception (code => sub {
          $comment-><M::Node.replaceChild> ($node, $node2);
        }, exception_subtype => <Q::MDOMX|HIERARCHY_BAD_TYPE>);
      }

  @Test:
    @@QName: CDATASection..=.1.test
    @@PerlDef:
      my $doc;
      __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;

      my $node = $doc-><M::Document.createCDATASection> ('');

      $node-><M::Node.manakaiAppendText> ('aaaa');
      $test->id ('1.class');
      $test->assert_isa ($node, <IFName::CDATASection>);
      $test->id ('1.value');
      $test->assert_equals ($node-><AG::tcd|CharacterData.data>, 'aaaa');

      $test->id (2);
      $node-><M::Node.manakaiAppendText> ('bbbb');
      $test->assert_equals ($node-><AG::tcd|CharacterData.data>, 'aaaabbbb');

  @CAttr:
    @@Name: nodeName
    @@enDesc:
      The node name.
    @@DOMMain:isNamespaceUnaware:1
    @@Type: DOMString
    @@Get:
      @@@disDef:
        @@@@DISLang:value:
          @@@@@@: \#cdata-section
          @@@@@ContentType:
            DISCore:String

    @@Test:
      @@@QName: CDATASection.nodeName.test
      @@@PerlDef:
        my $text;
        __CODE{tx|createCDATASectionForTest:: $text => $text}__;

        $test->assert_equals ($text-><AG::Node.nodeName>,
                              '#cdata-section');

  @CL3Method:
    @@Name: getFeature
    @@enDesc:
      Returns a specialized object that implements the specialized APIs.
    @@Param:
      @@@Name: feature
      @@@Type: DOMString
      @@@dis:actualType: f|FeatureNameString
    @@Param:
      @@@Name: version
      @@@Type: DOMString
      @@@dis:actualType: f|FeatureVersionString
    @@Return:
      @@@Type: DOMMain|DOMObject
      @@@nullCase:
      @@@PerlDef:
        $feature =~ s/^\+//;
        __CODE{f|getFeatureImpl::
          $self => $self,
          $feature => $feature, $version => $version, $r => $r,
          $base_class => {<ClassName::ManakaiDOMCDATASection>},
        }__;
        unless (defined $r) {
          __DEEP{
            $r = $self->SUPER::get_feature ($feature, $version);
          }__;
        }

    @@Test:
      @@@QName: CDATASection.getFeature.test
      @@@PerlDef:
        my $node;
        __CODE{tx|createCDATASectionForTest:: $text => $node}__;

        for (
          [Core => '1.0', <IFName::CDATASection||ManakaiDOM|ManakaiDOM1>],
          [Core => '2.0', <IFName::CDATASection||ManakaiDOM|ManakaiDOM2>],
          [Core => '3.0', <IFName::CDATASection||ManakaiDOM|ManakaiDOM3>],
          [XML => '1.0', <IFName::CDATASection||ManakaiDOM|ManakaiDOM1>],
          [XML => '2.0', <IFName::CDATASection||ManakaiDOM|ManakaiDOM2>],
          [XML => '3.0', <IFName::CDATASection||ManakaiDOM|ManakaiDOM3>],
        ) {
          $test->id ($_->[0].'.'.$_->[1]);
          my $sp = $node-><M::Node.getFeature> ($_->[0], $_->[1]);
          $test->assert_isa ($sp, $_->[2]);
        }

  @LXTest:
    @@QName: CDATASection.baseURI.test
    @@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $pi = $doc-><M::Document.createCDATASection>;
       
        $test->id ('default');
        $test->assert_null ($pi-><AG::Node.baseURI>);

        $test->id ('doc');
        $doc-><AS::Document.documentURI> (q<http://doc.test/>);
        $test->assert_equals
                 ($pi-><AG::Node.baseURI>,
                  q<http://doc.test/>);

        $test->id ('el');
        my $el = $doc-><M::Document.createElementNS> (null, 'e');
        $el-><M::Element.setAttributeNS> (<Q::xml:>, 'xml:base',
                                          q<http://el.test/>);
        $el-><M::Node.appendChild> ($pi);
        $test->assert_equals
                 ($pi-><AG::Node.baseURI>,
                  q<http://el.test/>);

        $test->id ('ent');
        my $ent = $doc-><M::Document.createEntityReference> ('ent');
        $ent-><M::Node.manakaiSetReadOnly> (false, true);
        $ent-><AS::EntityReference.manakaiExternal> (true);
        $ent-><AS::EntityReference.manakaiEntityBaseURI> (q<http://ent.test/>);
        $el-><M::Node.appendChild> ($ent);
        $ent-><M::Node.appendChild> ($pi);
        $test->assert_equals
                 ($pi-><AG::Node.baseURI>,
                  q<http://ent.test/>);
##CDATASection

ResourceDef:
  @QName: Node
  @AliasFor: tc|Node
  @For: ManakaiDOM|DOM

ResourceDef:
  @QName: Document
  @AliasFor: td|Document
  @For: ManakaiDOM|DOM

ResourceDef:
  @QName: Element
  @AliasFor: te|Element
  @For: ManakaiDOM|DOM

ResourceDef:
  @QName: Attr
  @AliasFor: te|Attr
  @For: ManakaiDOM|DOM

ResourceDef:
  @QName: Text
  @AliasFor: tcd|Text
  @For: ManakaiDOM|DOM

NodeTypeIFDef:
  @IFQName: DocumentType

  @enDesc:
    The <IF::tx|DocumentType> interface procides an interface to
    the list of general entities and notations that are defined
    for the document.

    In DOM levels 3 or earlier, <IF::DocumentType> nodes are read-only.

    A <IF::DocumentType> node can be a child of a <IF::Document> node
    <SRC::DOM1, DOM2, DOM3> but it must be an elder sibling of the
    document element node, if any <SRC::manakai>.

    DOM Level 2 introduces the <M::c|DOMImplementation.createDocumentType>
    method, which creates a <IF::DocumentType> node not
    bound to any <IF::Document>, and that makes <IF::DocumentType>
    nodes without any parent being allowed.  The <IF::DocumentType>
    nodes themselves cannot have any children in DOM levels
    3 or earlier; <IF::Entity> and <IF::Notation> nodes are
    defined not to have any parent.

    However, the manakai's implementation allow a <IF::DocumentType>
    node to contain zero or more <IF::ProcessingInstruction> nodes
    as children.  In addition, <IF::DocumentType> node and
    <IF::Entity>, <IF::Notation>, <IF::ProcessingInstruction>,
    or other nodes contained in the <IF::DocumentType> node
    can be modified once their read-only flag is turned off
    by the <M::Node.manakaiSetReadOnly> method.

  @Attr:
    @@Name: name
    @@enDesc:
      The document type name.
    @@DOMMain:isNamespaceUnaware: 1
    @@Type: DOMString
    @@dis:actualType: DOMMain|ManakaiDOMXMLName
    @@Get:
            
  @Attr:
    @@Name: entities
    @@enDesc:
      A <IF::tc|NamedNodeMap> containing the general entities,
      both external and internal, declared in the DTD.
 
        {NOTE::
          Parameter entities are not contained and
          duplicate entity declarations are discarded.
        }

      Every node in the map also implements the <IF::Entity> interface.
    @@Type: tc|NamedNodeMap
    @@Get:

  @Attr:
    @@Name: notations
    @@enDesc:
      A <IF::tc|NamedNodeMap> containing the notations
      declared in the DTD.

        {NOTE::
          Duplicate notation declarations are discarded.
        }

      Every node in the map also implements the <IF::Notation> interface.
    @@Type: tc|NamedNodeMap
    @@Get:

  @L2Attr:
    @@Name: publicId
    @@enDesc:
      The public identifier of the external subset.
    @@Type: DOMString
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          If the external subset has no public identifier
          or if there is no external subset.  <SRC::manakai>

  @L2Attr:
    @@Name: systemId
    @@enDesc:
      The system identifier of the external subset.  It may
      or may not be an absolute URI.
    @@Type: DOMString
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          If the external subset has no system identifier
          or if there is no external subset.  <SRC::manakai>

  @L2Attr:
    @@Name: internalSubset
    @@enDesc:
      The internal subset as a string, without delimiting square brackets.
    @@Type: DOMString
    @@Get:
      @@@enDesc:
        The actual content returned depends on how much information
        is available to the implementation.  This may vary depending
        on various parameters, including the XML processor used
        to build the document.
      @@@nullCase:
        @@@@enDesc:
          If there is no internal subset.

  @LXAttr:
    @@Name: implementation
    @@enDesc:
      The <IF::c|DOMImplementation> object to which the node belongs.

      This attribute is a manakai extension.
    @@Type: c|DOMImplementation
    @@Get:
    @@enImplNote:
      {ISSUE::
        If a level 2 implementation creates a document type node
        whose class also implement level 3 document type interfaces,
        its <A::DocumentType.implementation> attribute must return
        a level 3 implementation object by definition.
      }
##DocumentType

enImplNote:
  @ddid: dtd
  @@:
## TODO: DocumentType

        {TODO::
           For <IF::tx|DocumentType>.removeChild.
        }

NodeTypeDef:
  @IFQName: Notation
  @ClsQName: ManakaiDOMNotation
  
  @enDesc:
    A <IF::Notation> node represents a notation declared in the DTD.

    The <A::Node.nodeName> attribute is set to the declared
    name of the notation.

    A <IF::Notation> node does not have any parent.

    In DOM levels 3 or earlier, <IF::Notation> nodes are always read-only.
    However, the manakai's implementation allow modifications
    of <IF::Notation> nodes.

    Note that a modification might make the document ill-formed.
    For example, setting an illegal public identifier string
    to the attribute <A::Notation.publicId> makes it impossible
    to serialize the document into an XML document.

  @IntMethod:
    @@Operator: mg|CreateNodeStemMethod
    @@Param:
      @@@Name: bag
      @@@Type: HASH
    @@Param:
      @@@Name: obj
      @@@Type: HASH
    @@Param:
      @@@Name: opt
      @@@Type: HASH
    @@Return:
      @@@Type: HASH
      @@@PerlDef:
        __CODE{DISPerl|HashStringRef||ManakaiDOM|all::
          $result => {$obj->{<H::infoset|name>}},
          $given => {${$opt->{<H::infoset|name>}}},
        }__;
        __CODE{mg|setOwnerProp||ManakaiDOM|all::
          $bag => $bag,
          $ownerref => {$opt->{<H::tc|ownerDocument>}},
          $ownee1hprop => {<H::tc|revOwnerDocument>},
          $ownee => {$obj},
          $owner0prop => {<H::tc|ownerDocument>},
        }__;
        $r = $obj;
  @mg:owner0: tc|ownerDocument
  @mg:origin0: d|ownerDefinition

  @enImplNote:
    @@ddid:props
    @@@:
      {P:: Required internal properties:

        - <Q::tc|ownerDocment>.

        - <Q::infoset|name>.

      }

      {P:: Optional internal properties:

        - <Q::d|ownerDefinition>.

        - <Q::infoset|publicIdentifier>, <Q::infoset|systemIdentifier>,
          <Q::infoset|declarationBaseURI>.

        - <Q::c|read-only>.

      }

  @CODE:
    @@QName: tx|createNotationForTest
    @@PerlDef:
      my $__docx;
      __CODE{d|createEmptyDocumentXForTest:: $docx => $__docx}__;
      $not = $__docx-><M::DocumentX.createNotation> ('not');
  @CODE:
    @@QName: tx|createRONotationForTest
    @@PerlDef:
      my $docx;
      __CODE{d|createEmptyDocumentXForTest:: $docx => $docx}__;
      $not = $docx-><M::DocumentX.createNotation> ('not');
      $not-><M::Node.manakaiSetReadOnly> (true, true);

  @CAttr:
    @@Name: childNodes
    @@enDesc:
      A list of nodes that contains all children of the node.
    @@Get:
      @@@Type: c|NodeList
      @@@enDesc:
        Since <IF::Notation> nodes cannot have child nodes,
        the node list is always empty.
      @@@disDef:
        @@@@DISPerl:cloneCode: tcd|ManakaiDOMCharacterData.childNodes.get

  @CAttr:
    @@Name: nodeName
    @@enDesc:
      The node name.
    @@DOMMain:isNamespaceUnaware:1
    @@Type: DOMString
    @@Get:
      @@@PerlDef:
        my $v;
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $v,
          $prop => {<H::infoset|name>},
          $ref => {$self},
        }__;
        $r = $$v;

    @@Test:
      @@@QName: Notation.nodeName.test
      @@@PerlDef:
        my $docx;
        __CODE{d|createEmptyDocumentXForTest:: $docx => $docx}__;

        my $not = $docx-><M::DocumentX.createNotation> ('notation1');

        $test->assert_equals ($not-><AG::Node.nodeName>, 'notation1');

  @CAttr:
    @@Name: nodeType
    @@Type: unsignedShort
    @@dis:actualType: tc|NodeType
    @@Get:
      @@@disDef:
        @@@@DISLang:constValue: Node.NOTATION_NODE

    @@Test:
      @@@QName: Notation.nodeType.test
      @@@PerlDef:
        my $text;
        __CODE{tx|createNotationForTest:: $not => $text}__;

        $test->id ('nodeType');
        $test->assert_num_equals
                 (actual_value => $text-><AG::Node.nodeType>,
                  expected_value => <C::Node.NOTATION_NODE>);

  @CL3Attr:
    @@Name: textContent
    @@enDesc:
      The text content of the node.
    @@Type: DOMString
    @@Get:
      @@@nullCase:
      @@@PerlDef:
        $r = null;
    @@Set:
      @@@nullCase:
      @@@c:reports:
        @@@@@: c|setting-node-value-no-effect
        @@@@enDesc:
          Setting the attribute value has no effect, since the
          node value is defined as <DOM::null>.
      @@@disDef:
        @@@@DISPerl:cloneCode: tc|ManakaiDOMNode.nodeValue.set

  @CMethod:
    @@Name: appendChild
    @@enDesc:
      Adds a node to the end of the list of children of the node.
      If that node is already in the tree, it is first removed.
    @@Param:
      @@@Name: newChild
      @@@Type: Node
      @@@enDesc:
        The node to add.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node added.
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_BAD_TYPE
        @@@@enDesc:
          The type of the node does not allow any children.
      @@@disDef:
        @@@@DISPerl:cloneCode: tcd|ManakaiDOMCharacterData.appendChild

  @CMethod:
    @@Name: insertBefore
    @@enDesc:
      Inserts a node before the existing child node of the node.
    @@Param:
      @@@Name: newChild
      @@@Type: Node
      @@@enDesc:
        The node to add.
    @@Param:
      @@@Name: refChild
      @@@Type: Node
      @@@enDesc:
        The node before which the <P::newChild> node is inserted.
      @@@nullCase:
        @@@@enDesc:
          The <P::newChild> node is inserted at the end.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node added.
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_BAD_TYPE
        @@@@enDesc:
          The type of the node does not allow any children.
      @@@disDef:
        @@@@DISPerl:cloneCode: tcd|ManakaiDOMCharacterData.insertBefore

  @CMethod:
    @@Name: replaceChild
    @@enDesc:
      Replaces a node by another node.
    @@Param:
      @@@Name: newChild
      @@@Type: Node
      @@@enDesc:
        The node to add.
    @@Param:
      @@@Name: oldChild
      @@@Type: Node
      @@@enDesc:
        The node to remove.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node added.
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_BAD_TYPE
        @@@@enDesc:
          The type of the node does not allow any children.
      @@@disDef:
        @@@@DISPerl:cloneCode: tcd|ManakaiDOMCharacterData.replaceChild

    @@Test:
      @@@QName: Notation.appendChild.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $comment = $docx-><M::DocumentX.createNotation> ('data');
        my $node2 = $docx-><M::DocumentX.createNotation> ('data');

        for my $node (<Code::tc|createNodesForTest+dt>) {
          $test->id ('appendChild.'.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.appendChild> ($node);
          }, exception_subtype => <Q::MDOMX|HIERARCHY_BAD_TYPE>);

          $test->id ('insertBefore.'.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.insertBefore> ($node);
          }, exception_subtype => <Q::MDOMX|HIERARCHY_BAD_TYPE>);

          $test->id ('replaceChild.'.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.replaceChild> ($node, $node2);
          }, exception_subtype => <Q::MDOMX|HIERARCHY_BAD_TYPE>);
        }

  @Test:
    @@QName: Notation..=.1.test
    @@PerlDef:
      my $doc;
      __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
      my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

      my $node = $docx-><M::DocumentX.createNotation> ('d');

      $node-><M::Node.manakaiAppendText> ('aaaa');
      $test->id ('1.class');
      $test->assert_isa ($node, <IFName::Notation>);
      $test->id ('1.value');
      $test->assert_null ($node-><AG::Node.textContent>);

  @CL3Method:
    @@Name: getFeature
    @@enDesc:
      Returns a specialized object that implements the specialized APIs.
    @@Param:
      @@@Name: feature
      @@@Type: DOMString
      @@@dis:actualType: f|FeatureNameString
    @@Param:
      @@@Name: version
      @@@Type: DOMString
      @@@dis:actualType: f|FeatureVersionString
    @@Return:
      @@@Type: DOMMain|DOMObject
      @@@nullCase:
      @@@PerlDef:
        $feature =~ s/^\+//;
        __CODE{f|getFeatureImpl::
          $self => $self,
          $feature => $feature, $version => $version, $r => $r,
          $base_class => {<ClassName::ManakaiDOMNotation>},
        }__;
        unless (defined $r) {
          __DEEP{
            $r = $self->SUPER::get_feature ($feature, $version);
          }__;
        }

    @@Test:
      @@@QName: Notation.getFeature.test
      @@@PerlDef:
        my $node;
        __CODE{tx|createNotationForTest:: $not => $node}__;

        for (
          [Core => '1.0', <IFName::Notation||ManakaiDOM|ManakaiDOM1>],
          [Core => '2.0', <IFName::Notation||ManakaiDOM|ManakaiDOM2>],
          [Core => '3.0', <IFName::Notation||ManakaiDOM|ManakaiDOM3>],
          [XML => '1.0', <IFName::Notation||ManakaiDOM|ManakaiDOM1>],
          [XML => '2.0', <IFName::Notation||ManakaiDOM|ManakaiDOM2>],
          [XML => '3.0', <IFName::Notation||ManakaiDOM|ManakaiDOM3>],
        ) {
          $test->id ($_->[0].'.'.$_->[1]);
          my $sp = $node-><M::Node.getFeature> ($_->[0], $_->[1]);
          $test->assert_isa ($sp, $_->[2]);
        }

  @Attr:
    @@Name: publicId
    @@enDesc:
      The public identifier of the notation.
    @@nullCase:
      @@@enDesc:
        If the public identifier is not specified.
    @@Type: DOMString
    @@Get:
      @@@PerlDef:
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $r,
          $prop => {<H::infoset|publicIdentifier>},
          $ref => {$self},
        }__;
    @@LXSet:
      @@@enDesc:
        Sets the attribute value.  No lexical checking is
        performed.
      @@@nullCase:
        @@@@enDesc:
          The attribute value is set to <DOM::null>.
      @@@NodeReadOnlyError:
      @@@PerlDef:
        __CODE{tc|NodeReadOnlyError:: $node => $self}__;
        __CODE{mg|setNodeStemPropValue||ManakaiDOM|all::
          $given => $given,
          $prop => {<H::infoset|publicIdentifier>},
          $ref => $self,
        }__;

    @@XDTest:
      @@@QName: Notation.publicId.test
      @@@PerlDef:
        my $et;
        __CODE{tx|createNotationForTest:: $not => $et}__;
        
        $test->id ('default');
        $test->assert_null ($et-><AG::Notation.publicId>);

        $test->id ('set');
        $et-><AS::Notation.publicId> ('string');
        $test->assert_equals ($et-><AG::Notation.publicId>, 'string');

        $test->id ('unset');
        $et-><AS::Notation.publicId> (null);
        $test->assert_null ($et-><AG::Notation.publicId>);

  @Attr:
    @@Name: systemId
    @@enDesc:
      The system identifier of the notation.  It might or might not
      be an absolute URI.
    @@nullCase:
      @@@enDesc:
        If the system identifier is not specified.
    @@Type: DOMString
    @@Get:
      @@@PerlDef:
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $r,
          $prop => {<H::infoset|systemIdentifier>},
          $ref => {$self},
        }__;
    @@LXSet:
      @@@enDesc:
        Sets the attribute value.  No lexical checking is
        performed.
      @@@nullCase:
        @@@@enDesc:
          The attribute value is set to <DOM::null>.
      @@@NodeReadOnlyError:
      @@@PerlDef:
        __CODE{tc|NodeReadOnlyError:: $node => $self}__;
        __CODE{mg|setNodeStemPropValue||ManakaiDOM|all::
          $given => $given,
          $prop => {<H::infoset|systemIdentifier>},
          $ref => $self,
        }__;

    @@XDTest:
      @@@QName: Notation.systemId.test
      @@@PerlDef:
        my $et;
        __CODE{tx|createNotationForTest:: $not => $et}__;
        
        $test->id ('default');
        $test->assert_null ($et-><AG::Notation.systemId>);

        $test->id ('set');
        $et-><AS::Notation.systemId> ('string');
        $test->assert_equals ($et-><AG::Notation.systemId>, 'string');

        $test->id ('unset');
        $et-><AS::Notation.systemId> (null);
        $test->assert_null ($et-><AG::Notation.systemId>);
  
  @CL3Attr:
    @@Name: baseURI
    @@enDesc:
      The base URI of the node.
    @@enDesc:
      @@@ddid: man
      @@@For: ManakaiDOM|ManakaiDOM
      @@@@:
        In manakai, it is always equal to the base DOM URI of 
        the owner document node.
    @@Type: DOMString
    @@dis:actualType: ManakaiDOM|ManakaiDOMURI
    @@Get:
      @@@enDesc:
        The absolute base DOM URI.
      @@@nullCase:
        @@@@enDesc:
          If the DOM implementation was not able to obtain the absolute URI.
      @@@PerlDef: 
        __DEEP{
          $r = $self-><AG::Node.ownerDocument>-><AG::Node.baseURI>;
        }__;

    @@XDTest:
      @@@QName: Notation.baseURI.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $dx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $ent = $dx-><M::DocumentX.createNotation> ('ent');

        $test->id ('initial');
        $test->assert_null ($ent-><AG::Node.baseURI>);

        $test->id ('doc');
        $doc-><AS::Document.documentURI> (q<http://base.example/>);
        $test->assert_equals
                 ($ent-><AG::Node.baseURI>,
                  q<http://base.example/>);

        $test->id ('declburi');
        $ent-><AS::Notation.manakaiDeclarationBaseURI>
                (q<http://www.example/>);
        $test->assert_equals
                 ($ent-><AG::Node.baseURI>,
                  q<http://base.example/>); # shouldn't affect

  @LXAttr:
    @@Name: manakaiDeclarationBaseURI
    @@enDesc:
      The base DOM URI of the notation declaration by which the notation
      is declared.

        {NOTE::
           This attribute is a manakai extension similar to
           the <InfoProp::declaration base URI> property
           of the XML Information Set.
        }
    @@Type: DOMString
    @@dis:actualType: ManakaiDOM|ManakaiDOMURI
    @@Get:
      @@@enDesc:
        The declaration base DOM URI.  If there is no explicit
        base DOM URI information attached to the node, then
        the base DOM URI of the node, i.e. <A::Node.baseURI>
        is returned.
      @@@nullCase:
        @@@@enDesc:
          If there is no explicit base URI information and
          the <A::Node.baseURI> attribute contains <DOM::null>.
      @@@PerlDef:
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $r,
          $prop => {<H::infoset|declarationBaseURI>},
          $ref => {$self},
        }__;
        unless (defined $r) {
          __DEEP{
            $r = $self-><AG::Node.baseURI>;
          }__;
        }
    @@Set:
      @@@enDesc:
        The declaration base DOM URI.  It <kwd:MUST> be an absolute
        DOM URI; however, no lexical checking is performed on 
        the setting.  In addition, it does not change <A::Notation.systemId>
        nor does any of entities or notation attributes in the document.
      @@@nullCase:
        @@@@enDesc:
          The declaration base DOM URI is unset.  It does
          not affect to the base DOM URI of the node or document.
      @@@NodeReadOnlyError:
      @@@PerlDef:
        __CODE{tc|NodeReadOnlyError:: $node => $self}__;
        __CODE{mg|setNodeStemPropValue||ManakaiDOM|all::
          $given => $given,
          $prop => {<H::infoset|declarationBaseURI>},
          $ref => $self,
        }__;

    @@XDTest:
      @@@QName: Notation.declBaseURI.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $dx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $ent = $dx-><M::DocumentX.createNotation> ('ent');

        $test->id ('initial');
        $test->assert_null ($ent-><AG::Notation.manakaiDeclarationBaseURI>);

        $test->id ('doc');
        $doc-><AS::Document.documentURI> (q<http://www.example/>);
        $test->assert_equals 
                 ($ent-><AG::Notation.manakaiDeclarationBaseURI>,
                  q<http://www.example/>);
        
        $test->id ('set');
        $ent-><AS::Notation.manakaiDeclarationBaseURI> (q<ftp://www.example/>);
        $test->assert_equals
                 ($ent-><AG::Notation.manakaiDeclarationBaseURI>,
                  q<ftp://www.example/>);
        $test->assert_equals
                 ($ent-><AG::Node.baseURI>,
                  q<http://www.example/>);

        $test->id ('unset');
        $ent-><AS::Notation.manakaiDeclarationBaseURI> (null);
        $test->assert_equals
                 ($ent-><AG::Notation.manakaiDeclarationBaseURI>,
                  q<http://www.example/>);

  @enImplNote:
    @@ddid: entURi
    @@@:
      {ISSUE::
        An attribute containing absolute system id (similar to
        <A::Entity.manakaiEntityURI>) is necessary?
      }

  @LXAttr:
    @@Name: ownerDocumentTypeDefinition
    @@enDesc:
      The document type definition node to which the notation is attached.
    @@Type: d|DocumentTypeDefinition
    @@Get:
      @@@enDesc:
        The owner document type definition node.
      @@@nullCase:
        @@@@enDesc:
          The notation is not attached to any document type.
      @@@PerlDef:
        __CODE{mg|getNodeStemProp0Node||ManakaiDOM|all::
          $r => $r,
          $prop => {<H::d|ownerDefinition>},
          $ref => $self,
          $opt => {{}},
        }__;

    @@XDTest:
      @@@QName: Notation.ownerDTDef.test
      @@@PerlDef:
        my $et;
        __CODE{tx|createNotationForTest:: $not => $et}__;
 
        my $odt = $et-><AG::Notation.ownerDocumentTypeDefinition>;
        $test->assert_null ($odt);

        my $dt = $et-><AG::Node.ownerDocument>
                     -><M::Node.getFeature> (<Q::fe|XDoctype>)
                     -><M::DocumentX.createDocumentTypeDefinition>
                         ('dt1');
        $test->assert_not_null ($dt);
        $dt-><M::d|DocumentTypeDefinition.setNotationNode> ($et);

        my $odt2 = $et-><AG::Notation.ownerDocumentTypeDefinition>;
        $test->assert_not_null ($odt2);
        $test->assert_isa ($odt2, <IFName::d|DocumentTypeDefinition>);
        $test->assert_equals ($odt2, $dt);
##Notation

ResourceDef:
  @QName: DocumentX
  @AliasFor: d|DocumentXDoctype
  @For: ManakaiDOM|ManakaiDOMLatest

NodeTypeDef:
  @IFQName: Entity
  @ClsQName: ManakaiDOMEntity

  @enDesc:
    An <IF::Entity> node represents a known entity, either
    parsed or unparsed, in an XML document.  Note that 
    is models the entity itself, <EM::not> entity declaration.
    <SRC::DOM1, DOM2, DOM3>

    The <A::Node.nodeName> attribute contains the name
    of the entity.  <SRC::DOM1, DOM2, DOM3>

    An <IF::Entity> node does not have any parent.
    <SRC::DOM1, DOM2, DOM3>

    When the replacement text of the entity is available, 
    the child list of the <IF::Entity> node represents the structure 
    of that replacement value.  Otherwise, the child list is empty.
    <SRC::DOM1, DOM2, DOM3>

    The resolution of the children of the <IF::Entity>
    (the replacement value) may be lazily evaluated;
    actions by the user (such as retrieving the <A::Node.childNodes>
    value from the <IF::Entity> node) are assumed to
    trigger the evaluation.  <SRC::DOM1>

    Note that if the entity contains an unbound namespace prefix, 
    the <A::Node.namespaceURI> of the corresponding node in the 
    <IF::Entity> node subtree is <DOM::null>.  <SRC::DOM2, DOM3>
    
    An <IF::Entity> node does not have any parent.  <SRC::DOM1, DOM2, DOM3>
    
    DOM levels 3 or earlier do not support editing <IF::Entity> nodes,
    so that all <IF::Entity> nodes and their descendants are read-only.

    However, in the manakai's implementation, <IF::Entity>
    nodes and their descendants can be modified by
    removing their read-only flag by the <M::Node.manakaiSetReadOnly>
    method.

    Any modification to <IF::Entity> subtree or possible
    removal of the <IF::Entity> node itself will cause
    inconsistency between <IF::Entity> and <IF::EntityReference>
    subtrees.  It should be fixed by the <M::Document.normalizeDocument>
    method if desired.
  
    Some change make a document invalid or even not well-formed.
    For example, setting <A::Entity.notationName> attribute
    might make a node unparsed entity and any reference to that 
    entity is an error.  An external entity with its
    <A::Entity.systemId> set to <DOM::null> is unserializable.

  @IntMethod:
    @@Operator: mg|CreateNodeStemMethod
    @@Param:
      @@@Name: bag
      @@@Type: HASH
    @@Param:
      @@@Name: obj
      @@@Type: HASH
    @@Param:
      @@@Name: opt
      @@@Type: HASH
    @@Return:
      @@@Type: HASH
      @@@PerlDef:
        __CODE{DISPerl|HashStringRef||ManakaiDOM|all::
          $result => {$obj->{<H::infoset|name>}},
          $given => {${$opt->{<H::infoset|name>}}},
        }__;
        __CODE{mg|setOwnerProp||ManakaiDOM|all::
          $bag => $bag,
          $ownerref => {$opt->{<H::tc|ownerDocument>}},
          $ownee1hprop => {<H::tc|revOwnerDocument>},
          $ownee => {$obj},
          $owner0prop => {<H::tc|ownerDocument>},
        }__;
        $obj->{<H::infoset|children>} = [];
        $r = $obj;
  @mg:owner0: tc|ownerDocument
  @mg:origin0: d|ownerDefinition
  @mg:subnode1a: infoset|children

  @enImplNote:
    @@ddid:props
    @@@:
      {P:: Required internal properties:

        - <Q::tc|ownerDocument>.

        - <Q::infoset|name>.

        - <Q::infoset|children>.

      }

      {P:: Optional internal properties:

        - <Q::d|ownerDefinition>, <Q::tx|hasReplacementTree>.

        - <Q::infoset|publicIdentifier>, <Q::infoset|systemIdentifier>,
          <Q::infoset|declarationBaseURI>.

        - <Q::infoset|characterEncodingScheme>, <Q::c|xmlEncoding>,
          <Q::infoset|version>, <Q::tx|entityURI>, <Q::tx|entityBaseURI>.

        - <Q::infoset|notationName>.

        - <Q::tx|externalDeclaration>.

        - <Q::c|read-only>.

      }

  @CODE:
    @@QName: tx|createGEForTest
    @@PerlDef:
      my $__docx;
      __CODE{d|createEmptyDocumentXForTest:: $docx => $__docx}__;
      $gent = $__docx-><M::DocumentX.createGeneralEntity> ('gent');
  @CODE:
    @@QName: tx|createROGEForTest
    @@PerlDef:
      my $docx;
      __CODE{d|createEmptyDocumentXForTest:: $docx => $docx}__;
      $gent = $docx-><M::DocumentX.createGeneralEntity> ('gent');
      $gent-><M::Node.manakaiSetReadOnly> (true, true);

  @CAttr:
    @@Name: nodeName
    @@enDesc:
      The node name.
    @@DOMMain:isNamespaceUnaware:1
    @@Type: DOMString
    @@Get:
      @@@disDef:
        @@@@DISPerl:cloneCode: ManakaiDOMNotation.nodeName.get

    @@Test:
      @@@QName: Entity.nodeName.test
      @@@PerlDef:
        my $docx;
        __CODE{d|createEmptyDocumentXForTest:: $docx => $docx}__;

        my $not = $docx-><M::DocumentX.createGeneralEntity> ('notation1');

        $test->assert_equals ($not-><AG::Node.nodeName>, 'notation1');

  @CAttr:
    @@Name: nodeType
    @@Type: unsignedShort
    @@dis:actualType: tc|NodeType
    @@Get:
      @@@disDef:
        @@@@DISLang:constValue: Node.ENTITY_NODE

    @@Test:
      @@@QName: GE.nodeType.test
      @@@PerlDef:
        my $text;
        __CODE{tx|createGEForTest:: $gent => $text}__;

        $test->id ('nodeType');
        $test->assert_num_equals
                 (actual_value => $text-><AG::Node.nodeType>,
                  expected_value => <C::Node.ENTITY_NODE>);
  
  @CMethod:
    @@Name: appendChild
    @@enDesc:
      Adds a node to the end of the list of children of the node.
      If that node is already in the tree, it is first removed.
    @@Param:
      @@@Name: newChild
      @@@Type: Node
      @@@enDesc:
        The node to add.
      @@@InCase:
        @@@@Type: tc|DocumentFragment
        @@@@enDesc:
          The entire contents of the document fragment are
          moved into the child list of the node.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node added.  If the <P::newChild> node is a <IF::tc|DocumentFragment>
        node, then the <P::newChild> node <kwd:MUST> be returned.
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_BAD_TYPE
        @@@@enDesc:
          If the node is of a type that does not allow children of
          the type of the <P::newChild> node.
 
          If the <A::Document.strictErrorChecking> is set to <DOM::false>,
          this exception <kwd:MAY-NOT> be thrown.
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_ANCESTOR_OR_SELF
        @@@@enDesc:
          If the <P::newChild> node is one of the node's ancestor
          <SRC::DOM 1, 2, 3> or the node itself <SRC::DOM 2 Errata, DOM 3>.
      @@@dx:raises:
        @@@@@: c|DIFFERENT_DOCUMENT_ERR
        @@@@enDesc:
          If the <P::newChild> node was created from a different
          document than the one to which the node was created or
          the node does not belong to any document.

          If the <A::Document.strictErrorChecking> is set to <DOM::false>,
          this exception <kwd:MAY-NOT> be thrown.
      @@@dx:raises: 
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the node is read-only.

          If the <A::Document.strictErrorChecking> is set to <DOM::false>,
          this exception <kwd:MAY-NOT> be thrown.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_SRC_PARENT
        @@@@enDesc:
          If the previous parent of the <P::newChild> node is read-only
          <SRC::DOM 2 Errata, DOM 3>.

          If the <A::Document.strictErrorChecking> is set to <DOM::false>,
          this exception <kwd:MAY-NOT> be thrown.
      @@@disDef:
        @@@@DISPerl:cloneCode: te|ManakaiDOMElement.appendChild

  @CMethod:
    @@Name: insertBefore
    @@enDesc:
      Inserts a node before the existing child node of the node.

      Inserting a node before itself is implementation dependent.
    @@Param:
      @@@Name: newChild
      @@@Type: Node
      @@@enDesc:
        The node to insert.  If the <P::newChild> is already in 
        the tree, it is first removed.
      @@@InCase:
        @@@@Type: tc|DocumentFragment
        @@@@enDesc:
          All of children of the <P::newChild> node are inserted,
          in the same order, before <P::refChild>.
    @@Param:
      @@@Name: refChild
      @@@Type: Node
      @@@enDesc:
        The reference node, i.e. the node before which the new node
        must be inserted.
      @@@nullCase:
        @@@@enDesc:
          The <P::newChild> node is inserted at the end of the list
          of children.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node being inserted.
      @@@enImplNote:
        What is returned if <P::newChild> is a <IF::tc|DocumentFragment>?
        See also <M::Node.appendChild>'s return value.
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_BAD_TYPE
        @@@@enDesc:
          If the node is of a type that does not allow children of
          the type of the <P::newChild> node.
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_ANCESTOR_OR_SELF
        @@@@enDesc:
          If the <P::newChild> node is one of the node's ancestor
          <SRC::DOM 1, 2, 3> or the node itself <SRC::DOM 2 Errata, DOM 3>.
      @@@dx:raises:
        @@@@@: c|DIFFERENT_DOCUMENT_ERR
        @@@@enDesc:
          If the <P::newChild> node was created from a different
          document than the one that created the node.
        @@@@enImplNote:
          The DOM specification ignores the fact that <IF::Document>s
          and <IF::tx|DocumentType>s are created from 
          <IF::c|DOMImplementation> :-)
      @@@dx:raises: 
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the node is read-only.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_SRC_PARENT
        @@@@enDesc:
          If the previous parent of the <P::newChild> node is read-only
          <SRC::DOM 1 SE, DOM 2, 3>.
      @@@dx:raises:
        @@@@@: c|NOT_CHILD_ERR
        @@@@enDesc:
          If the <P::refChild> node is not a child of the node.
      @@@c:reports:
        @@@@@: t|insert-before-itself
        @@@@enDesc:
          If the <P::newChild> node is same as the <P::refChild> node.
          Then, the result is implementation dependent.
      @@@disDef:
        @@@@DISPerl:cloneCode: te|ManakaiDOMElement.insertBefore

  @CMethod:
    @@Name: replaceChild
    @@enDesc:
      Replaces a child node with another node.

      Replacing a node with itself is implementation dependent <SRC::DOM3>.
    @@Param:
      @@@Name: newChild
      @@@Type: Node
      @@@enDesc:
        The new node to put in the child list.

        If the <P::newChild> node is already in the tree,
        it is first removed.
      @@@InCase:
        @@@@Type: tc|DocumentFragment
        @@@@enDesc:
          The <P::oldChild> node is replaced by all of the 
          <IF::DocumentFragment> children, which are inserted
          in the same order <SRC::DOM1 SE, DOM2, DOM3>.
    @@Param:
      @@@Name: oldChild
      @@@Type: Node
      @@@enDesc:
        The node being replaced in the list.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node replaced.
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_BAD_TYPE
        @@@@enDesc:
          If the node is of a type that does not allow children of
          the type of the <P::newChild> node.
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_ANCESTOR_OR_SELF
        @@@@enDesc:
          If the <P::newChild> node is one of the node's ancestor
          <SRC::DOM 1, 2, 3> or the node itself <SRC::DOM 2 Errata, DOM 3>.
      @@@dx:raises:
        @@@@@: c|DIFFERENT_DOCUMENT_ERR
        @@@@enDesc:
          If the <P::newChild> node was created from a different
          document than the one that created the node.
        @@@@enImplNote:
          The DOM specification ignores the fact that <IF::Document>s
          and <IF::tx|DocumentType>s are created from 
          <IF::c|DOMImplementation> :-)
      @@@dx:raises: 
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the node is read-only.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_SRC_PARENT
        @@@@enDesc:
          If the previous parent of the <P::newChild> node is read-only
          <SRC::DOM1 SE, DOM2, DOM3>.
      @@@dx:raises:
        @@@@@: c|NOT_CHILD_ERR
        @@@@enDesc:
          If the <P::oldChild> node is not a child of the node.
      @@@c:reports:
        @@@@@: t|replaced-by-itself
        @@@@enDesc:
          If the <P::newChild> node is same as the <P::oldChild> node.
          Then, the result is implementation dependent.
      @@@disDef:
        @@@@DISPerl:cloneCode: te|ManakaiDOMElement.replaceChild

    @@Test:
      @@@QName: Entity.appendChild.1.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentX.createGeneralEntity> ('dt');
        my $pi = $doc-><M::Document.createTextNode> ('pi');

        my $return = $dtd-><M::Node.appendChild> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: Entity.appendChild.1.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentX.createGeneralEntity> ('dt');
        my $pi = $doc-><M::Document.createEntityReference> ('pi');

        my $return = $dtd-><M::Node.appendChild> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|EntityReference>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: Entity.appendChild.1.3.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentX.createGeneralEntity> ('dt');
        my $pi = $doc-><M::Document.createElement> ('pi');

        my $return = $dtd-><M::Node.appendChild> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tc|Element>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: Entity.appendChild.1.4.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentX.createGeneralEntity> ('dt');
        my $pi = $doc-><M::Document.createProcessingInstruction> ('pi');

        my $return = $dtd-><M::Node.appendChild> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|ProcessingInstruction>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: Entity.appendChild.1.5.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentX.createGeneralEntity> ('dt');
        my $pi = $doc-><M::Document.createCDATASection> ('pi');

        my $return = $dtd-><M::Node.appendChild> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|CDATASection>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: Entity.appendChild.1.6.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentX.createGeneralEntity> ('dt');
        my $pi = $doc-><M::Document.createComment> ('pi');

        my $return = $dtd-><M::Node.appendChild> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tc|Comment>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: Entity.insertBefore.1.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentX.createGeneralEntity> ('dt');
        my $pi = $doc-><M::Document.createTextNode> ('pi');

        my $return = $dtd-><M::Node.insertBefore> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: Entity.insertBefore.1.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentX.createGeneralEntity> ('dt');
        my $pi = $doc-><M::Document.createEntityReference> ('pi');

        my $return = $dtd-><M::Node.insertBefore> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|EntityReference>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: Entity.insertBefore.1.3.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentX.createGeneralEntity> ('dt');
        my $pi = $doc-><M::Document.createElement> ('pi');

        my $return = $dtd-><M::Node.insertBefore> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tc|Element>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: Entity.insertBefore.1.4.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentX.createGeneralEntity> ('dt');
        my $pi = $doc-><M::Document.createProcessingInstruction> ('pi');

        my $return = $dtd-><M::Node.insertBefore> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|ProcessingInstruction>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: Entity.insertBefore.1.5.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentX.createGeneralEntity> ('dt');
        my $pi = $doc-><M::Document.createCDATASection> ('pi');

        my $return = $dtd-><M::Node.insertBefore> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|CDATASection>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: Entity.insertBefore.1.6.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentX.createGeneralEntity> ('dt');
        my $pi = $doc-><M::Document.createComment> ('pi');

        my $return = $dtd-><M::Node.insertBefore> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tc|Comment>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);

    @@Test:
      @@@QName: Entity.appendChild.has.parent.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentX.createGeneralEntity> ('dt');

        my $piparent = $doc-><M::Document.createElementNS> (null, 'e');
        my $pi = $doc-><M::Document.createTextNode> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.appendChild> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: Entity.appendChild.has.parent.1.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentX.createGeneralEntity> ('dt');

        my $piparent = $doc-><M::Document.createElementNS> (null, 'e');
        my $pi = $doc-><M::Document.createEntityReference> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.appendChild> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|EntityReference>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: Entity.insertBefore.has.parent.1.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentX.createGeneralEntity> ('dt');

        my $piparent = $doc-><M::Document.createElementNS> (null, 'e');
        my $pi = $doc-><M::Document.createTextNode> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.insertBefore> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: Entity.insertBefore.has.parent.1.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentX.createGeneralEntity> ('dt');

        my $piparent = $doc-><M::Document.createElementNS> (null, 'e');
        my $pi = $doc-><M::Document.createEntityReference> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.insertBefore> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|EntityReference>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi);

    @@Test:
      @@@QName: Entity.appendChild.documentfragment.1.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentX.createGeneralEntity> ('dt');

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createTextNode> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.appendChild> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: Entity.appendChild.documentfragment.1.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentX.createGeneralEntity> ('dt');

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createEntityReference> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.appendChild> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|EntityReference>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: Entity.insertBefore.documentfragment.1.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentX.createGeneralEntity> ('dt');

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createTextNode> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.insertBefore> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);
        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: Entity.insertBefore.documentfragment.1.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentX.createGeneralEntity> ('dt');

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createEntityReference> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.insertBefore> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|EntityReference>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: Entity.replaceChild.documentfragment.1.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentX.createGeneralEntity> ('dt');
        my $pi0 = $doc-><M::Document.createTextNode> ('pi0');
        $dtd-><M::Node.appendChild> ($pi0);

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createTextNode> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.replaceChild> ($piparent, $pi0);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi0);
    @@Test:
      @@@QName: Entity.replaceChild.documentfragment.1.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentX.createGeneralEntity> ('dt');
        my $pi0 = $doc-><M::Document.createTextNode> ('pi0');
        $dtd-><M::Node.appendChild> ($pi0);

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createEntityReference> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.replaceChild> ($piparent, $pi0);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|EntityReference>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi0);

    @@Test:
      @@@QName: Entity.appendChild.documentfragment.2.1.test
      @@@enDesc:
        Empty document fragment.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentX.createGeneralEntity> ('dt');

        my $piparent = $doc-><M::Document.createDocumentFragment>;

        my $return = $dtd-><M::Node.appendChild> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 0);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: Entity.insertBefore.documentfragment.2.test
      @@@enDesc:
        Empty document fragment.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentX.createGeneralEntity> ('dt');

        my $piparent = $doc-><M::Document.createDocumentFragment>;

        my $return = $dtd-><M::Node.insertBefore> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 0);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: Entity.replaceChild.documentfragment.2.test
      @@@enDesc:
        Empty document fragment.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentX.createGeneralEntity> ('dt');
        my $pi0 = $doc-><M::Document.createTextNode> ('pi0');
        $dtd-><M::Node.appendChild> ($pi0);

        my $piparent = $doc-><M::Document.createDocumentFragment>;

        my $return = $dtd-><M::Node.replaceChild> ($piparent, $pi0);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 0);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi0);

    @@Test:
      @@@QName: Entity.appendChild.documentfragment.3.test
      @@@enDesc:
        Three PIs in document fragment.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentX.createGeneralEntity> ('dt');

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createTextNode> ('pi');
        my $pi2 = $doc-><M::Document.createEntityReference> ('pi2');
        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $piparent-><M::Node.appendChild> ($pi);
        $piparent-><M::Node.appendChild> ($pi2);
        $piparent-><M::Node.appendChild> ($pi3);

        my $return = $dtd-><M::Node.appendChild> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 3);

        my $item = $child-><M::tc|NodeList.item> (0);
        my $item2 = $child-><M::tc|NodeList.item> (1);
        my $item3 = $child-><M::tc|NodeList.item> (2);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);
        $test->id ('child.item.node2');
        $test->assert_isa ($item2, <IFName::Node>);
        $test->id ('child.item.node3');
        $test->assert_isa ($item3, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);
        $test->id ('child.item.pi2');
        $test->assert_isa ($item2, <IFName::tx|EntityReference>);
        $test->id ('child.item.pi3');
        $test->assert_isa ($item3, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);
        $test->id ('child.item.equals2');
        $test->assert_equals ($item2, $pi2);
        $test->id ('child.item.equals3');
        $test->assert_equals ($item3, $pi3);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi3);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);
        $test->id ('parent2');
        my $parent2 = $item2-><AG::Node.parentNode>;
        $test->assert_equals ($parent2, $dtd);
        $test->id ('parent3');
        my $parent3 = $item3-><AG::Node.parentNode>;
        $test->assert_equals ($parent3, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: Entity.insertBefore.documentfragment.3.test
      @@@enDesc:
        Three PIs in document fragment.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentX.createGeneralEntity> ('dt');

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createTextNode> ('pi');
        my $pi2 = $doc-><M::Document.createEntityReference> ('pi2');
        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $piparent-><M::Node.appendChild> ($pi);
        $piparent-><M::Node.appendChild> ($pi2);
        $piparent-><M::Node.appendChild> ($pi3);

        my $return = $dtd-><M::Node.insertBefore> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 3);

        my $item = $child-><M::tc|NodeList.item> (0);
        my $item2 = $child-><M::tc|NodeList.item> (1);
        my $item3 = $child-><M::tc|NodeList.item> (2);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);
        $test->id ('child.item.node2');
        $test->assert_isa ($item2, <IFName::Node>);
        $test->id ('child.item.node3');
        $test->assert_isa ($item3, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);
        $test->id ('child.item.pi2');
        $test->assert_isa ($item2, <IFName::tx|EntityReference>);
        $test->id ('child.item.pi3');
        $test->assert_isa ($item3, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);
        $test->id ('child.item.equals2');
        $test->assert_equals ($item2, $pi2);
        $test->id ('child.item.equals3');
        $test->assert_equals ($item3, $pi3);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi3);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);
        $test->id ('parent2');
        my $parent2 = $item2-><AG::Node.parentNode>;
        $test->assert_equals ($parent2, $dtd);
        $test->id ('parent3');
        my $parent3 = $item3-><AG::Node.parentNode>;
        $test->assert_equals ($parent3, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: Entity.replaceChild.documentfragment.3.test
      @@@enDesc:
        Three PIs in document fragment.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentX.createGeneralEntity> ('dt');
        my $pi0 = $doc-><M::Document.createTextNode> ('pi0');
        $dtd-><M::Node.appendChild> ($pi0);

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createTextNode> ('pi');
        my $pi2 = $doc-><M::Document.createEntityReference> ('pi2');
        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $piparent-><M::Node.appendChild> ($pi);
        $piparent-><M::Node.appendChild> ($pi2);
        $piparent-><M::Node.appendChild> ($pi3);

        my $return = $dtd-><M::Node.replaceChild> ($piparent, $pi0);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 3);

        my $item = $child-><M::tc|NodeList.item> (0);
        my $item2 = $child-><M::tc|NodeList.item> (1);
        my $item3 = $child-><M::tc|NodeList.item> (2);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);
        $test->id ('child.item.node2');
        $test->assert_isa ($item2, <IFName::Node>);
        $test->id ('child.item.node3');
        $test->assert_isa ($item3, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);
        $test->id ('child.item.pi2');
        $test->assert_isa ($item2, <IFName::tx|EntityReference>);
        $test->id ('child.item.pi3');
        $test->assert_isa ($item3, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);
        $test->id ('child.item.equals2');
        $test->assert_equals ($item2, $pi2);
        $test->id ('child.item.equals3');
        $test->assert_equals ($item3, $pi3);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi3);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);
        $test->id ('parent2');
        my $parent2 = $item2-><AG::Node.parentNode>;
        $test->assert_equals ($parent2, $dtd);
        $test->id ('parent3');
        my $parent3 = $item3-><AG::Node.parentNode>;
        $test->assert_equals ($parent3, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi0);

    @@Test:
      @@@QName: Entity.appendChild.badtype.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $comment = $docx-><M::DocumentX.createGeneralEntity>
                               ('data');
        my $pi0 = $doc-><M::Document.createTextNode> ('pi0');
        $comment-><M::Node.appendChild> ($pi0);

        for my $node (
          $docx-><M::DocumentX.createDocumentTypeDefinition> ('d'),
          $doc-><M::Document.createAttribute> ('a'),
          $docx-><M::DocumentX.createGeneralEntity> ('ge'),
          $docx-><M::DocumentX.createNotation> ('not'),
          $docx-><M::DocumentX.createElementTypeDefinition> ('et'),
          $docx-><M::DocumentX.createAttributeDefinition> ('at'),
          #test:nodeTypes
        ) {
          $test->id ('appendChild.'.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.appendChild> ($node);
          }, exception_subtype => <Q::MDOMX|HIERARCHY_BAD_TYPE>);

          $test->id ('insertBefore.'.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.insertBefore> ($node);
          }, exception_subtype => <Q::MDOMX|HIERARCHY_BAD_TYPE>);

          $test->id ('replaceChild.'.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.replaceChild> ($node, $pi0);
          }, exception_subtype => <Q::MDOMX|HIERARCHY_BAD_TYPE>);
        }

    @@Test:
      @@@QName: Entity.appendChild.wrongdoc.test
      @@@PerlDef:
        my $doc0;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc0}__;
        my $docx0 = $doc0-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $comment = $docx0-><M::DocumentX.createGeneralEntity>
                                ('data');

        for my $node (
          $doc-><M::Document.createTextNode> ('pi'),
          $doc-><M::Document.createEntityReference> ('e'),
          $doc-><M::Document.createComment> ('c'),
          $doc-><M::Document.createCDATASection> ('cs'),
          $doc-><M::Document.createProcessingInstruction> ('pi'),
          $doc-><M::Document.createElement> ('el'),
        ) {
          $test->id ('type='.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.appendChild> ($node);
          }, exception_subtype => <Q::c|DIFFERENT_DOCUMENT_ERR>);
        }
    @@Test:
      @@@QName: Entity.insertBefore.wrongdoc.test
      @@@PerlDef:
        my $doc0;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc0}__;
        my $docx0 = $doc0-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $comment = $docx0-><M::DocumentX.createGeneralEntity>
                                ('data');
        my $pi0 = $doc0-><M::Document.createTextNode> ('pi0');
        $comment-><M::Node.appendChild> ($pi0);

        for my $node (
          $doc-><M::Document.createTextNode> ('pi'),
          $doc-><M::Document.createEntityReference> ('ent'),
          $doc-><M::Document.createComment> ('c'),
          $doc-><M::Document.createCDATASection> ('cs'),
          $doc-><M::Document.createProcessingInstruction> ('pi'),
          $doc-><M::Document.createElement> ('el'),
        ) {
          $test->id ('appendChild.'.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.appendChild> ($node);
          }, exception_subtype => <Q::c|DIFFERENT_DOCUMENT_ERR>);

          $test->id ('insertBefore.'.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.insertBefore> ($node);
          }, exception_subtype => <Q::c|DIFFERENT_DOCUMENT_ERR>);

          $test->id ('replaceChild.'.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.replaceChild> ($node, $pi0);
          }, exception_subtype => <Q::c|DIFFERENT_DOCUMENT_ERR>);
        }

    @@Test:
      @@@QName: Entity.appendChild.readonly.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentX.createGeneralEntity> ('d');
        my $pi0 = $doc-><M::Document.createTextNode> ('pi0');
        $dtd-><M::Node.appendChild> ($pi0);
        $dtd-><M::Node.manakaiSetReadOnly> (true);

        $test->id ('pi');
        my $node = $doc-><M::Document.createTextNode> ('pi');

        $test->assert_exception (code => sub {
          $dtd-><M::Node.appendChild> ($node);
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);

        $test->id ('pi.insertBefore');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.insertBefore> ($node);
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);

        $test->id ('pi.replaceChild');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.replaceChild> ($node, $pi0);
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);

        $test->id ('fragment');
        my $node2 = $doc-><M::Document.createDocumentFragment>;
        $node2-><M::Node.appendChild> ($node);

        $test->assert_exception (code => sub {
          $dtd-><M::Node.appendChild> ($node2);
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);

        $test->id ('fragment.insertBefore');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.insertBefore> ($node2);
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);

        $test->id ('fragment.replaceChild');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.replaceChild> ($node2, $pi0);
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);

    @@Test:
      @@@QName: Entity.appendChild.readonly.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentX.createGeneralEntity> ('d');
        my $pi0 = $doc-><M::Document.createTextNode> ('pi0');
        $dtd-><M::Node.appendChild> ($pi0);

        $test->id ('pi');
        my $el = $doc-><M::Document.createElementNS> (null, 'e');
        my $node = $doc-><M::Document.createTextNode> ('pi');
        $el-><M::Node.appendChild> ($node);
        $el-><M::Node.manakaiSetReadOnly> (true);

        $test->assert_exception (code => sub {
          $dtd-><M::Node.appendChild> ($node);
        }, exception_subtype => <Q::MDOMX|NOMOD_SRC_PARENT>);

        $test->id ('pi.insertBefore');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.insertBefore> ($node);
        }, exception_subtype => <Q::MDOMX|NOMOD_SRC_PARENT>);

        $test->id ('pi.replaceChild');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.replaceChild> ($node, $pi0);
        }, exception_subtype => <Q::MDOMX|NOMOD_SRC_PARENT>);

        $test->id ('fragment');
        my $node2 = $doc-><M::Document.createDocumentFragment>;
        my $node3 = $doc-><M::Document.createTextNode> ('pi');
        $node2-><M::Node.appendChild> ($node3);
        $node2-><M::Node.manakaiSetReadOnly> (true);

        $test->assert_exception (code => sub {
          $dtd-><M::Node.appendChild> ($node2);
        }, exception_subtype => <Q::MDOMX|NOMOD_SRC_PARENT>);

        $test->id ('fragment.insertBefore');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.insertBefore> ($node2);
        }, exception_subtype => <Q::MDOMX|NOMOD_SRC_PARENT>);

        $test->id ('fragment.replaceChild');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.replaceChild> ($node2, $pi0);
        }, exception_subtype => <Q::MDOMX|NOMOD_SRC_PARENT>);

    @@Test:
      @@@QName: Entity.insertBefore.refChild.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentX.createGeneralEntity> ('d');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.insertBefore> ($pi2, $pi1);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi2);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi1);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: Entity.insertBefore.refChild.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentX.createGeneralEntity> ('d');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $dtd-><M::Node.insertBefore> ($pi3, $pi2);

        # pi1, pi3, pi2

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi1);

        $test->id ('firstChild.nextSibling');
        $test->assert_equals ($dtd-><AG::Node.firstChild>
                                  -><AG::Node.nextSibling>, $pi3);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi2);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 3);

    @@Test:
      @@@QName: Entity.insertBefore.refChild.3.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentX.createGeneralEntity> ('d');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $dtd-><M::Node.appendChild> ($pi3);

        # pi1, pi2, pi3

        $dtd-><M::Node.insertBefore> ($pi2, $pi1);
 
        # pi2, pi1, pi3

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi2);

        $test->id ('firstChild.nextSibling');
        $test->assert_equals ($dtd-><AG::Node.firstChild>
                                  -><AG::Node.nextSibling>, $pi1);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi3);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 3);

    @@Test:
      @@@QName: Entity.insertBefore.refChild.4.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentX.createGeneralEntity> ('d');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $dtd-><M::Node.appendChild> ($pi3);

        # pi1, pi2, pi3

        $dtd-><M::Node.insertBefore> ($pi3, $pi1);
 
        # pi3, pi1, pi2

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi3);

        $test->id ('firstChild.nextSibling');
        $test->assert_equals ($dtd-><AG::Node.firstChild>
                                  -><AG::Node.nextSibling>, $pi1);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi2);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 3);

    @@Test:
      @@@QName: Entity.insertBefore.refChild.not_found_err.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentX.createGeneralEntity> ('d');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');

        my $pi4 = $doc-><M::Document.createTextNode> ('pi4');

        # pi1, pi2

        $test->assert_exception (code => sub {
          $dtd-><M::Node.insertBefore> ($pi4, $pi3);
        }, exception_subtype => <Q::c|NOT_CHILD_ERR>);

    @@Test:
      @@@QName: Entity.insertBefore.refChild=newChild.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentX.createGeneralEntity> ('d');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        # pi1, pi2

        my $eh_called = false;
        my $cfg = $doc-><AG::Document.domConfig>;
        $cfg-><M::c|DOMConfiguration.setParameter> ('error-handler' => sub {
          my (undef, $err) = @_;
          $eh_called = true;
          $test->assert_equals ($err-><AG::c|DOMError.severity>,
                                <C::c|DOMError.SEVERITY_WARNING>);
          $test->assert_equals ($err-><AG::c|DOMError.type>,
                                <Q::t|insert-before-itself>);
          $test->assert_equals ($err-><AG::c|DOMError.relatedData>, $pi2);
          $test->assert_null ($err-><AG::c|DOMError.relatedException>);
          $test->assert_isa ($err-><AG::c|DOMError.location>,
                             <IFName::c|DOMLocator>);
          $test->assert_not_null ($err-><AG::c|DOMError.message>);
        });

        $test->assert_false ($eh_called);
        $dtd-><M::Node.insertBefore> ($pi2, $pi2);
        $test->assert_true ($eh_called);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi1);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi2);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: Entity.replaceChild.oldChild=newChild.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentX.createGeneralEntity> ('d');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        # pi1, pi2

        my $eh_called = false;
        my $cfg = $doc-><AG::Document.domConfig>;
        $cfg-><M::c|DOMConfiguration.setParameter> ('error-handler' => sub {
          my (undef, $err) = @_;
          $eh_called = true;
          $test->assert_equals ($err-><AG::c|DOMError.severity>,
                                <C::c|DOMError.SEVERITY_WARNING>);
          $test->assert_equals ($err-><AG::c|DOMError.type>,
                                <Q::t|replace-by-itself>);
          $test->assert_equals ($err-><AG::c|DOMError.relatedData>, $pi2);
          $test->assert_null ($err-><AG::c|DOMError.relatedException>);
          $test->assert_isa ($err-><AG::c|DOMError.location>,
                             <IFName::c|DOMLocator>);
          $test->assert_not_null ($err-><AG::c|DOMError.message>);
        });

        $test->assert_false ($eh_called);
        $dtd-><M::Node.replaceChild> ($pi2, $pi2);
        $test->assert_true ($eh_called);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi1);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi2);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: Entity.appendChild.sameparent.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentX.createGeneralEntity> ('d');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        # pi1, pi2

        my $return = $dtd-><M::Node.appendChild> ($pi1);

        # pi2, pi1

        $test->id ('return');
        $test->assert_equals ($return, $pi1);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi2);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi1);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: Entity.insertBefore.sameparent.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentX.createGeneralEntity> ('d');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        # pi1, pi2

        my $return = $dtd-><M::Node.insertBefore> ($pi1);

        # pi2, pi1

        $test->id ('return');
        $test->assert_equals ($return, $pi1);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi2);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi1);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: Entity.appendChild.sameparent.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentX.createGeneralEntity> ('d');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        # pi1, pi2

        my $return = $dtd-><M::Node.appendChild> ($pi2);

        # pi1, pi2

        $test->id ('return');
        $test->assert_equals ($return, $pi2);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi1);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi2);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: Entity.insertBefore.sameparent.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentX.createGeneralEntity> ('d');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        # pi1, pi2

        my $return = $dtd-><M::Node.insertBefore> ($pi2);

        # pi1, pi2

        $test->id ('return');
        $test->assert_equals ($return, $pi2);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi1);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi2);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: Entity.replaceChild.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentX.createGeneralEntity> ('d');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $dtd-><M::Node.appendChild> ($pi3);

        # pi1, pi2, pi3

        my $pi9 = $doc-><M::Document.createTextNode> ('pi9');
        my $return = $dtd-><M::Node.replaceChild> ($pi9, $pi1);

        # pi9, pi2, pi3

        $test->id ('return.node');
        $test->assert_isa ($return, <IFName::Node>);
        $test->id ('return.pi');
        $test->assert_isa ($return, <IFName::Text>);
        $test->id ('return');
        $test->assert_equals ($return, $pi1);

        my $c = $dtd-><AG::Node.childNodes>;

        $test->id ('length');
        $test->assert_num_equals (actual_value => 0+@$c, expected_value => 3);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi9);

        $test->id ('firstChild.nextSibling');
        $test->assert_equals ($dtd-><AG::Node.firstChild>
                                  -><AG::Node.nextSibling>, $pi2);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi3);
 
        $test->id ('parent');
        $test->assert_equals ($pi9-><AG::Node.parentNode>, $dtd);

        $test->id ('return.parent');
        $test->assert_null ($pi1-><AG::Node.parentNode>);

    @@Test:
      @@@QName: Entity.replaceChild.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentX.createGeneralEntity> ('d');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $dtd-><M::Node.appendChild> ($pi3);

        # pi1, pi2, pi3

        my $pi9 = $doc-><M::Document.createTextNode> ('pi9');
        my $return = $dtd-><M::Node.replaceChild> ($pi9, $pi2);

        # pi1, pi9, pi3

        $test->id ('return.node');
        $test->assert_isa ($return, <IFName::Node>);
        $test->id ('return.pi');
        $test->assert_isa ($return, <IFName::Text>);
        $test->id ('return');
        $test->assert_equals ($return, $pi2);

        my $c = $dtd-><AG::Node.childNodes>;

        $test->id ('length');
        $test->assert_num_equals (actual_value => 0+@$c, expected_value => 3);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi1);

        $test->id ('firstChild.nextSibling');
        $test->assert_equals ($dtd-><AG::Node.firstChild>
                                  -><AG::Node.nextSibling>, $pi9);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi3);
 
        $test->id ('parent');
        $test->assert_equals ($pi9-><AG::Node.parentNode>, $dtd);

        $test->id ('return.parent');
        $test->assert_null ($pi2-><AG::Node.parentNode>);

    @@Test:
      @@@QName: Entity.replaceChild.3.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentX.createGeneralEntity> ('d');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $dtd-><M::Node.appendChild> ($pi3);

        # pi1, pi2, pi3

        my $pi9 = $doc-><M::Document.createTextNode> ('pi9');
        my $return = $dtd-><M::Node.replaceChild> ($pi9, $pi3);

        # pi1, pi2, pi9

        $test->id ('return.node');
        $test->assert_isa ($return, <IFName::Node>);
        $test->id ('return.pi');
        $test->assert_isa ($return, <IFName::Text>);
        $test->id ('return');
        $test->assert_equals ($return, $pi3);

        my $c = $dtd-><AG::Node.childNodes>;

        $test->id ('length');
        $test->assert_num_equals (actual_value => 0+@$c, expected_value => 3);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi1);

        $test->id ('firstChild.nextSibling');
        $test->assert_equals ($dtd-><AG::Node.firstChild>
                                  -><AG::Node.nextSibling>, $pi2);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi9);
 
        $test->id ('parent');
        $test->assert_equals ($pi9-><AG::Node.parentNode>, $dtd);

        $test->id ('return.parent');
        $test->assert_null ($pi3-><AG::Node.parentNode>);

    @@Test:
      @@@QName: Entity.replaceChild.sameparent.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentX.createGeneralEntity> ('d');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $dtd-><M::Node.appendChild> ($pi3);

        # pi1, pi2, pi3

        my $return = $dtd-><M::Node.replaceChild> ($pi3, $pi1);

        # pi3, pi2

        $test->id ('return.node');
        $test->assert_isa ($return, <IFName::Node>);
        $test->id ('return.pi');
        $test->assert_isa ($return, <IFName::Text>);
        $test->id ('return');
        $test->assert_equals ($return, $pi1);

        my $c = $dtd-><AG::Node.childNodes>;

        $test->id ('length');
        $test->assert_num_equals (actual_value => 0+@$c, expected_value => 2);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi3);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi2);
 
        $test->id ('parent');
        $test->assert_equals ($pi3-><AG::Node.parentNode>, $dtd);

        $test->id ('return.parent');
        $test->assert_null ($pi1-><AG::Node.parentNode>);

    @@Test:
      @@@QName: Entity.replaceChild.sameparent.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $docx-><M::DocumentX.createGeneralEntity> ('d');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $dtd-><M::Node.appendChild> ($pi3);

        # pi1, pi2, pi3

        my $return = $dtd-><M::Node.replaceChild> ($pi1, $pi3);

        # pi2, pi1

        $test->id ('return.node');
        $test->assert_isa ($return, <IFName::Node>);
        $test->id ('return.pi');
        $test->assert_isa ($return, <IFName::Text>);
        $test->id ('return');
        $test->assert_equals ($return, $pi3);

        my $c = $dtd-><AG::Node.childNodes>;

        $test->id ('length');
        $test->assert_num_equals (actual_value => 0+@$c, expected_value => 2);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi2);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi1);
 
        $test->id ('parent');
        $test->assert_equals ($pi1-><AG::Node.parentNode>, $dtd);

        $test->id ('return.parent');
        $test->assert_null ($pi3-><AG::Node.parentNode>);

  @CMethod:
    @@Name: manakaiAppendText
    @@Param:
      @@@Name: string
      @@@Type: DOMString
      @@@enDesc:
        The string to append.
      @@@InCase:
        @@@@Type: DISPerl|SCALAR||ManakaiDOM|all
        @@@@enDesc:
          A copy of the string value referenced from the value
          is appended.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node itself.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the node to insert the string or a <IF::Text> node
          is read-only.
      @@@disDef:
        @@@@DISPerl:cloneCode: te|ManakaiDOMAttr.manakaiAppendText

    @@Test:
      @@@QName: Entity..=.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $node = $docx-><M::DocumentX.createGeneralEntity> ('node');

        $node-><M::Node.manakaiAppendText> ('string');
        $test->id ('1.class');
        $test->assert_isa ($node, <IFName::Entity>);
        $test->id ('1.value');
        $test->assert_equals ($node-><AG::Node.textContent>, 'string');
        $test->id ('1.length');
        $test->assert_num_equals
                 (expected_value => 1,
                  actual_value => 0+@{$node-><AG::Node.childNodes>});

        $test->id (2);
        $node-><M::Node.manakaiAppendText> ('STRING');
        $test->assert_equals ($node-><AG::Node.textContent>, 'stringSTRING');
        $test->assert_num_equals
                 (expected_value => 1,
                  actual_value => 0+@{$node-><AG::Node.childNodes>});

        $node-><M::Node.appendChild>
                 ($doc-><M::Document.createEntityReference> ('er'));

        $test->id (3);
        $node-><M::Node.manakaiAppendText> ('text');
        $test->assert_equals ($node-><AG::Node.textContent>, 'stringSTRINGtext');
        $test->assert_num_equals
                 (expected_value => 3,
                  actual_value => 0+@{$node-><AG::Node.childNodes>});

  @CL3Method:
    @@Name: getFeature
    @@enDesc:
      Returns a specialized object that implements the specialized APIs.
    @@Param:
      @@@Name: feature
      @@@Type: DOMString
      @@@dis:actualType: f|FeatureNameString
    @@Param:
      @@@Name: version
      @@@Type: DOMString
      @@@dis:actualType: f|FeatureVersionString
    @@Return:
      @@@Type: DOMMain|DOMObject
      @@@nullCase:
      @@@PerlDef:
        $feature =~ s/^\+//;
        __CODE{f|getFeatureImpl::
          $self => $self,
          $feature => $feature, $version => $version, $r => $r,
          $base_class => {<ClassName::ManakaiDOMEntity>},
        }__;
        unless (defined $r) {
          __DEEP{
            $r = $self->SUPER::get_feature ($feature, $version);
          }__;
        }

    @@Test:
      @@@QName: Entity.getFeature.test
      @@@PerlDef:
        my $node;
        __CODE{tx|createGEForTest:: $gent => $node}__;

        for (
          [Core => '1.0', <IFName::Entity||ManakaiDOM|ManakaiDOM1>],
          [Core => '2.0', <IFName::Entity||ManakaiDOM|ManakaiDOM2>],
          [Core => '3.0', <IFName::Entity||ManakaiDOM|ManakaiDOM3>],
          [XML => '1.0', <IFName::Entity||ManakaiDOM|ManakaiDOM1>],
          [XML => '2.0', <IFName::Entity||ManakaiDOM|ManakaiDOM2>],
          [XML => '3.0', <IFName::Entity||ManakaiDOM|ManakaiDOM3>],
        ) {
          $test->id ($_->[0].'.'.$_->[1]);
          my $sp = $node-><M::Node.getFeature> ($_->[0], $_->[1]);
          $test->assert_isa ($sp, $_->[2]);
        }
  
  @CL3Attr:
    @@Name: baseURI
    @@enDesc:
      The base URI of the node.
    @@enDesc:
      @@@ddid: man
      @@@For: ManakaiDOM|ManakaiDOM
      @@@@:
        In manakai, it is always equal to the base DOM URI of 
        the owner document node.
    @@Type: DOMString
    @@dis:actualType: ManakaiDOM|ManakaiDOMURI
    @@Get:
      @@@enDesc:
        The absolute base DOM URI.
      @@@nullCase:
        @@@@enDesc:
          If the DOM implementation was not able to obtain the absolute URI.
      @@@PerlDef: 
        __DEEP{
          $r = $self-><AG::Node.ownerDocument>-><AG::Node.baseURI>;
        }__;

    @@XDTest:
      @@@QName: Entity.baseURI.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $dx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $ent = $dx-><M::DocumentX.createGeneralEntity> ('ent');

        $test->id ('initial');
        $test->assert_null ($ent-><AG::Node.baseURI>);

        $test->id ('doc');
        $doc-><AS::Document.documentURI> (q<http://base.example/>);
        $test->assert_equals
                 ($ent-><AG::Node.baseURI>,
                  q<http://base.example/>);

        $test->id ('entburi');
        $ent-><AS::Entity.manakaiEntityBaseURI> (q<http://www.example.com/>);
        $test->assert_equals
                 ($ent-><AG::Node.baseURI>,
                  q<http://base.example/>); # shouldn't affect

        $test->id ('declburi');
        $ent-><AS::Entity.manakaiDeclarationBaseURI> (q<http://www.example/>);
        $test->assert_equals
                 ($ent-><AG::Node.baseURI>,
                  q<http://base.example/>); # shouldn't affect

  @L3Attr:
    @@Name: inputEncoding
    @@enDesc:
      The encoding used for the entity at the time of parsing,
      when it is an external parsed entity.
    @@Type: DOMString
    @@enImplNote:
      What type of value?
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          If it is an entity from the internal subset or if it is not known.
          <SRC::DOM3>
      @@@nullCase:
        @@@@enDesc:
          If it is an internal entity, if it is an unparsed entity,
          or if the character encoding name of the entity is not 
          known to the implementation.
      @@@PerlDef:
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $r,
          $prop => {<H::infoset|characterEncodingScheme>},
          $ref => {$self},
        }__;
    @@LXSet:
      @@@enDesc:
        Sets the attribute value.  No lexical checking is performed
        on setting.
      @@@nullCase:
        @@@@enDesc:
          Sets <DOM::null> as the attribute value.
      @@@NodeReadOnlyError:
      @@@PerlDef:
        __CODE{tc|NodeReadOnlyError:: $node => $self}__;
        __CODE{mg|setNodeStemPropValue||ManakaiDOM|all::
          $given => $given,
          $prop => {<H::infoset|characterEncodingScheme>},
          $ref => $self,
        }__;

    @@Test:
      @@@QName: Entity.inputEncoding.test
      @@@PerlDef:
        my $node;
        __CODE{tx|createGEForTest:: $gent => $node}__;

        $test->id ('initial');
        $test->assert_null ($node-><AG::Entity.inputEncoding>);

        $test->id ('set');
        $node-><AS::Entity.inputEncoding> ('utf-8');
        $test->assert_equals ($node-><AG::Entity.inputEncoding>, 'utf-8');

        $test->id ('reset');
        $node-><AS::Entity.inputEncoding> (null);
        $test->assert_null ($node-><AG::Entity.inputEncoding>);

  @Attr:
    @@Name: notationName
    @@enDesc:
      The name of the notation for the entity.
    @@Type: DOMString
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          If it is a parsed entity.
      @@@PerlDef:
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $r,
          $prop => {<H::infoset|notationName>},
          $ref => {$self},
        }__;
    @@LXSet:
      @@@enDesc:
        Sets the attribute value.  No lexical checking is performed
        on setting.
      @@@enImplNote:
        {ISSUE::
          Should <Q::MDOMX|MDOM_BAD_NAME> exception be thrown?
        }
      @@@nullCase:
        @@@@enDesc:
          Sets <DOM::null> as the attribute value.
      @@@NodeReadOnlyError:
      @@@PerlDef:
        __CODE{tc|NodeReadOnlyError:: $node => $self}__;
        __CODE{mg|setNodeStemPropValue||ManakaiDOM|all::
          $given => $given,
          $prop => {<H::infoset|notationName>},
          $ref => $self,
        }__;

    @@Test:
      @@@QName: Entity.notationName.test
      @@@PerlDef:
        my $node;
        __CODE{tx|createGEForTest:: $gent => $node}__;

        $test->id ('initial');
        $test->assert_null ($node-><AG::Entity.notationName>);

        $test->id ('set');
        $node-><AS::Entity.notationName> ('utf-8');
        $test->assert_equals ($node-><AG::Entity.notationName>, 'utf-8');

        $test->id ('reset');
        $node-><AS::Entity.notationName> (null);
        $test->assert_null ($node-><AG::Entity.notationName>);

  @Attr:
    @@Name: publicId
    @@enDesc:
      The public identifier associated with the entity.
    @@nullCase:
      @@@enDesc:
        If no public identifier is associated.
    @@Type: DOMString
    @@Get:
      @@@PerlDef:
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $r,
          $prop => {<H::infoset|publicIdentifier>},
          $ref => {$self},
        }__;
    @@LXSet:
      @@@enDesc:
        Sets the attribute value.  No lexical checking is performed
        on setting.
      @@@nullCase:
        @@@@enDesc:
          Sets <DOM::null> as the attribute value.
      @@@NodeReadOnlyError:
      @@@PerlDef:
        __CODE{tc|NodeReadOnlyError:: $node => $self}__;
        __CODE{mg|setNodeStemPropValue||ManakaiDOM|all::
          $given => $given,
          $prop => {<H::infoset|publicIdentifier>},
          $ref => $self,
        }__;

    @@Test:
      @@@QName: Entity.publicId.test
      @@@PerlDef:
        my $node;
        __CODE{tx|createGEForTest:: $gent => $node}__;

        $test->id ('initial');
        $test->assert_null ($node-><AG::Entity.publicId>);

        $test->id ('set');
        $node-><AS::Entity.publicId> ('utf-8');
        $test->assert_equals ($node-><AG::Entity.publicId>, 'utf-8');

        $test->id ('reset');
        $node-><AS::Entity.publicId> (null);
        $test->assert_null ($node-><AG::Entity.publicId>);

  @Attr:
    @@Name: systemId
    @@enDesc:
      The system identifier associated with the entity.
      This may or may not be an absolute URI.
    @@Type: DOMString
    @@nullCase:
      @@@enDesc:
        No system identifier is associated.
    @@Get:
      @@@PerlDef:
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $r,
          $prop => {<H::infoset|systemIdentifier>},
          $ref => {$self},
        }__;
    @@LXSet:
      @@@enDesc:
        Sets the attribute value.  No lexical checking is performed
        on setting.
      @@@nullCase:
        @@@@enDesc:
          Sets <DOM::null> as the attribute value.
      @@@NodeReadOnlyError:
      @@@PerlDef:
        __CODE{tc|NodeReadOnlyError:: $node => $self}__;
        __CODE{mg|setNodeStemPropValue||ManakaiDOM|all::
          $given => $given,
          $prop => {<H::infoset|systemIdentifier>},
          $ref => $self,
        }__;

    @@Test:
      @@@QName: Entity.systemId.test
      @@@PerlDef:
        my $node;
        __CODE{tx|createGEForTest:: $gent => $node}__;

        $test->id ('initial');
        $test->assert_null ($node-><AG::Entity.systemId>);

        $test->id ('set');
        $node-><AS::Entity.systemId> ('utf-8');
        $test->assert_equals ($node-><AG::Entity.systemId>, 'utf-8');

        $test->id ('reset');
        $node-><AS::Entity.systemId> (null);
        $test->assert_null ($node-><AG::Entity.systemId>);

  @L3Attr:
    @@Name: xmlEncoding
    @@enDesc:
      The encoding of the entity specified in the text declaration.
    @@nullCase:
      @@@enDesc:
        If it is an external parsed entity.
    @@nullCase:
      @@@enDesc:
        If there is no text declaration.  <SRC::manakai>
    @@Type: DOMString
    @@Get:
      @@@PerlDef:
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $r,
          $prop => {<H::c|xmlEncoding>},
          $ref => {$self},
        }__;
    @@LXSet:
      @@@enDesc:
        Sets the attribute value.  No lexical checking is performed
        on setting.
      @@@nullCase:
        @@@@enDesc:
          Sets <DOM::null> as the attribute value.
      @@@NodeReadOnlyError:
      @@@PerlDef:
        __CODE{tc|NodeReadOnlyError:: $node => $self}__;
        __CODE{mg|setNodeStemPropValue||ManakaiDOM|all::
          $given => $given,
          $prop => {<H::c|xmlEncoding>},
          $ref => $self,
        }__;

    @@Test:
      @@@QName: Entity.xmlEncoding.test
      @@@PerlDef:
        my $node;
        __CODE{tx|createGEForTest:: $gent => $node}__;

        $test->id ('initial');
        $test->assert_null ($node-><AG::Entity.xmlEncoding>);

        $test->id ('set');
        $node-><AS::Entity.xmlEncoding> ('utf-8');
        $test->assert_equals ($node-><AG::Entity.xmlEncoding>, 'utf-8');

        $test->id ('reset');
        $node-><AS::Entity.xmlEncoding> (null);
        $test->assert_null ($node-><AG::Entity.xmlEncoding>);

  @L3Attr:
    @@Name: xmlVersion
    @@enDesc:
      The XML version of the entity specified in the text declaration.
    @@nullCase:
      @@@enDesc:
        If it is not an exparsed entity.
    @@nullCase:
      @@@enDesc:
        If the entity has no text declaration.  <SRC::manakai>
      @@@enImplNote:
        Should any default value provided? Or <DOM::null>?
    @@enImplNote:
      XML 1.0 documents cannot include the external parsed entities 
      other than those versioned as XML 1.0.  XML 1.1 document 
      can use both XML 1.0 and XML 1.1 entities, but both interpreted 
      as XML 1.1 entities.
    @@Type: DOMString
    @@Get:
      @@@PerlDef:
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $r,
          $prop => {<H::infoset|version>},
          $ref => {$self},
        }__;
    @@LXSet:
      @@@enDesc:
        Sets the attribute value.  No lexical checking is performed
        on setting.
      @@@nullCase:
        @@@@enDesc:
          Sets <DOM::null> as the attribute value.
      @@@NodeReadOnlyError:
      @@@PerlDef:
        __CODE{tc|NodeReadOnlyError:: $node => $self}__;
        __CODE{mg|setNodeStemPropValue||ManakaiDOM|all::
          $given => $given,
          $prop => {<H::infoset|version>},
          $ref => $self,
        }__;
      @@@enImplNote:
        {ISSUE::
          Should <X::c|DOMException.NOT_SUPPORTED_ERR> be thrown?
        }

    @@Test:
      @@@QName: Entity.xmlVersion.test
      @@@PerlDef:
        my $node;
        __CODE{tx|createGEForTest:: $gent => $node}__;

        $test->id ('initial');
        $test->assert_null ($node-><AG::Entity.xmlVersion>);

        $test->id ('set');
        $node-><AS::Entity.xmlVersion> ('1.0');
        $test->assert_equals ($node-><AG::Entity.xmlVersion>, '1.0');

        $test->id ('reset');
        $node-><AS::Entity.xmlVersion> (null);
        $test->assert_null ($node-><AG::Entity.xmlVersion>);

  @LXAttr:
    @@Name: manakaiDeclarationBaseURI
    @@enDesc:
      The base DOM URI of the entity declaration by which the entity
      is declared.

        {NOTE::
           This attribute is a manakai extension similar to
           the <InfoProp::declaration base URI> property
           of the XML Information Set.
        }
    @@Type: DOMString
    @@dis:actualType: ManakaiDOM|ManakaiDOMURI
    @@Get:
      @@@enDesc:
        The declaration base DOM URI.  If there is no explicit
        base DOM URI information attached to the node, then
        the base DOM URI of the node, i.e. <A::Node.baseURI>
        is returned.
      @@@nullCase:
        @@@@enDesc:
          If there is no explicit base URI information and
          the <A::Node.baseURI> attribute contains <DOM::null>.
      @@@PerlDef:
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $r,
          $prop => {<H::infoset|declarationBaseURI>},
          $ref => {$self},
        }__;
        unless (defined $r) {
          __DEEP{
            $r = $self-><AG::Node.baseURI>;
          }__;
        }
    @@Set:
      @@@enDesc:
        The declaration base DOM URI.  It <kwd:MUST> be an absolute
        DOM URI; however, no lexical checking is performed on 
        the setting.  In addition, it does not change <A::Entity.systemId>
        nor does the replacement subtree or any of entity reference
        in the document.
      @@@nullCase:
        @@@@enDesc:
          The declaration base DOM URI is unset.  It does
          not affect to the base DOM URI of the node or entity.
      @@@NodeReadOnlyError:
      @@@PerlDef:
        __CODE{tc|NodeReadOnlyError:: $node => $self}__;
        __CODE{mg|setNodeStemPropValue||ManakaiDOM|all::
          $given => $given,
          $prop => {<H::infoset|declarationBaseURI>},
          $ref => $self,
        }__;

    @@XDTest:
      @@@QName: Entity.declBaseURI.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $dx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $ent = $dx-><M::DocumentX.createGeneralEntity> ('ent');

        $test->id ('initial');
        $test->assert_null ($ent-><AG::Entity.manakaiDeclarationBaseURI>);

        $test->id ('doc');
        $doc-><AS::Document.documentURI> (q<http://www.example/>);
        $test->assert_equals 
                 ($ent-><AG::Entity.manakaiDeclarationBaseURI>,
                  q<http://www.example/>);
        
        $test->id ('set');
        $ent-><AS::Entity.manakaiDeclarationBaseURI> (q<ftp://www.example/>);
        $test->assert_equals
                 ($ent-><AG::Entity.manakaiDeclarationBaseURI>,
                  q<ftp://www.example/>);
        $test->assert_equals
                 ($ent-><AG::Node.baseURI>,
                  q<http://www.example/>);

        $test->id ('unset');
        $ent-><AS::Entity.manakaiDeclarationBaseURI> (null);
        $test->assert_equals
                 ($ent-><AG::Entity.manakaiDeclarationBaseURI>,
                  q<http://www.example/>);

  @LXAttr:
    @@Name: manakaiEntityBaseURI
    @@enDesc:
      The base DOM URI of the entity.

        {NOTE::
           This attribute is a manakai extension.
        }
    @@Type: DOMString
    @@dis:actualType: ManakaiDOM|ManakaiDOMURI
    @@Get:
      @@@enDesc:
        The base DOM URI of the entity.

          = If there is an explicit base DOM URI for the entity,
            then return it.

          = If <A::Entity.manakaiEntityURI> of the node contains a
            non-<DOM::null> value, then return it.

          = Otherwise, return <A::Node.baseURI> of the node.

            {NOTE::
              Therefore, the entity base URI for internal general
              entities are same as one for the document.
            }

            {ISSUE::
              Entity base URI for parameter entities
            }
      @@@nullCase:
        @@@@enDesc:
          If there is no explicit base URI or entity URI information and
          the <A::Node.baseURI> attribute contains <DOM::null>.
      @@@PerlDef:
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $r,
          $prop => {<H::tx|entityBaseURI>},
          $ref => {$self},
        }__;
        unless (defined $r) {
          __DEEP{
            $r = $self-><AG::Entity.manakaiEntityURI>;
            $r = $self-><AG::Node.baseURI> unless defined $r;
          }__;
        }
    @@Set:
      @@@enDesc:
        Sets the entity base DOM URI explicitly.  It <kwd:MUST> be an absolute
        DOM URI; however, no lexical checking is performed on 
        the setting.  In addition, it does not change <A::Entity.systemId>
        nor does the replacement subtree (except that
        the base URI of nodes in the replacement subtree might
        be changed according to the new entity base URI) or any of
        entity reference in the document.
      @@@nullCase:
        @@@@enDesc:
          The entity base DOM URI is unset.  It does
          not affect to the <A::Entity.systemId> or <A::Node.baseURI> of
          the node or the document.
      @@@NodeReadOnlyError:
      @@@PerlDef:
        __CODE{tc|NodeReadOnlyError:: $node => $self}__;
        __CODE{mg|setNodeStemPropValue||ManakaiDOM|all::
          $given => $given,
          $prop => {<H::tx|entityBaseURI>},
          $ref => $self,
        }__;

    @@XDTest:
      @@@QName: Entity.entBaseURI.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $dx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $ent = $dx-><M::DocumentX.createGeneralEntity> ('ent');

        $test->id ('initial');
        $test->assert_null ($ent-><AG::Entity.manakaiEntityBaseURI>);

        $test->id ('doc');
        $doc-><AS::Document.documentURI> (q<http://www.example/>);
        $test->assert_equals 
                 ($ent-><AG::Entity.manakaiEntityBaseURI>,
                  q<http://www.example/>);
        
        $test->id ('set');
        $ent-><AS::Entity.manakaiEntityBaseURI> (q<ftp://www.example/>);
        $test->assert_equals
                 ($ent-><AG::Entity.manakaiEntityBaseURI>,
                  q<ftp://www.example/>);
        $test->assert_equals
                 ($ent-><AG::Node.baseURI>,
                  q<http://www.example/>);

        $test->id ('unset');
        $ent-><AS::Entity.manakaiEntityBaseURI> (null);
        $test->assert_equals
                 ($ent-><AG::Entity.manakaiEntityBaseURI>,
                  q<http://www.example/>);

        $test->id ('euri.set');
        $ent-><AS::Entity.manakaiEntityURI> (q<https://www.example/>);
        $test->assert_equals
                 ($ent-><AG::Entity.manakaiEntityBaseURI>,
                  q<https://www.example/>);
        $test->assert_equals
                 ($ent-><AG::Node.baseURI>,
                  q<http://www.example/>);

        $test->id ('euri.unset');
        $ent-><AS::Entity.manakaiEntityURI> (null);
        $test->assert_equals
                 ($ent-><AG::Entity.manakaiEntityBaseURI>,
                  q<http://www.example/>);

  @LXAttr:
    @@Name: manakaiEntityURI
    @@enDesc:
      The URI of the entity.

        {NOTE::
           It might or might not be equal to the <A::Entity.systemId>
           or the absolute URI resolved from <A::Entity.systemId>
           against <A::Entity.manakaiDeclarationBaseURI>.  In particular,
           a catalog mechanism is used or a redirection is encountered during
           the entity resolution phase of the parsing, the entity
           URI is typically different from the system identifier.
        }
    @@Type: DOMString
    @@dis:actualType: ManakaiDOM|ManakaiDOMURI
    @@Get:
      @@@enDesc:
        The DOM URI of the entity.

        If the DOM URI of the entity is explicitly set by application
        or during the tree construction, then it is returned.

        Otherwise and the <A::Entity.systemId> attribute contains
        a non-<DOM::null> value, then its value, resolved against
        the <A::Entity.manakaiDeclarationBaseURI> if necessary,
        is returned.  If the <A::Entity.manakaiDeclarationBaseURI>
        is <DOM::null>, then the result is implementation dependent.
      @@@nullCase:
        @@@@enDesc:
          If the DOM URI of the entity is not found.  If the entity
          is an internal entity and not modified since the tree construction,
          the entity URI must be <DOM::null>.
      @@@PerlDef:
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $r,
          $prop => {<H::tx|entityURI>},
          $ref => {$self},
        }__;
        unless (defined $r) {
          __DEEP{
            $r = $self-><AG::Entity.systemId>;
            if (defined $r) {
              if (<Code::DOMMain:isRelativeDOMURI:: $INPUT = $r>) {
                my $base = $self-><AG::Entity.manakaiDeclarationBaseURI>;
                $r = $self-><AG::Node.ownerDocument>
                          -><AG::Document.implementation>
                          -><M::urigen|URIImplementation.createURIReference>
                              ($r)
                          -><M::urigen|URIReference.getAbsoluteReference>
                              ($base)
                          -><AG::urigen|URIReference.uriReference>
                  if defined $base;
              }
            } else {
              $r = null;
            }
          }__;
        }
    @@Set:
      @@@enDesc:
        Sets the entity DOM URI of the node.
      @@@nullCase:
        @@@@enDesc:
          Removes explicitly set entity DOM URI for the node if any.
          It does not affect on the base URI or the system identifier.
      @@@NodeReadOnlyError:
      @@@PerlDef:
        __CODE{tc|NodeReadOnlyError:: $node => $self}__;
        __CODE{mg|setNodeStemPropValue||ManakaiDOM|all::
          $given => $given,
          $prop => {<H::tx|entityURI>},
          $ref => $self,
        }__;

    @@XDTest:
      @@@QName: Entity.entURI.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $dx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $ent = $dx-><M::DocumentX.createGeneralEntity> ('ent');

        $test->id ('initial');
        $test->assert_null ($ent-><AG::Entity.manakaiEntityURI>);

        $test->id ('doc');
        $doc-><AS::Document.documentURI> (q<http://www.document.example/>);
        $test->assert_null ($ent-><AG::Entity.manakaiEntityURI>);
        
        $test->id ('dburi');
        $ent-><AS::Entity.manakaiDeclarationBaseURI> (q<http://decl.example/>);
        $test->assert_null ($ent-><AG::Entity.manakaiEntityURI>);

        $test->id ('sys');
        $ent-><AS::Entity.systemId> (q<sysid>);
        $test->assert_equals
                 ($ent-><AG::Entity.manakaiEntityURI>,
                  q<http://decl.example/sysid>);

        $test->id ('set');
        $ent-><AS::Entity.manakaiEntityURI> (q<http://enturi.example/>);
        $test->assert_equals
                 ($ent-><AG::Entity.manakaiEntityURI>,
                  q<http://enturi.example/>);

        $test->id ('unset');
        $ent-><AS::Entity.manakaiEntityURI> (null);
        $test->assert_equals
                 ($ent-><AG::Entity.manakaiEntityURI>,
                  q<http://decl.example/sysid>);

  @LXAttr:
    @@Name: hasReplacementTree
    @@enDesc:
      Whether the structure of the replacement text is available
      via the child list of the node or not.

      When the replacement text of a general entity is available,
      the corresponding <IF::Entity> node's child list represents
      the structure of the replacement value.  Otherwise, the child
      list is empty.

        {NOTE::
          When this attribute contains <DOM::false> value, then
          the child list of the node, even if it is not empty, 
          should be ignored for e.g. creation of an entity reference
          subtree or serialization.
        }
    @@Type: idl|boolean||ManakaiDOM|all
    @@Get:
      @@@TrueCase:
        @@@@enDesc:
          If the entity is a general parsed entity and whose
          replacement tree is available.
      @@@FalseCase:
        @@@@enDesc:
          Otherwise.
      @@@PerlDef:
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $r,
          $prop => {<H::tx|hasReplacementTree>},
          $ref => {$self},
        }__;
    @@Set:
      @@@NodeReadOnlyError:
      @@@PerlDef:
        __CODE{tc|NodeReadOnlyError:: $node => $self}__;
        __CODE{mg|setNodeStemPropValue||ManakaiDOM|all::
          $given => $given,
          $prop => {<H::tx|hasReplacementTree>},
          $ref => $self,
        }__;

  @LXAttr:
    @@Name: ownerDocumentTypeDefinition
    @@enDesc:
      The document type definition node to which the entity is attached.
    @@Type: d|DocumentTypeDefinition
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          The entity is not attached to any document type.
      @@@disDef:
        @@@@DISPerl:cloneCode:
          ManakaiDOMNotation.ownerDocumentTypeDefinition.get

    @@XDTest:
      @@@QName: Entity.ownerDTDef.test
      @@@PerlDef:
        my $et;
        __CODE{tx|createGEForTest:: $gent => $et}__;
 
        my $odt = $et-><AG::Entity.ownerDocumentTypeDefinition>;
        $test->assert_null ($odt);

        my $dt = $et-><AG::Node.ownerDocument>
                     -><M::Node.getFeature> (<Q::fe|XDoctype>)
                     -><M::DocumentX.createDocumentTypeDefinition>
                         ('dt1');
        $test->assert_not_null ($dt);
        $dt-><M::d|DocumentTypeDefinition.setGeneralEntityNode> ($et);

        my $odt2 = $et-><AG::Entity.ownerDocumentTypeDefinition>;
        $test->assert_not_null ($odt2);
        $test->assert_isa ($odt2, <IFName::d|DocumentTypeDefinition>);
        $test->assert_equals ($odt2, $dt);

  @LXAttr:
    @@Name: isExternallyDeclared
    @@enDesc:
      Whether the entity is declared by an external markup declaration,
      i.e. a markup declaration occuring in the external subset or
      in a parameter entity.
    @@Type: boolean
    @@TrueCase:
      @@@enDesc:
        If the entity is declared by an external markup declaration.
    @@FalseCase:
      @@@enDesc:
        If the entity is declared by a markup declaration in
        the internal subset, or if the <IF::Entity> node
        is created in memory.
    @@Get:
      @@@PerlDef:
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $r,
          $prop => {<H::tx|externalDeclaration>},
          $ref => {$self},
        }__;
    @@Set:
      @@@NodeReadOnlyError:
      @@@PerlDef:
        __CODE{tc|NodeReadOnlyError:: $node => $self}__;
        __CODE{mg|setNodeStemPropValue||ManakaiDOM|all::
          $given => $given,
          $prop => {<H::tx|externalDeclaration>},
          $ref => $self,
        }__;

    @@XDTest:
      @@@QName: Entity.isExternallyDeclared.test
      @@@PerlDef:
        my $et;
        __CODE{tx|createGEForTest:: $gent => $et}__;

        $test->id ('default');
        $test->assert_false ($et-><AG::Entity.isExternallyDeclared>);

        $test->id ('set.true');
        $et-><AS::Entity.isExternallyDeclared> (true);
        $test->assert_true ($et-><AG::Entity.isExternallyDeclared>);

        $test->id ('set.false');
        $et-><AS::Entity.isExternallyDeclared> (false);
        $test->assert_false ($et-><AG::Entity.isExternallyDeclared>);
##Entity

NodeTypeDef:
  @IFQName: EntityReference
  @ClsQName: ManakaiDOMEntityReference

  @enDesc:
    An <IF::EntityReference> node represents an entity reference
    in the document.

      {NOTE::
        Character references and predefined entity references
        are considered to be expanded by the HTML or XML
        processor so that characters are represented by (part of)
        <IF::Text> node rather than by an <IF::EntityReference> node.
        Moreover, the XML processor may completely expand
        entity references while building the document tree,
        instead of providing <IF::EntityReference> node.
      }

    If an <IF::EntityReference> node represents a reference to
    known entity an <IF::Entity> node exists, the subtree
    of the <IF::EntityReference> node is a copy of the <IF::Entity>
    node subtree.  However, when an entity contains an unbound
    namespace prefix, the descandants of the <IF::EntityReference>
    node may be bound to different namespace URIs.  <SRC::DOM2, DOM3>

    If an <IF::EntityReference> node represents a reference to
    an unknown entity, the node has no children and its replacement
    value, when used by <A::Attr.value> for example, is empty.
    <SRC::DOM3>

    The resolution of the children of the <IF::EntityReference>
    (the replacement value of the referenced <IF::Entity>) may
    be lazily evaluated; actions by the user (such as retrieveing
    the <A::Node.childNodes> value on the <IF::EntityReference>
    node) are assumed to trigger the evaluation.  <SRC::DOM1>

      {NOTE::
        <IF::EntityReference> nodes may cause normalization problems
        when the normalization is performed after entity references
        are expanded.
      }
  
    In DOM levels 3 or earlier, <IF::EntityReference> nodes
    and their descendants are read-only.

    However, in the manakai's implementation, they can be modified
    by removing their read-only flag by the <M::Node.manakaiSetReadOnly>
    method.  In this case, <IF::EntityReference> nodes might end in 
    inconsistent with the corresponding <IF::Entity> nodes.  The
    <M::Document.normalizeDocument> method with appropriate 
    configuration parameters can be used to remove such incosistency.
  
  @IntMethod:
    @@Operator: mg|CreateNodeStemMethod
    @@Param:
      @@@Name: bag
      @@@Type: HASH
    @@Param:
      @@@Name: obj
      @@@Type: HASH
    @@Param:
      @@@Name: opt
      @@@Type: HASH
    @@Return:
      @@@Type: HASH
      @@@PerlDef:
        $obj->{<H::infoset|children>} = [];
        __CODE{DISPerl|HashStringRef||ManakaiDOM|all::
          $result => {$obj->{<H::infoset|name>}},
          $given => {${$opt->{<H::infoset|name>}}},
        }__;
        __CODE{mg|setOwnerProp||ManakaiDOM|all::
          $bag => $bag,
          $ownerref => {$opt->{<H::tc|ownerDocument>}},
          $ownee1hprop => {<H::tc|revOwnerDocument>},
          $ownee => {$obj},
          $owner0prop => {<H::tc|ownerDocument>},
        }__;
        $r = $obj;
  @mg:subnode1a: infoset|children
  @mg:owner0: tc|ownerDocument
  @mg:origin0: infoset|parent

  @enImplNote:
    @@ddid: props
    @@@:
      {P:: Required internal properties:

         - <Q::tc|ownerDocument>.

         - <Q::infoset|name>.

         - <Q::infoset|children>.

      }

      {P:: Optional internal properties:

         - <Q::infoset|parent>, <Q::tx|expanded>.

         - <Q::tx|isExternalEntity>, <Q::tx|entityBaseURI>.

         - <Q::c|read-only>.

         - <Q::infoset|declarationBaseURI>, <Q::infoset|publicIdentifier>,
           <Q::infoset|systemIdentifier>.
 
      }

  @CODE:
    @@QName: tx|createERForTest
    @@PerlDef:
      my $__doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $__doc}__;
      $er = $__doc-><M::Document.createEntityReference> ('er');
      $er-><M::Node.manakaiSetReadOnly> (false, true);
  @CODE:
    @@QName: tx|createROERForTest
    @@PerlDef:
      my $__doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $__doc}__;
      $er = $__doc-><M::Document.createEntityReference> ('er');

  @CAttr:
    @@Name: nodeType
    @@Type: unsignedShort
    @@dis:actualType: tc|NodeType
    @@Get:
      @@@disDef:
        @@@@DISLang:constValue: Node.ENTITY_REFERENCE_NODE

    @@Test:
      @@@QName: ER.nodeType.test
      @@@PerlDef:
        my $er;
        __CODE{tx|createERForTest:: $er => $er}__;

        $test->id ('nodeType');
        $test->assert_num_equals
                 (actual_value => $er-><AG::Node.nodeType>,
                  expected_value => <C::Node.ENTITY_REFERENCE_NODE>);

  @Test:
    @@QName: ER.parentNode.1.test
    @@PerlDef:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

      my $df = $doc-><M::Document.createEntityReference> ('entity');

      $test->assert_null ($df-><AG::Node.parentNode>);

  @Test:
    @@QName: ER.isSameNode.1.test
    @@PerlDef:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

      my $el = $doc-><M::Document.createEntityReference> ('entity');

      my $el2 = $doc-><M::Document.createEntityReference> ('entity');
      
      $test->id ('same');
      $test->assert_equals ($el, $el);
      
      $test->id ('diff');
      $test->assert_not_equals ($el, $el2);
      
      $test->id ('doc');
      $test->assert_not_equals ($el, $doc);
  @Test:
    @@QName: ER.isSameNode.2.test
    @@PerlDef:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

      my $el = $doc-><M::Document.createEntityReference> ('entity');

      my $el2 = $doc-><M::Document.createEntityReference> ('entity');
      
      $test->id ('same');
      $test->assert_true ($el-><M::Node.isSameNode> ($el));
      
      $test->id ('diff');
      $test->assert_false ($el-><M::Node.isSameNode> ($el2));
      
      $test->id ('doc');
      $test->assert_false ($el-><M::Node.isSameNode> ($doc));

  @LXTest:
    @@QName: ER.readOnly.test
    @@PerlDef:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

      my $el = $doc-><M::Document.createEntityReference> ('entity');

      $test->id ('default');
      $test->assert_true ($el-><AG::Node.manakaiReadOnly>);

  @CMethod:
    @@Name: appendChild
    @@enDesc:
      Adds a node to the end of the list of children of the node.
      If that node is already in the tree, it is first removed.
    @@Param:
      @@@Name: newChild
      @@@Type: Node
      @@@enDesc:
        The node to add.
      @@@InCase:
        @@@@Type: tc|DocumentFragment
        @@@@enDesc:
          The entire contents of the document fragment are
          moved into the child list of the node.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node added.  If the <P::newChild> node is a <IF::tc|DocumentFragment>
        node, then the <P::newChild> node <kwd:MUST> be returned.
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_BAD_TYPE
        @@@@enDesc:
          If the node is of a type that does not allow children of
          the type of the <P::newChild> node.
 
          If the <A::Document.strictErrorChecking> is set to <DOM::false>,
          this exception <kwd:MAY-NOT> be thrown.
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_ANCESTOR_OR_SELF
        @@@@enDesc:
          If the <P::newChild> node is one of the node's ancestor
          <SRC::DOM 1, 2, 3> or the node itself <SRC::DOM 2 Errata, DOM 3>.
      @@@dx:raises:
        @@@@@: c|DIFFERENT_DOCUMENT_ERR
        @@@@enDesc:
          If the <P::newChild> node was created from a different
          document than the one to which the node was created or
          the node does not belong to any document.

          If the <A::Document.strictErrorChecking> is set to <DOM::false>,
          this exception <kwd:MAY-NOT> be thrown.
      @@@dx:raises: 
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the node is read-only.

          If the <A::Document.strictErrorChecking> is set to <DOM::false>,
          this exception <kwd:MAY-NOT> be thrown.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_SRC_PARENT
        @@@@enDesc:
          If the previous parent of the <P::newChild> node is read-only
          <SRC::DOM 2 Errata, DOM 3>.

          If the <A::Document.strictErrorChecking> is set to <DOM::false>,
          this exception <kwd:MAY-NOT> be thrown.
      @@@disDef:
        @@@@DISPerl:cloneCode: ManakaiDOMEntity.appendChild

  @CMethod:
    @@Name: insertBefore
    @@enDesc:
      Inserts a node before the existing child node of the node.

      Inserting a node before itself is implementation dependent.
    @@Param:
      @@@Name: newChild
      @@@Type: Node
      @@@enDesc:
        The node to insert.  If the <P::newChild> is already in 
        the tree, it is first removed.
      @@@InCase:
        @@@@Type: tc|DocumentFragment
        @@@@enDesc:
          All of children of the <P::newChild> node are inserted,
          in the same order, before <P::refChild>.
    @@Param:
      @@@Name: refChild
      @@@Type: Node
      @@@enDesc:
        The reference node, i.e. the node before which the new node
        must be inserted.
      @@@nullCase:
        @@@@enDesc:
          The <P::newChild> node is inserted at the end of the list
          of children.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node being inserted.
      @@@enImplNote:
        What is returned if <P::newChild> is a <IF::tc|DocumentFragment>?
        See also <M::Node.appendChild>'s return value.
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_BAD_TYPE
        @@@@enDesc:
          If the node is of a type that does not allow children of
          the type of the <P::newChild> node.
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_ANCESTOR_OR_SELF
        @@@@enDesc:
          If the <P::newChild> node is one of the node's ancestor
          <SRC::DOM 1, 2, 3> or the node itself <SRC::DOM 2 Errata, DOM 3>.
      @@@dx:raises:
        @@@@@: c|DIFFERENT_DOCUMENT_ERR
        @@@@enDesc:
          If the <P::newChild> node was created from a different
          document than the one that created the node.
        @@@@enImplNote:
          The DOM specification ignores the fact that <IF::Document>s
          and <IF::DocumentType>s are created from 
          <IF::c|DOMImplementation> :-)
      @@@dx:raises: 
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the node is read-only.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_SRC_PARENT
        @@@@enDesc:
          If the previous parent of the <P::newChild> node is read-only
          <SRC::DOM 1 SE, DOM 2, 3>.
      @@@dx:raises:
        @@@@@: c|NOT_CHILD_ERR
        @@@@enDesc:
          If the <P::refChild> node is not a child of the node.
      @@@c:reports:
        @@@@@: t|insert-before-itself
        @@@@enDesc:
          If the <P::newChild> node is same as the <P::refChild> node.
          Then, the result is implementation dependent.
      @@@disDef:
        @@@@DISPerl:cloneCode: ManakaiDOMEntity.insertBefore

  @CMethod:
    @@Name: replaceChild
    @@enDesc:
      Replaces a child node with another node.

      Replacing a node with itself is implementation dependent <SRC::DOM3>.
    @@Param:
      @@@Name: newChild
      @@@Type: Node
      @@@enDesc:
        The new node to put in the child list.

        If the <P::newChild> node is already in the tree,
        it is first removed.
      @@@InCase:
        @@@@Type: tc|DocumentFragment
        @@@@enDesc:
          The <P::oldChild> node is replaced by all of the 
          <IF::tc|DocumentFragment> children, which are inserted
          in the same order <SRC::DOM1 SE, DOM2, DOM3>.
    @@Param:
      @@@Name: oldChild
      @@@Type: Node
      @@@enDesc:
        The node being replaced in the list.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node replaced.
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_BAD_TYPE
        @@@@enDesc:
          If the node is of a type that does not allow children of
          the type of the <P::newChild> node.
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_ANCESTOR_OR_SELF
        @@@@enDesc:
          If the <P::newChild> node is one of the node's ancestor
          <SRC::DOM 1, 2, 3> or the node itself <SRC::DOM 2 Errata, DOM 3>.
      @@@dx:raises:
        @@@@@: c|DIFFERENT_DOCUMENT_ERR
        @@@@enDesc:
          If the <P::newChild> node was created from a different
          document than the one that created the node.
        @@@@enImplNote:
          The DOM specification ignores the fact that <IF::Document>s
          and <IF::DocumentType>s are created from 
          <IF::c|DOMImplementation> :-)
      @@@dx:raises: 
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the node is read-only.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_SRC_PARENT
        @@@@enDesc:
          If the previous parent of the <P::newChild> node is read-only
          <SRC::DOM1 SE, DOM2, DOM3>.
      @@@dx:raises:
        @@@@@: c|NOT_CHILD_ERR
        @@@@enDesc:
          If the <P::oldChild> node is not a child of the node.
      @@@c:reports:
        @@@@@: t|replaced-by-itself
        @@@@enDesc:
          If the <P::newChild> node is same as the <P::oldChild> node.
          Then, the result is implementation dependent.
      @@@disDef:
        @@@@DISPerl:cloneCode: ManakaiDOMEntity.replaceChild

    @@Test:
      @@@QName: EntityRef.appendChild.1.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createEntityReference> ('dt');
        $dtd-><M::Node.manakaiSetReadOnly> (false, true);
        my $pi = $doc-><M::Document.createTextNode> ('pi');

        my $return = $dtd-><M::Node.appendChild> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: EntityRef.appendChild.1.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createEntityReference> ('dt');
        $dtd-><M::Node.manakaiSetReadOnly> (false, true);
        my $pi = $doc-><M::Document.createEntityReference> ('pi');

        my $return = $dtd-><M::Node.appendChild> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|EntityReference>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: EntityRef.appendChild.1.3.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createEntityReference> ('dt');
        $dtd-><M::Node.manakaiSetReadOnly> (false, true);
        my $pi = $doc-><M::Document.createElement> ('pi');

        my $return = $dtd-><M::Node.appendChild> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tc|Element>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: EntityRef.appendChild.1.4.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createEntityReference> ('dt');
        $dtd-><M::Node.manakaiSetReadOnly> (false, true);
        my $pi = $doc-><M::Document.createProcessingInstruction> ('pi');

        my $return = $dtd-><M::Node.appendChild> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|ProcessingInstruction>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: EntityRef.appendChild.1.5.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createEntityReference> ('dt');
        $dtd-><M::Node.manakaiSetReadOnly> (false, true);
        my $pi = $doc-><M::Document.createCDATASection> ('pi');

        my $return = $dtd-><M::Node.appendChild> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|CDATASection>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: EntityRef.appendChild.1.6.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createEntityReference> ('dt');
        $dtd-><M::Node.manakaiSetReadOnly> (false, true);
        my $pi = $doc-><M::Document.createComment> ('pi');

        my $return = $dtd-><M::Node.appendChild> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tc|Comment>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: EntityRef.insertBefore.1.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createEntityReference> ('dt');
        $dtd-><M::Node.manakaiSetReadOnly> (false, true);
        my $pi = $doc-><M::Document.createTextNode> ('pi');

        my $return = $dtd-><M::Node.insertBefore> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: EntityRef.insertBefore.1.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createEntityReference> ('dt');
        $dtd-><M::Node.manakaiSetReadOnly> (false, true);
        my $pi = $doc-><M::Document.createEntityReference> ('pi');

        my $return = $dtd-><M::Node.insertBefore> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|EntityReference>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: EntityRef.insertBefore.1.3.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createEntityReference> ('dt');
        $dtd-><M::Node.manakaiSetReadOnly> (false, true);
        my $pi = $doc-><M::Document.createElement> ('pi');

        my $return = $dtd-><M::Node.insertBefore> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tc|Element>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: EntityRef.insertBefore.1.4.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createEntityReference> ('dt');
        $dtd-><M::Node.manakaiSetReadOnly> (false, true);
        my $pi = $doc-><M::Document.createProcessingInstruction> ('pi');

        my $return = $dtd-><M::Node.insertBefore> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|ProcessingInstruction>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: EntityRef.insertBefore.1.5.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createEntityReference> ('dt');
        $dtd-><M::Node.manakaiSetReadOnly> (false, true);
        my $pi = $doc-><M::Document.createCDATASection> ('pi');

        my $return = $dtd-><M::Node.insertBefore> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|CDATASection>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: EntityRef.insertBefore.1.6.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createEntityReference> ('dt');
        $dtd-><M::Node.manakaiSetReadOnly> (false, true);
        my $pi = $doc-><M::Document.createComment> ('pi');

        my $return = $dtd-><M::Node.insertBefore> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tc|Comment>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);

    @@Test:
      @@@QName: EntityRef.appendChild.has.parent.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createEntityReference> ('dt');
        $dtd-><M::Node.manakaiSetReadOnly> (false, true);

        my $piparent = $doc-><M::Document.createElementNS> (null, 'e');
        my $pi = $doc-><M::Document.createTextNode> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.appendChild> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: EntityRef.appendChild.has.parent.1.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createEntityReference> ('dt');
        $dtd-><M::Node.manakaiSetReadOnly> (false, true);

        my $piparent = $doc-><M::Document.createElementNS> (null, 'e');
        my $pi = $doc-><M::Document.createEntityReference> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.appendChild> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|EntityReference>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: EntityRef.insertBefore.has.parent.1.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createEntityReference> ('dt');
        $dtd-><M::Node.manakaiSetReadOnly> (false, true);

        my $piparent = $doc-><M::Document.createElementNS> (null, 'e');
        my $pi = $doc-><M::Document.createTextNode> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.insertBefore> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: EntityRef.insertBefore.has.parent.1.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createEntityReference> ('dt');
        $dtd-><M::Node.manakaiSetReadOnly> (false, true);

        my $piparent = $doc-><M::Document.createElementNS> (null, 'e');
        my $pi = $doc-><M::Document.createEntityReference> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.insertBefore> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|EntityReference>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi);

    @@Test:
      @@@QName: EntityRef.appendChild.documentfragment.1.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createEntityReference> ('dt');
        $dtd-><M::Node.manakaiSetReadOnly> (false, true);

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createTextNode> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.appendChild> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: EntityRef.appendChild.documentfragment.1.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createEntityReference> ('dt');
        $dtd-><M::Node.manakaiSetReadOnly> (false, true);

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createEntityReference> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.appendChild> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|EntityReference>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: EntityRef.insertBefore.documentfragment.1.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createEntityReference> ('dt');
        $dtd-><M::Node.manakaiSetReadOnly> (false, true);

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createTextNode> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.insertBefore> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: EntityRef.insertBefore.documentfragment.1.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createEntityReference> ('dt');
        $dtd-><M::Node.manakaiSetReadOnly> (false, true);

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createEntityReference> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.insertBefore> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|EntityReference>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: EntityRef.replaceChild.documentfragment.1.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createEntityReference> ('dt');
        $dtd-><M::Node.manakaiSetReadOnly> (false, true);
        my $pi0 = $doc-><M::Document.createTextNode> ('pi0');
        $dtd-><M::Node.appendChild> ($pi0);

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createTextNode> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.replaceChild> ($piparent, $pi0);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi0);
    @@Test:
      @@@QName: EntityRef.replaceChild.documentfragment.1.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createEntityReference> ('dt');
        $dtd-><M::Node.manakaiSetReadOnly> (false, true);
        my $pi0 = $doc-><M::Document.createTextNode> ('pi0');
        $dtd-><M::Node.appendChild> ($pi0);

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createEntityReference> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.replaceChild> ($piparent, $pi0);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|EntityReference>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi0);

    @@Test:
      @@@QName: EntityRef.appendChild.documentfragment.2.1.test
      @@@enDesc:
        Empty document fragment.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createEntityReference> ('dt');
        $dtd-><M::Node.manakaiSetReadOnly> (false, true);

        my $piparent = $doc-><M::Document.createDocumentFragment>;

        my $return = $dtd-><M::Node.appendChild> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 0);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: EntityRef.insertBefore.documentfragment.2.test
      @@@enDesc:
        Empty document fragment.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createEntityReference> ('dt');
        $dtd-><M::Node.manakaiSetReadOnly> (false, true);

        my $piparent = $doc-><M::Document.createDocumentFragment>;

        my $return = $dtd-><M::Node.insertBefore> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 0);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: EntityRef.replaceChild.documentfragment.2.test
      @@@enDesc:
        Empty document fragment.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createEntityReference> ('dt');
        $dtd-><M::Node.manakaiSetReadOnly> (false, true);
        my $pi0 = $doc-><M::Document.createTextNode> ('pi0');
        $dtd-><M::Node.appendChild> ($pi0);

        my $piparent = $doc-><M::Document.createDocumentFragment>;

        my $return = $dtd-><M::Node.replaceChild> ($piparent, $pi0);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 0);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi0);

    @@Test:
      @@@QName: EntityRef.appendChild.documentfragment.3.test
      @@@enDesc:
        Three PIs in document fragment.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createEntityReference> ('dt');
        $dtd-><M::Node.manakaiSetReadOnly> (false, true);

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createTextNode> ('pi');
        my $pi2 = $doc-><M::Document.createEntityReference> ('pi2');
        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $piparent-><M::Node.appendChild> ($pi);
        $piparent-><M::Node.appendChild> ($pi2);
        $piparent-><M::Node.appendChild> ($pi3);

        my $return = $dtd-><M::Node.appendChild> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 3);

        my $item = $child-><M::tc|NodeList.item> (0);
        my $item2 = $child-><M::tc|NodeList.item> (1);
        my $item3 = $child-><M::tc|NodeList.item> (2);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);
        $test->id ('child.item.node2');
        $test->assert_isa ($item2, <IFName::Node>);
        $test->id ('child.item.node3');
        $test->assert_isa ($item3, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);
        $test->id ('child.item.pi2');
        $test->assert_isa ($item2, <IFName::tx|EntityReference>);
        $test->id ('child.item.pi3');
        $test->assert_isa ($item3, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);
        $test->id ('child.item.equals2');
        $test->assert_equals ($item2, $pi2);
        $test->id ('child.item.equals3');
        $test->assert_equals ($item3, $pi3);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi3);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);
        $test->id ('parent2');
        my $parent2 = $item2-><AG::Node.parentNode>;
        $test->assert_equals ($parent2, $dtd);
        $test->id ('parent3');
        my $parent3 = $item3-><AG::Node.parentNode>;
        $test->assert_equals ($parent3, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: EntityRef.insertBefore.documentfragment.3.test
      @@@enDesc:
        Three PIs in document fragment.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createEntityReference> ('dt');
        $dtd-><M::Node.manakaiSetReadOnly> (false, true);

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createTextNode> ('pi');
        my $pi2 = $doc-><M::Document.createEntityReference> ('pi2');
        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $piparent-><M::Node.appendChild> ($pi);
        $piparent-><M::Node.appendChild> ($pi2);
        $piparent-><M::Node.appendChild> ($pi3);

        my $return = $dtd-><M::Node.insertBefore> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 3);

        my $item = $child-><M::tc|NodeList.item> (0);
        my $item2 = $child-><M::tc|NodeList.item> (1);
        my $item3 = $child-><M::tc|NodeList.item> (2);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);
        $test->id ('child.item.node2');
        $test->assert_isa ($item2, <IFName::Node>);
        $test->id ('child.item.node3');
        $test->assert_isa ($item3, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);
        $test->id ('child.item.pi2');
        $test->assert_isa ($item2, <IFName::tx|EntityReference>);
        $test->id ('child.item.pi3');
        $test->assert_isa ($item3, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);
        $test->id ('child.item.equals2');
        $test->assert_equals ($item2, $pi2);
        $test->id ('child.item.equals3');
        $test->assert_equals ($item3, $pi3);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi3);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);
        $test->id ('parent2');
        my $parent2 = $item2-><AG::Node.parentNode>;
        $test->assert_equals ($parent2, $dtd);
        $test->id ('parent3');
        my $parent3 = $item3-><AG::Node.parentNode>;
        $test->assert_equals ($parent3, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: EntityRef.replaceChild.documentfragment.3.test
      @@@enDesc:
        Three PIs in document fragment.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createEntityReference> ('dt');
        $dtd-><M::Node.manakaiSetReadOnly> (false, true);
        my $pi0 = $doc-><M::Document.createTextNode> ('pi0');
        $dtd-><M::Node.appendChild> ($pi0);

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createTextNode> ('pi');
        my $pi2 = $doc-><M::Document.createEntityReference> ('pi2');
        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $piparent-><M::Node.appendChild> ($pi);
        $piparent-><M::Node.appendChild> ($pi2);
        $piparent-><M::Node.appendChild> ($pi3);

        my $return = $dtd-><M::Node.replaceChild> ($piparent, $pi0);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 3);

        my $item = $child-><M::tc|NodeList.item> (0);
        my $item2 = $child-><M::tc|NodeList.item> (1);
        my $item3 = $child-><M::tc|NodeList.item> (2);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);
        $test->id ('child.item.node2');
        $test->assert_isa ($item2, <IFName::Node>);
        $test->id ('child.item.node3');
        $test->assert_isa ($item3, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);
        $test->id ('child.item.pi2');
        $test->assert_isa ($item2, <IFName::tx|EntityReference>);
        $test->id ('child.item.pi3');
        $test->assert_isa ($item3, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);
        $test->id ('child.item.equals2');
        $test->assert_equals ($item2, $pi2);
        $test->id ('child.item.equals3');
        $test->assert_equals ($item3, $pi3);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi3);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);
        $test->id ('parent2');
        my $parent2 = $item2-><AG::Node.parentNode>;
        $test->assert_equals ($parent2, $dtd);
        $test->id ('parent3');
        my $parent3 = $item3-><AG::Node.parentNode>;
        $test->assert_equals ($parent3, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi0);

    @@Test:
      @@@QName: EntityRef.appendChild.badtype.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $comment = $doc-><M::Document.createEntityReference> ('dt');
        $comment-><M::Node.manakaiSetReadOnly> (false, true);
        my $pi0 = $doc-><M::Document.createTextNode> ('pi0');
        $comment-><M::Node.appendChild> ($pi0);

        for my $node (
          $docx-><M::DocumentX.createDocumentTypeDefinition> ('d'),
          $doc-><M::Document.createAttribute> ('a'),
          $docx-><M::DocumentX.createGeneralEntity> ('ge'),
          $docx-><M::DocumentX.createNotation> ('not'),
          $docx-><M::DocumentX.createElementTypeDefinition> ('et'),
          $docx-><M::DocumentX.createAttributeDefinition> ('at'),
          #test:nodeTypes
        ) {
          $test->id ('appendChild.'.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.appendChild> ($node);
          }, exception_subtype => <Q::MDOMX|HIERARCHY_BAD_TYPE>);

          $test->id ('insertBefore.'.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.insertBefore> ($node);
          }, exception_subtype => <Q::MDOMX|HIERARCHY_BAD_TYPE>);

          $test->id ('replaceChild.'.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.replaceChild> ($node, $pi0);
          }, exception_subtype => <Q::MDOMX|HIERARCHY_BAD_TYPE>);
        }

    @@Test:
      @@@QName: EntityRef.appendChild.wrongdoc.test
      @@@PerlDef:
        my $doc0;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc0}__;
        my $docx0 = $doc0-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;

        my $comment = $doc0-><M::Document.createEntityReference> ('dt');
        $comment-><M::Node.manakaiSetReadOnly> (false, true);

        for my $node (
          $doc-><M::Document.createTextNode> ('pi'),
          $doc-><M::Document.createEntityReference> ('e'),
          $doc-><M::Document.createComment> ('c'),
          $doc-><M::Document.createCDATASection> ('cs'),
          $doc-><M::Document.createProcessingInstruction> ('pi'),
          $doc-><M::Document.createElement> ('el'),
        ) {
          $test->id ('type='.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.appendChild> ($node);
          }, exception_subtype => <Q::c|DIFFERENT_DOCUMENT_ERR>);
        }
    @@Test:
      @@@QName: EntityRef.insertBefore.wrongdoc.test
      @@@PerlDef:
        my $doc0;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc0}__;
        my $docx0 = $doc0-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;

        my $comment = $doc0-><M::Document.createEntityReference> ('dt');
        $comment-><M::Node.manakaiSetReadOnly> (false, true);
        my $pi0 = $doc0-><M::Document.createTextNode> ('pi0');
        $comment-><M::Node.appendChild> ($pi0);

        for my $node (
          $doc-><M::Document.createTextNode> ('pi'),
          $doc-><M::Document.createEntityReference> ('ent'),
          $doc-><M::Document.createComment> ('c'),
          $doc-><M::Document.createCDATASection> ('cs'),
          $doc-><M::Document.createProcessingInstruction> ('pi'),
          $doc-><M::Document.createElement> ('el'),
        ) {
          $test->id ('appendChild.'.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.appendChild> ($node);
          }, exception_subtype => <Q::c|DIFFERENT_DOCUMENT_ERR>);

          $test->id ('insertBefore.'.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.insertBefore> ($node);
          }, exception_subtype => <Q::c|DIFFERENT_DOCUMENT_ERR>);

          $test->id ('replaceChild.'.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.replaceChild> ($node, $pi0);
          }, exception_subtype => <Q::c|DIFFERENT_DOCUMENT_ERR>);
        }

    @@Test:
      @@@QName: EntityRef.appendChild.readonly.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createEntityReference> ('dt');
        $dtd-><M::Node.manakaiSetReadOnly> (false, true);
        my $pi0 = $doc-><M::Document.createTextNode> ('pi0');
        $dtd-><M::Node.appendChild> ($pi0);
        $dtd-><M::Node.manakaiSetReadOnly> (true);

        $test->id ('pi');
        my $node = $doc-><M::Document.createTextNode> ('pi');

        $test->assert_exception (code => sub {
          $dtd-><M::Node.appendChild> ($node);
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);

        $test->id ('pi.insertBefore');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.insertBefore> ($node);
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);

        $test->id ('pi.replaceChild');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.replaceChild> ($node, $pi0);
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);

        $test->id ('fragment');
        my $node2 = $doc-><M::Document.createDocumentFragment>;
        $node2-><M::Node.appendChild> ($node);

        $test->assert_exception (code => sub {
          $dtd-><M::Node.appendChild> ($node2);
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);

        $test->id ('fragment.insertBefore');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.insertBefore> ($node2);
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);

        $test->id ('fragment.replaceChild');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.replaceChild> ($node2, $pi0);
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);

    @@Test:
      @@@QName: EntityRef.appendChild.readonly.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createEntityReference> ('dt');
        $dtd-><M::Node.manakaiSetReadOnly> (false, true);
        my $pi0 = $doc-><M::Document.createTextNode> ('pi0');
        $dtd-><M::Node.appendChild> ($pi0);

        $test->id ('pi');
        my $el = $doc-><M::Document.createElementNS> (null, 'e');
        my $node = $doc-><M::Document.createTextNode> ('pi');
        $el-><M::Node.appendChild> ($node);
        $el-><M::Node.manakaiSetReadOnly> (true);

        $test->assert_exception (code => sub {
          $dtd-><M::Node.appendChild> ($node);
        }, exception_subtype => <Q::MDOMX|NOMOD_SRC_PARENT>);

        $test->id ('pi.insertBefore');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.insertBefore> ($node);
        }, exception_subtype => <Q::MDOMX|NOMOD_SRC_PARENT>);

        $test->id ('pi.replaceChild');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.replaceChild> ($node, $pi0);
        }, exception_subtype => <Q::MDOMX|NOMOD_SRC_PARENT>);

        $test->id ('fragment');
        my $node2 = $doc-><M::Document.createDocumentFragment>;
        my $node3 = $doc-><M::Document.createTextNode> ('pi');
        $node2-><M::Node.appendChild> ($node3);
        $node2-><M::Node.manakaiSetReadOnly> (true);

        $test->assert_exception (code => sub {
          $dtd-><M::Node.appendChild> ($node2);
        }, exception_subtype => <Q::MDOMX|NOMOD_SRC_PARENT>);

        $test->id ('fragment.insertBefore');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.insertBefore> ($node2);
        }, exception_subtype => <Q::MDOMX|NOMOD_SRC_PARENT>);

        $test->id ('fragment.replaceChild');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.replaceChild> ($node2, $pi0);
        }, exception_subtype => <Q::MDOMX|NOMOD_SRC_PARENT>);

    @@Test:
      @@@QName: EntityRef.insertBefore.refChild.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createEntityReference> ('dt');
        $dtd-><M::Node.manakaiSetReadOnly> (false, true);

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.insertBefore> ($pi2, $pi1);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi2);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi1);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: EntityRef.insertBefore.refChild.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createEntityReference> ('dt');
        $dtd-><M::Node.manakaiSetReadOnly> (false, true);

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $dtd-><M::Node.insertBefore> ($pi3, $pi2);

        # pi1, pi3, pi2

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi1);

        $test->id ('firstChild.nextSibling');
        $test->assert_equals ($dtd-><AG::Node.firstChild>
                                  -><AG::Node.nextSibling>, $pi3);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi2);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 3);

    @@Test:
      @@@QName: EntityRef.insertBefore.refChild.3.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createEntityReference> ('dt');
        $dtd-><M::Node.manakaiSetReadOnly> (false, true);

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $dtd-><M::Node.appendChild> ($pi3);

        # pi1, pi2, pi3

        $dtd-><M::Node.insertBefore> ($pi2, $pi1);
 
        # pi2, pi1, pi3

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi2);

        $test->id ('firstChild.nextSibling');
        $test->assert_equals ($dtd-><AG::Node.firstChild>
                                  -><AG::Node.nextSibling>, $pi1);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi3);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 3);

    @@Test:
      @@@QName: EntityRef.insertBefore.refChild.4.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createEntityReference> ('dt');
        $dtd-><M::Node.manakaiSetReadOnly> (false, true);

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $dtd-><M::Node.appendChild> ($pi3);

        # pi1, pi2, pi3

        $dtd-><M::Node.insertBefore> ($pi3, $pi1);
 
        # pi3, pi1, pi2

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi3);

        $test->id ('firstChild.nextSibling');
        $test->assert_equals ($dtd-><AG::Node.firstChild>
                                  -><AG::Node.nextSibling>, $pi1);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi2);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 3);

    @@Test:
      @@@QName: EntityRef.insertBefore.refChild.not_found_err.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createEntityReference> ('dt');
        $dtd-><M::Node.manakaiSetReadOnly> (false, true);

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');

        my $pi4 = $doc-><M::Document.createTextNode> ('pi4');

        # pi1, pi2

        $test->assert_exception (code => sub {
          $dtd-><M::Node.insertBefore> ($pi4, $pi3);
        }, exception_subtype => <Q::c|NOT_CHILD_ERR>);

    @@Test:
      @@@QName: EntityRef.insertBefore.refChild=newChild.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createEntityReference> ('dt');
        $dtd-><M::Node.manakaiSetReadOnly> (false, true);

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        # pi1, pi2

        my $eh_called = false;
        my $cfg = $doc-><AG::Document.domConfig>;
        $cfg-><M::c|DOMConfiguration.setParameter> ('error-handler' => sub {
          my (undef, $err) = @_;
          $eh_called = true;
          $test->assert_equals ($err-><AG::c|DOMError.severity>,
                                <C::c|DOMError.SEVERITY_WARNING>);
          $test->assert_equals ($err-><AG::c|DOMError.type>,
                                <Q::t|insert-before-itself>);
          $test->assert_equals ($err-><AG::c|DOMError.relatedData>, $pi2);
          $test->assert_null ($err-><AG::c|DOMError.relatedException>);
          $test->assert_isa ($err-><AG::c|DOMError.location>,
                             <IFName::c|DOMLocator>);
          $test->assert_not_null ($err-><AG::c|DOMError.message>);
        });

        $test->assert_false ($eh_called);
        $dtd-><M::Node.insertBefore> ($pi2, $pi2);
        $test->assert_true ($eh_called);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi1);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi2);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: EntityRef.replaceChild.oldChild=newChild.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createEntityReference> ('dt');
        $dtd-><M::Node.manakaiSetReadOnly> (false, true);

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        # pi1, pi2

        my $eh_called = false;
        my $cfg = $doc-><AG::Document.domConfig>;
        $cfg-><M::c|DOMConfiguration.setParameter> ('error-handler' => sub {
          my (undef, $err) = @_;
          $eh_called = true;
          $test->assert_equals ($err-><AG::c|DOMError.severity>,
                                <C::c|DOMError.SEVERITY_WARNING>);
          $test->assert_equals ($err-><AG::c|DOMError.type>,
                                <Q::t|replace-by-itself>);
          $test->assert_equals ($err-><AG::c|DOMError.relatedData>, $pi2);
          $test->assert_null ($err-><AG::c|DOMError.relatedException>);
          $test->assert_isa ($err-><AG::c|DOMError.location>,
                             <IFName::c|DOMLocator>);
          $test->assert_not_null ($err-><AG::c|DOMError.message>);
        });

        $test->assert_false ($eh_called);
        $dtd-><M::Node.replaceChild> ($pi2, $pi2);
        $test->assert_true ($eh_called);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi1);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi2);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: EntityRef.appendChild.sameparent.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createEntityReference> ('dt');
        $dtd-><M::Node.manakaiSetReadOnly> (false, true);

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        # pi1, pi2

        my $return = $dtd-><M::Node.appendChild> ($pi1);

        # pi2, pi1

        $test->id ('return');
        $test->assert_equals ($return, $pi1);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi2);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi1);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: EntityRef.insertBefore.sameparent.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createEntityReference> ('dt');
        $dtd-><M::Node.manakaiSetReadOnly> (false, true);

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        # pi1, pi2

        my $return = $dtd-><M::Node.insertBefore> ($pi1);

        # pi2, pi1

        $test->id ('return');
        $test->assert_equals ($return, $pi1);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi2);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi1);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: EntityRef.appendChild.sameparent.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createEntityReference> ('dt');
        $dtd-><M::Node.manakaiSetReadOnly> (false, true);

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        # pi1, pi2

        my $return = $dtd-><M::Node.appendChild> ($pi2);

        # pi1, pi2

        $test->id ('return');
        $test->assert_equals ($return, $pi2);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi1);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi2);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: EntityRef.insertBefore.sameparent.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createEntityReference> ('dt');
        $dtd-><M::Node.manakaiSetReadOnly> (false, true);

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        # pi1, pi2

        my $return = $dtd-><M::Node.insertBefore> ($pi2);

        # pi1, pi2

        $test->id ('return');
        $test->assert_equals ($return, $pi2);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi1);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi2);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: EntityRef.replaceChild.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createEntityReference> ('dt');
        $dtd-><M::Node.manakaiSetReadOnly> (false, true);

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $dtd-><M::Node.appendChild> ($pi3);

        # pi1, pi2, pi3

        my $pi9 = $doc-><M::Document.createTextNode> ('pi9');
        my $return = $dtd-><M::Node.replaceChild> ($pi9, $pi1);

        # pi9, pi2, pi3

        $test->id ('return.node');
        $test->assert_isa ($return, <IFName::Node>);
        $test->id ('return.pi');
        $test->assert_isa ($return, <IFName::Text>);
        $test->id ('return');
        $test->assert_equals ($return, $pi1);

        my $c = $dtd-><AG::Node.childNodes>;

        $test->id ('length');
        $test->assert_num_equals (actual_value => 0+@$c, expected_value => 3);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi9);

        $test->id ('firstChild.nextSibling');
        $test->assert_equals ($dtd-><AG::Node.firstChild>
                                  -><AG::Node.nextSibling>, $pi2);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi3);
 
        $test->id ('parent');
        $test->assert_equals ($pi9-><AG::Node.parentNode>, $dtd);

        $test->id ('return.parent');
        $test->assert_null ($pi1-><AG::Node.parentNode>);

    @@Test:
      @@@QName: EntityRef.replaceChild.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createEntityReference> ('dt');
        $dtd-><M::Node.manakaiSetReadOnly> (false, true);

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $dtd-><M::Node.appendChild> ($pi3);

        # pi1, pi2, pi3

        my $pi9 = $doc-><M::Document.createTextNode> ('pi9');
        my $return = $dtd-><M::Node.replaceChild> ($pi9, $pi2);

        # pi1, pi9, pi3

        $test->id ('return.node');
        $test->assert_isa ($return, <IFName::Node>);
        $test->id ('return.pi');
        $test->assert_isa ($return, <IFName::Text>);
        $test->id ('return');
        $test->assert_equals ($return, $pi2);

        my $c = $dtd-><AG::Node.childNodes>;

        $test->id ('length');
        $test->assert_num_equals (actual_value => 0+@$c, expected_value => 3);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi1);

        $test->id ('firstChild.nextSibling');
        $test->assert_equals ($dtd-><AG::Node.firstChild>
                                  -><AG::Node.nextSibling>, $pi9);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi3);
 
        $test->id ('parent');
        $test->assert_equals ($pi9-><AG::Node.parentNode>, $dtd);

        $test->id ('return.parent');
        $test->assert_null ($pi2-><AG::Node.parentNode>);

    @@Test:
      @@@QName: EntityRef.replaceChild.3.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createEntityReference> ('dt');
        $dtd-><M::Node.manakaiSetReadOnly> (false, true);

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $dtd-><M::Node.appendChild> ($pi3);

        # pi1, pi2, pi3

        my $pi9 = $doc-><M::Document.createTextNode> ('pi9');
        my $return = $dtd-><M::Node.replaceChild> ($pi9, $pi3);

        # pi1, pi2, pi9

        $test->id ('return.node');
        $test->assert_isa ($return, <IFName::Node>);
        $test->id ('return.pi');
        $test->assert_isa ($return, <IFName::Text>);
        $test->id ('return');
        $test->assert_equals ($return, $pi3);

        my $c = $dtd-><AG::Node.childNodes>;

        $test->id ('length');
        $test->assert_num_equals (actual_value => 0+@$c, expected_value => 3);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi1);

        $test->id ('firstChild.nextSibling');
        $test->assert_equals ($dtd-><AG::Node.firstChild>
                                  -><AG::Node.nextSibling>, $pi2);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi9);
 
        $test->id ('parent');
        $test->assert_equals ($pi9-><AG::Node.parentNode>, $dtd);

        $test->id ('return.parent');
        $test->assert_null ($pi3-><AG::Node.parentNode>);

    @@Test:
      @@@QName: EntityRef.replaceChild.sameparent.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createEntityReference> ('dt');
        $dtd-><M::Node.manakaiSetReadOnly> (false, true);

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $dtd-><M::Node.appendChild> ($pi3);

        # pi1, pi2, pi3

        my $return = $dtd-><M::Node.replaceChild> ($pi3, $pi1);

        # pi3, pi2

        $test->id ('return.node');
        $test->assert_isa ($return, <IFName::Node>);
        $test->id ('return.pi');
        $test->assert_isa ($return, <IFName::Text>);
        $test->id ('return');
        $test->assert_equals ($return, $pi1);

        my $c = $dtd-><AG::Node.childNodes>;

        $test->id ('length');
        $test->assert_num_equals (actual_value => 0+@$c, expected_value => 2);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi3);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi2);
 
        $test->id ('parent');
        $test->assert_equals ($pi3-><AG::Node.parentNode>, $dtd);

        $test->id ('return.parent');
        $test->assert_null ($pi1-><AG::Node.parentNode>);

    @@Test:
      @@@QName: EntityRef.replaceChild.sameparent.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createEntityReference> ('dt');
        $dtd-><M::Node.manakaiSetReadOnly> (false, true);

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $dtd-><M::Node.appendChild> ($pi3);

        # pi1, pi2, pi3

        my $return = $dtd-><M::Node.replaceChild> ($pi1, $pi3);

        # pi2, pi1

        $test->id ('return.node');
        $test->assert_isa ($return, <IFName::Node>);
        $test->id ('return.pi');
        $test->assert_isa ($return, <IFName::Text>);
        $test->id ('return');
        $test->assert_equals ($return, $pi3);

        my $c = $dtd-><AG::Node.childNodes>;

        $test->id ('length');
        $test->assert_num_equals (actual_value => 0+@$c, expected_value => 2);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi2);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi1);
 
        $test->id ('parent');
        $test->assert_equals ($pi1-><AG::Node.parentNode>, $dtd);

        $test->id ('return.parent');
        $test->assert_null ($pi3-><AG::Node.parentNode>);

    @@Test:
      @@@QName: EntityRef.appendChild.ancestor.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createEntityReference> ('dt');
        $dtd-><M::Node.manakaiSetReadOnly> (false, true);
        $dtd-><M::Node.appendChild>
                ($doc-><M::Document.createTextNode> ('text1'));

        $test->id ('appendChild');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.appendChild> ($dtd);
        }, exception_subtype => <Q::MDOMX|HIERARCHY_ANCESTOR_OR_SELF>);

        $test->id ('insertBefore');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.insertBefore> ($dtd);
        }, exception_subtype => <Q::MDOMX|HIERARCHY_ANCESTOR_OR_SELF>);

        $test->id ('replaceChild');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.replaceChild> ($dtd, $dtd-><AG::Node.firstChild>);
        }, exception_subtype => <Q::MDOMX|HIERARCHY_ANCESTOR_OR_SELF>);

    @@Test:
      @@@QName: EntityRef.appendChild.ancestor.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createEntityReference> ('dt');
        $dtd-><M::Node.manakaiSetReadOnly> (false, true);
        $dtd-><M::Node.appendChild>
                ($doc-><M::Document.createTextNode> ('text1'));
        my $el = $doc-><M::Document.createElement> ('el');
        $el-><M::Node.appendChild> ($dtd);

        $test->id ('appendChild');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.appendChild> ($el);
        }, exception_subtype => <Q::MDOMX|HIERARCHY_ANCESTOR_OR_SELF>);

        $test->id ('insertBefore');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.insertBefore> ($el);
        }, exception_subtype => <Q::MDOMX|HIERARCHY_ANCESTOR_OR_SELF>);

        $test->id ('replaceChild');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.replaceChild> ($el, $dtd-><AG::Node.firstChild>);
        }, exception_subtype => <Q::MDOMX|HIERARCHY_ANCESTOR_OR_SELF>);

    @@Test:
      @@@QName: EntityRef.appendChild.ancestor.3.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createEntityReference> ('dt');
        $dtd-><M::Node.manakaiSetReadOnly> (false, true);
        $dtd-><M::Node.appendChild>
                ($doc-><M::Document.createTextNode> ('text1'));
        my $el = $doc-><M::Document.createElement> ('el');
        $el-><M::Node.appendChild> ($dtd);
        my $el2 = $doc-><M::Document.createElement> ('el');
        $el2-><M::Node.appendChild> ($el);

        $test->id ('appendChild');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.appendChild> ($el2);
        }, exception_subtype => <Q::MDOMX|HIERARCHY_ANCESTOR_OR_SELF>);

        $test->id ('insertBefore');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.insertBefore> ($el2);
        }, exception_subtype => <Q::MDOMX|HIERARCHY_ANCESTOR_OR_SELF>);

        $test->id ('replaceChild');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.replaceChild> ($el2, $dtd-><AG::Node.firstChild>);
        }, exception_subtype => <Q::MDOMX|HIERARCHY_ANCESTOR_OR_SELF>);

  @CMethod:
    @@Name: manakaiAppendText
    @@Param:
      @@@Name: string
      @@@Type: DOMString
      @@@enDesc:
        The string to append.
      @@@InCase:
        @@@@Type: DISPerl|SCALAR||ManakaiDOM|all
        @@@@enDesc:
          A copy of the string value referenced from the value
          is appended.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node itself.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the node to insert the string or a <IF::Text> node
          is read-only.
      @@@disDef:
        @@@@DISPerl:cloneCode: te|ManakaiDOMAttr.manakaiAppendText

    @@Test:
      @@@QName: EntityRef..=.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;

        my $node = $doc-><M::Document.createEntityReference> ('node');
        $node-><M::Node.manakaiSetReadOnly> (false, true);

        $node-><M::Node.manakaiAppendText> ('string');
        $test->id ('1.class');
        $test->assert_isa ($node, <IFName::EntityReference>);
        $test->id ('1.value');
        $test->assert_equals ($node-><AG::Node.textContent>, 'string');
        $test->id ('1.length');
        $test->assert_num_equals
                 (expected_value => 1,
                  actual_value => 0+@{$node-><AG::Node.childNodes>});

        $test->id (2);
        $node-><M::Node.manakaiAppendText> ('STRING');
        $test->assert_equals ($node-><AG::Node.textContent>, 'stringSTRING');
        $test->assert_num_equals
                 (expected_value => 1,
                  actual_value => 0+@{$node-><AG::Node.childNodes>});

        $node-><M::Node.appendChild>
                 ($doc-><M::Document.createEntityReference> ('er'));

        $test->id (3);
        $node-><M::Node.manakaiAppendText> ('text');
        $test->assert_equals ($node-><AG::Node.textContent>, 'stringSTRINGtext');
        $test->assert_num_equals
                 (expected_value => 3,
                  actual_value => 0+@{$node-><AG::Node.childNodes>});

  @CAttr:
    @@Name: nodeName
    @@enDesc:
      The node name.
    @@DOMMain:isNamespaceUnaware:1
    @@Type: DOMString
    @@Get:
      @@@disDef:
        @@@@DISPerl:cloneCode: ManakaiDOMNotation.nodeName.get

    @@Test:
      @@@QName: ER.nodeName.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $not = $doc-><M::Document.createEntityReference> ('notation1');

        $test->assert_equals ($not-><AG::Node.nodeName>, 'notation1');

  @CL3Method:
    @@Name: getFeature
    @@enDesc:
      Returns a specialized object that implements the specialized APIs.
    @@Param:
      @@@Name: feature
      @@@Type: DOMString
      @@@dis:actualType: f|FeatureNameString
    @@Param:
      @@@Name: version
      @@@Type: DOMString
      @@@dis:actualType: f|FeatureVersionString
    @@Return:
      @@@Type: DOMMain|DOMObject
      @@@nullCase:
      @@@PerlDef:
        $feature =~ s/^\+//;
        __CODE{f|getFeatureImpl::
          $self => $self,
          $feature => $feature, $version => $version, $r => $r,
          $base_class => {<ClassName::ManakaiDOMEntityReference>},
        }__;
        unless (defined $r) {
          __DEEP{
            $r = $self->SUPER::get_feature ($feature, $version);
          }__;
        }

    @@Test:
      @@@QName: ER.getFeature.test
      @@@PerlDef:
        my $node;
        __CODE{tx|createERForTest:: $er => $node}__;

        for (
          [Core => '1.0', <IFName::EntityReference||ManakaiDOM|ManakaiDOM1>],
          [Core => '2.0', <IFName::EntityReference||ManakaiDOM|ManakaiDOM2>],
          [Core => '3.0', <IFName::EntityReference||ManakaiDOM|ManakaiDOM3>],
          [XML => '1.0', <IFName::EntityReference||ManakaiDOM|ManakaiDOM1>],
          [XML => '2.0', <IFName::EntityReference||ManakaiDOM|ManakaiDOM2>],
          [XML => '3.0', <IFName::EntityReference||ManakaiDOM|ManakaiDOM3>],
        ) {
          $test->id ($_->[0].'.'.$_->[1]);
          my $sp = $node-><M::Node.getFeature> ($_->[0], $_->[1]);
          $test->assert_isa ($sp, $_->[2]);
        }

  @CL3Attr:
    @@Name: baseURI
    @@enDesc:
      The base URI of the node.
    @@enDesc:
      @@@ddid: man
      @@@For: ManakaiDOM|ManakaiDOM
      @@@@:
        In manakai, it is always equal to the base DOM URI of 
        the parent element in the same external entity, if any, or
        the external entity in which the node is contained.
    @@Type: DOMString
    @@dis:actualType: ManakaiDOM|ManakaiDOMURI
    @@Get:
      @@@enDesc:
        The absolute base DOM URI.
      @@@nullCase:
        @@@@enDesc:
          If the DOM implementation was not able to obtain the absolute URI.
      @@@disDef:
        @@@@DISPerl:cloneCode: tcd|ManakaiDOMCharacterData.baseURI.get

    @@XDTest:
      @@@QName: EntityRef.baseURI.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $ent = $doc-><M::Document.createEntityReference> ('ent');
        $ent-><M::Node.manakaiSetReadOnly> (false, true);

        $test->id ('initial');
        $test->assert_null ($ent-><AG::Node.baseURI>);

        $test->id ('doc');
        $doc-><AS::Document.documentURI> (q<http://base.example/>);
        $test->assert_equals
                 ($ent-><AG::Node.baseURI>,
                  q<http://base.example/>);

        $test->id ('entburi');
        $ent-><AS::Entity.manakaiEntityBaseURI> (q<http://www.example.com/>);
        $test->assert_equals
                 ($ent-><AG::Node.baseURI>,
                  q<http://base.example/>); # shouldn't affect

        my $el = $doc-><M::Document.createElementNS> (null, 'el');
        $el-><M::Element.setAttributeNS> (<Q::xml:>, 'xml:base',
                                          q<http://el.test/>);

        $test->id ('el');
        $el-><M::Node.appendChild> ($ent);
        $test->assert_equals
                 ($ent-><AG::Node.baseURI>,
                  q<http://el.test/>);

        my $xent = $doc-><M::Document.createEntityReference> ('ext');
        $xent-><M::Node.manakaiSetReadOnly> (false, true);
        $xent-><AS::EntityReference.manakaiEntityBaseURI> (q<http://ent.test/>);
        $xent-><AS::EntityReference.manakaiExternal> (true);
        $el-><M::Node.appendChild> ($xent);
        $xent-><M::Node.appendChild> ($ent);

        $test->id ('ent');
        $test->assert_equals
                 ($ent-><AG::Node.baseURI>,
                  q<http://ent.test/>);

  @LXAttr:
    @@Name: manakaiExpanded
    @@enDesc:
      Whether the reference is expanded so that its children list
      represents a part of the document.
    @@Type: boolean
    @@Get:
      @@@PerlDef:
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $r,
          $prop => {<H::tx|expanded>},
          $ref => {$self},
        }__;
    @@Set:
      @@@NodeReadOnlyError:
      @@@PerlDef:
        __CODE{tc|NodeReadOnlyError:: $node => $self}__;
        __CODE{mg|setNodeStemPropValue||ManakaiDOM|all::
          $given => $given,
          $prop => {<H::tx|expanded>},
          $ref => $self,
        }__;
    @@enImplNote:
      {ISSUE::
        Should subtree modifications turn the flag like <A::Attr.specified>?
      }

    @@Test:
      @@@QName: EntityReference.manakaiExpanded.test
      @@@PerlDef:
        my $node;
        __CODE{tx|createERForTest:: $er => $node}__;

        $test->id ('set.false.1');
        $node-><AS::EntityReference.manakaiExpanded> (false);
        $test->assert_false ($node-><AG::EntityReference.manakaiExpanded>);

        $test->id ('set.true');
        $node-><AS::EntityReference.manakaiExpanded> (true);
        $test->assert_true ($node-><AG::EntityReference.manakaiExpanded>);

        $test->id ('set.false.2');
        $node-><AS::EntityReference.manakaiExpanded> (false);
        $test->assert_false ($node-><AG::EntityReference.manakaiExpanded>);

  @LXAttr:
    @@Name: manakaiEntityBaseURI
    @@enDesc:
      The base DOM URI of the entity referenced by the entity reference.

        {NOTE::
           This attribute is a manakai extension.
        }
    @@Type: DOMString
    @@dis:actualType: ManakaiDOM|ManakaiDOMURI
    @@Get:
      @@@enDesc:
        The base DOM URI of the entity.

          = If there is an explicit base DOM URI for the entity,
            then return it.

          = Otherwise, return <A::Node.baseURI> of the node.

            {NOTE::
              Therefore, the entity base URI for internal general
              entities are same as one for the external or document entity
              in which the entity is referenced.
            }
      @@@nullCase:
        @@@@enDesc:
          If there is no explicit base URI or entity URI information and
          the <A::Node.baseURI> attribute contains <DOM::null>.
      @@@PerlDef:
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $r,
          $prop => {<H::tx|entityBaseURI>},
          $ref => {$self},
        }__;
        unless (defined $r) {
          __DEEP{
            $r = $self-><AG::Node.baseURI>;
          }__;
        }
    @@Set:
      @@@enDesc:
        Sets the entity base DOM URI explicitly.  It <kwd:MUST> be an absolute
        DOM URI; however, no lexical checking is performed on 
        the setting.  In addition, it does not change the
        entity base URI of the <IF::Entity> node referenced by the node.
      @@@nullCase:
        @@@@enDesc:
          The entity base DOM URI is unset.  It does
          not affect to the entity base URI of the referenced <IF::Entity>
          node or the <A::Node.baseURI> of the entity reference node.

            {NOTE::
               It removes the explicit entity base URI information
               attached to the entity reference node entirely and
               never restores the original entity base URI set during
               the tree construction, if any.  To synchronize 
               entity base URI with that of the <IF::Entity> node,
               use <M::Document.normalizeDocument> method.
            }
      @@@NodeReadOnlyError:
      @@@PerlDef:
        __CODE{tc|NodeReadOnlyError:: $node => $self}__;
        __CODE{mg|setNodeStemPropValue||ManakaiDOM|all::
          $given => $given,
          $prop => {<H::tx|entityBaseURI>},
          $ref => $self,
        }__;

    @@XDTest:
      @@@QName: EntityRef.entBaseURI.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $ent = $doc-><M::Document.createEntityReference> ('ent');
        $ent-><M::Node.manakaiSetReadOnly> (false, true);

        $test->id ('initial');
        $test->assert_null ($ent-><AG::EntityReference.manakaiEntityBaseURI>);

        $test->id ('doc');
        $doc-><AS::Document.documentURI> (q<http://www.example/>);
        $test->assert_equals 
                 ($ent-><AG::EntityReference.manakaiEntityBaseURI>,
                  q<http://www.example/>);
        
        $test->id ('set');
        $ent-><AS::EntityReference.manakaiEntityBaseURI> (q<ftp://www.example/>);
        $test->assert_equals
                 ($ent-><AG::EntityReference.manakaiEntityBaseURI>,
                  q<ftp://www.example/>);
        $test->assert_equals
                 ($ent-><AG::Node.baseURI>,
                  q<http://www.example/>);

        $test->id ('unset');
        $ent-><AS::EntityReference.manakaiEntityBaseURI> (null);
        $test->assert_equals
                 ($ent-><AG::Entity.manakaiEntityBaseURI>,
                  q<http://www.example/>);

  @LXAttr:
    @@Name: manakaiExternal
    @@enDesc:
      Whether the entity referenced by the node is an external entity
      or not.

      {NOTE::
        Setting this attribute might make a node inconsistent
        with the <IF::Entity> node referenced by it.  Such
        incosistence should be fixed by the method 
        <M::Document.normalizeDocument> if necessary.
      }
    @@Type: boolean
    @@TrueCase:
      @@@enDesc:
        The node is an external entity reference.
    @@FalseCase:
      @@@enDesc:
        The node is <EM::not> an external entity reference.
    @@Get:
      @@@PerlDef:
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $r,
          $prop => {<H::tx|isExternalEntity>},
          $ref => {$self},
        }__;
    @@Set:
      @@@NodeReadOnlyError:
      @@@PerlDef:
        __CODE{tc|NodeReadOnlyError:: $node => $self}__;
        __CODE{mg|setNodeStemPropValue||ManakaiDOM|all::
          $given => $given,
          $prop => {<H::tx|isExternalEntity>},
          $ref => $self,
        }__;
    @@enImplNote:
      {ISSUE::
        Default value?
      }

    @@LXTest:
      @@@QName: EntRef.external.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $ent = $doc-><M::Document.createEntityReference> ('ent');
        $ent-><M::Node.manakaiSetReadOnly> (false, true);

        $test->id ('set.false.1');
        $ent-><AS::EntityReference.manakaiExternal> (false);
        $test->assert_false ($ent-><AG::EntityReference.manakaiExternal>);

        $test->id ('set.true');
        $ent-><AS::EntityReference.manakaiExternal> (true);
        $test->assert_true ($ent-><AG::EntityReference.manakaiExternal>);

        $test->id ('set.false.2');
        $ent-><AS::EntityReference.manakaiExternal> (false);
        $test->assert_false ($ent-><AG::EntityReference.manakaiExternal>);

  @enImplNote:
    @@ddid: todo
    @@@:
      {TODO::
        Define [system identifier], [public identifier], and
        [declaration base URI] for DOM.
      }
##EntityReference

NodeTypeDef:
  @IFQName: ProcessingInstruction
  @ClsQName: ManakaiDOMProcessingInstruction

  @DISLang:role: tc|ProcessingInstructionRole

  @enDesc:
    A <IF::ProcessingInstruction> node represents a processing
    instruction.

    The <A::ProcessingInstruction.data> attribute contains
    the content of the processing instruction.  No lexical 
    checking is performed on the content and it is therefore
    possible to have the character sequence <XML::?<gt>> in the content,
    which is illegal in XML.
  
  @IntMethod:
    @@Operator: mg|CreateNodeStemMethod
    @@Param:
      @@@Name: bag
      @@@Type: HASH
    @@Param:
      @@@Name: obj
      @@@Type: HASH
    @@Param:
      @@@Name: opt
      @@@Type: HASH
    @@Return:
      @@@Type: HASH
      @@@PerlDef:
        __CODE{DISPerl|HashStringRef||ManakaiDOM|all::
          $result => {$obj->{<H::infoset|target>}},
          $given => {${$opt->{<H::infoset|target>}}},
        }__;
        $obj->{<H::infoset|content>} = $opt->{<H::infoset|content>};
        __CODE{mg|setOwnerProp||ManakaiDOM|all::
          $bag => $bag,
          $ownerref => {$opt->{<H::tc|ownerDocument>}},
          $ownee1hprop => {<H::tc|revOwnerDocument>},
          $ownee => {$obj},
          $owner0prop => {<H::tc|ownerDocument>},
        }__;
        $r = $obj;
  @mg:owner0: tc|ownerDocument
  @mg:origin0: infoset|parent
  @enImplNote:
    @@ddid: props
    @@@:
      {P:: Required internal properties:

         - <Q::tc|ownerDocument>.

         - <Q::infoset|target>.

      }

      {P:: Optional internal properties:
 
         - <Q::infoset|parent>.

         - <Q::infoset|content>.

         - <Q::infoset|baseURI>.

         - <Q::c|read-only>.

      }

      If a subclass don't use <Q::infoset|content>, then
      it <kwd:MUST> overrides at least <A::ProcessingInstruction.data>,
      and <M::Node.manakaiAppendText>.

  @CODE:
    @@QName: tx|createPIForTest
    @@PerlDef:
      my $__doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $__doc}__;
      $pi = $__doc-><M::Document.createProcessingInstruction> ('pi', 'data');

  @CAttr:
    @@Name: nodeType
    @@Type: unsignedShort
    @@dis:actualType: tc|NodeType
    @@Get:
      @@@disDef:
        @@@@DISLang:constValue: Node.PROCESSING_INSTRUCTION_NODE

    @@Test:
      @@@QName: PI.nodeType.test
      @@@PerlDef:
        my $pi;
        __CODE{tx|createPIForTest:: $pi => $pi}__;

        $test->id ('nodeType');
        $test->assert_num_equals
                 (actual_value => $pi-><AG::Node.nodeType>,
                  expected_value => <C::Node.PROCESSING_INSTRUCTION_NODE>);

  @Test:
    @@QName: PI.parentNode.1.test
    @@PerlDef:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

      my $df = $doc-><M::Document.createProcessingInstruction> ('pi', 'data');

      $test->assert_null ($df-><AG::Node.parentNode>);

  @Test:
    @@QName: PI.isSameNode.1.test
    @@PerlDef:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

      my $el = $doc-><M::Document.createProcessingInstruction> ('pi', 'data');

      my $el2 = $doc-><M::Document.createProcessingInstruction> ('pi', 'data');
      
      $test->id ('same');
      $test->assert_equals ($el, $el);
      
      $test->id ('diff');
      $test->assert_not_equals ($el, $el2);
      
      $test->id ('doc');
      $test->assert_not_equals ($el, $doc);
  @Test:
    @@QName: PI.isSameNode.2.test
    @@PerlDef:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

      my $el = $doc-><M::Document.createProcessingInstruction> ('pi', 'data');

      my $el2 = $doc-><M::Document.createProcessingInstruction> ('pi', 'data');
      
      $test->id ('same');
      $test->assert_true ($el-><M::Node.isSameNode> ($el));
      
      $test->id ('diff');
      $test->assert_false ($el-><M::Node.isSameNode> ($el2));
      
      $test->id ('doc');
      $test->assert_false ($el-><M::Node.isSameNode> ($doc));

  @LXTest:
    @@QName: PI.readOnly.test
    @@PerlDef:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

      my $el = $doc-><M::Document.createProcessingInstruction> ('pi', 'data');

      $test->id ('default');
      $test->assert_false ($el-><AG::Node.manakaiReadOnly>);

  @CAttr:
    @@Name: childNodes
    @@enDesc:
      A list of nodes that contains all children of the node.
    @@Get:
      @@@Type: c|NodeList
      @@@enDesc:
        Since <IF::ProcessingInstruction> nodes cannot have child nodes,
        the node list is always empty.
      @@@disDef:
        @@@@DISPerl:cloneCode: tcd|ManakaiDOMCharacterData.childNodes.get

  @CMethod:
    @@Name: appendChild
    @@enDesc:
      Adds a node to the end of the list of children of the node.
      If that node is already in the tree, it is first removed.
    @@Param:
      @@@Name: newChild
      @@@Type: Node
      @@@enDesc:
        The node to add.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node added.
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_BAD_TYPE
        @@@@enDesc:
          The type of the node does not allow any children.
      @@@disDef:
        @@@@DISPerl:cloneCode: tcd|ManakaiDOMCharacterData.appendChild

  @CMethod:
    @@Name: insertBefore
    @@enDesc:
      Inserts a node before the existing child node of the node.
    @@Param:
      @@@Name: newChild
      @@@Type: Node
      @@@enDesc:
        The node to add.
    @@Param:
      @@@Name: refChild
      @@@Type: Node
      @@@enDesc:
        The node before which the <P::newChild> node is inserted.
      @@@nullCase:
        @@@@enDesc:
          The <P::newChild> node is inserted at the end.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node added.
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_BAD_TYPE
        @@@@enDesc:
          The type of the node does not allow any children.
      @@@disDef:
        @@@@DISPerl:cloneCode: tcd|ManakaiDOMCharacterData.insertBefore

  @CMethod:
    @@Name: replaceChild
    @@enDesc:
      Replaces a node by another node.
    @@Param:
      @@@Name: newChild
      @@@Type: Node
      @@@enDesc:
        The node to add.
    @@Param:
      @@@Name: oldChild
      @@@Type: Node
      @@@enDesc:
        The node to remove.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node added.
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_BAD_TYPE
        @@@@enDesc:
          The type of the node does not allow any children.
      @@@disDef:
        @@@@DISPerl:cloneCode: tcd|ManakaiDOMCharacterData.replaceChild

    @@Test:
      @@@QName: PI.appendChild.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $comment = $doc-><M::Document.createProcessingInstruction> ('data');
        my $node2 = $doc-><M::Document.createProcessingInstruction> ('data');

        for my $node (<Code::tc|createNodesForTest+dt>) {
          $test->id ('appendChild.'.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.appendChild> ($node);
          }, exception_subtype => <Q::MDOMX|HIERARCHY_BAD_TYPE>);

          $test->id ('insertBefore.'.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.insertBefore> ($node);
          }, exception_subtype => <Q::MDOMX|HIERARCHY_BAD_TYPE>);

          $test->id ('replaceChild.'.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.replaceChild> ($node, $node2);
          }, exception_subtype => <Q::MDOMX|HIERARCHY_BAD_TYPE>);
        }

  @CMethod:
    @@Name: manakaiAppendText
    @@Param:
      @@@Name: string
      @@@Type: DOMString
      @@@enDesc:
        The string to append.
      @@@InCase:
        @@@@Type: DISPerl|SCALAR||ManakaiDOM|all
        @@@@enDesc:
          A copy of the string value referenced from the value
          is appended.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node itself.
      @@@NodeReadOnlyError:
      @@@disDef:
        @@@@DISPerl:cloneCode: tcd|ManakaiDOMCharacterData.manakaiAppendText

    @@Test:
      @@@QName: PI..=.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;

        my $node = $doc-><M::Document.createProcessingInstruction> ('d');

        $node-><M::Node.manakaiAppendText> ('aaaa');
        $test->id ('1.class');
        $test->assert_isa ($node, <IFName::ProcessingInstruction>);
        $test->id ('1.value');
        $test->assert_equals ($node-><AG::ProcessingInstruction.data>, 'aaaa');

        $test->id (2);
        $node-><M::Node.manakaiAppendText> ('bbbb');
        $test->assert_equals
                 ($node-><AG::ProcessingInstruction.data>, 'aaaabbbb');

  @CAttr:
    @@Name: nodeName
    @@enDesc:
      The node name.
    @@DOMMain:isNamespaceUnaware:1
    @@Type: DOMString
    @@Get:
      @@@disDef:
        @@@@DISPerl:cloneCode: .target.get

  @CAttr:
    @@Name: nodeValue
    @@enDesc:
      The value of the node.
    @@Type: DOMString
    @@Get:
      @@@PerlDef:
        __DEEP{
          $r = $self-><AG::ProcessingInstruction.data>;
        }__;
    @@Set:
      @@@NodeReadOnlyError:
      @@@PerlDef:
        __DEEP{
          $self-><AS::ProcessingInstruction.data> ($given);
        }__;

  @CL3Attr:
    @@Name: textContent
    @@enDesc:
      The text content of the node.
    @@Type: DOMString
    @@Get:
      @@@PerlDef:
        __DEEP{
          $r = $self-><AG::ProcessingInstruction.data>;
        }__;
    @@Set:
      @@@nullCase:
      @@@NodeReadOnlyError:
      @@@PerlDef:
        __DEEP{
          $self-><AS::ProcessingInstruction.data>
                   (defined $given ? $given : '');
        }__;

  @CL3Method:
    @@Name: getFeature
    @@enDesc:
      Returns a specialized object that implements the specialized APIs.
    @@Param:
      @@@Name: feature
      @@@Type: DOMString
      @@@dis:actualType: f|FeatureNameString
    @@Param:
      @@@Name: version
      @@@Type: DOMString
      @@@dis:actualType: f|FeatureVersionString
    @@Return:
      @@@Type: DOMMain|DOMObject
      @@@nullCase:
      @@@PerlDef:
        $feature =~ s/^\+//;
        __CODE{f|getFeatureImpl::
          $self => $self,
          $feature => $feature, $version => $version, $r => $r,
          $base_class => {<ClassName::ManakaiDOMProcessingInstruction>},
        }__;
        unless (defined $r) {
          __DEEP{
            $r = $self->SUPER::get_feature ($feature, $version);
          }__;
        }

    @@Test:
      @@@QName: PI.getFeature.test
      @@@PerlDef:
        my $node;
        __CODE{tx|createPIForTest:: $pi => $node}__;

        for (
          [Core => '1.0', <IFName::ProcessingInstruction||ManakaiDOM|ManakaiDOM1>],
          [Core => '2.0', <IFName::ProcessingInstruction||ManakaiDOM|ManakaiDOM2>],
          [Core => '3.0', <IFName::ProcessingInstruction||ManakaiDOM|ManakaiDOM3>],
          [XML => '1.0', <IFName::ProcessingInstruction||ManakaiDOM|ManakaiDOM1>],
          [XML => '2.0', <IFName::ProcessingInstruction||ManakaiDOM|ManakaiDOM2>],
          [XML => '3.0', <IFName::ProcessingInstruction||ManakaiDOM|ManakaiDOM3>],
        ) {
          $test->id ($_->[0].'.'.$_->[1]);
          my $sp = $node-><M::Node.getFeature> ($_->[0], $_->[1]);
          $test->assert_isa ($sp, $_->[2]);
        }

  @CL3Attr:
    @@Name: baseURI
    @@enDesc:
      The base URI of the node.
    @@Type: DOMString
    @@dis:actualType: ManakaiDOM|ManakaiDOMURI
    @@Get:
      @@@enDesc:
        The absolute base DOM URI of the node.
      @@@nullCase:
        @@@@enDesc:
          If the absolute base DOM URI is not available.
      @@@PerlDef:
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $r,
          $prop => {<H::infoset|baseURI>},
          $ref => {$self},
        }__;
        unless (defined $r) {
          __DEEP{
            my $node = $self-><AG::Node.parentNode>;
            W: {
              while (defined $node) {
                my $nt = $node-><AG::Node.nodeType>;
                if ($nt == <C::Node.ELEMENT_NODE> or
                    $nt == <C::Node.DOCUMENT_NODE> or
                    $nt == <C::Node.DOCUMENT_FRAGMENT_NODE> or
                    $nt == <C::Node.DOCUMENT_TYPE_NODE> or
                    $nt == <C::Node.ENTITY_NODE>) {
                  $r = $node-><AG::Node.baseURI>;
                  last W;
                } elsif ($nt == <C::Node.ENTITY_REFERENCE_NODE>) {
                  if ($node-><AG::EntityReference.manakaiExternal>) {
                    $r = $node-><AG::EntityReference.manakaiEntityBaseURI>;
                    last W;
                  }
                }
                $node = $node-><AG::Node.parentNode>;
              }
              if ($node) {
                $r = $node-><AG::Node.baseURI>;
              } else {
                $r = $self-><AG::Node.ownerDocument>-><AG::Node.baseURI>;
              }
            } # W
          }__;
        }

    @@LXTest:
      @@@QName: PI.baseURI.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $pi = $doc-><M::Document.createProcessingInstruction> ('i');
       
        $test->id ('default');
        $test->assert_null ($pi-><AG::Node.baseURI>);
        $test->assert_null ($pi-><AG::ProcessingInstruction.manakaiBaseURI>);

        $test->id ('doc');
        $doc-><AS::Document.documentURI> (q<http://doc.test/>);
        $test->assert_equals
                 ($pi-><AG::Node.baseURI>,
                  q<http://doc.test/>);
        $test->assert_null ($pi-><AG::ProcessingInstruction.manakaiBaseURI>);

        $test->id ('el');
        my $el = $doc-><M::Document.createElementNS> (null, 'e');
        $el-><M::Element.setAttributeNS> (<Q::xml:>, 'xml:base',
                                          q<http://el.test/>);
        $el-><M::Node.appendChild> ($pi);
        $test->assert_equals
                 ($pi-><AG::Node.baseURI>,
                  q<http://el.test/>);
        $test->assert_null ($pi-><AG::ProcessingInstruction.manakaiBaseURI>);

        $test->id ('ent');
        my $ent = $doc-><M::Document.createEntityReference> ('ent');
        $ent-><M::Node.manakaiSetReadOnly> (false, true);
        $ent-><AS::EntityReference.manakaiExternal> (true);
        $ent-><AS::EntityReference.manakaiEntityBaseURI> (q<http://ent.test/>);
        $el-><M::Node.appendChild> ($ent);
        $ent-><M::Node.appendChild> ($pi);
        $test->assert_equals
                 ($pi-><AG::Node.baseURI>,
                  q<http://ent.test/>);
        $test->assert_null ($pi-><AG::ProcessingInstruction.manakaiBaseURI>);

        $test->id ('pi');
        $pi-><AS::ProcessingInstruction.manakaiBaseURI> (q<http://pi.ent/>);
        $test->assert_equals
                 ($pi-><AG::Node.baseURI>,
                  q<http://pi.ent/>);
        $test->assert_equals
                 ($pi-><AG::ProcessingInstruction.manakaiBaseURI>,
                  q<http://pi.ent/>);

        $test->id ('pi.unset');
        $pi-><AS::ProcessingInstruction.manakaiBaseURI> (null);
        $test->assert_equals
                 ($pi-><AG::Node.baseURI>,
                  q<http://ent.test/>);
        $test->assert_null ($pi-><AG::ProcessingInstruction.manakaiBaseURI>);

  @Attr:
    @@Name: target
    @@enDesc:
      The target of the processing instruction.
    @@DOMMain:isNamespaceUnaware:1
    @@Type: DOMString
    @@Get:
      @@@PerlDef:
        my $v;
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $v,
          $prop => {<H::infoset|target>},
          $ref => {$self},
        }__;
        $r = $$v;

    @@Test:
      @@@QName: PI.nodeName.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $pi = $doc-><M::Document.createProcessingInstruction> ('pi');

        $test->id ('nodeName');
        $test->assert_equals ($pi-><AG::Node.nodeName>, 'pi');

        $test->id ('target');
        $test->assert_equals ($pi-><AG::ProcessingInstruction.target>, 'pi');

  @Attr:
    @@Name: data
    @@enDesc:
      The content of the processing instruction, i.e. the first 
      non white space character after the target to the character
      immediately preceding the <XML::?<gt>>.
    @@enImplNote:
      Difference between <XML::<lt>?target?<gt>> and <XML::<lt>?target ?<gt>>
      are not preserved in DOM <SRC::manakai>.
    @@Type: DOMString
    @@Get:
      @@@PerlDef:
        my $v;
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $v,
          $prop => {<H::infoset|content>},
          $ref => {$self},
        }__;
        $r = $$v;
    @@Set:
      @@@NodeReadOnlyError:
      @@@PerlDef:
        __CODE{tc|NodeReadOnlyError:: $node => $self}__;
        __CODE{mg|setNodeStemPropValue||ManakaiDOM|all::
          $given => {\$given},
          $prop => {<H::infoset|content>},
          $ref => $self,
        }__;

    @@Test:
      @@@QName: PI.nodeValue.textContent.data.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
  
        for my $node (
          $doc-><M::Document.createProcessingInstruction> ('pi', 'initial'),
        ) {
          $test->id ('nodeValue.get');
          $test->assert_equals ($node-><AG::Node.nodeValue>, 'initial');

          $test->id ('textContent.get');
          $test->assert_equals ($node-><AG::Node.textContent>, 'initial');

          $test->id ('data.get');
          $test->assert_equals ($node-><AG::ProcessingInstruction.data>,
                                'initial');

          $node-><M::Node.manakaiSetReadOnly> (false);

          $node-><AS::Node.nodeValue> ('value1');

          $test->id ('nodeValue.set.nodeValue');
          $test->assert_equals ($node-><AG::Node.nodeValue>, 'value1');

          $test->id ('nodeValue.set.textContent');
          $test->assert_equals ($node-><AG::Node.textContent>, 'value1');

          $test->id ('nodeValue.set.data');
          $test->assert_equals ($node-><AG::ProcessingInstruction.data>,
                                'value1');

          $node-><AS::Node.nodeValue> ('');

          $test->id ('nodeValue.empty.nodeValue');
          $test->assert_equals ($node-><AG::Node.nodeValue>, '');

          $test->id ('nodeValue.empty.textContent');
          $test->assert_equals ($node-><AG::Node.textContent>, '');

          $test->id ('nodeValue.empty.data');
          $test->assert_equals ($node-><AG::ProcessingInstruction.data>, '');

          $node-><AS::Node.textContent> ('value3');

          $test->id ('textContent.set.nodeValue');
          $test->assert_equals ($node-><AG::Node.nodeValue>, 'value3');

          $test->id ('textContent.set.textContent');
          $test->assert_equals ($node-><AG::Node.textContent>, 'value3');

          $test->id ('textContent.set.data');
          $test->assert_equals ($node-><AG::ProcessingInstruction.data>,
                                'value3');

          $node-><AS::Node.textContent> ('');

          $test->id ('textContent.empty.nodeValue');
          $test->assert_equals ($node-><AG::Node.nodeValue>, '');

          $test->id ('textContent.empty.textContent');
          $test->assert_equals ($node-><AG::Node.textContent>, '');

          $test->id ('textContent.empty.data');
          $test->assert_equals ($node-><AG::ProcessingInstruction.data>, '');

          $node-><AS::Node.textContent> ('value4');
          $node-><AS::Node.textContent> (null);

          $test->id ('textContent.null.nodeValue');
          $test->assert_equals ($node-><AG::Node.nodeValue>, '');

          $test->id ('textContent.null.textContent');
          $test->assert_equals ($node-><AG::Node.textContent>, '');

          $test->id ('textContent.null.data');
          $test->assert_equals ($node-><AG::ProcessingInstruction.data>, '');

          $node-><AS::ProcessingInstruction.data> ('value2');

          $test->id ('data.set.nodeValue');
          $test->assert_equals ($node-><AG::Node.nodeValue>, 'value2');

          $test->id ('data.set.textContent');
          $test->assert_equals ($node-><AG::Node.textContent>, 'value2');

          $test->id ('data.set.data');
          $test->assert_equals ($node-><AG::ProcessingInstruction.data>,
                                'value2');
     
          $node-><AS::ProcessingInstruction.data> ('');

          $test->id ('data.empty.nodeValue');
          $test->assert_equals ($node-><AG::Node.nodeValue>, '');

          $test->id ('data.empty.textContent');
          $test->assert_equals ($node-><AG::Node.textContent>, '');

          $test->id ('data.empty.data');
          $test->assert_equals ($node-><AG::ProcessingInstruction.data>, '');

          $node-><M::Node.manakaiSetReadOnly> (true);

          $test->id ('nodeValue.set.ro');
          $test->assert_exception (code => sub {
            $node-><AS::Node.nodeValue> ('value1');
          }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);
          $test->assert_equals ($node-><AG::Node.nodeValue>, '');

          $test->id ('textContent.set.ro');
          $test->assert_exception (code => sub {
            $node-><AS::Node.textContent> ('value1');
          }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);
          $test->assert_equals ($node-><AG::Node.nodeValue>, '');

          $test->id ('data.set.ro');
          $test->assert_exception (code => sub {
            $node-><AS::ProcessingInstruction.data> ('value1');
          }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);
          $test->assert_equals ($node-><AG::Node.nodeValue>, '');
        }

  @LXAttr:
    @@Name: manakaiBaseURI
    @@enDesc:
      The base DOM URI of the node.
    @@Type: DOMString
    @@dis:actualType: ManakaiDOM|ManakaiDOMURI
    @@Get:
      @@@enDesc:
        The base DOM URI of the element, if it is explicitly set
        to the element.

          {NOTE::
            This attribute is similar to the <InfoProp::base URI>
            property for element information items in the XML
            Information Set.
          }

          {NOTE::
            To obtain the computed base URI of the element,
            use the <A::Node.baseURI> attribute.
          }
      @@@nullCase:
        @@@@enDesc:
          If no explicit base DOM URI is available.
      @@@disDef:
        @@@@DISPerl:cloneCode: te|ManakaiDOMElement.manakaiBaseURI.get
    @@Set:
      @@@enDesc:
        Sets the base DOM URI of the node.  It <kwd:MUST> be an 
        absolute DOM URI; however, no lexical checking is performed
        on setting.  It is similar to the <InfoProp::base URI>
        property in the XML Information Set.
      @@@nullCase:
        @@@@enDesc:
          Removes the explicit value of the base DOM URI of the node.
          It does not affect to the base URI of the entity or element
          in which the node is contained.
      @@@NodeReadOnlyError:
      @@@disDef:
        @@@@DISPerl:cloneCode: te|ManakaiDOMElement.manakaiBaseURI.set
##ProcessingInstruction
