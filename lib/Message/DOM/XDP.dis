Module:
  @QName: MDOM|XDP
  @enFN:
    XDP DOM
  @enDesc:
    The <DFN::XDP>, <DFN::XML DTD Physical Structure DOM>
    provides facility to compose XML DTD with its physical
    structure.

  @Namespace:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/DOM/XDP/

  @DISCore:author: DISCore|Wakaba
  @License: license|Perl+MPL
  @Date:
    $Date: 2006/05/21 08:55:21 $

  @Require:
    @@Module:
      @@@QName: Markup|common
    @@Module:
      @@@QName: MDOM|TreeCore
      @@@WithFor: ManakaiDOM|ManakaiDOMLatest
    @@Module:
      @@@WithFor: ManakaiDOM|ManakaiDOM
    @@Module:
      @@@WithFor: ManakaiDOM|ManakaiDOMLatest
  @DefaultFor: ManakaiDOM|ManakaiDOMLatest

Namespace:
  @atom:
    http://www.w3.org/2005/Atom
  @c:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#
  @cfg:
    http://suika.fam.cx/www/2006/dom-config/
  @dis:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#dis--
  @doc:
    http://suika.fam.cx/~wakaba/archive/2005/7/tutorial#
  @d:
    http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#
  @DOMMain:
    http://suika.fam.cx/~wakaba/archive/2004/dom/main#
  @dx:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#
  @ecore:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/Core/
  @f:
    http://suika.fam.cx/~wakaba/archive/2004/dom/feature#
  @fe:
    http://suika.fam.cx/www/2006/feature/
  @html:
    http://www.w3.org/1999/xhtml
  @idl:
    http://suika.fam.cx/~wakaba/archive/2004/dis/IDL#
  @kwd:
    http://suika.fam.cx/~wakaba/archive/2005/rfc2119/
  @lang:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#
  @license:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/license#
  @ManakaiDOM:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#
  @Markup:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Markup#
  @mat:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Markup/Atom/
  @MDOM:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#ManakaiDOM.
  @MDOMX:
    http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#
  @dlp:
    http://suika.fam.cx/~wakaba/archive/2004/dis/Perl#
  @rel:
    http://www.iana.org/assignments/relation/
  @s:
    http://suika.fam.cx/~wakaba/archive/2004/dis/Markup#
  @tc:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/DOM/TreeCore/
  @td:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/DOM/Document/
  @te:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/DOM/Element/
  @test:
    http://suika.fam.cx/~wakaba/archive/2004/dis/Test#
  @trv:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/DOM/Traversal/
  @tx:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/DOM/XML/
  @urigen:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/URI/Generic/
  @xdp:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/DOM/XDP/
  @xml:
    http://www.w3.org/XML/1998/namespace

ElementTypeBinding:
  @Name: CODE
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: dlp|BlockCode
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: Method
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|Method
    @@ForCheck: !=ManakaiDOM|ManakaiDOM

ElementTypeBinding:
  @Name: Param
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|MethodParameter

ElementTypeBinding:
  @Name: Return
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|MethodReturn

ElementTypeBinding:
  @Name: Attr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|Attribute
    @@ForCheck: !=ManakaiDOM|ManakaiDOM

ElementTypeBinding:
  @Name: CAttr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|Attribute
    @@ForCheck: !=ManakaiDOM|ManakaiDOM ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: Get
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|AttributeGet

ElementTypeBinding:
  @Name: Set
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|AttributeSet

ElementTypeBinding:
  @Name: nullCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: ManakaiDOM|InCase
    @@Value:
      @@@is-null:1

ElementTypeBinding:
  @Name: PerlDef
  @ElementType:
    dis:Def
  @ShadowContent:
    @@ContentType: lang|Perl
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: PerlCDef
  @ElementType:
    dis:Def
  @ShadowContent:
    @@ContentType: lang|Perl

ElementTypeBinding:
  @Name: enImplNote
  @ElementType:
    dis:ImplNote
  @ShadowContent:
    @@lang:en

ElementTypeBinding:
  @Name: enFN
  @ElementType:
    dis:FullName
  @ShadowContent:
    @@lang:en

ElementTypeBinding:
  @Name: IFClsETDef
  @ElementType: 
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType:
      @@@@: dis|MultipleResource
      @@@ForCheck: !ManakaiDOM|ForIF !ManakaiDOM|ForClass !s|ForML
    @@resourceFor: ManakaiDOM|ForIF
    @@resourceFor: ManakaiDOM|ForClass
    @@resourceFor: s|ForML
    @@For: ManakaiDOM|ManakaiDOM

    @@DISCore:resourceType:
      @@@@: DISLang|Interface
      @@@ForCheck: ManakaiDOM|ForIF

    @@DISCore:resourceType:
      @@@@: DISLang|Class
      @@@ForCheck: ManakaiDOM|ForClass
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOM||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOMLatest||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOMLatest

    @@s:elementType:
      @@@@: ||+||s|ForML
      @@@ContentType: DISCore|TFPQNames
      @@@DISCore:stopISARecursive:1

    @@DISCore:resourceType:
      @@@@: s|ElementType
      @@@ForCheck: s|ForML

    @@f:implements: XDPFeature30

ElementTypeBinding:
  @Name: IFClsDef
  @ElementType: 
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType:
      @@@@: dis|MultipleResource
      @@@ForCheck: !ManakaiDOM|ForIF !ManakaiDOM|ForClass !s|ForML
    @@resourceFor: ManakaiDOM|ForIF
    @@resourceFor: ManakaiDOM|ForClass
    @@For: ManakaiDOM|ManakaiDOM

    @@DISCore:resourceType:
      @@@@: DISLang|Interface
      @@@ForCheck: ManakaiDOM|ForIF

    @@DISCore:resourceType:
      @@@@: DISLang|Class
      @@@ForCheck: ManakaiDOM|ForClass
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOM||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOMLatest||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOMLatest

    @@f:implements: XDPFeature30

ElementTypeBinding:
  @Name: IFQName
  @ElementType:
    dis:QName
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForIF

ElementTypeBinding:
  @Name: ClsQName
  @ElementType:
    dis:QName
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: ETRQName
  @ElementType:
    dis:QName
  @ShadowContent:
    @@ForCheck: s|ForML

ElementTypeBinding:
  @Name: ETQName
  @ElementType:
    dis:AppName
  @ShadowContent:
    @@ForCheck: s|ForML
    @@ContentType: DISCore|QName

ElementTypeBinding:
  @Name: IFISA
  @ElementType:
    dis:ISA
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForIF

ElementTypeBinding:
  @Name: ClsISA
  @ElementType:
    dis:ISA
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: disDef
  @ElementType:
    dis:Def
  @ShadowContent:
    @@ContentType:
      lang:dis
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: Code
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: dlp|InlineCode
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: Test
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: test|StandaloneTest
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: TestC
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: test|StandaloneTest

ResourceDef:
  @QName: Document
  @AliasFor: td|Document
  @For: ManakaiDOM|DOM

ResourceDef:
  @QName: Element
  @AliasFor: te|Element
  @For: ManakaiDOM|DOM

ResourceDef:
  @QName: Attr
  @AliasFor: te|Attr
  @For: ManakaiDOM|DOM

ResourceDef:
  @QName: Text
  @AliasFor: te|Text
  @For: ManakaiDOM|DOM

ResourceDef:
  @QName: DOMString
  @AliasFor: DOMMain|DOMString
  @For: ManakaiDOM|DOM

ResourceDef:
  @QName: boolean
  @AliasFor: idl|boolean||ManakaiDOM|all

ResourceDef:
  @QName: Node
  @AliasFor: tc|Node
  @For: ManakaiDOM|ManakaiDOM

ResourceDef:
  @QName: NodeFilter
  @AliasFor: trv|NodeFilter
  @For: ManakaiDOM|DOM2

ResourceDef:
  @QName: TreeWalker
  @AliasFor: trv|TreeWalker
  @For: ManakaiDOM|DOM2

ElementTypeBinding:
  @Name: enDesc
  @ElementType:
    dis:Description
  @ShadowContent:
    @@lang:en

ElementTypeBinding:
  @Name: TrueCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType:
      ManakaiDOM:InCase
    @@Value:
      @@@@: 1
      @@@ContentType: DISCore|Boolean
    @@Type: idl|boolean||ManakaiDOM|all

ElementTypeBinding:
  @Name: FalseCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType:
      ManakaiDOM:InCase
    @@Value:
      @@@@: 0
      @@@ContentType: DISCore|Boolean
    @@Type: idl|boolean||ManakaiDOM|all

## -- Features

ElementTypeBinding:
  @Name: FeatureDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: f|Feature
    @@For: =ManakaiDOM|all

ElementTypeBinding:
  @Name: FeatureVerDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: f|Feature

ElementTypeBinding:
  @Name: featureQName
  @ElementType:
    f:name
  @ShadowContent:
    @@ContentType: DISCore|QName

FeatureDef:
  @featureQName: fe|XDP
  @QName: XDPFeature
  @FeatureVerDef:
    @@QName: XDPFeature30
    @@Version: 3.0
    @@f:instanceOf: XDPFeature
    @@f:requires: tx|XMLFeature30
    @@enDesc:
      The XDP DOM, version 3.0.

## -- Document

IFClsDef:
  @IFQName: XDPDocument
  @ClsQName: ManakaiDOMXDPDocument

  @IFISA: Document
  @ClsISA: td|ManakaiDOMDocument

  @f:implements: XDPFeature30
  @f:provides:
    @@@: XDPFeature30
    @@f:through: c|ManakaiDOMImplementation

  @enDesc:
    The <IF::XDPDocument> interface provides a set of methods
    to create instances of XDP interfaces.

    If the implementation supports the <Feature::fe|XDP> feature
    version <Feature::3.0>, <IF::Document> objects <kwd:MUST> also
    implement the <IF::XDPDocument> interface.

  @Test:
    @@QName: XDPDocument.interface.test
    @@PerlDef:
      for (
        <IFName::XDPDocument>,
        <IFName::Document>,
        <IFName::Node>,
        <IFName::f|GetFeature>,
      ) {
        $test->id ($_);
        $test->assert_true (<Class::ManakaiDOMXDPDocument>->isa ($_));
      }

  @Test:
    @@QName: Document.getFeature.XDPDocument.test
    @@PerlDef:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
      my $docp = $doc->get_feature (<Q::fe|XDP>, '3.0');

      $test->id ($docp, <IFName::XDPDocument>);

  @CODE:
    @@QName: createXDPDocumentForTest
    @@PerlDef:
      my $__edoc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $__edoc}__;
      $doc = $__edoc->get_feature (<Q::fe|XDP> => '3.0');

  @Method:
    @@Name: createXDPS
    @@dlp:methodName: create_xdp_s
    @@enDesc:
      Creates a <XE::xdp|s> element.
    @@Param:
      @@@Name: value
      @@@Type: DOMString
      @@@enDesc:
        The value of the element.
      @@@nullCase:
        @@@@enDesc:
          The element's <A::Node.textContent> is set to
          a <CHAR::SPACE>.
    @@Return:
      @@@Type: XDPElement
      @@@enDesc:
        The newly created element node.

        {P:: A new <IF::Element> node with following attributes
             <kwd:MUST> be returned:

           - <A::Node.localName>::: <XE::s>.

           - <A::Node.namespaceURI>::: <URI^^DISCore|QName::xdp|>.

           - <A::Node.ownerDocument>::: The document.

           - <A::Node.textContent>::: <P::value>, or a <CHAR::SPACE>
                                      if <P::value> is <DOM::null>.
           
        }

        If a <IF::Text> node is created, its
        <A::Text.isElementContentWhitespace> attribute value
        <kwd:MUST> be set to <DOM::false>.
      @@@PerlDef:
        __DEEP{
          $r = $self-><M::Document.createElementNS> (<Q::xdp|>, 's');
          $r-><AS::Node.textContent> (defined $value ? $value : ' ');
        }__;

    @@Test:
      @@@QName: XDPDocument.createXDPS.1.test
      @@@PerlDef:
        my $doc;
        __CODE{createXDPDocumentForTest}__;

        my $value = "\t";
        my $el = $doc-><M::XDPDocument.createXDPS> ($value);

        $test->id ('interface');
        $test->assert_isa ($el, <IFName::XDPElement>);

        $test->id ('namespaceURI');
        $test->assert_equals ($el-><AG::Node.namespaceURI>, <Q::xdp|>);

        $test->id ('localName');
        $test->assert_equals ($el-><AG::Node.localName>, 's');

        $test->id ('textContent');
        $test->assert_equals ($el-><AG::Node.textContent>, $value);

        $test->id ('dtdText');
        $test->assert_equals ($el-><AG::XDPElement.dtdText>, $value);
    @@Test:
      @@@QName: XDPDocument.createXDPS.2.test
      @@@PerlDef:
        my $doc;
        __CODE{createXDPDocumentForTest}__;

        my $value = null;
        my $el = $doc-><M::XDPDocument.createXDPS> ($value);

        $test->id ('interface');
        $test->assert_isa ($el, <IFName::XDPElement>);

        $test->id ('namespaceURI');
        $test->assert_equals ($el-><AG::Node.namespaceURI>, <Q::xdp|>);

        $test->id ('localName');
        $test->assert_equals ($el-><AG::Node.localName>, 's');

        $test->id ('textContent');
        $test->assert_equals ($el-><AG::Node.textContent>, ' ');

        $test->id ('dtdText');
        $test->assert_equals ($el-><AG::XDPElement.dtdText>, ' ');

  @Method:
    @@Name: createXDPName
    @@enDesc:
      Creates a <XE::xdp|name> element.
    @@Param:
      @@@Name: value
      @@@Type: DOMString
      @@@enDesc:
        The value of the element.
      @@@nullCase:
        @@@@enDesc:
          Same as an empty string.
    @@Return:
      @@@Type: XDPElement
      @@@enDesc:
        The newly created element node.

        {P:: A new <IF::Element> node with following attributes
             <kwd:MUST> be returned:

           - <A::Node.localName>::: <XE::name>.

           - <A::Node.namespaceURI>::: <URI^^DISCore|QName::xdp|>.

           - <A::Node.ownerDocument>::: The document.

           - <A::Node.textContent>::: <P::value>, or an empty
                                      string if <P::value> is <DOM::null>.
           
        }

        If a <IF::Text> node is created, its
        <A::Text.isElementContentWhitespace> attribute value
        <kwd:MUST> be set to <DOM::false>.
      @@@PerlDef:
        __DEEP{
          $r = $self-><M::Document.createElementNS> (<Q::xdp|>, 'name');
          $r-><AS::Node.textContent> (defined $value ? $value : '');
        }__;

    @@Test:
      @@@QName: XDPDocument.createXDPName.1.test
      @@@PerlDef:
        my $doc;
        __CODE{createXDPDocumentForTest}__;

        my $value = "example-name";
        my $el = $doc-><M::XDPDocument.createXDPName> ($value);

        $test->id ('interface');
        $test->assert_isa ($el, <IFName::XDPElement>);

        $test->id ('namespaceURI');
        $test->assert_equals ($el-><AG::Node.namespaceURI>, <Q::xdp|>);

        $test->id ('localName');
        $test->assert_equals ($el-><AG::Node.localName>, 'name');

        $test->id ('textContent');
        $test->assert_equals ($el-><AG::Node.textContent>, $value);

        $test->id ('dtdText');
        $test->assert_equals ($el-><AG::XDPElement.dtdText>, $value);
    @@Test:
      @@@QName: XDPDocument.createXDPName.2.test
      @@@PerlDef:
        my $doc;
        __CODE{createXDPDocumentForTest}__;

        my $value = "example-name";
        my $el = $doc-><M::XDPDocument.createXDPName> (null);

        $test->id ('interface');
        $test->assert_isa ($el, <IFName::XDPElement>);

        $test->id ('namespaceURI');
        $test->assert_equals ($el-><AG::Node.namespaceURI>, <Q::xdp|>);

        $test->id ('localName');
        $test->assert_equals ($el-><AG::Node.localName>, 'name');

        $test->id ('textContent');
        $test->assert_equals ($el-><AG::Node.textContent>, '');

        $test->id ('dtdText');
        $test->assert_equals ($el-><AG::XDPElement.dtdText>, '');

  @Method:
    @@Name: createXDPNmtoken
    @@enDesc:
      Creates a <XE::xdp|nmtoken> element.
    @@Param:
      @@@Name: value
      @@@Type: DOMString
      @@@enDesc:
        The value of the element.
      @@@nullCase:
        @@@@enDesc:
          Same as an empty string.
    @@Return:
      @@@Type: XDPElement
      @@@enDesc:
        The newly created element node.

        {P:: A new <IF::Element> node with following attributes
             <kwd:MUST> be returned:

           - <A::Node.localName>::: <XE::nmtoken>.

           - <A::Node.namespaceURI>::: <URI^^DISCore|QName::xdp|>.

           - <A::Node.ownerDocument>::: The document.

           - <A::Node.textContent>::: <P::value>, or an empty
                                      string if <P::value> is <DOM::null>.
           
        }

        If a <IF::Text> node is created, its
        <A::Text.isElementContentWhitespace> attribute value
        <kwd:MUST> be set to <DOM::false>.
      @@@PerlDef:
        __DEEP{
          $r = $self-><M::Document.createElementNS> (<Q::xdp|>, 'nmtoken');
          $r-><AS::Node.textContent> (defined $value ? $value : '');
        }__;

    @@Test:
      @@@QName: XDPDocument.createXDPNmtoken.1.test
      @@@PerlDef:
        my $doc;
        __CODE{createXDPDocumentForTest}__;

        my $value = "example-name";
        my $el = $doc-><M::XDPDocument.createXDPNmtoken> ($value);

        $test->id ('interface');
        $test->assert_isa ($el, <IFName::XDPElement>);

        $test->id ('namespaceURI');
        $test->assert_equals ($el-><AG::Node.namespaceURI>, <Q::xdp|>);

        $test->id ('localName');
        $test->assert_equals ($el-><AG::Node.localName>, 'nmtoken');

        $test->id ('textContent');
        $test->assert_equals ($el-><AG::Node.textContent>, $value);

        $test->id ('dtdText');
        $test->assert_equals ($el-><AG::XDPElement.dtdText>, $value);
    @@Test:
      @@@QName: XDPDocument.createXDPNmtoken.2.test
      @@@PerlDef:
        my $doc;
        __CODE{createXDPDocumentForTest}__;

        my $el = $doc-><M::XDPDocument.createXDPNmtoken> (null);

        $test->id ('interface');
        $test->assert_isa ($el, <IFName::XDPElement>);

        $test->id ('namespaceURI');
        $test->assert_equals ($el-><AG::Node.namespaceURI>, <Q::xdp|>);

        $test->id ('localName');
        $test->assert_equals ($el-><AG::Node.localName>, 'nmtoken');

        $test->id ('textContent');
        $test->assert_equals ($el-><AG::Node.textContent>, '');

        $test->id ('dtdText');
        $test->assert_equals ($el-><AG::XDPElement.dtdText>, '');

  @Method:
    @@Name: createXDPKeyword
    @@enDesc:
      Creates a <XE::xdp|keyword> element.
    @@Param:
      @@@Name: value
      @@@Type: DOMString
      @@@enDesc:
        The value of the element.
      @@@nullCase:
        @@@@enDesc:
          Same as an empty string.
    @@Return:
      @@@Type: XDPElement
      @@@enDesc:
        The newly created element node.

        {P:: A new <IF::Element> node with following attributes
             <kwd:MUST> be returned:

           - <A::Node.localName>::: <XE::keyword>.

           - <A::Node.namespaceURI>::: <URI^^DISCore|QName::xdp|>.

           - <A::Node.ownerDocument>::: The document.

           - <A::Node.textContent>::: <P::value>, or an empty
                                      string if <P::value> is <DOM::null>.
           
        }

        If a <IF::Text> node is created, its
        <A::Text.isElementContentWhitespace> attribute value
        <kwd:MUST> be set to <DOM::false>.
      @@@PerlDef:
        __DEEP{
          $r = $self-><M::Document.createElementNS> (<Q::xdp|>, 'keyword');
          $r-><AS::Node.textContent> (defined $value ? $value : '');
        }__;

    @@Test:
      @@@QName: XDPDocument.createXDPKeyword.1.test
      @@@PerlDef:
        my $doc;
        __CODE{createXDPDocumentForTest}__;

        my $value = "PUBLIC";
        my $el = $doc-><M::XDPDocument.createXDPKeyword> ($value);

        $test->id ('interface');
        $test->assert_isa ($el, <IFName::XDPElement>);

        $test->id ('namespaceURI');
        $test->assert_equals ($el-><AG::Node.namespaceURI>, <Q::xdp|>);

        $test->id ('localName');
        $test->assert_equals ($el-><AG::Node.localName>, 'keyword');

        $test->id ('textContent');
        $test->assert_equals ($el-><AG::Node.textContent>, $value);

        $test->id ('dtdText');
        $test->assert_equals ($el-><AG::XDPElement.dtdText>, $value);
    @@Test:
      @@@QName: XDPDocument.createXDPKeyword.2.test
      @@@PerlDef:
        my $doc;
        __CODE{createXDPDocumentForTest}__;

        my $el = $doc-><M::XDPDocument.createXDPKeyword> (null);

        $test->id ('interface');
        $test->assert_isa ($el, <IFName::XDPElement>);

        $test->id ('namespaceURI');
        $test->assert_equals ($el-><AG::Node.namespaceURI>, <Q::xdp|>);

        $test->id ('localName');
        $test->assert_equals ($el-><AG::Node.localName>, 'keyword');

        $test->id ('textContent');
        $test->assert_equals ($el-><AG::Node.textContent>, '');

        $test->id ('dtdText');
        $test->assert_equals ($el-><AG::XDPElement.dtdText>, '');

  @Method:
    @@Name: createXDPRNIKeyword
    @@dlp:methodName: create_xdp_rni_keyword
    @@enDesc:
      Creates a <XE::xdp|rni-keyword> element.
    @@Param:
      @@@Name: value
      @@@Type: DOMString
      @@@enDesc:
        The value of the element.
      @@@nullCase:
        @@@@enDesc:
          Same as an empty string.
    @@Return:
      @@@Type: XDPRNIKeywordElement
      @@@enDesc:
        The newly created element node.

        {P:: A new <IF::Element> node with following attributes
             <kwd:MUST> be returned:

           - <A::Node.localName>::: <XE::rni-keyword>.

           - <A::Node.namespaceURI>::: <URI^^DISCore|QName::xdp|>.

           - <A::Node.ownerDocument>::: The document.

           - <A::Node.textContent>::: <P::value>, or an empty
                                      string if <P::value> is <DOM::null>.
           
        }

        If a <IF::Text> node is created, its
        <A::Text.isElementContentWhitespace> attribute value
        <kwd:MUST> be set to <DOM::false>.
      @@@PerlDef:
        __DEEP{
          $r = $self-><M::Document.createElementNS> (<Q::xdp|>, 'rni-keyword');
          $r-><AS::Node.textContent> (defined $value ? $value : '');
        }__;

    @@Test:
      @@@QName: XDPDocument.createXDPRNIKeyword.1.test
      @@@PerlDef:
        my $doc;
        __CODE{createXDPDocumentForTest}__;

        my $value = "PCDATA";
        my $el = $doc-><M::XDPDocument.createXDPRNIKeyword> ($value);

        $test->id ('interface');
        $test->assert_isa ($el, <IFName::XDPElement>);

        $test->id ('namespaceURI');
        $test->assert_equals ($el-><AG::Node.namespaceURI>, <Q::xdp|>);

        $test->id ('localName');
        $test->assert_equals ($el-><AG::Node.localName>, 'rni-keyword');

        $test->id ('textContent');
        $test->assert_equals ($el-><AG::Node.textContent>, $value);

        $test->id ('dtdText');
        $test->assert_equals ($el-><AG::XDPElement.dtdText>, '#'.$value);
    @@Test:
      @@@QName: XDPDocument.createXDPRNIKeyword.2.test
      @@@PerlDef:
        my $doc;
        __CODE{createXDPDocumentForTest}__;

        my $el = $doc-><M::XDPDocument.createXDPRNIKeyword> (null);

        $test->id ('interface');
        $test->assert_isa ($el, <IFName::XDPElement>);

        $test->id ('namespaceURI');
        $test->assert_equals ($el-><AG::Node.namespaceURI>, <Q::xdp|>);

        $test->id ('localName');
        $test->assert_equals ($el-><AG::Node.localName>, 'rni-keyword');

        $test->id ('textContent');
        $test->assert_equals ($el-><AG::Node.textContent>, '');

        $test->id ('dtdText');
        $test->assert_equals ($el-><AG::XDPElement.dtdText>, '#');

  @Method:
    @@Name: createXDPDelimiter
    @@enDesc:
      Creates a <XE::xdp|delimiter> element.
    @@Param:
      @@@Name: value
      @@@Type: DOMString
      @@@enDesc:
        The value of the element.
      @@@nullCase:
        @@@@enDesc:
          Same as an empty string.
    @@Return:
      @@@Type: XDPElement
      @@@enDesc:
        The newly created element node.

        {P:: A new <IF::Element> node with following attributes
             <kwd:MUST> be returned:

           - <A::Node.localName>::: <XE::delimiter>.

           - <A::Node.namespaceURI>::: <URI^^DISCore|QName::xdp|>.

           - <A::Node.ownerDocument>::: The document.

           - <A::Node.textContent>::: <P::value>, or an empty
                                      string if <P::value> is <DOM::null>.
           
        }

        If a <IF::Text> node is created, its
        <A::Text.isElementContentWhitespace> attribute value
        <kwd:MUST> be set to <DOM::false>.
      @@@PerlDef:
        __DEEP{
          $r = $self-><M::Document.createElementNS> (<Q::xdp|>, 'delimiter');
          $r-><AS::Node.textContent> (defined $value ? $value : '');
        }__;

    @@Test:
      @@@QName: XDPDocument.createXDPDelimiter.1.test
      @@@PerlDef:
        my $doc;
        __CODE{createXDPDocumentForTest}__;

        my $value = "%";
        my $el = $doc-><M::XDPDocument.createXDPDelimiter> ($value);

        $test->id ('interface');
        $test->assert_isa ($el, <IFName::XDPElement>);

        $test->id ('namespaceURI');
        $test->assert_equals ($el-><AG::Node.namespaceURI>, <Q::xdp|>);

        $test->id ('localName');
        $test->assert_equals ($el-><AG::Node.localName>, 'delimiter');

        $test->id ('textContent');
        $test->assert_equals ($el-><AG::Node.textContent>, $value);

        $test->id ('dtdText');
        $test->assert_equals ($el-><AG::XDPElement.dtdText>, $value);
    @@Test:
      @@@QName: XDPDocument.createXDPDelimiter.2.test
      @@@PerlDef:
        my $doc;
        __CODE{createXDPDocumentForTest}__;

        my $el = $doc-><M::XDPDocument.createXDPDelimiter> (null);

        $test->id ('interface');
        $test->assert_isa ($el, <IFName::XDPElement>);

        $test->id ('namespaceURI');
        $test->assert_equals ($el-><AG::Node.namespaceURI>, <Q::xdp|>);

        $test->id ('localName');
        $test->assert_equals ($el-><AG::Node.localName>, 'delimiter');

        $test->id ('textContent');
        $test->assert_equals ($el-><AG::Node.textContent>, '');

        $test->id ('dtdText');
        $test->assert_equals ($el-><AG::XDPElement.dtdText>, '');

  @Method:
    @@Name: createXDPEntityValue
    @@enDesc:
      Creates a <XE::xdp|entity-value> element.
    @@Param:
      @@@Name: value
      @@@Type: DOMString
      @@@enDesc:
        The value of the element.
      @@@nullCase:
        @@@@enDesc:
          Same as an empty string.
    @@Return:
      @@@Type: XDPEntityValueElement
      @@@enDesc:
        The newly created element node.

        {P:: A new <IF::Element> node with following attributes
             <kwd:MUST> be returned:

           - <A::Node.localName>::: <XE::entity-value>.

           - <A::Node.namespaceURI>::: <URI^^DISCore|QName::xdp|>.

           - <A::Node.ownerDocument>::: The document.

           - <A::Node.textContent>::: <P::value>, or an empty
                                      string if <P::value> is <DOM::null>.
           
        }

        If a <IF::Text> node is created, its
        <A::Text.isElementContentWhitespace> attribute value
        <kwd:MUST> be set to <DOM::false>.
      @@@PerlDef:
        __DEEP{
          $r = $self-><M::Document.createElementNS> (<Q::xdp|>, 'entity-value');
          $r-><AS::Node.textContent> (defined $value ? $value : '');
        }__;

    @@Test:
      @@@QName: XDPDocument.createXDPEntityValue.1.test
      @@@PerlDef:
        my $doc;
        __CODE{createXDPDocumentForTest}__;

        my $value = q<a%b;c&d;e"f"g'h'i>;
        my $qvalue = q<'a&#x25;b;c&#x26;d;e"f"g&#x27;h&#x27;i'>;
        my $el = $doc-><M::XDPDocument.createXDPEntityValue> ($value);

        $test->id ('interface');
        $test->assert_isa ($el, <IFName::XDPEntityValueElement>);

        $test->id ('namespaceURI');
        $test->assert_equals ($el-><AG::Node.namespaceURI>, <Q::xdp|>);

        $test->id ('localName');
        $test->assert_equals ($el-><AG::Node.localName>, 'entity-value');

        $test->id ('textContent');
        $test->assert_equals ($el-><AG::Node.textContent>, $value);

        $test->id ('dtdText');
        $test->assert_equals ($el-><AG::XDPElement.dtdText>, $qvalue);
    @@Test:
      @@@QName: XDPDocument.createXDPEntityValue.2.test
      @@@PerlDef:
        my $doc;
        __CODE{createXDPDocumentForTest}__;

        my $el = $doc-><M::XDPDocument.createXDPEntityValue> (null);

        $test->id ('interface');
        $test->assert_isa ($el, <IFName::XDPEntityValueElement>);

        $test->id ('namespaceURI');
        $test->assert_equals ($el-><AG::Node.namespaceURI>, <Q::xdp|>);

        $test->id ('localName');
        $test->assert_equals ($el-><AG::Node.localName>, 'entity-value');

        $test->id ('textContent');
        $test->assert_equals ($el-><AG::Node.textContent>, '');

        $test->id ('dtdText');
        $test->assert_equals ($el-><AG::XDPElement.dtdText>, '""');

  @Method:
    @@Name: createXDPMinimumLiteral
    @@enDesc:
      Creates a <XE::xdp|minimum-literal> element.
    @@Param:
      @@@Name: value
      @@@Type: DOMString
      @@@enDesc:
        The value of the element.
      @@@nullCase:
        @@@@enDesc:
          Same as an empty string.
    @@Return:
      @@@Type: XDPMinimumLiteralElement
      @@@enDesc:
        The newly created element node.

        {P:: A new <IF::Element> node with following attributes
             <kwd:MUST> be returned:

           - <A::Node.localName>::: <XE::minimum-literal>.

           - <A::Node.namespaceURI>::: <URI^^DISCore|QName::xdp|>.

           - <A::Node.ownerDocument>::: The document.

           - <A::Node.textContent>::: <P::value>, or an empty
                                      string if <P::value> is <DOM::null>.
           
        }

        If a <IF::Text> node is created, its
        <A::Text.isElementContentWhitespace> attribute value
        <kwd:MUST> be set to <DOM::false>.
      @@@PerlDef:
        __DEEP{
          $r = $self-><M::Document.createElementNS>
                        (<Q::xdp|>, 'minimum-literal');
          $r-><AS::Node.textContent> (defined $value ? $value : '');
        }__;

    @@Test:
      @@@QName: XDPDocument.createXDPMinimumLiteral.1.test
      @@@PerlDef:
        my $doc;
        __CODE{createXDPDocumentForTest}__;

        my $value = q<a%b;c&d;e"f"g'h'i>;
        my $qvalue = q<"a%b;c&d;e%22f%22g'h'i">;
        my $el = $doc-><M::XDPDocument.createXDPMinimumLiteral> ($value);

        $test->id ('interface');
        $test->assert_isa ($el, <IFName::XDPMinimumLiteralElement>);

        $test->id ('namespaceURI');
        $test->assert_equals ($el-><AG::Node.namespaceURI>, <Q::xdp|>);

        $test->id ('localName');
        $test->assert_equals ($el-><AG::Node.localName>, 'minimum-literal');

        $test->id ('textContent');
        $test->assert_equals ($el-><AG::Node.textContent>, $value);

        $test->id ('dtdText');
        $test->assert_equals ($el-><AG::XDPElement.dtdText>, $qvalue);
    @@Test:
      @@@QName: XDPDocument.createXDPMinimumLiteral.2.test
      @@@PerlDef:
        my $doc;
        __CODE{createXDPDocumentForTest}__;

        my $el = $doc-><M::XDPDocument.createXDPMinimumLiteral> (null);

        $test->id ('interface');
        $test->assert_isa ($el, <IFName::XDPMinimumLiteralElement>);

        $test->id ('namespaceURI');
        $test->assert_equals ($el-><AG::Node.namespaceURI>, <Q::xdp|>);

        $test->id ('localName');
        $test->assert_equals ($el-><AG::Node.localName>, 'minimum-literal');

        $test->id ('textContent');
        $test->assert_equals ($el-><AG::Node.textContent>, '');

        $test->id ('dtdText');
        $test->assert_equals ($el-><AG::XDPElement.dtdText>, '""');

  @Method:
    @@Name: createXDPSystemLiteral
    @@enDesc:
      Creates a <XE::xdp|system-literal> element.
    @@Param:
      @@@Name: value
      @@@Type: DOMString
      @@@enDesc:
        The value of the element.
      @@@nullCase:
        @@@@enDesc:
          Same as an empty string.
    @@Return:
      @@@Type: XDPSystemLiteralElement
      @@@enDesc:
        The newly created element node.

        {P:: A new <IF::Element> node with following attributes
             <kwd:MUST> be returned:

           - <A::Node.localName>::: <XE::system-literal>.

           - <A::Node.namespaceURI>::: <URI^^DISCore|QName::xdp|>.

           - <A::Node.ownerDocument>::: The document.

           - <A::Node.textContent>::: <P::value>, or an empty
                                      string if <P::value> is <DOM::null>.
           
        }

        If a <IF::Text> node is created, its
        <A::Text.isElementContentWhitespace> attribute value
        <kwd:MUST> be set to <DOM::false>.
      @@@PerlDef:
        __DEEP{
          $r = $self-><M::Document.createElementNS>
                        (<Q::xdp|>, 'system-literal');
          $r-><AS::Node.textContent> (defined $value ? $value : '');
        }__;

    @@Test:
      @@@QName: XDPDocument.createXDPSystemLiteral.1.test
      @@@PerlDef:
        my $doc;
        __CODE{createXDPDocumentForTest}__;

        my $value = q<a%b;c&d;e"f"g'h'i>;
        my $qvalue = q<"a%b;c&d;e%22f%22g'h'i">;
        my $el = $doc-><M::XDPDocument.createXDPSystemLiteral> ($value);

        $test->id ('interface');
        $test->assert_isa ($el, <IFName::XDPSystemLiteralElement>);

        $test->id ('namespaceURI');
        $test->assert_equals ($el-><AG::Node.namespaceURI>, <Q::xdp|>);

        $test->id ('localName');
        $test->assert_equals ($el-><AG::Node.localName>, 'system-literal');

        $test->id ('textContent');
        $test->assert_equals ($el-><AG::Node.textContent>, $value);

        $test->id ('dtdText');
        $test->assert_equals ($el-><AG::XDPElement.dtdText>, $qvalue);
    @@Test:
      @@@QName: XDPDocument.createXDPSystemLiteral.2.test
      @@@PerlDef:
        my $doc;
        __CODE{createXDPDocumentForTest}__;

        my $el = $doc-><M::XDPDocument.createXDPSystemLiteral> (null);

        $test->id ('interface');
        $test->assert_isa ($el, <IFName::XDPSystemLiteralElement>);

        $test->id ('namespaceURI');
        $test->assert_equals ($el-><AG::Node.namespaceURI>, <Q::xdp|>);

        $test->id ('localName');
        $test->assert_equals ($el-><AG::Node.localName>, 'system-literal');

        $test->id ('textContent');
        $test->assert_equals ($el-><AG::Node.textContent>, '');

        $test->id ('dtdText');
        $test->assert_equals ($el-><AG::XDPElement.dtdText>, '""');

  @Method:
    @@Name: createXDPAttrLiteral
    @@enDesc:
      Creates a <XE::xdp|attr-literal> element.
    @@Param:
      @@@Name: value
      @@@Type: DOMString
      @@@enDesc:
        The value of the element.
      @@@nullCase:
        @@@@enDesc:
          Same as an empty string.
    @@Return:
      @@@Type: XDPAttrLiteralElement
      @@@enDesc:
        The newly created element node.

        {P:: A new <IF::Element> node with following attributes
             <kwd:MUST> be returned:

           - <A::Node.localName>::: <XE::attr-literal>.

           - <A::Node.namespaceURI>::: <URI^^DISCore|QName::xdp|>.

           - <A::Node.ownerDocument>::: The document.

           - <A::Node.textContent>::: <P::value>, or an empty
                                      string if <P::value> is <DOM::null>.
           
        }

        If a <IF::Text> node is created, its
        <A::Text.isElementContentWhitespace> attribute value
        <kwd:MUST> be set to <DOM::false>.
      @@@PerlDef:
        __DEEP{
          $r = $self-><M::Document.createElementNS>
                        (<Q::xdp|>, 'attr-literal');
          $r-><AS::Node.textContent> (defined $value ? $value : '');
        }__;

    @@Test:
      @@@QName: XDPDocument.createXDPAttrLiteral.1.test
      @@@PerlDef:
        my $doc;
        __CODE{createXDPDocumentForTest}__;

        my $value = q<a%b;c&d;e"f"g'h'i>;
        my $qvalue = q<'a%b;c&amp;d;e"f"g&apos;h&apos;i'>;
        my $el = $doc-><M::XDPDocument.createXDPAttrLiteral> ($value);

        $test->id ('interface');
        $test->assert_isa ($el, <IFName::XDPAttrLiteralElement>);

        $test->id ('namespaceURI');
        $test->assert_equals ($el-><AG::Node.namespaceURI>, <Q::xdp|>);

        $test->id ('localName');
        $test->assert_equals ($el-><AG::Node.localName>, 'attr-literal');

        $test->id ('textContent');
        $test->assert_equals ($el-><AG::Node.textContent>, $value);

        $test->id ('dtdText');
        $test->assert_equals ($el-><AG::XDPElement.dtdText>, $qvalue);
    @@Test:
      @@@QName: XDPDocument.createXDPAttrLiteral.2.test
      @@@PerlDef:
        my $doc;
        __CODE{createXDPDocumentForTest}__;

        my $el = $doc-><M::XDPDocument.createXDPAttrLiteral> (null);

        $test->id ('interface');
        $test->assert_isa ($el, <IFName::XDPAttrLiteralElement>);

        $test->id ('namespaceURI');
        $test->assert_equals ($el-><AG::Node.namespaceURI>, <Q::xdp|>);

        $test->id ('localName');
        $test->assert_equals ($el-><AG::Node.localName>, 'attr-literal');

        $test->id ('textContent');
        $test->assert_equals ($el-><AG::Node.textContent>, '');

        $test->id ('dtdText');
        $test->assert_equals ($el-><AG::XDPElement.dtdText>, '""');

  @Method:
    @@Name: createXDPCharRef
    @@enDesc:
      Creates an <XE::xdp|hcr> element.
    @@Param:
      @@@Name: value
      @@@Type: unsignedLong
      @@@enDesc:
        The code point of the character represented
        by the element to create.
    @@Return:
      @@@Type: XDPHCRElement
      @@@enDesc:
        The newly created element node.

        {P:: A new <IF::Element> node with following attributes
             <kwd:MUST> be returned:

           - <A::Node.localName>::: <XE::hcr>.

           - <A::Node.namespaceURI>::: <URI^^DISCore|QName::xdp|>.

           - <A::Node.ownerDocument>::: The document.

           - <A::Node.textContent>::: A hexadecimal representation
                 of the <P::value>, in upper case.
           
        }

        If a <IF::Text> node is created, its
        <A::Text.isElementContentWhitespace> attribute value
        <kwd:MUST> be set to <DOM::false>.
      @@@PerlDef:
        __DEEP{
          $r = $self-><M::Document.createElementNS> (<Q::xdp|>, 'hcr');
          $r-><AS::Node.textContent> (sprintf '%04X', $value);
        }__;

    @@Test:
      @@@QName: XDPDocument.createXDPCharRef.1.test
      @@@PerlDef:
        my $doc;
        __CODE{createXDPDocumentForTest}__;

        my $el = $doc-><M::XDPDocument.createXDPCharRef> (0x4E00);

        $test->id ('interface');
        $test->assert_isa ($el, <IFName::XDPHCRElement>);

        $test->id ('namespaceURI');
        $test->assert_equals ($el-><AG::Node.namespaceURI>, <Q::xdp|>);

        $test->id ('localName');
        $test->assert_equals ($el-><AG::Node.localName>, 'hcr');

        $test->id ('textContent');
        $test->assert_equals ($el-><AG::Node.textContent>, '4E00');

        $test->id ('dtdText');
        $test->assert_equals ($el-><AG::XDPElement.dtdText>, '&#x4E00;');

  @Method:
    @@Name: createXDPPERef
    @@dlp:methodName: create_xdp_peref
    @@enDesc:
      Creates a <XE::xdp|peref> element.
    @@Param:
      @@@Name: value
      @@@Type: DOMString
      @@@enDesc:
        The value of the element, i.e. the name of the
        parameter entity.
      @@@nullCase:
        @@@@enDesc:
          Same as an empty string.
    @@Return:
      @@@Type: XDPPERefElement
      @@@enDesc:
        The newly created element node.

        {P:: A new <IF::Element> node with following attributes
             <kwd:MUST> be returned:

           - <A::Node.localName>::: <XE::peref>.

           - <A::Node.namespaceURI>::: <URI^^DISCore|QName::xdp|>.

           - <A::Node.ownerDocument>::: The document.

           - <A::Node.textContent>::: <P::value>, or an empty
                                      string if <P::value> is <DOM::null>.
           
        }

        If a <IF::Text> node is created, its
        <A::Text.isElementContentWhitespace> attribute value
        <kwd:MUST> be set to <DOM::false>.
      @@@PerlDef:
        __DEEP{
          $r = $self-><M::Document.createElementNS>
                        (<Q::xdp|>, 'peref');
          $r-><AS::Node.textContent> (defined $value ? $value : '');
        }__;

    @@Test:
      @@@QName: XDPDocument.createXDPPERef.1.test
      @@@PerlDef:
        my $doc;
        __CODE{createXDPDocumentForTest}__;

        my $value = q<pename>;
        my $el = $doc-><M::XDPDocument.createXDPPERef> ($value);

        $test->id ('interface');
        $test->assert_isa ($el, <IFName::XDPPERefElement>);

        $test->id ('namespaceURI');
        $test->assert_equals ($el-><AG::Node.namespaceURI>, <Q::xdp|>);

        $test->id ('localName');
        $test->assert_equals ($el-><AG::Node.localName>, 'peref');

        $test->id ('textContent');
        $test->assert_equals ($el-><AG::Node.textContent>, $value);

        $test->id ('dtdText');
        $test->assert_equals ($el-><AG::XDPElement.dtdText>, '%'.$value.';');
    @@Test:
      @@@QName: XDPDocument.createXDPPERef.2.test
      @@@PerlDef:
        my $doc;
        __CODE{createXDPDocumentForTest}__;

        my $el = $doc-><M::XDPDocument.createXDPPERef> (null);

        $test->id ('interface');
        $test->assert_isa ($el, <IFName::XDPPERefElement>);

        $test->id ('namespaceURI');
        $test->assert_equals ($el-><AG::Node.namespaceURI>, <Q::xdp|>);

        $test->id ('localName');
        $test->assert_equals ($el-><AG::Node.localName>, 'peref');

        $test->id ('textContent');
        $test->assert_equals ($el-><AG::Node.textContent>, '');

        $test->id ('dtdText');
        $test->assert_equals ($el-><AG::XDPElement.dtdText>, '%;');

  @Method:
    @@Name: createXDPGERef
    @@dlp:methodName: create_xdp_geref
    @@enDesc:
      Creates a <XE::xdp|geref> element.
    @@Param:
      @@@Name: value
      @@@Type: DOMString
      @@@enDesc:
        The value of the element, i.e. the name of the
        general entity.
      @@@nullCase:
        @@@@enDesc:
          Same as an empty string.
    @@Return:
      @@@Type: XDPGERefElement
      @@@enDesc:
        The newly created element node.

        {P:: A new <IF::Element> node with following attributes
             <kwd:MUST> be returned:

           - <A::Node.localName>::: <XE::geref>.

           - <A::Node.namespaceURI>::: <URI^^DISCore|QName::xdp|>.

           - <A::Node.ownerDocument>::: The document.

           - <A::Node.textContent>::: <P::value>, or an empty
                                      string if <P::value> is <DOM::null>.
           
        }

        If a <IF::Text> node is created, its
        <A::Text.isElementContentWhitespace> attribute value
        <kwd:MUST> be set to <DOM::false>.
      @@@PerlDef:
        __DEEP{
          $r = $self-><M::Document.createElementNS>
                        (<Q::xdp|>, 'geref');
          $r-><AS::Node.textContent> (defined $value ? $value : '');
        }__;

    @@Test:
      @@@QName: XDPDocument.createXDPGERef.1.test
      @@@PerlDef:
        my $doc;
        __CODE{createXDPDocumentForTest}__;

        my $value = q<pename>;
        my $el = $doc-><M::XDPDocument.createXDPGERef> ($value);

        $test->id ('interface');
        $test->assert_isa ($el, <IFName::XDPGERefElement>);

        $test->id ('namespaceURI');
        $test->assert_equals ($el-><AG::Node.namespaceURI>, <Q::xdp|>);

        $test->id ('localName');
        $test->assert_equals ($el-><AG::Node.localName>, 'geref');

        $test->id ('textContent');
        $test->assert_equals ($el-><AG::Node.textContent>, $value);

        $test->id ('dtdText');
        $test->assert_equals ($el-><AG::XDPElement.dtdText>, '&'.$value.';');
    @@Test:
      @@@QName: XDPDocument.createXDPGERef.2.test
      @@@PerlDef:
        my $doc;
        __CODE{createXDPDocumentForTest}__;

        my $el = $doc-><M::XDPDocument.createXDPGERef> (null);

        $test->id ('interface');
        $test->assert_isa ($el, <IFName::XDPGERefElement>);

        $test->id ('namespaceURI');
        $test->assert_equals ($el-><AG::Node.namespaceURI>, <Q::xdp|>);

        $test->id ('localName');
        $test->assert_equals ($el-><AG::Node.localName>, 'geref');

        $test->id ('textContent');
        $test->assert_equals ($el-><AG::Node.textContent>, '');

        $test->id ('dtdText');
        $test->assert_equals ($el-><AG::XDPElement.dtdText>, '&;');

  @Method:
    @@Name: createXDPPAttr
    @@dlp:methodName: create_xdp_pattr
    @@enDesc:
      Creates a <XE::xdp|pattr> element.
    @@Param:
      @@@Name: name
      @@@Type: DOMString
      @@@enDesc:
        The name of the pseudo-attribute.
      @@@nullCase:
        @@@@enDesc:
          Same as an empty string.
    @@Param:
      @@@Name: value
      @@@Type: DOMString
      @@@enDesc:
        The value of the pseudo-attribute.
      @@@nullCase:
        @@@@enDesc:
          Same as an empty string.
    @@Return:
      @@@Type: XDPPAttrElement
      @@@enDesc:
        The newly created element node.

        {P:: A new <IF::Element> node with following attributes
             <kwd:MUST> be returned:

           - <A::Node.localName>::: <XE::pattr>.

           - <A::Node.namespaceURI>::: <URI^^DISCore|QName::xdp|>.

           - <A::Node.ownerDocument>::: The document.

           {LI:: <A::Node.childNodes>::: A new <IF::tc|NodeList> with
                     three nodes in this order:

             {OLI::

               - <A::Node.localName>::: <XE::name>.

               - <A::Node.namespaceURI>::: <URI^^DISCore|QName::xdp|>.

               - <A::Node.nodeType>::: <C::Node.ELEMENT_NODE>.

               - <A::Node.ownerDocument>::: The document.

               - <A::Node.textContent>::: <P::name>, or an empty
                                          string if <P::name> is <DOM::null>.

             }

             {OLI::

               - <A::Node.localName>::: <XE::delimiter>.
 
               - <A::Node.namespaceURI>::: <URI^^DISCore|QName::xdp|>.

               - <A::Node.nodeType>::: <C::Node.ELEMENT_NODE>.

               - <A::Node.ownerDocument>::: The document.

               - <A::Node.textContent>::: <XML::=>.

             }

             {OLI::

               - <A::Node.localName>::: <XE::attr-literal>.

               - <A::Node.namespaceURI>::: <URI^^DISCore|QName::xdp|>.

               - <A::Node.nodeType>::: <C::Node.ELEMENT_NODE>.

               - <A::Node.ownerDocument>::: The document.

               - <A::Node.textContent>::: <P::value>, or an empty
                                          string if <P::value> is <DOM::null>.

             }

           }
           
        }

        If a <IF::Text> node is created, its
        <A::Text.isElementContentWhitespace> attribute value
        <kwd:MUST> be set to <DOM::false>.
      @@@PerlDef:
        __DEEP{
          $r = $self-><M::Document.createElementNS> (<Q::xdp|>, 'pattr');
          my $name_el = $self-><M::XDPDocument.createXDPName> ($name);
          $r-><M::Node.appendChild> ($name_el);
          my $vi_el = $self-><M::XDPDocument.createXDPDelimiter> ('=');
          $r-><M::Node.appendChild> ($vi_el);
          my $value_el = $self-><M::XDPDocument.createXDPAttrLiteral> ($value);
          $r-><M::Node.appendChild> ($value_el);
        }__;

    @@Test:
      @@@QName: XDPDocument.createXDPPAttr.1.test
      @@@PerlDef:
        my $doc;
        __CODE{createXDPDocumentForTest}__;

        my $el = $doc-><M::XDPDocument.createXDPPAttr> ('paname' => 'pavalue');

        $test->id ('interface');
        $test->assert_isa ($el, <IFName::XDPPAttrElement>);

        $test->id ('namespaceURI');
        $test->assert_equals ($el-><AG::Node.namespaceURI>, <Q::xdp|>);

        $test->id ('localName');
        $test->assert_equals ($el-><AG::Node.localName>, 'pattr');

        $test->id ('dtdText');
        $test->assert_equals ($el-><AG::XDPElement.dtdText>, 'paname="pavalue"');
    @@Test:
      @@@QName: XDPDocument.createXDPPAttr.2.test
      @@@PerlDef:
        my $doc;
        __CODE{createXDPDocumentForTest}__;

        my $el = $doc-><M::XDPDocument.createXDPPAttr> (null, null);

        $test->id ('interface');
        $test->assert_isa ($el, <IFName::XDPPAttrElement>);

        $test->id ('namespaceURI');
        $test->assert_equals ($el-><AG::Node.namespaceURI>, <Q::xdp|>);

        $test->id ('localName');
        $test->assert_equals ($el-><AG::Node.localName>, 'pattr');

        $test->id ('dtdText');
        $test->assert_equals ($el-><AG::XDPElement.dtdText>, '=""');

  @Method:
    @@Name: createXDPTextDecl
    @@enDesc:
      Creates a <XE::xdp|text-decl> element.
    @@Param:
      @@@Name: version
      @@@Type: DOMString
      @@@enDesc:
        The value of the <XA::version> pseudo-attribute of
        the text declaration.
      @@@nullCase:
        @@@@enDesc:
          If <P::encoding> is also <DOM::null>, it is treated
          as if <XML::1.0> is specified.  Otherwise, 
          no <XA::version> pseudo-attribute will appear.
    @@Param:
      @@@Name: encoding
      @@@Type: DOMString
      @@@enDesc:
        The value of the <XE::encoding> pseudo-attribute
        of the text declaration.
      @@@nullCase:
        @@@@enDesc:
          No <XA::encoding> pseudo-attribute will appear.
    @@Return:
      @@@Type: XDPTextDeclElement
      @@@enDesc:
        The newly created element node.

        {P:: A new <IF::Element> node with following attributes
             <kwd:MUST> be returned:

           - <A::Node.localName>::: <XE::text-decl>.

           - <A::Node.namespaceURI>::: <URI^^DISCore|QName::xdp|>.

           - <A::Node.ownerDocument>::: The document.
           
        }

        {P:: In addition, the returned node <kwd:MUST> have following
             child nodes in order:

           = If <P::version> is different from <DOM::null> and / or
             if <P::encoding> is <DOM::null>, an <CODE::S> node.

           = If <P::version> is different from <DOM::null> and / or
             if <P::encoding> is <DOM::null>, a pseudo-attribute
             node whose <VAR::name> is <XA::version> and
             whose <VAR::value> is <P::version>, if it is
             not <DOM::null>, or <XML::1.0>, otherwise.

           = An <CODE::S> node.

           = If <P::encoding> is different from <DOM::null>,
             a pseudo-attribute node whose <VAR::name> is
             <XA::encoding> and whose <VAR::value> is <P::encoding>.

        }

        {P:: <DFN::An <CODE::S> node> <kwd:MUST> be a <IF::Node>
             that contains following attribute values:

              - <A::Node.localName>::: <XE::s>.

              - <A::Node.namespaceURI>::: <URI^^DISCore|QName::xdp|>.

              - <A::Node.nodeType>::: <C::Node.ELEMENT_NODE>.
 
              - <A::Node.ownerDocument>::: The document.

              - <A::Node.textContent>::: A <CHAR::SPACE>.

        }

        <DFN::A pseudo-attribute node> with <VAR::name> and 
        <VAR::value> <kwd:MUST> be a <IF::Node> that would be
        returned when the <A::XDPDocument.createXDPPAttr> method
        on the document with parameters <VAR::name> and <VAR::value>
        were invoked.

        If a <IF::Text> node is created, its
        <A::Text.isElementContentWhitespace> attribute value
        <kwd:MUST> be set to <DOM::false>.
      @@@PerlDef:
        __DEEP{
          $r = $self-><M::Document.createElementNS> (<Q::xdp|>, 'text-decl');
          if (defined $version or not defined $encoding) {
            $r-><M::Node.appendChild> ($self-><M::XDPDocument.createXDPS> (' '));
            my $ver_el = $self-><M::XDPDocument.createXDPPAttr>
                                  (version => defined $version
                                                ? $version : '1.0');
            $r-><M::Node.appendChild> ($ver_el);
          }
          if (defined $encoding) {
            $r-><M::Node.appendChild> ($self-><M::XDPDocument.createXDPS> (' '));
            my $enc_el = $self-><M::XDPDocument.createXDPPAttr>
                                  (encoding => $encoding);
            $r-><M::Node.appendChild> ($enc_el);
          }
        }__;

    @@Test:
      @@@QName: XDPDocument.createXDPTextDecl.1.test
      @@@PerlDef:
        my $doc;
        __CODE{createXDPDocumentForTest}__;

        my $el = $doc-><M::XDPDocument.createXDPTextDecl> ('1.1', 'utf-8');

        $test->id ('interface');
        $test->assert_isa ($el, <IFName::XDPTextDeclElement>);

        $test->id ('namespaceURI');
        $test->assert_equals ($el-><AG::Node.namespaceURI>, <Q::xdp|>);

        $test->id ('localName');
        $test->assert_equals ($el-><AG::Node.localName>, 'text-decl');

        $test->id ('dtdText');
        $test->assert_equals ($el-><AG::XDPElement.dtdText>,
                              '<?xml version="1.1" encoding="utf-8"?>');
    @@Test:
      @@@QName: XDPDocument.createXDPTextDecl.2.test
      @@@PerlDef:
        my $doc;
        __CODE{createXDPDocumentForTest}__;

        my $el = $doc-><M::XDPDocument.createXDPTextDecl> ('1.1');

        $test->id ('interface');
        $test->assert_isa ($el, <IFName::XDPTextDeclElement>);

        $test->id ('namespaceURI');
        $test->assert_equals ($el-><AG::Node.namespaceURI>, <Q::xdp|>);

        $test->id ('localName');
        $test->assert_equals ($el-><AG::Node.localName>, 'text-decl');

        $test->id ('dtdText');
        $test->assert_equals ($el-><AG::XDPElement.dtdText>,
                              '<?xml version="1.1"?>');
    @@Test:
      @@@QName: XDPDocument.createXDPTextDecl.3.test
      @@@PerlDef:
        my $doc;
        __CODE{createXDPDocumentForTest}__;

        my $el = $doc-><M::XDPDocument.createXDPTextDecl> (null, 'utf-8');

        $test->id ('interface');
        $test->assert_isa ($el, <IFName::XDPTextDeclElement>);

        $test->id ('namespaceURI');
        $test->assert_equals ($el-><AG::Node.namespaceURI>, <Q::xdp|>);

        $test->id ('localName');
        $test->assert_equals ($el-><AG::Node.localName>, 'text-decl');

        $test->id ('dtdText');
        $test->assert_equals ($el-><AG::XDPElement.dtdText>,
                              '<?xml encoding="utf-8"?>');
    @@Test:
      @@@QName: XDPDocument.createXDPTextDecl.4.test
      @@@PerlDef:
        my $doc;
        __CODE{createXDPDocumentForTest}__;

        my $el = $doc-><M::XDPDocument.createXDPTextDecl>;

        $test->id ('interface');
        $test->assert_isa ($el, <IFName::XDPTextDeclElement>);

        $test->id ('namespaceURI');
        $test->assert_equals ($el-><AG::Node.namespaceURI>, <Q::xdp|>);

        $test->id ('localName');
        $test->assert_equals ($el-><AG::Node.localName>, 'text-decl');

        $test->id ('dtdText');
        $test->assert_equals ($el-><AG::XDPElement.dtdText>,
                              '<?xml version="1.0"?>');

  @Method:
    @@Name: createXDPPI
    @@dlp:methodName: create_xdp_pi
    @@enDesc:
      Creates a <XE::xdp|pi> element.
    @@Param:
      @@@Name: target
      @@@Type: DOMString
      @@@enDesc:
        The target of the processing instruction.
      @@@nullCase:
        @@@@enDesc:
          Same as an empty string.
    @@Param:
      @@@Name: data
      @@@Type: DOMString
      @@@enDesc:
        The content of the processing instruction.
      @@@nullCase:
        @@@@enDesc:
          No <CODE::S> is inserted after the target.
    @@Return:
      @@@Type: XDPPIElement
      @@@enDesc:
        The newly created element node.

        {P:: A new <IF::Element> node with following attributes
             <kwd:MUST> be returned:

           - <A::Node.localName>::: <XE::pi>.

           - <A::Node.namespaceURI>::: <URI^^DISCore|QName::xdp|>.

           - <A::Node.ownerDocument>::: The document.
           
        }

        If the <P::value> is different from <DOM::null>, 
        the returned value <kwd:MUST> contain two or three child
        element nodes: the target node, an <CODE::S> node,
        and if the length of <P::value> is greater than zero,
        the data node.  Otherwise, it <kwd:MUST> contain
        one child element node: the target node.

        {P:: <DFM::The target node> <kwd:MUST> be a <IF::Node>
             that contains following attribute values:

              - <A::Node.localName>::: <XE::name>.

              - <A::Node.namespaceURI>::: <URI^^DISCore|QName::xdp|>.

              - <A::Node.nodeType>::: <C::Node.ELEMENT_NODE>.
 
              - <A::Node.ownerDocument>::: The document.

              - <A::Node.textContent>::: <P::target>, or an empty
                                          string if <P::target> is <DOM::null>.

        }

        {P:: <DFN::An <CODE::S> node> <kwd:MUST> be a <IF::Node>
             that contains following attribute values:

              - <A::Node.localName>::: <XE::s>.

              - <A::Node.namespaceURI>::: <URI^^DISCore|QName::xdp|>.

              - <A::Node.nodeType>::: <C::Node.ELEMENT_NODE>.
 
              - <A::Node.ownerDocument>::: The document.

              - <A::Node.textContent>::: A <CHAR::SPACE>.

        }

        {P:: <DFM::The data node> <kwd:MUST> be a <IF::Node>
             that contains following attribute values:

              - <A::Node.nodeType>::: <C::Node.TEXT_NODE>.
 
              - <A::Node.ownerDocument>::: The document.

              - <A::Node.textContent>::: <P::data>.

        }

        If a <IF::Text> node are created, its
        <A::Text.isElementContentWhitespace> attribute value
        <kwd:MUST> be set to <DOM::false>.
      @@@PerlDef:
        __DEEP{
          $r = $self-><M::Document.createElementNS> (<Q::xdp|>, 'pi');
          $r-><M::Node.appendChild>
                ($self-><M::XDPDocument.createXDPName> ($target));
          if (defined $data) {
            $r-><M::Node.appendChild> ($self-><M::XDPDocument.createXDPS> (' '));
            $r-><M::Node.manakaiAppendText> ($data) if length $data;
          }
        }__;

    @@Test:
      @@@QName: XDPDocument.createXDPPI.1.test
      @@@PerlDef:
        my $doc;
        __CODE{createXDPDocumentForTest}__;

        my $el = $doc-><M::XDPDocument.createXDPPI> ('pitarget', 'pidata');

        $test->id ('interface');
        $test->assert_isa ($el, <IFName::XDPPIElement>);

        $test->id ('namespaceURI');
        $test->assert_equals ($el-><AG::Node.namespaceURI>, <Q::xdp|>);

        $test->id ('localName');
        $test->assert_equals ($el-><AG::Node.localName>, 'pi');

        $test->id ('dtdText');
        $test->assert_equals ($el-><AG::XDPElement.dtdText>,
                              '<?pitarget pidata?>');

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$el-><AG::Node.childNodes>},
                  expected_value => 3);
    @@Test:
      @@@QName: XDPDocument.createXDPPI.2.test
      @@@PerlDef:
        my $doc;
        __CODE{createXDPDocumentForTest}__;

        my $el = $doc-><M::XDPDocument.createXDPPI> ('pitarget');

        $test->id ('interface');
        $test->assert_isa ($el, <IFName::XDPPIElement>);

        $test->id ('namespaceURI');
        $test->assert_equals ($el-><AG::Node.namespaceURI>, <Q::xdp|>);

        $test->id ('localName');
        $test->assert_equals ($el-><AG::Node.localName>, 'pi');

        $test->id ('dtdText');
        $test->assert_equals ($el-><AG::XDPElement.dtdText>,
                              '<?pitarget?>');

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$el-><AG::Node.childNodes>},
                  expected_value => 1);
    @@Test:
      @@@QName: XDPDocument.createXDPPI.3.test
      @@@PerlDef:
        my $doc;
        __CODE{createXDPDocumentForTest}__;

        my $el = $doc-><M::XDPDocument.createXDPPI> (null, 'pidata');

        $test->id ('interface');
        $test->assert_isa ($el, <IFName::XDPPIElement>);

        $test->id ('namespaceURI');
        $test->assert_equals ($el-><AG::Node.namespaceURI>, <Q::xdp|>);

        $test->id ('localName');
        $test->assert_equals ($el-><AG::Node.localName>, 'pi');

        $test->id ('dtdText');
        $test->assert_equals ($el-><AG::XDPElement.dtdText>,
                              '<? pidata?>');

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$el-><AG::Node.childNodes>},
                  expected_value => 3);
    @@Test:
      @@@QName: XDPDocument.createXDPPI.4.test
      @@@PerlDef:
        my $doc;
        __CODE{createXDPDocumentForTest}__;

        my $el = $doc-><M::XDPDocument.createXDPPI>;

        $test->id ('interface');
        $test->assert_isa ($el, <IFName::XDPPIElement>);

        $test->id ('namespaceURI');
        $test->assert_equals ($el-><AG::Node.namespaceURI>, <Q::xdp|>);

        $test->id ('localName');
        $test->assert_equals ($el-><AG::Node.localName>, 'pi');

        $test->id ('dtdText');
        $test->assert_equals ($el-><AG::XDPElement.dtdText>, '<??>');

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$el-><AG::Node.childNodes>},
                  expected_value => 1);

  @Method:
    @@Name: createXDPComment
    @@enDesc:
      Creates a <XE::xdp|comment> element.
    @@Param:
      @@@Name: value
      @@@Type: DOMString
      @@@enDesc:
        The value of the element, i.e. the content of the comment.
      @@@nullCase:
        @@@@enDesc:
          Same as an empty string.
    @@Return:
      @@@Type: XDPCommentElement
      @@@enDesc:
        The newly created element node.

        {P:: A new <IF::Element> node with following attributes
             <kwd:MUST> be returned:

           - <A::Node.localName>::: <XE::comment>.

           - <A::Node.namespaceURI>::: <URI^^DISCore|QName::xdp|>.

           - <A::Node.ownerDocument>::: The document.

           - <A::Node.textContent>::: <P::value>, or an empty
                                      string if <P::value> is <DOM::null>.
           
        }

        If a <IF::Text> node is created, its
        <A::Text.isElementContentWhitespace> attribute value
        <kwd:MUST> be set to <DOM::false>.
      @@@PerlDef:
        __DEEP{
          $r = $self-><M::Document.createElementNS>
                        (<Q::xdp|>, 'comment');
          $r-><AS::Node.textContent> (defined $value ? $value : '');
        }__;

    @@Test:
      @@@QName: XDPDocument.createXDPComment.1.test
      @@@PerlDef:
        my $doc;
        __CODE{createXDPDocumentForTest}__;

        my $value = q<pename>;
        my $el = $doc-><M::XDPDocument.createXDPComment> ($value);

        $test->id ('interface');
        $test->assert_isa ($el, <IFName::XDPCommentElement>);

        $test->id ('namespaceURI');
        $test->assert_equals ($el-><AG::Node.namespaceURI>, <Q::xdp|>);

        $test->id ('localName');
        $test->assert_equals ($el-><AG::Node.localName>, 'comment');

        $test->id ('textContent');
        $test->assert_equals ($el-><AG::Node.textContent>, $value);

        $test->id ('dtdText');
        $test->assert_equals ($el-><AG::XDPElement.dtdText>,
                              '<!--'.$value.'-->');
    @@Test:
      @@@QName: XDPDocument.createXDPComment.2.test
      @@@PerlDef:
        my $doc;
        __CODE{createXDPDocumentForTest}__;

        my $el = $doc-><M::XDPDocument.createXDPComment> (null);

        $test->id ('interface');
        $test->assert_isa ($el, <IFName::XDPCommentElement>);

        $test->id ('namespaceURI');
        $test->assert_equals ($el-><AG::Node.namespaceURI>, <Q::xdp|>);

        $test->id ('localName');
        $test->assert_equals ($el-><AG::Node.localName>, 'comment');

        $test->id ('textContent');
        $test->assert_equals ($el-><AG::Node.textContent>, '');

        $test->id ('dtdText');
        $test->assert_equals ($el-><AG::XDPElement.dtdText>, '<!---->');

  @Method:
    @@Name: createXDPMarkedSectionStatus
    @@enDesc:
      Creates a <XE::xdp|marked-section-status> element.
    @@Param:
      @@@Name: value
      @@@Type: DOMString
      @@@enDesc:
        The value of the element.
      @@@nullCase:
        @@@@enDesc:
          Same as an empty string.
    @@Return:
      @@@Type: XDPMarkedSectionStatusElement
      @@@enDesc:
        The newly created element node.

        {P:: A new <IF::Element> node with following attributes
             <kwd:MUST> be returned:

           - <A::Node.localName>::: <XE::marked-section-status>.

           - <A::Node.namespaceURI>::: <URI^^DISCore|QName::xdp|>.

           - <A::Node.ownerDocument>::: The document.

        }

        {P:: If <P::value> is not <DOM::null> and its length
             is greater than zero, the returned node <kwd:MUST>
             contain a <IF::Element> with following attributes:

           - <A::Node.localName>::: <XE::keyword>.

           - <A::Node.namespaceURI>::: <URI^^DISCore|QName::xdp|>.

           - <A::Node.ownerDocument>::: The document.

           - <A::Node.textContent>::: <P::value>.
           
        }

        If a <IF::Text> node is created, its
        <A::Text.isElementContentWhitespace> attribute value
        <kwd:MUST> be set to <DOM::false>.
      @@@PerlDef:
        __DEEP{
          $r = $self-><M::Document.createElementNS>
                        (<Q::xdp|>, 'marked-section-status');
          if (defined $value and length $value) {
            $r-><M::Node.appendChild>
                  ($self-><M::XDPDocument.createXDPKeyword> ($value));
          }
        }__;

    @@Test:
      @@@QName: XDPDocument.createXDPMarkedSectionStatus.1.test
      @@@PerlDef:
        my $doc;
        __CODE{createXDPDocumentForTest}__;

        my $value = q<INCLUDE>;
        my $el = $doc-><M::XDPDocument.createXDPMarkedSectionStatus> ($value);

        $test->id ('interface');
        $test->assert_isa ($el, <IFName::XDPMarkedSectionStatusElement>);

        $test->id ('namespaceURI');
        $test->assert_equals ($el-><AG::Node.namespaceURI>, <Q::xdp|>);

        $test->id ('localName');
        $test->assert_equals ($el-><AG::Node.localName>,
                              'marked-section-status');

        $test->id ('textContent');
        $test->assert_equals ($el-><AG::Node.textContent>, $value);

        $test->id ('dtdText');
        $test->assert_equals ($el-><AG::XDPElement.dtdText>, $value.'[');
    @@Test:
      @@@QName: XDPDocument.createXDPMarkedSectionStatus.2.test
      @@@PerlDef:
        my $doc;
        __CODE{createXDPDocumentForTest}__;

        my $el = $doc-><M::XDPDocument.createXDPMarkedSectionStatus> (null);

        $test->id ('interface');
        $test->assert_isa ($el, <IFName::XDPMarkedSectionStatusElement>);

        $test->id ('namespaceURI');
        $test->assert_equals ($el-><AG::Node.namespaceURI>, <Q::xdp|>);

        $test->id ('localName');
        $test->assert_equals ($el-><AG::Node.localName>,
                              'marked-section-status');

        $test->id ('textContent');
        $test->assert_equals ($el-><AG::Node.textContent>, '');

        $test->id ('dtdText');
        $test->assert_equals ($el-><AG::XDPElement.dtdText>, '[');

  @Method:
    @@Name: createXDPMarkedSection
    @@enDesc:
      Creates a <XE::xdp|marked-section> element.
    @@Param:
      @@@Name: status
      @@@Type: DOMString
      @@@enDesc:
        The status value of the marked section.
      @@@nullCase:
        @@@@enDesc:
          Same as an empty string.
    @@Param:
      @@@Name: value
      @@@Type: DOMString
      @@@enDesc:
        The value of the marked section.
      @@@nullCase:
        @@@@enDesc:
          Same as an empty string.
    @@Return:
      @@@Type: XDPMarkedSectionElement
      @@@enDesc:
        The newly created element node.

        {P:: A new <IF::Element> node with following attributes
             <kwd:MUST> be returned:

           - <A::Node.localName>::: <XE::marked-section>.

           - <A::Node.namespaceURI>::: <URI^^DISCore|QName::xdp|>.

           - <A::Node.ownerDocument>::: The document.
           
        }

        The returned <IF::Element> node <kwd:MUST> contain
        a child node that would be returned when the
        <M::XDPDocument.createXDPMarkedSectionStatus> method
        on the document is invoked with <P::status> as a parameter.

        {P:: If <P::value> is not <DOM::null> and the length of
             <P::value> is greater than zero, the 
             <XE::xdp|marked-section-status> <IF::Element> node
             <kwd:MUST> have a <A::Node.nextSibling> <IF::Node>
             with following attributes:

           - <A::Node.nodeType>::: <C::Node.TEXT_NODE>.

           - <A::Node.ownerDocument>::: The document.

           - <A::Node.textContent>::: <P::content>, or an empty
                                      string if <P::content> is <DOM::null>.

        }

        If a <IF::Text> node is created, its
        <A::Text.isElementContentWhitespace> attribute value
        <kwd:MUST> be set to <DOM::false>.
      @@@PerlDef:
        __DEEP{
          $r = $self-><M::Document.createElementNS>
                        (<Q::xdp|>, 'marked-section');
          my $mss_el = $self-><M::XDPDocument.createXDPMarkedSectionStatus>
                                ($status);
          $r-><M::Node.appendChild> ($mss_el);
          $r-><M::Node.manakaiAppendText> ($value)
            if defined $value and length $value;
        }__;

    @@Test:
      @@@QName: XDPDocument.createXDPMarkedSection.1.test
      @@@PerlDef:
        my $doc;
        __CODE{createXDPDocumentForTest}__;

        my $el = $doc-><M::XDPDocument.createXDPMarkedSection> ('IGNORE', 'a');

        $test->id ('interface');
        $test->assert_isa ($el, <IFName::XDPMarkedSectionElement>);

        $test->id ('namespaceURI');
        $test->assert_equals ($el-><AG::Node.namespaceURI>, <Q::xdp|>);

        $test->id ('localName');
        $test->assert_equals ($el-><AG::Node.localName>, 'marked-section');

        $test->id ('dtdText');
        $test->assert_equals ($el-><AG::XDPElement.dtdText>, '<![IGNORE[a]]>');
    @@Test:
      @@@QName: XDPDocument.createXDPMarkedSection.2.test
      @@@PerlDef:
        my $doc;
        __CODE{createXDPDocumentForTest}__;

        my $el = $doc-><M::XDPDocument.createXDPMarkedSection> ('IGNORE');

        $test->id ('interface');
        $test->assert_isa ($el, <IFName::XDPMarkedSectionElement>);

        $test->id ('namespaceURI');
        $test->assert_equals ($el-><AG::Node.namespaceURI>, <Q::xdp|>);

        $test->id ('localName');
        $test->assert_equals ($el-><AG::Node.localName>, 'marked-section');

        $test->id ('dtdText');
        $test->assert_equals ($el-><AG::XDPElement.dtdText>, '<![IGNORE[]]>');
    @@Test:
      @@@QName: XDPDocument.createXDPMarkedSection.3.test
      @@@PerlDef:
        my $doc;
        __CODE{createXDPDocumentForTest}__;

        my $el = $doc-><M::XDPDocument.createXDPMarkedSection> (null, 'a');

        $test->id ('interface');
        $test->assert_isa ($el, <IFName::XDPMarkedSectionElement>);

        $test->id ('namespaceURI');
        $test->assert_equals ($el-><AG::Node.namespaceURI>, <Q::xdp|>);

        $test->id ('localName');
        $test->assert_equals ($el-><AG::Node.localName>, 'marked-section');

        $test->id ('dtdText');
        $test->assert_equals ($el-><AG::XDPElement.dtdText>, '<![[a]]>');
    @@Test:
      @@@QName: XDPDocument.createXDPMarkedSection.4.test
      @@@PerlDef:
        my $doc;
        __CODE{createXDPDocumentForTest}__;

        my $el = $doc-><M::XDPDocument.createXDPMarkedSection>;

        $test->id ('interface');
        $test->assert_isa ($el, <IFName::XDPMarkedSectionElement>);

        $test->id ('namespaceURI');
        $test->assert_equals ($el-><AG::Node.namespaceURI>, <Q::xdp|>);

        $test->id ('localName');
        $test->assert_equals ($el-><AG::Node.localName>, 'marked-section');

        $test->id ('dtdText');
        $test->assert_equals ($el-><AG::XDPElement.dtdText>, '<![[]]>');

  @Method:
    @@Name: createXDPNotation
    @@enDesc:
      Creates a <XE::xdp|notation> element.
    @@Param:
      @@@Name: name
      @@@Type: DOMString
      @@@enDesc:
        The name of the declaration.
      @@@nullCase:
        @@@@enDesc:
          All parameters are ignored.
    @@Param:
      @@@Name: publicId
      @@@Type: DOMString
      @@@enDesc:
        The public identifier in the declaration.
      @@@nullCase:
        @@@@enDesc:
          No public identifier.
    @@Param:
      @@@Name: systemId
      @@@Type: DOMString
      @@@enDesc:
        The system identifier in the declaration.
      @@@nullCase:
        @@@@enDesc:
          No system identifier.
    @@Return:
      @@@Type: XDPNotationElement
      @@@enDesc:
        The newly created element node.

        {P:: A new <IF::Element> node with following attributes
             <kwd:MUST> be returned:

           - <A::Node.localName>::: <XE::notation>.

           - <A::Node.namespaceURI>::: <URI^^DISCore|QName::xdp|>.

           - <A::Node.ownerDocument>::: The document.
           
        }

        {P:: A series of nodes <kwd:MUST> be associated to the returned
             node as if the following algorithm were applied:

           = If <P::name> is <DOM::null>, stop the algorithm.

           = Create a node by <M::XDPDocument.createXDPS> on the document with
             a <CHAR::SPACE> as a parameter and append the
             node to the returned element by the <M::Node.appendChild> method.

           = Create a node by <M::XDPDocument.createXDPName> on the document
             with <P::name> as a parameter and append the
             node to the returned element by the <M::Node.appendChild> method.

           {OLI:: If <P::publicId> is different from <DOM::null>,

             = Create a node by <M::XDPDocument.createXDPS> on the document with
               a <CHAR::SPACE> as a parameter and append the
               node to the returned element by the <M::Node.appendChild> method.

             = Create a node by <M::XDPDocument.createXDPKeyword>
               on the document with a string <XML::PUBLIC> as
               a parameter and append the
               node to the returned element by the <M::Node.appendChild> method.

             = Create a node by <M::XDPDocument.createXDPS> on the document with
               a <CHAR::SPACE> as a parameter and append the
               node to the returned element by the <M::Node.appendChild> method.

             = Create a node by <M::XDPDocument.createXDPMinimumLiteral>
               on the document with <P::publicId> as a parameter
               and append the node to the returned element by
               the <M::Node.appendChild> method.

           }

           {OLI:: If <P::systemId> is different from <DOM::null> and
                  <P::publicId> is <DOM::null>,

             = Create a node by <M::XDPDocument.createXDPS> on the document with
               a <CHAR::SPACE> as a parameter and append the
               node to the returned element by the <M::Node.appendChild> method.

             = Create a node by <M::XDPDocument.createXDPKeyword>
               on the document with a string <XML::SYSTEM> as
               a parameter and append the
               node to the returned element by the <M::Node.appendChild> method.

           }

           {OLI:: If <P::systemId> is different from <DOM::null> and
                  <P::publicId> is <DOM::null>,

             = Create a node by <M::XDPDocument.createXDPS> on the document with
               a <CHAR::SPACE> as a parameter and append the
               node to the returned element by the <M::Node.appendChild> method.

             = Create a node by <M::XDPDocument.createXDPSystemLiteral>
               on the document with <P::systemId> as a parameter
               and append the node to the returned element by
               the <M::Node.appendChild> method.

           }

        }
      @@@PerlDef:
        __DEEP{
          $r = $self-><M::Document.createElementNS> (<Q::xdp|>, 'notation');
          if (defined $name) {
            $r-><M::Node.appendChild>
                  ($self-><M::XDPDocument.createXDPS> (' '));
            $r-><M::Node.appendChild>
                  ($self-><M::XDPDocument.createXDPName> ($name));

            if (defined $publicId) {
              $r-><M::Node.appendChild>
                    ($self-><M::XDPDocument.createXDPS> (' '));
              $r-><M::Node.appendChild>
                    ($self-><M::XDPDocument.createXDPKeyword> ('PUBLIC'));
              $r-><M::Node.appendChild>
                    ($self-><M::XDPDocument.createXDPS> (' '));
              $r-><M::Node.appendChild>
                    ($self-><M::XDPDocument.createXDPMinimumLiteral>
                              ($publicId));
              if (defined $systemId) {
                $r-><M::Node.appendChild>
                      ($self-><M::XDPDocument.createXDPS> (' '));
                $r-><M::Node.appendChild>
                      ($self-><M::XDPDocument.createXDPSystemLiteral>
                                ($systemId));
              }
            } elsif (defined $systemId) {
              $r-><M::Node.appendChild>
                    ($self-><M::XDPDocument.createXDPS> (' '));
              $r-><M::Node.appendChild>
                    ($self-><M::XDPDocument.createXDPKeyword> ('SYSTEM'));
              $r-><M::Node.appendChild>
                    ($self-><M::XDPDocument.createXDPS> (' '));
              $r-><M::Node.appendChild>
                    ($self-><M::XDPDocument.createXDPSystemLiteral>
                              ($systemId));
            }
          }
        }__;

    @@Test:
      @@@QName: XDPDocument.createXDPNotation.1.test
      @@@PerlDef:
        my $doc;
        __CODE{createXDPDocumentForTest}__;

        my $el = $doc-><M::XDPDocument.createXDPNotation>
                         ('iname', 'pubid', 'sysid');

        $test->id ('interface');
        $test->assert_isa ($el, <IFName::XDPNotationElement>);

        $test->id ('namespaceURI');
        $test->assert_equals ($el-><AG::Node.namespaceURI>, <Q::xdp|>);

        $test->id ('localName');
        $test->assert_equals ($el-><AG::Node.localName>, 'notation');

        $test->id ('dtdText');
        $test->assert_equals ($el-><AG::XDPElement.dtdText>,
                              '<!NOTATION iname PUBLIC "pubid" "sysid">');
    @@Test:
      @@@QName: XDPDocument.createXDPNotation.2.test
      @@@PerlDef:
        my $doc;
        __CODE{createXDPDocumentForTest}__;

        my $el = $doc-><M::XDPDocument.createXDPNotation>
                         ('iname', 'pubid');

        $test->id ('dtdText');
        $test->assert_equals ($el-><AG::XDPElement.dtdText>,
                              '<!NOTATION iname PUBLIC "pubid">');
    @@Test:
      @@@QName: XDPDocument.createXDPNotation.3.test
      @@@PerlDef:
        my $doc;
        __CODE{createXDPDocumentForTest}__;

        my $el = $doc-><M::XDPDocument.createXDPNotation>
                         ('iname');

        $test->id ('dtdText');
        $test->assert_equals ($el-><AG::XDPElement.dtdText>,
                              '<!NOTATION iname>');
    @@Test:
      @@@QName: XDPDocument.createXDPNotation.4.test
      @@@PerlDef:
        my $doc;
        __CODE{createXDPDocumentForTest}__;

        my $el = $doc-><M::XDPDocument.createXDPNotation>;

        $test->id ('dtdText');
        $test->assert_equals ($el-><AG::XDPElement.dtdText>,
                              '<!NOTATION>');
    @@Test:
      @@@QName: XDPDocument.createXDPNotation.5.test
      @@@PerlDef:
        my $doc;
        __CODE{createXDPDocumentForTest}__;

        my $el = $doc-><M::XDPDocument.createXDPNotation>
                         ('iname', null, 'sysid');

        $test->id ('dtdText');
        $test->assert_equals ($el-><AG::XDPElement.dtdText>,
                              '<!NOTATION iname SYSTEM "sysid">');
    @@Test:
      @@@QName: XDPDocument.createXDPNotation.6.test
      @@@PerlDef:
        my $doc;
        __CODE{createXDPDocumentForTest}__;

        my $el = $doc-><M::XDPDocument.createXDPNotation>
                         (null, null, 'sysid');

        $test->id ('dtdText');
        $test->assert_equals ($el-><AG::XDPElement.dtdText>,
                              '<!NOTATION>');
    @@Test:
      @@@QName: XDPDocument.createXDPNotation.7.test
      @@@PerlDef:
        my $doc;
        __CODE{createXDPDocumentForTest}__;

        my $el = $doc-><M::XDPDocument.createXDPNotation>
                         (null, 'pubid');

        $test->id ('dtdText');
        $test->assert_equals ($el-><AG::XDPElement.dtdText>,
                              '<!NOTATION>');
    @@Test:
      @@@QName: XDPDocument.createXDPNotation.8.test
      @@@PerlDef:
        my $doc;
        __CODE{createXDPDocumentForTest}__;

        my $el = $doc-><M::XDPDocument.createXDPNotation>
                         (null, 'pubid', 'sysid');

        $test->id ('dtdText');
        $test->assert_equals ($el-><AG::XDPElement.dtdText>,
                              '<!NOTATION>');

  @Method:
    @@Name: createXDPEntity
    @@enDesc:
      Creates a <XE::xdp|entity> element.
    @@Param:
      @@@Name: isPE
      @@@Type: boolean
      @@@enDesc:
        Whether the declaration declares a parameter entity or not.
      @@@TrueCase:
        @@@@enDesc:
          The declaration declares a parameter entity.  A <XML::%>
          delimiter will be appended to the return node.
      @@@FalseCase:
        @@@@enDesc:
          The declaration is not known to declare a parameter entity.
    @@Param:
      @@@Name: name
      @@@Type: DOMString
      @@@enDesc:
        The name of the declaration.
      @@@nullCase:
        @@@@enDesc:
          All parameters are ignored.
    @@Param:
      @@@Name: value
      @@@Type: DOMString
      @@@enDesc:
        The literal replacement text of the declaration.
      @@@nullCase:
        @@@@enDesc:
          Same as an empty string or no entity value in the declaration, 
          depending on whether the <P::publicId> parameters are <DOM::null>
          or not.
    @@Param:
      @@@Name: publicId
      @@@Type: DOMString
      @@@enDesc:
        The public identifier in the declaration.
      @@@nullCase:
        @@@@enDesc:
          No public identifier.
    @@Param:
      @@@Name: systemId
      @@@Type: DOMString
      @@@enDesc:
        The system identifier in the declaration.
      @@@nullCase:
        @@@@enDesc:
          No system identifier.
    @@Param:
      @@@Name: notation
      @@@Type: DOMString
      @@@enDesc:
        The notation name in the declaration.
      @@@nullCase:
        @@@@enDesc:
          No notation name.
    @@Return:
      @@@Type: XDPEntityElement
      @@@enDesc:
        The newly created element node.

        {P:: A new <IF::Element> node with following attributes
             <kwd:MUST> be returned:

           - <A::Node.localName>::: <XE::entity>.

           - <A::Node.namespaceURI>::: <URI^^DISCore|QName::xdp|>.

           - <A::Node.ownerDocument>::: The document.
           
        }

        {P:: A series of nodes <kwd:MUST> be associated to the returned
             node as if the following algorithm were applied:

           {OLI:: If <P::isPE> is <DOM::true>,

                 = Create a node by <M::XDPDocument.createXDPS> on the
                   document with a <CHAR::SPACE> as a parameter and append the
                   node to the returned element by the <M::Node.appendChild>
                   method.

                 = Create a node by <M::XDPDocument.createXDPDelimiter>
                   on the document with a <CHAR::PERCENT SIGN> as a parameter
                   and append the node to the returned element by the
                   <M::Node.appendChild> method.

           }

           = If <P::name> is <DOM::null>, stop the algorithm.

           = Create a node by <M::XDPDocument.createXDPS> on the document with
             a <CHAR::SPACE> as a parameter and append the
             node to the returned element by the <M::Node.appendChild> method.

           = Create a node by <M::XDPDocument.createXDPName> on the document
             with <P::name> as a parameter and append the
             node to the returned element by the <M::Node.appendChild> method.

           {OLI:: If <P::systemId> is different from <DOM::null>,

             {OLI:: If <P::publicId> is different from <DOM::null>,
  
               = Create a node by <M::XDPDocument.createXDPS> on the document
                 with a <CHAR::SPACE> as a parameter and append the
                 node to the returned element by the <M::Node.appendChild>
                 method.

               = Create a node by <M::XDPDocument.createXDPKeyword>
                 on the document with a string <XML::PUBLIC> as
                 a parameter and append the
                 node to the returned element by the <M::Node.appendChild>
                 method.

               = Create a node by <M::XDPDocument.createXDPS> on the document 
                 with a <CHAR::SPACE> as a parameter and append the
                 node to the returned element by the <M::Node.appendChild>
                 method.

               = Create a node by <M::XDPDocument.createXDPMinimumLiteral>
                 on the document with <P::publicId> as a parameter
                 and append the node to the returned element by
                 the <M::Node.appendChild> method.

             }

             {OLI:: Otherwise,

               = Create a node by <M::XDPDocument.createXDPS> on the document
                 with a <CHAR::SPACE> as a parameter and append the
                 node to the returned element by the <M::Node.appendChild>
                 method.

               = Create a node by <M::XDPDocument.createXDPKeyword>
                 on the document with a string <XML::SYSTEM> as
                 a parameter and append the
                 node to the returned element by the <M::Node.appendChild>
                 method.

             }

             = Create a node by <M::XDPDocument.createXDPS> on the document with
               a <CHAR::SPACE> as a parameter and append the
               node to the returned element by the <M::Node.appendChild> method.

             = Create a node by <M::XDPDocument.createXDPSystemLiteral>
               on the document with <P::systemId> as a parameter
               and append the node to the returned element by
               the <M::Node.appendChild> method.

             {OLI:: If <P::notation> is different from <DOM::null>
                    and <P::isPE> is <DOM::false>,

               = Create a node by <M::XDPDocument.createXDPS> on the document
                 with a <CHAR::SPACE> as a parameter and append the
                 node to the returned element by the <M::Node.appendChild>
                 method.

               = Create a node by <M::XDPDocument.createXDPKeyword>
                 on the document with a string <XML::NDATA> as
                 a parameter and append the
                 node to the returned element by the <M::Node.appendChild>
                 method.

               = Create a node by <M::XDPDocument.createXDPS> on the document 
                 with a <CHAR::SPACE> as a parameter and append the
                 node to the returned element by the <M::Node.appendChild>
                 method.
  
               = Create a node by <M::XDPDocument.createXDPName>
                 on the document with <P::notation> as a parameter
                 and append the node to the returned element by
                 the <M::Node.appendChild> method.

             }

           }

           {OLI:: Otherwise, 

             = Create a node by <M::XDPDocument.createXDPS> on the document with
               a <CHAR::SPACE> as a parameter and append the
               node to the returned element by the <M::Node.appendChild> method.

             = Create a node by <M::XDPDocument.createXDPEntityValue>
               on the document with <P::value> as a parameter
               and append the node to the returned element by
               the <M::Node.appendChild> method.

           }

        }
      @@@PerlDef:
        __DEEP{
          $r = $self-><M::Document.createElementNS> (<Q::xdp|>, 'entity');
          if ($isPE) {
            $r-><M::Node.appendChild>
                  ($self-><M::XDPDocument.createXDPS> (' '));
            $r-><M::Node.appendChild>
                  ($self-><M::XDPDocument.createXDPDelimiter> ('%'));
          }
          if (defined $name) {
            $r-><M::Node.appendChild>
                  ($self-><M::XDPDocument.createXDPS> (' '));
            $r-><M::Node.appendChild>
                  ($self-><M::XDPDocument.createXDPName> ($name));

            if (defined $systemId) {
              if (defined $publicId) {
                $r-><M::Node.appendChild>
                      ($self-><M::XDPDocument.createXDPS> (' '));
                $r-><M::Node.appendChild>
                      ($self-><M::XDPDocument.createXDPKeyword> ('PUBLIC'));
                $r-><M::Node.appendChild>
                      ($self-><M::XDPDocument.createXDPS> (' '));
                $r-><M::Node.appendChild>
                      ($self-><M::XDPDocument.createXDPMinimumLiteral>
                                ($publicId));
                $r-><M::Node.appendChild>
                      ($self-><M::XDPDocument.createXDPS> (' '));
                $r-><M::Node.appendChild>
                      ($self-><M::XDPDocument.createXDPSystemLiteral>
                                ($systemId));
              } else {
                $r-><M::Node.appendChild>
                      ($self-><M::XDPDocument.createXDPS> (' '));
                $r-><M::Node.appendChild>
                      ($self-><M::XDPDocument.createXDPKeyword> ('SYSTEM'));
                $r-><M::Node.appendChild>
                      ($self-><M::XDPDocument.createXDPS> (' '));
                $r-><M::Node.appendChild>
                      ($self-><M::XDPDocument.createXDPSystemLiteral>
                                ($systemId));
              }

              if (defined $notation and not $isPE) {
                $r-><M::Node.appendChild>
                      ($self-><M::XDPDocument.createXDPS> (' '));
                $r-><M::Node.appendChild>
                      ($self-><M::XDPDocument.createXDPKeyword> ('NDATA'));
                $r-><M::Node.appendChild>
                      ($self-><M::XDPDocument.createXDPS> (' '));
                $r-><M::Node.appendChild>
                      ($self-><M::XDPDocument.createXDPName> ($notation));
              }
            } else {
              $r-><M::Node.appendChild>
                    ($self-><M::XDPDocument.createXDPS> (' '));
              $r-><M::Node.appendChild>
                    ($self-><M::XDPDocument.createXDPEntityValue> ($value));
            }
          }
        }__;

    @@Test:
      @@@QName: XDPDocument.createXDPEntity.1.test
      @@@PerlDef:
        my $doc;
        __CODE{createXDPDocumentForTest}__;

        my $el = $doc-><M::XDPDocument.createXDPEntity>
                         (true, 'iname', 'evalue', 'pubid', 'sysid', 'nname');

        $test->id ('interface');
        $test->assert_isa ($el, <IFName::XDPEntityElement>);

        $test->id ('namespaceURI');
        $test->assert_equals ($el-><AG::Node.namespaceURI>, <Q::xdp|>);

        $test->id ('localName');
        $test->assert_equals ($el-><AG::Node.localName>, 'entity');

        $test->id ('dtdText');
        $test->assert_equals
                 ($el-><AG::XDPElement.dtdText>,
                  '<!ENTITY % iname PUBLIC "pubid" "sysid">');
    @@Test:
      @@@QName: XDPDocument.createXDPEntity.2.test
      @@@PerlDef:
        my $doc;
        __CODE{createXDPDocumentForTest}__;

        my $el = $doc-><M::XDPDocument.createXDPEntity>
                         (false, 'iname', 'evalue', 'pubid', 'sysid', 'nname');

        $test->id ('dtdText');
        $test->assert_equals
                 ($el-><AG::XDPElement.dtdText>,
                  '<!ENTITY iname PUBLIC "pubid" "sysid" NDATA nname>');
    @@Test:
      @@@QName: XDPDocument.createXDPEntity.3.test
      @@@PerlDef:
        my $doc;
        __CODE{createXDPDocumentForTest}__;

        my $el = $doc-><M::XDPDocument.createXDPEntity>
                         (false, 'iname', 'evalue', 'pubid', 'sysid');

        $test->id ('dtdText');
        $test->assert_equals
                 ($el-><AG::XDPElement.dtdText>,
                  '<!ENTITY iname PUBLIC "pubid" "sysid">');
    @@Test:
      @@@QName: XDPDocument.createXDPEntity.4.test
      @@@PerlDef:
        my $doc;
        __CODE{createXDPDocumentForTest}__;

        my $el = $doc-><M::XDPDocument.createXDPEntity>
                         (true, 'iname', 'evalue', 'pubid', 'sysid');

        $test->id ('dtdText');
        $test->assert_equals
                 ($el-><AG::XDPElement.dtdText>,
                  '<!ENTITY % iname PUBLIC "pubid" "sysid">');
    @@Test:
      @@@QName: XDPDocument.createXDPEntity.5.test
      @@@PerlDef:
        my $doc;
        __CODE{createXDPDocumentForTest}__;

        my $el = $doc-><M::XDPDocument.createXDPEntity>
                         (false, 'iname', 'evalue', null, 'sysid');

        $test->id ('dtdText');
        $test->assert_equals
                 ($el-><AG::XDPElement.dtdText>,
                  '<!ENTITY iname SYSTEM "sysid">');
    @@Test:
      @@@QName: XDPDocument.createXDPEntity.6.test
      @@@PerlDef:
        my $doc;
        __CODE{createXDPDocumentForTest}__;

        my $el = $doc-><M::XDPDocument.createXDPEntity>
                         (true, 'iname', 'evalue', null, 'sysid');

        $test->id ('dtdText');
        $test->assert_equals
                 ($el-><AG::XDPElement.dtdText>,
                  '<!ENTITY % iname SYSTEM "sysid">');
    @@Test:
      @@@QName: XDPDocument.createXDPEntity.7.test
      @@@PerlDef:
        my $doc;
        __CODE{createXDPDocumentForTest}__;

        my $el = $doc-><M::XDPDocument.createXDPEntity>
                         (false, 'iname', 'evalue');

        $test->id ('dtdText');
        $test->assert_equals
                 ($el-><AG::XDPElement.dtdText>,
                  '<!ENTITY iname "evalue">');
    @@Test:
      @@@QName: XDPDocument.createXDPEntity.8.test
      @@@PerlDef:
        my $doc;
        __CODE{createXDPDocumentForTest}__;

        my $el = $doc-><M::XDPDocument.createXDPEntity>
                         (true, 'iname', 'evalue');

        $test->id ('dtdText');
        $test->assert_equals
                 ($el-><AG::XDPElement.dtdText>,
                  '<!ENTITY % iname "evalue">');
    @@Test:
      @@@QName: XDPDocument.createXDPEntity.9.test
      @@@PerlDef:
        my $doc;
        __CODE{createXDPDocumentForTest}__;

        my $el = $doc-><M::XDPDocument.createXDPEntity>
                         (false, 'iname');

        $test->id ('dtdText');
        $test->assert_equals
                 ($el-><AG::XDPElement.dtdText>,
                  '<!ENTITY iname "">');
    @@Test:
      @@@QName: XDPDocument.createXDPEntity.10.test
      @@@PerlDef:
        my $doc;
        __CODE{createXDPDocumentForTest}__;

        my $el = $doc-><M::XDPDocument.createXDPEntity>
                         (false);

        $test->id ('dtdText');
        $test->assert_equals
                 ($el-><AG::XDPElement.dtdText>,
                  '<!ENTITY>');
    @@Test:
      @@@QName: XDPDocument.createXDPEntity.11.test
      @@@PerlDef:
        my $doc;
        __CODE{createXDPDocumentForTest}__;

        my $el = $doc-><M::XDPDocument.createXDPEntity>
                         (true);

        $test->id ('dtdText');
        $test->assert_equals
                 ($el-><AG::XDPElement.dtdText>,
                  '<!ENTITY %>');

  @Method:
    @@Name: createXDPEnumGroup
    @@enDesc:
      Creates a <XE::xdp|enum-group> element.
    @@Return:
      @@@Type: XDPEnumGroupElement
      @@@enDesc:
        The newly created element node.

        {P:: A new <IF::Element> node with following attributes
             <kwd:MUST> be returned:

           - <A::Node.localName>::: <XE::enum-group>.

           - <A::Node.namespaceURI>::: <URI^^DISCore|QName::xdp|>.

           - <A::Node.ownerDocument>::: The document.
           
        }
      @@@PerlDef:
        __DEEP{
          $r = $self-><M::Document.createElementNS>
                        (<Q::xdp|>, 'enum-group');
        }__;

    @@Test:
      @@@QName: XDPDocument.createXDPEnumGroup.1.test
      @@@PerlDef:
        my $doc;
        __CODE{createXDPDocumentForTest}__;

        my $el = $doc-><M::XDPDocument.createXDPEnumGroup>;

        $test->id ('interface');
        $test->assert_isa ($el, <IFName::XDPEnumGroupElement>);

        $test->id ('namespaceURI');
        $test->assert_equals ($el-><AG::Node.namespaceURI>, <Q::xdp|>);

        $test->id ('localName');
        $test->assert_equals ($el-><AG::Node.localName>, 'enum-group');

        $test->id ('dtdText');
        $test->assert_equals ($el-><AG::XDPElement.dtdText>, '()');

  @Method:
    @@Name: createXDPModelGroup
    @@enDesc:
      Creates a <XE::xdp|model-group> element.
    @@Return:
      @@@Type: XDPModelGroupElement
      @@@enDesc:
        The newly created element node.

        {P:: A new <IF::Element> node with following attributes
             <kwd:MUST> be returned:

           - <A::Node.localName>::: <XE::model-group>.

           - <A::Node.namespaceURI>::: <URI^^DISCore|QName::xdp|>.

           - <A::Node.ownerDocument>::: The document.
           
        }
      @@@PerlDef:
        __DEEP{
          $r = $self-><M::Document.createElementNS>
                        (<Q::xdp|>, 'model-group');
        }__;

    @@Test:
      @@@QName: XDPDocument.createXDPModelGroup.1.test
      @@@PerlDef:
        my $doc;
        __CODE{createXDPDocumentForTest}__;

        my $el = $doc-><M::XDPDocument.createXDPModelGroup>;

        $test->id ('interface');
        $test->assert_isa ($el, <IFName::XDPModelGroupElement>);

        $test->id ('namespaceURI');
        $test->assert_equals ($el-><AG::Node.namespaceURI>, <Q::xdp|>);

        $test->id ('localName');
        $test->assert_equals ($el-><AG::Node.localName>, 'model-group');

        $test->id ('dtdText');
        $test->assert_equals ($el-><AG::XDPElement.dtdText>, '()');

  @Method:
    @@Name: createXDPAttrDefinition
    @@enDesc:
      Creates a <XE::xdp|attr-definition> element.

      {ISSUE::
        Declared type and default type parameters should be added?
      }
    @@Param:
      @@@Name: name
      @@@Type: DOMString
      @@@enDesc: 
        The name of the attribute.
      @@@nullCase:
        @@@@enDesc:
          All parameters are ignored.
    @@Return:
      @@@Type: XDPElement
      @@@enDesc:
        The newly created element node.

        {P:: A new <IF::Element> node with following attributes
             <kwd:MUST> be returned:

           - <A::Node.localName>::: <XE::attr-definition>.

           - <A::Node.namespaceURI>::: <URI^^DISCore|QName::xdp|>.

           - <A::Node.ownerDocument>::: The document.
           
        }

        {P:: If <P::name> is different from <DOM::null>, a
             <IF::Element> node with following attributes
             <kwd:MUST> be appended to the returned node
             as if the <M::Node.appendChild> method were invoked.

           - <A::Node.localName>::: <XE::name>.

           - <A::Node.namespaceURI>::: <URI^^DISCore|QName::xdp|>.

           - <A::Node.ownerDocument>::: The document.

           - <A::Node.textContent>::: <P::name>.

        }
      @@@PerlDef:
        __DEEP{
          $r = $self-><M::Document.createElementNS>
                        (<Q::xdp|>, 'attr-definition');
          $r-><M::Node.appendChild>
                ($self-><M::XDPDocument.createXDPName> ($name))
            if defined $name;
        }__;

    @@Test:
      @@@QName: XDPDocument.createXDPAttrDefinition.1.test
      @@@PerlDef:
        my $doc;
        __CODE{createXDPDocumentForTest}__;

        my $el = $doc-><M::XDPDocument.createXDPAttrDefinition> ('aname');

        $test->id ('interface');
        $test->assert_isa ($el, <IFName::XDPElement>);

        $test->id ('namespaceURI');
        $test->assert_equals ($el-><AG::Node.namespaceURI>, <Q::xdp|>);

        $test->id ('localName');
        $test->assert_equals ($el-><AG::Node.localName>, 'attr-definition');

        $test->id ('dtdText');
        $test->assert_equals ($el-><AG::XDPElement.dtdText>, 'aname');
    @@Test:
      @@@QName: XDPDocument.createXDPAttrDefinition.2.test
      @@@PerlDef:
        my $doc;
        __CODE{createXDPDocumentForTest}__;

        my $el = $doc-><M::XDPDocument.createXDPAttrDefinition>;

        $test->id ('interface');
        $test->assert_isa ($el, <IFName::XDPElement>);

        $test->id ('namespaceURI');
        $test->assert_equals ($el-><AG::Node.namespaceURI>, <Q::xdp|>);

        $test->id ('localName');
        $test->assert_equals ($el-><AG::Node.localName>, 'attr-definition');

        $test->id ('dtdText');
        $test->assert_equals ($el-><AG::XDPElement.dtdText>, '');

  @Method:
    @@Name: createXDPAttlist
    @@enDesc:
      Creates a <XE::xdp|attlist> element.
    @@Param:
      @@@Name: name
      @@@Type: DOMString
      @@@enDesc: 
        The name in the declaration.
      @@@nullCase:
        @@@@enDesc:
          The declaration does not contain any name.
    @@Return:
      @@@Type: XDPAttlistElement
      @@@enDesc:
        The newly created element node.

        {P:: A new <IF::Element> node with following attributes
             <kwd:MUST> be returned:

           - <A::Node.localName>::: <XE::attlist>.

           - <A::Node.namespaceURI>::: <URI^^DISCore|QName::xdp|>.

           - <A::Node.ownerDocument>::: The document.
           
        }

        {P:: If <P::name> is different from <DOM::null>, two
             <IF::Element> nodes with following attributes
             <kwd:MUST> be appended to the returned node
             as if the <M::Node.appendChild> method were invoked in order.

           {LI::
             
             - <A::Node.localName>::: <XE::s>.

             - <A::Node.namespaceURI>::: <URI^^DISCore|QName::xdp|>.
 
             - <A::Node.ownerDocument>::: The document.

             - <A::Node.textContent>::: A <CHAR::SPACE>.

           }

           {LI::

             - <A::Node.localName>::: <XE::name>.

             - <A::Node.namespaceURI>::: <URI^^DISCore|QName::xdp|>.
 
             - <A::Node.ownerDocument>::: The document.

             - <A::Node.textContent>::: <P::name>.

           }

        }
      @@@PerlDef:
        __DEEP{
          $r = $self-><M::Document.createElementNS>
                        (<Q::xdp|>, 'attlist');
          if (defined $name) {
            $r-><M::Node.appendChild>
                  ($self-><M::XDPDocument.createXDPS> (' '));
            $r-><M::Node.appendChild>
                  ($self-><M::XDPDocument.createXDPName> ($name));
          }
        }__;

    @@Test:
      @@@QName: XDPDocument.createXDPAttlist.1.test
      @@@PerlDef:
        my $doc;
        __CODE{createXDPDocumentForTest}__;

        my $el = $doc-><M::XDPDocument.createXDPAttlist> ('aname');

        $test->id ('interface');
        $test->assert_isa ($el, <IFName::XDPAttlistElement>);

        $test->id ('namespaceURI');
        $test->assert_equals ($el-><AG::Node.namespaceURI>, <Q::xdp|>);

        $test->id ('localName');
        $test->assert_equals ($el-><AG::Node.localName>, 'attlist');

        $test->id ('dtdText');
        $test->assert_equals ($el-><AG::XDPElement.dtdText>, '<!ATTLIST aname>');
    @@Test:
      @@@QName: XDPDocument.createXDPAttlist.2.test
      @@@PerlDef:
        my $doc;
        __CODE{createXDPDocumentForTest}__;

        my $el = $doc-><M::XDPDocument.createXDPAttlist>;

        $test->id ('interface');
        $test->assert_isa ($el, <IFName::XDPAttlistElement>);

        $test->id ('namespaceURI');
        $test->assert_equals ($el-><AG::Node.namespaceURI>, <Q::xdp|>);

        $test->id ('localName');
        $test->assert_equals ($el-><AG::Node.localName>, 'attlist');

        $test->id ('dtdText');
        $test->assert_equals ($el-><AG::XDPElement.dtdText>, '<!ATTLIST>');

  @Method:
    @@Name: createXDPElement
    @@enDesc:
      Creates a <XE::xdp|element> element.

      {ISSUE::
        Should declared content parameter be added?
      }
    @@Param:
      @@@Name: name
      @@@Type: DOMString
      @@@enDesc: 
        The name in the declaration.
      @@@nullCase:
        @@@@enDesc:
          The declaration does not contain any name.
    @@Return:
      @@@Type: XDPElementElement
      @@@enDesc:
        The newly created element node.

        {P:: A new <IF::Element> node with following attributes
             <kwd:MUST> be returned:

           - <A::Node.localName>::: <XE::element>.

           - <A::Node.namespaceURI>::: <URI^^DISCore|QName::xdp|>.

           - <A::Node.ownerDocument>::: The document.
           
        }

        {P:: If <P::name> is different from <DOM::null>, two
             <IF::Element> nodes with following attributes
             <kwd:MUST> be appended to the returned node
             as if the <M::Node.appendChild> method were invoked in order.

           {LI::
             
             - <A::Node.localName>::: <XE::s>.

             - <A::Node.namespaceURI>::: <URI^^DISCore|QName::xdp|>.
 
             - <A::Node.ownerDocument>::: The document.

             - <A::Node.textContent>::: A <CHAR::SPACE>.

           }

           {LI::

             - <A::Node.localName>::: <XE::name>.

             - <A::Node.namespaceURI>::: <URI^^DISCore|QName::xdp|>.
 
             - <A::Node.ownerDocument>::: The document.

             - <A::Node.textContent>::: <P::name>.

           }

        }
      @@@PerlDef:
        __DEEP{
          $r = $self-><M::Document.createElementNS>
                        (<Q::xdp|>, 'element');
          if (defined $name) {
            $r-><M::Node.appendChild>
                  ($self-><M::XDPDocument.createXDPS> (' '));
            $r-><M::Node.appendChild>
                  ($self-><M::XDPDocument.createXDPName> ($name));
          }
        }__;

    @@Test:
      @@@QName: XDPDocument.createXDPElement.1.test
      @@@PerlDef:
        my $doc;
        __CODE{createXDPDocumentForTest}__;

        my $el = $doc-><M::XDPDocument.createXDPElement> ('aname');

        $test->id ('interface');
        $test->assert_isa ($el, <IFName::XDPElementElement>);

        $test->id ('namespaceURI');
        $test->assert_equals ($el-><AG::Node.namespaceURI>, <Q::xdp|>);

        $test->id ('localName');
        $test->assert_equals ($el-><AG::Node.localName>, 'element');

        $test->id ('dtdText');
        $test->assert_equals ($el-><AG::XDPElement.dtdText>, '<!ELEMENT aname>');
    @@Test:
      @@@QName: XDPDocument.createXDPElement.2.test
      @@@PerlDef:
        my $doc;
        __CODE{createXDPDocumentForTest}__;

        my $el = $doc-><M::XDPDocument.createXDPElement>;

        $test->id ('interface');
        $test->assert_isa ($el, <IFName::XDPElementElement>);

        $test->id ('namespaceURI');
        $test->assert_equals ($el-><AG::Node.namespaceURI>, <Q::xdp|>);

        $test->id ('localName');
        $test->assert_equals ($el-><AG::Node.localName>, 'element');

        $test->id ('dtdText');
        $test->assert_equals ($el-><AG::XDPElement.dtdText>, '<!ELEMENT>');

  @Method:
    @@Name: createXDPIf
    @@enDesc:
      Creates an <XE::xdp|if> element.
    @@Param:
      @@@Name: statusEntity
      @@@Type: DOMString
      @@@enDesc: 
        The name of the parameter entity that contains
        the status of the marked section.
      @@@nullCase:
        @@@@enDesc:
          Same as an empty string.
    @@Return:
      @@@Type: XDPIfElement
      @@@enDesc:
        The newly created element node.

        {P:: A new <IF::Element> node with following attributes
             <kwd:MUST> be returned:

           - <A::Node.localName>::: <XE::if>.

           - <A::Node.namespaceURI>::: <URI^^DISCore|QName::xdp|>.

           - <A::Node.ownerDocument>::: The document.
           
        }

        {P:: The <A::Node.attributes> <IF::tc|NamedNodeMap>
             of the returned <IF:Element> node <kwd:MUST> contain
             a new <IF::te|Attr> node with following attributes:
 
           - <A::Node.localName>::: <XA::status-entity>.

           - <A::Node.namespaceURI>::: <DOM::null>.

           - <A::te|Attr.specified>::: <DOM::true>.

           - <A::Node.textContent>::: <P::statusEntity>, or an empty
                                      string if <P::statusEntity>
                                      is <DOM::null>.

        }

        {P:: <A::Node.childNodes> <IF::tc|NodeList> of
             the returned <IF::Element> node <kwd:MUST> contain
             two <IF::Element> nodes in order:

           {LI::
             
             - <A::Node.localName>::: <XE::true>.

             - <A::Node.namespaceURI>::: <URI^^DISCore|QName::xdp|>.
 
             - <A::Node.ownerDocument>::: The document.

             - <A::Node.textContent>::: An empty string.

           }

           {LI::

             - <A::Node.localName>::: <XE::false>.

             - <A::Node.namespaceURI>::: <URI^^DISCore|QName::xdp|>.
 
             - <A::Node.ownerDocument>::: The document.

             - <A::Node.textContent>::: An empty string.

           }

        }
      @@@PerlDef:
        __DEEP{
          $r = $self-><M::Document.createElementNS> (<Q::xdp|>, 'if');
          $r-><M::Element.setAttributeNS>
                (null, 'status-entity',
                 defined $statusEntity ? $statusEntity : '');
          $r-><M::Node.appendChild>
                ($self-><M::Document.createElementNS> (<Q::xdp|>, 'tr'.'ue'));
          $r-><M::Node.appendChild>
                ($self-><M::Document.createElementNS> (<Q::xdp|>, 'fal'.'se'));
        }__;

    @@Test:
      @@@QName: XDPDocument.createXDPIf.1.test
      @@@PerlDef:
        my $doc;
        __CODE{createXDPDocumentForTest}__;

        my $el = $doc-><M::XDPDocument.createXDPIf> ('aname');

        $test->id ('interface');
        $test->assert_isa ($el, <IFName::XDPIfElement>);

        $test->id ('namespaceURI');
        $test->assert_equals ($el-><AG::Node.namespaceURI>, <Q::xdp|>);

        $test->id ('localName');
        $test->assert_equals ($el-><AG::Node.localName>, 'if');

        $test->id ('dtdText');
        $test->assert_equals ($el-><AG::XDPElement.dtdText>,
                              "<![%aname;[\n<!-- end of aname -->]]>\n");

        $test->id ('fc');
        my $fc = $el-><AG::Node.firstChild>;
        $test->assert_isa ($fc, <IFName::XDPElement>);

        $test->id ('fc.namespaceURI');
        $test->assert_equals ($fc-><AG::Node.namespaceURI>, <Q::xdp|>);

        $test->id ('fc.localName');
        $test->assert_equals ($fc-><AG::Node.localName>, 'tr'.'ue');

        $test->id ('lc');
        my $lc = $el-><AG::Node.lastChild>;
        $test->assert_isa ($fc, <IFName::XDPElement>);

        $test->id ('lc.namespaceURI');
        $test->assert_equals ($lc-><AG::Node.namespaceURI>, <Q::xdp|>);

        $test->id ('lc.localName');
        $test->assert_equals ($lc-><AG::Node.localName>, 'fal'.'se');
##XDPDocument

IFClsDef:
  @IFQName: XDPElement
  @ClsQName: ManakaiDOMXDPElement

  @IFISA: Element
  @ClsISA: te|ManakaiDOMElement

  @s:elementType: AnyXDPElement||ManakaiDOM|all

  @Test:
    @@QName: createElementNS.XDPElement.test
    @@PerlDef:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

      my $el = $doc-><M::Document.createElementNS> (<Q::xdp:>, 'anElement');
  
      $test->assert_isa ($el, <IFName::XDPElement>);

  @Attr:
    @@Name: dtdText
    @@enDesc:
      The serialized representation of the element and its descendants.
    @@Type: DOMString
    @@Get:
      @@@enDesc:
        {ISSUE::
          Definition
        }
      @@@PerlDef:
        require Message::DOM::Traversal;
        my $doctrv = $self-><AG::Node.ownerDocument>
                          -><M::Node.getFeature> (Traversal => '2.0');
        my $tw = $doctrv->create_tree_walker
                            ($self, <C::NodeFilter.SHOW_ELEMENT> |
                                    <C::NodeFilter.SHOW_TEXT> |
                                    <C::NodeFilter.SHOW_CDATA_SECTION>,
                             sub {
                               my $node = $_[1];
                               if ($node-><AG::Node.nodeType>
                                       == <C::Node.ELEMENT_NODE>) {
                                 my $ns = $node-><AG::Node.namespaceURI>;
                                 if (not defined $ns) {
                                   return <C::NodeFilter.FILTER_REJECT>;
                                 } elsif ($ns eq <Q::xdp|>) {
                                   return <C::NodeFilter.FILTER_ACCEPT>;
                                 } else {
                                   return <C::NodeFilter.FILTER_REJECT>;
                                 }
                               } else {
                                 return <C::NodeFilter.FILTER_ACCEPT>;
                               }
                             }, true);
        my $current = $tw->first_child;
        $r = '';
        C: while (defined $current) {
          if ($current-><AG::Node.nodeType> == <C::Node.ELEMENT_NODE>) {
            $r .= $current-><AG::XDPElement.dtdText>;
          } else {
            $r .= $current-><AG::Node.textContent>;
          }
          
          $current = $tw->next_sibling;
        } # C
##XDPElement

ResourceDef:
  @QName: AnyXDPElement
  @DISCore:resourceType: s|AnyElementInNS
  @AppName:
    @@@: xdp|*
    @@ContentType: DISCore|QName
  @ForCheck: =ManakaiDOM|all

IFClsETDef:
  @IFQName: XDPPEElement
  @ETQName: xdp|pe
  @ClsQName: ManakaiDOMXDPPEElement

  @IFISA: XDPElement
  @ClsISA: ManakaiDOMXDPElement

  @enDesc:
    An <XE::xdp|pe> element represents an XML parameter
    entity, an XML external subset entity, or an XML internal subset.
##XDPPEElement

IFClsETDef:
  @IFQName: XDPElementElement
  @ETQName: xdp|element
  @ClsQName: ManakaiDOMXDPElementElement

  @IFISA: XDPElement
  @ClsISA: ManakaiDOMXDPElement

  @enDesc:
    An <XE::xdp|element> element represents an XML <XML::ELEMENT>
    declaration.

  @CAttr:
    @@Name: dtdText
    @@Type: DOMString
    @@Get:
      @@@PerlDef:
        $r = '<!ELEMENT'.$self->SUPER::dtd_text.'>';
##XDPElementElement

IFClsETDef:
  @IFQName: XDPModelGroupElement
  @ETQName: xdp|model-group
  @ClsQName: ManakaiDOMXDPModelGroupElement

  @IFISA: XDPElement
  @ClsISA: ManakaiDOMXDPElement

  @enDesc:
    An <XE::xdp|model-group> element represents an XML model
    group.

  @CAttr:
    @@Name: dtdText
    @@Type: DOMString
    @@Get:
      @@@PerlDef:
        $r = '('.$self->SUPER::dtd_text.')';
##XDPModelGroupElement

IFClsETDef:
  @IFQName: XDPAttlistElement
  @ETQName: xdp|attlist
  @ClsQName: ManakaiDOMXDPAttlistElement

  @IFISA: XDPElement
  @ClsISA: ManakaiDOMXDPElement

  @enDesc:
    An <XE::xdp|attlist> element represents an XML <XML::ATTLIST>
    declaration.

  @CAttr:
    @@Name: dtdText
    @@Type: DOMString
    @@Get:
      @@@PerlDef:
        $r = '<!ATTLIST'.$self->SUPER::dtd_text.'>';
##XDPAttlistElement

IFClsETDef:
  @IFQName: XDPEnumGroupElement
  @ETQName: xdp|enum-group
  @ClsQName: ManakaiDOMXDPEnumGroupElement

  @IFISA: XDPElement
  @ClsISA: ManakaiDOMXDPElement

  @enDesc:
    An <XE::xdp|enum-group> element represents an XML enumeration
    group in an attribute definition.

  @CAttr:
    @@Name: dtdText
    @@Type: DOMString
    @@Get:
      @@@PerlDef:
        $r = '('.$self->SUPER::dtd_text.')';
##XDPEnumGroupElement

IFClsETDef:
  @IFQName: XDPEntityElement
  @ETQName: xdp|entity
  @ClsQName: ManakaiDOMXDPEntityElement

  @IFISA: XDPElement
  @ClsISA: ManakaiDOMXDPElement

  @enDesc:
    An <XE::xdp|entity> element represents an XML <XML::ENTITY>
    declaration.

  @CAttr:
    @@Name: dtdText
    @@Type: DOMString
    @@Get:
      @@@PerlDef:
        $r = '<!ENTITY'.$self->SUPER::dtd_text.'>';
##XDPEntityElement

IFClsETDef:
  @IFQName: XDPNotationElement
  @ETQName: xdp|notation
  @ClsQName: ManakaiDOMXDPNotationElement

  @IFISA: XDPElement
  @ClsISA: ManakaiDOMXDPElement

  @enDesc:
    An <XE::xdp|notation> element represents an XML <XML::NOTATION>
    declaration.

  @CAttr:
    @@Name: dtdText
    @@Type: DOMString
    @@Get:
      @@@PerlDef:
        $r = '<!NOTATION'.$self->SUPER::dtd_text.'>';
##XDPNotationElement

IFClsETDef:
  @IFQName: XDPMarkedSectionElement
  @ETQName: xdp|marked-section
  @ClsQName: ManakaiDOMXDPMarkedSectionElement

  @IFISA: XDPElement
  @ClsISA: ManakaiDOMXDPElement

  @enDesc:
    An <XE::xdp|marked-section> element represents an XML conditional
    section.

  @CAttr:
    @@Name: dtdText
    @@Type: DOMString
    @@Get:
      @@@PerlDef:
        $r = '<!['.$self->SUPER::dtd_text.']]>';
##XDPMarkedSectionElement

IFClsETDef:
  @IFQName: XDPMarkedSectionStatusElement
  @ETQName: xdp|marked-section-status
  @ClsQName: ManakaiDOMXDPMarkedSectionStatusElement

  @IFISA: XDPElement
  @ClsISA: ManakaiDOMXDPElement

  @enDesc:
    An <XE::xdp|marked-section-status> element represents the
    status part of an XML marked section.

  @CAttr:
    @@Name: dtdText
    @@Type: DOMString
    @@Get:
      @@@PerlDef:
        $r = $self->SUPER::dtd_text.'[';
##XDPMarkedSectionStatusElement

IFClsETDef:
  @IFQName: XDPCommentElement
  @ETQName: xdp|comment
  @ClsQName: ManakaiDOMXDPCommentElement

  @IFISA: XDPElement
  @ClsISA: ManakaiDOMXDPElement

  @enDesc:
    An <XE::xdp|comment> element represents an XML comment.

  @CAttr:
    @@Name: dtdText
    @@Type: DOMString
    @@Get:
      @@@PerlDef:
        $r = $self->SUPER::dtd_text;
        $r =~ s/--/- - /g;
        $r = '<!--'.$r.'-->';
##XDPCommentElement

IFClsETDef:
  @IFQName: XDPPIElement
  @ETQName: xdp|pi
  @ClsQName: ManakaiDOMXDPPIElement

  @IFISA: XDPElement
  @ClsISA: ManakaiDOMXDPElement

  @enDesc:
    An <XE::xdp|pi> element represents an XML processing
    instruction.

  @CAttr:
    @@Name: dtdText
    @@Type: DOMString
    @@Get:
      @@@PerlDef:
        $r = $self->SUPER::dtd_text;
        $r =~ s/\?>/?&gt;/g;
        $r = '<?'.$r.'?>';
##XDPPIElement

IFClsETDef:
  @IFQName: XDPTextDeclElement
  @ETQName: xdp|text-decl
  @ClsQName: ManakaiDOMXDPTextDeclElement

  @IFISA: XDPElement
  @ClsISA: ManakaiDOMXDPElement

  @enDesc:
    An <XE::xdp|text-decl> element represents an XML text declaration.

  @CAttr:
    @@Name: dtdText
    @@Type: DOMString
    @@Get:
      @@@PerlDef:
        $r = $self->SUPER::dtd_text;
        $r =~ s/\?>/?&gt;/g;
        $r = '<?xml'.$r.'?>';
##XDPTextDeclElement

IFClsETDef:
  @IFQName: XDPPAttrElement
  @ETQName: xdp|pattr
  @ClsQName: ManakaiDOMXDPPAttrElement

  @IFISA: XDPElement
  @ClsISA: ManakaiDOMXDPElement

  @enDesc:
    An <XE::xdp|pattr> element represents a pseudo-attribute.
##XDPPAttrElement

IFClsETDef:
  @IFQName: XDPPERefElement
  @ETQName: xdp|peref
  @ClsQName: ManakaiDOMXDPPERefElement

  @IFISA: XDPElement
  @ClsISA: ManakaiDOMXDPElement

  @enDesc:
    An <XE::xdp|peref> element represents an XML parameter entity
    reference.

  @CAttr:
    @@Name: dtdText
    @@Type: DOMString
    @@Get:
      @@@PerlDef:
        $r = '%'.$self->SUPER::dtd_text.';';
##XDPPERefElement

IFClsETDef:
  @IFQName: XDPGERefElement
  @ETQName: xdp|geref
  @ClsQName: ManakaiDOMXDPGERefElement

  @IFISA: XDPElement
  @ClsISA: ManakaiDOMXDPElement

  @enDesc:
    An <XE::xdp|geref> element represents an XML general entity
    reference.

  @CAttr:
    @@Name: dtdText
    @@Type: DOMString
    @@Get:
      @@@PerlDef:
        $r = '&'.$self->SUPER::dtd_text.';';
##XDPGERefElement

IFClsETDef:
  @IFQName: XDPNCRElement
  @ETQName: xdp|ncr
  @ClsQName: ManakaiDOMXDPNCRElement

  @IFISA: XDPElement
  @ClsISA: ManakaiDOMXDPElement

  @enDesc:
    An <XE::xdp|ncr> element represents an XML numeric character
    reference.

  @CAttr:
    @@Name: dtdText
    @@Type: DOMString
    @@Get:
      @@@PerlDef:
        $r = '&#'.$self->SUPER::dtd_text.';';
##XDPNCRElement

IFClsETDef:
  @IFQName: XDPHCRElement
  @ETQName: xdp|hcr
  @ClsQName: ManakaiDOMXDPHCRElement

  @IFISA: XDPElement
  @ClsISA: ManakaiDOMXDPElement

  @enDesc:
    An <XE::xdp|hcr> element represents an XML hexadecimal character
    reference.

  @CAttr:
    @@Name: dtdText
    @@Type: DOMString
    @@Get:
      @@@PerlDef:
        $r = '&#x'.$self->SUPER::dtd_text.';';
##XDPHCRElement

IFClsETDef:
  @IFQName: XDPRNIKeywordElement
  @ETQName: xdp|rni-keyword
  @ClsQName: ManakaiDOMXDPRNIKeywordElement

  @IFISA: XDPElement
  @ClsISA: ManakaiDOMXDPElement

  @enDesc:
    An <XE::xdp|rni-keyword> element represents an XML keyword
    prepended by a <CHAR::NUMBER SIGN>.

  @CAttr:
    @@Name: dtdText
    @@Type: DOMString
    @@Get:
      @@@PerlDef:
        $r = '#'.$self->SUPER::dtd_text;
##XDPRNIKeywordElement

IFClsETDef:
  @IFQName: XDPEntityValueElement
  @ETQName: xdp|entity-value
  @ClsQName: ManakaiDOMXDPEntityValueElement

  @IFISA: XDPElement
  @ClsISA: ManakaiDOMXDPElement

  @enDesc:
    An <XE::xdp|entity-value> element represents an XML entity
    value.

  @CAttr:
    @@Name: dtdText
    @@Type: DOMString
    @@Get:
      @@@PerlDef:
        require Message::DOM::Traversal;
        my $doctrv = $self-><AG::Node.ownerDocument>
                          -><M::Node.getFeature> (Traversal => '2.0');
        my $tw = $doctrv->create_tree_walker
                            ($self, <C::NodeFilter.SHOW_ELEMENT> |
                                    <C::NodeFilter.SHOW_TEXT> |
                                    <C::NodeFilter.SHOW_CDATA_SECTION>,
                             sub {
                               my $node = $_[1];
                               if ($node-><AG::Node.nodeType>
                                       == <C::Node.ELEMENT_NODE>) {
                                 my $ns = $node-><AG::Node.namespaceURI>;
                                 if (not defined $ns) {
                                   return <C::NodeFilter.FILTER_REJECT>;
                                 } elsif ($ns eq <Q::xdp|>) {
                                   return <C::NodeFilter.FILTER_ACCEPT>;
                                 } else {
                                   return <C::NodeFilter.FILTER_REJECT>;
                                 }
                               } else {
                                 return <C::NodeFilter.FILTER_ACCEPT>;
                               }
                             }, true);
        my $current = $tw->first_child;
        $r = '';
        C: while (defined $current) {
          if ($current-><AG::Node.nodeType> == <C::Node.ELEMENT_NODE>) {
            if ({
                  <Q::xdp|attr-definition> => true,
                  <Q::xdp|peref> => true,
                }->{$current->manakai_expanded_uri}) {
              $r .= $current-><AG::XDPElement.dtdText>;
            } else {
              my $v = $current-><AG::XDPElement.dtdText>;
              $v =~ s/&/&#x26;/g;
              $v =~ s/%/&#x25;/g;
              $r .= $v;
            }
          } else {
            my $v = $current-><AG::Node.textContent>;
            $v =~ s/&/&#x26;/g;
            $v =~ s/%/&#x25;/g;
            $r .= $v;
          }
          
          $current = $tw->next_sibling;
        } # C

        if ($r =~ /"/) {
          $r =~ s/'/&#x27;/g;
          $r = "'".$r."'";
        } else {
          $r =~ s/"/&#x22;/g;
          $r = '"'.$r.'"';
        }
##XDPEntityValueElement

IFClsETDef:
  @IFQName: XDPAttrLiteralElement
  @ETQName: xdp|attr-literal
  @ClsQName: ManakaiDOMXDPAttrLiteralElement

  @IFISA: XDPElement
  @ClsISA: ManakaiDOMXDPElement

  @enDesc:
    An <XE::xdp|attr-literal> element represents an XML attribute
    value literal.

  @CAttr:
    @@Name: dtdText
    @@Type: DOMString
    @@Get:
      @@@PerlDef:
        require Message::DOM::Traversal;
        my $doctrv = $self-><AG::Node.ownerDocument>
                          -><M::Node.getFeature> (Traversal => '2.0');
        my $tw = $doctrv->create_tree_walker
                            ($self, <C::NodeFilter.SHOW_ELEMENT> |
                                    <C::NodeFilter.SHOW_TEXT> |
                                    <C::NodeFilter.SHOW_CDATA_SECTION>,
                             sub {
                               my $node = $_[1];
                               if ($node-><AG::Node.nodeType>
                                       == <C::Node.ELEMENT_NODE>) {
                                 my $ns = $node-><AG::Node.namespaceURI>;
                                 if (not defined $ns) {
                                   return <C::NodeFilter.FILTER_REJECT>;
                                 } elsif ($ns eq <Q::xdp|>) {
                                   return <C::NodeFilter.FILTER_ACCEPT>;
                                 } else {
                                   return <C::NodeFilter.FILTER_REJECT>;
                                 }
                               } else {
                                 return <C::NodeFilter.FILTER_ACCEPT>;
                               }
                             }, true);
        my $current = $tw->first_child;
        $r = '';
        C: while (defined $current) {
          if ($current-><AG::Node.nodeType> == <C::Node.ELEMENT_NODE>) {
            if ({
                  <Q::xdp|geref> => true,
                  <Q::xdp|ncr> => true,
                  <Q::xdp|hcr> => true,
                }->{$current->manakai_expanded_uri}) {
              $r .= $current-><AG::XDPElement.dtdText>;
            } else {
              my $v = $current-><AG::XDPElement.dtdText>;
              $v =~ s/&/&amp;/g;
              $r .= $v;
            }
          } else {
            my $v = $current-><AG::Node.textContent>;
            $v =~ s/&/&amp;/g;
            $r .= $v;
          }
          
          $current = $tw->next_sibling;
        } # C

        if ($r =~ /"/) {
          $r =~ s/'/&apos;/g;
          $r = "'".$r."'";
        } else {
          $r =~ s/"/&quot;/g;
          $r = '"'.$r.'"';
        }
##XDPPAttrLiteralElement

IFClsETDef:
  @IFQName: XDPMinimumLiteralElement
  @ETQName: xdp|minimum-literal
  @ClsQName: ManakaiDOMXDPMinimumLiteralElement

  @IFISA: XDPElement
  @ClsISA: ManakaiDOMXDPElement

  @enDesc:
    An <XE::xdp|minimum-literal> element represents an XML public identifier
    literal.

  @CAttr:
    @@Name: dtdText
    @@Type: DOMString
    @@Get:
      @@@PerlDef:
        $r = $self->SUPER::dtd_text;
        $r =~ s/"/%22/g;
        $r = '"'.$r.'"';
##XDPMinimumLiteralElement

IFClsETDef:
  @IFQName: XDPSystemLiteralElement
  @ETQName: xdp|system-literal
  @ClsQName: ManakaiDOMXDPSystemLiteralElement

  @IFISA: XDPElement
  @ClsISA: ManakaiDOMXDPElement

  @enDesc:
    An <XE::xdp|system-literal> element represents an XML system
    literal.

  @CAttr:
    @@Name: dtdText
    @@Type: DOMString
    @@Get:
      @@@PerlDef:
        $r = $self->SUPER::dtd_text;
        $r =~ s/"/%22/g;
        $r = '"'.$r.'"';
##XDPSystemLiteralElement

IFClsETDef:
  @IFQName: XDPIfElement
  @ETQName: xdp|if
  @ClsQName: ManakaiDOMXDPIfElement

  @IFISA: XDPElement
  @ClsISA: ManakaiDOMXDPElement

  @enDesc:
    An <XE::xdp|if> element represents a set of XML DTD declarations
    with a conditional section that can be enabled by a
    parameter entity.

  @CAttr:
    @@Name: dtdText
    @@Type: DOMString
    @@Get:
      @@@PerlDef:
        __DEEP{
          require Message::DOM::Traversal;
          my $doctrv = $self-><AG::Node.ownerDocument>
                            -><M::Node.getFeature> (Traversal => '2.0');
          my $tw = $doctrv->create_tree_walker
                              ($self, <C::NodeFilter.SHOW_ELEMENT> |
                                      <C::NodeFilter.SHOW_TEXT> |
                                      <C::NodeFilter.SHOW_CDATA_SECTION>,
                               sub {
                                 my $node = $_[1];
                                 if ($node-><AG::Node.nodeType>
                                         == <C::Node.ELEMENT_NODE>) {
                                   my $ns = $node-><AG::Node.namespaceURI>;
                                   if (not defined $ns) {
                                     return <C::NodeFilter.FILTER_REJECT>;
                                   } elsif ($ns eq <Q::xdp|>) {
                                     return <C::NodeFilter.FILTER_ACCEPT>;
                                   } else {
                                     return <C::NodeFilter.FILTER_REJECT>;
                                   }
                                 } else {
                                   return <C::NodeFilter.FILTER_ACCEPT>;
                                 }
                               }, true);
          my $current = $tw->first_child;

          my $pename = $self-><M::Element.getAttributeNS>
                                (null, 'status-entity');
          $r = '<![%'.$pename.";[\n";
     
          my $has_true;
          C: while (defined $current) {
            if ($current-><AG::Node.nodeType> == <C::Node.ELEMENT_NODE>) {
              if (not $has_true and
                  $current->manakai_expanded_uri eq <Q::xdp|true>) {
                $r .= $current-><AG::XDPElement.dtdText>;
                $r .= "<!-- end of $pename -->]]>";
                $has_true = true;
              } elsif ($current->manakai_expanded_uri eq <Q::xdp|false>) {
                my $v = $current-><AG::XDPElement.dtdText>;
                $r .= "\n" if length $v;
                $r .= $v;
              } else {
                $r .= $current-><AG::XDPElement.dtdText>;
              }
            } else {
              $r .= $current-><AG::XDPElement.dtdText>;
            }
          
            $current = $tw->next_sibling;
          } # C

          $r .= "<!-- end of $pename -->]]>" unless $has_true;
        }__;
##XDPIfElement
