Module:
  @QName: MDOM|CharacterData
  @enFN:
    DOM Character Data Module
  @enDesc:
    The manakai DOM Character Data Module implements a part of the W3C DOM
    Core module on character data leaf nodes in HTML or XML documents.

  @Namespace:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/DOM/CharacterData/

  @DISCore:author: DISCore|Wakaba
  @License: license|Perl+MPL
  @Date:
    $Date: 2006/12/29 14:45:40 $

  @Require:
    @@Module:
      @@@QName: Util|Grove
      @@@WithFor: ManakaiDOM|all
    @@Module:
      @@@QName: MDOM|TreeCore
      @@@WithFor: ManakaiDOM|ManakaiDOMLatest
    @@Module:
      @@@WithFor: ManakaiDOM|ManakaiDOM
    @@Module:
      @@@WithFor: ManakaiDOM|ManakaiDOM1
    @@Module:
      @@@WithFor: ManakaiDOM|ManakaiDOM2
    @@Module:
      @@@WithFor: ManakaiDOM|ManakaiDOM3
    @@Module:
      @@@WithFor: ManakaiDOM|ManakaiDOMLatest
    @@Module:
      @@@QName: MDOM|Traversal
      @@@WithFor: ManakaiDOM|ManakaiDOMLatest
  @DefaultFor: ManakaiDOM|ManakaiDOMLatest

Namespace:
  @c:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#
  @cfg:
    http://suika.fam.cx/www/2006/dom-config/
  @dis:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#dis--
  @doc:
    http://suika.fam.cx/~wakaba/archive/2005/7/tutorial#
  @d:
    http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#
  @DOMMain:
    http://suika.fam.cx/~wakaba/archive/2004/dom/main#
  @domperl:
    http://suika.fam.cx/~wakaba/archive/2006/dom/perl/
  @dx:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#
  @dxm:
    http://suika.fam.cx/~wakaba/archive/2004/dis/XML#
  @ecore:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/Core/
  @ev:
    http://www.w3.org/2001/xml-events
  @f:
    http://suika.fam.cx/~wakaba/archive/2004/dom/feature#
  @fe:
    http://suika.fam.cx/www/2006/feature/
  @idl:
    http://suika.fam.cx/~wakaba/archive/2004/dis/IDL#
  @infoset:
    http://www.w3.org/2001/04/infoset#
  @kwd:
    http://suika.fam.cx/~wakaba/archive/2005/rfc2119/
  @lang:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#
  @license:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/license#
  @ManakaiDOM:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#
  @ManakaiDOMCore:
    http://suika.fam.cx/~wakaba/archive/2004/mdom-core#
  @MDOM:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#ManakaiDOM.
  @MDOMX:
    http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#
  @null:
    http://suika.fam.cx/~wakaba/-temp/2003/09/27/null
  @dlp:
    http://suika.fam.cx/~wakaba/archive/2004/dis/Perl#
  @rdf:
    http://www.w3.org/1999/02/22-rdf-syntax-ns#
  @rdfs:
    http://www.w3.org/2000/01/rdf-schema#
  @sw010:
    urn:x-suika-fam-cx:markup:suikawiki:0:10:
  @t:
    http://suika.fam.cx/~wakaba/archive/2004/dom/tree#
  @tc:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/DOM/TreeCore/
  @tcd:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/DOM/CharacterData/
  @td:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/DOM/Document/
  @te:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/DOM/Element/
  @test:
    http://suika.fam.cx/~wakaba/archive/2004/dis/Test#
  @trv:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/DOM/Traversal/
  @tx:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/DOM/XML/
  @urigen:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/URI/Generic/
  @Util:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/
  @xml:
    http://www.w3.org/XML/1998/namespace
  @xml-dtd:
    http://www.w3.org/TR/REC-xml
  @xmlns:
    http://www.w3.org/2000/xmlns/

ElementTypeBinding:
  @Name: CODE
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISPerl|BlockCode
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: Method
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|Method
    @@ForCheck: !=ManakaiDOM|ManakaiDOM

ElementTypeBinding:
  @Name: CMethod
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|Method
    @@ForCheck: !=ManakaiDOM|ManakaiDOM ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: L2Method
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|Method
    @@ForCheck: !=ManakaiDOM|ManakaiDOM ManakaiDOM|DOM2

ElementTypeBinding:
  @Name: CL2Method
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|Method
    @@ForCheck: !=ManakaiDOM|ManakaiDOM ManakaiDOM|DOM2 ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: L3Method
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|Method
    @@ForCheck: !=ManakaiDOM|ManakaiDOM ManakaiDOM|DOM3

ElementTypeBinding:
  @Name: CL3Method
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|Method
    @@ForCheck: !=ManakaiDOM|ManakaiDOM ManakaiDOM|DOM3 ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: LXMethod
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|Method
    @@ForCheck: !=ManakaiDOM|ManakaiDOM ManakaiDOM|ManakaiDOMLatest

ElementTypeBinding:
  @Name: IntMethod
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|Method
    @@ForCheck:
      ManakaiDOM|ManakaiDOM !=ManakaiDOM|ManakaiDOM ManakaiDOM|ForClass
    @@ManakaiDOM:isForInternal: 1

ElementTypeBinding:
  @Name: Param
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|MethodParameter

ElementTypeBinding:
  @Name: Return
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|MethodReturn

ElementTypeBinding:
  @Name: Attr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|Attribute
    @@ForCheck: !=ManakaiDOM|ManakaiDOM

ElementTypeBinding:
  @Name: CAttr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|Attribute
    @@ForCheck: !=ManakaiDOM|ManakaiDOM ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: IntAttr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|Attribute
    @@ForCheck: ManakaiDOM|ForClass
    @@ManakaiDOM:isForInternal: 1

ElementTypeBinding:
  @Name: L2Attr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|Attribute
    @@ForCheck: !=ManakaiDOM|ManakaiDOM ManakaiDOM|DOM2

ElementTypeBinding:
  @Name: L3Attr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|Attribute
    @@ForCheck: !=ManakaiDOM|ManakaiDOM ManakaiDOM|DOM3

ElementTypeBinding:
  @Name: CL3Attr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|Attribute
    @@ForCheck: !=ManakaiDOM|ManakaiDOM ManakaiDOM|DOM3 ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: LXAttr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|Attribute
    @@ForCheck: !=ManakaiDOM|ManakaiDOM ManakaiDOM|ManakaiDOMLatest

ElementTypeBinding:
  @Name: Get
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|AttributeGet
ElementTypeBinding:
  @Name: Set
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|AttributeSet

ElementTypeBinding:
  @Name: LXSet
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|AttributeSet
    @@ForCheck: ManakaiDOM|ManakaiDOMLatest

ElementTypeBinding:
  @Name: InCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: ManakaiDOM|InCase

ElementTypeBinding:
  @Name: nullCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: ManakaiDOM|InCase
    @@Value:
      @@@is-null:1

ElementTypeBinding:
  @Name: PerlDef
  @ElementType:
    dis:Def
  @ShadowContent:
    @@ContentType: lang|Perl
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: enImplNote
  @ElementType:
    dis:ImplNote
  @ShadowContent:
    @@lang:en

ElementTypeBinding:
  @Name: enFN
  @ElementType:
    dis:FullName
  @ShadowContent:
    @@lang:en

ElementTypeBinding:
  @Name: IFCls1Def
  @ElementType: 
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType:
      @@@@: dis|MultipleResource
      @@@ForCheck: !ManakaiDOM|ForIF !ManakaiDOM|ForClass
    @@resourceFor: ManakaiDOM|ForIF
    @@resourceFor:
      @@@@: ManakaiDOM|ForClass
      @@@ForCheck: ManakaiDOM|ManakaiDOMLatest
    @@For: ManakaiDOM|DOM1
    @@For: =ManakaiDOM|ManakaiDOM

    @@DISCore:resourceType:
      @@@@: DISLang|Interface
      @@@ForCheck: ManakaiDOM|ForIF

    @@DISCore:resourceType:
      @@@@: DISLang|Class
      @@@ForCheck: ManakaiDOM|ForClass
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOM||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOM1||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM1
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOM2||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM2
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOM3||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM3
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOMLatest||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOMLatest

    @@f:implements:
      @@@@: c|CoreFeature10
      @@@For: ManakaiDOM|DOM1
    @@f:implements:
      @@@@: c|CoreFeature20
      @@@For: ManakaiDOM|DOM2
    @@f:implements:
      @@@@: c|CoreFeature30
      @@@For: ManakaiDOM|DOM3
    @@f:implements:
      @@@@: tx|XMLFeature10
      @@@For: ManakaiDOM|DOM1
    @@f:implements:
      @@@@: tx|XMLFeature20
      @@@For: ManakaiDOM|DOM2
    @@f:implements:
      @@@@: tx|XMLFeature30
      @@@For: ManakaiDOM|DOM3
    @@f:implements:
      @@@@: tx|XMLVersionFeature10
      @@@For: ManakaiDOM|DOM3
    @@f:implements:
      @@@@: tx|XMLVersionFeature11
      @@@For: ManakaiDOM|DOM3

ElementTypeBinding:
  @Name: IF2Def
  @ElementType: 
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType:
      @@@@: dis|MultipleResource
      @@@ForCheck: !ManakaiDOM|ForIF !ManakaiDOM|ForClass
    @@resourceFor: ManakaiDOM|ForIF
    @@For: ManakaiDOM|DOM1
    @@For: =ManakaiDOM|ManakaiDOM

    @@DISCore:resourceType:
      @@@@: DISLang|Interface
      @@@ForCheck: ManakaiDOM|ForIF

ElementTypeBinding:
  @Name: IFQName
  @ElementType:
    dis:QName
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForIF

ElementTypeBinding:
  @Name: ClsQName
  @ElementType:
    dis:QName
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: IFISA
  @ElementType:
    dis:ISA
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForIF

ElementTypeBinding:
  @Name: ClsISA
  @ElementType:
    dis:ISA
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: disDef
  @ElementType:
    dis:Def
  @ShadowContent:
    @@ContentType:
      lang:dis
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: Code
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISPerl|InlineCode
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: IntPropDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISCore|Property
    @@For: =ManakaiDOM|all

ElementTypeBinding:
  @Name: RPropDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISSource|ResourceProperty
    @@For: =ManakaiDOM|all

ElementTypeBinding:
  @Name: Test
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: test|StandaloneTest
    @@ForCheck: ManakaiDOM|ForClass

ResourceDef:
  @QName: Document
  @AliasFor: td|Document
  @For: ManakaiDOM|DOM

ResourceDef:
  @QName: DocumentFragment
  @AliasFor: td|DocumentFragment
  @For: ManakaiDOM|DOM

ResourceDef:
  @QName: Element
  @AliasFor: te|Element
  @For: ManakaiDOM|DOM

ResourceDef:
  @QName: Attr
  @AliasFor: te|Attr
  @For: ManakaiDOM|DOM

ResourceDef:
  @QName: DOMString
  @AliasFor: DOMMain|DOMString
  @For: ManakaiDOM|DOM

ResourceDef:
  @QName: DOMImpl
  @AliasFor: c|DOMImplementation
  @For: ManakaiDOM|DOM

ResourceDef:
  @QName: boolean
  @AliasFor: idl|boolean||ManakaiDOM|all

ResourceDef:
  @QName: unsignedLong
  @AliasFor: idl|unsignedLong||ManakaiDOM|all

ResourceDef:
  @QName: unsignedShort
  @AliasFor: idl|unsignedShort||ManakaiDOM|all

ResourceDef:
  @QName: ARRAY
  @AliasFor: DISPerl|ARRAY||ManakaiDOM|all

ResourceDef:
  @QName: HASH
  @AliasFor: DISPerl|HASH||ManakaiDOM|all

ResourceDef:
  @QName: DocumentX
  @AliasFor: d|DocumentXDoctype
  @For: ManakaiDOM|ManakaiDOMLatest

ResourceDef:
  @QName: DTDef
  @AliasFor: d|DocumentTypeDefinition
  @For: ManakaiDOM|ManakaiDOMLatest

ResourceDef:
  @QName: ETDef
  @AliasFor: d|ElementTypeDefinition
  @For: ManakaiDOM|ManakaiDOMLatest

ResourceDef:
  @QName: ATDef
  @AliasFor: d|AttributeDefinition
  @For: ManakaiDOM|ManakaiDOMLatest

ResourceDef:
  @QName: Node
  @AliasFor: tc|Node
  @For: ManakaiDOM|ManakaiDOM


ElementTypeBinding:
  @Name: enDesc
  @ElementType:
    dis:Description
  @ShadowContent:
    @@lang:en

ElementTypeBinding:
  @Name: NodeReadOnlyError
  @ElementType:
    dx:raises
  @ShadowContent:
    @@@: MDOMX|NOMOD_THIS
    @@Description:
      @@@lang:en
      @@@@:
        The node is read-only.

ElementTypeBinding:
  @Name: TrueCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType:
      ManakaiDOM:InCase
    @@Value:
      @@@@: 1
      @@@ContentType: DISCore|Boolean
    @@Type: idl|boolean||ManakaiDOM|all

ElementTypeBinding:
  @Name: FalseCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType:
      ManakaiDOM:InCase
    @@Value:
      @@@@: 0
      @@@ContentType: DISCore|Boolean
    @@Type: idl|boolean||ManakaiDOM|all

ElementTypeBinding:
  @Name: iRaises
  @ElementType:
    dx:raises
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForIF

## -- Document

ClsDef:
  @ClsQName: ManakaiDOMDocumentCharacterData

  @domperl:classImplementedByObjectsOf: td|ManakaiDOMDocument
  @Test:
    @@QName: DocumentCharacterData.class.1.test
    @@PerlDef:
      $test->assert_true
          (<Class::td|ManakaiDOMDocument>->isa
              (<ClassName::ManakaiDOMDocumentCharacterData>));

  @CMethod:
    @@Name: createTextNode
    @@enDesc:
      Creates a <IF::Text> node given the specified string.
    @@Param:
      @@@Name: data
      @@@Type: DOMString
      @@@enDesc:
        The data for the node.
    @@Return:
      @@@Type: Text
      @@@enDesc:
        The newly created <IF::Text> node.
      @@@PerlDef:
        $r = bless \{
          <H::tc|ownerDocument> => $self,
          <H::infoset|content> => \$data,
        }, <ClassName::tcd|ManakaiDOMText>;
        Scalar::Util::weaken ($$r->{<H::tc|ownerDocument>});

    @@Test:
      @@@QName: Document.createTextNode.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $text = $doc-><M::Document.createTextNode> ('text data');
       
        $test->id ('interface');
        $test->assert_isa ($text, <IFName::Text>);

        $test->id ('nodeValue');
        $test->assert_equals ($text-><AG::Node.nodeValue>, 'text data');
 
        $test->id ('isElementContentWhitespace');
        $test->assert_false ($text-><AG::Text.isElementContentWhitespace>);
    @@Test:
      @@@QName: Document.createTextNode.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $text = $doc-><M::Document.createTextNode> ('');
       
        $test->id ('interface');
        $test->assert_isa ($text, <IFName::Text>);

        $test->id ('nodeValue');
        $test->assert_equals ($text-><AG::Node.nodeValue>, '');
 
        $test->id ('isElementContentWhitespace');
        $test->assert_false ($text-><AG::Text.isElementContentWhitespace>);

  @CMethod:
    @@Name: createComment
    @@enDesc:
      Creates a <IF::tcd|Comment> node.
    @@Param:
      @@@Name: data
      @@@Type: DOMString
      @@@enDesc:
        The data for the node.
    @@Return:
      @@@Type: Comment
      @@@enDesc:
        The newly created <IF::tcd|Comment> node.
      @@@PerlDef:
        $r = bless \{
          <H::tc|ownerDocument> => $self,
          <H::infoset|content> => \$data,
        }, <ClassName::tcd|ManakaiDOMComment>;
        Scalar::Util::weaken ($$r->{<H::tc|ownerDocument>});
##DocumentCharacterData

ElementTypeBinding:
  @Name: ClsDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType:
      @@@@: dis|MultipleResource
      @@@ForCheck: !ManakaiDOM|ForIF !ManakaiDOM|ForClass
    @@resourceFor: ManakaiDOM|ForClass
    @@For: ManakaiDOM|ManakaiDOMLatest

    @@DISCore:resourceType:
      @@@@: DISLang|Class
      @@@ForCheck: ManakaiDOM|ForClass

## -- CharacterData

IFCls1Def:
  @IFQName: CharacterData
  @ClsQName: ManakaiDOMCharacterData

  @IFISA: Node
  @ClsISA: tc|ManakaiDOMNode

  @Implement: StringExtended

  @enDesc:
    The <IF::CharacterData> interface extends the <IF::Node>
    interface with a set of attributes and methods for
    accessing character data in the DOM.  No DOM objects correspond 
    directly to the <IF::CharacterData> interface -- the
    <IF::Text> interface and the <IF::Comment> interface
    inherits this interface.

    {ps:: <doc:caption::Positions in character data>

    All <CODE::offset>s in this interface start from <CODE::0>.  Since strings in
    the DOM are represented in UTF-16, indexing
    on <IF::CharacterData> is done in 16-bit units, i.e. characters
    allocated in the range <CODE::U+10000> to <CODE::U+10FFFF>
    (inclusive) are counted as two units.
    }

    {NOTE:: DOM implementations may not put arbitary limits on 
            the amount of the data that may be stored in a 
            <IF::CharacterData> node.  This might make a node's
            data cannot fit into a single <TYPE::DOMString>.
            See also <X::DOMSTRING_SIZE_ERR>.
    }

  @enImplNote:
    @@ddid: customdata
    @@@:
      {P:: If a subclass of the interface don't use the <Q::infoset|content>
      internal property for the <A::CharacterData.data>, it <kwd:MUST>
      implement its own method and attribute implementations for:

        - <A::Node.nodeValue>

        - <A::Node.textContent>

        - <M::Node.manakaiAppendText>

        - <M::StringExtended.findOffset16>

        - <M::StringExtended.findOffset32>
 
        - <A::CharacterData.data>

        - <A::CharacterData.length>

      }

      It <kwd:MAY>, but need not, override other attributes and methods.

  @CAttr:
    @@Name: childNodes
    @@enDesc:
      A list of nodes that contains all children of the node.
    @@Get:
      @@@Type: c|NodeList
      @@@enDesc:
        Since <IF::CharacterData> nodes cannot have child nodes,
        the node list is always empty.
      @@@PerlDef:
        __CODE{tc|createEmptyNodeList::
          $r => $r,
        }__;

  @CMethod:
    @@Name: appendChild
    @@enDesc:
      Adds a node to the end of the list of children of the node.
      If that node is already in the tree, it is first removed.
    @@Param:
      @@@Name: newChild
      @@@Type: Node
      @@@enDesc:
        The node to add.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node added.
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_BAD_TYPE
        @@@@enDesc:
          The type of the node does not allow any children.
      @@@PerlDef:
        __EXCEPTION{MDOMX|HIERARCHY_BAD_TYPE::
          MDOMX|param-name => 'newChild',
          c|node => {$newChild},
        }__;

  @CMethod:
    @@Name: insertBefore
    @@enDesc:
      Inserts a node before the existing child node of the node.
    @@Param:
      @@@Name: newChild
      @@@Type: Node
      @@@enDesc:
        The node to add.
    @@Param:
      @@@Name: refChild
      @@@Type: Node
      @@@enDesc:
        The node before which the <P::newChild> node is inserted.
      @@@nullCase:
        @@@@enDesc:
          The <P::newChild> node is inserted at the end.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node added.
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_BAD_TYPE
        @@@@enDesc:
          The type of the node does not allow any children.
      @@@PerlDef:
        __EXCEPTION{MDOMX|HIERARCHY_BAD_TYPE::
          MDOMX|param-name => 'newChild',
          c|node => {$newChild},
        }__;

  @CMethod:
    @@Name: replaceChild
    @@enDesc:
      Replaces a node by another node.
    @@Param:
      @@@Name: newChild
      @@@Type: Node
      @@@enDesc:
        The node to add.
    @@Param:
      @@@Name: oldChild
      @@@Type: Node
      @@@enDesc:
        The node to remove.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node replaced.
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_BAD_TYPE
        @@@@enDesc:
          The type of the node does not allow any children.
      @@@PerlDef:
        __EXCEPTION{MDOMX|HIERARCHY_BAD_TYPE::
          MDOMX|param-name => 'newChild',
          c|node => {$newChild},
        }__;

  @CMethod:
    @@Name: manakaiAppendText
    @@Param:
      @@@Name: string
      @@@Type: DOMString
      @@@enDesc:
        The string to append.
      @@@InCase:
        @@@@Type: DISPerl|SCALAR||ManakaiDOM|all
        @@@@enDesc:
          A copy of the string value referenced from the value
          is appended.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node itself.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the node to insert the string or a <IF::Text> node
          is read-only.
      @@@PerlDef:
        __DEEP{
          if ($self-><AG::Node.ownerDocument>
                   -><AG::Document.strictErrorChecking> and
              $self-><AG::Node.manakaiReadOnly>) {
            __UNDEEP{__EXCEPTION{MDOMX|NOMOD_THIS::
            }__}__;
          }
          my $v = $$self->{<H::infoset|content>};
          $$v .= ref $string eq 'SCALAR' ? $$string : $string;
          $r = $self;
        }__;

  @CAttr:
    @@Name: nodeValue
    @@enDesc:
      The value of the node.
    @@Type: DOMString
    @@Get:
      @@@disDef:
        @@@@DISPerl:cloneCode: .data.get
    @@Set:
      @@@NodeReadOnlyError:
      @@@disDef:
        @@@@DISPerl:cloneCode: .data.set

  @CL3Attr:
    @@Name: textContent
    @@enDesc:
      The text content of the node.
    @@Type: DOMString
    @@Get:
      @@@disDef:
        @@@@DISPerl:cloneCode: .data.get
    @@Set:
      @@@nullCase:
        @@@@enImplNote:
          The DOM Level 3 Core specification is unclear on 
          setting <DOM::null> to the <A::Node.textContent>
          attribute to the node whose type is so defined
          that it has same effect as <A::Node.nodeValue>.
      @@@NodeReadOnlyError:
      @@@disDef:
        @@@@DISPerl:cloneCode: .data.set

  @CL3Attr:
    @@Name: baseURI
    @@enDesc:
      The base URI of the node.
    @@Type: DOMString
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          If it is not available.
      @@@PerlDef:
        __DEEP{
          my $pe = $self-><AG::Node.parentNode>;
          W: {
            while (defined $pe) {
              my $nt = $pe-><AG::Node.nodeType>;
              if ($nt == <C::Node.ELEMENT_NODE> or
                  $nt == <C::Node.ATTRIBUTE_NODE> or
                  $nt == <C::Node.DOCUMENT_NODE> or
                  $nt == <C::Node.DOCUMENT_FRAGMENT_NODE> or
                  $nt == <C::Node.ENTITY_NODE>) {
                $r = $pe-><AG::Node.baseURI>;
                last W;
              } elsif ($nt == <C::Node.ENTITY_REFERENCE_NODE>) {
                if ($pe-><AG::tx|EntityReference.manakaiExternal>) {
                  $r = $pe-><AG::tx|EntityReference.manakaiEntityBaseURI>;
                  last W;
                }
              }
              $pe = $pe-><AG::Node.parentNode>;
            }
            if ($pe) {
              $r = $pe-><AG::Node.baseURI>;
            } else {
              $r = $self-><AG::Node.ownerDocument>-><AG::Node.baseURI>;
            }
          } # W
        }__;

  @CL2Method:
    @@Name: findOffset16
    @@dlp:methodName: find_offset16
    @@Param:
      @@@Name: offset32
      @@@Type: unsignedLong
    @@Return:
      @@@Type: unsignedLong
      @@@dx:raises: c|StringIndexOutOfBoundsException
      @@@PerlDef:
        my $v = $$self->{<H::infoset|content>};

        if (not defined $offset32 or $offset32 < 0 or
            CORE::length ($$v) < $offset32) {
          __EXCEPTION{c|StringIndexOutOfBoundsException::
            MDOMX|param-name => 'offset32',
            c|index => {$offset32},
          }__;
        }

        my $ss = substr $$v, 0, $offset32;
        $r = $offset32;
        if ($ss =~ /[\x{10000}-\x{10FFFF}]/) {
          while ($ss =~ /[\x{10000}-\x{10FFFF}]+/g) {
            $r += $+[0] - $-[0];
          }
        }

    @@Test:
      @@@QName: CharacterData.findOffset16.test
      @@@PerlDef:
        my $text;
        my $doc;
        __CODE{tc|createTextForTest:: $text => $text, $doc => $doc}__;

        my @data = (
          '', # 0
          'a', # 1
          'AbEdwerErsArw', # 2
          "A\x{10000}BC", # 3
          "\x{12001}", # 4
        );

        for my $testdata (
          # data, 32, 16
          [0, 0, 0],
          [0, 1],
          [0, 2],
          [0, -1],
          [0, -2],
          [1, 0, 0],
          [1, 1, 1],
          [1, 2],
          [1, -1],
          [1, -2],
          [2, 0, 0],
          [2, 1, 1],
          [2, 13, 13],
          [2, 14],
          [3, 0, 0],
          [3, 1, 1],
          [3, 2, 3],
          [3, 3, 4],
          [3, 4, 5],
          [3, 5],
          [4, 0, 0],
          [4, 1, 2],
          [4, 2],
        ) {
          $test->id ($testdata->[0].'.'.$testdata->[1]);
          $text-><AS::CharacterData.data> ($data[$testdata->[0]]);
          if (defined $testdata->[2]) {
            my $return = $text-><M::StringExtended.findOffset16>
                                  ($testdata->[1]);
            $test->assert_num_equals
                     (expected_value => $testdata->[2],
                      actual_value => $return);
          } else {
            $test->assert_exception
                     (code => sub {
                        my $return = $text-><M::StringExtended.findOffset16>
                                              ($testdata->[1]);
                      }, exception_subtype =>
                             <Q::c|StringIndexOutOfBoundsException>);
          }
        }

  @CL2Method:
    @@Name: findOffset32
    @@dlp:methodName: find_offset32
    @@Param:
      @@@Name: offset16
      @@@Type: unsignedLong
    @@Return:
      @@@Type: unsignedLong
      @@@dx:raises: c|StringIndexOutOfBoundsException
      @@@enImplNote:
        {NOTE:: This function is implemented in a way that
                breaks the <Perl::pos> (position) of the string
                being changed.
        }
      @@@PerlDef:
        my $v = $$self->{<H::infoset|content>};

        if (not defined $offset16 or $offset16 < 0) {
          __EXCEPTION{c|StringIndexOutOfBoundsException::
            MDOMX|param-name => 'offset16',
            c|index => {$offset16},
          }__;
        }

        my $o = $offset16;
        while ($o > 0) {
          my $c = substr ($$v, $r, 1);
          if (length $c) {
            if ($c =~ /[\x{10000}-\x{10FFFF}]/) {
              $o -= 2;
            } else {
              $o--;
            }
            $r++;
          } else {
            __EXCEPTION{c|StringIndexOutOfBoundsException::
              MDOMX|param-name => 'offset16',
              c|index => {$offset16},
            }__;
          }
        }


    @@Test:
      @@@QName: CharacterData.findOffset32.test
      @@@PerlDef:
        my $text;
        my $doc;
        __CODE{tc|createTextForTest:: $text => $text, $doc => $doc}__;

        my @data = (
          '', # 0
          'a', # 1
          'AbEdwerErsArw', # 2
          "A\x{10000}BC", # 3
          "\x{12001}", # 4
        );

        for my $testdata (
          # data, 16, 32
          [0, 0, 0],
          [0, 1],
          [0, 2],
          [0, -1],
          [0, -2],
          [1, 0, 0],
          [1, 1, 1],
          [1, 2],
          [1, -1],
          [1, -2],
          [2, 0, 0],
          [2, 1, 1],
          [2, 13, 13],
          [2, 14],
          [3, 0, 0],
          [3, 1, 1],
          [3, 2, 2],
          [3, 3, 2],
          [3, 4, 3],
          [3, 5, 4],
          [3, 6],
          [4, 0, 0],
          [4, 1, 1],
          [4, 2, 1],
          [4, 3],
        ) {
          $test->id ($testdata->[0].'.'.$testdata->[1]);
          $text-><AS::CharacterData.data> ($data[$testdata->[0]]);
          if (defined $testdata->[2]) {
            my $return = $text-><M::StringExtended.findOffset32>
                                  ($testdata->[1]);
            $test->assert_num_equals
                     (expected_value => $testdata->[2],
                      actual_value => $return);
          } else {
            $test->assert_exception
                     (code => sub {
                        my $return = $text-><M::StringExtended.findOffset32>
                                              ($testdata->[1]);
                      }, exception_subtype =>
                             <Q::c|StringIndexOutOfBoundsException>);
          }
        }

  @Attr:
    @@Name: data
    @@enDesc:
      The character data of the node.

      The DOM implementation may not put arbitary limits on the
      amount of data that may be stored in a <IF::CharacterData> node.
      However, implementation limits may mean that the entirely
      of a node's data may not fit into a single <TYPE::DOMString>.
      In such cases, applications may call <M::CharacterData.substringData>
      to retrieve the data in appropriately sized pieces.

      If the node is a <IF::tx|CDATASection>, it is the
      content of the <XML::CDATA> section.  Since DOM implementation
      does no lexical check on the content of the <XML::CDATA>
      section, <A::CharacterData.data> might include the character
      sequence equals to <SGML::MSE>, i.e. <XML::]]<gt>> in XML.
    @@Type: DOMString
    @@Get:
      @@@iRaises:
        @@@@@: c|DOMSTRING_SIZE_ERR
        @@@@enDesc:
          When it would return more characters than fit in a
          <TYPE::DOMString> variable on the implementation platform.
      @@@PerlDef:
        $r = ${$$self->{<H::infoset|content>}};
    @@Set:
      @@@NodeReadOnlyError:
      @@@PerlDef:
        __CODE{tc|NodeReadOnlyError:: $node => $self}__;
        my $v = $$self->{<H::infoset|content>};
        $$v = defined $given ? $given : '';
                ## NOTE: Setting NULL is supported for
                ##       compatibility with |textContent|.

    @@Test:
      @@@QName: CharacterData.nodeValue.data.textContent.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
  
        for my $node (
          $doc-><M::Document.createTextNode> ('initial value'),
          $doc-><M::Document.createComment> ('initial value'),
          $doc-><M::Document.createCDATASection> ('initial value'),
        ) {
          $test->id ($node-><AG::Node.nodeType>.'.nodeValue.get');
          $test->assert_equals ($node-><AG::Node.nodeValue>, 'initial value');

          $test->id ($node-><AG::Node.nodeType>.'.textContent.get');
          $test->assert_equals ($node-><AG::Node.textContent>,
                                'initial value');

          $test->id ($node-><AG::Node.nodeType>.'.data.get');
          $test->assert_equals ($node-><AG::CharacterData.data>,
                                'initial value');

          $node-><M::Node.manakaiSetReadOnly> (false);

          $node-><AS::Node.nodeValue> ('value1');

          $test->id ($node-><AG::Node.nodeType>.'.nodeValue.set.nodeValue');
          $test->assert_equals ($node-><AG::Node.nodeValue>, 'value1');

          $test->id ($node-><AG::Node.nodeType>.'.nodeValue.set.textContent');
          $test->assert_equals ($node-><AG::Node.textContent>, 'value1');

          $test->id ($node-><AG::Node.nodeType>.'.nodeValue.set.data');
          $test->assert_equals ($node-><AG::CharacterData.data>, 'value1');

          $node-><AS::Node.nodeValue> ('');

          $test->id ($node-><AG::Node.nodeType>.'.nodeValue.empty.nodeValue');
          $test->assert_equals ($node-><AG::Node.nodeValue>, '');

          $test->id ($node-><AG::Node.nodeType>.'.nodeValue.empty.text');
          $test->assert_equals ($node-><AG::Node.textContent>, '');

          $test->id ($node-><AG::Node.nodeType>.'.nodeValue.empty.data');
          $test->assert_equals ($node-><AG::CharacterData.data>, '');

          $node-><AS::Node.textContent> ('value3');

          $test->id ($node-><AG::Node.nodeType>.'.textContent.set.nodeValue');
          $test->assert_equals ($node-><AG::Node.nodeValue>, 'value3');

          $test->id ($node-><AG::Node.nodeType>.'.textContent.set.text');
          $test->assert_equals ($node-><AG::Node.textContent>, 'value3');

          $test->id ($node-><AG::Node.nodeType>.'.textContent.set.data');
          $test->assert_equals ($node-><AG::CharacterData.data>, 'value3');

          $node-><AS::Node.textContent> ('');

          $test->id ($node-><AG::Node.nodeType>.'.text.empty.nodeValue');
          $test->assert_equals ($node-><AG::Node.nodeValue>, '');

          $test->id ($node-><AG::Node.nodeType>.'.textContent.empty.text');
          $test->assert_equals ($node-><AG::Node.textContent>, '');

          $test->id ($node-><AG::Node.nodeType>.'.textContent.empty.data');
          $test->assert_equals ($node-><AG::CharacterData.data>, '');

          $node-><AS::Node.textContent> ('value4');
          $node-><AS::Node.textContent> (null);

          $test->id ($node-><AG::Node.nodeType>.'.text.null.nodeValue');
          $test->assert_equals ($node-><AG::Node.nodeValue>, '');

          $test->id ($node-><AG::Node.nodeType>.'.textContent.null.text');
          $test->assert_equals ($node-><AG::Node.textContent>, '');

          $test->id ($node-><AG::Node.nodeType>.'.textContent.null.data');
          $test->assert_equals ($node-><AG::CharacterData.data>, '');

          $node-><AS::CharacterData.data> ('value2');

          $test->id ($node-><AG::Node.nodeType>.'.data.set.nodeValue');
          $test->assert_equals ($node-><AG::Node.nodeValue>, 'value2');

          $test->id ($node-><AG::Node.nodeType>.'.data.set.textContent');
          $test->assert_equals ($node-><AG::Node.textContent>, 'value2');

          $test->id ($node-><AG::Node.nodeType>.'.data.set.data');
          $test->assert_equals ($node-><AG::CharacterData.data>, 'value2');
     
          $node-><AS::CharacterData.data> ('');

          $test->id ($node-><AG::Node.nodeType>.'.data.empty.nodeValue');
          $test->assert_equals ($node-><AG::Node.nodeValue>, '');

          $test->id ($node-><AG::Node.nodeType>.'.data.empty.textContent');
          $test->assert_equals ($node-><AG::Node.textContent>, '');

          $test->id ($node-><AG::Node.nodeType>.'.data.empty.data');
          $test->assert_equals ($node-><AG::CharacterData.data>, '');

          $node-><M::Node.manakaiSetReadOnly> (true);

          $test->id ($node-><AG::Node.nodeType>.'.nodeValue.set.ro');
          $test->assert_exception (code => sub {
            $node-><AS::Node.nodeValue> ('value1');
          }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);
          $test->assert_equals ($node-><AG::Node.nodeValue>, '');

          $test->id ($node-><AG::Node.nodeType>.'.textContent.set.ro');
          $test->assert_exception (code => sub {
            $node-><AS::Node.textContent> ('value1');
          }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);
          $test->assert_equals ($node-><AG::Node.nodeValue>, '');

          $test->id ($node-><AG::Node.nodeType>.'.data.set.ro');
          $test->assert_exception (code => sub {
            $node-><AS::CharacterData.data> ('value1');
          }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);
          $test->assert_equals ($node-><AG::Node.nodeValue>, '');
        }

  @Attr:
    @@Name: length
    @@enDesc:
      The number of 16-bit units that are available through 
      the <A::CharacterData.data> attribute.

      This may have the value zero, i.e. a <IF::CharacterData>
      node may be empty.
    @@Offset16Note:
    @@Get:
      @@@Type: unsignedLong
      @@@PerlDef:
        my $v = $$self->{<H::infoset|content>};
        $r = CORE::length $$v;
        $r++ while $$v =~ /[\x{10000}-\x{10FFFF}]/g;

    @@Test:
      @@@QName: CharacterData.length.test
      @@@PerlDef:
        my $text;
        my $doc;
        __CODE{tc|createTextForTest:: $text => $text, $doc => $doc}__;

        for my $testdata (
          # id, data, length
          ['empty', '', 0],
          ['small.a', 'a', 1],
          ['han.4e00', "\x{4E00}", 1],
          ['a-z', 'abcdefghijklmnopqrstuvwxyz', 26],
          ['U+10000', "\x{10000}", 2],
          ['aU+10000', "a\x{10000}", 3],
          ['U+10000U+11111', "\x{10000}\x{11111}", 4],
        ) {
          $test->id ($testdata->[0]);
          $text-><AS::CharacterData.data> ($testdata->[1]);
          my $return = $text-><AG::CharacterData.length>;
          $test->assert_num_equals
                   (actual_value => $return, expected_value => $testdata->[2]);
        }

  @Method:
    @@Name: substringData
    @@enDesc:
      Extracts a range of the data from the node.
    @@Offset16Note:
    @@Param:
      @@@Name: offset
      @@@Type: unsignedLong
      @@@enDesc:
        The start offset of the substring to extract.
    @@Param:
      @@@Name: count
      @@@Type: unsignedLong
      @@@enDesc:
        The number of the 16-bit units to extract.
    @@Return:
      @@@Type: DOMString
      @@@enDesc:
        The specified substring.

        If the sum of the <P::offset> and the <P::count> arguments
        exceeds the <A::CharacterData.length> of the node,
        then all the 16-bit units to the end of
        the <A::CharacterData.data> of the node are returned.
      @@@dx:raises:
        @@@@@: c|StringIndexOutOfBoundsException
        @@@@enDesc:
          If the specified <P::offset> is negative or
          greater than the number of the 16-bit units in
          the <A::CharacterData.data> of the node.
      @@@dx:raises:
        @@@@@: c|NEGATIVE_LENGTH_ERR
        @@@@enDesc:
          If the specified <P::count> is negative.

            {SpecIssue::
              Parameters <P::offset> and <P::count> cannot be negative
              by definition.
            }
      @@@iRaises:
        @@@@@: c|DOMSTRING_SIZE_ERR
        @@@@enDesc:
          If the specified range of the data does not fit
          into a <TYPE::DOMString>.
      @@@enImplNote:
        {SpecIssue::
          If the operation would return a part of a surrogate pair...
        }
      @@@PerlDef:
        __CODE{tc|NodeReadOnlyError:: $node => $self}__;
        if ($count < 0) {
          __EXCEPTION{c|NEGATIVE_LENGTH_ERR::
            MDOMX|param-name => 'count',
            c|length => {$count},
          }__;
        }
        my $eoffset32;
        try {
          $eoffset32 = $self-><M::StringExtended.findOffset32>
                                ($offset + $count);
        } catch <IF::c|DOMException> with {
          my $err = shift;
          if ($err->subtype eq <Q::c|StringIndexOutOfBoundsException>) {
            $eoffset32 = ($offset + $count) * 2;
          } else {
            $err->throw;
          }
        };
        __DEEP{
          my $offset32 = $self-><M::StringExtended.findOffset32> ($offset);
          my $data = $self-><AG::CharacterData.data>;
          $r = substr ($data, $offset32, $eoffset32 - $offset32);
        }__;

    @@Test:
      @@@QName: CharacterData.substringData.1.test
      @@@PerlDef:
        my $text;
        my $doc;
        __CODE{tc|createTextForTest:: $text => $text, $doc => $doc}__;

        $test->id (1);
        $test->assert_equals
                 ($text-><M::CharacterData.substringData> (0, 0), '');

        $test->id (2);
        $test->assert_equals
                 ($text-><M::CharacterData.substringData> (0, 1), '');
    @@Test:
      @@@QName: CharacterData.substringData.2.test
      @@@PerlDef:
        my $text;
        my $doc;
        __CODE{tc|createTextForTest:: $text => $text, $doc => $doc}__;

        $text-><AS::CharacterData.data> ('abcdefg');

        $test->id (1);
        $test->assert_equals
                 ($text-><M::CharacterData.substringData> (0, 0), '');

        $test->id (2);
        $test->assert_equals
                 ($text-><M::CharacterData.substringData> (0, 1), 'a');

        $test->id (3);
        $test->assert_equals
                 ($text-><M::CharacterData.substringData> (5, 1), 'f');

        $test->id (4);
        $test->assert_equals
                 ($text-><M::CharacterData.substringData> (5, 2), 'fg');

  @Method:
    @@Name: appendData
    @@enDesc:
      Appends a string to the end of the character data of the node.

      Upon success, the <A::CharacterData.data> attribute
      provides access to the contatenation of the
      <A::CharacterData.data> and the <P::arg>.
    @@Param:
      @@@Name: arg
      @@@Type: DOMString
      @@@enDesc:
        The string to append.
    @@Return:
      @@@NodeReadOnlyError:
      @@@PerlDef:
        __DEEP{
          $self-><M::Node.manakaiAppendText> (\$arg);
        }__;

    @@Test:
      @@@QName: CharacterData.appendData.test
      @@@PerlDef:
        my $text;
        my $doc;
        __CODE{tc|createTextForTest:: $text => $text, $doc => $doc}__;

        $test->id ('empty.to.empty');
        $text-><M::CharacterData.appendData> ('');
        $test->assert_equals ($text-><AG::CharacterData.data>, '');

        $test->id ('to.empty');
        $text-><M::CharacterData.appendData> ('a');
        $test->assert_equals ($text-><AG::CharacterData.data>, 'a');

        $test->id ('3');
        $text-><M::CharacterData.appendData> ('abc');
        $test->assert_equals ($text-><AG::CharacterData.data>, 'aabc');

  @Method:
    @@Name: insertData
    @@enDesc:
      Inserts a string at the specified 16-bit unit offset.
    @@Offset16Note:
    @@Param:
      @@@Name: offset
      @@@Type: unsignedLong
      @@@enDesc:
        The character offset at which to insert.
    @@Param:
      @@@Name: arg
      @@@Type: DOMString
      @@@enDesc:
        The string to insert.
    @@Return:
      @@@dx:raises:
        @@@@@: c|StringIndexOutOfBoundsException
        @@@@enDesc:
          If the specified <P::offset> is negative or
          greater than the number of the 16-bit units in 
          the <A::CharacterData.data> of the node.

            {SpecIssue::
              The parameter <P::offset> cannot be negative
              by definition.
            }
      @@@NodeReadOnlyError:
      @@@enImplNote:
        {SpecIssue::
          If the operation would break a surrogate pair...
        }
      @@@PerlDef:
        __CODE{tc|NodeReadOnlyError:: $node => $self}__;
        __DEEP{
          my $offset32 = $self-><M::StringExtended.findOffset32> ($offset);
          my $data = $self-><AG::CharacterData.data>;
          substr ($data, $offset32, 0) = $arg;
          $self-><AS::CharacterData.data> ($data);
        }__;

    @@Test:
      @@@QName: CharacterData.insertData.1.test
      @@@PerlDef:
        my $text;
        my $doc;
        __CODE{tc|createTextForTest:: $text => $text, $doc => $doc}__;

        $test->id (1);
        $test->assert_exception (code => sub {
          $text-><M::CharacterData.insertData> (1, 'abc');
        }, exception_subtype => <Q::c|StringIndexOutOfBoundsException>);

        $test->id (2);
        $test->assert_exception (code => sub {
          $text-><M::CharacterData.insertData> (-1, 'abc');
        }, exception_subtype => <Q::c|StringIndexOutOfBoundsException>);

        $test->id (3);
        $text-><M::CharacterData.insertData> (0, 'abc');
        $test->assert_equals
                 ($text-><AG::CharacterData.data>, 'abc');

        $test->id (4);
        $text-><M::CharacterData.insertData> (3, 'abc');
        $test->assert_equals
                 ($text-><AG::CharacterData.data>, 'abcabc');

        $test->id (5);
        $text-><M::CharacterData.insertData> (1, 'abc');
        $test->assert_equals
                 ($text-><AG::CharacterData.data>, 'aabcbcabc');
    @@Test:
      @@@QName: CharacterData.insertData.2.test
      @@@PerlDef:
        my $text;
        my $doc;
        __CODE{tc|createTextForTest:: $text => $text, $doc => $doc}__;

        $test->id (1);
        $text-><M::CharacterData.insertData> (0, "\x{10000}");
        $test->assert_equals
                 ($text-><AG::CharacterData.data>, "\x{10000}");

        $test->id (2);
        $text-><M::CharacterData.insertData> (2, "\x{10001}");
        $test->assert_equals
                 ($text-><AG::CharacterData.data>, "\x{10000}\x{10001}");

        $test->id (3);
        $text-><M::CharacterData.insertData> (2, "a");
        $test->assert_equals
                 ($text-><AG::CharacterData.data>, "\x{10000}a\x{10001}");

  @Method:
    @@Name: deleteData
    @@enDesc:
      Removes a range of 16-bit units from the character
      data of the node.

      Upon success, the <A::CharacterData.data> and
      the <A::CharacterData.length> attributes reflect the change.
    @@Offset16Note:
    @@Param:
      @@@Name: offset
      @@@Type: unsignedLong
      @@@enDesc:
        The offset from which to start removing.
    @@Param:
      @@@Name: count
      @@@Type: unsignedLong
      @@@enDesc:
        The number of the 16-bit units to delete.

        If the sum of the <P::offset> and the <P::count> arguments
        exceeds the <A::CharacterData.length>, then all 
        the 16-bit units from the <P::offset> to the end of
        the <A::CharacterData.data> are deleted.
    @@Return:
      @@@dx:raises:
        @@@@@: c|StringIndexOutOfBoundsException
        @@@@enDesc:
          If the specified <P::offset> is negative or greater than
          the number of the 16-bit units in the 
          <A::CharacterData.data>, or if the specified <P::count>
          is negative.

            {SpecIssue::
              Parameters <P::offset> and <P::count> cannot be negative
              by definition.
            }
      @@@NodeReadOnlyError:
      @@@enImplNote:
        {SpecIssue::
          If the operation would break a surrogate pair...
        }
      @@@PerlDef:
        __CODE{tc|NodeReadOnlyError:: $node => $self}__;
        if ($count < 0) {
          __EXCEPTION{c|NEGATIVE_LENGTH_ERR::
            MDOMX|param-name => 'count',
            c|length => {$count},
          }__;
        }
        my $eoffset32;
        try {
          $eoffset32 = $self-><M::StringExtended.findOffset32>
                                ($offset + $count);
        } catch <IF::c|DOMException> with {
          my $err = shift;
          if ($err->subtype eq <Q::c|StringIndexOutOfBoundsException>) {
            $eoffset32 = ($offset + $count) * 2;
          } else {
            $err->throw;
          }
        };
        __DEEP{
          my $offset32 = $self-><M::StringExtended.findOffset32> ($offset);
          my $data = $self-><AG::CharacterData.data>;
          substr ($data, $offset32, $eoffset32 - $offset32) = '';
          $self-><AS::CharacterData.data> ($data);
        }__;

    @@Test:
      @@@QName: CharacterData.deleteData.empty.test
      @@@PerlDef:
        my $text;
        my $doc;
        __CODE{tc|createTextForTest:: $text => $text, $doc => $doc}__;

        $test->id ('1');
        $text-><M::CharacterData.deleteData> (0, 0);
        $test->assert_equals ($text-><AG::CharacterData.data>, '');

        $test->id ('2');
        $text-><M::CharacterData.deleteData> (0, 10);
        $test->assert_equals ($text-><AG::CharacterData.data>, '');

        $test->id ('3');
        $test->assert_exception (code => sub {
          $text-><M::CharacterData.deleteData> (-1, 0);
        }, exception_subtype => <Q::c|StringIndexOutOfBoundsException>);

        $test->id ('4');
        $test->assert_exception (code => sub {
          $text-><M::CharacterData.deleteData> (1, 0);
        }, exception_subtype => <Q::c|StringIndexOutOfBoundsException>);

        $test->id ('5');
        $test->assert_exception (code => sub {
          $text-><M::CharacterData.deleteData> (0, -10);
        }, exception_subtype => <Q::c|NEGATIVE_LENGTH_ERR>);
    @@Test:
      @@@QName: CharacterData.deleteData.1.test
      @@@PerlDef:
        my $text;
        my $doc;
        __CODE{tc|createTextForTest:: $text => $text, $doc => $doc}__;

        $text-><M::CharacterData.appendData> ('abcdefg');

        $test->id ('1');
        $text-><M::CharacterData.deleteData> (0, 0);
        $test->assert_equals ($text-><AG::CharacterData.data>, 'abcdefg');

        $test->id ('2');
        $text-><M::CharacterData.deleteData> (0, 2);
        $test->assert_equals ($text-><AG::CharacterData.data>, 'cdefg');

        $test->id ('3');
        $test->assert_exception (code => sub {
          $text-><M::CharacterData.deleteData> (-1, 0);
        }, exception_subtype => <Q::c|StringIndexOutOfBoundsException>);

        $test->id ('4');
        $test->assert_exception (code => sub {
          $text-><M::CharacterData.deleteData> (20, 0);
        }, exception_subtype => <Q::c|StringIndexOutOfBoundsException>);

        $test->id ('5');
        $test->assert_exception (code => sub {
          $text-><M::CharacterData.deleteData> (0, -10);
        }, exception_subtype => <Q::c|NEGATIVE_LENGTH_ERR>);

        $test->id ('6');
        $text-><M::CharacterData.deleteData> (2, 12);
        $test->assert_equals ($text-><AG::CharacterData.data>, 'cd');

        $test->id ('7');
        $text-><M::CharacterData.deleteData> (0, 2);
        $test->assert_equals ($text-><AG::CharacterData.data>, '');
    @@Test:
      @@@QName: CharacterData.deleteData.2.test
      @@@PerlDef:
        my $text;
        my $doc;
        __CODE{tc|createTextForTest:: $text => $text, $doc => $doc}__;

        $text-><M::CharacterData.appendData> ("ab\x{10000}cdefg");

        $test->id ('1');
        $text-><M::CharacterData.deleteData> (0, 4);
        $test->assert_equals ($text-><AG::CharacterData.data>, 'cdefg');
    @@Test:
      @@@QName: CharacterData.deleteData.3.test
      @@@PerlDef:
        my $text;
        my $doc;
        __CODE{tc|createTextForTest:: $text => $text, $doc => $doc}__;

        $text-><M::CharacterData.appendData> ("ab\x{10000}cdefg");

        $test->id ('1');
        $text-><M::CharacterData.deleteData> (4, 2);
        $test->assert_equals ($text-><AG::CharacterData.data>, "ab\x{10000}efg");

  @Method:
    @@Name: replaceData
    @@enDesc:
      Replaces the characters starting at the specified
      16-bit unit offset with the specified string.
    @@Offset16Note:
    @@Param:
      @@@Name: offset
      @@@Type: unsignedLong
      @@@enDesc:
        The offset from which to start replacing.
    @@Param:
      @@@Name: count
      @@@Type: unsignedLong
      @@@enDesc:
        The number of the 16-bit units to replace.

        If the sum of the <P::offset> and the <P::count> arguments
        exceeds the <A::CharacterData.length> of the node, then
        all the 16-bit units to the end of the <A::CharacterData.data>
        are replaced.
    @@Param:
      @@@Name: arg
      @@@Type: DOMString
      @@@enDesc:
        The string with which the range must be replaced.
    @@Return:
      @@@dx:raises:
        @@@@@: c|StringIndexOutOfBoundsException
        @@@@enDesc:
          If the specified <P::offset> is negative or
          greater than the number of the 16-bit units
          in the <A::CharacterData.data> of the node.
      @@@dx:raises:
        @@@@@: c|NEGATIVE_LENGTH_ERR
        @@@@enDesc:
          If the specified <P::count> is negative.

            {SpecIssue::
              Parameters <P::offset> and <P::count> cannot be negative
              by definition.
            }
      @@@NodeReadOnlyError:
      @@@enImplNote:
        {SpecIssue::
          If the operation would break a surrogate pair...
        }
      @@@PerlDef:
        __DEEP{
          $self-><M::CharacterData.deleteData> ($offset, $count);
          $self-><M::CharacterData.insertData> ($offset, $arg);
        }__;

    @@Test:
      @@@QName: CharacterData.replaceData.test
      @@@PerlDef:
        my $text;
        my $doc;
        __CODE{tc|createTextForTest:: $text => $text, $doc => $doc}__;

        $test->id (1);
        $text-><M::CharacterData.appendData> ('abcdefg');
        $text-><M::CharacterData.replaceData> (0, 2, 'ABCD');
        $test->assert_equals
                 ($text-><AG::CharacterData.data>, 'ABCDcdefg');

        $test->id (2);
        $text-><M::CharacterData.replaceData> (3, 32, "\x{3000}\x{4E00}");
        $test->assert_equals
                 ($text-><AG::CharacterData.data>, "ABC\x{3000}\x{4E00}");
##CharacterData

ElementTypeBinding:
  @Name: Offset16Note
  @ElementType:
    dis:Description
  @ShadowContent:
    @@lang:en
    @@@:
      {NOTE::
        Since strings are hold as sequences of characters in Perl
        rather than as sequences of UTF-16 code units in DOM,
        use of this method would be a bad choice in the viewpoint
        of performance.  Usually applications should prefer normal
        string functions of Perl.
      }
    @@For: ManakaiDOM|ManakaiDOM
    @@ddid:Offset16Note

IFCls1Def:
  @IFQName: Text
  @ClsQName: ManakaiDOMText

  @IFISA: CharacterData
  @ClsISA: ManakaiDOMCharacterData

  @enDesc:
    A <IF::Text> object represents a textual content of an
    <IF::Element> or <IF::Attr> (termed <DFN::character data>
    in XML).  If there is no markup inside an element's content,
    the text is contained in a single <IF::Text> object that
    is the only child of the element.  If there is markup,
    it is parsed into the information items (elements,
    comments, and so on) that form the list of children of the element,
    where sequences of character information items consist 
    <IF::Text> nodes.

    When a document is first made available via the DOM,
    there is only one <IF::Text> node for each block
    of text.  Applications may create adjacent <IF::Text> nodes
    that represents the contents of a given element without any
    intervening markup, but should be aware that there is no way
    to represent the separations between these nodes in
    XML or HTML, so they will not in general persisten between
    DOM editing sessions.  The <M::Node.normalize> method
    merges any such adjacent <IF::Text> nodes into a single
    node for each block of text.

    No lexical check or parsing is done on the content of a <IF::Text> node
    and some characters must be escaped, depending on its position
    in the document, during serialization using character or
    general entity references.

  @enImplNote:
    @@ddid: props
    @@@:
      {P:: Required internal properties:

        - <Q::tc|ownerDocument>.

        - <Q::infoset|content>.

      }

      {P:: Optional internal properties:

        - <Q::infoset|parent>.

        - <Q::c|read-only>.

      }

  @CODE:
    @@QName: tc|createTextForTest
    @@PerlDef:
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
      $text = $doc-><M::Document.createTextNode> ('');

  @CAttr:
    @@Name: nodeType
    @@Type: unsignedShort
    @@dis:actualType: NodeType
    @@Get:
      @@@disDef:
        @@@@DISLang:constValue: Node.TEXT_NODE

    @@Test:
      @@@QName: Text.nodeType.test
      @@@PerlDef:
        my $text;
        my $doc;
        __CODE{tc|createTextForTest:: $text => $text, $doc => $doc}__;

        $test->id ('nodeType');
        $test->assert_num_equals
                 (actual_value => $text-><AG::Node.nodeType>,
                  expected_value => <C::Node.TEXT_NODE>);

  @Test:
    @@QName: Text.parentNode.1.test
    @@PerlDef:
      my $text;
      my $doc;
      __CODE{tc|createTextForTest:: $text => $text, $doc => $doc}__;

      $test->assert_null ($text-><AG::Node.parentNode>);

  @Test:
    @@QName: Text.isSameNode.1.test
    @@PerlDef:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

      my $el = $doc-><M::Document.createTextNode> ('a');

      my $el2 = $doc-><M::Document.createTextNode> ('a');
      
      $test->id ('same');
      $test->assert_equals ($el, $el);
      
      $test->id ('diff');
      $test->assert_not_equals ($el, $el2);
      
      $test->id ('doc');
      $test->assert_not_equals ($el, $doc);
  @Test:
    @@QName: Text.isSameNode.2.test
    @@PerlDef:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

      my $el = $doc-><M::Document.createTextNode> ('a');

      my $el2 = $doc-><M::Document.createTextNode> ('a');
      
      $test->id ('same');
      $test->assert_true ($el-><M::Node.isSameNode> ($el));
      
      $test->id ('diff');
      $test->assert_false ($el-><M::Node.isSameNode> ($el2));
      
      $test->id ('doc');
      $test->assert_false ($el-><M::Node.isSameNode> ($doc));

  @Test:
    @@QName: Text.readOnly.test
    @@PerlDef:
      my $text;
      my $doc;
      __CODE{tc|createTextForTest:: $text => $text, $doc => $doc}__;

      $test->id ('default');
      $test->assert_false ($text-><AG::Node.manakaiReadOnly>);

  @CAttr:
    @@Name: nodeName
    @@enDesc:
      The node name.
    @@DOMMain:isNamespaceUnaware:1
    @@Type: DOMString
    @@Get:
      @@@DefaultValue:
        @@@@@: \#text
        @@@@ContentType:
          DISCore:String
      @@@disDef:
        @@@@DISLang:nop:

    @@Test:
      @@@QName: Text.nodeName.test
      @@@PerlDef:
        my $text;
        my $doc;
        __CODE{tc|createTextForTest:: $text => $text, $doc => $doc}__;

        $test->assert_equals ($text-><AG::Node.nodeName>, '#text');

  @Test:
    @@QName: Text.appendChild.test
    @@PerlDef:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
      my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

      my $text = $doc-><M::Document.createTextNode> ('data');
      my $node2 = $doc-><M::Document.createTextNode> ('2');

      for my $node (<Code::tc|createNodesForTest+dt>) {
        $test->id ('appendChild.'.$node-><AG::Node.nodeType>);
        $test->assert_exception (code => sub {
          $text-><M::Node.appendChild> ($node);
        }, exception_subtype => <Q::MDOMX|HIERARCHY_BAD_TYPE>);

        $test->id ('insertBefore.'.$node-><AG::Node.nodeType>);
        $test->assert_exception (code => sub {
          $text-><M::Node.insertBefore> ($node);
        }, exception_subtype => <Q::MDOMX|HIERARCHY_BAD_TYPE>);

        $test->id ('replaceChild.'.$node-><AG::Node.nodeType>);
        $test->assert_exception (code => sub {
          $text-><M::Node.replaceChild> ($node, $node2);
        }, exception_subtype => <Q::MDOMX|HIERARCHY_BAD_TYPE>);
      }

  @Test:
    @@QName: Text..=.1.test
    @@PerlDef:
      my $doc;
      __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;

      my $node = $doc-><M::Document.createTextNode> ('');

      $node-><M::Node.manakaiAppendText> ('aaaa');
      $test->id ('1.class');
      $test->assert_isa ($node, <IFName::Text>);
      $test->id ('1.value');
      $test->assert_equals ($node-><AG::CharacterData.data>, 'aaaa');

      $test->id (2);
      $node-><M::Node.manakaiAppendText> ('bbbb');
      $test->assert_equals ($node-><AG::CharacterData.data>, 'aaaabbbb');

  @CL3Method:
    @@Name: getFeature
    @@enDesc:
      Returns a specialized object that implements the specialized APIs.
    @@Param:
      @@@Name: feature
      @@@Type: DOMString
      @@@dis:actualType: f|FeatureNameString
    @@Param:
      @@@Name: version
      @@@Type: DOMString
      @@@dis:actualType: f|FeatureVersionString
    @@Return:
      @@@Type: DOMMain|DOMObject
      @@@nullCase:
      @@@PerlDef:
        $feature =~ s/^\+//;
        __CODE{f|getFeatureImpl::
          $self => $self,
          $feature => $feature, $version => $version, $r => $r,
          $base_class => {<ClassName::ManakaiDOMText>},
        }__;
        unless (defined $r) {
          __DEEP{
            $r = $self->SUPER::get_feature ($feature, $version);
          }__;
        }

    @@Test:
      @@@QName: Text.getFeature.test
      @@@PerlDef:
        my $node;
        my $doc;
        __CODE{tc|createTextForTest:: $text => $node, $doc => $doc}__;

        for (
          [Core => '1.0', <IFName::Text||ManakaiDOM|ManakaiDOM1>],
          [Core => '2.0', <IFName::Text||ManakaiDOM|ManakaiDOM2>],
          [Core => '3.0', <IFName::Text||ManakaiDOM|ManakaiDOM3>],
          [XML => '1.0', <IFName::Text||ManakaiDOM|ManakaiDOM1>],
          [XML => '2.0', <IFName::Text||ManakaiDOM|ManakaiDOM2>],
          [XML => '3.0', <IFName::Text||ManakaiDOM|ManakaiDOM3>],
        ) {
          $test->id ($_->[0].'.'.$_->[1]);
          my $sp = $node-><M::Node.getFeature> ($_->[0], $_->[1]);
          $test->assert_isa ($sp, $_->[2]);
        }

  @Test:
    @@QName: Text.baseURI.test
    @@PerlDef:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $pi = $doc-><M::Document.createTextNode> ('text');
       
        $test->id ('default');
        $test->assert_null ($pi-><AG::Node.baseURI>);

        $test->id ('doc');
        $doc-><AS::Document.documentURI> (q<http://doc.test/>);
        $test->assert_equals
                 ($pi-><AG::Node.baseURI>,
                  q<http://doc.test/>);

        $test->id ('el');
        my $el = $doc-><M::Document.createElementNS> (null, 'e');
        $el-><M::Element.setAttributeNS> (<Q::xml:>, 'xml:base',
                                          q<http://el.test/>);
        $el-><M::Node.appendChild> ($pi);
        $test->assert_equals
                 ($pi-><AG::Node.baseURI>,
                  q<http://el.test/>);

        $test->id ('ent');
        my $ent = $doc-><M::Document.createEntityReference> ('ent');
        $ent-><M::Node.manakaiSetReadOnly> (false, true);
        $ent-><AS::tx|EntityReference.manakaiExternal> (true);
        $ent-><AS::tx|EntityReference.manakaiEntityBaseURI>
                (q<http://ent.test/>);
        $el-><M::Node.appendChild> ($ent);
        $ent-><M::Node.appendChild> ($pi);
        $test->assert_equals
                 ($pi-><AG::Node.baseURI>,
                  q<http://ent.test/>);

  @L3Attr:
    @@Name: isElementContentWhitespace
    @@enDesc:
      Whether the text node contains element content white spaces.

      The text node is determined to contain white space in element
      content during the load of the document or if validation occurs
      while using <M::Document.normalizeDocument>.
    @@enImplNote:
      @@@ddid: ??
      @@@@:
        <IF::Text> with non-white-space-characters or with
        no white space character?

        <IF::CDATASection>?
    @@Type: boolean
    @@Get:
      @@@PerlDef:
        $r = $$self->{<H::infoset|elementContentWhitespace>};
    @@LXSet:
      @@@enImplNote:
        {TODO::
          Clarification is necessary.
        }
      @@@NodeReadOnlyError:
      @@@PerlDef:
        __CODE{tc|NodeReadOnlyError:: $node => $self}__;
        $$self->{<H::infoset|elementContentWhitespace>} = $given;

    @@Test:
      @@@QName: Text.isElementContentWhitespace.test
      @@@PerlDef:
        my $node;
        my $doc;
        __CODE{tc|createTextForTest:: $text => $node, $doc => $doc}__;
        $node-><AS::Node.nodeValue> (' ');

        $test->id ('default');
        $test->assert_false ($node-><AG::Text.isElementContentWhitespace>);

        $test->id ('set.true');
        $node-><AS::Text.isElementContentWhitespace> (true);
        $test->assert_true ($node-><AG::Text.isElementContentWhitespace>);

        $test->id ('set.false');
        $node-><AS::Text.isElementContentWhitespace> (false);
        $test->assert_false ($node-><AG::Text.isElementContentWhitespace>);

  @L3Attr:
    @@Name: wholeText
    @@enDesc:
      All text of logically-adjacent text nodes to this node,
      concatenated in document order.

      The <DFN::logically-adjacent text nodes> are <IF::Text>
      or <IF::tx|CDATASection> nodes that can be visited
      sequentially in document order or in reverse document
      order without entering, exiting, or passing
      over <IF::Element>, <IF::Comment>, <IF::tx|ProcessingInstruction>
      <SRC::DOM3>, or <IF::tx|DocumentType> <SRC::manakai> nodes.
    @@enImplNote:
      @@@ddid: unexpanded
      @@@@:
        By definition unexpanded entity references are seemed to be ignored.
    @@Type: DOMString
    @@Get:
      @@@PerlDef:
        __DEEP{
          require Message::DOM::Traversal;
          my $doc = $self-><AG::Node.ownerDocument>;
          my $doctrv = $doc-><M::Node.getFeature> (Traversal => '2.0');
          my $tw1 = $doctrv-><M::trv|DocumentTraversal.createTreeWalker>
                               ($doc, <C::trv|NodeFilter.SHOW_ALL>, sub {
                                 ($_[1]-><AG::Node.nodeType>
                                      == <C::Node.ENTITY_REFERENCE_NODE>)
                                   ? <C::trv|NodeFilter.FILTER_SKIP>
                                   : <C::trv|NodeFilter.FILTER_ACCEPT>
                               }, true);
          $tw1-><AS::trv|TreeWalker.currentNode> ($self);
          my $tw2 = $tw1->clone;
          $r = $self-><AG::Node.nodeValue>;

          S: while (defined (my $node = $tw1-><M::trv|TreeWalker
                                                .previousSibling>)) {
            my $nt = $node-><AG::Node.nodeType>;
            if ($nt == <C::Node.TEXT_NODE> or
                $nt == <C::Node.CDATA_SECTION_NODE>) {
              $r = $node-><AG::Node.nodeValue> . $r;
            } else {
              last S;
            }
          } # S

          S: while (defined (my $node = $tw2-><M::trv|TreeWalker
                                                .nextSibling>)) {
            my $nt = $node-><AG::Node.nodeType>;
            if ($nt == <C::Node.TEXT_NODE> or
                $nt == <C::Node.CDATA_SECTION_NODE>) {
              $r .= $node-><AG::Node.nodeValue>;
            } else {
              last S;
            }
          } # S
        }__;

    @@Test:
      @@@QName: Text.wholeText.1.test
      @@@PerlDef:
        my $el;
        my $doc;
        __CODE{tc|createElementForTest:: $el => $el, $doc => $doc}__;

        my $text1 = $doc-><M::Document.createTextNode> ('text1');

        $el-><M::Node.appendChild> ($text1);

        $test->assert_equals ($text1-><AG::Text.wholeText>, 'text1');
    @@Test:
      @@@QName: Text.wholeText.2.test
      @@@PerlDef:
        my $el;
        my $doc;
        __CODE{tc|createElementForTest:: $el => $el, $doc => $doc}__;

        my $text1 = $doc-><M::Document.createTextNode> ('text1');
        $el-><M::Node.appendChild> ($text1);
        my $text2 = $doc-><M::Document.createTextNode> ('text2');
        $el-><M::Node.appendChild> ($text2);

        $test->id ('text1');
        $test->assert_equals ($text1-><AG::Text.wholeText>, 'text1text2');
        $test->id ('text2');
        $test->assert_equals ($text2-><AG::Text.wholeText>, 'text1text2');
    @@Test:
      @@@QName: Text.wholeText.3.test
      @@@PerlDef:
        my $el;
        my $doc;
        __CODE{tc|createElementForTest:: $el => $el, $doc => $doc}__;

        my $text1 = $doc-><M::Document.createTextNode> ('text1');
        $el-><M::Node.appendChild> ($text1);
        my $text2 = $doc-><M::Document.createTextNode> ('text2');
        $el-><M::Node.appendChild> ($text2);
        my $text3 = $doc-><M::Document.createCDATASection> ('text3');
        $el-><M::Node.appendChild> ($text3);

        $test->id ('text1');
        $test->assert_equals ($text1-><AG::Text.wholeText>, 'text1text2text3');
        $test->id ('text2');
        $test->assert_equals ($text2-><AG::Text.wholeText>, 'text1text2text3');
        $test->id ('text3');
        $test->assert_equals ($text3-><AG::Text.wholeText>, 'text1text2text3');
    @@Test:
      @@@QName: Text.wholeText.4.test
      @@@PerlDef:
        my $el;
        my $doc;
        __CODE{tc|createElementForTest:: $el => $el, $doc => $doc}__;

        my $text1 = $doc-><M::Document.createTextNode> ('text1');
        $el-><M::Node.appendChild> ($text1);
        my $text3 = $doc-><M::Document.createCDATASection> ('text3');
        $el-><M::Node.appendChild> ($text3);
        my $el1 = $doc-><M::Document.createElement> ('el1');
        $el-><M::Node.appendChild> ($el1);
        my $text2 = $doc-><M::Document.createTextNode> ('text2');
        $el-><M::Node.appendChild> ($text2);

        $test->id ('text1');
        $test->assert_equals ($text1-><AG::Text.wholeText>, 'text1text3');
        $test->id ('text2');
        $test->assert_equals ($text2-><AG::Text.wholeText>, 'text2');
        $test->id ('text3');
        $test->assert_equals ($text3-><AG::Text.wholeText>, 'text1text3');
    @@Test:
      @@@QName: Text.wholeText.5.test
      @@@PerlDef:
        my $el;
        my $doc;
        __CODE{tc|createElementForTest:: $el => $el, $doc => $doc}__;

        my $text1 = $doc-><M::Document.createTextNode> ('text1');
        $el-><M::Node.appendChild> ($text1);
        my $text3 = $doc-><M::Document.createCDATASection> ('text3');
        $el-><M::Node.appendChild> ($text3);
        my $er1 = $doc-><M::Document.createEntityReference> ('er1');
        $er1-><M::Node.manakaiSetReadOnly> (false, true);
        $el-><M::Node.appendChild> ($er1);
        my $text4 = $doc-><M::Document.createTextNode> ('text4');
        $er1-><M::Node.appendChild> ($text4);
        my $text2 = $doc-><M::Document.createTextNode> ('text2');
        $el-><M::Node.appendChild> ($text2);

        $test->id ('text1');
        $test->assert_equals ($text1-><AG::Text.wholeText>,
                              'text1text3text4text2');
        $test->id ('text2');
        $test->assert_equals ($text2-><AG::Text.wholeText>,
                              'text1text3text4text2');
        $test->id ('text3');
        $test->assert_equals ($text3-><AG::Text.wholeText>,
                              'text1text3text4text2');
        $test->id ('text4');
        $test->assert_equals ($text4-><AG::Text.wholeText>,
                              'text1text3text4text2');
    @@Test:
      @@@QName: Text.wholeText.6.test
      @@@PerlDef:
        my $el;
        my $doc;
        __CODE{tc|createElementForTest:: $el => $el, $doc => $doc}__;

        my $text1 = $doc-><M::Document.createTextNode> ('text1');
        $el-><M::Node.appendChild> ($text1);
        my $text3 = $doc-><M::Document.createCDATASection> ('text3');
        $el-><M::Node.appendChild> ($text3);
        my $er1 = $doc-><M::Document.createEntityReference> ('er1');
        $er1-><M::Node.manakaiSetReadOnly> (false, true);
        $el-><M::Node.appendChild> ($er1);
        my $text4 = $doc-><M::Document.createTextNode> ('text4');
        $er1-><M::Node.appendChild> ($text4);
        my $com1 = $doc-><M::Document.createComment> ('');
        $er1-><M::Node.appendChild> ($com1);
        my $text2 = $doc-><M::Document.createTextNode> ('text2');
        $el-><M::Node.appendChild> ($text2);

        $test->id ('text1');
        $test->assert_equals ($text1-><AG::Text.wholeText>,
                              'text1text3text4');
        $test->id ('text2');
        $test->assert_equals ($text2-><AG::Text.wholeText>,
                              'text2');
        $test->id ('text3');
        $test->assert_equals ($text3-><AG::Text.wholeText>,
                              'text1text3text4');
        $test->id ('text4');
        $test->assert_equals ($text4-><AG::Text.wholeText>,
                              'text1text3text4');

  @L3Method:
    @@Name: replaceWholeText
    @@enDesc:
      Replaces the text of the node and all logically-adjacent
      text nodes with the specified text.

      All logically-adjacent text nodes are removed
      including the current node unless it was the recipient of
      the replacement text.

      Where the nodes to be removed are read-only descendants
      of an <IF::tx|EntityReference>, the <IF::tx|EntityReference>
      must be removed instead of the read-only nodes.  If any
      <IF::tx|EntityReference> to be removed has descendants
      that are not <IF::tx|EntityReference>, <IF::Text>, or
      <IF::tx|CDATASection> nodes, the method must fail
      before performing any modification of the document,
      raising a <IF::c|DOMException> with the code
      <C::c|NO_MODIFICATION_ALLOWED_ERR>.
    @@Param:
      @@@Name: content
      @@@Type: DOMString
      @@@enDesc:
        The content of the replacing <IF::Text> node.
    @@Return:
      @@@Type: Text
      @@@enDesc:
        The node that received the replacement text.  That is,
        the current node, except when the current node is read-only,
        or a new <IF::Text> or <IF::tx|CDATASection> node with the same 
        <A::Node.nodeType> as the current node inserted at the
        location of the replacement.
      @@@nullCase:
        @@@@enDesc:
          When the replacement text is an empty string.
      @@@dx:raises:
        @@@@@: c|NO_MODIFICATION_ALLOWED_ERR
        @@@@enDesc:
          If one of the <IF::Text> nodes being replaced is read-only.

            {SpecIssue::
              <QUOTE::One of>?  Some of? All of?  A parent of?
            }
    @@enImplNote:
      {SpecIssue::
        isElementContentWhitespace
      }

      {TODO::
         Implement this method.
      }

  @Method:
    @@Name: splitText
    @@enDesc:
      Breaks the node into two nodes at the specified <P::offset>,
      keeping both in the tree as siblings.

        {SpecIssue::
           Kept as sibling if and only if the node has <A::Node.parentNode>.
        }

      After being split, the node will contain all the content
      up to the <P::offset> point.  A new node of the same type,
      which contains all the content at and after the <P::offset>
      point, is returned.

      If the node has a parent, the new node is inserted as the
      next sibling of that node.

      When the <P::offset> is equal to the length of the data of 
      the node, the new node has no data.

        {SpecIssue::
           When <P::offset> is zero?
        }

        {SpecIssue::
           When it would break a surrogate pair?
        }

        {SpecIssue::
           <A::Text.isElementContentWhitespace>?
        }
    @@Offset16Note:
    @@Param:
      @@@Name: offset
      @@@Type: unsignedLong
      @@@enDesc:
        The 16-bit unit offset at which to split, starting from zero.
    @@Return:
      @@@Type: Text
      @@@enDesc:
        The new node, of the same type as the node.
      @@@dx:raises:
        @@@@@: c|StringIndexOutOfBoundsException
        @@@@enDesc:
          If the specified <P::offset> is negative or
          greater than the number of the 16-bit units
          in the <A::CharacterData.data> of the node.
      @@@dx:raises:
        @@@@@: c|NEGATIVE_LENGTH_ERR
        @@@@enDesc:
          If the specified <P::count> is negative.

            {SpecIssue::
              Parameters <P::offset> and <P::count> cannot be negative
              by definition.
            }
      @@@NodeReadOnlyError:
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_PARENT
        @@@@enDesc:
          If the parent node of the node is read-only.

            {SpecIssue::
               Not in the spec.
            }
      @@@PerlDef:
        __CODE{tc|NodeReadOnlyError:: $node => $self}__; 
        my $parent = $self-><AG::Node.parentNode>;
        if (defined $parent and $parent-><AG::Node.manakaiReadOnly>) {
          __EXCEPTION{MDOMX|NOMOD_PARENT::
          }__;
        }

        __DEEP{
          my $offset32 = $self-><M::StringExtended.findOffset32> ($offset);
          my $data1 = $self-><AG::CharacterData.data>;
          my $data2 = substr ($data1, $offset32);
          substr ($data1, $offset32) = '';
 
          $r = $self-><AG::Node.nodeType> == <C::Node.TEXT_NODE>
                 ? $self-><AG::Node.ownerDocument>
                        -><M::Document.createTextNode> ($data2)
                 : $self-><AG::Node.ownerDocument>
                        -><M::Document.createCDATASection> ($data2);
          $r-><AS::Text.isElementContentWhitespace>
                ($self-><AG::Text.isElementContentWhitespace>);
          $self-><AS::CharacterData.data> ($data1);
          if (defined $parent) {
            $parent-><M::Node.insertBefore>
                       ($r, $self-><AG::Node.nextSibling>);
          }
        }__;

    @@Test:
      @@@QName: Text.splitText.1.test
      @@@PerlDef:
        my $node;
        my $doc;
        __CODE{tc|createTextForTest:: $text => $node, $doc => $doc}__;
        $node-><AS::Node.nodeValue> ('abcdefg');

        my $return = $node-><M::Text.splitText> (3);

        $test->id ('1.nodeValue');
        $test->assert_equals ($node-><AG::Node.nodeValue>, 'abc');
        
        $test->id ('2.interface');
        $test->assert_isa ($return, <IFName::Text>);

        $test->id ('2.nodeType');
        $test->assert_num_equals
                 (actual_value => $return-><AG::Node.nodeType>,
                  expected_value => <C::Node.TEXT_NODE>);

        $test->id ('2.nodeValue');
        $test->assert_equals ($return-><AG::Node.nodeValue>, 'defg');

        $test->id ('2.parentNode');
        $test->assert_null ($return-><AG::Node.parentNode>);
    @@Test:
      @@@QName: Text.splitText.2.test
      @@@PerlDef:
        my $node;
        my $doc;
        __CODE{tc|createTextForTest:: $text => $node, $doc => $doc}__;
        $node-><AS::Node.nodeValue> ('abcdefg');

        my $el = $node-><AG::Node.ownerDocument>
                      -><M::Document.createElement> ('e');
        $el-><M::Node.appendChild> ($node);
        
        my $return = $node-><M::Text.splitText> (3);

        $test->id ('1.nodeValue');
        $test->assert_equals ($node-><AG::Node.nodeValue>, 'abc');
        
        $test->id ('2.interface');
        $test->assert_isa ($return, <IFName::Text>);

        $test->id ('2.nodeType');
        $test->assert_num_equals
                 (actual_value => $return-><AG::Node.nodeType>,
                  expected_value => <C::Node.TEXT_NODE>);

        $test->id ('2.nodeValue');
        $test->assert_equals ($return-><AG::Node.nodeValue>, 'defg');

        $test->id ('2.parentNode');
        $test->assert_equals ($return-><AG::Node.parentNode>, $el);
    @@Test:
      @@@QName: CDATASection.splitText.1.test
      @@@PerlDef:
        my $node;
        my $doc;
        __CODE{tx|createCDATASectionForTest:: $text => $node, $doc => $doc}__;
        $node-><AS::Node.nodeValue> ('abcdefg');

        my $return = $node-><M::Text.splitText> (3);

        $test->id ('1.nodeValue');
        $test->assert_equals ($node-><AG::Node.nodeValue>, 'abc');
        
        $test->id ('2.interface');
        $test->assert_isa ($return, <IFName::tx|CDATASection>);

        $test->id ('2.nodeType');
        $test->assert_num_equals
                 (actual_value => $return-><AG::Node.nodeType>,
                  expected_value => <C::Node.CDATA_SECTION_NODE>);

        $test->id ('2.nodeValue');
        $test->assert_equals ($return-><AG::Node.nodeValue>, 'defg');

        $test->id ('2.parentNode');
        $test->assert_null ($return-><AG::Node.parentNode>);
    @@Test:
      @@@QName: CDATASection.splitText.2.test
      @@@PerlDef:
        my $node;
        my $doc;
        __CODE{tx|createCDATASectionForTest:: $text => $node, $doc => $doc}__;
        $node-><AS::Node.nodeValue> ('abcdefg');

        my $el = $node-><AG::Node.ownerDocument>
                      -><M::Document.createElement> ('e');
        $el-><M::Node.appendChild> ($node);
        
        my $return = $node-><M::Text.splitText> (3);

        $test->id ('1.nodeValue');
        $test->assert_equals ($node-><AG::Node.nodeValue>, 'abc');
        
        $test->id ('2.interface');
        $test->assert_isa ($return, <IFName::tx|CDATASection>);

        $test->id ('2.nodeType');
        $test->assert_num_equals
                 (actual_value => $return-><AG::Node.nodeType>,
                  expected_value => <C::Node.CDATA_SECTION_NODE>);

        $test->id ('2.nodeValue');
        $test->assert_equals ($return-><AG::Node.nodeValue>, 'defg');

        $test->id ('2.parentNode');
        $test->assert_equals ($return-><AG::Node.parentNode>, $el);
##Text

IFCls1Def:
  @IFQName: Comment
  @ClsQName: ManakaiDOMComment

  @IFISA: CharacterData
  @ClsISA: ManakaiDOMCharacterData

  @enDesc:
    A <IF::Comment> object represents the content of a comment,
    i.e. all the characters between the starting <XML::<!--> and
    ending <XML::--<gt>> in XML.

    No lexical check is done on the content of a <IF::Comment>
    and it is therefore possible to have the character sequence
    <CODE::--> in the content, which is illegal in a comment
    per XML specification.  Such <IF::Comment> node cannot be
    serialized in XML.

  @enImplNote:
    @@ddid: props
    @@@:
      {P:: Required internal properties:

        - <Q::tc|ownerDocument>.

        - <Q::infoset|content>.

      }

      {P:: Optional internal properties:

        - <Q::infoset|parent>.

        - <Q::c|read-only>.

      }

  @CODE:
    @@QName: tc|createCommentForTest
    @@PerlDef:
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
      $text = $doc-><M::Document.createComment> ('text');

  @CAttr:
    @@Name: nodeType
    @@Type: unsignedShort
    @@dis:actualType: NodeType
    @@Get:
      @@@disDef:
        @@@@DISLang:constValue: Node.COMMENT_NODE

    @@Test:
      @@@QName: Comment.nodeType.test
      @@@PerlDef:
        my $text;
        my $doc;
        __CODE{tc|createCommentForTest:: $text => $text, $doc => $doc}__;

        $test->id ('nodeType');
        $test->assert_num_equals
                 (actual_value => $text-><AG::Node.nodeType>,
                  expected_value => <C::Node.COMMENT_NODE>);

  @Test:
    @@QName: Comment.parentNode.1.test
    @@PerlDef:
      my $text;
      my $doc;
      __CODE{tc|createCommentForTest:: $text => $text, $doc => $doc}__;

      $test->assert_null ($text-><AG::Node.parentNode>);

  @Test:
    @@QName: Comment.isSameNode.1.test
    @@PerlDef:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

      my $el = $doc-><M::Document.createComment> ('a');

      my $el2 = $doc-><M::Document.createComment> ('a');
      
      $test->id ('same');
      $test->assert_equals ($el, $el);
      
      $test->id ('diff');
      $test->assert_not_equals ($el, $el2);
      
      $test->id ('doc');
      $test->assert_not_equals ($el, $doc);
  @Test:
    @@QName: Comment.isSameNode.2.test
    @@PerlDef:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

      my $el = $doc-><M::Document.createComment> ('a');

      my $el2 = $doc-><M::Document.createComment> ('a');
      
      $test->id ('same');
      $test->assert_true ($el-><M::Node.isSameNode> ($el));
      
      $test->id ('diff');
      $test->assert_false ($el-><M::Node.isSameNode> ($el2));
      
      $test->id ('doc');
      $test->assert_false ($el-><M::Node.isSameNode> ($doc));

  @Test:
    @@QName: Comment.readOnly.test
    @@PerlDef:
      my $text;
      my $doc;
      __CODE{tc|createCommentForTest:: $text => $text, $doc => $doc}__;

      $test->id ('default');
      $test->assert_false ($text-><AG::Node.manakaiReadOnly>);
  
  @CAttr:
    @@Name: nodeName
    @@enDesc:
      The node name.
    @@DOMMain:isNamespaceUnaware:1
    @@Type: DOMString
    @@DOMMain:isNamespaceUnaware:1
    @@Get:
      @@@disDef: 
        @@@@DISLang:value:
          @@@@@@: \#comment
          @@@@@ContentType:
            DISCore:String

    @@Test:
      @@@QName: Comment.nodeName.test
      @@@PerlDef:
        my $text;
        my $doc;
        __CODE{tc|createCommentForTest:: $text => $text, $doc => $doc}__;

        $test->assert_equals ($text-><AG::Node.nodeName>, '#comment');

  @Test:
    @@QName: Comment.appendChild.test
    @@PerlDef:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
      my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

      my $comment = $doc-><M::Document.createComment> ('data');
      my $node2 = $doc-><M::Document.createComment> ('data');

      for my $node (<Code::tc|createNodesForTest+dt>) {
        $test->id ('appendChild.'.$node-><AG::Node.nodeType>);
        $test->assert_exception (code => sub {  
          $comment-><M::Node.appendChild> ($node);
        }, exception_subtype => <Q::MDOMX|HIERARCHY_BAD_TYPE>);

        $test->id ('insertBefore.'.$node-><AG::Node.nodeType>);
        $test->assert_exception (code => sub {  
          $comment-><M::Node.insertBefore> ($node);
        }, exception_subtype => <Q::MDOMX|HIERARCHY_BAD_TYPE>);

        $test->id ('replaceChild.'.$node-><AG::Node.nodeType>);
        $test->assert_exception (code => sub {  
          $comment-><M::Node.replaceChild> ($node, $node2);
        }, exception_subtype => <Q::MDOMX|HIERARCHY_BAD_TYPE>);
      }

  @Test:
    @@QName: Comment..=.1.test
    @@PerlDef:
      my $doc;
      __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;

      my $node = $doc-><M::Document.createComment> ('');

      $node-><M::Node.manakaiAppendText> ('aaaa');
      $test->id ('1.class');
      $test->assert_isa ($node, <IFName::Comment>);
      $test->id ('1.value');
      $test->assert_equals ($node-><AG::CharacterData.data>, 'aaaa');

      $test->id (2);
      $node-><M::Node.manakaiAppendText> ('bbbb');
      $test->assert_equals ($node-><AG::CharacterData.data>, 'aaaabbbb');

  @CL3Method:
    @@Name: getFeature
    @@enDesc:
      Returns a specialized object that implements the specialized APIs.
    @@Param:
      @@@Name: feature
      @@@Type: DOMString
      @@@dis:actualType: f|FeatureNameString
    @@Param:
      @@@Name: version
      @@@Type: DOMString
      @@@dis:actualType: f|FeatureVersionString
    @@Return:
      @@@Type: DOMMain|DOMObject
      @@@nullCase:
      @@@PerlDef:
        $feature =~ s/^\+//;
        __CODE{f|getFeatureImpl::
          $self => $self,
          $feature => $feature, $version => $version, $r => $r,
          $base_class => {<ClassName::ManakaiDOMComment>},
        }__;
        unless (defined $r) {
          __DEEP{
            $r = $self->SUPER::get_feature ($feature, $version);
          }__;
        }

    @@Test:
      @@@QName: Comment.getFeature.test
      @@@PerlDef:
        my $node;
        my $doc;
        __CODE{tc|createCommentForTest:: $text => $node, $doc => $doc}__;

        for (
          [Core => '1.0', <IFName::Comment||ManakaiDOM|ManakaiDOM1>],
          [Core => '2.0', <IFName::Comment||ManakaiDOM|ManakaiDOM2>],
          [Core => '3.0', <IFName::Comment||ManakaiDOM|ManakaiDOM3>],
          [XML => '1.0', <IFName::Comment||ManakaiDOM|ManakaiDOM1>],
          [XML => '2.0', <IFName::Comment||ManakaiDOM|ManakaiDOM2>],
          [XML => '3.0', <IFName::Comment||ManakaiDOM|ManakaiDOM3>],
        ) {
          $test->id ($_->[0].'.'.$_->[1]);
          my $sp = $node-><M::Node.getFeature> ($_->[0], $_->[1]);
          $test->assert_isa ($sp, $_->[2]);
        }

  @Test:
    @@QName: Comment.baseURI.test
    @@PerlDef:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $pi = $doc-><M::Document.createComment> ('data');
       
        $test->id ('default');
        $test->assert_null ($pi-><AG::Node.baseURI>);

        $test->id ('doc');
        $doc-><AS::Document.documentURI> (q<http://doc.test/>);
        $test->assert_equals
                 ($pi-><AG::Node.baseURI>,
                  q<http://doc.test/>);

        $test->id ('el');
        my $el = $doc-><M::Document.createElementNS> (null, 'e');
        $el-><M::Element.setAttributeNS> (<Q::xml:>, 'xml:base',
                                          q<http://el.test/>);
        $el-><M::Node.appendChild> ($pi);
        $test->assert_equals
                 ($pi-><AG::Node.baseURI>,
                  q<http://el.test/>);

        $test->id ('ent');
        my $ent = $doc-><M::Document.createEntityReference> ('ent');
        $ent-><M::Node.manakaiSetReadOnly> (false, true);
        $ent-><AS::tx|EntityReference.manakaiExternal> (true);
        $ent-><AS::tx|EntityReference.manakaiEntityBaseURI>
                (q<http://ent.test/>);
        $el-><M::Node.appendChild> ($ent);
        $ent-><M::Node.appendChild> ($pi);
        $test->assert_equals
                 ($pi-><AG::Node.baseURI>,
                  q<http://ent.test/>);
##Comment


IF2Def:
  @IFQName: StringExtended

  @enDesc:
    The <IF::StringExtended> interface, defined in an informative
    appendix of DOM Level 2 and 3 Core specifications, provides
    extensions to a language's native <CODE::Strign>
    class or interface.

    In DOM characters are represented in Unicode by numbers
    called <DFN::code point>s.  These numbers can range from
    <CODE::U+0000> up to <CODE::U+10FFFF> (although some of these
    values are illegal).  However, since the DOM specification
    uses UTF-16, in which characters that have values less than
    or equal to <CODE::U+FFFF> are represented by a single 16-bit
    code unit, while characters above <CODE::U+FFFF> use pairs
    of code units called as <DFN::surrogate pair>s.

    Some specifications other than DOM, such as XPath and XML Schema,
    use code point indices rather than code unit indices.  For
    interfacing with such formats it is recommended by the DOM
    specification that the programming language provides string
    processing methods for converting code point indeces to
    code unit indices and back.  Some languages do not provide
    these functions natively; for these it is recommended
    that the native <CODE::String> type that is bound to
    the <TYPE::DOMString> type be extended to enable these conversions.
    The <IF::StringExtended> interface is an example of such API.

        {NOTE::
          It is always possible to round-trip from a UTF-32
          offset to a UTF-16 offset and back.  However, it is 
          possible to round-trip from a UTF-16 offset to a UTF-32
          offset and back if and only if the <P::offset16> is
          not in the middle of a surrogate pair.  Unmatched
          surrogates count as a single UTF-16 value.
        }

  @L2Method:
    @@Name: findOffset16
    @@dlp:methodName: find_offset16
    @@enDesc:
      Returns the UTF-16 offset that corresponding to a UTF-32
      offset.
    @@Param:
      @@@Name: offset32
      @@@Type:
        @@@@@: unsignedLong
        @@@@enImplNote:
          {SpecIssue:: <CODE::int> in the spec.
          }
      @@@enDesc:
        The UTF-32 offset.
    @@Return:
      @@@Type:
        @@@@@: unsignedLong
        @@@@enImplNote:
          {SpecIssue:: <CODE::int> in the spec.
          }
      @@@enDesc:
        The UTF-16 offset.
      @@@dx:raises:
        @@@@@: c|StringIndexOutOfBoundsException
        @@@@enDesc:
          If the <P::offset32> is out of bound.
  
  @L2Method:
    @@Name: findOffset32
    @@dlp:methodName: find_offset32
    @@enDesc:
      Returns the UTF-32 offset corresponding to a UTF-16 offset.

        {eg::  
          {P:: A pseudo-code

             {CODE::<html5:var::len32> = findOffset32 (<html5:var
                    ::str>, <html5:var::str>.length);
             }

               would return the number of characters in
               the string <html5:var::str>.
          }
        }
    @@Param:
      @@@Name: offset16
      @@@Type:
        @@@@@: unsignedLong
        @@@@enImplNote:
          {SpecIssue:: <CODE::int> in the spec.
          }
      @@@enDesc:
        The UTF-16 offset.
    @@Return:
      @@@Type:
        @@@@@: unsignedLong
        @@@@enImplNote:
          {SpecIssue:: <CODE::int> in the spec.
          }
      @@@enDesc:
        The UTF-32 offset.

        If the UTF-16 offset is into the middle of a surrogate pair,
        then the UTF-32 offset of the <EM::end> of the pair
        is returned; that is, the index of the character
        after the end of the pair.  
      @@@dx:raises:
        @@@@@: c|StringIndexOutOfBoundsException
        @@@@enDesc:
          If the <P::offset16> is out of bound.
##StringExtended
