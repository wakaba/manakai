Module:
  @QName: MDOM|Tree
  @enFN:
    DOM Tree Module
  @enDesc:
    The manakai DOM Tree Module implements a part of the W3C DOM
    Core module related to tree structural model for HTML or XML documents.

  @Namespace:
    http://suika.fam.cx/~wakaba/archive/2004/dom/tree#

  @DISCore:author: DISCore|Wakaba
  @License: license|Perl+MPL
  @Date:
    $Date: 2006/02/13 17:03:21 $

  @Require:
    @@Module:
      @@@QName: MDOM|DOMCore
    @@Module:
      @@@WithFor: ManakaiDOM|ManakaiDOM
    @@Module:
      @@@WithFor: ManakaiDOM|ManakaiDOM1
    @@Module:
      @@@WithFor: ManakaiDOM|ManakaiDOM2
    @@Module:
      @@@WithFor: ManakaiDOM|ManakaiDOM3
    @@Module:
      @@@WithFor: ManakaiDOM|ManakaiDOMLatest
    @@Module:
      @@@QName: MDOM|DOMXML
    @@Module:
      @@@QName: MDOM|XDoctype
      @@@WithFor: ManakaiDOM|ManakaiDOMLatest

  @DefaultFor: ManakaiDOM|ManakaiDOMLatest

Namespace:
  @c:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#
  @cfg:
    http://suika.fam.cx/www/2006/dom-config/
  @dis:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#dis--
  @doc:
    http://suika.fam.cx/~wakaba/archive/2005/7/tutorial#
  @d:
    http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#
  @DOMMain:
    http://suika.fam.cx/~wakaba/archive/2004/dom/main#
  @dx:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#
  @dxm:
    http://suika.fam.cx/~wakaba/archive/2004/dis/XML#
  @ecore:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/Core/
  @ev:
    http://www.w3.org/2001/xml-events
  @f:
    http://suika.fam.cx/~wakaba/archive/2004/dom/feature#
  @html5:
    http://www.w3.org/1999/xhtml
  @idl:
    http://suika.fam.cx/~wakaba/archive/2004/dis/IDL#
  @infoset:
    http://www.w3.org/2001/04/infoset#
  @kwd:
    http://suika.fam.cx/~wakaba/archive/2005/rfc2119/
  @lang:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#
  @license:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/license#
  @ManakaiDOM:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#
  @ManakaiDOMCore:
    http://suika.fam.cx/~wakaba/archive/2004/mdom-core#
  @ManakaiDOMXML:
    http://suika.fam.cx/~wakaba/archive/2004/mdom-xml#
  @MDOM:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#ManakaiDOM.
  @MDOMX:
    http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#
  @mn:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/ManakaiNode#
  @null:
    http://suika.fam.cx/~wakaba/-temp/2003/09/27/null
  @rdf:
    http://www.w3.org/1999/02/22-rdf-syntax-ns#
  @rdfs:
    http://www.w3.org/2000/01/rdf-schema#
  @sw010:
    urn:x-suika-fam-cx:markup:suikawiki:0:10:
  @t:
    http://suika.fam.cx/~wakaba/archive/2004/dom/tree#
  @test:
    http://suika.fam.cx/~wakaba/archive/2004/dis/Test#
  @x:
    http://suika.fam.cx/~wakaba/archive/2004/dom/xml#
  @xhtml1:
    http://www.w3.org/1999/xhtml
  @xml:
    http://www.w3.org/XML/1998/namespace
  @xml-dtd:
    http://www.w3.org/TR/REC-xml
  @xmlns:
    http://www.w3.org/2000/xmlns/

ElementTypeBinding:
  @Name: Exception
  @ElementType:
    dis:ImplNote
  @ShadowContent:
    @@For: !ManakaiDOM|all

ElementTypeBinding:
  @Name: raises
  @ElementType:
    dx:raises

ElementTypeBinding:
  @Name: ClsDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      @@@@: dis|MultipleResource
      @@@ForCheck: !ManakaiDOM|ForIF !ManakaiDOM|ForClass
    @@resourceFor:
      @@@@: ManakaiDOM|ForClass
      @@@ForCheck: ManakaiDOM|ManakaiDOM !=ManakaiDOM|ManakaiDOM
    @@For: ManakaiDOM|DOM1
    @@For: =ManakaiDOM|ManakaiDOM

    @@rdf:type:
      @@@@: DISLang|Class
      @@@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: L1
  @ElementType:
    dis:ImplNote

ElementTypeBinding:
  @Name: L2
  @ElementType:
    dis:ImplNote

ElementTypeBinding:
  @Name: L3
  @ElementType:
    dis:ImplNote

ElementTypeBinding:
  @Name: BlockCode
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISPerl|BlockCode

ElementTypeBinding:
  @Name: Method
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Method
    @@ForCheck: !=ManakaiDOM|ManakaiDOM

ElementTypeBinding:
  @Name: L2Method
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Method
    @@ForCheck: !=ManakaiDOM|ManakaiDOM ManakaiDOM|DOM2

ElementTypeBinding:
  @Name: L3Method
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Method
    @@ForCheck: !=ManakaiDOM|ManakaiDOM ManakaiDOM|DOM3

ElementTypeBinding:
  @Name: IntMethod
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Method
    @@ForCheck:
      ManakaiDOM:ManakaiDOM !=ManakaiDOM:ManakaiDOM ManakaiDOM|ForClass
    @@ManakaiDOM:isForInternal: 1

ElementTypeBinding:
  @Name: IntMethodC
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Method
    @@ForCheck:
      ManakaiDOM:ManakaiDOM !=ManakaiDOM:ManakaiDOM
    @@ManakaiDOM:isForInternal: 1

ElementTypeBinding:
  @Name: ReMethod
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Method
    @@ForCheck:
      ManakaiDOM:ManakaiDOM !=ManakaiDOM:ManakaiDOM ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: Param
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|MethodParameter

ElementTypeBinding:
  @Name: Return
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|MethodReturn

ElementTypeBinding:
  @Name: Attr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Attribute
    @@ForCheck: !=ManakaiDOM|ManakaiDOM

ElementTypeBinding:
  @Name: IntAttr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Attribute
    @@ForCheck: ManakaiDOM|ForClass
    @@ManakaiDOM:isForInternal: 1

ElementTypeBinding:
  @Name: L2Attr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Attribute
    @@ForCheck: !=ManakaiDOM|ManakaiDOM ManakaiDOM|DOM2

ElementTypeBinding:
  @Name: L3Attr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Attribute
    @@ForCheck: !=ManakaiDOM|ManakaiDOM ManakaiDOM|DOM3
  ## Note that there are attributes introduced in DOM Level 3
  ## but also defined for lower levels as internal attributes
  ## for the purpose of internal use.

ElementTypeBinding:
  @Name: ReAttr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Attribute
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: Get
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|AttributeGet

ElementTypeBinding:
  @Name: Set
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|AttributeSet

ElementTypeBinding:
  @Name: InCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:InCase

ElementTypeBinding:
  @Name: nullCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:InCase
    @@Value:
      @@@is-null:1

ElementTypeBinding:
  @Name: ConstGroup
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|ConstGroup
    @@ForCheck: ManakaiDOM|ForIF !=ManakaiDOM|ManakaiDOM

ElementTypeBinding:
  @Name: Const
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Const

ElementTypeBinding:
  @Name: SubType
  @ElementType:
    dis:ImplNote

ElementTypeBinding:
  @Name: PerlDef
  @ElementType:
    dis:Def
  @ShadowContent:
    @@ContentType:
      lang:Perl
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: PerlDefC
  @ElementType:
    dis:Def
  @ShadowContent:
    @@ContentType:
      lang:Perl

ElementTypeBinding:
  @Name: XML2Feature
  @ElementType:
    dis:ImplNote
  @ShadowContent:
    @@ImplNote:
      @@@lang:en
      @@@@:
        The <CITE::DOM Level 2 Core> specification said that HTML-only 
        DOM Level 2 implementations does not need to implement this member. 
        The DOM Level 2 Errata withdraws it and it requires HTML-only 
        DOM implementations throw a <X::DOMException.NOT_SUPPORTED_ERR>. 

ElementTypeBinding:
  @Name: enImplNote
  @ElementType:
    dis:ImplNote
  @ShadowContent:
    @@lang:en

ElementTypeBinding:
  @Name: enFN
  @ElementType:
    dis:FullName
  @ShadowContent:
    @@lang:en

ElementTypeBinding:
  @Name: NodeTypeDef
  @ElementType: 
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      @@@@: dis|MultipleResource
      @@@ForCheck: !ManakaiDOM|ForIF !ManakaiDOM|ForClass
    @@resourceFor: ManakaiDOM|ForIF
    @@resourceFor:
      @@@@: ManakaiDOM|ForClass
      @@@ForCheck: ManakaiDOM|ManakaiDOM !=ManakaiDOM|ManakaiDOM
    @@For: ManakaiDOM|DOM1
    @@For: =ManakaiDOM|ManakaiDOM

    @@rdf:type:
      @@@@: DISLang|Interface
      @@@ForCheck: ManakaiDOM|ForIF

    @@rdf:type:
      @@@@: DISLang|Class
      @@@ForCheck: ManakaiDOM|ForClass

    @@ISA:
      @@@@: Node
      @@@ForCheck: ManakaiDOM|ForIF
    @@ISA:
      @@@@: ManakaiDOMNode
      @@@ForCheck: ManakaiDOM|ForClass

    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOM||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOM1||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM1
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOM2||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM2
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOM3||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM3
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOMLatest||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOMLatest

    @@DOMMain:implementFeature:
      @@@@: DOMCore|CoreFeature10
      @@@For: ManakaiDOM|DOM1
    @@DOMMain:implementFeature:
      @@@@: DOMCore|CoreFeature20
      @@@For: ManakaiDOM|DOM2
    @@DOMMain:implementFeature:
      @@@@: DOMCore|CoreFeature30
      @@@For: ManakaiDOM|DOM3
    @@DOMMain:implementFeature:
      @@@@: DOMXML|XMLFeature10
      @@@For: ManakaiDOM|DOM1 ManakaiDOM|DOMXMLFeature
    @@DOMMain:implementFeature:
      @@@@: DOMXML|XMLFeature20
      @@@For: ManakaiDOM|DOM2 ManakaiDOM|DOMXMLFeature
    @@DOMMain:implementFeature:
      @@@@: DOMXML|XMLFeature30
      @@@For: ManakaiDOM|DOM3 ManakaiDOM|DOMXMLFeature
    @@DOMMain:implementFeature:
      @@@@: DOMXML|XMLVersionFeature10
      @@@For: ManakaiDOM|DOM3 ManakaiDOM|DOMXMLFeature
    @@DOMMain:implementFeature:
      @@@@: DOMXML|XMLVersionFeature11
      @@@For: ManakaiDOM|DOM3 ManakaiDOM|DOMXMLFeatureXML11


ElementTypeBinding:
  @Name: IFCls1Def
  @ElementType: 
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      @@@@: dis|MultipleResource
      @@@ForCheck: !ManakaiDOM|ForIF !ManakaiDOM|ForClass
    @@resourceFor: ManakaiDOM|ForIF
    @@resourceFor:
      @@@@: ManakaiDOM|ForClass
      @@@ForCheck: ManakaiDOM|ManakaiDOM !=ManakaiDOM|ManakaiDOM
    @@For: ManakaiDOM|DOM1
    @@For: =ManakaiDOM|ManakaiDOM

    @@rdf:type:
      @@@@: DISLang|Interface
      @@@ForCheck: ManakaiDOM|ForIF

    @@rdf:type:
      @@@@: DISLang|Class
      @@@ForCheck: ManakaiDOM|ForClass
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOM||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOM1||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM1
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOM2||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM2
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOM3||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM3
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOMLatest||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOMLatest

    @@f:implements:
      @@@@: c|CoreFeature10
      @@@For: ManakaiDOM|DOM1
    @@f:implements:
      @@@@: c|CoreFeature20
      @@@For: ManakaiDOM|DOM2
    @@f:implements:
      @@@@: c|CoreFeature30
      @@@For: ManakaiDOM|DOM3
    @@f:implements:
      @@@@: DOMXML|XMLFeature10
      @@@For: ManakaiDOM|DOM1 ManakaiDOM|DOMXMLFeature
    @@f:implements:
      @@@@: DOMXML|XMLFeature20
      @@@For: ManakaiDOM|DOM2 ManakaiDOM|DOMXMLFeature
    @@f:implements:
      @@@@: DOMXML|XMLFeature30
      @@@For: ManakaiDOM|DOM3 ManakaiDOM|DOMXMLFeature
    @@f:implements:
      @@@@: DOMXML|XMLVersionFeature10
      @@@For: ManakaiDOM|DOM3 ManakaiDOM|DOMXMLFeature
    @@f:implements:
      @@@@: DOMXML|XMLVersionFeature11
      @@@For: ManakaiDOM|DOM3 ManakaiDOM|DOMXMLFeatureXML11


ElementTypeBinding:
  @Name: IFQName
  @ElementType:
    dis:QName
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForIF

ElementTypeBinding:
  @Name: ClsQName
  @ElementType:
    dis:QName
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass


ElementTypeBinding:
  @Name: IFISA
  @ElementType:
    dis:ISA
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForIF

ElementTypeBinding:
  @Name: ClsISA
  @ElementType:
    dis:ISA
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass


ResourceDef:
  @QName: NodeStem
  @AliasFor: ManakaiNode|NodeStem||ManakaiDOM|Perl
  @For: ManakaiDOM|ManakaiDOM !=ManakaiDOM|ManakaiDOM

ResourceDef:
  @QName: NodeRef
  @AliasFor: ManakaiNode|NodeRef||ManakaiDOM|Perl
  @For: ManakaiDOM|ManakaiDOM !=ManakaiDOM|ManakaiDOM

ElementTypeBinding:
  @Name: disDef
  @ElementType:
    dis:Def
  @ShadowContent:
    @@ContentType:
      lang:dis
    @@ForCheck: ManakaiDOM|ForClass

ResourceDef:
  @QName: c|Node
  @AliasFor: Node
  @For: ManakaiDOM|DOM

ResourceDef:
  @QName: DOMException
  @AliasFor: c|DOMException
  @For: ManakaiDOM|DOM

ResourceDef:
  @QName: c|ManakaiDOMNode
  @AliasFor: ManakaiDOMNode
  @For: ManakaiDOM|ManakaiDOM !=ManakaiDOM|ManakaiDOM
  @ForCheck: !=ManakaiDOM|all

IFCls1Def:
  @IFQName: Node
  @ClsQName: ManakaiDOMNode

  @enDesc:
    The <IF::Node> interface is the primary datatype for the entire 
    document object model.  It represents a single node in the 
    document tree.

    The <IF::Node> interface is not implemented alone; the <IF::Node>
    objects are expected to implement one or more additional
    interfaces according to its node type.  For example, a node
    whose <A::Node.nodeType> equals to <C::Node.ELEMENT_NODE>
    would also implement the <IF::Element> interface.

  @IsFinal:
    @@@: -1
    @@ForCheck:
      ManakaiDOM:ForClass

  @ClsISA: ManakaiNode|ManakaiNodeRef||ManakaiDOM|Perl
  @ClsISA: ManakaiDOM|ManakaiDOMObject

  @ConstGroup:
    @@QName: NodeType

    @@rdfs:subClassOf: idl|unsignedShort||ManakaiDOM|all
    @@Type: idl|unsignedShort||ManakaiDOM|all

   @@enDesc:
     Constant values in this group are integers indicating of which
     type a node is.

     {NOTE:: Numeric codes up to 200 are reserved to W3C
             for possible future use <SRC::<CITE::DOM Level 3 Core>>.
     }

     @@Const:
        @@@Name:  ELEMENT_NODE
        @@@intValue:  1
        @@@Description:
          @@@@lang:en
          @@@@@: 
            The node is an <IF::Element>.
     @@Const:
        @@@Name:  ATTRIBUTE_NODE
        @@@intValue:  2
        @@@Description:
          @@@@lang:en
          @@@@@: 
            The node is an <IF::Attr>.
     @@Const:
        @@@Name:  TEXT_NODE
        @@@intValue:  3
        @@@Description:
          @@@@lang:en
          @@@@@: 
            The node is a <IF::Text>.
     @@Const:
        @@@Name:  CDATA_SECTION_NODE
        @@@intValue:  4
        @@@Description:
          @@@@lang:en
          @@@@@: 
            The node is a <IF::DOMXML:CDATASection>.
     @@Const:
        @@@Name:  ENTITY_REFERENCE_NODE
        @@@intValue:  5
        @@@Description:
          @@@@lang:en
          @@@@@: 
            The node is an <IF::DOMXML:EntityReference>.
     @@Const:
        @@@Name:  ENTITY_NODE
        @@@intValue:  6
        @@@Description:
          @@@@lang:en
          @@@@@: 
            The node is an <IF::DOMXML:Entity>.
     @@Const:
        @@@Name:  PROCESSING_INSTRUCTION_NODE
        @@@intValue:  7
        @@@Description:
          @@@@lang:en
          @@@@@: 
            The node is a <IF::DOMXML:ProcessingInstruction>.
     @@Const:
        @@@Name:  COMMENT_NODE
        @@@intValue:  8
        @@@Description:
          @@@@lang:en
          @@@@@: 
            The node is a <IF::Comment>.
     @@Const:
        @@@Name:  DOCUMENT_NODE
        @@@intValue:  9
        @@@Description:
          @@@@lang:en
          @@@@@: 
            The node is a <IF::Document>.
     @@Const:
        @@@Name:  DOCUMENT_TYPE_NODE
        @@@intValue:  10
        @@@Description:
          @@@@lang:en
          @@@@@: 
            The node is a <IF::DOMXML:DocumentType>.
     @@Const:
        @@@Name:  DOCUMENT_FRAGMENT_NODE
        @@@intValue:  11
        @@@Description:
          @@@@lang:en
          @@@@@: 
            The node is a <IF::DocumentFragment>.
     @@Const:
        @@@Name:  NOTATION_NODE
        @@@intValue:  12
        @@@Description:
          @@@@lang:en
          @@@@@: 
            The node is a <IF::DOMXML:Notation>.

    @@Const:
      @@@Name: ELEMENT_TYPE_DEFINITION_NODE
      @@@intValue: 81001
      @@@enDesc:
        The node is a <IF::d|ElementTypeDefinition>.
      @@@For: ManakaiDOM|ManakaiDOMLatest
    @@Const:
      @@@Name: ATTRIBUTE_DEFINITION_NODE
      @@@intValue: 81002
      @@@enDesc:
        The node is a <IF::d|AttributeDefinition>.
      @@@For: ManakaiDOM|ManakaiDOMLatest

  @Attr:
     @@Name:  nodeName
     @@Description:
        @@@lang:en
        @@@@: 
          The name of this node. 
     @@DOMMain:isNamespaceUnaware:1
     @@IsFinal: -1
     @@Get:
        @@@Type:  
          DOMMain:DOMString

  @Attr:
     @@Name:  nodeValue
     @@Description:
       @@@lang:en
       @@@@: The value of this node.
     @@Type:  
        DOMMain:DOMString
     @@Get:
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: DOMSTRING_SIZE_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: 
              This attribute would return more characters than fit 
              in a <TYPE::DOMMain:DOMString> variable on the implementation 
              platform. 
        @@@PerlDef: $r = null;
     @@Set:
       @@@enDesc:
         The new node value.
       @@@raises:
         @@@@@: DOMException.NO_MODIFICATION_ALLOWED_ERR
         @@@@enDesc:
           If the node is read-only and its <A::Node.nodeValue>
           is <EM::not> defined as <DOM::null>.
       @@@c:reports:
         @@@@@: c|setting-node-value-no-effect
         @@@@enDesc:
           Setting the attribute value has no effect, since the
           node value is defined as <DOM::null>.
         @@@@enImplNote:
           In this case, <X::DOMException.NO_MODIFICATION_ALLOWED_ERR>
           exception is never thrown.  This is clarified by the 
           DOM Level 2 Core errata.
         @@@@For: ManakaiDOM|ManakaiDOM
       @@@PerlDef:
         __c|ERROR{t|setting-node-value-no-effect::
              c|relatedData => {$self},
         }__;

       @@@L3Test:
         @@@@QName: Node.nodeValue.Set.null.noEffect.Test
         @@@@enDesc:
           This test ensures that attempts to set <A::Node.nodeValue>
           of <IF::Element> or <IF::Document> node never change its value
           and warnings are reported.

             {NOTE:: This test is restricted to DOM Level 3 or higher,
                     since the <IF::c|DOMError> interface is introduced
                     in that level of DOM.
             }
         @@@@PerlDef:
           my $impl = <Class::c|ManakaiDOMImplementation>->_new;
           my $doc = $impl-><M::c|DOMImplementation.createDocument>
                              ('http://www.example/', 'ex');

           my $eh_called = 0;
           my $current_node;

           my $cfg = $doc-><AG::Document.domConfig>;
           $cfg-><M::c|DOMConfiguration.setParameter> ('error-handler' => sub {
             my (undef, $err) = @_;
             $eh_called++;
             $test->assert_equals ($err-><AG::c|DOMError.severity>,
                                   <C::c|DOMError.SEVERITY_WARNING>);
             $test->assert_equals ($err-><AG::c|DOMError.type>,
                                   <Q::t|setting-node-value-no-effect>);
             $test->assert_equals ($err-><AG::c|DOMError.relatedData>,
                                   $current_node);
             $test->assert_null ($err-><AG::c|DOMError.relatedException>);
             $test->assert_isa ($err-><AG::c|DOMError.location>,
                                <IFName::c|DOMLocator>);
             $test->assert_not_null ($err-><AG::c|DOMError.message>);
           });

           my $del = $doc-><AG::Document.documentElement>;
           $current_node = $del;
           $del-><AS::Node.nodeValue> ('non-null value');

           $test->assert_null ($del-><AG::Node.nodeValue>);
           $test->assert_equals ($eh_called, 1);

           $current_node = $doc;
           $doc-><AS::Node.nodeValue> ('non-null value');
            
           $test->assert_equals ($doc-><AG::Node.nodeValue>);
           $test->assert_equals ($eh_called, 2);

           $current_node = null;

  @Attr:
     @@Name:  nodeType
     @@Description:
       @@@lang:en
       @@@@: The type of this node.
     @@IsFinal: -1
     @@Get:
        @@@Type:  
          DOMMain:unsigned-short||ManakaiDOM|all
        @@@actualType: NodeType
        @@@Description:
          @@@@lang:en
          @@@@@: 
            A code representing the type of the underlying object. 
       @@@PerlDef: \
  @Attr:
     @@Name:  parentNode
     @@Description:
       @@@lang:en
       @@@@: The parent of this node.
     @@Type: Node
     @@actualType: ManakaiDOMNode
     @@Get:
        @@@Description:
          @@@@lang:en
          @@@@@: The parent node.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              This node does not have a parent, since either the type 
              of this node is <IF::Attr>, <IF::Document>, 
              <IF::DocumentFragment>, <IF::DOMXML:Entity> or 
              <IF::DOMXML:Notation>, this node has just been created 
              and not yet added to any tree, or it has been removed 
              from the tree. 
        @@@disDef:
          @@@@GetPropNode:
            infoset:parent
    @@Level[list]:
      1
      2
      3
    @@SpecLevel:1
  @Attr:
     @@Name:  childNodes
     @@Description:
       @@@lang:en
       @@@@:
         A list of node that contains all children of this node.
     @@Get:
        @@@Type: NodeList
        @@@actualType:
          ManakaiDOMCore:ManakaiDOMChildNodeList
        @@@Description:
          @@@@lang:en
          @@@@@:
            A <IF::NodeList> object.
        @@@InCase:
          @@@@Label:
            @@@@@lang:en
            @@@@@@:
              A <IF::NodeList> containing no nodes
          @@@@Type: NodeList
          @@@@actualType:
            ManakaiDOMCore:ManakaiDOMChildNodeList
          @@@@Description:
            @@@@@lang:en
            @@@@@@: This node has no child node.
        @@@PerlDef:
          __CODE{getNodeRef::
            $object => {$self->{<H::mn:node>}},
            $ref => $r,
            $class => {<ClassName::ManakaiDOMCore:ManakaiDOMChildNodeList>},
          }__;
     @@SpecLevel:1
     @@Level[list]:
       1
       2
       3
  @Attr:
     @@Name:  firstChild
     @@Description:
       @@@lang:en
       @@@@: The first child of this node.
     @@Get:
        @@@Type:  Node
        @@@actualType: ManakaiDOMNode
        @@@Description:
          @@@@lang:en
          @@@@@: The first child node.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: There is no child node.
        @@@PerlDef:
          $r = $self->{<H::mn:node>}->{<H::infoset:children>}->[0];
          $r = $r ? <ClassM::ManakaiDOMNode.getNodeReference> ($r) : null;
    @@Level[list]:
      1
      2
      3
    @@SpecLevel:1
  @Attr:
     @@Name:  lastChild
     @@Description:
        @@@lang:en
        @@@@: The last child of this node.
     @@Get:
        @@@Type:  Node
        @@@actualType: ManakaiDOMNode
        @@@Description:
          @@@@lang:en
          @@@@@: The last child node.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: There is no child node.
        @@@PerlDef:
          $r = $self->{<H::mn:node>}->{<H::infoset:children>}->[-1];
          $r = $r ? <ClassM::ManakaiDOMNode.getNodeReference> ($r) : null;
     @@Level[list]:
        1
        2
        3
     @@SpecLevel:1
  @Attr:
     @@Name:  previousSibling
     @@Description:
        @@@lang:en
        @@@@:
          The node immediately preceding this node.
     @@Get:
        @@@Type:  Node
        @@@actualType: ManakaiDOMNode
        @@@Description:
          @@@@lang:en
          @@@@@: The node immediately preceding this node.
        @@@InCase:
          @@@@Value:
             @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: There is no such node.
        @@@PerlDef:
          @@@@@:
            if (my $parent = $self->{<H::mn:node>}->{<H::infoset:parent>}) {
              for (@{$parent->{<H::infoset:children>}}) {
                if ($_->{<H::mn:nodeID>} eq
                         $self->{<H::mn:node>}->{<H::mn:nodeID>}) {
                  last;
                } else {
                  $r = $_;
                }
              }
            }
            if ($r) {
              $r = <ClassM::ManakaiDOMNode.getNodeReference> ($r);
            }
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              This code will result in something incorrect when the 
              <Q::infoset:children> of the <Q::infoset:parent> of 
              this node does not have this node (i.e. the tree 
              is broken). 
    @@Level[list]:
      1
      2
      3
    @@SpecLevel:1
  @Attr:
     @@Name:  nextSibling
     @@Description:
        @@@lang:en
        @@@@: The node immediately following this node.
     @@Get:
        @@@Type:  Node
        @@@actualType: ManakaiDOMNode
        @@@Description:
          @@@@lang:en
          @@@@@: The node immediately following this node.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: There is no such node.
        @@@PerlDef:
            if (my $parent = $self->{<H::mn:node>}->{<H::infoset:parent>}) {
              my $next = 0;
              for (@{$parent->{<H::infoset:children>}}) {
                if ($next) {
                  $r = <ClassM::ManakaiDOMNode.getNodeReference> ($_);
                  last;
                } elsif ($_->{<H::mn:nodeID>} eq
                         $self->{<H::mn:node>}->{<H::mn:nodeID>}) {
                  $next = 1;
                }
              }
            }
    @@Level[list]:
      1
      2
      3
    @@SpecLevel:1
  @Attr:
     @@Name:  attributes
     @@Description:
       @@@lang:en
       @@@@:
         A node map containing the attributes of this node.
     @@Get:
        @@@Type: NamedNodeMap
        @@@Description:
          @@@@lang:en
          @@@@@:
            A (possibly empty) <IF::NamedNodeMap> object.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              This node is not of type <IF::Element>.
        @@@PerlDef:\
  @Attr:
     @@Name:  ownerDocument
     @@Description:
       @@@lang:en
       @@@@:
         The <IF::Document> object associated with this node.
     @@Get:
        @@@Type:  Document
        @@@actualType: ManakaiDOMDocument
        @@@Description:
          @@@@lang:en
          @@@@@:
            The owner document object.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Either this node is a <IF::Document> or this node is 
              a <IF::DOMXML:DocumentType> that has just been created 
              and not yet used in any document. 
        @@@disDef:
          @@@@GetPropNode: c|ownerDocument
     @@SpecLevel[list]:
        1
        2
     @@Level[list]:
        1
        2
        3
     @@ImplNote:
       @@@lang:en
       @@@@:
         DOM Level 1 does not have <M::DOMImplementation.createDocumentType> 
         so that DOM Level 1 does not consider a <IF::DOMXML:DocumentType> 
         object without any owner <IF::Document>. 
  @Method:
     @@Name:  insertBefore
     @@Description:
       @@@lang:en
       @@@@:
         Inserts a node just before the existing child node. 
     @@Param:
        @@@Name:  newChild
        @@@Type:  Node
        @@@actualType: ManakaiDOMNode
        @@@Description:
          @@@@lang:en
          @@@@@:
            A node to insert.  If the <P::newChild> is already 
            used in any tree, it is first removed. 
        @@@InCase:
          @@@@Type: DocumentFragment
          @@@@actualType: ManakaiDOMDocumentFragment
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              All the child nodes are inserted, in the same order, 
              to the child list.  After the insertion, the child list 
              of <P::newChild> is to be empty.
          @@@@SpecLevel: 1
     @@Param:
        @@@Name:  refChild
        @@@Type:  Node
        @@@actualType: ManakaiDOMNode
        @@@Description:
          @@@@lang:en
          @@@@@:
            The reference node before which the <P::refChild> 
            (or its children) is inserted. 
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The <P::newChild> is inseted at the end of the list of children. 
        @@@InCase:
          @@@@Label:
            @@@@@lang:en
            @@@@@@:
              <P::newChild> itself
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The result is implementation dependent.
            @@@@@For:
              ManakaiDOM:DOM3
     @@Return:
        @@@Type:  Node
        @@@actualType: ManakaiDOMNode
        @@@Description:
          @@@@lang:en
          @@@@@: The node being inserted.
        @@@ImplNote:
          @@@@lang:en
          @@@@@:
            What should be returned when the "newChild" is a "DocumentFragment" 
            is unclear.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: HIERARCHY_REQUEST_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: 
              Either this node is of a type that does not allow 
              children of the type of the "newChild" node [DOM 1, 2, 3],
              the node to insert is one of ancestors of this node 
              [DOM 1, 2, 3], the node to insert is this node itself
              [DOM 2 Errata, 3], or this node is of type "Document" 
              and the attemption 
              to insert a second "DocumentType" or "Element" node 
              is made [DOM 3].
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@: 
              Special treatment required if it is a "DocumentFragment".
              Whether the node is hierarchically valid must be 
              ensured for each child nodes.
            \
              For example, the attemption to add more than one elements 
              using "DocumentFragment" to the empty "Document" must 
              be detected.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: WRONG_DOCUMENT_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The "newChild" node was created from a different 
              document.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Either this node is read-only [DOM 1, 2, 3] or the parent of 
              the node being inserted is read-only [DOM 1 SE, 2, 3].
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NOT_SUPPORTED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              This node is of type "Document" and the DOM implementation 
              does not support the insertion of a "DocumentType" or 
              "Element" node.
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              While the specification does not address, 
              in case that the parent of the "newChild" is a "Document" 
              and the DOM implementation does not support the 
              removal from it, this error should also be raised.
          @@@@SpecLevel:3
        @@@c:reports:
          @@@@@: t|insert-before-itself
          @@@@enDesc:
            If the <P::newChild> node is same as the <P::refChild> node.
            Then, the result is implementation dependent.

            The manakai implementation only issues a warning in the case.
          @@@@For: ManakaiDOM|ManakaiDOM
        @@@PerlDef:
            my $node;
            my $newNode;
            CHKDOC: {
              if (UNIVERSAL::isa ($newChild, <IFName::Node
                                              ::ManakaiDOM:ManakaiDOM>) and
                  UNIVERSAL::isa ($newChild, <IFName::NodeRef>)) {
                $node = $self->{<H::mn:node>};
                $newNode = $newChild->{<H::mn:node>};
                if ($node->{<H::DOMCore:ownerDocument>}) {
                  if ($newNode->{<H::DOMCore:ownerDocument>}) {
                    last CHKDOC if $node->{<H::DOMCore:ownerDocument>}
                                        ->{<H::mn:nodeID>} eq
                                   $newNode->{<H::DOMCore:ownerDocument>}
                                        ->{<H::mn:nodeID>};
                  }
                } else { ## I'm "Document" or "DocumentType" node.
                  if ($node->{<H::DOMCore:nodeType>} eq <H::infoset:Document>) {
                    last CHKDOC;
                  }
                }
              }
              __EXCEPTION{
                DOMException.WRONG_DOCUMENT_ERR::
                  MDOMX:param-name => 'newChild',
              }__;
            } # CHKDOC
            my @newNode = ($newNode);
            if ($newNode->{<H::DOMCore:nodeType>} eq
                <H::DOMCore:DocumentFragmentNode>) {
       \       @newNode = @{$newNode->{<H::infoset:children>}};
            }
            INSERTION: {
            if (@newNode) {
              my $parentNode = $newNode[0]->{<H::infoset:parent>};

              ## Read-only?
              if ($node->{<H::DOMCore:read-only>}) {
                ## This node is read-only.
                __EXCEPTION{
                  MDOMX:NOMOD_THIS::
                }__;
              } elsif ($parentNode and $parentNode->{<H::DOMCore:read-only>}) {
                ## Parent of new node(s) is read-only
                __EXCEPTION{
                  MDOMX:NOMOD_SRC_PARENT::
                    MDOMX:param-name => 'newChild',
                }__;
              }
              
              ## Check type of this node and new child node
              CHKTYPE: {
                if ({
                      <H::infoset:Element> => 1,
                      <H::DOMCore:DocumentFragmentNode> => 1,
                      <H::DOMXML:EntityNode> => 1,
                      <H::DOMXML:EntityReferenceNode> => 1,
                    }->{$node->{<H::DOMCore:nodeType>}}) {
                  CHILDTYPE: {
                    for (@newNode) {
                      unless ({
                            <H::infoset:Element> => 1,
                            <H::DOMCore:TextNode> => 1,
                            <H::infoset:Comment> => 1,
                            <H::infoset:ProcessingInstruction> => 1,
                            <H::DOMXML:CDATASectionNode> => 1,
                            <H::DOMXML:EntityReferenceNode> => 1,
                          }->{$_->{<H::DOMCore:nodeType>}}) {
                        last CHILDTYPE;
                      }
                    }
                    last CHKTYPE; # No problem
                  }
                } elsif ($node->{<H::DOMCore:nodeType>} eq <H::infoset:Document>) {
                  CHILDTYPE: {
                    my %has;
                    EACHNEWNODE: for my $newNode (@newNode) {
                      if ({
                            <H::infoset:Element> => 1,
                            <H::infoset:DocumentTypeDeclaration> => 1,
                          }->{$newNode->{<H::DOMCore:nodeType>}}) {
                        FOUND: {
                          if ($has{$newNode->{<H::DOMCore:nodeType>}}) {
                            ## DOCTYPE or document element is waiting 
                            ## to be added
                            last FOUND;
                          }
                          for (@{$node->{<H::infoset:children>}}) {
                            ## Document already has a DOCTYPE or doc.element
                            last FOUND if $_->{<H::DOMCore:nodeType>} eq
                                          $newNode->{<H::DOMCore:nodeType>};
                          }
                          $has{$newNode->{<H::DOMCore:nodeType>}} = 1;
                          next EACHNEWNODE;
                        }
                        if ($newNode->{<H::DOMCore:nodeType>} eq
                            <H::infoset:Element>) {
                          __EXCEPTION{
                            MDOMX:MDOM_SECOND_DOC_ELEMENT::
                              MDOMX:param-name => 'newChild',
                          }__;
                        } else { # infoset:DocumentTypeDeclaration
                          __EXCEPTION{
                            MDOMX:MDOM_SECOND_DOCTYPE::
                              MDOMX:param-name => 'newChild',
                          }__;
                        }
                      } elsif (not {
                                 <H::infoset:Comment> => 1,
                                 <H::infoset:ProcessingInstruction> => 1,
                               }->{$newNode->{<H::DOMCore:nodeType>}}) {
                        last CHILDTYPE;
                      }
                    } # EACHNEWNODE
                    last CHKTYPE; # No problem
                  } # CHILDTYPE
                } elsif ($node->{<H::DOMCore:nodeType>} eq
                         <H::infoset:Attribute>) {
                  CHILDTYPE: {
                    for my $newNode (@newNode) {
                      unless ({
                            <H::DOMCore:TextNode> => 1,
                            <H::DOMXML:EntityReferenceNode> => 1,
                          }->{$newNode->{<H::DOMCore:nodeType>}}) {
                        last CHILDTYPE;
                      }
                    }
                    last CHKTYPE; # No problem
                  }
                } # $node->{< Q::DOMCore:nodeType>}


                __FOR{ManakaiDOM:ManakaiDOMLatest::
                  if ($node->{<H::c|nodeType>} eq
                      <H::infoset:DocumentTypeDeclaration>) {
                    CHILDTYPE: {
                      for my $newNode (@newNode) {
                        unless ({
                                  <H::infoset:ProcessingInstruction> => true,
                                }->{$newNode->{<H::c|nodeType>}}) {
                          last CHILDTYPE;
                        }
                      }
                      last CHKTYPE; # No problem
                    }
                    ## NOTE: PI children of doctype is allowed
                    ##       by manakai XDoctype module.
                  } elsif ($node->{<H::c|nodeType>} eq
                           <H::d|AttributeDefinitionNodeType>) {
                    CHILDTYPE: {
                      for my $newNode (@newNode) {
                        unless ({
                                  <H::c|TextNode> => 1,
                                  <H::DOMXML:EntityReferenceNode> => 1,
                                }->{$newNode->{<H::c|nodeType>}}) {
                          last CHILDTYPE; # Error
                        }
                      }
                      last CHKTYPE; # No problem
                    }
                  }
                }__;

                __EXCEPTION{
                  MDOMX:HIERARCHY_BAD_TYPE::
                    c|nodeType => {$newNode->{<H::c|nodeType>}},
                    MDOMX:param-name => 'newChild',
                }__;
              } # CHKTYPE
              
              ## Check $newNode (not $newNode[0]) = ancestor-or-self::node()
              if (${$node->{<H::mn:treeID>}} eq
                  ${$newNode->{<H::mn:treeID>}}) {
                my $n = $node;
                {
                  if ($newNode->{<H::mn:nodeID>} eq
                      $n->{<H::mn:nodeID>}) {
                    __EXCEPTION{
                      MDOMX:HIERARCHY_ANCESTOR_OR_SELF::
                        MDOMX:param-name => 'newChild',
                    }__;
                  }
                  if ($n->{<H::infoset:parent>}) {
                    $n = $n->{<H::infoset:parent>};
                    redo;
                  }
                }
              }
              
              ## Seek the $refChild
              my $newIndex = @{$node->{<H::infoset:children>}};
              REFCHILD: {
                if (defined $refChild) {
                  my $refID = $refChild->{<H::mn:node>}
                                       ->{<H::mn:nodeID>};
                  for my $i (0..$#{$node->{<H::infoset:children>}}) {
                    if ($node->{<H::infoset:children>}->[$i]
                             ->{<H::mn:nodeID>} eq $refID) {
                      $newIndex = $i;
                      last REFCHILD;
                    }
                  }
                  __EXCEPTION{
                    DOMException.NOT_FOUND_ERR::
                      MDOMX:param-name => 'refChild',
                  }__;
                }
              } # REFCHILD
              if ($newNode[0]->{<H::infoset:parent>} and
                  $newNode[0]->{<H::infoset:parent>}->{<H::mn:nodeID>} eq
                  $node->{<H::mn:nodeID>}) {
                if (@newNode > 1) {
                  __EXCEPTION{
                    MDOMX:MDOM_DEBUG_BUG||ManakaiDOM:Perl::
                  }__;
                } elsif (ref $refChild and
                         $newNode[0]->{<H::mn:nodeID>} eq
                         $refChild->{<H::mn:node>}->{<H::mn:nodeID>}) {
                  ## refChild is the same node as the newChild
                  __c:ERROR{t|insert-before-itself::
                    c:relatedData => {$refChild},
                  }__;
                  ## And no action.
                  last INSERTION;
                } else {
                  ## refChild and newChild are siblings each other.
                  my $currentIndex;
                  for my $i (0..$#{$node->{<H::infoset:children>}}) {
                    if ($node->{<H::infoset:children>}->[$i]
                             ->{<H::mn:nodeID>} eq
                        $newNode[0]->{<H::mn:nodeID>}) {
                      $currentIndex = $i;
                    }
                  }
                  ## Changes the position of the newChild in the parent nodelist
                  if ($newIndex < $currentIndex) {
                    splice @{$node->{<H::infoset:children>}}, $currentIndex,
                           1, ();
                    splice @{$node->{<H::infoset:children>}},
                           $newIndex, 1, @newNode;
                  } else {
                    splice @{$node->{<H::infoset:children>}},
                           $newIndex, 1, @newNode;
                    splice @{$node->{<H::infoset:children>}}, $currentIndex,
                           1, ();
                  }
                }
              } else { ## $newChild->parentNode ne $self
                for my $newNode (@newNode) {
                  CORE::delete $newNode->{<H::infoset:parent>};
                  $node-><M::NodeStem.importTree> ($newNode);
                  $newNode->{<H::infoset:parent>} = $node;
                }
                splice @{$node->{<H::infoset:children>}},
                       $newIndex, 0, @newNode;
              }
              
              if ($newNode->{<H::DOMCore:nodeType>} eq
                  <H::DOMCore:DocumentFragmentNode>) {
                $newNode->{<H::infoset:children>} = [];
              } elsif ($parentNode) {
                P: for my $i (0..$#{$parentNode->{<H::infoset:children>}}) {
                  if ($parentNode->{<H::infoset:children>}->[$i]
                                 ->{<H::mn:nodeID>} eq
                      $newNode->{<H::mn:nodeID>}) {
                    splice @{$parentNode->{<H::infoset:children>}}, $i, 1, ();
                    last P;
                  }
                }
              }
            } # @newNode
            } # INSERTION
            $r = $newChild;

       @@@L3Test:
         @@@@QName: Node.insertBefore.insert-before-itself.Test
         @@@@PerlDef:
           my $impl = <Class::c|ManakaiDOMImplementation>->_new;
           my $doc = $impl-><M::c|DOMImplementation.createDocument>
                              ('http://www.example/', 'ex');

           my $eh_called = false;

           my $del = $doc-><AG::Document.documentElement>;
           my $el = $doc-><M::Document.createElementNS>
                       ('http://www.example/', 'element');
           $del-><M::Node.appendChild> ($el);

           my $cfg = $doc-><AG::Document.domConfig>;
           $cfg-><M::c|DOMConfiguration.setParameter> ('error-handler' => sub {
             my (undef, $err) = @_;
             $eh_called = true;
             $test->assert_equals ($err-><AG::c|DOMError.severity>,
                                   <C::c|DOMError.SEVERITY_WARNING>);
             $test->assert_equals ($err-><AG::c|DOMError.type>,
                                   <Q::t|insert-before-itself>);
             $test->assert_equals ($err-><AG::c|DOMError.relatedData>, $el);
             $test->assert_null ($err-><AG::c|DOMError.relatedException>);
             $test->assert_isa ($err-><AG::c|DOMError.location>,
                                <IFName::c|DOMLocator>);
             $test->assert_not_null ($err-><AG::c|DOMError.message>);
           });

           $test->assert_false ($eh_called);
           $del-><M::Node.insertBefore> ($el, $el);
           $test->assert_true ($eh_called);

           $test->assert_equals ($del-><AG::Node.firstChild>, $el);

           $el = null;

     @@Level[list]:
        1
     @@SpecLevel[list]:
        1
        3


  @Method:
     @@Name:  replaceChild
     @@Description:
        @@@lang:en
        @@@@:
          Replace a child node with the other node.
     @@Param:
        @@@Name:  newChild
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@:
            The new node to put in the child list.  If the "newChild" node 
            is already in the tree, it is first removed.
        @@@InCase:
          @@@@Type: DocumentFragment
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The "oldChild" node is replaced by all of the 
              child nodes of the "newChild" node, in the same order. 
              The child list of the "newChild" is to be empty. 
              [DOM 1 SE, 2, 3]
     @@Param:
        @@@Name:  oldChild
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@:
            The node being replaced in the child list.
        @@@InCase:
          @@@@Label: Same as the "newChild" node
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Replacing a node with itself is implementation dependent.
          @@@@SpecLevel: 3
     @@Return:
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@: The node replaced.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: HIERARCHY_REQUEST_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Either this node is of a type that does not allow 
              children of the type of the "newChild" node [DOM 1, 2, 3],
              the node to put in is one of ancestors of this node 
              [DOM 1, 2, 3], the node to put in is this node itself
              [DOM 2 Errata, 3], or this 
              node is of type "Document" and the result of the 
              replacement would add a second "DocumentType" or "Element" node.
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              Special treatment required for the "DocumentFragment" node.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: WRONG_DOCUMENT_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The new node was created from a different document.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Either this node is read-only [DOM 1, 2, 3] or the parent of the 
              new node is read-only [DOM 1 SE, 2, 3].
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NOT_FOUND_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The "oldChild" node is not a child of this node.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NOT_SUPPORTED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              This node is of type "Document" and the DOM implementation 
              does not support the replacement of the "DocumentType" or 
              "Element" child.
          @@@@SpecLevel:3
        @@@c:reports:
          @@@@@: t|replace-by-itself
          @@@@enDesc:
            If the <P::newChild> node is same as the <P::oldChild> node.
            Result of replacing of a node by itself is implementation
            dependent.

            In manakai, such operation has no effect other than the issue
            of a warning.
          @@@@For: ManakaiDOM|ManakaiDOM
        @@@PerlDef:
            my $node;
            my $newNode;
            CHKDOC: {
              if (UNIVERSAL::isa ($newChild, <IFName::Node
                                              ::ManakaiDOM:ManakaiDOM>) and
                  UNIVERSAL::isa ($newChild, <IFName::NodeRef>)) {
                $node = $self->{<H::mn:node>};
                $newNode = $newChild->{<H::mn:node>};
                if ($node->{<H::DOMCore:ownerDocument>}) {
                  if ($newNode->{<H::DOMCore:ownerDocument>}) {
                    last CHKDOC if $node->{<H::DOMCore:ownerDocument>}
                                        ->{<H::mn:nodeID>} eq
                                   $newNode->{<H::DOMCore:ownerDocument>}
                                        ->{<H::mn:nodeID>};
                  }
                } else { ## I'm "Document" or "DocumentType" node.
                  if ($node->{<H::DOMCore:nodeType>} eq <H::infoset:Document>) {
                    last CHKDOC;
                  }
                }
              }
              __EXCEPTION{DOMException.WRONG_DOCUMENT_ERR::
                  MDOMX:param-name => 'newChild',
              }__;
            } # CHKDOC

            my @newNode = ($newNode);
            if ($newNode->{<H::DOMCore:nodeType>} eq
                <H::DOMCore:DocumentFragmentNode>) {
       \       @newNode = @{$newNode->{<H::infoset:children>}};
            }
            REPLACE: {
            if (@newNode) {
              my $parentNode = $newNode[0]->{<H::infoset:parent>};

              ## Read-only?
              if ($node->{<H::DOMCore:read-only>}) {
                ## This node is read-only.
                __EXCEPTION{
                    MDOMX:NOMOD_THIS::
                }__;
              } elsif ($parentNode and $parentNode->{<H::DOMCore:read-only>}) {
                ## Parent of new node(s) is read-only
                __EXCEPTION{
                  MDOMX:NOMOD_SRC_PARENT::
                    MDOMX:param-name => 'newChild',
                }__;
              }
              
              ## Check type of this node and new child node
              CHKTYPE: {
                if ({
                      <H::infoset:Element> => 1,
                      <H::DOMCore:DocumentFragmentNode> => 1,
                      <H::DOMXML:EntityNode> => 1,
                      <H::DOMXML:EntityReferenceNode> => 1,
                    }->{$node->{<H::DOMCore:nodeType>}}) {
                  CHILDTYPE: {
                    for (@newNode) {
                      unless ({
                            <H::infoset:Element> => 1,
                            <H::DOMCore:TextNode> => 1,
                            <H::infoset:Comment> => 1,
                            <H::infoset:ProcessingInstruction> => 1,
                            <H::DOMXML:CDATASectionNode> => 1,
                            <H::DOMXML:EntityReferenceNode> => 1,
                          }->{$_->{<H::DOMCore:nodeType>}}) {
                        last CHILDTYPE;
                      }
                    }
                    last CHKTYPE; # No problem
                  }
                } elsif ($node->{<H::DOMCore:nodeType>} eq <H::infoset:Document>) {
                  CHILDTYPE: {
                    my %has;
                    EACHNEWNODE: for my $newNode (@newNode) {
                      if ({
                            <H::infoset:Element> => 1,
                            <H::infoset:DocumentTypeDeclaration> => 1,
                          }->{$newNode->{<H::DOMCore:nodeType>}}) {
                        FOUND: {
                          if ($has{$newNode->{<H::DOMCore:nodeType>}}) {
                            ## DOCTYPE or document element is waiting 
                            ## to be added
                            last FOUND;
                          }
                          for (@{$node->{<H::infoset:children>}}) {
                            ## Document already has a DOCTYPE or doc.element
                            last FOUND if $_->{<H::DOMCore:nodeType>} eq
                                          $newNode->{<H::DOMCore:nodeType>};
                          }
                          $has{$newNode->{<H::DOMCore:nodeType>}} = 1;
                          next EACHNEWNODE;
                        }
                        if ($newNode->{<H::DOMCore:nodeType>} eq
                            <H::infoset:Element>) {
                          __EXCEPTION{
                            MDOMX:MDOM_SECOND_DOC_ELEMENT::
                              MDOMX:param-name => 'newChild',
                          }__;
                        } else { # infoset:DocumentTypeDeclaration
                          __EXCEPTION{
                            MDOMX:MDOM_SECOND_DOCTYPE::
                              MDOMX:param-name => 'newChild',
                          }__;
                        }
                      } elsif (not {
                                 <H::infoset:Comment> => 1,
                                 <H::infoset:ProcessingInstruction> => 1,
                               }->{$newNode->{<H::DOMCore:nodeType>}}) {
                        last CHILDTYPE;
                      }
                    } # EACHNEWNODE
                    last CHKTYPE; # No problem
                  } # CHILDTYPE
                } elsif ($node->{<H::DOMCore:nodeType>} eq
                         <H::infoset:Attribute>) {
                  CHILDTYPE: {
                    for my $newNode (@newNode) {
                      unless ({
                            <H::DOMCore:TextNode> => 1,
                            <H::DOMXML:EntityReferenceNode> => 1,
                          }->{$newNode->{<H::DOMCore:nodeType>}}) {
                        last CHILDTYPE;
                      }
                    }
                    last CHKTYPE; # No problem
                  }
                } # $node->{< Q::DOMCore:nodeType>}


                __FOR{ManakaiDOM:ManakaiDOMLatest::
                  if ($node->{<H::c|nodeType>} eq
                      <H::infoset:DocumentTypeDeclaration>) {
                    CHILDTYPE: {
                      for my $newNode (@newNode) {
                        unless ({
                                  <H::infoset:ProcessingInstruction> => true,
                                }->{$newNode->{<H::c|nodeType>}}) {
                          last CHILDTYPE; # Error
                        }
                      }
                      last CHKTYPE; # No problem
                    }
                    ## NOTE: PI children of doctype is allowed
                    ##       by manakai XDoctype module.
                  } elsif ($node->{<H::c|nodeType>} eq
                           <H::d|AttributeDefinitionNodeType>) {
                    CHILDTYPE: {
                      for my $newNode (@newNode) {
                        unless ({
                                  <H::c|TextNode> => 1,
                                  <H::DOMXML:EntityReferenceNode> => 1,
                                }->{$newNode->{<H::c|nodeType>}}) {
                          last CHILDTYPE; # Error
                        }
                      }
                      last CHKTYPE; # No problem
                    }
                  }
                }__;

                __EXCEPTION{
                  MDOMX:HIERARCHY_BAD_TYPE::
                    c|nodeType => {$newNode->{<H::c|nodeType>}},
                    MDOMX:param-name => 'newChild',
                }__;
              } # CHKTYPE
              
              ## Check $newNode (not $newNode[0]) = ancestor-or-self::node()
              if (${$node->{<H::mn:treeID>}} eq
                  ${$newNode->{<H::mn:treeID>}}) {
                my $n = $node;
                {
                  if ($newNode->{<H::mn:nodeID>} eq
                      $n->{<H::mn:nodeID>}) {
                    __EXCEPTION{
                      MDOMX:HIERARCHY_ANCESTOR_OR_SELF::
                        MDOMX:param-name => 'newChild',
                    }__;
                  }
                  if ($n->{<H::infoset:parent>}) {
                    $n = $n->{<H::infoset:parent>};
                    redo;
                  }
                }
              }
              
              ## Seek the $oldChild
              my $newIndex = @{$node->{<H::infoset:children>}};
              REFCHILD: {
                if (defined $oldChild) {
                  my $refID = $oldChild->{<H::mn:node>}
                                       ->{<H::mn:nodeID>};
                  for my $i (0..$#{$node->{<H::infoset:children>}}) {
                    if ($node->{<H::infoset:children>}->[$i]
                             ->{<H::mn:nodeID>} eq $refID) {
                      $newIndex = $i;
                      last REFCHILD;
                    }
                  }
                  __EXCEPTION{DOMException.NOT_FOUND_ERR::
                      MDOMX:param-name => 'oldChild',
                  }__;
                } else { ## oldChild is n u l l
                  __EXCEPTION{DOMException.NOT_FOUND_ERR::
                      MDOMX:param-name => 'oldChild',
                  }__;
                }
              } # REFCHILD

              if ($newNode[0]->{<H::infoset:parent>} and
                  $newNode[0]->{<H::infoset:parent>}->{<H::mn:nodeID>} eq
                  $node->{<H::mn:nodeID>}) {
                if (@newNode > 1) {
                  __EXCEPTION{
                    MDOMX:MDOM_DEBUG_BUG||ManakaiDOM:Perl::
                  }__;
                } elsif (ref $oldChild and
                         $newNode[0]->{<H::mn:nodeID>} eq
                         $oldChild->{<H::mn:node>}->{<H::mn:nodeID>}) {
                  __c:ERROR{t|replace-by-itself::
                    c:relatedData => {$oldChild},
                  }__;
                  ## And no action.
                  last REPLACE;
                } else {
                  my $currentIndex;
                  for my $i (0..$#{$node->{<H::infoset:children>}}) {
                    if ($node->{<H::infoset:children>}->[$i]
                             ->{<H::mn:nodeID>} eq
                        $newNode[0]->{<H::mn:nodeID>}) {
                      $currentIndex = $i;
                    }
                  }
                  if ($newIndex < $currentIndex) {
                    splice @{$node->{<H::infoset:children>}}, $currentIndex,
                           1, ();
                    splice @{$node->{<H::infoset:children>}},
                           $newIndex, 1, @newNode;
                  } else {
                    splice @{$node->{<H::infoset:children>}},
                           $newIndex, 1, @newNode;
                    splice @{$node->{<H::infoset:children>}}, $currentIndex,
                           1, ();
                  }
                }
              } else { ## $newChild->parentNode ne $self
                for my $newNode (@newNode) {
                  CORE::delete $newNode->{<H::infoset:parent>};
                  $node-><M::NodeStem.importTree> ($newNode);
                  $newNode->{<H::infoset:parent>} = $node;
                }
                splice @{$node->{<H::infoset:children>}},
                       $newIndex, 1, @newNode;
              }
              
              if ($newNode->{<H::DOMCore:nodeType>} eq
                  <H::DOMCore:DocumentFragmentNode>) {
                $newNode->{<H::infoset:children>} = [];
              } elsif ($parentNode) {
                P: for my $i (0..$#{$parentNode->{<H::infoset:children>}}) {
                  if ($parentNode->{<H::infoset:children>}->[$i]
                                 ->{<H::mn:nodeID>} eq
                      $newNode->{<H::mn:nodeID>}) {
                    splice @{$parentNode->{<H::infoset:children>}}, $i, 1, ();
                    last P;
                  }
                }
              }
              CORE::delete $oldChild->{<H::mn:node>}
                                    ->{<H::infoset:parent>};
              $oldChild->{<H::mn:node>}-><M::NodeStem.orphanate>;
            } # @newNode
            } # REPLACE
            $r = $oldChild;

       @@@L3Test:
         @@@@QName: Node.replaceChild.replace-by-itself.Test
         @@@@PerlDef:
           my $impl = <Class::c|ManakaiDOMImplementation>->_new;
           my $doc = $impl-><M::c|DOMImplementation.createDocument>
                              ('http://www.example/', 'ex');

           my $eh_called = false;

           my $del = $doc-><AG::Document.documentElement>;
           my $el = $doc-><M::Document.createElementNS>
                       ('http://www.example/', 'element');
           $del-><M::Node.appendChild> ($el);

           my $cfg = $doc-><AG::Document.domConfig>;
           $cfg-><M::c|DOMConfiguration.setParameter> ('error-handler' => sub {
             my (undef, $err) = @_;
             $eh_called = true;
             $test->assert_equals ($err-><AG::c|DOMError.severity>,
                                   <C::c|DOMError.SEVERITY_WARNING>);
             $test->assert_equals ($err-><AG::c|DOMError.type>,
                                   <Q::t|replace-by-itself>);
             $test->assert_equals ($err-><AG::c|DOMError.relatedData>, $el);
             $test->assert_null ($err-><AG::c|DOMError.relatedException>);
             $test->assert_isa ($err-><AG::c|DOMError.location>,
                                <IFName::c|DOMLocator>);
             $test->assert_not_null ($err-><AG::c|DOMError.message>);
           });

           $test->assert_false ($eh_called);
           $del-><M::Node.replaceChild> ($el, $el);
           $test->assert_true ($eh_called);

           $test->assert_equals ($del-><AG::Node.firstChild>, $el);

           $el = null;

      @@@enImplNote:
        Test for doctype/child::pi and attrdef/(text | entref)
        is included in <Module::MDOM|XDoctype> module.

     @@Level[list]:
        1
        3
     @@SpecLevel[list]:
        1
        3
  @Method:
     @@Name:  removeChild
     @@Description:
       @@@lang:en
       @@@@:
         Remove a child node from the list of children and return it.
     @@Param:
        @@@Name:  oldChild
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@: The node being removed.
     @@Return:
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@: The node removed.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: This node is read-only.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NOT_FOUND_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The "oldChild" is not a child of this node.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NOT_SUPPORTED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              This node is of type "Document" and the DOM implementation 
              does not support the removal of the "DocumentType" or 
              "Element" child.
        @@@PerlDef:
            my $node = $self->{<H::mn:node>};
            if ($node->{<H::DOMCore:read-only>}) {
              __EXCEPTION{
                MDOMX:NOMOD_THIS::
              }__;
            }
            my $oldChildID = ref $oldChild ?
                               $oldChild->{<H::mn:node>}
                                        ->{<H::mn:nodeID>} : '';
            FIND: {
              for my $i (0..$#{$node->{<H::infoset:children>}}) {
                if ($node->{<H::infoset:children>}->[$i]
                         ->{<H::mn:nodeID>} eq $oldChildID) {
                  splice @{$node->{<H::infoset:children>}}, $i, 1, ();
                  last FIND;
                }
              }
              __EXCEPTION{DOMException.NOT_FOUND_ERR::
              }__;
            }
            if (ref $oldChild) {
              $r = $oldChild;
              CORE::delete $oldChild->{<H::mn:node>}
                                    ->{<H::infoset:parent>};
              $oldChild->{<H::mn:node>}-><M::NodeStem.orphanate>;
            }
     @@Level[list]:  3
     @@SpecLevel:3
     @@For:
       ManakaiDOM:DOM3
  @Method:
     @@Name:  appendChild
     @@Description:
       @@@lang:en
       @@@@:
         Add a node to the end of the list of children of this node.
     @@Param:
        @@@Name:  newChild
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@:
            The node to add.  If it is already in the tree, 
            it is first removed.
        @@@InCase:
          @@@@Type: DocumentFragment
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The entire contents of the document fragment 
              are moved into the child list of this node. 
              The child list of the "newChild" is to be empty.
     @@Return:
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@: The node added.
        @@@ImplNote:
          @@@@lang:en
          @@@@@:
            What should be returned when the "newChild" node is a 
            "DocumentFragment" is unclear.  Current implementation
            returns the <P::newChild>, but returning <QUOTE::this>
            might be better.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: HIERARCHY_REQUEST_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Either this node is of a type that does not allow 
              children of the type of the "newChild" node [DOM 1, 2, 3], 
              the node to add is one of ancestors of this node [DOM 1, 2, 3],
              the node to add is this node itself [DOM 2 Errata, 3] or 
              this node is of type "Document" and the attemption 
              to append a second "DocumentType" or "Element" node 
              is made [DOM 3].
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              Is this error raised if this node is of type "Document" and 
              it has an "Element" node but no "DocumentType" node then 
              the attemption to add a "DocumentType" is made?
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: WRONG_DOCUMENT_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The "newChild" node was created from a different document 
              than the one that created this node.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Either this node is read-only [DOM 1, 2, 3] or
              the previous (current) parent 
              of the "newChild" node is read-only [DOM 2 Errata, 3].
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NOT_SUPPORTED_ERR
          @@@@Level: 3
          @@@@SpecLevel:3
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The "newChild" node is a child of the "Document" node and 
              the DOM implementation does not support the removal of 
              the "DocumentType" or "Element" child node from the 
              "Document" node.
        @@@PerlDef:
          @@@@@:
            my $node;
            my $newNode;
            CHKDOC: {
              unless (<Code::doStrictErrorChecking:: $nodeRef = $self>) {
                $node = $self->{<H::mn:node>};
                $newNode = $newChild->{<H::mn:node>};
                last CHKDOC;
              } elsif (UNIVERSAL::isa ($newChild, <IFName::Node
                                              ::ManakaiDOM:ManakaiDOM>) and
                  UNIVERSAL::isa ($newChild, <IFName::NodeRef>)) {
                $node = $self->{<H::mn:node>};
                $newNode = $newChild->{<H::mn:node>};
                if ($node->{<H::DOMCore:ownerDocument>}) {
                  if ($newNode->{<H::DOMCore:ownerDocument>}) {
                    last CHKDOC if $node->{<H::DOMCore:ownerDocument>}
                                        ->{<H::mn:nodeID>} eq
                                   $newNode->{<H::DOMCore:ownerDocument>}
                                        ->{<H::mn:nodeID>};
                  }
                } else { ## I'm "Document" or "DocumentType" node.
                  if ($node->{<H::DOMCore:nodeType>} eq <H::infoset:Document>) {
                    last CHKDOC;
                  }
                }
              }
              __EXCEPTION{DOMException.WRONG_DOCUMENT_ERR::
                  MDOMX:param-name => 'newChild',
              }__;
            } # CHKDOC
            my @newNode = ($newNode);
            if ($newNode->{<H::DOMCore:nodeType>} eq
                <H::DOMCore:DocumentFragmentNode>) {
       \       @newNode = @{$newNode->{<H::infoset:children>}};
            }
            if (@newNode) {
              my $parentNode = $newNode[0]->{<H::infoset:parent>};

              ## Read-only?
              if ($node->{<H::DOMCore:read-only>}) {
                ## This node is read-only.
                __EXCEPTION{
                  MDOMX:NOMOD_THIS::
                }__;
              } elsif ($parentNode and $parentNode->{<H::DOMCore:read-only>}) {
                ## Parent of new node(s) is read-only
                __EXCEPTION{
                  MDOMX:NOMOD_SRC_PARENT::
                    MDOMX:param-name => 'newChild',
                }__;
              }
            
            if (<Code::doStrictErrorChecking:: $nodeRef = $self>) {  
              ## Check type of this node and new child node
              CHKTYPE: {
                if ({
                      <H::infoset:Element> => 1,
                      <H::DOMCore:DocumentFragmentNode> => 1,
                      <H::DOMXML:EntityNode> => 1,
                      <H::DOMXML:EntityReferenceNode> => 1,
                    }->{$node->{<H::DOMCore:nodeType>}}) {
                  CHILDTYPE: {
                    for (@newNode) {
                      unless ({
                            <H::infoset:Element> => 1,
                            <H::DOMCore:TextNode> => 1,
                            <H::infoset:Comment> => 1,
                            <H::infoset:ProcessingInstruction> => 1,
                            <H::DOMXML:CDATASectionNode> => 1,
                            <H::DOMXML:EntityReferenceNode> => 1,
                          }->{$_->{<H::DOMCore:nodeType>}}) {
                        last CHILDTYPE;
                      }
                    }
                    last CHKTYPE; # No problem
                  }
                } elsif ($node->{<H::DOMCore:nodeType>} eq <H::infoset:Document>) {
                  CHILDTYPE: {
                    my %has;
                    EACHNEWNODE: for my $newNode (@newNode) {
                      if ({
                            <H::infoset:Element> => 1,
                            <H::infoset:DocumentTypeDeclaration> => 1,
                          }->{$newNode->{<H::DOMCore:nodeType>}}) {
                        FOUND: {
                          if ($has{$newNode->{<H::DOMCore:nodeType>}}) {
                            ## DOCTYPE or document element is waiting 
                            ## to be added
                            last FOUND;
                          }
                          for (@{$node->{<H::infoset:children>}}) {
                            ## Document already has a DOCTYPE or doc.element
                            last FOUND if $_->{<H::DOMCore:nodeType>} eq
                                          $newNode->{<H::DOMCore:nodeType>};
                          }
                          $has{$newNode->{<H::DOMCore:nodeType>}} = 1;
                          next EACHNEWNODE;
                        }
                        if ($newNode->{<H::DOMCore:nodeType>} eq
                            <H::infoset:Element>) {
                          __EXCEPTION{
                            MDOMX:MDOM_SECOND_DOC_ELEMENT::
                              MDOMX:param-name => 'newChild',
                          }__;
                        } else { # infoset:DocumentTypeDeclaration
                          __EXCEPTION{
                            MDOMX:MDOM_SECOND_DOCTYPE::
                              MDOMX:param-name => 'newChild',
                          }__;
                        }
                      } elsif (not {
                                 <H::infoset:Comment> => 1,
                                 <H::infoset:ProcessingInstruction> => 1,
                               }->{$newNode->{<H::DOMCore:nodeType>}}) {
                        last CHILDTYPE;
                      }
                    } # EACHNEWNODE
                    last CHKTYPE; # No problem
                  } # CHILDTYPE
                } elsif ($node->{<H::DOMCore:nodeType>} eq
                         <H::infoset:Attribute>) {
                  CHILDTYPE: {
                    for my $newNode (@newNode) {
                      unless ({
                            <H::DOMCore:TextNode> => 1,
                            <H::DOMXML:EntityReferenceNode> => 1,
                          }->{$newNode->{<H::DOMCore:nodeType>}}) {
                        last CHILDTYPE;
                      }
                    }
                    last CHKTYPE; # No problem
                  }
                } # $node->{< Q::DOMCore:nodeType>}

                __FOR{ManakaiDOM:ManakaiDOMLatest::
                  if ($node->{<H::c|nodeType>} eq
                      <H::infoset:DocumentTypeDeclaration>) {
                    CHILDTYPE: {
                      for my $newNode (@newNode) {
                        unless ({
                                  <H::infoset:ProcessingInstruction> => true,
                                }->{$newNode->{<H::c|nodeType>}}) {
                          last CHILDTYPE; # Error
                        }
                      }
                      last CHKTYPE; # No problem
                    }
                    ## NOTE: PI children of doctype is allowed
                    ##       by manakai XDoctype module.
                  } elsif ($node->{<H::c|nodeType>} eq
                           <H::d|AttributeDefinitionNodeType>) {
                    CHILDTYPE: {
                      for my $newNode (@newNode) {
                        unless ({
                                  <H::c|TextNode> => 1,
                                  <H::DOMXML:EntityReferenceNode> => 1,
                                }->{$newNode->{<H::c|nodeType>}}) {
                          last CHILDTYPE; # Error
                        }
                      }
                      last CHKTYPE; # No problem
                    }
                  }
                }__;

                __EXCEPTION{
                  MDOMX:HIERARCHY_BAD_TYPE::
                    c|nodeType => {$newNode->{<H::c|nodeType>}},
                    MDOMX:param-name => 'newChild',
                }__;
              } # CHKTYPE
              
              ## Check $newNode (not $newNode[0]) = ancestor-or-self::node()
              if (${$node->{<H::mn:treeID>}} eq
                  ${$newNode->{<H::mn:treeID>}}) {
                my $n = $node;
                P: {
                  if ($newNode->{<H::mn:nodeID>} eq
                      $n->{<H::mn:nodeID>}) {
                    __EXCEPTION{
                      MDOMX:HIERARCHY_ANCESTOR_OR_SELF::
                        MDOMX:param-name => 'newChild',
                    }__;
                  }
                  if ($n->{<H::infoset:parent>}) {
                    $n = $n->{<H::infoset:parent>};
                    redo P;
                  }
                }
              }
            } # chk
              
              for my $newNode (@newNode) {
                CORE::delete $newNode->{<H::infoset:parent>};
                $node-><M::NodeStem.importTree> ($newNode);
                $newNode->{<H::infoset:parent>} = $node;
              }
              push @{$node->{<H::infoset:children>}}, @newNode;

              if ($newNode->{<H::DOMCore:nodeType>} eq
                  <H::DOMCore:DocumentFragmentNode>) {
                $newNode->{<H::infoset:children>} = [];
              } elsif ($parentNode) {
                RP: for my $i (0..$#{$parentNode->{<H::infoset:children>}}) {
                  if ($parentNode->{<H::infoset:children>}->[$i]
                                 ->{<H::mn:nodeID>} eq
                      $newNode->{<H::mn:nodeID>}) {
                    splice @{$parentNode->{<H::infoset:children>}}, $i, 1, ();
                    last RP;
                  }
                }
              }
            } # @newNode
            $r = $newChild;
     @@Level[list]:
        1
        3
     @@SpecLevel[list]:
        1
        3
     @@ImplNote:
       @@@lang:en
       @@@@: See also the implementation note of the "insertBefore" method.
  @Method:
     @@Name:  hasChildNodes
     @@Description:
       @@@lang:en
       @@@@: Return whether this node has any children.
     @@Return:
        @@@Type: 
          DOMMain:boolean::ManakaiDOM:all
        @@@TrueCase:
          @@@@Description:
            @@@@@lang:en
            @@@@@@: This node has any child nodes.
        @@@FalseCase:
          @@@@Description:
            @@@@@lang:en
            @@@@@@: This node does not have any child node.
        @@@PerlDef:
            $r = (@{$self->{<H::mn:node>}->{<H::infoset:children>}||[]} > 0)

  @Method:
    @@Name: cloneNode
    @@rdf:type: DISLang|Constructor
    @@Operator: DISPerl|CloneMethod
    @@enDesc:
      Returns a duplicate of the node, i.e. serves as a generic
      copy constructor for nodes.

      - The duplicate node has no parent, i.e. <A::Node.parentNode>
        is <DOM::null>.  <SRC::DOM Level 1> <SRC::DOM Level 2> <SRC::DOM Level 3>

      - The duplicate node has no user data, i.e. user data 
        associated to the node is not carried over.  However,
        if any <IF::UserDataHandlers> has been specified along with
        the associated data, those handlers will be called with
        the appropriate parameters before the method returns.
        <SRC::DOM Level 3>

      - If the node is an <IF::Element>, all attributes and their values,
        including those representing defaulted attributes (i.e.
        attributes whose <A::Attr.specified> are <DOM::false>),
        but the method does not copy any children it contains
        unless it is a deep clone (i.e. <P::deep> is <DOM::true>).
        <SRC::DOM Level 1> <SRC::DOM Level 2> <SRC::DOM Level 3>

      - Cloning an <IF::Attr> directly, as oppsed to be cloned
        as part of an <IF::Element> cloning operation, returns
        a specified attribute (i.e. its <A::Attr.specified> is
        set to <DOM::true>).  <SRC::DOM Level 1 SE> <SRC::DOM Level 2>
        <SRC::DOM Level 3>

      - Cloning an <IF::Attr> always clones its children, since 
        they represent its value, no matter whether this is a 
        deep clone or not.  <SRC::DOM Level 3>

      - Cloning an <IF::DOMXML:EntityReference> automatically constructs
        its subtree if a corresponding <IF::DOMXML:Entity> is available,  
        no matter whether this is a deep clone or not.  <SRC::DOM Level 3>

      - Cloning <IF::Document>, <IF::DOMXML:DocumentType>, <IF::DOMXML:Entity>,
        <IF::DOMXML:Notation> nodes is implementation dependent.
        <SRC::DOM Level 1 SE> <SRC::DOM Level 2> <SRC::DOM Level 3>

      - Cloning any other type of node simply returns a copy of the node.
        <SRC::DOM Level 1> <SRC::DOM Level 2> <SRC::DOM Level 3>

      - Cloning an immutable subtree results in a mutable copy, but
        the children of an <IF::DOMXML:EntityReference> clone are
        read-only.  <SRC::DOM Level 2> <SRC::DOM Level 3>

      - Cloning a node does not copy the event listeners attached to it.
        <SRC::DOM Level 2 Events> <SRC::DOM Level 3 Events>

      {NOTE:: <IF::UserDataHandler>s are prohibitted to throw exceptions;
              if a <IF::UserDataHandler> that is registered to the node
              being cloned throws an exception, then the result of
              the method is undefined.
      }

     @@ImplNote:
       @@@lang:en
       @@@@:
         How affects to style sheets?

     @@Param:
       @@@Name: deep
       @@@Type:  
         idl:boolean::ManakaiDOM:all
       @@@enDesc:
         Whether the subtree under the node should be recursively cloned
         or not.
       @@@TrueCase:
         @@@@enDesc:
           Recusively clones the subtree under the node.
       @@@FalseCase:
         @@@@enDesc:
           Doesn't clone the subtree under the node.

     @@Return:
       @@@Type:  Node
       @@@enDesc: The duplicate node.

       @@@raises:
         @@@@@: c|CLONE_NODE_TYPE_NOT_SUPPORTED_ERR
         @@@@enDesc:
           The node is of type <IF::Document>, <IF::DOMXML:DocumentType>,
           <IF::DOMXML:Entity>, or <IF::DOMXML:Notation> and the implementation
           does not support cloning that type of node.
           <SRC::DOM Level 1 SE>
         @@@@ImplNote:
           @@@@@lang:en
           @@@@@@:
             Only in DOM Level 1 SE.

       @@@PerlDef:
         __DEEP{
           my $od = $self-><AG::Node.ownerDocument>;
           my $strict_check;
           my $cfg;
           my $er_copy_asis;
           __FOR{ManakaiDOM:DOM3::
             $strict_check = $od-><AG::Document.strictErrorChecking>;
             $od-><AS::Document.strictErrorChecking> (false);
             $cfg = $od-><AG::Document.domConfig>;
             $er_copy_asis = $cfg-><M::c|DOMConfiguration.getParameter>
                                     (<Q::cfg|clone-entity-reference-subtree>);
           }__;
           my @udh;
           my @node = ([$self]);
           while (@node) {
             my ($node, $parent) = @{shift @node};
             my $nt = $node-><AG::Node.nodeType>;
             my $clone;
             if ($nt == <C::Node.ELEMENT_NODE>) {
               my $ln;

               __FOR{ManakaiDOM:DOM2::
                 $ln = $node-><AG::Node.localName>;
               }__;
               if (defined $ln) {
                 $clone = $od-><M::Document.createElementNS>
                                   ($node-><AG::Node.namespaceURI>, $ln);
               } else {  ## DOM Level 1 node
                 $clone = $od-><M::Document.createAttribute>
                                   ($node-><AG::Node.nodeName>);
               }
               if ($parent) {
                 $parent-><M::Node.appendChild> ($clone);
               } else {
                 $r = $clone;
               }
               my $attrs = $node-><AG::Node.attributes>;
               my $attrsMax = $attrs-><AG::NamedNodeMap.length> - 1;
               for my $i (0..$attrsMax) {
                 push @node, [$attrs-><M::NamedNodeMap.item> ($i), $clone];
               }
               if ($deep) {
                 push @node, map {[$_, $clone]} @{$node-><AG::Node.childNodes>};
               }
             } elsif ($nt == <C::Node.TEXT_NODE>) {
               $clone = $od-><M::Document.createTextNode>
                                   ($node-><AG::CharacterData.data>);
               if ($parent) {
                 $parent-><M::Node.appendChild> ($clone);
               } else {
                 $r = $clone;
               }
               __FOR{ManakaiDOM:DOM3::
                 $clone-><AS::Text.isElementContentWhitespace> (true)
                   if $node-><AG::Text.isElementContentWhitespace>;
               }__;
             } elsif ($nt == <C::Node.ATTRIBUTE_NODE>) {
               my $ln;
               __FOR{ManakaiDOM:DOM2::
                 $ln = $node-><AG::Node.localName>;
               }__;
               if (defined $ln) {
                 $clone = $od-><M::Document.createAttributeNS>
                                   ($node-><AG::Node.namespaceURI>, $ln);
                 if ($parent) {
                   $parent-><M::Element.setAttributeNodeNS> ($clone);
                   $clone->{<H::mn:node>}->{<H::infoset:specified>} = true
                     if $node-><AG::Attr.specified>;
                 } else {
                   $r = $clone;
                   $clone->{<H::mn:node>}->{<H::infoset:specified>} = true;
                 }
               } else {  ## DOM Level 1 node
                 $clone = $od-><M::Document.createAttribute>
                                   ($node-><AG::Node.nodeName>);
                 if ($parent) {
                   $parent-><M::Element.setAttributeNode> ($clone);
                   $clone->{<H::mn:node>}->{<H::infoset:specified>} = true
                     if $node-><AG::Attr.specified>;
                 } else {
                   $r = $clone;
                   $clone->{<H::mn:node>}->{<H::infoset:specified>} = true;
                 }
               }
               push @node, map {[$_, $clone]} @{$node-><AG::Node.childNodes>};
             } elsif ($nt == <C::Node.COMMENT_NODE>) {
               $clone = $od-><M::Document.createComment>
                                   ($node-><AG::CharacterData.data>);
               if ($parent) {
                 $parent-><M::Node.appendChild> ($clone);
               } else {
                 $r = $clone;
               }
             } elsif ($nt == <C::Node.CDATA_SECTION_NODE>) {
               $clone = $od-><M::Document.createTextNode>
                                   ($node-><AG::CharacterData.data>);
               if ($parent) {
                 $parent-><M::Node.appendChild> ($clone);
               } else {
                 $r = $clone;
               }
             } elsif ($nt == <C::Node.PROCESSING_INSTRUCTION_NODE>) {
               $clone = $od-><M::Document.createProcessingInstruction>
                              ($node-><AG::DOMXML:ProcessingInstruction.target>);
               $clone-><AS::DOMXML:ProcessingInstruction.data>
                              ($node-><AG::DOMXML:ProcessingInstruction.data>);
               if ($parent) {
                 $parent-><M::Node.appendChild> ($clone);
               } else {
                 $r = $clone;
               }
             } elsif ($nt == <C::Node.ENTITY_REFERENCE_NODE>) {
               $clone = $od-><M::Document.createEntityReference>
                                    ($node-><AG::Node.nodeName>);
               __FOR{ManakaiDOM:DOM3::
                 if ($er_copy_asis) {
                   local $clone->{<H::mn:node>}->{<H::c|read-only>} = false;
                   $clone-><AS::Node.textContent> ('');
                   my @ronode;
                   for (@{$node-><AG::Node.childNodes>}) {
                     push @ronode, $clone-><M::Node.appendChild>
                                             ($_-><M::Node.cloneNode> (true));
                   }
                   if ($cfg-><M::c|DOMConfiguration.getParameter>
                               (<Q::cfg|entity-reference-read-only>)) {
                     while (@ronode) {
                       my $ronode = shift @ronode;
                       $ronode->{<H::mn:node>}->{<H::c|read-only>} = true;
                       push @ronode, @{$ronode-><AG::Node.childNodes>};
                       push @ronode, values %{$ronode-><AG::Node.attributes>
                                                or {}};
                     }
                   }
                   $clone->{<H::mn:node>}->{<H::ManakaiDOM|isExpanded>}
                     = $node->{<H::mn:node>}->{<H::ManakaiDOM|isExpanded>};
                 }
               }__;
               if ($parent) {
                 $parent-><M::Node.appendChild> ($clone);
               } else {
                 $r = $clone;
               }
             } elsif ($nt == <C::Node.DOCUMENT_FRAGMENT_NODE>) {
               $clone = $od-><M::Document.createDocumentFragment>;
               $r = $clone;
               push @node, map {[$_, $clone]} @{$node-><AG::Node.childNodes>};
             } elsif ($nt == <C::Node.DOCUMENT_NODE>) {
               __FOR{ManakaiDOM:DOM3::
                 $od-><AS::Document.strictErrorChecking> ($strict_check);
               }__;
               __UNDEEP{__EXCEPTION{c|CLONE_NODE_TYPE_NOT_SUPPORTED_ERR::
                 DOMCore:node => $node,
               }__}__;
             } elsif ($nt == <C::Node.DOCUMENT_TYPE_NODE>) {
               __FOR{ManakaiDOM:DOM3::
                 $od-><AS::Document.strictErrorChecking> ($strict_check);
               }__;
               __UNDEEP{__EXCEPTION{c|CLONE_NODE_TYPE_NOT_SUPPORTED_ERR::
                 DOMCore:node => $node,
               }__}__;
             } elsif ($nt == <C::Node.ENTITY_NODE>) {
               __FOR{ManakaiDOM:DOM3::
                 $od-><AS::Document.strictErrorChecking> ($strict_check);
               }__;
               __UNDEEP{__EXCEPTION{c|CLONE_NODE_TYPE_NOT_SUPPORTED_ERR::
                 DOMCore:node => $node,
               }__}__;
             } elsif ($nt == <C::Node.NOTATION_NODE>) {
               __FOR{ManakaiDOM:DOM3::
                 $od-><AS::Document.strictErrorChecking> ($strict_check);
               }__;
               __UNDEEP{__EXCEPTION{c|CLONE_NODE_TYPE_NOT_SUPPORTED_ERR::
                 DOMCore:node => $node,
               }__}__;
             } else {
               ## TODO: Assertion
             }

             push @udh, [$node => $clone]
               if $node->{<H::mn:node>}->{<H::t|userData>};
           } # @node
           __FOR{ManakaiDOM:DOM3::
             $od-><AS::Document.strictErrorChecking> (true) if $strict_check;

             ## Calling user data handlers if any
             for my $sd (@udh) {
               my $src = $sd->[0];
               my $src_ud = $src->{<H::mn:node>}->{<H::t|userData>};
               for my $key (keys %{$src_ud}) {
                 my $dh = $src_ud->{$key}->[1];
                 if ($dh) {
                   $dh-><M::c|UserDataHandler.handle>
                           (<C::c|UserDataHandler.NODE_CLONED>,
                            $key, $src_ud->{$key}->[0], $src, $sd->[1]);
                 }
               }
             }
           }__;
         }__;

        @@@enImplNote:
          When are <IF::UserDataHandler>s invoked?  After a node
          is cloned?  Or, all nodes are cloned?  In any order?

          Level 1 or 2 method does not invoke user data handlers
          even if the node cloned is a Level 3 node in current implementation.

    @@L3Test:
      @@@QName: Node.CloneNode.UserDataHandler.Test
      @@@PerlDef:
        my $impl = <Class::c|ManakaiDOMImplementation>->_new;
        my $doc = $impl-><M::c|DOMImplementation.createDocument>
                              ('http://www.example/', 'ex');
        my $node = $doc-><AG::Document.documentElement>;
        my $node_id = $node->{<H::mn:node>}->{<H::mn:nodeID>};

        my $udh_called = false;

        my $clone_node_id;

        $node-><M::Node.setUserData> ('key' => {}, sub {
          my ($self, $op, $key, $data, $src, $dest) = @_;
          $udh_called = true;

          $test->assert_equals ($op, <C::c|UserDataHandler.NODE_CLONED>);
          $test->assert_equals ($key, 'key');
          $test->assert_equals (ref $data, 'HASH');
          $test->assert_not_null ($src);
          $test->assert_equals ($src-><AG::Node.localName>, 'ex');
          $test->assert_equals
                   ($src->{<H::mn:node>}->{<H::mn:nodeID>}, $node_id);
          $test->assert_not_null ($dest);
          $test->assert_equals ($dest-><AG::Node.localName>, 'ex');
          $test->assert_not_equals
                   ($dest->{<H::mn:node>}->{<H::mn:nodeID>}, $node_id);
          $clone_node_id = $dest->{<H::mn:node>}->{<H::mn:nodeID>};
        });

        my $clone = $node-><M::Node.cloneNode>;

        $test->assert_true ($udh_called);
        $test->assert_equals ($clone_node_id,
                              $clone->{<H::mn:node>}->{<H::mn:nodeID>});

        $node-><M::Node.setUserData> ('key', null, null);

    @@XDTest:
      @@@QName: EntityReference.cloneNode.clone-entity-reference-subtree.1.test
      @@@PerlDef:
        my $doc;
        __CODE{createEmptyDocumentForTest:: $doc => $doc}__;
        my $docd = $doc-><M::Node.getFeature> (<Q::ManakaiDOM:XDoctype>, '3.0');
        my $dtd = $docd-><M::d|DocumentXDoctype.createDocumentTypeDefinition>
                           ('doctype');
          my $et = $docd-><M::d|DocumentXDoctype.createGeneralEntity>
                             ('ent1');
          $et-><AS::Node.textContent> ('replacement text content');
          $et-><AS::x|Entity.hasReplacementTree> (true);
        $dtd-><M::DTDef.setGeneralEntityNode> ($et);
        $doc-><M::Node.appendChild> ($dtd);
        $doc-><AG::Document.domConfig>
            -><M::c|DOMConfiguration.setParameter>
                (<Q::cfg|entity-reference-read-only> => false);

        $doc-><AG::Document.domConfig>
            -><M::c|DOMConfiguration.setParameter>
                (<Q::cfg|clone-entity-reference-subtree> => false);
                # DOM 3 definition

        $test->id ('original');
        my $ent = $doc-><M::Document.createEntityReference> ('ent1');
        $test->assert_isa ($ent, <IFName::x|EntityReference>);
        $test->assert_equals ($ent-><AG::Node.textContent>,
                              'replacement text content');
        $test->assert_true ($ent-><AG::x|EntityReference.isExpanded>);

        $test->id ('change');
        $ent-><AS::Node.textContent> ('another text');
        $test->assert_equals ($ent-><AG::Node.textContent>,
                              'another text');

        $test->id ('clone');
        my $clone = $ent-><M::Node.cloneNode>;
        $test->assert_isa ($clone, <IFName::x|EntityReference>);
        $test->assert_equals ($clone-><AG::Node.textContent>,
                              'replacement text content');
        $test->assert_true ($clone-><AG::x|EntityReference.isExpanded>);
    @@XDTest:
      @@@QName: EntityReference.cloneNode.clone-entity-reference-subtree.2.test
      @@@PerlDef:
        my $doc;
        __CODE{createEmptyDocumentForTest:: $doc => $doc}__;
        my $docd = $doc-><M::Node.getFeature> (<Q::ManakaiDOM:XDoctype>, '3.0');
        my $dtd = $docd-><M::d|DocumentXDoctype.createDocumentTypeDefinition>
                           ('doctype');
          my $et = $docd-><M::d|DocumentXDoctype.createGeneralEntity>
                             ('ent1');
          $et-><AS::Node.textContent> ('replacement text content');
          $et-><AS::x|Entity.hasReplacementTree> (true);
        $dtd-><M::DTDef.setGeneralEntityNode> ($et);
        $doc-><M::Node.appendChild> ($dtd);
        $doc-><AG::Document.domConfig>
            -><M::c|DOMConfiguration.setParameter>
                (<Q::cfg|entity-reference-read-only> => false);

        $doc-><AG::Document.domConfig>
            -><M::c|DOMConfiguration.setParameter>
                (<Q::cfg|clone-entity-reference-subtree> => true);

        $test->id ('original');
        my $ent = $doc-><M::Document.createEntityReference> ('ent1');
        $test->assert_isa ($ent, <IFName::x|EntityReference>);
        $test->assert_equals ($ent-><AG::Node.textContent>,
                              'replacement text content');
        $test->assert_true ($ent-><AG::x|EntityReference.isExpanded>);

        $test->id ('change');
        $ent-><AS::Node.textContent> ('another text');
        $test->assert_equals ($ent-><AG::Node.textContent>,
                              'another text');

        $test->id ('clone');
        my $clone = $ent-><M::Node.cloneNode>;
        $test->assert_isa ($clone, <IFName::x|EntityReference>);
        $test->assert_equals ($clone-><AG::Node.textContent>,
                              'another text');
        $test->assert_true ($clone-><AG::x|EntityReference.isExpanded>);
    @@XDTest:
      @@@QName: EntityReference.cloneNode.clone-entity-reference-subtree.3.test
      @@@PerlDef:
        my $doc;
        __CODE{createEmptyDocumentForTest:: $doc => $doc}__;
        my $docd = $doc-><M::Node.getFeature> (<Q::ManakaiDOM:XDoctype>, '3.0');
        my $dtd = $docd-><M::d|DocumentXDoctype.createDocumentTypeDefinition>
                           ('doctype');
          my $et = $docd-><M::d|DocumentXDoctype.createGeneralEntity>
                             ('ent1');
          $et-><AS::Node.textContent> ('replacement text content');
          $et-><AS::x|Entity.hasReplacementTree> (true);
        $dtd-><M::DTDef.setGeneralEntityNode> ($et);
        $doc-><M::Node.appendChild> ($dtd);
        $doc-><AG::Document.domConfig>
            -><M::c|DOMConfiguration.setParameter>
                (<Q::cfg|entity-reference-read-only> => false);

        $doc-><AG::Document.domConfig>
            -><M::c|DOMConfiguration.setParameter>
                (<Q::cfg|clone-entity-reference-subtree> => true);

        $test->id ('original');
        my $ent = $doc-><M::Document.createEntityReference> ('ent1');
        $test->assert_isa ($ent, <IFName::x|EntityReference>);
        $test->assert_equals ($ent-><AG::Node.textContent>,
                              'replacement text content');
        $test->assert_true ($ent-><AG::x|EntityReference.isExpanded>);

        $test->id ('change');
        $ent-><AS::Node.textContent> ('');
        $test->assert_equals ($ent-><AG::Node.textContent>, '');
        $ent-><AS::x|EntityReference.isExpanded> (false);
        $test->assert_false ($ent-><AG::x|EntityReference.isExpanded>);

        $test->id ('clone');
        my $clone = $ent-><M::Node.cloneNode>;
        $test->assert_isa ($clone, <IFName::x|EntityReference>);
        $test->assert_equals ($clone-><AG::Node.textContent>, '');
        $test->assert_false ($clone-><AG::x|EntityReference.isExpanded>);

  @Method:
     @@Name:  normalize
     @@Description:
       @@@lang:en
       @@@@:
         Put all <IF::Text> nodes in the full depth of the sub-tree 
         underneath this <IF::Node>, including attribute nodes 
         attaced to the <IF::Element>, 
         into a <QUOTE::normal> form where only structures separate
         <IF::Text> nodes, i.e. there are neither adjacent <IF::Text> 
         nodes nor empty <IF::Text> nodes. <SRC::DOM 1, 2, 3>
       \
         If the parameter <cfg::normalize-characters> of the 
         <A::Document.domConfig> is <DOM::true>, the characters 
         of the <IF::Text> nodes will also be fully normalized. 
         <SRC::DOM 3>
     @@ImplNote:
       @@@lang:en
       @@@@:
         The spec does not say to normalize nodes other than 
         <IF::Text> (such as <IF::DOMXML:CDATASection>, 
         <IF::Comment> and so on).
     @@Return:
       @@@Exception:
         @@@@@:
           MDOMX:NOMOD_THIS
         @@@@Description:
           @@@@@lang:en
           @@@@@@:
             This node is read-only. 
         @@@@For:
           ManakaiDOM:ManakaiDOM
       @@@Exception:
         @@@@@: c|NOMOD_DESCENDANT_ERR
         @@@@Description:
           @@@@@lang:en
           @@@@@@:
             One of descendant (or attribute) is read-only. 
         @@@@For:
           ManakaiDOM:ManakaiDOM
       @@@PerlDef:
         @@@@@:
           __DEEP{
             $self->{<H::mn:node>}
                -><M::ManakaiDOMCore:ManakaiDOMNodeObjectNode.normalizeText>
                                                               (false, false);
           }__;
         @@@@ImplNote:
           @@@@@lang:en
           @@@@@@:
             {TODO:: Character normalization should be implemented.
             \
             }
           @@@@@ForCheck:
             ManakaiDOM:ManakaiDOM3
     @@Level[list]:
       2
       3
     @@SpecLevel[list]:
       2
       3
     @@For:
       ManakaiDOM:DOM2
     @@ImplNote:
       @@@lang:en
       @@@@:
         This method was defined in the "Element" interface in the DOM 
         Level 1, but has beem moved to the "Node" interface in the 
         DOM Level 2.
  @Method:
     @@Name:  isSupported
     @@ImplNote:
       @@@lang:en
       @@@@:
         This method is parallel to the <M::DOMImplementation.hasFeature>. 
     @@Param:
        @@@Name:  feature
        @@@Type:  
          DOMMain:DOMString
        @@@actualType: f|FeatureNameString
     @@Param:
        @@@Name:  version
        @@@Type:  
          DOMMain:DOMString
        @@@actualType: f|FeatureVersionString
     @@Level[list]:  2
     @@SpecLevel:2
     @@L2:
     @@Return:
        @@@Type:  
          DOMMain:boolean||ManakaiDOM|all
        @@@PerlDef:
          my $plus = $feature =~ s/^\+// ? 1 : 0;
          if ($<Class::DOMCore:ManakaiDOMNode
                                     ::ManakaiDOM:ManakaiDOMLatest>::Class{
              ref $self}->{$feature}->{$version}) {
              \## ISSUE: Not work for node type specific classes
            $r = true;
          } else {
            for (values %<Class::DOMCore:ManakaiDOMNode
                                     ::ManakaiDOM:ManakaiDOMLatest>::Class) {
              if ($_->{feature}->{$feature}->{$version}) {
                $r = true;
                last;
              }
            }
          } 
          \## TODO: Node type specific alternates
  @Attr:
     @@Name:  namespaceURI
     @@Description:
       @@@lang:en
       @@@@:
         The namespace URI of this node.
       \
         Note that this is not a computed value that is the result 
         of a namespace lookup based on an examination of the 
         namespace declarations in scope, but is merely the 
         namespace URI given at creation time.
     @@DOMMain:isNamespaceAware:1
     @@Get:
        @@@Type:
          DOMMain:DOMString
        @@@actualType:
          ManakaiDOM:ManakaiDOMNamespaceURI
        @@@Description:
          @@@@lang:en
          @@@@@: The namespace URI.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The namespace URI is unspecified (the "null" namespace or 
              the attribute in a per-element-type partition),
              the type of the node is other than "ELEMENT_NODE" or 
              "ATTRIBUTE_NODE", or 
              the node is created with a DOM Level 1 methods.
        @@@PerlDef: $r = null;
     @@Level[list]:  2
     @@SpecLevel:2
     @@For:
       ManakaiDOM:DOM2

  @L2Attr:
     @@Name:  prefix
     @@Description:
       @@@lang:en
       @@@@: The namespace prefix of this node.
     @@DOMMain:isNamespaceAware:1
     @@Get:
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The namespace prefix.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Either the namespace prefix is unspecified, the node 
              is created with a DOM Level 1 method, or the type 
              of the node is other than "ELEMENT_NODE" and 
              "ATTRIBUTE_NODE".
        @@@PerlDef: $r = null;
     @@Set:
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            The namespace prefix.
            Note that setting this attribute has no effect if 
            the namespace prefix is defined to be "null".
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The namespace prefix is unspecified.
        @@@InCase:
          @@@@Value: \
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The result is implementation dependent.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: INVALID_CHARACTER_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The specified prefix contains an illegal character 
              accoding to the XML version in use in the document.
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              The DOM Level 2 Errata clarifies that the "illegal"ness 
              is accoding to the XML 1.0 Specification.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: This node is read-only.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NAMESPACE_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Either the specified prefix is malformed per the 
              XML Namespace specification, non-"null" prefix is 
              specified but the "namespaceURI" of this node is "null", 
              the specified prefix is "xml" and the "namespaceURI" 
              of this node is different from 
              "http://www.w3.org/XML/1998/namespace", if this 
              node is an attribute and the specified prefix is "xmlns" 
              and the "namespaceURI" of this node is different from 
              "http://www.w3.org/2000/xmlns/", or if this node is 
              an attribute and the "qualifiedName" of this node is 
              "xmlns".
        @@@c:reports:
          @@@@@: t|setting-prefix-no-effect-because-of-document
          @@@@enDesc:
            If the the document does not support XML namespace
            so that setting the attribute value has no effect.
          @@@@For: ManakaiDOM|ManakaiDOM
        @@@c:reports:
          @@@@@: t|setting-prefix-no-effect-because-of-node
          @@@@enDesc:
            If the the node does not support XML namespace
            so that setting the attribute value has no effect.
          @@@@For: ManakaiDOM|ManakaiDOM
        @@@PerlDef:
          __c:ERROR{t|setting-prefix-no-effect-because-of-node::
            c:relatedData => {$self},
          }__;

  @Attr:
     @@Name:  localName
     @@Description:
       @@@lang:en
       @@@@: The local part of the qualified name of this node.
     @@DOMMain:isNamespaceAware:1
     @@Get:
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            The local name.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The type of the node is other than "ELEMENT_NODE" or 
              "ATTRIBUTE_NODE", or the node is created with a DOM Level 1 
              methods.
        @@@PerlDef:$r = null;
     @@Level[list]:  2
     @@SpecLevel:2
     @@For:
       ManakaiDOM:DOM2
  @Method:
     @@Name:  hasAttributes
     @@Description:
       @@@lang:en
       @@@@:
         Return whether this node has any attributes.
     @@Return:
        @@@Type: DOMMain|boolean||ManakaiDOM|all
        @@@TrueCase:
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              This node is an <IF::Element> and has any attributes.
        @@@FalseCase:
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              This node does not have any attribute.
        @@@PerlDef:
            for (values %{$self->{<H::mn:node>}
                               ->{<H::infoset:attributes>}||{}}) {
              if (keys %$_) {
                $r = true;
                last;
              }
            }
     @@Level[list]:  2
     @@SpecLevel:2
     @@For:
       ManakaiDOM:DOM2
  @Attr:
     @@Name:  baseURI
     @@Description:
       @@@lang:en
       @@@@:
         The base URI of this node.
     @@Get:
        @@@Type: 
          DOMMain:DOMString
        @@@actualType:
          ManakaiDOM:ManakaiDOMURI
        @@@Description:
          @@@@lang:en
          @@@@@:
            The absolute base URI.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The DOM implementation was not able to obtain 
              an absolute URI.
        @@@PerlDef:
            if ($self->{<H::mn:node>}->{<H::DOMCore:ownerDocument>} and
                $self->{<H::mn:node>}->{<H::DOMCore:ownerDocument>}
                     ->{<H::DOMCore:hasFeature>}->{HTML}) {
              $r = $self->{<H::mn:node>}
                     -><M::ManakaiDOMCore:ManakaiDOMNodeObjectNode.htmlBaseURI>;
            } else {
              $r = null;
            }
     @@ImplNote:
       @@@lang:en
       @@@@:
         = If the <IF::Document> support the feature <Feature::HTML>,
       \
         == If there is a <HE::base> element with the <HA::href> attribute, 
            the base URI is its value.
       \
         == Otherwise, the base URI is the value of <A::Document.documentURI>.
       \
         = Elsif the <IF::Document> support the feature <Feature::XML>, 
           compute the base URI accoding to the XML Base Specification.
     @@ImplNote:
       @@@lang:en
       @@@@:
         The descriptions in the sections of Base URIs (DOM Level 3 Core 
         1.3.4) and <A::Node.baseURI> (and some readings from XML Base 
         and XML Infoset specifications) is insufficient to understand 
         and implement this attribute.  The <sw010:csection::Infoset Mapping>, a 
         normative appendix of the DOM Level 3 Core Specification, is 
         useful for this purpose.
     @@ImplNote:
       @@@lang:en
       @@@@:
         The DOM Level 3 Specification does not address to 
         <HA::codebase> attributes.
     @@Level[list]:  3
     @@SpecLevel:3
     @@Spec:
       @@@DOM3:
         http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#baseURIs-Considerations
    @@For:
      ManakaiDOM:DOM2

  @ConstGroup:
    @@QName: DocumentPosition

     @@Description:
       @@@lang:en
       @@@@:
         A bitmask indicating the relative document position of a node 
         with respect to another node.
     @@Level: 3
     @@SpecLevel:3
     @@For:
       ManakaiDOM:DOM3

     @@rdfs:subClassOf: idl|unsignedShort||ManakaiDOM|all
     @@Type: idl|unsignedShort||ManakaiDOM|all

     @@Const:
        @@@Name:  DOCUMENT_POSITION_DISCONNECTED
        @@@intValue:  0x01
        @@@Description:
          @@@@lang:en
          @@@@@:
            The two nodes are disconnected.  Order between disconnected nodes 
            is always implementation-specific.
     @@Const:
        @@@Name:  DOCUMENT_POSITION_PRECEDING
        @@@intValue:  0x02
        @@@Description:
          @@@@lang:en
          @@@@@:
            The node precedes the reference node.
     @@Const:
        @@@Name:  DOCUMENT_POSITION_FOLLOWING
        @@@intValue:  0x04
        @@@Description:
          @@@@lang:en
          @@@@@: The node fllows the reference node.
     @@Const:
        @@@Name:  DOCUMENT_POSITION_CONTAINS
        @@@intValue:  0x08
        @@@Description: 
          @@@@lang:en
          @@@@@:
            The node contains the reference node.  A node that 
            contains is always preceding, too.
     @@Const:
        @@@Name:  DOCUMENT_POSITION_CONTAINED_BY
        @@@intValue:  0x10
        @@@Description:
          @@@@lang:en
          @@@@@:
            The node is contained by the reference node. 
            A node that is contained is always following, too.
     @@Const:
        @@@Name:  DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC
        @@@intValue:  0x20
        @@@Description:
          @@@@lang:en
          @@@@@:
            The determination of preceding versus following is 
            implementation-specific.
  @Method:
     @@Name:  compareDocumentPosition
     @@Return:
        @@@Type:  
          DOMMain:unsigned-short||ManakaiDOM|all
        @@@actualType: DocumentPosition
        @@@Exception[list]:  DOMException
     @@Param:
        @@@Name:  other
        @@@Type:  Node
     @@Level[list]:  3
     @@SpecLevel:3
     @@For:
       ManakaiDOM:DOM3

  @Attr:
     @@Name:  textContent

     @@Level[list]:
        3
     @@SpecLevel:3

     @@ManakaiDOM:isForInternal:
       @@@@:1
       @@@ForCheck: 
         !ManakaiDOM:DOM3
     @@For:
       ManakaiDOM:ManakaiDOM
     @@For:
       ManakaiDOM:DOM3

     @@Description:
       @@@lang:en
       @@@@:
         The text content of this node and its descendants. 
         Note that element content whitespaces are not considered 
         as the text content of an "Element".
     @@ImplNote:
       @@@lang:en
       @@@@:
         A lot of methods and attributes referrs this attribute 
         by Perl method call or by <Q::DISPerl:cloneCode>. 
       @@@For:
         ManakaiDOM:ManakaiDOM
     @@Get:
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            The text content of this node.
        @@@InCase:
          @@@@Label: Concatenation of the text content of child nodes
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
            For the node of type "Element", "Attr", "Entity", 
            "EntityReference" or "DocumentFragment",  
            concatenation of the "textContent" value of every 
            child node, excluding of type "Comment" or 
            "ProcessingInstruction", is the text content.
        @@@InCase:
          @@@@Label: "nodeValue"
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              For the node of type "Text", "CDATASection", 
              "Comment" or "ProcessingInstruction", the text content 
              is same as the value of the attribute "nodeValue".
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              For the node of type "Document", "DocumentType" or 
              "Notation", the text content is defined to be "null".
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: DOMSTRING_SIZE_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The attribute would return more characters than 
              fit in a "DOMString" variable on the implementation 
              platform.
        @@@PerlDef:
          __CODE{DOMCore:getNodeTextContent::
                           $node => $self,
                           $result => $r}__;
     @@Set:
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            Any child nodes of this node are removed and 
            replaced by a single "Text" node containing the string 
            specified.
          \
            Note that when the "textContent" is defined to be "null", 
            setting the value has no effect.
        @@@InCase:
          @@@@Value:\
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Any child nodes are removed if the value is not defined to 
              be "null".
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: 
              Any child nodes are removed if the value is not defined 
              to be "null".
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: This node is read-only.
        @@@PerlDef:
          __CODE{DOMCore:setNodeTextContent::
                    $node => $self,
                    $given => $given}__;

  @ResourceDef:
    @@QName: c|getNodeTextContent
    @@aliasChild:1
    @@rdf:type: DISPerl|BlockCode
    @@ForCheck:
      ManakaiDOM:ForClass
    @@enDesc:
      Gets a text content of a node.
    @@PerlDef:
      my $__nodeobj = $node->{<H::mn:node>};
      if ({
             <H::infoset:Element> => true,
             <H::infoset:Attribute> => true,
             <H::DOMXML:EntityNode> => true,
             <H::DOMXML:EntityReferenceNode> => true,
             <H::DOMCore:DocumentFragmentNode> => true,
      }->{$__nodeobj->{<H::DOMCore:nodeType>}}) {
        __DEEP{
          for my $__cno (@{$node->{<H::mn:node>}
                                ->{<H::infoset:children>}}) {
            if ($__cno->{<H::DOMCore:nodeType>} eq <H::DOMCore:TextNode>) {
              $result .= $__cno->{<H::infoset:content>}
                unless $__cno->{<H::infoset:elementContentWhitespace>};
            } elsif (not {
                  <H::infoset:Comment> => true,
                  <H::infoset:ProcessingInstruction> => true,
            }->{$__cno->{<H::DOMCore:nodeType>}}) {
              my $__cn;
              __CODE{ManakaiNode:getWeakReference||ManakaiDOM:Perl::
                $object => $__cno, $ref => $__cn,
                $class => {{
                  <H::infoset:Element> => <ClassName::ManakaiDOMElement>,
                  <H::DOMXML:CDATASectionNode> =>
                              <ClassName::DOMXML:ManakaiDOMCDATASection>,
                  <H::DOMXML:EntityReferenceNode> =>
                           <ClassName::DOMXML:ManakaiDOMEntityReference>,
                }->{$__cno->{<H::DOMCore:nodeType>}} ||
                <ClassName::ManakaiDOMNode>},
              }__;
              __FOR{ManakaiDOM:DOM3::
                $result .= $__cn-><AG::DOMCore:Node.textContent>;
              }__;
              __FOR{!ManakaiDOM:DOM3::
                $result .= $__cn-><AG::DOMCore:ManakaiDOMNode.textContent>;
              }__;
            }
          }
        }__;
      } elsif ({
          <H::DOMCore:TextNode> => true,
          <H::DOMXML:CDATASectionNode> => true,
          <H::infoset:Comment> => true,
          <H::infoset:ProcessingInstruction> => true,
      }->{$__nodeobj->{<H::DOMCore:nodeType>}}) {
        $result = $__nodeobj->{<H::infoset:content>};
      } else {
        ## TODO: Namespace node not supported yet
        ## TODO: XDoctype node types
        __ASSERT{DISPerl:invariant::
          msg => {qq{Node type: "$__nodeobj->{<H::DOMCore:nodeType>}"}}
        }__;
        $result = null;
      }
    @@ImplNote:
      @@@lang:en
      @@@@:
            ISSUE: Element content does not allow non-whitespace 
            character data or CDATA section.  In invalid document, 
            how this is?

  @ResourceDef:
    @@QName: c|setNodeTextContent
    @@rdf:type: DISPerl|BlockCode
    @@Description:
      @@@lang:en
      @@@@:
        Sets a string as the text content of a node.
    @@ForCheck:
      ManakaiDOM:ForClass
    @@PerlDef:
            my $__node = $node->{<H::mn:node>};
            if ($__node->{<H::DOMCore:read-only>}) {
              __EXCEPTION{
                MDOMX:NOMOD_THIS::
              }__;
            }
            my @__oldChild = @{$__node->{<H::infoset:children>}};
            for my $__oc (@__oldChild) {
              CORE::delete $__oc->{<H::infoset:parent>};
            }
            $__node->{<H::infoset:children>} = [];
          if (defined $given and length $given) {
            my $__textNode = <ClassM::ManakaiDOMText.newObject> ($__node);
            __CODE{mn|setXRefNode||ManakaiDOM|Perl::
              $referrer => {$__textNode},
              $propName => {<H::DOMCore:ownerDocument>},
              $referent => {$__node->{<H::DOMCore:ownerDocument>}},
            }__;
            $__textNode->{<H::infoset:content>} = $given;
            $__textNode->{<H::infoset:parent>} = $__node;
            $__node->{<H::infoset:children>} = [$__textNode];
          }
            for my $__oc (@__oldChild) {
              $__oc-><M::NodeStem.orphanate>;
            }
  @Method:
     @@Name:  isSameNode
     @@Description:
        @@@lang:en
        @@@@:
          Return whether this node is the same node as the given one.
        \
          When two "Node" references are references to the same object, 
          even if through a proxy, the references may be used completely 
          interchangably, such that all attributes have the same values 
          and calling the same method on either reference always has 
          exactly same effect.
     @@Operator:
        @@@@: eq
        @@@ContentType:
          lang:Perl
        @@@For:
          ManakaiDOM:ManakaiDOM
     @@Param:
        @@@Name:  other
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@: The node to test against.
     @@Return:
        @@@Type:  DOMMain|boolean||ManakaiDOM|all
        @@@InCase:
          @@@@Value: true
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The two nodes are the same.
        @@@InCase:
          @@@@Value: false
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The two nodes are not same.
        @@@PerlDef:
            if (UNIVERSAL::isa ($other, <IFName::NodeRef>) and
                $other->{<H::mn:node>}->{<H::mn:nodeID>}
                  eq $self->{<H::mn:node>}->{<H::mn:nodeID>}) {
              $r = true;
            }
     @@Level[list]:  3
     @@SpecLevel:3
     @@For:
       ManakaiDOM:DOM3
  @Method:
     @@Name:  lookupPrefix
     @@Description:
       @@@lang:en
       @@@@:
         Lookup the namespace prefix associated to the given namespace 
         URI, starting from this node.
       \
         The default namespace declarations are ignored by this method. 
         To lookup default namespace, use the <M::Node.isDefaultNamespace>
         method.
     @@DOMMain:isNamespaceAware:1
     @@Param:
        @@@Name:  namespaceURI
        @@@Type:
          DOMMain:DOMString
        @@@actualType:
          ManakaiDOM:ManakaiDOMNamespaceURI
        @@@Description:
          @@@@lang:en
          @@@@@: The namespace URI to look for.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Always <DOM::null> will be returned.
        @@@InCase:
          @@@@Value:\
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Always <DOM::null> will be returned.
     @@Return:
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            An associated namespace prefix.
          \
            If more than one prefix are associated to the 
            namespace URI, which is returned is implementation 
            dependent.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              No namespace prefix is found.
        @@@PerlDef:
            if (not defined $namespaceURI) {
              $r = null;
            } else {
              my $n = $self->{<H::mn:node>};
              ANCESTOR: {
                if ($n->{<H::infoset:parent>}) {
                  $n = $n->{<H::infoset:parent>};
                  if ($n->{<H::DOMCore:nodeType>} eq <H::infoset:Element>) {
                    $r = $n-><M::ManakaiDOMCore:ManakaiDOMNodeObjectNode
                                  .lookupNamespacePrefix> ($namespaceURI, $n);
                    last ANCESTOR;
                  } else {
                    redo ANCESTOR;
                  }
                }
                $r = null;
              } # ANCESTOR
            }
     @@Level[list]:  3
     @@SpecLevel:3
     @@For:
       ManakaiDOM:DOM3
  @Method:
     @@Name:  isDefaultNamespace
     @@Description:
       @@@lang:en
       @@@@:
         Return whether the given namespace URI is the default namespace.
     @@DOMMain:isNamespaceAware:1
     @@Param:
        @@@Name:  namespaceURI
        @@@Type: 
          DOMMain:DOMString
        @@@actualType:
          ManakaiDOM:ManakaiDOMNamespaceURI
        @@@Description:
          @@@@lang:en
          @@@@@:
            The namespace URI to look for.
     @@Return:
        @@@Type:  DOMMain|boolean||ManakaiDOM|all
        @@@InCase:
          @@@@Value:true
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The specified <P::namespaceURI> is the default namespace.
        @@@InCase:
          @@@@Value:false
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The specified <P::namespaceURI> is not the default namespace.
        @@@PerlDef:
            $r = $self->{<H::mn:node>}
                      -><M::ManakaiDOMCore:ManakaiDOMNodeObjectNode
                              .isDefaultNamespace> ($namespaceURI);
     @@For:
       ManakaiDOM:DOM3
     @@Level[list]:  3
     @@SpecLevel:3
  @Method:
     @@Name:  lookupNamespaceURI
     @@Description:
       @@@lang:en
       @@@@:
         Lookup the namespace URI associated to the given 
         prefix, starting from this node.
     @@DOMMain:isNamespaceAware:1
     @@Param:
        @@@Name:  prefix
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            The prefix to look for.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Return the default namespace URI if any.
     @@Return:
        @@@Type:
          DOMMain:DOMString
        @@@actualType:
          ManakaiDOM:ManakaiDOMNamespaceURI
        @@@Description:
          @@@@lang:en
          @@@@@:
            The associated namespace URI.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              No associated namespace URI found.
        @@@PerlDef:
            $r = $self->{<H::mn:node>}
                      -><M::ManakaiDOMCore:ManakaiDOMNodeObjectNode
                                    .lookupNamespaceURI> ($prefix);
     @@For:
       ManakaiDOM:DOM3
     @@Level[list]:  3
     @@SpecLevel:3
  @Method:
     @@Name:  isEqualNode
     @@ManakaiDOM:isForInternal:
       @@@@:1
       @@@For:
         !ManakaiDOM:DOM3
     @@For:
       ManakaiDOM:DOM3
     @@For:
       ManakaiDOM:ManakaiDOM
     @@Operator:
       @@@@: ==
       @@@ContentType:
          lang:Perl
       @@@For:
         ManakaiDOM:ManakaiDOM
     @@Description:
       @@@lang:en
       @@@@: 
         Test whether two nodes are equal.
       \
         Two nodes are equal if their node types, node names, 
         contents, attributes and some DOM attributes are equal. 
         Their parent nodes, schema type, user data and some other DOM 
         attributes do not affect equality.  Future versions of 
         DOM may take into account more DOM attributes.
      @@ImplNote:
        @@@lang:en
        @@@@:
          DOM implementations are expected to be updated when 
          future versions of DOM specify to take into 
          account more DOM attributes.
      @@Param:
        @@@Name:  arg
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@: 
            The node to compare equality with.
            \
            {NOTE:: The <P::arg> may or may not be an instance of 
                    the manakai DOM implementation, while: 
              \
              - It implements the feature <Feature::Core> version 
                <FeatureVer::2.0> and, if it is a <IF::DOMXML:DocumentType> 
                node, the feature <Feature::XML> version <Feature::2.0>; 
                to test their equality, as defined by DOM Level 3 Core, 
                some DOM Level 2 attributes are required.
              \
              - It shares the same naming convention for method and 
                attribute names.
              \
              - Its implementation overloads the operator <Perl::==> 
                for <IF::NodeList> and <IF::NamedNodeMap> objects, 
                testing their equality as per DOM Level 3.
              \
            } 
     @@Return:
        @@@Type:  DOMMain|boolean||ManakaiDOM|all
        @@@InCase:
          @@@@Value:true
          @@@@Description:
            @@@@@lang:en
            @@@@@@: Two nodes are equal.
        @@@InCase:
          @@@@Value:false
          @@@@Description:
            @@@@@lang:en
            @@@@@@: Two nodes are not equal.
        @@@PerlDef:
          __DEEP{
            EQ: {
              last EQ unless $self-><AG::Node.nodeType> eq
                             $arg-><AG::Node.nodeType>;
              for my $v ([$self-><AG::Node.nodeName>,
                          $arg-><AG::Node.nodeName>],
                         [$self-><AG::Node.localName>,
                          $arg-><AG::Node.localName>],
                         [$self-><AG::Node.namespaceURI>,
                          $arg-><AG::Node.namespaceURI>],
                         [$self-><AG::Node.prefix>, $arg-><AG::Node.prefix>], 
                         [$self-><AG::Node.nodeValue>, 
                          $arg-><AG::Node.nodeValue>]) {
                if (not defined $v->[0] and not defined $v->[1]) {
                  #
                } elsif (defined $v->[0] and defined $v->[1] and
                         ''.$v->[0] eq ''.$v->[1]) {
                  # 
                } else {
                  last EQ;
                }
              }
              for my $v ([$self-><AG::Node.attributes>, 
                          $arg-><AG::Node.attributes>],
                         [$self-><AG::Node.childNodes>, 
                          $arg-><AG::Node.childNodes>]) {
                if (not defined $v->[0] and not defined $v->[1]) {
                  #
                } elsif (defined $v->[0] and defined $v->[1] and
                         $v->[0] == $v->[1]) {
                  #
                } else {
                  last EQ;
                }
              }
              if ($self-><AG::Node.nodeType> == <C::Node.DOCUMENT_TYPE_NODE>) {
                for my $v ([$self-><AG::DOMXML:DocumentType.publicId>,
                            $arg-><AG::DOMXML:DocumentType.publicId>],
                           [$self-><AG::DOMXML:DocumentType.systemId>, 
                            $arg-><AG::DOMXML:DocumentType.systemId>],
                           [$self-><AG::DOMXML:DocumentType.internalSubset>,
                            $arg-><AG::DOMXML:DocumentType.internalSubset>]) {
                  if (not defined $v->[0] and not defined $v->[1]) {
                    #
                  } elsif (defined $v->[0] and defined $v->[1] and
                           ''.$v->[0] eq ''.$v->[1]) {
                    # 
                  } else {
                    last EQ;
                  }
                }
                for my $v ([$self-><AG::DOMXML:DocumentType.entities>,
                            $arg-><AG::DOMXML:DocumentType.entities>],
                           [$self-><AG::DOMXML:DocumentType.notations>,
                            $arg-><AG::DOMXML:DocumentType.notations>]) {
                  if (not defined $v->[0] and not defined $v->[1]) {
                    #
                  } elsif (defined $v->[0] and defined $v->[1] and
                           $v->[0] == $v->[1]) {
                    #
                  } else {
                    last EQ;
                  }
                }
              }
              $r = true;
            } # EQ
          }__;
    @@Level[list]:  3
    @@SpecLevel:3
    @@For:
      ManakaiDOM:DOM3
    @@enImplNote:
      {TODO:: <Module::MDOM:XDoctype> node types must be supported.
      }

  @Method:
     @@Name:  getFeature
     @@enDesc:
       Returns a specialized object that implements the
       specialized interfaces of the specified feature and version.
     @@Param:
        @@@Name:  feature
        @@@Type:  
          DOMMain:DOMString
        @@@actualType: ManakaiDOM|ManakaiDOMFeatureName
        @@@enDesc:
          The feature name to request.
        @@@InCase:
          @@@@Label:
            @@@@@lang:en
            @@@@@@: 
              Feature name preceded by a <CHAR::PLUS SIGN>
          @@@@enDesc:
            The <CHAR::PLUS SIGN> is ignored.
     @@Param:
        @@@Name:  version
        @@@Type:  
          DOMMain:DOMString
        @@@actualType: ManakaiDOM|ManakaiDOMFeatureVersion
        @@@enDesc:
          The feature version to request.
        @@@nullCase:
          @@@@enDesc:
            No specific version is requested.
     @@Level[list]:  3
     @@SpecLevel:3
     @@For:
       ManakaiDOM:DOM3
     @@Return:
        @@@Type:  
          DOMMain:DOMObject
        @@@enDesc:
          An object implementing the specialized interfaces.
          Note that the specialized object may or may not
          implement the <IF::Node> interface.
        @@@nullCase:
          @@@@enDesc:
            There is no object available that implements
            the specialized interfaces.
        @@@disDef:
          @@@@DISLang:nop:
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              Implemented by each inheriting classes.

  @L3Method:
    @@Name: setUserData
    @@enDesc:
      Associates an object to a key on the node.  The object can later
      be retrieved from the node by calling <M::Node.getUserData>
      method with the same key.
    @@enDesc:
      @@@ForCheck: ManakaiDOM|Perl ManakaiDOM|ForClass
      @@@ddid: pleak
      @@@@:
        {NOTE:: Application developers are advised to be careful
                to include direct or indirect references to the node
                itself as user data or in user data handlers.
                They would result in memory leak problems unless
                the circular references are removed later.
                
                It would be a good practive to eusure that every user data
                registered to a node is later unregistered by setting
                <DOM::null> as a data for the same key.
        }
    @@Param:
      @@@Name: key
      @@@Type: DOMMain|DOMString
      @@@enDesc:
        The key to associate the <P::data> to.
    @@Param:
      @@@Name: data
      @@@Type: DOMMain|DOMUserData
      @@@enDesc:
        The object to associate to the given key.
      @@@nullCase:
        @@@@enDesc:
          Removes any existing association to the <P::key>.
    @@Param:
      @@@Name: handler
      @@@Type: c|UserDataHandler
      @@@enDesc:
        The handler to associate to the <P::key>.
      @@@nullCase:
        @@@@enDesc:
          No handler is associated.
    @@Return:
      @@@Type: DOMMain|DOMUserData
      @@@enDesc:
        The object previously associated to the <P::key> on the node.
      @@@nullCase:
        @@@@enDesc:
          No object was associated.
      @@@PerlDef:
        $r = $self->{<H::mn:node>}->{<H::t|userData>}->{$key}->[0];
        if (defined $data) {
          $self->{<H::mn:node>}->{<H::t|userData>}->{$key} = [$data, $handler];
        } else {
          CORE::delete $self->{<H::mn:node>}->{<H::t|userData>}->{$key};
        }

  @L3Method:
    @@Name: getUserData
    @@enDesc:
      Retrieves the object associated to a key on the node.
    @@Param:
      @@@Name: key
      @@@Type: DOMMain|DOMString
      @@@enDesc:
        The key the object is associated to.
    @@Return:
      @@@Type: DOMMain|DOMUserData
      @@@enDesc:
        The object associated to the given <P::key> on the node.
      @@@nullCase:
        @@@@enDesc:
          No object is associated.
      @@@PerlDef:
        $r = $self->{<H::mn:node>}->{<H::t|userData>}->{$key}->[0];

  @L3Test:
    @@QName: GetSetUserDataTest
    @@PerlDef:
      my $impl = <Class::c|ManakaiDOMImplementation>->_new;
      my $node = $impl-><M::c|DOMImplementation.createDocument>;

      my $data = ['2'];
      my $handler = sub { 1 };

      $test->assert_null
               ($node-><M::Node.setUserData> ('key1', $data, $handler),
                uri => <Q::GetSetUserDataTest.InitialReturnNull>);

      my $key1_data = $node-><M::Node.getUserData> ('key1');
      $test->assert_not_null ($key1_data);
      $test->assert_equals ($data->[0], $key1_data->[0]);
      $test->assert_equals
               ($handler, $node->{<H::mn:node>}->{<H::t|userData>}->{key1}->[1]);
      $test->assert_true
               ($node->{<H::mn:node>}->{<H::t|userData>}->{key1}->[1]
                     ->isa (<IFName::c|UserDataHandler>));

      my $data2 = ['4'];
      
      $test->assert_equals ($node-><M::Node.setUserData> ('key1', $data2, null),
                            $data);
      
      $test->assert_equals ($node-><M::Node.getUserData> ('key1'), $data2);
      $test->assert_null ($node->{<H::mn:node>}->{<H::t|userData>}->{key1}->[1]);

      $node-><M::Node.setUserData> ('key1', null, $handler);
      $test->assert_null ($node-><M::Node.getUserData> ('key1'));
      $test->assert_null ($node->{<H::mn:node>}->{<H::t|userData>}->{key1}->[1]);

      $node-><M::Node.setUserData> ('key1', null, null);
      $test->assert_null ($node-><M::Node.getUserData> ('key1'));
      $test->assert_null ($node->{<H::mn:node>}->{<H::t|userData>}->{key1}->[1]);

  @IntMethod:
    @@Name: newObject
    @@Description:
      @@@lang:en
      @@@@: 
        Construct an object for a new instance of the <IF::Node>.
    @@Param:
      @@@Name: refClass
      @@@Type: DOMString
      @@@enDesc:
        The name of a <IF::mn|NodeRef||ManakaiDOM|Perl> class.
    @@NewObjectRefNodeParam:
    @@Return:
      @@@Type: NodeStem
      @@@Description:
        @@@@lang:en
        @@@@@:
          The object for the <IF::Node> to be created.
      @@@PerlDef:
        if (defined $refNode) {
          $r = bless $refNode-><M::NodeStem.newNode> ($refClass),
                            <ClassName::ManakaiDOMCore:ManakaiDOMNodeObjectNode>;
        } else {
          $r = bless <ClassM::ManakaiNode|ManakaiNodeStem||
                                         ManakaiDOM|Perl.new> ($refClass),
                            <ClassName::ManakaiDOMCore:ManakaiDOMNodeObjectNode>;
        }
       @@@enImplNote:
         {P::: <IF::Node> properties:

             - <Q::DOMCore:nodeType> (required)

             - <Q::infoset:localName> (required for Level 2 element or
                                       attribute nodes)

             - <Q::infoset:prefix> (for Level 2 element, attribute,
                                    or doctype node)

             - <Q::DOMCore:ownerDocument>

           <Q::DOMCore:ownerDocument> (required for an <IF::Node> whose 
           type is other than <IF::Document> and <IF::DOMXML:DocumentType>), 
           <Q::infoset:namespaceName>, <Q::DOMCore:name>,
           <Q::DOMCore:read-only>.
  @mn:anydata2: t|userData

  @IntMethod:
    @@Name: getNodeReference
    @@Description:
      @@@lang:en
      @@@@:
        Create a new "Node" object blessed with the appropriate class.
      \
        To create a new "Document", use the internal method 
        "newByDocumentType" of the "Document" interface.
    @@Param:
      @@@Name: object
      @@@Type: NodeStem
      @@@Description:
        @@@@lang:en
        @@@@@: The node object referred to.
    @@Param:
      @@@Name: interface
      @@@Type: DOMMain|DOMString
      @@@enDesc:
        The package name of the interface the return value
        <kwd:MUST> implement in addition to the base interface
        for the node type.
      @@@nullCase:
        @@@@enDesc:
          No additional interface is required.
    @@Return:
      @@@Type: ManakaiDOMNode
      @@@Description:
        @@@@lang:en
        @@@@@: 
          The node reference.  It may implement specialized 
          interfaces for the specific document type or so on. 
      @@@PerlDef:
          my $nt = $object->{<H::DOMCore:nodeType>};
          my $class;
        UNKNOWN: {
          if (defined $object->{<H::DOMCore:nodeRefClass>} and
              (not defined $interface or
               $object->{<H::c|nodeRefClass>}->isa ($interface))) {
            $class = ${$object->{<H::DOMCore:nodeRefClass>}};
            last UNKNOWN;
          }
          FIND: {
          if ($nt eq <H::infoset:Element>) {
            my $ns;
            my $ln;
            if (defined $object->{<H::infoset:localName>}) { ## Namespace-aware
              $ns = $object->{<H::infoset:namespaceName>};
              $ns = \'' unless defined $ns;
              $ln = $object->{<H::infoset:localName>};
            } elsif ($object->{<H::DOMCore:ownerDocument>}
                            ->{<H::DOMCore:hasFeature>}->{HTML}) {
              $ns = \<Q::xhtml1:>;
              $ln = lc $object->{<H::DOMCore:name>};
            }
            if (defined $ln) {
              for my $pack (sort {
                $Message::DOM::ClassPoint{$b} <=> $Message::DOM::ClassPoint{$a}
              } keys %{
                $Message::DOM::ManakaiDOMElement::CompatClassET{$$ns}->{$ln}
              }) {
                if ($pack->isa (<IFName::Element>) and
                    (not defined $interface or
                     $pack->isa ($interface))) {
                  $class = $pack;
                  last FIND;
                }
              }
              for my $pack (sort {
                $Message::DOM::ClassPoint{$b} <=> $Message::DOM::ClassPoint{$a}
              } keys %{
                $Message::DOM::ManakaiDOMElement::CompatClassET{$$ns}->{'*'}
              }) {
                if ($pack->isa (<IFName::Element>) and
                    (not defined $interface or
                     $pack->isa ($interface))) {
                  $class = $pack;
                  last FIND;
                }
              }
            }
            for my $pack (sort {
              $Message::DOM::ClassPoint{$b} <=> $Message::DOM::ClassPoint{$a}
            } keys %Message::DOM::ManakaiDOMElement::CompatClass) {
              if ($pack->isa (<IFName::Element>) and
                    (not defined $interface or
                     $pack->isa ($interface))) {
                $class = $pack;
                last FIND;
              }
            }
            $class = <ClassName::ManakaiDOMElement>;
          } elsif ($nt eq <H::infoset:Attribute>) {
            ## TODO: Find class by namespace URI and local name
            for my $pack (sort {
              $Message::DOM::ClassPoint{$b} <=> $Message::DOM::ClassPoint{$a}
            } keys %Message::DOM::ManakaiDOMAttr::CompatClass) {
              if ($pack->isa (<IFName::Attr>) and
                    (not defined $interface or
                     $pack->isa ($interface))) {
                $class = $pack;
                last FIND;
              }
            }
            $class = <ClassName::ManakaiDOMAttr>;
          } elsif ($nt eq <H::DOMCore:TextNode>) {
            for my $pack (sort {
              $Message::DOM::ClassPoint{$b} <=> $Message::DOM::ClassPoint{$a}
            } keys %Message::DOM::ManakaiDOMText::CompatClass) {
              if ($pack->isa (<IFName::Text>) and
                    (not defined $interface or
                     $pack->isa ($interface))) {
                $class = $pack;
                last FIND;
              }
            }
            $class = <ClassName::ManakaiDOMText>;
          } elsif ($nt eq <H::infoset:Comment>) {
            for my $pack (sort {
              $Message::DOM::ClassPoint{$b} <=> $Message::DOM::ClassPoint{$a}
            } keys %Message::DOM::ManakaiDOMComment::CompatClass) {
              if ($pack->isa (<IFName::Comment>) and
                    (not defined $interface or
                     $pack->isa ($interface))) {
                $class = $pack;
                last FIND;
              }
            }
            $class = <ClassName::ManakaiDOMComment>;
          } elsif ($nt eq <H::infoset:Document>) {
            CHILD: for my $co (@{$object->{<H::infoset:children>}}) {
              ## By root element type
              if ($co->{<H::DOMCore:nodeType>} eq <H::infoset:Element>) {
                my $ns;
                my $ln;
                if (defined $co->{<H::infoset:localName>}) { ## Namespace-aware
                  $ns = $co->{<H::infoset:namespaceName>};
                  $ns = \'' unless defined $ns;
                  $ln = $co->{<H::infoset:localName>};
                } elsif ($co->{<H::DOMCore:ownerDocument>}
                            ->{<H::DOMCore:hasFeature>}->{HTML}) {
                  $ns = \<Q::xhtml1:>;
                  $ln = lc $co->{<H::DOMCore:name>};
                }
                if (defined $ln) {
                  for my $pack (sort {
                    $Message::DOM::ClassPoint{$b} <=>
                    $Message::DOM::ClassPoint{$a}
                  } keys %{
                    $Message::DOM::ManakaiDOMDocument::CompatClassET{$$ns}->{$ln}
                  }) {
                    if ($pack->isa (<IFName::Document>) and
                        (not defined $interface or
                         $pack->isa ($interface))) {
                      $class = $pack;
                      last FIND;
                    }
                  }
                  for my $pack (sort {
                    $Message::DOM::ClassPoint{$b} <=>
                    $Message::DOM::ClassPoint{$a}
                  } keys %{
                    $Message::DOM::ManakaiDOMDocument::CompatClassET{$$ns}->{'*'}
                  }) {
                    if ($pack->isa (<IFName::Document>) and
                        (not defined $interface or
                         $pack->isa ($interface))) {
                      $class = $pack;
                      last FIND;
                    }
                  }
                }
                last CHILD; # Not found

              ## By document type or by external subset identifier
              } elsif ($co->{<H::DOMCore:nodeType>} eq
                       <H::infoset:DocumentTypeDeclaration>) {

                # Not found --> checking root element
              }
            } # CHILD

            if ($object->{<H::DOMCore:hasFeature>}->{HTML}) {
              for my $pack (sort {
                    $Message::DOM::ClassPoint{$b} <=>
                    $Message::DOM::ClassPoint{$a}
              } keys %{
                $Message::DOM::ManakaiDOMDocument::CompatClassET{<Q::xhtml1:>}
                                                              ->{'*'}
              }) {
                if ($pack->isa (<IFName::Document>) and
                    (not defined $interface or
                     $pack->isa ($interface))) {
                  $class = $pack;
                  last FIND;
                }
              }
            }

            for my $pack (sort {
              $Message::DOM::ClassPoint{$b} <=> $Message::DOM::ClassPoint{$a}
            } keys %Message::DOM::ManakaiDOMDocument::CompatClass) {
              if ($pack->isa (<IFName::Document>) and
                  (not defined $interface or
                   $pack->isa ($interface))) {
                $class = $pack;
                last FIND;
              }
            }
            $class = <ClassName::ManakaiDOMDocument>;
          } elsif ($nt eq <H::infoset:ProcessingInstruction>) {
            ## TODO: Find class by namespace URI and local name
            for my $pack (sort {
              $Message::DOM::ClassPoint{$b} <=> $Message::DOM::ClassPoint{$a}
            } keys %Message::DOM::ManakaiDOMProcessingInstruction::CompatClass) {
              if ($pack->isa (<IFName::DOMXML:ProcessingInstruction>) and
                  (not defined $interface or
                   $pack->isa ($interface))) {
                $class = $pack;
                last FIND;
              }
            }
            $class = <ClassName::DOMXML:ManakaiDOMProcessingInstruction>;
          } elsif ($nt eq <H::DOMXML:CDATASectionNode>) {
            for my $pack (sort {
              $Message::DOM::ClassPoint{$b} <=> $Message::DOM::ClassPoint{$a}
            } keys %Message::DOM::ManakaiDOMCDATASection::CompatClass) {
              if ($pack->isa (<IFName::DOMXML:CDATASection>) and
                  (not defined $interface or
                   $pack->isa ($interface))) {
                $class = $pack;
                last FIND;
              }
            }
            $class = <ClassName::DOMXML:ManakaiDOMCDATASection>;
          } elsif ($nt eq <H::DOMXML:EntityReferenceNode>) {
            for my $pack (sort {
              $Message::DOM::ClassPoint{$b} <=> $Message::DOM::ClassPoint{$a}
            } keys %Message::DOM::ManakaiDOMEntityReference::CompatClass) {
              if ($pack->isa (<IFName::DOMXML:EntityReference>) and
                  (not defined $interface or
                   $pack->isa ($interface))) {
                $class = $pack;
                last FIND;
              }
            }
            $class = <ClassName::DOMXML:ManakaiDOMEntityReference>;
          } elsif ($nt eq <H::DOMCore:DocumentFragmentNode>) {
            for my $pack (sort {
              $Message::DOM::ClassPoint{$b} <=> $Message::DOM::ClassPoint{$a}
            } keys %Message::DOM::ManakaiDOMDocumentFragment::CompatClass) {
              if ($pack->isa (<IFName::DocumentFragment>) and
                  (not defined $interface or
                   $pack->isa ($interface))) {
                $class = $pack;
                last FIND;
              }
            }
            $class = <ClassName::ManakaiDOMDocumentFragment>;
          } elsif ($nt eq <H::infoset:DocumentTypeDeclaration>) {
            for my $pack (sort {
              $Message::DOM::ClassPoint{$b} <=> $Message::DOM::ClassPoint{$a}
            } keys %Message::DOM::ManakaiDOMDocumentType::CompatClass) {
              if ($pack->isa (<IFName::DOMXML:DocumentType>) and
                  (not defined $interface or
                   $pack->isa ($interface))) {
                $class = $pack;
                last FIND;
              }
            }
            $class = <ClassName::DOMXML:ManakaiDOMDocumentType>;
          } elsif ($nt eq <H::DOMXML:EntityNode>) {
            for my $pack (sort {
              $Message::DOM::ClassPoint{$b} <=> $Message::DOM::ClassPoint{$a}
            } keys %Message::DOM::ManakaiDOMEntity::CompatClass) {
              if ($pack->isa (<IFName::DOMXML:Entity>) and
                  (not defined $interface or
                   $pack->isa ($interface))) {
                $class = $pack;
                last FIND;
              }
            }
            $class = <ClassName::DOMXML:ManakaiDOMEntity>;
          } elsif ($nt eq <H::infoset:Notation>) {
            for my $pack (sort {
              $Message::DOM::ClassPoint{$b} <=> $Message::DOM::ClassPoint{$a}
            } keys %Message::DOM::ManakaiDOMNotation::CompatClass) {
              if ($pack->isa (<IFName::DOMXML:Notation>) and
                  (not defined $interface or
                   $pack->isa ($interface))) {
                $class = $pack;
                last FIND;
              }
            }
            $class = <ClassName::DOMXML:ManakaiDOMNotation>;
          ## TODO: Namespace

          } elsif ($nt eq <H::d|ElementTypeDefinitionNodeType>) {
            for my $pack (sort {
              $Message::DOM::ClassPoint{$b} <=> $Message::DOM::ClassPoint{$a}
            } keys %Message::DOM::ManakaiDOMElementTypeDefinition::CompatClass) {
              if ($pack->isa (<IFName::d|ElementTypeDefinition>) and
                  (not defined $interface or
                   $pack->isa ($interface))) {
                $class = $pack;
                last FIND;
              }
            }
            __FOR{ManakaiDOM:ManakaiDOMLatest::
              $class = <ClassName::d|ManakaiDOMElementTypeDefinition>;
            }__;
            __FOR{!ManakaiDOM:ManakaiDOMLatest::
              $class = <ClassName::d|ManakaiDOMElementTypeDefinition
                                 ||ManakaiDOM|ManakaiDOMLatest>;
            }__;
            last FIND;

          } elsif ($nt eq <H::d|AttributeDefinitionNodeType>) {
            for my $pack (sort {
              $Message::DOM::ClassPoint{$b} <=> $Message::DOM::ClassPoint{$a}
            } keys %Message::DOM::ManakaiDOMAttributeDefinition::CompatClass) {
              if ($pack->isa (<IFName::d|AttributeDefinition>) and
                  (not defined $interface or
                   $pack->isa ($interface))) {
                $class = $pack;
                last FIND;
              }
            }
            __FOR{ManakaiDOM:ManakaiDOMLatest::
              $class = <ClassName::d|ManakaiDOMAttributeDefinition>;
            }__;
            __FOR{!ManakaiDOM:ManakaiDOMLatest::
              $class = <ClassName::d|ManakaiDOMAttributeDefinition
                                 ||ManakaiDOM|ManakaiDOMLatest>;
            }__;
             last FIND;

          } else {
            __EXCEPTION{
              MDOMX:MDOM_DEBUG_BUG||ManakaiDOM:Perl::
                MDOMX:values => {{
                  <H::DOMCore:nodeType> => $nt,
                }},
            }__;
          }
          } # FIND
          __CODE{DISPerl|HashStringRef||ManakaiDOM|all::
            $result => {$object->{<H::DOMCore:nodeRefClass>}},
            $given => $class,
          }__;
        } # UNKNOWN
          __CODE{getNodeRef::
            $object => $object,
            $ref => $r,
            $class => $class,
          }__;

  @IntMethod:
    @@Name: getCoreNodeReference
    @@Description:
      @@@lang:en
      @@@@:
        Create a new "Node" object blessed with the appropriate class.
    @@Param:
      @@@Name: object
      @@@Type: NodeStem
      @@@Description:
        @@@@lang:en
        @@@@@: The node object referred to.
    @@Return:
      @@@Type: ManakaiDOMNode
      @@@Description:
        @@@@lang:en
        @@@@@: The node reference.
      @@@PerlDef:
          my $nt = $object->{<H::DOMCore:nodeType>};
          my $class;
          if ($nt eq <H::infoset:Element>) {
            $class = <ClassName::ManakaiDOMElement>;
          } elsif ($nt eq <H::infoset:Attribute>) {
            $class = <ClassName::ManakaiDOMAttr>;
          } elsif ($nt eq <H::DOMCore:TextNode>) {
            $class = <ClassName::ManakaiDOMText>;
          } elsif ($nt eq <H::infoset:Comment>) {
            $class = <ClassName::ManakaiDOMComment>;
          } elsif ($nt eq <H::infoset:Document>) {
            $class = <ClassName::ManakaiDOMDocument>;
          } elsif ($nt eq <H::DOMCore:DocumentFragmentNode>) {
            $class = <ClassName::ManakaiDOMDocumentFragment>;
          } elsif ($nt eq <H::DOMXML:EntityReferenceNode>) {
            $class = <ClassName::DOMXML:ManakaiDOMEntityReference>;
          } elsif ($nt eq <H::infoset:ProcessingInstruction>) {
            $class = <ClassName::DOMXML:ManakaiDOMProcessingInstruction>;
          } elsif ($nt eq <H::DOMXML:EntityNode>) {
            $class = <ClassName::DOMXML:ManakaiDOMEntity>;
          } elsif ($nt eq <H::DOMXML:CDATASectionNode>) {
            $class = <ClassName::DOMXML:ManakaiDOMCDATASection>;
          } elsif ($nt eq <H::infoset:Notation>) {
            $class = <ClassName::DOMXML:ManakaiDOMNotation>;
          } elsif ($nt eq <H::d|ElementTypeDefinitionNodeType>) {
            $class = <ClassName::d|ManakaiDOMElementTypeDefinition>;
          } elsif ($nt eq <H::d|AttributeDefinitionNodeType>) {
            $class = <ClassName::d|ManakaiDOMAttributeDefinition>;
          } else {
            ## TODO: Use assertion
            __EXCEPTION{
              MDOMX:MDOM_DEBUG_BUG||ManakaiDOM:Perl::
                MDOMX:values => {{
                  <H::DOMCore:nodeType> => $nt,
                }},
            }__;
          }
          __CODE{getNodeRef::
            $object => $object,
            $ref => $r,
            $class => $class,
          }__;

  @IntMethod:
    @@For: ManakaiDOM|ManakaiDOM3
    @@Operator: ManakaiDOM|MUErrorHandler
    @@enDesc:
      When a <IF::ecore|ErrorInterface||ManakaiDOM|Perl> is <Perl::report>ed
      with an <Perl::-object> of <IF::Node>, then this method is invoked.
      
      The method calls the <cfg::error-handler> if the error is of 
      <IF::c|DOMError>.  Otherwise, including the cases of <IF::c|DOMException>s,
      the error is rethrown so that appropriate <Perl::catch> clause
      can catch the error.
    @@enImplNote:
      For implementations which does not have the
      <IF::c|DOMError||ManakaiDOM|ManakaiDOM3> interface, the method
      is defined in the <Class::ManakaiDOM|ManakaiDOMObject> class
      and it is not overridden here.
    @@Param:
      @@@Name: err
      @@@Type: ecore|ErrorInterface||ManakaiDOM|Perl
      @@@enDesc:
        The reported error object.
    @@Return:
      @@@Type: DISPerl|Any
      @@@enDesc:
        If the <P::err> is a <IF::c|DOMError>, then the return value
        of the error handler.

           {NOTE:: If the error is thrown, the method never returns.
           }
      @@@nullCase:
        @@@@enDesc:
          No error handler.
      @@@PerlDef:
          if ($err->isa (<IFName::c|DOMError||ManakaiDOM|ManakaiDOM>)) {
            __DEEP{
              A: {
                my $doc = $self-><AG::Node.ownerDocument>;
                if (not defined $doc) {
                  if ($self-><AG::Node.nodeType> == <C::Node.DOCUMENT_NODE>) {
                    $doc = $self;
                  } else {  ## DOCUMENT_TYPE_NODE
                    CORE::warn $err;
                    last A;
                  }
                }
                my $cfg = $doc-><AG::Document.domConfig>;
                my $h = $cfg-><M::c|DOMConfiguration.getParameter>
                                 ('error-handler');
                $r = $h-><M::c|DOMErrorHandler.handleError> ($err);
              } # A
            }__;
          } else {
            $err-><M::ecore|ErrorInterface||ManakaiDOM|Perl.throw>;
          }
##Node

ElementTypeBinding:
  @Name: ErrDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DOMCore|DOMErrorType
    @@For: ManakaiDOM|DOM3
    @@ecore:textFormatter: ecore|MUErrorFormatter||ManakaiDOM|Perl

ErrDef:
  @QName: t|setting-node-value-no-effect
  @enDesc:
    An attempt is made to set the <A::Node.nodeValue> that is 
    defined as <DOM::null>.  The operation has no effect.
  @c:severity: c|SEVERITY_WARNING
  @c:relatedData:
    @@enDesc:
      The node whose node value is attempted to change.

ErrDef:
  @QName: t|insert-before-itself
  @enDesc:
    An attempt is made to insert a node before itself.
    The result is implementation dependent; it has no effect
    in manakai.
  @c:severity: c|SEVERITY_WARNING
  @c:relatedData:
    @@enDesc:
      The node attempted to insert.

ErrDef:
  @QName: t|replace-by-itself
  @enDesc:
    An attempt is made to replace a node by itself.
    The result is implementation dependent; it has no effect
    in manakai.
  @c:severity: c|SEVERITY_WARNING
  @c:relatedData:
    @@enDesc:
      The node attempted to replace.

ErrDef:
  @QName: t|setting-prefix-no-effect-because-of-node
  @enDesc:
    An attempt is made to set the <A::Node.prefix> that is 
    defined as <DOM::null> since it is not an <IF::Element> or <IF::Attr>
    node or since it is a DOM Level 1 (i.e. namespace unaware) node.
    The operation has no effect.
  @c:severity: c|SEVERITY_WARNING
  @c:relatedData:
    @@enDesc:
      The node attempted to change its prefix.

ErrDef:
  @QName: t|setting-prefix-no-effect-because-of-document
  @enDesc:
    An attempt is made to set the <A::Node.prefix> that is 
    defined as <DOM::null> since its owner document does
    not support XML namespaces.  The operation has no effect.
  @c:severity: c|SEVERITY_WARNING
  @c:relatedData:
    @@enDesc:
      The node attempted to change its prefix.

PropDef:
  @QName: t|userData
  @enDesc:
    A hash reference whose value is a reference to the array of 
    data and its handler.
  @rdfs:domain: Node
  @rdfs:range: DISPerl|HASH
  @c:nodeProp: ud

PropDef:
  @QName: DOMCore|nodeRefClass
  @enDesc:
    A fully qualified package name of the node reference class that is most
    <QUOTE::natural> for the node.
  @c:nodeProp: cp

PropDef:
  @QName: DOMCore|nodeProp
  @enDesc:
    The name of the property when it is used as an internal property
    hash key for nodes.
  @rdfs:subPropertyOf: mn|stemName
  @dataType: DISCore|String
  @multipleProperties: DISCore|Single

PropDef:
  @QName: DOMCore|read-only
  @enDesc:
    Whether a node is read-only or not.
  @Type: DISPerl|Boolean
  @c:nodeProp: ro

ElementTypeBinding:
  @Name: RoleDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:Role
    @@ForCheck:
      =ManakaiDOM:all

RoleDef:
  @QName: c|ElementRole
  @enDesc:
    Any class playing this role may be retrievable from 
    <M::Node.getFeature> method of an <IF::Element> node. 

RoleDef:
  @QName: c|AttributeRole
  @enDesc:
    Any class playing this role may be retrievable from 
    <M::Node.getFeature> method of an <IF::Attr> node. 

RoleDef:
  @QName: c|TextRole
  @enDesc:
    Any class playing this role may be retrievable from 
    <M::Node.getFeature> method of an <IF::Text> node. 

RoleDef:
  @QName: c|CommentRole
  @enDesc:
    Any class playing this role may be retrievable from 
    <M::Node.getFeature> method of an <IF::Comment> node. 

RoleDef:
  @QName: c|DocumentRole
  @enDesc:
    Any class playing this role may be retrievable from 
    <M::Node.getFeature> method of an <IF::Document> node. 

RoleDef:
  @QName: c|DocumentFragmentRole
  @enDesc:
    Any class playing this role may be retrievable from 
    <M::Node.getFeature> method of an <IF::DocumentFragment> node. 

RoleDef:
  @QName: c|DocumentTypeRole
  @enDesc:
    Any class playing this role may be retrievable from 
    <M::Node.getFeature> method of an <IF::DOMXML:DocumentType> node. 

RoleDef:
  @QName: c|EntityRole
  @enDesc:
    Any class playing this role may be retrievable from 
    <M::Node.getFeature> method of an <IF::DOMXML:Entity> node. 

RoleDef:
  @QName: c|EntityReferenceRole
  @enDesc:
    Any class playing this role may be retrievable from 
    <M::Node.getFeature> method of an <IF::DOMXML:EntityReference> node. 

RoleDef:
  @QName: c|ProcessingInstructionRole
  @enDesc:
    Any class playing this role may be retrievable from 
    <M::Node.getFeature> method of an <IF::DOMXML:ProcessingInstruction> node. 

RoleDef:
  @QName: c|NotationRole
  @enDesc:
    Any class playing this role may be retrievable from 
    <M::Node.getFeature> method of a <IF::DOMXML:Notation> node. 

RoleDef:
  @QName: c|CDATASectionRole
  @enDesc:
    Any class playing this role may be retrievable from 
    <M::Node.getFeature> method of a <IF::DOMXML:CDATASection> node. 

RoleDef:
  @QName: c|NamespaceRole
  @enDesc:
    Any class playing this role may be retrievable from 
    <M::Node.getFeature> method of a <IF::DOMXPath:Namespace> node. 

RoleDef:
  @QName: c|ElementTypeDefinitionRole
  @enDesc:
    Any class playing the <Q::c|ElementTypeDefinitionRole>
    might be retrieved by <M::Node.getFeature> method of
    an <IF::d|ElementTypeDefinition> node.

RoleDef:
  @QName: c|AttributeDefinitionRole
  @enDesc:
    Any class playing the <Q::c|AttributeDefinitionRole>
    might be retrieved by <M::Node.getFeature> method of
    an <IF::d|AttributeDefinition> node.

RoleDef:
  @QName: c|AnyNodeRole
  @enDesc:
    Any class playing this role may be retrievable from 
    <M::Node.getFeature> method of a <IF::Node> node. 
  @rdfs:subClassOf: c|ElementRole
  @rdfs:subClassOf: c|AttributeRole
  @rdfs:subClassOf: c|DocumentRole
  @rdfs:subClassOf: c|DocumentFragmentRole
  @rdfs:subClassOf: c|DocumentTypeRole
  @rdfs:subClassOf: c|TextRole
  @rdfs:subClassOf: c|CommentRole
  @rdfs:subClassOf: c|EntityRole
  @rdfs:subClassOf: c|EntityReferenceRole
  @rdfs:subClassOf: c|NotationRole
  @rdfs:subClassOf: c|ProcessingInstructionRole
  @rdfs:subClassOf: c|CDATASectionRole
  @rdfs:subClassOf: c|NamespaceRole

PropDef:
  @QName: ManakaiDOMCore|nodeMatch
  @enDesc:
    A reference to code to test whether a node matches or not.
  @Type: DISPerl|CODE||ManakaiDOM|all

PropDef:
  @QName: DOMCore|nodeType
  @enDesc:
    The type of the node, i.e. <A::Node||ManakaiDOM|ManakaiDOM.nodeType>.
  @Type: DISPerl|String
  @c:nodeProp: nt

PropDef:
  @QName: c|xmlEncoding
  @enDesc:
    <A::Document.xmlEncoding>
  @c:nodeProp: xcs

ClsDef:
  @ClsQName: 
    ManakaiDOMCore:ManakaiDOMNodeObjectNode
  @ClsISA: ManakaiNode|ManakaiNodeStem||ManakaiDOM|Perl

  @Description:
    @@lang:en
    @@@:
      The extended internal interface for the "ManakaiDOMNodeObject" 
      object used as a "Node".

  @IntMethodC:
    @@Name: contentBaseURI
    @@Description:
      @@@lang:en
      @@@@:
        The base URI by which URI references in the content of 
        this node should be resolved, as per the XML Base Specification.
    @@Param:
      @@@Name:useInfosetProperty
      @@@Type:DOMMain|boolean||ManakaiDOM|all
      @@@Description:
        @@@@lang:en
        @@@@@:
          Whether the <InfosetP::base URI> property of the XML Infoset, 
          if any, should be used to compute the base URI.
    @@Return:
      @@@Type:
        ManakaiDOM:ManakaiDOMURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          The base URI.
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The DOM implementation is unable to obtain an absolute URI.
      @@@PerlDefC:
          $r = null;
          if ($useInfosetProperty and defined $self->{<H::infoset:baseURI>}) {
            ## Note: In XML Infoset, infoset:Document, 
            ##       infoset:Element and infoset:ProcessingInstruction
            ##       allow infoset:baseURI.  In addition, 
            ##       DOMCore:Entity and DOMCore:EntityReference
            ##       may have it, if it is ManakaiDOM:isExternalEntity,
            ##       in this implementation.
            $r = $self->{<H::infoset:baseURI>};
          } else {
            if ($self->{<H::DOMCore:nodeType>} eq <H::infoset:Element>) {
              if ($self->{<H::infoset:attributes>}
                       ->{<Q::xml:>}->{'base'}) {
                $r = $self->{<H::infoset:attributes>}
                          ->{<Q::xml:>}->{'base'}
                          -><M::ManakaiDOMCore:ManakaiDOMNodeObjectNode
                                     .contentBaseURI> ($useInfosetProperty);
              } elsif ($self->{<H::infoset:attributes>}
                            ->{<Q::ManakaiDOM:noNS>}->{'xml:base'}) {
                $r = $self->{<H::infoset:attributes>}
                          ->{<Q::ManakaiDOM:noNS>}->{'xml:base'}
                          -><M::ManakaiDOMCore:ManakaiDOMNodeObjectNode
                                     .contentBaseURI> ($useInfosetProperty);
              }
              if (not defined $r and $self->{<H::infoset:parent>}) {
                $r = $self->{<H::infoset:parent>}
                          -><M::ManakaiDOMCore:ManakaiDOMNodeObjectNode
                                     .contentBaseURI> ($useInfosetProperty);
              }
            } elsif ($self->{<H::DOMCore:nodeType>} eq <H::infoset:Attribute>) {
              if ((defined $self->{<H::infoset:localName>} and
                   $self->{<H::infoset:localName>} eq 'base' and
                   defined $self->{<H::infoset:namespaceName>} and
                   ${$self->{<H::infoset:namespaceName>}} eq <Q::xml:>) or
                  (not defined $self->{<H::infoset:localName>} and
                   $self->{<H::DOMCore:name>} eq 'xml:base')) {
                my $attrcls = <ClassName::ManakaiDOMAttr>;
                $r = <Code::getWeakRef:: $object = $self, $class = $attrcls>
                          -><AG::Attr.value>;
                if (defined $r and
                    <Code::DOMMain:isRelativeDOMURI:: $INPUT = $r>) {
                  if ($self->{<H::infoset:ownerElement>} and
                      $self->{<H::infoset:ownerElement>}
                           ->{<H::infoset:parent>}) {
                    my $base = $self->{<H::infoset:ownerElement>}
                                    ->{<H::infoset:parent>}
                                    -><M::ManakaiDOMCore:ManakaiDOMNodeObjectNode
                                            .contentBaseURI>
                                                     ($useInfosetProperty);
                    if (defined $base) {
                      require URI;
                      $r = URI->new_abs ($r, $base)->as_string;
                    } else {
                      $r = null;
                    }
                  } else {
                    $r = null;
                  }
                }
              } else { # not xml:base
                if ($self->{<H::infoset:ownerElement>}) {
                  $r = $self->{<H::infoset:ownerElement>}
                            -><M::ManakaiDOMCore:ManakaiDOMNodeObjectNode
                                    .contentBaseURI> ($useInfosetProperty);
                }
              }
            } elsif ({
                       <H::DOMCore:TextNode> => 1,
                       <H::DOMXML:CDATASectionNode> => 1,
                       <H::infoset:DocumentTypeDeclaration> => 1,
                       <H::infoset:Comment> => 1,
                       <H::infoset:ProcessingInstruction> => 1,
                       <H::infoset:Notation> => 1, ## but does not have content
                     }->{$self->{<H::DOMCore:nodeType>}}) {
              if ($self->{<H::infoset:parent>}) {
                $r = $self->{<H::infoset:parent>}
                          -><M::ManakaiDOMCore:ManakaiDOMNodeObjectNode
                                   .contentBaseURI> ($useInfosetProperty);
              }
            } elsif ($self->{<H::DOMCore:nodeType>} eq <H::infoset:Document>) {
              ## 2. The base URI of the protocol entity
                # infoset:baseURI
              ## 3. The URI to retrieve the protocol entity
              ## 4. The application defined base URI
              if (defined $self->{<H::DOMCore:documentURI>} and
                  not <Code::DOMMain:isRelativeDOMURI:: $INPUT = $r>) {
                $r = $self->{<H::DOMCore:documentURI>};
              }
            } elsif ({
                       <H::DOMXML:EntityNode> => 1,
                       <H::DOMXML:EntityReferenceNode> => 1,
                     }->{$self->{<H::DOMCore:nodeType>}}) {
              if ($self->{<H::ManakaiDOM:isExpanded>}) {
                if ($self->{<H::ManakaiDOM:isExternalEntity>}) {
                  ## 2. The base URI of the protocol entity
                    # infoset:baseURI
                  ## 3. The URI to retrieve the protocol entity
                  ## 4. The application defined base URI
                  if (defined $self->{<H::DOMCore:documentURI>} and
                      not <Code::DOMMain:isRelativeDOMURI:: $INPUT = $r>) {
                    $r = $self->{<H::DOMCore:documentURI>};
                  }
                  ## Should infoset:systemIdentifier +
                  ## infoset:declarationBaseURI also be used?
                }
              } else {
                if ($self->{<H::infoset:parent>}) {
                  $r = $self->{<H::infoset:parent>}
                            -><M::ManakaiDOMCore:ManakaiDOMNodeObjectNode
                                    .contentBaseURI> ($useInfosetProperty);
                }
              }
            } else {
              # DOMCore:DocumentFragment or 
              # unknown node types
            }
          }
    @@ImplNote:
      @@@lang:en
      @@@@:
        This internal method assumes that the document is an XML 
        document and the base URI is computed by the XML Base 
        Specification.
    @@ImplNote:
      @@@lang:en
      @@@@:
        ISSUE: More study required for the base URI of document type- 
        or entity-related node types.
  @IntMethodC:
    @@Name:htmlBaseURI
    @@Description:
      @@@lang:en
      @@@@:
        Return the base URI, as the document is an HTML document.
    @@Return:
      @@@Type:
        ManakaiDOM:ManakaiDOMURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          An absolute URI.  Although the HTML 4 Specification 
          refers the RFC 2396, the return value is a DOM URI 
          (URI reference, IRI reference or some other identifier), 
          if the source document is broken (see HTML 4 Appendix) or 
          the base URI is provided from the source other than 
          the content of the HTML document (ex. the DOM URI 
          used to retrieve the document or the value of 
          the <A::Document.documentURI>).
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The DOM implementation was not able to obtain an 
            absolute URI.
      @@@PerlDefC:
          $r = null;
          my $doc = $self->{<H::mn:node>}->{<H::DOMCore:ownerDocument>};
          if ($doc and $doc->{<H::DOMCore:hasFeature>}->{HTML}) {
            HTML: {
              DOC: for (@{$doc->{<H::infoset:children>}}) {
                if ($_->{<H::DOMCore:nodeType>} eq <H::infoset:Element> and
                    (defined $_->{<H::infoset:localName>} and
                     $_->{<H::infoset:localName>} eq 'html' and
                     ((defined $_->{<H::infoset:namespaceName>} and
                       ${$_->{<H::infoset:namespaceName>}} eq <Q::xhtml1:>) or
                      not defined $_->{<H::infoset:namespaceName>})) or
                    (not defined $_->{<H::infoset:localName>} and
                     $_->{<H::DOMCore:name>} eq 'html')) {
                  for (@{$_->{<H::infoset:children>}}) {
                    if ($_->{<H::DOMCore:nodeType>} eq <H::infoset:Element> and
                        (defined $_->{<H::infoset:localName>} and
                         $_->{<H::infoset:localName>} eq 'head' and
                         ((defined $_->{<H::infoset:namespaceName>} and
                           ${$_->{<H::infoset:namespaceName>}} eq <Q::xhtml1:>) or
                          not defined $_->{<H::infoset:namespaceName>})) or
                        (not defined $_->{<H::infoset:localName>} and
                         $_->{<H::DOMCore:name>} eq 'head')) {
                      for (@{$_->{<H::infoset:children>}}) {
                        if ($_->{<H::DOMCore:nodeType>} eq <H::infoset:Element> and
                            (defined $_->{<H::infoset:localName>} and
                             $_->{<H::infoset:localName>} eq 'base' and
                             ((defined $_->{<H::infoset:namespaceName>} and
                               ${$_->{<H::infoset:namespaceName>}} eq <Q::xhtml1:>) or
                              not defined $_->{<H::infoset:namespaceName>})) or
                            (not defined $_->{<H::infoset:localName>} and
                             $_->{<H::DOMCore:name>} eq 'base')) {
                          my $a = $_->{<H::infoset:attributes>}
                                    ->{<Q::null:>}->{href} ||
                                  $_->{<H::infoset:attributes>}
                                    ->{<Q::ManakaiDOM:noNS>}->{href};
                          if ($a) {
                            my $ac = <ClassName::ManakaiDOMAttr>;
                            $r = <Code::getWeakRef:: $object = $a, $class = $ac>
                                      -><AG::Attr.value>;
                            unless (<Code::DOMMain:isRelativeDOMURI::
                                             $INPUT = $r>) {
                              $r = null;
                            } else {
                              last HTML;
                            }
                          }
                          last DOC;
                        }
                      }
                      last DOC;
                    }
                  }
                  last DOC;
                }
              } # DOC
              if (defined $doc->{<H::infoset:baseURI>}) {
                $r = $doc->{<H::infoset:baseURI>};
                $r = null if <Code::DOMMain:isRelativeDOMURI:: $INPUT = $r>;
              } elsif (defined $doc->{<H::DOMCore:documentURI>}) {
                $r = $doc->{<H::DOMCore:documentURI>};
                $r = null if <Code::DOMMain:isRelativeDOMURI:: $INPUT = $r>;
              }
            } # HTML
          }
       @@@@ImplNote:
         @@@@@lang:en
         @@@@@@:
           TODO: <HA::codebase> attribute should be considered by option.
       @@@@ImplNote:
         @@@@@lang:en
         @@@@@@:
           ISSUE: How treat base URI of <IF::DOMXML:DocumentType>, ...
  @IntMethodC:
    @@Name:lookupNamespacePrefix
    @@Description:
      @@@lang:en
      @@@@:
        Lookup the namespace prefix associated to the given namespace URI. 
        This node must be of type <IF::Element>. 
    @@ImplNote:
      @@@lang:en
      @@@@:
        This internal method implements the <DOM::lookupNamespacePrefix> 
        <SRC::<CITE::DOM Level 3 Core Specification>
        <sw010:csection::B.2 Namespace Prefix Lookup>>.
    @@Param:
      @@@Name:namespaceURI
      @@@Type:
        ManakaiDOM:ManakaiDOMNamespaceURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          The namespace URI.  <DOM::null> is not allowed; it must be 
          checked before the call of this internal method.
    @@Param:
      @@@Name:originalElement
      @@@Type:
        ManakaiDOMCore:ManakaiDOMNodeObjectNode
      @@@Description:
        @@@@lang:en
        @@@@@:
          The element node object to which the original request to lookup the 
          <P::namespaceURI> is issued.
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The original node the request is issued is not an <IF::Element> node.
    @@Return:
      @@@Type: 
        @@@@@:
          DOMMain:ManakaiDOMNamespacePrefix
        @@@@ManakaiDOM:noInputNormalize:
          @@@@@@:1
          @@@@@ImplNote:
            @@@@@@lang:en
            @@@@@@@: An empty prefix should not be passed.
      @@@Description:
        @@@@lang:en
        @@@@@: The namespace prefix.
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The associated namespace prefix does not found.
      @@@PerlDefC:
          $r = null;
          FIND: {
          if ($originalElement) {
            if (defined $self->{<H::infoset:namespaceName>} and
                ${$self->{<H::infoset:namespaceName>}} eq $namespaceURI and
                defined $self->{<H::infoset:prefix>} and
                $originalElement-><M::ManakaiDOMCore:ManakaiDOMNodeObjectNode
                                         .lookupNamespaceURI>
                      ($self->{<H::infoset:prefix>}) eq $namespaceURI) {
              $r = $self->{<H::infoset:prefix>};
              last FIND;
            }
            my $ac = <ClassName::ManakaiDOMAttr>;
            for (values %{$self->{<H::infoset:attributes>}->{<Q::xmlns:>}||{}}) {
              if (defined $_->{<H::infoset:prefix>} and
                  $_->{<H::infoset:prefix>} eq 'xmlns' and
                  <Code::getWeakRef:: $object = $_, $class = $ac>
                    -><AG::Attr.value> eq $namespaceURI and
                  $originalElement-><M::ManakaiDOMCore:ManakaiDOMNodeObjectNode
                                            .lookupNamespaceURI>
                            ($_->{<H::infoset:localName>}) eq $namespaceURI) {
                $r = $_->{<H::infoset:localName>};
                last FIND;
              }
            }
          }
            ## If element has ancestor element
            my $n = $self;
            ANCESTOR: {
              if ($n->{<H::infoset:parent>}) {
                $n = $n->{<H::infoset:parent>};
                if ($n->{<H::DOMCore:nodeType>} eq <H::infoset:Element>) {
                  $r = $n-><M::ManakaiDOMCore:ManakaiDOMNodeObjectNode
                                        .lookupNamespacePrefix>
                                             ($namespaceURI, $originalElement);
                  last FIND;
                } else {
                  redo ANCESTOR;
                }
              }
            }
          } # FIND
     @@ImplNote:
       @@@lang:en
       @@@@:
         Before returning found prefix, the algorithm needs to make 
         sure that the prefix is not redefined.  This is why 
         <P::originalElement> is required.
  @IntMethodC:
    @@Name:isDefaultNamespace
    @@Description:
      @@@lang:en
      @@@@:
        Return whether the given namespace URI is the 
        default namespace.
    @@ImplNote:
      @@@lang:en
      @@@@:
        This internal method implements the <DOM::isDefaultNamespace> 
        <SRC::<CITE::DOM Level 3 Core Specification> 
        <sw010:csection::B.3 Default Namespace Lookup>>.
    @@Param:
      @@@Name:namespaceURI
      @@@Type:
        @@@@@:
          ManakaiDOM:ManakaiDOMNamespaceURI
        @@@@ManakaiDOM:noInputNormalize:
          @@@@@@:1
          @@@@@ImplNote:
            @@@@@@lang:en
            @@@@@@@: An empty namespace URI should not be passed in DOM Level 2.
      @@@Description:
        @@@@lang:en
        @@@@@: The namespace URI to look for.
    @@Return:
      @@@Type:DOMMain|boolean||ManakaiDOM|all
      @@@PerlDefC:
          if ($self->{<H::DOMCore:nodeType>} eq <H::infoset:Element>) {
            if (not defined $self->{<H::infoset:prefix>}) {
              if (defined $namespaceURI and
                  defined $self->{<H::infoset:namespaceName>} and
                  $namespaceURI eq ${$self->{<H::infoset:namespaceName>}}) {
                $r = true;
              } elsif (not defined $namespaceURI and
                       not defined $self->{<H::infoset:namespaceName>}) {
                $r = true;
              }
              # else false
            } elsif ($self->{<H::infoset:attributes>}
                          ->{<Q::xmlns:>}->{xmlns}) {
              my $vo = $self->{<H::infoset:attributes>}
                            ->{<Q::xmlns:>}->{xmlns};
              my $ac = <ClassName::ManakaiDOMAttr>;
              my $v = <Code::getWeakRef:: $object = $vo, $class = $ac>
                           -><AG::Attr.value>;
              if (defined $namespaceURI and $namespaceURI eq $v) {
                $r = true;
              } elsif (not defined $namespaceURI and not length $v) {
                $r = true;
              }
              # else false
            } else {
              ## If element has ancestor element
              my $n = $self;
              ANCESTOR: {
                if ($n->{<H::infoset:parent>}) {
                  $n = $n->{<H::infoset:parent>};
                  if ($n->{<H::DOMCore:nodeType>} eq <H::infoset:Element>) {
                    $r = $n-><M::ManakaiDOMCore:ManakaiDOMNodeObjectNode
                                   .isDefaultNamespace> ($namespaceURI);
                    last ANCESTOR;
                  } else {
                    redo ANCESTOR;
                  }
                }
                # false
              }
            }
          } elsif ($self->{<H::DOMCore:nodeType>} eq <H::infoset:Document>) {
            for (@{$self->{<H::infoset:children>}}) {
              if ($_->{<H::DOMCore:nodeType>} eq <H::infoset:Element>) {
                $r = $_-><M::ManakaiDOMCore:ManakaiDOMNodeObjectNode
                                .isDefaultNamespace> ($namespaceURI);
                last;
              }
            }
          } elsif ($self->{<H::DOMCore:nodeType>} eq <H::infoset:Attribute>) {
            if ($self->{<H::infoset:ownerElement>}) {
              $r = $self->{<H::infoset:ownerElement>}
                        -><M::ManakaiDOMCore:ManakaiDOMNodeObjectNode
                                .isDefaultNamespace> ($namespaceURI);
              last FIND;
            }
          } elsif ({
                     <H::DOMXML:EntityNode> => 1,
                     <H::infoset:Notation> => 1,
                     <H::infoset:DocumentTypeDeclaration> => 1,
                     <H::DOMCore:DocumentFragmentNode> => 1,
                   }->{$self->{<H::DOMCore:nodeType>}}) {
            #
          } else {
          #} elsif ({
          #           < Q::DOMCore:Text> => 1,
          #           < Q::DOMCore:Comment> => 1,
          #           < Q::DOMXML:EntityReference> => 1,
          #           < Q::DOMXML:CDATASection> => 1,
          #           < Q::infoset:ProcessingInstruction> => 1,
          #         }->{$self->{< Q::DOMCore:nodeType>}}) {
            ## If node has ancestor element
            my $n = $self;
            ANCESTOR: {
              if ($n->{<H::infoset:parent>}) {
                $n = $n->{<H::infoset:parent>};
                if ($n->{<H::DOMCore:nodeType>} eq <H::infoset:Element>) {
                  $r = $n-><M::ManakaiDOMCore:ManakaiDOMNodeObjectNode
                                .isDefaultNamespace> ($namespaceURI);
                  last ANCESTOR;
                } else {
                  redo ANCESTOR;
                }
              }
              # false
            }
          } # nodeType
  @IntMethodC:
    @@Name:lookupNamespaceURI
    @@Description:
      @@@lang:en
      @@@@:
        Lookup the namespace URI associated to the given prefix.
    @@ImplNote:
      @@@lang:en
      @@@@:
        This internal method implements the <DOM::lookupNamespaceURI> 
        <SRC::<CITE::DOM Level 3 Core Specification> 
        <sw010:csection::B.4 Namespace URI Lookup>>.
    @@Param:
      @@@Name:prefix
      @@@Type:
        @@@@@:
          DOMMain:ManakaiDOMNamespacePrefix
        @@@@ManakaiDOM:noInputNormalize:
          @@@@@@:1
          @@@@@ImplNote:
            @@@@@@lang:en
            @@@@@@@: An empty namespace prefix should not be specified.
      @@@Description:
        @@@@lang:en
        @@@@@: The namespace prefix.
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@: Look for the default namespace URI.
    @@Return:
      @@@Type:
        ManakaiDOM:ManakaiDOMNamespaceURI
      @@@Description:
        @@@@lang:en
        @@@@@: The namespace URI.
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@: No namespace URI associated.
      @@@PerlDefC:
          $r = null;
          FIND: {
          if ($self->{<H::DOMCore:nodeType>} eq <H::infoset:Element>) {
            if (defined $self->{<H::infoset:localName>} and
                defined $self->{<H::infoset:namespaceName>} and
                ((defined $self->{<H::infoset:prefix>} and defined $prefix and
                  $self->{<H::infoset:prefix>} eq $prefix) or
                 (not defined $self->{<H::infoset:prefix>} and
                  not defined $prefix))) {
              $r = ${$self->{<H::infoset:namespaceName>}};
              last FIND;
            }
            my $ac = <ClassName::ManakaiDOMAttr>;
            for (values %{$self->{<H::infoset:attributes>}->{<Q::xmlns:>}||{}}) {
              if (defined $_->{<H::infoset:prefix>} and defined $prefix and
                  $_->{<H::infoset:prefix>} eq 'xmlns' and
                  $_->{<H::infoset:localName>} eq $prefix) {
                ## Non default namespace
                $r = <Code::getWeakRef:: $object = $_, $class = $ac>
                          -><AG::Attr.value>;
                $r = null unless length $r;
                last FIND;
              } elsif (not defined $prefix and
                       $_->{<H::infoset:localName>} eq 'xmlns') {
                ## Default namespace
                $r = <Code::getWeakRef:: $object = $_, $class = $ac>
                          -><AG::Attr.value>;
                $r = null unless length $r;
                last FIND;
              }
            }
            ## If element has ancestor element
            my $n = $self;
            ANCESTOR: {
              if ($n->{<H::infoset:parent>}) {
                $n = $n->{<H::infoset:parent>};
                if ($n->{<H::DOMCore:nodeType>} eq <H::infoset:Element>) {
                  $r = $n-><M::ManakaiDOMCore:ManakaiDOMNodeObjectNode
                                  .lookupNamespaceURI> ($prefix);
                  last FIND;
                } else {
                  redo ANCESTOR;
                }
              }
            }
          } elsif ($self->{<H::DOMCore:nodeType>} eq <H::infoset:Document>) {
            for (@{$self->{<H::infoset:children>}}) {
              if ($_->{<H::DOMCore:nodeType>} eq <H::infoset:Element>) {
                $r = $_-><M::ManakaiDOMCore:ManakaiDOMNodeObjectNode
                               .lookupNamespaceURI> ($prefix);
                last FIND;
              }
            }
          } elsif ($self->{<H::DOMCore:nodeType>} eq <H::infoset:Attribute>) {
            if ($self->{<H::infoset:ownerElement>}) {
              $r = $self->{<H::infoset:ownerElement>}
                        -><M::ManakaiDOMCore:ManakaiDOMNodeObjectNode
                                 .lookupNamespaceURI> ($prefix);
              last FIND;
            }
          } elsif ({
                     <H::DOMXML:EntityNode> => 1,
                     <H::infoset:Notation> => 1,
                     <H::infoset:DocumentTypeDeclaration> => 1,
                     <H::DOMCore:DocumentFragmentNode> => 1,
                   }->{$self->{<H::DOMCore:nodeType>}}) {
            #
          } else {
          #} elsif ({
          #           < Q::DOMCore:Text> => 1,
          #           < Q::DOMCore:Comment> => 1,
          #           < Q::DOMXML:EntityReference> => 1,
          #           < Q::DOMXML:CDATASection> => 1,
          #           < Q::infoset:ProcessingInstruction> => 1,
          #         }->{$self->{< Q::DOMCore:nodeType>}}) {
            ## If node has ancestor element
            my $n = $self;
            ANCESTOR: {
              if ($n->{<H::infoset:parent>}) {
                $n = $n->{<H::infoset:parent>};
                if ($n->{<H::DOMCore:nodeType>} eq <H::infoset:Element>) {
                  $r = $n-><M::ManakaiDOMCore:ManakaiDOMNodeObjectNode
                                .lookupNamespaceURI> ($prefix);
                  last FIND;
                } else {
                  redo ANCESTOR;
                }
              }
            }
          } # nodeType
          } # FIND
      @@@ImplNote:
        @@@@lang:en
        @@@@@:
          Non namespace-aware nodes are ignored <SRC::DOM 3>.
  @IntMethodC:
    @@Name:getElementBy
    @@Description:
      @@@lang:en
      @@@@:
        Return an element that met the given condition.
    @@Param:
      @@@Name:check
      @@@Type: DISPerl|CODE||ManakaiDOM|all
      @@@Description:
        @@@@lang:en
        @@@@@:
          A code reference.  The code referred is called with a 
          parameter of this <Class::ManakaiDOMCore|ManakaiDOMNodeObjectNode>
          object when an <IF::Element> node is determined whether it could 
          be returned.  The code should return either <DOM::true> or 
          <DOM::false>.
    @@Param:
      @@@Name:index
      @@@Type: DISPerl|SCALAR||ManakaiDOM|all
      @@@Description:
        @@@@lang:en
        @@@@@:
          A reference to the ordinal index of the element to return.
      @@@In:1
      @@@Out:
        @@@@@:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The number of <IF::Element> nodes with which <P::check> has 
            returned <DOM::true> is minused from the original value. 
            \
            For example, if the original <P::index> is <CODE::4> and 
            there is three <P::check>-<DOM::true> <IF::Element> nodes, 
            then <P::index> would result in <CODE:1> and this method 
            itself would return <DOM::null>.  If there is five (or more)
            such nodes, 
            <P::index> would be <CODE:-1> and the return value would be 
            the fiveth matching node.
      @@@InCase:
        @@@@intValue:0
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The first <IF::Element> node with which <P::check> has returned 
            <DOM::true> is returned.
    @@Return:
      @@@Type:
        ManakaiDOMCore:ManakaiDOMNodeObjectNode
      @@@Description:
        @@@@lang:en
        @@@@@:
          The <IF::Element> node that met the condition.
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:There is no such node.
      @@@PerlDefC:
          for (@{$self->{<H::infoset:children>}||[]}) {
            last if $$index < 0;
            if ($_->{<H::DOMCore:nodeType>} eq <H::infoset:Element>) {
              if ($check->($_)) {
                if ($$index-- == 0) {
                  $r = $_;
                  last;
                }
              }
              $r = $_-><M::ManakaiDOMCore:ManakaiDOMNodeObjectNode.getElementBy>
                          ($check, $index);
              last if $$index == -1;
            } elsif ({
                       <H::DOMXML:EntityReferenceNode> => 1,
                     }->{$_->{<H::DOMCore:nodeType>}}) {
              $r = $_-><M::ManakaiDOMCore:ManakaiDOMNodeObjectNode.getElementBy>
                         ($check, $index);
              last if $$index == -1;
            }
          }
  @IntMethodC:
    @@Name:getElementsBy
    @@Description:
      @@@lang:en
      @@@@:
        Return descendant elements that met the given condition.
    @@Param:
      @@@Name:check
      @@@Type: DISPerl|CODE||ManakaiDOM|all
      @@@Description:
        @@@@lang:en
        @@@@@:
          A code reference.  The code referred is called with a 
          parameter of this <Class::ManakaiDOMCore|ManakaiDOMNodeObjectNode>
          object when an <IF::Element> node is determined whether it could 
          be returned.  The code should return either <DOM::true> or 
          <DOM::false>.
    @@Return:
      @@@Type: DISPerl|ARRAY||ManakaiDOM|all
      @@@Description:
        @@@@lang:en
        @@@@@:
          An array reference to the <IF::Element> nodes that meet the condition.
      @@@PerlDefC:
          $r = [];
          for (@{$self->{<H::infoset:children>}||[]}) {
            if ($_->{<H::DOMCore:nodeType>} eq <H::infoset:Element>) {
              if ($check->($_)) {
                push @$r, $_;
              }
         \    push @$r,
         \         @{$_-><M::ManakaiDOMCore:ManakaiDOMNodeObjectNode
         \                        .getElementsBy> ($check)};
            } elsif ({
                       <H::DOMXML:EntityReferenceNode> => 1,
                     }->{$_->{<H::DOMCore:nodeType>}}) {
         \    push @$r,
         \         @{$_-><M::ManakaiDOMCore:ManakaiDOMNodeObjectNode
         \                        .getElementsBy> ($check)};
            }
          }


    @ResourceDef:
      @@QName: getDocumentXMLVersion
      @@rdf:type: DISPerl|InlineCode
      @@Description:
        @@@lang:en
        @@@@: 
          Returns the XML version of a document.  If the document 
          does not support the <Feature::XML> feature, 
          <DOM::null> is returned.
      @@PerlDefC:
        ($DOCOBJ->{<H::DOMCore:hasFeature>}->{XML}
             ? CORE::defined $DOCOBJ->{<H::infoset:version>}
                   ? $DOCOBJ->{<H::infoset:version>}
                   : '1.0'
             : null)

  @IntMethodC:
    @@Name: isEqualNode
    @@Operator:
      @@@@: ==
      @@@ContentType:
        lang:Perl
    @@Description:
      @@@lang:en
      @@@@:
        Checks whether this node and another node are equal or not. 
    @@Param:
      @@@Name: node
      @@@Type: 
        ManakaiDOMCore:ManakaiDOMNodeObjectNode
      @@@Description:
        @@@@lang:en
        @@@@@: Another node object to compare.
    @@Return:
      @@@Type:DOMMain|boolean||ManakaiDOM|all
      @@@InCase:
        @@@@Value:true
        @@@@Description:
          @@@@@lang:en
          @@@@@@: Two nodes are equal.
      @@@InCase:
        @@@@Value:false
        @@@@Description:
          @@@@@lang:en
          @@@@@@: Two nodes are not equal.
      @@@PerlDefC:
         my $nodeclass = <ClassName::ManakaiDOMNode>;
         $r = <M::DOMCore:ManakaiDOMNode.isEqualNode>
                (<Code::getWeakRef:: $object = $self,
                                                 $class = $nodeclass>,
                 <Code::getWeakRef:: $object = $node,
                                                 $class = $nodeclass>);
  @IntMethodC:
    @@Operator:
      @@@@: eq
      @@@ContentType: DISPerl|Perl
    @@Param:
      @@@Name: node
      @@@Type: 
        ManakaiDOMCore:ManakaiDOMNodeObjectNode
      @@@Description:
        @@@@lang:en
        @@@@@: Another node object to compare.
    @@Return:
      @@@Type: idl|boolean||ManakaiDOM|all
      @@@TrueCase:
        @@@@enDesc:
          Two nodes are the same object.
      @@@FalseCase:
        @@@@enDesc:
          Two nodes are not the same object.
      @@@PerlDefC:
        $r = (ref $self eq ref $node and
              $self->{<H::mn:nodeID>} eq $node->{<H::mn:nodeID>});

  @IntMethodC:
    @@Name:normalizeText
    @@Description:
      @@@lang:en
      @@@@:
        Puts all <IF::Text> nodes in the full depth of the subtree 
        underneath this node object, including attribute nodes attached 
        to the element nodes, into a <QUOTE::normalized> form where 
        only structure such as XML tags separates text nodes, i.e. 
        there are neither adjacent text nodes nor empty text nodes. 
        (For the support of DOM Level 1 <M::Element||ManakaiDOM|ManakaiDOM1
        .normalize> and DOM levels 2 and 3 <M::Node.normalize>.) 
        \
        In addition, this method may also normalize text nodes in the subtree, 
        i.e. the characters of the text nodes will be fully normalized. 
        (For the support of DOM Level 3 <M::Node.normalize> with the 
        configuration parameter <CP::normalize-characters> turned on.)
     @@Param:
       @@@Name:fullyNormalize
       @@@Type:DOMMain|boolean||ManakaiDOM|all
       @@@Description:
         @@@@lang:en
         @@@@@:
           Whether the characters in the text nodes in the subtree  
           should be fully normalized or not. 
     @@Param:
       @@@Name:isDescendant
       @@@Type:
         DOMMain:boolean||ManakaiDOM|all
       @@@Description:
         @@@@lang:en
         @@@@@:
           Whether this node is a descendant of the node to normalize or not. 
       @@@InCase:
         @@@@Value:true
         @@@@Description:
           @@@@@lang:en
           @@@@@@:
             This node is a descendant (or an attribute and 
             an descendant of attribute of the root or its descendant)
             of the node. 
       @@@InCase:
         @@@@Value:false
         @@@@Description:
           @@@@@lang:en
           @@@@@@:
             This node is the node to normalize. 
   @@Return:
       @@@Exception:
         @@@@@:
           MDOMX:NOMOD_THIS
         @@@@Description:
           @@@@@lang:en
           @@@@@@:
             This node is read-only. 
       @@@Exception:
         @@@@@: c|NOMOD_DESCENDANT_ERR
         @@@@Description:
           @@@@@lang:en
           @@@@@@:
             One of descendant (or attribute) is read-only. 
     @@@PerlDefC:
       @@@@@:
         if (@{$self->{<H::infoset:children>}||[]}) {
           my @new;
           my $changed = false;
           my @change;
           my @removed;
           my $pchild;
           for my $child (@{$self->{<H::infoset:children>}}) {
             if ($self->{<H::DOMCore:nodeType>} eq <H::DOMCore:TextNode>) {
               if (length $child->{<H::infoset:content>}) {
                 if ($pchild) {
                   if ($self->{<H::DOMCore:read-only>}) {
                     if ($isDescendant) {
                       __EXCEPTION{c|NOMOD_DESCENDANT_ERR::
                         DOMCore:nodeObject => {$self},
                       }__;
                     } else {
                       __EXCEPTION{MDOMX:NOMOD_THIS::
                         DOMCore:nodeObject => {$self},
                       }__;
                     }
                   } elsif ($pchild->{<H::DOMCore:read-only>}) {
                     if ($child->{<H::DOMCore:read-only>}) {
                       ## Creates a new node
                       my $text = <ClassM::ManakaiDOMText.newObject> ($self);
                       push @change, [$text, 'append', $pchild];
                       push @change, [$text, 'append', $child];
                       $text->{<H::infoset:content>} = '';
                       __CODE{mn|setXRefNode||ManakaiDOM|Perl::
                         $referrer => {$text},
                         $propName => {<H::DOMCore:ownerDocument>},
                         $referent => {$child->{<H::DOMCore:ownerDocument>}},
                       }__;
                       $text->{<H::infoset:parent>} = $self;
                       push @removed, $pchild, $child;
                       $pchild = $text;
                       push @new, $text;
                       $changed = true;
                     } else {
                       push @change, [$child, 'prepend', $pchild];
                       push @removed, $pchild;
                       $pchild = $child;
                       pop @new;
                       push @new, $child;
                       $changed = true;
                     }
                   } else {
                     push @change, [$pchild, 'append', $child];
                     push @removed, $child;
                     $changed = true;
                   }
                 } else {
                   $pchild = $child;
                   push @new, $child;
                 }
               } else { # length zero
                 if ($self->{<H::DOMCore:read-only>}) {
                   if ($isDescendant) {
                     __EXCEPTION{c|NOMOD_DESCENDANT_ERR::
                       DOMCore:nodeObject => {$self},
                     }__;
                   } else {
                     __EXCEPTION{MDOMX:NOMOD_THIS::
                       DOMCore:nodeObject => {$self},
                     }__;
                   }
                 }
                 push @removed, $child;
                 $changed = true;
               }
             } elsif ({
                         <H::infoset:Element> => 1,
                         <H::DOMXML:EntityReferenceNode> => 1,
                      }->{$self->{<H::DOMCore:nodeType>}}) {
               $pchild = null;
               push @new, $child;
               __DEEP{
                 $child-><M::ManakaiDOMCore:ManakaiDOMNodeObjectNode
                                       .normalizeText> ($fullyNormalize, true);
               }__;
             } else {
               $pchild = null;
               push @new, $child;
             }
           }

           if ($changed) {
             ## NOTE: Actual changes made here, to avoid breaking data 
             ##       when some of children are read-only. 
             for (@change) {
               if ($_->[1] eq 'append') {
                 $_->[0]->{<H::infoset:content>}
                     .= $_->[2]->{<H::infoset:content>};
               } elsif ($_->[1] eq 'preprend') {
                 $_->[0]->{<H::infoset:content>}
                      = $_->[1]->{<H::infoset:content>} . 
                        $_->[0]->{<H::infoset:content>};
               } else {
                 __ASSERT{DISPerl:invariant::
                   msg => {qq{Normalizing operation "$_->[1]"}},
                 }__;
               }
             }
  
             for (@removed) {
               CORE::delete $_->{<H::infoset:parent>};
               $_-><M::NodeStem.orphanate>;
             }
   
             $self->{<H::infoset:children>} = \@new;

             ## infoset:specified should turn on if normalization occured.
             ## Otherwise, infoset does not change so that no change required. 
           }
         }

         if ($self->{<H::DOMCore:nodeType>} eq <H::infoset:Attribute>) {
           for (values %{$self->{<H::infoset:attributes>}}) {
             for (values %$_) {
               $_-><M::ManakaiDOMCore:ManakaiDOMNodeObjectNode
                                       .normalizeText> ($fullyNormalize, true);
             }
           }
         }

         \## TODO: Normalization
       @@@@ImplNote:
         @@@@@lang:en
         @@@@@@:
           {NOTE:: Read-only status must not be changed by others
                   during this process.
           \
           }
    @@ImplNote:
      @@@lang:en
      @@@@:
        Normalization should be done after the merge of adjacent 
        text nodes, since the merge might change the status 
        of normalization. 

  @L3Method:
    @@Name: destroyNodeStem
    @@ManakaiDOM:isForInternal: 1
    @@enDesc:
      Invokes the user data handlers, if any, before the node
      is deleted.
    @@Return:
      @@@PerlDef:
        __FOR{ManakaiDOM:DOM3::
          __DEEP{
            for my $key (keys %{$self->{<H::t|userData>}||{}}) {
              my $dha = $self->{<H::t|userData>}->{$key};
              if ($dha->[1]) {
                $dha->[1]-><M::c|UserDataHandler.handle>
                             (<C::c|UserDataHandler.NODE_DELETED>,
                              $key, $dha->[0], null, null);
              }
            }
          }__;
        }__;

    @@L3Test:
      @@@QName: Node.Deleted.UserDataHandler
      @@@PerlDef:
        my $impl = <Class::c|ManakaiDOMImplementation>->_new;
        my $doc = $impl-><M::c|DOMImplementation.createDocument>
                              ('http://www.example/', 'ex');
        my $node = $doc-><AG::Document.documentElement>;

        my $udh_called = false;

        $node-><M::Node.setUserData> ('key' => {}, sub {
          my ($self, $op, $key, $data, $src, $dest) = @_;
          $udh_called = true;

          $test->assert_equals ($op, <C::c|UserDataHandler.NODE_DELETED>);
          $test->assert_equals ($key, 'key');
          $test->assert_equals (ref $data, 'HASH');
          $test->assert_null ($src);
          $test->assert_null ($dest);
        });

        undef $doc;
        undef $node;

        $test->assert_true ($udh_called);
        
##ManakaiDOMNodeObjectNode

ElementTypeBinding:
  @Name: actualType
  @ElementType:
    dis:actualType
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass

ForDef:
  @QName:
    c:ForChildNodeList
  @Description:
    @@lang:en
    @@@:
      For <Class::ManakaiDOMCore:ManakaiDOMChildNodeList> class.
  @ISA: ManakaiDOM|ForClass

ForDef:
  @QName:
    c:ForGetNodeList
  @Description:
    @@lang:en
    @@@:
      For <Class::ManakaiDOMCore:ManakaiDOMGetElementsNodeList> class.
  @ISA: ManakaiDOM|ForClass

ForDef:
  @QName: c|ForEmptyNodeList
  @ISA: ManakaiDOM|ForClass

ResourceDef:
  @QName: getWeakRef
  @AliasFor:
    ManakaiNode:getWeakRef::ManakaiDOM:Perl
  @For: ManakaiDOM|ManakaiDOM !=ManakaiDOM|ManakaiDOM

ResourceDef:
  @QName: c|NodeList
  @AliasFor: NodeList
  @For: ManakaiDOM|DOM

ResourceDef:
  @rdf:type:
    @@@:
      dis:MultipleResource
    @@ForCheck:
      !ManakaiDOM:ForIF !c|ForChildNodeList !c|ForGetNodeList
      !c|ForEmptyNodeList
  @ForCheck: ManakaiDOM|DOM

  @resourceFor:
    ManakaiDOM:ForIF
  @rdf:type:
    @@@: DISLang|Interface
    @@ForCheck:
      ManakaiDOM:ForIF
  @IFQName: NodeList

  @DOMMain:implementFeature:
    @@@: c|CoreFeature10
    @@ForCheck: ManakaiDOM|DOM1
  @DOMMain:implementFeature:
    @@@: c|CoreFeature20
    @@ForCheck: ManakaiDOM|DOM2
  @DOMMain:implementFeature:
    @@@: c|CoreFeature30
    @@ForCheck: ManakaiDOM|DOM3

  @resourceFor:
    @@@: c|ForChildNodeList
    @@For:
      ManakaiDOM:ManakaiDOM !=ManakaiDOM:ManakaiDOM
  @QName:
    @@@:
      ManakaiDOMCore:ManakaiDOMChildNodeList
    @@ForCheck: c|ForChildNodeList
  @rdf:type:
    @@@:
      ManakaiDOM:Class
    @@ForCheck: c|ForChildNodeList
  @ISA:
    @@@: ManakaiNode|ManakaiNodeRef||ManakaiDOM|Perl
    @@ForCheck: c|ForChildNodeList
  @ISA:
    @@@:
      ManakaiDOM:ManakaiDOMObject
    @@ForCheck: c|ForChildNodeList

  @AppISA:
    @@ForCheck: c|ForChildNodeList
    @@ContentType: DISPerl|Perl
    @@@:
      Tie::Array

  @resourceFor:
    @@@: c|ForGetNodeList
    @@ForCheck:
      ManakaiDOM:ManakaiDOM !=ManakaiDOM:ManakaiDOM
  @QName:
    @@@:
      ManakaiDOMCore:ManakaiDOMGetElementsNodeList
    @@ForCheck: c|ForGetNodeList
  @rdf:type:
    @@@: DISPerl|Class
    @@ForCheck: c|ForGetNodeList
  @ISA:
    @@@: ManakaiNode|ManakaiNodeRef||ManakaiDOM|Perl
    @@ForCheck: c|ForGetNodeList
  @ISA:
    @@@:
      ManakaiDOM:ManakaiDOMObject
    @@ForCheck: c|ForGetNodeList

  @AppISA:
    @@ForCheck: c|ForGetNodeList
    @@ContentType: DISPerl|Perl
    @@@:
      Tie::Array

  @resourceFor:
    @@@: c|ForEmptyNodeList
    @@ForCheck:
      ManakaiDOM:ManakaiDOM !=ManakaiDOM:ManakaiDOM
  @QName:
    @@@: DOMCore|ManakaiDOMEmptyNodeList
    @@ForCheck: c|ForEmptyNodeList
  @rdf:type:
    @@@: DISLang|Class
    @@ForCheck: c|ForEmptyNodeList
  @ISA:
    @@@: ManakaiDOM|ManakaiDOMObject
    @@ForCheck: c|ForEmptyNodeList

  @Implement:
    @@@: NodeList||ManakaiDOM|ManakaiDOM
    @@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM
  @Implement:
    @@@: NodeList||ManakaiDOM|ManakaiDOM1
    @@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM1
  @Implement:
    @@@: NodeList||ManakaiDOM|ManakaiDOM2
    @@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM2
  @Implement:
    @@@: NodeList||ManakaiDOM|ManakaiDOM3
    @@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM3
  @Implement:
    @@@: NodeList||ManakaiDOM|ManakaiDOMLatest
    @@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOMLatest

  @enDesc:
    Objects implementing the <IF::NodeList> interface are used
    to represent ordered collections of nodes.

    The <IF::NodeList> objects are live; which means
    that the <IF::NodeList> objects are always <QUOTE::up-to-date>.
    For example, a <IF::NodeList> obtained from the 
    <A::Node.childNodes> attribute of an empty element would 
    have its <A::NodeList.length> value of <CODE::1> after
    a <M::Node.appendChild> operation would have appended a node
    to the element.

    {NOTE:: How this collection is implemented is neither defined
            nor constrained.
    }

    The items in the <IF::NodeList> are accessible via
    an ordinal index, starting from zero.

  @enDesc:
    @@For: ManakaiDOM|ManakaiDOM
    @@@:
      In the manakai implementation, <IF::NodeList> can be 
      dereferenced as if it is an array reference.  For 
      example, <Perl::@a = @$nodeList> result in the array
      <Perl::@a> containing all <IF::Node>s in the <Perl::$nodeList>.
      Please note that <Perl::@a> is just a Perl array and
      it is <EM::not> live.

  @enDesc:
    {NOTE:: <IF::NodeList>s are different from <IF::NamedNodeMap>s
            in that <IF::NodeList>s are <EM::ordered> and
            <IF::NamedNodeMap>s are not.
    }

  @Method:
     @@Name:  item
     @@Perlop:FETCH
     @@Description:
       @@@lang:en
       @@@@:
         Return an item in the collection.
     @@Param:
        @@@Name:  index
        @@@Type:  
          DOMMain:unsigned-long||ManakaiDOM|all
        @@@Description:
          @@@@lang:en
          @@@@@: The index of the item into the collection.
        @@@ImplNote:
          @@@@lang:en
          @@@@@:
            A negative index is automatically translated to 
            a positive index when <Perl::FETCH>ed. 
          @@@@For:
            ManakaiDOM:ManakaiDOM
     @@Return:
        @@@Type:  Node
        @@@actualType: ManakaiDOMNode
        @@@Description:
          @@@@lang:en
          @@@@@: 
            The node at the "index"th position in the collection.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The "index" is invalid, i.e. it is greater than or 
              equal to the number of nodes in the list.
        @@@PerlDef:
          @@@@ForCheck: c|ForChildNodeList
          @@@@@:
            $r = $self->{<H::mn:node>}->{<H::infoset:children>}->[$index];
            if (defined $r) {
              $r = <ClassM::ManakaiDOMNode.getNodeReference> ($r);
            }
        @@@PerlDef:
          @@@@ForCheck: c|ForGetNodeList
          @@@@@:
            $r = $self->{<H::mn:node>}
                      -><M::ManakaiDOMCore:ManakaiDOMNodeObjectNode
                                   .getElementBy> 
                          ($self->{<H::ManakaiDOMCore:nodeMatch>}, \$index);
           if (defined $r) {
             $r = <ClassM::ManakaiDOMNode.getNodeReference> ($r, $self);
           }
         @@@@ImplNote:
           @@@@@lang:en
           @@@@@@:
             TODO: Cache mechanism required.
      @@@PerlDef:
        @@@@ForCheck: c|ForEmptyNodeList
        @@@@@: \

  @IntMethod:
    @@Perlop: STORE
    @@Description:
      @@@lang:en
      @@@@:
        Sets an item. 
    @@Param:
      @@@Name:index
      @@@Type:
        DOMMain:unsigned-long||ManakaiDOM|all
      @@@Description:
        @@@@lang:en
        @@@@@:
          An ordinal index in the list.  If the <P::index> is greater 
          than the number of items, then it is appended to the end of 
          the list.  A negative index is converted into a positive 
          index by Perl. 
    @@Param:
      @@@Name:value
      @@@Type: Node
      @@@Description:
        @@@@lang:en
        @@@@@:
          The node to set at the <P::index>th position in the list. 
    @@Return:
      @@@Type:Node
      @@@Description:
        @@@@lang:en
        @@@@@:
          The old node that has been replaced to the new <P::value>. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            No node has been removed from this list. 
      @@@Exception:
        @@@@@: c|NOMOD_NODELIST_ERR
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            A <IF::NodeList> returned by <M::Document.getElementsByTagNameNS> 
            or like is unable to be edited. 
        @@@@ForCheck: c|ForGetNodeList
      @@@Exception:
        @@@@@: c|NOMOD_NODELIST_ERR
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            A <IF::NodeList> is unable to be edited. 
        @@@@ForCheck: c|ForEmptyNodeList
      @@@disDef:
        @@@@DOMMain:raiseException: c|NOMOD_NODELIST_ERR
        @@@@ForCheck: c|ForGetNodeList
      @@@disDef:
        @@@@DOMMain:raiseException: c|NOMOD_NODELIST_ERR
        @@@@ForCheck: c|ForEmptyNodeList
      @@@Exception:
        @@@@ForCheck: c|ForChildNodeList
          @@@@Type: DOMException
          @@@@Name: HIERARCHY_REQUEST_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Either this node is of a type that does not allow 
              children of the type of the "newChild" node [DOM 1, 2, 3],
              the node to put in is one of ancestors of this node 
              [DOM 1, 2, 3], the node to put in is this node itself
              [DOM 2 Errata, 3], or this 
              node is of type "Document" and the result of the 
              replacement would add a second "DocumentType" or "Element" node.
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              Special treatment required for the "DocumentFragment" node.
        @@@Exception:
        @@@@ForCheck: c|ForChildNodeList
          @@@@Type: DOMException
          @@@@Name: WRONG_DOCUMENT_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The new node was created from a different document.
        @@@Exception:
        @@@@ForCheck: c|ForChildNodeList
          @@@@Type: DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Either this node is read-only [DOM 1, 2, 3] or the parent of the 
              new node is read-only [DOM 1 SE, 2, 3].
      @@@PerlDef:
        @@@@ForCheck: c|ForChildNodeList
        @@@@@:
          if (CORE::exists $self->{<H::mn:node>}
                                ->{<H::infoset:children>}->[$index]) {
            __DEEP{
              $r = $self-><M::ManakaiDOMNode.replaceChild>
                     ($value, $self-><M::ManakaiDOMCore:ManakaiDOMChildNodeList
                                               .item> ($index));
            }__;
          } else {
            __DEEP{
              $self-><M::ManakaiDOMNode.appendChild> ($value);
            }__;
          }

  @IntMethod:
    @@Perlop: DELETE
    @@Description:
      @@@lang:en
      @@@@:
        Removes an item from this list. 
        \
        Unlike the deletion for Perl's standard array, this method 
        removes an item and moves the rest of the array (i.e. items 
        whose index is greater than <P::index>) one position, since 
        the <IF::NodeList> cannot contain a <DOM::null> value. 
    @@Param:
      @@@Name:index
      @@@Type:
        DOMMain:unsigned-long||ManakaiDOM|all
      @@@Description:
        @@@@lang:en
        @@@@@:
          An ordinal index in the list.  If the <P::index> is greater 
          than the number of items, then no item is removed.
          A negative index is converted into a positive 
          index by Perl. 
    @@Return:
      @@@Type:Node
      @@@Description:
        @@@@lang:en
        @@@@@:
          The node removed from this list. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            No node has removed from this list. 
      @@@Exception:
        @@@@@: c|NOMOD_NODELIST_ERR
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            A <IF::NodeList> returned by <M::Document.getElementsByTagNameNS> 
            or like is unable to be edited. 
        @@@@ForCheck: !c|ForChildNodeList
      @@@disDef:
        @@@@DOMMain:raiseException: c|NOMOD_NODELIST_ERR
        @@@@ForCheck: !c|ForChildNodeList
      @@@Exception:
        @@@@ForCheck: c|ForChildNodeList
          @@@@Type: DOMException
          @@@@Name: HIERARCHY_REQUEST_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Either this node is of a type that does not allow 
              children of the type of the "newChild" node [DOM 1, 2, 3],
              the node to put in is one of ancestors of this node 
              [DOM 1, 2, 3], the node to put in is this node itself
              [DOM 2 Errata, 3], or this 
              node is of type "Document" and the result of the 
              replacement would add a second "DocumentType" or "Element" node.
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              Special treatment required for the "DocumentFragment" node.
      @@@Exception:
        @@@@ForCheck: c|ForChildNodeList
          @@@@Type: DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Either this node is read-only [DOM 1, 2, 3] or the parent of the 
              new node is read-only [DOM 1 SE, 2, 3].
      @@@PerlDef:
        @@@@ForCheck: c|ForChildNodeList
        @@@@@:
          if (CORE::exists $self->{<H::mn:node>}
                                ->{<H::infoset:children>}->[$index]) {
            __DEEP{
              $r = $self-><M::ManakaiDOMNode.removeChild>
                          ($self-><M::ManakaiDOMCore:ManakaiDOMChildNodeList
                                         .item> ($index));
            }__;
          }

  @Attr:
     @@Name:  length
     @@Perlop: FETCHSIZE
     @@Description:
       @@@lang:en
       @@@@:
         The number of nodes in the list.
     @@Get:
        @@@Type:  
          DOMMain:unsigned-long||ManakaiDOM|all
        @@@PerlDef:
          @@@@ForCheck: c|ForChildNodeList
          @@@@@:
            $r = @{$self->{<H::mn:node>}->{<H::infoset:children>}};
        @@@PerlDef:
          @@@@ForCheck: c|ForGetNodeList
          @@@@@:
            my $l = $self->{<H::mn:node>}
                         -><M::ManakaiDOMCore:ManakaiDOMNodeObjectNode
                                  .getElementsBy>
                             ($self->{<H::ManakaiDOMCore:nodeMatch>});
            $r = @$l;
      @@@PerlDef:
        @@@@ForCheck: c|ForEmptyNodeList
        @@@@@:\

  @IntMethod:
    @@Perlop: STORESIZE
    @@Description:
      @@@lang:en
      @@@@:
        Changes the size of this node list.
    @@Param:
      @@@Name:count
      @@@Type:
        DOMMain:unsigned-long||ManakaiDOM|all
      @@@Description:
        @@@@lang:en
        @@@@@: 
          The new length of this list.  If the <P::count> 
          is smaller than the current <A::NodeList.length>, <P::count>th or 
          greater index'th items are removed from this list.  Otherwise, 
          no action.
    @@Return:
      @@@NoModGetNodeList:
      @@@PerlDef:
        @@@@ForCheck: c|ForChildNodeList
        @@@@@:
          my $len = @{$self->{<H::mn:node>}->{<H::infoset:children>}};
          if ($len < $count) {
            __DEEP{
              my $node = <ClassM::ManakaiDOMNode.getCoreNodeReference>
                               ($self->{<H::mn:node>});
              for (my $i = $count - 1; $i >= $len; $i--) {
                my $cnode = <ClassM::ManakaiDOMNode.getCoreNodeReference>
                               ($self->{<H::mn:node>}
                                     ->{<H::infoset:children>}->[$i]);
                $node-><M::Node.removeChild> ($cnode);
              }
            }__;
          }

  @IntMethod:
     @@Perlop: EXISTS
     @@Description:
       @@@lang:en
       @@@@:
         Returns whether an item exists in this list or not. 
     @@Param:
       @@@Name:index
       @@@Type:
         DOMMain:unsigned-long||ManakaiDOM|all
       @@@Description:
         @@@@lang:en
         @@@@@:
           The ordinal index of the item to test. 
     @@Return:
        @@@Type:  DOMMain|boolean||ManakaiDOM|all
        @@@PerlDef:
          @@@@ForCheck: c|ForChildNodeList
          @@@@@:
            $r = CORE::exists $self->{<H::mn:node>}
                                   ->{<H::infoset:children>}->[$index];
        @@@PerlDef:
          @@@@ForCheck: c|ForGetNodeList
          @@@@@:
            __DEEP{
              $r = $self-><M::ManakaiDOMCore:ManakaiDOMGetElementsNodeList.item>
                               ($index) ? 1 : 0;
            }__;
       @@@PerlDef:
         @@@@ForCheck: c|ForEmptyNodeList
         @@@@@:\
  @IntMethod:
    @@Name: isEqualNodeList
    @@ForCheck: !c|ForGetNodeList
    @@Perlop: ==
    @@Description:
      @@@lang:en
      @@@@:
        Checks whether two node lists are equal or not.  
        Two node lists are equal iff their <A::NodeList.length> are 
        equal and their item at the same index are equal. 
        \
        See <M::Node.isEqualNode>.
    @@Param:
      @@@Name:arg
      @@@Type: NodeList
      @@@Description:
        @@@@lang:en
        @@@@@:
          The node list to compare equality with.
    @@Return:
      @@@Type:DOMMain|boolean||ManakaiDOM|all
      @@@PerlDef:
        @@@@ForCheck: c|ForChildNodeList
        @@@@@:
          EQ: {
            last EQ unless @{$self->{<H::mn:node>}
                                  ->{<H::infoset:children>}} ==
                           $arg-><AG::NodeList.length>;
            my $nc = <ClassName::ManakaiDOMNode>;
            for my $i (0..@{$self->{<H::mn:node>}
                                 ->{<H::infoset:children>}}) {
              my $a = $self->{<H::mn:node>}
                                      ->{<H::infoset:children>}->[$i];
              unless (<M::DOMCore:ManakaiDOMNode.isEqualNode>
                         (<Code::ManakaiNode:getWeakRef||ManakaiDOM:Perl::
                             $object = $a, $class = $nc>,
                          $arg-><M::NodeList.item> ($i))) {
                last EQ;
              }
            }
            $r = true;
          }
    @@PerlDef:
      @@@ForCheck: c|ForEmptyNodeList
      @@@@:
        __DEEP{
          $r = ($arg-><AG::NodeList.length> == 0);
        }__;

  @IntMethod:
    @@ForCheck: !c|ForEmptyNodeList
    @@Perlop:TIEARRAY
    @@ManakaiDOM:isStatic:1
    @@Description:
      @@@lang:en
      @@@@:
        Binds a node list to an array.  This method is intended to 
        be called by Perl <Perl::tie> function. 
    @@Param:
      @@@Name: nodeList
      @@@Type: NodeList
      @@@Description:
        @@@@lang:en
        @@@@@:
          A node list that is tied with an array. 
    @@Return:
      @@@Type: NodeList
      @@@Description:
        @@@@lang:en
        @@@@@:
          The node list to which the array has bound, 
          i.e. <P::nodeList>.
      @@@PerlDef:
        $r = $nodeList;

  @IntMethod:
    @@Perlop:PUSH
    @@Description:
      @@@lang:en
      @@@@:
        Pushes an item to the last of this list. 
    @@Param:
      @@@Name:value
      @@@Type:Node
      @@@Description:
        @@@@lang:en
        @@@@@:
          The node to push. 
    @@Return:
      @@@Exception:
        @@@@@: c|NOMOD_NODELIST_ERR
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            A <IF::NodeList> returned by <M::Document.getElementsByTagNameNS> 
            or like is unable to be edited. 
        @@@@ForCheck: !c|ForChildNodeList
      @@@disDef:
        @@@@DOMMain:raiseException: c|NOMOD_NODELIST_ERR
        @@@@ForCheck: !c|ForChildNodeList
      @@@Exception:
        @@@@ForCheck: c|ForChildNodeList
          @@@@Type: DOMException
          @@@@Name: HIERARCHY_REQUEST_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Either this node is of a type that does not allow 
              children of the type of the "newChild" node [DOM 1, 2, 3],
              the node to put in is one of ancestors of this node 
              [DOM 1, 2, 3], the node to put in is this node itself
              [DOM 2 Errata, 3], or this 
              node is of type "Document" and the result of the 
              replacement would add a second "DocumentType" or "Element" node.
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              Special treatment required for the "DocumentFragment" node.
      @@@Exception:
        @@@@ForCheck: c|ForChildNodeList
          @@@@Type: DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Either this node is read-only [DOM 1, 2, 3] or the parent of the 
              new node is read-only [DOM 1 SE, 2, 3].
      @@@PerlDef:
        @@@@ForCheck: c|ForChildNodeList
        @@@@@:
          __DEEP{
            $self-><M::ManakaiDOMNode.insertBefore>
                           ($value,
                            $self-><M::ManakaiDOMCore:ManakaiDOMChildNodeList
                                            .item> (0));
          }__;

  @IntMethod:
    @@Perlop:POP
    @@Description:
      @@@lang:en
      @@@@:
        Pops an item from the last of this list. 
    @@Return:
      @@@Type:Node
      @@@Description:
        @@@@lang:en
        @@@@@:
          The node removed from the last of this list. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The list has been empty and no item is poped. 
      @@@NoModGetNodeList:
      @@@Exception:
        @@@@ForCheck: c|ForChildNodeList
          @@@@Type: DOMException
          @@@@Name: HIERARCHY_REQUEST_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Either this node is of a type that does not allow 
              children of the type of the "newChild" node [DOM 1, 2, 3],
              the node to put in is one of ancestors of this node 
              [DOM 1, 2, 3], the node to put in is this node itself
              [DOM 2 Errata, 3], or this 
              node is of type "Document" and the result of the 
              replacement would add a second "DocumentType" or "Element" node.
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              Special treatment required for the "DocumentFragment" node.
      @@@Exception:
        @@@@ForCheck: c|ForChildNodeList
          @@@@Type: DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Either this node is read-only [DOM 1, 2, 3] or the parent of the 
              new node is read-only [DOM 1 SE, 2, 3].
      @@@PerlDef:
        @@@@ForCheck: c|ForChildNodeList
        @@@@@:
          __DEEP{
            $self-><M::ManakaiDOMNode.removeChild>
                     ($self-><M::ManakaiDOMCore:ManakaiDOMChildNodeList.item>
                        ($self-><AG::ManakaiDOMCore:ManakaiDOMChildNodeList
                                       .length> - 1));
          }__;

  @IntMethod:
    @@Perlop:CLEAR
    @@Description:
      @@@lang:en
      @@@@:
        Removes all items from this list. 
    @@Return:
      @@@NoModGetNodeList:
      @@@Exception:
        @@@@ForCheck: c|ForChildNodeList
          @@@@Type: DOMException
          @@@@Name: HIERARCHY_REQUEST_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Either this node is of a type that does not allow 
              children of the type of the "newChild" node [DOM 1, 2, 3],
              the node to put in is one of ancestors of this node 
              [DOM 1, 2, 3], the node to put in is this node itself
              [DOM 2 Errata, 3], or this 
              node is of type "Document" and the result of the 
              replacement would add a second "DocumentType" or "Element" node.
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              Special treatment required for the "DocumentFragment" node.
      @@@Exception:
        @@@@ForCheck: c|ForChildNodeList
          @@@@Type: DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Either this node is read-only [DOM 1, 2, 3] or the parent of the 
              new node is read-only [DOM 1 SE, 2, 3].
      @@@PerlDef:
        @@@@ForCheck: c|ForChildNodeList
        @@@@@:
          __DEEP{
            my $length = $self-><AG::ManakaiDOMCore:ManakaiDOMChildNodeList
                                       .length> - 1;
            for (reverse $length..0) {
              $self-><M::ManakaiDOMNode.removeChild>
                 ($self-><M::ManakaiDOMCore:ManakaiDOMChildNodeList.item> ($_));
            }
          }__;

  @ImplNote:
    @@lang:en
    @@@:
      {TODO:: Optimize PUSH, POP, SHIFT, UNSHIFT, SPLICE. 
      \
      }

  @IntMethod:
    @@Perlop:@{}
    @@Description:
      @@@lang:en
      @@@@:
        Returns an array representation of this node list. 
        \
        {NOTE:: It is intended that most operations through the 
                array is as like ones in DOM Level 0 JavaScript 
                implementations as possible. 
        \
        }
    @@Return:
      @@@Type: DISPerl|ARRAY||ManakaiDOM|all
      @@@PerlDef:
        @@@@ForCheck: !c|ForEmptyNodeList
        @@@@@:
          tie my @list, ref $self, $self;
          $r = \@list;
      @@@PerlDef:
        @@@@ForCheck: c|ForEmptyNodeList
        @@@@@: \

  @IntMethod:
    @@Perlop:DESTROY
    @@Description:
      @@@lang:en
      @@@@:
        Redefines destructor for the class
        <Class::ManakaiNode|ManakaiNodeRef||ManakaiDOM|Perl>,
        since the <PerlModule::Tie::Array> also has its own empty destructor. 
    @@Return:
      @@@disDef:
        @@@@ForCheck: !c|ForEmptyNodeList
        @@@@DISPerl:cloneCode:
          ManakaiNode|ManakaiNodeRef||ManakaiDOM|Perl.destroy
      @@@PerlDef:
        @@@@ForCheck: c|ForEmptyNodeList
        @@@@@: \

  @Method:
    @@ForCheck: c|ForEmptyNodeList
    @@Operator: DISPerl|NewMethod
    @@enDesc:
      Creats a new instance of <Class::ManakaiDOMEmptyNodeList>.
    @@Return:
      @@@Type: NodeList
      @@@dis:actualType: ManakaiDOMEmptyNodeList
      @@@enDesc: The newly created node list.
      @@@PerlDef:
        $r = bless [], $self;


  @IntMethod:
    @@ForCheck: ManakaiDOM|ManakaiDOM3
    @@Operator: ManakaiDOM|MUErrorHandler
    @@enDesc:
      When a <IF::ecore|ErrorInterface||ManakaiDOM|Perl> is <Perl::report>ed
      with an <Perl::-object> of <IF::NodeList>, then this method is invoked.
      
      The method calls the <cfg::error-handler> if the error is of 
      <IF::c|DOMError>.  Otherwise, including the cases of <IF::c|DOMException>s,
      the error is rethrown so that appropriate <Perl::catch> clause
      can catch the error.
    @@enImplNote:
      For implementations which does not have the
      <IF::c|DOMError||ManakaiDOM|ManakaiDOM3> interface, the method
      is defined in the <Class::ManakaiDOM|ManakaiDOMObject> class
      and it is not overridden here.
    @@Param:
      @@@Name: err
      @@@Type: ecore|ErrorInterface||ManakaiDOM|Perl
      @@@enDesc:
        The reported error object.
    @@Return:
      @@@Type: DISPerl|Any
      @@@enDesc:
        If the <P::err> is a <IF::c|DOMError>, then the return value
        of the error handler.

           {NOTE:: If the error is thrown, the method never returns.
           }
      @@@nullCase:
        @@@@enDesc:
          No error handler.
      @@@PerlDef:
          if ($err->isa (<IFName::c|DOMError||ManakaiDOM|ManakaiDOM>)) {
            __DEEP{
              A: {
                my $doco = $self->{<H::mn:node>}->{<H::DOMCore:ownerDocument>};
                if (not defined $doco) {
                  if ($self->{<H::mn:node>}->{<H::DOMCore:nodeType>}
                        eq <Q::infoset:Document>) {
                    $doco = $self->{<H::mn:node>};
                  } else {  ## DocumentType node
                    warn $err;
                    last A;
                  }
                }
                my $doc;
                __CODE{mn:getWeakReference||ManakaiDOM:Perl::
                  $object => $doco,
                  $ref => $doc,
                  $class => {<ClassName::ManakaiDOMDocument>},
                }__;
                my $cfg = $doc-><AG::Document.domConfig>;
                my $h = $cfg-><M::c|DOMConfiguration.getParameter>
                                 ('error-handler');
                $r = $h-><M::c|DOMErrorHandler.handleError> ($err);
              } # A
            }__;
          } else {
            $err-><M::ecore|ErrorInterface||ManakaiDOM|Perl.throw>;
          }
##NodeList

ElementTypeBinding:
  @Name:NoModGetNodeList
  @ElementType:
    rdf:type
  @ShadowContent:
    rdfs:Resource
  @ShadowSibling:
    @@dx:raises:
      @@@@: c|NOMOD_NODELIST_ERR
      @@@Description:
        @@@@lang:en
        @@@@@:
          A <IF::NodeList> returned by <M::Document.getElementsByTagNameNS> 
          or like is unable to be edited. 
      @@@ForCheck: !c|ForEmptyNodeList
    @@disDef:
      @@@DOMMain:raiseException: c|NOMOD_NODELIST_ERR
      @@@ForCheck: !c|ForEmptyNodeList

ElementTypeBinding:
  @Name: Perlop
  @ElementType:
    dis:Operator
  @ShadowContent:
    @@ContentType: DISPerl|Perl
    @@For: ManakaiDOM|Perl

ForDef:
  @QName: t|ForAttrMap
  @enDesc:
    For element attributes named node map class.
  @ISA: ManakaiDOM|ForClass

ForDef:
  @QName: c|ForNotationMap
  @Description:
    @@lang:en
    @@@:
      For <ClassM::ManakaiDOMXML:ManakaiDOMNotations> class.
  @ISA: ManakaiDOM|ForClass

ForDef:
  @QName: t|ForETMap
  @enDesc:
    For element type definition list named node map class.
  @ISA: ManakaiDOM|ForClass

ForDef:
  @QName: t|ForATMap
  @enDesc:
    For attribute definition list named node map class.
  @ISA: ManakaiDOM|ForClass

ForDef:
  @QName: t|ForEntityMap
  @enDesc:
    For entity list named node map class.
  @ISA: ManakaiDOM|ForClass

ResourceDef:
  @QName: c|NamedNodeMap
  @AliasFor: NamedNodeMap
  @For: ManakaiDOM|DOM

ResourceDef:
  @rdf:type:
    @@@:
      dis:MultipleResource
    @@ForCheck: !ManakaiDOM|ForIF !ManakaiDOM|ForClass
  @ForCheck: ManakaiDOM|DOM

  @resourceFor: ManakaiDOM|ForIF
  @IFQName: t|NamedNodeMap
  @rdf:type:
    @@@: DISLang|Interface
    @@ForCheck: ManakaiDOM|ForIF

  @f:implements:
    @@@: c|CoreFeature10
    @@ForCheck: ManakaiDOM|DOM1
  @f:implements:
    @@@: c|CoreFeature20
    @@ForCheck: ManakaiDOM|DOM2
  @f:implements:
    @@@: c|CoreFeature30
    @@ForCheck: ManakaiDOM|DOM3

  @resourceFor:
    @@@: c|ForNotationMap
    @@For:
      ManakaiDOM:ManakaiDOM !=ManakaiDOM:ManakaiDOM
  @QName:
    @@@: 
      ManakaiDOMXML:ManakaiDOMNotations
    @@ForCheck: c|ForNotationMap
  @ISA:
    @@@: ManakaiNode|ManakaiNodeRef||ManakaiDOM|Perl
    @@ForCheck: c|ForNotationMap

  @DOMMain:implementFeature:
    @@@: 
      DOMXML:XMLFeature10
    @@ForCheck:
      c|ForNotationMap ManakaiDOM:DOM1
  @DOMMain:implementFeature:
    @@@: 
      DOMXML:XMLFeature20
    @@ForCheck:
      c|ForNotationMap ManakaiDOM:DOM2
  @DOMMain:implementFeature:
    @@@: 
      DOMXML:XMLFeature30
    @@ForCheck:
      c|ForNotationMap ManakaiDOM:DOM3

  @resourceFor:
    @@@: t|ForAttrMap
    @@ForCheck: ManakaiDOM|ManakaiDOM1
  @QName:
    @@@: t|ManakaiDOMAttrMap
    @@ForCheck: t|ForAttrMap

  @resourceFor:
    @@@: t|ForETMap
    @@ForCheck: ManakaiDOM|ManakaiDOMLatest
  @QName:
    @@@: t|ManakaiDOMElementTypeDefMap
    @@ForCheck: t|ForETMap
 
  @f:implements:
    @@@: d|Feature30
    @@ForCheck: t|ForETMap ManakaiDOM|DOM3

  @resourceFor:
    @@@: t|ForATMap
    @@ForCheck: ManakaiDOM|ManakaiDOMLatest
  @QName:
    @@@: t|ManakaiDOMAttrDefMap
    @@ForCheck: t|ForATMap

  @f:implements:
    @@@: d|Feature30
    @@ForCheck: t|ForATMap ManakaiDOM|DOM3

  @resourceFor:
    @@@: t|ForEntityMap
    @@ForCheck: ManakaiDOM|ManakaiDOM1 ManakaiDOM|DOMXMLFeature
  @QName:
    @@@: t|ManakaiDOMEntityMap
    @@ForCheck: t|ForEntityMap

  @f:implements:
    @@@: x|XMLFeature10
    @@ForCheck: t|ForEntityMap ManakaiDOM|DOM1
  @f:implements:
    @@@: x|XMLFeature20
    @@ForCheck: t|ForEntityMap ManakaiDOM|DOM2
  @f:implements:
    @@@: x|XMLFeature30
    @@ForCheck: t|ForEntityMap ManakaiDOM|DOM3
  @f:implements:
    @@@: x|XMLVersionFeature10
    @@ForCheck: t|ForEntityMap ManakaiDOM|DOM3
  @f:implements:
    @@@: x|XMLVersionFeature11
    @@ForCheck: t|ForEntityMap ManakaiDOM|DOM3 ManakaiDOM|DOMXMLFeatureXML11

  @rdf:type:
    @@@: DISLang|Class
    @@ForCheck: ManakaiDOM|ForClass
  @ISA:
    @@@: ManakaiDOM|ManakaiDOMObject
    @@ForCheck: ManakaiDOM|ForClass

  @AppISA:
    @@@: 
      Tie::Array
    @@ContentType: DISPerl|Perl
    @@ForCheck: ManakaiDOM|ForClass

  @Implement:
    @@@: NamedNodeMap||ManakaiDOM|ManakaiDOM
    @@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM
  @Implement:
    @@@: NamedNodeMap||ManakaiDOM|ManakaiDOM1
    @@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM1
  @Implement:
    @@@: NamedNodeMap||ManakaiDOM|ManakaiDOM2
    @@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM2
  @Implement:
    @@@: NamedNodeMap||ManakaiDOM|ManakaiDOM3
    @@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM3
  @Implement:
    @@@: NamedNodeMap||ManakaiDOM|ManakaiDOMLatest
    @@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOMLatest

  @enDesc:
    An object implementing the <IF::NamedNodeMap> interface represents
    a collection of nodes that can be accessed by name.  Unlike
    <IF::NodeList>, a <IF::NamedNodeMap> object does not maintain
    any particular order.  Nodes contained in a <IF::NamedNodeMap>
    may also be accessed by an ordinal index, starting from
    <CODE::0> (zero), but this is simply
    to allow convenient enumeration of the contents of the collection.

    A <IF::NamedNodeMap> object is live.

  @enImplNote:
    @@ddid: order
    @@@:
      That is, node order is preserved as long as no change
      is made to the collection?

  @enImplNote:
    @@ddid: usecases
    @@@:
      In DOM Core module, the only place where <IF::NamedNodeMap>
      is returned is <A::Node.attributes> attribute.  In DOM XML module,
      <A::x|DocumentType.entities> and <A::x|DocumentType.notations>
      are also <IF::NamedNodeMap>s.

      In manakai DOM <MDOM::XDoctype> module, 
      <A::d|DocumentTypeDefinition.elementTypes>, 
      <A::d|DocumentTypeDefinition.generalEntities>,
      <A::d|DocumentTypeDefinition.parameterEntities>,
      <A::d|DocumentTypeDefinition.notations>, and
      <A::d|ElementTypeDefinition.attributeDefinitions> attributes
      are <IF::NamedNodeMap>s.

  @ImplNote:
    @@lang:en
    @@@:
      An element may have two (or more) attributes that have the same 
      <A::Node.nodeName>, but different <A::Node.namespaceURI>s. 
      Which of them is returned by DOM Level 1 methods is 
      implementation dependent.  The only guarantee is 
      that all methods that access a named item by its <A::Node.nodeName> 
      will access the same item, and all methods by its namespace URI
      and local name will access the same item. 
      <SRC::<CITE::DOM Level 2 Core> <sw010:csection::1.4.8 XML Namespaces>,
      <CITE::DOM Level 3 Core> <sw010:csection::1.3.3 XML Namespaces>>

  @enDesc:
    @@For: ManakaiDOM|ManakaiDOM
    @@@:
      In the manakai implementation, <IF::NamedNodeMap>s can be 
      dereferenced as if it is an array reference or a hash reference.
      Dereferencing as an array reference provides an access to
      items by ordinal index, like <M::.item> method; 
      Dereferencing as a hash reference
      provides by name, like <M::.getNamedItem> method.

      {TODO:: How namespace-aware node can be accessed?
      }

      {TODO:: This is <EM::not> implemented yet!
      }

  @IntMethod:
    @@Perlop: %{}
    @@enDesc:
      In manakai's Perl binding, a <IF::NamedNodeMap> object can be
      dereferenced as if it is a hash reference.  For example,
      <Perl::$map-<lt>{name}> will return the same <IF::Node> as
      <Perl::$map-<lt>get_named_item ('name')> would return.  However, it does
      not currently support substitions to hash values (e.g. 
      <Perl::$map-<lt>{name} = $node> does not work).
    @@enImplNote:
      {TODO::
        $map->{$ns, $ln} for attribute maps should be allowed.
      }

      Should $map->{$key} = $node be allowed?  What if 
      $key differs from $node->node_name?
    @@Return:
      @@@Type: DISPerl|HASH||ManakaiDOM|all
      @@@PerlDef:
        tie my %list, ref $self, $self;
        $r = \%list;

    @@Test:
      @@@ForCheck: t|ForAttrMap
      @@@QName: AttrMap.P.test
      @@@PerlDef:
        my $el;
        __CODE{createElementForTest}__;
        my $doc = $el-><AG::Node.ownerDocument>;
        my $em = $el-><AG::Node.attributes>;

        $test->id ('hash.scalar');
        $test->assert_not_null (scalar %$em);

        $test->id ('key.no');
        $test->assert_null ($em->{et1});
        $test->assert_null ($em->{et2});
        $test->id ('exists.no');
        $test->assert_false (exists $em->{et1});
        $test->assert_false (exists $em->{et2});

        $test->id ('setNamedItem');
        my $et1 = $doc-><M::Document.createAttribute> ('et1');
        $em-><M::NamedNodeMap.setNamedItem> ($et1);

        $test->id ('key.et1');
        my $v1 = $em->{et1};
        $test->assert_equals ($v1, $et1);
        $test->id ('exists.et1');
        $test->assert_true (exists $em->{et1});
        $test->id ('not.exists.et2');
        $test->assert_false (exists $em->{et2});

        $test->id ('keys');
        my @keys = keys %$em;
        $test->assert_num_equals
                 (actual_value => 0 + @keys,
                  expected_value => 1);
        $test->assert_equals ($keys[0], 'et1');
        
        $test->id ('setNamedItem.2');
        my $et2 = $doc-><M::Document.createAttribute> ('et2');
        $em-><M::NamedNodeMap.setNamedItem> ($et2);

        $test->id ('keys.2');
        @keys = keys %$em;
        $test->assert_num_equals
                 (actual_value => 0 + @keys,
                  expected_value => 2);
        $test->assert_not_equals ($keys[0], $keys[1]);
        $test->assert_true ($keys[0] eq 'et1' or $keys[0] eq 'et2');
        $test->assert_true ($keys[1] eq 'et1' or $keys[1] eq 'et2');
        
        $test->id ('delete');
        delete $em->{et1};
        $test->assert_false (exists $em->{et1});
        $test->assert_true (exists $em->{et2});

        $test->id ('clear');
        %$em = ();
        $test->assert_num_equals
                 (actual_value => 0 + keys %$em,
                  expected_value => 0);

    @@XDTest:
      @@@ForCheck: t|ForEntityMap
      @@@QName: EntityMap.P.test
      @@@PerlDef:
        my $dtd;
        __CODE{d|newDoctypeForTest}__;
        my $doc = $dtd-><AG::Node.ownerDocument>;
        my $em = $dtd-><AG::d|DocumentTypeDefinition.generalEntities>;

        $test->id ('hash.scalar');
        $test->assert_not_null (scalar %$em);

        $test->id ('key.no');
        $test->assert_null ($em->{et1});
        $test->assert_null ($em->{et2});
        $test->id ('exists.no');
        $test->assert_false (exists $em->{et1});
        $test->assert_false (exists $em->{et2});

        $test->id ('setNamedItem');
        my $et1 = $doc-><M::d|DocumentXDoctype.createGeneralEntity>
                          ('et1');
        $em-><M::NamedNodeMap.setNamedItem> ($et1);

        $test->id ('key.et1');
        my $v1 = $em->{et1};
        $test->assert_equals ($v1, $et1);
        $test->id ('exists.et1');
        $test->assert_true (exists $em->{et1});
        $test->id ('not.exists.et2');
        $test->assert_false (exists $em->{et2});

        $test->id ('keys');
        my @keys = keys %$em;
        $test->assert_num_equals
                 (actual_value => 0 + @keys,
                  expected_value => 1);
        $test->assert_equals ($keys[0], 'et1');
        
        $test->id ('setNamedItem.2');
        my $et2 = $doc-><M::d|DocumentXDoctype.createGeneralEntity>
                          ('et2');
        $em-><M::NamedNodeMap.setNamedItem> ($et2);

        $test->id ('keys.2');
        @keys = keys %$em;
        $test->assert_num_equals
                 (actual_value => 0 + @keys,
                  expected_value => 2);
        $test->assert_not_equals ($keys[0], $keys[1]);
        $test->assert_true ($keys[0] eq 'et1' or $keys[0] eq 'et2');
        $test->assert_true ($keys[1] eq 'et1' or $keys[1] eq 'et2');
        
        $test->id ('delete');
        delete $em->{et1};
        $test->assert_false (exists $em->{et1});
        $test->assert_true (exists $em->{et2});

        $test->id ('clear');
        %$em = ();
        $test->assert_num_equals
                 (actual_value => 0 + keys %$em,
                  expected_value => 0);

    @@XDTest:
      @@@ForCheck: t|ForETMap
      @@@QName: ETMap.P.test
      @@@PerlDef:
        my $dtd;
        __CODE{d|newDoctypeForTest}__;
        my $doc = $dtd-><AG::Node.ownerDocument>;
        my $em = $dtd-><AG::d|DocumentTypeDefinition.elementTypes>;

        $test->id ('hash.scalar');
        $test->assert_not_null (scalar %$em);

        $test->id ('key.no');
        $test->assert_null ($em->{et1});
        $test->assert_null ($em->{et2});
        $test->id ('exists.no');
        $test->assert_false (exists $em->{et1});
        $test->assert_false (exists $em->{et2});

        $test->id ('setNamedItem');
        my $et1 = $doc-><M::d|DocumentXDoctype.createElementTypeDefinition>
                          ('et1');
        $em-><M::NamedNodeMap.setNamedItem> ($et1);

        $test->id ('key.et1');
        my $v1 = $em->{et1};
        $test->assert_equals ($v1, $et1);
        $test->id ('exists.et1');
        $test->assert_true (exists $em->{et1});
        $test->id ('not.exists.et2');
        $test->assert_false (exists $em->{et2});

        $test->id ('keys');
        my @keys = keys %$em;
        $test->assert_num_equals
                 (actual_value => 0 + @keys,
                  expected_value => 1);
        $test->assert_equals ($keys[0], 'et1');
        
        $test->id ('setNamedItem.2');
        my $et2 = $doc-><M::d|DocumentXDoctype.createElementTypeDefinition>
                          ('et2');
        $em-><M::NamedNodeMap.setNamedItem> ($et2);

        $test->id ('keys.2');
        @keys = keys %$em;
        $test->assert_num_equals
                 (actual_value => 0 + @keys,
                  expected_value => 2);
        $test->assert_not_equals ($keys[0], $keys[1]);
        $test->assert_true ($keys[0] eq 'et1' or $keys[0] eq 'et2');
        $test->assert_true ($keys[1] eq 'et1' or $keys[1] eq 'et2');
        
        $test->id ('delete');
        delete $em->{et1};
        $test->assert_false (exists $em->{et1});
        $test->assert_true (exists $em->{et2});

        $test->id ('clear');
        %$em = ();
        $test->assert_num_equals
                 (actual_value => 0 + keys %$em,
                  expected_value => 0);

    @@XDTest:
      @@@ForCheck: t|ForATMap
      @@@QName: ATMap.P.test
      @@@PerlDef:
        my $dtd;
        __CODE{d|newDoctypeForTest}__;
        my $doc = $dtd-><AG::Node.ownerDocument>;
        my $etd = $doc-><M::d|DocumentXDoctype.createElementTypeDefinition>
                          ('etd');
        my $em = $etd-><AG::d|ElementTypeDefinition.attributeDefinitions>;
        undef $dtd;

        $test->id ('hash.scalar');
        $test->assert_not_null (scalar %$em);

        $test->id ('key.no');
        $test->assert_null ($em->{et1});
        $test->assert_null ($em->{et2});
        $test->id ('exists.no');
        $test->assert_false (exists $em->{et1});
        $test->assert_false (exists $em->{et2});

        $test->id ('setNamedItem');
        my $et1 = $doc-><M::d|DocumentXDoctype.createAttributeDefinition>
                          ('et1');
        $em-><M::NamedNodeMap.setNamedItem> ($et1);

        $test->id ('key.et1');
        my $v1 = $em->{et1};
        $test->assert_equals ($v1, $et1);
        $test->id ('exists.et1');
        $test->assert_true (exists $em->{et1});
        $test->id ('not.exists.et2');
        $test->assert_false (exists $em->{et2});

        $test->id ('keys');
        my @keys = keys %$em;
        $test->assert_num_equals
                 (actual_value => 0 + @keys,
                  expected_value => 1);
        $test->assert_equals ($keys[0], 'et1');
        
        $test->id ('setNamedItem.2');
        my $et2 = $doc-><M::d|DocumentXDoctype.createAttributeDefinition>
                          ('et2');
        $em-><M::NamedNodeMap.setNamedItem> ($et2);

        $test->id ('keys.2');
        @keys = keys %$em;
        $test->assert_num_equals
                 (actual_value => 0 + @keys,
                  expected_value => 2);
        $test->assert_not_equals ($keys[0], $keys[1]);
        $test->assert_true ($keys[0] eq 'et1' or $keys[0] eq 'et2');
        $test->assert_true ($keys[1] eq 'et1' or $keys[1] eq 'et2');
        
        $test->id ('delete');
        delete $em->{et1};
        $test->assert_false (exists $em->{et1});
        $test->assert_true (exists $em->{et2});

        $test->id ('clear');
        %$em = ();
        $test->assert_num_equals
                 (actual_value => 0 + keys %$em,
                  expected_value => 0);

  @IntMethod:
    @@Perlop: @{}
    @@enDesc:
      In manakai's Perl binding, a <IF::NamedNodeMap> object can be
      dereferenced as if it is an array reference.  For example,
      <Perl::$map-<lt>[2]> will return the same <IF::Node> as
      <Perl::$map-<lt>item (2)> would return.  However, it does
      not support substitions to array items (e.g. <Perl::$map-<lt>[2] = $node>
      does not work).
    @@Return:
      @@@Type: DISPerl|ARRAY||ManakaiDOM|all
      @@@PerlDef:
        @@@@ForCheck: t|ForAttrMap
        @@@@@:
          tie my @list, <ClassName::ManakaiDOMAttrMapArray>, $self;
          $r = \@list;
      @@@PerlDef:
        @@@@ForCheck: t|ForETMap
        @@@@@:
          tie my @list, <ClassName::ManakaiDOMElementTypeDefMapArray>, $self;
          $r = \@list;
      @@@PerlDef:
        @@@@ForCheck: t|ForATMap
        @@@@@:
          tie my @list, <ClassName::ManakaiDOMAttrDefMapArray>, $self;
          $r = \@list;
      @@@PerlDef:
        @@@@ForCheck: t|ForEntityMap
        @@@@@:
          tie my @list, <ClassName::ManakaiDOMEntityMapArray>, $self;
          $r = \@list;

    @@Test:
      @@@ForCheck: t|ForAttrMap
      @@@QName: AttrMap.@.test
      @@@PerlDef:
        my $el;
        __CODE{createElementForTest}__;
        my $doc = $el-><AG::Node.ownerDocument>;
        my $em = $el-><AG::Node.attributes>;

        $test->id ('length.0');
        $test->assert_num_equals
                 (actual_value => 0 + @$em,
                  expected_value => 0);

        $test->id ('fetch.0.no');
        $test->assert_null ($em->[0]);
        $test->id ('exists.0');
        $test->assert_false (exists $em->[0]);
        $test->id ('exists.-1');
        $test->assert_false (exists $em->[-1]);

        $test->id ('setNamedItem');
        my $et1 = $doc-><M::Document.createAttribute> ('et1');
        $em-><M::NamedNodeMap.setNamedItem> ($et1);

        $test->id ('length.1');
        $test->assert_num_equals
                 (actual_value => 0 + @$em,
                  expected_value => 1);

        $test->id ('0.fetch.0');
        $test->assert_equals ($em->[0], $et1);
        $test->id ('0.fetch.-1');
        $test->assert_equals ($em->[-1], $et1);
        $test->id ('0.fetch.1.no');
        $test->assert_null ($em->[1]);
        $test->id ('0.exists.0');
        $test->assert_true (exists $em->[0]);
        $test->id ('0.exists.-1');
        $test->assert_true (exists $em->[-1]);
        $test->id ('0.exists.1.no');
        $test->assert_false (exists $em->[1]);

        $test->id ('delete.0');
        delete $em->[0];
        $test->assert_false (exists $em->[0]);

    @@XDTest:
      @@@ForCheck: t|ForETMap
      @@@QName: ETMap.@.test
      @@@PerlDef:
        my $dtd;
        __CODE{d|newDoctypeForTest}__;
        my $doc = $dtd-><AG::Node.ownerDocument>;
        my $em = $dtd-><AG::d|DocumentTypeDefinition.elementTypes>;

        $test->id ('length.0');
        $test->assert_num_equals
                 (actual_value => 0 + @$em,
                  expected_value => 0);

        $test->id ('fetch.0.no');
        $test->assert_null ($em->[0]);
        $test->id ('exists.0');
        $test->assert_false (exists $em->[0]);
        $test->id ('exists.-1');
        $test->assert_false (exists $em->[-1]);

        $test->id ('setNamedItem');
        my $et1 = $doc-><M::d|DocumentXDoctype.createElementTypeDefinition>
                          ('et1');
        $em-><M::NamedNodeMap.setNamedItem> ($et1);

        $test->id ('length.1');
        $test->assert_num_equals
                 (actual_value => 0 + @$em,
                  expected_value => 1);

        $test->id ('0.fetch.0');
        $test->assert_equals ($em->[0], $et1);
        $test->id ('0.fetch.-1');
        $test->assert_equals ($em->[-1], $et1);
        $test->id ('0.fetch.1.no');
        $test->assert_null ($em->[1]);
        $test->id ('0.exists.0');
        $test->assert_true (exists $em->[0]);
        $test->id ('0.exists.-1');
        $test->assert_true (exists $em->[-1]);
        $test->id ('0.exists.1.no');
        $test->assert_false (exists $em->[1]);

        $test->id ('delete.0');
        delete $em->[0];
        $test->assert_false (exists $em->[0]);

    @@XDTest:
      @@@ForCheck: t|ForEntityMap
      @@@QName: EntityMap.@.test
      @@@PerlDef:
        my $dtd;
        __CODE{d|newDoctypeForTest}__;
        my $doc = $dtd-><AG::Node.ownerDocument>;
        my $em = $dtd-><AG::d|DocumentTypeDefinition.generalEntities>;

        $test->id ('length.0');
        $test->assert_num_equals
                 (actual_value => 0 + @$em,
                  expected_value => 0);

        $test->id ('fetch.0.no');
        $test->assert_null ($em->[0]);
        $test->id ('exists.0');
        $test->assert_false (exists $em->[0]);
        $test->id ('exists.-1');
        $test->assert_false (exists $em->[-1]);

        $test->id ('setNamedItem');
        my $et1 = $doc-><M::d|DocumentXDoctype.createGeneralEntity>
                          ('et1');
        $em-><M::NamedNodeMap.setNamedItem> ($et1);

        $test->id ('length.1');
        $test->assert_num_equals
                 (actual_value => 0 + @$em,
                  expected_value => 1);

        $test->id ('0.fetch.0');
        $test->assert_equals ($em->[0], $et1);
        $test->id ('0.fetch.-1');
        $test->assert_equals ($em->[-1], $et1);
        $test->id ('0.fetch.1.no');
        $test->assert_null ($em->[1]);
        $test->id ('0.exists.0');
        $test->assert_true (exists $em->[0]);
        $test->id ('0.exists.-1');
        $test->assert_true (exists $em->[-1]);
        $test->id ('0.exists.1.no');
        $test->assert_false (exists $em->[1]);

        $test->id ('delete.0');
        delete $em->[0];
        $test->assert_false (exists $em->[0]);

    @@XDTest:
      @@@ForCheck: t|ForATMap
      @@@QName: ATMap.@.test
      @@@PerlDef:
        my $dtd;
        __CODE{d|newDoctypeForTest}__;
        my $doc = $dtd-><AG::Node.ownerDocument>;
        my $etd = $doc-><M::d|DocumentXDoctype.createElementTypeDefinition>
                          ('et1');
        my $em = $etd-><AG::d|ElementTypeDefinition.attributeDefinitions>;
        undef $dtd;

        $test->id ('length.0');
        $test->assert_num_equals
                 (actual_value => 0 + @$em,
                  expected_value => 0);

        $test->id ('fetch.0.no');
        $test->assert_null ($em->[0]);
        $test->id ('exists.0');
        $test->assert_false (exists $em->[0]);
        $test->id ('exists.-1');
        $test->assert_false (exists $em->[-1]);

        $test->id ('setNamedItem');
        my $et1 = $doc-><M::d|DocumentXDoctype.createAttributeDefinition>
                          ('et1');
        $em-><M::NamedNodeMap.setNamedItem> ($et1);

        $test->id ('length.1');
        $test->assert_num_equals
                 (actual_value => 0 + @$em,
                  expected_value => 1);

        $test->id ('0.fetch.0');
        $test->assert_equals ($em->[0], $et1);
        $test->id ('0.fetch.-1');
        $test->assert_equals ($em->[-1], $et1);
        $test->id ('0.fetch.1.no');
        $test->assert_null ($em->[1]);
        $test->id ('0.exists.0');
        $test->assert_true (exists $em->[0]);
        $test->id ('0.exists.-1');
        $test->assert_true (exists $em->[-1]);
        $test->id ('0.exists.1.no');
        $test->assert_false (exists $em->[1]);

        $test->id ('delete.0');
        delete $em->[0];
        $test->assert_false (exists $em->[0]);

  @Method:
    @@Name: getNamedItem
    @@Perlop: FETCH
    @@enDesc:
      Retrieves a node specified by name.
    @@NSVersion: .getNamedItemNS
    @@Param:
      @@@Name: name
      @@@Type: DOMString
      @@@dis:actualType:
        @@@@@: DOMMain|ManakaiDOMXMLName
        @@@@ManakaiDOM:noInputNormalize: 1
      @@@enDesc:
        The <A::Node.nodeName> of a node to retrieve.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        A <IF::Node> with the specified <P::name>.
      @@@nullCase:
        @@@@enDesc:
          If the <P::name> does not identify any node in the map.
      @@@PerlDef:
        @@@@ForCheck: t|ForAttrMap
        @@@@@:
          __DEEP{
            $r = ($$$self)-><M::Element.getAttributeNode> ($name);
          }__;
      @@@PerlDef:
        @@@@ForCheck: !t|ForAttrMap
        @@@@@:
          my $list;
          __FOR{t:ForETMap::
            $list = ($$$self)->{<H::mn:node>}->{<H::d|elementTypes>};
          }__;
          __FOR{t:ForATMap::
            $list = ($$$self)->{<H::mn:node>}->{<H::d|attributeDefinitions>};
          }__;
          __FOR{t:ForEntityMap::
            $list = ($$$self)->{<H::mn:node>}->{<H::d|generalEntities>};
          }__;
          if (defined $list->{$name}) {
            $r = <ClassM::ManakaiDOMNode.getNodeReference> ($list->{$name});
          }

    @@Test:
      @@@ForCheck: t|ForAttrMap
      @@@QName: AttrMap.getNamedItem.test
      @@@PerlDef:
        my $el;
        __CODE{createElementForTest:: $el => $el}__;

        my $map = $el-><AG::Node.attributes>;
        $test->assert_isa ($map, <IFName::NamedNodeMap>);
        
        $test->id ('no.attr.node');
        $test->assert_null ($map-><M::NamedNodeMap.getNamedItem> ('a1'));

        $test->id ('dom1.attr.node');
        $el-><M::Element.setAttribute> ('a1', 'value1');
        my $a1 = $map-><M::NamedNodeMap.getNamedItem> ('a1');
        $test->assert_isa ($a1, <IFName::Attr>);
        $test->assert_num_equals
                 (actual_value => $a1-><AG::Node.nodeType>,
                  expected_value => <C::Node.ATTRIBUTE_NODE>);
        $test->assert_equals ($a1-><AG::Node.nodeName>, 'a1');
        $test->assert_equals ($a1-><AG::Node.nodeValue>, 'value1');
        undef $a1;

        $test->id ('dom1.attr.node.removed');
        $el-><M::Element.removeAttribute> ('a1');
        $test->assert_null ($map-><M::NamedNodeMap.getNamedItem> ('a1'));
    @@Test:
      @@@ForCheck: t|ForAttrMap ManakaiDOM|DOM2
      @@@QName: AttrMap.getNamedItem.qname.test
      @@@PerlDef:
        my $el;
        __CODE{createElementForTest:: $el => $el}__;

        my $map = $el-><AG::Node.attributes>;
        $test->assert_isa ($map, <IFName::NamedNodeMap>);
        
        $test->id ('dom2.attr.node');
        $el-><M::Element.setAttributeNS> ('http://attr.example/', 'ns:a1', 'v1');
        my $a1 = $map-><M::NamedNodeMap.getNamedItem> ('ns:a1');
        $test->assert_isa ($a1, <IFName::Attr>);
        $test->assert_num_equals
                 (actual_value => $a1-><AG::Node.nodeType>,
                  expected_value => <C::Node.ATTRIBUTE_NODE>);
        $test->assert_equals ($a1-><AG::Node.nodeName>, 'ns:a1');
        $test->assert_equals ($a1-><AG::Node.nodeValue>, 'v1');
        undef $a1;
        $test->assert_null ($map-><M::NamedNodeMap.getNamedItem> ('a1'));

        $test->id ('dom2.attr.node.removed');
        $el-><M::Element.removeAttributeNS> ('http://attr.example/', 'a1');
        $test->assert_null ($map-><M::NamedNodeMap.getNamedItem> ('ns:a1'));

    @@Test:
      @@@ForCheck: t|ForAttrMap
      @@@QName: AttrMap.getNamedItem.setNamedItem.test
      @@@PerlDef:
        my $el;
        __CODE{createElementForTest}__;
        my $doc = $el-><AG::Node.ownerDocument>;

        my $em = $el-><AG::Node.attributes>;
        $test->assert_isa ($em, <IFName::t|NamedNodeMap>);

        $test->id ('getNamedItem.none');
        $test->assert_null ($em-><M::NamedNodeMap.getNamedItem> ('et1'));

        my $et1 = $doc-><M::Document.createAttribute>
                          ('et1');
        $test->assert_isa ($et1, <IFName::Attr>);

        $test->id ('setNamedItem.et1');
        my $r1 = $em-><M::NamedNodeMap.setNamedItem> ($et1);
        $test->assert_null ($r1);

        $test->id ('getNamedItem.et1');
        my $r2 = $em-><M::NamedNodeMap.getNamedItem> ('et1');
        $test->assert_equals ($r2, $et1);
        $test->assert_equals
                 ($r2-><AG::Attr.ownerElement>, $el);
        $test->assert_equals
                 ($et1-><AG::Attr.ownerElement>, $el);

        my $et2 = $doc-><M::Document.createAttribute>
                          ('et1');
        $test->assert_isa ($et2, <IFName::Attr>);
        $test->assert_not_equals ($et1, $et2);

        $test->id ('setNamedItem.et2');
        my $r3 = $em-><M::NamedNodeMap.setNamedItem> ($et2);
        $test->assert_equals ($r3, $et1);

        $test->id ('getNamedItem.et2');
        my $r4 = $em-><M::NamedNodeMap.getNamedItem> ('et1');
        $test->assert_equals ($r4, $et2);

        $test->id ('setNamedItem.et2.by.et2');
        my $r5 = $em-><M::NamedNodeMap.setNamedItem> ($et2);
        $test->assert_null ($r5);
        $test->assert_equals ($em-><M::NamedNodeMap.getNamedItem> ('et1'), $et2);

    @@XDTest:
      @@@ForCheck: t|ForETMap
      @@@QName: etmap.getNamedItem.setNamedItem.test
      @@@PerlDef:
        my $dtd;
        __CODE{d|newDoctypeForTest}__;
        my $doc = $dtd-><AG::Node.ownerDocument>;

        my $em = $dtd-><AG::d|DocumentTypeDefinition.elementTypes>;
        $test->assert_isa ($em, <IFName::t|NamedNodeMap>);

        $test->id ('getNamedItem.none');
        $test->assert_null ($em-><M::NamedNodeMap.getNamedItem> ('et1'));

        my $et1 = $doc-><M::d|DocumentXDoctype.createElementTypeDefinition>
                          ('et1');
        $test->assert_isa ($et1, <IFName::d|ElementTypeDefinition>);

        $test->id ('setNamedItem.et1');
        my $r1 = $em-><M::NamedNodeMap.setNamedItem> ($et1);
        $test->assert_null ($r1);

        $test->id ('getNamedItem.et1');
        my $r2 = $em-><M::NamedNodeMap.getNamedItem> ('et1');
        $test->assert_equals ($r2, $et1);
        $test->assert_equals
                 ($r2-><AG::d|ElementTypeDefinition.ownerDocumentTypeDefinition>,
                  $dtd);
        $test->assert_equals
                 ($et1-><AG::d|ElementTypeDefinition.ownerDocumentTypeDefinition>,
                  $dtd);

        my $et2 = $doc-><M::d|DocumentXDoctype.createElementTypeDefinition>
                          ('et1');
        $test->assert_isa ($et2, <IFName::d|ElementTypeDefinition>);
        $test->assert_not_equals ($et1, $et2);

        $test->id ('setNamedItem.et2');
        my $r3 = $em-><M::NamedNodeMap.setNamedItem> ($et2);
        $test->assert_equals ($r3, $et1);

        $test->id ('getNamedItem.et2');
        my $r4 = $em-><M::NamedNodeMap.getNamedItem> ('et1');
        $test->assert_equals ($r4, $et2);

        $test->id ('setNamedItem.et2.by.et2');
        my $r5 = $em-><M::NamedNodeMap.setNamedItem> ($et2);
        $test->assert_null ($r5);
        $test->assert_equals ($em-><M::NamedNodeMap.getNamedItem> ('et1'), $et2);

    @@XDTest:
      @@@ForCheck: t|ForEntityMap
      @@@QName: EntityMap.getNamedItem.setNamedItem.test
      @@@PerlDef:
        my $dtd;
        __CODE{d|newDoctypeForTest}__;
        my $doc = $dtd-><AG::Node.ownerDocument>;

        my $em = $dtd-><AG::d|DocumentTypeDefinition.generalEntities>;
        $test->assert_isa ($em, <IFName::t|NamedNodeMap>);

        $test->id ('getNamedItem.none');
        $test->assert_null ($em-><M::NamedNodeMap.getNamedItem> ('et1'));

        my $et1 = $doc-><M::d|DocumentXDoctype.createGeneralEntity>
                          ('et1');
        $test->assert_isa ($et1, <IFName::x|Entity>);

        $test->id ('setNamedItem.et1');
        my $r1 = $em-><M::NamedNodeMap.setNamedItem> ($et1);
        $test->assert_null ($r1);

        $test->id ('getNamedItem.et1');
        my $r2 = $em-><M::NamedNodeMap.getNamedItem> ('et1');
        $test->assert_equals ($r2, $et1);
        $test->assert_equals
                 ($r2-><AG::x|Entity.ownerDocumentTypeDefinition>,
                  $dtd);
        $test->assert_equals
                 ($et1-><AG::x|Entity.ownerDocumentTypeDefinition>,
                  $dtd);

        my $et2 = $doc-><M::d|DocumentXDoctype.createGeneralEntity>
                          ('et1');
        $test->assert_isa ($et2, <IFName::x|Entity>);
        $test->assert_not_equals ($et1, $et2);

        $test->id ('setNamedItem.et2');
        my $r3 = $em-><M::NamedNodeMap.setNamedItem> ($et2);
        $test->assert_equals ($r3, $et1);

        $test->id ('getNamedItem.et2');
        my $r4 = $em-><M::NamedNodeMap.getNamedItem> ('et1');
        $test->assert_equals ($r4, $et2);

        $test->id ('setNamedItem.et2.by.et2');
        my $r5 = $em-><M::NamedNodeMap.setNamedItem> ($et2);
        $test->assert_null ($r5);
        $test->assert_equals ($em-><M::NamedNodeMap.getNamedItem> ('et1'), $et2);

  @Method:
    @@Name: setNamedItem
    @@enDesc:
      Adds a node using its <A::Node.nodeName> attribute.  If a node
      with that name is already present in the map, it is replaced
      by the new one.  Replacing a node by itself has no effect.

      As the <A::Node.nodeName> is used to derive the name under which
      the node is stored, multiple nodes the names would clash
      cannot be stored.
    @@enImplNote:
      @@@ddid: repbyitself
      @@@@:
        <QUOTE::Replacing a node by itself has no effect> clause is 
        clarified by DOM Level 2 errata.
    @@NSVersion: .setNamedItemNS
    @@Param:
      @@@Name: arg
      @@@Type: Node
      @@@enDesc:
        A node to store to the map.
      @@@enImplNote:
        The node will later be accessible using the value of <A::Node.nodeName>
        attribute.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        If <P::arg> replaces an existing node, the replaced <IF::Node>.
      @@@nullCase:
        @@@@enDesc:
          No replacement occurred.
        @@@@enImplNote:
          What is returned if replace-by-itself?  It has no effect,
          so it does no <QUOTE::replacement>, and <DOM::null>
          should be returned?
      @@@dx:raises:
        @@@@@: c|DIFFERENT_DOCUMENT_ERR
        @@@@enDesc:
          If <P::arg> was created from a different document than
          the one that created the map.
        @@@@enDesc:
          @@@@@ddid: no-doc
          @@@@@ForCheck: !t|ForAttrMap ManakaiDOM|ManakaiDOM
          @@@@@@:
            If the map is attached to a <IF::x|DocumentType> 
            whose <A::Node.ownerDocument> is <DOM::null>.
      @@@dx:raises:
        @@@@@: c|NOMOD_NAMEDNODEMAP_ERR
        @@@@enDesc:
          If the map is read-only.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the node to which the map is attached is read-only.
      @@@dx:raises:
        @@@@@: c|INUSE_ATTRIBUTE_ERR
        @@@@enDesc:
          If <P::arg> is an <IF::Attr> that is already an attribute
          of another <IF::Element>.
        @@@@ForCheck: !t|ForETMap !t|ForATMap !t|ForEntityMap
      @@@dx:raises:
        @@@@@: c|INUSE_DEFINITION_ERR
        @@@@enDesc:
          If <P::arg> is a definition node that is already used
          for another node.
        @@@@ForCheck: !t|ForAttrMap
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_BAD_TYPE
        @@@@enDesc:
          If an attempt is made to add a node that is unable to
          belong to the map.
        @@@@enImplNote:
          Added by DOM Level 2 errata.
        @@@@For: ManakaiDOM|DOM2
      @@@c:reports:
        @@@@@: t|replace-by-itself
        @@@@enDesc:
          If the <P::arg> node is same as the node that is in the map.
          Then, the method call has no effect.
        @@@@enImplNote:
          This case is clarified by DOM Level 2 errata.
        @@@@For: ManakaiDOM|ManakaiDOM
      @@@PerlDef:
        @@@@ForCheck: t|ForAttrMap
        @@@@@:
          __DEEP{
            $r = ($$$self)-><M::Element.setAttributeNode> ($arg);
          }__;
      @@@PerlDef:
        @@@@ForCheck: !t|ForAttrMap
        @@@@@:
          my $owner = ($$$self)->{<H::mn:node>};
          my $list;
          my $expected_type;
          __FOR{t:ForETMap::
            $list = $owner->{<H::d|elementTypes>};
            $expected_type = <C::Node.ELEMENT_TYPE_DEFINITION_NODE>;
          }__;
          __FOR{t:ForATMap::
            $list = $owner->{<H::d|attributeDefinitions>};
            $expected_type = <C::Node.ATTRIBUTE_DEFINITION_NODE>;
          }__;
          __FOR{t:ForEntityMap::
            $list = $owner->{<H::d|generalEntities>};
            $expected_type = <C::Node.ENTITY_NODE>;
          }__;
          if (<Code::doStrictErrorChecking:: $nodeRef = {$$$self}>) {
            unless (UNIVERSAL::isa ($arg,
                                    <IFName::mn|NodeRef||ManakaiDOM|Perl>) and
                    $arg->{<H::mn:node>}->{<H::c|ownerDocument>} and
                    $owner->{<H::c|ownerDocument>} and
                    $arg->{<H::mn:node>}->{<H::c|ownerDocument>}
                        ->{<H::mn:nodeID>} eq
                            $owner->{<H::c|ownerDocument>}->{<H::mn:nodeID>}) {
              __EXCEPTION{c|DIFFERENT_DOCUMENT_ERR::
              }__;
            }
            if ($owner->{<H::c|read-only>}) {
              __EXCEPTION{c|NOMOD_NAMEDNODEMAP_ERR::
              }__;
            }
            if ($arg->{<H::mn:node>}->{<H::d|ownerDefinition>} and
                $arg->{<H::mn:node>}->{<H::d|ownerDefinition>} ne $owner) {
              __EXCEPTION{c|INUSE_DEFINITION_ERR::
                MDOMX:param-name => 'arg',
                c:node => {$arg},
              }__;
              ## NOTE: If equals to owner, then replace-by-itself error.
            }
            if ($arg-><AG::Node.nodeType> != $expected_type) {
              __EXCEPTION{MDOMX|HIERARCHY_BAD_TYPE::
                c:nodeType => {$arg-><AG::Node.nodeType>},
                MDOMX:param-name => 'arg',
              }__;
            }
          } # strictErrorChecking
          SET: {
            my $name = $arg-><AG::Node.nodeName>;
            if (defined $list->{$name}) {
              my $old_stem = $list->{$name};
              if ($old_stem eq $arg->{<H::mn:node>}) {
                __c:ERROR{t|replace-by-itself::
                  c:relatedData => {$arg},
                }__;
                # no return value
                last SET;
              } else {
                $r = <ClassM::ManakaiDOMNode.getNodeReference> ($old_stem)
                  if defined wantarray;
                CORE::delete $list->{$name};
                CORE::delete $old_stem->{<H::d|ownerDefinition>};
                $old_stem-><M::NodeStem.orphanate>;
              }
            }
            $owner-><M::NodeStem.importTree> ($arg->{<H::mn:node>});
            $list->{$name} = $arg->{<H::mn:node>};
            $arg->{<H::mn:node>}->{<H::d|ownerDefinition>} = $owner;
          } # SET

    @@enImplNote:
      @@@ForCheck: !t|ForETMap
      @@@ddid: nsattrnodename
      @@@@:
        {P:: If a <IF::NamedNodeMap> contains two nodes:
            
             - <A::Node.nodeName> equals to <CODE::ns1:ln>, and
 
             - <A::Node.nodeName> equals to <CODE::ns2:ln>,
               <A::Node.localName> equals to <CODE::ln>, and 
               <A::Node.namespaceURI> equals to <URI::http://www.example/>,
              
             then what result is lead by an attempt to add a node
             with <A::Node.nodeName> equals to <CODE::ns1:ln>,
             <A::Node.localName> equals to <CODE::ln>, and
             <A::Node.namespaceURI> equals to <URI::http://www.example/>?
        }

    @@Test:
      @@@ForCheck: t|ForAttrMap
      @@@QName: AttrMap.setNamedItem.dom1.test
      @@@PerlDef:
        my $doc;
        my $el;
        __CODE{createElementForTest:: $el => $el}__;

        $doc = $el-><AG::Node.ownerDocument>;

        my $map = $el-><AG::Node.attributes>;

        $test->assert_null ($map-><M::NamedNodeMap.getNamedItem> ('a1'));

        $test->id ('set.new.node');
        my $a1 = $doc-><M::Document.createAttribute> ('a1');
        $a1-><AS::Attr.value> ('value1');
        $map-><M::NamedNodeMap.setNamedItem> ($a1);
        my $a1r = $map-><M::NamedNodeMap.getNamedItem> ('a1');
        $test->assert_isa ($a1r, <IFName::Attr>);
        $test->assert_num_equals
                 (actual_value => $a1r-><AG::Node.nodeType>,
                  expected_value => <C::Node.ATTRIBUTE_NODE>);
        $test->assert_equals ($a1r-><AG::Node.nodeName>, 'a1');
        $test->assert_equals ($a1r-><AG::Node.nodeValue>, 'value1');
        $test->assert_equals ($a1r, $a1);
        $test->assert_equals ($el-><M::Element.getAttribute> ('a1'), 'value1');

        $test->id ('replace.node');
        my $a2 = $doc-><M::Document.createAttribute> ('a1');
        $a2-><AS::Attr.value> ('value2');
        $test->assert_not_equals ($a1, $a2);
        my $ra1 = $map-><M::NamedNodeMap.setNamedItem> ($a2);
        $test->assert_equals ($ra1, $a1);
        my $a2r = $map-><M::NamedNodeMap.getNamedItem> ('a1');
        $test->assert_equals ($a2r, $a2);
        $test->assert_equals ($el-><M::Element.getAttribute> ('a1'), 'value2');
     @@enImplNote:
       {TODO:: Namespace aware test required
       }

  @Method:
    @@Name: removeNamedItem
    @@enDesc:
      Removes a node specified by name.
    @@enDesc:
      @@@ddid: attr
      @@@ForCheck: !t|ForETMap !t|ForATMap !t|ForEntityMap
      @@@enDesc:
        If the removed attribute is known to have a default value,
        an attribute immediately appears containing the default
        value as well as the corresponding namespace URI, local name,
        and prefix when applicable.
    @@NSVersion: .removeNamedItemNS
    @@Param:
      @@@Name: name
      @@@Type: DOMString
      @@@dis:actualType: 
        @@@@@: DOMMain|ManakaiDOMXMLName
        @@@@ManakaiDOM:noInputNormalize: 1
      @@@enDesc:
        The <A::Node.nodeName> of the node to remove.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node removed from the map.
      @@@dx:raises:
        @@@@@: c|NO_NAMED_NODE_ERR
        @@@@enDesc:
          If there is no node named as <P::name> in the map.
      @@@dx:raises:
        @@@@@: c|NOMOD_NAMEDNODEMAP_ERR
        @@@@enDesc:
          If the map is read-only.
        @@@@enImplNote:
          Added by DOM Level 1 (first edition) errata.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the node to which the map is attached is read-only.
        @@@@For: ManakaiDOM|ManakaiDOM
      @@@enImplNote:
        In DOM Level 1 Specification (first edition), it is defined that 
        in case there is no node with <P::name> then <DOM::null> should be
        returned while <X::c|NO_NAMED_NODE_ERR> exception is also specified.
        The former is removed by DOM Level 1 (first edition) errata.
      @@@PerlDef:
        @@@@ForCheck: t|ForAttrMap
        @@@@@:
          my $el = $$$self;
          __DEEP{ 
            $r = $el-><M::Element.getAttributeNode> ($name);
          }__;
          unless ($r) {
            __EXCEPTION{c|NO_NAMED_NODE_ERR::
              c|name => {$name},
              MDOMX|param-name => 'name',
            }__;
          }
          __DEEP{
            $r = $el-><M::Element.removeAttributeNode> ($r);
          }__;
      @@@PerlDef:
        @@@@ForCheck: !t|ForAttrMap
        @@@@@:
          my $owner = ($$$self)->{<H::mn:node>};
          my $list;
          __FOR{t:ForETMap::
            $list = $owner->{<H::d|elementTypes>};
          }__;
          __FOR{t:ForATMap::
            $list = $owner->{<H::d|attributeDefinitions>};
          }__;
          __FOR{t:ForEntityMap::
            $list = $owner->{<H::d|generalEntities>};
          }__;
          if (<Code::doStrictErrorChecking:: $nodeRef = {$$$self}>) {
            if ($owner->{<H::c|read-only>}) {
              __EXCEPTION{c|NOMOD_NAMEDNODEMAP_ERR::
              }__;
            }
          } # strictErrorChecking

          if (defined $list->{$name}) {
            my $old_stem = $list->{$name};
            $r = <ClassM::ManakaiDOMNode.getNodeReference> ($old_stem)
              if defined wantarray;
            CORE::delete $list->{$name};
            CORE::delete $old_stem->{<H::d|ownerDefinition>};
            $old_stem-><M::NodeStem.orphanate>;
          } else {
            __EXCEPTION{c|NO_NAMED_NODE_ERR::
              c|name => {$name},
              MDOMX|param-name => 'name',
            }__;
          }

    @@Test:
      @@@QName: AttrMap.removeNamedItem.test
      @@@ForCheck: t|ForAttrMap
      @@@PerlDef:
        my $el;
        __CODE{createElementForTest}__;
        my $doc = $el-><AG::Node.ownerDocument>;
        my $em = $el-><AG::Node.attributes>;
        undef $el;

        $test->id ('setNamedItem');
        my $et1 = $doc-><M::Document.createAttribute> ('et1');
        $em-><M::NamedNodeMap.setNamedItem> ($et1);
        $test->assert_equals
                 ($em-><M::NamedNodeMap.getNamedItem> ('et1'), $et1);

        $test->id ('removeNamedItem.noremove');
        $test->assert_exception (code => sub {
          $em-><M::NamedNodeMap.removeNamedItem> ('et2');
        }, exception_subtype => <Q::c|NO_NAMED_NODE_ERR>);

        $test->id ('removeNamedItem.remove');
        my $et3 = $em-><M::NamedNodeMap.removeNamedItem> ('et1');
        $test->assert_equals ($et3, $et1);
        $test->assert_null ($em-><M::NamedNodeMap.getNamedItem> ('et1'));

        undef $em;

    @@XDTest:
      @@@QName: ETMap.removeNamedItem.test
      @@@ForCheck: t|ForETMap
      @@@PerlDef:
        my $dtd;
        __CODE{d|newDoctypeForTest}__;
        my $doc = $dtd-><AG::Node.ownerDocument>;
        my $em = $dtd-><AG::d|DocumentTypeDefinition.elementTypes>;
        undef $dtd;

        $test->id ('setNamedItem');
        my $et1 = $doc-><M::d|DocumentXDoctype.createElementTypeDefinition>
                          ('et1');
        $em-><M::NamedNodeMap.setNamedItem> ($et1);
        $test->assert_equals
                 ($em-><M::NamedNodeMap.getNamedItem> ('et1'), $et1);

        $test->id ('removeNamedItem.noremove');
        $test->assert_exception (code => sub {
          $em-><M::NamedNodeMap.removeNamedItem> ('et2');
        }, exception_subtype => <Q::c|NO_NAMED_NODE_ERR>);

        $test->id ('removeNamedItem.remove');
        my $et3 = $em-><M::NamedNodeMap.removeNamedItem> ('et1');
        $test->assert_equals ($et3, $et1);
        $test->assert_null ($em-><M::NamedNodeMap.getNamedItem> ('et1'));

        undef $em;

    @@XDTest:
      @@@QName: ATMap.removeNamedItem.test
      @@@ForCheck: t|ForATMap
      @@@PerlDef:
        my $dtd;
        __CODE{d|newDoctypeForTest}__;
        my $doc = $dtd-><AG::Node.ownerDocument>;
        my $etd = $doc-><M::d|DocumentXDoctype.createElementTypeDefinition>
                          ('et1');
        my $ad = $etd-><AG::d|ElementTypeDefinition.attributeDefinitions>;
        undef $dtd;
        undef $etd;

        $test->id ('setNamedItem');
        my $at1 = $doc-><M::d|DocumentXDoctype.createAttributeDefinition>
                          ('at1');
        $ad-><M::NamedNodeMap.setNamedItem> ($at1);
        $test->assert_equals
                 ($ad-><M::NamedNodeMap.getNamedItem> ('at1'), $at1);

        $test->id ('removeNamedItem.noremove');
        $test->assert_exception (code => sub {
          $ad-><M::NamedNodeMap.removeNamedItem> ('at2');
        }, exception_subtype => <Q::c|NO_NAMED_NODE_ERR>);

        $test->id ('removeNamedItem.remove');
        my $at3 = $ad-><M::NamedNodeMap.removeNamedItem> ('at1');
        $test->assert_equals ($at3, $at1);
        $test->assert_null ($ad-><M::NamedNodeMap.getNamedItem> ('at1'));

        undef $ad;

    @@XDTest:
      @@@QName: EntityMap.removeNamedItem.test
      @@@ForCheck: t|ForEntityMap
      @@@PerlDef:
        my $dtd;
        __CODE{d|newDoctypeForTest}__;
        my $doc = $dtd-><AG::Node.ownerDocument>;
        my $em = $dtd-><AG::d|DocumentTypeDefinition.generalEntities>;
        undef $dtd;

        $test->id ('setNamedItem');
        my $et1 = $doc-><M::d|DocumentXDoctype.createGeneralEntity>
                          ('et1');
        $em-><M::NamedNodeMap.setNamedItem> ($et1);
        $test->assert_equals
                 ($em-><M::NamedNodeMap.getNamedItem> ('et1'), $et1);

        $test->id ('removeNamedItem.noremove');
        $test->assert_exception (code => sub {
          $em-><M::NamedNodeMap.removeNamedItem> ('et2');
        }, exception_subtype => <Q::c|NO_NAMED_NODE_ERR>);

        $test->id ('removeNamedItem.remove');
        my $et3 = $em-><M::NamedNodeMap.removeNamedItem> ('et1');
        $test->assert_equals ($et3, $et1);
        $test->assert_null ($em-><M::NamedNodeMap.getNamedItem> ('et1'));

        undef $em;

  @IntMethod:
    @@Perlop: DELETE
    @@enDesc:
      Removes a node specified by name.
    @@enDesc:
      @@@ddid: attr
      @@@ForCheck: t|ForAttrMap
      @@@enDesc:
        If the removed attribute is known to have a default value,
        an attribute immediately appears containing the default
        value as well as the corresponding namespace URI, local name,
        and prefix when applicable.
    @@Param:
      @@@Name: key
      @@@Type: DOMString
      @@@enDesc:
        The <A::Node.nodeName> of the node to remove.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node removed from the map.
      @@@enImplNote:
        Is this return value OK?
      @@@nullCase:
        @@@@enDesc:
          If there is no node named as <P::name> in the map.
      @@@dx:raises:
        @@@@@: c|NOMOD_NAMEDNODEMAP_ERR
        @@@@enDesc:
          If the map is read-only.
      @@@PerlDef:
        try {
          $r = $self-><M::NamedNodeMap.removeNamedItem> ($key);
        } catch <IF::c|DOMException> with {
          my $err = shift;
          unless ($err->subtype eq <Q::c|NO_NAMED_NODE_ERR>) {
            $err->throw;
          }
        };

  @Method:
    @@Name: item
    @@enDesc:
      Returns the <P::index>th item in the map.
    @@Param:
      @@@Name: index
      @@@Type: idl|unsignedLong||ManakaiDOM|all
      @@@enDesc:
        The ordinal index of a node to retrieve.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node at the <P::index>th position in the map.
      @@@nullCase:
        @@@@enDesc:
          If <P::index> is greater than or equal to the number of nodes
          in the map.
      @@@PerlDef:
        @@@@ForCheck: t|ForAttrMap
        @@@@@:
          FIND: {
            my $i = 0;
            my $attrs = ($$$self)->{<H::mn:node>}->{<H::infoset:attributes>};
            for my $ns (sort {$a cmp $b} keys %{$attrs}) {
              for my $ln (sort {$a cmp $b} keys %{$attrs->{$ns}}) {
                if ($i++ == $index) {
                  $r = <ClassM::ManakaiDOMNode.getNodeReference>
                         ($attrs->{$ns}->{$ln});
                  last FIND;
                }
              }
            }
          } # FIND
      @@@PerlDef:
        @@@@ForCheck: !t|ForAttrMap
        @@@@@:
          my $list;
          __FOR{t:ForETMap::
            $list = ($$$self)->{<H::mn:node>}->{<H::d|elementTypes>};
          }__;
          __FOR{t:ForATMap::
            $list = ($$$self)->{<H::mn:node>}->{<H::d|attributeDefinitions>};
          }__;
          __FOR{t:ForEntityMap::
            $list = ($$$self)->{<H::mn:node>}->{<H::d|generalEntities>};
          }__;
          my $key = $index >= 0 ? [sort {$a cmp $b} keys %$list]->[$index]
                                : null;
          if (defined $key and defined $list->{$key}) {
            $r = <ClassM::ManakaiDOMNode.getNodeReference> ($list->{$key});
          }
    
    @@Test:
      @@@QName: AttrMap.item.test
      @@@ForCheck: t|ForAttrMap
      @@@PerlDef:
        my $el;
        __CODE{createElementForTest}__;
        my $doc = $el-><AG::Node.ownerDocument>;
        my $em = $el-><AG::Node.attributes>;
        
        $test->id ('no.item');
        $test->assert_null ($em-><M::NamedNodeMap.item> (-1));
        $test->assert_null ($em-><M::NamedNodeMap.item> (0));
        $test->assert_null ($em-><M::NamedNodeMap.item> (1));
        $test->assert_null ($em-><M::NamedNodeMap.item> (2));

        $test->id ('two.items');
        my $et1 = $doc-><M::Document.createAttribute>
                          ('et1');
        $el-><M::Element.setAttributeNode> ($et1);
        my $et2 = $doc-><M::Document.createAttribute>
                          ('et2');
        $el-><M::Element.setAttributeNode> ($et2);

        $test->assert_null ($em-><M::NamedNodeMap.item> (-1));
        $test->assert_null ($em-><M::NamedNodeMap.item> (2));
        my $item0 = $em-><M::NamedNodeMap.item> (0);
        my $item1 = $em-><M::NamedNodeMap.item> (1);
        $test->assert_not_null ($item0);
        $test->assert_not_null ($item1);
        $test->assert_not_equals ($item0, $item1);
        $test->assert_true ($et1 eq $item0 or $et2 eq $item0);
        $test->assert_true ($et1 eq $item1 or $et2 eq $item1);
    
    @@XDTest:
      @@@QName: ETMap.item.test
      @@@ForCheck: t|ForETMap
      @@@PerlDef:
        my $dtd;
        __CODE{d|newDoctypeForTest}__;
        my $doc = $dtd-><AG::Node.ownerDocument>;
        my $em = $dtd-><AG::d|DocumentTypeDefinition.elementTypes>;
        
        $test->id ('no.item');
        $test->assert_null ($em-><M::NamedNodeMap.item> (-1));
        $test->assert_null ($em-><M::NamedNodeMap.item> (0));
        $test->assert_null ($em-><M::NamedNodeMap.item> (1));
        $test->assert_null ($em-><M::NamedNodeMap.item> (2));

        $test->id ('two.items');
        my $et1 = $doc-><M::d|DocumentXDoctype.createElementTypeDefinition>
                          ('et1');
        $dtd-><M::d|DocumentTypeDefinition.setElementTypeDefinitionNode> ($et1);
        my $et2 = $doc-><M::d|DocumentXDoctype.createElementTypeDefinition>
                          ('et2');
        $dtd-><M::d|DocumentTypeDefinition.setElementTypeDefinitionNode> ($et2);

        $test->assert_null ($em-><M::NamedNodeMap.item> (-1));
        $test->assert_null ($em-><M::NamedNodeMap.item> (2));
        my $item0 = $em-><M::NamedNodeMap.item> (0);
        my $item1 = $em-><M::NamedNodeMap.item> (1);
        $test->assert_not_null ($item0);
        $test->assert_not_null ($item1);
        $test->assert_not_equals ($item0, $item1);
        $test->assert_true ($et1 eq $item0 or $et2 eq $item0);
        $test->assert_true ($et1 eq $item1 or $et2 eq $item1);
    
    @@XDTest:
      @@@QName: ATMap.item.test
      @@@ForCheck: t|ForATMap
      @@@PerlDef:
        my $dtd;
        __CODE{d|newDoctypeForTest}__;
        my $doc = $dtd-><AG::Node.ownerDocument>;
        my $etd = $doc-><M::d|DocumentXDoctype.createElementTypeDefinition>
                          ('et1');
        my $ad = $etd-><AG::d|ElementTypeDefinition.attributeDefinitions>;
        undef $dtd;
        
        $test->id ('no.item');
        $test->assert_null ($ad-><M::NamedNodeMap.item> (-1));
        $test->assert_null ($ad-><M::NamedNodeMap.item> (0));
        $test->assert_null ($ad-><M::NamedNodeMap.item> (1));
        $test->assert_null ($ad-><M::NamedNodeMap.item> (2));

        $test->id ('two.items');
        my $at1 = $doc-><M::d|DocumentXDoctype.createAttributeDefinition>
                          ('at1');
        $etd-><M::d|ElementTypeDefinition.setAttributeDefinitionNode> ($at1);
        my $at2 = $doc-><M::d|DocumentXDoctype.createAttributeDefinition>
                          ('at2');
        $etd-><M::d|ElementTypeDefinition.setAttributeDefinitionNode> ($at2);

        $test->assert_null ($ad-><M::NamedNodeMap.item> (-1));
        $test->assert_null ($ad-><M::NamedNodeMap.item> (2));
        my $item0 = $ad-><M::NamedNodeMap.item> (0);
        my $item1 = $ad-><M::NamedNodeMap.item> (1);
        $test->assert_not_null ($item0);
        $test->assert_not_null ($item1);
        $test->assert_not_equals ($item0, $item1);
        $test->assert_true ($at1 eq $item0 or $at2 eq $item0);
        $test->assert_true ($at1 eq $item1 or $at2 eq $item1);
    
    @@XDTest:
      @@@QName: EntityMap.item.test
      @@@ForCheck: t|ForEntityMap
      @@@PerlDef:
        my $dtd;
        __CODE{d|newDoctypeForTest}__;
        my $doc = $dtd-><AG::Node.ownerDocument>;
        my $em = $dtd-><AG::d|DocumentTypeDefinition.generalEntities>;
        
        $test->id ('no.item');
        $test->assert_null ($em-><M::NamedNodeMap.item> (-1));
        $test->assert_null ($em-><M::NamedNodeMap.item> (0));
        $test->assert_null ($em-><M::NamedNodeMap.item> (1));
        $test->assert_null ($em-><M::NamedNodeMap.item> (2));

        $test->id ('two.items');
        my $et1 = $doc-><M::d|DocumentXDoctype.createGeneralEntity>
                          ('et1');
        $dtd-><M::d|DocumentTypeDefinition.setGeneralEntityNode> ($et1);
        my $et2 = $doc-><M::d|DocumentXDoctype.createGeneralEntity>
                          ('et2');
        $dtd-><M::d|DocumentTypeDefinition.setGeneralEntityNode> ($et2);

        $test->assert_null ($em-><M::NamedNodeMap.item> (-1));
        $test->assert_null ($em-><M::NamedNodeMap.item> (2));
        my $item0 = $em-><M::NamedNodeMap.item> (0);
        my $item1 = $em-><M::NamedNodeMap.item> (1);
        $test->assert_not_null ($item0);
        $test->assert_not_null ($item1);
        $test->assert_not_equals ($item0, $item1);
        $test->assert_true ($et1 eq $item0 or $et2 eq $item0);
        $test->assert_true ($et1 eq $item1 or $et2 eq $item1);

  @Attr:
    @@Name: length
    @@Perlop: FETCHSIZE
    @@enDesc:
      The number of nodes in the map.
    @@Type: idl|unsignedLong||ManakaiDOM|all
    @@Get:
      @@@PerlDef:
        @@@@ForCheck: t|ForAttrMap
        @@@@@:
          for my $l (values %{($$$self)->{<H::mn:node>}
                                       ->{<H::infoset:attributes>}}) {
            $r += grep {$l->{$_}} keys %$l;
          }
      @@@PerlDef:
        @@@@ForCheck: t|ForETMap
        @@@@@:
          $r = @{[map {$_} values %{$$$self->{<H::mn:node>}
                                           ->{<H::d|elementTypes>}}]};
      @@@PerlDef:
        @@@@ForCheck: t|ForATMap
        @@@@@:
          $r = @{[map {$_} values %{$$$self->{<H::mn:node>}
                                           ->{<H::d|attributeDefinitions>}}]};
      @@@PerlDef:
        @@@@ForCheck: t|ForEntityMap
        @@@@@:
          $r = @{[map {$_} values %{$$$self->{<H::mn:node>}
                                           ->{<H::d|generalEntities>}}]};

    @@Test:
      @@@QName: AttrMap.length.test
      @@@ForCheck: t|ForAttrMap
      @@@PerlDef:
        my $el;
        __CODE{createElementForTest}__;
        my $doc = $el-><AG::Node.ownerDocument>;
        my $et = $el-><AG::Node.attributes>;

        $test->id ('length.0');
        $test->assert_num_equals
                 (actual_value => $et-><AG::NamedNodeMap.length>,
                  expected_value => 0);

        $test->id ('length.1');
        my $et1 = $doc-><M::Document.createAttribute>
                          ('et1');
        $el-><M::Element.setAttributeNode> ($et1);
        $test->assert_num_equals
                 (actual_value => $et-><AG::NamedNodeMap.length>,
                  expected_value => 1);

        $test->id ('length.1');
        my $et2 = $doc-><M::Document.createAttribute>
                          ('et2');
        $el-><M::Element.setAttributeNode> ($et2);
        $test->assert_num_equals
                 (actual_value => $et-><AG::NamedNodeMap.length>,
                  expected_value => 2);
    @@XDTest:
      @@@QName: ETMap.length.test
      @@@ForCheck: t|ForETMap
      @@@PerlDef:
        my $dtd;
        __CODE{d|newDoctypeForTest}__;
        my $doc = $dtd-><AG::Node.ownerDocument>;
        my $et = $dtd-><AG::d|DocumentTypeDefinition.elementTypes>;

        $test->id ('length.0');
        $test->assert_num_equals
                 (actual_value => $et-><AG::NamedNodeMap.length>,
                  expected_value => 0);

        $test->id ('length.1');
        my $et1 = $doc-><M::d|DocumentXDoctype.createElementTypeDefinition>
                          ('et1');
        $dtd-><M::d|DocumentTypeDefinition.setElementTypeDefinitionNode> ($et1);
        $test->assert_num_equals
                 (actual_value => $et-><AG::NamedNodeMap.length>,
                  expected_value => 1);

        $test->id ('length.1');
        my $et2 = $doc-><M::d|DocumentXDoctype.createElementTypeDefinition>
                          ('et2');
        $dtd-><M::d|DocumentTypeDefinition.setElementTypeDefinitionNode> ($et2);
        $test->assert_num_equals
                 (actual_value => $et-><AG::NamedNodeMap.length>,
                  expected_value => 2);
    @@XDTest:
      @@@QName: ATMap.length.test
      @@@ForCheck: t|ForATMap
      @@@PerlDef:
        my $dtd;
        __CODE{d|newDoctypeForTest}__;
        my $doc = $dtd-><AG::Node.ownerDocument>;
        my $etd = $doc-><M::d|DocumentXDoctype.createElementTypeDefinition>
                          ('et1');
        my $at = $etd-><AG::d|ElementTypeDefinition.attributeDefinitions>;

        $test->id ('length.0');
        $test->assert_num_equals
                 (actual_value => $at-><AG::NamedNodeMap.length>,
                  expected_value => 0);

        $test->id ('length.1');
        my $at1 = $doc-><M::d|DocumentXDoctype.createAttributeDefinition>
                          ('at1');
        $etd-><M::d|ElementTypeDefinition.setAttributeDefinitionNode> ($at1);
        $test->assert_num_equals
                 (actual_value => $at-><AG::NamedNodeMap.length>,
                  expected_value => 1);

        $test->id ('length.2');
        my $at2 = $doc-><M::d|DocumentXDoctype.createAttributeDefinition>
                          ('at2');
        $etd-><M::d|ElementTypeDefinition.setAttributeDefinitionNode> ($at2);
        $test->assert_num_equals
                 (actual_value => $at-><AG::NamedNodeMap.length>,
                  expected_value => 2);
    @@XDTest:
      @@@QName: EntityMap.length.test
      @@@ForCheck: t|ForEntityMap
      @@@PerlDef:
        my $dtd;
        __CODE{d|newDoctypeForTest}__;
        my $doc = $dtd-><AG::Node.ownerDocument>;
        my $et = $dtd-><AG::d|DocumentTypeDefinition.generalEntities>;

        $test->id ('length.0');
        $test->assert_num_equals
                 (actual_value => $et-><AG::NamedNodeMap.length>,
                  expected_value => 0);

        $test->id ('length.1');
        my $et1 = $doc-><M::d|DocumentXDoctype.createGeneralEntity>
                          ('et1');
        $dtd-><M::d|DocumentTypeDefinition.setGeneralEntityNode> ($et1);
        $test->assert_num_equals
                 (actual_value => $et-><AG::NamedNodeMap.length>,
                  expected_value => 1);

        $test->id ('length.1');
        my $et2 = $doc-><M::d|DocumentXDoctype.createGeneralEntity>
                          ('et2');
        $dtd-><M::d|DocumentTypeDefinition.setGeneralEntityNode> ($et2);
        $test->assert_num_equals
                 (actual_value => $et-><AG::NamedNodeMap.length>,
                  expected_value => 2);

  @IntMethod:
    @@Perlop: STORESIZE
    @@Param:
      @@@Name: count
      @@@Type: idl|unsignedLong||ManakaiDOM|all
    @@Return:
      @@@dx:raises:
        @@@@@: c|NOMOD_NAMEDNODEMAP_ERR
        @@@@enDesc:
          If the map is read-only.
      @@@PerlDef:
        __DEEP{
          my $length = $self-><AG::NamedNodeMap.length>;
          if ($length > $count) {
            for (my $i = $length - 1; $i >= $count; $i--) {
              my $item = $self-><M::NamedNodeMap.item> ($i);
              $self-><M::NamedNodeMap.removeNamedItem>
                       ($item-><AG::Node.nodeName>);
            }
          }
        }__;

  @IntMethod:
    @@Perlop: EXISTS
    @@enDesc:
      <Perl::EXISTS> for tied hash.
    @@Param:
      @@@Name: key
      @@@Type: DOMString
    @@Return:
      @@@Type: idl|boolean||ManakaiDOM|all
      @@@PerlDef:
        @@@@ForCheck: !t|ForETMap !t|ForATMap !t|ForEntityMap
        @@@@@:
          __DEEP{
            $r = defined ($self-><M::NamedNodeMap.getNamedItem> ($key));
          }__;
      @@@PerlDef:
        @@@@ForCheck: t|ForETMap
        @@@@@:
          $r = exists (($$$self)->{<H::mn:node>}->{<H::d|elementTypes>}->{$key});
      @@@PerlDef:
        @@@@ForCheck: t|ForATMap
        @@@@@:
          $r = exists (($$$self)->{<H::mn:node>}
                                ->{<H::d|attributeDefinitions>}->{$key});
      @@@PerlDef:
        @@@@ForCheck: t|ForEntityMap
        @@@@@:
          $r = exists (($$$self)->{<H::mn:node>}
                                ->{<H::d|generalEntities>}->{$key});

  @IntMethod:
    @@Perlop: FIRSTKEY
    @@enDesc:
      <Perl::FIRSTKEY> for tied hash.
    @@Return:
      @@@Type: DOMString
      @@@PerlDef:
        @@@@ForCheck: t|ForAttrMap
        @@@@@:
          __DEEP{
            my $node = $self-><M::NamedNodeMap.item> (0);
            $r = $node ? $node-><AG::Node.nodeName> : null;
            ($$$self)->{<H::mn:node>}->{<H::t|hashPosition>} = 1;
          }__;
      @@@PerlDef:
        @@@@ForCheck: t|ForETMap
        @@@@@:
          my $a = keys %{($$$self)->{<H::mn:node>}->{<H::d|elementTypes>}};
            # reset
          $r = each %{($$$self)->{<H::mn:node>}->{<H::d|elementTypes>}};
      @@@PerlDef:
        @@@@ForCheck: t|ForATMap
        @@@@@:
          my $a = keys %{($$$self)->{<H::mn:node>}
                              ->{<H::d|attributeDefinitions>}}; # reset
          $r = each %{($$$self)->{<H::mn:node>}->{<H::d|attributeDefinitions>}};
      @@@PerlDef:
        @@@@ForCheck: t|ForEntityMap
        @@@@@:
          my $a = keys %{($$$self)->{<H::mn:node>}->{<H::d|generalEntities>}};
            # reset
          $r = each %{($$$self)->{<H::mn:node>}->{<H::d|generalEntities>}};

  @IntMethod:
    @@Perlop: NEXTKEY
    @@enDesc:
      <Perl::NEXTKEY> for tied hash.
    @@Param:
      @@@Name: lastkey
      @@@Type: DOMString
    @@Return:
      @@@Type: DOMString
      @@@PerlDef:
        @@@@ForCheck: t|ForAttrMap
        @@@@@:
          __DEEP{
            my $i = ($$$self)->{<H::mn:node>}->{<H::t|hashPosition>}++;
            my $node = $self-><M::NamedNodeMap.item> ($i);
            $r = $node ? $node-><AG::Node.nodeName> : null;
          }__;
      @@@PerlDef:
        @@@@ForCheck: t|ForETMap
        @@@@@:
          $r = each %{($$$self)->{<H::mn:node>}->{<H::d|elementTypes>}};
      @@@PerlDef:
        @@@@ForCheck: t|ForATMap
        @@@@@:
          $r = each %{($$$self)->{<H::mn:node>}->{<H::d|attributeDefinitions>}};
      @@@PerlDef:
        @@@@ForCheck: t|ForEntityMap
        @@@@@:
          $r = each %{($$$self)->{<H::mn:node>}->{<H::d|generalEntities>}};

  @IntMethod:
    @@ForCheck: !t|ForAttrMap
    @@Perlop: SCALAR
    @@enDesc:
      <Perl::SCALAR> for tied hash.
    @@Return:
      @@@Type: DOMString
      @@@PerlDef:
        @@@@ForCheck: t|ForETMap
        @@@@@:
          $r = scalar %{($$$self)->{<H::mn:node>}->{<H::d|elementTypes>}};
      @@@PerlDef:
        @@@@ForCheck: t|ForATMap
        @@@@@:
          $r = scalar %{($$$self)->{<H::mn:node>}
                                 ->{<H::d|attributeDefinitions>}};
      @@@PerlDef:
        @@@@ForCheck: t|ForEntityMap
        @@@@@:
          $r = scalar %{($$$self)->{<H::mn:node>}->{<H::d|generalEntities>}};

  @L2Method:
    @@Name: getNamedItemNS
    @@enDesc:
      Retrieves a node specified by local name and namespace URI.
    @@NoNSVersion: .getNamedItem
    @@XML2Feature:
    @@Param:
      @@@Name: namespaceURI
      @@@Type: DOMString
      @@@dis:actualType: ManakaiDOM|ManakaiDOMNamespaceURI
      @@@enDesc:
        The namespace URI of the node to retrieve.
    @@Param:
      @@@Name: localName
      @@@Type: DOMString
      @@@enDesc:
        The local name of the node to retrieve.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The <IF::Node> with the specified <P::localName> and
        <P::namespaceURI>.
      @@@nullCase:
        @@@@enDesc:
          If the pair of <P::localName> and <P::namespaceURI>
          does not identify any node in the map.
        @@@@enDesc:
          @@@@@ddid:nons
          @@@@@ForCheck: !t|ForAttrMap ManakaiDOM|ManakaiDOM
          @@@@@@:
            If it is a <IF::NamedNodeMap> containing element type definitions,
            attribute definitions, entities, or notations attached to
            <IF::d|DocumentTypeDefinition> or <IF::d|ElementTypeDefinition>
            nodes.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_IMPL_NOSUPPORT_XMLNS
        @@@@enDesc:
          If the implementation does not support the <Feature::XML> feature
          and the language exposed through the <IF::Document> does
          not support XML namespaces.
      @@@PerlDef:
        @@@@ForCheck: t|ForAttrMap
        @@@@@:
          __DEEP{
            $r = ($$$self)-><M::Element.getAttributeNodeNS>
                              ($namespaceURI, $localName);
          }__;
      @@@PerlDef:
        @@@@ForCheck: !t|ForAttrMap
        @@@@@: \

    @@L2Test:
      @@@QName: AttrMap.getNamedItemNS.test
      @@@ForCheck: t|ForAttrMap
      @@@PerlDef:
        my $el;
        __CODE{createElementForTest:: $el => $el}__;
        my $as = $el-><AG::Node.attributes>;

        my $uri = 'http://www.example/';
        my $ln = 'el1';
        my $qn = 'p:el1';
        my $value = 'value1';

        $test->id ('get.no');
        $test->assert_null ($as-><M::NamedNodeMap.getNamedItemNS> ($uri, $ln));
   
        $test->id ('set.text');
        $el-><M::Element.setAttributeNS> ($uri, $qn => $value);

        $test->id ('get.item');
        my $item0 = $as-><M::NamedNodeMap.getNamedItemNS> ($uri, $ln);
        $test->assert_isa ($item0, <IFName::Attr>);
        $test->assert_equals ($item0-><AG::Attr.ownerElement>, $el);
        $test->assert_equals ($item0-><AG::Attr.value>, $value);

  @L2Method:
    @@Name: setNamedItemNS
    @@enDesc:
      Adds a node using its <A::Node.namespaceURI> and <A::Node.localName>.
      If a node with that namespace URI and that local name is already
      present in the map, it is replaced by the new one.  Replacing a
      node by itself has no effect.
    @@enImplNote:
      @@@ddid: repbyitself
      @@@@:
        <QUOTE::Replacing a node by itself has no effect> clause
        is clarified by DOM Level 2 errata.
    @@NoNSVersion: .setNamedItem
    @@XML2Feature:
    @@Param:
      @@@Name: arg
      @@@Type: Node
      @@@enDesc:
        A node to store to the map.
      @@@enImplNote:
        The node will later be accessible using the value of 
        its <A::Node.namespaceURI> and <A::Node.localName> attributes.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        If the new <IF::Node> replaces an existing node, the replaced
        <IF::Node>.
      @@@nullCase:
        @@@@enDesc:
          If no replacement is occurred.
      @@@dx:raises:
        @@@@@: c|DIFFERENT_DOCUMENT_ERR
        @@@@enDesc:
          If <P::arg> was created from a different document than
          the one that created the map.
      @@@dx:raises:
        @@@@@: c|NOMOD_NAMEDNODEMAP_ERR
        @@@@enDesc:
          If the map is read-only.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the node to which the map is attached is read-only.
        @@@@For: ManakaiDOM|ManakaiDOM
      @@@dx:raises:
        @@@@@: c|INUSE_ATTRIBUTE_ERR
        @@@@enDesc:
          If <P::arg> is an <IF::Attr> that is already an attribute
          of another <IF::Element>.
        @@@@ForCheck: !t|ForETMap !t|ForATMap
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_BAD_TYPE
        @@@@enDesc:
          If an attempt is made to add a node that is unable to
          belong to the map.
        @@@@enImplNote:
          Added by DOM Level 2 errata.
        @@@@For: ManakaiDOM|DOM2
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_IMPL_NOSUPPORT_XMLNS
        @@@@enDesc:
          If the implementation does not support the <Feature::XML> feature
          and the language exposed through the <IF::Document> does
          not support XML namespaces.
      @@@dx:raises:
        @@@@ForCheck: !t|ForAttrMap ManakaiDOM|ManakaiDOM
        @@@@@: c|NO_NS_NAMEDNODEMAP_ERR
        @@@@enDesc:
          If it is a <IF::NamedNodeMap> containing element type definitions,
          attribute definitions, entities, or notations attached to
          <IF::d|DocumentTypeDefinition> or <IF::d|ElementTypeDefinition>
          nodes.  They does not support XML namespaces.
      @@@c:reports:
        @@@@@: t|replace-by-itself
        @@@@enDesc:
          If the <P::arg> node is same as the current node in the map.
          The method has no effect in this case.
        @@@@enImplNote:
          This case is clarified by DOM Level 2 errata.
        @@@@For: ManakaiDOM|ManakaiDOM
      @@@PerlDef:
        @@@@ForCheck: t|ForAttrMap
        @@@@@:
          __DEEP{
            $r = ($$$self)-><M::Element.setAttributeNodeNS> ($arg);
          }__;
      @@@disDef:
        @@@@ForCheck: !t|ForAttrMap ManakaiDOM|DOMXMLFeature
        @@@@DOMMain:raiseException: c|NO_NS_NAMEDNODEMAP_ERR
      @@@disDef:
        @@@@ForCheck: !t|ForAttrMap !ManakaiDOM|DOMXMLFeature
        @@@@DOMMain:raiseException: MDOMX|MDOM_IMPL_NOSUPPORT_XMLNS

    @@L2Test:
      @@@QName: AttrMap.setNamedItemNS.test
      @@@ForCheck: t|ForAttrMap
      @@@PerlDef:
        my $el;
        __CODE{createElementForTest:: $el => $el}__;
        my $as = $el-><AG::Node.attributes>;
        my $doc = $el-><AG::Node.ownerDocument>;

        my $uri = 'http://www.example/';
        my $ln = 'el1';
        my $qn = 'p:el1';
        my $value = 'value1';

        $test->id ('get.no');
        $test->assert_null ($as-><M::NamedNodeMap.getNamedItemNS> ($uri, $ln));

        $test->id ('set.item');
        my $item0 = $doc-><M::Document.createAttributeNS> ($uri, $qn);
        $item0-><AS::Attr.value> ($value);
        my $item2 = $as-><M::NamedNodeMap.setNamedItemNS> ($item0);
        $test->assert_null ($item2);
 
        my $item3 = $as-><M::NamedNodeMap.getNamedItemNS> ($uri, $ln);
        $test->assert_equals ($item3, $item0);

        $test->id ('set.item.4');
        my $item4 = $doc-><M::Document.createAttributeNS> ($uri, $qn);
        my $item5 = $as-><M::NamedNodeMap.setNamedItemNS> ($item4);
        $test->assert_equals ($item5, $item0);
        
        my $item6 = $as-><M::NamedNodeMap.getNamedItemNS> ($uri, $ln);
        $test->assert_equals ($item6, $item4);

     @@L3Test:
       @@@QName: NamedNodeMap.Attr.setNamedItemNS.replace-by-itself.Test
       @@@ForCheck: t|ForAttrMap
       @@@PerlDef:
           my $doc;
           __CODE{createDocumentForTest:: $doc => $doc}__;

           my $eh_called = false;

           my $del = $doc-><AG::Document.documentElement>;
           $del-><M::Element.setAttributeNS> (null, 'attr' => 'value');

           my $attr = $del-><M::Element.getAttributeNodeNS> (null, 'attr');

           my $cfg = $doc-><AG::Document.domConfig>;
           $cfg-><M::c|DOMConfiguration.setParameter> ('error-handler' => sub {
             my (undef, $err) = @_;
             $eh_called = true;
             $test->assert_equals ($err-><AG::c|DOMError.severity>,
                                   <C::c|DOMError.SEVERITY_WARNING>);
             $test->assert_equals ($err-><AG::c|DOMError.type>,
                                   <Q::t|replace-by-itself>);
             $test->assert_equals ($err-><AG::c|DOMError.relatedData>, $attr);
             $test->assert_null ($err-><AG::c|DOMError.relatedException>);
             $test->assert_isa ($err-><AG::c|DOMError.location>,
                                <IFName::c|DOMLocator>);
             $test->assert_not_null ($err-><AG::c|DOMError.message>);
           });

           $test->assert_false ($eh_called);
           $del-><AG::Node.attributes>
               -><M::NamedNodeMap.setNamedItemNS> ($attr);
           $test->assert_true ($eh_called);

           $test->assert_equals ($del-><M::Element.getAttributeNodeNS>
                                   (null, 'attr'), $attr);

           $attr = null;

  @L2Method:
    @@Name: removeNamedItemNS
    @@enDesc:
      Removes a node specified by local name and namespace URI.
    @@NoNSVersion: .removeNamedItem
    @@enDesc:
      @@@ddid: attr
      @@@ForCheck: !t|ForETMap !t|ForATMap !t|ForEntityMap
      @@@@:
        If the removed attribute is known to have a default value,
        an attribute immediately appears containing the default value
        as well as the corresponding namespace URI, local name, 
        and prefix when applicable.
    @@XML2Feature:
    @@Param:
      @@@Name: namespaceURI
      @@@Type: DOMString
      @@@dis:actualType: ManakaiDOM|ManakaiDOMNamespaceURI
      @@@enDesc:
        The namespace URI of the node to remove.
    @@Param:
      @@@Name: localName
      @@@Type: DOMString
      @@@enDesc:
        The local name of the node to remove.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node removed from the map.
      @@@dx:raises:
        @@@@@: c|NO_NAMED_NODE_NS_ERR
        @@@@enDesc:
          If there is no node with the specified <P::namespaceURI>
          and <P::localName> in the map.

          If it is a <IF::NamedNodeMap> containing element type definitions,
          attribute definitions, entities, or notations attached to
          <IF::d|DocumentTypeDefinition> or <IF::d|ElementTypeDefinition>
          nodes.  They does not support XML namespaces.
      @@@dx:raises:
        @@@@@: c|NOMOD_NAMEDNODEMAP_ERR
        @@@@enDesc:
          If the map is read-only.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_IMPL_NOSUPPORT_XMLNS
        @@@@enDesc:
          If the implementation does not support the <Feature::XML> feature
          and the language exposed through the <IF::Document> does
          not support XML namespaces.
      @@@PerlDef:
        @@@@ForCheck: t|ForAttrMap
        @@@@@:
          my $el = $$$self;
          __DEEP{ 
            $r = $el-><M::Element.getAttributeNodeNS>
                        ($namespaceURI, $localName);
          }__;
          unless ($r) {
            __EXCEPTION{c|NO_NAMED_NODE_NS_ERR::
              infoset|namespaceName => {$namespaceURI},
              c|name => {$localName},
              infoset|localName => {$localName},
              MDOMX|param-name => 'name',
            }__;
          }
          __DEEP{
            $r = $el-><M::Element.removeAttributeNode> ($r);
          }__;
      @@@disDef:
        @@@@ForCheck: !t|ForAttrMap ManakaiDOM|DOMXMLFeature
        @@@@DOMMain:raiseException: c|NO_NAMED_NODE_NS_ERR
      @@@disDef:
        @@@@ForCheck: !t|ForAttrMap !ManakaiDOM|DOMXMLFeature
        @@@@DOMMain:raiseException: MDOMX|MDOM_IMPL_NOSUPPORT_XMLNS

  @IntMethod:
    @@Perlop: ==
    @@enDesc:
      Returns whether two <IF::NamedNodeMap>s are equals.
   
      Two <IF::NamedNodeMap>s are equal if they have the same
      <A::NamedNodeMap.length> and for each node that exists in
      one map there is a node that exists in the other map 
      and is equal, although not necessarily at the same index.
    @@enImplNote:
      See also <M::Node.isEqualNode>.
    @@Param:
      @@@Name:arg
      @@@Type:NamedNodeMap
      @@@Description:
        @@@@lang:en
        @@@@@:
          The node list to compare equality with.
    @@Return:
      @@@Type:DOMMain|boolean||ManakaiDOM|all
      @@@PerlDef:
        @@@@@:
          __DEEP{
            my $length1 = $self-><AG::NamedNodeMap.length>;
            my $length2 = $arg-><AG::NamedNodeMap.length>;
            if ($length1 == $length2) {
              CHK: {
                for my $i (0..$length1-1) {
                  my $node1 = $self-><M::NamedNodeMap.item> ($i);
                  my $node2 = $arg-><M::NamedNodeMap.item> ($i);
                  unless ($node1 == $node2) {
                    last CHK;
                  }
                }
                $r = true;
              } # CHK
            }
          }__;
        @@@@enImplNote:
          In manakai, nodes in namespace unaware <IF::NamedNodeMap> are
          ordered by their <A::Node.nodeName>.
 
        @@@@enImplNote:
          {TODO::
            Add test for elementTypes and attributeDefinitions
            (they requires == equality for element type definition
             and attribute definition nodes being defined)
          }

  @IntMethod:
    @@ForCheck: ManakaiDOM|ManakaiDOM3
    @@Operator: ManakaiDOM|MUErrorHandler
    @@enDesc:
      When a <IF::ecore|ErrorInterface||ManakaiDOM|Perl> is <Perl::report>ed
      with an <Perl::-object> of <IF::NamedNodeMap> that represents
      a set of attributes, then this method is invoked.
      
      The method calls the <cfg::error-handler> if the error is of 
      <IF::c|DOMError>.  Otherwise, including the cases of <IF::c|DOMException>s,
      the error is rethrown so that appropriate <Perl::catch> clause
      can catch the error.
    @@enImplNote:
      For implementations which does not have the
      <IF::c|DOMError||ManakaiDOM|ManakaiDOM3> interface, the method
      is defined in the <Class::ManakaiDOM|ManakaiDOMObject> class
      and it is not overridden here.
    @@Param:
      @@@Name: err
      @@@Type: ecore|ErrorInterface||ManakaiDOM|Perl
      @@@enDesc:
        The reported error object.
    @@Return:
      @@@Type: DISPerl|Any
      @@@enDesc:
        If the <P::err> is a <IF::c|DOMError>, then the return value
        of the error handler.

           {NOTE:: If the error is thrown, the method never returns.
           }
      @@@nullCase:
        @@@@enDesc:
          No error handler.
      @@@PerlDef:
          __DEEP{
            ($$$self)->___report_error ($err);
          }__;

  @IntMethod:
    @@Perlop: TIEARRAY
    @@ManakaiDOM:isStatic:1
    @@Param:
      @@@Name: map
      @@@Type: NamedNodeMap
    @@Return:
      @@@Type: NamedNodeMap
      @@@PerlDef:
        $r = bless \\($$$map), $self;

  @IntMethod:
    @@Perlop: TIEHASH
    @@ManakaiDOM:isStatic:1
    @@Param:
      @@@Name: map
      @@@Type: NamedNodeMap
    @@Return:
      @@@Type: NamedNodeMap
      @@@PerlDef: $r = $map;

  @CODE:
    @@ForCheck: t|ForAttrMap ManakaiDOM|ManakaiDOMLatest
    @@QName: getAttrMap
    @@enDesc:
      Creates an attribute node map from an element node.
    @@PerlDef:
      $map = bless \\($node), <ClassName::t|ManakaiDOMAttrMap>;
      $node->{<H::mn:node>}->{<H::t|hashPosition>} ||= -1;

  @CODE:
    @@ForCheck: t|ForETMap ManakaiDOM|ManakaiDOMLatest
    @@QName: getElementTypeDefNodeMap
    @@enDesc:
      Creates an element type definition node map from a document
      type definition node.
    @@PerlDef:
      $map = bless \\($node), <ClassName::t|ManakaiDOMElementTypeDefMap>;

  @CODE:
    @@ForCheck: t|ForATMap ManakaiDOM|ManakaiDOMLatest
    @@QName: getAttrDefNodeMap
    @@enDesc:
      Creates an attribute definition node map from a document
      type definition node.
    @@PerlDef:
      $map = bless \\($node), <ClassName::t|ManakaiDOMAttrDefMap>;

  @CODE:
    @@ForCheck: t|ForEntityMap ManakaiDOM|ManakaiDOMLatest
    @@QName: getEntityNodeMap
    @@enDesc:
      Creates an entity node map from a document
      type definition node.
    @@PerlDef:
      $map = bless \\($node), <ClassName::t|ManakaiDOMEntityMap>;
##NamedNodeMap

PropDef:
  @QName: t|hashPosition
  @c:nodeProp: hpos
  @enDesc:
    Index for <Perl::each>.

ResourceDef:
  @rdf:type:
    @@@: dis|MultipleResource
    @@ForCheck: !ManakaiDOM|ForIF !ManakaiDOM|ForClass
  @ForCheck: ManakaiDOM|ManakaiDOM

  @enDesc:
    <IF::NamedNodeMap> implementation for tied array.

  @rdf:type:
    @@@: DISLang|Class
    @@ForCheck: ManakaiDOM|ForClass

  @resourceFor:
    @@@: t|ForAttrMap
    @@For: ManakaiDOM|ManakaiDOMLatest
  @QName:
    @@@: ManakaiDOMAttrMapArray
    @@ForCheck: t|ForAttrMap
  @ISA:
    @@@: ManakaiDOMAttrMap
    @@ForCheck: t|ForAttrMap

  @resourceFor:
    @@@: t|ForETMap
    @@For: ManakaiDOM|ManakaiDOMLatest
  @QName:
    @@@: ManakaiDOMElementTypeDefMapArray
    @@ForCheck: t|ForETMap
  @ISA:
    @@@: ManakaiDOMElementTypeDefMap
    @@ForCheck: t|ForETMap

  @resourceFor:
    @@@: t|ForATMap
    @@For: ManakaiDOM|ManakaiDOMLatest
  @QName:
    @@@: ManakaiDOMAttrDefMapArray
    @@ForCheck: t|ForATMap
  @ISA:
    @@@: ManakaiDOMAttrDefMap
    @@ForCheck: t|ForATMap

  @resourceFor:
    @@@: t|ForEntityMap
    @@For: ManakaiDOM|ManakaiDOMLatest
  @QName:
    @@@: ManakaiDOMEntityMapArray
    @@ForCheck: t|ForEntityMap
  @ISA:
    @@@: ManakaiDOMEntityMap
    @@ForCheck: t|ForEntityMap

  @AppISA:
    Tie::Array

  @IntMethod:
    @@Perlop: FETCH
    @@Param:
      @@@Name: index
      @@@Type: idl|unsignedLong||ManakaiDOM|all
    @@Return:
      @@@Type: Node
      @@@nullCase:
      @@@PerlDef:
        __DEEP{
          $r = $self-><M::NamedNodeMap.item> ($index);
        }__;

  @IntMethod:
    @@Perlop: EXISTS
    @@enDesc:
      <Perl::EXISTS> for tied array.
    @@Param:
      @@@Name: index
      @@@Type: idl|unsignedLong||ManakaiDOM|all
    @@Return:
      @@@Type: idl|boolean||ManakaiDOM|all
      @@@PerlDef:
        __DEEP{
          my $length = $self-><AG::NamedNodeMap.length>;
          $r = ($index < $length);
        }__;
  
  @enImplNote:
    @@@ddid: perl.store
    @@@@:
      <Perl::STORE> is not implemented.

  @IntMethod:
    @@Perlop: DELETE
    @@enDesc:
      Removes a node specified by index.
    @@enDesc:
      @@@ddid: attr
      @@@ForCheck: t|ForAttrMap
      @@@enDesc:
        If the removed attribute is known to have a default value,
        an attribute immediately appears containing the default
        value as well as the corresponding namespace URI, local name,
        and prefix when applicable.
    @@Param:
      @@@Name: index
      @@@Type: idl|unsignedLong||ManakaiDOM|all
      @@@enDesc:
        The ordinal index of the node to remove.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node removed from the map.
      @@@enImplNote:
        Is this return value OK?
      @@@nullCase:
        @@@@enDesc:
          If there is no node named as <P::name> in the map.
      @@@dx:raises:
        @@@@@: c|NOMOD_NAMEDNODEMAP_ERR
        @@@@enDesc:
          If the map is read-only.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the node to which the map is attached is read-only.
      @@@PerlDef:
        __DEEP{
          my $item = $self-><M::NamedNodeMap.item> ($index);
          if ($item) {
            $r = $self-><M::NamedNodeMap.removeNamedItem>
                            ($item-><AG::Node.nodeName>);
          }
        }__;
##NamedNodeMapArray

ElementTypeBinding:
  @Name: CODE
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISPerl|BlockCode
    @@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM

ResourceDef:
  @QName: createDocumentForTest
  @rdf:type: DISPerl|BlockCode
  @For: ManakaiDOM|ManakaiDOM
  @PerlDefC:
    my $impl = <Class::c|ManakaiDOMImplementation>->_new;
    $doc = $impl-><M::c|DOMImplementation.createDocument>
                              ('http://www.example/', 'ex');

ResourceDef:
  @QName: createEmptyDocumentForTest
  @rdf:type: DISPerl|BlockCode
  @For: ManakaiDOM|ManakaiDOM
  @PerlDefC:
    my $impl = <Class::c|ManakaiDOMImplementation>->_new;
    $doc = $impl-><M::c|DOMImplementation.createDocument>;

ResourceDef:
  @QName: createElementForTest
  @rdf:type: DISPerl|BlockCode
  @For: ManakaiDOM|ManakaiDOM
  @PerlDefC:
    my $doc;
    __CODE{createDocumentForTest:: $doc => $doc}__;
    $el = $doc-><M::Document.createElementNS>
                  ('http://www.example.net/', 'ex:element');

## -- Specialized |Node| Interfaces

ResourceDef:
  @QName: c|CharacterData
  @AliasFor: CharacterData
  @For: ManakaiDOM|DOM

NodeTypeDef:
  @IFQName: CharacterData
  @ClsQName: ManakaiDOMCharacterData

  @enDesc:
    The <IF::CharacterData> interface extends the <IF::Node>
    interface with a set of attributes and methods for
    accessing character data in the DOM.  No DOM objects correspond 
    directly to the <IF::CharacterData> interface -- the
    <IF::Text> interface and the <IF::Comment> interface
    inherits this interface.

    {ps:: <doc:caption::Positions in character data>

    All <CODE::offset>s in this interface start from <CODE::0>.  Since strings in
    the DOM are represented in UTF-16, indexing
    on <IF::CharacterData> is done in 16-bit units, i.e. characters
    allocated in the range <CODE::U+10000> to <CODE::U+10FFFF>
    (inclusive) are counted as two units.
    }

    {NOTE:: DOM implementations may not put arbitary limits on 
            the amount of the data that may be stored in a 
            <IF::CharacterData> node.  This might make a node's
            data cannot fit into a single <TYPE::DOMMain:DOMString>.
            See also <X::DOMException.DOMSTRING_SIZE_ERR>.
    }

  @Attr:
    @@Name: data
    @@enDesc:
      The character data of the node.

      If the node is a <IF::DOMXML|CDATASection>, it is the
      content of the <XML::CDATA> section.  Since DOM implementation
      does no lexical check on the content of the <XML::CDATA>
      section, <A::CharacterData.data> might include the character
      sequence equals to <SGML::MSE>, i.e. <XML::]]<gt>> in XML.

     @@Get:
        @@@Type:  
          DOMMain:DOMString
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: DOMSTRING_SIZE_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The attribute would return more characters than 
              fit in a "DOMString" variable on the implementation 
              platform.
        @@@disDef:
          @@@@GetProp:
            infoset:content
     @@Set:
        @@@Type:  
          DOMMain:DOMString
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The node is read-only.
        @@@disDef:
          @@@@SetProp:
            @@@@@@:
              infoset:content
            @@@@@CheckReadOnly:1
  @Attr:
     @@Name:  length
     @@Description:
       @@@lang:en
       @@@@: 
         The number of 16-bit units of the "data".
    @@Offset16Note:
     @@Get:
        @@@Type:  
          DOMMain:unsigned-long||ManakaiDOM|all
        @@@Description:
          @@@@lang:en
          @@@@@: The number of 16-bit units of the "data".
        @@@PerlDef:
          $r = CORE::length $self->{<H::mn:node>}->{<H::infoset:content>};
          $r++ while $self->{<H::mn:node>}->{<H::infoset:content>}
                       =~ /[\x{10000}-\x{10FFFF}]/g;
  @Method:
     @@Name:  substringData
     @@Description:
       @@@lang:en
       @@@@:
         Extract a range of data from the node.
    @@Offset16Note:
     @@Param:
        @@@Name:  offset
        @@@Type:  
          DOMMain:unsigned-long||ManakaiDOM|all
        @@@Description:
          @@@@lang:en
          @@@@@: Start offset of substring to extract.
     @@Param:
        @@@Name:  count
        @@@Type:  
          DOMMain:unsigned-long||ManakaiDOM|all
        @@@Description:
          @@@@lang:en
          @@@@@:
          The number of 16-bit units to extract.  If the sum of the
          parameters offset and count exceeds the length of the
          DOMString then all 16-bit units from offset to the end
          of the DOMString are returned.
    @@Return:
      @@@Type: 
        DOMMain:DOMString
      @@@Description:
        @@@@lang:en
        @@@@@: The specified substring.
      @@@Exception:
        @@@@Type: DOMException
        @@@@Name: INDEX_SIZE_ERR
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The specified "offset" is negative or greater than
            the number of 16-bit units in the "DOMString", or the specified
            "count" is negative.
      @@@Exception:
        @@@@Type: DOMException
        @@@@Name: DOMSTRING_SIZE_ERR
        @@@@Description:
          @@@@@lang:en
          @@@@@@: The specified range does not fit into a "DOMString".
      @@@Exception:
        @@@@Type: 
          ManakaiDOM:ManakaiDOMImplementationException
        @@@@Name: MDOM_INDEX_IN_SURROGATE_PAIR
        @@@@Description:
          @@@@@lang:en
          @@@@@@: An attempt is made to break surrogate pair.
      @@@PerlDef:
        __DEEP{
          my $offset32 = <ClassM::DOMMain:ManakaiDOMStringExtend.findOffset32>
                            ($offset);
          my $coffset32 = <ClassM::DOMMain:ManakaiDOMStringExtend.findOffset32>
                            ($offset + $count);
          $r = substr ($self->{<H::mn:node>}->{<H::infoset:content>},
                       $offset32, $coffset32 - $offset32);
        }__;
  @Method:
     @@Name:  appendData
     @@Description:
       @@@lang:en
       @@@@:
         Append the string to the end of the character data of the node.
     @@Param:
        @@@Name:  arg
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The string to append.
     @@Return:
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: This node is read-only.
        @@@PerlDef:
            my $node = $self->{<H::mn:node>};
            if ($node->{<H::DOMCore:read-only>}) {
              __EXCEPTION{
                MDOMX:NOMOD_THIS::
              }__;
            }
            $node->{<H::infoset:content>} .= $arg;
  @Method:
     @@Name:  insertData
     @@Description:
       @@@lang:en
       @@@@: Insert a string at the specified 16-bit unit offset. 
    @@Offset16Note:
    @@Param:
      @@@Name: offset
      @@@Type: 
        DOMMain:unsigned-long||ManakaiDOM|all
      @@@Description:
        @@@@lang:en
        @@@@@: The offset from which to insert.
    @@Param:
      @@@Name: arg
      @@@Type: 
        DOMMain:DOMString
      @@@Description:
        @@@@lang:en
        @@@@@: The DOMString to insert.
    @@Return:
      @@@Exception:
        @@@@Type: DOMException
        @@@@Name: INDEX_SIZE_ERR
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The specified "offset" is negative or greater than
            the number of 16-bit units in the DOMString.
      @@@Exception:
        @@@@Type: DOMException
        @@@@Name: NO_MODIFICATION_ALLOWED_ERR
        @@@@Description:
          @@@@@lang:en
          @@@@@@: This node is read-only.
      @@@Exception:
        @@@@Type: 
          ManakaiDOM:ManakaiDOMImplementationException
        @@@@Name: MDOM_INDEX_IN_SURROGATE_PAIR
        @@@@Description:
          @@@@@lang:en
          @@@@@@: An attempt is made to break surrogate pair.
      @@@PerlDef:
        if ($self->{<H::mn:node>}->{<H::DOMCore:read-only>}) {
          __EXCEPTION{
            MDOMX:NOMOD_THIS::
          }__;
        }
        __DEEP{
          my $offset32 = <ClassM::DOMMain:ManakaiDOMStringExtend.findOffset32>
                            ($offset);
          substr ($self->{<H::mn:node>}->{<H::infoset:content>},
                  $offset32, 0) = $arg;
        }__;
  @Method:
     @@Name:  deleteData
     @@Description:
        @@@lang:en
        @@@@: 
          Remove a range of 16-bit units from the node.
    @@Offset16Note:
    @@Param:
      @@@Name: offset
      @@@Type: 
        DOMMain:unsigned-long::ManakaiDOM:all
      @@@Description:
        @@@@lang:en
        @@@@@: The offset from which to start removing.
    @@Param:
      @@@Name: count
      @@@Type: 
        DOMMain:unsigned-long||ManakaiDOM|all
      @@@Description:
        @@@@lang:en
        @@@@@:
          The number of 16-bit units to delete.  If the sum of the
          parameters offset and count exceeds the length of the
          DOMString then all 16-bit units from offset to the end
          of the DOMString are deleted.
    @@Return:
      @@@Exception:
        @@@@Type: DOMException
        @@@@Name: INDEX_SIZE_ERR
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The specified "offset" is negative or greater than
            the number of 16-bit units in the DOMString, or the specified
            "count" is negative.
      @@@Exception:
        @@@@Type: DOMException
        @@@@Name: NO_MODIFICATION_ALLOWED_ERR
        @@@@Description:
          @@@@@lang:en
          @@@@@@: This node is read-only.
      @@@Exception:
        @@@@Type: 
          ManakaiDOM:ManakaiDOMImplementationException
        @@@@Name: MDOM_INDEX_IN_SURROGATE_PAIR
        @@@@Description:
          @@@@@lang:en
          @@@@@@: 
            An attempt is made to break surrogate pair.
      @@@PerlDef:
        if ($self->{<H::mn:node>}->{<H::DOMCore:read-only>}) {
          __EXCEPTION{
            MDOMX:NOMOD_THIS::
          }__;
        }
        __DEEP{
          my $offset32 = <ClassM::DOMMain:ManakaiDOMStringExtend.findOffset32>
                            ($offset);
          substr ($self->{<H::mn:node>}->{<H::infoset:content>}, $offset32, 0)
            = '';
        }__;
  @Method:
    @@Name:  replaceData
    @@Description:
      @@@lang:en
      @@@@:
        Replace the characters starting at the specified 16-bit unit 
        offset with the specified string.
    @@Offset16Note:
    @@Param:
      @@@Name: offset
      @@@Type: 
        DOMMain:unsigned-long||ManakaiDOM|all
      @@@Description:
        @@@@lang:en
        @@@@@: The offset from which to start replacing.
    @@Param:
      @@@Name: count
      @@@Type: 
        DOMMain:unsigned-long||ManakaiDOM|all
      @@@Description:
        @@@@lang:en
        @@@@@:
          The number of 16-bit units to replace.  If the sum of the
          parameters offset and count exceeds the length of the
          DOMString then all 16-bit units from offset to the end
          of the DOMString are replaced.
    @@Param:
      @@@Name: arg
      @@@Type: 
        DOMMain:DOMString
      @@@Description:
        @@@@lang:en
        @@@@@: The DOMString with which the range is replaced.
    @@Return:
      @@@Exception:
        @@@@Type: DOMException
        @@@@Name: INDEX_SIZE_ERR
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The specified "offset" is negative or greater than
            the number of 16-bit units in the DOMString, or the specified
            "count" is negative.
      @@@Exception:
        @@@@Type: DOMException
        @@@@Name: NO_MODIFICATION_ALLOWED_ERR
        @@@@Description:
          @@@@@lang:en
          @@@@@@: This node is read-only.
      @@@Exception:
        @@@@Type: 
          ManakaiDOM:ManakaiDOMImplementationException
        @@@@Name: MDOM_INDEX_IN_SURROGATE_PAIR
        @@@@Description:
          @@@@@lang:en
          @@@@@@: An attempt is made to break surrogate pair.
      @@@PerlDef:
        if ($self->{<H::mn:node>}->{<H::DOMCore:read-only>}) {
          __EXCEPTION{
            MDOMX:NOMOD_THIS::
          }__;
        }
        __DEEP{
          my $offset32 = <ClassM::DOMMain:ManakaiDOMStringExtend.findOffset32>
                            ($offset);
          my $coffset32 = <ClassM::DOMMain:ManakaiDOMStringExtend.findOffset32>
                            ($offset + $count);
          substr ($self->{<H::mn:node>}->{<H::infoset:content>},
                  $offset32, $coffset32 - $offset32) = $arg;
        }__;
  @ReAttr:
     @@Name:  nodeValue
     @@Description:
       @@@lang:en
       @@@@: The value of this node.
     @@Get:
        @@@Type:  
          DOMMain:DOMString
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: DOMSTRING_SIZE_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: 
              The node value, i.e. same as "data".
        @@@disDef:
          @@@@DISPerl:cloneCode: .data.get
     @@Set:
        @@@Type:  
          DOMMain:DOMString
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: 
              The node is read-only.
        @@@Description:
          @@@@lang:en
          @@@@@:
            New node value.
        @@@disDef:
          @@@@DISPerl:cloneCode: .data.set
    @@Level[list]:
      1
      2
      3
    @@SpecLevel:1
  @ReAttr:
     @@Name:  textContent
     @@Description:
       @@@lang:en
       @@@@: The text content of this node and its descendants.
     @@ImplNote:
        @@@lang:en
        @@@@:
          CharacterData->data == CharacterData->nodeValue == 
          CharacterData->textContent.
     @@Get:
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            The text content of this node, i.e. the "nodeValue".
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: DOMSTRING_SIZE_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The attribute would return more characters than 
              fit in a "DOMString" variable on the implementation 
              platform.
        @@@disDef:
          @@@@DISPerl:cloneCode: .data.get
     @@Set:
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            The new text content of the node.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: 
              The text content is set to the empty.  Note that the 
              DOM specification does not specify how to treat the "null".
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: This node is read-only.
        @@@disDef:
          @@@@DISPerl:cloneCode: .data.set
     @@Level[list]:
        3
     @@SpecLevel:3
     @@For:
       ManakaiDOM:DOM3

  @Attr:
    @@Name: childNodes
    @@ForCheck: ManakaiDOM|ForClass
    @@enDesc:
      A list of nodes that contains all children of the node.
    @@Get:
      @@@Type: c|NodeList
      @@@actualType: DOMCore|ManakaiDOMEmptyNodeList
      @@@enDesc:
        Since <IF::DOMCore|CharacterData> nodes cannot have any child nodes,
        the node list is always empty.
      @@@PerlDef:
        $r = <Class::DOMCore|ManakaiDOMEmptyNodeList>->new;
##CharacterData

ElementTypeBinding:
  @Name: Offset16Note
  @ElementType:
    dis:Description
  @ShadowContent:
    @@lang:en
    @@@:
      {NOTE::
        Since strings are hold as sequences of characters in Perl
        rather than as sequences of UTF-16 code units in DOM,
        use of this method would be a bad choice in the viewpoint
        of performance.  Usually applications should prefer normal
        string functions of Perl.
      }
    @@For: ManakaiDOM|ManakaiDOM
    @@ddid:Offset16Note

ResourceDef:
  @QName: c|Attr
  @AliasFor: Attr
  @For: ManakaiDOM|DOM

ResourceDef:
  @QName: c|ManakaiDOMAttr
  @AliasFor: ManakaiDOMAttr
  @For: !=ManakaiDOM|all ManakaiDOM|ManakaiDOM !=ManakaiDOM|ManakaiDOM

NodeTypeDef:
  @IFQName: Attr
  @ClsQName: ManakaiDOMAttr

  @DISLang:role: c|AttributeRole

  @enDesc:
    An <IF::Attr> object represents an attribute that can be attached
    on an <IF::Element> object.

      The DOM Core treats the attribute values as a plain string, even if 
      the schema language defines them as having tokenized types.
  @ImplNote:
    @@lang:en
    @@@:
      If the implementation knows about the schema in use when 
      the attribute value is changed, and it is of a different type 
      than "CDATA", it may normalize it at that time. [SVG DOM, DOM 3]
  @Attr:
     @@Name:  name
     @@Description:
       @@@lang:en
       @@@@: The name of this attribute.
     @@Get:
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The attribute name. 
        @@@InCase:
          @@@@Label: Qualified name
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              If the "localName" is different from "null".
        @@@PerlDef:
            my $node = $self->{<H::mn:node>};
            if (defined $node->{<H::infoset:localName>}) {
              $r = (defined $node->{<H::infoset:prefix>} ?
                   $node->{<H::infoset:prefix>} . ':' : '') . 
                   $node->{<H::infoset:localName>};
            } else {
              $r = $node->{<H::DOMCore:name>};
            }
        @@@ImplNote:
          @@@@lang:en
          @@@@@:
            "Element.tagName" is defined to return the uppercase name 
            if the document is an HTML document.  "Attr.name" is not 
            defined so.
  @Attr:
     @@Name:  specified
     @@Description:
       @@@lang:en
       @@@@: Whether this attribute is specified explicitly in the document.
     @@Get:
        @@@Type:  DOMMain|boolean||ManakaiDOM|all
        @@@InCase:
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              This attribute is explicitly given a value in the 
              instance document.
        @@@InCase:
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              This attribute is not explicitly given a value in the 
              instance document.
        @@@disDef:
          @@@@GetProp:
             infoset:specified
    @@ImplNote:
       @@@lang:en
       @@@@:
         This attribute is set to "true" if the DOM application 
         changed the value of this attribute node (even if it ends up 
         having the same value as the default value).
    @@ImplNote:
       @@@lang:en
       @@@@:
         The implementation may handle attributes with default 
         values from other schemas than DTD and XML Schema but 
         the DOM application should use "normalizeDocument" to 
         guarantee this information is up-to-date.
    @@ImplNote:
      @@@lang:en
      @@@@:
        Removing an attribute node may generate a new attribute 
        node with the default value and "specified" set to "false".
      \
        When "normalizeDocument" is invoked, non-"specified" 
        attribute nodes are recomputed according to the defaulu 
        attribute value.
    @@ImplNote:
      @@@lang:en
      @@@@: 
        The DOM Level 1 Specification (Second Edition) and the 
        DOM Level 2 Specification says that if the "ownerElement" 
        is "null", "specified" is always "true".  The DOM Level 3 
        Specification does not address this case.

        {ISSUE::
          May <M::Element.removeAttributeNS>, for example, left
          <A::Attr.specified> flag as is?
        }
    @@enImplNote:
      @@@ddid: mutation 
      @@@@:
        {TODO::
          If a node in subtree is modified, the <A::Attr.specified>
          flag must be turned <DOM::true>.  Manakai implements this
          behavior in some case, but not all, in particular
          node operation methods such as <M::Node.appendChild> does not.

          $another_node->append_child ($text_that_is_a_child_of_attr)
          must change $text_that_is_a_child_of_attr->parent_node->specified.

          Setting of any <QUOTE::reflected> attribute must change
          the specified value.
        }

  @Attr:
    @@Name: value
    @@enDesc:
      The value of the attribute.
    @@Type: DOMString
    @@Get:
      @@@enDesc:
        @@@@ForCheck: ManakaiDOM|ManakaiDOM
        @@@@@:
          In the manakai implementation, it is the concatenation of
          the <DFN::text content> of every child node.  For <IF::t|Text>
          children, the text content of a node is the <A::t|Node.textContent>
          attribute value.  For <IF::x|EntityReference>
          children, the text content of a node is the
          <A::t|Node.textContent> attribute value with
          any <CODE::U+0009>, <CODE::U+000A>, and
          <CODE::U+000D> replaced by <CODE::U+0020>.

          If the <InfoProp::attribute type> of the node
          (which might be accessible via <A::Attr.schemaTypeInfo>
           if the schema language of the document is XML DTD) has
          a valid value different from <CODE::no value>, <CODE::unknown>,
          and <CODE::CDATA>, then the value
          is further modified by discarding any leading
          and trailing <CODE::U+0020> characters and
          by replacing sequences of <CODE::U+0020> characters
          by a single <CODE::U+0020> character.
      @@@PerlDef:
         __DEEP{
            for my $child (@{$self-><AG::t|Node.childNodes>}) {
              if ($child-><AG::t|Node.nodeType> ==
                  <C::t|Node.ENTITY_REFERENCE_NODE>) {
                my $v = $child-><AG::t|Node.textContent>;
                $v =~ s/[\x09\x0A\x0D]/ /;
                $r .= $v;
              } else {
                $r .= $child-><AG::t|Node.textContent>;
              }
            } # childNodes
            my $vt = $self->{<H::mn:node>}->{<H::infoset:attributeType>};
            unless (not defined $vt or
                    $vt == <C::ATDef.NO_TYPE_ATTR> or
                    $vt == <C::ATDef.UNKNOWN_ATTR> or
                    $vt == <C::ATDef.CDATA_ATTR>) {
              $r =~ s/\A\x20+//;
              $r =~ s/\x20+\z//;
              $r =~ s/\x20+/ /g;
            }
        }__;
    @@Set:
      @@@enDesc:
        Creates a <IF::Text> node with the string.
      @@@enDesc:
        @@@@ddid: noval
        @@@@For: ManakaiDOM|ManakaiDOM
        @@@@@:
          The exist child nodes, if any, are replaced by the new
          <IF::Text> node.  If the new string is empty (i.e. its
          length is zero), then no node is created and the child
          node list is simply cleared.
      @@@enDesc:
        @@@@ddid: norm
        @@@@@:
          Some specialized implementations may do normalization automatically.
          In such case, the value on retrieval may differ from the value
          on setting.
        @@@@For: ManakaiDOM|DOM3
      @@@enImplNote:
        Currenly type information does not affect on setting.
        Should it do?
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the node is read-only.
        @@@@enImplNote:
          Added by DOM Level 1 (first edition) Errata and
          incorporated into DOM Level 1 Second Edition, Level 2 and later.
      @@@PerlDef:
        __CODE{c|setNodeTextContent::
               $node => $self, $given => $given}__;
    @@enImplNote:
      @@@ddid: value-attrs
      @@@@:
        <IF::Node.nodeValue> for <IF::Attr> and <IF::Attr.value> shares their
        definition.  <IF::Node.textContent> does <EM::not>.

        Manakai's <IF::Node.nodeValue> for <IF::ATDef> is also shares
        the definition with <IF::Attr.value>.

  @Attr:
     @@Name:  ownerElement
     @@Description:
       @@@lang:en
       @@@@:
         The element to which this attribute is attached.
     @@Get:
        @@@Type:  Element
        @@@Description:
          @@@@lang:en
          @@@@@: The "Element" node.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: This attribute is not in use.
        @@@disDef:
          @@@@GetPropNode:
            infoset:ownerElement
     @@Level[list]:  
        2
        3
     @@SpecLevel:2
     @@For:
       ManakaiDOM:DOM2

  @L3Attr:
    @@Name: schemaTypeInfo
    @@enDesc:
      The type information associated with the attribute.

      While the type information contained in the attribute is guarantee
      to be correct after loading the document or validation,
      it may not be reliable if the node was moved.
    @@Type: c|TypeInfo
    @@Get:
      @@@PerlDef:
        __CODE{c|createDTDTypeInfo::
          $result => $r,
          $type => {$self->{<H::mn:node>}->{<H::infoset:attributeType>}},
        }__;
    @@L3Test:
      @@@QName: Attr.schemaTypeInfo.no-schema.test
      @@@PerlDef:
        my $el;
        __CODE{createElementForTest:: $el => $el}__;
        $el-><AG::Node.ownerDocument>
           -><AG::Document.domConfig>
           -><M::c|DOMConfiguration.setParameter>
               ('schema-type' => q[http://dummy.example/]);
        $el-><M::Element.setAttributeNS> (null, 'a', 'b');
        my $attr = $el-><M::Element.getAttributeNodeNS> (null, 'a');

        my $sti = $attr-><AG::Attr.schemaTypeInfo>;
        $test->assert_isa ($sti, <IFName::c|TypeInfo>);
        $test->assert_null ($sti-><AG::c|TypeInfo.typeName>);
        $test->assert_null ($sti-><AG::c|TypeInfo.typeNamespace>);
    @@L3Test:
      @@@QName: Attr.schemaTypeInfo.dtd.test
      @@@PerlDef:
        my $el;
        __CODE{createElementForTest:: $el => $el}__;
        $el-><AG::Node.ownerDocument>
           -><AG::Document.domConfig>
           -><M::c|DOMConfiguration.setParameter>
               ('schema-type' => <Q::xml-dtd:>);
        $el-><M::Element.setAttributeNS> (null, 'a', 'b');
        my $attr = $el-><M::Element.getAttributeNodeNS> (null, 'a');

        my $sti = $attr-><AG::Attr.schemaTypeInfo>;
        $test->assert_isa ($sti, <IFName::c|TypeInfo>);
        $test->assert_null ($sti-><AG::c|TypeInfo.typeName>);
        $test->assert_null ($sti-><AG::c|TypeInfo.typeNamespace>);
    @@L3Test:
      @@@QName: Attr.schemaTypeInfo.dtd.cdata.test
      @@@PerlDef:
        my $el;
        __CODE{createElementForTest:: $el => $el}__;
        $el-><AG::Node.ownerDocument>
           -><AG::Document.domConfig>
           -><M::c|DOMConfiguration.setParameter>
               ('schema-type' => <Q::xml-dtd:>);
        $el-><M::Element.setAttributeNS> (null, 'a', 'b');
        my $attr = $el-><M::Element.getAttributeNodeNS> (null, 'a');
        $attr->{<H::mn:node>}->{<H::infoset:attributeType>}
          = <C::ATDef.CDATA_ATTR>;

        my $sti = $attr-><AG::Attr.schemaTypeInfo>;
        $test->assert_isa ($sti, <IFName::c|TypeInfo>);
        $test->assert_equals ($sti-><AG::c|TypeInfo.typeName>, 'CDATA');
        $test->assert_equals
                 ($sti-><AG::c|TypeInfo.typeNamespace>, <Q::xml-dtd:>);

  @CODE:
    @@QName: setAttrType
    @@enDesc:
      Sets <Q::infoset:attributeType> attribute.
    @@PerlDef:
      $attr->{<H::mn:node>}->{<H::infoset:attributeType>} = $type;

  #L3Attr:
  @Attr:
    @@Name: isId
    @@ManakaiDOM:isForInternal:
      @@@@: 1
      @@@For: ManakaiDOM|ManakaiDOM !ManakaiDOM|DOM3
     @@Description:
       @@@lang:en
       @@@@:
         Whether this attribute is known to be of type ID or not.
     @@ImplNote:
       @@@lang:en
       @@@@:
         The ways to determine whether an attribute node is known 
         to contain an identifier:
        \
         PSVI - If validation occurred using an XML Schema, the PSVI 
         contributions values are used to determine whether this 
         attribute is a Schema-determined ID attribute as the 
         XPointer specification defines, i.e. iif one of the following 
         is true:
        \
         1. The attribute information item has a [memeber type definition] or 
         [type definition] property whose value in turn has [name] eq "ID" 
         and [target namespace] eq "http://www.w3.org/2001/XMLSchema".
        \
         2. The attribute information item has a [base type definition] 
         property whose value in turn has [name] eq "ID"
         and [target namespace] eq "http://www.w3.org/2001/XMLSchema".
        \
         3. The attribute information item has a [base type definition] 
         property whose value has a [base type definition] property 
         whose value has ... whose value in turn has [name] eq "ID"
         and [target namespace] eq "http://www.w3.org/2001/XMLSchema".
        \
         4. The attribute information item has a [type definition name] 
         eq "ID" and a [type definition namespace] eq 
         "http://www.w3.org/2001/XMLSchema".
        \
         5. The attribute information item has a 
         [member type definition name] eq "ID" and a 
         [member type definition namespace] eq 
         "http://www.w3.org/2001/XMLSchema".
        \
         DTD - If validation occured using a DTD, the infoset 
         [type definition] value is used to determine whether 
         this attribute is a DTD-determined ID attribute as the 
         XPointer framework specification defines.  Iif the 
         attribute information item has a [type definition] property 
         eq "ID", it is a DTD-determined ID attribute.
        \
         User-determined - If the methods "setIdAttribute", 
         "setIdAttributeNS", "setIdAttributeNode" was used, 
         it is an user-determined ID attribute.
        \
         Externally-determined - Other mechanisms, including other 
         schema languages than DTD and XML Schema may provide 
         ways to determine whether it is a ID attribute.
     @@Get:
        @@@Type:  DOMMain|boolean||ManakaiDOM|all
        @@@InCase:
          @@@@Value:true
          @@@@Description:
            @@@@@lang:en
            @@@@@@: 
              This attribute is a ID attribute.
        @@@InCase:
          @@@@Value:false
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              This attribute is not a ID attribute.
      @@@PerlDef:
        @@@@@:
          if (defined $self->{<H::mn:node>}->{<H::infoset:attributeType>} and
              $self->{<H::mn:node>}->{<H::infoset:attributeType>}
                == <C::ATDef.ID_ATTR>) {
            $r = true;
          } elsif ($self->{<H::mn:node>}->{<H::c:userDeterminedId>}) {
            $r = true;
          }
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              TODO: Support non-user-determined ID attributes.
              Especially, application-determined ID such as html5:*/@id
              and xml:id should be supported.
  
  @ReAttr:
     @@Name:  localName
     @@Description:
       @@@lang:en
       @@@@: The local part of the qualified name of this "Attr" node.
     @@Get:
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            The local name of the attribute.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The node is created with a DOM Level 1 methods.
        @@@disDef:
          @@@@GetProp:
            infoset:localName
     @@Level[list]:  2
     @@SpecLevel:2
     @@For:
       ManakaiDOM:DOM2
  @ReMethod:
     @@Name:  lookupPrefix
     @@Description:
       @@@lang:en
       @@@@:
         Lookup the namespace prefix associated to the given namespace 
         URI, starting from this node.
       \
         The default namespace declarations are ignored by this method. 
         To lookup default namespace, use the <M::Node.isDefaultNamespace>
         method.
     @@Param:
        @@@Name:  namespaceURI
        @@@Type:
          DOMMain:DOMString
        @@@actualType:
          ManakaiDOM:ManakaiDOMNamespaceURI
        @@@Description:
          @@@@lang:en
          @@@@@: The namespace URI to look for.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Always <DOM::null> will be returned.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Always <DOM::null> will be returned.
     @@Return:
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            An associated namespace prefix.
          \
            If more than one prefix are associated to the 
            namespace URI, which is returned is implementation 
            dependent.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              No namespace prefix is found.
        @@@PerlDef:
            if (not defined $namespaceURI) {
              $r = null;
            } else {
              my $n = $self->{<H::mn:node>};
              if ($n->{<H::infoset:ownerElement>}) {
                $r = $n->{<H::infoset:ownerElement>}
                       -><M::ManakaiDOMCore:ManakaiDOMNodeObjectNode
                             .lookupNamespacePrefix>
                                ($namespaceURI, $n->{<H::infoset:ownerElement>});
              } else {
                $r = null;
              }
            }
     @@For:
       ManakaiDOM:DOM3
     @@Level[list]:  3
     @@SpecLevel:3
  @ReAttr:
     @@Name:  namespaceURI
     @@Description:
       @@@lang:en
       @@@@:
         The namespace URI of this node.
     @@Get:
        @@@Type:  
          DOMMain:DOMString
        @@@actualType:
          ManakaiDOM:ManakaiDOMNamespaceURI
        @@@Description:
          @@@@lang:en
          @@@@@: The namespace URI.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The namespace URI is unspecified (the attribute in a 
              per-element-type partition) or 
              the node is created with a DOM Level 1 methods.
        @@@PerlDef:
          $r = defined $self->{<H::mn:node>}->{<H::infoset:namespaceName>}
             ? ${$self->{<H::mn:node>}->{<H::infoset:namespaceName>}} : null;
     @@For:
       ManakaiDOM:DOM2
     @@Level[list]:  2
     @@SpecLevel:2
  @ReAttr:
    @@Name: nodeName
    @@Description:
      @@@lang:en
      @@@@: The node name.
    @@DOMMain:isNamespaceUnaware:1
    @@Get:
      @@@Type: 
        DOMMain:DOMString
      @@@Description:
        @@@@lang:en
        @@@@@:
          The attribute name.  It is same as the value of the "name" 
          attribute.
      @@@disDef:
        @@@@DISPerl:cloneCode:
          .name.get
  @ReAttr:
    @@Name: nodeType
    @@Description:
      @@@lang:en
      @@@@: The type of this node.
    @@Get:
      @@@Type: 
        DOMMain:unsigned-short||ManakaiDOM|all
      @@@actualType: NodeType
      @@@InCase:
        @@@@Label: ATTRIBUTE_NODE
        @@@@Description:
          @@@@@lang:en
          @@@@@@: The node is an "Attr".
      @@@disDef:
        @@@@DISLang:constValue: 
          Node.ATTRIBUTE_NODE
  @ReAttr:
     @@Name:  nodeValue
     @@Description:
       @@@lang:en
       @@@@: The value of this node.
     @@Get:
        @@@Type:  
          DOMMain:DOMString
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: DOMSTRING_SIZE_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: 
              The attribute value, i.e. same as "value".
        @@@disDef:
          @@@@DISPerl:cloneCode:
            ManakaiDOMAttr.value.get
     @@Set:
        @@@Type:  
          DOMMain:DOMString
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: 
              The node is read-only.
        @@@Description:
          @@@@lang:en
          @@@@@:
            New node value.
        @@@disDef:
          @@@@DISPerl:cloneCode: ManakaiDOMAttr.value.set
    @@Level[list]:
        1
        2
        3
    @@SpecLevel:1
  @ReAttr:
     @@Name:  prefix
     @@Description:
       @@@lang:en
       @@@@: The namespace prefix of this node.
     @@DOMMain:isNamespaceAware:1
     @@Type:  
       DOMMain:DOMString
     @@actualType:
       DOMMain:ManakaiDOMNamespacePrefix
     @@Get:
        @@@Description:
          @@@@lang:en
          @@@@@: The namespace prefix.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Either the namespace prefix is unspecified or the node 
              is created with a DOM Level 1 method.
        @@@disDef:
          @@@@GetProp:
            infoset:prefix
     @@Set:
        @@@Description:
          @@@@lang:en
          @@@@@:
            The namespace prefix.
            Note that setting this attribute has no effect if 
            the namespace prefix is defined to be "null".
          \
            Note also that changing the prefix of an attribute that 
            is known to have a default value does not make a 
            new attribute with the default value and the original 
            prefix appear, since the "namespaceURI" and "localName" 
            do not change.  This is different from the defaulting 
            mechanism of the DTD, which is namespace-unaware.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The namespace prefix is unspecified.
        @@@InCase:
          @@@@Value: \
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The result is implementation dependent <SRC::DOM Level 3>.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: INVALID_CHARACTER_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The specified prefix contains an illegal character 
              accoding to the XML version in use in the document.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: This node is read-only.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NAMESPACE_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Either the specified prefix is malformed per the 
              XML Namespace specification, non-"null" prefix is 
              specified but the "namespaceURI" of this node is "null", 
              the specified prefix is "xml" and the "namespaceURI" 
              of this node is different from 
              "http://www.w3.org/XML/1998/namespace", the specified 
              prefix is "xmlns" and the "namespaceURI" of this node 
              is different from "http://www.w3.org/2000/xmlns/", or 
              the "qualifiedName" of this node is "xmlns".
        @@@c:reports:
          @@@@@: t|setting-prefix-no-effect-because-of-document
          @@@@enDesc:
            If the the document does not support XML namespace
            so that setting the attribute value has no effect.
          @@@@For: ManakaiDOM|ManakaiDOM
        @@@c:reports:
          @@@@@: t|setting-prefix-no-effect-because-of-node
          @@@@enDesc:
            If the the node does not support XML namespace
            so that setting the attribute value has no effect.
          @@@@For: ManakaiDOM|ManakaiDOM
        @@@PerlDef:
            my $node = $self->{<H::mn:node>};
            my $docnode = $node->{<H::DOMCore:ownerDocument>};
            my $version = <Code::getDocumentXMLVersion:: $DOCOBJ = $docnode>;
            if (not defined $version) {
              __c:ERROR{t|setting-prefix-no-effect-because-of-document::
                c:relatedData => {$self},
              }__;
            } elsif (not defined $node->{<H::infoset:localName>}) {
              __c:ERROR{t|setting-prefix-no-effect-because-of-node::
                c:relatedData => {$self},
              }__;
            } elsif ($node->{<H::DOMCore:read-only>}) {
              __EXCEPTION{
                MDOMX:NOMOD_THIS::
              }__;
            } elsif (not defined $node->{<H::infoset:prefix>} and
                     $node->{<H::infoset:localName>} and
                     $node->{<H::infoset:localName>} eq 'xmlns') {
              __EXCEPTION{
                MDOMX:MDOM_NS_QNAME_IS_XMLNS::
              }__;
            } else {
              __CODE{DOMMain:ensureNamespacePrefix::
                $INPUT => $given, $INPUT_PARAM_NAME => '',
                $XMLVERSION => $version,
              }__;
              my $nsURI = $node->{<H::infoset:namespaceName>};
              if (not defined $given) {
                if (defined $nsURI) {
                  __EXCEPTION{MDOMX:MDOM_NS_NOPREFIX_WITH_NON_NULL_URI::
                    infoset:namespaceName => {$$nsURI},
                    DOMCore:qualifiedName => {$node->{<H::infoset:localName>}},
                  }__;
                }
              } else {  ## Non-n u l l prefix
                if (not defined $nsURI) {
                  __EXCEPTION{
                    MDOMX:MDOM_NS_PREFIX_WITH_NULL_URI::
                      infoset:prefix => {$given},
                  }__;
                } elsif ($given eq 'xml' and $$nsURI ne <Q::xml:>) {
                  __EXCEPTION{
                    MDOMX:MDOM_NS_XML_WITH_OTHER_URI::
                      infoset:prefix => {$given},
                      infoset:namespaceName => {$$nsURI},
                  }__;
                } elsif ($given eq 'xmlns' and $$nsURI ne <Q::xmlns:>) {
                  __EXCEPTION{
                    MDOMX:MDOM_NS_XMLNS_WITH_OTHER_URI::
                      infoset:prefix => {$given},
                      infoset:namespaceName => {$$nsURI},
                  }__;
                } elsif ($$nsURI eq <Q::xml:> and $given ne 'xml') {
                  __EXCEPTION{MDOMX:MDOM_NS_OTHER_WITH_XML_URI::
                    infoset:prefix => {$given},
                    infoset:namespaceName => {$$nsURI},
                  }__;
                } elsif ($$nsURI eq <Q::xmlns:> and $given ne 'xmlns') {
                  __EXCEPTION{MDOMX:MDOM_NS_OTHER_WITH_XMLNS_URI::
                    infoset:prefix => {$given},
                    infoset:namespaceName => {$$nsURI},
                  }__;
                }
              }
              $node->{<H::infoset:prefix>} = $given;
            }
     @@Level[list]:
       2
       3
     @@SpecLevel:2
     @@For:
       ManakaiDOM:DOM2

  @IntMethod:
    @@Name: newObject
    @@Description:
      @@@lang:en
      @@@@:
        Construct an object for a new instance of the <IF::Attr> node.
    @@ManakaiDOM:isStatic:1
    @@NewObjectRefNodeParam:
    @@Return:
      @@@Type: NodeStem
      @@@Description:
        @@@@lang:en
        @@@@@:
          The new object for the <IF::Attr> node.
      @@@PerlDef:
          $r = <ClassM::ManakaiDOMNode.newObject> ($self, $refNode);
          $r->{<H::infoset:children>} = [];
          $r->{<H::DOMCore:nodeType>} = <H::infoset:Attribute>;
     @@ImplNote:
       @@@lang:en
       @@@@:
         Other properties required to be a legal <IF::Attr> object:
         Either <Q::DOMCore:name> or <Q::infoset:localName>, 
         <Q::DOMCore:ownerDocument>.
       \
         Other available properties: <Q::infoset:prefix>, 
         <Q::DOMCore:read-only>, <Q::infoset:specified>, 
         <Q::infoset:ownerElement>, <Q::infoset:children>, 
         <Q::infoset:namespaceName>, <Q::DOMCore:userDeterminedId>.

  @mn:xrefnode0: DOMCore|ownerDocument
  @mn:origin0: infoset|ownerElement
  @mn:subnode1: infoset|children

  @Method:
     @@Name:  getFeature
     @@enDesc:
       Returns a specialized object that implements the
       specialized interfaces of the specified feature and version.
     @@ManakaiDOM:isRedefining:1
     @@ForCheck: ManakaiDOM|ForClass ManakaiDOM|DOM3
     @@Param:
        @@@Name:  feature
        @@@Type:  
          DOMMain:DOMString
        @@@actualType: ManakaiDOM|ManakaiDOMFeatureName
        @@@enDesc:
          The feature name to request.
        @@@InCase:
          @@@@Label:
            @@@@@lang:en
            @@@@@@: 
              Feature name preceded by a <CHAR::PLUS SIGN>
          @@@@enDesc:
            The <CHAR::PLUS SIGN> is ignored.
     @@Param:
        @@@Name:  version
        @@@Type:  
          DOMMain:DOMString
        @@@actualType: ManakaiDOM|ManakaiDOMFeatureVersion
        @@@enDesc:
          The feature version to request.
        @@@nullCase:
          @@@@enDesc:
            No specific version is requested.
     @@Return:
        @@@Type:  
          DOMMain:DOMObject
        @@@enDesc:
          An object implementing the specialized interfaces.
          Note that the specialized object may or may not
          implement the <IF::Node> interface.
        @@@nullCase:
          @@@@enDesc:
            There is no object available that implements
            the specialized interfaces.
        @@@PerlDef:
            $feature =~ s/^\+//;
            if ($Message::DOM::ClassFeature{ref $self}->{$feature}->{$version}) {
              ## This class
              $r = $self;
            } else {
              ## Attribute name dependent classes
                ## TODO:
              ## Attribute name independent classes
              CLASS: for my $class (grep {
                $Message::DOM::ManakaiDOMAttr::CompatClass{$_}
              } keys %Message::DOM::ManakaiDOMAttr::CompatClass) {
                if ($Message::DOM::ClassFeature{$class}
                            ->{$feature}->{$version}) {
                  __CODE{getNodeRef::
                    $object => {$self->{<H::mn:node>}},
                    $ref => $r,
                    $class => $class,
                  }__;
                  last CLASS;
                }
              }
            }
##Attr

ResourceDef:
  @QName: DTDef
  @For: ManakaiDOM|ManakaiDOMLatest
  @AliasFor: d|DocumentTypeDefinition
ResourceDef:
  @QName: DTDef
  @For: ManakaiDOM|ManakaiDOM3 !ManakaiDOM|ManakaiDOMLatest
  @AliasFor: d|DocumentTypeDefinition||ManakaiDOM|ManakaiDOMLatest

ResourceDef:
  @QName: ETDef
  @For: ManakaiDOM|ManakaiDOMLatest
  @AliasFor: d|ElementTypeDefinition
ResourceDef:
  @QName: ETDef
  @For: ManakaiDOM|ManakaiDOM3 !ManakaiDOM|ManakaiDOMLatest
  @AliasFor: d|ElementTypeDefinition||ManakaiDOM|ManakaiDOMLatest

ResourceDef:
  @QName: ATDef
  @For: ManakaiDOM|ManakaiDOMLatest
  @AliasFor: d|AttributeDefinition
ResourceDef:
  @QName: ATDef
  @For: ManakaiDOM|ManakaiDOM3 !ManakaiDOM|ManakaiDOMLatest
  @AliasFor: d|AttributeDefinition||ManakaiDOM|ManakaiDOMLatest

ResourceDef:
  @QName: DocXDoctype
  @For: ManakaiDOM|ManakaiDOMLatest
  @AliasFor: d|DocumentXDoctype
ResourceDef:
  @QName: DocXDoctype
  @For: ManakaiDOM|ManakaiDOM3 !ManakaiDOM|ManakaiDOMLatest
  @AliasFor: d|DocumentXDoctype||ManakaiDOM|ManakaiDOMLatest

PropDef:
  @QName: c|userDeterminedId
  @enDesc:
    Whether it is a user-determined ID attribute or not.
  @Type: DISPerl|Boolean||ManakaiDOM|all
  @rdfs:range: t|Attr

ElementTypeBinding:
  @Name: NewObjectRefNodeParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@Name: refNode
    @@Type: NodeStem
    @@Description:
      @@@lang:en
      @@@@:
        A node from the tree to which the new node will belong.
    @@rdf:type: DISLang|MethodParameter
    @@ResourceDef:
      @@@rdf:type: ManakaiDOM|InCase
      @@@Value:
        @@@@is-null:1
      @@@Description:
        @@@@lang:en
        @@@@@:
          The node belongs to a new tree.

ResourceDef:
  @QName: c|Element
  @AliasFor: Element
  @For: ManakaiDOM|DOM

ResourceDef:
  @QName: c|ManakaiDOMElement
  @AliasFor: ManakaiDOMElement
  @For: !=ManakaiDOM|all ManakaiDOM|ManakaiDOM !=ManakaiDOM|ManakaiDOM

NodeTypeDef:
  @IFQName: Element
  @ClsQName: ManakaiDOMElement

  @DISLang:role: c|ElementRole

  @Description:
    @@lang:en
    @@@:
      An element in a document.
  @Attr:
     @@Name:  tagName
     @@Description:
       @@@lang:en
       @@@@: The element type name of this node.
     @@Get:
        @@@Type:  
          DOMMain:DOMString
        @@@InCase:
          @@@@Label:
            @@@@@@: Qualified name
            @@@@@lang:en
          @@@@actualType:
            DOMMain:ManakaiDOMXMLQName
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              If the <A::Node.localName> is different from <DOM::null>.
        @@@InCase:
          @@@@Label: 
            @@@@@@:Canonical uppercase form of name
            @@@@@lang:en
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              If this is an HTML element node.
        @@@PerlDef:
          @@@@@:
            my $node = $self->{<H::mn:node>};
            if (defined $node->{<H::infoset:localName>}) {
              $r = (defined $node->{<H::infoset:prefix>} ?
                   $node->{<H::infoset:prefix>} . ':' : '') . 
                   $node->{<H::infoset:localName>};
            } else {
              $r = $node->{<H::DOMCore:name>};
            }
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              The manakai DOM implementation has HTML element type names 
              as uppercase normalized form so that no convertion is 
              required in this attribute.

  @ResourceDef:
    @@ForCheck: ManakaiDOM|ManakaiDOM ManakaiDOM|ForClass
    @@QName: c|selectAttrNodeObjectNS
    @@AliasFor: selectAttrNodeObjectNS

  @ResourceDef:
    @@ForCheck:
      ManakaiDOM:ManakaiDOM ManakaiDOM:ForClass
    @@rdf:type:
      @@@@:
        dis:MultipleResource
      @@@ForCheck:
        !ForSelect !ForRemove
    @@resourceFor: ForSelect
    @@resourceFor: ForRemove

    @@QName:
      @@@@: selectAttrNodeObject
      @@@ForCheck: ForSelect
    @@NSVersion:
      @@@@: selectAttrNodeObjectNS
      @@@ForCheck: ForSelect
      @@@ContentType: DISCore|TFQNames

    @@QName:
      @@@@: selectAttrNodeObjectForRemove
      @@@ForCheck: ForRemove
    @@NSVersion:
      @@@@: selectAttrNodeObjectForRemoveNS
      @@@ForCheck: ForRemove
      @@@ContentType: DISCore|TFQNames

    @@rdf:type: DISPerl|BlockCode

    @@Description:
      @@@lang:en
      @@@@:
        Select an <IF::ManakaiDOMNodeObject> object that represents an 
        <IF::Attr> node.

    @@Param:
      @@@Name:name
      @@@Type:
        @@@@@:
          DOMMain:ManakaiDOMXMLName
        @@@@ManakaiDOM:noInputNormalize:1
      @@@Description:
        @@@@lang:en
        @@@@@:
          The name of the attribute to select.
    @@Param:
      @@@Name: r
      @@@Out: 1
      @@@Type: NodeStem
      @@@Description:
        @@@@lang:en
        @@@@@:
          The <IF::NodeStem> object.  If there is no attribute
          node, then its value is left unchanged.
    @@PerlDef:
      my $__attr = $self->{<H::mn:node>}->{<H::infoset:attributes>};

      if ($__attr->{<Q::ManakaiDOM:noNS>}->{$name}) {
        ## If there is a DOM Level 1 attribute whose |nodeName| equals to
        ## the requested name, then the node is the answer.
        __FOR{!ForRemove::
          $r = $__attr->{<Q::ManakaiDOM:noNS>}->{$name};
        }__;
        __FOR{ForRemove::
          $list = $__attr->{<Q::ManakaiDOM:noNS>};
          $key = $name;
        }__;

      } else {
        ## Otherwise, if an attribute's qualified name is equal to
        ## the requested name, then the node is the answer.

        ## Note that if there is a namespace ill-formed attribute,
        ## the result is not the expected one.  For example,
        ## if an |xmlns| attribute in the |http://www.w3.org/2000/xmlns/|
        ## namespace has non-NULL |prefix|, a request to get |xmlns|
        ## attribute will not return that node.

        ## |sort|ing is required so that every |getAttribute|, |setAttribute|,
        ## |hasAttribute|, |removeAttribute|, or any other namespace unaware
        ## methods operates on the same node even if there is 
        ## multiple nodes with the same qualified name.

        NS: for my $__ns (sort {$a cmp $b} keys %$__attr) {
          next NS if $__ns eq <Q::ManakaiDOM:noNS>;
          for my $__ln (sort {$a cmp $b} keys %{$__attr->{$__ns}}) {
            my $__stem = $__attr->{$__ns}->{$__ln};
            if (defined $__stem->{<H::infoset:prefix>}) {
              if ($__stem->{<H::infoset:prefix>}.':'.
                  $__stem->{<H::infoset:localName>} eq $name) {
                __FOR{!ForRemove::
                  $r = $__stem;
                }__;
                __FOR{ForRemove::
                  $list = $__attr->{$__ns};
                  $key = $__ln;
                }__;
                last NS;
              }
            } else { # no prefix
              if ($__stem->{<H::infoset:localName>} eq $name) {
                __FOR{!ForRemove::
                  $r = $__stem;
                }__;
                __FOR{ForRemove::
                  $list = $__attr->{$__ns};
                  $key = $__ln;
                }__;
                last NS;
              }
            }
          } # ln
        } # NS
      }

  @Method:
     @@Name:  getAttribute
     @@Description:
       @@@lang:en
       @@@@:
         Retrieves an attribute value by name.
     @@NSVersion:.getAttribute
     @@Param:
        @@@Name:  name
        @@@Type:  
          DOMMain:DOMString
        @@@actualType:
          @@@@@:
            DOMMain:ManakaiDOMXMLName
          @@@@ManakaiDOM:noInputNormalize:1
        @@@Description:
          @@@@lang:en
          @@@@@:
            The name of the attribute to retrieve.
     @@Return:
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            The <IF::Attr> value as a string.
        @@@InCase:
          @@@@Value:\
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              That attribute does not have a specified or default value.
        @@@PerlDef:
          __CODE{selectAttrNodeObject}__;
          if ($r) {
            __CODE{ManakaiNode:getWeakReference||ManakaiDOM:Perl::
              $object => $r, $ref => $r,
              $class => {<ClassName::ManakaiDOMAttr>},
            }__;
            $r = $r-><AG::Node.textContent>;
          } else {
            ## Web browser compatible behavior
            __FOR{ManakaiDOM:DOMLatest::
              $r = null;
            }__;
            ## DOM spec
            __FOR{!ManakaiDOM:DOMLatest::
              $r = '';
            }__;
          }
  @Method:
     @@Name:  setAttribute
     @@Description:
       @@@lang:en
       @@@@:
         Add a new attribute.  If an attribute with that name is 
         already present in the element, its value is changed. 
     @@NSVersion:.setAttributeNS
     @@Param:
        @@@Name:  name
        @@@Type:  
          DOMMain:DOMString
        @@@actualType:
          @@@@@:
            DOMMain:ManakaiDOMXMLName
          @@@@ManakaiDOM:noInputNormalize:1
        @@@Description:
          @@@@lang:en
          @@@@@: The name of the attribute to create or alter.
     @@Param:
        @@@Name:  value
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The value to set.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              How to process <DOM::null> <P::value> is not mentioned.
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The manakai DOM implementation converts <DOM::null> value 
              to an empty string. 
            @@@@@For:
              ManakaiDOM:ManakaiDOM
     @@Return:
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:INVALID_CHARACTER_ERR
          @@@@SubType:
            @@@@@QName:
              MDOMX:MDOM_BAD_NAME
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <P::name> is not a legal SGML or XML <CODE::Name>.
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:NO_MODIFICATION_ALLOWED_ERR
          @@@@SubType:
            @@@@@QName:
              MDOMX:NOMOD_THIS
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                This (<IF::Element>) node is read-only.
            @@@@@SpecLevel:1
          @@@@SubType:
            @@@@@QName:
              MDOMX:NOMOD_ATTR
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <IF::Attr> node to edit is read-only.
            @@@@@SpecLevel[list]:
        @@@PerlDef:
            if ($self->{<H::mn:node>}->{<H::DOMCore:read-only>}) {
              __EXCEPTION{
                MDOMX:NOMOD_THIS::
              }__;
            }
            my $r;
            __CODE{selectAttrNodeObject}__;
            my $node = $self->{<H::mn:node>};
            if ($r) {  ## There is already a node for the name
              if ($r->{<H::DOMCore:read-only>}) {
                __EXCEPTION{
                  MDOMX:NOMOD_ATTR::
                }__;
              }
              my @children = @{$r->{<H::infoset:children>}};
              $r->{<H::infoset:children>} = [];
              for (@children) {
                CORE::delete $_->{<H::infoset:parent>};
                $_-><M::NodeStem.orphanate>;
              }
            } else {   ## There is no attribute node for the name
              my $docNode = $node->{<H::c|ownerDocument>};
              if (<Code::doStrictErrorChecking:: $nodeRef = $self>) {
                my $version = <Code::getDocumentXMLVersion:: $DOCOBJ = $docNode>;
                __CODE{DOMMain:ensureXMLName:: $INPUT => $name,
                                             $INPUT_PARAM_NAME => 'name',
                                             $XMLVERSION => $version}__;
              }
              $r = <ClassM::ManakaiDOMAttr.newObject> ($node);
              $r->{<H::DOMCore:name>} = $name;
              $r->{<H::infoset:ownerElement>} = $node;
              __CODE{mn|setXRefNode||ManakaiDOM|Perl::
                $referrer => {$r},
                $propName => {<H::DOMCore:ownerDocument>},
                $referent => {$docNode},
              }__;
              $node->{<H::infoset:attributes>}
                   ->{<Q::ManakaiDOM:noNS>}->{$name} = $r;

              ## Schema type information
              if (defined $docNode->{<H::c|schema-type>} and
                  $docNode->{<H::c|schema-type>} eq <Q::xml-dtd:>) {
                __DEEP{
                  my $doctype = $self-><AG::Node.ownerDocument>
                                     -><AG::Document.doctype>;
                  $doctype = $doctype-><M::Node.getFeature>
                                         (<Q::ManakaiDOM:XDoctype> => '3.0')
                    if $doctype;
                  if ($doctype) {
                    my $et = $doctype-><M::DTDef.getElementTypeDefinitionNode>
                                         ($self-><AG::Node.nodeName>);
                    if ($et) {
                      my $at = $et-><M::ETDef.getAttributeDefinitionNode>
                                      ($name);
                      if ($at) {
                        $r->{<H::infoset:attributeType>}
                          = $at-><AG::ATDef.declaredType>;
                      }
                    }
                  }
                }__;
              } # Schema language is XML DTD
            }
            my $text = <ClassM::ManakaiDOMText.newObject> ($node);
            $text->{<H::infoset:content>} = defined $value ? $value : '';
            __CODE{mn|setXRefNode||ManakaiDOM|Perl::
              $referrer => {$text},
              $propName => {<H::DOMCore:ownerDocument>},
              $referent => {$self->{<H::mn:node>}->{<H::DOMCore:ownerDocument>}},
            }__;
            $text->{<H::infoset:parent>} = $r;
            $r->{<H::infoset:children>} = [$text];
            $r->{<H::infoset:specified>} = true;
     @@SpecLevel:1
    @@enImplNote:
      {ISSUE:: Should <XA::xml:id> attribute has type info?
      }

  @Method:
     @@Name:  removeAttribute
     @@Description:
       @@@lang:en
       @@@@:
         Remove an attribute by name.
       \
         If a default value for the removed attribute is defined in 
         the DTD, a new attribute immediately appears.  The DOM 
         implementation may handle default values from other schemas.
     @@NSVersion:.removeAttributeNS
     @@Param:
        @@@Name:  name
        @@@Type:  
          DOMMain:DOMString
        @@@actualType:
          @@@@@:
            DOMMain:ManakaiDOMXMLName
          @@@@ManakaiDOM:noInputNormalize:1
        @@@Description:
          @@@@lang:en
          @@@@@:
            The name of the attribute to remove.  If no attribute 
            with this <P::name> is found, this method has no effect.
    @@Return:
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the <IF::Element> node is read-only.
      @@@PerlDef:
        my $list;
        my $key;
        __CODE{selectAttrNodeObjectForRemove::
          $self => $self,
          $name => $name,
          $list => $list,
          $key => $key,
        }__;
        if ($list) { # there is an attribute node
          if ($self->{<H::mn:node>}->{<H::c|read-only>}) {
            __EXCEPTION{
              MDOMX:NOMOD_THIS::
            }__;
          }

          ## Remove the attribute node
          my $stem = $list->{$key};
          CORE::delete $list->{$key};
          CORE::delete $stem->{<H::infoset:ownerElement>};
          $stem-><M::NodeStem.orphanate>;

          ## Default attribute
          my $doc = $self-><AG::Node.ownerDocument>;
          __CODE{t|generateDefaultAttribute::
            $document => $doc,
            $element_type => {$self-><AG::Node.nodeName>},
            $element => $self,
            $name => $name,
          }__;
        } # exists

    @@Test:
      @@@QName: Element.removeAttribute.test
      @@@PerlDef:
        my $el;
        __CODE{createElementForTest:: $el => $el}__;

        $test->id ('remove.no.attr');
        $el-><M::Element.removeAttribute> ('at1');

        $test->id ('set.attr');
        $el-><M::Element.setAttribute> (at1 => 'value1');
        my $v1 = $el-><M::Element.getAttribute> ('at1');
        $test->assert_equals ($v1, 'value1');

        $test->id ('remove.attr');
        $el-><M::Element.removeAttribute> ('at1');
        my $v2 = $el-><M::Element.getAttribute> ('at1');
        $test->assert_true (not defined $v2 or $v2 eq '');
    @@L2Test:
      @@@ForCheck: ManakaiDOM|DOMXMLFeature
      @@@QName: Element.removeAttribute.nsattr.test
      @@@PerlDef:
        my $el;
        __CODE{createElementForTest:: $el => $el}__;

        $test->id ('remove.no.attr');
        $el-><M::Element.removeAttribute> ('ns1:at1');

        $test->id ('set.attr.ns');
        $el-><M::Element.setAttributeNS>
               ('http://example./', 'ns1:at1' => 'value1');
        my $v1 = $el-><M::Element.getAttributeNS> ('http://example./', 'at1');
        $test->assert_equals ($v1, 'value1');

        $test->id ('remove.attr');
        $el-><M::Element.removeAttribute> ('ns1:at1');
        my $v2 = $el-><M::Element.getAttributeNS> ('http://example./', 'at1');
        undef $v2 if defined $v2 and $v2 eq '';
        $test->assert_null ($v2);
    @@L3Test:
      @@@QName: Element.removeAttribute.defaultattr.test
      @@@PerlDef:
        my $doc;
        __CODE{createEmptyDocumentForTest:: $doc => $doc}__;
        my $docd = $doc-><M::Node.getFeature> (<Q::ManakaiDOM:XDoctype>, '3.0');
        my $dtd = $docd-><M::d|DocumentXDoctype.createDocumentTypeDefinition>
                           ('doctype');
          my $et = $docd-><M::d|DocumentXDoctype.createElementTypeDefinition>
                             ('et1');
            my $at = $docd-><M::d|DocumentXDoctype.createAttributeDefinition>
                               ('dattr1');
            $at-><AS::ATDef.defaultType> (<C::ATDef.EXPLICIT_DEFAULT>);
            $at-><AS::Node.textContent> ('dattr1 default ');
          $et-><M::ETDef.setAttributeDefinitionNode> ($at);
        $dtd-><M::DTDef.setElementTypeDefinitionNode> ($et);
        $doc-><M::Node.appendChild> ($dtd);

        $test->id ('created.default.value');
        my $el = $doc-><M::Document.createElement> ('et1');
        $test->assert_equals ($el-><M::Element.getAttribute> ('dattr1'),
                              'dattr1 default ');
        $test->assert_false ($el-><M::Element.getAttributeNode> ('dattr1')
                                -><AG::Attr.specified>);

        $test->id ('set.attr');
        $el-><M::Element.setAttribute> ('dattr1', 'non-default-value');
        $test->assert_equals ($el-><M::Element.getAttribute> ('dattr1'),
                              'non-default-value');
        $test->assert_true ($el-><M::Element.getAttributeNode> ('dattr1')
                               -><AG::Attr.specified>);

        $test->id ('remove.attr');
        $el-><M::Element.removeAttribute> ('dattr1');
        $test->assert_equals ($el-><M::Element.getAttribute> ('dattr1'),
                              'dattr1 default ');
        $test->assert_false ($el-><M::Element.getAttributeNode> ('dattr1')
                                -><AG::Attr.specified>);

  @CODE:
    @@QName: generateDefaultAttribute
    @@PerlDef:
      @@@For: ManakaiDOM|DOM3 ManakaiDOM|DOMXMLFeature
      @@@@:
        __DEEP{
          my $__doctype = $document-><AG::Document.doctype>;
          $__doctype = $__doctype-><M::Node.getFeature>
                                     (<Q::ManakaiDOM:XDoctype> => '3.0')
            if $__doctype;
          if ($__doctype) {
            my $__et = $__doctype-><M::DTDef.getElementTypeDefinitionNode>
                                     ($element_type);
            if ($__et) {
              local $document->{<H::mn:node>}
                             ->{<H::c|strictErrorChecking>} = false;          
              my $__at = $__et-><M::ETDef.getAttributeDefinitionNode> ($name);
              if ($__at) {
                my ($__an1, $__an2) = split /:/, $name;
                my $__cfg = $document-><AG::Document.domConfig>;
                my $__copy_asis = $__cfg-><M::c|DOMConfiguration.getParameter>
                                       (<Q::cfg|clone-entity-reference-subtree>);
                $__cfg-><M::c|DOMConfiguration.setParameter>
                          (<Q::cfg|clone-entity-reference-subtree> => true);
                ADD: {
                  my $__attr;
                  if (defined $__an2) {   ## prefixed attr
                    my $__nsuri = $element-><M::Node.lookupNamespaceURI>
                                              ($__an1);
                    unless (defined $__nsuri) {
                      ## TODO: Namespace well-formedness error
                    }
                    if ($element->{<H::mn:node>}->{<H::infoset:attributes>}
                                ->{defined $__nsuri ? $__nsuri : <Q::null:>}
                                ->{$__an2}) {
                      ## TODO: Namespace well-formedness warning?
                      last ADD;
                    }
                    $__attr = $document-><M::Document.createAttributeNS>
                                           ($__nsuri, $name);
                  } else {                ## local attr
                    if ($name eq 'xmlns') {
                      if ($element->{<H::mn:node>}->{<H::infoset:attributes>}
                                  ->{<Q::xmlns:>}->{xmlns}) {
                        ## TODO: Namespace well-formedness warning?
                        last ADD;
                      }
                      $__attr = $document-><M::Document.createAttributeNS>
                                             (<Q::xmlns:>, 'xmlns');
                    } else {
                      if ($element->{<H::mn:node>}->{<H::infoset:attributes>}
                                  ->{<Q::null:>}->{$name}) {
                        ## TODO: Namespace well-formedness warning?
                        last ADD;
                      }
                      ## TODO: NCName error
                      $__attr = $document-><M::Document.createAttributeNS>
                                             (null, $name);
                    }
                  }
                  for my $__at_child (@{$__at-><AG::Node.childNodes>}) {
                    $__attr-><M::Node.appendChild>
                               ($__at_child-><M::Node.cloneNode> (true));
                  }
                  $__attr->{<H::mn:node>}->{<H::infoset:attributeType>}
                    = $__at-><AG::ATDef.declaredType>;
                  $element-><M::Element.setAttributeNodeNS> ($__attr);
                              ## This method change the |specified| flag
                  $__attr->{<H::mn:node>}->{<H::infoset:specified>} = false;
                } # ADD
                $__cfg-><M::c|DOMConfiguration.setParameter>
                       (<Q::cfg|clone-entity-reference-subtree> => $__copy_asis);
              }
            }
          }
        }__;
    @@enImplNote:
      @@@ddid: downlevels
      @@@@:
        {TODO:: Implementation for level 1, 2, 3+ w/o XML required. 
        }
    @@enImplNote:
      {ISSUE::
        Given <XA::ns1:ln> attribute has a default value <CODE::value>
        amd there is a <A::Attr.specified> attribute node <VAR::a1>
        whose <A::Node.prefix> is <XML::ns1> and <A::Node.localName>
        is <XML::ln>.  Then, <VAR::a1>'s <A::Node.prefix> is 
        so modified that its value is now <XML::ns2>.  At this
        time no default attribute is added <SRC::DOM Level 3 Core>.

        Now we remove the <VAR::a1> node from its owner element.
        Should the operation make a default attribute with
        its <A::Node.nodeName> <XA::ns1:ln> be created?
        
        To do it, because of DTD's namespace unawareness, 
        we must test any possible default attribute if
        its local name matches to the removed attribute's local name,
        i.e. <XML::ln>, and looking up its prefix by the
        former owner element of the removed attribute and
        it matches to the namespace URI of the removed attribute.
      }

  @Method:
     @@Name:  getAttributeNode
     @@Description:
       @@@lang:en
       @@@@:
         Retrieve an attribute node by name.
     @@NSVersion:.getAttributeNodeNS
     @@Param:
        @@@Name:  name
        @@@Type:  
          DOMMain:DOMString
        @@@actualType:
          @@@@@:
            DOMMain:ManakaiDOMXMLName
          @@@@ManakaiDOM:noInputNormalize:1
        @@@Description:
          @@@@lang:en
          @@@@@:
            The name (<A::Node.nodeName>) of the attribute to retrieve.
     @@Return:
        @@@Type:  Attr
        @@@actualType: ManakaiDOMAttr
        @@@Description:
          @@@@lang:en
          @@@@@:
            The <IF::Attr> node with the specified name.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: There is no such attribute.
        @@@PerlDef:
            my $obj;
            __CODE{selectAttrNodeObject:: $r => $obj}__;
            if ($obj) {
              $r = <ClassM::ManakaiDOMNode.getNodeReference> ($obj);
            }
  @Method:
     @@Name:  setAttributeNode
     @@Description:
       @@@lang:en
       @@@@:
         Add a new attribute node.  If an attribute with that name is 
         already present in the element, it is replaced by the new one. 
         \
         Replacing an attribute node by itself has no effect.
     @@NSVersion:.setAttributeNodeNS
     @@Param:
        @@@Name:  newAttr
        @@@Type:  Attr
        @@@actualType: ManakaiDOMAttr
        @@@Description:
          @@@@lang:en
          @@@@@: 
            The <IF::Attr> node to add to the attribute list.
     @@Return:
        @@@Type:  Attr
        @@@actualType: ManakaiDOMAttr
        @@@Description:
          @@@@lang:en
          @@@@@:
            The replaced <IF::Attr> node.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              No <IF::Attr> node was replaced.
        @@@@enImplNote:
          Although the spec is unclear, when a node is <QUOTE::replaced>
          by itself, it is defined as <QUOTE::no effect>, no node
          is actually replaced and the manakai implementation does
          return <DOM::null>.
      @@@dx:raises:
        @@@@@: c|DIFFERENT_DOCUMENT_ERR
        @@@@enDesc:
          If <P::newAttr> was created from a different document
          than the <A::Node.ownerDocument> of the element.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the element is read-only.
      @@@dx:raises:
        @@@@@: c|INUSE_ATTRIBUTE_ERR
        @@@@enDesc:
          If the <P::newAttr> node is already used as an attribute
          of another <IF::Element> node.
        @@@c:reports:
          @@@@@: t|replace-by-itself
          @@@@enDesc:
            If the <P::arg> node is same as the attribute node that
            is attached to the element node.  Then, the method call is 
            no effect.
          @@@@For: ManakaiDOM|ManakaiDOM
      @@@PerlDef:
        my $stem = $self->{<H::mn:node>};
        my $a_stem = $newAttr->{<H::mn:node>};
        my $strict = <Code::doStrictErrorChecking:: $nodeRef = $self>;
        if ($strict and
            not $stem->{<H::c|ownerDocument>}
                    eq $a_stem->{<H::c|ownerDocument>}) {
          __EXCEPTION{c|DIFFERENT_DOCUMENT_ERR::
            MDOMX|param-name => 'newAttr',
            c|node => {$newAttr},
          }__;
        }

        my $c_a_stem; # current attribute node stem
        my $nsuri;
        my $ln;
        if (defined $a_stem->{<H::infoset:localName>}) {
          $nsuri = defined $a_stem->{<H::infoset:namespaceName>}
                     ? $a_stem->{<H::infoset:namespaceName>}
                     : \(<Q::null:>);
          $ln = $a_stem->{<H::infoset:localName>};
        } else { # DOM Level 1 node
          $nsuri = \(<Q::ManakaiDOM:noNS>);
          $ln = $a_stem->{<H::c|name>};
        }
        $c_a_stem = $stem->{<H::infoset:attributes>}->{$$nsuri}->{$ln};

        if ($a_stem->{<H::infoset:ownerElement>}) {
          if ($c_a_stem and $a_stem eq $c_a_stem) {
            __c:ERROR{t|replace-by-itself::
              c:relatedData => {$newAttr},
            }__;
            ## No return value
          } else {
            __EXCEPTION{c|INUSE_ATTRIBUTE_ERR::
              MDOMX|param-name => 'newAttr',
              c|node => {$newAttr},
            }__;
          }
        } else { # not in use
          if ($strict and $stem->{<H::c|read-only>}) {
            __EXCEPTION{MDOMX|NOMOD_THIS::
            }__;
          }
          
          $stem-><M::NodeStem.importTree> ($a_stem);
          $a_stem->{<H::infoset:ownerElement>} = $stem;
          $stem->{<H::infoset:attributes>}->{$$nsuri}->{$ln} = $a_stem;
       
          $a_stem->{<H::infoset:specified>} = true;

          if ($c_a_stem) {
            $r = <ClassM::ManakaiDOMNode.getNodeReference> ($c_a_stem)
              if defined wantarray;
            CORE::delete $c_a_stem->{<H::infoset:ownerElement>};
            $c_a_stem-><M::NodeStem.orphanate>;
          }
        }

    @@Test:
      @@@QName: Element.setAttributeNode.test
      @@@PerlDef:
        my $el;
        __CODE{createElementForTest:: $el => $el}__;
        my $doc = $el-><AG::Node.ownerDocument>;

        my $a1 = $doc-><M::Document.createAttribute> ('attr1');
        $a1-><AS::Attr.value> ('value1');

        $test->id ('set');
        my $r1 = $el-><M::Element.setAttributeNode> ($a1);

        $test->id ('no.replace.no.return');
        $test->assert_null ($r1);

        $test->id ('get.text');
        $test->assert_equals ($el-><M::Element.getAttribute> ('attr1'),
                              'value1');

        $test->id ('get.return.setten');
        my $r2 = $el-><M::Element.getAttributeNode> ('attr1');
        $test->assert_equals ($r2, $a1);

        $test->id ('owner');
        $test->assert_equals ($a1-><AG::Attr.ownerElement>, $el);

        $test->id ('specified');
        $test->assert_true ($a1-><AG::Attr.specified>);

        my $a2 = $doc-><M::Document.createAttribute> ('attr1');
        
        $test->id ('replace');
        my $r3 = $el-><M::Element.setAttributeNode> ($a2);
  
        $test->id ('replaced.node.returned');
        $test->assert_equals ($r3, $a1);

        $test->id ('replaced.no.owner');
        $test->assert_null ($a1-><AG::Attr.ownerElement>);

    @@L3Test:
      @@@QName: Element.setAttributeNode.replace-by-itself.Test
      @@@PerlDef:
           my $impl = <Class::c|ManakaiDOMImplementation>->_new;
           my $doc = $impl-><M::c|DOMImplementation.createDocument>
                              ('http://www.example/', 'ex');

           my $eh_called = false;

           my $del = $doc-><AG::Document.documentElement>;
           $del-><M::Element.setAttributeNS> (null, 'attr' => 'value');

           my $attr = $del-><M::Element.getAttributeNodeNS> (null, 'attr');

           my $cfg = $doc-><AG::Document.domConfig>;
           $cfg-><M::c|DOMConfiguration.setParameter> ('error-handler' => sub {
             my (undef, $err) = @_;
             $eh_called = true;
             $test->assert_equals ($err-><AG::c|DOMError.severity>,
                                   <C::c|DOMError.SEVERITY_WARNING>);
             $test->assert_equals ($err-><AG::c|DOMError.type>,
                                   <Q::t|replace-by-itself>);
             $test->assert_equals ($err-><AG::c|DOMError.relatedData>, $attr);
             $test->assert_null ($err-><AG::c|DOMError.relatedException>);
             $test->assert_isa ($err-><AG::c|DOMError.location>,
                                <IFName::c|DOMLocator>);
             $test->assert_not_null ($err-><AG::c|DOMError.message>);
           });

           $test->assert_false ($eh_called);
           $del-><M::Element.setAttributeNode> ($attr);
           $test->assert_true ($eh_called);

           $test->assert_equals ($del-><M::Element.getAttributeNodeNS>
                                   (null, 'attr'), $attr);

           $attr = null;

  @Method:
     @@Name:  removeAttributeNode
     @@Description:
        @@@lang:en
        @@@@:
          Remove the specified attribute node.
        \
          If a default value for the removed attribute is defined 
          in the DTD, a new node immediately appears.  The DOM 
          implementation may handle default values from other schemas.
     @@Param:
        @@@Name:  oldAttr
        @@@Type:  Attr
        @@@actualType: ManakaiDOMAttr
        @@@Description:
          @@@@lang:en
          @@@@@: 
            The attribute node to remove from the attribute list.
    @@Return:
      @@@Type: Attr
      @@@enDesc:
        The removed attribute node.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the element node is read-only.
      @@@dx:raises:
        @@@@@: c|NOT_ATTR_ERR
        @@@@enDesc:
          If the <P::oldAttr> node is not an attribute of the element.
      @@@PerlDef:
        my $stem = $self->{<H::mn:node>};
        if (<Code::doStrictErrorChecking:: $nodeRef = $self>) {
          if ($stem->{<H::c|read-only>}) {
            __EXCEPTION{MDOMX:NOMOD_THIS::
            }__;
          }
        }

        my $a_stem = $oldAttr->{<H::mn:node>};
        FIND: {
          if (defined $a_stem->{<H::infoset:localName>}) {
            my $list = $stem->{<H::infoset:attributes>}
                            ->{defined $a_stem->{<H::infoset:namespaceName>}
                                 ? ${$a_stem->{<H::infoset:namespaceName>}}
                                 : <Q::null:>};
            if ($list->{$a_stem->{<H::infoset:localName>}} and
                $list->{$a_stem->{<H::infoset:localName>}} eq $a_stem) {
              CORE::delete $list->{$a_stem->{<H::infoset:localName>}};
              last FIND;
            }
          } else { ## DOM Level 1 node
            my $list = $stem->{<H::infoset:attributes>}->{<Q::ManakaiDOM:noNS>};
            if ($list->{$a_stem->{<H::c|name>}} and
                $list->{$a_stem->{<H::c|name>}} eq $a_stem) {
              CORE::delete $list->{$a_stem->{<H::c|name>}};
              last FIND;
            }
          }
          __EXCEPTION{c|NOT_ATTR_ERR::
            MDOMX:param-name => 'oldAttr',
            c|node => {$oldAttr},
          }__;
        } # FIND

        CORE::delete $a_stem->{<H::infoset:ownerElement>};
        $a_stem-><M::NodeStem.orphanate>;
        $r = $oldAttr if defined wantarray;
      
        ## Default attribute
        my $doc = $self-><AG::Node.ownerDocument>;
        my $name = $oldAttr-><AG::Node.nodeName>;
        __CODE{t|generateDefaultAttribute::
          $document => $doc,
          $element_type => {$self-><AG::Node.nodeName>},
          $element => $self,
          $name => $name,
        }__;

    @@Test:
      @@@QName: Element.removeAttributeNode.test
      @@@PerlDef:
        my $el;
        __CODE{createElementForTest:: $el => $el}__;

        $test->id ('remove.no.attr');
        $el-><M::Element.removeAttribute> ('at1');

        $test->id ('set.attr');
        $el-><M::Element.setAttribute> (at1 => 'value1');
        my $v1 = $el-><M::Element.getAttribute> ('at1');
        $test->assert_equals ($v1, 'value1');

        $test->id ('remove.attr');
        my $a1 = $el-><M::Element.getAttributeNode> ('at1');
        $el-><M::Element.removeAttributeNode> ($a1);
        my $v2 = $el-><M::Element.getAttribute> ('at1');
        $test->assert_true (not defined $v2 or $v2 eq '');
        $test->assert_null ($a1-><AG::Attr.ownerElement>);
    @@L2Test:
      @@@ForCheck: ManakaiDOM|DOMXMLFeature
      @@@QName: Element.removeAttributeNode.nsattr.test
      @@@PerlDef:
        my $el;
        __CODE{createElementForTest:: $el => $el}__;

        $test->id ('remove.no.attr');
        $el-><M::Element.removeAttribute> ('ns1:at1');

        $test->id ('set.attr.ns');
        $el-><M::Element.setAttributeNS>
               ('http://example./', 'ns1:at1' => 'value1');
        my $v1 = $el-><M::Element.getAttributeNS> ('http://example./', 'at1');
        $test->assert_equals ($v1, 'value1');

        $test->id ('remove.attr');
        my $a1 = $el-><M::Element.getAttributeNode> ('ns1:at1');
        $el-><M::Element.removeAttributeNode> ($a1);
        my $v2 = $el-><M::Element.getAttributeNS> ('http://example./', 'at1');
        $test->assert_true (not defined $v2 or $v2 eq '');
        $test->assert_null ($a1-><AG::Attr.ownerElement>);
    @@L3Test:
      @@@QName: Element.removeAttributeNode.defaultattr.test
      @@@PerlDef:
        my $doc;
        __CODE{createEmptyDocumentForTest:: $doc => $doc}__;
        my $docd = $doc-><M::Node.getFeature> (<Q::ManakaiDOM:XDoctype>, '3.0');
        my $dtd = $docd-><M::d|DocumentXDoctype.createDocumentTypeDefinition>
                           ('doctype');
          my $et = $docd-><M::d|DocumentXDoctype.createElementTypeDefinition>
                             ('et1');
            my $at = $docd-><M::d|DocumentXDoctype.createAttributeDefinition>
                               ('dattr1');
            $at-><AS::ATDef.defaultType> (<C::ATDef.EXPLICIT_DEFAULT>);
            $at-><AS::Node.textContent> ('dattr1 default ');
          $et-><M::ETDef.setAttributeDefinitionNode> ($at);
        $dtd-><M::DTDef.setElementTypeDefinitionNode> ($et);
        $doc-><M::Node.appendChild> ($dtd);

        $test->id ('created.default.value');
        my $el = $doc-><M::Document.createElement> ('et1');
        $test->assert_equals ($el-><M::Element.getAttribute> ('dattr1'),
                              'dattr1 default ');
        $test->assert_false ($el-><M::Element.getAttributeNode> ('dattr1')
                                -><AG::Attr.specified>);

        $test->id ('set.attr');
        $el-><M::Element.setAttribute> ('dattr1', 'non-default-value');
        $test->assert_equals ($el-><M::Element.getAttribute> ('dattr1'),
                              'non-default-value');
        $test->assert_true ($el-><M::Element.getAttributeNode> ('dattr1')
                               -><AG::Attr.specified>);

        $test->id ('remove.attr');
        my $a1 = $el-><M::Element.getAttributeNode> ('dattr1');
        $el-><M::Element.removeAttributeNode> ($a1);
        $test->assert_equals ($el-><M::Element.getAttribute> ('dattr1'),
                              'dattr1 default ');
        $test->assert_false ($el-><M::Element.getAttributeNode> ('dattr1')
                                -><AG::Attr.specified>);
        $test->assert_null ($a1-><AG::Attr.ownerElement>);

  @Method:
     @@Name:  getElementsByTagName
     @@Description:
       @@@lang:en
       @@@@:
         Return a <IF::NodeList> of all descendant elements with a 
         given element type name, in the document order.
     @@Param:
        @@@Name:  name
        @@@Type:  
          DOMMain:DOMString
        @@@actualType:
          @@@@@:
            DOMMain:ManakaiDOMXMLName
          @@@@ManakaiDOM:noInputNormalize:1
        @@@Description:
          @@@@lang:en
          @@@@@:
            The name of the element type to match on.
        @@@InCase:
          @@@@Value:*
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Match all element type names.
     @@Return:
        @@@Type:  NodeList
        @@@actualType:
          ManakaiDOMCore:ManakaiDOMGetElementsNodeList
        @@@Description:
          @@@@lang:en
          @@@@@:
            A list of matching <IF::Element> nodes.
        @@@PerlDef:
            my $node = $self->{<H::mn:node>};
            my $chk;
            if (defined $name and $name eq '*') {
              $chk = sub { 1 };
            } else {
              $name = "$name";
              $chk = sub {
                my ($self) = @_;
                if (defined $self->{<H::infoset:localName>}) {
                  if (defined $self->{<H::infoset:prefix>}) {
                    return ($self->{<H::infoset:prefix>} . ':' .
                            $self->{<H::infoset:localName>} eq $name)
                               ? true : false;
                  } else {
                    return ($self->{<H::infoset:localName>} eq $name)
                               ? true : false;
                  }
                } else {
                  return ($self->{<H::DOMCore:name>} eq $name)
                               ? true : false;
                }
              };
            }
            __CODE{getNodeRef::
              $object => $node, $ref => $r,
              $class => {
                <ClassName::ManakaiDOMCore:ManakaiDOMGetElementsNodeList>
              },
            }__;
            $r->{<H::ManakaiDOMCore:nodeMatch>} = $chk;
     @@NSVersion:.getElementsByTagNameNS

  @ResourceDef:
    @@ForCheck:
      ManakaiDOM:ManakaiDOM ManakaiDOM:ForClass
    @@rdf:type:
      @@@@:
        dis:MultipleResource
      @@@ForCheck: !ForRemove !ForSelect
    @@resourceFor: ForSelect
    @@resourceFor: ForRemove

    @@QName:
      @@@@: selectAttrNodeObjectNS
      @@@ForCheck: ForSelect
    @@NoNSVersion:
      @@@@: selectAttrNodeObject
      @@@ForCheck: ForSelect
      @@@ContentType: DISCore|TFQNames
    @@rdf:type:
      @@@@: DISPerl|BlockCode
      @@@ForCheck: ForSelect
    
    @@QName:
      @@@@: selectAttrNodeObjectForRemoveNS
      @@@ForCheck: ForRemove
    @@NoNSVersion:
      @@@@: selectAttrNodeObjectForRemove
      @@@ForCheck: ForRemove
      @@@ContentType: DISCore|TFQNames
    @@rdf:type:
      @@@@: DISPerl|BlockCode
      @@@ForCheck: ForRemove
    
     @@Description:
       @@@lang:en
       @@@@:
         Select a <Class::ManakaiDOMNodeObject> object that represents 
         an <IF::Attr> node, by namespace URI and local name.
     @@Param:
        @@@Name:  namespaceURI
        @@@Type:
          DOMMain:DOMString
        @@@actualType:
          ManakaiDOM:ManakaiDOMNamespaceURI
        @@@Description:
          @@@@lang:en
          @@@@@:
            The namespace URI of the attribute to select.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The attribute to select has no namespace.
     @@Param:
        @@@Name:  localName
        @@@Type:  
          @@@@@:
            DOMMain:ManakaiDOMXMLLocalName
          @@@@ManakaiDOM:noInputNormalize:1
        @@@Description:
          @@@@lang:en
          @@@@@: The local name of the attribute to select.
     @@Return:
        @@@Type: NodeStem
        @@@Description:
          @@@@lang:en
          @@@@@:
            The <Class::ManakaiDOM:ManakaiDOMNodeObject> object being selected.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: There is no such attribute.
    @@PerlDef:
      @@@ForCheck: !ForRemove
      @@@@:
        $r = $self->{<H::mn:node>}->{<H::infoset:attributes>}
                  ->{defined $namespaceURI ? $namespaceURI : <Q::null:>}
                  ->{$localName};
    @@PerlDef:
      @@@ForCheck: ForRemove
      @@@@:
        $list = $element->{<H::mn:node>}->{<H::infoset:attributes>}
                        ->{defined $namespaceURI ? $namespaceURI : <Q::null:>};
        $list = null unless $list->{$localName};

  @Method:
     @@Name:  getAttributeNS
     @@Description:
       @@@lang:en
       @@@@:
         Retrieve an attribute value by local name and namespace URI.
     @@NoNSVersion:.getAttribute
     @@Param:
        @@@Name:  namespaceURI
        @@@Type:
          DOMMain:DOMString
        @@@actualType:
          ManakaiDOM:ManakaiDOMNamespaceURI
        @@@Description:
          @@@@lang:en
          @@@@@:
            The namespace URI of the attribute to retrieve.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The attribute to retrieve has no namespace.
     @@Param:
        @@@Name:  localName
        @@@Type:  
          DOMMain:DOMString
        @@@actualType:
          @@@@@: 
            DOMMain:ManakaiDOMXMLLocalName
          @@@@ManakaiDOM:noInputNormalize:1
        @@@Description:
          @@@@lang:en
          @@@@@: The local name of the attribute to retrieve.
     @@Return:
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            The <IF::Attr> value as a string.
        @@@InCase:
          @@@@Value:\
          @@@@Description:
            @@@@@lang:en
            @@@@@@: That attribute does not have a specified or default value.
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:NOT_SUPPORTED_ERR
          @@@@SubType:
            @@@@@QName:
              MDOMX:MDOM_IMPL_NOSUPPORT_XML
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The DOM implementation does not support the feature 
                <Feature::XML> and the language exposed through the 
                <IF::Document> does not support XML Namespaces.
        @@@PerlDef:
          @@@@@:
            __CODE{selectAttrNodeObjectNS}__;
            if ($r) {
              __CODE{ManakaiNode:getWeakReference||ManakaiDOM:Perl::
                $object => $r, $ref => $r,
                $class => {<ClassName::ManakaiDOMAttr>},
              }__;
              $r = $r-><AG::DOMCore:Node.textContent>;
            } else {
              ## Web browser compatible behavior
              __FOR{ManakaiDOM:DOMLatest::
                $r = null;
              }__;
              ## DOM spec
              __FOR{!ManakaiDOM:DOMLatest::
                $r = '';
              }__;
            }
          @@@@For:
            ManakaiDOM:DOMXMLFeature
        @@@disDef:
          @@@@ForCheck:
            !ManakaiDOM:DOMXMLFeature
          @@@@DOMMain:raiseException:
            MDOMX:MDOM_IMPL_NOSUPPORT_XMLNS
     @@For:
       ManakaiDOM:DOM2
     @@Level[list]:  2
     @@SpecLevel:2
  @Method:
     @@Name:  setAttributeNS
     @@Description:
       @@@lang:en
       @@@@:
         Add a new attribute.  If an attribute with the same 
         local name and namespace URI is already present on the element, 
         its value is changed and its prefix is also changed to be the 
         prefix of the new qualified name. 
     @@NoNSVersion:.setAttribute
     @@Param:
        @@@Name:  namespaceURI
        @@@Type:
           DOMMain:DOMString
        @@@actualType:
          ManakaiDOM:ManakaiDOMNamespaceURI
        @@@Description:
          @@@@lang:en
          @@@@@:
            The namespace URI of the attribute to create or alter.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: 
              The attribute to create or alter has no namespace.
     @@Param:
        @@@Name:  qualifiedName
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:The qualified name of the attribute to create or alter.
     @@Param:
        @@@Name:  value
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The value to set.
     @@Return:
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: INVALID_CHARACTER_ERR
          @@@@SubType:
            @@@@@QName:
              MDOMX:MDOM_BAD_NAME
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <P::qualifiedName> is not an XML <CODE::Name>.
          @@@@SpecLevel:2
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NAMESPACE_ERR
          @@@@SubType:
            @@@@@QName:
              MDOMX:MDOM_NS_MALFORMED_QNAME
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@: 
                The <P::qualifiedName> is malformed as a qualified name.
            @@@@@SpecLevel:2
          @@@@SubType:
            @@@@@QName:
              MDOMX:MDOM_NS_PREFIX_WITH_NULL_URI
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <P::qualifiedName> has a prefix and the
                <P::namespaceURI> is <DOM::null>.
            @@@@@SpecLevel:2
          @@@@SubType:
            @@@@@QName:
              MDOMX:MDOM_NS_XML_WITH_OTHER_URI
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <P::qualifiedName> has a prefix that is <XML::xml> and the
                <P::namespaceURI> is different from
                <URI::http://www.w3.org/XML/1998/namespace>.
            @@@@@SpecLevel:2
          @@@@SubType:
            @@@@@QName:
              MDOMX:MDOM_NS_XMLNS_WITH_OTHER_URI
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <P::qualifiedName> has a prefix that is <XML::xmlns> and
                the <P::namespaceURI> is different from the
                <URI::http://www.w3.org/2000/xmlns>.
            @@@@@SpecLevel:3
          @@@@SubType:
            @@@@@QName:
              MDOMX:MDOM_NS_XMLNSQ_WITH_OTHER_URI
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <P::qualifiedName> is <XA::xmlns> and
                the <P::namespaceURI> is different from the
                <URI::http://www.w3.org/2000/xmlns>.
            @@@@@SpecLevel:2
          @@@@SubType:
            @@@@@QName:
              MDOMX:MDOM_NS_OTHER_WITH_XML_URI
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <P::namespaceURI> is 
                <URI::http://www.w3.org/XML/1998/namespace> and the 
                prefix of the <P::qualifiedName> is different from 
                <XA::xml>.
            @@@@@SpecLevel[list]:
          @@@@SubType:
            @@@@@QName:
              MDOMX:MDOM_NS_OTHER_WITH_XMLNS_URI
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <P::namespaceURI> is <URI::http://www.w3.org/2000/xmlns> and 
                neither the <P::qualifiedName> nor its prefix is <XML::xmlns>.
            @@@@@SpecLevel:3
          @@@@SubType:
            @@@@@QName:
              MDOMX:MDOM_NS_XMLNS_XMLNS
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <P::qualifiedName> is <XA::xmlns:xmlns>.
            @@@@@SpecLevel[list]:
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@: Is no-prefix with URI is OK?
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:NOT_SUPPORTED_ERR
          @@@@SubType:
            @@@@@QName:
              MDOMX:MDOM_DOC_NOSUPPORT_XML
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                This document does not support the <Feature::XML> 
                feature.
            @@@@@SpecLevel:2
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:NO_MODIFICATION_ALLOWED_ERR
          @@@@SubType:
            @@@@@QName:
              MDOMX:NOMOD_THIS
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                This (<IF::Element>) node is read-only.
            @@@@@SpecLevel:2
          @@@@SubType:
            @@@@@QName:
              MDOMX:NOMOD_ATTR
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <IF::Attr> node to edit is read-only.
            @@@@@SpecLevel[list]:
        @@@PerlDef:
          @@@@For:
            ManakaiDOM:DOMXMLFeature
          @@@@@:
            my $docNode = $self->{<H::mn:node>}
                               ->{<H::DOMCore:ownerDocument>};
            my ($prefix, $localName) = split /:/, $qualifiedName, 2;
            ($prefix, $localName) = (null, $prefix) unless defined $localName;

            if (<Code::doStrictErrorChecking:: $nodeRef = $self>) {
              if ($self->{<H::mn:node>}->{<H::DOMCore:read-only>}) {
                __EXCEPTION{MDOMX:NOMOD_THIS::
                }__;
              }
              my $version = <Code::getDocumentXMLVersion:: $DOCOBJ = $docNode>;
              unless (defined $version) {
                __EXCEPTION{MDOMX:MDOM_DOC_NOSUPPORT_XMLNS}__;
              }
              __CODE{DOMMain:ensureXMLQName::
                     $INPUT = $qualifiedName, 
                     $INPUT_PARAM_NAME = 'qualifiedName',
                     $XMLVERSION = $version,
              }__;
              __CODE{DOMMain:checkXMLNamesQName::
                     $PREFIX => $prefix, $NSURI => $namespaceURI,
                     $LNAME => $localName,
              }__;
              ## TODO: Check prefix if nsuri
            }
            __CODE{setAttrValueNS::
              $namespaceURI => $namespaceURI,
              $prefix => $prefix,
              $localName => $localName,
              $element => $self,
              $value => $value,
            }__;
        @@@disDef:
          @@@@ForCheck:
            !ManakaiDOM:DOMXMLFeature
          @@@@DOMMain:raiseException:
            MDOMX:MDOM_IMPL_NOSUPPORT_XMLNS
     @@For:
       ManakaiDOM:DOM2
     @@Level[list]:  2
     @@SpecLevel:2

  @ResourceDef:
    @@QName: c|setAttrValueNS
    @@AliasFor: setAttrValueNS
    @@ForCheck: ManakaiDOM|ForClass

  @ResourceDef:
    @@QName: setAttrValueNS
    @@rdf:type: DISPerl|BlockCode
    @@ForCheck: ManakaiDOM|ForClass
    @@PerlDef:
      my $__r;
      __CODE{selectAttrNodeObjectNS::
        $namespaceURI => $namespaceURI,
        $localName => $localName,
        $r => $__r,
      }__;
      my $__node = $element->{<H::mn:node>};
      if ($__r) {  ## There is already a node for the attribute
        if ($__r->{<H::DOMCore:read-only>}) {
          __EXCEPTION{MDOMX:NOMOD_ATTR::
          }__;
        }
        my @__children = @{$__r->{<H::infoset:children>}};
        $__r->{<H::infoset:children>} = [];
        for (@__children) {
          CORE::delete $_->{<H::infoset:parent>};
          $_-><M::NodeStem.orphanate>;
        }
      } else {     ## There is no node for the attribute yet
        $__r = <ClassM::ManakaiDOMAttr.newObject> ($__node);
        $__r->{<H::infoset:ownerElement>} = $__node;
        __CODE{mn|setXRefNode||ManakaiDOM|Perl::
          $referrer => {$__r},
          $propName => {<H::DOMCore:ownerDocument>},
          $referent => {$__node->{<H::DOMCore:ownerDocument>}},
        }__;
        $__r->{<H::infoset:prefix>} = $prefix if defined $prefix;
        __CODE{DISPerl|HashStringRef||ManakaiDOM|all::
          $result => {$__r->{<H::infoset:namespaceName>}},
          $given => $namespaceURI,
        }__;
        $__r->{<H::infoset:localName>} = $localName;
        $__node->{<H::infoset:attributes>}
               ->{defined $namespaceURI ? $namespaceURI : <Q::null:>}
               ->{$localName} = $__r;

        ## Schema type information
        if (defined $__node->{<H::c|ownerDocument>}->{<H::c|schema-type>}) {
          my $schema_type = $__node->{<H::c|ownerDocument>}
                                   ->{<H::c|schema-type>};
          if ($schema_type eq <Q::xml-dtd:>) {
            __DEEP{
              my $__doctype = $element-><AG::Node.ownerDocument>
                                      -><AG::Document.doctype>;
              $__doctype = $__doctype-><M::Node.getFeature>
                                         (<Q::ManakaiDOM:XDoctype> => '3.0')
                if $__doctype;
              if ($__doctype) {
                my $__et = $__doctype-><M::DTDef.getElementTypeDefinitionNode>
                                         ($element-><AG::Node.nodeName>);
                if ($__et) {
                  my $__at = $__et-><M::ETDef.getAttributeDefinitionNode>
                                (defined $prefix ? $prefix.':'.$localName
                                                 : $localName);
                  if ($__at) {
                    $__r->{<H::infoset:attributeType>}
                            = $__at-><AG::ATDef.declaredType>;
                  }
                }
              }
            }__;
          } # Schema language is XML DTD
        }
      }
      my $__text = <ClassM::ManakaiDOMText.newObject> ($__node);
      __CODE{mn|setXRefNode||ManakaiDOM|Perl::
        $referrer => {$__text},
        $propName => {<H::DOMCore:ownerDocument>},
        $referent => {$__node->{<H::DOMCore:ownerDocument>}},
      }__;
      $__text->{<H::infoset:content>} = defined $value ? $value : '';
      $__text->{<H::infoset:parent>} = $__r;
      $__r->{<H::infoset:children>} = [$__text];
      $__r->{<H::infoset:specified>} = true;

  @L2Method:
     @@Name:  removeAttributeNS
     @@Description:
       @@@lang:en
       @@@@:
         Remove an attribute by local name and namespace URI.
       \
         If a default value for the removed attribute is defined 
         in the DTD, a new attribute is immediately appears. 
         The DOM implementation may handle default values from 
         other schemas.
     @@NoNSVersion:.removeAttribute
     @@Param:
        @@@Name:  namespaceURI
        @@@Type:
          DOMMain:DOMString
        @@@actualType:
          ManakaiDOM:ManakaiDOMNamespaceURI
        @@@Description:
          @@@@lang:en
          @@@@@: The namespace URI of the attribute to remove.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The attribute to remove has no namespace.
     @@Param:
        @@@Name:  localName
        @@@Type:  
          DOMMain:DOMString
        @@@actualType:
          @@@@@:
            DOMMain:ManakaiDOMXMLLocalName
          @@@@ManakaiDOM:noInputNormalize:1
        @@@Description:
          @@@@lang:en
          @@@@@:
            The local name of the attribute to remove.
          \
            If no attribute with this <P::localName> and 
            <P::namespaceURI> is found, this method has no effect.
     @@Return:
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:NO_MODIFICATION_ALLOWED_ERR
          @@@@SubType:
            @@@@@QName:
              MDOMX:NOMOD_THIS
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                This (<IF::Element>) node is read-only.
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:NOT_SUPPORTED_ERR
          @@@@SubType:
            @@@@@QName:
              MDOMX:MDOM_IMPL_NOSUPPORT_XML
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The DOM implementation does not support the feature 
                <Feature::XML> and the language exposed through 
                the <IF::Document> does not support XML Namespaces.
        @@@PerlDef:
          @@@@For:
            ManakaiDOM:DOMXMLFeature
          @@@@@:
          my $list;
          __CODE{selectAttrNodeObjectForRemoveNS::
            $element => $self,
            $namespaceURI => $namespaceURI,
            $localName => $localName,
            $list => $list,
          }__;
          if ($list) {
            if ($self->{<H::mn:node>}->{<H::c|read-only>}) {
              __EXCEPTION{
                MDOMX:NOMOD_THIS::
              }__;
            }
         
            ## Removes the attribute node
            my $stem = $list->{$localName};
            my $pfx = $stem->{<H::infoset:prefix>};
            CORE::delete $list->{$localName};
            CORE::delete $stem->{<H::infoset:ownerElement>};
            $stem-><M::NodeStem.orphanate>;

            ## Default attribute
            my $name = defined $pfx ? $pfx.':'.$localName : $localName;
            my $doc = $self-><AG::Node.ownerDocument>;
            __CODE{t|generateDefaultAttribute::
              $document => $doc,
              $element_type => {$self-><AG::Node.nodeName>},
              $element => $self,
              $name => $name,
            }__;
          } # exists
         @@@@ImplNote:
           @@@@@lang:en
           @@@@@@:
             Almost same as <M::ManakaiDOMAttributes.removeNamedItemNS>.
        @@@disDef:
          @@@@ForCheck:
            !ManakaiDOM:DOMXMLFeature
          @@@@DOMMain:raiseException:
            MDOMX:MDOM_IMPL_NOSUPPORT_XMLNS

    @@Test:
      @@@ForCheck: ManakaiDOM|DOMXMLFeature
      @@@QName: Element.removeAttributeNS.test
      @@@PerlDef:
        my $el;
        __CODE{createElementForTest:: $el => $el}__;

        $test->id ('remove.no.attr');
        $el-><M::Element.removeAttributeNS> (null, 'at1');

        $test->id ('set.attr');
        $el-><M::Element.setAttributeNS> (null, at1 => 'value1');
        my $v1 = $el-><M::Element.getAttributeNS> (null, 'at1');
        $test->assert_equals ($v1, 'value1');

        $test->id ('remove.attr');
        $el-><M::Element.removeAttributeNS> (null, 'at1');
        my $v2 = $el-><M::Element.getAttributeNS> (null, 'at1');
        $test->assert_true (not defined $v2 or $v2 eq '');
    @@Test:
      @@@ForCheck: ManakaiDOM|DOMXMLFeature
      @@@QName: Element.removeAttributeNS.global.test
      @@@PerlDef:
        my $el;
        __CODE{createElementForTest:: $el => $el}__;

        my $uri = 'http://example.com/';
        $test->id ('remove.no.attr');
        $el-><M::Element.removeAttributeNS> ($uri, 'at1');

        $test->id ('set.attr');
        $el-><M::Element.setAttributeNS> ($uri, at1 => 'value1');
        my $v1 = $el-><M::Element.getAttributeNS> ($uri, 'at1');
        $test->assert_equals ($v1, 'value1');

        $test->id ('remove.attr');
        $el-><M::Element.removeAttributeNS> ($uri, 'at1');
        my $v2 = $el-><M::Element.getAttributeNS> ($uri, 'at1');
        $test->assert_true (not defined $v2 or $v2 eq '');
    @@L3Test:
      @@@ForCheck: ManakaiDOM|DOMXMLFeature
      @@@QName: Element.removeAttributeNS.defaultattr.test
      @@@PerlDef:
        my $doc;
        __CODE{createEmptyDocumentForTest:: $doc => $doc}__;
        my $uri = 'http://www.example.com/';
        my $docd = $doc-><M::Node.getFeature> (<Q::ManakaiDOM:XDoctype>, '3.0');
        my $dtd = $docd-><M::d|DocumentXDoctype.createDocumentTypeDefinition>
                           ('doctype');
          my $et = $docd-><M::d|DocumentXDoctype.createElementTypeDefinition>
                             ('et1');
            my $at = $docd-><M::d|DocumentXDoctype.createAttributeDefinition>
                               ('ns1:dattr1');
            $at-><AS::ATDef.defaultType> (<C::ATDef.EXPLICIT_DEFAULT>);
            $at-><AS::Node.textContent> ('dattr1 default ');
          $et-><M::ETDef.setAttributeDefinitionNode> ($at);
            my $at2 = $docd-><M::d|DocumentXDoctype.createAttributeDefinition>
                               ('xmlns:ns1');
            $at2-><AS::ATDef.defaultType> (<C::ATDef.EXPLICIT_DEFAULT>);
            $at2-><AS::Node.textContent> ($uri);
          $et-><M::ETDef.setAttributeDefinitionNode> ($at2);
        $dtd-><M::DTDef.setElementTypeDefinitionNode> ($et);
        $doc-><M::Node.appendChild> ($dtd);

        $test->id ('created.default.value');
        my $el = $doc-><M::Document.createElementNS> ($uri, 'et1');
        $test->assert_equals ($el-><M::Element.getAttributeNS> ($uri, 'dattr1'),
                              'dattr1 default ');
        $test->assert_false ($el-><M::Element.getAttributeNodeNS>
                                    ($uri, 'dattr1')
                                -><AG::Attr.specified>);

        $test->id ('set.attr');
        $el-><M::Element.setAttributeNS>
               ($uri, 'ns1:dattr1', 'non-default-value');
        $test->assert_equals ($el-><M::Element.getAttributeNS> ($uri, 'dattr1'),
                              'non-default-value');
        $test->assert_true ($el-><M::Element.getAttributeNodeNS> ($uri, 'dattr1')
                               -><AG::Attr.specified>);

        $test->id ('remove.attr');
        $el-><M::Element.removeAttributeNS> ($uri, 'dattr1');
        $test->assert_equals ($el-><M::Element.getAttributeNS> ($uri, 'dattr1'),
                              'dattr1 default ');
        $test->assert_false ($el-><M::Element.getAttributeNodeNS>
                                    ($uri, 'dattr1')
                                -><AG::Attr.specified>);

  @Method:
     @@Name:  getAttributeNodeNS
     @@Description:
       @@@lang:en
       @@@@:
         Retrieve an <IF::Attr> node by local name and namespace URI.
     @@NoNSVersion:.getAttributeNode
     @@Param:
        @@@Name:  namespaceURI
        @@@Type:
          DOMMain:DOMString
        @@@actualType:
          ManakaiDOM:ManakaiDOMNamespaceURI
        @@@Description:
          @@@@lang:en
          @@@@@: The namespace URI of the attribute to retrieve.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The attribute to retrieve have no namespace.
     @@Param:
        @@@Name:  localName
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The local name of the attribute to retrieve.
     @@Return:
        @@@Type:  Attr
        @@@Description:
          @@@@lang:en
          @@@@@:
            The <IF::Attr> node.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: There is no such attribute.
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:NOT_SUPPORTED_ERR
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The DOM implementation does not support the feature 
                <Feature::XML> and the language exposed through the 
                <IF::Document> does not support XML Namespaces.
        @@@PerlDef:
          @@@@For:
            ManakaiDOM:DOMXMLFeature
          @@@@@:
            my $obj;
            __CODE{selectAttrNodeObjectNS:: $r => $obj}__;
            if ($obj) {
              $r = <ClassM::ManakaiDOMNode.getNodeReference> ($obj);
            }
        @@@disDef:
          @@@@ForCheck:
            !ManakaiDOM:DOMXMLFeature
          @@@@DOMMain:raiseException:
            MDOMX:MDOM_IMPL_NOSUPPORT_XMLNS
     @@Level[list]:
        2
        3
     @@SpecLevel:2
     @@For:
       ManakaiDOM:DOM2
  @Method:
     @@Name:  setAttributeNodeNS
     @@Description:
       @@@lang:en
       @@@@:
         Add a new attribute.  If an attribute with that local name and 
         namespace URI is already present in the element, 
         it is replaced by the new node.
       \
         Replacing an attribute node by itself has no effect.
     @@NoNSVersion:.setAttributeNS
     @@Param:
        @@@Name:  newAttr
        @@@Type:  Attr
        @@@actualType: ManakaiDOMAttr
        @@@Description:
          @@@@lang:en
          @@@@@:
            The attribute node to add to the attribute list.
     @@Return:
        @@@Type:  Attr
        @@@actualType: ManakaiDOMAttr
        @@@Description:
          @@@@lang:en
          @@@@@:
            The <IF::Attr> node replaced by the <P::newAttr> node.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The <P::newAttr> node replaces no existing node.
         @@@Exception:
           @@@@Name:WRONG_DOCUMENT_ERR
           @@@@Type:DOMException
           @@@@Description:
             @@@@@lang:en
             @@@@@@:
               The <P::newAttr> node was created from a different document.
         @@@Exception:
           @@@@Name:NO_MODIFICATION_ALLOWED_ERR
           @@@@Type:DOMException
           @@@@SubType:
             @@@@@QName: 
               MDOMX:NOMOD_THIS
             @@@@@Description:
               @@@@@@lang:en
               @@@@@@@:
                 This (<IF::Element>) node is read-only.
         @@@Exception:
           @@@@Name:INUSE_ATTRIBUTE_ERR
           @@@@Type:DOMException
           @@@@Description:
             @@@@@lang:en
             @@@@@@:
               The <P::newAttr> node is already used as an attribute 
               of another <IF::Element> object.
         @@@Exception:
           @@@@Name:NOT_SUPPORTED_ERR
           @@@@Type:DOMException
           @@@@SubType:
             @@@@@QName:
               MDOMX:MDOM_IMPL_NOSUPPORT_XML
             @@@@@Description:
               @@@@@@lang:en
               @@@@@@@:
                 The DOM implementation does not support the feature 
                 <Feature::XML> and the language exposed through the 
                 <IF::Document> does not support XML Namespaces.
             @@@@@SpecLevel:2
           @@@@SubType:
             @@@@@QName:
               MDOMX:MDOM_NODE_NOSUPPORT_XMLNS
             @@@@@Description:
               @@@@@@lang:en
               @@@@@@@:
                 The <P::newAttr> node does not support XML Namespace.
             @@@@@SpecLevel[list]:
        @@@c:reports:
          @@@@@: t|replace-by-itself
          @@@@enDesc:
            If the <P::newAttr> node is same as the node already attached
            to the element.  Then, the method is no effect.
          @@@@For: ManakaiDOM|ManakaiDOM
        @@@disDef:
          @@@@For: ManakaiDOM|DOMXMLFeature
          @@@@DISPerl:cloneCode: .setAttributeNode
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              It is unclear whether the node should be returned if 
              the node is <QUOTE::replaced> by itself.
        @@@disDef:
          @@@@ForCheck:
            !ManakaiDOM:DOMXMLFeature
          @@@@DOMMain:raiseException:
            MDOMX:MDOM_IMPL_NOSUPPORT_XMLNS
     @@Level[list]:  
        2
        3
     @@SpecLevel:2
     @@For:
       ManakaiDOM:DOM2
  @Method:
     @@Name:  getElementsByTagNameNS
     @@Description: 
       @@@lang:en
       @@@@:
         Return a <IF::NodeList> of all the descendant <IF::Element> nodes 
         with a given local name and namespace URI pair in the document 
         order.
     @@Param:
        @@@Name:  namespaceURI
        @@@Type:  
          DOMMain:DOMString
        @@@actualType:
          ManakaiDOM:ManakaiDOMNamespaceURI
        @@@Description:
          @@@@lang:en
          @@@@@:
            The namespace URI of the elements to match on.
        @@@InCase:
          @@@@Value:*
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Mathch all namespaces.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
     @@Param:
        @@@Name:  localName
        @@@Type:  
          DOMMain:DOMString
        @@@actualType:
          @@@@@:
            DOMMain:ManakaiDOMXMLLocalName
          @@@@ManakaiDOM:noInputNormalize:1
        @@@Description:
          @@@@lang:en
          @@@@@:
            The local name of the elements to match on.
        @@@InCase:
          @@@@Value:*
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Match all local names.
     @@Return:
        @@@Type:  NodeList
        @@@actualType:
          ManakaiDOMCore:ManakaiDOMGetElementsNodeList
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:NOT_SUPPORTED_ERR
          @@@@SubType:
            @@@@@QName:
              MDOMX:MDOM_IMPL_NOSUPPORT_XML
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The DOM implementation does not support the 
                <Feature::XML> feature and the language exposed 
                through the <IF::Document> does not support XML 
                Namespaces.
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              The <CITE::DOM Level 2 Core Specification> was stated 
              that HTML-only DOM implementations were not required 
              to implement this method.  Its Errata and the 
              <CITE::DOM Level 3 Core Specification> ammend it to 
              throw an exception.
        @@@Description:
          @@@@lang:en
          @@@@@:
            A new <IF::NodeList> object containing all the matched 
            <IF::Element> nodes.
        @@@PerlDef:
          @@@@For:
            ManakaiDOM:DOMXMLFeature
          @@@@@:
            my $node = $self->{<H::mn:node>};
            my $chk;
            if (defined $namespaceURI) {
              if ($namespaceURI eq '*') {
                if (defined $localName and $localName eq '*') {
                  $chk = sub {
                    my ($self) = @_;
                    return defined $self->{<H::infoset:localName>}
                             ? true : false;
                      ## Any element node with local name
                  };
                } else {
                  $localName = "$localName";
                  $chk = sub {
                    my ($self) = @_;
                    return
                        (defined $self->{<H::infoset:localName>} and
                         $self->{<H::infoset:localName>} eq $localName)
                           ? true : false;
                  };
                }
              } else { ## Non-n u l l namespace URI
                $namespaceURI = "$namespaceURI";
                if (defined $localName and $localName eq '*') {
                  $chk = sub {
                    my ($self) = @_;
                    return (defined $self->{<H::infoset:namespaceName>} and
                            ${$self->{<H::infoset:namespaceName>}} eq $namespaceURI)
                              ? true : false;
                  };
                } else {
                  $localName = "$localName";
                  $chk = sub {
                    my ($self) = @_;
                    return
                        (defined $self->{<H::infoset:localName>} and
                         defined $self->{<H::infoset:namespaceName>} and
                         ${$self->{<H::infoset:namespaceName>}} eq $namespaceURI and
                         $self->{<H::infoset:localName>} eq $localName)
                           ? true : false;
                  };
                }
              }
            } else { ## Null namespace
              if (defined $localName and $localName eq '*') {
                $chk = sub {
                  my ($self) = @_;
                  return (defined $self->{<H::infoset:localName>} and
                          not defined $self->{<H::infoset:namespaceName>})
                            ? true : false;
                    ## Any element node with local name but not namespace URI
                };
              } else {
                $localName = "$localName";
                $chk = sub {
                  my ($self) = @_;
                  return
                      (defined $self->{<H::infoset:localName>} and
                       not defined $self->{<H::infoset:namespaceName>} and
                       $self->{<H::infoset:localName>} eq $localName)
                         ? true : false;
                };
              }
            }
            __CODE{getNodeRef::
              $object => $node, $ref => $r,
              $class => {
                <ClassName::ManakaiDOMCore:ManakaiDOMGetElementsNodeList>
              },
            }__;
            $r->{<H::ManakaiDOMCore:nodeMatch>} = $chk;
        @@@disDef:
          @@@@ForCheck:
            !ManakaiDOM:DOMXMLFeature
          @@@@DOMMain:raiseException:
            MDOMX:MDOM_IMPL_NOSUPPORT_XMLNS
     @@Level[list]:  
       2
       3
     @@SpecLevel:2
     @@For:
       ManakaiDOM:DOM2
     @@NoNSVersion:.getElementsByTagName
  @Method:
     @@Name:  hasAttribute
     @@Description:
       @@@lang:en
       @@@@:
         Whether an attribute with the given name is specified on 
         this element or has a default value.
     @@NSVersion:.hasAttributeNS
     @@Param:
        @@@Name:  name
        @@@Type:  
          DOMMain:DOMString
        @@@actualType:
          @@@@@:
            DOMMain:ManakaiDOMXMLName
          @@@@ManakaiDOM:noInputNormalize:1
        @@Description:
          @@@lang:en
          @@@@: The name of the attribute to look for.
     @@Return:
        @@@Type:  DOMMain|boolean||ManakaiDOM|all
        @@@InCase:
          @@@@Value:true
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              An attribute with the given name is specified on 
              this element or has a default value.
        @@@InCase:
          @@@@Value:false
          @@@@Description:
            @@@@@lang:en
            @@@@@@: 
              There is no such attribute.
        @@@PerlDef:
            __CODE{selectAttrNodeObject}__;
            $r = true if $r;
     @@Level[list]:  2
     @@SpecLevel:2
     @@For:
       ManakaiDOM:DOM2
  @Method:
     @@Name:  hasAttributeNS
     @@Description:
       @@@lang:en
       @@@@:
         Whether an attribute with a given local name and namespace URI 
         is specified on this element or has a default value.
     @@NoNSVersion:.hasAttribute
     @@Param:
        @@@Name:  namespaceURI
        @@@Type: 
          DOMMain:DOMString
        @@@actualType:
          ManakaiDOM:ManakaiDOMNamespaceURI
        @@@Description:
          @@@@lang:en
          @@@@@: The namespace URI of the attribute to look for.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The attribute to look for has no namespace.
     @@Param:
        @@@Name:  localName
        @@@Type:  
          DOMMain:DOMString
        @@@actualType:
          @@@@@:
            DOMMain:ManakaiDOMXMLLocalName
          @@@@ManakaiDOM:noInputNormalize:1
        @@@Description:
          @@@@lang:en
          @@@@@: The local name of the attribute to look for.
     @@Return:
        @@@Type:  DOMMain|boolean||ManakaiDOM|all
        @@@InCase:
          @@@@Value:true
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              An attribute with given local name and namespace URI is 
              specified or has a default value on this element.
        @@@InCase:
          @@@@Value:false
          @@@@Description:
            @@@@@lang:en
            @@@@@@: There is no such attribute.
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:NOT_SUPPORTED_ERR
          @@@@SubType:
            @@@@@QName:
              MDOMX:MDOM_IMPL_NOSUPPORT_XML
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The DOM implementation does not support the feature 
                <Feature::XML> and the language exposed through the 
                <IF::Document> does not support XML Namespaces.
        @@@PerlDef:
          @@@@For:
            ManakaiDOM:DOMXMLFeature
          @@@@@:
            __CODE{selectAttrNodeObjectNS}__;
            $r = $r ? true : false;
        @@@disDef:
          @@@@ForCheck:
            !ManakaiDOM:DOMXMLFeature
          @@@@DOMMain:raiseException:
            MDOMX:MDOM_IMPL_NOSUPPORT_XMLNS
     @@Level[list]:  2
     @@SpecLevel:2
     @@For:
       ManakaiDOM:DOM2

  @L3Attr:
    @@Name: schemaTypeInfo
    @@enDesc:
      The type information associated with the element.
    @@enImplNote:
      Currently manakai does not support XML Schema, so it is 
      always a no-type <IF::c|TypeInfo>.  It is expected that
      a future version of the implementation will return an
      element type definition node that also implement the
      <IF::c|TypeInfo> interface when the schema language is XML DTD.
    @@Type: c|TypeInfo
    @@Get:
      @@@PerlDef:
        __CODE{c|createDTDTypeInfo::
          $result => $r,
          $type => {0},
        }__;
    @@L3Test:
      @@@QName: Element.schemaTypeInfo.no-schema.test
      @@@PerlDef:
        my $el;
        __CODE{createElementForTest:: $el => $el}__;
        $el-><AG::Node.ownerDocument>
           -><AG::Document.domConfig>
           -><M::c|DOMConfiguration.setParameter>
               ('schema-type' => q[http://dummy.example/]);

        my $sti = $el-><AG::Element.schemaTypeInfo>;
        $test->assert_isa ($sti, <IFName::c|TypeInfo>);
        $test->assert_null ($sti-><AG::c|TypeInfo.typeName>);
        $test->assert_null ($sti-><AG::c|TypeInfo.typeNamespace>);
    @@L3Test:
      @@@QName: Element.schemaTypeInfo.dtd.test
      @@@PerlDef:
        my $el;
        __CODE{createElementForTest:: $el => $el}__;
        $el-><AG::Node.ownerDocument>
           -><AG::Document.domConfig>
           -><M::c|DOMConfiguration.setParameter>
               ('schema-type' => <Q::xml-dtd:>);

        my $sti = $el-><AG::Element.schemaTypeInfo>;
        $test->assert_isa ($sti, <IFName::c|TypeInfo>);
        $test->assert_null ($sti-><AG::c|TypeInfo.typeName>);
        $test->assert_null ($sti-><AG::c|TypeInfo.typeNamespace>);

  @Method:
     @@Name:  setIdAttribute
     @@Description:
       @@@lang:en
       @@@@:
         Set whether an attribute is a user-determined ID attribute or not.
       \
         Note that this does not affect any schema that may be 
         in use.  Whether this attribute is a DTD-, Schema- or 
         externally-determined ID attribute is unable to change by 
         this method.
     @@NSVersion:.setIdAttributeNS
     @@Param:
        @@@Name:  name
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The name of the attribute.
     @@Param:
        @@@Name:  isId
        @@@Type:  DOMMain|boolean||ManakaiDOM|all
        @@@Description:
          @@@@lang:en
          @@@@@:
            Whether the attribtue is a user-determined ID attribute.
        @@@InCase:
          @@@@Value:true
          @@@@Description:
            @@@@@lang:en
            @@@@@@: 
              Declare the attribute to be a user-determined ID attribute.
        @@@InCase:
          @@@@Value:false
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Undeclare the attribute for being a user-determined ID attribute.
     @@Return:
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:NO_MODIFICATION_ALLOWED_ERR
          @@@@SubType:
            @@@@@QName:
              MDOMX:NOMOD_THIS
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                This (<IF::Element>) node is read-only.
            @@@@@SpecLevel:3
          @@@@SubType:
            @@@@@QName:
              MDOMX:NOMOD_ATTR
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The attribute node is read-only.
            @@@@@SpecLevel[list]:
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              Is <QUOTE::user-determined ID> a property of the 
              <IF::Attr> or of the <IF::Element>?
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:NOT_FOUND_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              There is no such attribute.
        @@@PerlDef:
            if ($self->{<H::mn:node>}->{<H::DOMCore:read-only>}) {
              __EXCEPTION{
                MDOMX:NOMOD_THIS::
              }__;
            }
            my $r;
            __CODE{selectAttrNodeObject}__;
            unless ($r) {
              __EXCEPTION{DOMException.NOT_FOUND_ERR::
              }__;
            }
            if ($r->{<H::DOMCore:read-only>}) {
              __EXCEPTION{
                MDOMX:NOMOD_ATTR::
              }__;
            }
            $r->{<H::DOMCore:userDeterminedId>} = $isId;
     @@L3:
     @@Level[list]:  3
     @@SpecLevel:3
     @@For:
       ManakaiDOM:DOM3
  @Method:
     @@Name:  setIdAttributeNS
     @@Description:
       @@@lang:en
       @@@@:
         Set whether an attribute is a user-determined ID attribute or not.
       \
         Note that this does not affect any schema that may be 
         in use.  Whether this attribute is a DTD-, Schema- or 
         externally-determined ID attribute is unable to change by 
         this method.
     @@NoNSVersion:.setIdAttribute
     @@Param:
        @@@Name:  namespaceURI
        @@@Type: 
          DOMMain:DOMString
        @@@actualType:
          ManakaiDOM:ManakaiDOMNamespaceURI
        @@@Description:
          @@@@lang:en
          @@@@@: The namespace URI of the attribute.
     @@Param:
        @@@Name:  localName
        @@@Type:  
          DOMMain:DOMString
        @@@actualType:
          @@@@@:
            DOMMain:ManakaiDOMXMLLocalName
          @@@@ManakaiDOM:noInputNormalize:1
        @@@Description:
          @@@@lang:en
          @@@@@: The local name of the attribute.
     @@Param:
        @@@Name:  isId
        @@@Type:  DOMMain|boolean||ManakaiDOM|all
        @@@Description:
          @@@@lang:en
          @@@@@:
            Whether the attribtue is a user-determined ID attribute.
        @@@InCase:
          @@@@Value:true
          @@@@Description:
            @@@@@lang:en
            @@@@@@: 
              Declare the attribute to be a user-determined ID attribute.
        @@@InCase:
          @@@@Value:false
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Undeclare the attribute for being a user-determined ID attribute.
     @@Return:
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:NO_MODIFICATION_ALLOWED_ERR
          @@@@SubType:
            @@@@@QName:
              MDOMX:NOMOD_THIS
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                This (<IF::Element>) node is read-only.
            @@@@@SpecLevel:3
          @@@@SubType:
            @@@@@QName:
              MDOMX:NOMOD_ATTR
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The attribute node is read-only.
            @@@@@SpecLevel[list]:
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              Is <QUOTE::user-determined ID> a property of the 
              <IF::Attr> or of the <IF::Element>?
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:NOT_FOUND_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              There is no such attribute.
        @@@PerlDef:
          @@@@For:
            ManakaiDOM:DOMXMLFeature
          @@@@@:
            if ($self->{<H::mn:node>}->{<H::DOMCore:read-only>}) {
              __EXCEPTION{
                MDOMX:NOMOD_THIS::
              }__;
            }
            my $r;
            __CODE{selectAttrNodeObjectNS}__;
            unless ($r) {
              __EXCEPTION{DOMException.NOT_FOUND_ERR::
              }__;
            }
            if ($r->{<H::DOMCore:read-only>}) {
              __EXCEPTION{
                MDOMX:NOMOD_ATTR::
              }__;
            }
            $r->{<H::DOMCore:userDeterminedId>} = $isId;
        @@@disDef:
          @@@@ForCheck:
            !ManakaiDOM:DOMXMLFeature
          @@@@DOMMain:raiseException:
            MDOMX:MDOM_IMPL_NOSUPPORT_XMLNS
     @@L3:
     @@Level[list]:  3
     @@SpecLevel:3
     @@For:
       ManakaiDOM:DOM3
  @Method:
     @@Name:  setIdAttributeNode
     @@Description:
       @@@lang:en
       @@@@:
         Set whether an attribute is a user-determined ID attribute or not.
       \
         Note that this does not affect any schema that may be 
         in use.  Whether this attribute is a DTD-, Schema- or 
         externally-determined ID attribute is unable to change by 
         this method.
     @@Param:
        @@@Name:  idAttr
        @@@Type:  Attr
        @@@actualType: ManakaiDOMAttr
        @@@Description:
          @@@@lang:en
          @@@@@: The attribute node.
     @@Param:
        @@@Name:  isId
        @@@Type:  DOMMain|boolean||ManakaiDOM|all
        @@@Description:
          @@@@lang:en
          @@@@@:
            Whether the attribtue is a user-determined ID attribute.
        @@@InCase:
          @@@@Value:true
          @@@@Description:
            @@@@@lang:en
            @@@@@@: 
              Declare the attribute to be a user-determined ID attribute.
        @@@InCase:
          @@@@Value:false
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Undeclare the attribute for being a user-determined ID attribute.
     @@Return:
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:NO_MODIFICATION_ALLOWED_ERR
          @@@@SubType:
            @@@@@QName:
              MDOMX:NOMOD_THIS
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                This (<IF::Element>) node is read-only.
            @@@@@SpecLevel:3
          @@@@SubType:
            @@@@@QName:
              MDOMX:NOMOD_ATTR
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The attribute node is read-only.
            @@@@@SpecLevel[list]:
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              Is <QUOTE::user-determined ID> a property of the 
              <IF::Attr> or of the <IF::Element>?
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:NOT_FOUND_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The <P::idAttr> is not an attribute of this element.
        @@@PerlDef:
            if ($self->{<H::mn:node>}->{<H::DOMCore:read-only>}) {
              __EXCEPTION{
                MDOMX:NOMOD_THIS::
              }__;
            }
            unless ($idAttr->{<H::mn:node>}->{<H::infoset:ownerElement>} and
                    $idAttr->{<H::mn:node>}->{<H::infoset:ownerElement>}
                           ->{<H::mn:nodeID>} eq
                    $self->{<H::mn:node>}->{<H::mn:nodeID>}) {
              __EXCEPTION{DOMException.NOT_FOUND_ERR::
              }__;
            }
            if ($idAttr->{<H::mn:node>}->{<H::DOMCore:read-only>}) {
              __EXCEPTION{
                MDOMX:NOMOD_ATTR::
              }__;
            }
            $idAttr->{<H::mn:node>}
                   ->{<H::DOMCore:userDeterminedId>} = $isId;
     @@L3:
     @@Level[list]:  3
     @@SpecLevel:3
     @@For:
       ManakaiDOM:DOM3
  @Method:
    @@Name: normalize
    @@Description:
      @@@lang:en
      @@@@:
         Puts all <IF::Text> nodes in the full depth of the sub-tree 
         underneath this <IF::Node>, including attribute nodes 
         attaced to the <IF::Element>, 
         into a <QUOTE::normal> form where only structure separates 
         <IF::Text> nodes, i.e. there are neither adjacent <IF::Text> 
         nodes nor empty <IF::Text> nodes. 

      Although the <IF::DOMXML:CDATASection> interface implements the
      <IF::Text> interface, the <M::Node.normalize> method does 
      not merge adjacent <IF::DOMXML:CDATASection> nodes.
    @@ImplNote:
      @@@lang:en
      @@@@:
        DOM level 2 and 3 defines <M::Node.normalize> instead 
        of <M::Element::ManakaiDOM|ManakaiDOM1.normalize>. 
    @@f:implements: c|CoreFeature10
    @@ForCheck: ManakaiDOM|ForIF ManakaiDOM|DOM1 !ManakaiDOM|DOM2
    @@Return:
       @@@Exception:
         @@@@@:
           MDOMX:NOMOD_THIS
         @@@@Description:
           @@@@@lang:en
           @@@@@@:
             This node is read-only. 
         @@@@For:
           ManakaiDOM:ManakaiDOM
       @@@Exception:
         @@@@@: c|NOMOD_DESCENDANT_ERR
         @@@@Description:
           @@@@@lang:en
           @@@@@@:
             One of descendant (or attribute) is read-only. 
        @@@@For:
          ManakaiDOM:ManakaiDOM
  
  @ReAttr:
    @@Name: attributes
    @@Description:
      @@@lang:en
      @@@@:
        A node map containing the attributes of this node.
    @@Get:
      @@@Type: NamedNodeMap
      @@@actualType:
        ManakaiDOMCore:ManakaiDOMAttributes
      @@@Description:
        @@@@lang:en
        @@@@@:
          A <IF::NamedNodeMap> object.
      @@@PerlDef:
        __CODE{t|getAttrMap::
          $node => $self,
          $map => $r,
        }__;
    @@Test:
      @@@QName: Element.attributes.test
      @@@PerlDef:
        my $el;
        __CODE{createElementForTest}__;
        
        my $as = $el-><AG::Node.attributes>;
        $test->assert_isa ($as, <IFName::NamedNodeMap>);

        $el-><M::Element.setAttribute> (at1 => 'value');
        $test->assert_equals 
                 ($as-><M::NamedNodeMap.getNamedItem> ('at1'),
                  $el-><M::Element.getAttributeNode> ('at1'));

  @ReAttr:
    @@Name:baseURI
    @@Description:
      @@@lang:en
      @@@@:
        The base URI of this element.
    @@Get:
      @@@Type:
        DOMMain:DOMString
      @@@actualType:
        ManakaiDOM:ManakaiDOMURI
      @@@Description:
        @@@@lang:en
        @@@@@: The base URI.
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The DOM implementation is unable to obtain an absolute URI.
      @@@PerlDef:
          if ($self->{<H::mn:node>}->{<H::DOMCore:hasFeature>}->{HTML}) {
            $r = $self->{<H::mn:node>}
                      -><M::ManakaiDOMCore:ManakaiDOMNodeObjectNode
                                   .htmlBaseURI>;
          } else {
            $r = $self->{<H::mn:node>}
                      -><M::ManakaiDOMCore:ManakaiDOMNodeObjectNode
                                   .contentBaseURI> (false);
          }
       @@@ImplNote:
         @@@@lang:en
         @@@@@:
           If a document has both a <HE::base> element and 
           an <XA::xml:base> attribute, or even in the case that 
           an XHTML 1 document has an <XA::xml:base> attribute, 
           its result is not defined by any W3C specification.
    @@SpecLevel:3
    @@Level[list]:3
    @@For:
      ManakaiDOM:DOM3
    @@L3:
  @ReAttr:
     @@Name:  localName
     @@Description:
       @@@lang:en
       @@@@: The local part of the qualified name of this "Element" node.
     @@DOMMain:isNamespaceAware:1
     @@Get:
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            The local name of the element type.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The node is created with a DOM Level 1 methods.
        @@@disDef:
          @@@@GetProp:
            infoset:localName
     @@Level[list]:  2
     @@SpecLevel:2
     @@For:
       ManakaiDOM:DOM2
     @@L2:
  @ReMethod:
     @@Name:  lookupPrefix
     @@Description:
       @@@lang:en
       @@@@:
         Lookup the namespace prefix associated to the given namespace 
         URI, starting from this node.
       \
         The default namespace declarations are ignored by this method. 
         To lookup default namespace, use the <M::Node.isDefaultNamespace>
         method.
     @@DOMMain:isNamespaceAware:1
     @@Param:
        @@@Name:  namespaceURI
        @@@Type:
          DOMMain:DOMString
        @@@actualType:
          ManakaiDOM:ManakaiDOMNamespaceURI
        @@@Description:
          @@@@lang:en
          @@@@@: The namespace URI to look for.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Always <DOM::null> will be returned.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Always <DOM::null> will be returned.
     @@Return:
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            An associated namespace prefix.
          \
            If more than one prefix are associated to the 
            namespace URI, which is returned is implementation 
            dependent.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              No namespace prefix is found.
        @@@PerlDef:
            if (not defined $namespaceURI) {
              $r = null;
            } else {
              my $n = $self->{<H::mn:node>};
              __DEEP{
                $r = $n-><M::ManakaiDOMCore:ManakaiDOMNodeObjectNode
                                .lookupNamespacePrefix>
                                                 ($namespaceURI, $n);
              }__;
            }
     @@Level[list]:  3
     @@SpecLevel:3
     @@For:
       ManakaiDOM:DOM3
     @@L3:
  @ReAttr:
     @@Name:  namespaceURI
     @@Description:
       @@@lang:en
       @@@@:
         The namespace URI of this node.
     @@DOMMain:isNamespaceAware:1
     @@Get:
        @@@Type:
          DOMMain:DOMString
        @@@actualType:
          ManakaiDOM:ManakaiDOMNamespaceURI
        @@@Description:
          @@@@lang:en
          @@@@@: The namespace URI.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The namespace URI is unspecified (the "null" namespace) or 
              the node is created with a DOM Level 1 methods.
        @@@PerlDef:
          $r = defined $self->{<H::mn:node>}->{<H::infoset:namespaceName>}
             ? ${$self->{<H::mn:node>}->{<H::infoset:namespaceName>}} : null;
     @@Level[list]:  2
     @@SpecLevel:2
     @@For:
       ManakaiDOM:DOM2
     @@L2:
  @ReAttr:
    @@Name: nodeName
    @@Description:
      @@@lang:en
      @@@@: The node name.
    @@DOMMain:isNamespaceUnaware:1
    @@L1:
    @@Get:
      @@@Type: 
        DOMMain:DOMString
      @@@Description:
        @@@@lang:en
        @@@@@: The element type name, i.e. same as "tagName" attribute.
      @@@disDef:
        @@@@DISPerl:cloneCode:.tagName.get
  @ReAttr:
    @@Name: nodeType
    @@Description:
      @@@lang:en
      @@@@: The type of this node.
    @@L1:
    @@Get:
      @@@Type: 
        DOMMain:unsigned-short||ManakaiDOM|all
      @@@actualType: NodeType
      @@@InCase:
        @@@@Label: ELEMENT_NODE
        @@@@Description:
          @@@@@lang:en
          @@@@@@: The node is an "Element".
      @@@disDef:
        @@@@DISLang:constValue: Node.ELEMENT_NODE
  @ReAttr:
     @@Name:  prefix
     @@Description:
       @@@lang:en
       @@@@: The namespace prefix of this node.
     @@DOMMain:isNamespaceAware:1
     @@Get:
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The namespace prefix.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Either the namespace prefix is unspecified or the node 
              is created with a DOM Level 1 method.
        @@@disDef:
          @@@@GetProp:
            infoset:prefix
     @@Set:
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            The namespace prefix.
            Note that setting this attribute has no effect if 
            the namespace prefix is defined to be "null".
        @@@ImplNote:
          @@@@lang:en
          @@@@@:
            It is unclear whether the default attribute should be 
            added or deleted as the DTD declares.  The DOM Level 2 
            and 3 specifications mentions that changing of the 
            attribute name prefix does not make the default 
            attribute supplied, since the namespace URI does not change.
            This logic might be applied to the element node.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The namespace prefix is unspecified.
        @@@InCase:
          @@@@Value: \
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The result is implementation dependent in DOM Level 3.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: INVALID_CHARACTER_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The specified prefix contains an illegal character 
              accoding to the XML version in use in the document.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: This node is read-only.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NAMESPACE_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Either the specified prefix is malformed per the 
              XML Namespace specification, non-"null" prefix is 
              specified but the "namespaceURI" of this node is "null" or 
              the specified prefix is "xml" and the "namespaceURI" 
              of this node is different from 
              "http://www.w3.org/XML/1998/namespace".
        @@@c:reports:
          @@@@@: t|setting-prefix-no-effect-because-of-document
          @@@@enDesc:
            If the the document does not support XML namespace
            so that setting the attribute value has no effect.
          @@@@For: ManakaiDOM|ManakaiDOM
        @@@c:reports:
          @@@@@: t|setting-prefix-no-effect-because-of-node
          @@@@enDesc:
            If the the node does not support XML namespace
            so that setting the attribute value has no effect.
          @@@@For: ManakaiDOM|ManakaiDOM
        @@@PerlDef:
            my $node = $self->{<H::mn:node>};
            my $docNode = $node->{<H::DOMCore:ownerDocument>};
            my $version = <Code::getDocumentXMLVersion:: $DOCOBJ = $docNode>;
            if (not defined $version) {
              __c:ERROR{t|setting-prefix-no-effect-because-of-document::
                c:relatedData => {$self},
              }__;
            } elsif (not defined $node->{<H::infoset:localName>}) {
              __c:ERROR{t|setting-prefix-no-effect-because-of-node::
                c:relatedData => {$self},
              }__;
            } elsif ($node->{<H::DOMCore:read-only>}) {
              __EXCEPTION{MDOMX:NOMOD_THIS}__;
            } else {
              __CODE{DOMMain:ensureNamespacePrefix::
                $INPUT => $given, $INPUT_PARAM_NAME => '',
                $XMLVERSION => $version,
              }__;
              my $nsURI = $node->{<H::infoset:namespaceName>};
              if (not defined $given) {
                if (not defined $nsURI) {
                  #
                } elsif ($$nsURI eq <Q::xml:>) {
                  __EXCEPTION{MDOMX:MDOM_NS_OTHER_WITH_XML_URI::
                    infoset:prefix => {null},
                    infoset:namespaceName => {$$nsURI},
                  }__;
                } elsif ($$nsURI eq <Q::xmlns:>) {
                  __EXCEPTION{MDOMX:MDOM_NS_OTHER_WITH_XMLNS_URI::
                    infoset:prefix => {null},
                    infoset:namespaceName => {$$nsURI},
                  }__;
                }
              } else {
                if (not defined $nsURI) {
                  __EXCEPTION{
                    MDOMX:MDOM_NS_PREFIX_WITH_NULL_URI::
                      infoset:prefix => {$given},
                  }__;
                } elsif ($given eq 'xml' and $$nsURI ne <Q::xml:>) {
                  __EXCEPTION{
                    MDOMX:MDOM_NS_XML_WITH_OTHER_URI::
                      infoset:prefix => {$given},
                      infoset:namespaceName => {$$nsURI},
                  }__;
                } elsif ($given eq 'xmlns' and $$nsURI ne <Q::xmlns:>) {
                  __EXCEPTION{
                    MDOMX:MDOM_NS_XMLNS_WITH_OTHER_URI::
                      infoset:prefix => {$given},
                      infoset:namespaceName => {$$nsURI},
                  }__;
                } elsif ($$nsURI eq <Q::xml:> and $given ne 'xml') {
                  __EXCEPTION{MDOMX:MDOM_NS_OTHER_WITH_XML_URI::
                    infoset:prefix => {$given},
                    infoset:namespaceName => {$$nsURI},
                  }__;
                } elsif ($$nsURI eq <Q::xmlns:> and $given ne 'xmlns') {
                  __EXCEPTION{MDOMX:MDOM_NS_OTHER_WITH_XMLNS_URI::
                    infoset:prefix => {$given},
                    infoset:namespaceName => {$$nsURI},
                  }__;
                }
              }
              $node->{<H::infoset:prefix>} = $given;
            }
     @@Level[list]:
       2
       3
     @@SpecLevel:2
     @@For:
       ManakaiDOM:DOM2
     @@L2:
  
  @IntMethod:
    @@Name: newObject
    @@Description:
      @@@lang:en
      @@@@:
        Construct an object for a new instance of the <IF::Element> node.
    @@NewObjectRefNodeParam:
    @@Return:
      @@@Type: NodeStem
      @@@Description:
        @@@@lang:en
        @@@@@:
          The new object for the <IF::Element> node.
      @@@PerlDef:
        $r = <ClassM::ManakaiDOMNode.newObject> ($self, $refNode);
        $r->{<H::infoset:attributes>} = {};
        $r->{<H::infoset:children>} = [];
        $r->{<H::DOMCore:nodeType>} = <H::infoset:Element>;
     @@ImplNote:
       @@@lang:en
       @@@@:
         Other properties required to be a legal <IF::Element> object:
         Either <Q::DOMCore:name> or <Q::infoset:localName>, 
         <Q::DOMCore:ownerDocument>.
       \
         Other available properties: <Q::infoset:prefix>, 
         <Q::DOMCore:read-only>, <Q::infoset:parent>, <Q::infoset:children>, 
         <Q::infoset:attributes>, <Q::infoset:namespaceName>.

  @mn:xrefnode0: DOMCore|ownerDocument
  @mn:origin0: infoset|parent
  @mn:subnode2: infoset|attributes
  @mn:subnode1: infoset|children

  @Method:
     @@Name:  getFeature
     @@enDesc:
       Returns a specialized object that implements the
       specialized interfaces of the specified feature and version.
     @@ManakaiDOM:isRedefining:1
     @@ForCheck: ManakaiDOM|ForClass ManakaiDOM|DOM3
     @@Param:
        @@@Name:  feature
        @@@Type:  
          DOMMain:DOMString
        @@@actualType: ManakaiDOM|ManakaiDOMFeatureName
        @@@enDesc:
          The feature name to request.
        @@@InCase:
          @@@@Label:
            @@@@@lang:en
            @@@@@@: 
              Feature name preceded by a <CHAR::PLUS SIGN>
          @@@@enDesc:
            The <CHAR::PLUS SIGN> is ignored.
     @@Param:
        @@@Name:  version
        @@@Type:  
          DOMMain:DOMString
        @@@actualType: ManakaiDOM|ManakaiDOMFeatureVersion
        @@@enDesc:
          The feature version to request.
        @@@nullCase:
          @@@@enDesc:
            No specific version is requested.
     @@Return:
        @@@Type:  
          DOMMain:DOMObject
        @@@enDesc:
          An object implementing the specialized interfaces.
          Note that the specialized object may or may not
          implement the <IF::Node> interface.
        @@@nullCase:
          @@@@enDesc:
            There is no object available that implements
            the specialized interfaces.
        @@@PerlDef:
            $feature =~ s/^\+//;
            if ($Message::DOM::ClassFeature{ref $self}->{$feature}->{$version}) {
              ## This class
              $r = $self;
            } else {
              ## Element type dependent classes
              my $object = $self->{<H::mn:node>};
              my $ns;
              my $ln;
              if (defined $object->{<H::infoset:localName>}) { ## Namespace-aware
                $ns = $object->{<H::infoset:namespaceName>};
                $ns = \'' unless defined $ns;
                $ln = $object->{<H::infoset:localName>};
              } elsif ($object->{<H::DOMCore:ownerDocument>}
                              ->{<H::DOMCore:hasFeature>}->{HTML}) {
                $ns = \<Q::xhtml1:>;
                $ln = lc $object->{<H::DOMCore:name>};
              }
              if (defined $ln) {
                for my $pack ((sort {
                  $Message::DOM::ClassPoint{$b} <=> $Message::DOM::ClassPoint{$a}
                } grep {
                  $Message::DOM::ManakaiDOMElement::CompatClassET{$$ns}
                          ->{$ln}->{$_}
                } keys %{$Message::DOM::ManakaiDOMElement::CompatClassET{$$ns}
                                 ->{$ln}}),
                (sort {
                  $Message::DOM::ClassPoint{$b} <=> $Message::DOM::ClassPoint{$a}
                } grep {
                  $Message::DOM::ManakaiDOMElement::CompatClassET{$$ns}
                          ->{'*'}->{$_}
                } keys %{$Message::DOM::ManakaiDOMElement::CompatClassET{$$ns}
                                 ->{'*'}})) {
                  if ($Message::DOM::ClassFeature{$pack}
                            ->{$feature}->{$version}) {
                    __CODE{getNodeRef::
                      $object => {$self->{<H::mn:node>}},
                      $ref => $r,
                      $class => $pack,
                    }__;
                    last CLASS;
                  }
                }
              }

              ## Element type independent classes
              CLASS: for my $class (grep {
                $Message::DOM::ManakaiDOMElement::CompatClass{$_}
              } keys %Message::DOM::ManakaiDOMElement::CompatClass) {
                if ($Message::DOM::ClassFeature{$class}
                            ->{$feature}->{$version}) {
                  __CODE{getNodeRef::
                    $object => {$self->{<H::mn:node>}},
                    $ref => $r,
                    $class => $class,
                  }__;
                  last CLASS;
                }
              }
            }
##Element

ElementTypeBinding:
  @Name: TrueCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:InCase
    @@Value:
      @@@@: 1
      @@@ContentType: DISCore|Boolean
    @@Type: idl|boolean||ManakaiDOM|all

ElementTypeBinding:
  @Name: FalseCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:InCase
    @@Value:
      @@@@: 0
      @@@ContentType: DISCore|Boolean
    @@Type: idl|boolean||ManakaiDOM|all

ElementTypeBinding:
  @Name: intValue
  @ElementType:
    dis:Value
  @ShadowContent:
    @@ContentType: DISCore|Integer

ResourceDef:
  @QName: getNodeRef
  @AliasFor: ManakaiNode|getNewReference||ManakaiDOM|Perl
  @For: ManakaiDOM|ManakaiDOM !=ManakaiDOM|ManakaiDOM

ResourceDef:
  @QName: c|getNodeRef
  @AliasFor: ManakaiNode|getNewReference||ManakaiDOM|Perl
  @For: ManakaiDOM|ManakaiDOM !=ManakaiDOM|ManakaiDOM

ForDef:
  @QName:
    Tree:ForSelect
  @enDesc:
    For selecting an attribute node for the purpose other than
    removing the node.

ForDef:
  @QName:
    Tree:ForRemove
  @enDesc:
    For selecting an attribute node for the purpose of removing.

ElementTypeBinding:
  @Name: enDesc
  @ElementType:
    dis:Description
  @ShadowContent:
    @@lang:en

ElementTypeBinding:
  @Name: Test
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: test|StandaloneTest
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: L2Test
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: test|StandaloneTest
    @@ForCheck: ManakaiDOM|ManakaiDOM2 ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: L3Test
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: test|StandaloneTest
    @@ForCheck: ManakaiDOM|ManakaiDOM3 ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: LXTest
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: test|StandaloneTest
    @@ForCheck: ManakaiDOM|ManakaiDOMLatest ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: XDTest
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: test|StandaloneTest
    @@ForCheck: ManakaiDOM|ManakaiDOMLatest ManakaiDOM|ForClass

ResourceDef:
  @QName: c|Text
  @AliasFor: Text
  @For: ManakaiDOM|DOM

IFCls1Def:
  @IFQName: Text
  @ClsQName: ManakaiDOMText

  @IFISA: CharacterData
  @ClsISA: ManakaiDOMCharacterData
  
  @DISLang:role: c|TextRole

  @Description:
    @@lang:en
    @@@:
      The textual content of an "Element" or "Attr".
    \
      When a document is first made available via the DOM, 
      there is only one "Text" node for each block of text. 
      DOM applications may create adjust "Text" nodes that 
      represent the contents of a given node (but there is no 
      way to represent the separation between these nodes in 
      XML or HTML so they will not persist between DOM editing sessions 
      in general).

  @Method:
     @@Name:  splitText
     @@Description:
       @@@lang:en
       @@@@:
         Break this node into two nodes.  After being split, 
         this node will contain all the content up to the break point 
         and a new node of the same type will contain all the content 
         at and after the break point.
      \
         If the original node had a parent node, the new node is 
         inserted as the next sibling of this node.
     @@L1:
     @@Param:
        @@@Name:  offset
        @@@Type:  
          DOMMain:unsigned-long||ManakaiDOM|all
        @@@Description:
          @@@@lang:en
          @@@@@:
            The 16-bit unit offset at which to split.
     @@Return:
        @@@Type:  Text
        @@@Description:
          @@@@lang:en
          @@@@@: The new node, of the same type as this node.
       @@@raises:
         @@@@@: DOMCore|NEGATIVE_INDEX_ERR
         @@@@enDesc:
           The <P::offset> is negative.
       @@@raises:
         @@@@@: DOMCore|OUT_OF_UPPER_BOUND_ERR
         @@@@enDesc:
           The <P::offset> is greater than the number of
           16-bit units.
       @@@raises:
         @@@@@: MDOMX|NOMOD_THIS
         @@@@enDesc:
           The node is read-only.
       @@@raises:
         @@@@@: MDOMX|NOMOD_PARENT
         @@@@enDesc:
           The parent node is read-only.
         @@@@For: ManakaiDOM|ManakaiDOM
      @@@PerlDef:
          my $node = $self->{<H::mn:node>};
          my $parentNode = $node->{<H::infoset:parent>};
          if ($node->{<H::DOMCore:read-only>}) {
            __EXCEPTION{
              MDOMX:NOMOD_THIS::
            }__;
          } elsif ($parentNode and $parentNode->{<H::DOMCore:read-only>}) {
            __EXCEPTION{
              MDOMX:NOMOD_PARENT::
            }__;
          }
          my $ds = \$node->{<H::infoset:content>};
          my $after;
          try {
            my $offset32 = <ClassM::DOMMain:ManakaiDOMStringExtend
                                   .findOffset32> ($offset);
            $after = substr ($$ds, $offset32);
            substr ($$ds, $offset32) = '';
          ## TODO: Catch StringIndexOutOfBoundsException
          };
          my $newNode;
          if ($node->{<H::DOMCore:nodeType>} eq <H::DOMCore:TextNode>) {
            $newNode = <ClassM::ManakaiDOMText.newObject> ($node);
          } elsif ($node->{<H::DOMCore:nodeType>} eq
                   <H::DOMXML:CDATASectionNode>) {
            $newNode = <ClassM::DOMXML:ManakaiDOMCDATASection.newObject> ($node);
          } else {
            __EXCEPTION{
              MDOMX:MDOM_DEBUG_BUG||ManakaiDOM:Perl::
                MDOMX:values => {+{
                  <H::DOMCore:nodeType> => $node->{<H::DOMCore:nodeType>},
                }},
            }__;
          }
          $newNode->{<H::infoset:content>} = $after;
          __CODE{mn|setXRefNode||ManakaiDOM|Perl::
            $referrer => {$newNode},
            $propName => {<H::DOMCore:ownerDocument>},
            $referent => {$parentNode->{<H::DOMCore:ownerDocument>}},
          }__;
          if ($parentNode) {
            $parentNode-><M::NodeStem.importTree> ($newNode);
            A: for my $i (0..$#{$parentNode->{<H::infoset:children>}}) {
              if ($parentNode->{<H::infoset:children>}->[$i]->{<H::mn:nodeID>} eq
                  $node->{<H::mn:nodeID>}) {
                splice @{$parentNode->{<H::infoset:children>}},
                       $i + 1, 0, $newNode;
                last A;
              }
            }
            $newNode->{<H::infoset:parent>} = $parentNode;
          }
          __CODE{mn|setXRefNode||ManakaiDOM|Perl::
            $referrer => {$newNode},
            $propName => {<H::DOMCore:ownerDocument>},
            $referent => {$node->{<H::DOMCore:ownerDocument>}},
          }__;

  @Attr:
     @@Name:  isElementContentWhitespace
     @@Description:
       @@@lang:en
       @@@@:
         Whether this text node contains element content whitespaces.
     @@Get:
        @@@Type:  DOMMain|boolean||ManakaiDOM|all
        @@@InCase:
          @@@@Value:true
          @@@@Description:
            @@@@@lang:en
            @@@@@@: This text node contains element content whitespaces.
        @@@InCase:
          @@@@Value:false
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              This text node contains element content whitespaces or 
              no validation occurs so that it is unknown.
        @@@disDef:
          @@@@GetProp:
            infoset:elementContentWhitespace
     @@Level[list]:  3
     @@SpecLevel:3
     @@For:
       ManakaiDOM:DOM3
     @@L3:
  @Attr:
     @@Name:  wholeText
     @@Description:
       @@@lang:en
       @@@@:
         All text of logically-adjacent text nodes.
     @@ImplNote:
       @@@lang:en
       @@@@:
         The DOM Level 3 Core Specification is unclear about 
         <IF::DOMXML:CDATASection>s.
         They should also be included (c.f. the definition for 
         <A::Text.replaceWholeText>).
         \
         What about unexpanded entity references?
     @@Get:
        @@@Type:  
          DOMMain:DOMString
        @@@ImplNote:
          @@@@ContentType:
            lang:Perl
          @@@@@:
            my $parent = $self-><AG::Node.parentNode>;
            if ($parent-><AG::Node.nodeType> !=
                <C::Node.ENTITY_REFERENCE_NODE>) {
              my $start = -1;
              my $end = -1;
              my $mfound = 0;
              my $sibs = $parent-><AG::DOMCore:Node.childNodes>;
              my $sibl = $sibs-><AG::DOMCore:NodeList.length>;
              for (my $i = 0; $i < $sibl; $i++) {
                my $sib = $sibs-><AG::DOMCore:NodeList.item> ($i);
                if (not $mfound and $sib-><M::DOMCore:Node.isSameNode> ($self)) {
                  $start = $i if $start == -1;
                  $end = $i;
                  $mfound = 1;
                } elsif ({
                           <C::Node.TEXT_NODE> => 1,
                           <C::Node.CDATA_SECTION_NODE> => 1,
                         }->{$sib-><AG::DOMCore:Node.nodeType>}) {
                  if ($mfound) {
                    $end = $i;
                  } else {
                    $start = $end = $i;
                  }
                } elsif ($sib-><AG::DOMCore:Node.nodeType> ==
                         <C::Node.ENTITY_REFERENCE_NODE>) {
                  if ($mfound) {
                    
                  } else {

                  }
                }
              }
            }

   TODO: Implement this.
            my $node = $self->{<H::mn:node>};
            if ($node->{<H::infoset:parent>}) {
              my $parentNode = $node->{<H::infoset:parent>};
              my (@t, @tr1, @tr2);
              my ($found, $first, $last);
              for my $i (0..$#{$parentNode->{<H::infoset:children>}}) {
                if ({
                      <H::DOMCore:TextNode> => 1,
                      <H::DOMXML:CDATASectionNode> => 1,
                    }->{$parentNode->{<H::infoset:children>}->[$i]
                                   ->{<H::DOMCore:nodeType>}}) {
                  push @t, $parentNode->{<H::infoset:children>}->[$i];
                  $first = ($i == 0);
                  $last = ($i == $#{$parentNode->{<H::infoset:children>}});
                  $found = 1 if $parentNode->{<H::infoset:children>}->[$i]
                                           ->{<H::mn:nodeID>} eq
                                $parentNode->{<H::mn:nodeID>};
                } elsif ($parentNode->{<H::infoset:children>}->[$i]
                                   ->{<H::DOMCore:nodeType>} eq
                         <H::DOMXML:EntityReferenceNode>) {
                  if ($found) {
                    push @tr2, $parentNode->{<H::infoset:children>}->[$i];
                    $last = ($i == $#{$parentNode->{<H::infoset:children>}});
                  } else {
                    push @tr1, $parentNode->{<H::infoset:children>}->[$i];
                  }
                } else {
                  if ($found) {
                    last;
                  } else {
                    $first = 0;
                    $last = 0;
                    @t = ();
                  }
                }
              }
              if ($parentNode->{<H::DOMCore:nodeType>} eq
                  <H::DOMXML:EntityReferenceNode> and 
                  $parentNode->{<H::infoset:parent>}) {
                
              }
            } else {
              $r = $node->__ SUPER{ManakaiDOMNodeObjectNode::}__::__ INT{textContent}__;
            }
     @@L3:
     @@Level[list]:  3
     @@SpecLevel:3
     @@For:
       ManakaiDOM:DOM3
  @Method:
     @@Name:  replaceWholeText
     @@Return:
        @@@Type:  Text
        @@@Exception[list]:  DOMException
     @@Param:
        @@@Name:  content
        @@@Type:  
          DOMMain:DOMString
     @@Level[list]:  3
     @@SpecLevel:3
     @@For:
       ManakaiDOM:DOM3
     @@L3:
  
  @ReAttr:
    @@Name: nodeName
    @@Description:
      @@@lang:en
      @@@@: The node name.
    @@Spec:
      @@@DOM3[list]:
        http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-F68D095
        http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-1841493061
    @@DOMMain:isNamespaceUnaware:1
    @@L1:
    @@Get:
      @@@Type: 
        DOMMain:DOMString
      @@@InCase:
        @@@@Value:\#text
        @@@@Description:
          @@@@@lang:en
          @@@@@@: Always this value for the "Text" node.
      @@@DefaultValue:
        @@@@@: \#text
        @@@@ContentType:
          DISCore:String
      @@@disDef:
        @@@@DISLang:nop:
  @ReAttr:
    @@Name: nodeType
    @@Description:
      @@@lang:en
      @@@@: The type of this node.
    @@L1:
    @@Get:
      @@@Type: 
        DOMMain:unsigned-short||ManakaiDOM|all
      @@@InCase:
        @@@@Label: TEXT_NODE
        @@@@Description:
          @@@@@lang:en
          @@@@@@: The node is a "Text".
      @@@disDef:
        @@@@DISLang:constValue:Node.TEXT_NODE

  @IntMethod:
    @@Name: newObject
    @@Description:
      @@@lang:en
      @@@@:
        Construct an object for a new instance of the <IF::Text> node.
    @@NewObjectRefNodeParam:
    @@Return:
      @@@Type: NodeStem
      @@@Description:
        @@@@lang:en
        @@@@@:
          The new object for the <IF::Text> node.
      @@@PerlDef:
          $r = <ClassM::ManakaiDOMNode.newObject> ($self, $refNode);
          $r->{<H::DOMCore:nodeType>} = <H::DOMCore:TextNode>;
          $r->{<H::infoset:content>} = '';
     @@ImplNote:
       @@@lang:en
       @@@@:
         Other properties requires to be a legal <IF::Text>:
         <Q::DOMCore:ownerDocument>.
         \
         Other available properties: <Q::infoset:ElementContentWhitespace>, 
         <Q::infoset:parent>, <Q::infoset:content>, <Q::DOMCore:read-only>.

  @mn:xrefnode0: DOMCore|ownerDocument
  @mn:origin0: infoset|parent

  @Method:
     @@Name:  getFeature
     @@enDesc:
       Returns a specialized object that implements the
       specialized interfaces of the specified feature and version.
     @@ManakaiDOM:isRedefining:1
     @@ForCheck: ManakaiDOM|ForClass ManakaiDOM|DOM3
     @@Param:
        @@@Name:  feature
        @@@Type:  
          DOMMain:DOMString
        @@@actualType: ManakaiDOM|ManakaiDOMFeatureName
        @@@enDesc:
          The feature name to request.
        @@@InCase:
          @@@@Label:
            @@@@@lang:en
            @@@@@@: 
              Feature name preceded by a <CHAR::PLUS SIGN>
          @@@@enDesc:
            The <CHAR::PLUS SIGN> is ignored.
     @@Param:
        @@@Name:  version
        @@@Type:  
          DOMMain:DOMString
        @@@actualType: ManakaiDOM|ManakaiDOMFeatureVersion
        @@@enDesc:
          The feature version to request.
        @@@nullCase:
          @@@@enDesc:
            No specific version is requested.
     @@Return:
        @@@Type:  
          DOMMain:DOMObject
        @@@enDesc:
          An object implementing the specialized interfaces.
          Note that the specialized object may or may not
          implement the <IF::Node> interface.
        @@@nullCase:
          @@@@enDesc:
            There is no object available that implements
            the specialized interfaces.
        @@@PerlDef:
            $feature =~ s/^\+//;
            if ($Message::DOM::ClassFeature{ref $self}->{$feature}->{$version}) {
              ## This class
              $r = $self;
            } else {
              CLASS: for my $class (grep {
                $Message::DOM::ManakaiDOMText::CompatClass{$_}
              } keys %Message::DOM::ManakaiDOMText::CompatClass) {
                if ($Message::DOM::ClassFeature{$class}
                            ->{$feature}->{$version}) {
                  __CODE{getNodeRef::
                    $object => {$self->{<H::mn:node>}},
                    $ref => $r,
                    $class => $class,
                  }__;
                  last CLASS;
                }
              }
            }
##Text

ResourceDef:
  @QName: c|Comment
  @AliasFor: Comment
  @For: ManakaiDOM|DOM

IFCls1Def:
  @IFQName: Comment
  @ClsQName: ManakaiDOMComment

  @IFISA: CharacterData
  @ClsISA: ManakaiDOMCharacterData
  
  @DISLang:role: c|CommentRole

  @Description:
    @@lang:en
    @@@:
      A comment, corresponding to a comment declaration in the HTML or 
      XML or a comment information item in the XML Infoset.
  @ImplNote:
    @@lang:en
    @@@:
      HTML comment declaration might have multiple "comment".  DOM 
      does not support it.
  
  @ReAttr:
    @@Name: nodeName
    @@Spec:
      @@@DOM3[list]:
        http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-F68D095
        http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-1841493061
    @@DOMMain:isNamespaceUnaware:1
    @@L1:
    @@Description:
      @@@lang:en
      @@@@: The node name.
    @@DOMMain:isNamespaceUnaware:1
    @@Get:
      @@@Type: 
        DOMMain:DOMString
      @@@InCase:
        @@@@Value: \#comment
        @@@@Description:
          @@@@@lang:en
          @@@@@@: Always this value for the "Comment" node.
      @@@disDef: 
        @@@@DISLang:value:
          @@@@@@: \#comment
          @@@@@ContentType:
            DISCore:String
  @ReAttr:
    @@Name: nodeType
    @@Description:
      @@@lang:en
      @@@@: The type of this node.
    @@L1:
    @@Get:
      @@@Type: 
        DOMMain:unsigned-short||ManakaiDOM|all
      @@@InCase:
        @@@@Label: COMMENT_NODE
        @@@@Description:
          @@@@@lang:en
          @@@@@@: The node is a "Comment".
      @@@disDef:
        @@@@DISLang:constValue: Node.COMMENT_NODE

  @IntMethod:
    @@Name: newObject
    @@Description:
      @@@lang:en
      @@@@:
        Construct an object for a new instance of the <IF::Comment> node.
    @@NewObjectRefNodeParam:
    @@Return:
      @@@Type: NodeStem
      @@@Description:
        @@@@lang:en
        @@@@@:
          The new object for the <IF::Comment> node.
      @@@PerlDef:
          $r = <ClassM::ManakaiDOMNode.newObject> ($self, $refNode);
          $r->{<H::DOMCore:nodeType>} = <H::infoset:Comment>;    
          $r->{<H::infoset:content>} = '';
     @@ImplNote:
       @@@lang:en
       @@@@:
         Other properties required to be a legal <IF::Comment> object:
         <Q::DOMCore:ownerDocument>.
        \
         Other available properties: <Q::infoset:parent>, <Q::infoset:content>, 
         <Q::DOMCore:read-only>.

  @mn:xrefnode0: DOMCore|ownerDocument
  @mn:origin0: infoset|parent

  @Method:
     @@Name:  getFeature
     @@enDesc:
       Returns a specialized object that implements the
       specialized interfaces of the specified feature and version.
     @@ManakaiDOM:isRedefining:1
     @@ForCheck: ManakaiDOM|ForClass ManakaiDOM|DOM3
     @@Param:
        @@@Name:  feature
        @@@Type:  
          DOMMain:DOMString
        @@@actualType: ManakaiDOM|ManakaiDOMFeatureName
        @@@enDesc:
          The feature name to request.
        @@@InCase:
          @@@@Label:
            @@@@@lang:en
            @@@@@@: 
              Feature name preceded by a <CHAR::PLUS SIGN>
          @@@@enDesc:
            The <CHAR::PLUS SIGN> is ignored.
     @@Param:
        @@@Name:  version
        @@@Type:  
          DOMMain:DOMString
        @@@actualType: ManakaiDOM|ManakaiDOMFeatureVersion
        @@@enDesc:
          The feature version to request.
        @@@nullCase:
          @@@@enDesc:
            No specific version is requested.
     @@Return:
        @@@Type:  
          DOMMain:DOMObject
        @@@enDesc:
          An object implementing the specialized interfaces.
          Note that the specialized object may or may not
          implement the <IF::Node> interface.
        @@@nullCase:
          @@@@enDesc:
            There is no object available that implements
            the specialized interfaces.
        @@@PerlDef:
            $feature =~ s/^\+//;
            if ($Message::DOM::ClassFeature{ref $self}->{$feature}->{$version}) {
              ## This class
              $r = $self;
            } else {
              CLASS: for my $class (grep {
                $Message::DOM::ManakaiDOMComment::CompatClass{$_}
              } keys %Message::DOM::ManakaiDOMComment::CompatClass) {
                if ($Message::DOM::ClassFeature{$class}
                            ->{$feature}->{$version}) {
                  __CODE{getNodeRef::
                    $object => {$self->{<H::mn:node>}},
                    $ref => $r,
                    $class => $class,
                  }__;
                  last CLASS;
                }
              }
            }
##Comment

ResourceDef:
  @QName: c|DocumentFragment
  @AliasFor: DocumentFragment
  @For: ManakaiDOM|DOM

NodeTypeDef:
  @IFQName: DocumentFragment
  @ClsQName: ManakaiDOMDocumentFragment
  
  @DISLang:role: c|DocumentFragmentRole

  @enDesc:
    <IF::DocumentFragment> is a <QUOTE::lightweight> or <QUOTE::minimal>
    <IF::Document> object.  It is useful to extract a portion of
    a document tree or to create a new fragment of a document.

    In various operations, such as inserting nodes as children
    of another <IF::Node> by <M::Node.appendChild>, 
    a <IF::DocumentFragment> node is treated <QUOTE::transparent> -- 
    it results in all the child nodes of the <IF::DocumentFragment>
    being moved to the child list of that <IF::Node>.

  @IntMethod:
    @@Name: newObject
    @@Description:
      @@@lang:en
      @@@@:
        Construct a node stem for a new instance of the
        <IF::DocumentFragment> object.
      \
        Note that this method is for the internal use.  The DOM 
        applications must use the <M::Document.createDocumentFragment> method 
        to create a new <IF::DocumentFragment> object.
    @@NewObjectRefNodeParam:
    @@Return:
      @@@Type: NodeStem
      @@@Description:
        @@@@lang:en
        @@@@@: 
          The new node stem object of type <IF::DocumentFragment>.
      @@@PerlDef:
          $r = <ClassM::ManakaiDOMNode.newObject> ($self, $refNode);
          $r->{<H::infoset:children>} = [];
          $r->{<H::DOMCore:nodeType>} = <H::DOMCore:DocumentFragmentNode>;
       @@@ImplNote:
         @@@@lang:en
         @@@@@:
           Other properties required to be a legal <IF::DocumentFragment> 
           object: <Q::DOMCore:ownerDocument>. 
         \
           Other available properties: <Q::infoset:children>, 
           <Q::DOMCore:read-only>.

  @mn:xrefnode0: DOMCore|ownerDocument
  @mn:subnode1: infoset|children
  
  @ReMethod:
     @@Name:  lookupPrefix
     @@Description:
       @@@lang:en
       @@@@:
         Lookup the namespace prefix associated to the given namespace 
         URI, starting from this node.
       \
         The default namespace declarations are ignored by this method. 
         To lookup default namespace, use the <M::Node.isDefaultNamespace>
         method.
     @@Param:
        @@@Name:  namespaceURI
        @@@Type:
          DOMMain:DOMString
        @@@actualType:
          ManakaiDOM:ManakaiDOMNamespaceURI
        @@@Description:
          @@@@lang:en
          @@@@@: The namespace URI to look for.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Always <DOM::null> will be returned.
        @@@InCase:
          @@@@Value:\
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Always <DOM::null> will be returned.
     @@Return:
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            An associated namespace prefix.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              No namespace prefix is found.  Always <DOM::null> is 
              returned for the <IF::DocumentFragment> node.
        @@@PerlDef:
          @@@@@: $r = null;
     @@Level[list]:  3
     @@SpecLevel:3
     @@For:
       ManakaiDOM:DOM3
  @ReAttr:
    @@Name: nodeName
    @@Description:
      @@@lang:en
      @@@@: The node name.
    @@Spec:
      @@@DOM3[list]:
        http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-F68D095
        http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-1841493061
    @@DOMMain:isNamespaceUnaware:1
    @@Get:
      @@@Type: 
        DOMMain:DOMString
      @@@InCase:
        @@@@Value:\#document-fragment
        @@@@Description:
          @@@@@lang:en
          @@@@@@: Always this value for the "DocumentFragment" node.
      @@@disDef:
        @@@@DISLang:value:
          @@@@@@: \#document-fragment
          @@@@@ContentType:
            DISCore:String
  @ReAttr:
    @@Name: nodeType
    @@Description:
      @@@lang:en
      @@@@: The type of this node.
    @@Get:
      @@@Type: 
        DOMMain:unsigned-short||ManakaiDOM|all
      @@@InCase:
        @@@@Label:
          <C::Node.DOCUMENT_FRAGMENT_NODE>
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The node is a <IF::DocumentFragment>.
      @@@disDef:
        @@@@DISLang:constValue: Node.DOCUMENT_FRAGMENT_NODE


  @Method:
     @@Name:  getFeature
     @@enDesc:
       Returns a specialized object that implements the
       specialized interfaces of the specified feature and version.
     @@ManakaiDOM:isRedefining:1
     @@ForCheck: ManakaiDOM|ForClass ManakaiDOM|DOM3
     @@Param:
        @@@Name:  feature
        @@@Type:  
          DOMMain:DOMString
        @@@actualType: ManakaiDOM|ManakaiDOMFeatureName
        @@@enDesc:
          The feature name to request.
        @@@InCase:
          @@@@Label:
            @@@@@lang:en
            @@@@@@: 
              Feature name preceded by a <CHAR::PLUS SIGN>
          @@@@enDesc:
            The <CHAR::PLUS SIGN> is ignored.
     @@Param:
        @@@Name:  version
        @@@Type:  
          DOMMain:DOMString
        @@@actualType: ManakaiDOM|ManakaiDOMFeatureVersion
        @@@enDesc:
          The feature version to request.
        @@@nullCase:
          @@@@enDesc:
            No specific version is requested.
     @@Return:
        @@@Type:  
          DOMMain:DOMObject
        @@@enDesc:
          An object implementing the specialized interfaces.
          Note that the specialized object may or may not
          implement the <IF::Node> interface.
        @@@nullCase:
          @@@@enDesc:
            There is no object available that implements
            the specialized interfaces.
        @@@PerlDef:
            $feature =~ s/^\+//;
            if ($Message::DOM::ClassFeature{ref $self}->{$feature}->{$version}) {
              ## This class
              $r = $self;
            } else {
              CLASS: for my $class (grep {
                $Message::DOM::ManakaiDOMDocumentFragment::CompatClass{$_}
              } keys %Message::DOM::ManakaiDOMDocumentFragment::CompatClass) {
                if ($Message::DOM::ClassFeature{$class}
                            ->{$feature}->{$version}) {
                  __CODE{getNodeRef::
                    $object => {$self->{<H::mn:node>}},
                    $ref => $r,
                    $class => $class,
                  }__;
                  last CLASS;
                }
              }
            }
##DocumentFragment

ResourceDef:
  @QName: c|Document
  @AliasFor: Document
  @For: ManakaiDOM|DOM

ResourceDef:
  @QName: c|ManakaiDOMDocument
  @AliasFor: ManakaiDOMDocument
  @For: !=ManakaiDOM|all ManakaiDOM|ManakaiDOM !=ManakaiDOM|ManakaiDOM

NodeTypeDef:
  @IFQName: Document
  @ClsQName: ManakaiDOMDocument
  
  @DISLang:role: c|DocumentRole

  @enDesc:
    A <IF::Document> object represents the entire HTML or XML document.
    It is conceptually the root of the document tree and
    corresponding to the <InfoItem::Document Information Item>
    in XML information set.

    Since nodes of type element, text, comment, etc. cannot exists
    outside the context of a <IF::Document>, the <IF::Document>
    interface also contains the factory methods needed to
    create these objects.

    {NOTE:: A <IF::DocumentType> node can be created by
            <M::c|DOMImplementation.createDocumentType> method.
            A <IF::Document> node can be created by 
            <M::c|DOMImplementation.createDocument> method.
    }

  @Attr:
    @@Name: doctype
    @@enDesc:
      The document type declaration associated with the document.
      It is the <IF::x|DocumentType> child of the node, if any.

      For an XML document with a document type declaration,
      this attribute contains the <IF::x|DocumentType> node.

    @@enDesc:
      @@@For: ManakaiDOM|DOM3
      @@@ddid: html
      @@@@:
        For an HTML document, this attribute may contain
        a <IF::x|DocumentType> node independently of the presence or
        absence of document type declaration. 
    @@enDesc:
      @@@For: !ManakaiDOM|DOM3
      @@@ddid: html
      @@@@:
        For an HTML document, the attribute value is always <DOM::null>.

    @@enDesc:
      @@@ddid: note
      @@@@:
        {NOTE:: Although this attribute itself is read-only, 
                usual node modification methods on the <IF::Document>
                node can alter the <IF::x|DocumentType> node.
                However, while the implementation might instantiate different
                types of <IF::Document> object supporting additional
                feature than <Feature::Core>, based on the <IF::x|DocumentType>
                specified at creation time, changing it afterward
                is unlikely to result in a change of the feature supported
                by the <IF::Document>.
        }
    @@enImplNote:
      Introduced in DOM Level 1, modified in DOM Level 3.

      {TODO:: HTML5 consideration.
      }
    @@Type: x|DocumentType
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          @@@@@For: ManakaiDOM|DOM3
          @@@@@@:
            If the document does not have a document type declaration,
            or if it is an HTML document and the implementation does not
            expose the document type declaration to the DOM.
        @@@@enDesc:
          @@@@@For: !ManakaiDOM|DOM3
          @@@@@@:
            If the document does not have a document type declaration,
            or if it is an HTML document.
      @@@PerlDef:
        @@@@@:
          __DEEP{
            F: for my $child (@{$self-><AG::Node.childNodes>}) {
              my $nt = $child-><AG::Node.nodeType>;
              if ($nt == <C::Node.DOCUMENT_TYPE_NODE>) {
                $r = $child;
                last F;
              } elsif ($nt == <C::Node.ELEMENT_NODE>) { # document element
                last F;
              }
            } # F
          }__;
        @@@@enImplNote:
          Although the intention of the DOM specification is unclear,
          the current manakai implementation <EM::does> return
          a <IF::x|DocumentType> node, if any, even if DOM level
          is less than (not equal to) 3.
    @@Test:
      @@@QName: Document.doctype.one-element-document.test
      @@@PerlDef:
        my $doc;
        __CODE{createDocumentForTest:: $doc => $doc}__;
        $test->assert_null ($doc-><AG::Document.doctype>);
    @@Test:
      @@@QName: Document.doctype.empty-document.test
      @@@PerlDef:
        my $doc;
        __CODE{createDocumentForTest:: $doc => $doc}__;
        $doc-><M::Node.removeChild> ($doc-><AG::Node.firstChild>);
        $test->assert_null ($doc-><AG::Document.doctype>);
    @@Test:
      @@@QName: Document.doctype.doctype-element-document.test
      @@@PerlDef:
        my $doc;
        __CODE{createDocumentForTest:: $doc => $doc}__;
        my $doctype = $doc-><AG::Document.implementation>
                          -><M::c|DOMImplementation.createDocumentType> ('dt');
        my $el = $doc-><AG::Node.firstChild>;
        $doc-><M::Node.removeChild> ($el);
        $doc-><M::Node.appendChild> ($doctype);
        $doc-><M::Node.appendChild> ($el);

        $test->assert_equals ($doc-><AG::Document.doctype>, $doctype);
    @@Test:
      @@@QName: Document.doctype.comment-doctype-element-document.test
      @@@PerlDef:
        my $doc;
        __CODE{createDocumentForTest:: $doc => $doc}__;
        my $doctype = $doc-><AG::Document.implementation>
                          -><M::c|DOMImplementation.createDocumentType> ('dt');
        my $el = $doc-><AG::Node.firstChild>;
        $doc-><M::Node.removeChild> ($el);
        my $comment = $doc-><M::Document.createComment> ('');
        $doc-><M::Node.appendChild> ($comment);
        $doc-><M::Node.appendChild> ($doctype);
        $doc-><M::Node.appendChild> ($el);

        $test->assert_equals ($doc-><AG::Document.doctype>, $doctype);

  @Attr:
     @@Name:  implementation
     @@Description:
       @@@lang:en
       @@@@:
         The "DOMImplementation" object that handles the "Document".
     @@Get:
        @@@Type:  c|DOMImplementation
        @@@disDef:
          @@@@GetProp:
            DOMCore:implementation

  @Attr:
    @@Name: documentElement
    @@enDesc:
      The document element of the document.
    @@Get:
      @@@Type: Element
      @@@nullCase:
        @@@@enDesc:
          If the document has no element.
        @@@@For: ManakaiDOM|ManakaiDOM
      @@@PerlDef:
        __DEEP{
          F: for my $child (@{$self-><AG::Node.childNodes>}) {
            if ($child-><AG::Node.nodeType> == <C::Node.ELEMENT_NODE>) {
              $r = $child;
              last F;
            }
          } # F
        }__;
    @@Test:
      @@@QName: Document.documentElement.one-element-document.test
      @@@PerlDef:
        my $doc;
        __CODE{createDocumentForTest:: $doc => $doc}__;
        $test->assert_equals ($doc-><AG::Document.documentElement>,
                              $doc-><AG::Node.firstChild>);
    @@Test:
      @@@QName: Document.documentElement.empty-document.test
      @@@PerlDef:
        my $doc;
        __CODE{createDocumentForTest:: $doc => $doc}__;
        $doc-><M::Node.removeChild> ($doc-><AG::Node.firstChild>);
        $test->assert_null ($doc-><AG::Document.documentElement>);
    @@Test:
      @@@QName: Document.documentElement.doctype-element-document.test
      @@@PerlDef:
        my $doc;
        __CODE{createDocumentForTest:: $doc => $doc}__;
        my $doctype = $doc-><AG::Document.implementation>
                          -><M::c|DOMImplementation.createDocumentType> ('dt');
        my $el = $doc-><AG::Node.firstChild>;
        $doc-><M::Node.removeChild> ($el);
        $doc-><M::Node.appendChild> ($doctype);
        $doc-><M::Node.appendChild> ($el);

        $test->assert_equals ($doc-><AG::Document.documentElement>, $el);

  @Method:
     @@Name:  createElement
     @@Description:
       @@@lang:en
       @@@@:
         Create an element.
       \
         If there are known attributes with default values, 
         <IF::Attr> nodes representing them are automatically 
         created and attached to the element created.
     @@NSVersion:.createElementNS
     @@Param:
        @@@Name:  tagName
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            The name of the element type to instantiate.
          \
            The case-sensitivity depends on that of the markup language 
            in use.  If it is case-insensitive, the <P::tagName> is 
            mapped to the canonical form of that markup language 
            by the DOM implementation.
     @@Return:
        @@@Type:  Element
        @@@actualType: ManakaiDOMElement
        @@@Description:
          @@@@lang:en
          @@@@@:
            A newly created <IF::Element> object.
        @@@Exception:
          @@@@@:
            MDOMX:MDOM_BAD_NAME
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The <P::tagName> is not a legal SGML or XML Name.
        @@@PerlDef:
            my $docNode = $self->{<H::mn:node>};
            my $version = <Code::getDocumentXMLVersion:: $DOCOBJ = $docNode>;
            __CODE{DOMMain:ensureXMLName:: $INPUT => $tagName,
                                           $INPUT_PARAM_NAME => 'tagName',
                                           $XMLVERSION => $version}__;
            my $node = <ClassM::ManakaiDOMElement.newObject>;
            __CODE{mn|setXRefNode||ManakaiDOM|Perl::
              $referrer => {$node},
              $propName => {<H::DOMCore:ownerDocument>},
              $referent => {$docNode},
            }__;
            $node->{<H::DOMCore:name>} = $tagName;
            $r = <ClassM::ManakaiDOMNode.getNodeReference> ($node);

        ## Default attributes
        __CODE{t|exposeDefaultAttributes::
          $document => $self,
          $element => $r,
          $element_type => $tagName,
        }__;

          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              TODO: <P::tagName> should be normalized to uppercases if HTML.
    @@enImplNote:
      {ISSUE::
        Should <P::tagName> be parsed as QName?
      }

      {ISSUE::
        Should we define <M::Document.createElement> as an alias
        of <M::Document.createElementNS> with its <P::namespaceURI>
        parameter set to <DOM::null> and its <P::qualifiedName>
        parameter set to <P::tagName>, without <P::qualifiedName>-is-no-a-qname
        error?  (It is what web browsers do.)
      }

    @@Test:
      @@@QName: Document.createElement.nodefaultattr.test
      @@@PerlDef:
        my $doc;
        __CODE{createDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createElement> ('et1');

        $test->assert_num_equals
                 (actual_value => $el-><AG::Node.attributes>
                                     -><AG::NamedNodeMap.length>,
                  expected_value => 0);
    @@Test:
      @@@QName: Document.createElement.defaultattr.1.test
      @@@PerlDef:
        my $doc;
        __CODE{createEmptyDocumentForTest:: $doc => $doc}__;
        my $docd = $doc-><M::Node.getFeature> (<Q::ManakaiDOM:XDoctype>, '3.0');
        my $dtd = $docd-><M::d|DocumentXDoctype.createDocumentTypeDefinition>
                           ('doctype');
          my $et = $docd-><M::d|DocumentXDoctype.createElementTypeDefinition>
                             ('et1');
            my $at = $docd-><M::d|DocumentXDoctype.createAttributeDefinition>
                               ('dattr1');
            $at-><AS::ATDef.defaultType> (<C::ATDef.EXPLICIT_DEFAULT>);
            $at-><AS::Node.textContent> ('dattr1 default ');
          $et-><M::ETDef.setAttributeDefinitionNode> ($at);
        $dtd-><M::DTDef.setElementTypeDefinitionNode> ($et);
        $doc-><M::Node.appendChild> ($dtd);

        my $el = $doc-><M::Document.createElement> ('et1');

        $test->id ('attributes.length');
        $test->assert_num_equals
                 (actual_value => $el-><AG::Node.attributes>
                                     -><AG::NamedNodeMap.length>,
                  expected_value => 1);
        
        $test->id ('has.attribute');
        $test->assert_true ($el-><M::Element.hasAttribute> ('dattr1'));

        $test->id ('get.attr.node');
        my $an = $el-><M::Element.getAttributeNode> ('dattr1');
        $test->assert_isa ($an, <IFName::Attr>);

        $test->id ('attr.text.content');
        $test->assert_equals ($an-><AG::Node.textContent>, 'dattr1 default ');
        
        $test->id ('attr.specified');
        $test->assert_false ($an-><AG::Attr.specified>);
    @@Test:
      @@@QName: Document.createElement.defaultattr.typed.test
      @@@PerlDef:
        my $doc;
        __CODE{createEmptyDocumentForTest:: $doc => $doc}__;
        my $docd = $doc-><M::Node.getFeature> (<Q::ManakaiDOM:XDoctype>, '3.0');
        my $dtd = $docd-><M::d|DocumentXDoctype.createDocumentTypeDefinition>
                           ('doctype');
          my $et = $docd-><M::d|DocumentXDoctype.createElementTypeDefinition>
                             ('et1');
            my $at = $docd-><M::d|DocumentXDoctype.createAttributeDefinition>
                               ('dattr1');
            $at-><AS::ATDef.defaultType> (<C::ATDef.EXPLICIT_DEFAULT>);
            $at-><AS::Node.textContent> ('dattr1 default ');
            $at-><AS::ATDef.declaredType> (<C::ATDef.NMTOKENS_ATTR>);
          $et-><M::ETDef.setAttributeDefinitionNode> ($at);
        $dtd-><M::DTDef.setElementTypeDefinitionNode> ($et);
        $doc-><M::Node.appendChild> ($dtd);

        my $el = $doc-><M::Document.createElement> ('et1');

        $test->id ('attributes.length');
        $test->assert_num_equals
                 (actual_value => $el-><AG::Node.attributes>
                                     -><AG::NamedNodeMap.length>,
                  expected_value => 1);
        
        $test->id ('has.attribute');
        $test->assert_true ($el-><M::Element.hasAttribute> ('dattr1'));

        $test->id ('get.attr.node');
        my $an = $el-><M::Element.getAttributeNode> ('dattr1');
        $test->assert_isa ($an, <IFName::Attr>);

        $test->id ('attr.text.content');
        $test->assert_equals ($an-><AG::Node.textContent>, 'dattr1 default ');
        
        $test->id ('attr.specified');
        $test->assert_false ($an-><AG::Attr.specified>);

        $test->id ('attr.type');
        my $ti = $an-><AG::Attr.schemaTypeInfo>;
        $test->assert_equals
                 ($ti-><AG::c|TypeInfo.typeNamespace>, <Q::xml-dtd:>);
        $test->assert_equals ($ti-><AG::c|TypeInfo.typeName>, 'NMTOKENS');

  @CODE:
    @@QName: t|exposeDefaultAttributes
    @@PerlDef:
      @@@For: ManakaiDOM|DOM2 ManakaiDOM|DOMXMLFeature
      @@@@:
      __DEEP{
        my $__doctype = $document-><AG::Document.doctype>;
        $__doctype = $__doctype-><M::Node.getFeature>
                                   (<Q::ManakaiDOM:XDoctype> => '3.0')
          if $__doctype;
        if ($__doctype) {
          my $__et = $__doctype-><M::DTDef.getElementTypeDefinitionNode>
                                   ($element_type);
          if ($__et) {
            local $document->{<H::mn:node>}
                           ->{<H::c|strictErrorChecking>} = false;
            my %__gattr;
            my %__has_attr;
            my %__pfx_to_uri;
            my $__cfg = $document-><AG::Document.domConfig>;
            my $__copy_asis = $__cfg-><M::c|DOMConfiguration.getParameter>
                                       (<Q::cfg|clone-entity-reference-subtree>);
            $__cfg-><M::c|DOMConfiguration.setParameter>
                          (<Q::cfg|clone-entity-reference-subtree> => true);
            for my $__at (@{$__et-><AG::ETDef.attributeDefinitions>}) {
              my $__at_default = $__at-><AG::ATDef.defaultType>;
              if ($__at_default == <C::ATDef.EXPLICIT_DEFAULT> or
                  $__at_default == <C::ATDef.FIXED_DEFAULT>) {
                my ($__nn1, $__nn2) = split /:/, $__at-><AG::Node.nodeName>;
                if (defined $__nn2) { # prefixed
                  if ($__nn1 eq 'xmlns') {
                    ## TODO: NCName check, prefix check and NSURI check
                    my $__attr = $document-><M::Document.createAttributeNS>
                                              (<Q::xmlns:>, $__nn1.':'.$__nn2);
                    for my $__at_child (@{$__at-><AG::Node.childNodes>}) {
                      $__attr-><M::Node.appendChild>
                                 ($__at_child-><M::Node.cloneNode> (true));
                    }
                    $__attr->{<H::mn:node>}->{<H::infoset:attributeType>}
                      = $__at-><AG::ATDef.declaredType>;
                    my $__nsuri = $__attr-><AG::Attr.value>;
                    ## TODO: Namespace well-formedness check (NSURI), v1.1 chk
                    $__pfx_to_uri{$__nn2} = $__nsuri;
                    $element-><M::Element.setAttributeNodeNS> ($__attr);
                             ## This method changes |specified| flag
                    $__attr->{<H::mn:node>}->{<H::infoset:specified>} = false;
                    $__has_attr{<Q::xmlns:>}->{$__nn2} = true;
                  } else {
                    ## TODO: NCName check
                    $__gattr{$__nn1}->{$__nn2} = $__at;
                  }
                } else {            # no prefixed
                  my $__attr;
                  if ($__nn1 eq 'xmlns') {
                    $__attr = $document-><M::Document.createAttributeNS>
                                              (<Q::xmlns:>, 'xmlns');
                    $__has_attr{<Q::xmlns:>}->{xmlns} = true;
                  } else {
                    $__attr = $document-><M::Document.createAttributeNS>
                                              (null, $__nn1);
                    ## TODO: NCName check
                  }
                  for my $__at_child (@{$__at-><AG::Node.childNodes>}) {
                    $__attr-><M::Node.appendChild>
                               ($__at_child-><M::Node.cloneNode> (true));
                  }
                  $__attr->{<H::mn:node>}->{<H::infoset:attributeType>}
                    = $__at-><AG::ATDef.declaredType>;
                  ## TODO: Namespace well-formedness check (NSURI)
                  $element-><M::Element.setAttributeNodeNS> ($__attr);
                             ## This method changes |specified| flag
                  $__attr->{<H::mn:node>}->{<H::infoset:specified>} = false;
                }
              }
            } # attrdefs
            for my $__pfx (keys %__gattr) {
              my $__nsuri = $__pfx_to_uri{$__pfx};
              unless (defined $__nsuri) {
                ## TODO: Namespace well-formedness error
              }
              LN: for my $__ln (keys %{$__gattr{$__pfx}}) {
                if ($__has_attr{defined $__nsuri ? $__nsuri : ''}->{$__ln}) {
                  ## TODO: Namespace well-formedness error
                  next LN;
                }
                ## TODO: NCName check, prefix check and NSURI check
                my $__at = $__gattr{$__pfx}->{$__ln};
                my $__attr = $document-><M::Document.createAttributeNS>
                                          ($__nsuri, $__pfx.':'.$__ln);
                for my $__at_child (@{$__at-><AG::Node.childNodes>}) {
                  $__attr-><M::Node.appendChild>
                             ($__at_child-><M::Node.cloneNode> (true));
                }
                $__attr->{<H::mn:node>}->{<H::infoset:attributeType>}
                  = $__at-><AG::ATDef.declaredType>;
                $element-><M::Element.setAttributeNodeNS> ($__attr);
                             ## This method changes |specified| flag
                $__attr->{<H::mn:node>}->{<H::infoset:specified>} = false;
                $__has_attr{defined $__nsuri ? $__nsuri : ''}->{$__ln} = true;
              } # LN
            } # pfx
            $__cfg-><M::c|DOMConfiguration.setParameter>
                      (<Q::cfg|clone-entity-reference-subtree> => $__copy_asis);
          }
        }
      }__;
    @@enImplNote:
      {TODO:: Implementation for non-namespace-aware version.
      }
    @@enImplNote:
      @@@: webbrowsers
        Firefox 1.5 and Opera 9 Preview 1 do not add default attributes
        by <M::Document.createElement> and <M::Document.createElementNS>.
        Opera does not support default attribute addition at 
        parsing time in internal subset neither.
        Firefox does support it but <A::Attr.specified> of the default
        attributes are set to <DOM::true>.

  @Method:
     @@Name:  createDocumentFragment
     @@Description:
       @@@lang:en
       @@@@:
         Create an empty <IF::DocumentFragment> object.
     @@Return:
        @@@Type:  DocumentFragment
        @@@Description:
          @@@@lang:en
          @@@@@:
            The new <IF::DocumentFragment> object.
        @@@PerlDef:
            my $docNode = $self->{<H::mn:node>};
            my $node = <ClassM::ManakaiDOMDocumentFragment.newObject>;
            __CODE{mn|setXRefNode||ManakaiDOM|Perl::
              $referrer => {$node},
              $propName => {<H::DOMCore:ownerDocument>},
              $referent => {$docNode},
            }__;
            $r = <ClassM::ManakaiDOMNode.getNodeReference> ($node);
    @@SpecLevel:1
    @@Level[list]:
      1
      2
      3
  @Method:
     @@Name:  createTextNode
     @@Description:
       @@@lang:en
       @@@@:
         Create a <IF::Text> node.
     @@Param:
        @@@Name:  data
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The data for the node.
     @@Return:
        @@@Type:  Text
        @@@Description:
          @@@@lang:en
          @@@@@:
            The new <IF::Text> object.
        @@@PerlDef:
            my $docNode = $self->{<H::mn:node>};
            my $node = <ClassM::ManakaiDOMText.newObject>;
            __CODE{mn|setXRefNode||ManakaiDOM|Perl::
              $referrer => {$node},
              $propName => {<H::DOMCore:ownerDocument>},
              $referent => {$docNode},
            }__;
            $node->{<H::infoset:content>} = defined $data ? $data : '';
            $r = <ClassM::ManakaiDOMNode.getNodeReference> ($node);
    @@SpecLevel:1
    @@Level[list]:
      1
      2
      3
  @Method:
     @@Name:  createComment
     @@Description:
       @@@lang:en
       @@@@:
         Create a <IF::Comment> node.
     @@Param:
        @@@Name:  data
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The data for the node.
     @@Return:
        @@@Type:  Comment
        @@@Description:
          @@@@lang:en
          @@@@@:
            The new <IF::Comment> object.
        @@@PerlDef:
            my $docNode = $self->{<H::mn:node>};
            my $node = <ClassM::ManakaiDOMComment.newObject>;
            __CODE{mn|setXRefNode||ManakaiDOM|Perl::
              $referrer => {$node},
              $propName => {<H::DOMCore:ownerDocument>},
              $referent => {$docNode},
            }__;
            $node->{<H::infoset:content>} = defined $data ? $data : '';
            $r = <ClassM::ManakaiDOMNode.getNodeReference> ($node);
    @@SpecLevel:1
    @@Level[list]:
      1
      2
      3
  @Method:
     @@Name:  createCDATASection
     @@Description:
       @@@lang:en
       @@@@:
         Create a <IF::DOMXML:CDATASection> node.
     @@Param:
        @@@Name:  data
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            The data for the <XML::CDATA> section.
     @@Return:
        @@@Type:  
          DOMXML:CDATASection
        @@@Description:
          @@@@lang:en
          @@@@@: 
            The newly created <IF::DOMXML:CDATASection> node.
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:NOT_SUPPORTED_ERR
          @@@@SubType:
            @@@@@QName:
              MDOMX:MDOM_DOC_NOSUPPORT_XML
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                This document does not support the <Feature::XML> feature. 
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              HTML-only DOM implementations must also implement this method. 
              The DOM Level 3 Core Specification should have changed 
              the description from <QUOTE::if this document is an HTML document> 
              to <QUOTE::if this document does not support the <Feature::XML> 
              feature> for consistency with other non-HTML methods.
        @@@PerlDef:
            my $docNode = $self->{<H::mn:node>};
            unless (<Code::DOMMain:docSupportsXMLFeature::
                              $DOCOBJ = $docNode>) {
              __EXCEPTION{
                MDOMX:MDOM_DOC_NOSUPPORT_XML::
              }__;
            }
            my $node = <ClassM::DOMXML:ManakaiDOMCDATASection.newObject>;
            __CODE{mn|setXRefNode||ManakaiDOM|Perl::
              $referrer => {$node},
              $propName => {<H::DOMCore:ownerDocument>},
              $referent => {$docNode},
            }__;
            $node->{<H::infoset:content>} = defined $data ? $data : '';
            $r = <ClassM::ManakaiDOMNode.getNodeReference> ($node);
    @@SpecLevel:1
    @@Level[list]:
      1
      2
      3
  @Method:
     @@Name:  createProcessingInstruction
     @@Description:
       @@@lang:en
       @@@@:
         Create a <IF::DOMXML:ProcessingInstruction> node.
     @@Param:
        @@@Name:  target
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            The target name of the processing instruction to create.
        @@@ImplNote:
          @@@@lang:en
          @@@@@:
            This is an XML <CODE::Name>, not an XML Names <CODE::NCName>.
        @@@ImplNote:
          @@@@lang:en
          @@@@@:
            The XML Specifications prohibit target names 
            matching to <XML::xml> in any lower/upper-case. 
            The DOM Specifications does not.
     @@Param:
        @@@Name:  data
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            The data for the node.
     @@Return:
        @@@Type:  
          DOMXML:ProcessingInstruction
        @@@Description:
          @@@@lang:en
          @@@@@:
            The new <IF::DOMXML:ProcessingInstruction> object.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_BAD_NAME
        @@@@enDesc:
          If the <P::name> is not an XML <CODE::Name>.
        @@@@UnlessStrictErrorChecking:
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:NOT_SUPPORTED_ERR
          @@@@SubType:
            @@@@@QName:
              MDOMX:MDOM_DOC_NOSUPPORT_XML
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                This document does not support the <Feature::XML> feature.
        @@@PerlDef:
            my $docNode = $self->{<H::mn:node>};
            my $version = <Code::getDocumentXMLVersion::
                                    $DOCOBJ = $docNode>;
            unless (defined $version) {
              __EXCEPTION{
                MDOMX:MDOM_DOC_NOSUPPORT_XML::
              }__;
            }
            if (<Code::doStrictErrorChecking:: $nodeRef = $self>) {
              __CODE{DOMMain:ensureXMLName:: $INPUT => $target,
                                             $INPUT_PARAM_NAME => 'target',
                                             $XMLVERSION => $version}__;
            }
            my $node = <ClassM::DOMXML:ManakaiDOMProcessingInstruction
                                               .newObject>;
            __CODE{mn|setXRefNode||ManakaiDOM|Perl::
              $referrer => {$node},
              $propName => {<H::DOMCore:ownerDocument>},
              $referent => {$docNode},
            }__;
            $node->{<H::infoset:target>} = $target;
            $node->{<H::infoset:content>} = defined $data ? $data : '';
            $r = <ClassM::ManakaiDOMNode.getNodeReference> ($node);
    @@SpecLevel:1
    @@Level[list]:
      1
      2
      3
  @Method:
     @@Name:  createAttribute
     @@Description:
       @@@lang:en
       @@@@:
         Create an <IF::Attr> node.
     @@NSVersion: .createAttributeNS
     @@Param:
        @@@Name:  name
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The name of the attribute.
        @@@ImplNote:
          @@@@lang:en
          @@@@@:
            There is no case-sensitivility consideration of the <P::name> 
            in the DOM Specifications.  Maybe attribute names are 
            lower-cased if it is an HTML document.
     @@Return:
        @@@Type:  Attr
        @@@Description:
          @@@@lang:en
          @@@@@:
            A new <IF::Attr> object.
        @@@ImplNote:
          @@@@lang:en
          @@@@@:
          <A::Node.nodeName> := <P::name>, <A::Node.localName> := <DOM::null>, 
          <A::Node.prefix> := <DOM::null>, <A::Node.namespaceURI> := <DOM::null>, 
          value := empty.

          Spec does not say to set <A::Node.specified> to <DOM::true>.
          Neither Gecko does.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: INVALID_CHARACTER_ERR
          @@@@SubType:
            @@@@@QName:
              MDOMX:MDOM_BAD_NAME
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <P::name> is not a SGML or XML <CODE::Name>.
        @@@PerlDef:
            my $docNode = $self->{<H::mn:node>};
            my $version = <Code::getDocumentXMLVersion::
                                   $DOCOBJ = $docNode>;
            __CODE{DOMMain:ensureXMLName:: $INPUT => $name,
                                           $INPUT_PARAM_NAME => 'name',
                                           $XMLVERSION => $version}__;
            my $node = <ClassM::ManakaiDOMAttr.newObject>;
            __CODE{mn|setXRefNode||ManakaiDOM|Perl::
              $referrer => {$node},
              $propName => {<H::DOMCore:ownerDocument>},
              $referent => {$docNode},
            }__;
            $node->{<H::DOMCore:name>} = $name;
            $r = <ClassM::ManakaiDOMNode.getNodeReference> ($node);
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              TODO: The name should be case-normalized by the definition 
              of the markup language in use.
        @@@@enImplNote:
          @@@@@ddid: schema
          @@@@@For: ManakaiDOM|ManakaiDOM
          @@@@@@:
            The created node does not have DTD type information,
            since its element type is not known.

            Should <XA::xml:id> attribute has type info?

  @Method:
    @@Name: createEntityReference
    @@enDesc:
      Creates an <IF::EntityReference> node.  In addition, if the
      referenced entity is known, the child list of the <IF::EntityReference>
      node is made the same as that of the corresponding <IF::x|Entity> node.
    @@enDesc:
      @@@ddid: ns
      @@@For: ManakaiDOM|DOM2
      @@@@:
        Note that if any descendant of the <IF::x|Entity> node has
        an unbound namespace prefix, the corresponding descendant of 
        the created <IF::x|EntityReference> node is also unbound,
        i.e. its <A::Node.namespaceURI> is <DOM::null>.
    @@DOMMain:isNamespaceUnaware: 1
    @@Param:
      @@@Name: name
      @@@Type: DOMString
      @@@enDesc:
        The name of the entity reference.

          {NOTE:: Namespace well-formedness check is not performed.
          }
      @@@enImplNote:
        <P::name> is <XML::lt> for example, then?
    @@Return:
      @@@Type: x|EntityReference
      @@@enDesc:
        The newly created <IF::x|EntityReference> node.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_BAD_NAME
        @@@@enDesc:
          If the <P::name> is not an XML <CODE::Name> according
          to the XML version of the <IF::Document>.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_DOC_NOSUPPORT_XML
        @@@@enDesc:
          If it is an HTML document.
      @@@PerlDef:
        our $CreateEntityReference_OpenEntity;
          ## NOTE: Multithread unsafe
            my $docNode = $self->{<H::mn:node>};
            my $version = <Code::getDocumentXMLVersion::
                                    $DOCOBJ = $docNode>;
            unless (defined $version) {
              __EXCEPTION{
                MDOMX:MDOM_DOC_NOSUPPORT_XML::
              }__;
            }
            __CODE{DOMMain:ensureXMLName::
                        $INPUT => $name, $XMLVERSION => $version,
                        $INPUT_PARAM_NAME => 'name'}__;
            my $node = <ClassM::DOMXML:ManakaiDOMEntityReference.newObject>;
            __CODE{mn|setXRefNode||ManakaiDOM|Perl::
              $referrer => {$node},
              $propName => {<H::DOMCore:ownerDocument>},
              $referent => {$docNode},
            }__;
            $node->{<H::DOMCore:name>} = $name;
            $r = <ClassM::ManakaiDOMNode.getNodeReference> ($node);

        ## Expansion
        __DEEP{
          unless ($CreateEntityReference_OpenEntity->{$name}) {
            local $CreateEntityReference_OpenEntity->{$name} = true;
            my $__doctype = $self-><AG::Document.doctype>;
            $__doctype = $__doctype-><M::Node.getFeature>
                                     (<Q::ManakaiDOM:XDoctype> => '3.0')
              if $__doctype;
          if ($__doctype) {
            my $__et = $__doctype-><M::DTDef.getGeneralEntityNode> ($name);
            if ($__et) {
              local $self->{<H::mn:node>}->{<H::c|strictErrorChecking>} = false;
              my @node;
              for my $c (@{$__et-><AG::Node.childNodes>}) {
                my $clone = $c-><M::Node.cloneNode> (true);
                $r-><M::Node.appendChild> ($clone);
                push @node, $clone;
              }
              if ($self->{<H::mn:node>}
                       ->{<H::cfg|entity-reference-read-only>}) {
                while (@node) {
                  my $node = shift @node;
                  $node->{<H::mn:node>}->{<H::c|read-only>} = true;
                  push @node, @{$node-><AG::Node.childNodes>};
                  push @node, values %{$node-><AG::Node.attributes> or {}};
                }
                $r->{<H::mn:node>}->{<H::c|read-only>} = true;
              }
              $r->{<H::mn:node>}->{<H::ManakaiDOM:isExpanded>}
                = $__et->{<H::mn:node>}->{<H::x|hasReplacementTree>};
            }
          }
          }
        }__;

    @@XDTest:
      @@@QName: Document.createER.nodef.test
      @@@PerlDef:
        my $doc;
        __CODE{createEmptyDocumentForTest:: $doc => $doc}__;

        my $ent = $doc-><M::Document.createEntityReference> ('ent1');
        $test->assert_isa ($ent, <IFName::x|EntityReference>);
        
        $test->id ('node.name');
        $test->assert_equals ($ent-><AG::Node.nodeName>, 'ent1');

        $test->id ('not.expanded');
        $test->assert_false ($ent-><AG::x|EntityReference.isExpanded>);

        $test->id ('empty');
        $test->assert_false ($ent-><M::Node.hasChildNodes>);
    @@XDTest:
      @@@QName: Document.createER.hasdef.test
      @@@PerlDef:
        my $doc;
        __CODE{createEmptyDocumentForTest:: $doc => $doc}__;
        my $docd = $doc-><M::Node.getFeature> (<Q::ManakaiDOM:XDoctype>, '3.0');
        my $dtd = $docd-><M::d|DocumentXDoctype.createDocumentTypeDefinition>
                           ('doctype');
          my $et = $docd-><M::d|DocumentXDoctype.createGeneralEntity>
                             ('ent1');
          $et-><AS::Node.textContent> ('replacement text content');
          $et-><AS::x|Entity.hasReplacementTree> (true);
        $dtd-><M::DTDef.setGeneralEntityNode> ($et);
        $doc-><M::Node.appendChild> ($dtd);

        my $ent = $doc-><M::Document.createEntityReference> ('ent1');
        $test->assert_isa ($ent, <IFName::x|EntityReference>);
        
        $test->id ('node.name');
        $test->assert_equals ($ent-><AG::Node.nodeName>, 'ent1');

        $test->id ('expanded');
        $test->assert_true ($ent-><AG::x|EntityReference.isExpanded>);

        $test->id ('not.empty');
        $test->assert_true ($ent-><M::Node.hasChildNodes>);

        $test->id ('text.content');
        $test->assert_equals ($ent-><AG::Node.textContent>,
                              'replacement text content');

        $test->id ('is.read.only');
        $test->assert_exception (code => sub {
          $ent-><AS::Node.textContent> ('new value');
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);
    @@XDTest:
      @@@QName: Document.createER.hasdef.no-read-only.test
      @@@PerlDef:
        my $doc;
        __CODE{createEmptyDocumentForTest:: $doc => $doc}__;
        my $docd = $doc-><M::Node.getFeature> (<Q::ManakaiDOM:XDoctype>, '3.0');
        my $dtd = $docd-><M::d|DocumentXDoctype.createDocumentTypeDefinition>
                           ('doctype');
          my $et = $docd-><M::d|DocumentXDoctype.createGeneralEntity>
                             ('ent1');
          $et-><AS::Node.textContent> ('replacement text content');
          $et-><AS::x|Entity.hasReplacementTree> (true);
        $dtd-><M::DTDef.setGeneralEntityNode> ($et);
        $doc-><M::Node.appendChild> ($dtd);
        $doc-><AG::Document.domConfig>
            -><M::c|DOMConfiguration.setParameter>
                (<Q::cfg|entity-reference-read-only> => false);

        my $ent = $doc-><M::Document.createEntityReference> ('ent1');
        $test->assert_isa ($ent, <IFName::x|EntityReference>);
        
        $test->id ('node.name');
        $test->assert_equals ($ent-><AG::Node.nodeName>, 'ent1');

        $test->id ('expanded');
        $test->assert_true ($ent-><AG::x|EntityReference.isExpanded>);

        $test->id ('not.empty');
        $test->assert_true ($ent-><M::Node.hasChildNodes>);

        $test->id ('text.content');
        $test->assert_equals ($ent-><AG::Node.textContent>,
                              'replacement text content');

        $test->id ('is.not.read.only');
        $ent-><AS::Node.textContent> ('new value');
        $test->assert_equals ($ent-><AG::Node.textContent>,
                              'new value');
    @@XDTest:
      @@@QName: Document.createER.hasdef.recursive.direct.test
      @@@PerlDef:
        my $doc;
        __CODE{createEmptyDocumentForTest:: $doc => $doc}__;
        my $docd = $doc-><M::Node.getFeature> (<Q::ManakaiDOM:XDoctype>, '3.0');
        my $dtd = $docd-><M::d|DocumentXDoctype.createDocumentTypeDefinition>
                           ('doctype');
          my $ent0 = $doc-><M::Document.createEntityReference> ('ent1');
          $test->assert_false ($ent0-><AG::x|EntityReference.isExpanded>);
          my $et = $docd-><M::d|DocumentXDoctype.createGeneralEntity>
                             ('ent1');
          $et-><M::Node.appendChild> ($ent0);
          $et-><AS::x|Entity.hasReplacementTree> (true);
        $dtd-><M::DTDef.setGeneralEntityNode> ($et);
        $doc-><M::Node.appendChild> ($dtd);

        $test->id ('create');
        my $ent = $doc-><M::Document.createEntityReference> ('ent1');
        $test->assert_isa ($ent, <IFName::x|EntityReference>);
        $test->assert_true ($ent-><AG::x|EntityReference.isExpanded>);

        $test->assert_not_null ($ent-><AG::Node.firstChild>);
        $test->assert_false ($ent-><AG::Node.firstChild>
                                 -><AG::x|EntityReference.isExpanded>);
    @@XDTest:
      @@@QName: Document.createER.hasdef.recursive.indirect.test
      @@@PerlDef:
        my $doc;
        __CODE{createEmptyDocumentForTest:: $doc => $doc}__;
        my $docd = $doc-><M::Node.getFeature> (<Q::ManakaiDOM:XDoctype>, '3.0');
        my $dtd = $docd-><M::d|DocumentXDoctype.createDocumentTypeDefinition>
                           ('doctype');
          my $ent0 = $doc-><M::Document.createEntityReference> ('ent2');
          $test->assert_false ($ent0-><AG::x|EntityReference.isExpanded>);
          my $et = $docd-><M::d|DocumentXDoctype.createGeneralEntity>
                             ('ent1');
          $et-><M::Node.appendChild> ($ent0);
          $et-><AS::x|Entity.hasReplacementTree> (true);

          my $ent0_2 = $doc-><M::Document.createEntityReference> ('ent1');
          my $et_2 = $docd-><M::d|DocumentXDoctype.createGeneralEntity>
                             ('ent2');
          $et_2-><M::Node.appendChild> ($ent0_2);
          $et_2-><AS::x|Entity.hasReplacementTree> (true);
        $dtd-><M::DTDef.setGeneralEntityNode> ($et);
        $doc-><M::Node.appendChild> ($dtd);

        $test->id ('create');
        my $ent = $doc-><M::Document.createEntityReference> ('ent1');
        $test->assert_isa ($ent, <IFName::x|EntityReference>);
        $test->assert_true ($ent-><AG::x|EntityReference.isExpanded>);

        $test->assert_not_null ($ent-><AG::Node.firstChild>);
        $test->assert_false ($ent-><AG::Node.firstChild>
                                 -><AG::x|EntityReference.isExpanded>);

  @Method:
     @@Name:  getElementsByTagName
     @@Description:
       @@@lang:en
       @@@@:
         Return a <IF::NodeList> of all the <IF::Element> in document 
         order with a given element type name and are contained in the document.
         \
         {NOTE:: <IF::Element> nodes also have the 
                 <M::Element.getElementsByTagName> method.
         \
         }
     @@ImplNote:
       @@@lang:en
       @@@@:
         Does <QUOTE::contained> mean that an <IF::Element> node 
         which is not a descendant of the <IF::Document> does not match?
       \
         The DOM Level 2 Specification specifies as <QUOTE::pre-order 
         traversal>.  The DOM Level 3 Specifies it by 
         <QUOTE::in document order> and this makes the ambigiousness.
       \
         Should <IF::Element> nodes in <IF::DOMXML:Entity> nodes be matched?
     @@Param:
        @@@Name:  tagname
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            The name of the element type to match on.
          \
            The case-sensitivility depends on the markup language in use.
        @@@InCase:
          @@@@Value:*
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Match all element type names.
     @@Return:
        @@@Type:NodeList
        @@@actualType:  
          ManakaiDOMCore:ManakaiDOMGetElementsNodeList
        @@@Description:
          @@@@lang:en
          @@@@@:
            A new <IF::NodeList> object containing all the matched 
            <IF::Element> objects.
        @@@PerlDef:
            my $node = $self->{<H::mn:node>};
            my $chk;
            if (defined $tagname and $tagname eq '*') {
              $chk = sub { 1 };
            } else {
              my $name = "$tagname";
              $chk = sub {
                my ($self) = @_;
                if (defined $self->{<H::infoset:localName>}) {
                  if (defined $self->{<H::infoset:prefix>}) {
                    return ($self->{<H::infoset:prefix>} . ':' .
                            $self->{<H::infoset:localName>} eq $name)
                               ? true : false;
                  } else {
                    return ($self->{<H::infoset:localName>} eq $name)
                               ? true : false;
                  }
                } else {
                  return ($self->{<H::DOMCore:name>} eq $name)
                               ? true : false;
                }
              };
            }
            __CODE{getNodeRef::
              $object => $node, $ref => $r,
              $class => {
                <ClassName::ManakaiDOMCore:ManakaiDOMGetElementsNodeList>
              },
            }__;
            $r->{<H::ManakaiDOMCore:nodeMatch>} = $chk;
    @@NSVersion:.getElementsByTagNameNS
  @Method:
     @@Name:  importNode
     @@Description:
       @@@lang:en
       @@@@:
         Import a node from another document to this document, 
         without altering or removing the source node from 
         the original document (i.e. create a new copy of 
         the source node in this document).
     @@ImplNote:
       @@@lang:en
       @@@@:
         Copied: <A::Node.nodeName>, <A::Node.nodeType>, <A::Node.prefix>, 
         <A::Node.localName>, <A::Node.namespaceURI>, <A::Entity.publicId>, 
         <A::Entity.systemId>, <A::Entity.notationName>, 
         <A::Notation.publicId>, <A::Notation.systemId>, 
         <A::ProcessingInstruction.target>, <A::ProcessingInstruction.data>, 
         <A::CharacterData.data>, <A::CharacterData.length>.
       \
         User data is not carried over.  However, if any 
         <IF::UserDataHandler>s has specified, these handlers will 
         be called with the appropriate parameters before this method 
         returns.
       \
         <A::Node.parentNode> := <DOM::null>.
         <A::Attr.ownerElement> := <DOM::null>. 
         <A::Attr.specified> := <DOM::true>.
         Specified attribute nodes attached to the <IF::Element> node 
         are imported.  Default attributes are created if exists.
     @@Param:
        @@@Name:  importedNode
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@:
            The node to import.
            \
            Note that <IF::Document> or <IF::DOMXML:DocumentType> nodes cannot 
            be imported.
     @@Param:
        @@@Name:  deep
        @@@Type:  DOMMain|boolean||ManakaiDOM|all
        @@@Description:
          @@@@lang:en
          @@@@@:
            Whether the subtree under the <P::importedNode> 
            is recursively imported or not.
            \
            This parameter has no effect on <IF::Attr>,
            <IF::DOMXML:EntityReference>, 
            <IF::DOMXML:Notation>, <IF::DOMXML:ProcessingInstruction>,
            <IF::Text>, 
            <IF::DOMXML:CDATASection> and <IF::Comment> nodes.
            The descendants of 
            the <IF::Attr> node are 
            always imported.  The descendants of the
            <IF::DOMXML:EntityReference> 
            node are always not imported.
        @@@InCase:
          @@@@Value:true
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The descendants are recursively imported if the 
              <P::importedNode> is of <IF::DocumentFragment>, <IF::Element> or 
              <IF::DOMXML:Entity>.
        @@@InCase:
          @@@@Value:false
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Import only the node itself.
     @@Return:
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@:
            The imported node.
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:NOT_SUPPORTED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The type of node being imported is not supported.
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              Maybe, if this document is not <Feature::XML> and 
              the node type is either <IF::DOMXML:ProcessingInstruction>, 
              <IF::DOMXML:Notation>, <IF::DOMXML:EntityReference>,
              <IF::DOMXML:Entity> or 
              <IF::DOMXML:CDATASection>.  And if namespaced nodes are imported?
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:INVALID_CHARACTER_ERR
          @@@@SubType:
            @@@@@QName:
              MDOMX:MDOM_BAD_NAME
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                One of the imported names is not a SGML or XML <CODE::Name>.
     @@L2:
     @@Level[list]:  2
     @@SpecLevel:2
     @@For:
       ManakaiDOM:DOM2

  @L2Method:
     @@Name:  createElementNS
     @@Description:
       @@@lang:en
       @@@@:
         Create an element.
       \
         If there are known attributes with default values, 
         <IF::Attr> nodes representing them are automatically 
         created and attached to the element created.
     @@NoNSVersion:.createElement
     @@Param:
        @@@Name:  namespaceURI
        @@@Type:
          DOMMain:DOMString
        @@@actualType:
          ManakaiDOM:ManakaiDOMNamespaceURI
        @@@Description:
          @@@@lang:en
          @@@@@:
            The namespace URI of the element to create.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The element to create will have no namespace.
     @@Param:
        @@@Name:  qualifiedName
        @@@Type:  
          DOMMain:DOMString
        @@@actualType:
          @@@@@:
            DOMMain:ManakaiDOMXMLQName
          @@@@ManakaiDOM:noInputNormalize:1
        @@@Description:
          @@@@lang:en
          @@@@@:
            The qualified name of the type of the element to create.
     @@Return:
        @@@Type:  Element
        @@@actualType: ManakaiDOMElement
        @@@Description:
          @@@@lang:en
          @@@@@:
            A new <IF::Element> object.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: INVALID_CHARACTER_ERR
          @@@@SubType:
            @@@@@QName:
              MDOMX:MDOM_BAD_NAME
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <P::qualifiedName> is not an XML <CODE::Name>.
            @@@@@SpecLevel:2
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NAMESPACE_ERR
          @@@@SubType:
            @@@@@QName:
              MDOMX:MDOM_NS_MALFORMED_QNAME
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@: 
                The <P::qualifiedName> is malformed as a qualified name.
            @@@@@SpecLevel:2
          @@@@SubType:
            @@@@@QName:
              MDOMX:MDOM_NS_PREFIX_WITH_NULL_URI
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <P::qualifiedName> has a prefix and the
                <P::namespaceURI> is <DOM::null>.
            @@@@@SpecLevel:2
          @@@@SubType:
            @@@@@QName:
              MDOMX:MDOM_NS_XML_WITH_OTHER_URI
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <P::qualifiedName> has a prefix that is <CODE::xml> and the
                <P::namespaceURI> is different from
                <URI::http://www.w3.org/XML/1998/namespace>.
            @@@@@SpecLevel:2
          @@@@SubType:
            @@@@@QName:
              MDOMX:MDOM_NS_XMLNS_WITH_OTHER_URI
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <P::qualifiedName> has a prefix that is <XML::xmlns> and
                the <P::namespaceURI> is different from the
                <URI::http://www.w3.org/2000/xmlns>.
            @@@@@SpecLevel:3
          @@@@SubType:
            @@@@@QName:
              MDOMX:MDOM_NS_XMLNSQ_WITH_OTHER_URI
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <P::qualifiedName> is <XA::xmlns> and
                the <P::namespaceURI> is different from the
                <URI::http://www.w3.org/2000/xmlns>.
            @@@@@SpecLevel:3
          @@@@SubType:
            @@@@@QName:
              MDOMX:MDOM_NS_OTHER_WITH_XML_URI
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <P::namespaceURI> is 
                <URI::http://www.w3.org/XML/1998/namespace> and the 
                prefix of the <P::qualifiedName> is different from 
                <XML::xml>.
            @@@@@SpecLevel[list]:
          @@@@SubType:
            @@@@@QName:
              MDOMX:MDOM_NS_OTHER_WITH_XMLNS_URI
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <P::namespaceURI> is <URI::http://www.w3.org/2000/xmlns> and 
                neither the <P::qualifiedName> nor its prefix is <XML::xmlns>.
            @@@@@SpecLevel:3
          @@@@SubType:
            @@@@@QName:
              MDOMX:MDOM_NS_XMLNS_XMLNS
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <P::qualifiedName> is <XA::xmlns:xmlns>.
            @@@@@SpecLevel[list]:
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:NOT_SUPPORTED_ERR
          @@@@SubType:
            @@@@@QName:
              MDOMX:MDOM_DOC_NOSUPPORT_XML
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                This document does not support the <Feature::XML> 
                feature.
        @@@PerlDef:
          @@@@For:
            ManakaiDOM:DOMXMLFeature
          @@@@@:
            my $docNode = $self->{<H::mn:node>};
            my ($prefix, $lname) = split /:/, $qualifiedName, 2;
            ($prefix, $lname) = (null, $prefix) unless defined $lname;
            if (<Code::doStrictErrorChecking:: $nodeRef = $self>) {
              my $version = <Code::getDocumentXMLVersion:: $DOCOBJ = $docNode>;
              unless (defined $version) {
                __EXCEPTION{MDOMX:MDOM_DOC_NOSUPPORT_XMLNS}__;
              }
              __CODE{DOMMain:ensureXMLQName::
                     $INPUT = $qualifiedName, 
                     $INPUT_PARAM_NAME = 'qualifiedName',
                     $XMLVERSION = $version,
              }__;
              __CODE{DOMMain:checkXMLNamesQName::
                     $PREFIX => $prefix, $NSURI => $namespaceURI,
                     $LNAME => $lname,
              }__;
            } # error checking

            my $node = <ClassM::ManakaiDOMElement.newObject>;
            __CODE{mn|setXRefNode||ManakaiDOM|Perl::
              $referrer => {$node},
              $propName => {<H::DOMCore:ownerDocument>},
              $referent => {$docNode},
            }__;
            __CODE{DISPerl|HashStringRef||ManakaiDOM|all::
              $result => {$node->{<H::infoset:namespaceName>}},
              $given => $namespaceURI,
            }__;
            $node->{<H::infoset:prefix>} = $prefix;
            $node->{<H::infoset:localName>} = $lname;
            $r = <ClassM::ManakaiDOMNode.getNodeReference> ($node);

        ## Default attributes
        __CODE{t|exposeDefaultAttributes::
          $document => $self,
          $element => $r,
          $element_type => $qualifiedName,
        }__;
        @@@disDef:
          @@@@ForCheck:
            !ManakaiDOM:DOMXMLFeature
          @@@@DOMMain:raiseException:
            MDOMX:MDOM_IMPL_NOSUPPORT_XMLNS

    @@Test:
      @@@ForCheck: ManakaiDOM|DOMXMLFeature
      @@@QName: Document.createElementNS.nodefaultattr.test
      @@@PerlDef:
        my $doc;
        __CODE{createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createElementNS> (null, 'et1');

        $test->assert_num_equals
                 (actual_value => $el-><AG::Node.attributes>
                                     -><AG::NamedNodeMap.length>,
                  expected_value => 0);
    @@Test:
      @@@ForCheck: ManakaiDOM|DOMXMLFeature
      @@@QName: Document.createElementNS.defaultattr.1.test
      @@@PerlDef:
        my $doc;
        __CODE{createEmptyDocumentForTest:: $doc => $doc}__;
        my $docd = $doc-><M::Node.getFeature> (<Q::ManakaiDOM:XDoctype>, '3.0');
        my $dtd = $docd-><M::d|DocumentXDoctype.createDocumentTypeDefinition>
                           ('doctype');
          my $et = $docd-><M::d|DocumentXDoctype.createElementTypeDefinition>
                             ('et1');
            my $at = $docd-><M::d|DocumentXDoctype.createAttributeDefinition>
                               ('dattr1');
            $at-><AS::ATDef.defaultType> (<C::ATDef.EXPLICIT_DEFAULT>);
            $at-><AS::Node.textContent> ('dattr1 default ');
          $et-><M::ETDef.setAttributeDefinitionNode> ($at);
        $dtd-><M::DTDef.setElementTypeDefinitionNode> ($et);
        $doc-><M::Node.appendChild> ($dtd);

        my $el = $doc-><M::Document.createElementNS> (null, 'et1');

        $test->id ('attributes.length');
        $test->assert_num_equals
                 (actual_value => $el-><AG::Node.attributes>
                                     -><AG::NamedNodeMap.length>,
                  expected_value => 1);
        
        $test->id ('has.attribute');
        $test->assert_true ($el-><M::Element.hasAttribute> ('dattr1'));

        $test->id ('get.attr.node');
        my $an = $el-><M::Element.getAttributeNode> ('dattr1');
        $test->assert_isa ($an, <IFName::Attr>);

        $test->id ('attr.text.content');
        $test->assert_equals ($an-><AG::Node.textContent>, 'dattr1 default ');
        
        $test->id ('attr.specified');
        $test->assert_false ($an-><AG::Attr.specified>);
    @@Test:
      @@@ForCheck: ManakaiDOM|DOMXMLFeature
      @@@QName: Document.createElementNS.defaultattr.typed.test
      @@@PerlDef:
        my $doc;
        __CODE{createEmptyDocumentForTest:: $doc => $doc}__;
        my $docd = $doc-><M::Node.getFeature> (<Q::ManakaiDOM:XDoctype>, '3.0');
        my $dtd = $docd-><M::d|DocumentXDoctype.createDocumentTypeDefinition>
                           ('doctype');
          my $et = $docd-><M::d|DocumentXDoctype.createElementTypeDefinition>
                             ('et1');
            my $at = $docd-><M::d|DocumentXDoctype.createAttributeDefinition>
                               ('dattr1');
            $at-><AS::ATDef.defaultType> (<C::ATDef.EXPLICIT_DEFAULT>);
            $at-><AS::Node.textContent> ('dattr1 default ');
            $at-><AS::ATDef.declaredType> (<C::ATDef.NMTOKENS_ATTR>);
          $et-><M::ETDef.setAttributeDefinitionNode> ($at);
        $dtd-><M::DTDef.setElementTypeDefinitionNode> ($et);
        $doc-><M::Node.appendChild> ($dtd);

        my $el = $doc-><M::Document.createElementNS> (null, 'et1');

        $test->id ('attributes.length');
        $test->assert_num_equals
                 (actual_value => $el-><AG::Node.attributes>
                                     -><AG::NamedNodeMap.length>,
                  expected_value => 1);
        
        $test->id ('has.attribute');
        $test->assert_true ($el-><M::Element.hasAttribute> ('dattr1'));

        $test->id ('get.attr.node');
        my $an = $el-><M::Element.getAttributeNode> ('dattr1');
        $test->assert_isa ($an, <IFName::Attr>);

        $test->id ('attr.text.content');
        $test->assert_equals ($an-><AG::Node.textContent>, 'dattr1 default ');
        
        $test->id ('attr.specified');
        $test->assert_false ($an-><AG::Attr.specified>);

        $test->id ('attr.type');
        my $ti = $an-><AG::Attr.schemaTypeInfo>;
        $test->assert_equals
                 ($ti-><AG::c|TypeInfo.typeNamespace>, <Q::xml-dtd:>);
        $test->assert_equals ($ti-><AG::c|TypeInfo.typeName>, 'NMTOKENS');

  @Method:
     @@Name:  createAttributeNS
     @@Description:
       @@@lang:en
       @@@@:
         Create an attribute of the given qualified name and namespace URI.
     @@NoNSVersion: .createAttribute
     @@Param:
        @@@Name:  namespaceURI
        @@@Type:
          DOMMain:DOMString
        @@@actualType:
          ManakaiDOM:ManakaiDOMNamespaceURI
        @@@Description:
          @@@@lang:en
          @@@@@: The namespace URI of the attribute to create.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The attribute has no namespace.
     @@Param:
        @@@Name:  qualifiedName
        @@@Type:  
          DOMMain:DOMString
        @@@actualType:
          @@@@@:
            DOMMain:ManakaiDOMXMLQName
          @@@@ManakaiDOM:noInputNormalize:1
        @@@Description:
          @@@@lang:en
          @@@@@: The qualified name of the attribute to create.
     @@Return:
        @@@Type:  Attr
        @@@actualType: ManakaiDOMAttr
        @@@Description:
          @@@@lang:en
          @@@@@: A new attribute object.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: INVALID_CHARACTER_ERR
          @@@@SubType:
            @@@@@QName:
              MDOMX:MDOM_BAD_NAME
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <P::qualifiedName> is not an XML <CODE::Name>.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NAMESPACE_ERR
          @@@@SubType:
            @@@@@QName:
              MDOMX:MDOM_NS_MALFORMED_QNAME
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@: 
                The <P::qualifiedName> is malformed as a qualified name.
            @@@@@SpecLevel:2
          @@@@SubType:
            @@@@@QName:
              MDOMX:MDOM_NS_PREFIX_WITH_NULL_URI
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <P::qualifiedName> has a prefix and the
                <P::namespaceURI> is <DOM::null>.
            @@@@@SpecLevel:2
          @@@@SubType:
            @@@@@QName:
              MDOMX:MDOM_NS_XML_WITH_OTHER_URI
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <P::qualifiedName> has a prefix that is <CODE::xml> and the
                <P::namespaceURI> is different from
                <URI::http://www.w3.org/XML/1998/namespace>.
            @@@@@SpecLevel:2
          @@@@SubType:
            @@@@@QName:
              MDOMX:MDOM_NS_XMLNS_WITH_OTHER_URI
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <P::qualifiedName> has a prefix that is <XML::xmlns> and
                the <P::namespaceURI> is different from the
                <URI::http://www.w3.org/2000/xmlns>.
            @@@@@SpecLevel:3
          @@@@SubType:
            @@@@@QName:
              MDOMX:MDOM_NS_XMLNSQ_WITH_OTHER_URI
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <P::qualifiedName> is <XA::xmlns> and
                the <P::namespaceURI> is different from the
                <URI::http://www.w3.org/2000/xmlns>.
            @@@@@SpecLevel:2
          @@@@SubType:
            @@@@@QName:
              MDOMX:MDOM_NS_OTHER_WITH_XML_URI
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <P::namespaceURI> is 
                <URI::http://www.w3.org/XML/1998/namespace> and the 
                prefix of the <P::qualifiedName> is different from 
                <XML::xml>.
            @@@@@SpecLevel[list]:
          @@@@SubType:
            @@@@@QName:
              MDOMX:MDOM_NS_OTHER_WITH_XMLNS_URI
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <P::namespaceURI> is <URI::http://www.w3.org/2000/xmlns> and 
                neither the <P::qualifiedName> nor its prefix is <XML::xmlns>.
            @@@@@SpecLevel:3
          @@@@SubType:
            @@@@@QName:
              MDOMX:MDOM_NS_XMLNS_XMLNS
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <P::qualifiedName> is <XA::xmlns:xmlns>.
            @@@@@SpecLevel[list]:
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@: Is no-prefix with URI is OK?
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:NOT_SUPPORTED_ERR
          @@@@SubType:
            @@@@@QName:
              MDOMX:MDOM_DOC_NOSUPPORT_XML
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                This document does not support the <Feature::XML> 
                feature.
        @@@PerlDef:
          @@@@For:
            ManakaiDOM:DOMXMLFeature
          @@@@@:
            my $docNode = $self->{<H::mn:node>};
            my ($prefix, $lname) = split /:/, $qualifiedName, 2;
            ($prefix, $lname) = (null, $prefix) unless defined $lname;

            if (<Code::doStrictErrorChecking:: $nodeRef = $self>) {
              my $version = <Code::getDocumentXMLVersion:: $DOCOBJ = $docNode>;
              unless (defined $version) {
               __EXCEPTION{MDOMX:MDOM_DOC_NOSUPPORT_XMLNS}__;
              }
              __CODE{DOMMain:ensureXMLQName::
                     $INPUT = $qualifiedName, 
                     $INPUT_PARAM_NAME = 'qualifiedName',
                     $XMLVERSION = $version,
              }__;
              __CODE{DOMMain:checkXMLNamesQName::
                     $PREFIX => $prefix, $NSURI => $namespaceURI,
                     $LNAME => $lname,
              }__;
            } # error checking

            my $node = <ClassM::ManakaiDOMAttr.newObject>;
            __CODE{mn|setXRefNode||ManakaiDOM|Perl::
              $referrer => {$node},
              $propName => {<H::DOMCore:ownerDocument>},
              $referent => {$docNode},
            }__;
            $node->{<H::infoset:localName>} = $lname;
            __CODE{DISPerl|HashStringRef||ManakaiDOM|all::
              $result => {$node->{<H::infoset:namespaceName>}},
              $given => $namespaceURI,
            }__;
            $node->{<H::infoset:prefix>} = $prefix;
            $node->{<H::infoset:specified>} = true;
            $r = <ClassM::ManakaiDOMNode.getNodeReference> ($node);
        @@@disDef:
          @@@@ForCheck:
            !ManakaiDOM:DOMXMLFeature
          @@@@DOMMain:raiseException:
            MDOMX:MDOM_IMPL_NOSUPPORT_XMLNS
    @@SpecLevel:2
    @@Level[list]:
      2
      3
    @@For:
      ManakaiDOM:DOM2
  @Method:
     @@Name:  getElementsByTagNameNS
     @@Description:
        @@@lang:en
        @@@@:
          Return a <IF::NodeList> of all the <IF::Element> nodes 
          with a given local name and namespace URI in document order.
          \
          {NOTE:: <IF::Element> nodes also have the 
                  <M::Element.getElementsByTagNameNS> method.
          \
          }
     @@Param:
        @@@Name:  namespaceURI
        @@@Type:
          DOMMain:DOMString
        @@@actualType:
          ManakaiDOM:ManakaiDOMNamespaceURI
        @@@Description:
          @@@@lang:en
          @@@@@:
            The namespace URI of the elements to match on.
        @@@InCase:
          @@@@Value:*
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Match all namespaces.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
     @@Param:
        @@@Name:  localName
        @@@Type:  
          DOMMain:DOMString
        @@@actualType:
          @@@@@:
            DOMMain:ManakaiDOMXMLLocalName
          @@@@ManakaiDOM:noInputNormalize:1
        @@@Description:
          @@@@lang:en
          @@@@@:
            The local name of the elements to match on.
        @@@InCase:
          @@@@Value:*
          @@@@Description:
            @@@@@lang:en
            @@@@@@: Match all local names.
     @@Return:
        @@@Type:NodeList
        @@@actualType:
          ManakaiDOMCore:ManakaiDOMGetElementsNodeList
        @@@Description:
          @@@@lang:en
          @@@@@:
            A new <IF::NodeList> object containing all the 
            matched <IF::Element> objects.
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:NOT_SUPPORTED_ERR
          @@@@SubType:
            @@@@@QName:
              MDOMX:MDOM_IMPL_NOSUPPORT_XML
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The DOM implementation does not support the <Feature::XML> 
                feature and the language exposed through the 
                <IF::Document> is not support XML Namespaces.
          @@@@SpecLevel:
        @@@ImplNote:
          @@@@lang:en
          @@@@@:
            For <M::Element.getElementsByTagNameNS>, DOM Level 2 allows 
            HTML-only DOM implementations not to implement that method 
            and its Errata and DOM Level 3 say to raise 
            <X::DOMException.NOT_SUPPORTED_ERROR> if it is called.  
            <M::Document.getElementsByTagNameNS> should also raise the 
            exception, shouldn't it?
        @@@PerlDef:
          @@@@For:
            ManakaiDOM:DOMXMLFeature
          @@@@@:
            my $node = $self->{<H::mn:node>};
            my $chk;
            if (defined $namespaceURI) {
              if ($namespaceURI eq '*') {
                if (defined $localName and $localName eq '*') {
                  $chk = sub {
                    my ($self) = @_;
                    return defined $self->{<H::infoset:localName>}
                             ? true : false;
                      ## Any element node with local name
                  };
                } else {
                  $localName = "$localName";
                  $chk = sub {
                    my ($self) = @_;
                    return
                        (defined $self->{<H::infoset:localName>} and
                         $self->{<H::infoset:localName>} eq $localName)
                           ? true : false;
                  };
                }
              } else { ## Non-n u l l namespace URI
                $namespaceURI = "$namespaceURI";
                if (defined $localName and $localName eq '*') {
                  $chk = sub {
                    my ($self) = @_;
                    return (defined $self->{<H::infoset:namespaceName>} and
                            ${$self->{<H::infoset:namespaceName>}} eq $namespaceURI)
                              ? true : false;
                  };
                } else {
                  $localName = "$localName";
                  $chk = sub {
                    my ($self) = @_;
                    return
                        (defined $self->{<H::infoset:localName>} and
                         defined $self->{<H::infoset:namespaceName>} and
                         ${$self->{<H::infoset:namespaceName>}} eq $namespaceURI and
                         $self->{<H::infoset:localName>} eq $localName)
                           ? true : false;
                  };
                }
              }
            } else { ## Null namespace
              if (defined $localName and $localName eq '*') {
                $chk = sub {
                  my ($self) = @_;
                  return (defined $self->{<H::infoset:localName>} and
                          not defined $self->{<H::infoset:namespaceName>})
                            ? true : false;
                    ## Any element node with local name but not namespace URI
                };
              } else {
                $localName = "$localName";
                $chk = sub {
                  my ($self) = @_;
                  return
                      (defined $self->{<H::infoset:localName>} and
                       not defined $self->{<H::infoset:namespaceName>} and
                       $self->{<H::infoset:localName>} eq $localName)
                         ? true : false;
                };
              }
            }
            __CODE{getNodeRef::
              $object => $node, $ref => $r,
              $class => {
                <ClassName::ManakaiDOMCore:ManakaiDOMGetElementsNodeList>
              },
            }__;
            $r->{<H::ManakaiDOMCore:nodeMatch>} = $chk;
        @@@disDef:
          @@@@ForCheck:
            !ManakaiDOM:DOMXMLFeature
          @@@@DOMMain:raiseException:
            MDOMX:MDOM_IMPL_NOSUPPORT_XMLNS
     @@Level[list]:  
       2
       3
     @@SpecLevel:2
     @@For:
       ManakaiDOM:DOM2
     @@NoNSVersion:.getElementsByTagName
  @Method:
     @@Name:  getElementById
     @@Description:
       @@@lang:en
       @@@@:
         Return the <IF::Element> that has an <SGML::ID> attribute 
         with the given value.
       \
         If more than one element has an <SGML::ID> attribute 
         with that value, what is returned is undefined.
     @@ImplNote:
       @@@lang:en
       @@@@:
         DOM implementations are expected to use the <A::Attr.isId> 
         to detect an <SGML::ID> attribute.
       \
         <XML::ID> ATTRIBUTES, not <XML::ID> ELEMENTS.
       \
         Can an <IF::Element> that is not a descendant of the <IF::Document> 
         be returned?
     @@Param:
        @@@Name:  elementId
        @@@Type:  
          DOMMain:DOMString
        @@@actualType:
          @@@@@:
            DOMMain:ManakaiDOMXMLName
          @@@@ManakaiDOM:noInputNormalize:1
        @@@Description:
          @@@@lang:en
          @@@@@:
            The unique identifier for an element.
     @@Level[list]:  2
     @@SpecLevel:2
     @@For:
       ManakaiDOM:DOM2
     @@ImplNote:
       @@@lang:en
       @@@@:
         This method was first defined in the interface <IF::HTMLDocument> 
         in the DOM Level 1.
     @@Return:
        @@@Type:  Element
        @@@actualType: ManakaiDOMElement
        @@@Description:
          @@@@lang:en
          @@@@@:
            The matching element.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              No element with the specified <SGML::ID> exists.
       @@@PerlDef:
         my @nodeo = (@{$self->{<H::mn:node>}->{<H::infoset:children>}});
         NODES: while (my $nodeo = shift @nodeo) {
           next unless $nodeo->{<H::DOMCore:nodeType>} eq <H::infoset:Element>;
           for my $attro (map {values %$_}
                          values %{$nodeo->{<H::infoset:attributes>}}) {
             my $attr;
             __CODE{ManakaiNode:getWeakReference
                    ||ManakaiDOM:Perl::
                      $object => $attro, $ref => $attr,
                      $class => {<ClassName::ManakaiDOMAttr>},
             }__;
             if ($attr-><AG::ManakaiDOMAttr.isId> and
                 $attr-><AG::ManakaiDOMAttr.value> eq $elementId) {
               $r = <ClassM::ManakaiDOMNode.getNodeReference> ($nodeo);
               last NODES;
             }
           }
           push @nodeo, @{$nodeo->{<H::infoset:children>}};
         }
  @Attr:
     @@Name:  inputEncoding
     @@Description:
       @@@lang:en
       @@@@:
         The encoding used for this document at the time of 
         the parsing.
       \
         This attribute is corresponding to the [character encoding scheme] 
         property of the document infomation item.
     @@ImplNote:
        @@@lang:en
        @@@@:
          It is unclear what type of values are permitted. 
          IANA-registered charset names? XML encoding declaration 
          names?  Or, any names passed from the upper-level protocols?
     @@Get:
        @@@Type:  
          DOMMain:DOMString
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The input encoding is not known.
        @@@disDef:
          @@@@GetProp:
            infoset:characterEncodingScheme
     @@Level[list]:  3
     @@SpecLevel:3
     @@For:
       ManakaiDOM:DOM3

  @L3Attr:
     @@Name:  xmlEncoding
     @@Description:
       @@@lang:en
       @@@@:
         The value of the encoding declaration in the XML declaration 
         of the document.
     @@ImplNote:
       @@@lang:en
       @@@@:
         This attribute is NOT equal to the [character encoding scheme] 
         property of the document information item of the Infoset.
    @@Type: DOMMain|DOMString
     @@Get:
        @@@Description:
          @@@@lang:en
          @@@@@: The encoding.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The encoding is not specified or not known.
        @@@disDef:
          @@@@GetProp:
            DOMCore:xmlEncoding
    @@Set:
      @@@For: ManakaiDOM|ManakaiDOM
      @@@enDesc:
        The value of the encoding declaration.
      @@@nullCase:
        @@@@enDesc:
          The encoding declaration is omitted.
      @@@enImplNote:
        This is a manakai extension.
      @@@disDef:
        @@@@SetProp: DOMCore|xmlEncoding

  @Attr:
     @@Name:  xmlStandalone
     @@Description:
       @@@lang:en
       @@@@: 
         Whether the document is standalone or not.
       \
         This attribute is corresponding to the standalone declaration 
         in the XML declaration and the [standalone] property of the 
         document information item of the XML Infoset.
     @@ImplNote:
       @@@lang:en
       @@@@: Default false.
     @@Get:
        @@@Type:  
          DOMMain:boolean||ManakaiDOM|all
        @@@disDef:
          @@@@GetProp:
            infoset:standalone
     @@Set:
        @@@Type:  
          DOMMain:boolean||ManakaiDOM|all
        @@@Description:
          @@@@lang:en
          @@@@@: Whether standalone or not.
        @@@InCase:
          @@@@Value: true
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Standalone "yes".  Note that no verification is done when 
              setting the value.  DOM applications should use 
              the method "normalizeDocument" with the "validate" parameter 
              to verify whether the value match the Validity Constraint.
        @@@InCase:
          @@@@Value: false
          @@@@Description:
            @@@@@lang:en
            @@@@@@: Standalone "no".
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:NOT_SUPPORTED_ERR
          @@@@SubType:
            @@@@@QName:
              MDOMX:MDOM_DOC_NOSUPPORT_XML
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The current document does not support the <Feature::XML> 
                feature.
        @@@disDef:
          @@@@SetProp:
            infoset:standalone
        @@@ImplNote:
          @@@@lang:en
          @@@@@:
            Isn't <X::DOMException.NO_MODIFICATION_ALLOWED_ERR> raised?
            (Since DOM Level 1-3 does not have read-only <IF::Document> node?)
     @@Level[list]:  3
     @@SpecLevel:3
     @@For:
       ManakaiDOM:DOM3
  @Attr:
     @@Name:  xmlVersion
     @@Description:
       @@@lang:en
       @@@@:
         The version number of the document.
      \
         This attribute is corresponding to the version declaration in the 
         XML declaration and [version] property of the document information 
         item of the XML Infoset.
     @@Get:
        @@@Type:  
          DOMMain:DOMString
        @@@InCase:
          @@@@Value: 1.0
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The XML version is specified as XML 1.0 or the XML document 
              has no version declaration.
        @@@InCase:
          @@@@Value: 1.1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The XML version is specified as XML 1.1.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The document does not support the "XML" feature.
        @@@disDef:
          @@@@GetProp:
            infoset:version
     @@Set:
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            The XML version number of the document.  Note that 
            changing this attribute will affect methods that 
            check for invalid characters in XML "Name"s.  DOM 
            application should invoke the method "normalizeDocument" in 
            order to check for invalid characters in the "Node"s that 
            are already part of the document.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NOT_SUPPORTED_ERR
        @@@PerlDef:
            my $node = $self->{<H::mn:node>};
            if (defined $node->{<H::DOMCore:hasFeature>}->{XML}) {
              if (($given and
                   ($given eq '1.0' or $given eq '1.1')) or
                  (not <Code::doStrictErrorChecking:: $nodeRef = $self>)) {
                $node->{<H::infoset:version>} = $given;
              } else {
                __EXCEPTION{
                  MDOMX:MDOM_IMPL_NOSUPPORT_XMLVER::
                    infoset:version => {$given},
                }__;
              }
            } else {
              __EXCEPTION{
                MDOMX:MDOM_DOC_NOSUPPORT_XML::
              }__;
            }
     @@Level[list]:  3
     @@SpecLevel:3
     @@For:
       ManakaiDOM:DOM3
  @Attr:
     @@Name:  strictErrorChecking
     @@Description:
       @@@lang:en
       @@@@:
         Whether error checking is enforced or not.
     @@Get:
        @@@Type:  
          DOMMain:boolean||ManakaiDOM|all
        @@@disDef:
          @@@@GetProp:
            DOMCore:strictErrorChecking
     @@Set:
        @@@Type:  
          DOMMain:boolean||ManakaiDOM|all
        @@@Description:
          @@@@lang:en
          @@@@@: Whether error checking is enforced or not.
        @@@InCase:
          @@@@Value: false
          @@@@@: 
            The implementation is free to not every possible error 
            case normally defined on DOM operations, and not raise any 
            "DOMException" on DOM operations or report error 
            while using method "normalizeDocument".  In case of error, 
            the behavior is undefined.
        @@@disDef:
          @@@@SetProp:
            DOMCore:strictErrorChecking
     @@Level[list]:  3
     @@SpecLevel:3
     @@For:
       ManakaiDOM:DOM3
     @@ImplNote:
       @@@lang:en
       @@@@: This attribute is "true" by default.

  @ResourceDef:
    @@ForCheck: ManakaiDOM|ForClass
    @@QName: c|doStrictErrorChecking
    @@AliasFor: doStrictErrorChecking

  @ResourceDef:
    @@ForCheck: ManakaiDOM|ForClass
    @@QName: doStrictErrorChecking
    @@rdf:type: DISPerl|InlineCode
    @@PerlDef:
      (($nodeRef->{<H::mn:node>}->{<H::DOMCore:ownerDocument>} or
        $nodeRef->{<H::mn:node>})
         ->{<H::DOMCore:strictErrorChecking>})

  @Attr:
     @@Name:  documentURI
     @@Description:
       @@@lang:en
       @@@@: The location of the document.
     @@Level[list]:  3
     @@SpecLevel:3
     @@For:
       ManakaiDOM:DOM3
     @@Get:
        @@@Type:
          ManakaiDOM:ManakaiDOMURI
        @@@Description:
          @@@@lang:en
          @@@@@: The location of the document.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The location is undefined or the "Document" was created using 
              the method "createDocument".
        @@@disDef:
          @@@@GetProp:
            DOMCore:documentURI
     @@Set:
        @@@Type:
          ManakaiDOM:ManakaiDOMURI
        @@@Description:
          @@@@lang:en
          @@@@@: 
            The location of the document.  Note that no lexical checking is 
            performed.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The location is undefined.
        @@@disDef:
          @@@@SetProp:
            DOMCore:documentURI

  @L3Method:
    @@Name: adoptNode
    @@enDesc:
      Attempts to adopt a node from another document to this document.
      
      If supported, it changes the <A::Node.ownerDocument> of
      the source node, its children, as well as the attached attribute
      nodes if any.  If the source node has a <A::Node.parentNode>
      it is first removed from the children list of the parent.
      
      This method effectively allowes moving a subtree from one
      document to another, unlike <M::Document.importNode> which
      creates a copy of the source node instead of moving it.
      When it fails, applications should use <M::Document.importNode> instead.

      Note that if the adopted node is already part of this document,
      i.e. the source and target document are the same, this method
      still has the effect of removing the source node from the
      children list of its parent, if any.

      - <IF::Element>::: All <A::Attr.specified> attributes are adopted.
                      Default attributes are discarded, though the 
                      target document defines default attributes 
                      for the element type, then those are assigned.
                      The descendant nodes are recursively adopted.

      - <IF::Attr>::: The <A::Node.ownerElement> attribute is set to
                      <DOM::null> and the <A::Attr.specified> attribute
                      is set to <DOM::true>.  The descendant nodes
                      are recursively adopted.
      
      - <IF::DocumentFragment>::: The descendant nodes
                      are recursively adopted.

      - <IF::DOMXML:EntityReference>::: Only the node itself is adopted
                      and the descendants are discarded, since the source
                      and target documents might have defined the entity
                      differently.  If the target document provides a
                      definition for the entity name, then its value is
                      assigned.

      - <IF::Text>, <IF::Comment>, <IF::DOMXML:CDATASection>,
        <IF::DOMXML:ProcessingInstruction>:::
                      These nodes can be adopted.  No specifics.

      - <IF::Document>, <IF::DOMXML:DocumentType>,
        <IF::DOMXML:Entity>, <IF::DOMXML:Notation>:::
                      This kind of nodes cannot be adopted.
      
      {NOTE:: Since this method does not create new nodes unlike
              the <M::Document.importNode> method, this method does
              not raise an <X::DOMException.INVALID_CHARACTER_ERR>
              exception and applications should use the 
              <M::Document.normalizeDocument> method to check if
              an imported name is not an XML <CODE::Name> according
              to the XML version in use.
      }    

    @@enDesc:
      @@@ddid: adopt
      @@@enImplNote: Not in spec.
      @@@:
        If an adopted node has user data with handlers being registered,
        those handlers are invoked after the adoption occurred,
        with the <CODE::operation>
        parameter set to <C::c|UserDataHandler.NODE_ADOPTED>,
        <CODE::src> parameter set to the adopted node, and
        the <CODE::dest> parameter set to <DOM::null>.

          {NOTE:: User data handlers are disallowed to throw any
                  exception; if they do, then the result of 
                  the method is implementation dependent.
          }

    @@Param:
      @@@Name:  source
      @@@Type:  Node
      @@@enDesc:
        The node to move into this document.
    @@Return:
      @@@Type:  Node
      @@@enDesc:
        The adopted node.
      @@@nullCase:
        @@@@enDesc:
          The adopting operation fails, such as when the <P::source>
          node comes from a different implementation.
      @@@enImplNote:
        What is returned if <P::source> belongs to the same node
        as the node?
      @@@raises:
        @@@@@: c|ADOPT_NODE_TYPE_NOT_SUPPORTED_ERR
        @@@@enDesc:
          The <P::source> node is of type <IF::Document>,
          <IF::DOMXML:DocumentType>, <IF::DOMXML:Entity>, or
          <IF::DOMXML:Notation>.
        @@@@enImplNote:
          In DOM Level 3 Core spec: <QUOTE::Raised if the source
          node is of type <CODE::DOCUMENT>, <CODE::DOCUMENT_TYPE>>.
      @@@raises:
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          The <P::source> node is read-only.
      @@@raises:
        @@@@@: MDOMX|NOMOD_PARENT
        @@@@enDesc:
          The parent or owner element node is read-only.
        @@@@For: ManakaiDOM|ManakaiDOM
      @@@raises:
        @@@@@: c|NOMOD_DESCENDANT_ERR
        @@@@enDesc:
          One or more descendant or attribute node is read-only.
        @@@@For: ManakaiDOM|ManakaiDOM
      @@@PerlDef:
        if ($source->isa (<ClassName::ManakaiDOMNode>)) {
          if ($self->{<H::mn:node>}->{<H::DOMCore:read-only>}) {
            __EXCEPTION{MDOMX|NOMOD_THIS::
              MDOMX:param-name => 'source',
              DOMCore:node => $source,
            }__;
          }
          my $parent = $source-><AG::Node.parentNode>;
          if ($parent and $parent->{<H::mn:node>}->{<H::DOMCore:read-only>}) {
            __EXCEPTION{MDOMX|NOMOD_PARENT::
              MDOMX:param-name => 'source',
              DOMCore:node => $parent,
            }__;
          }
          my $nt = $source-><AG::Node.nodeType>;
          my $oe;
          if ($nt == <C::Node.ATTRIBUTE_NODE>) {
            $oe = $source-><AG::Attr.ownerElement>;
            if ($oe and $oe->{<H::mn:node>}->{<H::DOMCore:read-only>}) {
              __EXCEPTION{MDOMX|NOMOD_PARENT::
                MDOMX:param-name => 'source', 
                DOMCore:node => $oe,
              }__;
            }
          } elsif ($nt == <C::Node.DOCUMENT_NODE> or 
                   $nt == <C::Node.DOCUMENT_TYPE_NODE> or
                   $nt == <C::Node.ENTITY_NODE> or
                   $nt == <C::Node.NOTATION_NODE>) {
            __EXCEPTION{c|ADOPT_NODE_TYPE_NOT_SUPPORTED_ERR::
              MDOMX:param-name => 'source',
              DOMCore:node => $source,
            }__;
          }

          my @change_od;
          my @nodes = ($source);
          while (@nodes) {
            my $node = shift @nodes;
            my $nt = $node-><AG::Node.nodeType>;
            if ($node->{<H::mn:node>}->{<H::DOMCore:read-only>}) {
              __EXCEPTION{c|NOMOD_DESCENDANT_ERR::
                MDOMX:param-name => 'source',
                DOMCore:node => {$node},
              }__;
            }
            if ($nt == <C::Node.ELEMENT_NODE>) {
              push @change_od, $node;
              push @nodes, @{$node-><AG::Node.childNodes>};
              my $attrs = $node-><AG::Node.attributes>;
              my $attrsLength = $attrs-><AG::NamedNodeMap.length>;
              for my $i (0..($attrsLength - 1)) {
                push @nodes, $attrs-><M::NamedNodeMap.item> ($i);
              }
            } elsif ($nt == <C::Node.ATTRIBUTE_NODE> or
                     $nt == <C::Node.ENTITY_REFERENCE_NODE> or
                     $nt == <C::Node.DOCUMENT_FRAGMENT_NODE>) {
              push @change_od, $node;
              push @nodes, @{$node-><AG::Node.childNodes>};
            } elsif ($nt == <C::Node.TEXT_NODE> or
                     $nt == <C::Node.COMMENT_NODE> or
                     $nt == <C::Node.PROCESSING_INSTRUCTION_NODE> or
                     $nt == <C::Node.CDATA_SECTION_NODE>) {
              push @change_od, $node;
            } else {
              ## TODO: assertion
            }
          } # nodes
          
          if ($parent) {
            __DEEP{
              $parent-><M::Node.removeChild> ($source);
            }__;
          } elsif ($oe) {
            __DEEP{
              $oe-><M::Element.removeAttributeNode> ($source);
            }__;
          }

          if (${$self->{<H::mn:node>}->{<H::mn:treeID>}} ne
              ${$source->{<H::mn:node>}->{<H::mn:treeID>}}) {
            for my $n (map {$_->{<H::mn:node>}} @change_od) {
              __CODE{mn|unsetXRefNode||ManakaiDOM|Perl::
                $referrer => {$n},
                $propName => {<H::DOMCore:ownerDocument>},
              }__;
              __CODE{mn|setXRefNode||ManakaiDOM|Perl::
                $referrer => {$n},
                $propName => {<H::DOMCore:ownerDocument>},
                $referent => {$self->{<H::mn:node>}},
              }__;
            }

            for my $src (@change_od) {
              my $src_ud = $src->{<H::mn:node>}->{<H::t|userData>} || {};
              for my $key (keys %{$src_ud}) {
                my $dh = $src_ud->{$key}->[1];
                if ($dh) {
                  $dh-><M::c|UserDataHandler.handle>
                           (<C::c|UserDataHandler.NODE_ADOPTED>,
                            $key, $src_ud->{$key}->[0], $src, null);
                }
              }
            }
          }
          $r = $source;
        } # compatible class

      @@@enImplNote:
        The order in which handlers are invoked when multiple
        nodes are adopted is undefined.  Called just after the adoption
        or after all nodes are adopted is also unspecified.


    @@L3Test:
      @@@QName: Node.AdoptNode.UserDataHandler.Test
      @@@PerlDef:
        my $impl = <Class::c|ManakaiDOMImplementation>->_new;
        my $doc = $impl-><M::c|DOMImplementation.createDocument>
                              ('http://www.example/', 'ex');
        my $node = $doc-><AG::Document.documentElement>;
        my $node_id = $node->{<H::mn:node>}->{<H::mn:nodeID>};

        $test->set_test_data (node => $node);
          ## This registration prevents the user data handler
          ## being called when a test fails so that the |$node|
          ## is being destructed (|NODE_DELETED|).

        my $doc2 = $impl-><M::c|DOMImplementation.createDocument>;

        my $udh_called = false;
        my $src_doc_id;

        $node-><M::Node.setUserData> ('key' => {}, sub {
          my ($self, $op, $key, $data, $src, $dest) = @_;
          $udh_called = true;

          $test->assert_equals ($op, <C::c|UserDataHandler.NODE_ADOPTED>);
          $test->assert_equals ($key, 'key');
          $test->assert_equals (ref $data, 'HASH');
          $test->assert_not_null ($src);
          $test->assert_equals ($src-><AG::Node.localName>, 'ex');
          $test->assert_equals
                   ($src->{<H::mn:node>}->{<H::mn:nodeID>}, $node_id);
          $src_doc_id = $src-><AG::Node.ownerDocument>
                            ->{<H::mn:node>}->{<H::mn:nodeID>};
          $test->assert_null ($dest);
        });

        $node = $doc2-><M::Document.adoptNode> ($node);

        $test->assert_true ($udh_called);
        $test->assert_equals ($src_doc_id,
                              $doc2->{<H::mn:node>}->{<H::mn:nodeID>});

        $node-><M::Node.setUserData> ('key', null, null);
        $test->set_test_data (node => null);

  @Attr:
    @@Name: domConfig
    @@For: ManakaiDOM|DOM3
    @@enDesc:
      The configuration of the document.

      {NOTE:: This configuration is used when e.g. the method
              <M::Document.normalizeDocument> is invoked.
      }

    @@Get:
      @@@Type: c|DOMConfiguration
      @@@enDesc: The DOM configuration object.
      @@@PerlDef:
        __CODE{c|getConfigObject::
          $target => $self,
          $targetHash => {$self->{<H::mn:node>}},
          $targetType => {<IFName::Document>},
          $result => $r,
        }__;

  @Method:
     @@Name:  normalizeDocument
     @@Description:
       @@@lang:en
       @@@@:
         Act as if the document was going through a save and 
         load cycle, putting the document in a "normal" form.
       \
         - Update the replacement tree of <IF::DOMXML:EntityReference> nodes.
       \
         - Normalize <IF::Text> nodes, as the method <M::Node.normalize> does.
       \
         - Other normalization specified by the <A::Document.domConfig>.
       \
         Mutation events, when supported, are generated to reflect  
         the changes occuring on the document.
       \
         If errors occur, such as an attempt to update a read-only 
         node or a <A::Node.nodeName> contains an invalid character, 
         (fatal and non-fatal) errors and warnings will be reported using 
         the <IF::DOMErrorHandler> object associated with the 
         <DOM::error-handler> parameter.
     @@Return:
      @@@c:reports:
        @@@@@: c|check-character-normalization-failure
        @@@@enDesc:
          If the <cfg::c|check-character-normalization> configuration
          parameter is set to <DOM::true> and a sequence of characters
          is encountered that fails normalization checking.
      @@@c:reports:
        @@@@@: c|cdata-sections-splitted
        @@@@enDesc:
          If the <cfg::c|split-cdata-sections> configuration parameter
          is set to <DOM::true> and a <XML::CDATA> section
          is split.
      @@@c:reports:
        @@@@@: c|wf-invalid-character-in-node-name
        @@@@enDesc:
          If the <cfg::c|well-formed> configuration parameter is set to 
          <DOM::true> and a <A::Node.nodeName> contains invalid character
          according to its node type.
      @@@c:reports:
        @@@@@: c|wf-invalid-character
        @@@@enDesc:
          If the <cfg::c|well-formed> configuration parameter is set to
          <DOM::true> and the text content inside <IF::Attr>, <IF::Element>,
          <IF::Comment>, <IF::Text>, or <IF::DOMXML:CDATASection> node
          or the data inside <IF::DOMXML:ProcessingInstruction> node
          contains invalid characters.
     @@Level[list]:  3
     @@SpecLevel:3
     @@For:
       ManakaiDOM:DOM3
  @L3Method:
    @@Name: renameNode
    @@enDesc:
      Renames an <IF::Element> or <IF::Attr> node.

      When possible, this simple changes the name of the
      given node.  Otherwise, this creates a new node with the
      specified name and replaces the existing node with the new node.

      If the renamed node is an <IF::Element>, only the <A::Attr.specified>
      attributes are moved; default attributes originated from the DTD
      are updated according to the new element type name.  In addition,
      the implementation may update default attributes from other schemas.

        {NOTE:: Applications should use <M::Document.normalizeDocument>
                to guarantee those attributes are up-to-date after
                renaming.
        }

      If the renamed node is an <IF::Attr> attached to <IF::Element>, 
      the node is first removed from the owner <IF::Element>'s attribute
      map.  Then, once renamed, it is put back.

      In addition, a user data event <C::c|UserDataHandler.NODE_RENAMED>
      is fired if there are user data handlers registered to the node.
      When the implementation supports the feature <Feature::MutationNameEvents>,
      each mutation operation involved in the method fires the appropriate
      event, and in the end the event <EV::ev|DOMElementNameChanged>
      or <EV::ev|DOMAttributeNameChanged> is fired.

    @@DOMMain:isNamespaceAware:1
    @@enImplNote:
      {P:: If simple changing is impossible:
 
           = Creates a new node.
 
           = Registers any registered event listener on the new node.

           = Removes any user data attached to the old node.

           = Removes the old node from its parent, if any.

           = Moves the children of the old node to the new node.

           = Inserts the new node at the position the old node used to have
             in its parent's child node list if it has one.

           = Attaches the user data that was attached to the old node.

      }

    @@Param:
      @@@Name: n
      @@@Type: Node
      @@@enDesc:
        The node to rename.
    @@Param:
      @@@Name: namespaceURI
      @@@Type: DOMMain|DOMString
      @@@dis:actualType: ManakaiDOM|ManakaiDOMNamespaceURI
      @@@enDesc:
        The new namespace URI.
      @@@nullCase:
        @@@@enDesc:
          The new name does not belong to any namespace.
    @@Param:
      @@@Name: qualifiedName
      @@@Type: DOMMain|DOMString
      @@@enDesc:
        The new qualified name.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The rename node.
      @@@raises:
        @@@@@: MDOMX|MDOM_IMPL_NOSUPPORT_XMLNS
        @@@@enDesc:
          If the DOM implementation does not support the <DOM::XML> feature
          and the language exposed through the <IF::Document>
          object does not support XML Namespaces.
        @@@@For: !ManakaiDOM|DOMXMLFeature ManakaiDOM|ManakaiDOM
      @@@raises:
        @@@@@: c|RENAME_NODE_TYPE_NOT_SUPPORTED_ERR
        @@@@enDesc:
          If the type of the <P::n> is neither <C::Node.ELEMENT_NODE>
          nor <C::Node.ATTRIBUTE_NODE>.
        @@@@enDesc:
          @@@@@ddid: nonns
          @@@@@For: ManakaiDOM|ManakaiDOM
          @@@@@@:
            Or, if the <P::n> does not support namespace since
            it is created by DOM Level 1 method or does not support
            the <Feature::XML> feature.
      @@@raises:
        @@@@@: c|RENAME_DOCUMENT_ELEMENT_NOT_SUPPORTED_ERR
        @@@@enDesc:
          If the <P::n> is the document element and the implementation
          does not support the renaming of the document element.
      @@@raises:
        @@@@@: MDOMX|MDOM_BAD_NAME
        @@@@enDesc:
          If the <P::qualifiedName> is not an XML <CODE::Name> according
          to the XML version in use (<A::Document.xmlVersion>).
      @@@raises:
        @@@@@: c|MDOMX_EXTERNAL_NODE
        @@@@enDesc:
          If the <P::n> was created from a different document than
          the document.
      @@@raises:
        @@@@@: MDOMX|MDOM_NS_MALFORMED_QNAME
        @@@@enDesc:
          If the <P::qualifiedName> is a malformed qualified name.
      @@@raises:
        @@@@@: MDOMX|MDOM_NS_PREFIX_WITH_NULL_URI
        @@@@enDesc:
          If the <P::qualifiedName> has a prefix and the 
          <P::namespaceURI> is <DOM::null>.
      @@@raises:
        @@@@@: MDOMX|MDOM_NS_XML_WITH_OTHER_URI
        @@@@enDesc:
          If the <P::qualifiedName> has a prefix that is <XML::xml>
          and the <P::namespaceURI> is different from 
          <URI::http://www.w3.org/XML/1998/namespace>.
      @@@raises:
        @@@@@: MDOMX|MDOM_NS_XMLNSQ_WITH_OTHER_URI
        @@@@enDesc:
          If the <P::n> is an attribute node and the <P::qualifiedName> 
          is <XA::xmlns> and the <P::namespaceURI> is different from
          <URI::http://www.w3.org/2000/xmlns/>.
      @@@raises:
        @@@@@: MDOMX|MDOM_NS_XMLNS_WITH_OTHER_URI
        @@@@enDesc:
          If the <P::n> is an attribute node and the <P::qualifiedName>
          has a prefix that is <XML::xmlns> and the <P::namespaceURI>
          is different from <URI::http://www.w3.org/2000/xmlns/>.
      @@@enImplNote:
        These exception cases from DOM Level 3 spec do not cover all.
      @@@enImplNote:
        What would happen if a non-XML or non-namespace-aware node
        is being renamed?
      ## TODO: Implement for xmlfeature
      @@@disDef:
        @@@@ForCheck: !ManakaiDOM|DOMXMLFeature
        @@@@DOMMain:raiseException: MDOMX|MDOM_IMPL_NOSUPPORT_XMLNS
  
  @ReAttr:
    @@Name:baseURI
    @@Description:
      @@@lang:en
      @@@@:
        The base URI of this document.
    @@Get:
      @@@Type:
        ManakaiDOM:ManakaiDOMURI
      @@@Description:
        @@@@lang:en
        @@@@@: The base URI.
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The DOM implementation is unable to obtain an absolute URI.
      @@@PerlDef:
          if ($self->{<H::mn:node>}->{<H::DOMCore:hasFeature>}->{HTML}) {
            $r = $self->{<H::mn:node>}
                      -><M::ManakaiDOMCore:ManakaiDOMNodeObjectNode
                                        .htmlBaseURI>;
          } else {
            $r = $self->{<H::mn:node>}
                      -><M::ManakaiDOMCore:ManakaiDOMNodeObjectNode
                                        .contentBaseURI> (false);
          }
       @@@ImplNote:
         @@@@lang:en
         @@@@@:
           If a document has both a <HE::base> element and 
           an <XA::xml:base> attribute, or even in the case that 
           an XHTML 1 document has an <XA::xml:base> attribute, 
           its result is not defined by any W3C specification.
    @@SpecLevel:3
    @@Level[list]:3
    @@For:
      ManakaiDOM:DOM3
  @ReMethod:
     @@Name:  lookupPrefix
     @@Description:
       @@@lang:en
       @@@@:
         Lookup the namespace prefix associated to the given namespace 
         URI, starting from this node.
       \
         The default namespace declarations are ignored by this method. 
         To lookup default namespace, use the <M::Node.isDefaultNamespace>
         method.
     @@Param:
        @@@Name:  namespaceURI
        @@@Type:
          ManakaiDOM:ManakaiDOMNamespaceURI
        @@@Description:
          @@@@lang:en
          @@@@@: The namespace URI to look for.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Always <DOM::null> will be returned.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Always <DOM::null> will be returned.
     @@Return:
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            An associated namespace prefix.
          \
            If more than one prefix are associated to the 
            namespace URI, which is returned is implementation 
            dependent.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              No namespace prefix is found.
        @@@PerlDef:
            if (not defined $namespaceURI) {
              $r = null;
            } else {
              __DEEP{
                for (@{$self->{<H::mn:node>}->{<H::infoset:children>}}) {
                  if ($_->{<H::DOMCore:nodeType>} eq <H::infoset:Element>) {
                    $r = $_-><M::ManakaiDOMCore:ManakaiDOMNodeObjectNode
                                   .lookupNamespacePrefix>
                                                   ($namespaceURI, $_);
                    last;
                  }
                }
              }__;
            }
     @@Level[list]:  3
     @@SpecLevel:3
     @@For:
       ManakaiDOM:DOM3
  @ReAttr:
    @@Name: nodeName
    @@Description:
      @@@lang:en
      @@@@: The node name.
    @@Spec:
      @@@DOM3[list]:
        http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-F68D095
        http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-1841493061
    @@DOMMain:isNamespaceUnaware:1
    @@Get:
      @@@Type: 
        DOMMain:DOMString
      @@@InCase:
        @@@@Value:\#document
        @@@@Description:
          @@@@@lang:en
          @@@@@@: Always this value for the "Document" node.
      @@@disDef:
        @@@@DISLang:value:
          @@@@@@: \#document
          @@@@@ContentType:
            DISCore:String
  @ReAttr:
    @@Name: nodeType
    @@Description:
      @@@lang:en
      @@@@: The type of this node.
    @@Get:
      @@@Type: 
        DOMMain:unsigned-short||ManakaiDOM|all
      @@@actualType: NodeType
      @@@InCase:
        @@@@Label: DOCUMENT_NODE
        @@@@Description:
          @@@@@lang:en
          @@@@@@: The node is a "Document".
      @@@disDef:
        @@@@DISLang:constValue: Node.DOCUMENT_NODE

  @L3Attr:
    @@Name: textContent
    @@enDesc:
      The text content of the node.
    @@Type: DOMMain|DOMString
    @@Get:
      @@@enDesc:
        The text content of the node.
      @@@nullCase:
        @@@@enDesc:
          It is already defined as <DOM::null>.
        @@@PerlDef: $r = null;
    @@Set:
      @@@Type: DOMMain|DOMString
      @@@enDesc:
        Setting the attribute value has no effect.
      @@@c:reports:
        @@@@@: c|setting-node-value-no-effect
        @@@@enDesc:
          Setting the attribute value has no effect, since the
          node value is defined as <DOM::null>.
        @@@@For: ManakaiDOM|ManakaiDOM
      @@@disDef:
        @@@@DISPerl:cloneCode: ManakaiDOMNode.nodeValue.set

  @IntMethod:
    @@Name: newObject
    @@Description:
      @@@lang:en
      @@@@:
        Construct an object for the new instance of the "Document".
      \
        Note that this method is for the internal use.  DOM 
        applications must use the "createDocument" method 
        of the "DOMImplementation" interface to create a new "Document".
    @@ImplNote:
      @@@lang:en
      @@@@:
        The caller of this internal method MUST ensure to set 
        the attributes: <Q::DOMCore:implementation>.
    @@NewObjectRefNodeParam:
    @@Return:
      @@@Type: NodeStem
      @@@Description:
        @@@@lang:en
        @@@@@: The new object for the "Document".
      @@@PerlDef:
          $r = <ClassM::ManakaiDOMNode.newObject> ($self, $refNode);
          $r->{<H::DOMCore:nodeType>} = <H::infoset:Document>;
          $r->{<H::infoset:version>} = '1.0';
          $r->{<H::DOMCore:strictErrorChecking>} = true;
          $r->{<H::infoset:children>} = [];
          $r->{<H::cfg|entity-reference-read-only>} = true;
       @@@ImplNote:
         @@@@lang:en
         @@@@@:
           Other properties required to be a legal <IF::Document> object:
           <Q::DOMCore:implementation>, <Q::ManakaiDOM:implID>, 
           <Q::DOMCore:hasFeature>.
         \
           Other available properties: <Q::DOMCore:read-only>,
           <Q::infoset:characterEncodingScheme>, <Q::DOMCore:xmlEncoding>,
           <Q::infoset:standalone>, <Q::infoset:version>,
           <Q::DOMCore:documentURI>, <Q::DOMCore:strictErrorChecking>, 
           <Q::infoset:children>,
           <Q::c|error-handler>,
           <Q::cfg|entity-reference-read-only>,
           <Q::cfg|clone-entity-reference-subtree>.

  @mn:subnode1: infoset|children
  @mn:anydata0: DOMCore|error-handler

  @Method:
     @@Name:  getFeature
     @@enDesc:
       Returns a specialized object that implements the
       specialized interfaces of the specified feature and version.
     @@ManakaiDOM:isRedefining:1
     @@ForCheck: ManakaiDOM|ForClass ManakaiDOM|DOM3
     @@Param:
        @@@Name:  feature
        @@@Type:  
          DOMMain:DOMString
        @@@actualType: ManakaiDOM|ManakaiDOMFeatureName
        @@@enDesc:
          The feature name to request.
        @@@InCase:
          @@@@Label:
            @@@@@lang:en
            @@@@@@: 
              Feature name preceded by a <CHAR::PLUS SIGN>
          @@@@enDesc:
            The <CHAR::PLUS SIGN> is ignored.
     @@Param:
        @@@Name:  version
        @@@Type:  
          DOMMain:DOMString
        @@@actualType: ManakaiDOM|ManakaiDOMFeatureVersion
        @@@enDesc:
          The feature version to request.
        @@@nullCase:
          @@@@enDesc:
            No specific version is requested.
     @@Return:
        @@@Type:  
          DOMMain:DOMObject
        @@@enDesc:
          An object implementing the specialized interfaces.
          Note that the specialized object may or may not
          implement the <IF::Node> interface.
        @@@nullCase:
          @@@@enDesc:
            There is no object available that implements
            the specialized interfaces.
        @@@PerlDef:
            $feature =~ s/^\+//;
            if ($Message::DOM::ClassFeature{ref $self}->{$feature}->{$version}) {
              ## This class
              $r = $self;
            } else {
              ## Root element type dependent classes
                ## TODO:
              ## Document type dependent classes
                ## TODO:
              ## Document type independent classes
              CLASS: for my $class (grep {
                $Message::DOM::ManakaiDOMDocument::CompatClass{$_}
              } keys %Message::DOM::ManakaiDOMDocument::CompatClass) {
                if ($Message::DOM::ClassFeature{$class}
                            ->{$feature}->{$version}) {
                  __CODE{getNodeRef::
                    $object => {$self->{<H::mn:node>}},
                    $ref => $r,
                    $class => $class,
                  }__;
                  last CLASS;
                }
              }
            }
##Document

ElementTypeBinding:
  @Name: UnlessStrictErrorChecking
  @ElementType:
    dis:Description
  @ShadowContent:
    @@ddid: unlessStrictErrorChecking
    @@For: ManakaiDOM|ManakaiDOM3
    @@@:
      In manakai implementation, this exception is not thrown
      when <A::Document.strictErrorChecking> attribute is set to
      <DOM::false>.

ElementTypeBinding:
  @Name: boolCParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      @@@@: c|DOMConfigurationParameter
      @@@For: ManakaiDOM|DOM
    @@rdf:type:
      @@@@: DISCore|Property
      @@@For: =ManakaiDOM|all
    @@For: ManakaiDOM|ManakaiDOMLatest
    @@For: =ManakaiDOM|all
    @@Type: idl|boolean||ManakaiDOM|all

ElementTypeBinding:
  @Name: nodeProp
  @ElementType: 
    c:nodeProp
  @ShadowContent:
    @@For: =ManakaiDOM|all

boolCParam:
  @QName: cfg|entity-reference-read-only
  @nodeProp: etro
  @c:targetType: t|Document
  @TrueCase:
    @@IsSupportRequired: 1
    @@IsDefault: 1
    @@c:isSupported: 1
    @@enDesc:
      <IF::x|EntityReference> nodes and its subtree created by
      <IF::t|Document.createEntityReference> method or
      any other method that clones them (with possible some modification
      if desired) from <IF::x|Entity> nodes are read-only.

      This is the DOM Level 3 (or earlier) conformant behavior.
  @FalseCase:
    @@c:isSupported: 1
    @@enDesc:
      <IF::x|EntityReference> nodes and its subtree created by
      <IF::t|Document.createEntityReference> method or
      any other method that clones them (with possible some modification
      if desired) from <IF::x|Entity> nodes are <EM::not> read-only.
  @L3Test:
    @@QName: cfg.entity-reference-read-only.test
    @@PerlDef:
      my $doc;
      __CODE{createEmptyDocumentForTest:: $doc => $doc}__;

      my $cfg = $doc-><AG::Document.domConfig>;

      $test->id ('default.true');
      $test->assert_true ($cfg-><M::c|DOMConfiguration.getParameter>
                                  (<Q::cfg|entity-reference-read-only>));
      
      $test->id ('true.to.false');
      $cfg-><M::c|DOMConfiguration.setParameter>
              (<Q::cfg|entity-reference-read-only> => false);
      $test->assert_false ($cfg-><M::c|DOMConfiguration.getParameter>
                                   (<Q::cfg|entity-reference-read-only>));
   
      $test->id ('false.to.true');
      $cfg-><M::c|DOMConfiguration.setParameter>
              (<Q::cfg|entity-reference-read-only> => true);
      $test->assert_false ($cfg-><M::c|DOMConfiguration.getParameter>
                                   (<Q::cfg|entity-reference-read-only>));

      $test->id ('reset');
      $cfg-><M::c|DOMConfiguration.setParameter>
              (<Q::cfg|entity-reference-read-only> => false);
      $cfg-><M::c|DOMConfiguration.setParameter>
              (<Q::cfg|entity-reference-read-only> => null);
      $test->assert_true ($cfg-><M::c|DOMConfiguration.getParameter>
                                  (<Q::cfg|entity-reference-read-only>));

boolCParam:
  @QName: cfg|clone-entity-reference-subtree
  @nodeProp: cerst
  @c:targetType: t|Document
  @TrueCase:
    @@c:isSupported: 1
    @@enDesc:
      When the method <M::Node.cloneNode> clones an <IF::x|EntityReference>
      node, it just copies its child nodes as for <IF::Attr> nodes.
      In addition, the flag that indicates whether the entity reference
      is expanded or not is copied to the cloned node.

      If the <cfg::cfg|entity-reference-read-only> configuration
      parameter set to <DOM::true>, cloned subtree, including
      the cloned <IF::x|EntityReference> node itself, is read-only.
      Otherwise, they are not read-only.

      Note that <M::Node.adoptNode> and <M::Node.importNode> methods
      does not affect by this configuration parameter.
    @@enImplNote:
      {ISSUE::
        Should <M::Node.adoptNode> do as <M::Node.cloneNode> would do?
      }
  @FalseCase:
    @@IsSupportRequired: 1
    @@IsDefault: 1
    @@c:isSupported: 1
    @@enDesc:
      When the method <M::Node.cloneNode> clones an <IF::x|EntityReference>
      node, it simply creates a new <IF::x|EntityReference> node
      as if the method <M::Document.createEntityReference> with appropriate
      node name parameter is invoked.

      This is the DOM Level 3 (or earlier) conformant behavior.
  @L3Test:
    @@QName: cfg.clone-entity-reference-subtree.test
    @@PerlDef:
      my $doc;
      __CODE{createEmptyDocumentForTest:: $doc => $doc}__;

      my $cfg = $doc-><AG::Document.domConfig>;

      $test->id ('default.false');
      $test->assert_false ($cfg-><M::c|DOMConfiguration.getParameter>
                                  (<Q::cfg|clone-entity-reference-subtree>));
   
      $test->id ('false.to.true');
      $cfg-><M::c|DOMConfiguration.setParameter>
              (<Q::cfg|clone-entity-reference-subtree> => true);
      $test->assert_false ($cfg-><M::c|DOMConfiguration.getParameter>
                                   (<Q::cfg|clone-entity-reference-subtree>));
      
      $test->id ('true.to.false');
      $cfg-><M::c|DOMConfiguration.setParameter>
              (<Q::cfg|clone-entity-reference-subtree> => false);
      $test->assert_false ($cfg-><M::c|DOMConfiguration.getParameter>
                                   (<Q::cfg|clone-entity-reference-subtree>));

      $test->id ('reset');
      $cfg-><M::c|DOMConfiguration.setParameter>
              (<Q::cfg|clone-entity-reference-subtree> => true);
      $cfg-><M::c|DOMConfiguration.setParameter>
              (<Q::cfg|clone-entity-reference-subtree> => null);
      $test->assert_false ($cfg-><M::c|DOMConfiguration.getParameter>
                                  (<Q::cfg|clone-entity-reference-subtree>));

PropDef:
  @QName: c|ownerDocument
  @enDesc:
    <A::Node.ownerDocument>.
  @c:nodeProp: od

PropDef:
  @QName: c|documentURI
  @enDesc:
    <A::Document.documentURI>.
  @c:nodeProp: duri

PropDef:
  @QName: c|strictErrorChecking
  @enDesc:
    <A::Document.strictErrorChecking>.
  @c:nodeProp: chk

PropDef:
  @QName: c|name
  @Description:
    @@lang:en
    @@@:
      A name.
  @c:nodeProp: xnm

ElementTypeBinding:
  @Name: PropDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: rdf|Property
    @@For: =ManakaiDOM|all

ClsDef:
  @ClsQName: ManakaiDOMImplementationDocument

  @enDesc:
    The <Class::ManakaiDOMImplementationDocument> class implements
    two factory methods to create DOM <IF::Document> or
    <IF::DOMXML|DocumentType> defined in DOM Level 2 or higher.


  @L2Method:
    @@Name: createDocumentType
    @@enDesc:
      Creates an empty <IF::x|DocumentType> node.  No <IF::x|Entity>
      or <IF::x|Notation> nodes are made available.  Entity reference
      expansions and default attribute additions do not occur.
    @@DOMMain:isNamespaceAware: 1
    @@XML2Feature:
    @@enDesc:
      @@@ddid: manakai
      @@@For: ManakaiDOM|ManakaiDOM
      @@@@:
        In manakai, the method <M::c|DOMImplementation.createDocumentType>
        is <EM::deprecated>; use the method
        <M::DocXDoctype.createDocumentTypeDefinition> instead.
    @@Param:
      @@@Name: qualifiedName
      @@@Type: DOMString
      @@@dis:actualType:
        @@@@@: DOMMain|ManakaiDOMXML11QName
        @@@@For: ManakaiDOM|ManakaiDOMLatest
        @@@@ManakaiDOM:noInputNormalize: 1
      @@@dis:actualType:
        @@@@@: DOMMain|ManakaiDOMXML10QName
        @@@@For: !ManakaiDOM|ManakaiDOMLatest
        @@@@ManakaiDOM:noInputNormalize: 1
      @@@enDesc:
        The qualified name of the document type to be created.
    @@Param:
      @@@Name: publicId
      @@@Type: DOMString
      @@@enDesc:
        The public identifier of the external subset.
      @@@nullCase:
        @@@@For: ManakaiDOM|ManakaiDOM
        @@@@enDesc:
          The external subset has no public identifier or
          the document type has no external subset.
    @@Param:
      @@@Name: systemId
      @@@Type: DOMString
      @@@enDesc:
        The system identifier of the external subset.
      @@@nullCase:
        @@@@For: ManakaiDOM|ManakaiDOM
        @@@@enDesc:
          The external subset has no system identifier or
          the document type has no external subset.
    @@enImplNote:
      @@@ddid: badparam
      @@@@:
        Can <P::systemId> and / or <P::publicId> be <DOM::null>?

        What should happen if <P::publicId> is non-<DOM::null>
        and <P::systemId> is <DOM::null>?

        What should happen if <P::publicId> or <P::systemId> 
        is ill-formed?
    @@Return:
      @@@Type: x|DocumentType
      @@@enDesc:
        The newly created <IF::x|DocumentType> node with
        <A::Node.ownerDocument> set to <DOM::null>.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_BAD_NAME
        @@@@enDesc:
          @@@@@For: ManakaiDOM|ManakaiDOMLatest
          @@@@@@:
            If the <P::qualifiedName> is not an XML 1.1 <CODE::Name>.
        @@@@enDesc:
          @@@@@For: !ManakaiDOM|ManakaiDOMLatest
          @@@@@@:
            If the <P::qualifiedName> is not an XML 1.0 <CODE::Name>.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_NS_MALFORMED_QNAME
        @@@@enDesc:
          If the <P::qualifiedName> is malformed.
      @@@enImplNote:
        @@@@ddid: strict
        @@@@@:
          The <A::Document.strictErrorChecking> attribute is
          <EM::not> applied to these errors, since it has no
          associated <IF::Document> node.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_IMPL_NOSUPPORT_XMLNS
        @@@@enDesc:
          This exception may be raised if the implementation does not support 
          the feature <Feature::XML> and the language exposed through
          the document does not support XML namespaces.
        @@@@enImplNote:
          <QUOTE::Document>?  What document?
      @@@PerlDef:
        @@@@ForCheck: ManakaiDOM|DOMXMLFeature
        @@@@@:
          ## Validate |qualifiedName| - don't use |InputProcessor|
          ## since it refers |strictErrorChecking| attribute.
          __FOR{ManakaiDOM:ManakaiDOMLatest::
            unless (<Code::DOMMain:testXML11Name:: $INPUT = $qualifiedName>) {
              __EXCEPTION{MDOMX:MDOM_BAD_NAME::
                  DOMCore:name => {$qualifiedName},
                  MDOMX:param-name => 'qualifiedName',
                  infoset:version => '1.1',
              }__;
            }
            unless (<Code::DOMMain:testXML11QName:: $INPUT = $qualifiedName>) {
              __EXCEPTION{MDOMX:MDOM_NS_MALFORMED_QNAME::
                DOMCore:name => {$qualifiedName},
                MDOMX:param-name => 'qualifiedName',
                infoset:version => '1.1',
              }__;
            }
          }__;
          __FOR{!ManakaiDOM:ManakaiDOMLatest::
            unless (<Code::DOMMain:testXML10Name:: $INPUT = $qualifiedName>) {
              __EXCEPTION{MDOMX:MDOM_BAD_NAME::
                  DOMCore:name => {$qualifiedName},
                  MDOMX:param-name => 'qualifiedName',
                  infoset:version => '1.0',
              }__;
            }
            unless (<Code::DOMMain:testXML10QName:: $INPUT = $qualifiedName>) {
              __EXCEPTION{MDOMX:MDOM_NS_MALFORMED_QNAME::
                DOMCore:name => {$qualifiedName},
                MDOMX:param-name => 'qualifiedName',
                infoset:version => '1.0',
              }__;
            }
          }__;

            my ($prefix, $lname) = split /:/, $qualifiedName, 2;
            if (not defined $lname) {
              ($prefix, $lname) = (null, $prefix);
            }
            my $node = <ClassM::x|MDTDef.newObject>;
            $node->{<H::infoset:prefix>} = $prefix if defined $prefix;
            $node->{<H::infoset:localName>} = $lname;
            __FOR{ManakaiDOM:ManakaiDOMLatest::
              unless (<Code::DOMMain:testXML10QName:: $INPUT = $qualifiedName>) {
                $node->{<H::infoset:version>} = '1.1';
              }
            }__;
            $node->{<H::infoset:publicIdentifier>} = $publicId
              if defined $publicId;
            $node->{<H::infoset:systemIdentifier>} = $systemId
              if defined $systemId; 
            ## Note: No DOM Level 3 method/attribute provides access 
            ##       to the DOM implementation object when the "DocumentType" 
            ##       does not have the parent node (= owner "Document").
            $node->{<H::DOMCore:implementation>} = $self;
            $node->{<H::ManakaiDOM:implID>}
                        = $self->{<H::mn:node>}->{<H::ManakaiDOM:implID>};
            $r = <ClassM::ManakaiDOMNode.getNodeReference> ($node);
        @@@@enImplNote:
          {ISSUE::
            Should <Q::c|read-only> flag set <DOM::true> for
            DOM levels 2 or 3?
          }
        @@@disDef:
          @@@@ForCheck:
            !ManakaiDOM:DOMXMLFeature
          @@@@DOMMain:raiseException:
            MDOMX:MDOM_IMPL_NOSUPPORT_XMLNS

    @@L2Test:
      @@@ForCheck: ManakaiDOM|DOMXMLFeature
      @@@QName: DOMImplDoc.createDocumentType.ncname.test
      @@@PerlDef:
        my $impl;
        __CODE{createDOMImplForTest:: $impl => $impl}__;

        $test->id ('create');
        my $dtype = $impl-><M::c|DOMImplementation.createDocumentType> ('qname');
        $test->assert_isa ($dtype, <IFName::x|DocumentType>);

        $test->id ('nodeName');
        $test->assert_equals ($dtype-><AG::Node.nodeName>, 'qname');
    @@L2Test:
      @@@ForCheck: ManakaiDOM|DOMXMLFeature
      @@@QName: DOMImplDoc.createDocumentType.qname.test
      @@@PerlDef:
        my $impl;
        __CODE{createDOMImplForTest:: $impl => $impl}__;

        $test->id ('create');
        my $dtype = $impl-><M::c|DOMImplementation.createDocumentType>
                             ('pfx:qname');
        $test->assert_isa ($dtype, <IFName::x|DocumentType>);

        $test->id ('nodeName');
        $test->assert_equals ($dtype-><AG::Node.nodeName>, 'pfx:qname');
    @@L2Test:
      @@@ForCheck: ManakaiDOM|DOMXMLFeature
      @@@QName: DOMImplDoc.createDocumentType.non.name11.test
      @@@PerlDef:
        my $impl;
        __CODE{createDOMImplForTest:: $impl => $impl}__;

        $test->id ('create');
        $test->assert_exception (code => sub {
          $impl-><M::c|DOMImplementation.createDocumentType> ('12345');
        }, exception_subtype => <Q::MDOMX|MDOM_BAD_NAME>);
    @@L2Test:
      @@@ForCheck: ManakaiDOM|DOMXMLFeature !ManakaiDOM|ManakaiDOMLatest
      @@@QName: DOMImplDoc.createDocumentType.name11.non.name10.test
      @@@PerlDef:
        my $impl;
        __CODE{createDOMImplForTest:: $impl => $impl}__;

        $test->id ('create');
        $test->assert_exception (code => sub {
          $impl-><M::c|DOMImplementation.createDocumentType>
                   ("\x{3001}\x{3002}");
                   ## A Name in XML 1.1 but not in XML 1.0.
        }, exception_subtype => <Q::MDOMX|MDOM_BAD_NAME>);
    @@LXTest:
      @@@ForCheck: ManakaiDOM|DOMXMLFeature
      @@@QName: DOMImplDoc.createDocumentType.name11.non.name10.test
      @@@PerlDef:
        my $impl;
        __CODE{createDOMImplForTest:: $impl => $impl}__;

        $test->id ('create');
        my $dtype = $impl-><M::c|DOMImplementation.createDocumentType>
                             ("\x{3001}\x{3002}");
                             ## A Name in XML 1.1 but not in XML 1.0.
        $test->assert_isa ($dtype, <IFName::x|DocumentType>);

        $test->id ('nodeName');
        $test->assert_equals ($dtype-><AG::Node.nodeName>, "\x{3001}\x{3002}");
    @@L2Test:
      @@@ForCheck: ManakaiDOM|DOMXMLFeature
      @@@QName: DOMImplDoc.createDocumentType.non.qname11.test
      @@@PerlDef:
        my $impl;
        __CODE{createDOMImplForTest:: $impl => $impl}__;

        $test->id ('create');
        $test->assert_exception (code => sub {
          $impl-><M::c|DOMImplementation.createDocumentType> (':aa');
        }, exception_subtype => <Q::MDOMX|MDOM_NS_MALFORMED_QNAME>);
    @@L2Test:
      @@@ForCheck: ManakaiDOM|DOMXMLFeature !ManakaiDOM|ManakaiDOMLatest
      @@@QName: DOMImplDoc.createDocumentType.qname11.non.qname10.test
      @@@PerlDef:
        my $impl;
        __CODE{createDOMImplForTest:: $impl => $impl}__;

        $test->id ('create');
        $test->assert_exception (code => sub {
          $impl-><M::c|DOMImplementation.createDocumentType>
                   ("a:\x{3005}b");
                    ## A QName in XMLNames 1.1 but not in XMLNames 1.0.
        }, exception_subtype => <Q::MDOMX|MDOM_NS_MALFORMED_QNAME>);
    @@LXTest:
      @@@ForCheck: ManakaiDOM|DOMXMLFeature
      @@@QName: DOMImplDoc.createDocumentType.qname11.non.qname10.test
      @@@PerlDef:
        my $impl;
        __CODE{createDOMImplForTest:: $impl => $impl}__;

        $test->id ('create');
        my $dtype = $impl-><M::c|DOMImplementation.createDocumentType>
                             ("a:\x{3005}b");
                             ## A QName in XMLNames 1.1 but not in XMLNames 1.0.
        $test->assert_isa ($dtype, <IFName::x|DocumentType>);

        $test->id ('nodeName');
        $test->assert_equals ($dtype-><AG::Node.nodeName>, "a:\x{3005}b");
    @@L2Test:
      @@@ForCheck: ManakaiDOM|DOMXMLFeature
      @@@QName: DOMImplDoc.createDocumentType.pubid.sysid.test
      @@@PerlDef:
        my $impl;
        __CODE{createDOMImplForTest:: $impl => $impl}__;

        $test->id ('create');
        my $dtype = $impl-><M::c|DOMImplementation.createDocumentType>
                             ('qname', 'pubid', 'sysid');
        $test->assert_isa ($dtype, <IFName::x|DocumentType>);

        $test->id ('nodeName');
        $test->assert_equals ($dtype-><AG::Node.nodeName>, 'qname');

        $test->id ('publicId');
        $test->assert_equals ($dtype-><AG::x|DocumentType.publicId>, 'pubid');

        $test->id ('systemId');
        $test->assert_equals ($dtype-><AG::x|DocumentType.systemId>, 'sysid');

  @Method:
     @@Name:  createDocument
     @@Description:
       @@@lang:en
       @@@@:
         Creates a new <IF::Document> object, with a document element.
     @@Description:
       @@@lang:en
       @@@@:
         {NOTE:: Either if the <P::doctype> is an XML 1.1 node 
                 or if the <P::qualifiedName> is a valid XML Namespace 1.1 
                 QName but is not a valid XML Namespace 1.0 QName,
                 then the XML version of the document to be created 
                 is <XML::1.1>; otherwise, it is <XML::1.0>.
          \
          }
       @@@For:
         ManakaiDOM:ManakaiDOMLatest
     @@Description:
       @@@lang:en
       @@@@:
         The manakai <M::DOMImplementation.createDocument> method always 
         creates an XML <IF::Document>, i.e. a <IF::Document> that supports 
         the <Feature::XML> feature. 
       @@@For:
         ManakaiDOM:ManakaiDOM
     @@XML2Feature:
     @@ImplNote:
       @@@lang:en
       @@@@:
         In DOM Level 1, there is no standardized way to create 
         a <IF::Document> object. 
     @@DOMMain:isNamespaceAware:1
     @@Param:
        @@@Name:  namespaceURI
        @@@Type:
          DOMMain:DOMString
        @@@actualType:
          ManakaiDOM:ManakaiDOMNamespaceURI
        @@@Description:
          @@@@lang:en
          @@@@@: 
            The namespace URI of the document element to create.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: 
              The document element to create has no namespace.
     @@Param:
        @@@Name:  qualifiedName
        @@@Type:  
          DOMMain:DOMString
        @@@actualType:
          @@@@@:
            DOMMain:ManakaiDOMXML11QName
          @@@@ForCheck:
            ManakaiDOM:ManakaiDOMLatest
          @@@@ManakaiDOM:noInputNormalize:1
        @@@actualType:
          @@@@@:
            DOMMain:ManakaiDOMXML10QName
          @@@@ForCheck:
            ManakaiDOM:ManakaiDOMLatest
          @@@@ManakaiDOM:noInputNormalize:1
        @@@Description:
          @@@@lang:en
          @@@@@: The qualified name of the document element to create.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: Document element is not created.
     @@Param:
        @@@Name:  doctype
        @@@Type:  
          DOMXML:DocumentType
        @@@actualType:
          DOMXML:ManakaiDOMDocumentType
        @@@Description:
          @@@@lang:en
          @@@@@:
            The document type of the document to create.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The document to create does not have any <IF::DOMXML:DocumentType> 
              node. 
        @@@ImplNote:
          @@@@lang:en
          @@@@@:
            The <A::Node.ownerDocument> of the <P::doctype> is set to 
            the document being created. 
     @@Return:
        @@@Type:  Document
        @@@actualType: ManakaiDOMDocument
        @@@Description:
          @@@@lang:en
          @@@@@:
            A newly created <IF::Document> object. 
            \
            {NOTE:: The object returned by this method may be a 
                    specialized <IF::Document> object based on the 
                    <P::doctype> given.  For example, a <IF::Document> 
                    object might also implement the <IF::DOMHTML:HTMLDocument> 
                    interface. 
            \
            }
        @@@raises:
          @@@@@: DOMException.INVALID_CHARACTER_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The specified qualified name is not an XML 1.0 <CODE::Name>.
            @@@@@For:
              !ManakaiDOM:ManakaiDOMLatest
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The specified qualified name is not an XML 1.1 <CODE::Name>.
            @@@@@For:
              ManakaiDOM:ManakaiDOMLatest
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              The <CITE::DOM Level 2 Core> specification does not
              explicitly defines the version of the XML for 
              <CODE::Name>s, but the definition for
              <X::DOMException.INVALID_CHARACTER_ERR> references
              the <CITE::XML 1.0> specification.

              The <CITE::DOM Level 3 Core> specification references
              the <CITE::XML 1.0> specification for the <CODE::Name>
              definition.
        @@@raises:
          @@@@@: DOMException.NAMESPACE_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Either the "qualifiedName" is malformed, the "qualifiedName" 
              has a prefix and the "namespaceURI" is "null", the 
              "qualifiedName" is "null" and the "namespaceURI" is 
              different from "null", the "qualifiedName" has 
              a prefix that is "xml" and the "namespaceURI" is 
              different from "http://www.w3.org/XML/1998/namespace" or
              the DOM implementation does not support the "XML" feature 
              but a non-null "namespaceURI" is provided.
         @@@ImplNote:
           @@@@lang:en
           @@@@@:
              In addition, it is possible to raise an exception 
              either if the "qualifiedName" has a prefix that is 
              "xmlns" and the "namespaceURI" is different from 
              "http://www.w3.org/2000/xmlns/", if the "namespaceURI" 
              is "http://www.w3.org/XML/1998/namespace" and the 
              "qualifiedName" has a prefix is different from "xml" or 
              if the "namespaceURI" is "http://www.w3.org/2000/xmlns/" 
              and the "qualifiedName" has a prefix is different from "xmlns".
              But this DOM implementation only report a warning on 
              these cases since the specification does not mention 
              to raise any exception.
        @@@raises:
          @@@@@: c|MDOMX_DOCTYPE_ALREADY_USED
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The <P::doctype> has already been used with a different 
              document.
        @@@raises:
          @@@@@: c|MDOMX_EXTERNAL_NODE
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The <P::doctype> was created from a different DOM implementation.
        @@@raises:
          @@@@@:
            MDOMX:MDOM_IMPL_NOSUPPORT_XMLNS
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The DOM implementation does not support the <DOM::XML> feature and 
              the language exposed through the <IF::Document> does not support 
              XML Namespaces.
            @@@@@ImplNote:
              @@@@@@lang:en
              @@@@@@@:
                DOM Level 2 Core described that this method creates 
                a <QUOTE::XML <IF::Document> object> and that 
                HTML-only implementations need not implement it. 
                DOM Level 2 Errata and DOM Level 3 Core describes that 
                such implementations should return a 
                <X::DOMException.NOT_SUPPORTED_ERR>.  In addition, 
                DOM Level 3 Core specifies this method to create 
                a <QUOTE::DOM <IF::Document> object>. Note also that 
                DOM Level 3 Core explicitly allows non-<Feature::XML> 
                document node to be created.
        @@@PerlDef:
          @@@@For:
            ManakaiDOM:DOMXMLFeature
          @@@@@:
            my ($prefix, $lname);
            if (defined $qualifiedName) {
              __ManakaiDOM:InputNormalize{qualifiedName}__;
              ($prefix, $lname) = split /:/, $qualifiedName, 2;
              unless (defined $lname) {
                ($prefix, $lname) = (null, $prefix);
              }
              __CODE{DOMMain:checkXMLNamesQName::
                $NSURI => $namespaceURI,
                $PREFIX => $prefix,
                $LNAME => $lname,
              }__;
              if ($lname eq 'xmlns') {
                if (not defined $prefix) {
                  __EXCEPTION{MDOMX:MDOM_NS_QNAME_IS_XMLNS::
                  }__;
                } elsif ($prefix eq 'xmlns') {
                  __EXCEPTION{MDOMX:MDOM_NS_XMLNS_XMLNS::
                  }__;
                }
              }
            } elsif (defined $namespaceURI) {
              __EXCEPTION{MDOMX:MDOM_NS_NULL_QNAME_WITH_NON_NULL_URI::
                MDOMX:param-name => 'qualifiedName',
                infoset:namespaceName => {$namespaceURI},
              }__;
            }

            my $node = <ClassM::ManakaiDOMDocument.newObject>;
            $node->{<H::DOMCore:implementation>} = $self;
            $node->{<H::ManakaiDOM:implID>}
                = $self->{<H::mn:node>}->{<H::ManakaiDOM:implID>};
            $node->{<H::DOMCore:hasFeature>}->{XML} = true;
            $node->{<H::DOMCore:hasFeature>}->{HTML} = true
              if (defined $namespaceURI and $namespaceURI eq <Q::xhtml1:>) or
                 (defined $qualifiedName and $qualifiedName eq 'html');

            if ($doctype) {
              if (not UNIVERSAL::isa
                        ($doctype, <ClassName::DOMXML:ManakaiDOMDocumentType>)) {
                __EXCEPTION{c|MDOMX_EXTERNAL_NODE::
                  MDOMX:param-name => 'doctype',
                }__;
              }
              my $doctypeNode = $doctype->{<H::mn:node>};
              if (${$node->{<H::mn:treeID>}} ne
                  ${$doctypeNode->{<H::mn:treeID>}} or
                  $doctypeNode->{<H::DOMCore:ownerDocument>} or
                  $doctypeNode->{<H::ManakaiDOM:implID>} ne 
                    $node->{<H::ManakaiDOM:implID>}) {
                __EXCEPTION{c|MDOMX_DOCTYPE_ALREADY_USED::
                  MDOMX:param-name => 'doctype',
                }__;
              }
              $doctypeNode-><M::NodeStem.importTree> ($node);
              __CODE{mn|setXRefNode||ManakaiDOM|Perl::
                $referrer => {$doctypeNode},
                $propName => {<H::DOMCore:ownerDocument>},
                $referent => {$node},
              }__;
              $doctypeNode->{<H::infoset:parent>} = $node;
              push @{$node->{<H::infoset:children>}}, $doctypeNode;
              __FOR{ManakaiDOM:ManakaiDOMLatest::
                $node->{<H::infoset:version>}
                    = $doctypeNode->{<H::infoset:version>};
              }__;
            }

            if ($lname) {
              __FOR{ManakaiDOM:ManakaiDOMLatest::
                if (not defined $node->{<H::infoset:version>} and
                    not <Code::DOMMain:testXML10Name:: $INPUT = $lname>) {
                  $node->{<H::infoset:version>} = '1.1';
                }
              }__;
              my $docElObj = <ClassM::ManakaiDOMElement.newObject> ($node);
              $docElObj->{<H::infoset:prefix>} = $prefix if defined $prefix;
              __CODE{DISPerl|HashStringRef||ManakaiDOM|all::
                $result => {$docElObj->{<H::infoset:namespaceName>}},
                $given => $namespaceURI,
              }__;
              $docElObj->{<H::infoset:localName>} = $lname;
              $docElObj->{<H::infoset:parent>} = $node;
              __CODE{mn|setXRefNode||ManakaiDOM|Perl::
                $referrer => {$docElObj},
                $propName => {<H::DOMCore:ownerDocument>},
                $referent => {$node},
              }__;
              push @{$node->{<H::infoset:children>}}, $docElObj;
            }

            $r = <ClassM::ManakaiDOMNode.getNodeReference> ($node);
        @@@PerlDef:
          @@@@ForCheck:
            ManakaiDOM:DOMHTMLFeature !ManakaiDOM:DOMXMLFeature 
            ManakaiDOM:DOM3
          @@@@@:
            my ($prefix, $lname);
            \## ISSUE: Should be checked against HTML namechar?
            if (defined $namespaceURI) {
              __EXCEPTION{DOMCore:MDOMX_HTML_NSURI::
                MDOMX:param-name => 'namespaceURI',
                infoset:namespaceName => {$namespaceURI},
              }__;
            }
            if (defined $qualifiedName) {
              __ManakaiDOM:InputNormalize{qualifiedName}__;
              ($prefix, $lname) = split /:/, $qualifiedName, 2;
              unless (defined $lname) {
                ($prefix, $lname) = (null, $prefix);
              }
              __CODE{DOMMain:checkXMLNamesQName::
                $NSURI => $namespaceURI,
                $PREFIX => $prefix,
                $LNAME => $lname,
              }__;
              if ($lname eq 'xmlns') {
                if (not defined $prefix) {
                  __EXCEPTION{MDOMX:MDOM_NS_QNAME_IS_XMLNS::
                  }__;
                } elsif ($prefix eq 'xmlns') {
                  __EXCEPTION{MDOMX:MDOM_NS_XMLNS_XMLNS::
                  }__;
                }
              }
            } # $qualifiedName

            my $node = <ClassM::ManakaiDOMDocument.newObject>;
            $node->{<H::DOMCore:implementation>} = $self;
            $node->{<H::ManakaiDOM:implID>}
                = $self->{<H::mn:node>}->{<H::ManakaiDOM:implID>};
            $node->{<H::DOMCore:hasFeature>}->{HTML} = 1;
            if ($doctype) {
              if (not UNIVERSAL::isa
                        ($doctype, <ClassName::DOMXML:ManakaiDOMDocumentType>)) {
                __EXCEPTION{c|MDOMX_EXTERNAL_NODE::
                  MDOMX:param-name => 'doctype',
                }__;
              }
              my $doctypeNode = $doctype->{<H::mn:node>};
              if (${$node->{<H::mn:treeID>}} ne
                  ${$doctypeNode->{<H::mn:treeID>}} or
                  $doctypeNode->{<H::DOMCore:ownerDocument>} or
                  $doctypeNode->{<H::ManakaiDOM:implID>} ne 
                    $node->{<H::ManakaiDOM:implID>}) {
                __EXCEPTION{c|MDOMX_DOCTYPE_ALREADY_USED::
                  MDOMX:param-name => 'doctype',
                }__;
              }
              $doctypeNode-><M::NodeStem.importTree> ($node);
              __CODE{mn|setXRefNode||ManakaiDOM|Perl::
                $referrer => {$doctypeNode},
                $propName => {<H::DOMCore:ownerDocument>},
                $referent => {$node},
              }__;
              $doctypeNode->{<H::infoset:parent>} = $node;
              push @{$node->{<H::infoset:children>}}, $doctypeNode;
              __FOR{ManakaiDOM:ManakaiDOMLatest::
                if (defined $doctypeNode->{<H::infoset:version>}) {
                  __EXCEPTION{MDOMX:MDOM_IMPL_NOSUPPORT_XML::
                    MDOMX:param-name => 'doctype',
                    infoset:version => {$doctypeNode->{<H::infoset:version>}},
                  }__;
                }
              }__;
            }
            if ($lname) {
              my $docElObj = <ClassM::ManakaiDOMElement.newObject> ($node);
              $docElObj->{<H::infoset:prefix>} = $prefix if defined $prefix;
              __CODE{DISPerl|HashStringRef||ManakaiDOM|all::
                $result => {$docElObj->{<H::infoset:namespaceName>}},
                $given => $namespaceURI,
              }__;
              $docElObj->{<H::infoset:localName>} = $lname;
              $docElObj->{<H::infoset:parent>} = $node;
              __CODE{mn|setXRefNode||ManakaiDOM|Perl::
                $referrer => {$docElObj},
                $propName => {<H::DOMCore:ownerDocument>},
                $referent => {$node},
              }__;
              push @{$node->{<H::infoset:children>}}, $docElObj;
            }
            $r = <ClassM::ManakaiDOMNode.getNodeReference> ($node);
        @@@disDef:
          @@@@For:
            !ManakaiDOM:DOMXMLFeature !ManakaiDOM|DOMHTMLFeature
          @@@@For: !ManakaiDOM|DOMXMLFeature !ManakaiDOM|DOM3
          @@@@DOMMain:raiseException:
            MDOMX:MDOM_IMPL_NOSUPPORT_XMLNS
     @@SpecLevel:2
     @@Level[list]:
       2
       3
     @@L2:
     @@For:
       ManakaiDOM:DOM2

  @CODE:
    @@QName: createDOMImplForTest
    @@PerlDef:
      $impl = <ClassName::c|ManakaiDOMImplementation>->_new;
##DOMImplementationDocument
