Module:
  @QName: MDOM|Document
  @enFN:
    DOM Document Module
  @enDesc:
    The manakai DOM Document Module implements a part of the W3C DOM
    Core module related to documents in the tree structural model
    for HTML or XML.

  @Namespace:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/DOM/Document/

  @DISCore:author: DISCore|Wakaba
  @License: license|Perl+MPL
  @Date:
    $Date: 2006/04/02 10:45:23 $

  @Require:
    @@Module:
      @@@QName: MDOM|TreeCore
      @@@WithFor: ManakaiDOM|ManakaiDOMLatest
    @@Module:
      @@@QName: MDOM|XML
      @@@WithFor: ManakaiDOM|ManakaiDOMLatest
    @@Module:
      @@@QName: MDOM|XDoctype
      @@@WithFor: ManakaiDOM|ManakaiDOMLatest
    @@Module:
      @@@WithFor: ManakaiDOM|ManakaiDOM
    @@Module:
      @@@WithFor: ManakaiDOM|ManakaiDOM1
    @@Module:
      @@@WithFor: ManakaiDOM|ManakaiDOM2
    @@Module:
      @@@WithFor: ManakaiDOM|ManakaiDOM3
    @@Module:
      @@@WithFor: ManakaiDOM|ManakaiDOMLatest
  @DefaultFor: ManakaiDOM|ManakaiDOMLatest

Namespace:
  @c:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#
  @cfg:
    http://suika.fam.cx/www/2006/dom-config/
  @dis:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#dis--
  @doc:
    http://suika.fam.cx/~wakaba/archive/2005/7/tutorial#
  @d:
    http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#
  @DOMMain:
    http://suika.fam.cx/~wakaba/archive/2004/dom/main#
  @dx:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#
  @dxm:
    http://suika.fam.cx/~wakaba/archive/2004/dis/XML#
  @ecore:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/Core/
  @ev:
    http://www.w3.org/2001/xml-events
  @f:
    http://suika.fam.cx/~wakaba/archive/2004/dom/feature#
  @fe:
    http://suika.fam.cx/www/2006/feature/
  @idl:
    http://suika.fam.cx/~wakaba/archive/2004/dis/IDL#
  @infoset:
    http://www.w3.org/2001/04/infoset#
  @kwd:
    http://suika.fam.cx/~wakaba/archive/2005/rfc2119/
  @lang:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#
  @license:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/license#
  @ManakaiDOM:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#
  @ManakaiDOMCore:
    http://suika.fam.cx/~wakaba/archive/2004/mdom-core#
  @MDOM:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#ManakaiDOM.
  @MDOMX:
    http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#
  @mg:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Grove/
  @null:
    http://suika.fam.cx/~wakaba/-temp/2003/09/27/null
  @rdf:
    http://www.w3.org/1999/02/22-rdf-syntax-ns#
  @rdfs:
    http://www.w3.org/2000/01/rdf-schema#
  @sw010:
    urn:x-suika-fam-cx:markup:suikawiki:0:10:
  @t:
    http://suika.fam.cx/~wakaba/archive/2004/dom/tree#
  @tc:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/DOM/TreeCore/
  @td:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/DOM/Document/
  @te:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/DOM/Element/
  @test:
    http://suika.fam.cx/~wakaba/archive/2004/dis/Test#
  @tx:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/DOM/XML/
  @urigen:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/URI/Generic/
  @Util:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/
  @xml:
    http://www.w3.org/XML/1998/namespace
  @xml-dtd:
    http://www.w3.org/TR/REC-xml
  @xmlns:
    http://www.w3.org/2000/xmlns/


ElementTypeBinding:
  @Name: CODE
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISPerl|BlockCode
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: Method
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Method
    @@ForCheck: !=ManakaiDOM|ManakaiDOM

ElementTypeBinding:
  @Name: L12Method
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Method
    @@ForCheck: !=ManakaiDOM|ManakaiDOM
  ## Modified in DOM Level 2

ElementTypeBinding:
  @Name: L13Method
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Method
    @@ForCheck: !=ManakaiDOM|ManakaiDOM
  ## Modified in DOM Level 3

ElementTypeBinding:
  @Name: CMethod
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Method
    @@ForCheck: !=ManakaiDOM|ManakaiDOM ManakaiDOM|ForClass
ElementTypeBinding:
  @Name: L2Method
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|Method
    @@ForCheck: !=ManakaiDOM|ManakaiDOM ManakaiDOM|DOM2

ElementTypeBinding:
  @Name: CL2Method
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|Method
    @@ForCheck: !=ManakaiDOM|ManakaiDOM ManakaiDOM|DOM2 ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: L3Method
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Method
    @@ForCheck: !=ManakaiDOM|ManakaiDOM ManakaiDOM|DOM3

ElementTypeBinding:
  @Name: CL3Method
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Method
    @@ForCheck: !=ManakaiDOM|ManakaiDOM ManakaiDOM|DOM3 ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: LXMethod
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Method
    @@ForCheck: !=ManakaiDOM|ManakaiDOM ManakaiDOM|ManakaiDOMLatest

ElementTypeBinding:
  @Name: IntMethod
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Method
    @@ForCheck:
      ManakaiDOM:ManakaiDOM !=ManakaiDOM:ManakaiDOM ManakaiDOM|ForClass
    @@ManakaiDOM:isForInternal: 1

ElementTypeBinding:
  @Name: Param
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|MethodParameter

ElementTypeBinding:
  @Name: Return
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|MethodReturn

ElementTypeBinding:
  @Name: Attr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Attribute
    @@ForCheck: !=ManakaiDOM|ManakaiDOM

ElementTypeBinding:
  @Name: CAttr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|Attribute
    @@ForCheck: !=ManakaiDOM|ManakaiDOM ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: IntAttr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Attribute
    @@ForCheck: ManakaiDOM|ForClass
    @@ManakaiDOM:isForInternal: 1

ElementTypeBinding:
  @Name: L2Attr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Attribute
    @@ForCheck: !=ManakaiDOM|ManakaiDOM ManakaiDOM|DOM2

ElementTypeBinding:
  @Name: L12Attr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Attribute
    @@ForCheck: !=ManakaiDOM|ManakaiDOM ManakaiDOM|DOM1
  # Modified in DOM Level 2

ElementTypeBinding:
  @Name: L13Attr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Attribute
    @@ForCheck: !=ManakaiDOM|ManakaiDOM ManakaiDOM|DOM1
  # Modified in DOM Level 3

ElementTypeBinding:
  @Name: CL2Attr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Attribute
    @@ForCheck: !=ManakaiDOM|ManakaiDOM ManakaiDOM|DOM2 ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: L3Attr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Attribute
    @@ForCheck: !=ManakaiDOM|ManakaiDOM ManakaiDOM|DOM3
  ## Note that there are attributes introduced in DOM Level 3
  ## but also defined for lower levels as internal attributes
  ## for the purpose of internal use.

ElementTypeBinding:
  @Name: CL3Attr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Attribute
    @@ForCheck: !=ManakaiDOM|ManakaiDOM ManakaiDOM|DOM3 ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: LXAttr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Attribute
    @@ForCheck: !=ManakaiDOM|ManakaiDOM ManakaiDOM|ManakaiDOMLatest

ElementTypeBinding:
  @Name: Get
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|AttributeGet

ElementTypeBinding:
  @Name: Set
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|AttributeSet

ElementTypeBinding:
  @Name: LXSet
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|AttributeSet
    @@ForCheck: ManakaiDOM|ManakaiDOMLatest

ElementTypeBinding:
  @Name: InCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:InCase

ElementTypeBinding:
  @Name: nullCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:InCase
    @@Value:
      @@@is-null:1

ElementTypeBinding:
  @Name: Constants
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|ConstGroup
    @@ForCheck: ManakaiDOM|ForIF !=ManakaiDOM|ManakaiDOM
    @@Type: unsignedShort
    @@subsetOf: unsignedShort

ElementTypeBinding:
  @Name: L3Bitmasks
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|ConstGroup
    @@ForCheck: ManakaiDOM|ForIF !=ManakaiDOM|ManakaiDOM
    @@Type: unsignedShort
    @@subsetOf: unsignedShort

ElementTypeBinding:
  @Name: Const
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|Const

ElementTypeBinding:
  @Name: LXConst
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|Const
    @@Description:
      @@@lang:en
      @@@ddid:manakai
      @@@@:
        {NOTE::
          This is a manakai extension.
        }

ElementTypeBinding:
  @Name: PerlDef
  @ElementType:
    dis:Def
  @ShadowContent:
    @@ContentType:
      lang:Perl
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: PerlDefC
  @ElementType:
    dis:Def
  @ShadowContent:
    @@ContentType:
      lang:Perl

ElementTypeBinding:
  @Name: XML2Feature
  @ElementType:
    dis:ImplNote
  @ShadowContent:
    @@ImplNote:
      @@@lang:en
      @@@@:
        The <CITE::DOM Level 2 Core> specification said that HTML-only 
        DOM Level 2 implementations does not need to implement this member. 
        The DOM Level 2 Errata withdraws it and it requires HTML-only 
        DOM implementations throw a <X::DOMException.NOT_SUPPORTED_ERR>. 

ElementTypeBinding:
  @Name: enImplNote
  @ElementType:
    dis:ImplNote
  @ShadowContent:
    @@lang:en

ElementTypeBinding:
  @Name: enFN
  @ElementType:
    dis:FullName
  @ShadowContent:
    @@lang:en

ElementTypeBinding:
  @Name: NodeTypeDef
  @ElementType: 
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      @@@@: dis|MultipleResource
      @@@ForCheck: !ManakaiDOM|ForIF !ManakaiDOM|ForClass
    @@resourceFor: ManakaiDOM|ForIF
    @@resourceFor:
      @@@@: ManakaiDOM|ForClass
      @@@ForCheck: ManakaiDOM|ManakaiDOMLatest
    @@For: ManakaiDOM|DOM1
    @@For: =ManakaiDOM|ManakaiDOM

    @@rdf:type:
      @@@@: DISLang|Interface
      @@@ForCheck: ManakaiDOM|ForIF

    @@rdf:type:
      @@@@: DISLang|Class
      @@@ForCheck: ManakaiDOM|ForClass

    @@ISA:
      @@@@: Node
      @@@ForCheck: ManakaiDOM|ForIF
    @@ISA:
      @@@@: tc|ManakaiDOMNode
      @@@ForCheck: ManakaiDOM|ForClass

    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOM||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOM1||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM1
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOM2||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM2
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOM3||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM3
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOMLatest||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOMLatest

    @@f:implements:
      @@@@: DOMCore|CoreFeature10
      @@@For: ManakaiDOM|DOM1
    @@DOMMain:implementFeature:
      @@@@: DOMCore|CoreFeature20
      @@@For: ManakaiDOM|DOM2
    @@DOMMain:implementFeature:
      @@@@: DOMCore|CoreFeature30
      @@@For: ManakaiDOM|DOM3
    @@DOMMain:implementFeature:
      @@@@: tx|XMLFeature10
      @@@For: ManakaiDOM|DOM1 ManakaiDOM|DOMXMLFeature
    @@DOMMain:implementFeature:
      @@@@: tx|XMLFeature20
      @@@For: ManakaiDOM|DOM2 ManakaiDOM|DOMXMLFeature
    @@DOMMain:implementFeature:
      @@@@: tx|XMLFeature30
      @@@For: ManakaiDOM|DOM3 ManakaiDOM|DOMXMLFeature
    @@DOMMain:implementFeature:
      @@@@: tx|XMLVersionFeature10
      @@@For: ManakaiDOM|DOM3 ManakaiDOM|DOMXMLFeature
    @@DOMMain:implementFeature:
      @@@@: tx|XMLVersionFeature11
      @@@For: ManakaiDOM|DOM3 ManakaiDOM|DOMXMLFeatureXML11
ElementTypeBinding:
  @Name: IFQName
  @ElementType:
    dis:QName
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForIF

ElementTypeBinding:
  @Name: ClsQName
  @ElementType:
    dis:QName
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: IFISA
  @ElementType:
    dis:ISA
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForIF

ElementTypeBinding:
  @Name: ClsISA
  @ElementType:
    dis:ISA
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: disDef
  @ElementType:
    dis:Def
  @ShadowContent:
    @@ContentType:
      lang:dis
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: Code
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISPerl|InlineCode
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: IntPropDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISCore|Property
    @@For: =ManakaiDOM|all

ElementTypeBinding:
  @Name: RPropDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISSource|ResourceProperty
    @@For: =ManakaiDOM|all

ElementTypeBinding:
  @Name: Test
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: test|StandaloneTest
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: L2Test
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: test|StandaloneTest
    @@ForCheck: ManakaiDOM|ForClass ManakaiDOM|DOM2

ElementTypeBinding:
  @Name: L3Test
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: test|StandaloneTest
    @@ForCheck: ManakaiDOM|ForClass ManakaiDOM|DOM3

ElementTypeBinding:
  @Name: LXTest
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: test|StandaloneTest
    @@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOMLatest

ElementTypeBinding:
  @Name: XDTest
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: test|StandaloneTest
    @@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOMLatest

ResourceDef:
  @QName: DOMString
  @AliasFor: DOMMain|DOMString
  @For: ManakaiDOM|DOM

ResourceDef:
  @QName: DOMImpl
  @AliasFor: c|DOMImplementation
  @For: ManakaiDOM|DOM

ResourceDef:
  @QName: boolean
  @AliasFor: idl|boolean||ManakaiDOM|all

ResourceDef:
  @QName: unsignedLong
  @AliasFor: idl|unsignedLong||ManakaiDOM|all

ResourceDef:
  @QName: unsignedShort
  @AliasFor: idl|unsignedShort||ManakaiDOM|all

ResourceDef:
  @QName: ARRAY
  @AliasFor: DISPerl|ARRAY||ManakaiDOM|all

ResourceDef:
  @QName: HASH
  @AliasFor: DISPerl|HASH||ManakaiDOM|all

ResourceDef:
  @QName: DocumentX
  @AliasFor: d|DocumentXDoctype
  @For: ManakaiDOM|ManakaiDOMLatest

ResourceDef:
  @QName: DTDef
  @AliasFor: d|DocumentTypeDefinition
  @For: ManakaiDOM|ManakaiDOMLatest

ResourceDef:
  @QName: ETDef
  @AliasFor: d|ElementTypeDefinition
  @For: ManakaiDOM|ManakaiDOMLatest

ResourceDef:
  @QName: ATDef
  @AliasFor: d|AttributeDefinition
  @For: ManakaiDOM|ManakaiDOMLatest

ResourceDef:
  @QName: Node
  @AliasFor: tc|Node
  @For: ManakaiDOM|DOM

ResourceDef:
  @QName: Element
  @AliasFor: te|Element
  @For: ManakaiDOM|DOM

ResourceDef:
  @QName: Attr
  @AliasFor: te|Attr
  @For: ManakaiDOM|DOM


NodeTypeDef:
  @IFQName: Document
  @ClsQName: ManakaiDOMDocument

  @DISLang:role: tc|DocumentRole

  @enDesc:
    A <IF::Document> object represents the entire HTML or XML document.
    It is conceptually the root of the document tree and
    provides the primary access to the docuement's data.

    Since elements, text nodes, comments, processing instructions,
    and so on cannot exist outside the context of a <IF::Document>,
    the <IF::Document> interface also contains the factory methods
    needed to create these objects.  The <IF::Node> objects
    created have a <A::Node.ownerDocument> attribute which
    associates them with the <IF::Document> within whose context
    they were created.

    {NOTE:: A <IF::DocumentType> node can be created by
            <M::c|DOMImplementation.createDocumentType> method.
            A <IF::Document> node can be created by 
            <M::c|DOMImplementation.createDocument> method.
    }

  @IntMethod:
    @@Operator: mg|CreateNodeStemMethod
    @@Param:
      @@@Name: bag
      @@@Type: HASH
    @@Param:
      @@@Name: obj
      @@@Type: HASH
    @@Param:
      @@@Name: opt
      @@@Type: HASH
    @@Return:
      @@@Type: HASH
      @@@PerlDef:
        $obj->{<H::infoset|children>} = [];
        $obj->{<H::tc|revOwnerDocument>} = {};
        $obj->{<H::infoset|version>} = '1.0';
        __CODE{mg|setOwnerProp||ManakaiDOM|all::
          $bag => $bag,
          $ownerref => {$opt->{<H::f|implementation>}},
          $ownee1hprop => {<H::f|revImplementation>},
          $ownee => {$obj},
          $owner0prop => {<H::f|implementation>},
        }__;
        $r = $obj;
  @mg:subnode1a: infoset|children
  @mg:ownee1h: tc|revOwnerDocument
  @mg:owner0: f|implementation

  @enImplNote:
    @@ddid: props
    @@@:
      {P:: Required internal properties:

        - <Q::tc|revOwnerDocument>, <Q::f|implementation>.

        - <Q::infoset|children>.

        - <Q::infoset|version>.

      }

      {P:: Optional internal properties:

        - <Q::c|xmlEncoding>,
          <Q::infoset|characterEncodingScheme>, <Q::infoset|standalone>,
          <Q::infoset|allDeclarationsProcessed>.

        - <Q::c|documentURI>, <Q::infoset|baseURI>.

        - <Q::c|read-only>, <Q::c|strictErrorChecking>.

        - <Q::cfg|xml-id>, <Q::c|error-handler>,
          <Q::cfg|clone-entity-reference-subtree>.

        - <Q::t|userData>.

      }

  @IntMethod:
    @@Operator: mg|CreateNodeRefMethod
    @@Param:
      @@@Name: obj
      @@@Type: HASH
    @@Param:
      @@@Name: opt
      @@@Type: HASH
    @@Return:
      @@@Type: Node
      @@@PerlDef:
        my $class;
        CLS: {
          if (defined $opt->{<H::mg|nodeRefClass>}) {
            $class = $opt->{<H::mg|nodeRefClass>};
            IFCHK: {
              for (@{$opt->{<H::mg|nodeRefInterfaces>} or []}) {
                last IFCHK unless $$class->isa ($_);
              }
              last CLS;
            } # IFCHK
          }

          __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
            $r => $class,
            $prop => {<H::tc|defaultNodeRefClass>},
            $ref => $obj,
          }__;
          if (defined $class) {
            IFCHK: {
              for (@{$opt->{<H::mg|nodeRefInterfaces>} or []}) {
                last IFCHK unless $$class->isa ($_);
              }
              last CLS;
            } # IFCHK
          }

          my $cns;
          __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
            $r => $cns,
            $prop => {<H::infoset|children>},
            $ref => $obj,
          }__;
          my $bag = <Code::mg|getNodeBag||ManakaiDOM|all:: $ref = $obj>;
          my $deh;
          DC: for my $cnid (@$cns) {
            my $cnh = <Code::mg|createNodeRefHashFromID||ManakaiDOM|all::
                                 $stemid = $cnid, $bag = $bag>;
            my $cncls;
            __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
              $r => $cncls,
              $prop => {<H::mg|nodeClass>},
              $ref => $cnh,
            }__;
            if ($$cncls eq <ClassName::te|ManakaiDOMElement>) {
              $deh = $cnh;
              last DC;
            }
          } # DC
          my $dens;
          my $deln;
          if (defined $deh) {
            __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
              $r => $dens,
              $prop => {<H::infoset|namespaceName>},
              $ref => $deh,
            }__;
            $dens = \'' unless defined $dens;
            __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
              $r => $deln,
              $prop => {<H::infoset|localName>},
              $ref => $deh,
            }__;
          } else {
            $dens = \'*';
            $deln = \'*';
          }

          A: {
            ## Use cases:
            ##   - Document element is |html5:html|
            ##   - Document element is |NULL:rfc|

            for my $nm (
              [$dens, $deln],
              [$dens, \'*'],
            ) {
              for my $__class (sort {
                $Message::DOM::ClassPoint{$b} <=> $Message::DOM::ClassPoint{$a}
              } grep {
                $Message::DOM::DOMFeature::ClassInfo
                    ->{<ClassName::ManakaiDOMDocument>}
                    ->{compat_class_by_type}
                    ->{${$nm->[0]}}->{${$nm->[1]}}->{$_}
              } keys %{$Message::DOM::DOMFeature::ClassInfo
                           ->{<ClassName::ManakaiDOMDocument>}
                           ->{compat_class_by_type}
                           ->{${$nm->[0]}}->{${$nm->[1]}} or {}}) {
                if ($Message::DOM::DOMFeature::ClassInfo->{$__class}
                        ->{has_feature}->{xml}->{'3.0'}) {
                  $class = \$__class;
                  IFCHK: {
                    for (@{$opt->{<H::mg|nodeRefInterfaces>} or []}) {
                      last IFCHK unless $$class->isa ($_);
                    }
                    last A;
                  } # IFCHK
                }
              }
            }

            ## Generic
            CLASS: for my $__class (sort {
              $Message::DOM::ClassPoint{$b} <=> $Message::DOM::ClassPoint{$a}
            } grep {
              $Message::DOM::DOMFeature::ClassInfo
                  ->{<ClassName::ManakaiDOMDocument>}
                  ->{compat_class}->{$_}
            } keys %{$Message::DOM::DOMFeature::ClassInfo
                         ->{<ClassName::ManakaiDOMDocument>}
                         ->{compat_class} or {}}) {
              if ($Message::DOM::DOMFeature::ClassInfo->{$__class}
                      ->{has_feature}->{xml}->{'3.0'}) {
                $class = \$__class;
                IFCHK: {
                  for (@{$opt->{<H::mg|nodeRefInterfaces>} or []}) {
                    last IFCHK unless $$class->isa ($_);
                  }
                  last A;
                } # IFCHK
              }
            }

            ## Default
            $class = \$self;
          } # A

          if (defined $deh) {
            __CODE{mg|setNodeStemPropValue||ManakaiDOM|all::
              $given => $class,
              $prop => {<H::tc|defaultNodeRefClass>},
              $ref => $obj,
            }__;
          }
        } # CLS
        $r = bless $obj, $$class;

  @CODE:
    @@QName: tc|createEmptyDocumentForTest
    @@PerlDef:
      my $__impl;
      __CODE{tc|createImplForTest:: $impl => $__impl}__;
      $doc = $__impl-><M::c|DOMImplementation.createDocument>;

  @CODE:
    @@QName: tc|createEmptyDocumentForTestNoErr
    @@PerlDef:
      my $__impl;
      __CODE{tc|createImplForTest:: $impl => $__impl}__;
      $doc = $__impl-><M::c|DOMImplementation.createDocument>;
      $doc-><AG::Document.domConfig>
          -><M::c|DOMConfiguration.setParameter>
              ('error-handler' => sub { });

  @CODE:
    @@QName: tc|createDocumentForTestDA
    @@PerlDef:
      my $__impl;
      __CODE{tc|createImplForTest:: $impl => $__impl}__;
      $doc = $__impl-><M::c|DOMImplementation.createDocument>;
      $doc-><AG::Document.domConfig>
          -><M::c|DOMConfiguration.setParameter>
              (<Q::cfg|strict-document-children> => false);

  @CODE:
    @@QName: tc|createEmptyDocumentForTestER
    @@enDesc:
      Creates an empty document, entity references created
      from which are not read-only.
    @@PerlDef:
      my $__impl;
      __CODE{tc|createImplForTest:: $impl => $__impl}__;
      $doc = $__impl-><M::c|DOMImplementation.createDocument>;

  @CAttr:
    @@Name: nodeType
    @@Type: unsignedShort
    @@dis:actualType: NodeType
    @@Get:
      @@@disDef:
        @@@@DISLang:constValue: Node.DOCUMENT_NODE

    @@Test:
      @@@QName: Document.nodeType.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        $test->id ('nodeType');
        $test->assert_num_equals
                 (actual_value => $doc-><AG::Node.nodeType>,
                  expected_value => <C::Node.DOCUMENT_NODE>);

  @Test:
    @@QName: Doc.prefix.test
    @@PerlDef:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
      $test->id ('get');
      $test->assert_null ($doc-><AG::Node.prefix>);
      $test->id ('set');
      $doc-><AS::Node.prefix> ('pre');
      $test->assert_null ($doc-><AG::Node.prefix>);

  @Test:
    @@QName: Document.parentNode.test
    @@PerlDef:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
      $test->assert_null ($doc-><AG::Node.parentNode>);

  @Test:
    @@QName: Document.isSameNode.1.test
    @@PerlDef:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

      $test->id ('same');
      $test->assert_equals ($doc, $doc);

      $test->id ('non-object.1');
      $test->assert_not_equals ($doc, 1);

      $test->id ('non-object.2');
      $test->assert_not_equals ($doc, {a => 2});

      my $doc2;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc2}__;

      $test->id ('diff');
      $test->assert_not_equals ($doc, $doc2);
  @L3Test:
    @@QName: Document.isSameNode.2.test
    @@PerlDef:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

      $test->id ('same');
      $test->assert_true ($doc-><M::Node.isSameNode> ($doc));

      my $doc2;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc2}__;

      $test->id ('diff');
      $test->assert_false ($doc-><M::Node.isSameNode> ($doc2));

  @LXTest:
    @@QName: Document.readOnly.test
    @@PerlDef:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

      $test->id ('default');
      $test->assert_false ($doc-><AG::Node.manakaiReadOnly>);


  @CMethod:
    @@Name: appendChild
    @@enDesc:
      Adds a node to the end of the list of children of the node.
      If that node is already in the tree, it is first removed.
    @@Param:
      @@@Name: newChild
      @@@Type: Node
      @@@enDesc:
        The node to add.
      @@@InCase:
        @@@@Type: DocumentFragment
        @@@@enDesc:
          The entire contents of the document fragment are
          moved into the child list of the node.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node added.  If the <P::newChild> node is a <IF::DocumentFragment>
        node, then the <P::newChild> node <kwd:MUST> be returned.
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_BAD_TYPE
        @@@@enDesc:
          If the node is of a type that does not allow children of
          the type of the <P::newChild> node.
 
          If the <A::Document.strictErrorChecking> is set to <DOM::false>,
          this exception <kwd:MAY-NOT> be thrown.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_SECOND_DOC_ELEMENT
        @@@@enDesc:
          If the node is of type <IF::Document> and an attempt
          is made to append a second <IF::DocumentType> node
          <SRC::DOM 3>.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_SECOND_DOCTYPE
        @@@@enDesc:
          If the node is of type <IF::Document> and an attempt
          is made to append a second <IF::tx|DocumentType> node
          <SRC::DOM 3>.
      @@@dx:raises:
        @@@@@: c|HIERARCHY_WRONG_DOCTYPE_ERR
        @@@@enDesc:
          If the node is of type <IF::Document> and an attempt
          is made to append a <IF::tx|DocumentType> node after
          an <IF::Element> node or an <IF::Element> node after
          a <IF::tx|DocumentType>.
        @@@@enImplNote:
          Although such document type node is not prohibited
          by DOM specification, Firefox 1.5 and Opera 9 TP1
          throws an <X::c|DOMException.HIERARCHY_REQUEST_ERR>.
      @@@dx:raises:
        @@@@@: c|DIFFERENT_DOCUMENT_ERR
        @@@@enDesc:
          If the <P::newChild> node was created from a different
          document than the one to which the node was created or
          the node does not belong to any document.

          If the <A::Document.strictErrorChecking> is set to <DOM::false>,
          this exception <kwd:MAY-NOT> be thrown.
      @@@dx:raises: 
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the node is read-only.

          If the <A::Document.strictErrorChecking> is set to <DOM::false>,
          this exception <kwd:MAY-NOT> be thrown.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_SRC_PARENT
        @@@@enDesc:
          If the previous parent of the <P::newChild> node is read-only
          <SRC::DOM 2 Errata, DOM 3>.

          If the <A::Document.strictErrorChecking> is set to <DOM::false>,
          this exception <kwd:MAY-NOT> be thrown.
      @@@PerlDef:
        my $strictc = $self-><AG::Document.domConfig>
                           -><M::c|DOMConfiguration.getParameter>
                               (<Q::cfg|strict-document-children>);
        my $child_od = $newChild-><AG::Node.ownerDocument> || $self;
        my $child_nt = $newChild-><AG::Node.nodeType>;
        if ($strictc and $self-><AG::Document.strictErrorChecking>) {
          __DEEP{
            my $has_el;
            my $has_dt;
            if ($child_nt == <C::Node.ELEMENT_NODE>) {
              $has_el = true;
            } elsif ($child_nt == <C::Node.DOCUMENT_TYPE_NODE>) {
              $has_dt = true;
            } elsif ($child_nt == <C::Node.DOCUMENT_FRAGMENT_NODE>) {
              for my $cn (@{$newChild-><AG::Node.childNodes>}) {
                my $cnt = $cn-><AG::Node.nodeType>;
                if ($cnt == <C::Node.ELEMENT_NODE>) {
                  if ($has_el) {
                    __UNDEEP{__EXCEPTION{MDOMX|MDOM_SECOND_DOC_ELEMENT::
                      MDOMX|param-name => 'newChild',
                      c|node => {$newChild},
                    }__}__;
                  }
                  $has_el = true;
                }
                # DocumentType node cannot be contained in DocumentFragments
              }
            }
  
            if ($has_el) {
              my $anode = $self-><AG::Node.lastChild>;
              while (defined $anode) {
                if ($anode-><AG::Node.nodeType> == <C::Node.ELEMENT_NODE>) {
                  __UNDEEP{__EXCEPTION{MDOMX|MDOM_SECOND_DOC_ELEMENT::
                    MDOMX|param-name => 'newChild',
                    c|node => {$newChild},
                  }__}__;
                }
                $anode = $anode-><AG::Node.previousSibling>;
              }
            } # has_el
            if ($has_dt) {
              my $anode = $self-><AG::Node.lastChild>;
              while (defined $anode) {
                my $ant = $anode-><AG::Node.nodeType>;
                if ($ant == <C::Node.ELEMENT_NODE>) {
                  __UNDEEP{__EXCEPTION{c|HIERARCHY_WRONG_DOCTYPE_ERR::
                    MDOMX|param-name => 'newChild',
                    c|node => {$newChild},
                  }__}__;
                } elsif ($ant == <C::Node.DOCUMENT_TYPE_NODE>) {
                  __UNDEEP{__EXCEPTION{MDOMX|MDOM_SECOND_DOCTYPE::
                    MDOMX|param-name => 'newChild',
                    c|node => {$newChild},
                  }__}__;
                }
                $anode = $anode-><AG::Node.previousSibling>;
              }
            } # has_dt
          }__;
        }
        __CODE{tc|appendChildImpl1::
          $self => $self, $self_od => $self,
          $newChild => $newChild, $child_od => $child_od, $child_nt => $child_nt,
          $r => $r,
          $allowedNodeTypes => {{
            <C::Node.TEXT_NODE> => (not $strictc),
            <C::Node.ENTITY_REFERENCE_NODE> => (not $strictc),
            <C::Node.ELEMENT_NODE> => true,
            <C::Node.CDATA_SECTION_NODE> => (not $strictc),
            <C::Node.PROCESSING_INSTRUCTION_NODE> => true,
            <C::Node.COMMENT_NODE> => true,
            <C::Node.DOCUMENT_TYPE_NODE> => true,
          }},
        }__;
        if ($child_nt == <C::Node.DOCUMENT_TYPE_NODE> and
            not defined $newChild-><AG::Node.ownerDocument>) {
          my $bag = <Code::mg|getNodeBag||ManakaiDOM|all:: $ref = $self>;
          __CODE{mg|deleteOwnerProp||ManakaiDOM|all::
            $bag => $bag,
            $owneeref => $newChild,
            $owner0prop => {<H::f|implementation>},
            $ownee1hprop => {<H::f|revImplementation>},
          }__;
          __CODE{mg|setOwnerPropRR||ManakaiDOM|all::
            $bag => $bag,
            $ownerref => $self,
            $ownee1hprop => {<H::tc|revOwnerDocument>},
            $owneeref => $newChild,
            $owner0prop => {<H::tc|ownerDocument>},
          }__;
        }

  @CMethod:
    @@Name: insertBefore
    @@enDesc:
      Inserts a node before the existing child node of the node.

      Inserting a node before itself is implementation dependent.
    @@Param:
      @@@Name: newChild
      @@@Type: Node
      @@@enDesc:
        The node to insert.  If the <P::newChild> is already in 
        the tree, it is first removed.
      @@@InCase:
        @@@@Type: DocumentFragment
        @@@@enDesc:
          All of children of the <P::newChild> node are inserted,
          in the same order, before <P::refChild>.
    @@Param:
      @@@Name: refChild
      @@@Type: Node
      @@@enDesc:
        The reference node, i.e. the node before which the new node
        must be inserted.
      @@@nullCase:
        @@@@enDesc:
          The <P::newChild> node is inserted at the end of the list
          of children.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node being inserted.
      @@@enImplNote:
        What is returned if <P::newChild> is a <IF::DocumentFragment>?
        See also <M::Node.appendChild>'s return value.
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_BAD_TYPE
        @@@@enDesc:
          If the node is of a type that does not allow children of
          the type of the <P::newChild> node.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_SECOND_DOC_ELEMENT
        @@@@enDesc:
          If the node is of type <IF::Document> and an attempt
          is made to append a second <IF::DocumentType> node
          <SRC::DOM 3>.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_SECOND_DOCTYPE
        @@@@enDesc:
          If the node is of type <IF::Document> and an attempt
          is made to append a second <IF::tx|DocumentType> node
          <SRC::DOM 3>.
      @@@dx:raises:
        @@@@@: c|HIERARCHY_WRONG_DOCTYPE_ERR
        @@@@enDesc:
          If the node is of type <IF::Document> and an attempt
          is made to append a <IF::tx|DocumentType> node after
          an <IF::Element> node or an <IF::Element> node after
          a <IF::tx|DocumentType>.
        @@@@enImplNote:
          Although such document type node is not prohibited
          by DOM specification, Firefox 1.5 and Opera 9 TP1
          throws an <X::c|DOMException.HIERARCHY_REQUEST_ERR>.
      @@@dx:raises:
        @@@@@: c|DIFFERENT_DOCUMENT_ERR
        @@@@enDesc:
          If the <P::newChild> node was created from a different
          document than the one that created the node.
        @@@@enImplNote:
          The DOM specification ignores the fact that <IF::Document>s
          and <IF::tx|DocumentType>s are created from 
          <IF::c|DOMImplementation> :-)
      @@@dx:raises: 
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the node is read-only.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_SRC_PARENT
        @@@@enDesc:
          If the previous parent of the <P::newChild> node is read-only
          <SRC::DOM 1 SE, DOM 2, 3>.
      @@@dx:raises:
        @@@@@: c|NOT_CHILD_ERR
        @@@@enDesc:
          If the <P::refChild> node is not a child of the node.
      @@@c:reports:
        @@@@@: t|insert-before-itself
        @@@@enDesc:
          If the <P::newChild> node is same as the <P::refChild> node.
          Then, the result is implementation dependent.
        @@@@For: ManakaiDOM|ManakaiDOM
      @@@PerlDef:
        my $strictc = $self-><AG::Document.domConfig>
                           -><M::c|DOMConfiguration.getParameter>
                               (<Q::cfg|strict-document-children>);
        my $child_od = $newChild-><AG::Node.ownerDocument> || $self;
        my $child_nt = $newChild-><AG::Node.nodeType>;
        if ($strictc and $self-><AG::Document.strictErrorChecking>) {
          __DEEP{
            my $has_el;
            my $has_dt;
            if ($child_nt == <C::Node.ELEMENT_NODE>) {
              $has_el = true;
            } elsif ($child_nt == <C::Node.DOCUMENT_TYPE_NODE>) {
              $has_dt = true;
            } elsif ($child_nt == <C::Node.DOCUMENT_FRAGMENT_NODE>) {
              for my $cn (@{$newChild-><AG::Node.childNodes>}) {
                my $cnt = $cn-><AG::Node.nodeType>;
                if ($cnt == <C::Node.ELEMENT_NODE>) {
                  if ($has_el) {
                    __UNDEEP{__EXCEPTION{MDOMX|MDOM_SECOND_DOC_ELEMENT::
                      MDOMX|param-name => 'newChild',
                      c|node => {$newChild},
                    }__}__;
                  }
                  $has_el = true;
                }
                # DocumentType node cannot be contained in DocumentFragments
              }
            }
  
            if ($has_el) {
              my $anode = $refChild ? $refChild-><AG::Node.previousSibling>
                                    : $self-><AG::Node.lastChild>;
              while (defined $anode) {
                if ($anode-><AG::Node.nodeType> == <C::Node.ELEMENT_NODE>) {
                  __UNDEEP{__EXCEPTION{MDOMX|MDOM_SECOND_DOC_ELEMENT::
                    MDOMX|param-name => 'newChild',
                    c|node => {$newChild},
                  }__}__;
                }
                $anode = $anode-><AG::Node.previousSibling>;
              }
              $anode = $refChild;
              while (defined $anode) {
                my $ant = $anode-><AG::Node.nodeType>;
                if ($ant == <C::Node.ELEMENT_NODE>) {
                  __UNDEEP{__EXCEPTION{MDOMX|MDOM_SECOND_DOC_ELEMENT::
                    MDOMX|param-name => 'newChild',
                    c|node => {$newChild},
                  }__}__;
                } elsif ($ant == <C::Node.DOCUMENT_TYPE_NODE>) {
                  __UNDEEP{__EXCEPTION{c|HIERARCHY_WRONG_DOCTYPE_ERR::
                    MDOMX|param-name => 'newChild',
                    c|node => {$newChild},
                  }__}__;
                }
                $anode = $anode-><AG::Node.nextSibling>;
              }
            } # has_el
            if ($has_dt) {
              my $anode = $refChild ? $refChild-><AG::Node.previousSibling>
                                    : $self-><AG::Node.lastChild>;
              while (defined $anode) {
                my $ant = $anode-><AG::Node.nodeType>;
                if ($ant == <C::Node.ELEMENT_NODE>) {
                  __UNDEEP{__EXCEPTION{c|HIERARCHY_WRONG_DOCTYPE_ERR::
                    MDOMX|param-name => 'newChild',
                    c|node => {$newChild},
                  }__}__;
                } elsif ($ant == <C::Node.DOCUMENT_TYPE_NODE>) {
                  __UNDEEP{__EXCEPTION{MDOMX|MDOM_SECOND_DOCTYPE::
                    MDOMX|param-name => 'newChild',
                    c|node => {$newChild},
                  }__}__;
                }
                $anode = $anode-><AG::Node.previousSibling>;
              }
              $anode = $refChild;
              while (defined $anode) {
                if ($anode-><AG::Node.nodeType>
                        == <C::Node.DOCUMENT_TYPE_NODE>) {
                  __UNDEEP{__EXCEPTION{MDOMX|MDOM_SECOND_DOCTYPE::
                    MDOMX|param-name => 'newChild',
                    c|node => {$newChild},
                  }__}__;
                }
                $anode = $anode-><AG::Node.nextSibling>;
              }
            } # has_dt
          }__;
        }
        __CODE{tc|insertBeforeImpl1::
          $self => $self, $self_od => $self,
          $newChild => $newChild, $refChild => $refChild,
          $child_od => $child_od, $child_nt => $child_nt,
          $r => $r,
          $allowedNodeTypes => {{
            <C::Node.TEXT_NODE> => (not $strictc),
            <C::Node.ENTITY_REFERENCE_NODE> => (not $strictc),
            <C::Node.ELEMENT_NODE> => true,
            <C::Node.CDATA_SECTION_NODE> => (not $strictc),
            <C::Node.PROCESSING_INSTRUCTION_NODE> => true,
            <C::Node.COMMENT_NODE> => true,
            <C::Node.DOCUMENT_TYPE_NODE> => true,
          }},
        }__;
        if ($child_nt == <C::Node.DOCUMENT_TYPE_NODE> and
            not defined $newChild-><AG::Node.ownerDocument>) {
          my $bag = <Code::mg|getNodeBag||ManakaiDOM|all:: $ref = $self>;
          __CODE{mg|deleteOwnerProp||ManakaiDOM|all::
            $bag => $bag,
            $owneeref => $newChild,
            $owner0prop => {<H::f|implementation>},
            $ownee1hprop => {<H::f|revImplementation>},
          }__;
          __CODE{mg|setOwnerPropRR||ManakaiDOM|all::
            $bag => $bag,
            $ownerref => $self,
            $ownee1hprop => {<H::tc|revOwnerDocument>},
            $owneeref => $newChild,
            $owner0prop => {<H::tc|ownerDocument>},
          }__;
        }

  @CMethod:
    @@Name: replaceChild
    @@enDesc:
      Replaces a child node with another node.

      Replacing a node with itself is implementation dependent <SRC::DOM3>.
    @@Param:
      @@@Name: newChild
      @@@Type: Node
      @@@enDesc:
        The new node to put in the child list.

        If the <P::newChild> node is already in the tree,
        it is first removed.
      @@@InCase:
        @@@@Type: DocumentFragment
        @@@@enDesc:
          The <P::oldChild> node is replaced by all of the 
          <IF::DocumentFragment> children, which are inserted
          in the same order <SRC::DOM1 SE, DOM2, DOM3>.
    @@Param:
      @@@Name: oldChild
      @@@Type: Node
      @@@enDesc:
        The node being replaced in the list.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node replaced.
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_BAD_TYPE
        @@@@enDesc:
          If the node is of a type that does not allow children of
          the type of the <P::newChild> node.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_SECOND_DOC_ELEMENT
        @@@@enDesc:
          If the node is of type <IF::Document> and an attempt
          is made to append a second <IF::DocumentType> node
          <SRC::DOM 3>.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_SECOND_DOCTYPE
        @@@@enDesc:
          If the node is of type <IF::Document> and an attempt
          is made to append a second <IF::tx|DocumentType> node
          <SRC::DOM 3>.
      @@@dx:raises:
        @@@@@: c|HIERARCHY_WRONG_DOCTYPE_ERR
        @@@@enDesc:
          If the node is of type <IF::Document> and an attempt
          is made to append a <IF::tx|DocumentType> node after
          an <IF::Element> node or an <IF::Element> node after
          a <IF::tx|DocumentType>.
        @@@@enImplNote:
          Although such document type node is not prohibited
          by DOM specification, Firefox 1.5 and Opera 9 TP1
          throws an <X::c|DOMException.HIERARCHY_REQUEST_ERR>.
      @@@dx:raises:
        @@@@@: c|DIFFERENT_DOCUMENT_ERR
        @@@@enDesc:
          If the <P::newChild> node was created from a different
          document than the one that created the node.
        @@@@enImplNote:
          The DOM specification ignores the fact that <IF::Document>s
          and <IF::tx|DocumentType>s are created from 
          <IF::c|DOMImplementation> :-)
      @@@dx:raises: 
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the node is read-only.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_SRC_PARENT
        @@@@enDesc:
          If the previous parent of the <P::newChild> node is read-only
          <SRC::DOM1 SE, DOM2, DOM3>.
      @@@dx:raises:
        @@@@@: c|NOT_CHILD_ERR
        @@@@enDesc:
          If the <P::oldChild> node is not a child of the node.
      @@@c:reports:
        @@@@@: t|replaced-by-itself
        @@@@enDesc:
          If the <P::newChild> node is same as the <P::oldChild> node.
          Then, the result is implementation dependent.
        @@@@For: ManakaiDOM|ManakaiDOM
      @@@PerlDef:
        my $strictc = $self-><AG::Document.domConfig>
                           -><M::c|DOMConfiguration.getParameter>
                               (<Q::cfg|strict-document-children>);
        my $child_od = $newChild-><AG::Node.ownerDocument> || $self;
        my $child_nt = $newChild-><AG::Node.nodeType>;
        if ($strictc and $self-><AG::Document.strictErrorChecking>) {
          __DEEP{
            my $has_el;
            my $has_dt;
            if ($child_nt == <C::Node.ELEMENT_NODE>) {
              $has_el = true;
            } elsif ($child_nt == <C::Node.DOCUMENT_TYPE_NODE>) {
              $has_dt = true;
            } elsif ($child_nt == <C::Node.DOCUMENT_FRAGMENT_NODE>) {
              for my $cn (@{$newChild-><AG::Node.childNodes>}) {
                my $cnt = $cn-><AG::Node.nodeType>;
                if ($cnt == <C::Node.ELEMENT_NODE>) {
                  if ($has_el) {
                    __UNDEEP{__EXCEPTION{MDOMX|MDOM_SECOND_DOC_ELEMENT::
                      MDOMX|param-name => 'newChild',
                      c|node => {$newChild},
                    }__}__;
                  }
                  $has_el = true;
                }
                # DocumentType node cannot be contained in DocumentFragments
              }
            }
  
            if ($has_el) {
              my $anode = $oldChild-><AG::Node.previousSibling>;
              while (defined $anode) {
                if ($anode-><AG::Node.nodeType> == <C::Node.ELEMENT_NODE>) {
                  __UNDEEP{__EXCEPTION{MDOMX|MDOM_SECOND_DOC_ELEMENT::
                    MDOMX|param-name => 'newChild',
                    c|node => {$newChild},
                  }__}__;
                }
                $anode = $anode-><AG::Node.previousSibling>;
              }
              $anode = $oldChild-><AG::Node.nextSibling>;
              while (defined $anode) {
                my $ant = $anode-><AG::Node.nodeType>;
                if ($ant == <C::Node.ELEMENT_NODE>) {
                  __UNDEEP{__EXCEPTION{MDOMX|MDOM_SECOND_DOC_ELEMENT::
                    MDOMX|param-name => 'newChild',
                    c|node => {$newChild},
                  }__}__;
                } elsif ($ant == <C::Node.DOCUMENT_TYPE_NODE>) {
                  __UNDEEP{__EXCEPTION{c|HIERARCHY_WRONG_DOCTYPE_ERR::
                    MDOMX|param-name => 'newChild',
                    c|node => {$newChild},
                  }__}__;
                }
                $anode = $anode-><AG::Node.nextSibling>;
              }
            } # has_el
            if ($has_dt) {
              my $anode = $oldChild-><AG::Node.previousSibling>;
              while (defined $anode) {
                my $ant = $anode-><AG::Node.nodeType>;
                if ($ant == <C::Node.ELEMENT_NODE>) {
                  __UNDEEP{__EXCEPTION{c|HIERARCHY_WRONG_DOCTYPE_ERR::
                    MDOMX|param-name => 'newChild',
                    c|node => {$newChild},
                  }__}__;
                } elsif ($ant == <C::Node.DOCUMENT_TYPE_NODE>) {
                  __UNDEEP{__EXCEPTION{MDOMX|MDOM_SECOND_DOCTYPE::
                    MDOMX|param-name => 'newChild',
                    c|node => {$newChild},
                  }__}__;
                }
                $anode = $anode-><AG::Node.previousSibling>;
              }
              $anode = $oldChild-><AG::Node.nextSibling>;
              while (defined $anode) {
                if ($anode-><AG::Node.nodeType>
                        == <C::Node.DOCUMENT_TYPE_NODE>) {
                  __UNDEEP{__EXCEPTION{MDOMX|MDOM_SECOND_DOCTYPE::
                    MDOMX|param-name => 'newChild',
                    c|node => {$newChild},
                  }__}__;
                }
                $anode = $anode-><AG::Node.nextSibling>;
              }
            } # has_dt
          }__;
        }
        __CODE{tc|replaceChildImpl1::
          $self => $self, $self_od => $self,
          $newChild => $newChild, $refChild => $oldChild,
          $child_od => $child_od, $child_nt => $child_nt,
          $r => $r,
          $allowedNodeTypes => {{
            <C::Node.TEXT_NODE> => (not $strictc),
            <C::Node.ENTITY_REFERENCE_NODE> => (not $strictc),
            <C::Node.ELEMENT_NODE> => true,
            <C::Node.CDATA_SECTION_NODE> => (not $strictc),
            <C::Node.PROCESSING_INSTRUCTION_NODE> => true,
            <C::Node.COMMENT_NODE> => true,
            <C::Node.DOCUMENT_TYPE_NODE> => true,
          }},
        }__;
        if ($child_nt == <C::Node.DOCUMENT_TYPE_NODE> and
            not defined $newChild-><AG::Node.ownerDocument>) {
          my $bag = <Code::mg|getNodeBag||ManakaiDOM|all:: $ref = $self>;
          __CODE{mg|deleteOwnerProp||ManakaiDOM|all::
            $bag => $bag,
            $owneeref => $newChild,
            $owner0prop => {<H::f|implementation>},
            $ownee1hprop => {<H::f|revImplementation>},
          }__;
          __CODE{mg|setOwnerPropRR||ManakaiDOM|all::
            $bag => $bag,
            $ownerref => $self,
            $ownee1hprop => {<H::tc|revOwnerDocument>},
            $owneeref => $newChild,
            $owner0prop => {<H::tc|ownerDocument>},
          }__;
        }

    @@Test:
      @@@QName: Document.appendChild.1.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;

        my $dtd = $doc;
        my $pi = $doc-><M::Document.createTextNode> ('pi');

        my $return = $dtd-><M::Node.appendChild> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);

    @@Test:
      @@@QName: Document.appendChild.1.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;
        my $pi = $doc-><M::Document.createEntityReference> ('pi');

        my $return = $dtd-><M::Node.appendChild> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|EntityReference>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: Document.appendChild.1.3.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;
        my $pi = $doc-><M::Document.createElement> ('pi');

        my $return = $dtd-><M::Node.appendChild> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Element>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: Document.appendChild.1.4.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;
        my $pi = $doc-><M::Document.createProcessingInstruction> ('pi');

        my $return = $dtd-><M::Node.appendChild> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|ProcessingInstruction>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: Document.appendChild.1.5.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;
        my $pi = $doc-><M::Document.createCDATASection> ('pi');

        my $return = $dtd-><M::Node.appendChild> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|CDATASection>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: Document.appendChild.1.6.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;
        my $pi = $doc-><M::Document.createComment> ('pi');

        my $return = $dtd-><M::Node.appendChild> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tc|Comment>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: Document.appendChild.1.7.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;
        my $pi = $docx-><M::d|DocumentXDoctype.createDocumentTypeDefinition>
                          ('pi');

        my $return = $dtd-><M::Node.appendChild> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|DocumentType>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: Document.insertBefore.1.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;
        my $pi = $doc-><M::Document.createTextNode> ('pi');

        my $return = $dtd-><M::Node.insertBefore> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: Document.insertBefore.1.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;
        my $pi = $doc-><M::Document.createEntityReference> ('pi');

        my $return = $dtd-><M::Node.insertBefore> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|EntityReference>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: Document.insertBefore.1.3.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;
        my $pi = $doc-><M::Document.createElement> ('pi');

        my $return = $dtd-><M::Node.insertBefore> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Element>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: Document.insertBefore.1.4.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;
        my $pi = $doc-><M::Document.createProcessingInstruction> ('pi');

        my $return = $dtd-><M::Node.insertBefore> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|ProcessingInstruction>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: Document.insertBefore.1.5.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;
        my $pi = $doc-><M::Document.createCDATASection> ('pi');

        my $return = $dtd-><M::Node.insertBefore> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|CDATASection>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: Document.insertBefore.1.6.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;
        my $pi = $doc-><M::Document.createComment> ('pi');

        my $return = $dtd-><M::Node.insertBefore> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tc|Comment>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: Document.insertBefore.1.7.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;
        my $pi = $docx-><M::d|DocumentXDoctype.createDocumentTypeDefinition>
                          ('pi');

        my $return = $dtd-><M::Node.insertBefore> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|DocumentType>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);

    @@Test:
      @@@QName: Document.appendChild.has.parent.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;

        my $piparent = $doc-><M::Document.createElementNS> (null, 'e');
        my $pi = $doc-><M::Document.createTextNode> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.appendChild> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: Document.appendChild.has.parent.1.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;

        my $piparent = $doc-><M::Document.createElementNS> (null, 'e');
        my $pi = $doc-><M::Document.createEntityReference> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.appendChild> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|EntityReference>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: Document.insertBefore.has.parent.1.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;

        my $piparent = $doc-><M::Document.createElementNS> (null, 'e');
        my $pi = $doc-><M::Document.createTextNode> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.insertBefore> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: Document.insertBefore.has.parent.1.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;

        my $piparent = $doc-><M::Document.createElementNS> (null, 'e');
        my $pi = $doc-><M::Document.createEntityReference> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.insertBefore> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|EntityReference>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi);

    @@Test:
      @@@QName: Document.appendChild.documentfragment.1.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createTextNode> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.appendChild> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: Document.appendChild.documentfragment.1.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createEntityReference> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.appendChild> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|EntityReference>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: Document.insertBefore.documentfragment.1.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createTextNode> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.insertBefore> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: Document.insertBefore.documentfragment.1.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createEntityReference> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.insertBefore> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|EntityReference>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: Document.replaceChild.documentfragment.1.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;
        my $pi0 = $doc-><M::Document.createTextNode> ('pi0');
        $dtd-><M::Node.appendChild> ($pi0);

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createTextNode> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.replaceChild> ($piparent, $pi0);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi0);
    @@Test:
      @@@QName: Document.replaceChild.documentfragment.1.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;
        my $pi0 = $doc-><M::Document.createTextNode> ('pi0');
        $dtd-><M::Node.appendChild> ($pi0);

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createEntityReference> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.replaceChild> ($piparent, $pi0);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|EntityReference>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi0);

    @@Test:
      @@@QName: Document.appendChild.documentfragment.2.1.test
      @@@enDesc:
        Empty document fragment.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;

        my $piparent = $doc-><M::Document.createDocumentFragment>;

        my $return = $dtd-><M::Node.appendChild> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 0);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: Document.insertBefore.documentfragment.2.test
      @@@enDesc:
        Empty document fragment.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;

        my $piparent = $doc-><M::Document.createDocumentFragment>;

        my $return = $dtd-><M::Node.insertBefore> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 0);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: Document.replaceChild.documentfragment.2.test
      @@@enDesc:
        Empty document fragment.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;
        my $pi0 = $doc-><M::Document.createTextNode> ('pi0');
        $dtd-><M::Node.appendChild> ($pi0);

        my $piparent = $doc-><M::Document.createDocumentFragment>;

        my $return = $dtd-><M::Node.replaceChild> ($piparent, $pi0);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 0);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi0);

    @@Test:
      @@@QName: Document.appendChild.documentfragment.3.test
      @@@enDesc:
        Three PIs in document fragment.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createTextNode> ('pi');
        my $pi2 = $doc-><M::Document.createEntityReference> ('pi2');
        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $piparent-><M::Node.appendChild> ($pi);
        $piparent-><M::Node.appendChild> ($pi2);
        $piparent-><M::Node.appendChild> ($pi3);

        my $return = $dtd-><M::Node.appendChild> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 3);

        my $item = $child-><M::NodeList.item> (0);
        my $item2 = $child-><M::NodeList.item> (1);
        my $item3 = $child-><M::NodeList.item> (2);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);
        $test->id ('child.item.node2');
        $test->assert_isa ($item2, <IFName::Node>);
        $test->id ('child.item.node3');
        $test->assert_isa ($item3, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);
        $test->id ('child.item.pi2');
        $test->assert_isa ($item2, <IFName::tx|EntityReference>);
        $test->id ('child.item.pi3');
        $test->assert_isa ($item3, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);
        $test->id ('child.item.equals2');
        $test->assert_equals ($item2, $pi2);
        $test->id ('child.item.equals3');
        $test->assert_equals ($item3, $pi3);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi3);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);
        $test->id ('parent2');
        my $parent2 = $item2-><AG::Node.parentNode>;
        $test->assert_equals ($parent2, $dtd);
        $test->id ('parent3');
        my $parent3 = $item3-><AG::Node.parentNode>;
        $test->assert_equals ($parent3, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: Document.insertBefore.documentfragment.3.test
      @@@enDesc:
        Three PIs in document fragment.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createTextNode> ('pi');
        my $pi2 = $doc-><M::Document.createEntityReference> ('pi2');
        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $piparent-><M::Node.appendChild> ($pi);
        $piparent-><M::Node.appendChild> ($pi2);
        $piparent-><M::Node.appendChild> ($pi3);

        my $return = $dtd-><M::Node.insertBefore> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 3);

        my $item = $child-><M::NodeList.item> (0);
        my $item2 = $child-><M::NodeList.item> (1);
        my $item3 = $child-><M::NodeList.item> (2);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);
        $test->id ('child.item.node2');
        $test->assert_isa ($item2, <IFName::Node>);
        $test->id ('child.item.node3');
        $test->assert_isa ($item3, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);
        $test->id ('child.item.pi2');
        $test->assert_isa ($item2, <IFName::tx|EntityReference>);
        $test->id ('child.item.pi3');
        $test->assert_isa ($item3, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);
        $test->id ('child.item.equals2');
        $test->assert_equals ($item2, $pi2);
        $test->id ('child.item.equals3');
        $test->assert_equals ($item3, $pi3);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi3);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);
        $test->id ('parent2');
        my $parent2 = $item2-><AG::Node.parentNode>;
        $test->assert_equals ($parent2, $dtd);
        $test->id ('parent3');
        my $parent3 = $item3-><AG::Node.parentNode>;
        $test->assert_equals ($parent3, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: Document.replaceChild.documentfragment.3.test
      @@@enDesc:
        Three PIs in document fragment.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;
        my $pi0 = $doc-><M::Document.createTextNode> ('pi0');
        $dtd-><M::Node.appendChild> ($pi0);

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createTextNode> ('pi');
        my $pi2 = $doc-><M::Document.createEntityReference> ('pi2');
        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $piparent-><M::Node.appendChild> ($pi);
        $piparent-><M::Node.appendChild> ($pi2);
        $piparent-><M::Node.appendChild> ($pi3);

        my $return = $dtd-><M::Node.replaceChild> ($piparent, $pi0);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 3);

        my $item = $child-><M::NodeList.item> (0);
        my $item2 = $child-><M::NodeList.item> (1);
        my $item3 = $child-><M::NodeList.item> (2);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);
        $test->id ('child.item.node2');
        $test->assert_isa ($item2, <IFName::Node>);
        $test->id ('child.item.node3');
        $test->assert_isa ($item3, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);
        $test->id ('child.item.pi2');
        $test->assert_isa ($item2, <IFName::tx|EntityReference>);
        $test->id ('child.item.pi3');
        $test->assert_isa ($item3, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);
        $test->id ('child.item.equals2');
        $test->assert_equals ($item2, $pi2);
        $test->id ('child.item.equals3');
        $test->assert_equals ($item3, $pi3);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi3);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);
        $test->id ('parent2');
        my $parent2 = $item2-><AG::Node.parentNode>;
        $test->assert_equals ($parent2, $dtd);
        $test->id ('parent3');
        my $parent3 = $item3-><AG::Node.parentNode>;
        $test->assert_equals ($parent3, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi0);

    @@Test:
      @@@QName: Document.appendChild.badtype.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $comment = $doc;
        my $pi0 = $doc-><M::Document.createTextNode> ('pi0');
        $comment-><M::Node.appendChild> ($pi0);

        for my $node (
          $doc-><M::Document.createAttribute> ('a'),
          $docx-><M::d|DocumentXDoctype.createGeneralEntity> ('ge'),
          $docx-><M::d|DocumentXDoctype.createNotation> ('not'),
          $docx-><M::d|DocumentXDoctype.createElementTypeDefinition> ('et'),
          $docx-><M::d|DocumentXDoctype.createAttributeDefinition> ('at'),
          #test:nodeTypes
        ) {
          $test->id ('appendChild.'.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.appendChild> ($node);
          }, exception_subtype => <Q::MDOMX|HIERARCHY_BAD_TYPE>);

          $test->id ('insertBefore.'.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.insertBefore> ($node);
          }, exception_subtype => <Q::MDOMX|HIERARCHY_BAD_TYPE>);

          $test->id ('replaceChild.'.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.replaceChild> ($node, $pi0);
          }, exception_subtype => <Q::MDOMX|HIERARCHY_BAD_TYPE>);
        }

    @@Test:
      @@@QName: Document.appendChild.wrongdoc.test
      @@@PerlDef:
        my $doc0;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc0}__;
        my $docx0 = $doc0-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $comment = $doc0;

        for my $node (
          $doc-><M::Document.createTextNode> ('pi'),
          $doc-><M::Document.createEntityReference> ('e'),
          $doc-><M::Document.createComment> ('c'),
          $doc-><M::Document.createCDATASection> ('cs'),
          $doc-><M::Document.createProcessingInstruction> ('pi'),
          $doc-><M::Document.createElement> ('el'),
          $docx-><M::d|DocumentXDoctype.createDocumentTypeDefinition> ('del'),
        ) {
          $test->id ('type='.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.appendChild> ($node);
          }, exception_subtype => <Q::c|DIFFERENT_DOCUMENT_ERR>);
        }
    @@Test:
      @@@QName: Document.insertBefore.wrongdoc.test
      @@@PerlDef:
        my $doc0;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc0}__;
        my $docx0 = $doc0-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $comment = $doc0;
        my $pi0 = $doc0-><M::Document.createTextNode> ('pi0');
        $comment-><M::Node.appendChild> ($pi0);

        for my $node (
          $doc-><M::Document.createTextNode> ('pi'),
          $doc-><M::Document.createEntityReference> ('ent'),
          $doc-><M::Document.createComment> ('c'),
          $doc-><M::Document.createCDATASection> ('cs'),
          $doc-><M::Document.createProcessingInstruction> ('pi'),
          $doc-><M::Document.createElement> ('el'),
          $docx-><M::d|DocumentXDoctype.createDocumentTypeDefinition> ('del'),
        ) {
          $test->id ('appendChild.'.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.appendChild> ($node);
          }, exception_subtype => <Q::c|DIFFERENT_DOCUMENT_ERR>);

          $test->id ('insertBefore.'.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.insertBefore> ($node);
          }, exception_subtype => <Q::c|DIFFERENT_DOCUMENT_ERR>);

          $test->id ('replaceChild.'.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.replaceChild> ($node, $pi0);
          }, exception_subtype => <Q::c|DIFFERENT_DOCUMENT_ERR>);
        }

    @@Test:
      @@@QName: Document.appendChild.readonly.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;
        my $pi0 = $doc-><M::Document.createTextNode> ('pi0');
        $dtd-><M::Node.appendChild> ($pi0);
        $dtd-><M::Node.manakaiSetReadOnly> (true);

        $test->id ('pi');
        my $node = $doc-><M::Document.createTextNode> ('pi');

        $test->assert_exception (code => sub {
          $dtd-><M::Node.appendChild> ($node);
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);

        $test->id ('pi.insertBefore');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.insertBefore> ($node);
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);

        $test->id ('pi.replaceChild');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.replaceChild> ($node, $pi0);
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);

        $test->id ('fragment');
        my $node2 = $doc-><M::Document.createDocumentFragment>;
        $node2-><M::Node.appendChild> ($node);

        $test->assert_exception (code => sub {
          $dtd-><M::Node.appendChild> ($node2);
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);

        $test->id ('fragment.insertBefore');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.insertBefore> ($node2);
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);

        $test->id ('fragment.replaceChild');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.replaceChild> ($node2, $pi0);
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);

    @@Test:
      @@@QName: Document.appendChild.readonly.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;
        my $pi0 = $doc-><M::Document.createTextNode> ('pi0');
        $dtd-><M::Node.appendChild> ($pi0);

        $test->id ('pi');
        my $el = $doc-><M::Document.createElementNS> (null, 'e');
        my $node = $doc-><M::Document.createTextNode> ('pi');
        $el-><M::Node.appendChild> ($node);
        $el-><M::Node.manakaiSetReadOnly> (true);

        $test->assert_exception (code => sub {
          $dtd-><M::Node.appendChild> ($node);
        }, exception_subtype => <Q::MDOMX|NOMOD_SRC_PARENT>);

        $test->id ('pi.insertBefore');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.insertBefore> ($node);
        }, exception_subtype => <Q::MDOMX|NOMOD_SRC_PARENT>);

        $test->id ('pi.replaceChild');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.replaceChild> ($node, $pi0);
        }, exception_subtype => <Q::MDOMX|NOMOD_SRC_PARENT>);

        $test->id ('fragment');
        my $node2 = $doc-><M::Document.createDocumentFragment>;
        my $node3 = $doc-><M::Document.createTextNode> ('pi');
        $node2-><M::Node.appendChild> ($node3);
        $node2-><M::Node.manakaiSetReadOnly> (true);

        $test->assert_exception (code => sub {
          $dtd-><M::Node.appendChild> ($node2);
        }, exception_subtype => <Q::MDOMX|NOMOD_SRC_PARENT>);

        $test->id ('fragment.insertBefore');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.insertBefore> ($node2);
        }, exception_subtype => <Q::MDOMX|NOMOD_SRC_PARENT>);

        $test->id ('fragment.replaceChild');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.replaceChild> ($node2, $pi0);
        }, exception_subtype => <Q::MDOMX|NOMOD_SRC_PARENT>);

    @@Test:
      @@@QName: Document.insertBefore.refChild.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.insertBefore> ($pi2, $pi1);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi2);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi1);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: Document.insertBefore.refChild.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $dtd-><M::Node.insertBefore> ($pi3, $pi2);

        # pi1, pi3, pi2

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi1);

        $test->id ('firstChild.nextSibling');
        $test->assert_equals ($dtd-><AG::Node.firstChild>
                                  -><AG::Node.nextSibling>, $pi3);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi2);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 3);

    @@Test:
      @@@QName: Document.insertBefore.refChild.3.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $dtd-><M::Node.appendChild> ($pi3);

        # pi1, pi2, pi3

        $dtd-><M::Node.insertBefore> ($pi2, $pi1);
 
        # pi2, pi1, pi3

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi2);

        $test->id ('firstChild.nextSibling');
        $test->assert_equals ($dtd-><AG::Node.firstChild>
                                  -><AG::Node.nextSibling>, $pi1);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi3);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 3);

    @@Test:
      @@@QName: Document.insertBefore.refChild.4.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $dtd-><M::Node.appendChild> ($pi3);

        # pi1, pi2, pi3

        $dtd-><M::Node.insertBefore> ($pi3, $pi1);
 
        # pi3, pi1, pi2

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi3);

        $test->id ('firstChild.nextSibling');
        $test->assert_equals ($dtd-><AG::Node.firstChild>
                                  -><AG::Node.nextSibling>, $pi1);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi2);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 3);

    @@Test:
      @@@QName: Document.insertBefore.refChild.not_found_err.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');

        my $pi4 = $doc-><M::Document.createTextNode> ('pi4');

        # pi1, pi2

        $test->assert_exception (code => sub {
          $dtd-><M::Node.insertBefore> ($pi4, $pi3);
        }, exception_subtype => <Q::c|NOT_CHILD_ERR>);

    @@Test:
      @@@QName: Document.insertBefore.refChild=newChild.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        # pi1, pi2

        my $eh_called = false;
        my $cfg = $doc-><AG::Document.domConfig>;
        $cfg-><M::c|DOMConfiguration.setParameter> ('error-handler' => sub {
          my (undef, $err) = @_;
          $eh_called = true;
          $test->assert_equals ($err-><AG::c|DOMError.severity>,
                                <C::c|DOMError.SEVERITY_WARNING>);
          $test->assert_equals ($err-><AG::c|DOMError.type>,
                                <Q::t|insert-before-itself>);
          $test->assert_equals ($err-><AG::c|DOMError.relatedData>, $pi2);
          $test->assert_null ($err-><AG::c|DOMError.relatedException>);
          $test->assert_isa ($err-><AG::c|DOMError.location>,
                             <IFName::c|DOMLocator>);
          $test->assert_not_null ($err-><AG::c|DOMError.message>);
        });

        $test->assert_false ($eh_called);
        $dtd-><M::Node.insertBefore> ($pi2, $pi2);
        $test->assert_true ($eh_called);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi1);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi2);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: Document.replaceChild.oldChild=newChild.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        # pi1, pi2

        my $eh_called = false;
        my $cfg = $doc-><AG::Document.domConfig>;
        $cfg-><M::c|DOMConfiguration.setParameter> ('error-handler' => sub {
          my (undef, $err) = @_;
          $eh_called = true;
          $test->assert_equals ($err-><AG::c|DOMError.severity>,
                                <C::c|DOMError.SEVERITY_WARNING>);
          $test->assert_equals ($err-><AG::c|DOMError.type>,
                                <Q::t|replace-by-itself>);
          $test->assert_equals ($err-><AG::c|DOMError.relatedData>, $pi2);
          $test->assert_null ($err-><AG::c|DOMError.relatedException>);
          $test->assert_isa ($err-><AG::c|DOMError.location>,
                             <IFName::c|DOMLocator>);
          $test->assert_not_null ($err-><AG::c|DOMError.message>);
        });

        $test->assert_false ($eh_called);
        $dtd-><M::Node.replaceChild> ($pi2, $pi2);
        $test->assert_true ($eh_called);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi1);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi2);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: Document.appendChild.sameparent.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        # pi1, pi2

        my $return = $dtd-><M::Node.appendChild> ($pi1);

        # pi2, pi1

        $test->id ('return');
        $test->assert_equals ($return, $pi1);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi2);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi1);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: Document.insertBefore.sameparent.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        # pi1, pi2

        my $return = $dtd-><M::Node.insertBefore> ($pi1);

        # pi2, pi1

        $test->id ('return');
        $test->assert_equals ($return, $pi1);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi2);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi1);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: Document.appendChild.sameparent.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        # pi1, pi2

        my $return = $dtd-><M::Node.appendChild> ($pi2);

        # pi1, pi2

        $test->id ('return');
        $test->assert_equals ($return, $pi2);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi1);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi2);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: Document.insertBefore.sameparent.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        # pi1, pi2

        my $return = $dtd-><M::Node.insertBefore> ($pi2);

        # pi1, pi2

        $test->id ('return');
        $test->assert_equals ($return, $pi2);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi1);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi2);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: Document.replaceChild.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $dtd-><M::Node.appendChild> ($pi3);

        # pi1, pi2, pi3

        my $pi9 = $doc-><M::Document.createTextNode> ('pi9');
        my $return = $dtd-><M::Node.replaceChild> ($pi9, $pi1);

        # pi9, pi2, pi3

        $test->id ('return.node');
        $test->assert_isa ($return, <IFName::Node>);
        $test->id ('return.pi');
        $test->assert_isa ($return, <IFName::Text>);
        $test->id ('return');
        $test->assert_equals ($return, $pi1);

        my $c = $dtd-><AG::Node.childNodes>;

        $test->id ('length');
        $test->assert_num_equals (actual_value => 0+@$c, expected_value => 3);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi9);

        $test->id ('firstChild.nextSibling');
        $test->assert_equals ($dtd-><AG::Node.firstChild>
                                  -><AG::Node.nextSibling>, $pi2);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi3);
 
        $test->id ('parent');
        $test->assert_equals ($pi9-><AG::Node.parentNode>, $dtd);

        $test->id ('return.parent');
        $test->assert_null ($pi1-><AG::Node.parentNode>);

    @@Test:
      @@@QName: Document.replaceChild.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $dtd-><M::Node.appendChild> ($pi3);

        # pi1, pi2, pi3

        my $pi9 = $doc-><M::Document.createTextNode> ('pi9');
        my $return = $dtd-><M::Node.replaceChild> ($pi9, $pi2);

        # pi1, pi9, pi3

        $test->id ('return.node');
        $test->assert_isa ($return, <IFName::Node>);
        $test->id ('return.pi');
        $test->assert_isa ($return, <IFName::Text>);
        $test->id ('return');
        $test->assert_equals ($return, $pi2);

        my $c = $dtd-><AG::Node.childNodes>;

        $test->id ('length');
        $test->assert_num_equals (actual_value => 0+@$c, expected_value => 3);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi1);

        $test->id ('firstChild.nextSibling');
        $test->assert_equals ($dtd-><AG::Node.firstChild>
                                  -><AG::Node.nextSibling>, $pi9);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi3);
 
        $test->id ('parent');
        $test->assert_equals ($pi9-><AG::Node.parentNode>, $dtd);

        $test->id ('return.parent');
        $test->assert_null ($pi2-><AG::Node.parentNode>);

    @@Test:
      @@@QName: Document.replaceChild.3.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $dtd-><M::Node.appendChild> ($pi3);

        # pi1, pi2, pi3

        my $pi9 = $doc-><M::Document.createTextNode> ('pi9');
        my $return = $dtd-><M::Node.replaceChild> ($pi9, $pi3);

        # pi1, pi2, pi9

        $test->id ('return.node');
        $test->assert_isa ($return, <IFName::Node>);
        $test->id ('return.pi');
        $test->assert_isa ($return, <IFName::Text>);
        $test->id ('return');
        $test->assert_equals ($return, $pi3);

        my $c = $dtd-><AG::Node.childNodes>;

        $test->id ('length');
        $test->assert_num_equals (actual_value => 0+@$c, expected_value => 3);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi1);

        $test->id ('firstChild.nextSibling');
        $test->assert_equals ($dtd-><AG::Node.firstChild>
                                  -><AG::Node.nextSibling>, $pi2);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi9);
 
        $test->id ('parent');
        $test->assert_equals ($pi9-><AG::Node.parentNode>, $dtd);

        $test->id ('return.parent');
        $test->assert_null ($pi3-><AG::Node.parentNode>);

    @@Test:
      @@@QName: Document.replaceChild.sameparent.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $dtd-><M::Node.appendChild> ($pi3);

        # pi1, pi2, pi3

        my $return = $dtd-><M::Node.replaceChild> ($pi3, $pi1);

        # pi3, pi2

        $test->id ('return.node');
        $test->assert_isa ($return, <IFName::Node>);
        $test->id ('return.pi');
        $test->assert_isa ($return, <IFName::Text>);
        $test->id ('return');
        $test->assert_equals ($return, $pi1);

        my $c = $dtd-><AG::Node.childNodes>;

        $test->id ('length');
        $test->assert_num_equals (actual_value => 0+@$c, expected_value => 2);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi3);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi2);
 
        $test->id ('parent');
        $test->assert_equals ($pi3-><AG::Node.parentNode>, $dtd);

        $test->id ('return.parent');
        $test->assert_null ($pi1-><AG::Node.parentNode>);

    @@Test:
      @@@QName: Document.replaceChild.sameparent.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $dtd-><M::Node.appendChild> ($pi3);

        # pi1, pi2, pi3

        my $return = $dtd-><M::Node.replaceChild> ($pi1, $pi3);

        # pi2, pi1

        $test->id ('return.node');
        $test->assert_isa ($return, <IFName::Node>);
        $test->id ('return.pi');
        $test->assert_isa ($return, <IFName::Text>);
        $test->id ('return');
        $test->assert_equals ($return, $pi3);

        my $c = $dtd-><AG::Node.childNodes>;

        $test->id ('length');
        $test->assert_num_equals (actual_value => 0+@$c, expected_value => 2);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi2);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi1);
 
        $test->id ('parent');
        $test->assert_equals ($pi1-><AG::Node.parentNode>, $dtd);

        $test->id ('return.parent');
        $test->assert_null ($pi3-><AG::Node.parentNode>);

    @@Test:
      @@@QName: Document.appendChild.twodtd.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        $doc-><AG::Document.domConfig>
            -><M::c|DOMConfiguration.setParameter>
                (<Q::cfg|strict-document-children> => true);

        $doc-><M::Node.appendChild>
                ($docx-><M::d|DocumentXDoctype.createDocumentTypeDefinition>
                          ('dt1'));
        $doc-><M::Node.appendChild>
                ($doc-><M::Document.createComment> ('c'));

        my $dt2 = $docx-><M::d|DocumentXDoctype.createDocumentTypeDefinition>
                           ('dt2');

        $test->id ('appendChild');
        $test->assert_exception (code => sub {
          $doc-><M::Node.appendChild> ($dt2);
        }, exception_subtype => <Q::MDOMX|MDOM_SECOND_DOCTYPE>);

        $test->id ('insertBefore');
        $test->assert_exception (code => sub {
          $doc-><M::Node.insertBefore> ($dt2);
        }, exception_subtype => <Q::MDOMX|MDOM_SECOND_DOCTYPE>);

        $test->id ('replaceChild');
        $test->assert_exception (code => sub {
          $doc-><M::Node.replaceChild> ($dt2, $doc-><AG::Node.lastChild>);
        }, exception_subtype => <Q::MDOMX|MDOM_SECOND_DOCTYPE>);

    @@Test:
      @@@QName: Document.insertBefore.twodtd.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        $doc-><AG::Document.domConfig>
            -><M::c|DOMConfiguration.setParameter>
                (<Q::cfg|strict-document-children> => true);

        $doc-><M::Node.appendChild>
                ($docx-><M::d|DocumentXDoctype.createDocumentTypeDefinition>
                          ('dt1'));
        $doc-><M::Node.appendChild>
                ($doc-><M::Document.createComment> ('c'));

        my $dt2 = $docx-><M::d|DocumentXDoctype.createDocumentTypeDefinition>
                           ('dt2');

        $test->id ('insertBefore');
        $test->assert_exception (code => sub {
          $doc-><M::Node.insertBefore> ($dt2, $doc-><AG::Node.firstChild>);
        }, exception_subtype => <Q::MDOMX|MDOM_SECOND_DOCTYPE>);

    @@Test:
      @@@QName: Document.replaceChild.twodtd.3.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        $doc-><AG::Document.domConfig>
            -><M::c|DOMConfiguration.setParameter>
                (<Q::cfg|strict-document-children> => true);

        $doc-><M::Node.appendChild>
                ($docx-><M::d|DocumentXDoctype.createDocumentTypeDefinition>
                          ('dt1'));
        my $c = $doc-><M::Node.appendChild>
                        ($doc-><M::Document.createComment> ('c'));

        my $dt2 = $docx-><M::d|DocumentXDoctype.createDocumentTypeDefinition>
                           ('dt2');

        $doc-><M::Node.replaceChild> ($dt2, $doc-><AG::Node.firstChild>);

        $test->id ('first');
        $test->assert_equals ($doc-><AG::Node.firstChild>, $dt2);

        $test->id ('last');
        $test->assert_equals ($doc-><AG::Node.lastChild>, $c);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$doc-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: Document.appendChild.twoel.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        $doc-><AG::Document.domConfig>
            -><M::c|DOMConfiguration.setParameter>
                (<Q::cfg|strict-document-children> => true);

        $doc-><M::Node.appendChild>
                ($doc-><M::Document.createElement>
                          ('dt1'));
        $doc-><M::Node.appendChild>
                ($doc-><M::Document.createComment> ('c'));

        my $dt2 = $doc-><M::Document.createElement>
                           ('dt2');

        $test->id ('appendChild');
        $test->assert_exception (code => sub {
          $doc-><M::Node.appendChild> ($dt2);
        }, exception_subtype => <Q::MDOMX|MDOM_SECOND_DOC_ELEMENT>);

        $test->id ('insertBefore');
        $test->assert_exception (code => sub {
          $doc-><M::Node.insertBefore> ($dt2);
        }, exception_subtype => <Q::MDOMX|MDOM_SECOND_DOC_ELEMENT>);

        $test->id ('replaceChild');
        $test->assert_exception (code => sub {
          $doc-><M::Node.replaceChild> ($dt2, $doc-><AG::Node.lastChild>);
        }, exception_subtype => <Q::MDOMX|MDOM_SECOND_DOC_ELEMENT>);

    @@Test:
      @@@QName: Document.insertBefore.twoel.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        $doc-><AG::Document.domConfig>
            -><M::c|DOMConfiguration.setParameter>
                (<Q::cfg|strict-document-children> => true);

        $doc-><M::Node.appendChild>
                ($doc-><M::Document.createElement>
                          ('dt1'));
        $doc-><M::Node.appendChild>
                ($doc-><M::Document.createComment> ('c'));

        my $dt2 = $doc-><M::Document.createElement>
                           ('dt2');

        $test->id ('insertBefore');
        $test->assert_exception (code => sub {
          $doc-><M::Node.insertBefore> ($dt2, $doc-><AG::Node.firstChild>);
        }, exception_subtype => <Q::MDOMX|MDOM_SECOND_DOC_ELEMENT>);

    @@Test:
      @@@QName: Document.replaceChild.twoel.3.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        $doc-><AG::Document.domConfig>
            -><M::c|DOMConfiguration.setParameter>
                (<Q::cfg|strict-document-children> => true);

        $doc-><M::Node.appendChild>
                ($doc-><M::Document.createElement>
                          ('dt1'));
        my $c = $doc-><M::Node.appendChild>
                        ($doc-><M::Document.createComment> ('c'));

        my $dt2 = $doc-><M::Document.createElement>
                           ('dt2');

        $doc-><M::Node.replaceChild> ($dt2, $doc-><AG::Node.firstChild>);

        $test->id ('first');
        $test->assert_equals ($doc-><AG::Node.firstChild>, $dt2);

        $test->id ('last');
        $test->assert_equals ($doc-><AG::Node.lastChild>, $c);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$doc-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: Document.appendChild.twoel.4.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        $doc-><AG::Document.domConfig>
            -><M::c|DOMConfiguration.setParameter>
                (<Q::cfg|strict-document-children> => true);

        $doc-><M::Node.appendChild>
                ($doc-><M::Document.createElement>
                          ('dt1'));
        $doc-><M::Node.appendChild>
                ($doc-><M::Document.createComment> ('c'));

        my $dt2 = $doc-><M::Document.createElement>
                           ('dt2');
        my $df = $doc-><M::Document.createDocumentFragment>;
        $df-><M::Node.appendChild> ($dt2);

        $test->id ('appendChild');
        $test->assert_exception (code => sub {
          $doc-><M::Node.appendChild> ($df);
        }, exception_subtype => <Q::MDOMX|MDOM_SECOND_DOC_ELEMENT>);

        $test->id ('insertBefore');
        $test->assert_exception (code => sub {
          $doc-><M::Node.insertBefore> ($df);
        }, exception_subtype => <Q::MDOMX|MDOM_SECOND_DOC_ELEMENT>);

        $test->id ('replaceChild');
        $test->assert_exception (code => sub {
          $doc-><M::Node.replaceChild> ($df, $doc-><AG::Node.lastChild>);
        }, exception_subtype => <Q::MDOMX|MDOM_SECOND_DOC_ELEMENT>);

    @@Test:
      @@@QName: Document.appendChild.el.dtd.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        $doc-><AG::Document.domConfig>
            -><M::c|DOMConfiguration.setParameter>
                (<Q::cfg|strict-document-children> => true);

        $doc-><M::Node.appendChild>
                ($doc-><M::Document.createElement>
                          ('dt1'));
        $doc-><M::Node.appendChild>
                ($doc-><M::Document.createComment> ('c'));

        my $dt2 = $docx-><M::d|DocumentXDoctype.createDocumentTypeDefinition>
                           ('dt2');

        $test->id ('appendChild');
        $test->assert_exception (code => sub {
          $doc-><M::Node.appendChild> ($dt2);
        }, exception_subtype => <Q::c|HIERARCHY_WRONG_DOCTYPE_ERR>);

        $test->id ('insertBefore');
        $test->assert_exception (code => sub {
          $doc-><M::Node.insertBefore> ($dt2);
        }, exception_subtype => <Q::c|HIERARCHY_WRONG_DOCTYPE_ERR>);

        $test->id ('replaceChild');
        $test->assert_exception (code => sub {
          $doc-><M::Node.replaceChild> ($dt2, $doc-><AG::Node.lastChild>);
        }, exception_subtype => <Q::c|HIERARCHY_WRONG_DOCTYPE_ERR>);

    @@Test:
      @@@QName: Document.appendChild.el.dtd.3.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        $doc-><AG::Document.domConfig>
            -><M::c|DOMConfiguration.setParameter>
                (<Q::cfg|strict-document-children> => true);

        $doc-><M::Node.appendChild>
                ($doc-><M::Document.createComment> ('c'));
        $doc-><M::Node.appendChild>
                ($docx-><M::d|DocumentXDoctype.createDocumentTypeDefinition>
                          ('dt1'));

        my $dt2 = $doc-><M::Document.createElement> ('dt2');
        my $df = $doc-><M::Document.createDocumentFragment>;
        $df-><M::Node.appendChild> ($dt2);

        $test->id ('insertBefore');
        $test->assert_exception (code => sub {
          $doc-><M::Node.insertBefore> ($df, $doc-><AG::Node.firstChild>);
        }, exception_subtype => <Q::c|HIERARCHY_WRONG_DOCTYPE_ERR>);

        $test->id ('replaceChild');
        $test->assert_exception (code => sub {
          $doc-><M::Node.replaceChild> ($df, $doc-><AG::Node.firstChild>);
        }, exception_subtype => <Q::c|HIERARCHY_WRONG_DOCTYPE_ERR>);

    @@Test:
      @@@QName: Document.appendChild.el.dtd.4.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        $doc-><AG::Document.domConfig>
            -><M::c|DOMConfiguration.setParameter>
                (<Q::cfg|strict-document-children> => true);

        $doc-><M::Node.appendChild>
                ($doc-><M::Document.createComment> ('c'));
        $doc-><M::Node.appendChild>
                ($docx-><M::d|DocumentXDoctype.createDocumentTypeDefinition>
                          ('dt1'));

        my $dt2 = $doc-><M::Document.createElement> ('dt2');

        $test->id ('insertBefore');
        $test->assert_exception (code => sub {
          $doc-><M::Node.insertBefore> ($dt2, $doc-><AG::Node.firstChild>);
        }, exception_subtype => <Q::c|HIERARCHY_WRONG_DOCTYPE_ERR>);

        $test->id ('replaceChild');
        $test->assert_exception (code => sub {
          $doc-><M::Node.replaceChild> ($dt2, $doc-><AG::Node.firstChild>);
        }, exception_subtype => <Q::c|HIERARCHY_WRONG_DOCTYPE_ERR>);

    @@Test:
      @@@QName: Document.appendChild.newDocumentType.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;

        my $dtd = $doc-><AG::Document.implementation>
                      -><M::c|DOMImplementation.createDocumentType> ('d');

        $doc-><M::Node.appendChild> ($dtd);

        $test->id ('doctype');
        $test->assert_isa ($doc-><AG::Document.doctype>,
                           <IFName::tx|DocumentType>);

        $test->id ('length');
        $test->assert_num_equals
                 (expected_value => 1,
                  actual_value => 0+@{$doc-><AG::Node.childNodes>});

        $test->id ('firstChild');
        $test->assert_equals ($doc-><AG::Node.firstChild>, $dtd);

        $test->id ('parent');
        $test->assert_equals ($dtd-><AG::Node.parentNode>, $doc);

        $test->id ('od');
        $test->assert_equals ($dtd-><AG::Node.ownerDocument>, $doc);

        $test->id ('impl');
        $test->assert_equals ($dtd-><AG::tx|DocumentType.implementation>,
                              $doc-><AG::Document.implementation>);
    @@Test:
      @@@QName: Document.insertBefore.newDocumentType.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;

        my $dtd = $doc-><AG::Document.implementation>
                      -><M::c|DOMImplementation.createDocumentType> ('d');

        $doc-><M::Node.insertBefore> ($dtd);

        $test->id ('doctype');
        $test->assert_isa ($doc-><AG::Document.doctype>,
                           <IFName::tx|DocumentType>);

        $test->id ('length');
        $test->assert_num_equals
                 (expected_value => 1,
                  actual_value => 0+@{$doc-><AG::Node.childNodes>});

        $test->id ('firstChild');
        $test->assert_equals ($doc-><AG::Node.firstChild>, $dtd);

        $test->id ('parent');
        $test->assert_equals ($dtd-><AG::Node.parentNode>, $doc);

        $test->id ('od');
        $test->assert_equals ($dtd-><AG::Node.ownerDocument>, $doc);

        $test->id ('impl');
        $test->assert_equals ($dtd-><AG::tx|DocumentType.implementation>,
                              $doc-><AG::Document.implementation>);

    @@Test:
      @@@QName: Document.replaceChild.newDocumentType.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;

        my $dtd = $doc-><AG::Document.implementation>
                      -><M::c|DOMImplementation.createDocumentType> ('d');
        my $c = $doc-><M::Document.createComment> ('c');
        $doc-><M::Node.appendChild> ($c);

        $doc-><M::Node.replaceChild> ($dtd, $c);

        $test->id ('doctype');
        $test->assert_isa ($doc-><AG::Document.doctype>,
                           <IFName::tx|DocumentType>);

        $test->id ('length');
        $test->assert_num_equals
                 (expected_value => 1,
                  actual_value => 0+@{$doc-><AG::Node.childNodes>});

        $test->id ('firstChild');
        $test->assert_equals ($doc-><AG::Node.firstChild>, $dtd);

        $test->id ('parent');
        $test->assert_equals ($dtd-><AG::Node.parentNode>, $doc);

        $test->id ('od');
        $test->assert_equals ($dtd-><AG::Node.ownerDocument>, $doc);

        $test->id ('impl');
        $test->assert_equals ($dtd-><AG::tx|DocumentType.implementation>,
                              $doc-><AG::Document.implementation>);

  @CMethod:
    @@Name: manakaiAppendText
    @@Param:
      @@@Name: string
      @@@Type: DOMString
      @@@enDesc:
        The string to append.
      @@@InCase:
        @@@@Type: DISPerl|SCALAR||ManakaiDOM|all
        @@@@enDesc:
          A copy of the string value referenced from the value
          is appended.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node itself.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the node to insert the string or a <IF::Text> node
          is read-only.
      @@@PerlDef:
        __DEEP{
          unless ($self-><AG::Document.domConfig>
                       -><M::c|DOMConfiguration.getParameter>
                           (<Q::cfg|strict-document-children>)) {
            my $lc = $self-><AG::Node.lastChild>;
            if (defined $lc and
                $lc-><AG::Node.nodeType> == <C::Node.TEXT_NODE>) {
              $lc-><M::Node.manakaiAppendText>
                     (ref $string eq 'SCALAR' ? $string : \$string);
            } else {
              my $text = $self-><M::Document.createTextNode> 
                                  (ref $string eq 'SCALAR' ? $$string : $string);
              $self-><M::Node.appendChild> ($text);
            }
          }
          $r = $self;
        }__;

    @@Test:
      @@@QName: Document..=.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;

        my $node = $doc;

        $node-><M::Node.manakaiAppendText> ('string');
        $test->id ('1.class');
        $test->assert_isa ($node, <IFName::Document>);
        $test->id ('1.length');
        $test->assert_num_equals
                 (expected_value => 1,
                  actual_value => 0+@{$node-><AG::Node.childNodes>});
        $test->id ('1.value');
        $test->assert_equals ($node-><AG::Node.lastChild>
                                   -><AG::Node.textContent>, 'string');

        $test->id (2);
        $node-><M::Node.manakaiAppendText> ('STRING');
        $test->assert_num_equals
                 (expected_value => 1,
                  actual_value => 0+@{$node-><AG::Node.childNodes>});
        $test->assert_equals ($node-><AG::Node.lastChild>
                                   -><AG::Node.textContent>, 'stringSTRING');

        $node-><M::Node.appendChild>
                 ($doc-><M::Document.createEntityReference> ('er'));

        $test->id (3);
        $node-><M::Node.manakaiAppendText> ('text');
        $test->assert_num_equals
                 (expected_value => 3,
                  actual_value => 0+@{$node-><AG::Node.childNodes>});
        $test->assert_equals ($node-><AG::Node.lastChild>
                                   -><AG::Node.textContent>, 'text');

    @@Test:
      @@@QName: Document..=.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $node = $doc;

        $node-><M::Node.manakaiAppendText> ('aaaa');
        $test->id ('1.class');
        $test->assert_isa ($node, <IFName::Document>);
        $test->id ('1.value');
        $test->assert_null ($node-><AG::Node.textContent>);

  @CMethod:
    @@Name: removeChild
    @@enDesc:
      Removes a child node.
    @@Param:
      @@@Name: oldChild
      @@@Type: Node
    @@Return:
      @@@Type: Node
      @@@NodeReadOnlyError:
      @@@dx:raises:
        @@@@@: c|NOT_CHILD_ERR
        @@@@enDesc:
          If the <P::oldChild> is not a child of the node.
      @@@PerlDef:
        if ($self-><AG::Document.strictErrorChecking> and
            $self-><AG::Node.manakaiReadOnly>) {
          __EXCEPTION{MDOMX|NOMOD_THIS::
          }__;
        }
        __CODE{tc|removeChildImpl}__;

    @@Test:
      @@@QName: Doc.removeChild.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $c1 = $doc-><M::Document.createComment> ('e');
        $doc-><M::Node.appendChild> ($c1);

        my $c2 = $doc-><M::Document.createComment> ('f');
        $doc-><M::Node.appendChild> ($c2);

        my $c3 = $doc-><M::Document.createComment> ('g');
        $doc-><M::Node.appendChild> ($c3);

        my $return = $doc-><M::Node.removeChild> ($c1);

        $test->id ('return');
        $test->assert_equals ($return, $c1);

        $test->id ('parentNode');
        $test->assert_null ($c1-><AG::Node.parentNode>);

        $test->id ('firstChild');
        $test->assert_equals ($doc-><AG::Node.firstChild>, $c2);

        $test->id ('lastChild');
        $test->assert_equals ($doc-><AG::Node.lastChild>, $c3);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$doc-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: Doc.removeChild.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $c1 = $doc-><M::Document.createComment> ('e');
        $doc-><M::Node.appendChild> ($c1);

        my $c2 = $doc-><M::Document.createComment> ('f');
        $doc-><M::Node.appendChild> ($c2);

        my $c3 = $doc-><M::Document.createComment> ('g');
        $doc-><M::Node.appendChild> ($c3);

        my $return = $doc-><M::Node.removeChild> ($c2);

        $test->id ('return');
        $test->assert_equals ($return, $c2);

        $test->id ('parentNode');
        $test->assert_null ($c2-><AG::Node.parentNode>);

        $test->id ('firstChild');
        $test->assert_equals ($doc-><AG::Node.firstChild>, $c1);

        $test->id ('lastChild');
        $test->assert_equals ($doc-><AG::Node.lastChild>, $c3);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$doc-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: Doc.removeChild.3.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $c1 = $doc-><M::Document.createComment> ('e');
        $doc-><M::Node.appendChild> ($c1);

        my $c2 = $doc-><M::Document.createComment> ('f');
        $doc-><M::Node.appendChild> ($c2);

        my $c3 = $doc-><M::Document.createComment> ('g');
        $doc-><M::Node.appendChild> ($c3);

        my $return = $doc-><M::Node.removeChild> ($c3);

        $test->id ('return');
        $test->assert_equals ($return, $c3);

        $test->id ('parentNode');
        $test->assert_null ($c3-><AG::Node.parentNode>);

        $test->id ('firstChild');
        $test->assert_equals ($doc-><AG::Node.firstChild>, $c1);

        $test->id ('lastChild');
        $test->assert_equals ($doc-><AG::Node.lastChild>, $c2);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$doc-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: Doc.removeChild.4.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $c1 = $doc-><M::Document.createComment> ('e');
        $doc-><M::Node.appendChild> ($c1);

        my $return = $doc-><M::Node.removeChild> ($c1);

        $test->id ('return');
        $test->assert_equals ($return, $c1);

        $test->id ('parentNode');
        $test->assert_null ($c1-><AG::Node.parentNode>);

        $test->id ('firstChild');
        $test->assert_null ($doc-><AG::Node.firstChild>);

        $test->id ('lastChild');
        $test->assert_null ($doc-><AG::Node.lastChild>);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$doc-><AG::Node.childNodes>},
                  expected_value => 0);

  @Test:
    @@QName: Doc.attributes.test
    @@PerlDef:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

      $test->assert_null ($doc-><AG::Node.attributes>);

  @CAttr:
    @@Name: nodeName
    @@enDesc:
      The node name.
    @@DOMMain:isNamespaceUnaware:1
    @@Type: DOMString
    @@Get:
      @@@disDef:
        @@@@DISLang:value:
          @@@@@@: \#document
          @@@@@ContentType:
            DISCore:String

    @@Test:
      @@@QName: Doc.nodeName.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        $test->assert_equals ($doc-><AG::Node.nodeName>, '#document');

  @CL3Attr:
    @@Name: textContent
    @@enDesc:
      The text content of the node and its descendants.
    @@Type: DOMString
    @@Get:
      @@@nullCase:
      @@@PerlDef:
        __DEEP{
          if ($self-><AG::Document.domConfig>
                   -><M::c|DOMConfiguration.getParameter>
                       (<Q::cfg|strict-document-children>)) {
            $r = null;
          } else {
            $r = '';
            my @target = @{$self-><AG::Node.childNodes>};
            C: for my $node (@target) {
              my $nt = $node-><AG::Node.nodeType>;
              if ($nt == <C::Node.TEXT_NODE> or
                  $nt == <C::Node.CDATA_SECTION_NODE>) {
                $r .= $node-><AG::tc|CharacterData.data>
                  unless $node-><AG::Text.isElementContentWhitespace>;
              } elsif ($nt == <C::Node.ELEMENT_NODE> or
                       $nt == <C::Node.ENTITY_REFERENCE_NODE>) {
                unshift @target, @{$node-><AG::Node.childNodes>};
              }
            }
          }
        }__;
    @@Set:
      @@@nullCase:
      @@@NodeReadOnlyError:
       @@@c:reports:
         @@@@@: c|setting-node-value-no-effect
         @@@@enDesc:
           Setting the attribute value has no effect, since the
           node value is defined as <DOM::null>.
      @@@PerlDef:
        if ($self-><AG::Document.domConfig>
                 -><M::c|DOMConfiguration.getParameter>
                     (<Q::cfg|strict-document-children>)) {
          __c|ERROR{t|setting-node-value-no-effect::
            c|relatedData => {$self},
          }__;
        } else {
          __CODE{tc|setNodeTextContent::
            $node => $self,
            $given => $given,
            $ownerDocument => $self,
          }__;
        }

  @CL3Method:
    @@Name: getFeature
    @@enDesc:
      Returns a specialized object that implements the specialized APIs.
    @@Param:
      @@@Name: feature
      @@@Type: DOMString
      @@@dis:actualType: f|FeatureNameString
    @@Param:
      @@@Name: version
      @@@Type: DOMString
      @@@dis:actualType: f|FeatureVersionString
    @@Return:
      @@@Type: DOMMain|DOMObject
      @@@nullCase:
      @@@PerlDef:
        $feature =~ s/^\+//;

        ## TODO: Remove this code and implement autoload
        if ($feature eq <Q::fe|xdoctype>) {
          require Message::DOM::XDoctype;
        }

        __CODE{f|getFeatureImpl::
          $self => $self,
          $feature => $feature, $version => $version, $r => $r,
          $base_class => {<ClassName::ManakaiDOMDocument>},
        }__;
        unless (defined $r) {
          __DEEP{
            $r = $self->SUPER::get_feature ($feature, $version);
          }__;
        }

    @@Test:
      @@@QName: Document.getFeature.test
      @@@PerlDef:
        my $node;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $node}__;

        for (
          [Core => '1.0', <IFName::Document||ManakaiDOM|ManakaiDOM1>],
          [Core => '2.0', <IFName::Document||ManakaiDOM|ManakaiDOM2>],
          [Core => '3.0', <IFName::Document||ManakaiDOM|ManakaiDOM3>],
          [XML => '1.0', <IFName::Document||ManakaiDOM|ManakaiDOM1>],
          [XML => '2.0', <IFName::Document||ManakaiDOM|ManakaiDOM2>],
          [XML => '3.0', <IFName::Document||ManakaiDOM|ManakaiDOM3>],
        ) {
          $test->id ($_->[0].'.'.$_->[1]);
          my $sp = $node-><M::Node.getFeature> ($_->[0], $_->[1]);
          $test->assert_isa ($sp, $_->[2]);
        }

  @CL3Attr:
    @@Name: baseURI
    @@enDesc:
      The base URI of the node.
    @@Type: DOMString
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          If it is not available.
      @@@PerlDef:
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $r,
          $prop => {<H::infoset|baseURI>},
          $ref => $self,
        }__;
        unless (defined $r) {
          __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
            $r => $r,
            $prop => {<H::c|documentURI>},
            $ref => $self,
          }__;
        }
      @@@enImplNote:
        {TODO::
          HTML <HE::base> element support (awaiting until HTML5 clarification)
        }

    @@L3Test:
      @@@QName: Document.baseURI.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        $test->id ('initial');
        $test->assert_null ($doc-><AG::Node.baseURI>);

        $test->id ('docuri.set');
        $doc-><AS::Document.documentURI> ('ftp://suika.fam.cx/');
        $test->assert_equals ($doc-><AG::Node.baseURI>,
                              q<ftp://suika.fam.cx/>);

        $test->id ('docuri.reset');
        $doc-><AS::Document.documentURI> (null);
        $test->assert_null ($doc-><AG::Node.baseURI>);
        $test->assert_null ($doc-><AG::Document.manakaiEntityBaseURI>);

        $test->id ('mburi.set');
        $doc-><AS::Document.manakaiEntityBaseURI> (q<https://suika.fam.cx/>);
        $test->assert_equals ($doc-><AG::Node.baseURI>,
                              q<https://suika.fam.cx/>);
        $test->assert_equals ($doc-><AG::Document.manakaiEntityBaseURI>,
                              q<https://suika.fam.cx/>);

        $test->id ('mburi.reset');
        $doc-><AS::Document.manakaiEntityBaseURI> (null);
        $test->assert_null ($doc-><AG::Node.baseURI>);
        $test->assert_null ($doc-><AG::Document.manakaiEntityBaseURI>);

        $test->id ('docuri.mburi.set');
        $doc-><AS::Document.documentURI> ('ftp://suika.fam.cx/');
        $doc-><AS::Document.manakaiEntityBaseURI> (q<https://suika.fam.cx/>);
        $test->assert_equals ($doc-><AG::Node.baseURI>,
                              q<https://suika.fam.cx/>);
        $test->assert_equals ($doc-><AG::Document.manakaiEntityBaseURI>,
                              q<https://suika.fam.cx/>);

  @Method:
    @@Name: createElement
    @@enDesc:
      Creates an element of the specified type.

      If there are known attributes with default values, 
      <IF::Attr> nodes representing them are automatically created
      and attached to the element.
    @@NSVersion:.createElementNS
    @@Param:
      @@@Name: tagName
      @@@Type: DOMString
      @@@enDesc:
        The name of the element type to instantiate.

        For XML this is case-sensitive.  <SRC::DOM1, DOM2, DOM3>

        For HTML the <P::tagName> parameter may be provided
        in any case, but it must be mapped to the canonical uppercase
        form by the implementation.  <SRC::DOM1, DOM2>

        If the markup language is different from XML, it
        depends on the case-sensitibity of the markup
        language in use.  In that case, the name is
        mapped to the canonical form of that markup by
        the implementation.  <SRC::DOM3>
    @@Return:
      @@@Type: Element
      @@@enDesc:
        {P:: A new <IF::Element> node with:

          - <A::Node.nodeName>::: <P::tagName>.

          - <A::Node.localName>::: <DOM::null>.  <SRC::DOM2, DOM3>
                However, in manakai, as well as in Web browsers,
                it is set to <P::tagName>, even if it is not
                an <CODE::NCName>.

          - <A::Node.prefix>::: <DOM::null>.

          - <A::Node.namespaceURI>::: <DOM::null>.

        }
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_BAD_NAME
        @@@@enDesc:
          If the specified name is not an XML <CODE::Name>
          according to the XML version in use specified in the
          <A::Document.xmlVersion> attribute.
      @@@PerlDef:
        my $strict = $self-><AG::Document.strictErrorChecking>;
        if ($strict) {
          my $version = $self-><AG::Document.xmlVersion>;
          __CODE{DOMMain|ensureXMLName::
            $INPUT => $tagName, $INPUT_PARAM_NAME => 'tagName',
            $XMLVERSION => $version,
          }__;
        }
        __DEEP{
          $self-><AS::Document.strictErrorChecking> (false);
          $r = $self-><M::Document.createElementNS> (null, [null, $tagName]);
          $self-><AS::Document.strictErrorChecking> ($strict);
        }__;
    @@enImplNote:
      {ISSUE::
        <P::tagName> normalization (HTML5)
      }

    @@Test:
      @@@QName: Document.createElement.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createElement> ('elName');

        $test->id ('interface');
        $test->assert_isa ($el, <IFName::Element>);

        $test->id ('nodeName');
        $test->assert_equals ($el-><AG::Node.nodeName>, 'elName');

        $test->id ('localName');
        $test->assert_equals ($el-><AG::Node.localName>, 'elName');

        $test->id ('namespaceURI');
        $test->assert_null ($el-><AG::Node.namespaceURI>);

        $test->id ('prefix');
        $test->assert_null ($el-><AG::Node.prefix>);
    @@Test:
      @@@QName: Document.createElement.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createElement> ('el:name');

        $test->id ('interface');
        $test->assert_isa ($el, <IFName::Element>);

        $test->id ('nodeName');
        $test->assert_equals ($el-><AG::Node.nodeName>, 'el:name');

        $test->id ('localName');
        $test->assert_equals ($el-><AG::Node.localName>, 'el:name');

        $test->id ('namespaceURI');
        $test->assert_null ($el-><AG::Node.namespaceURI>);

        $test->id ('prefix');
        $test->assert_null ($el-><AG::Node.prefix>);
    @@Test:
      @@@QName: Document.createElement.nodefaultattr.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createElement> ('et1');

        $test->assert_num_equals
                 (actual_value => $el-><AG::Node.attributes>
                                     -><AG::NamedNodeMap.length>,
                  expected_value => 0);
    @@Test:
      @@@QName: Document.createElement.defaultattr.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docd = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>, '3.0');
        my $dtd = $docd-><M::d|DocumentXDoctype.createDocumentTypeDefinition>
                           ('doctype');
          my $et = $docd-><M::d|DocumentXDoctype.createElementTypeDefinition>
                             ('et1');
            my $at = $docd-><M::d|DocumentXDoctype.createAttributeDefinition>
                               ('dattr1');
            $at-><AS::ATDef.defaultType> (<C::ATDef.EXPLICIT_DEFAULT>);
            $at-><AS::Node.textContent> ('dattr1 default ');
          $et-><M::ETDef.setAttributeDefinitionNode> ($at);
        $dtd-><M::DTDef.setElementTypeDefinitionNode> ($et);
        $doc-><M::Node.appendChild> ($dtd);

        my $el = $doc-><M::Document.createElement> ('et1');

        $test->id ('attributes.length');
        $test->assert_num_equals
                 (actual_value => $el-><AG::Node.attributes>
                                     -><AG::NamedNodeMap.length>,
                  expected_value => 1);
        
        $test->id ('has.attribute');
        $test->assert_true ($el-><M::Element.hasAttribute> ('dattr1'));

        $test->id ('get.attr.node');
        my $an = $el-><M::Element.getAttributeNode> ('dattr1');
        $test->assert_isa ($an, <IFName::Attr>);

        $test->id ('attr.text.content');
        $test->assert_equals ($an-><AG::Node.textContent>, 'dattr1 default ');
        
        $test->id ('attr.specified');
        $test->assert_false ($an-><AG::Attr.specified>);
    @@Test:
      @@@QName: Document.createElement.defaultattr.typed.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docd = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>, '3.0');
        my $dtd = $docd-><M::d|DocumentXDoctype.createDocumentTypeDefinition>
                           ('doctype');
          my $et = $docd-><M::d|DocumentXDoctype.createElementTypeDefinition>
                             ('et1');
            my $at = $docd-><M::d|DocumentXDoctype.createAttributeDefinition>
                               ('dattr1');
            $at-><AS::ATDef.defaultType> (<C::ATDef.EXPLICIT_DEFAULT>);
            $at-><AS::Node.textContent> ('dattr1 default ');
            $at-><AS::ATDef.declaredType> (<C::ATDef.NMTOKENS_ATTR>);
          $et-><M::ETDef.setAttributeDefinitionNode> ($at);
        $dtd-><M::DTDef.setElementTypeDefinitionNode> ($et);
        $doc-><M::Node.appendChild> ($dtd);

        my $el = $doc-><M::Document.createElement> ('et1');

        $test->id ('attributes.length');
        $test->assert_num_equals
                 (actual_value => $el-><AG::Node.attributes>
                                     -><AG::NamedNodeMap.length>,
                  expected_value => 1);
        
        $test->id ('has.attribute');
        $test->assert_true ($el-><M::Element.hasAttribute> ('dattr1'));

        $test->id ('get.attr.node');
        my $an = $el-><M::Element.getAttributeNode> ('dattr1');
        $test->assert_isa ($an, <IFName::Attr>);

        $test->id ('attr.text.content');
        $test->assert_equals ($an-><AG::Node.textContent>, 'dattr1 default ');
        
        $test->id ('attr.specified');
        $test->assert_false ($an-><AG::Attr.specified>);

        $test->id ('attr.type');
        my $ti = $an-><AG::Attr.schemaTypeInfo>;
        $test->assert_equals
                 ($ti-><AG::c|TypeInfo.typeNamespace>, <Q::xml-dtd:>);
        $test->assert_equals ($ti-><AG::c|TypeInfo.typeName>, 'NMTOKENS');
    @@L3Test:
      @@@QName: Document.createElement.defaultattr.3.test
      @@@enDesc:
        The <cfg::cfg|dtd-default-attributes> configuration
        parameter is set to <DOM::false> so that no default
        attribute should be exposed by the creation.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docd = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>, '3.0');
        my $dtd = $docd-><M::d|DocumentXDoctype.createDocumentTypeDefinition>
                           ('doctype');
          my $et = $docd-><M::d|DocumentXDoctype.createElementTypeDefinition>
                             ('et1');
            my $at = $docd-><M::d|DocumentXDoctype.createAttributeDefinition>
                               ('dattr1');
            $at-><AS::ATDef.defaultType> (<C::ATDef.EXPLICIT_DEFAULT>);
            $at-><AS::Node.textContent> ('dattr1 default ');
          $et-><M::ETDef.setAttributeDefinitionNode> ($at);
        $dtd-><M::DTDef.setElementTypeDefinitionNode> ($et);
        $doc-><M::Node.appendChild> ($dtd);

        $doc-><AG::Document.domConfig>
            -><M::c|DOMConfiguration.setParameter>
                 (<Q::cfg|dtd-default-attributes> => false);

        my $el = $doc-><M::Document.createElement> ('et1');

        $test->id ('attributes.length');
        $test->assert_num_equals
                 (actual_value => $el-><AG::Node.attributes>
                                     -><AG::NamedNodeMap.length>,
                  expected_value => 0);

  @L2Method:
    @@Name: createElementNS
    @@enDesc:
      Creates an element of the given qualified name and namespace URI.
    @@NoNSVersion:.createElement
    @@XML2Feature:
    @@Param:
      @@@Name: namespaceURI
      @@@Type: DOMString
      @@@dis:actualType: ManakaiDOM|ManakaiDOMNamespaceURI
      @@@enDesc:
        The namespace URI of the element to create.
      @@@nullCase:
        @@@@enDesc:
          If the element has no namespace.
    @@Param:
      @@@Name: qualifiedName
      @@@Type: DOMString
      @@@dis:actualType:
        @@@@@: DOMMain|ManakaiDOMXMLQName
        @@@@ManakaiDOM:noInputNormalize: 1
      @@@enDesc:
        The qualified name of the element type to instantiate.
      @@@InCase:
        @@@@Type: ARRAY
        @@@@enDesc:
          A reference to the array that contains the namespace
          prefix (zeroth item) and the local name (first item)
          of the attribute.  The namespace prefix <kwd:MAY>
          be <DOM::null> to indicate that the qualified name
          contains no <CHAR::COLON> character.
    @@Return:
      @@@Type: Element
      @@@enDesc:
        {P:: A new <IF::Element> node with:

          - <A::Node.nodeName>::: <P::qualifiedName>.

          - <A::Node.namespaceURI>::: <P::namespaceURI>.

          - <A::Node.prefix>::: The namespace prefix extracted
                from <P::qualifiedName>, or <DOM::null> if there
                is no prefix.

          - <A::Node.localName>::: The local name extracted
                from <P::qualifiedName>.

          - <A::Element.tagName>::: <P::qualifiedName>.

        }
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_BAD_NAME
        @@@@enDesc:
          If the specified <P::qualifiedName> is not an XML
          <CODE::Name> according to the XML version in use 
          specified in the <A::Document.xmlVersion> attribute.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_NS_MALFORMED_QNAME
        @@@@enDesc:
          If the <P::qualifiedName> is malformed qualified
          name.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_NS_PREFIX_WITH_NULL_URI
        @@@@enDesc:
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_NS_XMLNS_WITH_OTHER_URI
        @@@@enDesc:
          If the <P::qualifiedName> has a prefix that is <XML::xmlns>
          and the <P::namespaceURI> is different from
          <URI::http://www.w3.org/2000/xmlns/>.  <SRC::DOM3>
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_NS_XMLNSQ_WITH_OTHER_URI
        @@@@enDesc:
          If the <P::qualifiedName> is <XE::xmlns> and
          the <P::namespaceURI> is different from 
          <URI::http://www.w3.org/2000/xmlns/>.  <SRC::DOM3>
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_NS_OTHER_WITH_XMLNS_URI
        @@@@enDesc:
          If the <P::namespaceURI> is <URI::http://www.w3.org/2000/xmlns/> 
          and neither the <P::qualifiedName> nor its prefix is
          <XML::xmlns>.  <SRC::DOM3>
          If the <P::qualifiedName> has a prefix and the
          <P::namespaceURI> is <DOM::null>.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_NS_XML_WITH_OTHER_URI
        @@@@enDesc:
          If the <P::qualifiedName> has a prefix that is <XML::xml>
          and the <P::namespaceURI> is different from
          <URI::http://www.w3.org/XML/1998/namespace>.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_NS_XMLNS_WITH_OTHER_URI
        @@@@enDesc:
          If the <P::qualifiedName> has a prefix that is <XML::xmlns>
          and the <P::namespaceURI> is different from
          <URI::http://www.w3.org/2000/xmlns/>.  <SRC::DOM3>
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_NS_XMLNSQ_WITH_OTHER_URI
        @@@@enDesc:
          If the <P::qualifiedName> is <XE::xmlns> and
          the <P::namespaceURI> is different from 
          <URI::http://www.w3.org/2000/xmlns/>.  <SRC::DOM3>
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_NS_OTHER_WITH_XMLNS_URI
        @@@@enDesc:
          If the <P::namespaceURI> is <URI::http://www.w3.org/2000/xmlns/>
          and neither the <P::qualifiedName> nor its prefix is
          <XML::xmlns>.  <SRC::DOM3>
      @@@iRaises:
        @@@@@: MDOMX|MDOM_DOC_NOSUPPORT_XML
        @@@@enDesc:
          If the current document does not support the <Feature::XML>
          feature.
      @@@PerlDef:
        require Message::DOM::Element;

        my ($prefix, $lname) = ref $qualifiedName eq 'ARRAY'
                                 ? @$qualifiedName
                                 : split /:/, $qualifiedName, 2;
        ($prefix, $lname) = (null, $prefix) unless defined $lname;
        $qualifiedName = defined $prefix ? $prefix.':'.$lname : $lname;

        if ($self-><AG::Document.strictErrorChecking>) {
          my $version = $self-><AG::Document.xmlVersion>;
          __CODE{DOMMain|ensureXMLQName::
            $INPUT = $qualifiedName, 
            $INPUT_PARAM_NAME = 'qualifiedName',
            $XMLVERSION = $version,
          }__;
          __CODE{DOMMain|checkXMLNamesQName::
            $PREFIX => $prefix, $NSURI => $namespaceURI,
            $LNAME => $lname,
          }__;
          if (defined $namespaceURI and $namespaceURI eq <Q::xmlns:> and
              ($qualifiedName eq 'xmlns' or
               (defined $prefix and $prefix eq 'xmlns'))) {
            __EXCEPTION{MDOMX|MDOM_NS_OTHER_WITH_XMLNS_URI::
              MDOMX|param-name => 'qualifiedName',
              infoset|prefix => {$prefix},
              infoset|localName => {$lname},
              infoset|namespaceName => {$namespaceURI},
            }__;
          }
        }

        my $bag = <Code::mg|getNodeBag||ManakaiDOM|all:: $ref = $self>;
        my $stem;
        __CODE{mg|createNodeStem||ManakaiDOM|all::
          $bag => $bag,
          $stem => $stem,
          $class => {<ClassName::te|ManakaiDOMElement>},
          $opt => {{
            <H::tc|ownerDocument> => $self,
            <H::infoset|namespaceName> => \$namespaceURI,
            <H::infoset|prefix> => \$prefix,
            <H::infoset|localName> => \$lname,
          }},
        }__;
        __CODE{mg|createNodeRef||ManakaiDOM|all::
          $bag => $bag,
          $stem => $stem,
          $ref => $r,
          $opt => {{
            <H::mg|nodeRefInterfaces> => [<IFName::Element>],
          }},
        }__;

        ## Default attributes
        __CODE{tc|exposeDefaultAttributes::
          $document => $self,
          $element => $r,
          $element_type => $qualifiedName,
        }__;

    @@Test:
      @@@QName: Doc.createElNS.mg.1.test
      @@@PerlDef:
        local $Message::Util::Grove::GCLatency = 0;

        my $impl;
        __CODE{tc|createImplForTest:: $impl => $impl}__;

        my $bag = $impl->{<H::mg|nodeBag>};
        my $id = $impl->{<H::mg|nodeIDReference>};

        my $doc = $impl-><M::c|DOMImplementation.createDocument>;

        my $el = $doc-><M::Document.createElementNS> (null, 'e');
        
        $test->id ('interface');
        $test->assert_isa ($el, <IFName::Element>);
        
        $test->id ('class');
        $test->assert_isa ($el, <ClassName::te|ManakaiDOMElement>);

        my $doc_id = $doc->{<H::mg|nodeIDReference>};
        my $el_id = $el->{<H::mg|nodeIDReference>};

        undef $impl;

        $test->id ('gc.impl.1');
        $test->assert_not_null ($bag->{$$id});

        $test->id ('gc.doc.1');
        $test->assert_not_null ($bag->{$$doc_id});

        $test->id ('gc.el.1');
        $test->assert_not_null ($bag->{$$el_id});

        undef $doc;

        $test->id ('gc.impl.2');
        $test->assert_not_null ($bag->{$$id});

        $test->id ('gc.doc.2');
        $test->assert_not_null ($bag->{$$doc_id});

        $test->id ('gc.el.2');
        $test->assert_not_null ($bag->{$$el_id});

        undef $el;

        $test->id ('gc.impl.3');
        $test->assert_null ($bag->{$$id});

        $test->id ('gc.doc.3');
        $test->assert_null ($bag->{$$doc_id});

        $test->id ('gc.el.3');
        $test->assert_null ($bag->{$$el_id});
    @@Test:
      @@@QName: Doc.createElNS.mg.2.test
      @@@PerlDef:
        local $Message::Util::Grove::GCLatency = 0;

        my $impl;
        __CODE{tc|createImplForTest:: $impl => $impl}__;

        my $bag = $impl->{<H::mg|nodeBag>};
        my $id = $impl->{<H::mg|nodeIDReference>};

        my $doc = $impl-><M::c|DOMImplementation.createDocument>;

        my $el = $doc-><M::Document.createElementNS> (null, 'e');
        
        $test->id ('interface');
        $test->assert_isa ($el, <IFName::Element>);
        
        $test->id ('class');
        $test->assert_isa ($el, <ClassName::te|ManakaiDOMElement>);

        my $doc_id = $doc->{<H::mg|nodeIDReference>};
        my $el_id = $el->{<H::mg|nodeIDReference>};

        undef $impl;

        $test->id ('gc.impl.1');
        $test->assert_not_null ($bag->{$$id});

        $test->id ('gc.doc.1');
        $test->assert_not_null ($bag->{$$doc_id});

        $test->id ('gc.el.1');
        $test->assert_not_null ($bag->{$$el_id});

        undef $el;

        $test->id ('gc.impl.2');
        $test->assert_not_null ($bag->{$$id});

        $test->id ('gc.doc.2');
        $test->assert_not_null ($bag->{$$doc_id});

        $test->id ('gc.el.2');
        $test->assert_null ($bag->{$$el_id});

        undef $doc;

        $test->id ('gc.impl.3');
        $test->assert_null ($bag->{$$id});

        $test->id ('gc.doc.3');
        $test->assert_null ($bag->{$$doc_id});

        $test->id ('gc.el.3');
        $test->assert_null ($bag->{$$el_id});
    @@Test:
      @@@QName: Doc.createElNS.mg.3.test
      @@@PerlDef:
        local $Message::Util::Grove::GCLatency = 0;

        my $impl;
        __CODE{tc|createImplForTest:: $impl => $impl}__;

        my $bag = $impl->{<H::mg|nodeBag>};
        my $id = $impl->{<H::mg|nodeIDReference>};

        my $doc = $impl-><M::c|DOMImplementation.createDocument>;

        my $el = $doc-><M::Document.createElementNS> (null, 'e');
        
        $test->id ('interface');
        $test->assert_isa ($el, <IFName::Element>);
        
        $test->id ('class');
        $test->assert_isa ($el, <ClassName::te|ManakaiDOMElement>);

        my $doc_id = $doc->{<H::mg|nodeIDReference>};
        my $el_id = $el->{<H::mg|nodeIDReference>};

        undef $doc;

        $test->id ('gc.impl.1');
        $test->assert_not_null ($bag->{$$id});

        $test->id ('gc.doc.1');
        $test->assert_not_null ($bag->{$$doc_id});

        $test->id ('gc.el.1');
        $test->assert_not_null ($bag->{$$el_id});

        undef $impl;

        $test->id ('gc.impl.2');
        $test->assert_not_null ($bag->{$$id});

        $test->id ('gc.doc.2');
        $test->assert_not_null ($bag->{$$doc_id});

        $test->id ('gc.el.2');
        $test->assert_not_null ($bag->{$$el_id});

        undef $el;

        $test->id ('gc.impl.3');
        $test->assert_null ($bag->{$$id});

        $test->id ('gc.doc.3');
        $test->assert_null ($bag->{$$doc_id});

        $test->id ('gc.el.3');
        $test->assert_null ($bag->{$$el_id});
    @@Test:
      @@@QName: Doc.createElNS.mg.4.test
      @@@PerlDef:
        local $Message::Util::Grove::GCLatency = 0;

        my $impl;
        __CODE{tc|createImplForTest:: $impl => $impl}__;

        my $bag = $impl->{<H::mg|nodeBag>};
        my $id = $impl->{<H::mg|nodeIDReference>};

        my $doc = $impl-><M::c|DOMImplementation.createDocument>;

        my $el = $doc-><M::Document.createElementNS> (null, 'e');
        
        $test->id ('interface');
        $test->assert_isa ($el, <IFName::Element>);
        
        $test->id ('class');
        $test->assert_isa ($el, <ClassName::te|ManakaiDOMElement>);

        my $doc_id = $doc->{<H::mg|nodeIDReference>};
        my $el_id = $el->{<H::mg|nodeIDReference>};

        undef $doc;

        $test->id ('gc.impl.1');
        $test->assert_not_null ($bag->{$$id});

        $test->id ('gc.doc.1');
        $test->assert_not_null ($bag->{$$doc_id});

        $test->id ('gc.el.1');
        $test->assert_not_null ($bag->{$$el_id});

        undef $el;

        $test->id ('gc.impl.2');
        $test->assert_not_null ($bag->{$$id});

        $test->id ('gc.doc.2');
        $test->assert_null ($bag->{$$doc_id});

        $test->id ('gc.el.2');
        $test->assert_null ($bag->{$$el_id});

        undef $impl;

        $test->id ('gc.impl.3');
        $test->assert_null ($bag->{$$id});

        $test->id ('gc.doc.3');
        $test->assert_null ($bag->{$$doc_id});

        $test->id ('gc.el.3');
        $test->assert_null ($bag->{$$el_id});
    @@Test:
      @@@QName: Doc.createElNS.mg.5.test
      @@@PerlDef:
        local $Message::Util::Grove::GCLatency = 0;

        my $impl;
        __CODE{tc|createImplForTest:: $impl => $impl}__;

        my $bag = $impl->{<H::mg|nodeBag>};
        my $id = $impl->{<H::mg|nodeIDReference>};

        my $doc = $impl-><M::c|DOMImplementation.createDocument>;

        my $el = $doc-><M::Document.createElementNS> (null, 'e');
        
        $test->id ('interface');
        $test->assert_isa ($el, <IFName::Element>);
        
        $test->id ('class');
        $test->assert_isa ($el, <ClassName::te|ManakaiDOMElement>);

        my $doc_id = $doc->{<H::mg|nodeIDReference>};
        my $el_id = $el->{<H::mg|nodeIDReference>};

        undef $el;

        $test->id ('gc.impl.1');
        $test->assert_not_null ($bag->{$$id});

        $test->id ('gc.doc.1');
        $test->assert_not_null ($bag->{$$doc_id});

        $test->id ('gc.el.1');
        $test->assert_null ($bag->{$$el_id});

        undef $impl;

        $test->id ('gc.impl.2');
        $test->assert_not_null ($bag->{$$id});

        $test->id ('gc.doc.2');
        $test->assert_not_null ($bag->{$$doc_id});

        $test->id ('gc.el.2');
        $test->assert_null ($bag->{$$el_id});

        undef $doc;

        $test->id ('gc.impl.3');
        $test->assert_null ($bag->{$$id});

        $test->id ('gc.doc.3');
        $test->assert_null ($bag->{$$doc_id});

        $test->id ('gc.el.3');
        $test->assert_null ($bag->{$$el_id});
    @@Test:
      @@@QName: Doc.createElNS.mg.6.test
      @@@PerlDef:
        local $Message::Util::Grove::GCLatency = 0;

        my $impl;
        __CODE{tc|createImplForTest:: $impl => $impl}__;

        my $bag = $impl->{<H::mg|nodeBag>};
        my $id = $impl->{<H::mg|nodeIDReference>};

        my $doc = $impl-><M::c|DOMImplementation.createDocument>;

        my $el = $doc-><M::Document.createElementNS> (null, 'e');
        
        $test->id ('interface');
        $test->assert_isa ($el, <IFName::Element>);
        
        $test->id ('class');
        $test->assert_isa ($el, <ClassName::te|ManakaiDOMElement>);

        my $doc_id = $doc->{<H::mg|nodeIDReference>};
        my $el_id = $el->{<H::mg|nodeIDReference>};

        undef $el;

        $test->id ('gc.impl.1');
        $test->assert_not_null ($bag->{$$id});

        $test->id ('gc.doc.1');
        $test->assert_not_null ($bag->{$$doc_id});

        $test->id ('gc.el.1');
        $test->assert_null ($bag->{$$el_id});

        undef $doc;

        $test->id ('gc.impl.2');
        $test->assert_not_null ($bag->{$$id});

        $test->id ('gc.doc.2');
        $test->assert_null ($bag->{$$doc_id});

        $test->id ('gc.el.2');
        $test->assert_null ($bag->{$$el_id});

        undef $impl;

        $test->id ('gc.impl.3');
        $test->assert_null ($bag->{$$id});

        $test->id ('gc.doc.3');
        $test->assert_null ($bag->{$$doc_id});

        $test->id ('gc.el.3');
        $test->assert_null ($bag->{$$el_id});
    @@Test:
      @@@QName: Document.createElementNS.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createElementNS> (null, 'el');

        $test->id ('interface');
        $test->assert_isa ($el, <IFName::Element>);

        $test->id ('nodeName');
        $test->assert_equals ($el-><AG::Node.nodeName>, 'el');

        $test->id ('localName');
        $test->assert_equals ($el-><AG::Node.localName>, 'el');

        $test->id ('namespaceURI');
        $test->assert_null ($el-><AG::Node.namespaceURI>);

        $test->id ('prefix');
        $test->assert_null ($el-><AG::Node.prefix>);
    @@Test:
      @@@QName: Document.createElementNS.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createElementNS> ('about:', 'a:el');

        $test->id ('interface');
        $test->assert_isa ($el, <IFName::Element>);

        $test->id ('nodeName');
        $test->assert_equals ($el-><AG::Node.nodeName>, 'a:el');

        $test->id ('localName');
        $test->assert_equals ($el-><AG::Node.localName>, 'el');

        $test->id ('namespaceURI');
        $test->assert_equals ($el-><AG::Node.namespaceURI>, 'about:');

        $test->id ('prefix');
        $test->assert_equals ($el-><AG::Node.prefix>, 'a');
    @@Test:
      @@@QName: Document.createElementNS.3.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createElementNS> ('about:', ['a', 'el']);

        $test->id ('interface');
        $test->assert_isa ($el, <IFName::Element>);

        $test->id ('nodeName');
        $test->assert_equals ($el-><AG::Node.nodeName>, 'a:el');

        $test->id ('localName');
        $test->assert_equals ($el-><AG::Node.localName>, 'el');

        $test->id ('namespaceURI');
        $test->assert_equals ($el-><AG::Node.namespaceURI>, 'about:');

        $test->id ('prefix');
        $test->assert_equals ($el-><AG::Node.prefix>, 'a');
    @@Test:
      @@@QName: Document.createElementNS.nodefaultattr.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createElementNS> (null, 'et1');

        $test->assert_num_equals
                 (actual_value => $el-><AG::Node.attributes>
                                     -><AG::NamedNodeMap.length>,
                  expected_value => 0);
    @@Test:
      @@@QName: Document.createElementNS.defaultattr.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docd = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>, '3.0');
        my $dtd = $docd-><M::d|DocumentXDoctype.createDocumentTypeDefinition>
                           ('doctype');
          my $et = $docd-><M::d|DocumentXDoctype.createElementTypeDefinition>
                             ('et1');
            my $at = $docd-><M::d|DocumentXDoctype.createAttributeDefinition>
                               ('dattr1');
            $at-><AS::ATDef.defaultType> (<C::ATDef.EXPLICIT_DEFAULT>);
            $at-><AS::Node.textContent> ('dattr1 default ');
          $et-><M::ETDef.setAttributeDefinitionNode> ($at);
        $dtd-><M::DTDef.setElementTypeDefinitionNode> ($et);
        $doc-><M::Node.appendChild> ($dtd);

        my $el = $doc-><M::Document.createElementNS> (null, 'et1');

        $test->id ('attributes.length');
        $test->assert_num_equals
                 (actual_value => $el-><AG::Node.attributes>
                                     -><AG::NamedNodeMap.length>,
                  expected_value => 1);
        
        $test->id ('has.attribute');
        $test->assert_true ($el-><M::Element.hasAttribute> ('dattr1'));

        $test->id ('get.attr.node');
        my $an = $el-><M::Element.getAttributeNode> ('dattr1');
        $test->assert_isa ($an, <IFName::Attr>);

        $test->id ('attr.text.content');
        $test->assert_equals ($an-><AG::Node.textContent>, 'dattr1 default ');
        
        $test->id ('attr.specified');
        $test->assert_false ($an-><AG::Attr.specified>);
    @@Test:
      @@@QName: Document.createElementNS.defaultattr.typed.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docd = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>, '3.0');
        my $dtd = $docd-><M::d|DocumentXDoctype.createDocumentTypeDefinition>
                           ('doctype');
          my $et = $docd-><M::d|DocumentXDoctype.createElementTypeDefinition>
                             ('et1');
            my $at = $docd-><M::d|DocumentXDoctype.createAttributeDefinition>
                               ('dattr1');
            $at-><AS::ATDef.defaultType> (<C::ATDef.EXPLICIT_DEFAULT>);
            $at-><AS::Node.textContent> ('dattr1 default ');
            $at-><AS::ATDef.declaredType> (<C::ATDef.NMTOKENS_ATTR>);
          $et-><M::ETDef.setAttributeDefinitionNode> ($at);
        $dtd-><M::DTDef.setElementTypeDefinitionNode> ($et);
        $doc-><M::Node.appendChild> ($dtd);

        my $el = $doc-><M::Document.createElementNS> (null, 'et1');

        $test->id ('attributes.length');
        $test->assert_num_equals
                 (actual_value => $el-><AG::Node.attributes>
                                     -><AG::NamedNodeMap.length>,
                  expected_value => 1);
        
        $test->id ('has.attribute');
        $test->assert_true ($el-><M::Element.hasAttribute> ('dattr1'));

        $test->id ('get.attr.node');
        my $an = $el-><M::Element.getAttributeNode> ('dattr1');
        $test->assert_isa ($an, <IFName::Attr>);

        $test->id ('attr.text.content');
        $test->assert_equals ($an-><AG::Node.textContent>, 'dattr1 default ');
        
        $test->id ('attr.specified');
        $test->assert_false ($an-><AG::Attr.specified>);

        $test->id ('attr.type');
        my $ti = $an-><AG::Attr.schemaTypeInfo>;
        $test->assert_equals
                 ($ti-><AG::c|TypeInfo.typeNamespace>, <Q::xml-dtd:>);
        $test->assert_equals ($ti-><AG::c|TypeInfo.typeName>, 'NMTOKENS');
    @@Test:
      @@@QName: Document.createElementNS.defaultattr.3.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docd = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>, '3.0');
        my $dtd = $docd-><M::d|DocumentXDoctype.createDocumentTypeDefinition>
                           ('doctype');
          my $et = $docd-><M::d|DocumentXDoctype.createElementTypeDefinition>
                             ('et1');
            my $at = $docd-><M::d|DocumentXDoctype.createAttributeDefinition>
                               ('dattr1');
            $at-><AS::ATDef.defaultType> (<C::ATDef.EXPLICIT_DEFAULT>);
            $at-><AS::Node.textContent> ('dattr1 default ');
          $et-><M::ETDef.setAttributeDefinitionNode> ($at);
        $dtd-><M::DTDef.setElementTypeDefinitionNode> ($et);
        $doc-><M::Node.appendChild> ($dtd);

        $doc-><AG::Document.domConfig>
            -><M::c|DOMConfiguration.setParameter>
                 (<Q::cfg|dtd-default-attributes> => false);

        my $el = $doc-><M::Document.createElementNS> (null, 'et1');

        $test->id ('attributes.length');
        $test->assert_num_equals
                 (actual_value => $el-><AG::Node.attributes>
                                     -><AG::NamedNodeMap.length>,
                  expected_value => 0);

  @CODE:
    @@QName: tc|exposeDefaultAttributes
    @@PerlDef:
      __DEEP{
        my $__doctype = $document-><AG::Document.doctype>;
        my $__cfg = $document-><AG::Document.domConfig>;
        undef $__doctype unless $__cfg-><M::c|DOMConfiguration.getParameter>
                                          (<Q::cfg|dtd-default-attributes>);
        $__doctype = $__doctype-><M::Node.getFeature>
                                   (<Q::fe|XDoctype> => '3.0')
          if $__doctype;
        if ($__doctype) {
          my $__et = $__doctype-><M::DTDef.getElementTypeDefinitionNode>
                                   ($element_type);
          if ($__et) {
            my $__orig_strict = $document-><AG::Document.strictErrorChecking>;
            $document-><AS::Document.strictErrorChecking> (false);
            my %__gattr;
            my %__has_attr;
            my %__pfx_to_uri;
            my $__copy_asis = $__cfg-><M::c|DOMConfiguration.getParameter>
                                     (<Q::cfg|clone-entity-reference-subtree>);
            $__cfg-><M::c|DOMConfiguration.setParameter>
                          (<Q::cfg|clone-entity-reference-subtree> => true);
            for my $__at (@{$__et-><AG::ETDef.attributeDefinitions>}) {
              my $__at_default = $__at-><AG::ATDef.defaultType>;
              if ($__at_default == <C::ATDef.EXPLICIT_DEFAULT> or
                  $__at_default == <C::ATDef.FIXED_DEFAULT>) {
                my ($__nn1, $__nn2) = split /:/, $__at-><AG::Node.nodeName>;
                if (defined $__nn2) { # prefixed
                  if ($__nn1 eq 'xmlns') {
                    ## TODO: NCName check, prefix check and NSURI check
                    my $__attr = $document-><M::Document.createAttributeNS>
                                              (<Q::xmlns:>, [$__nn1, $__nn2]);
                    for my $__at_child (@{$__at-><AG::Node.childNodes>}) {
                      $__attr-><M::Node.appendChild>
                                 ($__at_child-><M::Node.cloneNode> (true));
                    }
                    $__attr-><AS::Attr.manakaiAttributeType>
                               ($__at-><AG::ATDef.declaredType>);
                    my $__nsuri = $__attr-><AG::Attr.value>;
                    ## TODO: Namespace well-formedness check (NSURI), v1.1 chk
                    $__pfx_to_uri{$__nn2} = $__nsuri;
                    $element-><M::Element.setAttributeNodeNS> ($__attr);
                             ## This method changes |specified| flag
                    $__attr-><AS::Attr.specified> (false);
                    $__has_attr{<Q::xmlns:>}->{$__nn2} = true;
                  } else {
                    ## TODO: NCName check
                    $__gattr{$__nn1}->{$__nn2} = $__at;
                  }
                } else {            # no prefixed
                  my $__attr;
                  if ($__nn1 eq 'xmlns') {
                    $__attr = $document-><M::Document.createAttributeNS>
                                              (<Q::xmlns:>, 'xmlns');
                    $__has_attr{<Q::xmlns:>}->{xmlns} = true;
                  } else {
                    $__attr = $document-><M::Document.createAttributeNS>
                                              (null, $__nn1);
                    ## TODO: NCName check
                  }
                  for my $__at_child (@{$__at-><AG::Node.childNodes>}) {
                    $__attr-><M::Node.appendChild>
                               ($__at_child-><M::Node.cloneNode> (true));
                  }
                  $__attr-><AS::Attr.manakaiAttributeType>
                             ($__at-><AG::ATDef.declaredType>);
                  ## TODO: Namespace well-formedness check (NSURI)
                  $element-><M::Element.setAttributeNodeNS> ($__attr);
                             ## This method changes |specified| flag
                  $__attr-><AS::Attr.specified> (false);
                }
              }
            } # attrdefs
            for my $__pfx (keys %__gattr) {
              my $__nsuri = $__pfx_to_uri{$__pfx};
              unless (defined $__nsuri) {
                ## TODO: Namespace well-formedness error
              }
              LN: for my $__ln (keys %{$__gattr{$__pfx}}) {
                if ($__has_attr{defined $__nsuri ? $__nsuri : ''}->{$__ln}) {
                  ## TODO: Namespace well-formedness error
                  next LN;
                }
                ## TODO: NCName check, prefix check and NSURI check
                my $__at = $__gattr{$__pfx}->{$__ln};
                my $__attr = $document-><M::Document.createAttributeNS>
                                          ($__nsuri, [$__pfx, $__ln]);
                for my $__at_child (@{$__at-><AG::Node.childNodes>}) {
                  $__attr-><M::Node.appendChild>
                             ($__at_child-><M::Node.cloneNode> (true));
                }
                $__attr-><AS::Attr.manakaiAttributeType>
                           ($__at-><AG::ATDef.declaredType>);
                $element-><M::Element.setAttributeNodeNS> ($__attr);
                             ## This method changes |specified| flag
                $__attr-><AS::Attr.specified> (false);
                $__has_attr{defined $__nsuri ? $__nsuri : ''}->{$__ln} = true;
              } # LN
            } # pfx
            $__cfg-><M::c|DOMConfiguration.setParameter>
                    (<Q::cfg|clone-entity-reference-subtree> => $__copy_asis);
            $document-><AS::Document.strictErrorChecking> ($__orig_strict);
          }
        }
      }__;
    @@enImplNote:
      @@@ddid: webbrowsers
      @@@@:
        Firefox 1.5 and Opera 9 Preview 1 do not add default attributes
        by <M::Document.createElement> and <M::Document.createElementNS>.
        Opera does not support default attribute addition at 
        parsing time in internal subset neither.
        Firefox <EM::does> support it but <A::Attr.specified> of the default
        attributes are set to <DOM::true>.

  @Method:
    @@Name: createAttribute
    @@enDesc:
      Creates an <IF::Attr> of the given name.
    @@NSVersion: .createAttributeNS
    @@Param:
      @@@Name: name
      @@@Type: DOMString
      @@@enDesc:
        The name of the attribute.
      @@@enImplNote:
        {ISSUE::
           Case in HTML documents??
        }
    @@Return:
      @@@Type: Attr
      @@@enDesc:
        {P:: A new <IF::Attr> object with:

          - <A::Node.nodeName>::: <P::name>.

          - <A::Node.localName>::: <DOM::null>.  <SRC::DOM2, DOM3>
              However, in manakai, as well as Web browsers, 
              it is set to <P::name> even if it is not an <CODE::NCName>.

          - <A::Node.prefix>::: <DOM::null>.

          - <A::Node.namespaceURI>::: <DOM::null>.

          - <A::Attr.value>::: The empty string.

          - <A::Attr.specified>::: <DOM::true>.  <SRC::DOM1, DOM2>
                Note that it is set to <DOM::false> in Gecko.

        }
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_BAD_NAME
        @@@@enDesc:
          If the specified name is not an <CODE::XML> name
          according to the XML version in use specified in
          the <A::Document.xmlVersion> attribute.
      @@@PerlDef:
        my $strict = $self-><AG::Document.strictErrorChecking>;
        if ($strict) {
          my $version = $self-><AG::Document.xmlVersion>;
          __CODE{DOMMain|ensureXMLName::
            $INPUT => $name, $INPUT_PARAM_NAME => 'name',
            $XMLVERSION => $version,
          }__;
        }
        __DEEP{
          $self-><AS::Document.strictErrorChecking> (false);
          $r = $self-><M::Document.createAttributeNS> (null, [null, $name]);
          $self-><AS::Document.strictErrorChecking> ($strict);
        }__;
      @@@enImplNote:
        @@@@ddid: schema
        @@@@For: ManakaiDOM|ManakaiDOM
        @@@@@:
          The created node does not have DTD type information,
          since its element type is not known.

    @@Test:
      @@@QName: Document.createAttribute.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $attr = $doc-><M::Document.createAttribute> ('attrName');

        $test->id ('interface');
        $test->assert_isa ($attr, <IFName::Attr>);

        $test->id ('nodeName');
        $test->assert_equals ($attr-><AG::Node.nodeName>, 'attrName');

        $test->id ('localName');
        $test->assert_equals ($attr-><AG::Node.localName>, 'attrName');

        $test->id ('prefix');
        $test->assert_null ($attr-><AG::Node.prefix>);

        $test->id ('namespaceURI');
        $test->assert_null ($attr-><AG::Node.namespaceURI>);

        $test->id ('specified');
        $test->assert_true ($attr-><AG::Attr.specified>);

        $test->id ('value');
        $test->assert_equals ($attr-><AG::Attr.value>, '');

        $test->id ('childNodes.length');
        $test->assert_num_equals
                 (expected_value => 0+@{$attr-><AG::Node.childNodes>},
                  actual_value => 0);
    @@Test:
      @@@QName: Document.createAttribute.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $attr = $doc-><M::Document.createAttribute> ('attr:name');

        $test->id ('interface');
        $test->assert_isa ($attr, <IFName::Attr>);

        $test->id ('nodeName');
        $test->assert_equals ($attr-><AG::Node.nodeName>, 'attr:name');

        $test->id ('localName');
        $test->assert_equals ($attr-><AG::Node.localName>, 'attr:name');

        $test->id ('prefix');
        $test->assert_null ($attr-><AG::Node.prefix>);

        $test->id ('namespaceURI');
        $test->assert_null ($attr-><AG::Node.namespaceURI>);
    @@Test:
      @@@QName: Document.createAttribute.3.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $attr = $doc-><M::Document.createAttribute> ('xml:lang');

        $test->id ('interface');
        $test->assert_isa ($attr, <IFName::Attr>);

        $test->id ('nodeName');
        $test->assert_equals ($attr-><AG::Node.nodeName>, 'xml:lang');

        $test->id ('localName');
        $test->assert_equals ($attr-><AG::Node.localName>, 'xml:lang');

        $test->id ('prefix');
        $test->assert_null ($attr-><AG::Node.prefix>);

        $test->id ('namespaceURI');
        $test->assert_null ($attr-><AG::Node.namespaceURI>);
    @@Test:
      @@@QName: Document.createAttribute.4.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $attr = $doc-><M::Document.createAttribute> ('xmlns');

        $test->id ('interface');
        $test->assert_isa ($attr, <IFName::Attr>);

        $test->id ('nodeName');
        $test->assert_equals ($attr-><AG::Node.nodeName>, 'xmlns');

        $test->id ('localName');
        $test->assert_equals ($attr-><AG::Node.localName>, 'xmlns');

        $test->id ('prefix');
        $test->assert_null ($attr-><AG::Node.prefix>);

        $test->id ('namespaceURI');
        $test->assert_null ($attr-><AG::Node.namespaceURI>);
    @@L3Test:
      @@@QName: Doc.createAttr.xmlid.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $cfg = $doc-><AG::Document.domConfig>;
        $doc-><AS::Document.strictErrorChecking> (false);

        $test->id ('id.xmlid');
        $cfg-><M::c|DOMConfiguration.setParameter> (<Q::cfg|xml-id> => true);
        my $at1 = $doc-><M::Document.createAttribute> ('xml:id');
        $test->assert_equals
                 ($at1-><AG::Attr.schemaTypeInfo>-><AG::c|TypeInfo.typeName>,
                  'ID');
        $test->assert_equals
                 ($at1-><AG::Attr.schemaTypeInfo>
                      -><AG::c|TypeInfo.typeNamespace>,
                  <Q::xml-dtd:>);

        $test->id ('id.other');
        my $at2 = $doc-><M::Document.createAttribute> ('id');
        $test->assert_null
                 ($at2-><AG::Attr.schemaTypeInfo>-><AG::c|TypeInfo.typeName>);
        $test->assert_null
                 ($at2-><AG::Attr.schemaTypeInfo>
                      -><AG::c|TypeInfo.typeNamespace>);

        $test->id ('noid.xmlid');
        $cfg-><M::c|DOMConfiguration.setParameter> (<Q::cfg|xml-id> => false);
        my $at3 = $doc-><M::Document.createAttribute> ('xml:id');
        $test->assert_null
                 ($at3-><AG::Attr.schemaTypeInfo>-><AG::c|TypeInfo.typeName>);
        $test->assert_null
                 ($at3-><AG::Attr.schemaTypeInfo>
                      -><AG::c|TypeInfo.typeNamespace>);

        $test->id ('noid.other');
        my $at4 = $doc-><M::Document.createAttribute> ('id');
        $test->assert_null
                 ($at4-><AG::Attr.schemaTypeInfo>-><AG::c|TypeInfo.typeName>);
        $test->assert_null
                 ($at4-><AG::Attr.schemaTypeInfo>
                      -><AG::c|TypeInfo.typeNamespace>);

  @L2Method:
    @@Name: createAttributeNS
    @@enDesc:
      Creates an attribute of the given qualified name and namespace URI.
    @@NoNSVersion: .createAttribute
    @@XML2Feature:
    @@Param:
      @@@Name: namespaceURI
      @@@Type: DOMString
      @@@dis:actualType: ManakaiDOM|ManakaiDOMNamespaceURI
      @@@enDesc:
        The namespace URI of the attribute to create.

        If the attribute has no namespace.
    @@Param:
      @@@Name: qualifiedName
      @@@Type: DOMString
      @@@dis:actualType:
        @@@@@: DOMMain|ManakaiDOMXMLQName
        @@@@ManakaiDOM:noInputNormalize: 1
      @@@enDesc:
        The qualified name of the attribute to create.
      @@@InCase:
        @@@@Type: ARRAY
        @@@@enDesc:
          A reference to the array that contains the namespace
          prefix (zeroth item) and the local name (first item)
          of the attribute.  The namespace prefix <kwd:MAY>
          be <DOM::null> to indicate that the qualified name
          contains no <CHAR::COLON> character.
    @@Return:
      @@@Type: Attr
      @@@enDesc:
        {P:: A new <IF::Attr> object with:

          - <A::Node.nodeName>::: <P::qualifiedName>.

          - <A::Node.namespaceURI>::: <P::namespaceURI>.

          - <A::Node.prefix>::: The prefix extracted from <P::qualifiedName>,
                                if any, or <DOM::null> otherwise.

          - <A::Node.localName>::: The local name extracted from
                                   <P::qualifiedName>.

          - <A::Attr.name>::: <P::qualifiedName>.

          - <A::Node.nodeValue>::: The empty string.

          - <A::Attr.specified>::: <DOM::true>.  <SRC::DOM2>
      
        }
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_BAD_NAME
        @@@@enDesc:
          If the <P::qualifiedName> is not an XML <CODE::Name>
          according to the XML version in use specified in
          the <A::Document.xmlVersion> attribute.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_NS_MALFORMED_QNAME
        @@@@enDesc:
          If the <P::qualifiedName> is a malformed qualified name.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_NS_PREFIX_WITH_NULL_URI
        @@@@enDesc:
          If the <P::qualifiedName> has a prefix and the 
          <P::namespaceURI> is <DOM::null>.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_NS_XML_WITH_OTHER_URI
        @@@@enDesc:
          If the <P::qualifiedName> has a prefix that is <XML::xml>
          and the <P::namespaceURI> is different from
          <URI::http://www.w3.org/XML/1998/namespace>.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_NS_XMLNS_WITH_OTHER_URI
        @@@@enDesc:
          If the <P::qualifiedName> has a prefix that is <P::xmlns>
          and the <P::namespaceURI> is different from
          <URI::http://www.w3.org/20900/xmlns/>.  <SRC::DOM3>
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_NS_XMLNSQ_WITH_OTHER_URI
        @@@@enDesc:
          If the <P::qualifiedName> is <XA::xmlns> and the
          <P::namespaceURI> is different from 
          <URI::http://www.w3.org/2000/xmlns/>.
      @@@iRaises:
        @@@@@: MDOMX|MDOM_DOC_NOSUPPORT_XML
        @@@@enDesc:
          If the current document does not support the <Feature::XML>
          feature.
      @@@PerlDef:
        require Message::DOM::Element;

        my ($prefix, $lname) = ref $qualifiedName eq 'ARRAY'
                                 ? @$qualifiedName
                                 : split /:/, $qualifiedName, 2;
        ($prefix, $lname) = (null, $prefix) unless defined $lname;

        ## TODO: autoload
        if ((defined $namespaceURI and $namespaceURI eq <Q::xml:>) or
            ($lname =~ /^xml:/)) {
          require Message::DOM::XML;
        }

        if ($self-><AG::Document.strictErrorChecking>) {
          my $version = $self-><AG::Document.xmlVersion>;
          $qualifiedName = defined $prefix ? $prefix.':'.$lname
                                           : $lname;
          __CODE{DOMMain|ensureXMLQName::
            $INPUT = $qualifiedName, 
            $INPUT_PARAM_NAME = 'qualifiedName',
            $XMLVERSION = $version,
          }__;
          __CODE{DOMMain|checkXMLNamesQName::
            $PREFIX => $prefix, $NSURI => $namespaceURI,
            $LNAME => $lname,
          }__;
        }

        my $bag = <Code::mg|getNodeBag||ManakaiDOM|all:: $ref = $self>;
        my $stem;
        __CODE{mg|createNodeStem||ManakaiDOM|all::
          $bag => $bag,
          $stem => $stem,
          $class => {<ClassName::te|ManakaiDOMAttr>},
          $opt => {{
            <H::tc|ownerDocument> => $self,
            <H::infoset|namespaceName> => \$namespaceURI,
            <H::infoset|prefix> => \$prefix,
            <H::infoset|localName> => \$lname,
            <H::infoset|specified> => true,
          }},
        }__;
        __CODE{mg|createNodeRef||ManakaiDOM|all::
          $bag => $bag,
          $stem => $stem,
          $ref => $r,
          $opt => {{
            <H::mg|nodeRefInterfaces> => [<IFName::Attr>],
          }},
        }__;

        ## Attribute type information
        if ((defined $namespaceURI and $namespaceURI eq <Q::xml:> and
             $lname eq 'id') or
            (not defined $namespaceURI and $lname eq 'xml:id')) {
          __DEEP{
            if ($self-><AG::Document.domConfig>
                     -><M::c|DOMConfiguration.getParameter>
                         (<Q::cfg|xml-id>)) {
              $r-><AS::Attr.manakaiAttributeType> (<C::ATDef.ID_ATTR>);
            }
          }__;
        }

    @@Test:
      @@@QName: Doc.createAttrNS.mg.1.test
      @@@PerlDef:
        local $Message::Util::Grove::GCLatency = 0;

        my $impl;
        __CODE{tc|createImplForTest:: $impl => $impl}__;

        my $bag = $impl->{<H::mg|nodeBag>};
        my $id = $impl->{<H::mg|nodeIDReference>};

        my $doc = $impl-><M::c|DOMImplementation.createDocument>;

        my $el = $doc-><M::Document.createAttributeNS> (null, 'e');
        
        $test->id ('interface');
        $test->assert_isa ($el, <IFName::Attr>);
        
        $test->id ('class');
        $test->assert_isa ($el, <ClassName::te|ManakaiDOMAttr>);

        my $doc_id = $doc->{<H::mg|nodeIDReference>};
        my $el_id = $el->{<H::mg|nodeIDReference>};

        undef $impl;

        $test->id ('gc.impl.1');
        $test->assert_not_null ($bag->{$$id});

        $test->id ('gc.doc.1');
        $test->assert_not_null ($bag->{$$doc_id});

        $test->id ('gc.el.1');
        $test->assert_not_null ($bag->{$$el_id});

        undef $doc;

        $test->id ('gc.impl.2');
        $test->assert_not_null ($bag->{$$id});

        $test->id ('gc.doc.2');
        $test->assert_not_null ($bag->{$$doc_id});

        $test->id ('gc.el.2');
        $test->assert_not_null ($bag->{$$el_id});

        undef $el;

        $test->id ('gc.impl.3');
        $test->assert_null ($bag->{$$id});

        $test->id ('gc.doc.3');
        $test->assert_null ($bag->{$$doc_id});

        $test->id ('gc.el.3');
        $test->assert_null ($bag->{$$el_id});
    @@Test:
      @@@QName: Document.createAttributeNS.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $attr = $doc-><M::Document.createAttributeNS> (null, 'a1');

        $test->id ('interface');
        $test->assert_isa ($attr, <IFName::Attr>);

        $test->id ('nodeName');
        $test->assert_equals ($attr-><AG::Node.nodeName>, 'a1');

        $test->id ('localName');
        $test->assert_equals ($attr-><AG::Node.localName>, 'a1');

        $test->id ('namespaceURI');
        $test->assert_null ($attr-><AG::Node.namespaceURI>);

        $test->id ('prefix');
        $test->assert_null ($attr-><AG::Node.prefix>);

        $test->id ('value');
        $test->assert_equals ($attr-><AG::Attr.value>, '');

        $test->id ('specified');
        $test->assert_true ($attr-><AG::Attr.specified>);

        $test->id ('ownerElement');
        $test->assert_null ($attr-><AG::Attr.ownerElement>);
    @@Test:
      @@@QName: Document.createAttributeNS.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $attr = $doc-><M::Document.createAttributeNS> ('about:', 'a:a1');

        $test->id ('interface');
        $test->assert_isa ($attr, <IFName::Attr>);

        $test->id ('nodeName');
        $test->assert_equals ($attr-><AG::Node.nodeName>, 'a:a1');

        $test->id ('localName');
        $test->assert_equals ($attr-><AG::Node.localName>, 'a1');

        $test->id ('namespaceURI');
        $test->assert_equals ($attr-><AG::Node.namespaceURI>, 'about:');

        $test->id ('prefix');
        $test->assert_equals ($attr-><AG::Node.prefix>, 'a');
    @@Test:
      @@@QName: Document.createAttributeNS.3.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $attr = $doc-><M::Document.createAttributeNS>
                           (<Q::xml:>, 'xml:lang');

        $test->id ('interface');
        $test->assert_isa ($attr, <IFName::Attr>);

        $test->id ('nodeName');
        $test->assert_equals ($attr-><AG::Node.nodeName>, 'xml:lang');

        $test->id ('localName');
        $test->assert_equals ($attr-><AG::Node.localName>, 'lang');

        $test->id ('namespaceURI');
        $test->assert_equals ($attr-><AG::Node.namespaceURI>, <Q::xml:>);

        $test->id ('prefix');
        $test->assert_equals ($attr-><AG::Node.prefix>, 'xml');
    @@Test:
      @@@QName: Document.createAttributeNS.4.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $attr = $doc-><M::Document.createAttributeNS>
                           (<Q::xmlns:>, 'xmlns');

        $test->id ('interface');
        $test->assert_isa ($attr, <IFName::Attr>);

        $test->id ('nodeName');
        $test->assert_equals ($attr-><AG::Node.nodeName>, 'xmlns');

        $test->id ('localName');
        $test->assert_equals ($attr-><AG::Node.localName>, 'xmlns');

        $test->id ('namespaceURI');
        $test->assert_equals ($attr-><AG::Node.namespaceURI>, <Q::xmlns:>);

        $test->id ('prefix');
        $test->assert_null ($attr-><AG::Node.prefix>);
    @@Test:
      @@@QName: Document.createAttributeNS.5.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $attr = $doc-><M::Document.createAttributeNS>
                           (<Q::xml:>, ['xml', 'lang']);

        $test->id ('interface');
        $test->assert_isa ($attr, <IFName::Attr>);

        $test->id ('nodeName');
        $test->assert_equals ($attr-><AG::Node.nodeName>, 'xml:lang');

        $test->id ('localName');
        $test->assert_equals ($attr-><AG::Node.localName>, 'lang');

        $test->id ('namespaceURI');
        $test->assert_equals ($attr-><AG::Node.namespaceURI>, <Q::xml:>);

        $test->id ('prefix');
        $test->assert_equals ($attr-><AG::Node.prefix>, 'xml');
    @@L3Test:
      @@@QName: Doc.createAttrNS.xmlid.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $cfg = $doc-><AG::Document.domConfig>;
        $doc-><AS::Document.strictErrorChecking> (false);

        $test->id ('id.xmlid');
        $cfg-><M::c|DOMConfiguration.setParameter> (<Q::cfg|xml-id> => true);
        my $at1 = $doc-><M::Document.createAttributeNS> (<Q::xml:>, 'xml:id');
        $test->assert_equals
                 ($at1-><AG::Attr.schemaTypeInfo>-><AG::c|TypeInfo.typeName>,
                  'ID');
        $test->assert_equals
                 ($at1-><AG::Attr.schemaTypeInfo>
                      -><AG::c|TypeInfo.typeNamespace>,
                  <Q::xml-dtd:>);

        $test->id ('id.other');
        my $at2 = $doc-><M::Document.createAttributeNS> (null, 'id');
        $test->assert_null
                 ($at2-><AG::Attr.schemaTypeInfo>-><AG::c|TypeInfo.typeName>);
        $test->assert_null
                 ($at2-><AG::Attr.schemaTypeInfo>
                      -><AG::c|TypeInfo.typeNamespace>);

        $test->id ('noid.xmlid');
        $cfg-><M::c|DOMConfiguration.setParameter> (<Q::cfg|xml-id> => false);
        my $at3 = $doc-><M::Document.createAttributeNS> (<Q::xml:>, 'xml:id');
        $test->assert_null
                 ($at3-><AG::Attr.schemaTypeInfo>-><AG::c|TypeInfo.typeName>);
        $test->assert_null
                 ($at3-><AG::Attr.schemaTypeInfo>
                      -><AG::c|TypeInfo.typeNamespace>);

        $test->id ('noid.other');
        my $at4 = $doc-><M::Document.createAttributeNS> (null, 'id');
        $test->assert_null
                 ($at4-><AG::Attr.schemaTypeInfo>-><AG::c|TypeInfo.typeName>);
        $test->assert_null
                 ($at4-><AG::Attr.schemaTypeInfo>
                      -><AG::c|TypeInfo.typeNamespace>);

  @Method:
    @@Name: createTextNode
    @@enDesc:
      Creates a <IF::Text> node given the specified string.
    @@Param:
      @@@Name: data
      @@@Type: DOMString
      @@@enDesc:
        The data for the node.
    @@Return:
      @@@Type: Text
      @@@enDesc:
        The newly created <IF::Text> node.
      @@@PerlDef:
        my $bag = <Code::mg|getNodeBag||ManakaiDOM|all:: $ref = $self>;
        my $stem;
        __CODE{mg|createNodeStem||ManakaiDOM|all::
          $bag => $bag,
          $stem => $stem,
          $class => {<ClassName::tc|ManakaiDOMText>},
          $opt => {{
            <H::tc|ownerDocument> => $self,
            <H::infoset|content> => \$data,
          }},
        }__;
        __CODE{mg|createNodeRef||ManakaiDOM|all::
          $bag => $bag,
          $stem => $stem,
          $ref => $r,
          $opt => {{
            <H::mg|nodeRefInterfaces> => [<IFName::Text>],
          }},
        }__;

    @@Test:
      @@@QName: Doc.createTextNode.mg.1.test
      @@@PerlDef:
        local $Message::Util::Grove::GCLatency = 0;

        my $impl;
        __CODE{tc|createImplForTest:: $impl => $impl}__;

        my $bag = $impl->{<H::mg|nodeBag>};
        my $id = $impl->{<H::mg|nodeIDReference>};

        my $doc = $impl-><M::c|DOMImplementation.createDocument>;

        my $el = $doc-><M::Document.createTextNode> ('textdata');
        
        $test->id ('interface');
        $test->assert_isa ($el, <IFName::Text>);
        
        $test->id ('class');
        $test->assert_isa ($el, <ClassName::tc|ManakaiDOMText>);

        my $doc_id = $doc->{<H::mg|nodeIDReference>};
        my $el_id = $el->{<H::mg|nodeIDReference>};

        undef $impl;

        $test->id ('gc.impl.1');
        $test->assert_not_null ($bag->{$$id});

        $test->id ('gc.doc.1');
        $test->assert_not_null ($bag->{$$doc_id});

        $test->id ('gc.el.1');
        $test->assert_not_null ($bag->{$$el_id});

        undef $doc;

        $test->id ('gc.impl.2');
        $test->assert_not_null ($bag->{$$id});

        $test->id ('gc.doc.2');
        $test->assert_not_null ($bag->{$$doc_id});

        $test->id ('gc.el.2');
        $test->assert_not_null ($bag->{$$el_id});

        undef $el;

        $test->id ('gc.impl.3');
        $test->assert_null ($bag->{$$id});

        $test->id ('gc.doc.3');
        $test->assert_null ($bag->{$$doc_id});

        $test->id ('gc.el.3');
        $test->assert_null ($bag->{$$el_id});
    @@Test:
      @@@QName: Document.createTextNode.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $text = $doc-><M::Document.createTextNode> ('text data');
       
        $test->id ('interface');
        $test->assert_isa ($text, <IFName::Text>);

        $test->id ('nodeValue');
        $test->assert_equals ($text-><AG::Node.nodeValue>, 'text data');
 
        $test->id ('isElementContentWhitespace');
        $test->assert_false ($text-><AG::Text.isElementContentWhitespace>);
    @@Test:
      @@@QName: Document.createTextNode.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $text = $doc-><M::Document.createTextNode> ('');
       
        $test->id ('interface');
        $test->assert_isa ($text, <IFName::Text>);

        $test->id ('nodeValue');
        $test->assert_equals ($text-><AG::Node.nodeValue>, '');
 
        $test->id ('isElementContentWhitespace');
        $test->assert_false ($text-><AG::Text.isElementContentWhitespace>);

  @Method:
    @@Name: createCDATASection
    @@enDesc:
      Creates a <IF::tx|CDATASection> node.
    @@Param:
      @@@Name: data
      @@@Type: DOMString
      @@@enDesc:
        The data for the <IF::tx|CDATASection> content.
    @@Return:
      @@@Type: tx|CDATASection
      @@@enDesc:
        The newly created <IF::tx|CDATASection> node.
      @@@iRaises:
        @@@@@: MDOMX|MDOM_DOC_NOSUPPORT_XML
        @@@@enDesc:
          If the document is an HTML document.
      @@@PerlDef:
        require Message::DOM::XML;
        my $bag = <Code::mg|getNodeBag||ManakaiDOM|all:: $ref = $self>;
        my $stem;
        __CODE{mg|createNodeStem||ManakaiDOM|all::
          $bag => $bag,
          $stem => $stem,
          $class => {<ClassName::tx|ManakaiDOMCDATASection>},
          $opt => {{
            <H::tc|ownerDocument> => $self,
            <H::infoset|content> => \$data,
          }},
        }__;
        __CODE{mg|createNodeRef||ManakaiDOM|all::
          $bag => $bag,
          $stem => $stem,
          $ref => $r,
          $opt => {{
            <H::mg|nodeRefInterfaces> => [<IFName::tx|CDATASection>],
          }},
        }__;

    @@Test:
      @@@QName: Document.createCDATASection.mg.1.test
      @@@PerlDef:
        local $Message::Util::Grove::GCLatency = 0;

        my $impl;
        __CODE{tc|createImplForTest:: $impl => $impl}__;

        my $bag = $impl->{<H::mg|nodeBag>};
        my $id = $impl->{<H::mg|nodeIDReference>};

        my $doc = $impl-><M::c|DOMImplementation.createDocument>;

        my $el = $doc-><M::Document.createCDATASection> ('textdata');
        
        $test->id ('interface');
        $test->assert_isa ($el, <IFName::tx|CDATASection>);
        
        $test->id ('class');
        $test->assert_isa ($el, <ClassName::tx|ManakaiDOMCDATASection>);

        my $doc_id = $doc->{<H::mg|nodeIDReference>};
        my $el_id = $el->{<H::mg|nodeIDReference>};

        undef $impl;

        $test->id ('gc.impl.1');
        $test->assert_not_null ($bag->{$$id});

        $test->id ('gc.doc.1');
        $test->assert_not_null ($bag->{$$doc_id});

        $test->id ('gc.el.1');
        $test->assert_not_null ($bag->{$$el_id});

        undef $doc;

        $test->id ('gc.impl.2');
        $test->assert_not_null ($bag->{$$id});

        $test->id ('gc.doc.2');
        $test->assert_not_null ($bag->{$$doc_id});

        $test->id ('gc.el.2');
        $test->assert_not_null ($bag->{$$el_id});

        undef $el;

        $test->id ('gc.impl.3');
        $test->assert_null ($bag->{$$id});

        $test->id ('gc.doc.3');
        $test->assert_null ($bag->{$$doc_id});

        $test->id ('gc.el.3');
        $test->assert_null ($bag->{$$el_id});

  @Method:
    @@Name: createComment
    @@enDesc:
      Creates a <IF::tc|Comment> node.
    @@Param:
      @@@Name: data
      @@@Type: DOMString
      @@@enDesc:
        The data for the node.
    @@Return:
      @@@Type: Comment
      @@@enDesc:
        The newly created <IF::tc|Comment> node.
      @@@PerlDef:
        my $bag = <Code::mg|getNodeBag||ManakaiDOM|all:: $ref = $self>;
        my $stem;
        __CODE{mg|createNodeStem||ManakaiDOM|all::
          $bag => $bag,
          $stem => $stem,
          $class => {<ClassName::tc|ManakaiDOMComment>},
          $opt => {{
            <H::tc|ownerDocument> => $self,
            <H::infoset|content> => \$data,
          }},
        }__;
        __CODE{mg|createNodeRef||ManakaiDOM|all::
          $bag => $bag,
          $stem => $stem,
          $ref => $r,
          $opt => {{
            <H::mg|nodeRefInterfaces> => [<IFName::tc|Comment>],
          }},
        }__;

    @@Test:
      @@@QName: Document.createComment.mg.1.test
      @@@PerlDef:
        local $Message::Util::Grove::GCLatency = 0;

        my $impl;
        __CODE{tc|createImplForTest:: $impl => $impl}__;

        my $bag = $impl->{<H::mg|nodeBag>};
        my $id = $impl->{<H::mg|nodeIDReference>};

        my $doc = $impl-><M::c|DOMImplementation.createDocument>;

        my $el = $doc-><M::Document.createComment> ('textdata');
        
        $test->id ('interface');
        $test->assert_isa ($el, <IFName::tc|Comment>);
        
        $test->id ('class');
        $test->assert_isa ($el, <ClassName::tc|ManakaiDOMComment>);

        my $doc_id = $doc->{<H::mg|nodeIDReference>};
        my $el_id = $el->{<H::mg|nodeIDReference>};

        undef $impl;

        $test->id ('gc.impl.1');
        $test->assert_not_null ($bag->{$$id});

        $test->id ('gc.doc.1');
        $test->assert_not_null ($bag->{$$doc_id});

        $test->id ('gc.el.1');
        $test->assert_not_null ($bag->{$$el_id});

        undef $doc;

        $test->id ('gc.impl.2');
        $test->assert_not_null ($bag->{$$id});

        $test->id ('gc.doc.2');
        $test->assert_not_null ($bag->{$$doc_id});

        $test->id ('gc.el.2');
        $test->assert_not_null ($bag->{$$el_id});

        undef $el;

        $test->id ('gc.impl.3');
        $test->assert_null ($bag->{$$id});

        $test->id ('gc.doc.3');
        $test->assert_null ($bag->{$$doc_id});

        $test->id ('gc.el.3');
        $test->assert_null ($bag->{$$el_id});

  @Method:
    @@Name: createDocumentFragment
    @@enDesc:
      Creates an empty <IF::DocumentFragment> node.
    @@Return:
      @@@Type: DocumentFragment
      @@@enDesc:
        A newly created <IF::DocumentFragment> node.
      @@@PerlDef:
        my $bag = <Code::mg|getNodeBag||ManakaiDOM|all:: $ref = $self>;
        my $stem;
        __CODE{mg|createNodeStem||ManakaiDOM|all::
          $bag => $bag,
          $stem => $stem,
          $class => {<ClassName::ManakaiDOMDocumentFragment>},
          $opt => {{
            <H::tc|ownerDocument> => $self,
          }},
        }__;
        __CODE{mg|createNodeRef||ManakaiDOM|all::
          $bag => $bag,
          $stem => $stem,
          $ref => $r,
          $opt => {{
            <H::mg|nodeRefInterfaces> => [<IFName::DocumentFragment>],
          }},
        }__;

    @@Test:
      @@@QName: Document.createDF.mg.1.test
      @@@PerlDef:
        local $Message::Util::Grove::GCLatency = 0;

        my $impl;
        __CODE{tc|createImplForTest:: $impl => $impl}__;

        my $bag = $impl->{<H::mg|nodeBag>};
        my $id = $impl->{<H::mg|nodeIDReference>};

        my $doc = $impl-><M::c|DOMImplementation.createDocument>;

        my $el = $doc-><M::Document.createDocumentFragment>;
        
        $test->id ('interface');
        $test->assert_isa ($el, <IFName::DocumentFragment>);
        
        $test->id ('class');
        $test->assert_isa ($el, <ClassName::ManakaiDOMDocumentFragment>);

        my $doc_id = $doc->{<H::mg|nodeIDReference>};
        my $el_id = $el->{<H::mg|nodeIDReference>};

        undef $impl;

        $test->id ('gc.impl.1');
        $test->assert_not_null ($bag->{$$id});

        $test->id ('gc.doc.1');
        $test->assert_not_null ($bag->{$$doc_id});

        $test->id ('gc.el.1');
        $test->assert_not_null ($bag->{$$el_id});

        undef $doc;

        $test->id ('gc.impl.2');
        $test->assert_not_null ($bag->{$$id});

        $test->id ('gc.doc.2');
        $test->assert_not_null ($bag->{$$doc_id});

        $test->id ('gc.el.2');
        $test->assert_not_null ($bag->{$$el_id});

        undef $el;

        $test->id ('gc.impl.3');
        $test->assert_null ($bag->{$$id});

        $test->id ('gc.doc.3');
        $test->assert_null ($bag->{$$doc_id});

        $test->id ('gc.el.3');
        $test->assert_null ($bag->{$$el_id});

  @Method:
    @@Name: createEntityReference
    @@enDesc:
      Creates an <IF::tx|EntityReference> node.

      In addition, if the referenced entity is known, the child
      list of the <IF::tx|EntityReference> node is made the same
      as that of the corresponding <IF::tx|Entity> node.

      Note that if any descendant of the <IF::tx|Entity> node has
      an unbound namespace prefix, the corresponding descendant of 
      the created <IF::tx|EntityReference> node is also unbound,
      i.e. its <A::Node.namespaceURI> is <DOM::null>.  DOM levels
      2 and 3 do not support any mechanism to resolve namespace
      prefixes in this case.  <SRC::DOM2, DOM3>
    @@DOMMain:isNamespaceUnaware: 1
    @@Param:
      @@@Name: name
      @@@Type: DOMString
      @@@enDesc:
        The name of the entity to reference.

          {NOTE:: Namespace well-formedness check is not performed.
          }
      @@@enImplNote:
        {ISSUE::
           What would be made if the <P::name> is the name of one of
           predefined entities?
        }
    @@Return:
      @@@Type: tx|EntityReference
      @@@enDesc:
        The newly created <IF::tx|EntityReference> node.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_BAD_NAME
        @@@@enDesc:
          If the <P::name> is not an XML <CODE::Name> according
          to the XML version in use specified in the
          <A::Document.xmlVersion> attribute.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_DOC_NOSUPPORT_XML
        @@@@enDesc:
          If it is an HTML document.
      @@@PerlDef:
        require Message::DOM::XML;
        our $CreateEntityReference_OpenEntity;
          ## NOTE: Multithread unsafe

        my $orig_strict = $self-><AG::Document.strictErrorChecking>;
        if ($orig_strict) {
          my $version = $self-><AG::Document.xmlVersion>;
          __CODE{DOMMain|ensureXMLName::
            $INPUT => $name, $INPUT_PARAM_NAME => 'name',
            $XMLVERSION => $version,
          }__;
        }

        my $bag = <Code::mg|getNodeBag||ManakaiDOM|all:: $ref = $self>;
        my $stem;
        __CODE{mg|createNodeStem||ManakaiDOM|all::
          $bag => $bag,
          $stem => $stem,
          $class => {<ClassName::tx|ManakaiDOMEntityReference>},
          $opt => {{
            <H::infoset|name> => \$name,
            <H::tc|ownerDocument> => $self,
          }},
        }__;
        __CODE{mg|createNodeRef||ManakaiDOM|all::
          $bag => $bag,
          $stem => $stem,
          $ref => $r,
          $opt => {{
            <H::mg|nodeRefInterfaces> => [<IFName::tx|EntityReference>],
          }},
        }__;

        ## Expansion
        __DEEP{
          unless ($CreateEntityReference_OpenEntity->{$name}) {
            local $CreateEntityReference_OpenEntity->{$name} = true;
            my $__doctype = $self-><AG::Document.doctype>;
            $__doctype = $__doctype-><M::Node.getFeature>
                                     (<Q::fe|XDoctype> => '3.0')
              if $__doctype;
            if ($__doctype) {
              my $__et = $__doctype-><M::DTDef.getGeneralEntityNode> ($name);
              if ($__et) {
                $self-><AS::Document.strictErrorChecking> (false);
                my @node;
                for my $c (@{$__et-><AG::Node.childNodes>}) {
                  my $clone = $c-><M::Node.cloneNode> (true);
                  $r-><M::Node.appendChild> ($clone);
                  push @node, $clone;
                }
                $r-><AS::tx|EntityReference.manakaiExpanded>
                      ($__et-><AG::tx|Entity.hasReplacementTree>);
                $self-><AS::Document.strictErrorChecking> ($orig_strict);
              } # entity
            } # doctype
          }
          $r-><M::Node.manakaiSetReadOnly> (true, true);
        }__;

    @@Test:
      @@@QName: Document.createER.mg.1.test
      @@@PerlDef:
        local $Message::Util::Grove::GCLatency = 0;

        my $impl;
        __CODE{tc|createImplForTest:: $impl => $impl}__;

        my $bag = $impl->{<H::mg|nodeBag>};
        my $id = $impl->{<H::mg|nodeIDReference>};

        my $doc = $impl-><M::c|DOMImplementation.createDocument>;

        my $el = $doc-><M::Document.createEntityReference> ('entity');
        
        $test->id ('interface');
        $test->assert_isa ($el, <IFName::tx|EntityReference>);
        
        $test->id ('class');
        $test->assert_isa ($el, <ClassName::tx|ManakaiDOMEntityReference>);

        my $doc_id = $doc->{<H::mg|nodeIDReference>};
        my $el_id = $el->{<H::mg|nodeIDReference>};

        undef $impl;

        $test->id ('gc.impl.1');
        $test->assert_not_null ($bag->{$$id});

        $test->id ('gc.doc.1');
        $test->assert_not_null ($bag->{$$doc_id});

        $test->id ('gc.el.1');
        $test->assert_not_null ($bag->{$$el_id});

        undef $doc;

        $test->id ('gc.impl.2');
        $test->assert_not_null ($bag->{$$id});

        $test->id ('gc.doc.2');
        $test->assert_not_null ($bag->{$$doc_id});

        $test->id ('gc.el.2');
        $test->assert_not_null ($bag->{$$el_id});

        undef $el;

        $test->id ('gc.impl.3');
        $test->assert_null ($bag->{$$id});

        $test->id ('gc.doc.3');
        $test->assert_null ($bag->{$$doc_id});

        $test->id ('gc.el.3');
        $test->assert_null ($bag->{$$el_id});
    @@XDTest:
      @@@QName: Document.createER.nodef.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $ent = $doc-><M::Document.createEntityReference> ('ent1');
        $test->assert_isa ($ent, <IFName::tx|EntityReference>);
        
        $test->id ('node.name');
        $test->assert_equals ($ent-><AG::Node.nodeName>, 'ent1');

        $test->id ('not.expanded');
        $test->assert_false ($ent-><AG::tx|EntityReference.manakaiExpanded>);

        $test->id ('empty');
        $test->assert_false ($ent-><M::Node.hasChildNodes>);

        $test->id ('readonly');
        $test->assert_true ($ent-><AG::Node.manakaiReadOnly>);
    @@XDTest:
      @@@QName: Document.createER.hasdef.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docd = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>, '3.0');
        my $dtd = $docd-><M::d|DocumentXDoctype.createDocumentTypeDefinition>
                           ('doctype');
          my $et = $docd-><M::d|DocumentXDoctype.createGeneralEntity>
                             ('ent1');
          $et-><AS::Node.textContent> ('replacement text content');
          $et-><AS::tx|Entity.hasReplacementTree> (true);
        $dtd-><M::DTDef.setGeneralEntityNode> ($et);
        $doc-><M::Node.appendChild> ($dtd);

        my $ent = $doc-><M::Document.createEntityReference> ('ent1');
        $test->assert_isa ($ent, <IFName::tx|EntityReference>);
        
        $test->id ('node.name');
        $test->assert_equals ($ent-><AG::Node.nodeName>, 'ent1');

        $test->id ('expanded');
        $test->assert_true ($ent-><AG::tx|EntityReference.manakaiExpanded>);

        $test->id ('not.empty');
        $test->assert_true ($ent-><M::Node.hasChildNodes>);

        $test->id ('text.content');
        $test->assert_equals ($ent-><AG::Node.textContent>,
                              'replacement text content');

        $test->id ('is.read.only');
        $test->assert_exception (code => sub {
          $ent-><AS::Node.textContent> ('new value');
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);
    @@XDTest:
      @@@QName: Document.createER.hasdef.no-read-only.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docd = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>, '3.0');
        my $dtd = $docd-><M::d|DocumentXDoctype.createDocumentTypeDefinition>
                           ('doctype');
          my $et = $docd-><M::d|DocumentXDoctype.createGeneralEntity>
                             ('ent1');
          $et-><AS::Node.textContent> ('replacement text content');
          $et-><AS::tx|Entity.hasReplacementTree> (true);
        $dtd-><M::DTDef.setGeneralEntityNode> ($et);
        $doc-><M::Node.appendChild> ($dtd);

        my $ent = $doc-><M::Document.createEntityReference> ('ent1');
        $test->assert_isa ($ent, <IFName::tx|EntityReference>);
        $ent-><M::Node.manakaiSetReadOnly> (false, true);
        
        $test->id ('node.name');
        $test->assert_equals ($ent-><AG::Node.nodeName>, 'ent1');

        $test->id ('expanded');
        $test->assert_true ($ent-><AG::tx|EntityReference.manakaiExpanded>);

        $test->id ('not.empty');
        $test->assert_true ($ent-><M::Node.hasChildNodes>);

        $test->id ('text.content');
        $test->assert_equals ($ent-><AG::Node.textContent>,
                              'replacement text content');

        $test->id ('is.not.read.only');
        $ent-><AS::Node.textContent> ('new value');
        $test->assert_equals ($ent-><AG::Node.textContent>,
                              'new value');
    @@XDTest:
      @@@QName: Document.createER.hasdef.recursive.direct.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docd = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>, '3.0');
        my $dtd = $docd-><M::d|DocumentXDoctype.createDocumentTypeDefinition>
                           ('doctype');
          my $ent0 = $doc-><M::Document.createEntityReference> ('ent1');
          $test->assert_false ($ent0-><AG::tx|EntityReference.manakaiExpanded>);
          my $et = $docd-><M::d|DocumentXDoctype.createGeneralEntity>
                             ('ent1');
          $et-><M::Node.appendChild> ($ent0);
          $et-><AS::tx|Entity.hasReplacementTree> (true);
        $dtd-><M::DTDef.setGeneralEntityNode> ($et);
        $doc-><M::Node.appendChild> ($dtd);

        $test->id ('create');
        my $ent = $doc-><M::Document.createEntityReference> ('ent1');
        $test->assert_isa ($ent, <IFName::tx|EntityReference>);
        $test->assert_true ($ent-><AG::tx|EntityReference.manakaiExpanded>);

        $test->id ('firstChild');
        $test->assert_not_null ($ent-><AG::Node.firstChild>);
        $test->assert_false ($ent-><AG::Node.firstChild>
                                 -><AG::tx|EntityReference.manakaiExpanded>);
    @@XDTest:
      @@@QName: Document.createER.hasdef.recursive.indirect.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docd = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>, '3.0');
        my $dtd = $docd-><M::d|DocumentXDoctype.createDocumentTypeDefinition>
                           ('doctype');
          my $ent0 = $doc-><M::Document.createEntityReference> ('ent2');
          $test->assert_false ($ent0-><AG::tx|EntityReference.manakaiExpanded>);
          my $et = $docd-><M::d|DocumentXDoctype.createGeneralEntity>
                             ('ent1');
          $et-><M::Node.appendChild> ($ent0);
          $et-><AS::tx|Entity.hasReplacementTree> (true);

          my $ent0_2 = $doc-><M::Document.createEntityReference> ('ent1');
          my $et_2 = $docd-><M::d|DocumentXDoctype.createGeneralEntity>
                             ('ent2');
          $et_2-><M::Node.appendChild> ($ent0_2);
          $et_2-><AS::tx|Entity.hasReplacementTree> (true);
        $dtd-><M::DTDef.setGeneralEntityNode> ($et);
        $doc-><M::Node.appendChild> ($dtd);

        $test->id ('create');
        my $ent = $doc-><M::Document.createEntityReference> ('ent1');
        $test->assert_isa ($ent, <IFName::tx|EntityReference>);
        $test->assert_true ($ent-><AG::tx|EntityReference.manakaiExpanded>);

        $test->id ('firstChild');
        $test->assert_not_null ($ent-><AG::Node.firstChild>);
        $test->assert_false ($ent-><AG::Node.firstChild>
                                 -><AG::tx|EntityReference.manakaiExpanded>);

  @Method:
    @@Name: createProcessingInstruction
    @@enDesc:
      Creates a <IF::tx|ProcessingInstruction> node given the
      specified name and data strings.
    @@Param:
      @@@Name: target
      @@@Type: DOMString
      @@@enDesc:
        The target part of the processing instruction.
    @@Param:
      @@@Name: data
      @@@Type: DOMString
      @@@enDesc:
        The data for the node.
    @@Return:
      @@@Type: tx|ProcessingInstruction
      @@@enDesc:
        The newly created <IF::tx|ProcessingInstruction> node.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_BAD_NAME
        @@@@enDesc:
          If the <P::name> is not an XML <CODE::Name> according
          to the XML version in use specified in the
          <A::Document.xmlVersion> attribute.
        @@@@UnlessStrictErrorChecking:
        @@@@enImplNote:
          <ABNF::"XML"> is not allowed as a target in XML
          but it is not forbidden in DOM.
          <URI::http://lists.w3.org/Archives/Public/www-dom/2001JanMar/thread.html#77>
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_DOC_NOSUPPORT_XML
        @@@@enDesc:
          If the document is an HTML document.
      @@@PerlDef:
        require Message::DOM::XML;

        if ($self-><AG::Document.strictErrorChecking>) {
          my $version = $self-><AG::Document.xmlVersion>;
          __CODE{DOMMain|ensureXMLName::
            $INPUT => $target, $INPUT_PARAM_NAME => 'target',
            $XMLVERSION => $version,
          }__;
        }

        my $bag = <Code::mg|getNodeBag||ManakaiDOM|all:: $ref = $self>;
        $data = '' unless defined $data;
        my $stem;
        __CODE{mg|createNodeStem||ManakaiDOM|all::
          $bag => $bag,
          $stem => $stem,
          $class => {<ClassName::tx|ManakaiDOMProcessingInstruction>},
          $opt => {{
            <H::infoset|target> => \$target,
            <H::infoset|content> => \$data,
            <H::tc|ownerDocument> => $self,
          }},
        }__;
        __CODE{mg|createNodeRef||ManakaiDOM|all::
          $bag => $bag,
          $stem => $stem,
          $ref => $r,
          $opt => {{
            <H::mg|nodeRefInterfaces> => [<IFName::tx|ProcessingInstruction>],
          }},
        }__;

    @@Test:
      @@@QName: Document.createPI.mg.1.test
      @@@PerlDef:
        local $Message::Util::Grove::GCLatency = 0;

        my $impl;
        __CODE{tc|createImplForTest:: $impl => $impl}__;

        my $bag = $impl->{<H::mg|nodeBag>};
        my $id = $impl->{<H::mg|nodeIDReference>};

        my $doc = $impl-><M::c|DOMImplementation.createDocument>;

        my $el = $doc-><M::Document.createProcessingInstruction> ('pi', 'data');
        
        $test->id ('interface');
        $test->assert_isa ($el, <IFName::tx|ProcessingInstruction>);
        
        $test->id ('class');
        $test->assert_isa ($el, <ClassName::tx|ManakaiDOMProcessingInstruction>);

        my $doc_id = $doc->{<H::mg|nodeIDReference>};
        my $el_id = $el->{<H::mg|nodeIDReference>};

        undef $impl;

        $test->id ('gc.impl.1');
        $test->assert_not_null ($bag->{$$id});

        $test->id ('gc.doc.1');
        $test->assert_not_null ($bag->{$$doc_id});

        $test->id ('gc.el.1');
        $test->assert_not_null ($bag->{$$el_id});

        undef $doc;

        $test->id ('gc.impl.2');
        $test->assert_not_null ($bag->{$$id});

        $test->id ('gc.doc.2');
        $test->assert_not_null ($bag->{$$doc_id});

        $test->id ('gc.el.2');
        $test->assert_not_null ($bag->{$$el_id});

        undef $el;

        $test->id ('gc.impl.3');
        $test->assert_null ($bag->{$$id});

        $test->id ('gc.doc.3');
        $test->assert_null ($bag->{$$doc_id});

        $test->id ('gc.el.3');
        $test->assert_null ($bag->{$$el_id});
    @@Test:
      @@@QName: Document.createProcessingInstruction.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $pi = $doc-><M::Document.createProcessingInstruction>
                          ('target', 'data');

        $test->id ('interface');
        $test->assert_isa ($pi, <IFName::tx|ProcessingInstruction>);

        $test->id ('nodeName');
        $test->assert_equals ($pi-><AG::Node.nodeName>, 'target');

        $test->id ('nodeValue');
        $test->assert_equals ($pi-><AG::Node.nodeValue>, 'data');
    @@Test:
      @@@QName: Document.createProcessingInstruction.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $pi = $doc-><M::Document.createProcessingInstruction>
                          ('target:name', '');

        $test->id ('interface');
        $test->assert_isa ($pi, <IFName::tx|ProcessingInstruction>);

        $test->id ('nodeName');
        $test->assert_equals ($pi-><AG::Node.nodeName>, 'target:name');

        $test->id ('nodeValue');
        $test->assert_equals ($pi-><AG::Node.nodeValue>, '');

  @L3Attr:
    @@Name: strictErrorChecking
    @@enDesc:
      Whether error checking is enforced or not.

      This attribute is <DOM::true> by default.
    @@Type: boolean
    @@FalseCase:
      @@@enDesc:
        The implementation is free not to test every possible error
        case normally defined on DOM operations and not raise any
        <IF::c|DOMException> on DOM operations or report errors
        while using <M::Document.normalizeDocument>.  In case of error,
        the behavior is undefined.
    @@Get:
      @@@PerlDef:
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $r,
          $prop => {<H::c|strictErrorChecking>},
          $ref => $self,
        }__;
        $r = true unless defined $r;
    @@Set:
      @@@PerlDef:
        __CODE{mg|setNodeStemPropValue||ManakaiDOM|all::
          $given => {$given ? true : false},
          $prop => {<H::c|strictErrorChecking>},
          $ref => $self,
        }__;

    @@L3Test:
      @@@QName: Document.strictErrorChecking.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        $test->id ('default');
        $test->assert_true ($doc-><AG::Document.strictErrorChecking>);

        $test->id ('disabled');
        $doc-><AS::Document.strictErrorChecking> (false);
        $test->assert_false ($doc-><AG::Document.strictErrorChecking>);

        $test->id ('enabled');
        $doc-><AS::Document.strictErrorChecking> (true);
        $test->assert_true ($doc-><AG::Document.strictErrorChecking>);

        $test->id ('disabled.by.null');
        $doc-><AS::Document.strictErrorChecking> (null);
        $test->assert_false ($doc-><AG::Document.strictErrorChecking>);

  @L3Attr:
    @@Name: domConfig
    @@enDesc:
      The configuration of the document.

      {NOTE:: This configuration is used when e.g. the method
              <M::Document.normalizeDocument> is invoked.
      }

    @@Get:
      @@@Type: c|DOMConfiguration
      @@@enDesc: The DOM configuration object.
      @@@PerlDef:
        __CODE{c|getConfigObject::
          $target => $self,
          $targetHash => {<Code::mg|getNodeStem||ManakaiDOM|all::
                                     $ref = $self>},
          $targetType => {<IFName::Document>},
          $result => $r,
        }__;

    @@L3Test:
      @@@QName: Doc.domConfig.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $cfg = $doc-><AG::Document.domConfig>;

        $test->id ('interface');
        $test->assert_isa ($cfg, <IFName::c|DOMConfiguration>);

  @Attr:
    @@Name: documentElement
    @@enDesc:
      The document element of the document.
    @@Get:
      @@@Type: Element
      @@@nullCase:
        @@@@enDesc:
          If the document has no element.
        @@@@For: ManakaiDOM|ManakaiDOM
      @@@PerlDef:
        __DEEP{
          F: for my $child (@{$self-><AG::Node.childNodes>}) {
            if ($child-><AG::Node.nodeType> == <C::Node.ELEMENT_NODE>) {
              $r = $child;
              last F;
            }
          } # F
        }__;
    @@Test:
      @@@QName: Document.documentElement.one-element-document.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createElementNS> (null, 'e');
        $doc-><M::Node.appendChild> ($el);

        $test->assert_equals ($doc-><AG::Document.documentElement>, $el);
    @@Test:
      @@@QName: Document.documentElement.empty-document.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        $test->assert_null ($doc-><AG::Document.documentElement>);
    @@Test:
      @@@QName: Document.documentElement.doctype-element-document.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $doctype = $doc-><AG::Document.implementation>
                          -><M::c|DOMImplementation.createDocumentType> ('dt');
        $doc-><M::Node.appendChild> ($doctype);
        my $el = $doc-><M::Document.createElementNS> (null, 'el');
        $doc-><M::Node.appendChild> ($el);

        $test->assert_equals ($doc-><AG::Document.documentElement>, $el);

  @Attr:
    @@Name: implementation
    @@enDesc:
      The <IF::c|DOMImplmentation> object that handles the document.
    @@Type: c|DOMImplementation
    @@Get:
      @@@PerlDef:
        __CODE{mg|getNodeStemProp0Node||ManakaiDOM|all::
          $r => $r,
          $prop => {<H::f|implementation>},
          $ref => $self,
          $opt => {{
            <H::mg|nodeRefInterfaces> => [<IFName::c|DOMImplementation>],
          }},
        }__;

    @@Test:
      @@@QName: Document.implementation.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $impl = $doc-><AG::Document.implementation>;
        $test->assert_isa ($impl, <IFName::c|DOMImplementation>);

  @L3Attr:
    @@Name: xmlVersion
    @@enDesc:
      The XML version number of the document, as part of the XML
      declaration.
    @@Type: DOMString
    @@InCase:
      @@@Value: 
        @@@@@: 1.0
        @@@@ContentType: DISCore|String
      @@@enDesc:
        If the <XA::version> declaration is set to <XML::1.0> or
        if there is no declaration and the document supports the
        <Feature::XML> feature.
    @@InCase:
      @@@Value:
        @@@@@: 1.1
        @@@@ContentType: DISCore|String
      @@@enDesc:
        If the <XA::version> declaration is set to <XML::1.1>.  <SRC::manakai>
    @@nullCase:
      @@@enDesc:
        If the document does not support the <Feature::XML> feature.
    @@Get:
      @@@PerlDef:
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $r,
          $prop => {<H::infoset|version>},
          $ref => $self,
        }__;
        $r = '1.0' unless defined $r;
    @@Set:
      @@@enDesc:
        Changing this attribute will affect methods that checks
        for invalid characters in XML <CODE::Name>s. 
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_IMPL_NOSUPPORT_XMLVER
        @@@@enDesc:
          If the version is set to a value that is not supported by
          the <IF::Document>.

          A <IF::Document> that supports a version of the <Feature::XMLVersion>
          feature must not raise a <C::c|DOMException.NOT_SUPPORTED_ERR>
          exception for the same version number when setting this
          attribute.
      @@@iRaises:
        @@@@@: MDOMX|MDOM_DOC_NOSUPPORT_XML
        @@@@enDesc:
          If the <IF::Document> does not support the <Feature::XML> feature.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the node is read-only.  <SRC::manakai>
      @@@PerlDef:
        __CODE{tc|NodeReadOnlyError:: $node => $self}__;
        if (defined $given and
            ($given eq '1.0' or $given eq '1.1' or
             not $self-><AG::Document.strictErrorChecking>)) {
          __CODE{mg|setNodeStemPropValue||ManakaiDOM|all::
            $given => $given,
            $prop => {<H::infoset|version>},
            $ref => $self,
          }__;
        } else {
          __EXCEPTION{MDOMX|MDOM_IMPL_NOSUPPORT_XMLVER::
            infoset|version => {$given},
          }__;
        }

    @@Test:
      @@@QName: Document.xmlVersion.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        $test->id ('initial');
        $test->assert_equals ($doc-><AG::Document.xmlVersion>, '1.0');

        $test->id ('set.1.1');
        $doc-><AS::Document.xmlVersion> ('1.1');
        $test->assert_equals ($doc-><AG::Document.xmlVersion>, '1.1');

        $test->id ('set.1.0');
        $doc-><AS::Document.xmlVersion> ('1.0');
        $test->assert_equals ($doc-><AG::Document.xmlVersion>, '1.0');

        $test->id ('set.1.2');
        $test->assert_exception (code => sub {
          $doc-><AS::Document.xmlVersion> ('1.2');
        }, exception_subtype => <Q::MDOMX|MDOM_IMPL_NOSUPPORT_XMLVER>);

  @L13Attr:
    @@Name: doctype
    @@enDesc:
      The document type declaration associated with the document.
      It is the <IF::tx|DocumentType> child of the node, if any.

      For an XML document with a document type declaration,
      this attribute contains the <IF::tx|DocumentType> node.
    @@enDesc:
      @@@For: ManakaiDOM|DOM3
      @@@ddid: html
      @@@@:
        For an HTML document, this attribute may contain
        a <IF::tx|DocumentType> node independently of the presence or
        absence of document type declaration. 
    @@enDesc:
      @@@For: !ManakaiDOM|DOM3
      @@@ddid: html
      @@@@:
        For an HTML document, the attribute value is always <DOM::null>.

    @@enDesc:
      @@@ddid: note
      @@@@:
        {NOTE:: Although this attribute itself is read-only, 
                usual node modification methods on the <IF::Document>
                node can alter the <IF::tx|DocumentType> node.
                However, while the implementation might instantiate different
                types of <IF::Document> object supporting additional
                feature than <Feature::Core>, based on the
                <IF::tx|DocumentType> specified at creation time,
                changing it afterward is unlikely to result in a
                change of the feature supported by the <IF::Document>.
        }
    @@enImplNote:
      {TODO:: HTML5 consideration.
      }
    @@Type: tx|DocumentType
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          @@@@@For: ManakaiDOM|DOM3
          @@@@@@:
            If the document does not have a document type declaration,
            or if it is an HTML document and the implementation does not
            expose the document type declaration to the DOM.
        @@@@enDesc:
          @@@@@For: !ManakaiDOM|DOM3
          @@@@@@:
            If the document does not have a document type declaration,
            or if it is an HTML document.
      @@@PerlDef:
        @@@@@:
          __DEEP{
            F: for my $child (@{$self-><AG::Node.childNodes>}) {
              my $nt = $child-><AG::Node.nodeType>;
              if ($nt == <C::Node.DOCUMENT_TYPE_NODE>) {
                $r = $child;
                last F;
              } elsif ($nt == <C::Node.ELEMENT_NODE>) { # document element
                last F;
              }
            } # F
          }__;
        @@@@enImplNote:
          Although the intention of the DOM specification is unclear,
          the current manakai implementation <EM::does> return
          a <IF::tx|DocumentType> node, if any, even if DOM level
          is less than (not equal to) 3.
    @@Test:
      @@@QName: Document.doctype.one-element-document.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        $test->assert_null ($doc-><AG::Document.doctype>);
    @@Test:
      @@@QName: Document.doctype.empty-document.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        $test->assert_null ($doc-><AG::Document.doctype>);
    @@Test:
      @@@QName: Document.doctype.doctype-element-document.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $doctype = $doc-><AG::Document.implementation>
                          -><M::c|DOMImplementation.createDocumentType> ('dt');
        my $el = $doc-><M::Document.createElementNS> (null, 'e');
        $doc-><M::Node.appendChild> ($doctype);
        $doc-><M::Node.appendChild> ($el);

        $test->assert_equals ($doc-><AG::Document.doctype>, $doctype);
    @@Test:
      @@@QName: Document.doctype.comment-doctype-element-document.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $doctype = $doc-><AG::Document.implementation>
                          -><M::c|DOMImplementation.createDocumentType> ('dt');
        my $el = $doc-><M::Document.createElementNS> (null, 'el');
        my $comment = $doc-><M::Document.createComment> ('');
        $doc-><M::Node.appendChild> ($comment);
        $doc-><M::Node.appendChild> ($doctype);
        $doc-><M::Node.appendChild> ($el);

        $test->assert_equals ($doc-><AG::Document.doctype>, $doctype);

  @L3Attr:
    @@Name: documentURI
    @@enDesc:
      The location of the document.
    @@nullCase:
      @@@enDesc:
        If undefined or if the <IF::Document> was created using
        <M::c|DOMImplementation.createDocument>.
    @@Type: DOMString
    @@dis:actualType: ManakaiDOM|ManakaiDOMURI
    @@Get:
      @@@PerlDef:
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $r,
          $prop => {<H::c|documentURI>},
          $ref => $self,
        }__;
    @@Set:
      @@@enDesc:
        No lexical checking is performed when setting this attribute;
        this could result in a <DOM::null> value return when using
        <A::Node.baseURI>.
      @@@NodeReadOnlyError:
      @@@PerlDef:
        __CODE{tc|NodeReadOnlyError:: $node => $self}__;
        __CODE{mg|setNodeStemPropValue||ManakaiDOM|all::
          $given => $given,
          $prop => {<H::c|documentURI>},
          $ref => $self,
        }__;

    @@Test:
      @@@QName: Document.documentURI.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        $test->id ('initial');
        $test->assert_null ($doc-><AG::Document.documentURI>);

        $test->id ('set');
        $doc-><AS::Document.documentURI> ('about:');
        $test->assert_equals ($doc-><AG::Document.documentURI>, 'about:');

        $test->id ('relative.set');
        $doc-><AS::Document.documentURI> ('path');
        $test->assert_equals ($doc-><AG::Document.documentURI>, 'path');

        $test->id ('reset');
        $doc-><AS::Document.documentURI> (null);
        $test->assert_null ($doc-><AG::Document.documentURI>);

  @L3Attr:
    @@Name: inputEncoding
    @@enDesc:
      The encoding used for the document at the time of the parsing.
    @@Type: DOMString
    @@enImplNote:
      It is unclear what type of values are permitted. 
      IANA-registered charset names? XML encoding declaration 
      names?  Or, any names passed from the upper-level protocols?
    @@nullCase:
      @@@enDesc:
        If it is not known, such as when the <IF::Document> was
        created in memory.
    @@Get:
      @@@PerlDef:
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $r,
          $prop => {<H::infoset|characterEncodingScheme>},
          $ref => $self,
        }__;
    @@LXSet:
      @@@enDesc:
        Sets the attribute value.  No lexical checking is performed
        on setting.
      @@@nullCase:
        @@@@enDesc:
          Sets <DOM::null> as the attribute value.
      @@@NodeReadOnlyError:
      @@@PerlDef:
        __CODE{tc|NodeReadOnlyError:: $node => $self}__;
        __CODE{mg|setNodeStemPropValue||ManakaiDOM|all::
          $given => $given,
          $prop => {<H::infoset|characterEncodingScheme>},
          $ref => $self,
        }__;

    @@Test:
      @@@QName: Document.inputEncoding.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        $test->id ('initial');
        $test->assert_null ($doc-><AG::Document.inputEncoding>);

        $test->id ('set');
        $doc-><AS::Document.inputEncoding> ('utf-8');
        $test->assert_equals ($doc-><AG::Document.inputEncoding>, 'utf-8');

        $test->id ('reset');
        $doc-><AS::Document.inputEncoding> (null);
        $test->assert_null ($doc-><AG::Document.inputEncoding>);

  @L3Attr:
    @@Name: xmlEncoding
    @@enDesc:
      The encoding of the document, as part of the XML declaration.
    @@Type: DOMString
    @@nullCase:
      @@@enDesc:
        If unspecified or if it is not known, such as when
        the <IF::Document> was created in memory.
    @@Get:
      @@@PerlDef:
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $r,
          $prop => {<H::c|xmlEncoding>},
          $ref => $self,
        }__;
    @@LXSet:
      @@@enDesc:
        The value of the <XA::encoding> declaration.  No lexical
        checking is performed on setting.
      @@@nullCase:
        @@@@enDesc:
          The <XA::encoding> declaration is <EM::not> specified.
      @@@NodeReadOnlyError:
      @@@PerlDef:
        __CODE{tc|NodeReadOnlyError:: $node => $self}__;
        __CODE{mg|setNodeStemPropValue||ManakaiDOM|all::
          $given => $given,
          $prop => {<H::c|xmlEncoding>},
          $ref => $self,
        }__;

    @@Test:
      @@@QName: Document.xmlEncoding.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        $test->id ('initial');
        $test->assert_null ($doc-><AG::Document.xmlEncoding>);

        $test->id ('set');
        $doc-><AS::Document.xmlEncoding> ('utf-8');
        $test->assert_equals ($doc-><AG::Document.xmlEncoding>, 'utf-8');

        $test->id ('reset');
        $doc-><AS::Document.xmlEncoding> (null);
        $test->assert_null ($doc-><AG::Document.xmlEncoding>);

  @L3Attr:
    @@Name: xmlStandalone
    @@enDesc:
      Whether the document is standalone or not, as part of the
      XML declaration.
    @@Type: boolean
    @@TrueCase:
      @@@enDesc:
        If the <XA::standalone> declaration is set to <XML::yes>.
    @@FalseCase:
      @@@enDesc:
        If the <XA::standalone> declaration is set to <XML::no>
        or is unspecified.
    @@Get:
      @@@PerlDef:
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $r,
          $prop => {<H::infoset|standalone>},
          $ref => $self,
        }__;
    @@Set:
      @@@enDesc:
        No verification is performed on the value when setting
        this attribute.
      @@@iRaises:
        @@@@@: MDOMX|MDOM_DOC_NOSUPPORT_XML
        @@@@enDesc:
          If the document does not support the <Feature::XML> feature.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the node is read-only.  <SRC::manakai>
      @@@NodeReadOnlyError:
      @@@PerlDef:
        __CODE{tc|NodeReadOnlyError:: $node => $self}__;
        __CODE{mg|setNodeStemPropValue||ManakaiDOM|all::
          $given => $given,
          $prop => {<H::infoset|standalone>},
          $ref => $self,
        }__;

    @@Test:
      @@@QName: Document.xmlStandalone.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
 
        $test->id ('initial');
        $test->assert_false ($doc-><AG::Document.xmlStandalone>);

        $test->id ('set.yes');
        $doc-><AS::Document.xmlStandalone> (true);
        $test->assert_true ($doc-><AG::Document.xmlStandalone>);

        $test->id ('set.no');
        $doc-><AS::Document.xmlStandalone> (false);
        $test->assert_false ($doc-><AG::Document.xmlStandalone>);

  @L3Method:
    @@Name: adoptNode
    @@enDesc:
      Attempts to adopt a node from another document to this document.
      
      If supported, it changes the <A::Node.ownerDocument> of
      the source node, its children, as well as the attached attribute
      nodes if any.  If the source node has a <A::Node.parentNode>
      it is first removed from the children list of the parent.
      
      This method effectively allowes moving a subtree from one
      document to another, unlike <M::Document.importNode> which
      creates a copy of the source node instead of moving it.
      When it fails, applications should use <M::Document.importNode> instead.

      Note that if the adopted node is already part of this document,
      i.e. the source and target document are the same, this method
      still has the effect of removing the source node from the
      children list of its parent, if any.

        {ISSUE::
          This clause is somewhat unclear.
        }

      - <IF::Attr>::: The <A::Attr.ownerElement> attribute is set to
                      <DOM::null> and the <A::Attr.specified> attribute
                      is set to <DOM::true>.  The descendant nodes
                      are recursively adopted.
      
      - <IF::DocumentFragment>::: The descendant nodes
                      are recursively adopted.

      - <IF::Element>::: All <A::Attr.specified> attributes are adopted.
                      Default attributes are discarded, though if the 
                      target document defines default attributes 
                      for the element type, then those are assigned.
                      The descendant nodes are recursively adopted.

      - <IF::tx|EntityReference>::: Only the node itself is adopted
                      and the descendants are discarded, since the source
                      and target documents might have defined the entity
                      differently.  If the target document provides a
                      definition for the entity name, then its value is
                      assigned.

         {TODO::
           copy-asis
         }

      - <IF::Text>, <IF::tc|Comment>, <IF::tx|CDATASection>,
        <IF::tx|ProcessingInstruction>:::
                      These nodes can be adopted.

      - <IF::Document>, <IF::tx|DocumentType>,
        <IF::tx|Entity>, <IF::tx|Notation>:::
                      These kinds of nodes cannot be adopted.
      
      {NOTE:: Since this method does not create new nodes unlike
              the <M::Document.importNode> method, this method does
              not raise an <X::DOMException.INVALID_CHARACTER_ERR>
              exception and applications should use the 
              <M::Document.normalizeDocument> method to check if
              an imported name is not an XML <CODE::Name> according
              to the XML version in use.
      }    

    @@enDesc:
      @@@ddid: adopt
      @@@enImplNote: Not in spec.
      @@@:
        If an adopted node has user data with handlers being registered,
        those handlers are invoked after the adoption occurred,
        with the <CODE::operation>
        parameter set to <C::c|UserDataHandler.NODE_ADOPTED>,
        <CODE::src> parameter set to the adopted node, and
        the <CODE::dest> parameter set to <DOM::null>.

          {NOTE:: User data handlers are disallowed to throw any
                  exception; if they do, then the result of 
                  the method is implementation dependent.
          }

    @@Param:
      @@@Name: source
      @@@Type: Node
      @@@enDesc:
        The node to move into this document.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The adopted node.
      @@@nullCase:
        @@@@enDesc:
          If the adopting operation fails, such as when the <P::source>
          node comes from a different implementation.
      @@@dx:raises:
        @@@@@: c|ADOPT_NODE_TYPE_NOT_SUPPORTED_ERR
        @@@@enDesc:
          The <P::source> node is of type <IF::Document>,
          <IF::tx|DocumentType> <SRC::DOM3>, <IF::tx|Entity>, or
          <IF::tx|Notation> <SRC::manakai>.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          The <P::source> node is read-only.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_PARENT
        @@@@enDesc:
          The parent or owner element node of the <P::source>
          node is read-only.  <SRC::manakai>
      @@@dx:raises:
        @@@@@: c|NOMOD_DESCENDANT_ERR
        @@@@enDesc:
          One or more descendant or attribute node of the
          <P::source> node is read-only.  <SRC::manakai>
      @@@PerlDef:
        if ($source->isa (<ClassName::tc|ManakaiDOMNode>) and
            <Code::mg|getNodeBag||ManakaiDOM|all:: $ref = $self>
                eq <Code::mg|getNodeBag||ManakaiDOM|all:: $ref = $source>) {
          if ($self-><AG::Node.manakaiReadOnly>) {
            __EXCEPTION{MDOMX|NOMOD_THIS::
              MDOMX|param-name => 'source',
              c|node => $source,
            }__;
          }
          my $parent = $source-><AG::Node.parentNode>;
          if ($parent and $parent-><AG::Node.manakaiReadOnly>) {
            __EXCEPTION{MDOMX|NOMOD_PARENT::
              MDOMX|param-name => 'source',
              c|node => $parent,
            }__;
          }
          my $nt = $source-><AG::Node.nodeType>;
          my $oe;
          if ($nt == <C::Node.ATTRIBUTE_NODE>) {
            $oe = $source-><AG::Attr.ownerElement>;
            if ($oe and $oe-><AG::Node.manakaiReadOnly>) {
              __EXCEPTION{MDOMX|NOMOD_PARENT::
                MDOMX|param-name => 'source', 
                c|node => $oe,
              }__;
            }
          } elsif ($nt == <C::Node.DOCUMENT_NODE> or 
                   $nt == <C::Node.DOCUMENT_TYPE_NODE> or
                   $nt == <C::Node.ENTITY_NODE> or
                   $nt == <C::Node.NOTATION_NODE>) {
            __EXCEPTION{c|ADOPT_NODE_TYPE_NOT_SUPPORTED_ERR::
              MDOMX|param-name => 'source',
              c|node => $source,
            }__;
          }

          my @change_od;
          my @nodes = ($source);
          while (@nodes) {
            my $node = shift @nodes;
            my $nt = $node-><AG::Node.nodeType>;
            if ($node-><AG::Node.manakaiReadOnly>) {
              __EXCEPTION{c|NOMOD_DESCENDANT_ERR::
                MDOMX|param-name => 'source',
                c|node => {$node},
              }__;
            }
            if ($nt == <C::Node.ELEMENT_NODE>) {
              push @change_od, $node;
              push @nodes, @{$node-><AG::Node.childNodes>};
              my $attrs = $node-><AG::Node.attributes>;
              my $attrsLength = $attrs-><AG::NamedNodeMap.length>;
              for my $i (0..($attrsLength - 1)) {
                push @nodes, $attrs-><M::NamedNodeMap.item> ($i);
              }
            } elsif ($nt == <C::Node.ATTRIBUTE_NODE> or
                     $nt == <C::Node.ENTITY_REFERENCE_NODE> or
                     $nt == <C::Node.DOCUMENT_FRAGMENT_NODE>) {
              push @change_od, $node;
              push @nodes, @{$node-><AG::Node.childNodes>};
            } elsif ($nt == <C::Node.TEXT_NODE> or
                     $nt == <C::Node.COMMENT_NODE> or
                     $nt == <C::Node.PROCESSING_INSTRUCTION_NODE> or
                     $nt == <C::Node.CDATA_SECTION_NODE>) {
              push @change_od, $node;
            } else {
              ## TODO: assertion
            }
          } # nodes
          
          if ($parent) {
            __DEEP{
              $parent-><M::Node.removeChild> ($source);
            }__;
          } elsif ($oe) {
            __DEEP{
              $oe-><M::Element.removeAttributeNode> ($source);
            }__;
          }

          my $old_od = $change_od[0]-><AG::Node.ownerDocument>;
                         ## NOTE: The array must have more than zero
                         ##       nodes by definition.  In addition,
                         ##       it cannot contain document or document
                         ##       type nodes in current implementation.
          my $old_od_list;
          __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
            $r => $old_od_list,
            $prop => {<H::tc|revOwnerDocument>},
            $ref => $old_od,
          }__;
          my $new_od_list;
          __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
            $r => $new_od_list,
            $prop => {<H::tc|revOwnerDocument>},
            $ref => $self,
          }__;
          for my $n (@change_od) {
            __CODE{mg|setNodeStemProp0Node||ManakaiDOM|all::
              $prop => {<H::tc|ownerDocument>},
              $ref => $n,
              $given => $self,
            }__;
            my $nid = <Code::mg|getNodeID||ManakaiDOM|all:: $ref = $n>;
            CORE::delete $old_od_list->{$$nid};
            $new_od_list->{$$nid} = $nid;
          }

          for my $src (@change_od) {
            my $src_ud;
            __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
              $r => $src_ud,
              $prop => {<H::t|userData>},
              $ref => $src,
            }__;
            for my $key (keys %{$src_ud or {}}) {
              my $dh = $src_ud->{$key}->[1];
              if ($dh) {
                $dh-><M::c|UserDataHandler.handle>
                         (<C::c|UserDataHandler.NODE_ADOPTED>,
                          $key, $src_ud->{$key}->[0], $src, null);
              }
            }
          }
          $r = $source;
        } # compatible class

      @@@enImplNote:
        The order in which handlers are invoked when multiple
        nodes are adopted is undefined.  Called just after the adoption
        or after all nodes are adopted is also unspecified.

        Is is invoked even if <A::Node.ownerDocument> is unchanged?

    @@Test:
      @@@QName: Node.adoptNode.1.test
      @@@PerlDef:
        my $impl;
        __CODE{tc|createImplForTest:: $impl => $impl}__;

        my $doc1 = $impl-><M::c|DOMImplementation.createDocument>;

        my $doc2 = $impl-><M::c|DOMImplementation.createDocument>;

        my $el1 = $doc1-><M::Document.createElementNS> (null, 'e');
     
        my $el2 = $doc2-><M::Document.adoptNode> ($el1);

        $test->id ('same');
        $test->assert_equals ($el2, $el1);
 
        $test->id ('ownerDocument');
        $test->assert_equals ($el2-><AG::Node.ownerDocument>, $doc2);

    @@L3Test:
      @@@QName: Node.adoptNode.UserDataHandler.Test
      @@@PerlDef:
        my $impl;
        __CODE{tc|createImplForTest:: $impl => $impl}__;

        my $doc = $impl-><M::c|DOMImplementation.createDocument>
                              ('http://www.example/', 'ex');
        my $node = $doc-><AG::Document.documentElement>;

        $test->set_test_data (node => $node);
          ## This registration prevents the user data handler
          ## being called when a test fails so that the |$node|
          ## is being destructed (|NODE_DELETED|).

        my $doc2 = $impl-><M::c|DOMImplementation.createDocument>;

        my $udh_called = false;

        $node-><M::Node.setUserData> ('key' => {}, sub {
          my ($self, $op, $key, $data, $src, $dest) = @_;
          $udh_called = true;

          $test->assert_equals ($op, <C::c|UserDataHandler.NODE_ADOPTED>);
          $test->assert_equals ($key, 'key');
          $test->assert_equals (ref $data, 'HASH');
          $test->assert_not_null ($src);
          $test->assert_equals ($src-><AG::Node.localName>, 'ex');
          $test->assert_null ($dest);
        });

        $node = $doc2-><M::Document.adoptNode> ($node);

        $test->id ('udh.called');
        $test->assert_true ($udh_called);

        $node-><M::Node.setUserData> ('key', null, null);
        $test->set_test_data (node => null);

  @L2Method:
    @@Name: getElementById
    @@enDesc:
      Returns the <IF::Element> that has an <XML::ID> attribute
      with the given value.

      The implementation is expected to use the attribute <A::Attr.isId>
      to determine if an attribute is of type <XML::ID>.  <SRC::DOM3>
    @@Param:
      @@@Name: elementId
      @@@Type: DOMString
      @@@enDesc:
        The unique identifier value for an element.
    @@Return:
      @@@Type: Element
      @@@enDesc:
        The matching element.

        If more than one element has an <XML::ID> attribute
        with that value, what is returned is undefined.
      @@@nullCase:
        @@@@enDesc:
          If no such element exists.
      @@@enImplNote:
        Can an <IF::Element> that is not a descendant of the <IF::Document> 
        be returned?

        This method was first defined in the interface <IF::HTMLDocument> 
        in the DOM Level 1.

        {TODO::
          Use hash table as in Web browsers.
        }
      @@@PerlDef:
        __DEEP{
          my @nodes = @{$self-><AG::Node.childNodes>};
          N: while (@nodes) {
            my $node = shift @nodes;
            next N unless $node-><AG::Node.nodeType> == <C::Node.ELEMENT_NODE>;
            for my $attr (@{$node-><AG::Node.attributes>}) {
              if ($attr-><AG::Attr.isId> and
                  $attr-><AG::Attr.value> eq $elementId) {
                $r = $attr;
                last N;
              }
            }
            unshift @nodes, @{$node-><AG::Node.childNodes>};
          } # N
        }__;

  @Method:
    @@Name: getElementsByTagName
    @@enDesc:
      Returns a <IF::NodeList> of all the <IF::Element>s in
      document order with a given tag name and are contained
      in the document.
    @@enImplNote:
         Does <QUOTE::contained> mean that an <IF::Element> node 
         which is not a descendant of the <IF::Document> does not match?
       \
         The DOM Level 2 Specification specifies as <QUOTE::pre-order 
         traversal>.  The DOM Level 3 Specifies it by 
         <QUOTE::in document order> and this makes the ambigiousness.
       \
         Should <IF::Element> nodes in <IF::tx|Entity> nodes be matched?
    @@NSVersion: .getElementsByTagNameNS
    @@Param:
      @@@Name: tagname
      @@@DISPerl:paramName: name
      @@@Type: DOMString
      @@@enDesc:
        The name of the tag to match on.

        For XML the <P::tagname> parameter is case-sensitive.

        In other markup languages it depends on the case-sensitivity
        of the markup language in use.
      @@@InCase:
        @@@@Value:
          @@@@@@: *
          @@@@@ContentType: DISCore|String
        @@@@enDesc:
          Matches all tags.
    @@Return:
      @@@Type: NodeList
      @@@enDesc:
        A <IF::NodeList> object containing all the matched
        <IF::Element>s.
      @@@disDef:
        @@@@DISPerl:cloneCode: te|ManakaiDOMElement.getElementsByTagName

  @L2Method:
    @@Name: getElementsByTagNameNS
    @@enDesc:
      Returns a <IF::NodeList> of all the <IF::Element>s with
      a given namespace URI and local name in document order.
    @@enImplNote:
      Pre-order traversal <SRC::DOM2> or document order <SRC::DOM3>.
    @@NoNSVersion: .getElementsByTagName
    @@Param:
      @@@Name: namespaceURI
      @@@Type: DOMString
      @@@dis:actualType: ManakaiDOM|ManakaiDOMNamespaceURI
      @@@enDesc:
        The namespace URI of the element to match on.
      @@@InCase:
        @@@@Value:
          @@@@@@: *
          @@@@@ContentType: DISCore|String
        @@@@enDesc:
          Matches all namespaces.
    @@Param:
      @@@Name: localName
      @@@Type: DOMString
      @@@enDesc:
        The local name of the elements to match on.
      @@@InCase:
        @@@@Value:
          @@@@@@: *
          @@@@@ContentType: DISCore|String
        @@@@enDesc:
          Matches all local names.
    @@Return:
      @@@Type: NodeList
      @@@enDesc:
        A new <IF::NodeList> object containing all the matched
        <IF::Element>s.
      @@@iRaises:
        @@@@@: MDOMX|MDOM_DOC_NOSUPPORT_XML
        @@@@enDesc:
          If the document does not support the <Feature::XML> feature.
          <SRC::manakai>
      @@@disDef:
        @@@@DISPerl:cloneCode: te|ManakaiDOMElement.getElementsByTagNameNS

  @L2Method:
    @@Name: importNode

     @@Description:
       @@@lang:en
       @@@@:
         Import a node from another document to this document, 
         without altering or removing the source node from 
         the original document (i.e. create a new copy of 
         the source node in this document).
     @@ImplNote:
       @@@lang:en
       @@@@:
         Copied: <A::Node.nodeName>, <A::Node.nodeType>, <A::Node.prefix>, 
         <A::Node.localName>, <A::Node.namespaceURI>, <A::tx|Entity.publicId>, 
         <A::tx|Entity.systemId>, <A::tx|Entity.notationName>, 
         <A::Notation.publicId>, <A::Notation.systemId>, 
         <A::ProcessingInstruction.target>, <A::ProcessingInstruction.data>, 
         <A::tc|CharacterData.data>, <A::tc|CharacterData.length>.
       \
         User data is not carried over.  However, if any 
         <IF::UserDataHandler>s has specified, these handlers will 
         be called with the appropriate parameters before this method 
         returns.
       \
         <A::Node.parentNode> := <DOM::null>.
         <A::Attr.ownerElement> := <DOM::null>. 
         <A::Attr.specified> := <DOM::true>.
         Specified attribute nodes attached to the <IF::Element> node 
         are imported.  Default attributes are created if exists.
     @@Param:
        @@@Name:  importedNode
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@:
            The node to import.
            \
            Note that <IF::Document> or <IF::tx|DocumentType> nodes cannot 
            be imported.
     @@Param:
        @@@Name:  deep
        @@@Type:  DOMMain|boolean||ManakaiDOM|all
        @@@Description:
          @@@@lang:en
          @@@@@:
            Whether the subtree under the <P::importedNode> 
            is recursively imported or not.
            \
            This parameter has no effect on <IF::Attr>,
            <IF::tx|EntityReference>, 
            <IF::tx|Notation>, <IF::tx|ProcessingInstruction>,
            <IF::Text>, 
            <IF::tx|CDATASection> and <IF::tc|Comment> nodes.
            The descendants of 
            the <IF::Attr> node are 
            always imported.  The descendants of the
            <IF::tx|EntityReference> 
            node are always not imported.
        @@@InCase:
          @@@@Value:true
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The descendants are recursively imported if the 
              <P::importedNode> is of <IF::DocumentFragment>, <IF::Element> or 
              <IF::tx|Entity>.
        @@@InCase:
          @@@@Value:false
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Import only the node itself.
     @@Return:
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@:
            The imported node.
#        @@@Exception:
#          @@@@Type:DOMException
#          @@@@Name:NOT_SUPPORTED_ERR
#          @@@@Description:
#            @@@@@lang:en
#            @@@@@@:
#              The type of node being imported is not supported.
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              Maybe, if this document is not <Feature::XML> and 
              the node type is either <IF::tx|ProcessingInstruction>, 
              <IF::tx|Notation>, <IF::tx|EntityReference>,
              <IF::tx|Entity> or 
              <IF::tx|CDATASection>.  And if namespaced nodes are imported?
#        @@@Exception:
#          @@@@Type:DOMException
#          @@@@Name:INVALID_CHARACTER_ERR
#          @@@@SubType:
#            @@@@@QName:
#              MDOMX:MDOM_BAD_NAME
#            @@@@@Description:
#              @@@@@@lang:en
#              @@@@@@@:
#                One of the imported names is not a SGML or XML <CODE::Name>.

  @L3Method:
    @@Name: normalizeDocument
     @@Description:
       @@@lang:en
       @@@@:
         Act as if the document was going through a save and 
         load cycle, putting the document in a "normal" form.
       \
         - Update the replacement tree of <IF::tx|EntityReference> nodes.
       \
         - Normalize <IF::Text> nodes, as the method <M::Node.normalize> does.
       \
         - Other normalization specified by the <A::Document.domConfig>.
       \
         Mutation events, when supported, are generated to reflect  
         the changes occuring on the document.
       \
         If errors occur, such as an attempt to update a read-only 
         node or a <A::Node.nodeName> contains an invalid character, 
         (fatal and non-fatal) errors and warnings will be reported using 
         the <IF::DOMErrorHandler> object associated with the 
         <DOM::error-handler> parameter.
     @@Return:
      @@@c:reports:
        @@@@@: c|check-character-normalization-failure
        @@@@enDesc:
          If the <cfg::c|check-character-normalization> configuration
          parameter is set to <DOM::true> and a sequence of characters
          is encountered that fails normalization checking.
      @@@c:reports:
        @@@@@: c|cdata-sections-splitted
        @@@@enDesc:
          If the <cfg::c|split-cdata-sections> configuration parameter
          is set to <DOM::true> and a <XML::CDATA> section
          is split.
      @@@c:reports:
        @@@@@: c|wf-invalid-character-in-node-name
        @@@@enDesc:
          If the <cfg::c|well-formed> configuration parameter is set to 
          <DOM::true> and a <A::Node.nodeName> contains invalid character
          according to its node type.
      @@@c:reports:
        @@@@@: c|wf-invalid-character
        @@@@enDesc:
          If the <cfg::c|well-formed> configuration parameter is set to
          <DOM::true> and the text content inside <IF::Attr>, <IF::Element>,
          <IF::tc|Comment>, <IF::Text>, or <IF::tx|CDATASection> node
          or the data inside <IF::tx|ProcessingInstruction> node
          contains invalid characters.

  @L3Method:
    @@Name: renameNode
    @@enDesc:
      Renames an <IF::Element> or <IF::Attr> node.

      When possible, this simple changes the name of the
      given node.  Otherwise, this creates a new node with the
      specified name and replaces the existing node with the new node.

      If the renamed node is an <IF::Element>, only the <A::Attr.specified>
      attributes are moved; default attributes originated from the DTD
      are updated according to the new element type name.  In addition,
      the implementation may update default attributes from other schemas.

        {NOTE:: Applications should use <M::Document.normalizeDocument>
                to guarantee those attributes are up-to-date after
                renaming.
        }

      If the renamed node is an <IF::Attr> attached to <IF::Element>, 
      the node is first removed from the owner <IF::Element>'s attribute
      map.  Then, once renamed, it is put back.

      In addition, a user data event <C::c|UserDataHandler.NODE_RENAMED>
      is fired if there are user data handlers registered to the node.
      When the implementation supports the feature <Feature::MutationNameEvents>,
      each mutation operation involved in the method fires the appropriate
      event, and in the end the event <EV::ev|DOMElementNameChanged>
      or <EV::ev|DOMAttributeNameChanged> is fired.

    @@DOMMain:isNamespaceAware:1
    @@enImplNote:
      {P:: If simple changing is impossible:
 
           = Creates a new node.
 
           = Registers any registered event listener on the new node.

           = Removes any user data attached to the old node.

           = Removes the old node from its parent, if any.

           = Moves the children of the old node to the new node.

           = Inserts the new node at the position the old node used to have
             in its parent's child node list if it has one.

           = Attaches the user data that was attached to the old node.

      }

    @@Param:
      @@@Name: n
      @@@Type: Node
      @@@enDesc:
        The node to rename.
    @@Param:
      @@@Name: namespaceURI
      @@@Type: DOMMain|DOMString
      @@@dis:actualType: ManakaiDOM|ManakaiDOMNamespaceURI
      @@@enDesc:
        The new namespace URI.
      @@@nullCase:
        @@@@enDesc:
          The new name does not belong to any namespace.
    @@Param:
      @@@Name: qualifiedName
      @@@Type: DOMMain|DOMString
      @@@enDesc:
        The new qualified name.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The rename node.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_IMPL_NOSUPPORT_XMLNS
        @@@@enDesc:
          If the DOM implementation does not support the <DOM::XML> feature
          and the language exposed through the <IF::Document>
          object does not support XML Namespaces.
        @@@@For: !ManakaiDOM|DOMXMLFeature ManakaiDOM|ManakaiDOM
      @@@dx:raises:
        @@@@@: c|RENAME_NODE_TYPE_NOT_SUPPORTED_ERR
        @@@@enDesc:
          If the type of the <P::n> is neither <C::Node.ELEMENT_NODE>
          nor <C::Node.ATTRIBUTE_NODE>.
        @@@@enDesc:
          @@@@@ddid: nonns
          @@@@@For: ManakaiDOM|ManakaiDOM
          @@@@@@:
            Or, if the <P::n> does not support namespace since
            it is created by DOM Level 1 method or does not support
            the <Feature::XML> feature.
      @@@dx:raises:
        @@@@@: c|RENAME_DOCUMENT_ELEMENT_NOT_SUPPORTED_ERR
        @@@@enDesc:
          If the <P::n> is the document element and the implementation
          does not support the renaming of the document element.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_BAD_NAME
        @@@@enDesc:
          If the <P::qualifiedName> is not an XML <CODE::Name> according
          to the XML version in use (<A::Document.xmlVersion>).
      @@@dx:raises:
        @@@@@: c|MDOMX_EXTERNAL_NODE
        @@@@enDesc:
          If the <P::n> was created from a different document than
          the document.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_NS_MALFORMED_QNAME
        @@@@enDesc:
          If the <P::qualifiedName> is a malformed qualified name.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_NS_PREFIX_WITH_NULL_URI
        @@@@enDesc:
          If the <P::qualifiedName> has a prefix and the 
          <P::namespaceURI> is <DOM::null>.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_NS_XML_WITH_OTHER_URI
        @@@@enDesc:
          If the <P::qualifiedName> has a prefix that is <XML::xml>
          and the <P::namespaceURI> is different from 
          <URI::http://www.w3.org/XML/1998/namespace>.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_NS_XMLNSQ_WITH_OTHER_URI
        @@@@enDesc:
          If the <P::n> is an attribute node and the <P::qualifiedName> 
          is <XA::xmlns> and the <P::namespaceURI> is different from
          <URI::http://www.w3.org/2000/xmlns/>.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_NS_XMLNS_WITH_OTHER_URI
        @@@@enDesc:
          If the <P::n> is an attribute node and the <P::qualifiedName>
          has a prefix that is <XML::xmlns> and the <P::namespaceURI>
          is different from <URI::http://www.w3.org/2000/xmlns/>.
      @@@enImplNote:
        These exception cases from DOM Level 3 spec do not cover all.
      @@@enImplNote:
        What would happen if a non-XML or non-namespace-aware node
        is being renamed?

  @LXAttr:
    @@Name: manakaiEntityBaseURI
    @@enDesc:
      The base URI of the document entity.

        {NOTE::
          This attribute is a manakai extension.
        }
    @@Type: DOMString
    @@Get:
      @@@enDesc:
        The base DOM URI of the document entity.  It is equal to
        the <A::Node.baseURI> value if there is no <HE::base> element.
      @@@nullCase:
        @@@@enDesc:
          If no base DOM URI is available.
      @@@PerlDef:
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $r,
          $prop => {<H::infoset|baseURI>},
          $ref => $self,
        }__;
        unless (defined $r) {
          __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
            $r => $r,
            $prop => {<H::c|documentURI>},
            $ref => $self,
          }__;
        }
    @@Set:
      @@@enDesc:
        Sets the base DOM URI of the document entity.  It <kwd:MUST>
        be an absolute DOM URI; however, no lexical checking is performed
        on setting.
      @@@nullCase:
        @@@@enDesc:
          The base DOM URI of the document entity, if available, is unset.
          Note that it does not affect to <A::Document.documentURI>.
      @@@NodeReadOnlyError:
      @@@PerlDef:
        __CODE{tc|NodeReadOnlyError:: $node => $self}__;
        __CODE{mg|setNodeStemPropValue||ManakaiDOM|all::
          $given => $given,
          $prop => {<H::infoset|baseURI>},
          $ref => $self,
        }__;

  @LXAttr:
    @@Name: allDeclarationsProcessed
    @@enDesc:
      Whether the XML processor has read the complete DTD when the
      XML document is parsed.  This attribute corresponding to
      the <InfoProp::all declarations processed> property of
      the <InfoItem::document information item> in the XML Information Set.

        {NOTE::
          This attribute only exposes the information set property.
          Its value does <EM::not> indicate whether the document
          is <QUOTE::complete> or not, or valid or not.  In particular,
          modifications to the DOM tree does not affect the
          value of this attribute.
        }
    @@enImplNote:
      {ISSUE::
        Interaction between <M::Document.normalizeDocument> and this attribute
      }
    @@Type: boolean
    @@TrueCase:
      @@@enDesc:
        The <InfoProp::all declarations processed> property is
        true.
    @@FalseCase:
      @@@enDesc:
        The <InfoProp::all declarations processed> property is <EM::not>
        true.
    @@Get:
      @@@PerlDef:
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $r,
          $prop => {<H::infoset|allDeclarationsProcessed>},
          $ref => $self,
        }__;
    @@Set:
      @@@NodeReadOnlyError:
      @@@PerlDef:
        __CODE{tc|NodeReadOnlyError:: $node => $self}__;
        __CODE{mg|setNodeStemPropValue||ManakaiDOM|all::
          $given => $given,
          $prop => {<H::infoset|allDeclarationsProcessed>},
          $ref => $self,
        }__;
    @@LXTest:
      @@@QName: Document.allDeclarationsProcessed.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        $test->id ('default');
        $test->assert_false ($doc-><AG::Document.allDeclarationsProcessed>);

        $test->id ('set.true');
        $doc-><AS::Document.allDeclarationsProcessed> (true);
        $test->assert_true ($doc-><AG::Document.allDeclarationsProcessed>);

        $test->id ('set.false');
        $doc-><AS::Document.allDeclarationsProcessed> (false);
        $test->assert_false ($doc-><AG::Document.allDeclarationsProcessed>);
##Document

ElementTypeBinding:
  @Name: iRaises
  @ElementType:
    dx:raises
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForIF

ElementTypeBinding:
  @Name: UnlessStrictErrorChecking
  @ElementType:
    dis:Description
  @ShadowContent:
    @@ddid: unlessStrictErrorChecking
    @@For: ManakaiDOM|ManakaiDOM3
    @@@:
      In manakai implementation, this exception is not thrown
      when <A::Document.strictErrorChecking> attribute is set to
      <DOM::false>.

ElementTypeBinding:
  @Name: enDesc
  @ElementType:
    dis:Description
  @ShadowContent:
    @@lang:en


ElementTypeBinding:
  @Name: NodeReadOnlyError
  @ElementType:
    dx:raises
  @ShadowContent:
    @@@: MDOMX|NOMOD_THIS
    @@Description:
      @@@lang:en
      @@@@:
        The node is read-only.

ElementTypeBinding:
  @Name: TrueCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType:
      ManakaiDOM:InCase
    @@Value:
      @@@@: 1
      @@@ContentType: DISCore|Boolean
    @@Type: idl|boolean||ManakaiDOM|all

ElementTypeBinding:
  @Name: FalseCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType:
      ManakaiDOM:InCase
    @@Value:
      @@@@: 0
      @@@ContentType: DISCore|Boolean
    @@Type: idl|boolean||ManakaiDOM|all

NodeTypeDef:
  @IFQName: DocumentFragment
  @ClsQName: ManakaiDOMDocumentFragment

  @DISLang:role: tc|DocumentFragmentRole
  
  @enDesc:
    The <IF::DocumentFragment> interface is originally designed
    as a <QUOTE::lightweight> or <QUOTE::minimum> <IF::Document> object.
    It is useful to extract a portion of a document tree or to
    create a new fragment of a document, for the purposes of e.g.
    implementing a command like cut or rearranging a document
    by moving fragments around.  While a <IF::Document> object could
    fulfill this role, a <IF::Document> object can potentially
    be a heavyweight object, depending on the undelying implementation.
  
    Furthrmore, various operations, such as inserting nodes as
    cildren of another <IF::Node>, may take <IF::DocumentFragment>
    nodes as arguments; this result in all the child nodes of the
    <IF::DocumentFragment> node being moved to the child list
    of that node.

    The children of a <IF::DocumentFragment> node are zero or more
    nodes representing the tops of any subtrees defining the
    structure of the document.  A <IF::DocumentFragment> node
    does not need to represent a well-formed XML document.  For
    example, a <IF::DocumentFragment> node might have only one
    child node and that child node could be a <IF::Text? node.

  @IntMethod:
    @@Operator: mg|CreateNodeStemMethod
    @@Param:
      @@@Name: bag
      @@@Type: HASH
    @@Param:
      @@@Name: obj
      @@@Type: HASH
    @@Param:
      @@@Name: opt
      @@@Type: HASH
    @@Return:
      @@@Type: HASH
      @@@PerlDef:
        $obj->{<H::infoset|children>} = [];
        __CODE{mg|setOwnerProp||ManakaiDOM|all::
          $bag => $bag,
          $ownerref => {$opt->{<H::tc|ownerDocument>}},
          $ownee1hprop => {<H::tc|revOwnerDocument>},
          $ownee => {$obj},
          $owner0prop => {<H::tc|ownerDocument>},
        }__;
        $r = $obj;
  @mg:subnode1a: infoset|children
  @mg:owner0: tc|ownerDocument
  @enImplNote:
    @@ddid: props
    @@@:
      {P:: Required internal properties:

        - <Q::tc|ownerDocument>.

        - <Q::infoset|children>.

      }

      {P:: Optional internal properties:

        - <Q::c|read-only>.

      }


  @CODE:
    @@QName: tc|createDFForTest
    @@PerlDef:
      my $__doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $__doc}__;
      $df = $__doc-><M::Document.createDocumentFragment>;

  @CAttr:
    @@Name: nodeType
    @@Type: unsignedShort
    @@dis:actualType: NodeType
    @@Get:
      @@@disDef:
        @@@@DISLang:constValue: Node.DOCUMENT_FRAGMENT_NODE

    @@Test:
      @@@QName: DF.nodeType.test
      @@@PerlDef:
        my $df;
        __CODE{tc|createDFForTest:: $df => $df}__;

        $test->id ('nodeType');
        $test->assert_num_equals
                 (actual_value => $df-><AG::Node.nodeType>,
                  expected_value => <C::Node.DOCUMENT_FRAGMENT_NODE>);

  @Test:
    @@QName: DF.parentNode.1.test
    @@PerlDef:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

      my $df = $doc-><M::Document.createDocumentFragment>;

      $test->assert_null ($df-><AG::Node.parentNode>);

  @Test:
    @@QName: DF.isSameNode.1.test
    @@PerlDef:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

      my $el = $doc-><M::Document.createDocumentFragment>;

      my $el2 = $doc-><M::Document.createDocumentFragment>;
      
      $test->id ('same');
      $test->assert_equals ($el, $el);
      
      $test->id ('diff');
      $test->assert_not_equals ($el, $el2);
      
      $test->id ('doc');
      $test->assert_not_equals ($el, $doc);
  @Test:
    @@QName: DF.isSameNode.2.test
    @@PerlDef:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

      my $el = $doc-><M::Document.createDocumentFragment>;

      my $el2 = $doc-><M::Document.createDocumentFragment>;
      
      $test->id ('same');
      $test->assert_true ($el-><M::Node.isSameNode> ($el));
      
      $test->id ('diff');
      $test->assert_false ($el-><M::Node.isSameNode> ($el2));
      
      $test->id ('doc');
      $test->assert_false ($el-><M::Node.isSameNode> ($doc));

  @LXTest:
    @@QName: DF.readOnly.test
    @@PerlDef:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

      my $el = $doc-><M::Document.createDocumentFragment>;

      $test->id ('default');
      $test->assert_false ($el-><AG::Node.manakaiReadOnly>);

  @CMethod:
    @@Name: appendChild
    @@enDesc:
      Adds a node to the end of the list of children of the node.
      If that node is already in the tree, it is first removed.
    @@Param:
      @@@Name: newChild
      @@@Type: Node
      @@@enDesc:
        The node to add.
      @@@InCase:
        @@@@Type: DocumentFragment
        @@@@enDesc:
          The entire contents of the document fragment are
          moved into the child list of the node.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node added.  If the <P::newChild> node is a <IF::DocumentFragment>
        node, then the <P::newChild> node <kwd:MUST> be returned.
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_BAD_TYPE
        @@@@enDesc:
          If the node is of a type that does not allow children of
          the type of the <P::newChild> node.
 
          If the <A::Document.strictErrorChecking> is set to <DOM::false>,
          this exception <kwd:MAY-NOT> be thrown.
      @@@dx:raises:
        @@@@@: c|DIFFERENT_DOCUMENT_ERR
        @@@@enDesc:
          If the <P::newChild> node was created from a different
          document than the one to which the node was created or
          the node does not belong to any document.

          If the <A::Document.strictErrorChecking> is set to <DOM::false>,
          this exception <kwd:MAY-NOT> be thrown.
      @@@dx:raises: 
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the node is read-only.

          If the <A::Document.strictErrorChecking> is set to <DOM::false>,
          this exception <kwd:MAY-NOT> be thrown.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_SRC_PARENT
        @@@@enDesc:
          If the previous parent of the <P::newChild> node is read-only
          <SRC::DOM 2 Errata, DOM 3>.

          If the <A::Document.strictErrorChecking> is set to <DOM::false>,
          this exception <kwd:MAY-NOT> be thrown.
      @@@dx:raises:
        @@@@@: t|HIERARCHY_DOCUMENT_FRAGMENT_ITSELF_ERR
        @@@@enDesc:
          If <P::newChild> is the node itself.
        @@@@For: ManakaiDOM|ManakaiDOM
      @@@PerlDef:
        if ($self eq $newChild) {
          __EXCEPTION{t|HIERARCHY_DOCUMENT_FRAGMENT_ITSELF_ERR::
            MDOMX|param-name => 'newChild',
          }__;
        }
        my $self_od = $self-><AG::Node.ownerDocument>;
        my $child_od = $newChild-><AG::Node.ownerDocument>;
        my $child_nt = $newChild-><AG::Node.nodeType>;
        __CODE{tc|appendChildImpl1::
          $self => $self, $self_od => $self_od,
          $newChild => $newChild, $child_od => $child_od, $child_nt => $child_nt,
          $r => $r,
          $allowedNodeTypes => {{
            <C::Node.TEXT_NODE> => true,
            <C::Node.ENTITY_REFERENCE_NODE> => true,
            <C::Node.ELEMENT_NODE> => true,
            <C::Node.PROCESSING_INSTRUCTION_NODE> => true,
            <C::Node.CDATA_SECTION_NODE> => true,
            <C::Node.COMMENT_NODE> => true,
          }},
        }__;

  @CMethod:
    @@Name: insertBefore
    @@enDesc:
      Inserts a node before the existing child node of the node.

      Inserting a node before itself is implementation dependent.
    @@Param:
      @@@Name: newChild
      @@@Type: Node
      @@@enDesc:
        The node to insert.  If the <P::newChild> is already in 
        the tree, it is first removed.
      @@@InCase:
        @@@@Type: DocumentFragment
        @@@@enDesc:
          All of children of the <P::newChild> node are inserted,
          in the same order, before <P::refChild>.
    @@Param:
      @@@Name: refChild
      @@@Type: Node
      @@@enDesc:
        The reference node, i.e. the node before which the new node
        must be inserted.
      @@@nullCase:
        @@@@enDesc:
          The <P::newChild> node is inserted at the end of the list
          of children.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node being inserted.
      @@@enImplNote:
        What is returned if <P::newChild> is a <IF::DocumentFragment>?
        See also <M::Node.appendChild>'s return value.
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_BAD_TYPE
        @@@@enDesc:
          If the node is of a type that does not allow children of
          the type of the <P::newChild> node.
      @@@dx:raises:
        @@@@@: c|DIFFERENT_DOCUMENT_ERR
        @@@@enDesc:
          If the <P::newChild> node was created from a different
          document than the one that created the node.
        @@@@enImplNote:
          The DOM specification ignores the fact that <IF::Document>s
          and <IF::tx|DocumentType>s are created from 
          <IF::c|DOMImplementation> :-)
      @@@dx:raises: 
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the node is read-only.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_SRC_PARENT
        @@@@enDesc:
          If the previous parent of the <P::newChild> node is read-only
          <SRC::DOM 1 SE, DOM 2, 3>.
      @@@dx:raises:
        @@@@@: c|NOT_CHILD_ERR
        @@@@enDesc:
          If the <P::refChild> node is not a child of the node.
      @@@c:reports:
        @@@@@: t|insert-before-itself
        @@@@enDesc:
          If the <P::newChild> node is same as the <P::refChild> node.
          Then, the result is implementation dependent.
        @@@@For: ManakaiDOM|ManakaiDOM
      @@@dx:raises:
        @@@@@: t|HIERARCHY_DOCUMENT_FRAGMENT_ITSELF_ERR
        @@@@enDesc:
          If <P::newChild> is the node itself.
        @@@@For: ManakaiDOM|ManakaiDOM
      @@@PerlDef:
        if ($self eq $newChild) {
          __EXCEPTION{t|HIERARCHY_DOCUMENT_FRAGMENT_ITSELF_ERR::
            MDOMX|param-name => 'newChild',
          }__;
        }
        my $self_od = $self-><AG::Node.ownerDocument>;
        my $child_od = $newChild-><AG::Node.ownerDocument>;
        my $child_nt = $newChild-><AG::Node.nodeType>;
        __CODE{tc|insertBeforeImpl1::
          $self => $self, $self_od => $self_od,
          $newChild => $newChild, $refChild => $refChild,
          $child_od => $child_od, $child_nt => $child_nt,
          $r => $r,
          $allowedNodeTypes => {{
            <C::Node.TEXT_NODE> => true,
            <C::Node.ENTITY_REFERENCE_NODE> => true,
            <C::Node.ELEMENT_NODE> => true,
            <C::Node.PROCESSING_INSTRUCTION_NODE> => true,
            <C::Node.CDATA_SECTION_NODE> => true,
            <C::Node.COMMENT_NODE> => true,
          }},
        }__;

  @CMethod:
    @@Name: replaceChild
    @@enDesc:
      Replaces a child node with another node.

      Replacing a node with itself is implementation dependent <SRC::DOM3>.
    @@Param:
      @@@Name: newChild
      @@@Type: Node
      @@@enDesc:
        The new node to put in the child list.

        If the <P::newChild> node is already in the tree,
        it is first removed.
      @@@InCase:
        @@@@Type: DocumentFragment
        @@@@enDesc:
          The <P::oldChild> node is replaced by all of the 
          <IF::DocumentFragment> children, which are inserted
          in the same order <SRC::DOM1 SE, DOM2, DOM3>.
    @@Param:
      @@@Name: oldChild
      @@@Type: Node
      @@@enDesc:
        The node being replaced in the list.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node replaced.
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_BAD_TYPE
        @@@@enDesc:
          If the node is of a type that does not allow children of
          the type of the <P::newChild> node.
      @@@dx:raises:
        @@@@@: c|DIFFERENT_DOCUMENT_ERR
        @@@@enDesc:
          If the <P::newChild> node was created from a different
          document than the one that created the node.
        @@@@enImplNote:
          The DOM specification ignores the fact that <IF::Document>s
          and <IF::tx|DocumentType>s are created from 
          <IF::c|DOMImplementation> :-)
      @@@dx:raises: 
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the node is read-only.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_SRC_PARENT
        @@@@enDesc:
          If the previous parent of the <P::newChild> node is read-only
          <SRC::DOM1 SE, DOM2, DOM3>.
      @@@dx:raises:
        @@@@@: c|NOT_CHILD_ERR
        @@@@enDesc:
          If the <P::oldChild> node is not a child of the node.
      @@@c:reports:
        @@@@@: t|replaced-by-itself
        @@@@enDesc:
          If the <P::newChild> node is same as the <P::oldChild> node.
          Then, the result is implementation dependent.
        @@@@For: ManakaiDOM|ManakaiDOM
      @@@dx:raises:
        @@@@@: t|HIERARCHY_DOCUMENT_FRAGMENT_ITSELF_ERR
        @@@@enDesc:
          If <P::newChild> is the node itself.
        @@@@For: ManakaiDOM|ManakaiDOM
      @@@PerlDef:
        if ($self eq $newChild) {
          __EXCEPTION{t|HIERARCHY_DOCUMENT_FRAGMENT_ITSELF_ERR::
            MDOMX|param-name => 'newChild',
          }__;
        }
        my $self_od = $self-><AG::Node.ownerDocument>;
        my $child_od = $newChild-><AG::Node.ownerDocument>;
        my $child_nt = $newChild-><AG::Node.nodeType>;
        __CODE{tc|replaceChildImpl1::
          $self => $self, $self_od => $self_od,
          $newChild => $newChild, $refChild => $oldChild,
          $child_od => $child_od, $child_nt => $child_nt,
          $r => $r,
          $allowedNodeTypes => {{
            <C::Node.TEXT_NODE> => true,
            <C::Node.ENTITY_REFERENCE_NODE> => true,
            <C::Node.ELEMENT_NODE> => true,
            <C::Node.PROCESSING_INSTRUCTION_NODE> => true,
            <C::Node.CDATA_SECTION_NODE> => true,
            <C::Node.COMMENT_NODE> => true,
          }},
        }__;

  @Test:
    @@QName: DF.attributes.test
    @@PerlDef:
      my $text;
      __CODE{tc|createDFForTest:: $df => $text}__;

      $test->assert_null ($text-><AG::Node.attributes>);

  @CAttr:
    @@Name: nodeName
    @@enDesc:
      The node name.
    @@DOMMain:isNamespaceUnaware:1
    @@Type: DOMString
    @@Get:
      @@@disDef:
        @@@@DISLang:value:
          @@@@@@: \#document-fragment
          @@@@@ContentType:
            DISCore:String

    @@Test:
      @@@QName: DF.nodeName.test
      @@@PerlDef:
        my $text;
        __CODE{tc|createDFForTest:: $df => $text}__;

        $test->assert_equals ($text-><AG::Node.nodeName>,
                              '#document-fragment');

    @@Test:
      @@@QName: DF.appendChild.1.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createTextNode> ('pi');

        my $return = $dtd-><M::Node.appendChild> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: DF.appendChild.1.3.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createElement> ('pi');

        my $return = $dtd-><M::Node.appendChild> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Element>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: DF.appendChild.1.4.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createCDATASection> ('d');

        my $return = $dtd-><M::Node.appendChild> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|CDATASection>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;

        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: DF.appendChild.1.5.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createComment> ('pi');

        my $return = $dtd-><M::Node.appendChild> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tc|Comment>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: DF.appendChild.1.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createEntityReference> ('pi');

        my $return = $dtd-><M::Node.appendChild> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|EntityReference>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: DF.appendChild.1.6.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createProcessingInstruction> ('pi');

        my $return = $dtd-><M::Node.appendChild> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|ProcessingInstruction>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: DF.insertBefore.1.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createTextNode> ('pi');

        my $return = $dtd-><M::Node.insertBefore> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: DF.insertBefore.1.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createEntityReference> ('pi');

        my $return = $dtd-><M::Node.insertBefore> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|EntityReference>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: DF.insertBefore.1.3.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createElement> ('pi');

        my $return = $dtd-><M::Node.insertBefore> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Element>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: DF.insertBefore.1.4.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createCDATASection> ('pi');

        my $return = $dtd-><M::Node.insertBefore> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|CDATASection>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: DF.insertBefore.1.5.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createComment> ('pi');

        my $return = $dtd-><M::Node.insertBefore> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tc|Comment>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: DF.insertBefore.1.6.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createProcessingInstruction> ('pi');

        my $return = $dtd-><M::Node.insertBefore> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|ProcessingInstruction>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);

    @@Test:
      @@@QName: DF.appendChild.has.parent.1.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createDocumentFragment>;

        my $piparent = $doc-><M::Document.createElementNS> (null, 'e');
        my $pi = $doc-><M::Document.createTextNode> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.appendChild> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: DF.appendChild.has.parent.1.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createDocumentFragment>;

        my $piparent = $doc-><M::Document.createElementNS> (null, 'e');
        my $pi = $doc-><M::Document.createEntityReference> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.appendChild> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|EntityReference>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: DF.appendChild.has.parent.1.3.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createDocumentFragment>;

        my $piparent = $doc-><M::Document.createElementNS> (null, 'e');
        my $pi = $doc-><M::Document.createElement> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.appendChild> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Element>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: DF.appendChild.has.parent.1.4.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createDocumentFragment>;

        my $piparent = $doc-><M::Document.createElementNS> (null, 'e');
        my $pi = $doc-><M::Document.createCDATASection> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.appendChild> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|CDATASection>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: DF.appendChild.has.parent.1.5.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createDocumentFragment>;

        my $piparent = $doc-><M::Document.createElementNS> (null, 'e');
        my $pi = $doc-><M::Document.createComment> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.appendChild> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tc|Comment>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: DF.insertBefore.has.parent.1.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createDocumentFragment>;

        my $piparent = $doc-><M::Document.createElementNS> (null, 'e');
        my $pi = $doc-><M::Document.createTextNode> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.insertBefore> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: DF.insertBefore.has.parent.1.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createDocumentFragment>;

        my $piparent = $doc-><M::Document.createElementNS> (null, 'e');
        my $pi = $doc-><M::Document.createEntityReference> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.insertBefore> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|EntityReference>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: DF.insertBefore.has.parent.1.3.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createDocumentFragment>;

        my $piparent = $doc-><M::Document.createElementNS> (null, 'e');
        my $pi = $doc-><M::Document.createElement> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.insertBefore> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Element>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: DF.insertBefore.has.parent.1.4.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createDocumentFragment>;

        my $piparent = $doc-><M::Document.createElementNS> (null, 'e');
        my $pi = $doc-><M::Document.createCDATASection> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.insertBefore> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|CDATASection>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: DF.insertBefore.has.parent.1.5.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createDocumentFragment>;

        my $piparent = $doc-><M::Document.createElementNS> (null, 'e');
        my $pi = $doc-><M::Document.createComment> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.insertBefore> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tc|Comment>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: DF.appendChild.documentfragment.1.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createDocumentFragment>;

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createTextNode> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.appendChild> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: DF.appendChild.documentfragment.1.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createDocumentFragment>;

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createEntityReference> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.appendChild> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|EntityReference>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: DF.appendChild.documentfragment.1.3.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createDocumentFragment>;

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createElement> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.appendChild> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Element>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: DF.appendChild.documentfragment.1.4.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createDocumentFragment>;

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createCDATASection> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.appendChild> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|CDATASection>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: DF.appendChild.documentfragment.1.5.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createDocumentFragment>;

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createComment> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.appendChild> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tc|Comment>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: DF.insertBefore.documentfragment.1.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createDocumentFragment>;

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createTextNode> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.insertBefore> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: DF.insertBefore.documentfragment.1.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createDocumentFragment>;

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createEntityReference> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.insertBefore> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|EntityReference>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: DF.insertBefore.documentfragment.1.3.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createDocumentFragment>;

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createElement> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.insertBefore> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Element>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: DF.insertBefore.documentfragment.1.4.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createDocumentFragment>;

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createCDATASection> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.insertBefore> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|CDATASection>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: DF.insertBefore.documentfragment.1.5.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createDocumentFragment>;

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createComment> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.insertBefore> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tc|Comment>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: DF.replaceChild.documentfragment.1.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createDocumentFragment>;
        my $pi0 = $doc-><M::Document.createTextNode> ('pi0');
        $dtd-><M::Node.appendChild> ($pi0);

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createTextNode> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.replaceChild> ($piparent, $pi0);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi0);
    @@Test:
      @@@QName: DF.replaceChild.documentfragment.1.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createDocumentFragment>;
        my $pi0 = $doc-><M::Document.createTextNode> ('pi0');
        $dtd-><M::Node.appendChild> ($pi0);

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createEntityReference> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.replaceChild> ($piparent, $pi0);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|EntityReference>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi0);
    @@Test:
      @@@QName: DF.replaceChild.documentfragment.1.3.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createDocumentFragment>;
        my $pi0 = $doc-><M::Document.createTextNode> ('pi0');
        $dtd-><M::Node.appendChild> ($pi0);

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createElement> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.replaceChild> ($piparent, $pi0);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Element>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi0);
    @@Test:
      @@@QName: DF.replaceChild.documentfragment.1.4.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createDocumentFragment>;
        my $pi0 = $doc-><M::Document.createTextNode> ('pi0');
        $dtd-><M::Node.appendChild> ($pi0);

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createCDATASection> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.replaceChild> ($piparent, $pi0);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|CDATASection>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi0);
    @@Test:
      @@@QName: DF.replaceChild.documentfragment.1.5.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createDocumentFragment>;
        my $pi0 = $doc-><M::Document.createTextNode> ('pi0');
        $dtd-><M::Node.appendChild> ($pi0);

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createComment> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.replaceChild> ($piparent, $pi0);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tc|Comment>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi0);

    @@Test:
      @@@QName: DF.appendChild.documentfragment.2.1.test
      @@@enDesc:
        Empty document fragment.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createDocumentFragment>;

        my $piparent = $doc-><M::Document.createDocumentFragment>;

        my $return = $dtd-><M::Node.appendChild> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 0);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: DF.insertBefore.documentfragment.2.test
      @@@enDesc:
        Empty document fragment.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createDocumentFragment>;

        my $piparent = $doc-><M::Document.createDocumentFragment>;

        my $return = $dtd-><M::Node.insertBefore> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 0);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: DF.replaceChild.documentfragment.2.test
      @@@enDesc:
        Empty document fragment.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createDocumentFragment>;
        my $pi0 = $doc-><M::Document.createTextNode> ('pi0');
        $dtd-><M::Node.appendChild> ($pi0);

        my $piparent = $doc-><M::Document.createDocumentFragment>;

        my $return = $dtd-><M::Node.replaceChild> ($piparent, $pi0);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 0);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi0);

    @@Test:
      @@@QName: DF.appendChild.documentfragment.3.test
      @@@enDesc:
        Three PIs in document fragment.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createDocumentFragment>;

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createTextNode> ('pi');
        my $pi2 = $doc-><M::Document.createEntityReference> ('pi2');
        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $piparent-><M::Node.appendChild> ($pi);
        $piparent-><M::Node.appendChild> ($pi2);
        $piparent-><M::Node.appendChild> ($pi3);

        my $return = $dtd-><M::Node.appendChild> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 3);

        my $item = $child-><M::NodeList.item> (0);
        my $item2 = $child-><M::NodeList.item> (1);
        my $item3 = $child-><M::NodeList.item> (2);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);
        $test->id ('child.item.node2');
        $test->assert_isa ($item2, <IFName::Node>);
        $test->id ('child.item.node3');
        $test->assert_isa ($item3, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);
        $test->id ('child.item.pi2');
        $test->assert_isa ($item2, <IFName::tx|EntityReference>);
        $test->id ('child.item.pi3');
        $test->assert_isa ($item3, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);
        $test->id ('child.item.equals2');
        $test->assert_equals ($item2, $pi2);
        $test->id ('child.item.equals3');
        $test->assert_equals ($item3, $pi3);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi3);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);
        $test->id ('parent2');
        my $parent2 = $item2-><AG::Node.parentNode>;
        $test->assert_equals ($parent2, $dtd);
        $test->id ('parent3');
        my $parent3 = $item3-><AG::Node.parentNode>;
        $test->assert_equals ($parent3, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: DF.insertBefore.documentfragment.3.test
      @@@enDesc:
        Three PIs in document fragment.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createDocumentFragment>;

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createTextNode> ('pi');
        my $pi2 = $doc-><M::Document.createEntityReference> ('pi2');
        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $piparent-><M::Node.appendChild> ($pi);
        $piparent-><M::Node.appendChild> ($pi2);
        $piparent-><M::Node.appendChild> ($pi3);

        my $return = $dtd-><M::Node.insertBefore> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 3);

        my $item = $child-><M::NodeList.item> (0);
        my $item2 = $child-><M::NodeList.item> (1);
        my $item3 = $child-><M::NodeList.item> (2);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);
        $test->id ('child.item.node2');
        $test->assert_isa ($item2, <IFName::Node>);
        $test->id ('child.item.node3');
        $test->assert_isa ($item3, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);
        $test->id ('child.item.pi2');
        $test->assert_isa ($item2, <IFName::tx|EntityReference>);
        $test->id ('child.item.pi3');
        $test->assert_isa ($item3, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);
        $test->id ('child.item.equals2');
        $test->assert_equals ($item2, $pi2);
        $test->id ('child.item.equals3');
        $test->assert_equals ($item3, $pi3);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi3);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);
        $test->id ('parent2');
        my $parent2 = $item2-><AG::Node.parentNode>;
        $test->assert_equals ($parent2, $dtd);
        $test->id ('parent3');
        my $parent3 = $item3-><AG::Node.parentNode>;
        $test->assert_equals ($parent3, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: DF.replaceChild.documentfragment.3.test
      @@@enDesc:
        Three PIs in document fragment.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createDocumentFragment>;
        my $pi0 = $doc-><M::Document.createTextNode> ('pi0');
        $dtd-><M::Node.appendChild> ($pi0);

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createTextNode> ('pi');
        my $pi2 = $doc-><M::Document.createEntityReference> ('pi2');
        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $piparent-><M::Node.appendChild> ($pi);
        $piparent-><M::Node.appendChild> ($pi2);
        $piparent-><M::Node.appendChild> ($pi3);

        my $return = $dtd-><M::Node.replaceChild> ($piparent, $pi0);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 3);

        my $item = $child-><M::NodeList.item> (0);
        my $item2 = $child-><M::NodeList.item> (1);
        my $item3 = $child-><M::NodeList.item> (2);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);
        $test->id ('child.item.node2');
        $test->assert_isa ($item2, <IFName::Node>);
        $test->id ('child.item.node3');
        $test->assert_isa ($item3, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);
        $test->id ('child.item.pi2');
        $test->assert_isa ($item2, <IFName::tx|EntityReference>);
        $test->id ('child.item.pi3');
        $test->assert_isa ($item3, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);
        $test->id ('child.item.equals2');
        $test->assert_equals ($item2, $pi2);
        $test->id ('child.item.equals3');
        $test->assert_equals ($item3, $pi3);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi3);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);
        $test->id ('parent2');
        my $parent2 = $item2-><AG::Node.parentNode>;
        $test->assert_equals ($parent2, $dtd);
        $test->id ('parent3');
        my $parent3 = $item3-><AG::Node.parentNode>;
        $test->assert_equals ($parent3, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi0);

    @@Test:
      @@@QName: DF.appendChild.badtype.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $comment = $doc-><M::Document.createDocumentFragment>;
        my $pi0 = $doc-><M::Document.createTextNode> ('pi0');
        $comment-><M::Node.appendChild> ($pi0);

        for my $node (
          $docx-><M::d|DocumentXDoctype.createDocumentTypeDefinition> ('d'),
          $doc-><M::Document.createAttribute> ('a'),
          $docx-><M::d|DocumentXDoctype.createGeneralEntity> ('ge'),
          $docx-><M::d|DocumentXDoctype.createNotation> ('not'),
          $docx-><M::d|DocumentXDoctype.createElementTypeDefinition> ('et'),
          $docx-><M::d|DocumentXDoctype.createAttributeDefinition> ('at'),
          #test:nodeTypes
        ) {
          $test->id ('appendChild.'.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.appendChild> ($node);
          }, exception_subtype => <Q::MDOMX|HIERARCHY_BAD_TYPE>);

          $test->id ('insertBefore.'.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.insertBefore> ($node);
          }, exception_subtype => <Q::MDOMX|HIERARCHY_BAD_TYPE>);

          $test->id ('replaceChild.'.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.replaceChild> ($node, $pi0);
          }, exception_subtype => <Q::MDOMX|HIERARCHY_BAD_TYPE>);
        }

    @@Test:
      @@@QName: DF.appendChild.wrongdoc.test
      @@@PerlDef:
        my $doc0;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc0}__;

        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $comment = $doc0-><M::Document.createDocumentFragment>;

        for my $node (
          $doc-><M::Document.createTextNode> ('pi'),
          $doc-><M::Document.createEntityReference> ('e'),
          $doc-><M::Document.createComment> ('c'),
          $doc-><M::Document.createCDATASection> ('cs'),
          $doc-><M::Document.createElement> ('el'),
        ) {
          $test->id ('type='.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.appendChild> ($node);
          }, exception_subtype => <Q::c|DIFFERENT_DOCUMENT_ERR>);
        }
    @@Test:
      @@@QName: DF.insertBefore.wrongdoc.test
      @@@PerlDef:
        my $doc0;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc0}__;
        my $docx0 = $doc0-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $comment = $doc0-><M::Document.createDocumentFragment>;
        my $pi0 = $doc0-><M::Document.createTextNode> ('pi0');
        $comment-><M::Node.appendChild> ($pi0);

        for my $node (
          $doc-><M::Document.createTextNode> ('pi'),
          $doc-><M::Document.createEntityReference> ('ent'),
          $doc-><M::Document.createComment> ('c'),
          $doc-><M::Document.createCDATASection> ('cs'),
          $doc-><M::Document.createElement> ('el'),
        ) {
          $test->id ('appendChild.'.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.appendChild> ($node);
          }, exception_subtype => <Q::c|DIFFERENT_DOCUMENT_ERR>);

          $test->id ('insertBefore.'.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.insertBefore> ($node);
          }, exception_subtype => <Q::c|DIFFERENT_DOCUMENT_ERR>);

          $test->id ('replaceChild.'.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.replaceChild> ($node, $pi0);
          }, exception_subtype => <Q::c|DIFFERENT_DOCUMENT_ERR>);
        }

    @@Test:
      @@@QName: DF.appendChild.readonly.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createDocumentFragment>;
        my $pi0 = $doc-><M::Document.createTextNode> ('pi0');
        $dtd-><M::Node.appendChild> ($pi0);
        $dtd-><M::Node.manakaiSetReadOnly> (true);

        $test->id ('pi');
        my $node = $doc-><M::Document.createTextNode> ('pi');

        $test->assert_exception (code => sub {
          $dtd-><M::Node.appendChild> ($node);
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);

        $test->id ('pi.insertBefore');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.insertBefore> ($node);
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);

        $test->id ('pi.replaceChild');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.replaceChild> ($node, $pi0);
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);

        $test->id ('fragment');
        my $node2 = $doc-><M::Document.createDocumentFragment>;
        $node2-><M::Node.appendChild> ($node);

        $test->assert_exception (code => sub {
          $dtd-><M::Node.appendChild> ($node2);
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);

        $test->id ('fragment.insertBefore');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.insertBefore> ($node2);
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);

        $test->id ('fragment.replaceChild');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.replaceChild> ($node2, $pi0);
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);

    @@Test:
      @@@QName: DF.appendChild.readonly.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createDocumentFragment>;
        my $pi0 = $doc-><M::Document.createTextNode> ('pi0');
        $dtd-><M::Node.appendChild> ($pi0);

        $test->id ('pi');
        my $el = $doc-><M::Document.createElementNS> (null, 'e');
        my $node = $doc-><M::Document.createTextNode> ('pi');
        $el-><M::Node.appendChild> ($node);
        $el-><M::Node.manakaiSetReadOnly> (true);

        $test->assert_exception (code => sub {
          $dtd-><M::Node.appendChild> ($node);
        }, exception_subtype => <Q::MDOMX|NOMOD_SRC_PARENT>);

        $test->id ('pi.insertBefore');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.insertBefore> ($node);
        }, exception_subtype => <Q::MDOMX|NOMOD_SRC_PARENT>);

        $test->id ('pi.replaceChild');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.replaceChild> ($node, $pi0);
        }, exception_subtype => <Q::MDOMX|NOMOD_SRC_PARENT>);

        $test->id ('fragment');
        my $node2 = $doc-><M::Document.createDocumentFragment>;
        my $node3 = $doc-><M::Document.createTextNode> ('pi');
        $node2-><M::Node.appendChild> ($node3);
        $node2-><M::Node.manakaiSetReadOnly> (true);

        $test->assert_exception (code => sub {
          $dtd-><M::Node.appendChild> ($node2);
        }, exception_subtype => <Q::MDOMX|NOMOD_SRC_PARENT>);

        $test->id ('fragment.insertBefore');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.insertBefore> ($node2);
        }, exception_subtype => <Q::MDOMX|NOMOD_SRC_PARENT>);

        $test->id ('fragment.replaceChild');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.replaceChild> ($node2, $pi0);
        }, exception_subtype => <Q::MDOMX|NOMOD_SRC_PARENT>);

    @@Test:
      @@@QName: DF.insertBefore.refChild.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createDocumentFragment>;

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.insertBefore> ($pi2, $pi1);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi2);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi1);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: DF.insertBefore.refChild.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createDocumentFragment>;

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $dtd-><M::Node.insertBefore> ($pi3, $pi2);

        # pi1, pi3, pi2

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi1);

        $test->id ('firstChild.nextSibling');
        $test->assert_equals ($dtd-><AG::Node.firstChild>
                                  -><AG::Node.nextSibling>, $pi3);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi2);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 3);

    @@Test:
      @@@QName: DF.insertBefore.refChild.3.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createDocumentFragment>;

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $dtd-><M::Node.appendChild> ($pi3);

        # pi1, pi2, pi3

        $dtd-><M::Node.insertBefore> ($pi2, $pi1);
 
        # pi2, pi1, pi3

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi2);

        $test->id ('firstChild.nextSibling');
        $test->assert_equals ($dtd-><AG::Node.firstChild>
                                  -><AG::Node.nextSibling>, $pi1);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi3);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 3);

    @@Test:
      @@@QName: DF.insertBefore.refChild.4.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createDocumentFragment>;

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $dtd-><M::Node.appendChild> ($pi3);

        # pi1, pi2, pi3

        $dtd-><M::Node.insertBefore> ($pi3, $pi1);
 
        # pi3, pi1, pi2

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi3);

        $test->id ('firstChild.nextSibling');
        $test->assert_equals ($dtd-><AG::Node.firstChild>
                                  -><AG::Node.nextSibling>, $pi1);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi2);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 3);

    @@Test:
      @@@QName: DF.insertBefore.refChild.not_found_err.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createDocumentFragment>;

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');

        my $pi4 = $doc-><M::Document.createTextNode> ('pi4');

        # pi1, pi2

        $test->assert_exception (code => sub {
          $dtd-><M::Node.insertBefore> ($pi4, $pi3);
        }, exception_subtype => <Q::c|NOT_CHILD_ERR>);

    @@Test:
      @@@QName: DF.insertBefore.refChild=newChild.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createDocumentFragment>;

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        # pi1, pi2

        my $eh_called = false;
        my $cfg = $doc-><AG::Document.domConfig>;
        $cfg-><M::c|DOMConfiguration.setParameter> ('error-handler' => sub {
          my (undef, $err) = @_;
          $eh_called = true;
          $test->assert_equals ($err-><AG::c|DOMError.severity>,
                                <C::c|DOMError.SEVERITY_WARNING>);
          $test->assert_equals ($err-><AG::c|DOMError.type>,
                                <Q::t|insert-before-itself>);
          $test->assert_equals ($err-><AG::c|DOMError.relatedData>, $pi2);
          $test->assert_null ($err-><AG::c|DOMError.relatedException>);
          $test->assert_isa ($err-><AG::c|DOMError.location>,
                             <IFName::c|DOMLocator>);
          $test->assert_not_null ($err-><AG::c|DOMError.message>);
        });

        $test->assert_false ($eh_called);
        $dtd-><M::Node.insertBefore> ($pi2, $pi2);
        $test->assert_true ($eh_called);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi1);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi2);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: DF.replaceChild.oldChild=newChild.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createDocumentFragment>;

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        # pi1, pi2

        my $eh_called = false;
        my $cfg = $doc-><AG::Document.domConfig>;
        $cfg-><M::c|DOMConfiguration.setParameter> ('error-handler' => sub {
          my (undef, $err) = @_;
          $eh_called = true;
          $test->assert_equals ($err-><AG::c|DOMError.severity>,
                                <C::c|DOMError.SEVERITY_WARNING>);
          $test->assert_equals ($err-><AG::c|DOMError.type>,
                                <Q::t|replace-by-itself>);
          $test->assert_equals ($err-><AG::c|DOMError.relatedData>, $pi2);
          $test->assert_null ($err-><AG::c|DOMError.relatedException>);
          $test->assert_isa ($err-><AG::c|DOMError.location>,
                             <IFName::c|DOMLocator>);
          $test->assert_not_null ($err-><AG::c|DOMError.message>);
        });

        $test->assert_false ($eh_called);
        $dtd-><M::Node.replaceChild> ($pi2, $pi2);
        $test->assert_true ($eh_called);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi1);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi2);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: DF.appendChild.sameparent.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createDocumentFragment>;

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        # pi1, pi2

        my $return = $dtd-><M::Node.appendChild> ($pi1);

        # pi2, pi1

        $test->id ('return');
        $test->assert_equals ($return, $pi1);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi2);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi1);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: DF.insertBefore.sameparent.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createDocumentFragment>;

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        # pi1, pi2

        my $return = $dtd-><M::Node.insertBefore> ($pi1);

        # pi2, pi1

        $test->id ('return');
        $test->assert_equals ($return, $pi1);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi2);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi1);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: DF.appendChild.sameparent.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createDocumentFragment>;

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        # pi1, pi2

        my $return = $dtd-><M::Node.appendChild> ($pi2);

        # pi1, pi2

        $test->id ('return');
        $test->assert_equals ($return, $pi2);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi1);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi2);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: DF.insertBefore.sameparent.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createDocumentFragment>;

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        # pi1, pi2

        my $return = $dtd-><M::Node.insertBefore> ($pi2);

        # pi1, pi2

        $test->id ('return');
        $test->assert_equals ($return, $pi2);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi1);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi2);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: DF.replaceChild.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createDocumentFragment>;

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $dtd-><M::Node.appendChild> ($pi3);

        # pi1, pi2, pi3

        my $pi9 = $doc-><M::Document.createTextNode> ('pi9');
        my $return = $dtd-><M::Node.replaceChild> ($pi9, $pi1);

        # pi9, pi2, pi3

        $test->id ('return.node');
        $test->assert_isa ($return, <IFName::Node>);
        $test->id ('return.pi');
        $test->assert_isa ($return, <IFName::Text>);
        $test->id ('return');
        $test->assert_equals ($return, $pi1);

        my $c = $dtd-><AG::Node.childNodes>;

        $test->id ('length');
        $test->assert_num_equals (actual_value => 0+@$c, expected_value => 3);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi9);

        $test->id ('firstChild.nextSibling');
        $test->assert_equals ($dtd-><AG::Node.firstChild>
                                  -><AG::Node.nextSibling>, $pi2);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi3);
 
        $test->id ('parent');
        $test->assert_equals ($pi9-><AG::Node.parentNode>, $dtd);

        $test->id ('return.parent');
        $test->assert_null ($pi1-><AG::Node.parentNode>);

    @@Test:
      @@@QName: DF.replaceChild.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createDocumentFragment>;

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $dtd-><M::Node.appendChild> ($pi3);

        # pi1, pi2, pi3

        my $pi9 = $doc-><M::Document.createTextNode> ('pi9');
        my $return = $dtd-><M::Node.replaceChild> ($pi9, $pi2);

        # pi1, pi9, pi3

        $test->id ('return.node');
        $test->assert_isa ($return, <IFName::Node>);
        $test->id ('return.pi');
        $test->assert_isa ($return, <IFName::Text>);
        $test->id ('return');
        $test->assert_equals ($return, $pi2);

        my $c = $dtd-><AG::Node.childNodes>;

        $test->id ('length');
        $test->assert_num_equals (actual_value => 0+@$c, expected_value => 3);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi1);

        $test->id ('firstChild.nextSibling');
        $test->assert_equals ($dtd-><AG::Node.firstChild>
                                  -><AG::Node.nextSibling>, $pi9);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi3);
 
        $test->id ('parent');
        $test->assert_equals ($pi9-><AG::Node.parentNode>, $dtd);

        $test->id ('return.parent');
        $test->assert_null ($pi2-><AG::Node.parentNode>);

    @@Test:
      @@@QName: DF.replaceChild.3.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createDocumentFragment>;

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $dtd-><M::Node.appendChild> ($pi3);

        # pi1, pi2, pi3

        my $pi9 = $doc-><M::Document.createTextNode> ('pi9');
        my $return = $dtd-><M::Node.replaceChild> ($pi9, $pi3);

        # pi1, pi2, pi9

        $test->id ('return.node');
        $test->assert_isa ($return, <IFName::Node>);
        $test->id ('return.pi');
        $test->assert_isa ($return, <IFName::Text>);
        $test->id ('return');
        $test->assert_equals ($return, $pi3);

        my $c = $dtd-><AG::Node.childNodes>;

        $test->id ('length');
        $test->assert_num_equals (actual_value => 0+@$c, expected_value => 3);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi1);

        $test->id ('firstChild.nextSibling');
        $test->assert_equals ($dtd-><AG::Node.firstChild>
                                  -><AG::Node.nextSibling>, $pi2);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi9);
 
        $test->id ('parent');
        $test->assert_equals ($pi9-><AG::Node.parentNode>, $dtd);

        $test->id ('return.parent');
        $test->assert_null ($pi3-><AG::Node.parentNode>);

    @@Test:
      @@@QName: DF.replaceChild.sameparent.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createDocumentFragment>;

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $dtd-><M::Node.appendChild> ($pi3);

        # pi1, pi2, pi3

        my $return = $dtd-><M::Node.replaceChild> ($pi3, $pi1);

        # pi3, pi2

        $test->id ('return.node');
        $test->assert_isa ($return, <IFName::Node>);
        $test->id ('return.pi');
        $test->assert_isa ($return, <IFName::Text>);
        $test->id ('return');
        $test->assert_equals ($return, $pi1);

        my $c = $dtd-><AG::Node.childNodes>;

        $test->id ('length');
        $test->assert_num_equals (actual_value => 0+@$c, expected_value => 2);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi3);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi2);
 
        $test->id ('parent');
        $test->assert_equals ($pi3-><AG::Node.parentNode>, $dtd);

        $test->id ('return.parent');
        $test->assert_null ($pi1-><AG::Node.parentNode>);

    @@Test:
      @@@QName: DF.replaceChild.sameparent.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createDocumentFragment>;

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $dtd-><M::Node.appendChild> ($pi3);

        # pi1, pi2, pi3

        my $return = $dtd-><M::Node.replaceChild> ($pi1, $pi3);

        # pi2, pi1

        $test->id ('return.node');
        $test->assert_isa ($return, <IFName::Node>);
        $test->id ('return.pi');
        $test->assert_isa ($return, <IFName::Text>);
        $test->id ('return');
        $test->assert_equals ($return, $pi3);

        my $c = $dtd-><AG::Node.childNodes>;

        $test->id ('length');
        $test->assert_num_equals (actual_value => 0+@$c, expected_value => 2);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi2);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi1);
 
        $test->id ('parent');
        $test->assert_equals ($pi1-><AG::Node.parentNode>, $dtd);

        $test->id ('return.parent');
        $test->assert_null ($pi3-><AG::Node.parentNode>);

    @@Test:
      @@@QName: DF.appendChild.itself.test
      @@@enDesc:
        See SuikaWiki
        <URI::http://suika.fam.cx/gate/2005/sw/appendChild#anchor-1>.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $df = $doc-><M::Document.createDocumentFragment>;
        $df-><M::Node.appendChild>
               ($doc-><M::Document.createTextNode> ('text1'));
        $df-><M::Node.appendChild>
               ($doc-><M::Document.createElement> ('e'));
        $df-><M::Node.appendChild>
               ($doc-><M::Document.createTextNode> ('text2'));

        $test->assert_exception (code => sub {
          $df-><M::Node.appendChild> ($df);
        }, exception_subtype => <Q::t|HIERARCHY_DOCUMENT_FRAGMENT_ITSELF_ERR>);
    @@Test:
      @@@QName: DF.insertBefore.itself.test
      @@@enDesc:
        See SuikaWiki
        <URI::http://suika.fam.cx/gate/2005/sw/appendChild#anchor-1>.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $df = $doc-><M::Document.createDocumentFragment>;
        $df-><M::Node.appendChild>
               ($doc-><M::Document.createTextNode> ('text1'));
        $df-><M::Node.appendChild>
               ($doc-><M::Document.createElement> ('e'));
        $df-><M::Node.appendChild>
               ($doc-><M::Document.createTextNode> ('text2'));

        $test->assert_exception (code => sub {
          $df-><M::Node.insertBefore> ($df);
        }, exception_subtype => <Q::t|HIERARCHY_DOCUMENT_FRAGMENT_ITSELF_ERR>);
    @@Test:
      @@@QName: DF.replaceChild.itself.test
      @@@enDesc:
        See SuikaWiki
        <URI::http://suika.fam.cx/gate/2005/sw/appendChild#anchor-1>.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $df = $doc-><M::Document.createDocumentFragment>;
        $df-><M::Node.appendChild>
               ($doc-><M::Document.createTextNode> ('text1'));
        $df-><M::Node.appendChild>
               ($doc-><M::Document.createElement> ('e'));
        $df-><M::Node.appendChild>
               ($doc-><M::Document.createTextNode> ('text2'));

        $test->assert_exception (code => sub {
          $df-><M::Node.replaceChild> ($df, $df-><AG::Node.firstChild>);
        }, exception_subtype => <Q::t|HIERARCHY_DOCUMENT_FRAGMENT_ITSELF_ERR>);

  @CMethod:
    @@Name: manakaiAppendText
    @@Param:
      @@@Name: string
      @@@Type: DOMString
      @@@enDesc:
        The string to append.
      @@@InCase:
        @@@@Type: DISPerl|SCALAR||ManakaiDOM|all
        @@@@enDesc:
          A copy of the string value referenced from the value
          is appended.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node itself.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the node to insert the string or a <IF::Text> node
          is read-only.
      @@@disDef:
        @@@@DISPerl:cloneCode: te|ManakaiDOMAttr.manakaiAppendText

    @@Test:
      @@@QName: DF..=.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $node = $doc-><M::Document.createDocumentFragment>;

        $node-><M::Node.manakaiAppendText> ('string');
        $test->id ('1.class');
        $test->assert_isa ($node, <IFName::DocumentFragment>);
        $test->id ('1.value');
        $test->assert_equals ($node-><AG::Node.textContent>, 'string');
        $test->id ('1.length');
        $test->assert_num_equals
                 (expected_value => 1,
                  actual_value => 0+@{$node-><AG::Node.childNodes>});

        $test->id (2);
        $node-><M::Node.manakaiAppendText> ('STRING');
        $test->assert_equals ($node-><AG::Node.textContent>, 'stringSTRING');
        $test->assert_num_equals
                 (expected_value => 1,
                  actual_value => 0+@{$node-><AG::Node.childNodes>});

        $node-><M::Node.appendChild>
                 ($doc-><M::Document.createEntityReference> ('er'));

        $test->id (3);
        $node-><M::Node.manakaiAppendText> ('text');
        $test->assert_equals ($node-><AG::Node.textContent>, 'stringSTRINGtext');
        $test->assert_num_equals
                 (expected_value => 3,
                  actual_value => 0+@{$node-><AG::Node.childNodes>});

  @CL3Method:
    @@Name: getFeature
    @@enDesc:
      Returns a specialized object that implements the specialized APIs.
    @@Param:
      @@@Name: feature
      @@@Type: DOMString
      @@@dis:actualType: f|FeatureNameString
    @@Param:
      @@@Name: version
      @@@Type: DOMString
      @@@dis:actualType: f|FeatureVersionString
    @@Return:
      @@@Type: DOMMain|DOMObject
      @@@nullCase:
      @@@PerlDef:
        $feature =~ s/^\+//;
        __CODE{f|getFeatureImpl::
          $self => $self,
          $feature => $feature, $version => $version, $r => $r,
          $base_class => {<ClassName::ManakaiDOMDocumentFragment>},
        }__;
        unless (defined $r) {
          __DEEP{
            $r = $self->SUPER::get_feature ($feature, $version);
          }__;
        }

    @@Test:
      @@@QName: DF.getFeature.test
      @@@PerlDef:
        my $node;
        __CODE{tc|createDFForTest:: $df => $node}__;

        for (
          [Core => '1.0', <IFName::DocumentFragment||ManakaiDOM|ManakaiDOM1>],
          [Core => '2.0', <IFName::DocumentFragment||ManakaiDOM|ManakaiDOM2>],
          [Core => '3.0', <IFName::DocumentFragment||ManakaiDOM|ManakaiDOM3>],
          [XML => '1.0', <IFName::DocumentFragment||ManakaiDOM|ManakaiDOM1>],
          [XML => '2.0', <IFName::DocumentFragment||ManakaiDOM|ManakaiDOM2>],
          [XML => '3.0', <IFName::DocumentFragment||ManakaiDOM|ManakaiDOM3>],
        ) {
          $test->id ($_->[0].'.'.$_->[1]);
          my $sp = $node-><M::Node.getFeature> ($_->[0], $_->[1]);
          $test->assert_isa ($sp, $_->[2]);
        }

  @CL3Attr:
    @@Name: baseURI
    @@enDesc:
      The base URI of the node.
    @@Type: DOMString
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          If it is not available.
      @@@PerlDef:
        __DEEP{
          $r = $self-><AG::Node.ownerDocument>-><AG::Node.baseURI>;
        }__;

    @@L3Test:
      @@@QName: DocumentFragment.baseURI.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $df = $doc-><M::Document.createDocumentFragment>;
 
        $test->id ('initial');
        $test->assert_null ($df-><AG::Node.baseURI>);

        $test->id ('doc.uri');
        $doc-><AS::Document.manakaiEntityBaseURI> (q<ftp://suika.fam.cx/>);
        $test->assert_equals ($df-><AG::Node.baseURI>,
                              q<ftp://suika.fam.cx/>);
##DocumentFragment

IntPropDef:
  @QName: c|documentURI
  @enDesc:
    <A::Document.documentURI>.
  @tc:nodeStemKey: duri

IntPropDef:
  @QName: c|strictErrorChecking
  @enDesc:
    <A::Document.strictErrorChecking>.
  @tc:nodeStemKey: chk

IntPropDef:
  @QName: c|xmlEncoding
  @enDesc:
    <A::Document.xmlEncoding>
  @tc:nodeStemKey: xcs

ResourceDef:
  @QName: Text
  @AliasFor: tc|Text
  @For: ManakaiDOM|DOM

ResourceDef:
  @QName: NodeList
  @AliasFor: tc|NodeList
  @For: ManakaiDOM|DOM

ResourceDef:
  @QName: NamedNodeMap
  @AliasFor: tc|NamedNodeMap
  @For: ManakaiDOM|DOM
