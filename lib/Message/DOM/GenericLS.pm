#!/usr/bin/perl 
## This file is automatically generated
## 	at 2007-01-02T02:31:14+00:00,
## 	from file "GenericLS.dis",
## 	module <http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#ManakaiDOM.GenericLS>.
## Don't edit by hand!
use strict;
require Message::DOM::DOMCore;
require Message::Util::Error;
require Message::Util::Error::DOMException;
package Message::DOM::GenericLS;
our $VERSION = 20070102.0231;
sub PARSE_ERR ();
sub AUTOLOAD {


        my $al = our $AUTOLOAD;
        $al =~ s/.+:://;
        if ({'PARSE_ERR',
'Message::DOM::IF::GLSException::PARSE_ERR'}->{$al}) {
          no strict 'refs';
          *{$AUTOLOAD} = \&{{'PARSE_ERR',
'Message::DOM::IF::GLSException::PARSE_ERR'}->{$al}};
          goto &{$AUTOLOAD};
        } else {
          require Carp;
          Carp::croak (qq<Can't locate method "$AUTOLOAD">);
        }
      
}
sub import {


        my $self = shift;
        if (@_) {
          local $Exporter::ExportLevel = $Exporter::ExportLevel + 1;
          $self->SUPER::import (@_);
          for (grep {not /\W/} @_) {
            eval qq{$_};
          }
        }
      
}
our %EXPORT_TAG = ('GLSExceptionCode',
['PARSE_ERR']);
our @EXPORT_OK = ('PARSE_ERR');
use Exporter; push our @ISA, 'Exporter';
package Message::DOM::IF::GLSImplementation;
our $VERSION = 20070102.0231;
package Message::DOM::GenericLS::ManakaiGLSImplementation;
our $VERSION = 20070102.0231;
push our @ISA, 'Message::DOM::IF::DOMImplementation',
'Message::DOM::IF::DOMImplementation',
'Message::DOM::IF::GLSImplementation';
push @Message::DOM::DOMCore::ManakaiDOMImplementation::ISA, q<Message::DOM::GenericLS::ManakaiGLSImplementation> unless Message::DOM::DOMCore::ManakaiDOMImplementation->isa (q<Message::DOM::GenericLS::ManakaiGLSImplementation>);
sub create_gls_parser ($$) {
my ($self, $features) = @_;

{


{

if 
(CORE::defined $features) {
  if (CORE::ref ($features) eq 'HASH') {
    my $__new = {};
    for my $__fname (keys %{$features}) {
      if (CORE::ref ($features->{$__fname}) eq 'HASH') {
        my $__lfname = lc $__fname;
        for my $__fver (keys %{$features->{$__fname}}) {
          $__new->{$__lfname}->{$__fver} = $features->{$__fname}->{$__fver};
        }
      } elsif (CORE::ref ($features->{$__fname}) eq 'ARRAY') {
        my $__lfname = lc $__fname;
        for my $__fver (@{$features->{$__fname}}) {
          $__new->{$__lfname}->{$__fver} = 
1
;
        }
      } else {
        $__new->{lc $__fname} = {(CORE::defined $features->{$__fname}
                                ? $features->{$__fname} : '') => 
1
};
      }
    }
    $features = $__new;
  } else {
    my @__f = split /\s+/, $features;
    my $__new = {};
    while (@__f) {
      my $__name = lc shift @__f;
      if (@__f and $__f[0] =~ /^[\d\.]+$/) {
        $__new->{$__name}->{shift @__f} = 1;
      } else {
        $__new->{$__name}->{''} = 1;
      }
    }
    $features = $__new;
  }
} else {
  $features = {};
}


}

;


}
my $r;

{


## Load modules if necessary
for my $fname (keys %$features) {
  for my $fver (grep {$features->{$fname}->{$_}}
      keys %{$features->{$fname} or {}}) {
    if ($Message::Util::AutoLoad::Registry::Feature->{$fname}->{$fver}) {
      eval qq{require
          $Message::Util::AutoLoad::Registry::Feature->{
          $fname}->{$fver}->{module}};
      die $@ if $@;
    }
  }
}

    CLS: for my $class (grep {
      $Message::DOM::DOMLS::ParserClass{$_}
    } keys %Message::DOM::DOMLS::ParserClass) {
      for my $fname (keys %$features) {
        my $fkey = $fname;
        #my $plus = $fname =~ s/^\+// ? t rue : f alse;
        FVER: for my $fver (grep {$features->{$fkey}->{$_}}
                               keys %{$features->{$fkey}}) {
          if ($Message::DOM::DOMFeature::ClassInfo->{$class}
                  ->{has_feature}->{$fname}->{$fver}) {
            next FVER; # Feature/version found
          }
          next CLS; # Not found
        } # FVER
      } # FNAME

      ## Class found
      $r = $class->new ($self, $features);
      last CLS;    ## NOTE: Method name directly written
    } # CLS


}
$r}
sub create_gls_serializer ($$) {
my ($self, $features) = @_;

{


{

if 
(CORE::defined $features) {
  if (CORE::ref ($features) eq 'HASH') {
    my $__new = {};
    for my $__fname (keys %{$features}) {
      if (CORE::ref ($features->{$__fname}) eq 'HASH') {
        my $__lfname = lc $__fname;
        for my $__fver (keys %{$features->{$__fname}}) {
          $__new->{$__lfname}->{$__fver} = $features->{$__fname}->{$__fver};
        }
      } elsif (CORE::ref ($features->{$__fname}) eq 'ARRAY') {
        my $__lfname = lc $__fname;
        for my $__fver (@{$features->{$__fname}}) {
          $__new->{$__lfname}->{$__fver} = 
1
;
        }
      } else {
        $__new->{lc $__fname} = {(CORE::defined $features->{$__fname}
                                ? $features->{$__fname} : '') => 
1
};
      }
    }
    $features = $__new;
  } else {
    my @__f = split /\s+/, $features;
    my $__new = {};
    while (@__f) {
      my $__name = lc shift @__f;
      if (@__f and $__f[0] =~ /^[\d\.]+$/) {
        $__new->{$__name}->{shift @__f} = 1;
      } else {
        $__new->{$__name}->{''} = 1;
      }
    }
    $features = $__new;
  }
} else {
  $features = {};
}


}

;


}
my $r;

{


## Load modules if necessary
for my $fname (keys %$features) {
  for my $fver (grep {$features->{$fname}->{$_}}
      keys %{$features->{$fname} or {}}) {
    if ($Message::Util::AutoLoad::Registry::Feature->{$fname}->{$fver}) {
      eval qq{require
          $Message::Util::AutoLoad::Registry::Feature->{
          $fname}->{$fver}->{module}};
      die $@ if $@;
    }
  }
}

    CLS: for my $class (grep {
      $Message::DOM::DOMLS::SerializerClass{$_}
    } keys %Message::DOM::DOMLS::SerializerClass) {
      for my $fname (keys %$features) {
        my $fkey = $fname;
        #my $plus = $fname =~ s/^\+// ? t rue : f alse;
        FVER: for my $fver (grep {$features->{$fkey}->{$_}}
                               keys %{$features->{$fkey}}) {
          if ($Message::DOM::DOMFeature::ClassInfo->{$class}
                  ->{has_feature}->{$fname}->{$fver}) {
            next FVER; # Feature/version found
          }
          next CLS; # Not found
        } # FVER
      } # FNAME

      ## Class found
      $r = $class->new ($self, $features);
      last CLS;    ## NOTE: Method name directly written
    } # CLS


}
$r}
$Message::DOM::DOMFeature::ClassInfo->{q<Message::DOM::GenericLS::ManakaiGLSImplementation>}->{has_feature} = {'',
{'',
'1'},
'http://suika.fam.cx/www/2006/feature/genericls',
{'',
'1',
'3.0',
'1'},
'http://suika.fam.cx/www/2006/feature/min',
{'',
'1',
'3.0',
'1'},
'http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#minimum',
{'',
'1',
'3.0',
'1'},
'xml',
{'',
'1',
'1.0',
'1',
'2.0',
'1',
'3.0',
'1'},
'xmlversion',
{'',
'1',
'1.0',
'1',
'1.1',
'1'}};
$Message::DOM::ClassPoint{q<Message::DOM::GenericLS::ManakaiGLSImplementation>} = 14.1;
package Message::DOM::IF::GLSException;
our $VERSION = 20070102.0231;
push our @ISA, 'Message::Util::Error';

sub ___error_def () {
  \%Message::DOM::IF::GLSException::ErrorDef
}

sub PARSE_ERR () {
81}
$Message::DOM::IF::GLSException::ErrorDef{'PARSE_ERR'} = {'description',
'An attempt was made to load a document and the processing has been stopped.',
'http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#code',
'81'};
package Message::DOM::GenericLS::ManakaiGLSException;
our $VERSION = 20070102.0231;
push our @ISA, 'Message::Util::Error::DOMException::Exception',
'Message::DOM::IF::GLSException';
$Message::DOM::DOMFeature::ClassInfo->{q<Message::DOM::GenericLS::ManakaiGLSException>}->{has_feature} = {'http://suika.fam.cx/www/2006/feature/genericls',
{'',
'1',
'3.0',
'1'}};
$Message::DOM::ClassPoint{q<Message::DOM::GenericLS::ManakaiGLSException>} = 3;
for ($Message::DOM::IF::DOMImplementation::){}
## License: <http://suika.fam.cx/~wakaba/archive/2004/8/18/license#Perl+MPL>
1;
