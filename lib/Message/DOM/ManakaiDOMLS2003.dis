Module:
  @QName: 
    MDOM:ManakaiDOMLS2003
  @Namespace:
    http://suika.fam.cx/~wakaba/archive/2004/9/27/mdom-old-ls#
  @FullName:
    @@@: Manakai DOM Load Transitional Module
    @@@@lang:en
  @Description:
    @@lang:en
    @@@:
      A set of interfaces for loading document objects. 
    \
      This module instantiate XML documents using the module 
      <PerlModule:Message::Markup::XML::Parser>, a simple XML parser 
      written in Perl.  Note that module is known to having 
      numbers of problems and its successor is now under development. 
      This DOM module is intended to be used for only the 
      transitional period.

  @DISCore:author: DISCore|Wakaba
  @License:
    @@@:
      license:Perl+MPL
    @@Original:
      @@@FullName:
        manakai <FILE:xml-validator.pl>
      @@@Year:2003
      @@@DISCore:author: DISCore|Wakaba
  @Date:
    @@@:
      $Date: 2005/11/16 10:07:13 $
    @@ContentType:
      dis:Date.RCS

  @DefaultFor:
    ManakaiDOM:ManakaiDOMLatest

  @Require:
    @@Module:
      @@@QName: MDOM|DOMXML
      @@@WithFor: ManakaiDOM|ManakaiDOMLatest
    @@Module:
      @@@QName: MDOM|DOMLS
      @@@WithFor: ManakaiDOM|ManakaiDOMLatest
    @@Module:
      @@@QName: MDOM|GenericLS
      @@@WithFor: ManakaiDOM|ManakaiDOMLatest

Namespace:
  @dis:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#dis--
  @dx:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#
  @f:
    http://suika.fam.cx/~wakaba/archive/2004/dom/feature#
  @infoset:
     http://www.w3.org/2001/04/infoset#
  @lang:
     http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#
  @license:
     http://suika.fam.cx/~wakaba/archive/2004/8/18/license#
  @LSEV:
    http://www.w3.org/2002/DOMLS
  @ManakaiDOM:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#
  @ManakaiDOMCore:
    http://suika.fam.cx/~wakaba/archive/2004/mdom-core#
  @ManakaiDOMLS:
    http://suika.fam.cx/~wakaba/archive/2004/mdom-ls#
  @MDOM:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#ManakaiDOM.
  @MDOMX:
    http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#
  @mn:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/ManakaiNode#
  @null:
    http://suika.fam.cx/~wakaba/-temp/2003/09/27/null
  @oldls:
    http://suika.fam.cx/~wakaba/archive/2004/9/27/mdom-old-ls#
  @rdf:
    http://www.w3.org/1999/02/22-rdf-syntax-ns#
  @rdfs:
    http://www.w3.org/2000/01/rdf-schema#
  @test:
    http://suika.fam.cx/~wakaba/archive/2004/dis/Test#
  @xml:
    http://www.w3.org/XML/1998/namespace
  @xmlns:
    http://www.w3.org/2000/xmlns/

## -- Feature

ElementTypeBinding:
  @Name: FeatureDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: f|Feature
    @@For: =ManakaiDOM|all

ElementTypeBinding:
  @Name: FeatureVerDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: f|Feature

ElementTypeBinding:
  @Name: featureQName
  @ElementType: f|name
  @ShadowContent:
    @@ContentType: DISCore|QName

FeatureDef:
  @QName:
    ManakaiDOMLS2003:LS
  @FeatureVerDef:
    @@f:version:1.0
    @@QName: oldls|LSFeature10
    @@f:instanceOf: ManakaiDOMLS2003|LS
    @@f:requires: DOMXML|XMLFeature30
    @@FullName:
      @@@lang:en
      @@@@:
        Manakai DOM Load Transitional Module.

ElementTypeBinding:
  @Name: Method
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Method
    @@For: ManakaiDOM|DOM !=ManakaiDOM|ManakaiDOM

ElementTypeBinding:
  @Name: IntMethod
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Method
    @@For: ManakaiDOM|DOM !=ManakaiDOM|ManakaiDOM
    @@ManakaiDOM:isForInternal: 1

ElementTypeBinding:
  @Name: Param
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|MethodParameter

ElementTypeBinding:
  @Name: Return
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|MethodReturn

ElementTypeBinding:
  @Name: Attr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Attribute
    @@ForCheck: ManakaiDOM|DOM !=ManakaiDOM|ManakaiDOM

ElementTypeBinding:
  @Name: Get
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|AttributeGet

ElementTypeBinding:
  @Name: InCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:InCase

ElementTypeBinding:
  @Name: Exception
  @ElementType:
    dx:raises

ElementTypeBinding:
  @Name: PerlDef
  @ElementType:
    dis:Def
  @ShadowContent:
    @@ContentType:
      lang:Perl

ElementTypeBinding:
  @Name: enDesc
  @ElementType:
    dis:Description
  @ShadowContent:
    @@lang:en

ResourceDef:
  @Name:  ManakaiDOMImplementationLS2003
  @rdf:type: DISLang|Class
  @For:
    ManakaiDOM:ManakaiDOMLatest
  @ISA:
    DOMCore:ManakaiDOMImplementation

  @f:implements: oldls|LSFeature10
  @f:provides: oldls|LSFeature10

  @enDesc:
    The <Class::ManakaiDOMImplementationLS2003> class implements
    factory methods for creating objects required for loading
    XML documents, which is a subset of <IF::DOMLS:DOMImplementationLS>
    interface.

  @Method:
     @@Name:  createLSParser
     @@Description:
       @@@lang:en
       @@@@:
         Create a new parser object.
     @@Param:
        @@@Name:  mode
        @@@Type: 
          DOMLS:DOMImplementationLSMode
        @@@InCase:
          @@@@Label:
            <X::DOMLS:DOMImplementationLS.MODE_SYNCHRONOUS>
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The <IF::ManakaiXMLParser2003> created will 
              operate in synchronous mode.
     @@Param:
        @@@Name:  schemaType
        @@@Type: 
          DOMMain:DOMString
        @@@actualType:
          ManakaiDOM:ManakaiDOMURI
        @@@Description:
          @@@@lang:en
          @@@@@:
            An absolute URI representing the type of the schema language 
            used during the load of a <IF::DOMCore:Document> using the newly 
            created <IF::ManakaiXMLParser2003>.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The <IF::ManakaiXMLParser2003> will be free to use any schema 
              found.
        @@@InCase:
          @@@@Value:
            http://www.w3.org/TR/REC-xml
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The XML 1.0 DTD.
     @@Return:
        @@@Type:  ManakaiXMLParser2003
        @@@Description:
          @@@@lang:en
          @@@@@:
            The newly created parser object.
        @@@ImplNote:
          @@@@lang:en
          @@@@@:
            By default, the parameter <DOM::error-handler> of the 
            <A::DOMLS:LSParser.domConfig> is <DOM::null>.  However, 
            the DOM implementation may provide a default error handler instead.
        @@@Exception:
          @@@@@: ManakaiDOMLS|MDOMLS_IMPL_NOSUPPORT_MODE
          @@@@enDesc: The requested mode is not supported.
        @@@Exception:
          @@@@@: MDOMX|MDOM_IMPL_NOSUPPORT_SCHEMA
          @@@@enDesc: The requested schema language is not supported.
       @@@PerlDef:
         if (not defined $mode or 
             $mode != <C::DOMLS:DOMImplementationLS.MODE_SYNCHRONOUS>) {
           __EXCEPTION{
             ManakaiDOMLS:MDOMLS_IMPL_NOSUPPORT_MODE::
               DOMLS:mode => {$mode},
               MDOMX:param-name => 'mode',
           }__;
         }
         if (defined $schemaType and
             $schemaType ne q<http://www.w3.org/TR/REC-xml>) {
           __EXCEPTION{
             MDOMX:MDOM_IMPL_NOSUPPORT_SCHEMA::
               DOMCore:schemaType => {$schemaType},
               MDOMX:param-name => 'schemaType',
           }__;
         }
         
         ## ** Code from bin/xml-validator.pl **
         my $eh = sub {
      \#line 1 "Error handler code from bin/xml-validator.pl"
		my ($self, $o, $error_type, $error_msg, $err) = @_;
		if ($err->{raiser_type} and
                    $err->{raiser_type} eq 'Message::Markup::XML::Validator') {
		  $error_msg = $err->{node_path} . ': ' . $error_msg
                              if $err->{node_path};
		  $error_msg = 'Document <'.$err->{uri}.'>: ' . $error_msg
                              if $err->{uri};
		}
		#if (($src{stop_with_fatal}
		# && {qw/fatal 1 wfc 1 nswfc 1/}->{$error_type->{level}})
		# || ($src{stop_with_vc}
		# && {qw/vc 1 nsvc 1/}->{$error_type->{level}})) {
		#  local $Carp::CarpLevel = 1;
		#  Carp::croak ('{'.$error_type->{level}.'} '.$error_msg);
		#} else {
		#  local $Carp::CarpLevel = 1;
		#  Carp::carp ('{'.$error_type->{level}.'} '.$error_msg);
		#}
                ## TODO: Report error by DOMError
                if ({fatal=>1, wfc=>1, nswfc=>1}->{$error_type->{level}}) {
                  warn "{{$error_type->{level}}} $error_msg.\n";
                  __EXCEPTION{
                    DOMLS:LSException.PARSE_ERR::
                  }__;
                } else {
                  #warn "{$error_type->{level}} $error_msg.\n";
                }
	   return 0;
    \#line 1 "ManakaiDOMImplementationLS2003.createLSParser #2"
         };

                                               ## Method from MMXParser
         $r = <Class::ManakaiXMLParser2003>->new (option => {
           uri_resolver => sub {
             \#line 1 "URI resolver from bin/xml-validator.pl"
		my ($self, $parser, $decl, $p) = @_;
		#unless (defined $catalog) {
		#  require Message::Markup::XML::Catalog;
		#  $catalog = Message::Markup::XML::Catalog->new;
		#  $catalog->option (uri_resolver => sub {
		#    my ($self, $parser, $decl, $p) = @_;
		#    print STDERR "Retriving catalog entity <$p->{uri}>...\n";
		#    return 1;
		#  });
		#  $catalog->option (dtd_of_xml_catalog_1_0 => $src{catalog_dtd});
		#}
		#$p->{uri} = $catalog->resolve_external_id ({public => $p->{PUBLIC},
		#                                            system => $p->{uri}},
		#                                           catalogs => [$src{catalog}],
		#                                           return_default => 1);
		#print STDERR "Retriving external entity <$p->{uri}>...\n";
		return 1;
    \#line 1 "ManakaiDOMImplementationLS2003.createLSParser #3"
          },
	   error_handler => $eh,
         });
         ## ** End Code from bin/xml-validator.pl **

         $r->flag (<H::DOMCore:implementation> => $self);
         $r->flag (<H::ManakaiDOM:implID> => $self->{<H::mn:node>}
                                                 ->{<H::ManakaiDOM:implID>});

         $r->flag (<H::DOMCore:domConfig> => $self->{<H::mn:node>}
                                                 ->{<H::DOMCore:domConfig>});
    
    @@Test:
      @@@enDesc:
        Ensures that the parser created by the method is keeping 
        flags required by the parser.
      @@@PerlDef:
        my $impl = <Class::ManakaiDOMImplementationLS2003>->_new;
        my $parser = $impl-><M::ManakaiDOMImplementationLS2003.createLSParser>
                               (<C::DOMLS:DOMImplementationLS.MODE_SYNCHRONOUS>);
        $test->assert_not_null ($parser);

        my $parser_impl = $parser->flag (<H::DOMCore:implementation>);
        $test->assert_equals ($parser_impl, $impl);

        my $parser_implid = $parser->flag (<H::ManakaiDOM:implID>);
        $test->assert_equals ($parser_implid, 
                              $impl->{<H::mn:node>}->{<H::ManakaiDOM:implID>});

        ## TODO: Add test for |domConfig|

  @Method:
     @@Name:  createLSInput
     @@Description:
       @@@lang:en
       @@@@:
         Create a new empty input source object.
     @@Return:
        @@@Type:  
          DOMLS:LSInput
        @@@Description:
          @@@@lang:en
          @@@@@: The newly created input object.
        @@@PerlDef:
            $r = <ClassM::DOMLS:ManakaiDOMLSInput.new>;
      @@ImplNote:
         @@@lang:en
         @@@@:
           See also <M::DOMLS:DOMImplementationLS.createLSInput>.

    @@Test:
      @@@PerlDef:
        my $impl = <Class::ManakaiDOMImplementationLS2003>->_new;
        my $input = $impl-><M::ManakaiDOMImplementationLS2003.createLSInput>;
        $test->assert_not_null ($input);
##DOMImplementationLS2003

ElementTypeBinding:
  @Name: Test
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: test|StandaloneTest

ResourceDef:
  @QName: NodeStem
  @AliasFor: mn|NodeStem||ManakaiDOM|Perl

ResourceDef:
  @Name:  ManakaiXMLParser2003
  @rdf:type: DISLang|Class
  @For:
    ManakaiDOM:ManakaiDOMLatest
  @AppISA:
    @@@: 
      Message::Markup::XML::Parser
    @@ContentType:
      lang:Perl
  @ISA:
    ManakaiDOM:ManakaiDOMObject

  @f:implements: oldls|LSFeature10
  @f:implements: DOMLS|ParseString
  @DISLang:role: DOMLS|ParserRole

  @Description:
    @@lang:en
    @@@:
      An interface to an object that is able to build 
      a DOM tree from string data or a URI reference.
  @ImplNote:
    @@lang:en
    @@@:
      {P:: When a document is first made available via the 
      <IF:ManakaiXMLParser2003>, 
      \
      - there will never be two adjacent <IF:Text> nodes.
      \
      - there will never be empty text nodes.
      \
      - <A:Attr.value> will be XML 1.0 normalized value.
      \
      }

  @Attr:
     @@Name:  domConfig
     @@Description:
       @@@lang:en
       @@@@:
         The configuration object used when parsing an input source. 
       \
         Note that this configuration is specific to the parse 
         operation.  No parameter values from this 
         configuration object are passed automatically to the 
         configuration object on the <IF:Document> that is created, or 
         used, by the parse operation.
     @@Get:
        @@@Type:  
          DOMCore:DOMConfiguration
        @@@PerlDef:
            $r = $self->flag (<H::DOMCore:domConfig>);
  @Method:
     @@Name:  parse
     @@Description:
       @@@lang:en
       @@@@:
         Parse an XML document from a resource identified by a 
         <IF::DOMLS|LSInput>.
     @@Param:
        @@@Name:  input
        @@@Type:  
          DOMLS:LSInput
        @@@Description:
          @@@@lang:en
          @@@@@:
            The <IF::DOMLS|LSInput> object from which the source of 
            the document is to be read.
     @@Return:
        @@@Type: 
          DOMCore:Document
        @@@actualType:
          DOMCore:ManakaiDOMDocument
        @@@Description:
          @@@@lang:en
          @@@@@:
            The newly created and populated <IF:Document>.
        @@@Exception:
          @@@@@: DOMLS|LSException.PARSE_ERR
          @@@@enDesc:
            The parser was unable to load the XML document.
       @@@PerlDef:
           my $text;
           my $uri;
           ## 1. characterStream
           ## 2. byteStream
           ## 3. stringData
           if (defined (my $sd = $input-><AG::DOMLS:LSInput
                                    ::ManakaiDOM:ManakaiDOMLatest.stringData>)) {
             $text = \$sd;
           }
           ## 4. systemId
           ## 5. publicId
           elsif (defined (my $sysId = $input-><AG::DOMLS:LSInput
                                    ::ManakaiDOM:ManakaiDOMLatest.systemId>) or
                  defined (my $pubId = $input-><AG::DOMLS:LSInput
                                    ::ManakaiDOM:ManakaiDOMLatest.publicId>)) {
             $uri = $sysId;
             __EXCEPTION{
               DOMCore:DOMException.NOT_SUPPORTED_ERR::
             }__;
           }

           $self->option (document_entity_base_uri =>
                                    $input-><AG::DOMLS:LSInput
                                    ::ManakaiDOM:ManakaiDOMLatest.baseURI>);

           my $doc;
           __DEEP{
             $doc = $self->parse_text ($$text,
                                        {uri => $uri,
                                         entity_type => 'document_entity'});
           }__;
           \## TODO: error & uri handler
           \## TODO: support of domConfig

           my $node = <ClassM::DOMCore:ManakaiDOMDocument.newObject>;
           $node->{<H::DOMCore:implementation>}
                = $self->flag (<H::DOMCore:implementation>);
           $node->{<H::ManakaiDOM:implID>}
                = $self->flag (<H::ManakaiDOM:implID>);
           $node->{<H::infoset:version>} = '1.0';
           $node->{<H::DOMCore:hasFeature>}->{XML} = 1;
           if ($doc->node_type eq '#document') {
             __DEEP{
             for my $src (@{$doc->child_nodes}) {
               if ($src->node_type eq '#element') {
                 $self-><M::ManakaiXMLParser2003.toDOMNode> ($src => $node);
               } elsif ($src->node_type eq '#pi' and
                        $src->local_name eq 'xml') {
                 $node->{<H::infoset:version>}
                      = $src->get_attribute_value ('version', default => '1.0');
                 $node->{<H::DOMCore:xmlEncoding>}
                      = $src->get_attribute_value ('encoding');
                 $node->{<H::infoset:xmlStandalone>}
                      = $src->get_attribute_value ('standalone');
               } elsif ({
                          '#pi' => 1, '#comment' => 1,
                        }->{$src->node_type}) {
                 $self-><M::ManakaiXMLParser2003.toDOMNode> ($src => $node);
               } else {
                 # not supported
               }
             }}__;
           } else {
             __EXCEPTION{
               MDOMX:MDOM_DEBUG_BUG||ManakaiDOM|Perl::
               MDOMX:values => {{node_type => $doc->node_type}},
             }__;
           }
           $r = <ClassM::DOMCore:ManakaiDOMNode.getNodeReference> ($node);
    
    @@Test:
      @@@enDesc:
        The implementation object of the parsed document must
        be the same object as the implementation that creates
        the parser.
      @@@PerlDef:
        my $impl = <Class::ManakaiDOMImplementationLS2003>->_new;
        my $parser = $impl-><M::ManakaiDOMImplementationLS2003.createLSParser>
                               (<C::DOMLS:DOMImplementationLS.MODE_SYNCHRONOUS>);
        $test->assert_not_null ($parser);

        my $input = $impl-><M::ManakaiDOMImplementationLS2003.createLSInput>;
        $input-><AS::DOMLS:LSInput.stringData> ('<'.'element/>');
        
        my $doc = $parser-><M::ManakaiXMLParser2003.parse> ($input);
        $test->assert_not_null ($doc);

        my $doc_impl = $doc-><AG::DOMCore:Document.implementation>;
        $test->assert_equals ($doc_impl, $impl);

  @IntMethod:
    @@Name: toDOMNode
    @@Param:
      @@@Name:src
      @@@Type:
        DOMMain:DOMObject
      @@@Description:
        @@@@lang:en
        @@@@@:
          A <PerlModule::Message::Markup::XML::Node> object to be converted.
    @@Param:
      @@@Name:parent
      @@@Type:
        ManakaiDOMCore:ManakaiDOMNodeObjectNode
      @@@Description:
        @@@@lang:en
        @@@@@:
          The parent DOM <IF::DOMCore|Node> object.
    @@Return:
      @@@PerlDef:
        use Message::Markup::XML::QName qw/DEFAULT_PFX NULL_URI/;
        use Message::Markup::XML::Node qw/SGML_NCR SGML_HEX_CHAR_REF
                                          SGML_GENERAL_ENTITY/;

             if ($src->node_type eq '#element') {
               my $newNode = <ClassM::DOMCore:ManakaiDOMElement.newObject>;
               $parent-><M::NodeStem.importTree> ($newNode);
               $newNode->{<H::DOMCore:ownerDocument>}
                 = $parent->{<H::DOMCore:ownerDocument>} || $parent;
               $newNode->{<H::infoset:prefix>}
                 = defined $src->{namespace_prefix}
                     ? $src->{namespace_prefix} eq DEFAULT_PFX
                         ? null : length $src->{namespace_prefix}
                                ? $src->{namespace_prefix} 
                         : null
                     : null;
               if (defined $src->{namespace_uri} and
                   $src->{namespace_uri} ne '' and
                   $src->{namespace_uri} ne NULL_URI) {
                 $newNode->{<H::infoset:namespaceName>}
                   = \($src->{namespace_uri});
               }
               $newNode->{<H::infoset:localName>} = $src->{local_name};
               $newNode->{<H::infoset:parent>} = $parent;
               push @{$parent->{<H::infoset:children>}}, $newNode;
               for (@{$src->{node}}) {
                 $self-><M::ManakaiXMLParser2003.toDOMNode> ($_ => $newNode);
               }
               for my $prefix (keys %{$src->{ns}||{}}) {
                 my $ns = <ClassM::DOMCore:ManakaiDOMAttr.newObject>;
                 $newNode-><M::NodeStem.importTree> ($ns);
                 $ns->{<H::DOMCore:ownerDocument>}
                   = $newNode->{<H::DOMCore:ownerDocument>};
                 $ns->{<H::infoset:prefix>}
                   = $prefix eq DEFAULT_PFX ? null : $prefix;
                 $ns->{<H::infoset:namespaceName>} = \<Q::xmlns:>;
                 $ns->{<H::infoset:localName>}
                   = $prefix eq DEFAULT_PFX ? 'xmlns' : $prefix;
                 $ns->{<H::infoset:ownerElement>} = $newNode;
                 $ns->{<H::infoset:specified>} = true;
                 $newNode->{<H::infoset:attributes>}
                         ->{<Q::xmlns:>}
                         ->{$ns->{<H::infoset:localName>}} = $ns;
                 if (defined $src->{ns}->{$prefix} and
                     length $src->{ns}->{$prefix} and 
                     $src->{ns}->{$prefix} ne NULL_URI) {
                   my $text = <ClassM::DOMCore:ManakaiDOMText.newObject>;
                   $ns-><M::NodeStem.importTree> ($text);
                   $text->{<H::DOMCore:ownerDocument>}
                     = $ns->{<H::DOMCore:ownerDocument>};
                   $text->{<H::infoset:content>} = $src->{ns}->{$prefix};
                   $text->{<H::infoset:parent>} = $ns;
                   push @{$ns->{<H::infoset:children>}}, $text;
                 }
               }
             } elsif ($src->node_type eq '#attribute') {
               my $newNode = <ClassM::DOMCore:ManakaiDOMAttr.newObject>;
               $parent-><M::NodeStem.importTree> ($newNode);
               $newNode->{<H::DOMCore:ownerDocument>}
                 = $parent->{<H::DOMCore:ownerDocument>};
               $newNode->{<H::infoset:prefix>}
                 = defined $src->{namespace_prefix}
                     ? $src->{namespace_prefix} eq DEFAULT_PFX
                         ? null : length $src->{namespace_prefix}
                                ? $src->{namespace_prefix}
                         : null
                     : null;
               $newNode->{<H::infoset:localName>} = $src->{local_name};
               $newNode->{<H::infoset:ownerElement>} = $parent;
               $newNode->{<H::infoset:specified>} = true;
               if (defined $src->{namespace_uri} and
                   $src->{namespace_uri} ne '' and
                   $src->{namespace_uri} ne NULL_URI) {
                 $newNode->{<H::infoset:namespaceName>}
                   = \($src->{namespace_uri});
                 $parent->{<H::infoset:attributes>}
                        ->{$src->{namespace_uri}}
                        ->{$newNode->{<H::infoset:localName>}} = $newNode;
               } else {
                 $parent->{<H::infoset:attributes>}
                        ->{<Q::null:>}
                        ->{$newNode->{<H::infoset:localName>}} = $newNode;
               }
               if (defined $src->{value} and length $src->{value}) {
                 my $text = <ClassM::DOMCore:ManakaiDOMText.newObject>;
                 $newNode-><M::NodeStem.importTree> ($text);
                 $text->{<H::DOMCore:ownerDocument>}
                   = $newNode->{<H::DOMCore:ownerDocument>};
                 $text->{<H::infoset:content>} = $src->{value};
                 $text->{<H::infoset:parent>} = $newNode;
                 push @{$newNode->{<H::infoset:children>}}, $text;
               }
               for (@{$src->{node}}) {
                 $self-><M::ManakaiXMLParser2003.toDOMNode> ($_ => $newNode);
               }
             } elsif ($src->node_type eq '#text') {
               my $lc = $parent->{<H::infoset:children>}->[-1];
               if ($lc and $lc->{<H::DOMCore:nodeType>} eq <H::DOMCore:Text>) {
                 $lc->{<H::infoset:content>} .= $src->{value};
               } elsif (defined $src->{value} and length $src->{value}) {
                 my $text = <ClassM::DOMCore:ManakaiDOMText.newObject>;
                 $parent-><M::NodeStem.importTree> ($text);
                 $text->{<H::DOMCore:ownerDocument>}
                   = $parent->{<H::DOMCore:ownerDocument>};
                 $text->{<H::infoset:content>} = $src->inner_text;
                 $text->{<H::infoset:parent>} = $parent;
                 push @{$parent->{<H::infoset:children>}}, $text;
               }
             } elsif ($src->node_type eq '#comment') {
               if (defined $src->{value} and length $src->{value}) {
                 my $text = <ClassM::DOMCore:ManakaiDOMComment.newObject>;
                 $parent-><M::NodeStem.importTree> ($text);
                 $text->{<H::DOMCore:ownerDocument>}
                   = $parent->{<H::DOMCore:ownerDocument>} || $parent;
                 $text->{<H::infoset:content>} = $src->inner_text;
                 $text->{<H::infoset:parent>} = $parent;
                 push @{$parent->{<H::infoset:children>}}, $text;
               }
             } elsif ($src->node_type eq '#reference') {
               if ($src->namespace_uri eq SGML_NCR or
                   $src->namespace_uri eq SGML_HEX_CHAR_REF or
                   ($src->namespace_uri eq SGML_GENERAL_ENTITY and
                    {qw/amp 1 lt 1 quot 1 gt 1 apos 1/}->{$src->local_name})) {
                 my $val;
                 if ($src->namespace_uri eq SGML_GENERAL_ENTITY) {
                   $val = {qw/amp & lt < quot " gt > apos '/}
                              ->{$src->local_name};
                 } else {
                   $val = chr $src->{value};
                 }
                 my $lc = $parent->{<H::infoset:children>}->[-1];
                 if ($lc and $lc->{<H::DOMCore:nodeType>} eq <H::DOMCore:Text>) {
                   $lc->{<H::infoset:content>} .= $val;
                 } else {
                   my $text = <ClassM::DOMCore:ManakaiDOMText.newObject>;
                   $parent-><M::NodeStem.importTree> ($text);
                   $text->{<H::DOMCore:ownerDocument>}
                     = $parent->{<H::DOMCore:ownerDocument>};
                   $text->{<H::infoset:content>} = $val;
                   $text->{<H::infoset:parent>} = $parent;
                   push @{$parent->{<H::infoset:children>}}, $text;
                 }
               } elsif ($src->namespace_uri eq SGML_GENERAL_ENTITY) {
                 my $text = <ClassM::DOMXML:ManakaiDOMEntityReference.newObject>;
                 $parent-><M::NodeStem.importTree> ($text);
                 $text->{<H::DOMCore:ownerDocument>}
                   = $parent->{<H::DOMCore:ownerDocument>} || $parent;
                 $text->{<H::DOMCore:name>} = $src->{local_name};
                 $text->{<H::ManakaiDOM:isExpanded>} = false;
                    ## TODO: Expansion
                 $text->{<H::infoset:parent>} = $parent;
                 push @{$parent->{<H::infoset:children>}}, $text;
                 if ($src->get_attribute ('base', namespace_uri => <Q::xml:>)) {
                   $text->{<H::infoset:baseURI>} = $src->get_attribute_value
                                         ('base', namespace_uri => <Q::xml:>);
                 }
               } else {
                 warn "{Impl} References not supported.\n";
                 __EXCEPTION{
                   DOMLS:LSException.PARSE_ERR::
                 }__;
                    ## Not supported err
               }
             } elsif ($src->node_type eq '#pi') {
               my $text = <ClassM::DOMXML:ManakaiDOMProcessingInstruction
                                           .newObject>;
               $parent-><M::NodeStem.importTree> ($text);
               $text->{<H::DOMCore:ownerDocument>}
                   = $parent->{<H::DOMCore:ownerDocument>} || $parent;
               $text->{<H::infoset:target>} = $src->{local_name};
               $text->{<H::infoset:data>} = $src->inner_text;
               $text->{<H::infoset:parent>} = $parent;
               push @{$parent->{<H::infoset:children>}}, $text;
             } elsif ($src->node_type eq '#section') {
               \## TODO: Include/Ignore sections
               my $text = <ClassM::DOMXML:ManakaiDOMCDATASection.newObject>;
               $parent-><M::NodeStem.importTree> ($text);
               $text->{<H::DOMCore:ownerDocument>}
                   = $parent->{<H::DOMCore:ownerDocument>};
               $text->{<H::infoset:content>} = $src->inner_text;
               $text->{<H::infoset:parent>} = $parent;
               push @{$parent->{<H::infoset:children>}}, $text;
             } else {
               warn "{Impl} Node of type ".$src->node_type." not supported.\n";
               __EXCEPTION{
                 DOMLS:LSException.PARSE_ERR::
               }__;
                  ## Not supported err
             }
##XMLParser2003
