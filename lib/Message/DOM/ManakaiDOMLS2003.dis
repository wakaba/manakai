Module:
  @QName: 
    MDOM:ManakaiDOMLS2003
  @Namespace:
    http://suika.fam.cx/~wakaba/archive/2004/9/27/mdom-old-ls#
  @FullName:
    @@@: Manakai DOM Load Transitional Module
    @@@@lang:en
  @Description:
    @@lang:en
    @@@:
      A set of interfaces for loading document objects. 
    \
      This module instantiate XML documents using the module 
      <PerlModule:Message::Markup::XML::Parser>, a simple XML parser 
      written in Perl.  Note that module is known to having 
      numbers of problems and its successor is now under development. 
      This DOM module is intended to be used for only the 
      transitional period.
    
  @Author:
     @@FullName: Wakaba
     @@Mail: w@suika.fam.cx
  @License:
    @@@:
      license:Perl+MPL
    @@Original:
      @@@FullName:
        manakai <FILE:xml-validator.pl>
      @@@Year:2003
      @@@Author:
        @@@@FullName:Wakaba
        @@@@Mail:w@suika.fam.cx
  @Date:
    @@@:
      $Date: 2005/02/19 07:21:14 $
    @@ContentType:
      dis:Date.RCS

  @DefaultFor:
    ManakaiDOM:ManakaiDOMLatest

  @Require:
     @@Module:
        @@@Name:  DOMCore
     @@Module:
        @@@Name:  DOMXML
     @@Module:
       @@@Name: DOMLS
     @@Module:
       @@@Name: ManakaiDOMLS2003
       @@@WithFor:
         ManakaiDOM:ManakaiDOMLatest

Namespace:
  @dis:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#dis--
  @infoset:
     http://www.w3.org/2001/04/infoset#
  @lang:
     http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#
  @license:
     http://suika.fam.cx/~wakaba/archive/2004/8/18/license#
  @LSEV:
    http://www.w3.org/2002/DOMLS
  @ManakaiDOM:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#
  @ManakaiDOMCore:
    http://suika.fam.cx/~wakaba/archive/2004/mdom-core#
  @ManakaiDOMLS:
    http://suika.fam.cx/~wakaba/archive/2004/mdom-ls#
  @MDOM:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#ManakaiDOM.
  @MDOMX:
    http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#
  @null:
    http://suika.fam.cx/~wakaba/-temp/2003/09/27/null
  @rdf:
    http://www.w3.org/1999/02/22-rdf-syntax-ns#
  @rdfs:
    http://www.w3.org/2000/01/rdf-schema#
  @TreeCore:\
  @xml:
    http://www.w3.org/XML/1998/namespace
  @xmlns:
    http://www.w3.org/2000/xmlns/

## -- Feature

ElementTypeBinding:
  @Name: FeatureDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DOMMain:DOMFeature
    @@AliasFor:
      @@@@:
        ::ManakaiDOM:all
      @@@For:
        !=ManakaiDOM:all
ElementTypeBinding:
  @Name: FeatureVerDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DOMMain:DOMFeature
ElementTypeBinding:
  @Name: featureQName
  @ElementType:
    dis:AppName
  @ShadowContent:
    @@ContentType:
      dis:TypeQName

FeatureDef:
  @QName:
    ManakaiDOMLS2003:LS
  @FeatureVerDef:
    @@Version:1.0
    @@QName: LSFeature10
    @@ISA: 
      ManakaiDOMLS2003:LS
    @@DOMMain:requireFeature:
      DOMXML:XMLFeature30
    @@FullName:
      @@@lang:en
      @@@@:
        Manakai DOM Load Transitional Module.

ElementTypeBinding:
  @Name: Method
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:DOMMethod
    @@ForCheck:
      ManakaiDOM:DOM !=ManakaiDOM:ManakaiDOM
ElementTypeBinding:
  @Name: IntMethod
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:DOMMethod
    @@ForCheck:
      ManakaiDOM:ManakaiDOM !=ManakaiDOM:ManakaiDOM
    @@ManakaiDOM:isForInternal: 1

ElementTypeBinding:
  @Name: Param
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:DOMMethodParameter
ElementTypeBinding:
  @Name: Return
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:DOMMethodReturn

ElementTypeBinding:
  @Name: Attr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:DOMAttribute
    @@ForCheck:
      ManakaiDOM:DOM !=ManakaiDOM:ManakaiDOM

ElementTypeBinding:
  @Name: Get
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:DOMAttrGet

ElementTypeBinding:
  @Name: InCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:InCase

ElementTypeBinding:
  @Name: Exception
  @ElementType:
    ManakaiDOM:raises

ElementTypeBinding:
  @Name: PerlDef
  @ElementType:
    dis:Def
  @ShadowContent:
    @@ContentType:
      lang:Perl

ResourceDef:
  @Name:  ManakaiDOMImplementationLS2003
  @rdf:type:
    ManakaiDOM:Class
  @For:
    ManakaiDOM:ManakaiDOMLatest
  @ISA:
    DOMCore:ManakaiDOMImplementation
  @Role:
    @@@:
      DOMCore:DOMImplementation::ManakaiDOM:ManakaiDOM
    @@compat:
      DOMCore:ManakaiDOMImplementation::ManakaiDOM:ManakaiDOMLatest
  @DOMMain:implementFeature: LSFeature10

  @Description:
    @@lang:en
    @@@:
      The factory methods for creating the objects required for loading.
  @ImplNote:
    @@lang:en
    @@@:
      It is expected that an instance of the <IF:ManakaiDOMImplementationLS2003> 
      interface can be obtained by binding-specific casting 
      methods on an instance of the <IF:DOMImplementation> interface 
      or <M:DOMImplementation.getFeature> with parameters 
      <Feature:ManakaiDOMLS2003:LS> and <FeatureVer:1.0>.

  @Method:
     @@Name:  createLSParser
     @@Description:
       @@@lang:en
       @@@@:
         Create a new parser object.
     @@Param:
        @@@Name:  mode
        @@@Type: 
          DOMLS:DOMImplementationLSMode
        @@@InCase:
          @@@@Label:
            <DOM:MODE_SYNCHRONOUS>
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The <IF:ManakaiXMLParser2003> created will 
              operate in synchronous mode.
     @@Param:
        @@@Name:  schemaType
        @@@Type: 
          DOMMain:DOMString
        @@@actualType:
          ManakaiDOM:ManakaiDOMURI
        @@@Description:
          @@@@lang:en
          @@@@@:
            An absolute URI representing the type of the schema language 
            used during the load of a <IF:Document> using the newly 
            created <IF:ManakaiXMLParser2003>.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The <IF:ManakaiXMLParser2003> will be free to use any schema 
              found.
        @@@InCase:
          @@@@Value:
            http://www.w3.org/TR/REC-xml
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The XML 1.0 DTD.
     @@Return:
        @@@Type:  ManakaiXMLParser2003
        @@@Description:
          @@@@lang:en
          @@@@@:
            The newly created parser object.
        @@@ImplNote:
          @@@@lang:en
          @@@@@:
            By default, the parameter <DOM:error-handler> of the 
            <A:LSParser.domConfig> is <DOM:null>.  However, 
            the DOM implementation may provide a default error handler instead.
        @@@Exception:
           @@@@Name:  NOT_SUPPORTED_ERR
           @@@@Type:
              DOMCore:DOMException
           @@@@SubType:
             @@@@@QName:
               ManakaiDOMLS:MDOMLS_IMPL_NOSUPPORT_MODE
             @@@@@Description:
               @@@@@@lang:en
               @@@@@@@: The requested mode is not supported.
           @@@@SubType:
             @@@@@QName:
               MDOMX:MDOM_IMPL_NOSUPPORT_SCHEMA
             @@@@@Description:
               @@@@@@lang:en
               @@@@@@@: The requested schema language is not supported.
       @@@PerlDef:
         if (not defined $mode or 
             $mode != <C::DOMLS:DOMImplementationLS.MODE_SYNCHRONOUS>) {
           __EXCEPTION{
             ManakaiDOMLS:MDOMLS_IMPL_NOSUPPORT_MODE::
               DOMLS:mode => {$mode},
               MDOMX:param-name => 'mode',
           }__;
         }
         if (defined $schemaType and
             $schemaType ne q<http://www.w3.org/TR/REC-xml>) {
           __EXCEPTION{
             MDOMX:MDOM_IMPL_NOSUPPORT_SCHEMA::
               DOMCore:schemaType => {$schemaType},
               MDOMX:param-name => 'schemaType',
           }__;
         }
         
         ## ** Code from bin/xml-validator.pl **
         my $eh = sub {
           \#line 1 "Error handler code from bin/xml-validator.pl"
		my ($self, $o, $error_type, $error_msg, $err) = @_;
		if ($err->{raiser_type} and
                    $err->{raiser_type} eq 'Message::Markup::XML::Validator') {
		  $error_msg = $err->{node_path} . ': ' . $error_msg
                              if $err->{node_path};
		  $error_msg = 'Document <'.$err->{uri}.'>: ' . $error_msg
                              if $err->{uri};
		}
		#if (($src{stop_with_fatal}
		# && {qw/fatal 1 wfc 1 nswfc 1/}->{$error_type->{level}})
		# || ($src{stop_with_vc}
		# && {qw/vc 1 nsvc 1/}->{$error_type->{level}})) {
		#  local $Carp::CarpLevel = 1;
		#  Carp::croak ('{'.$error_type->{level}.'} '.$error_msg);
		#} else {
		#  local $Carp::CarpLevel = 1;
		#  Carp::carp ('{'.$error_type->{level}.'} '.$error_msg);
		#}
                ## TODO: Report error by DOMError
                if ({fatal=>1, wfc=>1, nswfc=>1}->{$error_type->{level}}) {
                  warn "{{$error_type->{level}}} $error_msg.\n";
                  __EXCEPTION{
                    DOMLS:ManakaiDOMLSException.PARSE_ERR::
                  }__;
                } else {
                  #warn "{$error_type->{level}} $error_msg.\n";
                }
	   return 0;
           \#line 1 "ManakaiDOMImplementationLS2003.createLSParser #2"
         };

                                               ## Method from MMXParser
         $r = <Class::ManakaiXMLParser2003>->new (option => {
           uri_resolver => sub {
             \#line 1 "URI resolver from bin/xml-validator.pl"
		my ($self, $parser, $decl, $p) = @_;
		#unless (defined $catalog) {
		#  require Message::Markup::XML::Catalog;
		#  $catalog = Message::Markup::XML::Catalog->new;
		#  $catalog->option (uri_resolver => sub {
		#    my ($self, $parser, $decl, $p) = @_;
		#    print STDERR "Retriving catalog entity <$p->{uri}>...\n";
		#    return 1;
		#  });
		#  $catalog->option (dtd_of_xml_catalog_1_0 => $src{catalog_dtd});
		#}
		#$p->{uri} = $catalog->resolve_external_id ({public => $p->{PUBLIC},
		#                                            system => $p->{uri}},
		#                                           catalogs => [$src{catalog}],
		#                                           return_default => 1);
		#print STDERR "Retriving external entity <$p->{uri}>...\n";
		return 1;
           \#line 1 "ManakaiDOMImplementationLS2003.createLSParser #3"
          },
	   error_handler => $eh,
         });
         ## ** End Code from bin/xml-validator.pl **

         $r->flag (<Q::DOMCore:implementation> => $self);
         $r->flag (<Q::ManakaiDOM:implID> => $self->{<Q::TreeCore:node>}
                                                 ->{<Q::ManakaiDOM:implID>});

         $r->flag (<Q::DOMCore:domConfig> => $self->{<Q::TreeCore:node>}
                                                 ->{<Q::DOMCore:domConfig>});

  @Method:
     @@Name:  createLSInput
     @@Description:
       @@@lang:en
       @@@@:
         Create a new empty input source object.
     @@Return:
        @@@Type:  
          DOMLS:LSInput
        @@@Description:
          @@@@lang:en
          @@@@@: The newly created input object.
        @@@PerlDef:
            $r = <ClassM::DOMLS:ManakaiDOMLSInput.new>;
      @@ImplNote:
         @@@lang:en
         @@@@:
           See also <M:DOMImplementationLS.createLSInput>.
##IF:ManakaiDOMImplementationLS2003

ResourceDef:
  @Name:  ManakaiXMLParser2003
  @rdf:type:
    ManakaiDOM:Class
  @For:
    ManakaiDOM:ManakaiDOMLatest
  @AppISA:
    @@@: 
      Message::Markup::XML::Parser
    @@ContentType:
      lang:Perl
  @ISA:
    ManakaiDOM:ManakaiDOMObject
  @DOMMain:implementFeature: LSFeature10

  @Description:
    @@lang:en
    @@@:
      An interface to an object that is able to build 
      a DOM tree from string data or a URI reference.
  @ImplNote:
    @@lang:en
    @@@:
      {P:: When a document is first made available via the 
      <IF:ManakaiXMLParser2003>, 
      \
      - there will never be two adjacent <IF:Text> nodes.
      \
      - there will never be empty text nodes.
      \
      - <A:Attr.value> will be XML 1.0 normalized value.
      \
      }

  @Attr:
     @@Name:  domConfig
     @@Description:
       @@@lang:en
       @@@@:
         The configuration object used when parsing an input source. 
       \
         Note that this configuration is specific to the parse 
         operation.  No parameter values from this 
         configuration object are passed automatically to the 
         configuration object on the <IF:Document> that is created, or 
         used, by the parse operation.
     @@Get:
        @@@Type:  
          DOMCore:DOMConfiguration
        @@@PerlDef:
            $r = $self->option (<Q::DOMCore:domConfig>);
  @Method:
     @@Name:  parse
     @@Description:
       @@@lang:en
       @@@@:
         Parse an XML document from a resource identified by a 
         <IF:LSInput>.
     @@Param:
        @@@Name:  input
        @@@Type:  
          DOMLS:LSInput
        @@@Description:
          @@@@lang:en
          @@@@@:
            The <IF:LSInput> object from which the source of 
            the document is to be read.
     @@Return:
        @@@Type: 
          DOMCore:Document
        @@@actualType:
          DOMCore:ManakaiDOMDocument
        @@@Description:
          @@@@lang:en
          @@@@@:
            The newly created and populated <IF:Document>.
        @@@Exception:
           @@@@Name:  PARSE_ERR
           @@@@Type:  
             DOMLS:LSException
           @@@@Description:
             @@@@@lang:en
             @@@@@@:
               The <IF:LSParser> was unable to load the XML document. 
       @@@PerlDef:
           my $text;
           my $uri;
           ## 1. characterStream
           ## 2. byteStream
           ## 3. stringData
           if (defined (my $sd = $input-><AG::DOMLS:LSInput
                                    ::ManakaiDOM:ManakaiDOMLatest.stringData>)) {
             $text = \$sd;
           }
           ## 4. systemId
           ## 5. publicId
           elsif (defined (my $sysId = $input-><AG::DOMLS:LSInput
                                    ::ManakaiDOM:ManakaiDOMLatest.systemId>) or
                  defined (my $pubId = $input-><AG::DOMLS:LSInput
                                    ::ManakaiDOM:ManakaiDOMLatest.publicId>)) {
             $uri = $sysId;
             __EXCEPTION{
               DOMCore:ManakaiDOMException.NOT_SUPPORTED_ERR::
             }__;
           }

           $self->option (document_entity_base_uri =>
                                    $input-><AG::DOMLS:LSInput
                                    ::ManakaiDOM:ManakaiDOMLatest.baseURI>);

           my $doc;
           __DEEP{
             $doc = $self->parse_text ($$text,
                                        {uri => $uri,
                                         entity_type => 'document_entity'});
           }__;
           \## TODO: error & uri handler
           \## TODO: support of domConfig

           my $node = <ClassM::DOMCore:ManakaiDOMDocument.newObject>;
           $node->{<Q::DOMCore:implementation>}
                = $self->flag (<Q::DOMCore:implementation>);
           $node->{<Q::ManakaiDOM:implID>}
                = $self->flag (<Q::ManakaiDOM:implID>);
           $node->{<Q::infoset:version>} = '1.0';
           $node->{<Q::DOMCore:hasFeature>}->{XML} = 1;
           if ($doc->node_type eq '#document') {
             __DEEP{
             for my $src (@{$doc->child_nodes}) {
               if ($src->node_type eq '#element') {
                 $self-><M::ManakaiXMLParser2003.toDOMNode> ($src => $node);
               } elsif ($src->node_type eq '#pi' and
                        $src->local_name eq 'xml') {
                 $node->{<Q::infoset:version>}
                      = $src->get_attribute_value ('version', default => '1.0');
                 $node->{<Q::DOMCore:xmlEncoding>}
                      = $src->get_attribute_value ('encoding');
                 $node->{<Q::infoset:xmlStandalone>}
                      = $src->get_attribute_value ('standalone');
               } elsif ({
                          '#pi' => 1, '#comment' => 1,
                        }->{$src->node_type}) {
                 $self-><M::ManakaiXMLParser2003.toDOMNode> ($src => $node);
               } else {
                 # not supported
               }
             }}__;
           } else {
             __EXCEPTION{
               MDOMX:MDOM_DEBUG_BUG::
               MDOMX:values => {{node_type => $doc->node_type}},
             }__;
           }
           $r = <ClassM::DOMCore:ManakaiDOMNode.getNodeReference> ($node);

  @IntMethod:
    @@Name: toDOMNode
    @@Param:
      @@@Name:src
      @@@Type:
        DOMMain:DOMObject
      @@@Description:
        @@@@lang:en
        @@@@@:
          A <PerlModule:Message::Markup::XML::Node> object to be converted.
    @@Param:
      @@@Name:parent
      @@@Type:
        ManakaiDOMCore:ManakaiDOMNodeObjectNode
      @@@Description:
        @@@@lang:en
        @@@@@:
          The parent DOM <IF:Node> object.
    @@Return:
      @@@PerlDef:
        use Message::Markup::XML::QName qw/DEFAULT_PFX NULL_URI/;
        use Message::Markup::XML::Node qw/SGML_NCR SGML_HEX_CHAR_REF
                                          SGML_GENERAL_ENTITY/;

             if ($src->node_type eq '#element') {
               my $newNode = <ClassM::DOMCore:ManakaiDOMElement.newObject>;
               $parent-><M::ManakaiDOM:ManakaiDOMNodeObject.importTree>
                                                           ($newNode);
               $newNode->{<Q::DOMCore:ownerDocument>}
                 = $parent->{<Q::DOMCore:ownerDocument>} || $parent;
               $newNode->{<Q::infoset:prefix>}
                 = defined $src->{namespace_prefix}
                     ? $src->{namespace_prefix} eq DEFAULT_PFX
                         ? null : length $src->{namespace_prefix}
                                ? $src->{namespace_prefix} 
                         : null
                     : null;
               if (defined $src->{namespace_uri} and
                   $src->{namespace_uri} ne '' and
                   $src->{namespace_uri} ne NULL_URI) {
                 $newNode->{<Q::infoset:namespaceName>} = $src->{namespace_uri};
               } else {
                 $newNode->{<Q::infoset:namespaceName>} = null;
               }
               $newNode->{<Q::infoset:localName>} = $src->{local_name};
               $newNode->{<Q::infoset:parent>} = $parent;
               push @{$parent->{<Q::infoset:children>}}, $newNode;
               for (@{$src->{node}}) {
                 $self-><M::ManakaiXMLParser2003.toDOMNode> ($_ => $newNode);
               }
               for my $prefix (keys %{$src->{ns}||{}}) {
                 my $ns = <ClassM::DOMCore:ManakaiDOMAttr.newObject>;
                 $newNode-><M::ManakaiDOM:ManakaiDOMNodeObject.importTree> ($ns);
                 $ns->{<Q::DOMCore:ownerDocument>}
                   = $newNode->{<Q::DOMCore:ownerDocument>};
                 $ns->{<Q::infoset:prefix>}
                   = $prefix eq DEFAULT_PFX ? null : $prefix;
                 $ns->{<Q::infoset:namespaceName>} = <Q::xmlns:>;
                 $ns->{<Q::infoset:localName>}
                   = $prefix eq DEFAULT_PFX ? 'xmlns' : $prefix;
                 $ns->{<Q::infoset:ownerElement>} = $newNode;
                 $ns->{<Q::infoset:specified>} = true;
                 $newNode->{<Q::infoset:attributes>}
                         ->{<Q::xmlns:>}
                         ->{$ns->{<Q::infoset:localName>}} = $ns;
                 if (defined $src->{ns}->{$prefix} and
                     length $src->{ns}->{$prefix} and 
                     $src->{ns}->{$prefix} ne NULL_URI) {
                   my $text = <ClassM::DOMCore:ManakaiDOMText.newObject>;
                   $ns-><M::ManakaiDOM:ManakaiDOMNodeObject.importTree> ($text);
                   $text->{<Q::DOMCore:ownerDocument>}
                     = $ns->{<Q::DOMCore:ownerDocument>};
                   $text->{<Q::infoset:content>} = $src->{ns}->{$prefix};
                   $text->{<Q::infoset:parent>} = $ns;
                   push @{$ns->{<Q::infoset:children>}}, $text;
                 }
               }
             } elsif ($src->node_type eq '#attribute') {
               my $newNode = <ClassM::DOMCore:ManakaiDOMAttr.newObject>;
               $parent-><M::ManakaiDOM:ManakaiDOMNodeObject.importTree>
                                                           ($newNode);
               $newNode->{<Q::DOMCore:ownerDocument>}
                 = $parent->{<Q::DOMCore:ownerDocument>};
               $newNode->{<Q::infoset:prefix>}
                 = defined $src->{namespace_prefix}
                     ? $src->{namespace_prefix} eq DEFAULT_PFX
                         ? null : length $src->{namespace_prefix}
                                ? $src->{namespace_prefix}
                         : null
                     : null;
               $newNode->{<Q::infoset:localName>} = $src->{local_name};
               $newNode->{<Q::infoset:ownerElement>} = $parent;
               $newNode->{<Q::infoset:specified>} = true;
               if (defined $src->{namespace_uri} and
                   $src->{namespace_uri} ne '' and
                   $src->{namespace_uri} ne NULL_URI) {
                 $newNode->{<Q::infoset:namespaceName>} = $src->{namespace_uri};
                 $parent->{<Q::infoset:attributes>}
                        ->{$src->{namespace_uri}}
                        ->{$newNode->{<Q::infoset:localName>}} = $newNode;
               } else {
                 $newNode->{<Q::infoset:namespaceName>} = null;
                 $parent->{<Q::infoset:attributes>}
                        ->{<Q::null:>}
                        ->{$newNode->{<Q::infoset:localName>}} = $newNode;
               }
               if (defined $src->{value} and length $src->{value}) {
                 my $text = <ClassM::DOMCore:ManakaiDOMText.newObject>;
                 $newNode-><M::ManakaiDOM:ManakaiDOMNodeObject.importTree>
                                                           ($text);
                 $text->{<Q::DOMCore:ownerDocument>}
                   = $newNode->{<Q::DOMCore:ownerDocument>};
                 $text->{<Q::infoset:content>} = $src->{value};
                 $text->{<Q::infoset:parent>} = $newNode;
                 push @{$newNode->{<Q::infoset:children>}}, $text;
               }
               for (@{$src->{node}}) {
                 $self-><M::ManakaiXMLParser2003.toDOMNode> ($_ => $newNode);
               }
             } elsif ($src->node_type eq '#text') {
               my $lc = $parent->{<Q::infoset:children>}->[-1];
               if ($lc and $lc->{<Q::DOMCore:nodeType>} eq <Q::DOMCore:Text>) {
                 $lc->{<Q::infoset:content>} .= $src->{value};
               } elsif (defined $src->{value} and length $src->{value}) {
                 my $text = <ClassM::DOMCore:ManakaiDOMText.newObject>;
                 $parent-><M::ManakaiDOM:ManakaiDOMNodeObject.importTree>
                                                           ($text);
                 $text->{<Q::DOMCore:ownerDocument>}
                   = $parent->{<Q::DOMCore:ownerDocument>};
                 $text->{<Q::infoset:content>} = $src->inner_text;
                 $text->{<Q::infoset:parent>} = $parent;
                 push @{$parent->{<Q::infoset:children>}}, $text;
               }
             } elsif ($src->node_type eq '#comment') {
               if (defined $src->{value} and length $src->{value}) {
                 my $text = <ClassM::DOMCore:ManakaiDOMComment.newObject>;
                 $parent-><M::ManakaiDOM:ManakaiDOMNodeObject.importTree>
                                ($text);
                 $text->{<Q::DOMCore:ownerDocument>}
                   = $parent->{<Q::DOMCore:ownerDocument>} || $parent;
                 $text->{<Q::infoset:content>} = $src->inner_text;
                 $text->{<Q::infoset:parent>} = $parent;
                 push @{$parent->{<Q::infoset:children>}}, $text;
               }
             } elsif ($src->node_type eq '#reference') {
               if ($src->namespace_uri eq SGML_NCR or
                   $src->namespace_uri eq SGML_HEX_CHAR_REF or
                   ($src->namespace_uri eq SGML_GENERAL_ENTITY and
                    {qw/amp 1 lt 1 quot 1 gt 1 apos 1/}->{$src->local_name})) {
                 my $val;
                 if ($src->namespace_uri eq SGML_GENERAL_ENTITY) {
                   $val = {qw/amp & lt < quot " gt > apos '/}
                              ->{$src->local_name};
                 } else {
                   $val = chr $src->{value};
                 }
                 my $lc = $parent->{<Q::infoset:children>}->[-1];
                 if ($lc and $lc->{<Q::DOMCore:nodeType>} eq <Q::DOMCore:Text>) {
                   $lc->{<Q::infoset:content>} .= $val;
                 } else {
                   my $text = <ClassM::DOMCore:ManakaiDOMText.newObject>;
                   $parent-><M::ManakaiDOM:ManakaiDOMNodeObject.importTree>
                                                           ($text);
                   $text->{<Q::DOMCore:ownerDocument>}
                     = $parent->{<Q::DOMCore:ownerDocument>};
                   $text->{<Q::infoset:content>} = $val;
                   $text->{<Q::infoset:parent>} = $parent;
                   push @{$parent->{<Q::infoset:children>}}, $text;
                 }
               } elsif ($src->namespace_uri eq SGML_GENERAL_ENTITY) {
                 my $text = <ClassM::DOMXML:ManakaiDOMEntityReference.newObject>;
                 $parent-><M::ManakaiDOM:ManakaiDOMNodeObject.importTree>
                                                           ($text);
                 $text->{<Q::DOMCore:ownerDocument>}
                   = $parent->{<Q::DOMCore:ownerDocument>} || $parent;
                 $text->{<Q::DOMCore:name>} = $src->{local_name};
                 $text->{<Q::ManakaiDOM:isExpanded>} = false;
                    ## TODO: Expansion
                 $text->{<Q::infoset:parent>} = $parent;
                 push @{$parent->{<Q::infoset:children>}}, $text;
                 if ($src->get_attribute ('base', namespace_uri => <Q::xml:>)) {
                   $text->{<Q::infoset:baseURI>} = $src->get_attribute_value
                                         ('base', namespace_uri => <Q::xml:>);
                 }
               } else {
                 warn "{Impl} References not supported.\n";
                 __EXCEPTION{
                   DOMLS:ManakaiDOMLSException.PARSE_ERR::
                    ## Not supported err
                 }__;
               }
             } elsif ($src->node_type eq '#pi') {
               my $text = <ClassM::DOMXML:ManakaiDOMProcessingInstruction
                                           .newObject>;
               $parent-><M::ManakaiDOM:ManakaiDOMNodeObject.importTree>
                                                           ($text);
               $text->{<Q::DOMCore:ownerDocument>}
                   = $parent->{<Q::DOMCore:ownerDocument>} || $parent;
               $text->{<Q::infoset:target>} = $src->{local_name};
               $text->{<Q::infoset:data>} = $src->inner_text;
               $text->{<Q::infoset:parent>} = $parent;
               push @{$parent->{<Q::infoset:children>}}, $text;
             } elsif ($src->node_type eq '#section') {
               \## TODO: Include/Ignore sections
               my $text = <ClassM::DOMXML:ManakaiDOMCDATASection.newObject>;
               $parent-><M::ManakaiDOM:ManakaiDOMNodeObject.importTree>
                                                           ($text);
               $text->{<Q::DOMCore:ownerDocument>}
                   = $parent->{<Q::DOMCore:ownerDocument>};
               $text->{<Q::infoset:content>} = $src->inner_text;
               $text->{<Q::infoset:parent>} = $parent;
               push @{$parent->{<Q::infoset:children>}}, $text;
             } else {
               warn "{Impl} Node of type ".$src->node_type." not supported.\n";
               __EXCEPTION{
                 DOMLS:ManakaiDOMLSException.PARSE_ERR::
                  ## Not supported err
               }__;
             }


  @Method:
     @@Name:  parseURI
     @@Description:
       @@@lang:en
       @@@@:
         Parse an XML document from a location identified by a 
         URI reference <SRC:<CITE:RFC 2396>>.
     @@Param:
        @@@Name:  uri
        @@@Type: 
          DOMMain:DOMString
        @@@actualType:
          ManakaiDOM:ManakaiDOMURI
        @@@Description:
          @@@@lang:en
          @@@@@:
            The location of the XML document to be read, 
            as a URI reference <SRC:<CITE:RFC 2396>>. 
        @@@InCase:
          @@@@Label:
            @@@@@lang:en
            @@@@@@: URI reference with a fragemnt identifier
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The behavior is undefined; it may be defined in future 
              version of the DOM specification.
     @@Return:
        @@@Type:  
          DOMCore:Document
        @@@actualType:
          DOMCore:ManakaiDOMDocument
        @@@Description:
          @@@@lang:en
          @@@@@:
            The newly created and populated <IF:Document>.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The <IF:LSParser> is asynchronous.
        @@@Exception:
           @@@@Name:  INVALID_STATE_ERR
           @@@@Type:
              DOMCore:DOMException
           @@@@SubType:
             @@@@@QName:
               ManakaiDOMLS:MDOMLS_BUSY
             @@@@@Description:
               @@@@@@lang:en
               @@@@@@@:
                 <A:LSParser.busy> is <DOM:true>.
        @@@Exception:
           @@@@Name:  PARSE_ERR
           @@@@Type:  
             DOMLS:LSException
           @@@@Description:
             @@@@@lang:en
             @@@@@@:
               The <IF:LSParser> was unable to load the XML document. 
           @@@@ImplNote:
             @@@@@lang:en
             @@@@@@:
               DOM applications should use an error handler to get 
               details on the error.
##IF:ManakaiXMLParser2003

## ManakaiDOMLS2003.dis ends here
