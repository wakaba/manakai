Module:
  @QName: MDOM|Traversal
  @enFN:
    DOM Traversal Module
  @enDesc:
    The <DFN::manakai DOM Traversal Module> implements the W3C Document
    Object Model Traversal Module defined in the W3C Document
    Object Model (DOM) Traversal and Range Specification.  Its
    <IF::TreeWalker>, <IF::NodeIterator>, and <IF::NodeFilter>
    interfaces provide easy-to-use, robust, and selective
    traversal of document's contents.

  @Namespace:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/DOM/Traversal/

  @DISCore:author: DISCore|Wakaba
  @License: license|Perl+MPL
  @Date:
    $Date: 2006/05/13 12:30:36 $

  @Require:
    @@Module:
      @@@QName: MDOM|TreeCore
      @@@WithFor: ManakaiDOM|ManakaiDOMLatest
    @@Module:
      @@@WithFor: ManakaiDOM|ManakaiDOM
    @@Module:
      @@@WithFor: ManakaiDOM|ManakaiDOM2
    @@Module:
      @@@WithFor: ManakaiDOM|ManakaiDOMLatest
  @DefaultFor: ManakaiDOM|ManakaiDOMLatest

Namespace:
  @c:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#
  @dis:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#dis--
  @dx:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#
  @ecore:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/Core/
  @f:
    http://suika.fam.cx/~wakaba/archive/2004/dom/feature#
  @fe:
    http://suika.fam.cx/www/2006/feature/
  @idl:
    http://suika.fam.cx/~wakaba/archive/2004/dis/IDL#
  @infoset:
    http://www.w3.org/2001/04/infoset#
  @kwd:
    http://suika.fam.cx/~wakaba/archive/2005/rfc2119/
  @lang:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#
  @license:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/license#
  @ManakaiDOM:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#
  @MDOM:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#ManakaiDOM.
  @MDOMX:
    http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#
  @dlp:
    http://suika.fam.cx/~wakaba/archive/2004/dis/Perl#
  @tc:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/DOM/TreeCore/
  @tcd:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/DOM/CharacterData/
  @td:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/DOM/Document/
  @te:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/DOM/Element/
  @test:
    http://suika.fam.cx/~wakaba/archive/2004/dis/Test#
  @trv:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/DOM/Traversal/
  @tx:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/DOM/XML/

ElementTypeBinding:
  @Name: CODE
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: dlp|BlockCode
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: Method
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|Method
    @@ForCheck: !=ManakaiDOM|ManakaiDOM

ElementTypeBinding:
  @Name: CMethod
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|Method
    @@ForCheck: !=ManakaiDOM|ManakaiDOM ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: L2Method
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|Method
    @@ForCheck: !=ManakaiDOM|ManakaiDOM ManakaiDOM|DOM2

ElementTypeBinding:
  @Name: Param
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|MethodParameter

ElementTypeBinding:
  @Name: Return
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|MethodReturn

ElementTypeBinding:
  @Name: Attr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|Attribute
    @@ForCheck: !=ManakaiDOM|ManakaiDOM

ElementTypeBinding:
  @Name: L2Attr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|Attribute
    @@ForCheck: !=ManakaiDOM|ManakaiDOM ManakaiDOM|DOM2

ElementTypeBinding:
  @Name: Get
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|AttributeGet

ElementTypeBinding:
  @Name: Set
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|AttributeSet

ElementTypeBinding:
  @Name: nullCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: ManakaiDOM|InCase
    @@Value:
      @@@is-null:1

ElementTypeBinding:
  @Name: PerlDef
  @ElementType:
    dis:Def
  @ShadowContent:
    @@ContentType: lang|Perl
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: enImplNote
  @ElementType:
    dis:ImplNote
  @ShadowContent:
    @@lang:en

ElementTypeBinding:
  @Name: enFN
  @ElementType:
    dis:FullName
  @ShadowContent:
    @@lang:en

ElementTypeBinding:
  @Name: IFCls2Def
  @ElementType: 
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType:
      @@@@: dis|MultipleResource
      @@@ForCheck: !ManakaiDOM|ForIF !ManakaiDOM|ForClass
    @@resourceFor: ManakaiDOM|ForIF
    @@resourceFor:
      @@@@: ManakaiDOM|ForClass
      @@@ForCheck: ManakaiDOM|ManakaiDOMLatest
    @@For: ManakaiDOM|DOM1
    @@For: =ManakaiDOM|ManakaiDOM

    @@DISCore:resourceType:
      @@@@: DISLang|Interface
      @@@ForCheck: ManakaiDOM|ForIF

    @@DISCore:resourceType:
      @@@@: DISLang|Class
      @@@ForCheck: ManakaiDOM|ForClass
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOM||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOM2||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM2
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOMLatest||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOMLatest

    @@f:implements:
      @@@@: TraversalFeature20
      @@@For: ManakaiDOM|DOM2

ElementTypeBinding:
  @Name: IFQName
  @ElementType:
    dis:QName
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForIF

ElementTypeBinding:
  @Name: ClsQName
  @ElementType:
    dis:QName
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: IFISA
  @ElementType:
    dis:ISA
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForIF

ElementTypeBinding:
  @Name: ClsISA
  @ElementType:
    dis:ISA
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: disDef
  @ElementType:
    dis:Def
  @ShadowContent:
    @@ContentType:
      lang:dis
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: Test
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: test|StandaloneTest
    @@ForCheck: ManakaiDOM|ForClass

ResourceDef:
  @QName: Document
  @AliasFor: td|Document
  @For: ManakaiDOM|DOM

ResourceDef:
  @QName: Element
  @AliasFor: te|Element
  @For: ManakaiDOM|DOM

ResourceDef:
  @QName: DOMString
  @AliasFor: DOMMain|DOMString
  @For: ManakaiDOM|DOM

ResourceDef:
  @QName: boolean
  @AliasFor: idl|boolean||ManakaiDOM|all

ResourceDef:
  @QName: unsignedLong
  @AliasFor: idl|unsignedLong||ManakaiDOM|all

ResourceDef:
  @QName: unsignedShort
  @AliasFor: idl|unsignedShort||ManakaiDOM|all

ResourceDef:
  @QName: ARRAY
  @AliasFor: dlp|ARRAY||ManakaiDOM|all

ResourceDef:
  @QName: HASH
  @AliasFor: dlp|HASH||ManakaiDOM|all

ResourceDef:
  @QName: Node
  @AliasFor: tc|Node
  @For: ManakaiDOM|ManakaiDOM

ElementTypeBinding:
  @Name: enDesc
  @ElementType:
    dis:Description
  @ShadowContent:
    @@lang:en

ElementTypeBinding:
  @Name: TrueCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType:
      ManakaiDOM:InCase
    @@Value:
      @@@@: 1
      @@@ContentType: DISCore|Boolean
    @@Type: idl|boolean||ManakaiDOM|all

ElementTypeBinding:
  @Name: FalseCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType:
      ManakaiDOM:InCase
    @@Value:
      @@@@: 0
      @@@ContentType: DISCore|Boolean
    @@Type: idl|boolean||ManakaiDOM|all

ElementTypeBinding:
  @Name: ShortConstGroup
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|ConstGroup
    @@ForCheck: ManakaiDOM|ForIF !=ManakaiDOM|ManakaiDOM
    @@Type: unsignedShort
    @@subsetOf: unsignedShort

ElementTypeBinding:
  @Name: BitMaskGroup
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|ConstGroup
    @@ForCheck: ManakaiDOM|ForIF !=ManakaiDOM|ManakaiDOM
    @@Type: unsignedShort
    @@subsetOf: unsignedShort

ElementTypeBinding:
  @Name: Const
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|Const

ElementTypeBinding:
  @Name: mConst
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|Const
    @@For: ManakaiDOM|ManakaiDOMLatest

ElementTypeBinding:
  @Name: intValue
  @ElementType:
    dis:Value
  @ShadowContent:
    @@ContentType: DISCore|Integer

## -- Features

ElementTypeBinding:
  @Name: FeatureDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: f|Feature
    @@For: =ManakaiDOM|all

ElementTypeBinding:
  @Name: FeatureVerDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: f|Feature

ElementTypeBinding:
  @Name: featureName
  @ElementType:
    f:name
  @ShadowContent:
    @@ContentType: DISCore|String

FeatureDef:
  @featureName: Traversal
  @QName: TraversalFeature
  @FeatureVerDef:
    @@QName: TraversalFeature20
    @@Version: 2.0
    @@f:instanceOf: TraversalFeature
    @@f:requires: c|CoreFeature20
    @@enDesc:
      The DOM Traversal Module, Level 2.

## -- Document

IFCls2Def:
  @IFQName: DocumentTraversal
  @ClsQName: ManakaiDOMDocumentTraversal

  @ClsISA: td|ManakaiDOMDocument

  @DISLang:role: tc|DocumentRole

  @enDesc:
    The <IF::DocumentTraversal> interface contains methods
    that create iterators and tree walkers to traverse a node
    and its children in document order.

    If the <Feature::Traversal> feature is supported, the
    <IF::DocumentTraversal> interface will be implemented
    by the same object that implement the
    <IF::Document> interface.

  @Test:
    @@QName: DocumentTraversal.interface.test
    @@PerlDef:
      for my $if (
        <IFName::DocumentTraversal>,
        <IFName::Document>,
        <IFName::f|GetFeature>,
      ) {
        $test->id ($if);
        $test->assert_isa (<ClassName::ManakaiDOMDocumentTraversal>, $if);
      }

  @Test:
    @@QName: Document.getFeature.DocumentTraversal.2.0.test
    @@PerlDef:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

      $test->assert_isa ($doc-><M::Node.getFeature> ('Traversal', '2.0'),
                         <IFName::DocumentTraversal||ManakaiDOM|ManakaiDOM2>);
  @Test:
    @@QName: Document.getFeature.DocumentTraversal.null.test
    @@PerlDef:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

      $test->assert_isa ($doc-><M::Node.getFeature> ('Traversal', null),
                         <IFName::DocumentTraversal||ManakaiDOM|ManakaiDOM>);
  @Test:
    @@QName: Document.getFeature.DocumentTraversal.empty.test
    @@PerlDef:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

      $test->assert_isa ($doc-><M::Node.getFeature> ('Traversal', ''),
                         <IFName::DocumentTraversal||ManakaiDOM|ManakaiDOM>);
  @Test:
    @@QName: Document.hasFeature+.DocumentTraversal.2.0.test
    @@PerlDef:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

      $test->assert_true ($doc-><M::Node.isSupported> ('+Traversal', '2.0'));
  @Test:
    @@QName: Document.hasFeature+.DocumentTraversal.null.test
    @@PerlDef:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

      $test->assert_true ($doc-><M::Node.isSupported> ('+Traversal', null));
  @Test:
    @@QName: Document.hasFeature+.DocumentTraversal.empty.test
    @@PerlDef:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

      $test->assert_true ($doc-><M::Node.isSupported> ('+Traversal', ''));

  @CODE:
    @@QName: createDocForTest
    @@PerlDef:
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
      $doctrv = $doc-><M::Node.getFeature> (Traversal => '2.0');

  @Method:
    @@Name: createNodeIterator
    @@Return:
      @@@enImplNote:
        {TODO::
          Implement this method.
        }

  @Method:
    @@Name: createTreeWalker
    @@enDesc:
      Creates a new <IF::TreeWalker> over the subtree rooted at the
      specified node.
    @@Param:
      @@@Name: root
      @@@Type: Node
      @@@enDesc:
        The node that will serve as the root for the <IF::TreeWalker>.

        The <P::whatToShow> flags and the <IF::NodeFilter>
        are not considered when setting this value; any node type
        will be accepted as the root.

        The <A::TreeWalker.currentNode> of the created <IF::TreeWalker>
        is initialized to the <P::root> node, whether or not it 
        is visible.  

        The <P::root> functions as a stopping point for traversal
        methods that look upwards in the document structure, such
        as <M::TreeWalker.parentNode> and <P::TreeWalker.nextNode>.

        The <P::root> must not be <DOM::null>.
    @@Param:
      @@@Name: whatToShow
      @@@Type: unsignedShort
      @@@actualType: WhatToShow
      @@@enDesc:
        The flags that specifies which node types may appear in the
        logical view of the tree presented by the tree walker.

        The set of the flags are defined in the <IF::NodeFilter> interface.
        They can be combined using the binary <CODE::OR> operation.
    @@Param:
      @@@Name: filter
      @@@Type: NodeFilter
      @@@enDesc:
        The <IF::NodeFilter> to be used with the created <IF::TreeWalker>.
      @@@nullCase:
        @@@@enDesc:
          Indicates that no filter is used.
    @@Param:
      @@@Name: entityReferenceExpansion
      @@@Type: boolean
      @@@enDesc:
        The <A::TreeWalker.expandEntityReferences> flag of 
        the created <IF::TreeWalker>.

          {SpecIssue::
            Poor description in the spec.
          }
      @@@FalseCase:
        @@@@enDesc:
          The contents of the <IF::tx|EntityReference> nodes
          are not presented in the logical view.
    @@Return:
      @@@Type: TreeWalker
      @@@enDesc:
        The newly created <IF::TreeWalker>.
      @@@dx:raises:
        @@@@@: c|SET_TO_NULL_ERR
        @@@@enDesc:
          If the specified <P::root> is <DOM::null>.
      @@@PerlDef:
        unless (defined $root) {
          __EXCEPTION{c|SET_TO_NULL_ERR::
            MDOMX|param-name => 'root',
          }__;
        }
        $r = bless {
          root => $root,
          what_to_show => defined $whatToShow ? $whatToShow : 0,
          filter => $filter,
          expand_entity_references => $entityReferenceExpansion,
          current_node => $root,
        }, <ClassName::ManakaiDOMTreeWalker>;

    @@Test:
      @@@QName: DocumentTraversal.createTreeWalker.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $doctrv = $doc-><M::Node.getFeature> (Traversal => '2.0');

        my $el = $doc-><M::Document.createElement> ('e');
        
        my $tw = $doctrv-><M::DocumentTraversal.createTreeWalker>
                            ($el);

        $test->id ('return');
        $test->assert_isa ($tw, <IFName::TreeWalker>);

        $test->id ('whatToShow');
        $test->assert_num_equals
                 (actual_value => $tw-><AG::TreeWalker.whatToShow>,
                  expected_value => 0);

        $test->id ('filter');
        $test->assert_null ($tw-><AG::TreeWalker.filter>);

        $test->id ('expandEntityReferences');
        $test->assert_false ($tw-><AG::TreeWalker.expandEntityReferences>);

        $test->id ('currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $el);
    @@Test:
      @@@QName: DocumentTraversal.createTreeWalker.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $doctrv = $doc-><M::Node.getFeature> (Traversal => '2.0');

        my $el = $doc-><M::Document.createElement> ('e');
        
        my $filter = sub { };
        my $tw = $doctrv-><M::DocumentTraversal.createTreeWalker>
                            ($el, <C::NodeFilter.SHOW_ALL>, $filter, true);

        $test->id ('return');
        $test->assert_isa ($tw, <IFName::TreeWalker>);

        $test->id ('whatToShow');
        $test->assert_num_equals
                 (actual_value => $tw-><AG::TreeWalker.whatToShow>,
                  expected_value => <C::NodeFilter.SHOW_ALL>);

        $test->id ('filter');
        $test->assert_equals ($tw-><AG::TreeWalker.filter>, $filter);

        $test->id ('filter.interface');
        $test->assert_isa ($tw-><AG::TreeWalker.filter>, <IFName::NodeFilter>);

        $test->id ('expandEntityReferences');
        $test->assert_true ($tw-><AG::TreeWalker.expandEntityReferences>);

        $test->id ('currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $el);
    @@Test:
      @@@QName: DocumentTraversal.createTreeWalker.3.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $doctrv = $doc-><M::Node.getFeature> (Traversal => '2.0');

        $test->assert_exception (code => sub {
          $doctrv-><M::DocumentTraversal.createTreeWalker>;
        }, exception_subtype => <Q::c|SET_TO_NULL_ERR>);
##DocumentTraversal

IFCls2Def:
  @IFQName: TreeWalker
  @ClsQName: ManakaiDOMTreeWalker
  
  @enDesc:
    <IF::TreeWalker> objects are used to navigate a document tree
    or subtree using the view of the document defined by their
    <A::TreeWalker.whatToShow> flags and filter (if any).  

    Omitting nodes from the logical view of a subtree can result 
    in a structure that is substantially different from the
    same subtree in the complete, unfiltered document.  Nodes
    that are siblings in the <IF::TreeWalker> view may be children
    of different, widely separeted nodes in the original view.
    For instance, consider a <IF::NodeFilter> that skips all nodes
    except for <IF::tcd|Text> nodes and the root node of a document. 
    In the logical view that results, all text nodes will be
    siblings and appear as direct children of the root node, 
    no matter how deeply nested the structure of the original document.

    A <IF::TreeWalker> may be active while the data structure it navigates
    is being edited, and must behave gracefully in the face of change.
    Additions and removals in the underlying data structure
    do not invalidate a <IF::TreeWalker>; in fact, a <IF::TreeWalker>
    is never invalidated.

    All the <IF::TreeWalker>'s navigation methods operate in terms
    of the context of the <A::TreeWalker.contextNode> at the time
    they invoked, no matter what has happened to, or around,
    that node since the last time the <IF::TreeWalker> was accessed.
    This remains true even if the <A::TreeWalker.currentNode>
    is moved out of its original subtree.

    Relocation of the <A::TreeWalker.currentNode> --- or explicit
    selection of a new <A::TreeWalker.currentNode>, or changes
    in the conditions that the <IF::NodeFilter> is basing its 
    decesions on --- can result in a <IF::TreeWalker> having a
    <A::TreeWalker.currentNode> that would not otherwise be
    visible in the logical view of the document.  This node can be
    thought of as a <QUOTE::transient member> of that view.
    When the application asks the <IF::TreeWalker> to navigate off
    this node, the result will be just as if it had been visible,
    but the application may be unable to navigate back to it
    unless conditions change to make it visible again.

    In particular, if the <A::TreeWalker.currentNode> becomes
    part of a subtree that would otherwise have been rejected
    by the filter, that entire subtree may be added as transient
    members of the logical view.  The application will be
    able to navigate within that subtree until the application
    moves upward past the rejected ancestor; thereafter, standard 
    filtering applies.

  @CODE:
    @@QName: createTWForTest
    @@PerlDef:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

      my $docel = $doc-><M::Document.createElement> ('docel');

      $doc-><M::Node.appendChild> ($docel);

      my $doctrv = $doc-><M::Node.getFeature> ('Traversal', '2.0');
      $tw = $doctrv-><M::DocumentTraversal.createTreeWalker> ($docel);

  @L2Attr:
    @@Name: currentNode
    @@enDesc:
      The node at which the <IF::TreeWalker> is currently positioned.

      Alteration to the DOM tree may cause the current node to
      no longer be accepted by the <IF::TreeWalker>'s associated
      filter.  The <A::TreeWalker.currentNode> may also be 
      explicitly set to any node, whether or not it is within the 
      subtree specified by the <A::TreeWalker.root> node or
      would be accepted by the filter and <A::TreeWalker.whatToShow>
      flags.  Further traversal occurs relative to <A::TreeWalker.currentNode>
      even if it is not part of the current view, by applying the filters
      in the requested direction; if no traversal is possible,
      the <A::TreeWalker.currentNode> is not changed.

        {SpecIssue::
          Is it allowed to set a node from external document or
          even external implementation?
        }
    @@Type: Node
    @@Get:
      @@@PerlDef:
        $r = $self->{current_node};
    @@Set:
      @@@dx:raises:
        @@@@@: c|SET_TO_NULL_ERR
        @@@@enDesc:
          If an attempt is made to set the <A::TreeWalker.currentNode>
          to <DOM::null>.
      @@@PerlDef:
        if (defined $given) {
          $self->{current_node} = $given;
        } else {
          __EXCEPTION{c|SET_TO_NULL_ERR::
          }__;
        }

    @@enImplNote:
      @@@ddid: test
      @@@@:
        Tests for this attribute are also found in 
        <M::DocumentTraversal.createTreeWalker> tests.

    @@Test:
      @@@QName: TreeWalker.currentNode.set.test
      @@@PerlDef:
        my $tw;
        __CODE{createTWForTest:: $tw => $tw}__;
        
        my $od = $tw-><AG::TreeWalker.currentNode>-><AG::Node.ownerDocument>;

        my $el = $od-><M::Document.createElement> ('e');

        $tw-><AS::TreeWalker.currentNode> ($el);

        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $el);
    @@Test:
      @@@QName: TreeWalker.currentNode.set.null.test
      @@@PerlDef:
        my $tw;
        __CODE{createTWForTest:: $tw => $tw}__;

        $test->assert_exception (code => sub {
          $tw-><AS::TreeWalker.currentNode> (null);
        }, exception_subtype => <Q::c|SET_TO_NULL_ERR>);

  @L2Attr:
    @@Name: expandEntityReferences
    @@enDesc:
      The value of the flag that determines whether the children of
      entity reference nodes are visible to the <IF::TreeWalker>.
      If <DOM::false>, they and their descendants will be rejected.
      This rejection takes precedence over the <A::TreeWalker.whatToShow>
      flags and the filter, if any.

      To produce a view of the document that has entity references
      expanded and does not expose the entity reference node itself,
      use the <A::TreeWalker.whatToShow> flags to hide the entity
      reference node and set the <A::TreeWalker.expandEntityReferences>
      flag to <DOM::true> when creating the <IF::TreeWalker>.

      To produce a view of the document that has entity reference
      nodes but no entity expansion, use the <A::TreeWalker.whatToShow>
      flags to show the entity reference nodes and set the
      <A::TreeWalker.expandEntityReferences> flag to <DOM::false>
      when creating the <IF::TreeWalker>.
    @@Type: boolean
    @@Get:
      @@@PerlDef:
        $r = $self->{expand_entity_references};

    @@enImplNote:
      @@@ddid: test
      @@@@:
        Tests for this attribute found in 
        <M::DocumentTraversal.createTreeWalker> tests.

  @L2Attr:
    @@Name: filter
    @@enDesc:
      The filter used to screen nodes.
    @@Type: NodeFilter
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          If the filter is not specified when the <IF::TreeWalker>
          is created.

            {SpecIssue::
              Not in the spec.
            }
      @@@PerlDef:
        $r = $self->{filter};

    @@enImplNote:
      @@@ddid: test
      @@@@:
        Tests for this attribute found in 
        <M::DocumentTraversal.createTreeWalker> tests.

  @L2Attr:
    @@Name: root
    @@enDesc:
      The root node of the <IF::TreeWalker>, as specified 
      when it was created.
    @@Type: Node
    @@Get:
      @@@PerlDef:
        $r = $self->{root};

    @@enImplNote:
      @@@ddid: test
      @@@@:
        Tests for this attribute found in 
        <M::DocumentTraversal.createTreeWalker> tests.

  @L2Attr:
    @@Name: whatToShow
    @@enDesc:
      The flags that determines which node types are presented 
      via the <IF::TreeWalker>.  The available set of constants
      is defined in the <IF::NodeFilter> interface.

      Nodes not accepted by the <A::TreeWalker.whatToShow>
      flags will be skipped, but their children may still be
      considered.  This skip takes precedence over the filter, if any.
    @@Type: unsignedShort
    @@actualType: WhatToShow
    @@Get:
      @@@PerlDef:
        $r = $self->{what_to_show};

    @@enImplNote:
      @@@ddid: test
      @@@@:
        Tests for this attribute found in 
        <M::DocumentTraversal.createTreeWalker> tests.

  @L2Method:
    @@Name: firstChild
    @@enDesc:
      Moves to and returns the first visible child of the current node.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The new node.
      @@@nullCase:
        @@@@enDesc:
          If the current node has no visible children, returns <DOM::null>
          and retains the current node.

          If the <IF::NodeFilter>, if any, returns 
          <C::NodeFilter.MANAKAI_FILTER_OPAQUE> for the
          <A::TreeWalker.currentNode>, this method
          <kwd:MUST> return <DOM::null>.

            {NOTE::
              By definition, the parent of the
              <M::TreeWalker.firstChild> node, if any, is
              either a child of the <A::TreeWalker.currentNode>
              or a descendant of the <A::TreeWalker.currentNode>
              where all ancestors between <A::TreeWalker.currentNode>
              and that node is <C::NodeFilter.FILTER_SKIP>ped.
              That means that the only node that might be
              <C::NodeFilter.MANAKAI_FILTER_OPAQUE> is the
              <A::TreeWalker.currentNode>.
            }
      @@@PerlDef:
        __DEEP{
          my $sresult;
          __CODE{testNode:: $target => {$self->{current_node}},
                            $result => $sresult}__;
          if ($sresult != <C::NodeFilter.MANAKAI_FILTER_OPAQUE>) {
            my @target = (@{$self->{current_node}-><AG::Node.childNodes>});
            A: while (@target) {
              my $target = shift @target;
              my $result;
              __CODE{testNode}__;
              if ($result == <C::NodeFilter.FILTER_ACCEPT> or
                  $result == <C::NodeFilter.MANAKAI_FILTER_OPAQUE>) {
                $r = $self->{current_node} = $target;
                last A;
              } elsif ($result == <C::NodeFilter.FILTER_SKIP>) {
                unshift @target, @{$target-><AG::Node.childNodes>};
              }
            } # A
          } # not opaque
        }__;

    @@Test:
      @@@QName: TreeWalker.firstChild.1.test
      @@@PerlDef:
        my $doc;
        my $doctrv;
        __CODE{createDocForTest}__;

        my %node;
        __CODE{TreeForTest2}__;

        my $tw = $doctrv-><M::DocumentTraversal.createTreeWalker>
                            ($node{el1}, <C::NodeFilter.SHOW_ALL>);

        $test->id ('el1');
        $test->assert_equals ($tw-><M::TreeWalker.firstChild>, $node{el2});
        $test->id ('el1.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el2});

        $test->id ('el2');
        $test->assert_null ($tw-><M::TreeWalker.firstChild>);
        $test->id ('el2.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el2});

        $test->id ('el3');
        $tw-><AS::TreeWalker.currentNode> ($node{el3});
        $test->assert_equals ($tw-><M::TreeWalker.firstChild>, $node{el4});
        $test->id ('el3.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el4});

        $test->id ('el4');
        $test->assert_null ($tw-><M::TreeWalker.firstChild>);
        $test->id ('el4.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el4});
    @@Test:
      @@@QName: TreeWalker.firstChild.2.test
      @@@PerlDef:
        my $doc;
        my $doctrv;
        __CODE{createDocForTest}__;

        my %node;
        __CODE{TreeForTest1}__;

        my $tw = $doctrv-><M::DocumentTraversal.createTreeWalker>
                            ($node{el1}, <C::NodeFilter.SHOW_ATTRIBUTE>);

        $test->id ('el1');
        $test->assert_null ($tw-><M::TreeWalker.firstChild>);
        $test->id ('el1.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el1});

        $test->id ('el2');
        $tw-><AS::TreeWalker.currentNode> ($node{el2});
        $test->assert_null ($tw-><M::TreeWalker.firstChild>);
        $test->id ('el2.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el2});

        $test->id ('el3');
        $tw-><AS::TreeWalker.currentNode> ($node{el3});
        $test->assert_null ($tw-><M::TreeWalker.firstChild>);
        $test->id ('el3.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el3});

        $test->id ('el4');
        $tw-><AS::TreeWalker.currentNode> ($node{el4});
        $test->assert_null ($tw-><M::TreeWalker.firstChild>);
        $test->id ('el4.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el4});
    @@Test:
      @@@QName: TreeWalker.firstChild.3.test
      @@@enDesc:
        expandEntityReferences
      @@@PerlDef:
        my $doc;
        my $doctrv;
        __CODE{createDocForTest}__;

        my %node;
        __CODE{TreeForTestER1}__;

        my $tw = $doctrv-><M::DocumentTraversal.createTreeWalker>
                            ($node{el1}, <C::NodeFilter.SHOW_ALL>, null, false);

        $test->id ('el1');
        $test->assert_equals ($tw-><M::TreeWalker.firstChild>, $node{er1});
        $test->id ('el1.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{er1});

        $tw-><AS::TreeWalker.currentNode> ($node{er1});
        $test->id ('er1');
        $test->assert_null ($tw-><M::TreeWalker.firstChild>);
        $test->id ('er1.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{er1});

        $tw-><AS::TreeWalker.currentNode> ($node{el3});
        $test->id ('el3');
        $test->assert_equals ($tw-><M::TreeWalker.firstChild>, $node{el4});
        $test->id ('el3.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el4});

        $test->id ('el4');
        $test->assert_null ($tw-><M::TreeWalker.firstChild>);
        $test->id ('el4.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el4});

        $tw-><AS::TreeWalker.currentNode> ($node{el5});
        $test->id ('el5');
        $test->assert_null ($tw-><M::TreeWalker.firstChild>);
        $test->id ('el5.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el5});

        $tw-><AS::TreeWalker.currentNode> ($node{el6});
        $test->id ('el6');
        $test->assert_null ($tw-><M::TreeWalker.firstChild>);
        $test->id ('el6.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el6});
    @@Test:
      @@@QName: TreeWalker.firstChild.4.test
      @@@enDesc:
        expandEntityReferences emulated by <C::NodeFilter.MANAKAI_FILTER_OPAQUE>
      @@@PerlDef:
        my $doc;
        my $doctrv;
        __CODE{createDocForTest}__;

        my %node;
        __CODE{TreeForTestER1}__;

        my $tw = $doctrv-><M::DocumentTraversal.createTreeWalker>
                            ($node{el1}, <C::NodeFilter.SHOW_ALL>, sub {
                               $_[1]->node_type
                                   == <C::Node.ENTITY_REFERENCE_NODE>
                                 ? <C::NodeFilter.MANAKAI_FILTER_OPAQUE>
                                 : <C::NodeFilter.FILTER_ACCEPT>
                             }, true);

        $test->id ('el1');
        $test->assert_equals ($tw-><M::TreeWalker.firstChild>, $node{er1});
        $test->id ('el1.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{er1});

        $tw-><AS::TreeWalker.currentNode> ($node{er1});
        $test->id ('er1');
        $test->assert_null ($tw-><M::TreeWalker.firstChild>);
        $test->id ('er1.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{er1});

        $tw-><AS::TreeWalker.currentNode> ($node{el3});
        $test->id ('el3');
        $test->assert_equals ($tw-><M::TreeWalker.firstChild>, $node{el4});
        $test->id ('el3.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el4});

        $test->id ('el4');
        $test->assert_null ($tw-><M::TreeWalker.firstChild>);
        $test->id ('el4.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el4});

        $tw-><AS::TreeWalker.currentNode> ($node{el5});
        $test->id ('el5');
        $test->assert_null ($tw-><M::TreeWalker.firstChild>);
        $test->id ('el5.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el5});

        $tw-><AS::TreeWalker.currentNode> ($node{el6});
        $test->id ('el6');
        $test->assert_null ($tw-><M::TreeWalker.firstChild>);
        $test->id ('el6.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el6});

  @L2Method:
    @@Name: lastChild
    @@enDesc:
      Moves to and returns the last visible child of the current node.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The new node.
      @@@nullCase:
        @@@@enDesc:
          If the current node has no visible children, returns <DOM::null>
          and retains the current node.

          If the <IF::NodeFilter>, if any, returns 
          <C::NodeFilter.MANAKAI_FILTER_OPAQUE> for the
          <A::TreeWalker.currentNode>, this method
          <kwd:MUST> return <DOM::null>.

            {NOTE::
              By definition, the parent of the
              <M::TreeWalker.lastChild> node, if any, is
              either a child of the <A::TreeWalker.currentNode>
              or a descendant of the <A::TreeWalker.currentNode>
              where all ancestors between <A::TreeWalker.currentNode>
              and that node is <C::NodeFilter.FILTER_SKIP>ped.
              That means that the only node that might be
              <C::NodeFilter.MANAKAI_FILTER_OPAQUE> is the
              <A::TreeWalker.currentNode>.
            }
      @@@PerlDef:
        __DEEP{
          my $sresult;
          __CODE{testNode:: $target => {$self->{current_node}},
                            $result => $sresult}__;
          if ($sresult != <C::NodeFilter.MANAKAI_FILTER_OPAQUE>) {
            my @target = (@{$self->{current_node}-><AG::Node.childNodes>});
            A: while (@target) {
              my $target = pop @target;
              my $result;
              __CODE{testNode}__;
              if ($result == <C::NodeFilter.FILTER_ACCEPT> or
                  $result == <C::NodeFilter.MANAKAI_FILTER_OPAQUE>) {
                $r = $self->{current_node} = $target;
                last A;
              } elsif ($result == <C::NodeFilter.FILTER_SKIP>) {
                push @target, @{$target-><AG::Node.childNodes>};
              }
            } # A
          }
        }__;

    @@Test:
      @@@QName: TreeWalker.lastChild.1.test
      @@@PerlDef:
        my $doc;
        my $doctrv;
        __CODE{createDocForTest}__;

        my %node;
        __CODE{TreeForTest2}__;

        my $tw = $doctrv-><M::DocumentTraversal.createTreeWalker>
                            ($node{el1}, <C::NodeFilter.SHOW_ALL>);

        $test->id ('el1');
        $test->assert_equals ($tw-><M::TreeWalker.lastChild>, $node{el3});
        $test->id ('el1.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el3});

        $test->id ('el2');
        $tw-><AS::TreeWalker.currentNode> ($node{el2});
        $test->assert_null ($tw-><M::TreeWalker.lastChild>);
        $test->id ('el2.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el2});

        $test->id ('el3');
        $tw-><AS::TreeWalker.currentNode> ($node{el3});
        $test->assert_equals ($tw-><M::TreeWalker.lastChild>, $node{el5});
        $test->id ('el3.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el5});

        $test->id ('el4');
        $tw-><AS::TreeWalker.currentNode> ($node{el4});
        $test->assert_null ($tw-><M::TreeWalker.lastChild>);
        $test->id ('el4.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el4});
    @@Test:
      @@@QName: TreeWalker.lastChild.2.test
      @@@PerlDef:
        my $doc;
        my $doctrv;
        __CODE{createDocForTest}__;

        my %node;
        __CODE{TreeForTest1}__;

        my $tw = $doctrv-><M::DocumentTraversal.createTreeWalker>
                            ($node{el1}, <C::NodeFilter.SHOW_ATTRIBUTE>);

        $test->id ('el1');
        $test->assert_null ($tw-><M::TreeWalker.lastChild>);
        $test->id ('el1.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el1});

        $test->id ('el2');
        $tw-><AS::TreeWalker.currentNode> ($node{el2});
        $test->assert_null ($tw-><M::TreeWalker.lastChild>);
        $test->id ('el2.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el2});

        $test->id ('el3');
        $tw-><AS::TreeWalker.currentNode> ($node{el3});
        $test->assert_null ($tw-><M::TreeWalker.lastChild>);
        $test->id ('el3.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el3});

        $test->id ('el4');
        $tw-><AS::TreeWalker.currentNode> ($node{el4});
        $test->assert_null ($tw-><M::TreeWalker.lastChild>);
        $test->id ('el4.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el4});
    @@Test:
      @@@QName: TreeWalker.lastChild.3.test
      @@@enDesc:
        expandEntityReferences
      @@@PerlDef:
        my $doc;
        my $doctrv;
        __CODE{createDocForTest}__;

        my %node;
        __CODE{TreeForTestER2}__;

        my $tw = $doctrv-><M::DocumentTraversal.createTreeWalker>
                            ($node{el1}, <C::NodeFilter.SHOW_ALL>, null, false);

        $test->id ('el1');
        $test->assert_equals ($tw-><M::TreeWalker.lastChild>, $node{er1});
        $test->id ('el1.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{er1});

        $tw-><AS::TreeWalker.currentNode> ($node{el2});
        $test->id ('el2');
        $test->assert_null ($tw-><M::TreeWalker.lastChild>);
        $test->id ('el2.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el2});

        $tw-><AS::TreeWalker.currentNode> ($node{er1});
        $test->id ('er1');
        $test->assert_null ($tw-><M::TreeWalker.lastChild>);
        $test->id ('er1.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{er1});

        $tw-><AS::TreeWalker.currentNode> ($node{el3});
        $test->id ('el3');
        $test->assert_equals ($tw-><M::TreeWalker.lastChild>, $node{el4});
        $test->id ('el3.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el4});

        $test->id ('el4');
        $test->assert_null ($tw-><M::TreeWalker.lastChild>);
        $test->id ('el4.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el4});

        $tw-><AS::TreeWalker.currentNode> ($node{el5});
        $test->id ('el5');
        $test->assert_null ($tw-><M::TreeWalker.lastChild>);
        $test->id ('el5.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el5});
    @@Test:
      @@@QName: TreeWalker.lastChild.4.test
      @@@enDesc:
        expandEntityReferences emulated by <C::NodeFilter.MANAKAI_FILTER_OPAQUE>
      @@@PerlDef:
        my $doc;
        my $doctrv;
        __CODE{createDocForTest}__;

        my %node;
        __CODE{TreeForTestER2}__;

        my $tw = $doctrv-><M::DocumentTraversal.createTreeWalker>
                            ($node{el1}, <C::NodeFilter.SHOW_ALL>, sub {
                               $_[1]->node_type
                                   == <C::Node.ENTITY_REFERENCE_NODE>
                                 ? <C::NodeFilter.MANAKAI_FILTER_OPAQUE>
                                 : <C::NodeFilter.FILTER_ACCEPT>
                             }, true);

        $test->id ('el1');
        $test->assert_equals ($tw-><M::TreeWalker.lastChild>, $node{er1});
        $test->id ('el1.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{er1});

        $tw-><AS::TreeWalker.currentNode> ($node{er1});
        $test->id ('er1');
        $test->assert_null ($tw-><M::TreeWalker.lastChild>);
        $test->id ('er1.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{er1});

        $tw-><AS::TreeWalker.currentNode> ($node{el3});
        $test->id ('el3');
        $test->assert_equals ($tw-><M::TreeWalker.lastChild>, $node{el4});
        $test->id ('el3.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el4});

        $test->id ('el4');
        $test->assert_null ($tw-><M::TreeWalker.lastChild>);
        $test->id ('el4.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el4});

        $tw-><AS::TreeWalker.currentNode> ($node{el5});
        $test->id ('el5');
        $test->assert_null ($tw-><M::TreeWalker.lastChild>);
        $test->id ('el5.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el5});

        $tw-><AS::TreeWalker.currentNode> ($node{el2});
        $test->id ('el2');
        $test->assert_null ($tw-><M::TreeWalker.lastChild>);
        $test->id ('el2.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el2});

  @L2Method:
    @@Name: parentNode
    @@enDesc:
      Moves to and returns the closest visible ancestor node
      of the current node.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The new parent node.
      @@@nullCase:
        @@@@enDesc:
          If the current node has no parent in the logical view.

          If the search for <M::TreeWalker.parentNode> attempts
          to step upward from the <A::TreeWalker.root> node,
          or if it fails to find a vislble ancestor node,
          it retains the current position and returns <DOM::null>.

          For the purpose of this method, <C::NodeFilter.MANAKAI_FILTER_OPAQUE>
          <kwd:MUST> be handled by the same way as 
          <C::NodeFilter.FILTER_ACCEPT>.
      @@@PerlDef:
        __DEEP{
          unless ($self->{current_node} eq $self->{root}) {
            my $target = $self->{current_node}-><AG::Node.parentNode>;
            T: while (defined $target) {
              my $result;
              __CODE{testNode}__;
              if ($result == <C::NodeFilter.FILTER_ACCEPT> or
                  $result == <C::NodeFilter.MANAKAI_FILTER_OPAQUE>) {
                $r = $self->{current_node} = $target;
                last T;
              } elsif ($target eq $self->{root}) {
                last T;
              }
              $target = $target-><AG::Node.parentNode>;
            }
          }
        }__;

    @@Test:
      @@@QName: TreeWalker.parentNode.1.test
      @@@PerlDef:
        my $doc;
        my $doctrv;
        __CODE{createDocForTest}__;

        my %node;
        __CODE{TreeForTest1}__;
        
        my $tw = $doctrv-><M::DocumentTraversal.createTreeWalker>
                            ($node{el1}, <C::NodeFilter.SHOW_ALL>);

        $test->id ('el1');
        $test->assert_null ($tw-><M::TreeWalker.parentNode>);
        $test->id ('el1.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el1});

        $test->id ('el2');
        $tw-><AS::TreeWalker.currentNode> ($node{el2});
        $test->assert_equals ($tw-><M::TreeWalker.parentNode>, $node{el1});
        $test->id ('el2.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el1});

        $test->id ('el3');
        $tw-><AS::TreeWalker.currentNode> ($node{el3});
        $test->assert_equals ($tw-><M::TreeWalker.parentNode>, $node{el1});
        $test->id ('el3.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el1});

        $test->id ('el4');
        $tw-><AS::TreeWalker.currentNode> ($node{el4});
        $test->assert_equals ($tw-><M::TreeWalker.parentNode>, $node{el3});
        $test->id ('el4.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el3});
    @@Test:
      @@@QName: TreeWalker.parentNode.2.test
      @@@PerlDef:
        my $doc;
        my $doctrv;
        __CODE{createDocForTest}__;

        my %node;
        __CODE{TreeForTest1}__;
        
        my $tw = $doctrv-><M::DocumentTraversal.createTreeWalker>
                            ($node{el1}, <C::NodeFilter.SHOW_ALL>, sub {
                              $_[1]->local_name eq 'el3'
                                ? <C::NodeFilter.FILTER_ACCEPT>
                                : <C::NodeFilter.FILTER_REJECT>
                            });

        $test->id ('el1');
        $test->assert_null ($tw-><M::TreeWalker.parentNode>);
        $test->id ('el1.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el1});

        $test->id ('el2');
        $tw-><AS::TreeWalker.currentNode> ($node{el2});
        $test->assert_null ($tw-><M::TreeWalker.parentNode>);
        $test->id ('el2.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el2});

        $test->id ('el3');
        $tw-><AS::TreeWalker.currentNode> ($node{el3});
        $test->assert_null ($tw-><M::TreeWalker.parentNode>);
        $test->id ('el3.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el3});

        $test->id ('el4');
        $tw-><AS::TreeWalker.currentNode> ($node{el4});
        $test->assert_equals ($tw-><M::TreeWalker.parentNode>, $node{el3});
        $test->id ('el4.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el3});
    @@Test:
      @@@QName: TreeWalker.parentNode.3.test
      @@@PerlDef:
        my $doc;
        my $doctrv;
        __CODE{createDocForTest}__;

        my %node;
        __CODE{TreeForTest1}__;
        
        my $tw = $doctrv-><M::DocumentTraversal.createTreeWalker>
                            ($node{el1}, <C::NodeFilter.SHOW_ALL>, sub {
                              $_[1]->local_name eq 'el3'
                                ? <C::NodeFilter.FILTER_SKIP>
                                : <C::NodeFilter.FILTER_ACCEPT>
                            });

        $test->id ('el1');
        $test->assert_null ($tw-><M::TreeWalker.parentNode>);
        $test->id ('el1.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el1});

        $test->id ('el2');
        $tw-><AS::TreeWalker.currentNode> ($node{el2});
        $test->assert_equals ($tw-><M::TreeWalker.parentNode>, $node{el1});
        $test->id ('el2.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el1});

        $test->id ('el3');
        $tw-><AS::TreeWalker.currentNode> ($node{el3});
        $test->assert_equals ($tw-><M::TreeWalker.parentNode>, $node{el1});
        $test->id ('el3.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el1});

        $test->id ('el4');
        $tw-><AS::TreeWalker.currentNode> ($node{el4});
        $test->assert_equals ($tw-><M::TreeWalker.parentNode>, $node{el1});
        $test->id ('el4.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el1});
    @@Test:
      @@@QName: TreeWalker.parentNode.4.test
      @@@enDesc:
        FILTER_REJECT works as if FILTER_SKIP if the currentNode
        is in the rejected subtree.
      @@@PerlDef:
        my $doc;
        my $doctrv;
        __CODE{createDocForTest}__;

        my %node;
        __CODE{TreeForTest1}__;
        
        my $tw = $doctrv-><M::DocumentTraversal.createTreeWalker>
                            ($node{el1}, <C::NodeFilter.SHOW_ALL>, sub {
                              $_[1]->local_name eq 'el3'
                                ? <C::NodeFilter.FILTER_REJECT>
                                : <C::NodeFilter.FILTER_ACCEPT>
                            });

        $test->id ('el1');
        $test->assert_null ($tw-><M::TreeWalker.parentNode>);
        $test->id ('el1.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el1});

        $test->id ('el2');
        $tw-><AS::TreeWalker.currentNode> ($node{el2});
        $test->assert_equals ($tw-><M::TreeWalker.parentNode>, $node{el1});
        $test->id ('el2.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el1});

        $test->id ('el3');
        $tw-><AS::TreeWalker.currentNode> ($node{el3});
        $test->assert_equals ($tw-><M::TreeWalker.parentNode>, $node{el1});
        $test->id ('el3.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el1});

        $test->id ('el4');
        $tw-><AS::TreeWalker.currentNode> ($node{el4});
        $test->assert_equals ($tw-><M::TreeWalker.parentNode>, $node{el1});
        $test->id ('el4.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el1});
    @@Test:
      @@@QName: TreeWalker.parentNode.5.test
      @@@enDesc:
        expandEntityReferences
      @@@PerlDef:
        my $doc;
        my $doctrv;
        __CODE{createDocForTest}__;

        my %node;
        __CODE{TreeForTestER1}__;
        
        my $tw = $doctrv-><M::DocumentTraversal.createTreeWalker>
                            ($node{el1}, <C::NodeFilter.SHOW_ALL>, null, false);

        $test->id ('el1');
        $test->assert_null ($tw-><M::TreeWalker.parentNode>);
        $test->id ('el1.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el1});

        $tw-><AS::TreeWalker.currentNode> ($node{er1});
        $test->id ('er1');
        $test->assert_equals ($tw-><M::TreeWalker.parentNode>, $node{el1});
        $test->id ('er1.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el1});

        $tw-><AS::TreeWalker.currentNode> ($node{el3});
        $test->id ('el3');
        $test->assert_equals ($tw-><M::TreeWalker.parentNode>, $node{er1});
        $test->id ('el3.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{er1});

        $tw-><AS::TreeWalker.currentNode> ($node{el4});
        $test->id ('el4');
        $test->assert_equals ($tw-><M::TreeWalker.parentNode>, $node{er1});
        $test->id ('el4.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{er1});

        $tw-><AS::TreeWalker.currentNode> ($node{el5});
        $test->id ('el5');
        $test->assert_equals ($tw-><M::TreeWalker.parentNode>, $node{er1});
        $test->id ('el5.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{er1});

        $tw-><AS::TreeWalker.currentNode> ($node{el6});
        $test->id ('el6');
        $test->assert_equals ($tw-><M::TreeWalker.parentNode>, $node{el1});
        $test->id ('el6.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el1});
    @@Test:
      @@@QName: TreeWalker.parentNode.6.test
      @@@enDesc:
        MANAKAI_FILTER_OPAQUE
      @@@PerlDef:
        my $doc;
        my $doctrv;
        __CODE{createDocForTest}__;

        my %node;
        __CODE{TreeForTestER1}__;
        
        my $tw = $doctrv-><M::DocumentTraversal.createTreeWalker>
                            ($node{el1}, <C::NodeFilter.SHOW_ALL>, sub {
                               $_[1]->node_type
                                   == <C::Node.ENTITY_REFERENCE_NODE>
                                 ? <C::NodeFilter.MANAKAI_FILTER_OPAQUE>
                                 : <C::NodeFilter.FILTER_ACCEPT>
                             }, true);

        $test->id ('el1');
        $test->assert_null ($tw-><M::TreeWalker.parentNode>);
        $test->id ('el1.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el1});

        $tw-><AS::TreeWalker.currentNode> ($node{er1});
        $test->id ('er1');
        $test->assert_equals ($tw-><M::TreeWalker.parentNode>, $node{el1});
        $test->id ('er1.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el1});

        $tw-><AS::TreeWalker.currentNode> ($node{el3});
        $test->id ('el3');
        $test->assert_equals ($tw-><M::TreeWalker.parentNode>, $node{er1});
        $test->id ('el3.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{er1});

        $tw-><AS::TreeWalker.currentNode> ($node{el4});
        $test->id ('el4');
        $test->assert_equals ($tw-><M::TreeWalker.parentNode>, $node{el3});
        $test->id ('el4.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el3});

        $tw-><AS::TreeWalker.currentNode> ($node{el5});
        $test->id ('el5');
        $test->assert_equals ($tw-><M::TreeWalker.parentNode>, $node{er1});
        $test->id ('el5.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{er1});

        $tw-><AS::TreeWalker.currentNode> ($node{el6});
        $test->id ('el6');
        $test->assert_equals ($tw-><M::TreeWalker.parentNode>, $node{el1});
        $test->id ('el6.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el1});

  @L2Method:
    @@Name: nextNode
    @@enDesc:
      Moves and returns to the next visible node in document order
      relative to the current node.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The new node.
      @@@nullCase:
        @@@@enDesc:
          If the current node has no next node, or if the search
          for <M::TreeWalker.nextNode> attempts to step upward
          from the <A::TreeWalker.root> node, returns
          <DOM::null> and retains the current node.

          {SpecIssue::
            Clarification is necessary; e.g. nextNode of root is null?
          }

          If the <A::TreeWalker.currentNode> is marked as 
          <C::NodeFilter.MANAKAI_FILTER_OPAQUE> by the <IF::NodeFilter>,
          the method <kwd:MUST-NOT> return any descendant of
          the <A::TreeWalker.currentNode>.  Otherwise,
          it <kwd:MUST> be treated as if <C::NodeFilter.FILTER_ACCEPT>.
      @@@PerlDef:
        __DEEP{
          my $target = $self->{current_node};
          T: {
            my $tw = $self->clone;
            $tw->{current_node} = $target;
            $tw->{root} = $target;
            my $fc = $tw-><M::TreeWalker.firstChild>;
            if (defined $fc) {
              $r = $self->{current_node} = $fc;
              last T;
            }

            while (defined $target) {
              my $current = $target;
              $target = null;
              P: while (defined $current and not $current eq $self->{root}) {
                $target = $current-><AG::Node.nextSibling>;
                if (defined $target) {
                  last P;
                }
                $current = $current-><AG::Node.parentNode>;
              } # P
              last T unless defined $target;
  
              my $result;
              __CODE{testNode}__;
              if ($result == <C::NodeFilter.FILTER_ACCEPT> or
                  $result == <C::NodeFilter.MANAKAI_FILTER_OPAQUE>) {
                $r = $self->{current_node} = $target;
                last T;
              } elsif ($result == <C::NodeFilter.FILTER_SKIP>) {
                my $tw = $self->clone;
                $tw->{current_node} = $target;
                $tw->{root} = $target;
                my $fc = $tw-><M::TreeWalker.firstChild>;
                if (defined $fc) {
                  $r = $self->{current_node} = $fc;
                  last T;
                }
              }
            }
          } # T
        }__;

    @@Test:
      @@@QName: TreeWalker.nextNode.1.test
      @@@PerlDef:
        my $doc;
        my $doctrv;
        __CODE{createDocForTest}__;

        my %node;
        __CODE{TreeForTest3}__;
        
        my $tw = $doctrv-><M::DocumentTraversal.createTreeWalker>
                            ($node{el1}, <C::NodeFilter.SHOW_ALL>);

        $test->id ('el1');
        $test->assert_equals ($tw-><M::TreeWalker.nextNode>, $node{el2});
        $test->id ('el1.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el2});

        $test->id ('el2');
        $test->assert_equals ($tw-><M::TreeWalker.nextNode>, $node{el3});
        $test->id ('el2.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el3});

        $test->id ('el3');
        $test->assert_equals ($tw-><M::TreeWalker.nextNode>, $node{el4});
        $test->id ('el3.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el4});

        $test->id ('el4');
        $test->assert_equals ($tw-><M::TreeWalker.nextNode>, $node{el5});
        $test->id ('el4.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el5});

        $test->id ('el5');
        $test->assert_null ($tw-><M::TreeWalker.nextNode>);
        $test->id ('el5.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el5});
    @@Test:
      @@@QName: TreeWalker.nextNode.2.test
      @@@PerlDef:
        my $doc;
        my $doctrv;
        __CODE{createDocForTest}__;

        my %node;
        __CODE{TreeForTest3}__;
        
        my $tw = $doctrv-><M::DocumentTraversal.createTreeWalker>
                            ($node{el3}, <C::NodeFilter.SHOW_ALL>);

        $test->id ('el1');
        $tw-><AS::TreeWalker.currentNode> ($node{el1});
        $test->assert_equals ($tw-><M::TreeWalker.nextNode>, $node{el2});
        $test->id ('el1.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el2});

        $test->id ('el2');
        $test->assert_equals ($tw-><M::TreeWalker.nextNode>, $node{el3});
        $test->id ('el2.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el3});

        $test->id ('el3');
        $test->assert_equals ($tw-><M::TreeWalker.nextNode>, $node{el4});
        $test->id ('el3.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el4});

        $test->id ('el4');
        $test->assert_null ($tw-><M::TreeWalker.nextNode>);
        $test->id ('el4.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el4});

        $test->id ('el5');
        $tw-><AS::TreeWalker.currentNode> ($node{el5});
        $test->assert_null ($tw-><M::TreeWalker.nextNode>);
        $test->id ('el5.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el5});
    @@Test:
      @@@QName: TreeWalker.nextNode.3.test
      @@@PerlDef:
        my $doc;
        my $doctrv;
        __CODE{createDocForTest}__;

        my %node;
        __CODE{TreeForTest3}__;
        
        my $tw = $doctrv-><M::DocumentTraversal.createTreeWalker>
                            ($node{el1}, <C::NodeFilter.SHOW_ALL>, sub {
                               $_[1]->local_name eq 'el3'
                                 ? <C::NodeFilter.FILTER_SKIP>
                                 : <C::NodeFilter.FILTER_ACCEPT>
                             });

        $test->id ('el1');
        $test->assert_equals ($tw-><M::TreeWalker.nextNode>, $node{el2});
        $test->id ('el1.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el2});

        $test->id ('el2');
        $test->assert_equals ($tw-><M::TreeWalker.nextNode>, $node{el4});
        $test->id ('el2.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el4});

        $test->id ('el3');
        $tw-><AS::TreeWalker.currentNode> ($node{el3});
        $test->assert_equals ($tw-><M::TreeWalker.nextNode>, $node{el4});
        $test->id ('el3.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el4});

        $test->id ('el4');
        $test->assert_equals ($tw-><M::TreeWalker.nextNode>, $node{el5});
        $test->id ('el4.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el5});

        $test->id ('el5');
        $test->assert_null ($tw-><M::TreeWalker.nextNode>);
        $test->id ('el5.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el5});
    @@Test:
      @@@QName: TreeWalker.nextNode.4.test
      @@@PerlDef:
        my $doc;
        my $doctrv;
        __CODE{createDocForTest}__;

        my %node;
        __CODE{TreeForTest3}__;
        
        my $tw = $doctrv-><M::DocumentTraversal.createTreeWalker>
                            ($node{el1}, <C::NodeFilter.SHOW_ALL>, sub {
                               $_[1]->local_name eq 'el3'
                                 ? <C::NodeFilter.FILTER_REJECT>
                                 : <C::NodeFilter.FILTER_ACCEPT>
                             });

        $test->id ('el1');
        $test->assert_equals ($tw-><M::TreeWalker.nextNode>, $node{el2});
        $test->id ('el1.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el2});

        $test->id ('el2');
        $test->assert_equals ($tw-><M::TreeWalker.nextNode>, $node{el5});
        $test->id ('el2.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el5});

        $test->id ('el3');
        $tw-><AS::TreeWalker.currentNode> ($node{el3});
        $test->assert_equals ($tw-><M::TreeWalker.nextNode>, $node{el4});
        $test->id ('el3.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el4});

        $test->id ('el4');
        $test->assert_equals ($tw-><M::TreeWalker.nextNode>, $node{el5});
        $test->id ('el4.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el5});

        $test->id ('el5');
        $test->assert_null ($tw-><M::TreeWalker.nextNode>);
        $test->id ('el5.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el5});
    @@Test:
      @@@QName: TreeWalker.nextNode.5.test
      @@@enDesc:
        expandEntityReferences
      @@@PerlDef:
        my $doc;
        my $doctrv;
        __CODE{createDocForTest}__;

        my %node;
        __CODE{TreeForTestER1}__;
        
        my $tw = $doctrv-><M::DocumentTraversal.createTreeWalker>
                            ($node{el1}, <C::NodeFilter.SHOW_ALL>);

        $test->id ('el1');
        $test->assert_equals ($tw-><M::TreeWalker.nextNode>, $node{er1});
        $test->id ('el1.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{er1});

        $test->id ('er1');
        $test->assert_equals ($tw-><M::TreeWalker.nextNode>, $node{el6});
        $test->id ('er1.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el6});

        $tw-><AS::TreeWalker.currentNode> ($node{el3});
        $test->id ('el3');
        $test->assert_equals ($tw-><M::TreeWalker.nextNode>, $node{el4});
        $test->id ('el3.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el4});

        $tw-><AS::TreeWalker.currentNode> ($node{el4});
        $test->id ('el4');
        $test->assert_equals ($tw-><M::TreeWalker.nextNode>, $node{el6});
        $test->id ('el4.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el6});

        $tw-><AS::TreeWalker.currentNode> ($node{el5});
        $test->id ('el5');
        $test->assert_equals ($tw-><M::TreeWalker.nextNode>, $node{el6});
        $test->id ('el5.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el6});

        $tw-><AS::TreeWalker.currentNode> ($node{el6});
        $test->id ('el6');
        $test->assert_null ($tw-><M::TreeWalker.nextNode>);
        $test->id ('el6.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el6});
    @@Test:
      @@@QName: TreeWalker.nextNode.6.test
      @@@enDesc:
        MANAKAI_FILTER_OPAQUE
      @@@PerlDef:
        my $doc;
        my $doctrv;
        __CODE{createDocForTest}__;

        my %node;
        __CODE{TreeForTestER1}__;
        
        my $tw = $doctrv-><M::DocumentTraversal.createTreeWalker>
                            ($node{el1}, <C::NodeFilter.SHOW_ALL>, sub {
                               $_[1]->node_type
                                   == <C::Node.ENTITY_REFERENCE_NODE>
                                 ? <C::NodeFilter.MANAKAI_FILTER_OPAQUE>
                                 : <C::NodeFilter.FILTER_ACCEPT>
                             }, true);

        $test->id ('el1');
        $test->assert_equals ($tw-><M::TreeWalker.nextNode>, $node{er1});
        $test->id ('el1.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{er1});

        $test->id ('er1');
        $test->assert_equals ($tw-><M::TreeWalker.nextNode>, $node{el6});
        $test->id ('er1.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el6});

        $tw-><AS::TreeWalker.currentNode> ($node{el3});
        $test->id ('el3');
        $test->assert_equals ($tw-><M::TreeWalker.nextNode>, $node{el4});
        $test->id ('el3.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el4});

        $test->id ('el4');
        $test->assert_equals ($tw-><M::TreeWalker.nextNode>, $node{el5});
        $test->id ('el4.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el5});

        $test->id ('el5');
        $test->assert_equals ($tw-><M::TreeWalker.nextNode>, $node{el6});
        $test->id ('el5.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el6});

        $test->id ('el6');
        $test->assert_null ($tw-><M::TreeWalker.nextNode>);
        $test->id ('el6.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el6});

  @L2Method:
    @@Name: nextSibling
    @@enDesc:
      Moves and returns to the next visible sibling of the current node.

      The <C::NodeFilter.MANAKAI_FILTER_OPAQUE> value <kwd:MUST>
      be treated as if <C::NodeFilter.FILTER_ACCEPT> is specified.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The new node.
      @@@nullCase:
        @@@@enDesc:
          If the current node has no visible next sibling
          in the logical view.
      @@@PerlDef:
        __DEEP{
          my $target = $self->{current_node};
          T: {
            while (defined $target) {
              my $current = $target;
              $target = null;
              P: while (defined $current and not $current eq $self->{root}) {
                $target = $current-><AG::Node.nextSibling>;
                if (defined $target) {
                  last P;
                }

                $current = $current-><AG::Node.parentNode>;
                last P unless defined $current;
                my $presult;
                __CODE{testNode:: $result => $presult, $target => $current}__;
                if ($presult != <C::NodeFilter.FILTER_SKIP>) {
                  last P;
                }
              } # P
              last T unless defined $target;
  
              my $result;
              __CODE{testNode}__;
              if ($result == <C::NodeFilter.FILTER_ACCEPT> or
                  $result == <C::NodeFilter.MANAKAI_FILTER_OPAQUE>) {
                $r = $self->{current_node} = $target;
                last T;
              } elsif ($result == <C::NodeFilter.FILTER_SKIP>) {
                my $tw = $self->clone;
                $tw->{current_node} = $target;
                $tw->{root} = $target;
                my $fc = $tw-><M::TreeWalker.firstChild>;
                if (defined $fc) {
                  $r = $self->{current_node} = $fc;
                  last T;
                }
              }
            }
          } # T
        }__;

    @@Test:
      @@@QName: TreeWalker.nextSibling.1.test
      @@@PerlDef:
        my $doc;
        my $doctrv;
        __CODE{createDocForTest}__;

        my %node;
        __CODE{TreeForTest3}__;
        
        my $tw = $doctrv-><M::DocumentTraversal.createTreeWalker>
                            ($node{el1}, <C::NodeFilter.SHOW_ALL>);

        $test->id ('el1');
        $test->assert_null ($tw-><M::TreeWalker.nextSibling>);
        $test->id ('el1.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el1});

        $test->id ('el2');
        $tw-><AS::TreeWalker.currentNode> ($node{el2});
        $test->assert_equals ($tw-><M::TreeWalker.nextSibling>, $node{el3});
        $test->id ('el2.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el3});

        $test->id ('el3');
        $test->assert_equals ($tw-><M::TreeWalker.nextSibling>, $node{el5});
        $test->id ('el3.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el5});

        $test->id ('el4');
        $tw-><AS::TreeWalker.currentNode> ($node{el4});
        $test->assert_null ($tw-><M::TreeWalker.nextSibling>);
        $test->id ('el4.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el4});

        $test->id ('el5');
        $tw-><AS::TreeWalker.currentNode> ($node{el5});
        $test->assert_null ($tw-><M::TreeWalker.nextSibling>);
        $test->id ('el5.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el5});
    @@Test:
      @@@QName: TreeWalker.nextSibling.2.test
      @@@PerlDef:
        my $doc;
        my $doctrv;
        __CODE{createDocForTest}__;

        my %node;
        __CODE{TreeForTest3}__;
        
        my $tw = $doctrv-><M::DocumentTraversal.createTreeWalker>
                            ($node{el3}, <C::NodeFilter.SHOW_ALL>);

        $test->id ('el1');
        $tw-><AS::TreeWalker.currentNode> ($node{el1});
        $test->assert_null ($tw-><M::TreeWalker.nextSibling>);
        $test->id ('el1.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el1});

        $test->id ('el2');
        $tw-><AS::TreeWalker.currentNode> ($node{el2});
        $test->assert_equals ($tw-><M::TreeWalker.nextSibling>, $node{el3});
        $test->id ('el2.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el3});

        $test->id ('el3');
        $test->assert_null ($tw-><M::TreeWalker.nextSibling>);
        $test->id ('el3.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el3});

        $test->id ('el4');
        $tw-><AS::TreeWalker.currentNode> ($node{el4});
        $test->assert_null ($tw-><M::TreeWalker.nextSibling>);
        $test->id ('el4.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el4});

        $test->id ('el5');
        $tw-><AS::TreeWalker.currentNode> ($node{el5});
        $test->assert_null ($tw-><M::TreeWalker.nextSibling>);
        $test->id ('el5.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el5});
    @@Test:
      @@@QName: TreeWalker.nextSibling.3.test
      @@@PerlDef:
        my $doc;
        my $doctrv;
        __CODE{createDocForTest}__;

        my %node;
        __CODE{TreeForTest3}__;
        
        my $tw = $doctrv-><M::DocumentTraversal.createTreeWalker>
                            ($node{el1}, <C::NodeFilter.SHOW_ALL>, sub {
                               $_[1]->local_name eq 'el3'
                                 ? <C::NodeFilter.FILTER_SKIP>
                                 : <C::NodeFilter.FILTER_ACCEPT>
                             });

        $test->id ('el1');
        $test->assert_null ($tw-><M::TreeWalker.nextSibling>);
        $test->id ('el1.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el1});

        $test->id ('el2');
        $tw-><AS::TreeWalker.currentNode> ($node{el2});
        $test->assert_equals ($tw-><M::TreeWalker.nextSibling>, $node{el4});
        $test->id ('el2.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el4});

        $test->id ('el3'); 
        $tw-><AS::TreeWalker.currentNode> ($node{el3});
        $test->assert_equals ($tw-><M::TreeWalker.nextSibling>, $node{el5});
        $test->id ('el3.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el5});

        $test->id ('el4');
        $tw-><AS::TreeWalker.currentNode> ($node{el4});
        $test->assert_equals ($tw-><M::TreeWalker.nextSibling>, $node{el5});
        $test->id ('el4.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el5});

        $test->id ('el5');
        $test->assert_null ($tw-><M::TreeWalker.nextSibling>);
        $test->id ('el5.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el5});
    @@Test:
      @@@QName: TreeWalker.nextSibling.4.test
      @@@PerlDef:
        my $doc;
        my $doctrv;
        __CODE{createDocForTest}__;

        my %node;
        __CODE{TreeForTest3}__;
        
        my $tw = $doctrv-><M::DocumentTraversal.createTreeWalker>
                            ($node{el1}, <C::NodeFilter.SHOW_ALL>, sub {
                               $_[1]->local_name eq 'el3'
                                 ? <C::NodeFilter.FILTER_REJECT>
                                 : <C::NodeFilter.FILTER_ACCEPT>
                             });

        $test->id ('el1');
        $test->assert_null ($tw-><M::TreeWalker.nextSibling>);
        $test->id ('el1.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el1});

        $test->id ('el2');
        $tw-><AS::TreeWalker.currentNode> ($node{el2});
        $test->assert_equals ($tw-><M::TreeWalker.nextSibling>, $node{el5});
        $test->id ('el2.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el5});

        $test->id ('el3');
        $tw-><AS::TreeWalker.currentNode> ($node{el3});
        $test->assert_equals ($tw-><M::TreeWalker.nextSibling>, $node{el5});
        $test->id ('el3.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el5});

        $test->id ('el4');
        $tw-><AS::TreeWalker.currentNode> ($node{el4});
        $test->assert_null ($tw-><M::TreeWalker.nextSibling>);
        $test->id ('el4.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el4});

        $test->id ('el5');
        $tw-><AS::TreeWalker.currentNode> ($node{el5});
        $test->assert_null ($tw-><M::TreeWalker.nextSibling>);
        $test->id ('el5.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el5});
    @@Test:
      @@@QName: TreeWalker.nextSibling.5.test
      @@@enDesc:
        expandEntityReferences
      @@@PerlDef:
        my $doc;
        my $doctrv;
        __CODE{createDocForTest}__;

        my %node;
        __CODE{TreeForTestER1}__;
        
        my $tw = $doctrv-><M::DocumentTraversal.createTreeWalker>
                            ($node{el1}, <C::NodeFilter.SHOW_ALL>, null, false);

        $test->id ('el1');
        $test->assert_null ($tw-><M::TreeWalker.nextSibling>);
        $test->id ('el1.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el1});

        $test->id ('er1');
        $tw-><AS::TreeWalker.currentNode> ($node{er1});
        $test->assert_equals ($tw-><M::TreeWalker.nextSibling>, $node{el6});
        $test->id ('er1.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el6});

        $test->id ('el3');
        $tw-><AS::TreeWalker.currentNode> ($node{el3});
        $test->assert_null ($tw-><M::TreeWalker.nextSibling>);
        $test->id ('el3.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el3});

        $test->id ('el4');
        $tw-><AS::TreeWalker.currentNode> ($node{el4});
        $test->assert_null ($tw-><M::TreeWalker.nextSibling>);
        $test->id ('el4.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el4});

        $test->id ('el5');
        $tw-><AS::TreeWalker.currentNode> ($node{el5});
        $test->assert_null ($tw-><M::TreeWalker.nextSibling>);
        $test->id ('el5.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el5});

        $test->id ('el6');
        $tw-><AS::TreeWalker.currentNode> ($node{el6});
        $test->assert_null ($tw-><M::TreeWalker.nextSibling>);
        $test->id ('el6.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el6});
    @@Test:
      @@@QName: TreeWalker.nextSibling.6.test
      @@@enDesc:
        MANAKAI_FILTER_OPAQUE
      @@@PerlDef:
        my $doc;
        my $doctrv;
        __CODE{createDocForTest}__;

        my %node;
        __CODE{TreeForTestER1}__;
        
        my $tw = $doctrv-><M::DocumentTraversal.createTreeWalker>
                            ($node{el1}, <C::NodeFilter.SHOW_ALL>, sub {
                               $_[1]->node_type
                                   == <C::Node.ENTITY_REFERENCE_NODE>
                                 ? <C::NodeFilter.MANAKAI_FILTER_OPAQUE>
                                 : <C::NodeFilter.FILTER_ACCEPT>
                             }, true);

        $test->id ('el1');
        $test->assert_null ($tw-><M::TreeWalker.nextSibling>);
        $test->id ('el1.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el1});

        $test->id ('er1');
        $tw-><AS::TreeWalker.currentNode> ($node{er1});
        $test->assert_equals ($tw-><M::TreeWalker.nextSibling>, $node{el6});
        $test->id ('er1.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el6});

        $test->id ('el3');
        $tw-><AS::TreeWalker.currentNode> ($node{el3});
        $test->assert_equals ($tw-><M::TreeWalker.nextSibling>, $node{el5});
        $test->id ('el3.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el5});

        $test->id ('el4');
        $tw-><AS::TreeWalker.currentNode> ($node{el4});
        $test->assert_null ($tw-><M::TreeWalker.nextSibling>);
        $test->id ('el4.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el4});

        $test->id ('el5');
        $tw-><AS::TreeWalker.currentNode> ($node{el5});
        $test->assert_null ($tw-><M::TreeWalker.nextSibling>);
        $test->id ('el5.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el5});

        $test->id ('el6');
        $tw-><AS::TreeWalker.currentNode> ($node{el6});
        $test->assert_null ($tw-><M::TreeWalker.nextSibling>);
        $test->id ('el6.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el6});

  @L2Method:
    @@Name: previousNode
    @@enDesc:
      Moves and returns to the previous visible node in document order
      relative to the current node.

      This method <kwd:MUST-NOT> return a descendant
      of a sibling of the <A::TreeWalker.currentNode> if 
      an ancestor between the descendant and the parent
      of the <A::TreeWalker.currentNode> (exclusive)
      is marked as <C::NodeFilter.MANAKAI_FILTER_OPAQUE> by
      the <IF::NodeFilter> if any.  If the node that is
      a candidate to return is an ancestor of the
      <A::TreeWalker.currentNode>, the <C::NodeFilter.MANAKAI_FILTER_OPAQUE>
      value returned by a <IF::NodeFilter> <kwd:MUST> be
      treated as if the <C::NodeFilter.FILTER_ACCEPT> value
      is returned.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The new node.
      @@@nullCase:
        @@@@enDesc:
          If the current node has no previous node, or if the search
          for <M::TreeWalker.previousNode> attempts to step upward
          from the <A::TreeWalker.root> node, returns
          <DOM::null> and retains the current node.

          {SpecIssue::
            Clarification is necessary; e.g. previousNode of root is null?
          }
      @@@PerlDef:
        __DEEP{
          my $target = $self->{current_node};

          T: {
            last T if $target eq $self->{root};

            P: {
              my $ptarget = $target-><AG::Node.previousSibling>;
              if (defined $ptarget) {
                my $result;
                __CODE{testNode:: $target => $ptarget}__;
                if ($result == <C::NodeFilter.MANAKAI_FILTER_OPAQUE>) {
                  $r = $self->{current_node} = $ptarget;
                  last T;
                } elsif ($result != <C::NodeFilter.FILTER_REJECT>) {
                  my $tw = $self->clone;
                  $tw->{current_node} = $ptarget;
                  $tw->{root} = $ptarget;
                  my $lc = $tw-><M::TreeWalker.lastChild>;
                  $r = $self->{current_node} = defined $lc ? $lc : $ptarget;
                  last T;
                } else {
                  $target = $ptarget;
                  redo P;
                }
              }
            } # P

            P: {
              my $ptarget = $target-><AG::Node.parentNode>;
              if (defined $ptarget) {
                my $result;
                __CODE{testNode:: $target => $ptarget}__;
                if ($result == <C::NodeFilter.FILTER_ACCEPT> or
                    $result == <C::NodeFilter.MANAKAI_FILTER_OPAQUE>) {
                  $r = $self->{current_node} = $ptarget;
                  last T;
                } else {
                  $target = $ptarget;
                  redo T;
                }
              }
            } # P
          } # T
        }__;

    @@Test:
      @@@QName: TreeWalker.previousNode.1.test
      @@@PerlDef:
        my $doc;
        my $doctrv;
        __CODE{createDocForTest}__;

        my %node;
        __CODE{TreeForTest3}__;
        
        my $tw = $doctrv-><M::DocumentTraversal.createTreeWalker>
                            ($node{el1}, <C::NodeFilter.SHOW_ALL>);

        $test->id ('el1');
        $test->assert_null ($tw-><M::TreeWalker.previousNode>);
        $test->id ('el1.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el1});

        $test->id ('el2');
        $tw-><AS::TreeWalker.currentNode> ($node{el2});
        $test->assert_equals ($tw-><M::TreeWalker.previousNode>, $node{el1});
        $test->id ('el2.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el1});

        $test->id ('el3');
        $tw-><AS::TreeWalker.currentNode> ($node{el3});
        $test->assert_equals ($tw-><M::TreeWalker.previousNode>, $node{el2});
        $test->id ('el3.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el2});

        $test->id ('el4');
        $tw-><AS::TreeWalker.currentNode> ($node{el4});
        $test->assert_equals ($tw-><M::TreeWalker.previousNode>, $node{el3});
        $test->id ('el4.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el3});

        $test->id ('el5');
        $tw-><AS::TreeWalker.currentNode> ($node{el5});
        $test->assert_equals ($tw-><M::TreeWalker.previousNode>, $node{el4});
        $test->id ('el5.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el4});
    @@Test:
      @@@QName: TreeWalker.previousNode.2.test
      @@@PerlDef:
        my $doc;
        my $doctrv;
        __CODE{createDocForTest}__;

        my %node;
        __CODE{TreeForTest3}__;
        
        my $tw = $doctrv-><M::DocumentTraversal.createTreeWalker>
                            ($node{el3}, <C::NodeFilter.SHOW_ALL>);

        $test->id ('el1');
        $tw-><AS::TreeWalker.currentNode> ($node{el1});
        $test->assert_null ($tw-><M::TreeWalker.previousNode>);
        $test->id ('el1.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el1});

        $test->id ('el2');
        $tw-><AS::TreeWalker.currentNode> ($node{el2});
        $test->assert_equals ($tw-><M::TreeWalker.previousNode>, $node{el1});
        $test->id ('el2.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el1});

        $test->id ('el3');
        $tw-><AS::TreeWalker.currentNode> ($node{el3});
        $test->assert_null ($tw-><M::TreeWalker.previousNode>);
        $test->id ('el3.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el3});

        $test->id ('el4'); 
        $tw-><AS::TreeWalker.currentNode> ($node{el4});
        $test->assert_equals ($tw-><M::TreeWalker.previousNode>, $node{el3});
        $test->id ('el4.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el3});

        $test->id ('el5');
        $tw-><AS::TreeWalker.currentNode> ($node{el5});
        $test->assert_equals ($tw-><M::TreeWalker.previousNode>, $node{el4});
        $test->id ('el5.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el4});
    @@Test:
      @@@QName: TreeWalker.previousNode.3.test
      @@@PerlDef:
        my $doc;
        my $doctrv;
        __CODE{createDocForTest}__;

        my %node;
        __CODE{TreeForTest3}__;
        
        my $tw = $doctrv-><M::DocumentTraversal.createTreeWalker>
                            ($node{el1}, <C::NodeFilter.SHOW_ALL>, sub {
                               $_[1]->local_name eq 'el3'
                                 ? <C::NodeFilter.FILTER_SKIP>
                                 : <C::NodeFilter.FILTER_ACCEPT>
                             });

        $test->id ('el1');
        $test->assert_null ($tw-><M::TreeWalker.previousNode>);
        $test->id ('el1.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el1});

        $test->id ('el2');
        $tw-><AS::TreeWalker.currentNode> ($node{el2});
        $test->assert_equals ($tw-><M::TreeWalker.previousNode>, $node{el1});
        $test->id ('el2.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el1});

        $test->id ('el3');
        $tw-><AS::TreeWalker.currentNode> ($node{el3});
        $test->assert_equals ($tw-><M::TreeWalker.previousNode>, $node{el2});
        $test->id ('el3.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el2});

        $test->id ('el4');
        $tw-><AS::TreeWalker.currentNode> ($node{el4});
        $test->assert_equals ($tw-><M::TreeWalker.previousNode>, $node{el2});
        $test->id ('el4.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el2});

        $test->id ('el5');
        $tw-><AS::TreeWalker.currentNode> ($node{el5});
        $test->assert_equals ($tw-><M::TreeWalker.previousNode>, $node{el4});
        $test->id ('el5.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el4});
    @@Test:
      @@@QName: TreeWalker.previousNode.4.test
      @@@PerlDef:
        my $doc;
        my $doctrv;
        __CODE{createDocForTest}__;

        my %node;
        __CODE{TreeForTest3}__;
        
        my $tw = $doctrv-><M::DocumentTraversal.createTreeWalker>
                            ($node{el1}, <C::NodeFilter.SHOW_ALL>, sub {
                               $_[1]->local_name eq 'el3'
                                 ? <C::NodeFilter.FILTER_REJECT>
                                 : <C::NodeFilter.FILTER_ACCEPT>
                             });

        $test->id ('el1');
        $test->assert_null ($tw-><M::TreeWalker.previousNode>);
        $test->id ('el1.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el1});

        $test->id ('el2');
        $tw-><AS::TreeWalker.currentNode> ($node{el2});
        $test->assert_equals ($tw-><M::TreeWalker.previousNode>, $node{el1});
        $test->id ('el2.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el1});

        $test->id ('el3');
        $tw-><AS::TreeWalker.currentNode> ($node{el3});
        $test->assert_equals ($tw-><M::TreeWalker.previousNode>, $node{el2});
        $test->id ('el3.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el2});

        $test->id ('el4');
        $tw-><AS::TreeWalker.currentNode> ($node{el4});
        $test->assert_equals ($tw-><M::TreeWalker.previousNode>, $node{el2});
        $test->id ('el4.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el2});

        $test->id ('el5');
        $tw-><AS::TreeWalker.currentNode> ($node{el5});
        $test->assert_equals ($tw-><M::TreeWalker.previousNode>, $node{el2});
        $test->id ('el5.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el2});
    @@Test:
      @@@QName: TreeWalker.previousNode.5.test
      @@@enDesc:
        expandEntityReferences
      @@@PerlDef:
        my $doc;
        my $doctrv;
        __CODE{createDocForTest}__;

        my %node;
        __CODE{TreeForTestER1}__;
        
        my $tw = $doctrv-><M::DocumentTraversal.createTreeWalker>
                            ($node{el1}, <C::NodeFilter.SHOW_ALL>, null, false);

        $test->id ('el1');
        $test->assert_null ($tw-><M::TreeWalker.previousNode>);
        $test->id ('el1.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el1});

        $test->id ('er1');
        $tw-><AS::TreeWalker.currentNode> ($node{er1});
        $test->assert_equals ($tw-><M::TreeWalker.previousNode>, $node{el1});
        $test->id ('er1.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el1});

        $test->id ('el3');
        $tw-><AS::TreeWalker.currentNode> ($node{el3});
        $test->assert_equals ($tw-><M::TreeWalker.previousNode>, $node{er1});
        $test->id ('el3.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{er1});

        $test->id ('el4');
        $tw-><AS::TreeWalker.currentNode> ($node{el4});
        $test->assert_equals ($tw-><M::TreeWalker.previousNode>, $node{er1});
        $test->id ('el4.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{er1});

        $test->id ('el5');
        $tw-><AS::TreeWalker.currentNode> ($node{el5});
        $test->assert_equals ($tw-><M::TreeWalker.previousNode>, $node{er1});
        $test->id ('el5.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{er1});

        $test->id ('el6');
        $tw-><AS::TreeWalker.currentNode> ($node{el6});
        $test->assert_equals ($tw-><M::TreeWalker.previousNode>, $node{er1});
        $test->id ('el6.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{er1});
    @@Test:
      @@@QName: TreeWalker.previousNode.6.test
      @@@enDesc:
        MANAKAI_FILTER_OPAQUE
      @@@PerlDef:
        my $doc;
        my $doctrv;
        __CODE{createDocForTest}__;

        my %node;
        __CODE{TreeForTestER1}__;
        
        my $tw = $doctrv-><M::DocumentTraversal.createTreeWalker>
                            ($node{el1}, <C::NodeFilter.SHOW_ALL>, sub {
                               $_[1]->node_type
                                   == <C::Node.ENTITY_REFERENCE_NODE>
                                 ? <C::NodeFilter.MANAKAI_FILTER_OPAQUE>
                                 : <C::NodeFilter.FILTER_ACCEPT>
                             }, true);

        $test->id ('el1');
        $test->assert_null ($tw-><M::TreeWalker.previousNode>);
        $test->id ('el1.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el1});

        $test->id ('er1');
        $tw-><AS::TreeWalker.currentNode> ($node{er1});
        $test->assert_equals ($tw-><M::TreeWalker.previousNode>, $node{el1});
        $test->id ('er1.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el1});

        $test->id ('el3');
        $tw-><AS::TreeWalker.currentNode> ($node{el3});
        $test->assert_equals ($tw-><M::TreeWalker.previousNode>, $node{er1});
        $test->id ('el3.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{er1});

        $test->id ('el4');
        $tw-><AS::TreeWalker.currentNode> ($node{el4});
        $test->assert_equals ($tw-><M::TreeWalker.previousNode>, $node{el3});
        $test->id ('el4.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el3});

        $test->id ('el5');
        $tw-><AS::TreeWalker.currentNode> ($node{el5});
        $test->assert_equals ($tw-><M::TreeWalker.previousNode>, $node{el4});
        $test->id ('el5.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el4});

        $test->id ('el6');
        $tw-><AS::TreeWalker.currentNode> ($node{el6});
        $test->assert_equals ($tw-><M::TreeWalker.previousNode>, $node{er1});
        $test->id ('el6.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{er1});

  @L2Method:
    @@Name: previousSibling
    @@enDesc:
      Moves and returns to the previous visible sibling of the current node.

      If a node that is a candicate to be returned is marked as
      <C::NodeFilter.MANAKAI_FILTER_OPAQUE>, it <kwd:MUST>
      be treated as <C::NodeFilter.FILTER_ACCEPT> when the
      node is a sibling of the <A::TreeWalker.currentNode>,
      or as in <M::TreeWalker.lastChild> where the
      <A::TreeWalker.currentNode> would be the sibling
      of the actual <A::TreeWalker.currentNode> otherwise.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The new node.
      @@@nullCase:
        @@@@enDesc:
          If the current node has no visible previous sibling
          in the logical view.
      @@@PerlDef:
        __DEEP{
          my $target = $self->{current_node};
          T: {
            while (defined $target) {
              my $current = $target;
              $target = null;
              P: while (defined $current and not $current eq $self->{root}) {
                $target = $current-><AG::Node.previousSibling>;
                if (defined $target) {
                  last P;
                }

                $current = $current-><AG::Node.parentNode>;
                last P unless defined $current;
                my $presult;
                __CODE{testNode:: $result => $presult, $target => $current}__;
                if ($presult != <C::NodeFilter.FILTER_SKIP> and
                    $presult != <C::NodeFilter.FILTER_REJECT>) {
                  last P;
                }
              } # P
              last T unless defined $target;
  
              my $result;
              __CODE{testNode}__;
              if ($result == <C::NodeFilter.FILTER_ACCEPT> or
                  $result == <C::NodeFilter.MANAKAI_FILTER_OPAQUE>) {
                $r = $self->{current_node} = $target;
                last T;
              } elsif ($result == <C::NodeFilter.FILTER_SKIP>) {
                my $tw = $self->clone;
                $tw->{current_node} = $target;
                $tw->{root} = $target;
                my $fc = $tw-><M::TreeWalker.lastChild>;
                if (defined $fc) {
                  $r = $self->{current_node} = $fc;
                  last T;
                }
              }
            }
          } # T
        }__;

    @@Test:
      @@@QName: TreeWalker.previousSibling.1.test
      @@@PerlDef:
        my $doc;
        my $doctrv;
        __CODE{createDocForTest}__;

        my %node;
        __CODE{TreeForTest3}__;
        
        my $tw = $doctrv-><M::DocumentTraversal.createTreeWalker>
                            ($node{el1}, <C::NodeFilter.SHOW_ALL>);

        $test->id ('el1');
        $test->assert_null ($tw-><M::TreeWalker.previousSibling>);
        $test->id ('el1.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el1});

        $test->id ('el2');
        $tw-><AS::TreeWalker.currentNode> ($node{el2});
        $test->assert_null ($tw-><M::TreeWalker.previousSibling>);
        $test->id ('el2.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el2});

        $test->id ('el3');
        $tw-><AS::TreeWalker.currentNode> ($node{el3});
        $test->assert_equals ($tw-><M::TreeWalker.previousSibling>, $node{el2});
        $test->id ('el3.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el2});

        $test->id ('el4');
        $tw-><AS::TreeWalker.currentNode> ($node{el4});
        $test->assert_null ($tw-><M::TreeWalker.previousSibling>);
        $test->id ('el4.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el4});

        $test->id ('el5');
        $tw-><AS::TreeWalker.currentNode> ($node{el5});
        $test->assert_equals ($tw-><M::TreeWalker.previousSibling>, $node{el3});
        $test->id ('el5.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el3});
    @@Test:
      @@@QName: TreeWalker.previousSibling.2.test
      @@@PerlDef:
        my $doc;
        my $doctrv;
        __CODE{createDocForTest}__;

        my %node;
        __CODE{TreeForTest3}__;
        
        my $tw = $doctrv-><M::DocumentTraversal.createTreeWalker>
                            ($node{el3}, <C::NodeFilter.SHOW_ALL>);

        $test->id ('el1');
        $tw-><AS::TreeWalker.currentNode> ($node{el1});
        $test->assert_null ($tw-><M::TreeWalker.previousSibling>);
        $test->id ('el1.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el1});

        $test->id ('el2');
        $tw-><AS::TreeWalker.currentNode> ($node{el2});
        $test->assert_null ($tw-><M::TreeWalker.previousSibling>);
        $test->id ('el2.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el2});

        $test->id ('el3');
        $tw-><AS::TreeWalker.currentNode> ($node{el3});
        $test->assert_null ($tw-><M::TreeWalker.previousSibling>);
        $test->id ('el3.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el3});

        $test->id ('el4');
        $tw-><AS::TreeWalker.currentNode> ($node{el4});
        $test->assert_null ($tw-><M::TreeWalker.previousSibling>);
        $test->id ('el4.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el4});

        $test->id ('el5');
        $tw-><AS::TreeWalker.currentNode> ($node{el5});
        $test->assert_equals ($tw-><M::TreeWalker.previousSibling>, $node{el3});
        $test->id ('el5.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el3});
    @@Test:
      @@@QName: TreeWalker.previousSibling.3.test
      @@@PerlDef:
        my $doc;
        my $doctrv;
        __CODE{createDocForTest}__;

        my %node;
        __CODE{TreeForTest3}__;
        
        my $tw = $doctrv-><M::DocumentTraversal.createTreeWalker>
                            ($node{el1}, <C::NodeFilter.SHOW_ALL>, sub {
                               $_[1]->local_name eq 'el3'
                                 ? <C::NodeFilter.FILTER_SKIP>
                                 : <C::NodeFilter.FILTER_ACCEPT>
                             });

        $test->id ('el1');
        $test->assert_null ($tw-><M::TreeWalker.previousSibling>);
        $test->id ('el1.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el1});

        $test->id ('el2');
        $tw-><AS::TreeWalker.currentNode> ($node{el2});
        $test->assert_null ($tw-><M::TreeWalker.previousSibling>);
        $test->id ('el2.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el2});

        $test->id ('el3'); 
        $tw-><AS::TreeWalker.currentNode> ($node{el3});
        $test->assert_equals ($tw-><M::TreeWalker.previousSibling>, $node{el2});
        $test->id ('el3.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el2});

        $test->id ('el4');
        $tw-><AS::TreeWalker.currentNode> ($node{el4});
        $test->assert_equals ($tw-><M::TreeWalker.previousSibling>, $node{el2});
        $test->id ('el4.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el2});

        $test->id ('el5');
        $tw-><AS::TreeWalker.currentNode> ($node{el5});
        $test->assert_equals ($tw-><M::TreeWalker.previousSibling>, $node{el4});
        $test->id ('el5.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el4});
    @@Test:
      @@@QName: TreeWalker.previousSibling.4.test
      @@@PerlDef:
        my $doc;
        my $doctrv;
        __CODE{createDocForTest}__;

        my %node;
        __CODE{TreeForTest3}__;
        
        my $tw = $doctrv-><M::DocumentTraversal.createTreeWalker>
                            ($node{el1}, <C::NodeFilter.SHOW_ALL>, sub {
                               $_[1]->local_name eq 'el3'
                                 ? <C::NodeFilter.FILTER_REJECT>
                                 : <C::NodeFilter.FILTER_ACCEPT>
                             });

        $test->id ('el1');
        $test->assert_null ($tw-><M::TreeWalker.previousSibling>);
        $test->id ('el1.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el1});

        $test->id ('el2');
        $tw-><AS::TreeWalker.currentNode> ($node{el2});
        $test->assert_null ($tw-><M::TreeWalker.previousSibling>);
        $test->id ('el2.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el2});

        $test->id ('el3');
        $tw-><AS::TreeWalker.currentNode> ($node{el3});
        $test->assert_equals ($tw-><M::TreeWalker.previousSibling>, $node{el2});
        $test->id ('el3.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el2});

        $test->id ('el4');
        $tw-><AS::TreeWalker.currentNode> ($node{el4});
        $test->assert_equals ($tw-><M::TreeWalker.previousSibling>, $node{el2});
        $test->id ('el4.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el2});

        $test->id ('el5');
        $tw-><AS::TreeWalker.currentNode> ($node{el5});
        $test->assert_equals ($tw-><M::TreeWalker.previousSibling>, $node{el2});
        $test->id ('el5.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el2});
    @@Test:
      @@@QName: TreeWalker.previousSibling.5.test
      @@@enDesc:
        expandEntityReferences
      @@@PerlDef:
        my $doc;
        my $doctrv;
        __CODE{createDocForTest}__;

        my %node;
        __CODE{TreeForTestER1}__;
        
        my $tw = $doctrv-><M::DocumentTraversal.createTreeWalker>
                            ($node{el1}, <C::NodeFilter.SHOW_ALL>, null, false);

        $test->id ('el1');
        $test->assert_null ($tw-><M::TreeWalker.previousSibling>);
        $test->id ('el1.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el1});

        $test->id ('er1');
        $tw-><AS::TreeWalker.currentNode> ($node{er1});
        $test->assert_null ($tw-><M::TreeWalker.previousSibling>);
        $test->id ('er1.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{er1});

        $test->id ('el3');
        $tw-><AS::TreeWalker.currentNode> ($node{el3});
        $test->assert_null ($tw-><M::TreeWalker.previousSibling>);
        $test->id ('el3.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el3});

        $test->id ('el4');
        $tw-><AS::TreeWalker.currentNode> ($node{el4});
        $test->assert_null ($tw-><M::TreeWalker.previousSibling>);
        $test->id ('el4.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el4});

        $test->id ('el5');
        $tw-><AS::TreeWalker.currentNode> ($node{el5});
        $test->assert_null ($tw-><M::TreeWalker.previousSibling>);
        $test->id ('el5.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el5});

        $test->id ('el6');
        $tw-><AS::TreeWalker.currentNode> ($node{el6});
        $test->assert_equals ($tw-><M::TreeWalker.previousSibling>, $node{er1});
        $test->id ('el6.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{er1});
    @@Test:
      @@@QName: TreeWalker.previousSibling.6.test
      @@@enDesc:
        MANAKAI_FILTER_OPAQUE
      @@@PerlDef:
        my $doc;
        my $doctrv;
        __CODE{createDocForTest}__;

        my %node;
        __CODE{TreeForTestER1}__;
        
        my $tw = $doctrv-><M::DocumentTraversal.createTreeWalker>
                            ($node{el1}, <C::NodeFilter.SHOW_ALL>, sub {
                               $_[1]->node_type
                                   == <C::Node.ENTITY_REFERENCE_NODE>
                                 ? <C::NodeFilter.MANAKAI_FILTER_OPAQUE>
                                 : <C::NodeFilter.FILTER_ACCEPT>
                             }, true);

        $test->id ('el1');
        $test->assert_null ($tw-><M::TreeWalker.previousSibling>);
        $test->id ('el1.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el1});

        $test->id ('er1');
        $tw-><AS::TreeWalker.currentNode> ($node{er1});
        $test->assert_null ($tw-><M::TreeWalker.previousSibling>);
        $test->id ('er1.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{er1});

        $test->id ('el3');
        $tw-><AS::TreeWalker.currentNode> ($node{el3});
        $test->assert_null ($tw-><M::TreeWalker.previousSibling>);
        $test->id ('el3.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el3});

        $test->id ('el4');
        $tw-><AS::TreeWalker.currentNode> ($node{el4});
        $test->assert_null ($tw-><M::TreeWalker.previousSibling>);
        $test->id ('el4.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el4});

        $test->id ('el5');
        $tw-><AS::TreeWalker.currentNode> ($node{el5});
        $test->assert_equals ($tw-><M::TreeWalker.previousSibling>, $node{el3});
        $test->id ('el5.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{el3});

        $test->id ('el6');
        $tw-><AS::TreeWalker.currentNode> ($node{el6});
        $test->assert_equals ($tw-><M::TreeWalker.previousSibling>, $node{er1});
        $test->id ('el6.currentNode');
        $test->assert_equals ($tw-><AG::TreeWalker.currentNode>, $node{er1});

  @CMethod:
    @@Operator: dlp|CloneMethod
    @@enDesc:
      Creates a copy of the <IF::TreeWalker>.
    @@Return:
      @@@Type: TreeWalker
      @@@PerlDef:
        $r = bless {%$self}, <ClassName::ManakaiDOMTreeWalker>;

  @CMethod:
    @@Operator: ManakaiDOM|MUErrorHandler
    @@Param:
      @@@Name: err
      @@@Type: ecore|ErrorInterface||ManakaiDOM|Perl
      @@@enDesc:
        The reported error object.
    @@Return:
      @@@Type: dlp|Any
      @@@nullCase:
        @@@@enDesc:
          No error handler.
      @@@PerlDef:
        __DEEP{
          $r = $self->{root}->___report_error ($err);
        }__;

  @CODE:
    @@QName: testNode
    @@enDesc:
      <Perl::$self>, <Perl::$target>, <Perl::$result>
    @@PerlDef:
      FILTER: {
        WHATTOSHOW: {
          unless ($self->{expand_entity_references}) {
            my $__parent = $target-><AG::Node.parentNode>;
            if (defined $__parent and
                $__parent-><AG::Node.nodeType>
                    == <C::Node.ENTITY_REFERENCE_NODE>) {
              $result = <C::NodeFilter.FILTER_REJECT>; # even if NodeIterator
              last FILTER;
            }
          }

          last WHATTOSHOW if $self->{what_to_show} == <C::NodeFilter.SHOW_ALL>;
  
          my $__nt = $target-><AG::Node.nodeType>;
          if ($__nt < 33 and
              ($self->{what_to_show} & (1 << ($__nt-1)))) {
            last WHATTOSHOW;
          }
  
          $result = <C::NodeFilter.FILTER_SKIP>;
          last FILTER;
        } # WHATTOSHOW

        if (defined $self->{filter}) {
          $result = $self->{filter}-><M::NodeFilter.acceptNode> ($target);
        } else {
          $result = <C::NodeFilter.FILTER_ACCEPT>;
        }
      } # FILTER

  @CODE:
    @@QName: TreeForTest1
    @@PerlDef:
      $node{el1} = $doc->create_element ('el1');
      $node{el2} = $doc->create_element ('el2');
      $node{el3} = $doc->create_element ('el3');
      $node{el4} = $doc->create_element ('el4');
      $node{el1}->append_child ($node{el2});
      $node{el1}->append_child ($node{el3});
      $node{el3}->append_child ($node{el4});
  @CODE:
    @@QName: TreeForTest2
    @@PerlDef:
      $node{el1} = $doc->create_element ('el1');
      $node{el2} = $doc->create_element ('el2');
      $node{el3} = $doc->create_element ('el3');
      $node{el4} = $doc->create_element ('el4');
      $node{el5} = $doc->create_element ('el5');
      $node{el1}->append_child ($node{el2});
      $node{el1}->append_child ($node{el3});
      $node{el3}->append_child ($node{el4});
      $node{el3}->append_child ($node{el5});
  @CODE:
    @@QName: TreeForTest3
    @@PerlDef:
      $node{el1} = $doc->create_element ('el1');
      $node{el2} = $doc->create_element ('el2');
      $node{el3} = $doc->create_element ('el3');
      $node{el4} = $doc->create_element ('el4');
      $node{el5} = $doc->create_element ('el5');
      $node{el1}->append_child ($node{el2});
      $node{el1}->append_child ($node{el3});
      $node{el3}->append_child ($node{el4});
      $node{el1}->append_child ($node{el5});
  @CODE:
    @@QName: TreeForTestER1
    @@PerlDef:
      $node{el1} = $doc->create_element ('el1');
      $node{er1} = $doc->create_entity_reference ('er1');
      $node{er1}->manakai_set_read_only (false, true);
      $node{el3} = $doc->create_element ('el3');
      $node{el4} = $doc->create_element ('el4');
      $node{el5} = $doc->create_element ('el5');
      $node{el6} = $doc->create_element ('el6');
      $node{el1}->append_child ($node{er1});
      $node{er1}->append_child ($node{el3});
      $node{el3}->append_child ($node{el4});
      $node{er1}->append_child ($node{el5});
      $node{el1}->append_child ($node{el6});
  @CODE:
    @@QName: TreeForTestER2
    @@PerlDef:
      $node{el1} = $doc->create_element ('el1');
      $node{el2} = $doc->create_element ('el2');
      $node{er1} = $doc->create_entity_reference ('er1');
      $node{er1}->manakai_set_read_only (false, true);
      $node{el3} = $doc->create_element ('el3');
      $node{el4} = $doc->create_element ('el4');
      $node{el5} = $doc->create_element ('el5');
      $node{el1}->append_child ($node{el2});
      $node{el1}->append_child ($node{er1});
      $node{er1}->append_child ($node{el3});
      $node{er1}->append_child ($node{el5});
      $node{el3}->append_child ($node{el4});
##TreeWalker

IFCls2Def:
  @IFQName: NodeFilter
  @ClsQName: ManakaiDOMNodeFilter

  @enDesc:
    Filters are objects that know how to <QUOTE::filter out> nodes.
    Each filter contains a user-written function that looks 
    at a node and determines whether or not it should be presented
    as part of the traversal's logical view of the document.

    If a <IF::NodeIterator> or <IF::TreeWalker> is given a
    <IF::NodeFilter>, it applies the filter before it returns
    the next node.  If the filter says to accept the node,
    the traversal engine returns it; otherwise, traversal looks
    for the next node and pretends that the node that was 
    not there.

    Filters will be consulted when a traversal operation is performed.
    However, the exact timing of these filter calls may vary 
    from one DOM implementation to another.  For that reason,
    <IF::NodeFilter>s should not attempt to maintain state based
    on the history of part invocations; the resulting
    bahavior may not be portable.

    Similarly, <IF::TreeWalker>s and <IF::NodeIterator>s should
    bahave as if they have no memory of paset filter results,
    and no anticipation of future result.  If the conditions
    a <IF::NodeFilter> is examining have changed, e.g.
    an attribute which it tests has been added or removed,
    since the last time the traversal engine examined the node,
    this change in visibility will be discovered only when
    the next traversal operation is performed.

    <IF::NodeFilter>s do not need to know how to traverse
    from node to node, nor do they need to know anything about
    the data structure that is being traversed.  This makes it very
    easy to write filters, since the only thing they have to
    know how to do is evaluate a single node.  One filter may
    be used with a number of different kinds of traversals,
    encouraging code reuse.

    <IF::NodeIterator> and <IF::TreeWalker> apply their <CODE::whatToShow>
    flags before applying filters.  If a node is skipped by 
    the active <CODE::whatToShow> flags, a <IF::NodeFilter> will
    not be called to evaluate that node.

    For manakai's Perl binding, an application <kwd:MAY> use
    a code reference as if it were a <IF::NodeFilter>; if it is set to
    a parameter that expects a <IF::NodeFilter>, the implementation
    <kwd:MUST> <Perl::bless> it with a class so that it
    implements the <IF::NodeFilter> interface.  Invoking the
    <M::NodeFilter.acceptNode> method on such <IF::NodeFilter>
    <kwd:MUST> result in the referenced code being invoked
    with the <Perl::$self> parameter, i.e. the <IF::NodeFilter>
    itself, and the <CODE::node> parameter.  The return
    value of the <M::NodeFilter.acceptNode> <kwd:MUST>
    be the return value of the code.

  @ResourceDef:
    @@DISCore:resourceType: DISLang|InputProcessor
    @@DISCore:resourceType: DISLang|OutputProcessor
    @@Def:
      @@@ContentType: lang|Perl
      @@@@:
        $INPUT = bless $INPUT, <ClassName::ManakaiDOMNodeFilter>
          if ref $INPUT eq 'CODE';

  @ShortConstGroup:
    @@Label:
      @@@lang:en
      @@@@:
        Constants returned by <M::NodeFilter.acceptNode>
    @@IFQName: AcceptNode
    @@enDesc:
      The costants that may be returned by the <M::NodeFilter.acceptNode>
      method.

    @@Const:
      @@@Name: FILTER_ACCEPT
      @@@intValue: 1
      @@@enDesc:
        Accept the node.  Navigation methods defined for
        <IF::NodeIterator> or <IF::TreeWalker> will return the node.
    @@Const:
      @@@Name: FILTER_REJECT
      @@@intValue: 2
      @@@enDesc:
        Reject the node.  Navigation methods defined for
        <IF::NodeIterator> or <IF::TreeWalker> will not return the node.
 
        For <IF::TreeWalker>, the children of the node will also be 
        rejected.  <IF::NodeIterator>s treat this as a synonym
        for the <C::NodeFilter.FILTER_SKIP>.
    @@Const:
      @@@Name: FILTER_SKIP
      @@@intValue: 3
      @@@enDesc:
        Skip the node.  Navigation methods defined for
        <IF::NodeIterator> or <IF::TreeWalker> will not return the node.
        The children of the node will still be considered.
    @@mConst:
      @@@Name: MANAKAI_FILTER_OPAQUE
      @@@intValue: 12101
      @@@enDesc:
        Accept the node itself while rejecting its children if any.

        If the <C::NodeFilter.MANAKAI_FILTER_OPAQUE> value is 
        specified for a node, the node itself <kwd:MUST> be treated
        as if the <C::NodeFilter.FILTER_ACCEPT> value is specified.
        However, any descendant of the node <kwd:MUST> be
        hidden from the logical view as if the
        <C::NodeFilter.FILTER_REJECT> value is specified for
        the ancestor node.

          {NOTE::
            This value can be used to emulate the
            <A::TreeWalker.expandEntityReferences> flag.
            However, unlike that flag, this filtering option
            makes the engine behave for descendants as if the node is
            rejected rather than the descendants of the node
            is rejected.
          }

          {ISSUE::
            Better name?  Any verb?
          }

          {ISSUE::
            Interaction to <IF::NodeIterator>s
          }

  @BitMaskGroup:
    @@Label:
      @@@lang:en
      @@@@:
        Constants for <CODE::whatToShow>
    @@IFQName: WhatToShow
    @@enDesc:
      The available values for the <CODE::whatToShow> flag used
      in <IF::TreeWalker>s and <IF::NodeIterator>s.

      They are the same as the set of possible types for <IF::Node>,
      and their values are derived by using a bit position corresponding
      to the value of <A::Node.nodeType> for the equivalent
      node type.  If a bit in <CODE::whatToShow> is set <DOM::false>,
      that will be taken as a request to skip over this type of node;
      the behavior in that case is similar to that of
      <C::NodeFilter.FILTER_SKIP>.

      Note that if node types greater than <CODE::32> are ever introduced,
      they may not be individually testable via <CODE::whatToShow>.
      If that need should arise, it can be handled by selecting
      <C::NodeFilter.SHOW_ALL> together with an appropriate
      <IF::NodeFilter>.

        {NOTE::
          The <C::Node.ELEMENT_TYPE_DEFINITION_NODE> and
          <C::Node.ATTRIBUTE_TYPE_DEFINITION> <A::Node.nodeType>s,
          extended by manakai, has values greater than <CODE::32>
          so that it cannot be controled by the <CODE::whatToShow>
          flags.
        }

        {NOTE::
           The effect of the <CODE::whatToShow> flags can be emulated
           by <IF::NodeFilter> tests.  However, some implementations
           may be able to improve <CODE::whatToShow> performance
           by taking advantage of knowledge of the document structure.
        }
    @@Const:
      @@@Name: SHOW_ALL
      @@@intValue: 0xFFFFFFFF
      @@@enDesc:
        Show all <IF::Node>s.
    @@Const:
      @@@Name: SHOW_ATTRIBUTE
      @@@intValue: 0x00000002
      @@@enDesc:
        Show <IF::te|Attr> nodes.  This meaningful only when
        creating an iterator or tree walker with an attribute node
        as its <CODE::root>; in this case, it means that the
        attribute node will appear in the first position of
        the iterator or traversal.  Since attributes are never
        children of other nodes, they do not appear when traversing
        over the document tree.
    @@Const:
      @@@Name: SHOW_CDATA_SECTION
      @@@intValue: 0x00000008
      @@@enDesc:
        Show <IF::tx|CDATASection> nodes.
    @@Const:
      @@@Name: SHOW_COMMENT
      @@@intValue: 0x00000080
      @@@enDesc:
        Show <IF::tcd|Comment> nodes.
    @@Const:
      @@@Name: SHOW_DOCUMENT
      @@@intValue: 0x00000100
      @@@enDesc:
        Show <IF::td|Document> nodes.
    @@Const:
      @@@Name: SHOW_DOCUMENT_FRAGMENT
      @@@intValue: 0x00000400
      @@@enDesc:
        Show <IF::td|DocumentFragment> nodes.
    @@Const:
      @@@Name: SHOW_DOCUMENT_TYPE
      @@@intValue: 0x00000200
      @@@enDesc:
        Show <IF::tx|DocumentType> nodes.
    @@Const:
      @@@Name: SHOW_ELEMENT
      @@@intValue: 0x00000001
      @@@enDesc:
        Show <IF::te|Element> nodes.
    @@Const:
      @@@Name: SHOW_ENTITY
      @@@intValue: 0x00000020
      @@@enDesc:
        Show <IF::tx|Entity> nodes.  This is meaningful only when
        creating an iterator or tree walker with an <IF::tx|Entity>
        node as its <CODE::root>; in this case, it means that
        the <IF::tx|Entity> node will appear in the first position
        of the traversal.  Since entities are not part of the
        document tree, they do not appear when traversing over document
        tree.
    @@Const:
      @@@Name: SHOW_ENTITY_REFERENCE
      @@@intValue: 0x00000010
      @@@enDesc:
        Show <IF::tx|EntityReference> nodes.
    @@Const:
      @@@Name: SHOW_NOTATION
      @@@intValue: 0x00000800
      @@@enDesc:
        Show <IF::tx|Notation> nodes.  This is meaningful only when
        creating an iterator or tree walker with an <IF::tx|Notation>
        node as its <CODE::root>; in this case, it means that
        the <IF::tx|Notation> node will appear in the first position
        of the traversal.  Since notations are not part of the
        document tree, they do not appear when traversing over document
        tree.
    @@Const:
      @@@Name: SHOW_PROCESSING_INSTRUCTION
      @@@intValue: 0x00000040
      @@@enDesc:
        Show <IF::tx|ProcessingInstruction> nodes.
    @@Const:
      @@@Name: SHOW_TEXT
      @@@intValue: 0x00000004
      @@@enDesc:
        Show <IF::tcd|Text> nodes.

  @L2Method:
    @@Name: acceptNode
    @@enDesc:
      Tests whether a specified node is visible in the logical
      view of a <IF::TreeWalker> or <IF::NodeIterator>.

      This method will be called by the implementation of
      <IF::TreeWalker> and <IF::NodeIterator>; it is not normally
      called directly from user code.  (Though an application could
      do so if it wanted to use the same filter to guide its
      own logic.)

      Although <IF::NodeFilter>s that change during a traversal
      can be written, their behavior may be confusing and 
      they should be avoided when possible.

      Well-designed <IF::NodeFilter>s should not have to modify
      the underlying structure of the document.  But the implementation
      does not provide any special processing to handle this case.
      In general, this may lead to inconsistent and confusing results,
      so it is encouraged to write <IF::NodeFilter>s that
      make no changes to document structures.  Instead, do the editing
      in the loop controlled by the traversal object.
    @@Param:
      @@@Name: n
      @@@Type: Node
      @@@enDesc:
        The node to check to see if it passes the filter or not.
    @@Return:
      @@@Type: unsignedShort
      @@@actualType: AcceptNode
      @@@enDesc:
        A constant to determine whether the node is accepted, rejected,
        or skipped.

          {SpecIssue::
            If none of them?
          }

        The implementation of this method should avoid to
        throw exceptions.  However, a DOM implementation
        cannot prevent an exception being thrown.  If
        an exception is thrown, <IF::TreeWalker> or
        <IF::NodeIterator> does not catch or alter the exception
        but it lets it propagate up to the application's code
        that invokes the <IF::TreeWalker> or
        <IF::NodeIterator> method.
      @@@PerlDef:
        goto &$self;
##NodeFilter
