Module:
  @QName:
    MDOM:DOMCore
  @AppName:
    @@@:  dom
    @@prefix:  w3c.org
    @@ContentType:
      lang:IDL-DOM
    @@For:
      ManakaiDOM:IDL
  @AppName:
    @@@: org.w3c.dom
    @@ContentType:
      lang:Java
    @@ForCheck:
      ManakaiDOM:ForIF
    @@For:
      ManakaiDOM:Java
  @FullName:
    @@lang:en
    @@@: DOM Core Module
  @Spec:
    @@DOM3:
      http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-BBACDC08
  @Namespace:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#
  
  @Description:
    @@lang:en
    @@@:
      The <DFN::DOM Core Module> is a fundemental module defined in 
      DOM Core specifications.  The Core Module provides basic 
      tree structure model and operations for HTML/XML document. 
      Interfaces in this module, as defined 
      in those specifications, must be fully implemented by all 
      conforming DOM implementations.
  
  @Author:
    @@FullName:Wakaba
    @@Mail:w@suika.fam.cx
  @License:
     license:Perl+MPL
  @Date:
    @@@:
      $Date: 2005/09/22 11:02:31 $
    @@ContentType:
      dis:Date.RCS

  @DefaultFor:
    ManakaiDOM:ManakaiDOMLatest
  
  @Require:
    @@Module:
      @@@Name: DOMMain
    @@Module:
      @@@Name: DOMXML
    @@Module:
      @@@Name: DOMCore
      @@@WithFor:
        ManakaiDOM:ManakaiDOM
    @@Module:
      @@@Name: DOMCore
      @@@WithFor:
        ManakaiDOM:ManakaiDOM1
      @@@For:
        !=ManakaiDOM:ManakaiDOM1
    @@Module:
      @@@Name: DOMCore
      @@@WithFor:
        ManakaiDOM:ManakaiDOM2
      @@@For:
        !=ManakaiDOM:ManakaiDOM2
    @@Module:
      @@@Name: DOMCore
      @@@WithFor:
        ManakaiDOM:ManakaiDOM3
      @@@For:
        !=ManakaiDOM:ManakaiDOM3
    @@Module:
      @@@Name: DOMCore
      @@@WithFor:
        ManakaiDOM:ManakaiDOMLatest
      @@@For:
        !=ManakaiDOM:ManakaiDOMLatest

Namespace:
  @dis:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#dis--
  @dis2pm:
    http://suika.fam.cx/~wakaba/archive/2004/11/8/dis2pm#
  @disPerl:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#dis--Perl--
  @doc:
    http://suika.fam.cx/~wakaba/archive/2005/7/tutorial#
  @DOMCore:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#
  @DOMEvents:
    http://suika.fam.cx/~wakaba/archive/2004/dom/events#
  @DOMLS:
    http://suika.fam.cx/~wakaba/archive/2004/dom/ls#
  @DOMMain:
    http://suika.fam.cx/~wakaba/archive/2004/dom/main#
  @DOMMetaImpl:
    http://suika.fam.cx/~wakaba/archive/2004/dom/meta#
  @DOMViews:
    http://suika.fam.cx/~wakaba/archive/2004/dom/views#
  @ev:
    http://www.w3.org/2001/xml-events
  @infoset:
    http://www.w3.org/2001/04/infoset#
  @kwd:
    http://suika.fam.cx/~wakaba/archive/2005/rfc2119/
  @lang:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#
  @license:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/license#
  @ManakaiDOM:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#
  @ManakaiDOMCore:
    http://suika.fam.cx/~wakaba/archive/2004/mdom-core#
  @ManakaiDOMEvents:
    http://suika.fam.cx/~wakaba/archive/2004/mdom-ev#
  @ManakaiDOMHTML:
    http://suika.fam.cx/~wakaba/archive/2004/mdom/html#
  @ManakaiDOMLS:
    http://suika.fam.cx/~wakaba/archive/2004/mdom-ls#
  @ManakaiDOMXML:
    http://suika.fam.cx/~wakaba/archive/2004/mdom-xml#
  @MDOM:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#ManakaiDOM.
  @MDOMX:
    http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#
  @MUErrorCore:-
  @null:
    http://suika.fam.cx/~wakaba/-temp/2003/09/27/null
  @perl:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#Perl--
  @rdf:
    http://www.w3.org/1999/02/22-rdf-syntax-ns#
  @rdfs:
    http://www.w3.org/2000/01/rdf-schema#
  @sw010:
    urn:x-suika-fam-cx:markup:suikawiki:0:10:
  @TreeCore: \
  @xhtml1:
    http://www.w3.org/1999/xhtml
  @xml:
    http://www.w3.org/XML/1998/namespace
  @xmlns:
    http://www.w3.org/2000/xmlns/

ElementTypeBinding:
  @Name: Exception
  @ElementType:
    ManakaiDOM:raises
  @ShadowContent:
    @@@For: !ManakaiDOM|all
ElementTypeBinding:
  @Name: Warning
  @ElementType:
    ManakaiDOM:alwaysWarns

ElementTypeBinding:
  @Name: raises
  @ElementType:
    ManakaiDOM:raises

ElementTypeBinding:
  @Name: IFDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:IF

ElementTypeBinding:
  @Name: ClassDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:Class
    @@For:
      ManakaiDOM:ManakaiDOM !=ManakaiDOM:ManakaiDOM

ElementTypeBinding:
  @Name: L1
  @ElementType:
    DOMMain:implementFeature
  @ShadowContent:
    @@@: CoreFeature10
    @@For:
      ManakaiDOM:DOM1
  @ShadowSibling:
    @@DOMMain:implementFeature:
      @@@@: CoreFeature20
      @@@For: 
        ManakaiDOM:DOM2
    @@DOMMain:implementFeature:
      @@@@: CoreFeature30
      @@@For: 
        ManakaiDOM:DOM3
    @@DOMMain:implementFeature:
      @@@@: 
        DOMXML:XMLFeature10
      @@@For:
        ManakaiDOM:DOM1 ManakaiDOM:DOMXMLFeature
    @@DOMMain:implementFeature:
      @@@@: 
        DOMXML:XMLFeature20
      @@@For:
        ManakaiDOM:DOM2 ManakaiDOM:DOMXMLFeature
    @@DOMMain:implementFeature:
      @@@@: 
        DOMXML:XMLFeature30
      @@@For:
        ManakaiDOM:DOM3 ManakaiDOM:DOMXMLFeature
    @@DOMMain:implementFeature:
      @@@@: 
        DOMXML:XMLVersionFeature10
      @@@For:
        ManakaiDOM:DOM3 ManakaiDOM:DOMXMLFeature
    @@DOMMain:implementFeature:
      @@@@: 
        DOMXML:XMLVersionFeature11
      @@@For:
        ManakaiDOM:DOM3 ManakaiDOM:DOMXMLFeature
ElementTypeBinding:
  @Name: L2
  @ElementType:
    DOMMain:implementFeature
  @ShadowContent:
    @@@: CoreFeature20
    @@For:
      ManakaiDOM:DOM2
  @ShadowSibling:
    @@DOMMain:implementFeature:
      @@@@: CoreFeature30
      @@@For: 
        ManakaiDOM:DOM3
    @@DOMMain:implementFeature:
      @@@@: 
        DOMXML:XMLFeature20
      @@@For:
        ManakaiDOM:DOM2 ManakaiDOM:DOMXMLFeature
    @@DOMMain:implementFeature:
      @@@@: 
        DOMXML:XMLFeature30
      @@@For:
        ManakaiDOM:DOM3 ManakaiDOM:DOMXMLFeature
    @@DOMMain:implementFeature:
      @@@@: 
        DOMXML:XMLVersionFeature10
      @@@For:
        ManakaiDOM:DOM3 ManakaiDOM:DOMXMLFeature
    @@DOMMain:implementFeature:
      @@@@: 
        DOMXML:XMLVersionFeature11
      @@@For:
        ManakaiDOM:DOM3 ManakaiDOM:DOMXMLFeature
ElementTypeBinding:
  @Name: L3
  @ElementType:
    DOMMain:implementFeature
  @ShadowContent:
    @@@: CoreFeature30
    @@For:
      ManakaiDOM:DOM3
  @ShadowSibling:
    @@DOMMain:implementFeature:
      @@@@: 
        DOMXML:XMLFeature30
      @@@For:
        ManakaiDOM:DOM3 ManakaiDOM:DOMXMLFeature
    @@DOMMain:implementFeature:
      @@@@: 
        DOMXML:XMLVersionFeature10
      @@@For:
        ManakaiDOM:DOM3 ManakaiDOM:DOMXMLFeature
    @@DOMMain:implementFeature:
      @@@@: 
        DOMXML:XMLVersionFeature11
      @@@For:
        ManakaiDOM:DOM3 ManakaiDOM:DOMXMLFeature

ElementTypeBinding:
  @Name: BlockCode
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      dis2pm:BlockCode

ElementTypeBinding:
  @Name: ConfigParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:DOMConfigParameterSet

ElementTypeBinding:
  @Name: EventSet
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:DOMEventSet

ElementTypeBinding:
  @Name: Method
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Method
    @@ForCheck: !=ManakaiDOM|ManakaiDOM

ElementTypeBinding:
  @Name: IntMethod
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Method
    @@ForCheck:
      ManakaiDOM:ManakaiDOM !=ManakaiDOM:ManakaiDOM ManakaiDOM|ForClass
    @@ManakaiDOM:isForInternal: 1

ElementTypeBinding:
  @Name: IntMethodC
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Method
    @@ForCheck:
      ManakaiDOM:ManakaiDOM !=ManakaiDOM:ManakaiDOM
    @@ManakaiDOM:isForInternal: 1

ElementTypeBinding:
  @Name: ReMethod
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Method
    @@ForCheck:
      ManakaiDOM:ManakaiDOM !=ManakaiDOM:ManakaiDOM ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: Param
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|MethodParameter

ElementTypeBinding:
  @Name: Return
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|MethodReturn

ElementTypeBinding:
  @Name: Attr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Attribute
    @@ForCheck: !=ManakaiDOM|ManakaiDOM

ElementTypeBinding:
  @Name: IntAttr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Attribute
    @@ForCheck: ManakaiDOM|ForClass
    @@ManakaiDOM:isForInternal: 1

ElementTypeBinding:
  @Name: ReAttr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Attribute
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: Get
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|AttributeGet

ElementTypeBinding:
  @Name: Set
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|AttributeSet

ElementTypeBinding:
  @Name: InCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:InCase

ElementTypeBinding:
  @Name: nullCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:InCase
    @@Value:
      @@@is-null:1

ElementTypeBinding:
  @Name: ConstGroup
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:ConstGroup
    @@ForCheck: !=ManakaiDOM|ManakaiDOM

ElementTypeBinding:
  @Name: ErrorSet
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      @@@@:
        ManakaiDOM:ConstGroup
      @@@ForCheck:
        ManakaiDOM:ForClass
    @@ForCheck: !=ManakaiDOM|ManakaiDOM ManakaiDOM|ForClass
    @@aliasChild:
      @@@@: 1
      @@@For:
        ManakaiDOM:ManakaiDOM
    @@Type:
      DOMMain:unsigned-short||ManakaiDOM|all
    @@rdfs:subClassOf:
      @@@@:
        DOMMain:unsigned-short||ManakaiDOM|all
      @@@ForCheck:
        ManakaiDOM:ForClass

ElementTypeBinding:
  @Name: Const
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: 
      ManakaiDOM:Const

ElementTypeBinding:
  @Name: XConst
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: 
      ManakaiDOM:Const

ElementTypeBinding:
  @Name: ErrorDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: 
      rdfs:Class
    @@ImplNote: Temporary.
    @@rdf:type:
      ManakaiDOM:DOMError
    @@ForCheck:
      ManakaiDOM:DOM !=ManakaiDOM:ManakaiDOM
    @@aliasChild:
      @@@@: 1
      @@@For:
        ManakaiDOM:ManakaiDOM
    @@ForCheck: !ManakaiDOM|all

ElementTypeBinding:
  @Name: ErrName
  @ElementType:
    dis:AppName
  @ShadowContent:
    @@ContentType:
      DOMCore:DOMErrorType

ElementTypeBinding:
  @Name: XParam
  @ElementType:
    ManakaiDOM:exceptionOrWarningParameter

ElementTypeBinding:
  @Name: SubTypeDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:ExceptionOrWarningSubType
    @@ForCheck:
      ManakaiDOM:ManakaiDOM ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: SubType
  @ElementType:
    dis:ImplNote

ElementTypeBinding:
  @Name: ErrSubTypeDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:ExceptionOrWarningSubType
    @@ForCheck:
      ManakaiDOM:ManakaiDOM
    @@ForCheck:
      ManakaiDOM:ForClass
    @@aliasChild:1
    @@ForCheck: !ManakaiDOM|all

ElementTypeBinding:
  @Name: PerlDef
  @ElementType:
    dis:Def
  @ShadowContent:
    @@ContentType:
      lang:Perl
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: PerlDefC
  @ElementType:
    dis:Def
  @ShadowContent:
    @@ContentType:
      lang:Perl

ElementTypeBinding:
  @Name: XML2Feature
  @ElementType:
    dis:ImplNote
  @ShadowContent:
    @@ImplNote:
      @@@lang:en
      @@@@:
        The <CITE::DOM Level 2 Core> specification said that HTML-only 
        DOM Level 2 implementations does not need to implement this member. 
        The DOM Level 2 Errata withdraws it and it requires HTML-only 
        DOM implementations throw a <X::DOMException.NOT_SUPPORTED_ERR>. 

PropDef:
  @QName: 
    dis:CParam
  @ImplNote:
    @@lang:en
    @@@:
      Temporary - should be bound to ManakaiDOM:DOMConfigParameter

## -- Features

ElementTypeBinding:
  @Name: FeatureDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DOMMain:DOMFeature
    @@For: =ManakaiDOM|all

ElementTypeBinding:
  @Name: FeatureVerDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DOMMain:DOMFeature

ElementTypeBinding:
  @Name: featureName
  @ElementType:
    dis:AppName
  @ShadowContent:
    @@ContentType:
      dis:String
ElementTypeBinding:
  @Name: featureQName
  @ElementType:
    dis:AppName
  @ShadowContent:
    @@ContentType:
      dis:TypeQName

FeatureDef:
  @featureName: Core
  @QName: CoreFeature
  @FeatureVerDef:
    @@QName: CoreFeature10
    @@Version: 1.0
    @@DOMMetaImpl:instanceFeatureOf: CoreFeature
    @@Description:
      @@@lang:en
      @@@@:
        The DOM Core Module (Fundemental Interface), Level 1. 
        \
        {NOTE:: Although some DOM implementations returns <DOM::true> for 
                <M::DOMImplementations.hasFeature> with <Feature::Core> and 
                <FeatureVer::1.0>, this behaviour is not defined by 
                any level of W3C DOM Specification.  DOM applications 
                should not expect DOM Level 1 Core implementation 
                would return <DOM::true> to that method call. 
          \
        }
  @FeatureVerDef:
    @@QName: CoreFeature20
    @@Version: 2.0
    @@DOMMetaImpl:instanceFeatureOf: CoreFeature
    @@DOMMetaImpl:extendFeature: CoreFeature10
    @@Spec:
      @@@DOM3:
        http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-BBACDC08
    @@Description:
      @@@lang:en
      @@@@: The DOM Core Module, Level 2.
  @FeatureVerDef:
    @@QName: CoreFeature30
    @@Version: 3.0
    @@DOMMetaImpl:instanceFeatureOf: CoreFeature
    @@DOMMetaImpl:extendFeature: CoreFeature20
    @@Spec:
      @@@DOM3:
        http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-BBACDC08
    @@Description:
      @@@lang:en
      @@@@: The DOM Core Module, Level 3.

## -- Exception

ElementTypeBinding:
  @Name:enMufDef
  @ElementType:
    dis:Def
  @ShadowContent:
    @@lang:en
    @@ContentType:
      lang:muf

ElementTypeBinding:
  @Name:XParamParamName
  @ElementType:
    ManakaiDOM:exceptionOrWarningParameter
  @ShadowContent:
    @@ForCheck:
      ManakaiDOM:ManakaiDOM
    @@QName:
      MDOMX:param-name

ResourceDef:
  @rdf:type:
    @@@: dis|MultipleResource
    @@ForCheck: !ManakaiDOM|ForIF !ManakaiDOM|ForClass
  @resourceFor: ManakaiDOM|ForIF
  @resourceFor:
    @@@: ManakaiDOM|ForClass
    @@ForCheck: ManakaiDOM|ManakaiDOM !=ManakaiDOM|ManakaiDOM
  @For: ManakaiDOM|DOM1
  @For: =ManakaiDOM|ManakaiDOM

  @rdf:type:
    @@@: ManakaiDOM|ExceptionIF
    @@ForCheck: ManakaiDOM|ForIF

  @rdf:type:
    @@@: ManakaiDOM|ExceptionClass
    @@ForCheck: ManakaiDOM|ForClass

  @Implement:
    @@@: ||ManakaiDOM|ManakaiDOM||ManakaiDOM|ForIF
    @@ContentType: DISCore|TFPQNames
    @@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM
  @Implement:
    @@@: ||ManakaiDOM|ManakaiDOM1||ManakaiDOM|ForIF
    @@ContentType: DISCore|TFPQNames
    @@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM1
  @Implement:
    @@@: ||ManakaiDOM|ManakaiDOM2||ManakaiDOM|ForIF
    @@ContentType: DISCore|TFPQNames
    @@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM2
  @Implement:
    @@@: ||ManakaiDOM|ManakaiDOM3||ManakaiDOM|ForIF
    @@ContentType: DISCore|TFPQNames
    @@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM3
  @Implement:
    @@@: ||ManakaiDOM|ManakaiDOMLatest||ManakaiDOM|ForIF
    @@ContentType: DISCore|TFPQNames
    @@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOMLatest

  @DOMMain:implementFeature:
    @@@: CoreFeature10
    @@For: ManakaiDOM|DOM1
  @DOMMain:implementFeature:
    @@@: CoreFeature20
    @@For: ManakaiDOM|DOM2
  @DOMMain:implementFeature:
    @@@: CoreFeature30
    @@For: ManakaiDOM|DOM3

  @DOMMain:implementFeature:
    @@@: DOMXML|XMLFeature10
    @@For: ManakaiDOM|DOM1 ManakaiDOM|DOMXMLFeature
  @DOMMain:implementFeature:
    @@@: DOMXML|XMLFeature20
    @@For: ManakaiDOM|DOM2 ManakaiDOM|DOMXMLFeature
  @DOMMain:implementFeature:
    @@@: DOMXML|XMLFeature30
    @@For: ManakaiDOM|DOM3 ManakaiDOM|DOMXMLFeature
  @DOMMain:implementFeature:
    @@@: DOMXML|XMLVersionFeature10
    @@For: ManakaiDOM|DOM3 ManakaiDOM|DOMXMLFeature
  @DOMMain:implementFeature:
    @@@: DOMXML|XMLVersionFeature11
    @@For: ManakaiDOM|DOM3 ManakaiDOM|DOMXMLFeatureXML11

  @Implement:
    @@@: DOMMain|ManakaiDOMExceptionIF||ManakaiDOM|Perl
    @@ForCheck: ManakaiDOM|ForClass

  @ISA:
    @@@: ManakaiDOM|ManakaiDOMException||ManakaiDOM|Perl
    @@ForCheck: ManakaiDOM|ForClass
  @ISA:
    @@@: ManakaiDOM|ManakaiDOMObject
    @@ForCheck: ManakaiDOM|ForClass

  @IFQName: DOMException
  @ClsQName: ManakaiDOMException

  @Description:
    @@lang:en
    @@@:
      Exceptions common to the DOM modules.
  @Attr:
     @@Name:  code
     @@Get:
       @@@Type:  
         DOMMain:unsigned-short||ManakaiDOM|all
       @@@actualType: ExceptionCode
       @@@Description:
         @@@@lang:en
         @@@@@: 
           The error code of this object. 
     @@ForCheck: ManakaiDOM|ForIF

  @ResourceDef:
    @@rdf:type: ManakaiDOM|ConstGroup
    @@ForCheck: !=ManakaiDOM|ManakaiDOM

    @@IFQName: ExceptionCode
    @@ClsQName: ManakaiDOMExceptionCode
    @@PerlName: ExceptionCode

     @@Description:
       @@@lang:en
       @@@@: Integers indicating the type of error generated.
     @@rdfs:subClassOf:
       @@@@:
         DOMMain:unsigned-short::ManakaiDOM:all
       @@@ForCheck:
         ManakaiDOM:ForClass
     @@Type:
       DOMMain:unsigned-short::ManakaiDOM:all
     @@XConst:
        @@@Name:  INDEX_SIZE_ERR
        @@@intValue:  1
        @@@Description:
          @@@@lang:en
          @@@@@: 
            The specified index or size value is less than or greater 
            than the allowed value. 
        @@@enMufDef:
              The index or size%t (
                name => {<Q::MDOMX:param-name>},
                prefix => {, as specified by the parameter "}, suffix => {",}); 
              is negative or greater than the allowed value.
        @@@XParamParamName:
          @@@@Description:
            @@@@@lang:en
            @@@@@@: 
              The name of parameter to which invalid value is specified.
       @@@XParam:
         @@@@QName:index
         @@@@Description:
           @@@@@lang:en
           @@@@@@: The specified index or size. 
       @@@SubTypeDef:
         @@@@QName: NEGATIVE_INDEX_ERR
         @@@@Description:
           @@@@@lang:en
           @@@@@@:
             The specified index or size is negative. 
         @@@@enMufDef:
           The specified index or size (%p (
             name => {<Q::MDOMX:param-name>},
             prefix => {"},
             suffix => {" = },
           );%p (
             name => {<Q::DOMCore:index>},
           );) is negative. 
       @@@SubTypeDef:
         @@@@QName: OUT_OF_UPPER_BOUND_ERR
         @@@@Description:
           @@@@@lang:en
           @@@@@@:
             The specified index or size is greater than an upper bound. 
         @@@@enMufDef:
           The specified index or size (%p (
             name => {<Q::MDOMX:param-name>},
             prefix => {"},
             suffix => {" = },
           );%p (
             name => {<Q::DOMCore:index>},
           );) is greater than an upper bound. 
     @@XConst:
        @@@Name:  DOMSTRING_SIZE_ERR
        @@@intValue:  2
        @@@Description:
          @@@@lang:en
          @@@@@: 
            The specified range of text does not fit into a 
            <TYPE::DOMMain:DOMString>.
        @@@Description:
          @@@@lang:en
          @@@@@:
            This exception code is so defined for languages in which 
            a string is only able to contain limited number of characters 
            that the manakai DOM implementation never raises this 
            kind of exception. 
          @@@@For:
            ManakaiDOM:ManakaiDOM
     @@XConst:
        @@@Name:  HIERARCHY_REQUEST_ERR
        @@@intValue:  3
        @@@Description:
          @@@@lang:en
          @@@@@:
            An attempt is made to insert a node somewhere it does not belong.
        @@@SubTypeDef:
          @@@@QName:
            MDOMX:HIERARCHY_ANCESTOR_OR_SELF
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              An attempt is made to insert a node that is one of 
              ancestor of this node or that is this node itself.
          @@@@XParam:
            @@@@@QName:
              MDOMX:param-name
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@: The name of the parameter that specifies the node.
        @@@SubTypeDef:
          @@@@QName:
            MDOMX:HIERARCHY_BAD_TYPE
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              An attempt is made to insert a node whose type is not allowed.
          @@@@XParam:
            @@@@@QName:
              infoset:nodeType
            @@@@@Type:
              ManakaiDOM:ManakaiDOMURI
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@: The type of the node being tried to insert.
          @@@@XParam:
            @@@@@QName:
              MDOMX:param-name
            @@@@@Type:
              DOMMain:DOMParameterName
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The name of the parameter that specifies the node.
        @@@SubTypeDef:
          @@@@QName:
            ManakaiDOMHTML:MDOM_NOT_CAPTION
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The given element is not of type <HE::caption>. 
        @@@SubTypeDef:
          @@@@QName:
            MDOMX:MDOM_SECOND_DOC_ELEMENT
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              An attempt is made to insert a second document element node.
          @@@@XParam:
            @@@@@QName:
              MDOMX:param-name
            @@@@@Type:
              DOMMain:DOMMethodParameterName
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The name of the parameter the node is specified.
        @@@SubTypeDef:
          @@@@QName:
            MDOMX:MDOM_SECOND_DOCTYPE
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              An attempt is made to insert a second document type node.
          @@@@XParam:
            @@@@@QName:
              MDOMX:param-name
            @@@@@Type:
              DOMMain:DOMMethodParameterName
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The name of the parameter the node is specified.
     @@XConst:
        @@@Name:  WRONG_DOCUMENT_ERR
        @@@Type:  
          DOMMain:unsigned-short||ManakaiDOM|all
        @@@intValue:  4
        @@@Description:
          @@@@lang:en
          @@@@@:
            A node is used in a different document than the one
            that created it.
        @@@SubTypeDef:
          @@@@QName: MDOMX_DOCTYPE_ALREADY_USED
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              A specified document type node has already been 
              used as part of a different document tree.
        @@@SubTypeDef:
          @@@@QName: MDOMX_EXTERNAL_NODE
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              A specified node was created from a different DOM implementation.
     @@XConst:
        @@@Name:  INVALID_CHARACTER_ERR
        @@@Type:  
          DOMMain:unsigned-short||ManakaiDOM|all
        @@@intValue:  5
        @@@Description:
          @@@@lang:en
          @@@@@: An invalid or illegal character is specified.
        @@@SubTypeDef:
          @@@@QName:
            MDOMX:MDOM_BAD_NAME
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The specified name is not a SGML or XML <XML::Name>.
          @@@@enMufDef:
            The name%p (name => {<Q::DOMCore:name>}, prefix => { "}, 
            suffix => {"}); is illegal%p (name => {<Q::infoset:version>}, 
            prefix => { according to XML });
          @@@@XParam:
            @@@@@QName:
              DOMCore:name
            @@@@@Type:
              DOMMain:ManakaiDOMXMLName
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@: 
                The <XML::Name> specified.
          @@@@XParam:
            @@@@@QName:
              infoset:version
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@: The version of XML.
     @@XConst:
        @@@Name:  NO_DATA_ALLOWED_ERR
        @@@intValue:  6
        @@@Description:
          @@@@lang:en
          @@@@@: Data is specified for a node that does not support data.
        @@@ImplNote:
          @@@@lang:en
          @@@@@: How is this exception code used?
     @@XConst:
        @@@QName:
          @@@@@:NO_MODIFICATION_ALLOWED_ERR
          @@@@ForCheck:
            ManakaiDOM:ForClass
          @@@@ImplNote: Temporary.
        @@@Name:  NO_MODIFICATION_ALLOWED_ERR
        @@@intValue:  7
        @@@Description:
          @@@@lang:en
          @@@@@:
            An attempt is made to modify an object where 
            modifications are not allowed. 
        @@@SubTypeDef:
          @@@@QName:
            MDOMX:NOMOD_ATTR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              One of attribute nodes is read-only. 
        @@@SubTypeDef:
          @@@@QName:
            MDOMX:NOMOD_CHILD
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              One of child nodes is read-only. 
        @@@SubTypeDef:
          @@@@QName:NOMOD_DESCENDANT_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              One of descendant nodes (including attribute nodes 
              or its descendants) is read-only. 
        @@@SubTypeDef:
          @@@@QName:NOMOD_NAMEDNODEMAP_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              An attempt is made to modify an uneditable <IF::NamedNodeMap>. 
        @@@SubTypeDef:
          @@@@QName:NOMOD_NODELIST_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              An attempt is made to modify an uneditable <IF::NodeList>. 
        @@@SubTypeDef:
          @@@@QName:
            MDOMX:NOMOD_PARENT
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The parent node of this node is read-only.
        @@@SubTypeDef:
          @@@@QName:
            MDOMX:NOMOD_SRC_PARENT
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The parent node of the source node is read-only.
          @@@@XParam:
            @@@@@QName:
              MDOMX:param-name
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@: The parameter by which the source node is specified.
        @@@SubTypeDef:
          @@@@QName:
            MDOMX:NOMOD_THIS
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              This node is read-only so that it is impossible to edit. 
          @@@@enMufDef:
            This node is read-only
     @@XConst:
        @@@Name:  NOT_FOUND_ERR
        @@@intValue:  8
        @@@Description:
          @@@@lang:en
          @@@@@:
            An attempt is made to refer a node in a context where 
            it does not exist.
       @@@SubTypeDef:
         @@@@QName: NOT_ATTR_ERR
         @@@@Description:
           @@@@@lang:en
           @@@@@@:
             The specified node is not an attribute node attached 
             to the target node. 
         @@@@enMufDef:
           The specified node is not an attribute of this node
       @@@SubTypeDef:
         @@@@QName: NOT_CHILD_ERR
         @@@@Description:
           @@@@@lang:en
           @@@@@@:
             The specified node is not a child node of the target node. 
         @@@@enMufDef:
           The specified node is not a direct child of this node
     @@XConst:
        @@@Name:  NOT_SUPPORTED_ERR
        @@@intValue:  9
        @@@Description:
          @@@@lang:en
          @@@@@:
            The DOM implementation does not support the type of object requested.
        @@@SubTypeDef:
          @@@@QName: FEATURE_NOT_SUPPORTED_ERR
          @@@@enDesc:
            One or more of the requested features or their versions
            are not supported by the implementation.
          @@@@XParam:
            @@@@@QName: features
            @@@@@enDesc:
              The features or the combination of the features
              that are not supported.
          @@@@enMufDef:
            %p (name => {<Q::DOMCore:features>}, prefix => {"},
            suffix => {": });Unsupported features requested
        @@@SubTypeDef:
          @@@@QName:
            ManakaiDOMEvents:FOREIGN_EVENT_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The event object was created by other DOM implementation and 
              it does not support the <IF::DOMEvents:CustomEvent> interface. 
          @@@@enMufDef:
            This is not a supported event object; use createEvent method 
            or implement the CustomEvent interface
          @@@@For:
            ManakaiDOM:DOMEventsFeature
        @@@SubTypeDef:
          @@@@QName:
            MDOMX:MDOM_DOC_NOSUPPORT_XML
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The document does not support the <DOM::XML> feature.
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              XML-specific operations were specified as HTML-only 
              DOM implementations does not have to implement them 
              in the DOM Level 2 Specification.  The DOM Level 2 
              Errata and the DOM Level 3 Specification define as 
              the DOM implementation raise an exception of code 
              <X::DOMException.NOT_SUPPORTED_ERR>.
           \
              This DOM implementation throws the exception in 
              both levels.
          @@@@enMufDef:
            The document is not an XML document while the operation 
            is for XML documents 
        @@@SubTypeDef:
          @@@@QName:
            MDOMX:MDOM_DOC_NOSUPPORT_XMLNS
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              This document does not support XML Namespaces.
          @@@@enMufDef:
            The document is not a namespaced XML document while the 
            operation is for XML Namespace documents 
        @@@SubTypeDef:
          @@@@QName:
            ManakaiDOMEvents:MDOM_IMPL_NOSUPPORT_EVENT
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The DOM implementation is unable to create an event of 
              the requested type. 
          @@@@XParam:
            @@@@@QName:
              DOMEvents:createEventType
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@: The type of event requested. 
        @@@SubTypeDef:
          @@@@QName:
            MDOMX:MDOM_IMPL_NOSUPPORT_SCHEMA
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The DOM implementation does not support the schema language.
          @@@@XParam:
            @@@@@QName:
              DOMCore:schemaType
            @@@@@Type:
              ManakaiDOM:ManakaiDOMNamespaceURI
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The absolute URI representing the schema language requested.
          @@@@enMufDef:
              The schema language specified %p (prefix => {<},
              suffix => {>}, name => {<Q::DOMCore:schemaType>}); 
              is not supported
        @@@SubTypeDef:
          @@@@QName:
            ManakaiDOMHTML:MDOMHTML_IMPL_NOSUPPORT_SET_SELECT_LENGTH
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The DOM implementation does not support setting 
              <A::DOMHTML:HTMLSelectElement.length>.
        @@@SubTypeDef:
          @@@@QName:
            MDOMX:MDOM_IMPL_NOSUPPORT_XML
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The DOM implementation does not support the <DOM::XML> feature.
          @@@@enMufDef:
            This operation requires the support for the XML documents
        @@@SubTypeDef:
          @@@@QName:
            MDOMX:MDOM_IMPL_NOSUPPORT_XMLNS
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The DOM implementation does not support the <DOM::XML> feature 
              and the language exposed through the <IF::Document> 
              object does not support XML Namespaces.
          @@@@enMufDef:
            This operation requires the support for the XML Namespaces 
        @@@SubTypeDef:
          @@@@QName:
            MDOMX:MDOM_IMPL_NOSUPPORT_XMLVER
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The DOM implementation does not support the XML 
              version specified.
          @@@@XParam:
            @@@@@QName:
              infoset:version
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@: The XML version
          @@@@enMufDef:
            XML version%p (name => {<Q::infoset:version>}, 
            prefix => { "}, suffix => {"}); is not supported
        @@@SubTypeDef:
          @@@@QName:
            MDOMX:MDOM_NODE_NOSUPPORT_XMLNS
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The node does not support XML Namespaces.  The node 
              might have been created by the DOM Level 1 methods or
              instantiated from the markup language that does not 
              support XML Namespaces.
          @@@@XParam:
            @@@@@QName:
              MDOMX:param-name
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The name of the parameter that provides the node 
                that does not support XML Namespaces.
          @@@@enMufDef:
            The node does not support XML Namespaces while the operation 
            requires the node to support namespaces; the node is not 
            of an XML document or the node has been created by DOM 
            Level 1 method
        @@@SubTypeDef:
          @@@@QName:
            ManakaiDOMLS:MDOMLS_IMPL_NOSUPPORT_MODE
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The DOM implementation does not support the requested mode.
          @@@@XParam: 
            @@@@@QName:
              DOMLS:mode
            @@@@@Type:
              DOMLS:DOMImplementationLSMode
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@: The requested mode.
          @@@@enMufDef:
              The requested mode "%p (name => {<Q::DOMLS:mode>});" 
              is not supported

       @@@SubTypeDef:
         @@@@QName: 
           MDOMX:MDOM_IMPL_BY_APP
         @@@@Type: 
           DOMMain:unsigned-short::ManakaiDOM:all
         @@@@intValue: 4
         @@@@enDesc:
           A method or attribute is not implemented; it is expected
           that a DOM application implements it.

     @@XConst:
        @@@Name:  INUSE_ATTRIBUTE_ERR
        @@@Type:  
          DOMMain:unsigned-short::ManakaiDOM:all
        @@@intValue:  10
        @@@Description:
          @@@@lang:en
          @@@@@: 
            An attempt is made to add an attribute that is already inuse 
            elsewhere.
       @@@enMufDef:
         The attribure node is already in use elsewhere
     @@XConst:
        @@@Name:  INVALID_STATE_ERR
        @@@intValue:  11
        @@@Level[list]:  2
        @@@SpecLevel: 2
        @@@For:
          ManakaiDOM:DOM2
        @@@Description:
          @@@@lang:en
          @@@@@:
            An attempt is made to use an object that is not (or no longer) 
            usable.
        @@@SubTypeDef:
          @@@@QName:
            ManakaiDOMLS:MDOMLS_BUSY
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The parser is busy.
     @@XConst:
        @@@Name:  SYNTAX_ERR
        @@@intValue:  12
        @@@Level[list]:  2
        @@@SpecLevel: 2
        @@@For:
          ManakaiDOM:DOM2
        @@@Description:
          @@@@lang:en
          @@@@@: An invalid or illegal string is specified.
        @@@SubTypeDef:
          @@@@QName:
            ManakaiDOMHTML:MDOMHTML_BAD_COOKIE
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The specifieid value does not adhere to RFC 2965 
              cookie value syntax.
     @@XConst:
        @@@Name:  INVALID_MODIFICATION_ERR
        @@@intValue:  13
        @@@Level[list]:  2
        @@@SpecLevel: 2
        @@@For:
          ManakaiDOM:DOM2
        @@@Description:
          @@@@lang:en
          @@@@@: An attempt is made to modify the type of underlying object.
     @@XConst:
        @@@Name:  NAMESPACE_ERR
        @@@intValue:  14
        @@@SpecLevel: 2
        @@@Level[list]:  2
        @@@For:
          ManakaiDOM:DOM2
        @@@Description:
          @@@@lang:en
          @@@@@:
            An attempt is made to create or change an object in 
            a way that is incorrect with regard to namespaces.
        @@@SubTypeDef:
          @@@@QName:
            MDOMX:MDOM_NS_BAD_NCNAME
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The specified <CODE::NCName> is illegal according to 
              the XML version in use.
          @@@@enMufDef:
            The NCName%p (name => {<Q::infoset:name>}, prefix => { "},
            suffix => {"}); is illegal%p (name => {<Q::infoset:version>}, 
            prefix => { according to the XML });
          @@@@XParam:
            @@@@@QName:
              infoset:name
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <CODE::NCName> specified.
          @@@@XParam:
            @@@@@QName:
              infoset:version
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The version of XML according to which the name is illegal. 
        @@@SubTypeDef:
          @@@@QName:
            MDOMX:MDOM_NS_MALFORMED_QNAME
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The specified qualified name is malformed according 
              to the XML version in use.
          @@@@XParam:
            @@@@@QName:
              DOMCore:qualifiedName
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@: The qualified name specified.
          @@@@XParam:
            @@@@@QName:
              infoset:version
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The version of XML used to check the name. 
          @@@@enMufDef:
            The QName%p (name => {<Q::DOMCore:qualifiedName>}, prefix => { "}, 
            suffix => {"}); is illegal%p (name => {<Q::infoset:version>}, 
            prefix => { according to XML });
        @@@SubTypeDef:
          @@@@QName:
            MDOMX:MDOM_NS_NOPREFIX_WITH_NON_NULL_URI
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              There is no namespace prefix but there is a 
              non-namespace URI specified.
          @@@@XParam:
            @@@@@QName:
              infoset:namespaceName
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The namespace URI. 
          @@@@XParam:
            @@@@@QName:
              DOMCore:qualifiedName
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The qualified name. 
          @@@@enMufDef:
            %p (name => {<Q::DOMCore:qualifiedName>}, prefix => {QName "}, 
            suffix => {": });
            A non-null namespace prefix is required for a non-null 
            namespace URI%p (name => {<Q::infoset:namespaceName>},
            prefix => { <}, suffix => {>});
        @@@SubTypeDef:
          @@@@QName:
            MDOMX:MDOM_NS_NULL_QNAME_WITH_NON_NULL_URI
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The qualified name specified is not <DOM::null> but 
              the namespace URI that is not <DOM::null> is specified.
          @@@@XParam:
            @@@@@QName:
              infoset:namespaceName
            @@@@@Type:
              ManakaiDOM:ManakaiDOMNamespaceURI
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@: The namespace URI specified.
          @@@@XParam:
            @@@@@QName:
              DOMCore:qualifiedName
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The qualified name. 
          @@@@enMufDef:
            %p (name => {<Q::DOMCore:qualifiedName>}, prefix => {QName "}, 
            suffix => {": });
            A non-null namespace prefix is required for a non-null 
            namespace URI%p (name => {<Q::infoset:namespaceName>},
            prefix => { <}, suffix => {>});
        @@@SubTypeDef:
          @@@@QName:
            MDOMX:MDOM_NS_OTHER_WITH_XML_URI
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The namespace prefix specified is not equal to <XML::xml> 
              while the namespace URI is 
              <URI::http://www.w3.org/XML/1998/namespace>.
          @@@@enMufDef:
            The namespace prefix for namespace URI 
            <http://www.w3.org/XML/1998/namespace> must be a "xml"%p
            (name => {<Q::infoset:prefix>}, prefix => {, not "}, 
             suffix => {"});
          @@@@XParam:
            @@@@@QName:
              infoset:prefix
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@: The namespace prefix.
          @@@@XParam:
            @@@@@QName:
              DOMCore:qualifiedName
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@: The qualified name.
        @@@SubTypeDef:
          @@@@QName:
            MDOMX:MDOM_NS_OTHER_WITH_XMLNS_URI
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The namespace prefix specified is not equal to <XML::xmlns> 
              while the namespace URI is 
              <URI::http://www.w3.org/2000/xmlns/>.
          @@@@enMufDef:
            The namespace prefix for namespace URI 
            <http://www.w3.org/2000/xmlns/> must be a "xmlns"%p
            (name => {<Q::infoset:prefix>}, prefix => {, not "}, 
             suffix => {"});
          @@@@XParam:
            @@@@@QName:
              infoset:prefix
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@: The namespace prefix.
        @@@SubTypeDef:
          @@@@QName:
            MDOMX:MDOM_NS_PREFIX_WITH_NULL_URI
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The namespace prefix is specified but the namespace URI 
              is <DOM::null>.
          @@@@XParam:
            @@@@@QName:
              infoset:prefix
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@: The namespace prefix specified.
        @@@SubTypeDef:
          @@@@QName:
            MDOMX:MDOM_NS_QNAME_IS_XMLNS
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The qualified name specified equals to <XA::xmlns>.
        @@@SubTypeDef:
          @@@@QName:
            MDOMX:MDOM_NS_XML_WITH_OTHER_URI
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The namespace prefix specified is <XML::xml> and 
              the namespace URI is other than 
              <URI::http://www.w3.org/XML/1998/namespace>.
          @@@@XParam:
            @@@@@QName:
              infoset:namespaceName
            @@@@@Type:
              ManakaiDOM:ManakaiDOMNamespaceURI
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@: The namespace URI.
        @@@SubTypeDef:
          @@@@QName:
            MDOMX:MDOM_NS_XMLNS_WITH_OTHER_URI
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The namespace prefix specified is <XML::xmlns> and 
              the namespace URI is other than 
              <URI::http://www.w3.org/2000/xmlns>.
          @@@@XParam:
            @@@@@QName:
              infoset:namespaceName
            @@@@@Type:
              ManakaiDOM:ManakaiDOMNamespaceURI
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@: The namespace URI.
        @@@SubTypeDef:
          @@@@QName:
            MDOMX:MDOM_NS_XMLNSQ_WITH_OTHER_URI
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The qualified name is <XML::xmlns> and 
              the namespace URI is other than 
              <URI::http://www.w3.org/2000/xmlns>.
          @@@@XParam:
            @@@@@QName:
              infoset:namespaceName
            @@@@@Type:
              ManakaiDOM:ManakaiDOMNamespaceURI
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@: The namespace URI.
       @@@SubTypeDef:
         @@@@QName:
           MDOMX:MDOM_NS_XMLNS_XMLNS
         @@@@Description:
           @@@@@lang:en
           @@@@@@:
             The qualified name is <XA::xmlns:xmlns>.  It is prohibited 
             by the XML Namespace Specifications.
        @@@SubTypeDef:
          @@@@QName: MDOMX_HTML_NSURI
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              An attempt is made to set a namespace URI to 
              an HTML node. 
          @@@@For:
            ManakaiDOM:DOMHTMLFeature
     @@XConst:
        @@@Name:  INVALID_ACCESS_ERR
        @@@intValue:  15
        @@@Level[list]:  2
        @@@SpecLevel: 2
        @@@Description:
          @@@@lang:en
          @@@@@:
            A parameter or an operation is not supported by the 
            underlying object.
     @@XConst:
        @@@Name:  VALIDATION_ERR
        @@@intValue:  16
        @@@Level[list]:  3
        @@@SpecLevel:3
        @@@For:
          ManakaiDOM:DOM3
        @@@Description:
          @@@@lang:en
          @@@@@:
            An attempt is made to modify an object where the modification 
            would make the Node invalid with respect to partial validity.

     @@XConst:
        @@@Name:  TYPE_MISMATCH_ERR
        @@@intValue:  17
        @@@Level[list]:  3
        @@@SpecLevel:3
        @@@For:
          ManakaiDOM:DOM3
        @@@Description:
          @@@@lang:en
          @@@@@:
            The type of an object is incompatible with the expected 
            type of the parameter associated to the object.

PropDef:
  @QName: features
  @enDesc:
    Lists of features.
  @Type: ManakaiDOM|ManakaiDOMFeatures

ElementTypeBinding:
  @Name: NodeTypeDef
  @ElementType: 
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      @@@@: dis|MultipleResource
      @@@ForCheck: !ManakaiDOM|ForIF !ManakaiDOM|ForClass
    @@resourceFor: ManakaiDOM|ForIF
    @@resourceFor:
      @@@@: ManakaiDOM|ForClass
      @@@ForCheck: ManakaiDOM|ManakaiDOM !=ManakaiDOM|ManakaiDOM
    @@For: ManakaiDOM|DOM1
    @@For: =ManakaiDOM|ManakaiDOM

    @@rdf:type:
      @@@@: ManakaiDOM|IF
      @@@ForCheck: ManakaiDOM|ForIF

    @@rdf:type:
      @@@@: ManakaiDOM|Class
      @@@ForCheck: ManakaiDOM|ForClass

    @@ISA:
      @@@@: Node
      @@@ForCheck: ManakaiDOM|ForIF
    @@ISA:
      @@@@: ManakaiDOMNode
      @@@ForCheck: ManakaiDOM|ForClass

    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOM||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOM1||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM1
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOM2||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM2
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOM3||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM3
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOMLatest||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOMLatest

    @@DOMMain:implementFeature:
      @@@@: CoreFeature10
      @@@For: ManakaiDOM|DOM1
    @@DOMMain:implementFeature:
      @@@@: CoreFeature20
      @@@For: ManakaiDOM|DOM2
    @@DOMMain:implementFeature:
      @@@@: CoreFeature30
      @@@For: ManakaiDOM|DOM3
    @@DOMMain:implementFeature:
      @@@@: DOMXML|XMLFeature10
      @@@For: ManakaiDOM|DOM1 ManakaiDOM|DOMXMLFeature
    @@DOMMain:implementFeature:
      @@@@: DOMXML|XMLFeature20
      @@@For: ManakaiDOM|DOM2 ManakaiDOM|DOMXMLFeature
    @@DOMMain:implementFeature:
      @@@@: DOMXML|XMLFeature30
      @@@For: ManakaiDOM|DOM3 ManakaiDOM|DOMXMLFeature
    @@DOMMain:implementFeature:
      @@@@: DOMXML|XMLVersionFeature10
      @@@For: ManakaiDOM|DOM3 ManakaiDOM|DOMXMLFeature
    @@DOMMain:implementFeature:
      @@@@: DOMXML|XMLVersionFeature11
      @@@For: ManakaiDOM|DOM3 ManakaiDOM|DOMXMLFeatureXML11

ElementTypeBinding:
  @Name: IFCls1Def
  @ElementType: 
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      @@@@: dis|MultipleResource
      @@@ForCheck: !ManakaiDOM|ForIF !ManakaiDOM|ForClass
    @@resourceFor: ManakaiDOM|ForIF
    @@resourceFor:
      @@@@: ManakaiDOM|ForClass
      @@@ForCheck: ManakaiDOM|ManakaiDOM !=ManakaiDOM|ManakaiDOM
    @@For: ManakaiDOM|DOM1
    @@For: =ManakaiDOM|ManakaiDOM

    @@rdf:type:
      @@@@: ManakaiDOM|IF
      @@@ForCheck: ManakaiDOM|ForIF

    @@rdf:type:
      @@@@: ManakaiDOM|Class
      @@@ForCheck: ManakaiDOM|ForClass
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOM||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOM1||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM1
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOM2||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM2
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOM3||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM3
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOMLatest||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOMLatest

    @@DOMMain:implementFeature: CoreFeature10
    @@DOMMain:implementFeature:
      @@@@: CoreFeature20
      @@@For: ManakaiDOM|DOM2
    @@DOMMain:implementFeature:
      @@@@: CoreFeature30
      @@@For: ManakaiDOM|DOM3
    @@DOMMain:implementFeature:
      @@@@: DOMXML|XMLFeature10
      @@@For: ManakaiDOM|DOM1 ManakaiDOM|DOMXMLFeature
    @@DOMMain:implementFeature:
      @@@@: DOMXML|XMLFeature20
      @@@For: ManakaiDOM|DOM2 ManakaiDOM|DOMXMLFeature
    @@DOMMain:implementFeature:
      @@@@: DOMXML|XMLFeature30
      @@@For: ManakaiDOM|DOM3 ManakaiDOM|DOMXMLFeature
    @@DOMMain:implementFeature:
      @@@@: DOMXML|XMLVersionFeature10
      @@@For: ManakaiDOM|DOM3 ManakaiDOM|DOMXMLFeature
    @@DOMMain:implementFeature:
      @@@@: DOMXML|XMLVersionFeature11
      @@@For: ManakaiDOM|DOM3 ManakaiDOM|DOMXMLFeatureXML11


ElementTypeBinding:
  @Name: IFCls2Def
  @ElementType: 
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      @@@@: dis|MultipleResource
      @@@ForCheck: !ManakaiDOM|ForIF !ManakaiDOM|ForClass
    @@resourceFor: ManakaiDOM|ForIF
    @@resourceFor:
      @@@@: ManakaiDOM|ForClass
      @@@ForCheck: ManakaiDOM|ManakaiDOM !=ManakaiDOM|ManakaiDOM
    @@For: ManakaiDOM|DOM2
    @@For: =ManakaiDOM|ManakaiDOM

    @@rdf:type:
      @@@@: ManakaiDOM|IF
      @@@ForCheck: ManakaiDOM|ForIF

    @@rdf:type:
      @@@@: ManakaiDOM|Class
      @@@ForCheck: ManakaiDOM|ForClass
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOM||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOM2||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM2
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOM3||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM3
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOMLatest||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOMLatest

    @@DOMMain:implementFeature: CoreFeature20
    @@DOMMain:implementFeature:
      @@@@: CoreFeature30
      @@@For: ManakaiDOM|DOM3
    @@DOMMain:implementFeature:
      @@@@: DOMXML|XMLFeature20
      @@@For: ManakaiDOM|DOM2 ManakaiDOM|DOMXMLFeature
    @@DOMMain:implementFeature:
      @@@@: DOMXML|XMLFeature30
      @@@For: ManakaiDOM|DOM3 ManakaiDOM|DOMXMLFeature
    @@DOMMain:implementFeature:
      @@@@: DOMXML|XMLVersionFeature10
      @@@For: ManakaiDOM|DOM3 ManakaiDOM|DOMXMLFeature
    @@DOMMain:implementFeature:
      @@@@: DOMXML|XMLVersionFeature11
      @@@For: ManakaiDOM|DOM3 ManakaiDOM|DOMXMLFeatureXML11

ElementTypeBinding:
  @Name: IFCls3Def
  @ElementType: 
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      @@@@: dis|MultipleResource
      @@@ForCheck: !ManakaiDOM|ForIF !ManakaiDOM|ForClass
    @@resourceFor: ManakaiDOM|ForIF
    @@resourceFor:
      @@@@: ManakaiDOM|ForClass
      @@@ForCheck: ManakaiDOM|ManakaiDOM !=ManakaiDOM|ManakaiDOM
    @@For: ManakaiDOM|DOM3
    @@For: =ManakaiDOM|ManakaiDOM

    @@rdf:type:
      @@@@: ManakaiDOM|IF
      @@@ForCheck: ManakaiDOM|ForIF

    @@rdf:type:
      @@@@: ManakaiDOM|Class
      @@@ForCheck: ManakaiDOM|ForClass
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOM||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOM3||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM3
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOMLatest||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOMLatest

    @@DOMMain:implementFeature:
      @@@@: CoreFeature30
      @@@For: ManakaiDOM|DOM3
    @@DOMMain:implementFeature:
      @@@@: DOMXML|XMLFeature30
      @@@For: ManakaiDOM|DOM3 ManakaiDOM|DOMXMLFeature
    @@DOMMain:implementFeature:
      @@@@: DOMXML|XMLVersionFeature10
      @@@For: ManakaiDOM|DOM3 ManakaiDOM|DOMXMLFeature
    @@DOMMain:implementFeature:
      @@@@: DOMXML|XMLVersionFeature11
      @@@For: ManakaiDOM|DOM3 ManakaiDOM|DOMXMLFeatureXML11

ElementTypeBinding:
  @Name: IFQName
  @ElementType:
    dis:QName
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForIF

ElementTypeBinding:
  @Name: ClsQName
  @ElementType:
    dis:QName
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass

IFCls3Def:
  @IFQName: DOMImplementationList
  @ClsQName: ManakaiDOMImplementationList

  @ClsISA: DOMFeature|ManakaiImplementationList
  @ClsISA: ManakaiDOM|ManakaiDOMObject

  @enDesc:
    The <IF::DOMImplementationList> interface provides the 
    abstraction of an ordered collection of DOM implementations.

    {NOTE:: How this collection is implemented is not defined nor
            constrained.
    }
    
    <EM::Identification of items>.  The items in the collection are
    accessible via an integral index, starting from <DOM::0>.
  @enDesc:
    @@ForCheck: ManakaiDOM|ManakaiDOM
    @@@:
      In the manakai implelemntation, the collection is implemented
      by Perl array reference; the array is <EM::not> <QUOTE::live>.

  @Attr:
    @@Name: length
    @@Type: DOMMain|unsigned-long||ManakaiDOM|all
    @@enDesc:
      The number of items in the collection.
    @@Get:
    @@ForCheck: !ManakaiDOM|ForClass

  @Method:
    @@Name: item
    @@enDesc:
      Returns the <P::index>th item in the collection.
    @@Type: DOMImplementation
    @@Param:
      @@@Name:index
      @@@Type:DOMMain|unsigned-long||ManakaiDOM|all
      @@@enDesc: Index in the collection.
    @@ForCheck: !ManakaiDOM|ForClass
    @@Return:
      @@@enDesc:
        The <IF::DOMImplementation> object at the <P::index>th
        position in the collection.
      @@@nullCase:
        @@@@enDesc:
          If the <P::index> is greater than or equal to
          the number of items in the collection.

  @Method:
    @@Operator:
      @@@@: DISPerl|NewMethod
      @@@ContentType: dis|TypeQName
    @@enDesc:
      Creates a new instance of the <Class::ManakaiDOMImplementationList>
      object and returns it.
    @@Type: ManakaiDOMImplementationList
    @@ManakaiDOM:isStatic:1
    @@ManakaiDOM:isForInternal:1
    @@Return:
      @@@enDesc: The newly created list.
      @@@PerlDef:
        __DEEP{
          $r = bless $self->SUPER::new,
                     <ClassName::ManakaiDOMImplementationList>;
        }__;
##DOMImplementationList

IFCls3Def:
  @IFQName: DOMImplementationSource
  @ClsQName: ManakaiDOMImplementationSource

  @ClsISA: DOMFeature|ManakaiImplementationSource
  @ClsISA: ManakaiDOM|ManakaiDOMObject

  @enDesc:
    The <IF::DOMImplementationSource> interface permits a DOM
    implementator to supply one or more DOM implementations,
    based upon requested features and versions.

    Each implemented <IF::DOMImplementationSource> object
    is listed in the binding-specific list of available sources
    so that its <IF::DOMImplementation> objects are made available
    from the <Class::DOMMain:DOMImplementationRegistry> object.

  @Method:
    @@Name: getDOMImplementation
    @@ForCheck: !ManakaiDOM|ForClass
    @@enDesc:
      Returns the first DOM implementation that supports the specified
      features.
    @@Param:
      @@@Name: features
      @@@Type: DOMMain|DOMString
      @@@actualType: DOMFeature|FeaturesString
      @@@enDesc:
        A space-separeted list in which features and versions
        are specified.
    @@Return:
      @@@Type: DOMImplementation
      @@@enDesc:
        The first DOM implementation that supports the desired
        features.  It is the first item of the list returned
        by the <M::DOMImplementationSource.getDOMImplementationList> method.
      @@@nullCase:
        @@@@enDesc:
          The source has no DOM implementation that supports the 
          desired features.

  @Method:
    @@Name: getDOMImplementationList
    @@enDesc:
      Returns a list of DOM implementations that supports the 
      specified features and versions.
    @@Param:
      @@@Name: features
      @@@Type: DOMMain|DOMString
      @@@actualType: DOMFeature|FeaturesString
      @@@enDesc:
        A space-separeted list in which features and versions
        are specified.
    @@Return:
      @@@Type: DOMImplementationList
      @@@actualType: ManakaiDOMImplementationList
      @@@enDesc:
        A list of DOM implementations that support the desired features.
      @@@PerlDef:     
        __DEEP{      ## NOTE: Method name is directly written.
          $r = bless $self->SUPER::get_dom_implementation_list ($features),
                     <ClassName::ManakaiDOMImplementationList>;
        }__;
##DOMImplementationSource

ElementTypeBinding:
  @Name: IFISA
  @ElementType:
    dis:ISA
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForIF

ElementTypeBinding:
  @Name: ClsISA
  @ElementType:
    dis:ISA
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass

IFCls3Def:
  @IFQName: DOMStringList
  @ClsQName: ManakaiDOMStringList

  @ClsISA: ManakaiDOM|ManakaiDOMObject

  @enDesc:
    Objects implementing the <IF::DOMStringList> interface are
    used to represent ordered collection of <TYPE::DOMMain|DOMString>
    values.

    {NOTE:: How this collection is implemented is neither defined nor
            constrained.
    }

    The items in the <IF::DOMStringList> are accessible via an
    ordinal index, starting from <CODE::0>.

  @enDesc:
    @@For: ManakaiDOM|ManakaiDOM
    @@@:
      In the manakai implementation, <IF::DOMStringList> can be 
      dereferenced as if it is an array reference.

  @Method:
     @@Name:  item
     @@Spec:
       @@@DOM3:
         http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#DOMStringList-item
     @@Description:
       @@@lang:en
       @@@@: 
         Returns a <TYPE::DOMMain:DOMString> object in this collection.
     @@Param:
        @@@Name:  index
        @@@Type:  
          DOMMain:unsigned-long||ManakaiDOM|all
        @@@Description:
          @@@@lang:en
          @@@@@: 
            The index of the object to retrieve in this collection.
     @@Return:
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            The <TYPE::DOMMain:DOMString> object at the <P::index>th 
            position in this collection.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Either the specified <P::index> is negative or greater 
              than or equal to the number of <TYPE::DOMMain:DOMString> 
              objects in this collection.
        @@@PerlDef:
          if (not defined $index or
              $index < 0 or
              $index > $#$self) {
            $r = null;
          } else {
            $r = $self->[$index];
          }
          
  @Attr:
     @@Name:  length
     @@Spec:
       @@@DOM3:
         http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#DOMStringList-length
     @@Description:
       @@@lang:en
       @@@@: 
         The number of <TYPE::DOMMain:DOMString> object in this collection.
     @@Get:
        @@@Type:  
          DOMMain:unsigned-long||ManakaiDOM|all
        @@@Description:
          @@@@lang:en
          @@@@@: 
            The number of strings in this collection.
        @@@PerlDef:
          $r = @$self;
  @Method:
     @@Name:  contains
     @@Spec:
       @@@DOM3: 
         http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#DOMStringList-contains
     @@Description:
       @@@lang:en
       @@@@: 
         Tests whether a string is an item of this collection or not.
     @@Param:
        @@@Name:  str
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: 
            A string to look for.
     @@Return:
        @@@Type:  
          DOMMain:boolean::ManakaiDOM:all
        @@@Description:
          @@@@lang:en
          @@@@@: 
            Whether the <P::str> is part of this collection or not.
        @@@TrueCase:
          @@@@Description:
            @@@@@lang:en
            @@@@@@: 
              The <P::str> has been found in this collection.
        @@@FalseCase:
          @@@@Description:
            @@@@@lang:en
            @@@@@@:  
              The <P::str> has not been found in this collection.
        @@@PerlDef:
          CHK: {
            __DEEP{
              for (@$self) {
                if ($str eq $_) {
                  $r = true;
                  last CHK;
                }
              }
            }__;
          }
##DOMStringList

IFCls3Def:
  @IFQName: NameList
  @ClsQName: ManakaiDOMNameList

  @ClsISA: ManakaiDOM|ManakaiDOMObject

  @enDesc:
    Objects implementing <IF::NameList> interface are used to
    represent ordered collections of parallel pairs of name
    and namespace values (which could be <DOM::null> values).

    {NOTE:: How this collection is implemented is neither defined
            nor constrained. 
    }

    The items in the <IF::NameList> are accessible via an
    ordinal index, starting from <CODE::0>.

  @enDesc:
    @@For: ManakaiDOM|ManakaiDOM
    @@@:
      In the manakai implementation, <IF::NameList> can be
      dereferenced as if it is an array reference, in which each item
      is a reference to array whose item <Perl::0> is the namespace
      URI and whose item <Perl::1> is the name.

  @Method:
     @@Name:  getName
     @@Spec:
       @@@DOM3:
         http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#NameList-getName
     @@Description:
        @@@lang:en
        @@@@: 
          Returns a name item in this collection.
     @@Param:
        @@@Name:  index
        @@@Type:  
          DOMMain:unsigned-long||ManakaiDOM|all
        @@@Description:
          @@@@lang:en
          @@@@@: 
            An index of item to retrieve in this collection.
     @@Return:
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            The name value at the <P::index>th position in this collection.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Either there is no name for the specified <P::index> or 
              the <P::index> is out of range.
        @@@PerlDef:
          if (not defined $index or
              $index < 0 or
              $index > $#$self) {
            $r = null;
          } else {
            $r = $self->[$index]->[1];
          }          
  @Method:
     @@Name:  getNamespaceURI
     @@Spec:
       @@@DOM3:
         http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#NameList-getNamespaceURI
     @@Description:
       @@@lang:en
       @@@@:
         Returns a namespace URI item in this collection.
     @@Param:
        @@@Name:  index
        @@@Type:  
          DOMMain:unsigned-long||ManakaiDOM|all
        @@@Description:
          @@@@lang:en
          @@@@@: 
            An index of item to retrieve in this collection.
     @@Return:
        @@@Type:
          DOMMain:DOMString
        @@@dis:actualType:
          ManakaiDOM:ManakaiDOMNamespaceURI
        @@@Description:
          @@@@lang:en
          @@@@@:
            The namespace URI at the <P::index>th position in this collection.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Either there is no namespace URI for the specified <P::index> 
              or the <P::index> is out of range.
        @@@PerlDef:
          if (not defined $index or
              $index < 0 or
              $index > $#$self) {
            $r = null;
          } else {
            $r = $self->[$index]->[0];
          }          
  @Attr:
     @@Name:  length
     @@Spec:
       @@@DOM3:
         http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#NameList-length
     @@Description:
       @@@lang:en
       @@@@:
         The number of pairs in this collection.
     @@Get:
        @@@Type:  
          DOMMain:unsigned-long||ManakaiDOM|all
        @@@Description:
          @@@@lang:en
          @@@@@: 
            The number of name and namespace URI pairs.
        @@@PerlDef:
          $r = @$self;
  @Method:
     @@Name:  contains
     @@Spec:
       @@@DOM3:
         http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#NameList-contains
     @@Description:
       @@@lang:en
       @@@@: 
         Tests whether a name is one of items in this collection.
     @@ImplNote:
       @@@lang:en
       @@@@:
         Is namespace URIs ignored in this matching?
     @@Param:
        @@@Name:  str
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: 
            A name to look for.
     @@Return:
        @@@Type:  
          DOMMain:boolean||ManakaiDOM|all
        @@@TrueCase:
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The name <P::str> has been found in this collection.
        @@@FalseCase:
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The name <P::str> has not been found in this collection.
        @@@PerlDef:
          CHK: {
            if (defined $str) {
              for my $item (@$self) {
                if (defined $item->[1] and $str eq $item->[1]) {
                  $r = true;
                  last CHK;
                }
              }
            } else { # not defined $str
              for my $item (@$self) {
                if (not defined $item->[1]) {
                  $r = true;
                  last CHK;
                }
              }
            } # $str defined?
          } # CHK
    @@NSVersion: .containsNS
  @Method:
     @@Name:  containsNS
     @@Spec:
       @@@DOM3:
         http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#NameList-containsNS
     @@NoNSVersion: .contains
     @@Description:
       @@@lang:en
       @@@@: 
         Tests if a pair of namespace URI and name is part of this collection.
     @@Param:
        @@@Name:  namespaceURI
        @@@Type:
          DOMMain:DOMString
        @@@dis:actualType:
          ManakaiDOM:ManakaiDOMNamespaceURI
        @@@Description:
          @@@@lang:en
          @@@@@: 
            A namespace URI to look for.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The namespace of name to look for is <DOM::null>.
          @@@@For:
            ManakaiDOM:ManakaiDOM
     @@Param:
        @@@Name:  name
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: 
            A name to look for.
     @@Return:
        @@@Type:  
          DOMMain:boolean||ManakaiDOM|all
        @@@TrueCase:
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The pair has been found in this collection.
        @@@FalseCase:
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The pair has not been found in this collection.
        @@@PerlDef:
          CHKLN: {
            CHKNS: {
              if (defined $namespaceURI) {
                for my $item (@$self) {
                  if (defined $item->[0] and $namespaceURI eq $item->[0]) {
                    last CHKNS;
                  }
                }
              } else { # not defined namespaceURI
                for my $item (@$self) {
                  if (not defined $item->[0]) {
                    last CHKNS;
                  }
                }
              } # namespaceURI defined?

              ## namespaceURI does not match
              last CHKLN;
            } # CHKNS

            if (defined $name) {
              for my $item (@$self) {
                if (defined $item->[1] and $name eq $item->[1]) {
                  $r = true;
                  last CHKLN;
                }
              }
            } else { # not defined namespaceURI
              for my $item (@$self) {
                if (not defined $item->[1]) {
                  $r = true;
                  last CHKLN;
                }
              }
            } # name defined?
          } # CHKLN
##NameList

IFCls1Def:
  @IFQName: DOMImplementation
  @ClsQName: ManakaiDOMImplementation

  @enDesc:
    The <IF::DOMImplementation> interface provides a number
    of methods for performing operations that are independent
    of any particular instance of the document object model.

  @ClsISA:
    @@@: DOMFeature|ManakaiMinimumImplementation
    @@For: ManakaiDOM|DOM3
  @ClsISA:
    @@@: DOMFeature|ManakaiMinimumImplementation||ManakaiDOM|ManakaiDOMLatest
    @@For: !ManakaiDOM|DOM3

  @ClsISA: ManakaiDOM|ManakaiDOMObject

  @DISLang:role:
    @@@:
      DOMMetaImpl:ManakaiDOMImplementationRole

  @DOMMetaImpl:provideFeature:
    @@@: CoreFeature10
    @@ForCheck:
      ManakaiDOM:DOM1
  @DOMMetaImpl:provideFeature:
    @@@: CoreFeature20
    @@ForCheck:
      ManakaiDOM:DOM2
  @DOMMetaImpl:provideFeature:
    @@@: CoreFeature30
    @@ForCheck:
      ManakaiDOM:DOM3
  @DOMMetaImpl:provideFeature:
    @@@: DOMXML|XMLFeature10
    @@ForCheck:
      ManakaiDOM:DOM1 ManakaiDOM|DOMXMLFeature
  @DOMMetaImpl:provideFeature:
    @@@: DOMXML|XMLFeature20
    @@ForCheck:
      ManakaiDOM:DOM2 ManakaiDOM|DOMXMLFeature
  @DOMMetaImpl:provideFeature:
    @@@: DOMXML|XMLFeature30
    @@ForCheck:
      ManakaiDOM:DOM3 ManakaiDOM|DOMXMLFeature
  @DOMMetaImpl:provideFeature:
    @@@: DOMXML|XMLVersionFeature10
    @@ForCheck:
      ManakaiDOM:DOM3 ManakaiDOM|DOMXMLFeature
  @DOMMetaImpl:provideFeature:
    @@@: DOMXML|XMLVersionFeature11
    @@ForCheck:
      ManakaiDOM:DOM3 ManakaiDOM|DOMXMLFeatureXML11

  @Method:
    @@ForCheck: !ManakaiDOM|ForClass
     @@Name:  hasFeature
     @@Description:
       @@@lang:en
       @@@@:
         Tests whether this DOM implementation supports a specific 
         feature and version or not.
     @@L1:
     @@Param:
        @@@Name:  feature
        @@@Type:
          DOMMain:DOMString
        @@@actualType: DOMFeature|FeatureNameString
        @@@Description:
          @@@@lang:en
          @@@@@: 
            A name of feature to test, with an optional <CHAR::PLUS SIGN>
            prefix.
        
        @@@ImplNote:
          @@@@lang:en
          @@@@@: Move to DOMMain
        @@@InCase:
          @@@@Value: HTML
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The DOM HTML feature.
              This is one of the allowed values in DOM Level 1 First Edition.
        @@@InCase:
          @@@@Value: XML
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The DOM XML feature.
              This is one of the allowed values in DOM Level 1 First Edition.
        @@@InCase:
          @@@@Label:
            @@@@@@:
              XML 1.0 <CODE::Name>
            @@@@@lang:en
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Only an XML 1.0 Name is allowed in DOM Level 1 Second Edition 
              and DOM Level 2.
        @@@InCase:
          @@@@Label:
            @@@@@@: Reversed Internet domain name
            @@@@@lang:en
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              DOM Level 1 First Edition and DOM Level 2 specifications 
              says that the feature name defined outside the DOM specifications 
              should use the reversed Internet domain name to avoid 
              possible confliction.
            \
              This recommendation is withdrawn by the Errata of the DOM Level 2 
              Specifications.
        @@@InCase:
          @@@@Label:
            @@@@@lang:en
            @@@@@@:
              Feature name preceeded by a <CODE::PLUS SIGN>
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The specified feature may not be directly castable
              but would be available through the method "getFeature".
     @@Param:
        @@@Name:  version
        @@@Type:
          DOMMain:DOMString
        @@@actualType:
          ManakaiDOM:ManakaiDOMFeatureVersion
        @@@Description:
          @@@@lang:en
          @@@@@:
            Version number of feature to test.

        @@@ImplNote:
          @@@@lang:en
          @@@@@: Move to DOMMain
        @@@InCase:
          @@@@Value: 1.0
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              DOM Level 1.
              This is the only allowed value in DOM Level 1 and
              one of allowed values in DOM Level 2.
        @@@InCase:
          @@@@Value: 2.0
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              DOM Level 2.
              This is one of allowed values in DOM Level 2.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              No particular version is specified.
              \
              It is implied that this value is allowed in DOM 
              Level 1 and Level 2.  DOM Level 2 Errata and DOM 
              Level 3 explicitly allow this value specified.
        @@@InCase:
          @@@@Value: \
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              No particular version is specified.
              \
              This value is allowed in DOM Level 2 Errata and 
              DOM Level 3.
     @@Return:
        @@@Type:  
          DOMMain:boolean||ManakaiDOM|all
        @@@Description:
          @@@@lang:en
          @@@@@: 
            Whether the feature and version is implemented or not.
        @@@TrueCase:
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The feature is implemented in the specified version.
        @@@FalseCase:
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The feature is not implemented.

  @Method:
     @@Name:  createDocumentType
     @@Description:
       @@@lang:en
       @@@@:
         Creates and returns an empty <IF::DOMXML:DocumentType> node.
     @@DOMMain:isNamespaceAware:1
     @@XML2Feature:
     @@Param:
        @@@Name:  qualifiedName
        @@@Type:  
          DOMMain:DOMString
        @@@actualType:
          @@@@@:
            DOMMain:ManakaiDOMXML11QName
          @@@@For: ManakaiDOM|ManakaiDOMLatest
        @@@actualType:
          @@@@@: DOMMain|ManakaiDOMXML10QName
          @@@@For: !ManakaiDOM|ManakaiDOMLatest
        @@@Description:
          @@@@lang:en
          @@@@@: The qualified name of the document type to be created.
        @@@Description:
          @@@@lang:en
          @@@@@:
            {NOTE:: DOM levels 2 and 3 requires DOM implementations to 
                    test whether a <P::qualifiedName> is a valid XML 1.0
                    Name or not.  The manakai DOM implementation
                    for the <QUOTE::latest> level tests against both XML 1.0 
                    and XML 1.1; if it is invalid against XML 1.1, an exception 
                    is thrown; otherwise, the node created is marked as 
                    an XML 1.1 document type node.
             \
            }
          @@@@For:
            ManakaiDOM:ManakaiDOMLatest
     @@Param:
        @@@Name:  publicId
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The external subset public identifier.
     @@Param:
        @@@Name:  systemId
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The external subset system identifier.
     @@SpecLevel: 2
     @@L2:
     @@For:
       ManakaiDOM:DOM2
     @@Return:
        @@@Type:  
          DOMXML:DocumentType
        @@@actualType:
          DOMXML:ManakaiDOMDocumentType
        @@@Description:
          @@@@lang:en
          @@@@@:
            A newly created <IF::DOMXML:DocumentType> node.
        @@@ImplNote:
          @@@@lang:en
          @@@@@:
            The <A::Node.ownerDocument> attribute is set to <DOM::null>.
        @@@raises:
          @@@@@: DOMException.INVALID_CHARACTER_ERR
          @@@@enDesc:
            @@@@@@:
              The <P::qualifiedName> is not an XML 1.0 <CODE::Name>.
            @@@@@For:
              !ManakaiDOM:ManakaiDOMLatest
          @@@@enDesc:
            @@@@@@:
              The <P::qualifiedName> is not an XML 1.1 <CODE::Name>.
            @@@@@For:
              ManakaiDOM:ManakaiDOMLatest
        @@@raises:
          @@@@@: MDOMX|MDOM_NS_MALFORMED_QNAME
          @@@@enDesc:
            The <P::qualifiedName> is malformed.
        @@@raises:
          @@@@@:
            MDOMX:MDOM_IMPL_NOSUPPORT_XMLNS
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The DOM implementation does not support the <DOM::XML> feature and 
              the language exposed through the <IF::Document> does not support 
              XML Namespaces.
        @@@PerlDef:
          @@@@ForCheck:
            ManakaiDOM:DOMXMLFeature
          @@@@@:
            my ($prefix, $lname) = split /:/, $qualifiedName, 2;
            if (not defined $lname) {
              ($prefix, $lname) = (null, $prefix);
            }
            my $node = <ClassM::DOMXML:ManakaiDOMDocumentType.newObject>;
            $node->{<Q::infoset:prefix>} = $prefix;
            $node->{<Q::infoset:localName>} = $lname;
            __FOR{ManakaiDOM:ManakaiDOMLatest::
              unless (<Code::DOMMain:testXML10QName:: $INPUT = $qualifiedName>) {
                $node->{<Q::infoset:version>} = '1.1';
              }
            }__;
            $node->{<Q::infoset:publicIdentifier>} = $publicId;
            $node->{<Q::infoset:systemIdentifier>} = $systemId; 
            ## Note: No DOM Level 3 method/attribute provides access 
            ##       to the DOM implementation object when the "DocumentType" 
            ##       does not have the parent node (= owner "Document").
            $node->{<Q::DOMCore:implementation>} = $self;
            $node->{<Q::ManakaiDOM:implID>}
                        = $self->{<Q::TreeCore:node>}->{<Q::ManakaiDOM:implID>};
            $r = <ClassM::ManakaiDOMNode.getNodeReference> ($node);
        @@@disDef:
          @@@@ForCheck:
            !ManakaiDOM:DOMXMLFeature
          @@@@DOMMain:raiseException:
            MDOMX:MDOM_IMPL_NOSUPPORT_XMLNS

  @Method:
     @@Name:  createDocument
     @@Description:
       @@@lang:en
       @@@@:
         Creates a new <IF::Document> object, with a document element.
     @@Description:
       @@@lang:en
       @@@@:
         {NOTE:: Either if the <P::doctype> is an XML 1.1 node 
                 or if the <P::qualifiedName> is a valid XML Namespace 1.1 
                 QName but is not a valid XML Namespace 1.0 QName,
                 then the XML version of the document to be created 
                 is <XML::1.1>; otherwise, it is <XML::1.0>.
          \
          }
       @@@For:
         ManakaiDOM:ManakaiDOMLatest
     @@Description:
       @@@lang:en
       @@@@:
         The manakai <M::DOMImplementation.createDocument> method always 
         creates an XML <IF::Document>, i.e. a <IF::Document> that supports 
         the <Feature::XML> feature. 
       @@@For:
         ManakaiDOM:ManakaiDOM
     @@XML2Feature:
     @@ImplNote:
       @@@lang:en
       @@@@:
         In DOM Level 1, there is no standardized way to create 
         a <IF::Document> object. 
     @@DOMMain:isNamespaceAware:1
     @@Param:
        @@@Name:  namespaceURI
        @@@Type:
          DOMMain:DOMString
        @@@actualType:
          ManakaiDOM:ManakaiDOMNamespaceURI
        @@@Description:
          @@@@lang:en
          @@@@@: 
            The namespace URI of the document element to create.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: 
              The document element to create has no namespace.
     @@Param:
        @@@Name:  qualifiedName
        @@@Type:  
          DOMMain:DOMString
        @@@actualType:
          @@@@@:
            DOMMain:ManakaiDOMXML11QName
          @@@@ForCheck:
            ManakaiDOM:ManakaiDOMLatest
          @@@@ManakaiDOM:noInputNormalize:1
        @@@actualType:
          @@@@@:
            DOMMain:ManakaiDOMXML10QName
          @@@@ForCheck:
            ManakaiDOM:ManakaiDOMLatest
          @@@@ManakaiDOM:noInputNormalize:1
        @@@Description:
          @@@@lang:en
          @@@@@: The qualified name of the document element to create.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: Document element is not created.
     @@Param:
        @@@Name:  doctype
        @@@Type:  
          DOMXML:DocumentType
        @@@actualType:
          DOMXML:ManakaiDOMDocumentType
        @@@Description:
          @@@@lang:en
          @@@@@:
            The document type of the document to create.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The document to create does not have any <IF::DOMXML:DocumentType> 
              node. 
        @@@ImplNote:
          @@@@lang:en
          @@@@@:
            The <A::Node.ownerDocument> of the <P::doctype> is set to 
            the document being created. 
     @@Return:
        @@@Type:  Document
        @@@actualType: ManakaiDOMDocument
        @@@Description:
          @@@@lang:en
          @@@@@:
            A newly created <IF::Document> object. 
            \
            {NOTE:: The object returned by this method may be a 
                    specialized <IF::Document> object based on the 
                    <P::doctype> given.  For example, a <IF::Document> 
                    object might also implement the <IF::DOMHTML:HTMLDocument> 
                    interface. 
            \
            }
        @@@raises:
          @@@@@: DOMException.INVALID_CHARACTER_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The specified qualified name is not an XML 1.0 <CODE::Name>.
            @@@@@For:
              !ManakaiDOM:ManakaiDOMLatest
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The specified qualified name is not an XML 1.1 <CODE::Name>.
            @@@@@For:
              ManakaiDOM:ManakaiDOMLatest
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              The <CITE::DOM Level 2 Core> specification does not
              explicitly defines the version of the XML for 
              <CODE::Name>s, but the definition for
              <X::DOMException.INVALID_CHARACTER_ERR> references
              the <CITE::XML 1.0> specification.

              The <CITE::DOM Level 3 Core> specification references
              the <CITE::XML 1.0> specification for the <CODE::Name>
              definition.
        @@@raises:
          @@@@@: DOMException.NAMESPACE_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Either the "qualifiedName" is malformed, the "qualifiedName" 
              has a prefix and the "namespaceURI" is "null", the 
              "qualifiedName" is "null" and the "namespaceURI" is 
              different from "null", the "qualifiedName" has 
              a prefix that is "xml" and the "namespaceURI" is 
              different from "http://www.w3.org/XML/1998/namespace" or
              the DOM implementation does not support the "XML" feature 
              but a non-null "namespaceURI" is provided.
         @@@ImplNote:
           @@@@lang:en
           @@@@@:
              In addition, it is possible to raise an exception 
              either if the "qualifiedName" has a prefix that is 
              "xmlns" and the "namespaceURI" is different from 
              "http://www.w3.org/2000/xmlns/", if the "namespaceURI" 
              is "http://www.w3.org/XML/1998/namespace" and the 
              "qualifiedName" has a prefix is different from "xml" or 
              if the "namespaceURI" is "http://www.w3.org/2000/xmlns/" 
              and the "qualifiedName" has a prefix is different from "xmlns".
              But this DOM implementation only report a warning on 
              these cases since the specification does not mention 
              to raise any exception.
        @@@raises:
          @@@@@: MDOMX_DOCTYPE_ALREADY_USED
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The <P::doctype> has already been used with a different 
              document.
        @@@raises:
          @@@@@: MDOMX_EXTERNAL_NODE
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The <P::doctype> was created from a different DOM implementation.
        @@@raises:
          @@@@@:
            MDOMX:MDOM_IMPL_NOSUPPORT_XMLNS
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The DOM implementation does not support the <DOM::XML> feature and 
              the language exposed through the <IF::Document> does not support 
              XML Namespaces.
            @@@@@ImplNote:
              @@@@@@lang:en
              @@@@@@@:
                DOM Level 2 Core described that this method creates 
                a <QUOTE::XML <IF::Document> object> and that 
                HTML-only implementations need not implement it. 
                DOM Level 2 Errata and DOM Level 3 Core describes that 
                such implementations should return a 
                <X::DOMException.NOT_SUPPORTED_ERR>.  In addition, 
                DOM Level 3 Core specifies this method to create 
                a <QUOTE::DOM <IF::Document> object>. Note also that 
                DOM Level 3 Core explicitly allows non-<Feature::XML> 
                document node to be created.
        @@@PerlDef:
          @@@@For:
            ManakaiDOM:DOMXMLFeature
          @@@@@:
            my ($prefix, $lname);
            if (defined $qualifiedName) {
              __ManakaiDOM:InputNormalize{qualifiedName}__;
              ($prefix, $lname) = split /:/, $qualifiedName, 2;
              unless (defined $lname) {
                ($prefix, $lname) = (null, $prefix);
              }
              __CODE{DOMMain:checkXMLNamesQName::
                $NSURI => $namespaceURI,
                $PREFIX => $prefix,
                $LNAME => $lname,
              }__;
              if ($lname eq 'xmlns') {
                if (not defined $prefix) {
                  __EXCEPTION{MDOMX:MDOM_NS_QNAME_IS_XMLNS::
                  }__;
                } elsif ($prefix eq 'xmlns') {
                  __EXCEPTION{MDOMX:MDOM_NS_XMLNS_XMLNS::
                  }__;
                }
              }
            } elsif (defined $namespaceURI) {
              __EXCEPTION{MDOMX:MDOM_NS_NULL_QNAME_WITH_NON_NULL_URI::
                MDOMX:param-name => 'qualifiedName',
                infoset:namespaceName => {$namespaceURI},
              }__;
            }

            my $node = <ClassM::ManakaiDOMDocument.newObject>;
            $node->{<Q::DOMCore:implementation>} = $self;
            $node->{<Q::ManakaiDOM:implID>}
                = $self->{<Q::TreeCore:node>}->{<Q::ManakaiDOM:implID>};
            $node->{<Q::DOMCore:hasFeature>}->{XML} = 1;
            $node->{<Q::DOMCore:hasFeature>}->{HTML} = 1
              if (defined $namespaceURI and $namespaceURI eq <Q::xhtml1:>) or
                 (defined $qualifiedName and $qualifiedName eq 'html');
            if ($doctype) {
              if (not UNIVERSAL::isa
                        ($doctype, <ClassName::DOMXML:ManakaiDOMDocumentType>)) {
                __EXCEPTION{MDOMX_EXTERNAL_NODE::
                  MDOMX:param-name => 'doctype',
                }__;
              }
              my $doctypeNode = $doctype->{<Q::TreeCore:node>};
              if ($node->{<Q::TreeCore:treeID>} ne
                  $doctypeNode->{<Q::TreeCore:treeID>} or
                  $doctypeNode->{<Q::DOMCore:ownerDocument>} or
                  $doctypeNode->{<Q::ManakaiDOM:implID>} ne 
                    $node->{<Q::ManakaiDOM:implID>}) {
                __EXCEPTION{MDOMX_DOCTYPE_ALREADY_USED::
                  MDOMX:param-name => 'doctype',
                }__;
              }
              $doctypeNode-><M::NodeStem.importTree> ($node);
              $doctypeNode->{<Q::DOMCore:ownerDocument>} = $node;
              $doctypeNode->{<Q::infoset:parent>} = $node;
              push @{$node->{<Q::infoset:children>}}, $doctypeNode;
              __FOR{ManakaiDOM:ManakaiDOMLatest::
                $node->{<Q::infoset:version>}
                    = $doctypeNode->{<Q::infoset:version>};
              }__;
            }
            if ($lname) {
              __FOR{ManakaiDOM:ManakaiDOMLatest::
                if (not defined $node->{<Q::infoset:version>} and
                    not <Code::DOMMain:testXML10Name:: $INPUT = $lname>) {
                  $node->{<Q::infoset:version>} = '1.1';
                }
              }__;
              my $docElObj = <ClassM::ManakaiDOMElement.newObject>;
              $node-><M::NodeStem.importTree> ($docElObj);
              $docElObj->{<Q::infoset:prefix>} = $prefix;
              $docElObj->{<Q::infoset:namespaceName>} = $namespaceURI;
              $docElObj->{<Q::infoset:localName>} = $lname;
              $docElObj->{<Q::infoset:parent>} = $node;
              $docElObj->{<Q::DOMCore:ownerDocument>} = $node;
              push @{$node->{<Q::infoset:children>}}, $docElObj;
            }
            $r = <ClassM::ManakaiDOMNode.getNodeReference> ($node);
        @@@PerlDef:
          @@@@ForCheck:
            ManakaiDOM:DOMHTMLFeature !ManakaiDOM:DOMXMLFeature 
            ManakaiDOM:DOM3
          @@@@@:
            my ($prefix, $lname);
            \## ISSUE: Should be checked against HTML namechar?
            if (defined $namespaceURI) {
              __EXCEPTION{DOMCore:MDOMX_HTML_NSURI::
                MDOMX:param-name => 'namespaceURI',
                infoset:namespaceName => {$namespaceURI},
              }__;
            }
            if (defined $qualifiedName) {
              __ManakaiDOM:InputNormalize{qualifiedName}__;
              ($prefix, $lname) = split /:/, $qualifiedName, 2;
              unless (defined $lname) {
                ($prefix, $lname) = (null, $prefix);
              }
              __CODE{DOMMain:checkXMLNamesQName::
                $NSURI => $namespaceURI,
                $PREFIX => $prefix,
                $LNAME => $lname,
              }__;
              if ($lname eq 'xmlns') {
                if (not defined $prefix) {
                  __EXCEPTION{MDOMX:MDOM_NS_QNAME_IS_XMLNS::
                  }__;
                } elsif ($prefix eq 'xmlns') {
                  __EXCEPTION{MDOMX:MDOM_NS_XMLNS_XMLNS::
                  }__;
                }
              }
            } # $qualifiedName

            my $node = <ClassM::ManakaiDOMDocument.newObject>;
            $node->{<Q::DOMCore:implementation>} = $self;
            $node->{<Q::ManakaiDOM:implID>}
                = $self->{<Q::TreeCore:node>}->{<Q::ManakaiDOM:implID>};
            $node->{<Q::DOMCore:hasFeature>}->{HTML} = 1;
            if ($doctype) {
              if (not UNIVERSAL::isa
                        ($doctype, <ClassName::DOMXML:ManakaiDOMDocumentType>)) {
                __EXCEPTION{MDOMX_EXTERNAL_NODE::
                  MDOMX:param-name => 'doctype',
                }__;
              }
              my $doctypeNode = $doctype->{<Q::TreeCore:node>};
              if ($node->{<Q::TreeCore:treeID>} ne
                  $doctypeNode->{<Q::TreeCore:treeID>} or
                  $doctypeNode->{<Q::DOMCore:ownerDocument>} or
                  $doctypeNode->{<Q::ManakaiDOM:implID>} ne 
                    $node->{<Q::ManakaiDOM:implID>}) {
                __EXCEPTION{MDOMX_DOCTYPE_ALREADY_USED::
                  MDOMX:param-name => 'doctype',
                }__;
              }
              $doctypeNode-><M::NodeStem.importTree> ($node);
              $doctypeNode->{<Q::DOMCore:ownerDocument>} = $node;
              $doctypeNode->{<Q::infoset:parent>} = $node;
              push @{$node->{<Q::infoset:children>}}, $doctypeNode;
              __FOR{ManakaiDOM:ManakaiDOMLatest::
                if (defined $doctypeNode->{<Q::infoset:version>}) {
                  __EXCEPTION{MDOMX:MDOM_IMPL_NOSUPPORT_XML::
                    MDOMX:param-name => 'doctype',
                    infoset:version => {$doctypeNode->{<Q::infoset:version>}},
                  }__;
                }
              }__;
            }
            if ($lname) {
              my $docElObj = <ClassM::ManakaiDOMElement.newObject>;
              $node-><M::NodeStem.importTree> ($docElObj);
              $docElObj->{<Q::infoset:prefix>} = $prefix;
              $docElObj->{<Q::infoset:namespaceName>} = $namespaceURI;
              $docElObj->{<Q::infoset:localName>} = $lname;
              $docElObj->{<Q::infoset:parent>} = $node;
              $docElObj->{<Q::DOMCore:ownerDocument>} = $node;
              push @{$node->{<Q::infoset:children>}}, $docElObj;
            }
            $r = <ClassM::ManakaiDOMNode.getNodeReference> ($node);
        @@@disDef:
          @@@@ForCheck:
            !ManakaiDOM:DOMXMLFeature
          @@@@DOMMain:raiseException:
            MDOMX:MDOM_IMPL_NOSUPPORT_XMLNS
     @@SpecLevel:2
     @@Level[list]:
       2
       3
     @@L2:
     @@For:
       ManakaiDOM:DOM2
        
  @Method:
    @@ForCheck: !ManakaiDOM|ForClass
     @@Name:  getFeature
     @@Description:
        @@@lang:en
        @@@@:
          Returns a specialized object that implements the specialized 
          interfaces of the specified feature and version.
     @@Param:
        @@@Name:  feature
        @@@Type:
          DOMMain:DOMString
        @@@actualType: FeatureNameString
        @@@Description:
          @@@@lang:en
          @@@@@:
            A feature name to request.

        ## TODO: Move to DOMMain
        @@@InCase: 
          @@@@Label: 
            @@@@@@:
              Feature name preceeded by a <CHAR::PLUS SIGN>
            @@@@@lang:en
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The <CHAR::PLUS SIGN> is ignored.
     @@Param:
        @@@Name:  version
        @@@Type:
          DOMMain:DOMString
        @@@actualType:
          ManakaiDOM:ManakaiDOMFeatureVersion
        @@@Description:
          @@@@lang:en
          @@@@@:
            A feature version number to request.
     @@SpecLevel:3
     @@Level[list]:  3
     @@L3:
     @@For:
       ManakaiDOM:DOM3
     @@Return:
        @@@Type:  
          DOMMain:DOMObject
        @@@Description:
          @@@@lang:en
          @@@@@:
            An object that implements the specialized APIs of the 
            <P::feature> and <P::version>.  It might or might not 
            implements the <IF::DOMImplementation> interface. 
        @@@Description:
          @@@@lang:en
          @@@@@:
            In addition, the object might or might not part of 
            manakai. 
          @@@@For:
            ManakaiDOM:ManakaiDOM
        @@@ImplNote:
          @@@@lang:en
          @@@@@:
            If the object implements the <IF::DOMImplementation> interface, 
            it must delegate to the primary core <IF::DOMImplementation> 
            and must not result incosistent with the primary core 
            <IF::DOMImplementation> such as <M::DOMImplementation.hasFeature>, 
            <M::DOMImplementation.getFeature>, etc.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@@: 
            There is no object available that implements interfaces 
            associated with the <P::feature> and <P::version>. 
##DOMImplementation

ResourceDef:
  @QName: NodeStem
  @AliasFor: ManakaiNode|NodeStem||ManakaiDOM|Perl
  @For: ManakaiDOM|ManakaiDOM !=ManakaiDOM|ManakaiDOM

ResourceDef:
  @QName: NodeRef
  @AliasFor: ManakaiNode|NodeRef||ManakaiDOM|Perl
  @For: ManakaiDOM|ManakaiDOM !=ManakaiDOM|ManakaiDOM

ElementTypeBinding:
  @Name: disDef
  @ElementType:
    dis:Def
  @ShadowContent:
    @@ContentType:
      lang:dis
    @@ForCheck: ManakaiDOM|ForClass

IFCls1Def:
  @IFQName: Node
  @ClsQName: ManakaiDOMNode

  @enDesc:
    The <IF::Node> interface is the primary datatype for the entire 
    document object model.  It represents a single node in the 
    document tree.

    The <IF::Node> interface is not implemented alone; the <IF::Node>
    objects are expected to implement one or more additional
    interfaces according to its node type.  For example, a node
    whose <A::Node.nodeType> equals to <C::Node.ELEMENT_NODE>
    would also implement the <IF::Element> interface.

  @IsFinal:
    @@@: -1
    @@ForCheck:
      ManakaiDOM:ForClass

  @ClsISA: ManakaiNode|ManakaiNodeRef||ManakaiDOM|Perl
  @ClsISA: ManakaiDOM|ManakaiDOMObject

  @ConstGroup:
    @@IFQName: NodeType
    @@ClsQName: ManakaiDOMNodeType
    @@PerlName: NodeType

   @@rdfs:subClassOf:
     @@@@: DOMMain|unsigned-short||ManakaiDOM|all
     @@@ForCheck: ManakaiDOM|ForClass
   @@Type: DOMMain|unsigned-short||ManakaiDOM|all

   @@enDesc:
     Constant values in this group are integers indicating of which
     type a node is.

     {NOTE:: Numeric codes up to 200 are reserved to W3C
             for possible future use <SRC::<CITE::DOM Level 3 Core>>.
     }

     @@Const:
        @@@Name:  ELEMENT_NODE
        @@@Type:  
          DOMMain:unsigned-short||ManakaiDOM|all
        @@@intValue:  1
        @@@Description:
          @@@@lang:en
          @@@@@: 
            The node is an <IF::Element>.
     @@Const:
        @@@Name:  ATTRIBUTE_NODE
        @@@intValue:  2
        @@@Description:
          @@@@lang:en
          @@@@@: 
            The node is an <IF::Attr>.
     @@Const:
        @@@Name:  TEXT_NODE
        @@@intValue:  3
        @@@Description:
          @@@@lang:en
          @@@@@: 
            The node is a <IF::Text>.
     @@Const:
        @@@Name:  CDATA_SECTION_NODE
        @@@intValue:  4
        @@@Description:
          @@@@lang:en
          @@@@@: 
            The node is a <IF::DOMXML:CDATASection>.
     @@Const:
        @@@Name:  ENTITY_REFERENCE_NODE
        @@@intValue:  5
        @@@Description:
          @@@@lang:en
          @@@@@: 
            The node is an <IF::DOMXML:EntityReference>.
     @@Const:
        @@@Name:  ENTITY_NODE
        @@@intValue:  6
        @@@Description:
          @@@@lang:en
          @@@@@: 
            The node is an <IF::DOMXML:Entity>.
     @@Const:
        @@@Name:  PROCESSING_INSTRUCTION_NODE
        @@@intValue:  7
        @@@Description:
          @@@@lang:en
          @@@@@: 
            The node is a <IF::DOMXML:ProcessingInstruction>.
     @@Const:
        @@@Name:  COMMENT_NODE
        @@@intValue:  8
        @@@Description:
          @@@@lang:en
          @@@@@: 
            The node is a <IF::Comment>.
     @@Const:
        @@@Name:  DOCUMENT_NODE
        @@@intValue:  9
        @@@Description:
          @@@@lang:en
          @@@@@: 
            The node is a <IF::Document>.
     @@Const:
        @@@Name:  DOCUMENT_TYPE_NODE
        @@@intValue:  10
        @@@Description:
          @@@@lang:en
          @@@@@: 
            The node is a <IF::DOMXML:DocumentType>.
     @@Const:
        @@@Name:  DOCUMENT_FRAGMENT_NODE
        @@@intValue:  11
        @@@Description:
          @@@@lang:en
          @@@@@: 
            The node is a <IF::DocumentFragment>.
     @@Const:
        @@@Name:  NOTATION_NODE
        @@@intValue:  12
        @@@Description:
          @@@@lang:en
          @@@@@: 
            The node is a <IF::DOMXML:Notation>.
  @Attr:
     @@Name:  nodeName
     @@Description:
        @@@lang:en
        @@@@: 
          The name of this node. 
     @@DOMMain:isNamespaceUnaware:1
     @@IsFinal: -1
     @@Get:
        @@@Type:  
          DOMMain:DOMString
        @@@actualType:
          DOMMain:ManakaiDOMString
  @Attr:
     @@Name:  nodeValue
     @@Description:
       @@@lang:en
       @@@@: The value of this node.
     @@Type:  
        DOMMain:DOMString
      @@actualType:
        DOMMain:ManakaiDOMString
     @@Get:
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: DOMSTRING_SIZE_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: 
              This attribute would return more characters than fit 
              in a <TYPE::DOMMain:DOMString> variable on the implementation 
              platform. 
        @@@PerlDef: $r = null;
     @@Set:
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: 
              This node is read-only and its <A::Node.nodeValue> is 
              not defined as <DOM::null>. 
        @@@Description:
          @@@@lang:en
          @@@@@:
            A new node value. 
            \
            {NOTE:: Setting this attribute has no effect if 
                    the node value is defined as <DOM::null>. 
            \
            }
        @@@Warning:
          @@@@@:
            MDOMX:ATTR_SET_NO_EFFECT
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Setting this attribute has no effect if the node value 
              is defined as <DOM::null>. 
        @@@ImplNote:
          @@@@lang:en
          @@@@@:
            Setting this attribute does not raise an exception, 
            even if this node is read-only, in case the node value 
            is defined as <DOM::null>. 
            \
            {NOTE:: <QUOTE::Even if read-only> has been clarified by 
                    the DOM Level 2 Specifications Errata. 
            \
            }
        @@@PerlDef: \
  @Attr:
     @@Name:  nodeType
     @@Description:
       @@@lang:en
       @@@@: The type of this node.
     @@IsFinal: -1
     @@Get:
        @@@Type:  
          DOMMain:unsigned-short||ManakaiDOM|all
        @@@actualType: ManakaiDOMNodeType
        @@@Description:
          @@@@lang:en
          @@@@@: 
            A code representing the type of the underlying object. 
       @@@PerlDef: \
  @Attr:
     @@Name:  parentNode
     @@Description:
       @@@lang:en
       @@@@: The parent of this node.
     @@Type: Node
     @@actualType: ManakaiDOMNode
     @@Get:
        @@@Description:
          @@@@lang:en
          @@@@@: The parent node.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              This node does not have a parent, since either the type 
              of this node is <IF::Attr>, <IF::Document>, 
              <IF::DocumentFragment>, <IF::DOMXML:Entity> or 
              <IF::DOMXML:Notation>, this node has just been created 
              and not yet added to any tree, or it has been removed 
              from the tree. 
        @@@disDef:
          @@@@GetPropNode:
            infoset:parent
    @@Level[list]:
      1
      2
      3
    @@SpecLevel:1
  @Attr:
     @@Name:  childNodes
     @@Description:
       @@@lang:en
       @@@@:
         A list of node that contains all children of this node.
     @@Get:
        @@@Type: NodeList
        @@@actualType:
          ManakaiDOMCore:ManakaiDOMChildNodeList
        @@@Description:
          @@@@lang:en
          @@@@@:
            A <IF::NodeList> object.
        @@@InCase:
          @@@@Label:
            @@@@@lang:en
            @@@@@@:
              A <IF::NodeList> containing no nodes
          @@@@Type: NodeList
          @@@@actualType:
            ManakaiDOMCore:ManakaiDOMChildNodeList
          @@@@Description:
            @@@@@lang:en
            @@@@@@: This node has no child node.
        @@@PerlDef:
          __CODE{getNodeRef::
            $object => {$self->{<Q::TreeCore:node>}},
            $ref => $r,
            $class => {<ClassName::ManakaiDOMCore:ManakaiDOMChildNodeList>},
          }__;
     @@SpecLevel:1
     @@Level[list]:
       1
       2
       3
  @Attr:
     @@Name:  firstChild
     @@Description:
       @@@lang:en
       @@@@: The first child of this node.
     @@Get:
        @@@Type:  Node
        @@@actualType: ManakaiDOMNode
        @@@Description:
          @@@@lang:en
          @@@@@: The first child node.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: There is no child node.
        @@@PerlDef:
          $r = $self->{<Q::TreeCore:node>}->{<Q::infoset:children>}->[0];
          $r = $r ? <ClassM::ManakaiDOMNode.getNodeReference> ($r) : null;
    @@Level[list]:
      1
      2
      3
    @@SpecLevel:1
  @Attr:
     @@Name:  lastChild
     @@Description:
        @@@lang:en
        @@@@: The last child of this node.
     @@Get:
        @@@Type:  Node
        @@@actualType: ManakaiDOMNode
        @@@Description:
          @@@@lang:en
          @@@@@: The last child node.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: There is no child node.
        @@@PerlDef:
          $r = $self->{<Q::TreeCore:node>}->{<Q::infoset:children>}->[-1];
          $r = $r ? <ClassM::ManakaiDOMNode.getNodeReference> ($r) : null;
     @@Level[list]:
        1
        2
        3
     @@SpecLevel:1
  @Attr:
     @@Name:  previousSibling
     @@Description:
        @@@lang:en
        @@@@:
          The node immediately preceding this node.
     @@Get:
        @@@Type:  Node
        @@@actualType: ManakaiDOMNode
        @@@Description:
          @@@@lang:en
          @@@@@: The node immediately preceding this node.
        @@@InCase:
          @@@@Value:
             @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: There is no such node.
        @@@PerlDef:
          @@@@@:
            if (my $parent = $self->{<Q::TreeCore:node>}->{<Q::infoset:parent>}) {
              for (@{$parent->{<Q::infoset:children>}}) {
                if ($_->{<Q::TreeCore:nodeID>} eq
                         $self->{<Q::TreeCore:node>}->{<Q::TreeCore:nodeID>}) {
                  last;
                } else {
                  $r = $_;
                }
              }
            }
            if ($r) {
              $r = <ClassM::ManakaiDOMNode.getNodeReference> ($r);
            }
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              This code will result in something incorrect when the 
              <Q::infoset:children> of the <Q::infoset:parent> of 
              this node does not have this node (i.e. the tree 
              is broken). 
    @@Level[list]:
      1
      2
      3
    @@SpecLevel:1
  @Attr:
     @@Name:  nextSibling
     @@Description:
        @@@lang:en
        @@@@: The node immediately following this node.
     @@Get:
        @@@Type:  Node
        @@@actualType: ManakaiDOMNode
        @@@Description:
          @@@@lang:en
          @@@@@: The node immediately following this node.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: There is no such node.
        @@@PerlDef:
            if (my $parent = $self->{<Q::TreeCore:node>}->{<Q::infoset:parent>}) {
              my $next = 0;
              for (@{$parent->{<Q::infoset:children>}}) {
                if ($next) {
                  $r = <ClassM::ManakaiDOMNode.getNodeReference> ($_);
                  last;
                } elsif ($_->{<Q::TreeCore:nodeID>} eq
                         $self->{<Q::TreeCore:node>}->{<Q::TreeCore:nodeID>}) {
                  $next = 1;
                }
              }
            }
    @@Level[list]:
      1
      2
      3
    @@SpecLevel:1
  @Attr:
     @@Name:  attributes
     @@Description:
       @@@lang:en
       @@@@:
         A node map containing the attributes of this node.
     @@Get:
        @@@Type: NamedNodeMap
        @@@Description:
          @@@@lang:en
          @@@@@:
            A (possibly empty) <IF::NamedNodeMap> object.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              This node is not of type <IF::Element>.
        @@@PerlDef:\
  @Attr:
     @@Name:  ownerDocument
     @@Description:
       @@@lang:en
       @@@@:
         The <IF::Document> object associated with this node.
     @@Get:
        @@@Type:  Document
        @@@actualType: ManakaiDOMDocument
        @@@Description:
          @@@@lang:en
          @@@@@:
            The owner document object.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Either this node is a <IF::Document> or this node is 
              a <IF::DOMXML:DocumentType> that has just been created 
              and not yet used in any document. 
        @@@disDef:
          @@@@GetPropNode:
            DOMCore:ownerDocument
     @@SpecLevel[list]:
        1
        2
     @@Level[list]:
        1
        2
        3
     @@ImplNote:
       @@@lang:en
       @@@@:
         DOM Level 1 does not have <M::DOMImplementation.createDocumentType> 
         so that DOM Level 1 does not consider a <IF::DOMXML:DocumentType> 
         object without any owner <IF::Document>. 
  @Method:
     @@Name:  insertBefore
     @@Description:
       @@@lang:en
       @@@@:
         Inserts a node just before the existing child node. 
     @@Param:
        @@@Name:  newChild
        @@@Type:  Node
        @@@actualType: ManakaiDOMNode
        @@@Description:
          @@@@lang:en
          @@@@@:
            A node to insert.  If the <P::newChild> is already 
            used in any tree, it is first removed. 
        @@@InCase:
          @@@@Type: DocumentFragment
          @@@@actualType: ManakaiDOMDocumentFragment
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              All the child nodes are inserted, in the same order, 
              to the child list.  After the insertion, the child list 
              of <P::newChild> is to be empty.
          @@@@SpecLevel: 1
     @@Param:
        @@@Name:  refChild
        @@@Type:  Node
        @@@actualType: ManakaiDOMNode
        @@@Description:
          @@@@lang:en
          @@@@@:
            The reference node before which the <P::refChild> 
            (or its children) is inserted. 
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The <P::newChild> is inseted at the end of the list of children. 
        @@@InCase:
          @@@@Label:
            @@@@@lang:en
            @@@@@@:
              <P::newChild> itself
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The result is implementation dependent.
            @@@@@For:
              ManakaiDOM:DOM3
     @@Return:
        @@@Type:  Node
        @@@actualType: ManakaiDOMNode
        @@@Description:
          @@@@lang:en
          @@@@@: The node being inserted.
        @@@ImplNote:
          @@@@lang:en
          @@@@@:
            What should be returned when the "newChild" is a "DocumentFragment" 
            is unclear.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: HIERARCHY_REQUEST_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: 
              Either this node is of a type that does not allow 
              children of the type of the "newChild" node [DOM 1, 2, 3],
              the node to insert is one of ancestors of this node 
              [DOM 1, 2, 3], the node to insert is this node itself
              [DOM 2 Errata, 3], or this node is of type "Document" 
              and the attemption 
              to insert a second "DocumentType" or "Element" node 
              is made [DOM 3].
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@: 
              Special treatment required if it is a "DocumentFragment".
              Whether the node is hierarchically valid must be 
              ensured for each child nodes.
            \
              For example, the attemption to add more than one elements 
              using "DocumentFragment" to the empty "Document" must 
              be detected.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: WRONG_DOCUMENT_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The "newChild" node was created from a different 
              document.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Either this node is read-only [DOM 1, 2, 3] or the parent of 
              the node being inserted is read-only [DOM 1 SE, 2, 3].
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NOT_SUPPORTED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              This node is of type "Document" and the DOM implementation 
              does not support the insertion of a "DocumentType" or 
              "Element" node.
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              While the specification does not address, 
              in case that the parent of the "newChild" is a "Document" 
              and the DOM implementation does not support the 
              removal from it, this error should also be raised.
          @@@@SpecLevel:3
        @@@PerlDef:
            my $node;
            my $newNode;
            CHKDOC: {
              if (UNIVERSAL::isa ($newChild, <IFName::Node
                                              ::ManakaiDOM:ManakaiDOM>) and
                  UNIVERSAL::isa ($newChild, <IFName::NodeRef>)) {
                $node = $self->{<Q::TreeCore:node>};
                $newNode = $newChild->{<Q::TreeCore:node>};
                if ($node->{<Q::DOMCore:ownerDocument>}) {
                  if ($newNode->{<Q::DOMCore:ownerDocument>}) {
                    last CHKDOC if $node->{<Q::DOMCore:ownerDocument>}
                                        ->{<Q::TreeCore:nodeID>} eq
                                   $newNode->{<Q::DOMCore:ownerDocument>}
                                        ->{<Q::TreeCore:nodeID>};
                  }
                } else { ## I'm "Document" or "DocumentType" node.
                  if ($node->{<Q::DOMCore:nodeType>} eq <Q::infoset:Document>) {
                    last CHKDOC;
                  }
                }
              }
              __EXCEPTION{
                ManakaiDOMException.WRONG_DOCUMENT_ERR::
                  MDOMX:param-name => 'newChild',
              }__;
            } # CHKDOC
            my @newNode = ($newNode);
            if ($newNode->{<Q::DOMCore:nodeType>} eq
                <Q::DOMCore:DocumentFragment>) {
       \       @newNode = @{$newNode->{<Q::infoset:children>}};
            }
            if (@newNode) {
              my $parentNode = $newNode[0]->{<Q::infoset:parent>};

              ## Read-only?
              if ($node->{<Q::DOMCore:read-only>}) {
                ## This node is read-only.
                __EXCEPTION{
                  MDOMX:NOMOD_THIS::
                }__;
              } elsif ($parentNode and $parentNode->{<Q::DOMCore:read-only>}) {
                ## Parent of new node(s) is read-only
                __EXCEPTION{
                  MDOMX:NOMOD_SRC_PARENT::
                    MDOMX:param-name => 'newChild',
                }__;
              }
              
              ## Check type of this node and new child node
              CHKTYPE: {
                if ({
                      <Q::infoset:Element> => 1,
                      <Q::DOMCore:DocumentFragment> => 1,
                      <Q::DOMXML:Entity> => 1,
                      <Q::DOMXML:EntityReference> => 1,
                    }->{$node->{<Q::DOMCore:nodeType>}}) {
                  CHILDTYPE: {
                    for (@newNode) {
                      unless ({
                            <Q::infoset:Element> => 1,
                            <Q::DOMCore:Text> => 1,
                            <Q::infoset:Comment> => 1,
                            <Q::infoset:ProcessingInstruction> => 1,
                            <Q::DOMXML:CDATASection> => 1,
                            <Q::DOMXML:EntityReference> => 1,
                          }->{$_->{<Q::DOMCore:nodeType>}}) {
                        last CHILDTYPE;
                      }
                    }
                    last CHKTYPE; # No problem
                  }
                } elsif ($node->{<Q::DOMCore:nodeType>} eq <Q::infoset:Document>) {
                  CHILDTYPE: {
                    my %has;
                    EACHNEWNODE: for my $newNode (@newNode) {
                      if ({
                            <Q::infoset:Element> => 1,
                            <Q::infoset:DocumentTypeDeclaration> => 1,
                          }->{$newNode->{<Q::DOMCore:nodeType>}}) {
                        FOUND: {
                          if ($has{$newNode->{<Q::DOMCore:nodeType>}}) {
                            ## DOCTYPE or document element is waiting 
                            ## to be added
                            last FOUND;
                          }
                          for (@{$node->{<Q::infoset:children>}}) {
                            ## Document already has a DOCTYPE or doc.element
                            last FOUND if $_->{<Q::DOMCore:nodeType>} eq
                                          $newNode->{<Q::DOMCore:nodeType>};
                          }
                          $has{$newNode->{<Q::DOMCore:nodeType>}} = 1;
                          next EACHNEWNODE;
                        }
                        if ($newNode->{<Q::DOMCore:nodeType>} eq
                            <Q::infoset:Element>) {
                          __EXCEPTION{
                            MDOMX:MDOM_SECOND_DOC_ELEMENT::
                              MDOMX:param-name => 'newChild',
                          }__;
                        } else { # infoset:DocumentTypeDeclaration
                          __EXCEPTION{
                            MDOMX:MDOM_SECOND_DOCTYPE::
                              MDOMX:param-name => 'newChild',
                          }__;
                        }
                      } elsif (not {
                                 <Q::infoset:Comment> => 1,
                                 <Q::infoset:ProcessingInstruction> => 1,
                               }->{$newNode->{<Q::DOMCore:nodeType>}}) {
                        last CHILDTYPE;
                      }
                    } # EACHNEWNODE
                    last CHKTYPE; # No problem
                  } # CHILDTYPE
                } elsif ($node->{<Q::DOMCore:nodeType>} eq
                         <Q::infoset:Attribute>) {
                  CHILDTYPE: {
                    for my $newNode (@newNode) {
                      unless ({
                            <Q::DOMCore:Text> => 1,
                            <Q::DOMXML:EntityReference> => 1,
                          }->{$newNode->{<Q::DOMCore:nodeType>}}) {
                        last CHILDTYPE;
                      }
                    }
                    last CHKTYPE; # No problem
                  }
                } # $node->{< Q::DOMCore:nodeType>}
                __EXCEPTION{
                  MDOMX:HIERARCHY_BAD_TYPE::
                    infoset:nodeType => {$newNode->{<Q::infoset:nodeType>}},
                    MDOMX:param-name => 'newChild',
                }__;
              } # CHKTYPE
              
              ## Check $newNode (not $newNode[0]) = ancestor-or-self::node()
              if ($node->{<Q::TreeCore:treeID>} eq
                  $newNode->{<Q::TreeCore:treeID>}) {
                my $n = $node;
                {
                  if ($newNode->{<Q::TreeCore:nodeID>} eq
                      $n->{<Q::TreeCore:nodeID>}) {
                    __EXCEPTION{
                      MDOMX:HIERARCHY_ANCESTOR_OR_SELF::
                        MDOMX:param-name => 'newChild',
                    }__;
                  }
                  if ($n->{<Q::infoset:parent>}) {
                    $n = $n->{<Q::infoset:parent>};
                    redo;
                  }
                }
              }
              
              ## Seek the $refChild
              my $newIndex = @{$node->{<Q::infoset:children>}};
              REFCHILD: {
                if (defined $refChild) {
                  my $refID = $refChild->{<Q::TreeCore:node>}
                                       ->{<Q::TreeCore:nodeID>};
                  for my $i (0..$#{$node->{<Q::infoset:children>}}) {
                    if ($node->{<Q::infoset:children>}->[$i]
                             ->{<Q::TreeCore:nodeID>} eq $refID) {
                      $newIndex = $i;
                      last REFCHILD;
                    }
                  }
                  __EXCEPTION{
                    ManakaiDOMException.NOT_FOUND_ERR::
                      MDOMX:param-name => 'refChild',
                  }__;
                }
              } # REFCHILD
              if ($newNode[0]->{<Q::infoset:parent>} and
                  $newNode[0]->{<Q::infoset:parent>}->{<Q::TreeCore:nodeID>} eq
                  $node->{<Q::TreeCore:nodeID>}) {
                if (@newNode > 1) {
                  __EXCEPTION{
                    MDOMX:MDOM_DEBUG_BUG||ManakaiDOM:Perl::
                  }__;
                } elsif (ref $refChild and
                         $newNode[0]->{<Q::TreeCore:nodeID>} eq
                         $refChild->{<Q::TreeCore:node>}->{<Q::TreeCore:nodeID>}) {
                  ## refChild is the same node as the newChild
                  __WARNING{
                    MDOMX:MDOM_NEWCHILD_IS_REFCHILD::
                      MDOMX:newChild-param-name => 'newChild',
                      MDOMX:refChild-param-name => 'refChild',
                  }__;
                  ## And no action.
                } else {
                  ## refChild and newChild are siblings each other.
                  my $currentIndex;
                  for my $i (0..$#{$node->{<Q::infoset:children>}}) {
                    if ($node->{<Q::infoset:children>}->[$i]
                             ->{<Q::TreeCore:nodeID>} eq
                        $newNode[0]->{<Q::TreeCore:nodeID>}) {
                      $currentIndex = $i;
                    }
                  }
                  ## Changes the position of the newChild in the parent nodelist
                  if ($newIndex < $currentIndex) {
                    splice @{$node->{<Q::infoset:children>}}, $currentIndex,
                           1, ();
                    splice @{$node->{<Q::infoset:children>}},
                           $newIndex, 1, @newNode;
                  } else {
                    splice @{$node->{<Q::infoset:children>}},
                           $newIndex, 1, @newNode;
                    splice @{$node->{<Q::infoset:children>}}, $currentIndex,
                           1, ();
                  }
                }
              } else { ## $newChild->parentNode ne $self
                for my $newNode (@newNode) {
                  CORE::delete $newNode->{<Q::infoset:parent>};
                  $node-><M::NodeStem.importTree> ($newNode);
                  $newNode->{<Q::infoset:parent>} = $node;
                }
                splice @{$node->{<Q::infoset:children>}},
                       $newIndex, 0, @newNode;
              }
              
              if ($newNode->{<Q::DOMCore:nodeType>} eq
                  <Q::DOMCore:DocumentFragment>) {
                $newNode->{<Q::infoset:children>} = [];
              } elsif ($parentNode) {
                P: for my $i (0..$#{$parentNode->{<Q::infoset:children>}}) {
                  if ($parentNode->{<Q::infoset:children>}->[$i]
                                 ->{<Q::TreeCore:nodeID>} eq
                      $newNode->{<Q::TreeCore:nodeID>}) {
                    splice @{$parentNode->{<Q::infoset:children>}}, $i, 1, ();
                    last P;
                  }
                }
              }
            } # @newNode
            $r = $newChild;
     @@Level[list]:
        1
     @@SpecLevel[list]:
        1
        3
  @Method:
     @@Name:  replaceChild
     @@Description:
        @@@lang:en
        @@@@:
          Replace a child node with the other node.
     @@Param:
        @@@Name:  newChild
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@:
            The new node to put in the child list.  If the "newChild" node 
            is already in the tree, it is first removed.
        @@@InCase:
          @@@@Type: DocumentFragment
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The "oldChild" node is replaced by all of the 
              child nodes of the "newChild" node, in the same order. 
              The child list of the "newChild" is to be empty. 
              [DOM 1 SE, 2, 3]
     @@Param:
        @@@Name:  oldChild
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@:
            The node being replaced in the child list.
        @@@InCase:
          @@@@Label: Same as the "newChild" node
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Replacing a node with itself is implementation dependent.
          @@@@SpecLevel: 3
     @@Return:
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@: The node replaced.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: HIERARCHY_REQUEST_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Either this node is of a type that does not allow 
              children of the type of the "newChild" node [DOM 1, 2, 3],
              the node to put in is one of ancestors of this node 
              [DOM 1, 2, 3], the node to put in is this node itself
              [DOM 2 Errata, 3], or this 
              node is of type "Document" and the result of the 
              replacement would add a second "DocumentType" or "Element" node.
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              Special treatment required for the "DocumentFragment" node.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: WRONG_DOCUMENT_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The new node was created from a different document.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Either this node is read-only [DOM 1, 2, 3] or the parent of the 
              new node is read-only [DOM 1 SE, 2, 3].
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NOT_FOUND_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The "oldChild" node is not a child of this node.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NOT_SUPPORTED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              This node is of type "Document" and the DOM implementation 
              does not support the replacement of the "DocumentType" or 
              "Element" child.
          @@@@SpecLevel:3
        @@@PerlDef:
            my $node;
            my $newNode;
            CHKDOC: {
              if (UNIVERSAL::isa ($newChild, <IFName::Node
                                              ::ManakaiDOM:ManakaiDOM>) and
                  UNIVERSAL::isa ($newChild, <IFName::NodeRef>)) {
                $node = $self->{<Q::TreeCore:node>};
                $newNode = $newChild->{<Q::TreeCore:node>};
                if ($node->{<Q::DOMCore:ownerDocument>}) {
                  if ($newNode->{<Q::DOMCore:ownerDocument>}) {
                    last CHKDOC if $node->{<Q::DOMCore:ownerDocument>}
                                        ->{<Q::TreeCore:nodeID>} eq
                                   $newNode->{<Q::DOMCore:ownerDocument>}
                                        ->{<Q::TreeCore:nodeID>};
                  }
                } else { ## I'm "Document" or "DocumentType" node.
                  if ($node->{<Q::DOMCore:nodeType>} eq <Q::infoset:Document>) {
                    last CHKDOC;
                  }
                }
              }
              __EXCEPTION{
                ManakaiDOMException.WRONG_DOCUMENT_ERR::
                  MDOMX:param-name => 'newChild',
              }__;
            } # CHKDOC
            my @newNode = ($newNode);
            if ($newNode->{<Q::DOMCore:nodeType>} eq
                <Q::DOMCore:DocumentFragment>) {
       \       @newNode = @{$newNode->{<Q::infoset:children>}};
            }
            if (@newNode) {
              my $parentNode = $newNode[0]->{<Q::infoset:parent>};

              ## Read-only?
              if ($node->{<Q::DOMCore:read-only>}) {
                ## This node is read-only.
                __EXCEPTION{
                    MDOMX:NOMOD_THIS::
                }__;
              } elsif ($parentNode and $parentNode->{<Q::DOMCore:read-only>}) {
                ## Parent of new node(s) is read-only
                __EXCEPTION{
                  MDOMX:NOMOD_SRC_PARENT::
                    MDOMX:param-name => 'newChild',
                }__;
              }
              
              ## Check type of this node and new child node
              CHKTYPE: {
                if ({
                      <Q::infoset:Element> => 1,
                      <Q::DOMCore:DocumentFragment> => 1,
                      <Q::DOMXML:Entity> => 1,
                      <Q::DOMXML:EntityReference> => 1,
                    }->{$node->{<Q::DOMCore:nodeType>}}) {
                  CHILDTYPE: {
                    for (@newNode) {
                      unless ({
                            <Q::infoset:Element> => 1,
                            <Q::DOMCore:Text> => 1,
                            <Q::infoset:Comment> => 1,
                            <Q::infoset:ProcessingInstruction> => 1,
                            <Q::DOMXML:CDATASection> => 1,
                            <Q::DOMXML:EntityReference> => 1,
                          }->{$_->{<Q::DOMCore:nodeType>}}) {
                        last CHILDTYPE;
                      }
                    }
                    last CHKTYPE; # No problem
                  }
                } elsif ($node->{<Q::DOMCore:nodeType>} eq <Q::infoset:Document>) {
                  CHILDTYPE: {
                    my %has;
                    EACHNEWNODE: for my $newNode (@newNode) {
                      if ({
                            <Q::infoset:Element> => 1,
                            <Q::infoset:DocumentTypeDeclaration> => 1,
                          }->{$newNode->{<Q::DOMCore:nodeType>}}) {
                        FOUND: {
                          if ($has{$newNode->{<Q::DOMCore:nodeType>}}) {
                            ## DOCTYPE or document element is waiting 
                            ## to be added
                            last FOUND;
                          }
                          for (@{$node->{<Q::infoset:children>}}) {
                            ## Document already has a DOCTYPE or doc.element
                            last FOUND if $_->{<Q::DOMCore:nodeType>} eq
                                          $newNode->{<Q::DOMCore:nodeType>};
                          }
                          $has{$newNode->{<Q::DOMCore:nodeType>}} = 1;
                          next EACHNEWNODE;
                        }
                        if ($newNode->{<Q::DOMCore:nodeType>} eq
                            <Q::infoset:Element>) {
                          __EXCEPTION{
                            MDOMX:MDOM_SECOND_DOC_ELEMENT::
                              MDOMX:param-name => 'newChild',
                          }__;
                        } else { # infoset:DocumentTypeDeclaration
                          __EXCEPTION{
                            MDOMX:MDOM_SECOND_DOCTYPE::
                              MDOMX:param-name => 'newChild',
                          }__;
                        }
                      } elsif (not {
                                 <Q::infoset:Comment> => 1,
                                 <Q::infoset:ProcessingInstruction> => 1,
                               }->{$newNode->{<Q::DOMCore:nodeType>}}) {
                        last CHILDTYPE;
                      }
                    } # EACHNEWNODE
                    last CHKTYPE; # No problem
                  } # CHILDTYPE
                } elsif ($node->{<Q::DOMCore:nodeType>} eq
                         <Q::infoset:Attribute>) {
                  CHILDTYPE: {
                    for my $newNode (@newNode) {
                      unless ({
                            <Q::DOMCore:Text> => 1,
                            <Q::DOMXML:EntityReference> => 1,
                          }->{$newNode->{<Q::DOMCore:nodeType>}}) {
                        last CHILDTYPE;
                      }
                    }
                    last CHKTYPE; # No problem
                  }
                } # $node->{< Q::DOMCore:nodeType>}
                __EXCEPTION{
                  MDOMX:HIERARCHY_BAD_TYPE::
                    infoset:nodeType => {$newNode->{<Q::infoset:nodeType>}},
                    MDOMX:param-name => 'newChild',
                }__;
              } # CHKTYPE
              
              ## Check $newNode (not $newNode[0]) = ancestor-or-self::node()
              if ($node->{<Q::TreeCore:treeID>} eq
                  $newNode->{<Q::TreeCore:treeID>}) {
                my $n = $node;
                {
                  if ($newNode->{<Q::TreeCore:nodeID>} eq
                      $n->{<Q::TreeCore:nodeID>}) {
                    __EXCEPTION{
                      MDOMX:HIERARCHY_ANCESTOR_OR_SELF::
                        MDOMX:param-name => 'newChild',
                    }__;
                  }
                  if ($n->{<Q::infoset:parent>}) {
                    $n = $n->{<Q::infoset:parent>};
                    redo;
                  }
                }
              }
              
              ## Seek the $oldChild
              my $newIndex = @{$node->{<Q::infoset:children>}};
              REFCHILD: {
                if (defined $oldChild) {
                  my $refID = $oldChild->{<Q::TreeCore:node>}
                                       ->{<Q::TreeCore:nodeID>};
                  for my $i (0..$#{$node->{<Q::infoset:children>}}) {
                    if ($node->{<Q::infoset:children>}->[$i]
                             ->{<Q::TreeCore:nodeID>} eq $refID) {
                      $newIndex = $i;
                      last REFCHILD;
                    }
                  }
                  __EXCEPTION{
                    ManakaiDOMException.NOT_FOUND_ERR::
                      MDOMX:param-name => 'oldChild',
                  }__;
                } else { ## oldChild is n u l l
                  __EXCEPTION{
                    ManakaiDOMException.NOT_FOUND_ERR::
                      MDOMX:param-name => 'oldChild',
                  }__;
                }
              } # REFCHILD
              if ($newNode[0]->{<Q::infoset:parent>} and
                  $newNode[0]->{<Q::infoset:parent>}->{<Q::TreeCore:nodeID>} eq
                  $node->{<Q::TreeCore:nodeID>}) {
                if (@newNode > 1) {
                  __EXCEPTION{
                    MDOMX:MDOM_DEBUG_BUG||ManakaiDOM:Perl::
                  }__;
                } elsif (ref $oldChild and
                         $newNode[0]->{<Q::TreeCore:nodeID>} eq
                         $oldChild->{<Q::TreeCore:node>}->{<Q::TreeCore:nodeID>}) {
                  __WARNING{
                    MDOMX:MDOM_NEWCHILD_IS_REFCHILD:: 
                      MDOMX:newChild-param-name => 'newChild',
                      MDOMX:refChild-param-name => 'oldChild',
                  }__;
                  ## And no action.
                } else {
                  my $currentIndex;
                  for my $i (0..$#{$node->{<Q::infoset:children>}}) {
                    if ($node->{<Q::infoset:children>}->[$i]
                             ->{<Q::TreeCore:nodeID>} eq
                        $newNode[0]->{<Q::TreeCore:nodeID>}) {
                      $currentIndex = $i;
                    }
                  }
                  if ($newIndex < $currentIndex) {
                    splice @{$node->{<Q::infoset:children>}}, $currentIndex,
                           1, ();
                    splice @{$node->{<Q::infoset:children>}},
                           $newIndex, 1, @newNode;
                  } else {
                    splice @{$node->{<Q::infoset:children>}},
                           $newIndex, 1, @newNode;
                    splice @{$node->{<Q::infoset:children>}}, $currentIndex,
                           1, ();
                  }
                }
              } else { ## $newChild->parentNode ne $self
                for my $newNode (@newNode) {
                  CORE::delete $newNode->{<Q::infoset:parent>};
                  $node-><M::NodeStem.importTree> ($newNode);
                  $newNode->{<Q::infoset:parent>} = $node;
                }
                splice @{$node->{<Q::infoset:children>}},
                       $newIndex, 1, @newNode;
              }
              
              if ($newNode->{<Q::DOMCore:nodeType>} eq
                  <Q::DOMCore:DocumentFragment>) {
                $newNode->{<Q::infoset:children>} = [];
              } elsif ($parentNode) {
                P: for my $i (0..$#{$parentNode->{<Q::infoset:children>}}) {
                  if ($parentNode->{<Q::infoset:children>}->[$i]
                                 ->{<Q::TreeCore:nodeID>} eq
                      $newNode->{<Q::TreeCore:nodeID>}) {
                    splice @{$parentNode->{<Q::infoset:children>}}, $i, 1, ();
                    last P;
                  }
                }
              }
              CORE::delete $oldChild->{<Q::TreeCore:node>}
                                    ->{<Q::infoset:parent>};
              $oldChild->{<Q::TreeCore:node>}-><M::NodeStem.orphanate>;
            } # @newNode
            $r = $oldChild;
     @@Level[list]:
        1
        3
     @@SpecLevel[list]:
        1
        3
  @Method:
     @@Name:  removeChild
     @@Description:
       @@@lang:en
       @@@@:
         Remove a child node from the list of children and return it.
     @@Param:
        @@@Name:  oldChild
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@: The node being removed.
     @@Return:
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@: The node removed.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: This node is read-only.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NOT_FOUND_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The "oldChild" is not a child of this node.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NOT_SUPPORTED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              This node is of type "Document" and the DOM implementation 
              does not support the removal of the "DocumentType" or 
              "Element" child.
        @@@PerlDef:
            my $node = $self->{<Q::TreeCore:node>};
            if ($node->{<Q::DOMCore:read-only>}) {
              __EXCEPTION{
                MDOMX:NOMOD_THIS::
              }__;
            }
            my $oldChildID = ref $oldChild ?
                               $oldChild->{<Q::TreeCore:node>}
                                        ->{<Q::TreeCore:nodeID>} : '';
            FIND: {
              for my $i (0..$#{$node->{<Q::infoset:children>}}) {
                if ($node->{<Q::infoset:children>}->[$i]
                         ->{<Q::TreeCore:nodeID>} eq $oldChildID) {
                  splice @{$node->{<Q::infoset:children>}}, $i, 1, ();
                  last FIND;
                }
              }
              __EXCEPTION{
                ManakaiDOMException.NOT_FOUND_ERR::
              }__;
            }
            if (ref $oldChild) {
              $r = $oldChild;
              CORE::delete $oldChild->{<Q::TreeCore:node>}
                                    ->{<Q::infoset:parent>};
              $oldChild->{<Q::TreeCore:node>}-><M::NodeStem.orphanate>;
            }
     @@Level[list]:  3
     @@SpecLevel:3
     @@For:
       ManakaiDOM:DOM3
  @Method:
     @@Name:  appendChild
     @@Description:
       @@@lang:en
       @@@@:
         Add a node to the end of the list of children of this node.
     @@Param:
        @@@Name:  newChild
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@:
            The node to add.  If it is already in the tree, 
            it is first removed.
        @@@InCase:
          @@@@Type: DocumentFragment
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The entire contents of the document fragment 
              are moved into the child list of this node. 
              The child list of the "newChild" is to be empty.
     @@Return:
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@: The node added.
        @@@ImplNote:
          @@@@lang:en
          @@@@@:
            What should be returned when the "newChild" node is a 
            "DocumentFragment" is unclear.  Current implementation
            returns the <P::newChild>, but returning <QUOTE::this>
            might be better.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: HIERARCHY_REQUEST_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Either this node is of a type that does not allow 
              children of the type of the "newChild" node [DOM 1, 2, 3], 
              the node to add is one of ancestors of this node [DOM 1, 2, 3],
              the node to add is this node itself [DOM 2 Errata, 3] or 
              this node is of type "Document" and the attemption 
              to append a second "DocumentType" or "Element" node 
              is made [DOM 3].
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              Is this error raised if this node is of type "Document" and 
              it has an "Element" node but no "DocumentType" node then 
              the attemption to add a "DocumentType" is made?
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: WRONG_DOCUMENT_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The "newChild" node was created from a different document 
              than the one that created this node.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Either this node is read-only [DOM 1, 2, 3] or
              the previous (current) parent 
              of the "newChild" node is read-only [DOM 2 Errata, 3].
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NOT_SUPPORTED_ERR
          @@@@Level: 3
          @@@@SpecLevel:3
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The "newChild" node is a child of the "Document" node and 
              the DOM implementation does not support the removal of 
              the "DocumentType" or "Element" child node from the 
              "Document" node.
        @@@PerlDef:
          @@@@@:
            my $node;
            my $newNode;
            CHKDOC: {
              if (UNIVERSAL::isa ($newChild, <IFName::Node
                                              ::ManakaiDOM:ManakaiDOM>) and
                  UNIVERSAL::isa ($newChild, <IFName::NodeRef>)) {
                $node = $self->{<Q::TreeCore:node>};
                $newNode = $newChild->{<Q::TreeCore:node>};
                if ($node->{<Q::DOMCore:ownerDocument>}) {
                  if ($newNode->{<Q::DOMCore:ownerDocument>}) {
                    last CHKDOC if $node->{<Q::DOMCore:ownerDocument>}
                                        ->{<Q::TreeCore:nodeID>} eq
                                   $newNode->{<Q::DOMCore:ownerDocument>}
                                        ->{<Q::TreeCore:nodeID>};
                  }
                } else { ## I'm "Document" or "DocumentType" node.
                  if ($node->{<Q::DOMCore:nodeType>} eq <Q::infoset:Document>) {
                    last CHKDOC;
                  }
                }
              }
              __EXCEPTION{
                ManakaiDOMException.WRONG_DOCUMENT_ERR::
                  MDOMX:param-name => 'newChild',
              }__;
            } # CHKDOC
            my @newNode = ($newNode);
            if ($newNode->{<Q::DOMCore:nodeType>} eq
                <Q::DOMCore:DocumentFragment>) {
       \       @newNode = @{$newNode->{<Q::infoset:children>}};
            }
            if (@newNode) {
              my $parentNode = $newNode[0]->{<Q::infoset:parent>};

              ## Read-only?
              if ($node->{<Q::DOMCore:read-only>}) {
                ## This node is read-only.
                __EXCEPTION{
                  MDOMX:NOMOD_THIS::
                }__;
              } elsif ($parentNode and $parentNode->{<Q::DOMCore:read-only>}) {
                ## Parent of new node(s) is read-only
                __EXCEPTION{
                  MDOMX:NOMOD_SRC_PARENT::
                    MDOMX:param-name => 'newChild',
                }__;
              }
              
              ## Check type of this node and new child node
              CHKTYPE: {
                if ({
                      <Q::infoset:Element> => 1,
                      <Q::DOMCore:DocumentFragment> => 1,
                      <Q::DOMXML:Entity> => 1,
                      <Q::DOMXML:EntityReference> => 1,
                    }->{$node->{<Q::DOMCore:nodeType>}}) {
                  CHILDTYPE: {
                    for (@newNode) {
                      unless ({
                            <Q::infoset:Element> => 1,
                            <Q::DOMCore:Text> => 1,
                            <Q::infoset:Comment> => 1,
                            <Q::infoset:ProcessingInstruction> => 1,
                            <Q::DOMXML:CDATASection> => 1,
                            <Q::DOMXML:EntityReference> => 1,
                          }->{$_->{<Q::DOMCore:nodeType>}}) {
                        last CHILDTYPE;
                      }
                    }
                    last CHKTYPE; # No problem
                  }
                } elsif ($node->{<Q::DOMCore:nodeType>} eq <Q::infoset:Document>) {
                  CHILDTYPE: {
                    my %has;
                    EACHNEWNODE: for my $newNode (@newNode) {
                      if ({
                            <Q::infoset:Element> => 1,
                            <Q::infoset:DocumentTypeDeclaration> => 1,
                          }->{$newNode->{<Q::DOMCore:nodeType>}}) {
                        FOUND: {
                          if ($has{$newNode->{<Q::DOMCore:nodeType>}}) {
                            ## DOCTYPE or document element is waiting 
                            ## to be added
                            last FOUND;
                          }
                          for (@{$node->{<Q::infoset:children>}}) {
                            ## Document already has a DOCTYPE or doc.element
                            last FOUND if $_->{<Q::DOMCore:nodeType>} eq
                                          $newNode->{<Q::DOMCore:nodeType>};
                          }
                          $has{$newNode->{<Q::DOMCore:nodeType>}} = 1;
                          next EACHNEWNODE;
                        }
                        if ($newNode->{<Q::DOMCore:nodeType>} eq
                            <Q::infoset:Element>) {
                          __EXCEPTION{
                            MDOMX:MDOM_SECOND_DOC_ELEMENT::
                              MDOMX:param-name => 'newChild',
                          }__;
                        } else { # infoset:DocumentTypeDeclaration
                          __EXCEPTION{
                            MDOMX:MDOM_SECOND_DOCTYPE::
                              MDOMX:param-name => 'newChild',
                          }__;
                        }
                      } elsif (not {
                                 <Q::infoset:Comment> => 1,
                                 <Q::infoset:ProcessingInstruction> => 1,
                               }->{$newNode->{<Q::DOMCore:nodeType>}}) {
                        last CHILDTYPE;
                      }
                    } # EACHNEWNODE
                    last CHKTYPE; # No problem
                  } # CHILDTYPE
                } elsif ($node->{<Q::DOMCore:nodeType>} eq
                         <Q::infoset:Attribute>) {
                  CHILDTYPE: {
                    for my $newNode (@newNode) {
                      unless ({
                            <Q::DOMCore:Text> => 1,
                            <Q::DOMXML:EntityReference> => 1,
                          }->{$newNode->{<Q::DOMCore:nodeType>}}) {
                        last CHILDTYPE;
                      }
                    }
                    last CHKTYPE; # No problem
                  }
                } # $node->{< Q::DOMCore:nodeType>}
                __EXCEPTION{
                  MDOMX:HIERARCHY_BAD_TYPE::
                    infoset:nodeType => {$newNode->{<Q::infoset:nodeType>}},
                    MDOMX:param-name => 'newChild',
                }__;
              } # CHKTYPE
              
              ## Check $newNode (not $newNode[0]) = ancestor-or-self::node()
              if ($node->{<Q::TreeCore:treeID>} eq
                  $newNode->{<Q::TreeCore:treeID>}) {
                my $n = $node;
                P: {
                  if ($newNode->{<Q::TreeCore:nodeID>} eq
                      $n->{<Q::TreeCore:nodeID>}) {
                    __EXCEPTION{
                      MDOMX:HIERARCHY_ANCESTOR_OR_SELF::
                        MDOMX:param-name => 'newChild',
                    }__;
                  }
                  if ($n->{<Q::infoset:parent>}) {
                    $n = $n->{<Q::infoset:parent>};
                    redo P;
                  }
                }
              }
              
              for my $newNode (@newNode) {
                CORE::delete $newNode->{<Q::infoset:parent>};
                $node-><M::NodeStem.importTree> ($newNode);
                $newNode->{<Q::infoset:parent>} = $node;
              }
              push @{$node->{<Q::infoset:children>}}, @newNode;

              if ($newNode->{<Q::DOMCore:nodeType>} eq
                  <Q::DOMCore:DocumentFragment>) {
                $newNode->{<Q::infoset:children>} = [];
              } elsif ($parentNode) {
                RP: for my $i (0..$#{$parentNode->{<Q::infoset:children>}}) {
                  if ($parentNode->{<Q::infoset:children>}->[$i]
                                 ->{<Q::TreeCore:nodeID>} eq
                      $newNode->{<Q::TreeCore:nodeID>}) {
                    splice @{$parentNode->{<Q::infoset:children>}}, $i, 1, ();
                    last RP;
                  }
                }
              }
            } # @newNode
            $r = $newChild;
     @@Level[list]:
        1
        3
     @@SpecLevel[list]:
        1
        3
     @@ImplNote:
       @@@lang:en
       @@@@: See also the implementation note of the "insertBefore" method.
  @Method:
     @@Name:  hasChildNodes
     @@Description:
       @@@lang:en
       @@@@: Return whether this node has any children.
     @@Return:
        @@@Type: 
          DOMMain:boolean::ManakaiDOM:all
        @@@TrueCase:
          @@@@Description:
            @@@@@lang:en
            @@@@@@: This node has any child nodes.
        @@@FalseCase:
          @@@@Description:
            @@@@@lang:en
            @@@@@@: This node does not have any child node.
        @@@PerlDef:
            $r = @{$self->{<Q::TreeCore:node>}->{<Q::infoset:children>}}
                   ? true : false;
  @Method:
     @@Name:  cloneNode
     @@Return:
        @@@Type:  Node
     @@Param:
        @@@Name:  deep
        @@@Type:  
          DOMMain:boolean::ManakaiDOM:all
  @Method:
     @@Name:  normalize
     @@Description:
       @@@lang:en
       @@@@:
         Put all <IF::Text> nodes in the full depth of the sub-tree 
         underneath this <IF::Node>, including attribute nodes 
         attaced to the <IF::Element>, 
         into a "normal" form where only structure separates 
         <IF::Text> nodes, i.e. there are neither adjacent <IF::Text> 
         nodes nor empty <IF::Text> nodes. <SRC::DOM 1, 2, 3>
       \
         If the parameter <DOM::normalize-characters> of the 
         <A::Document.domConfig> is <DOM::true>, the characters 
         of the <IF::Text> nodes will also be fully normalized. 
         <SRC::DOM 3>
     @@ImplNote:
       @@@lang:en
       @@@@:
         The spec does not say to normalize nodes other than 
         <IF::Text> (such as <IF::DOMXML:CDATASection>, 
         <IF::Comment> and so on).
     @@Return:
       @@@Exception:
         @@@@@:
           MDOMX:NOMOD_THIS
         @@@@Description:
           @@@@@lang:en
           @@@@@@:
             This node is read-only. 
         @@@@For:
           ManakaiDOM:ManakaiDOM
       @@@Exception:
         @@@@@:NOMOD_DESCENDANT_ERR
         @@@@Description:
           @@@@@lang:en
           @@@@@@:
             One of descendant (or attribute) is read-only. 
         @@@@For:
           ManakaiDOM:ManakaiDOM
       @@@PerlDef:
         @@@@@:
           __DEEP{
             $self->{<Q::TreeCore:node>}
                -><M::ManakaiDOMCore:ManakaiDOMNodeObjectNode.normalizeText>
                                                               (false, false);
           }__;
         @@@@ImplNote:
           @@@@@lang:en
           @@@@@@:
             {TODO:: Character normalization should be implemented.
             \
             }
           @@@@@ForCheck:
             ManakaiDOM:ManakaiDOM3
     @@Level[list]:
       2
       3
     @@SpecLevel[list]:
       2
       3
     @@For:
       ManakaiDOM:DOM2
     @@ImplNote:
       @@@lang:en
       @@@@:
         This method was defined in the "Element" interface in the DOM 
         Level 1, but has beem moved to the "Node" interface in the 
         DOM Level 2.
  @Method:
     @@Name:  isSupported
     @@ImplNote:
       @@@lang:en
       @@@@:
         This method is parallel to the <M::DOMImplementation.hasFeature>. 
     @@Param:
        @@@Name:  feature
        @@@Type:  
          DOMMain:DOMString
        @@@actualType:
          ManakaiDOM:ManakaiDOMFeatureName
     @@Param:
        @@@Name:  version
        @@@Type:  
          DOMMain:DOMString
        @@@actualType:
          ManakaiDOM:ManakaiDOMFeatureVersion
     @@Level[list]:  2
     @@SpecLevel:2
     @@L2:
     @@Return:
        @@@Type:  
          DOMMain:boolean||ManakaiDOM|all
        @@@PerlDef:
          my $plus = $feature =~ s/^\+// ? 1 : 0;
          if ($<Class::DOMCore:ManakaiDOMNode
                                     ::ManakaiDOM:ManakaiDOMLatest>::Class{
              ref $self}->{$feature}->{$version}) {
              \## ISSUE: Not work for node type specific classes
            $r = true;
          } else {
            for (values %<Class::DOMCore:ManakaiDOMNode
                                     ::ManakaiDOM:ManakaiDOMLatest>::Class) {
              if ($_->{feature}->{$feature}->{$version}) {
                $r = true;
                last;
              }
            }
          } 
          \## TODO: Node type specific alternates
  @Attr:
     @@Name:  namespaceURI
     @@Description:
       @@@lang:en
       @@@@:
         The namespace URI of this node.
       \
         Note that this is not a computed value that is the result 
         of a namespace lookup based on an examination of the 
         namespace declarations in scope, but is merely the 
         namespace URI given at creation time.
     @@DOMMain:isNamespaceAware:1
     @@Get:
        @@@Type:
          DOMMain:DOMString
        @@@actualType:
          ManakaiDOM:ManakaiDOMNamespaceURI
        @@@Description:
          @@@@lang:en
          @@@@@: The namespace URI.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The namespace URI is unspecified (the "null" namespace or 
              the attribute in a per-element-type partition),
              the type of the node is other than "ELEMENT_NODE" or 
              "ATTRIBUTE_NODE", or 
              the node is created with a DOM Level 1 methods.
        @@@PerlDef: $r = null;
     @@Level[list]:  2
     @@SpecLevel:2
     @@For:
       ManakaiDOM:DOM2
  @Attr:
     @@Name:  prefix
     @@Description:
       @@@lang:en
       @@@@: The namespace prefix of this node.
     @@DOMMain:isNamespaceAware:1
     @@Get:
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The namespace prefix.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Either the namespace prefix is unspecified, the node 
              is created with a DOM Level 1 method, or the type 
              of the node is other than "ELEMENT_NODE" and 
              "ATTRIBUTE_NODE".
        @@@PerlDef: $r = null;
     @@Set:
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            The namespace prefix.
            Note that setting this attribute has no effect if 
            the namespace prefix is defined to be "null".
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The namespace prefix is unspecified.
        @@@InCase:
          @@@@Value: \
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The result is implementation dependent.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: INVALID_CHARACTER_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The specified prefix contains an illegal character 
              accoding to the XML version in use in the document.
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              The DOM Level 2 Errata clarifies that the "illegal"ness 
              is accoding to the XML 1.0 Specification.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: This node is read-only.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NAMESPACE_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Either the specified prefix is malformed per the 
              XML Namespace specification, non-"null" prefix is 
              specified but the "namespaceURI" of this node is "null", 
              the specified prefix is "xml" and the "namespaceURI" 
              of this node is different from 
              "http://www.w3.org/XML/1998/namespace", if this 
              node is an attribute and the specified prefix is "xmlns" 
              and the "namespaceURI" of this node is different from 
              "http://www.w3.org/2000/xmlns/", or if this node is 
              an attribute and the "qualifiedName" of this node is 
              "xmlns".
        @@@Warning:
          @@@@Type:
            ManakaiDOM:ManakaiDOMImplementationWarning
          @@@@Name: ATTR_SET_NO_EFFECT
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Setting this attribute has no effect.
        @@@PerlDef: \
     @@Level[list]:  2
     @@SpecLevel:2
     @@For:
       ManakaiDOM:DOM2
  @Attr:
     @@Name:  localName
     @@Description:
       @@@lang:en
       @@@@: The local part of the qualified name of this node.
     @@DOMMain:isNamespaceAware:1
     @@Get:
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            The local name.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The type of the node is other than "ELEMENT_NODE" or 
              "ATTRIBUTE_NODE", or the node is created with a DOM Level 1 
              methods.
        @@@PerlDef:$r = null;
     @@Level[list]:  2
     @@SpecLevel:2
     @@For:
       ManakaiDOM:DOM2
  @Method:
     @@Name:  hasAttributes
     @@Description:
       @@@lang:en
       @@@@:
         Return whether this node has any attributes.
     @@Return:
        @@@Type: DOMMain|boolean||ManakaiDOM|all
        @@@TrueCase:
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              This node is an <IF::Element> and has any attributes.
        @@@FalseCase:
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              This node does not have any attribute.
        @@@PerlDef:
            for (values %{$self->{<Q::TreeCore:node>}
                               ->{<Q::infoset:attributes>}||{}}) {
              if (keys %$_) {
                $r = true;
                last;
              }
            }
     @@Level[list]:  2
     @@SpecLevel:2
     @@For:
       ManakaiDOM:DOM2
  @Attr:
     @@Name:  baseURI
     @@Description:
       @@@lang:en
       @@@@:
         The base URI of this node.
     @@Get:
        @@@Type: 
          DOMMain:DOMString
        @@@actualType:
          ManakaiDOM:ManakaiDOMURI
        @@@Description:
          @@@@lang:en
          @@@@@:
            The absolute base URI.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The DOM implementation was not able to obtain 
              an absolute URI.
        @@@PerlDef:
            if ($self->{<Q::TreeCore:node>}->{<Q::DOMCore:ownerDocument>} and
                $self->{<Q::TreeCore:node>}->{<Q::DOMCore:ownerDocument>}
                     ->{<Q::DOMCore:hasFeature>}->{HTML}) {
              $r = $self->{<Q::TreeCore:node>}
                     -><M::ManakaiDOMCore:ManakaiDOMNodeObjectNode.htmlBaseURI>;
            } else {
              $r = null;
            }
     @@ImplNote:
       @@@lang:en
       @@@@:
         = If the <IF::Document> support the feature <Feature::HTML>,
       \
         == If there is a <HE::base> element with the <HA::href> attribute, 
            the base URI is its value.
       \
         == Otherwise, the base URI is the value of <A::Document.documentURI>.
       \
         = Elsif the <IF::Document> support the feature <Feature::XML>, 
           compute the base URI accoding to the XML Base Specification.
     @@ImplNote:
       @@@lang:en
       @@@@:
         The descriptions in the sections of Base URIs (DOM Level 3 Core 
         1.3.4) and <A::Node.baseURI> (and some readings from XML Base 
         and XML Infoset specifications) is insufficient to understand 
         and implement this attribute.  The <sw010:csection::Infoset Mapping>, a 
         normative appendix of the DOM Level 3 Core Specification, is 
         useful for this purpose.
     @@ImplNote:
       @@@lang:en
       @@@@:
         The DOM Level 3 Specification does not address to 
         <HA::codebase> attributes.
     @@Level[list]:  3
     @@SpecLevel:3
     @@Spec:
       @@@DOM3:
         http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#baseURIs-Considerations
    @@For:
      ManakaiDOM:DOM2
  @ConstGroup:
     @@QName: 
       @@@@: DocumentPosition
       @@@ForCheck:
         ManakaiDOM:ForIF
     @@QName:
       @@@@: ManakaiDOMDocumentPosition
       @@@ForCheck:
         ManakaiDOM:ForClass
     @@PerlName: DocumentPosition

     @@Description:
       @@@lang:en
       @@@@:
         A bitmask indicating the relative document position of a node 
         with respect to another node.
     @@Level: 3
     @@SpecLevel:3
     @@For:
       ManakaiDOM:DOM3
     @@rdfs:subClassOf:
       @@@@: DOMMain|unsigned-short||ManakaiDOM|all
       @@@ForCheck: ManakaiDOM|ForClass
     @@Type:
       DOMMain:unsigned-short::ManakaiDOM:all
     @@Const:
        @@@Name:  DOCUMENT_POSITION_DISCONNECTED
        @@@intValue:  0x01
        @@@Description:
          @@@@lang:en
          @@@@@:
            The two nodes are disconnected.  Order between disconnected nodes 
            is always implementation-specific.
     @@Const:
        @@@Name:  DOCUMENT_POSITION_PRECEDING
        @@@intValue:  0x02
        @@@Description:
          @@@@lang:en
          @@@@@:
            The node precedes the reference node.
     @@Const:
        @@@Name:  DOCUMENT_POSITION_FOLLOWING
        @@@intValue:  0x04
        @@@Description:
          @@@@lang:en
          @@@@@: The node fllows the reference node.
     @@Const:
        @@@Name:  DOCUMENT_POSITION_CONTAINS
        @@@intValue:  0x08
        @@@Description: 
          @@@@lang:en
          @@@@@:
            The node contains the reference node.  A node that 
            contains is always preceding, too.
     @@Const:
        @@@Name:  DOCUMENT_POSITION_CONTAINED_BY
        @@@intValue:  0x10
        @@@Description:
          @@@@lang:en
          @@@@@:
            The node is contained by the reference node. 
            A node that is contained is always following, too.
     @@Const:
        @@@Name:  DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC
        @@@intValue:  0x20
        @@@Description:
          @@@@lang:en
          @@@@@:
            The determination of preceding versus following is 
            implementation-specific.
  @Method:
     @@Name:  compareDocumentPosition
     @@Return:
        @@@Type:  
          DOMMain:unsigned-short||ManakaiDOM|all
        @@@actualType: ManakaiDOMDocumentPosition
        @@@Exception[list]:  DOMException
     @@Param:
        @@@Name:  other
        @@@Type:  Node
     @@Level[list]:  3
     @@SpecLevel:3
     @@For:
       ManakaiDOM:DOM3

  @Attr:
     @@Name:  textContent

     @@Level[list]:
        3
     @@SpecLevel:3

     @@ManakaiDOM:isForInternal:
       @@@@:1
       @@@ForCheck: 
         !ManakaiDOM:DOM3
     @@For:
       ManakaiDOM:ManakaiDOM
     @@For:
       ManakaiDOM:DOM3

     @@Description:
       @@@lang:en
       @@@@:
         The text content of this node and its descendants. 
         Note that element content whitespaces are not considered 
         as the text content of an "Element".
     @@ImplNote:
       @@@lang:en
       @@@@:
         A lot of methods and attributes referrs this attribute 
         by Perl method call or by <Q::DISPerl:cloneCode>. 
       @@@For:
         ManakaiDOM:ManakaiDOM
     @@Get:
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            The text content of this node.
        @@@InCase:
          @@@@Label: Concatenation of the text content of child nodes
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
            For the node of type "Element", "Attr", "Entity", 
            "EntityReference" or "DocumentFragment",  
            concatenation of the "textContent" value of every 
            child node, excluding of type "Comment" or 
            "ProcessingInstruction", is the text content.
        @@@InCase:
          @@@@Label: "nodeValue"
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              For the node of type "Text", "CDATASection", 
              "Comment" or "ProcessingInstruction", the text content 
              is same as the value of the attribute "nodeValue".
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              For the node of type "Document", "DocumentType" or 
              "Notation", the text content is defined to be "null".
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: DOMSTRING_SIZE_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The attribute would return more characters than 
              fit in a "DOMString" variable on the implementation 
              platform.
        @@@PerlDef:
          __CODE{DOMCore:getNodeTextContent::
                           $node => $self,
                           $result => $r}__;
     @@Set:
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            Any child nodes of this node are removed and 
            replaced by a single "Text" node containing the string 
            specified.
          \
            Note that when the "textContent" is defined to be "null", 
            setting the value has no effect.
        @@@InCase:
          @@@@Value:\
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Any child nodes are removed if the value is not defined to 
              be "null".
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: 
              Any child nodes are removed if the value is not defined 
              to be "null".
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: This node is read-only.
        @@@PerlDef:
          __CODE{DOMCore:setNodeTextContent::
                    $node => $self,
                    $given => $given}__;

  @ResourceDef:
    @@QName: getNodeTextContent
    @@aliasChild:1
    @@rdf:type:
      dis2pm:BlockCode
    @@ForCheck:
      ManakaiDOM:ForClass
    @@enDesc:
      Gets a text content of a node.
    @@PerlDef:
      my $__nodeobj = $node->{<Q::TreeCore:node>};
      if ({
             <Q::infoset:Element> => true,
             <Q::infoset:Attribute> => true,
             <Q::DOMXML:Entity> => true,
             <Q::DOMXML:EntityReference> => true,
             <Q::DOMCore:DocumentFragment> => true,
      }->{$__nodeobj->{<Q::DOMCore:nodeType>}}) {
        __DEEP{
          for my $__cno (@{$node->{<Q::TreeCore:node>}
                                ->{<Q::infoset:children>}}) {
            if ($__cno->{<Q::TreeCore:node>}->{<Q::nodeType>}
                   eq <Q::DOMCore:Text>) {
              $result .= $__cno->{<Q::infoset:content>}
                unless $__cno->{<Q::infoset:elementContentWhitespace>};
            } elsif (not {
                  <Q::infoset:Comment> => true,
                  <Q::infoset:ProcessingInstruction> => true,
            }->{$__cno->{<Q::DOMCore:nodeType>}}) {
              my $__cn;
              __CODE{ManakaiNode:getWeakReference||ManakaiDOM:Perl::
                $object => $__cno, $ref => $__cn,
                $class => {{
                  <Q::infoset:Element> => <ClassName::ManakaiDOMElement>,
                  <Q::DOMXML:CDATASection> =>
                              <ClassName::DOMXML:ManakaiDOMCDATASection>,
                  <Q::DOMXML:EntityReference> =>
                           <ClassName::DOMXML:ManakaiDOMEntityReference>,
                }->{$__cno->{<Q::DOMCore:nodeType>}} ||
                <ClassName::ManakaiDOMNode>},
              }__;
              __FOR{ManakaiDOM:DOM3::
                $result .= $__cn-><AG::DOMCore:Node.textContent>;
              }__;
              __FOR{!ManakaiDOM:DOM3::
                $result .= $__cn-><AG::DOMCore:ManakaiDOMNode.textContent>;
              }__;
            }
          }
        }__;
      } elsif ({
          <Q::DOMCore:Text> => true,
          <Q::DOMXML:CDATASection> => true,
          <Q::infoset:Comment> => true,
          <Q::infoset:ProcessingInstruction> => true,
      }->{$__nodeobj->{<Q::DOMCore:nodeType>}}) {
        $result = $__nodeobj->{<Q::infoset:content>};
      } else {
        ## TODO: Namespace node not supported yet
        __ASSERT{DISPerl:invariant::
          msg => {qq{Node type: "$__nodeobj->{<Q::DOMCore:nodeType>}"}}
        }__;
        $result = null;
      }
    @@ImplNote:
      @@@lang:en
      @@@@:
            ISSUE: Element content does not allow non-whitespace 
            character data or CDATA section.  In invalid document, 
            how this is?

  @ResourceDef:
    @@QName: setNodeTextContent
    @@rdf:type:
      dis2pm:BlockCode
    @@Description:
      @@@lang:en
      @@@@:
        Sets a string as the text content of a node.
    @@ForCheck:
      ManakaiDOM:ForClass
    @@PerlDef:
            my $__node = $node->{<Q::TreeCore:node>};
            if ($__node->{<Q::DOMCore:read-only>}) {
              __EXCEPTION{
                MDOMX:NOMOD_THIS::
              }__;
            }
            my @__oldChild = @{$__node->{<Q::infoset:children>}};
            for my $__oc (@__oldChild) {
              CORE::delete $__oc->{<Q::infoset:parent>};
            }
            $__node->{<Q::infoset:children>} = [];
            my $__textNode = <ClassM::DOMCore:ManakaiDOMText.newObject>;
            $__textNode->{<Q::DOMCore:ownerDocument>}
                                   = $__node->{<Q::DOMCore:ownerDocument>};
            $__node-><M::NodeStem.importTree> ($__textNode);
            $__textNode->{<Q::infoset:content>} = $given;
            $__textNode->{<Q::infoset:parent>} = $__node;
            $__node->{<Q::infoset:children>} = [$__textNode];
            for my $__oc (@__oldChild) {
              $__oc-><M::NodeStem.orphanate>;
            }
  @Method:
     @@Name:  isSameNode
     @@Description:
        @@@lang:en
        @@@@:
          Return whether this node is the same node as the given one.
        \
          When two "Node" references are references to the same object, 
          even if through a proxy, the references may be used completely 
          interchangably, such that all attributes have the same values 
          and calling the same method on either reference always has 
          exactly same effect.
     @@Operator:
        @@@@: eq
        @@@ContentType:
          lang:Perl
        @@@For:
          ManakaiDOM:ManakaiDOM
     @@Param:
        @@@Name:  other
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@: The node to test against.
     @@Return:
        @@@Type:  DOMMain|boolean||ManakaiDOM|all
        @@@InCase:
          @@@@Value: true
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The two nodes are the same.
        @@@InCase:
          @@@@Value: false
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The two nodes are not same.
        @@@PerlDef:
            if (UNIVERSAL::isa ($other, <IFName::NodeRef>) and
                $other->{<Q::TreeCore:node>}->{<Q::TreeCore:nodeID>}
                  eq $self->{<Q::TreeCore:node>}->{<Q::TreeCore:nodeID>}) {
              $r = true;
            }
     @@Level[list]:  3
     @@SpecLevel:3
     @@For:
       ManakaiDOM:DOM3
  @Method:
     @@Name:  lookupPrefix
     @@Description:
       @@@lang:en
       @@@@:
         Lookup the namespace prefix associated to the given namespace 
         URI, starting from this node.
       \
         The default namespace declarations are ignored by this method. 
         To lookup default namespace, use the <M::Node.isDefaultNamespace>
         method.
     @@DOMMain:isNamespaceAware:1
     @@Param:
        @@@Name:  namespaceURI
        @@@Type:
          DOMMain:DOMString
        @@@actualType:
          ManakaiDOM:ManakaiDOMNamespaceURI
        @@@Description:
          @@@@lang:en
          @@@@@: The namespace URI to look for.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Always <DOM::null> will be returned.
        @@@InCase:
          @@@@Value:\
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Always <DOM::null> will be returned.
     @@Return:
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            An associated namespace prefix.
          \
            If more than one prefix are associated to the 
            namespace URI, which is returned is implementation 
            dependent.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              No namespace prefix is found.
        @@@PerlDef:
            if (not defined $namespaceURI) {
              $r = null;
            } else {
              my $n = $self->{<Q::TreeCore:node>};
              ANCESTOR: {
                if ($n->{<Q::infoset:parent>}) {
                  $n = $n->{<Q::infoset:parent>};
                  if ($n->{<Q::DOMCore:nodeType>} eq <Q::infoset:Element>) {
                    $r = $n-><M::ManakaiDOMCore:ManakaiDOMNodeObjectNode
                                  .lookupNamespacePrefix> ($namespaceURI, $n);
                    last ANCESTOR;
                  } else {
                    redo ANCESTOR;
                  }
                }
                $r = null;
              } # ANCESTOR
            }
     @@Level[list]:  3
     @@SpecLevel:3
     @@For:
       ManakaiDOM:DOM3
  @Method:
     @@Name:  isDefaultNamespace
     @@Description:
       @@@lang:en
       @@@@:
         Return whether the given namespace URI is the default namespace.
     @@DOMMain:isNamespaceAware:1
     @@Param:
        @@@Name:  namespaceURI
        @@@Type: 
          DOMMain:DOMString
        @@@actualType:
          ManakaiDOM:ManakaiDOMNamespaceURI
        @@@Description:
          @@@@lang:en
          @@@@@:
            The namespace URI to look for.
     @@Return:
        @@@Type:  DOMMain|boolean||ManakaiDOM|all
        @@@InCase:
          @@@@Value:true
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The specified <P::namespaceURI> is the default namespace.
        @@@InCase:
          @@@@Value:false
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The specified <P::namespaceURI> is not the default namespace.
        @@@PerlDef:
            $r = $self->{<Q::TreeCore:node>}
                      -><M::ManakaiDOMCore:ManakaiDOMNodeObjectNode
                              .isDefaultNamespace> ($namespaceURI);
     @@For:
       ManakaiDOM:DOM3
     @@Level[list]:  3
     @@SpecLevel:3
  @Method:
     @@Name:  lookupNamespaceURI
     @@Description:
       @@@lang:en
       @@@@:
         Lookup the namespace URI associated to the given 
         prefix, starting from this node.
     @@DOMMain:isNamespaceAware:1
     @@Param:
        @@@Name:  prefix
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            The prefix to look for.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Return the default namespace URI if any.
     @@Return:
        @@@Type:
          DOMMain:DOMString
        @@@actualType:
          ManakaiDOM:ManakaiDOMNamespaceURI
        @@@Description:
          @@@@lang:en
          @@@@@:
            The associated namespace URI.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              No associated namespace URI found.
        @@@PerlDef:
            $r = $self->{<Q::TreeCore:node>}
                      -><M::ManakaiDOMCore:ManakaiDOMNodeObjectNode
                                    .lookupNamespaceURI> ($prefix);
     @@For:
       ManakaiDOM:DOM3
     @@Level[list]:  3
     @@SpecLevel:3
  @Method:
     @@Name:  isEqualNode
     @@ManakaiDOM:isForInternal:
       @@@@:1
       @@@For:
         !ManakaiDOM:DOM3
     @@For:
       ManakaiDOM:DOM3
     @@For:
       ManakaiDOM:ManakaiDOM
     @@Operator:
       @@@@: ==
       @@@ContentType:
          lang:Perl
       @@@For:
         ManakaiDOM:ManakaiDOM
     @@Description:
       @@@lang:en
       @@@@: 
         Test whether two nodes are equal.
       \
         Two nodes are equal if their node types, node names, 
         contents, attributes and some DOM attributes are equal. 
         Their parent nodes, schema type, user data and some other DOM 
         attributes do not affect equality.  Future versions of 
         DOM may take into account more DOM attributes.
      @@ImplNote:
        @@@lang:en
        @@@@:
          DOM implementations are expected to be updated when 
          future versions of DOM specify to take into 
          account more DOM attributes.
      @@Param:
        @@@Name:  arg
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@: 
            The node to compare equality with.
            \
            {NOTE:: The <P::arg> may or may not be an instance of 
                    the manakai DOM implementation, while: 
              \
              - It implements the feature <Feature::Core> version 
                <FeatureVer::2.0> and, if it is a <IF::DOMXML:DocumentType> 
                node, the feature <Feature::XML> version <Feature::2.0>; 
                to test their equality, as defined by DOM Level 3 Core, 
                some DOM Level 2 attributes are required.
              \
              - It shares the same naming convention for method and 
                attribute names.
              \
              - Its implementation overloads the operator <Perl::==> 
                for <IF::NodeList> and <IF::NamedNodeMap> objects, 
                testing their equality as per DOM Level 3.
              \
            } 
     @@Return:
        @@@Type:  DOMMain|boolean||ManakaiDOM|all
        @@@InCase:
          @@@@Value:true
          @@@@Description:
            @@@@@lang:en
            @@@@@@: Two nodes are equal.
        @@@InCase:
          @@@@Value:false
          @@@@Description:
            @@@@@lang:en
            @@@@@@: Two nodes are not equal.
        @@@PerlDef:
          __DEEP{
            EQ: {
              last EQ unless $self-><AG::Node.nodeType> eq
                             $arg-><AG::Node.nodeType>;
              for my $v ([$self-><AG::Node.nodeName>,
                          $arg-><AG::Node.nodeName>],
                         [$self-><AG::Node.localName>,
                          $arg-><AG::Node.localName>],
                         [$self-><AG::Node.namespaceURI>,
                          $arg-><AG::Node.namespaceURI>],
                         [$self-><AG::Node.prefix>, $arg-><AG::Node.prefix>], 
                         [$self-><AG::Node.nodeValue>, 
                          $arg-><AG::Node.nodeValue>]) {
                if (not defined $v->[0] and not defined $v->[1]) {
                  #
                } elsif (defined $v->[0] and defined $v->[1] and
                         ''.$v->[0] eq ''.$v->[1]) {
                  # 
                } else {
                  last EQ;
                }
              }
              for my $v ([$self-><AG::Node.attributes>, 
                          $arg-><AG::Node.attributes>],
                         [$self-><AG::Node.childNodes>, 
                          $arg-><AG::Node.childNodes>]) {
                if (not defined $v->[0] and not defined $v->[1]) {
                  #
                } elsif (defined $v->[0] and defined $v->[1] and
                         $v->[0] == $v->[1]) {
                  #
                } else {
                  last EQ;
                }
              }
              if ($self-><AG::Node.nodeType> == <C::Node.DOCUMENT_TYPE_NODE>) {
                for my $v ([$self-><AG::DOMXML:DocumentType.publicId>,
                            $arg-><AG::DOMXML:DocumentType.publicId>],
                           [$self-><AG::DOMXML:DocumentType.systemId>, 
                            $arg-><AG::DOMXML:DocumentType.systemId>],
                           [$self-><AG::DOMXML:DocumentType.internalSubset>,
                            $arg-><AG::DOMXML:DocumentType.internalSubset>]) {
                  if (not defined $v->[0] and not defined $v->[1]) {
                    #
                  } elsif (defined $v->[0] and defined $v->[1] and
                           ''.$v->[0] eq ''.$v->[1]) {
                    # 
                  } else {
                    last EQ;
                  }
                }
                for my $v ([$self-><AG::DOMXML:DocumentType.entities>,
                            $arg-><AG::DOMXML:DocumentType.entities>],
                           [$self-><AG::DOMXML:DocumentType.notations>,
                            $arg-><AG::DOMXML:DocumentType.notations>]) {
                  if (not defined $v->[0] and not defined $v->[1]) {
                    #
                  } elsif (defined $v->[0] and defined $v->[1] and
                           $v->[0] == $v->[1]) {
                    #
                  } else {
                    last EQ;
                  }
                }
              }
              $r = true;
            } # EQ
          }__;
    @@Level[list]:  3
    @@SpecLevel:3
    @@For:
      ManakaiDOM:DOM3

  @Method:
     @@Name:  getFeature
     @@enDesc:
       Returns a specialized object that implements the
       specialized interfaces of the specified feature and version.
     @@Param:
        @@@Name:  feature
        @@@Type:  
          DOMMain:DOMString
        @@@actualType: ManakaiDOM|ManakaiDOMFeatureName
        @@@enDesc:
          The feature name to request.
        @@@InCase:
          @@@@Label:
            @@@@@lang:en
            @@@@@@: 
              Feature name preceded by a <CHAR::PLUS SIGN>
          @@@@enDesc:
            The <CHAR::PLUS SIGN> is ignored.
     @@Param:
        @@@Name:  version
        @@@Type:  
          DOMMain:DOMString
        @@@actualType: ManakaiDOM|ManakaiDOMFeatureVersion
        @@@enDesc:
          The feature version to request.
        @@@nullCase:
          @@@@enDesc:
            No specific version is requested.
     @@Level[list]:  3
     @@SpecLevel:3
     @@For:
       ManakaiDOM:DOM3
     @@Return:
        @@@Type:  
          DOMMain:DOMObject
        @@@enDesc:
          An object implementing the specialized interfaces.
          Note that the specialized object may or may not
          implement the <IF::Node> interface.
        @@@nullCase:
          @@@@enDesc:
            There is no object available that implements
            the specialized interfaces.
        @@@disDef:
          @@@@DISLang:nop:
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              Implemented by each inheriting classes.
  @Method:
     @@Name:  setUserData
     @@Return:
        @@@Type:  
          DOMMain:DOMUserData
     @@Param:
        @@@Name:  key
        @@@Type:  
          DOMMain:DOMString
     @@Param:
        @@@Name:  data
        @@@Type:  
          DOMMain:DOMUserData
     @@Param:
        @@@Name:  handler
        @@@Type:  UserDataHandler
     @@L3:
     @@Level[list]:  3
     @@SpecLevel:3
     @@For:
       ManakaiDOM:DOM3
  @Method:
     @@Name:  getUserData
     @@Return:
        @@@Type: 
          DOMMain:DOMUserData
     @@Param:
        @@@Name:  key
        @@@Type:  
          DOMMain:DOMString
     @@L3:
     @@Level[list]:  3
     @@SpecLevel:3
     @@For:
       ManakaiDOM:DOM3

  @IntMethod:
    @@Name: newObject
    @@Description:
      @@@lang:en
      @@@@: 
        Construct an object for a new instance of the <IF::Node>.
    @@Return:
      @@@Type: NodeStem
      @@@Description:
        @@@@lang:en
        @@@@@:
          The object for the <IF::Node> to be created.
      @@@PerlDef:
          my $node = $r = bless <ClassM::ManakaiNode|ManakaiNodeStem||
                                         ManakaiDOM|Perl.new>,
                            <ClassName::ManakaiDOMCore:ManakaiDOMNodeObjectNode>;
          push @{$node->{<Q::TreeCore:irefnode>}}, <Q::DOMCore:ownerDocument>;
          push @{$node->{<Q::TreeCore:anydata2>}}, <Q::DOMEvents:eventListener>;
       @@@ImplNote:
         @@@@lang:en
         @@@@@:
           Other properties required to be a legal <IF::Node> object:
           <Q::DOMCore:nodeType>.
         \
           Optional properties: <Q::infoset:localName>, <Q::infoset:prefix>,
           <Q::DOMCore:ownerDocument> (required for an <IF::Node> whose 
           type is other than <IF::Document> and <IF::DOMXML:DocumentType>), 
           <Q::infoset:namespaceName>, <Q::DOMCore:name>,
           <Q::DOMCore:read-only>.

  @IntMethod:
    @@Name: getNodeReference
    @@Description:
      @@@lang:en
      @@@@:
        Create a new "Node" object blessed with the appropriate class.
      \
        To create a new "Document", use the internal method 
        "newByDocumentType" of the "Document" interface.
    @@Param:
      @@@Name: object
      @@@Type: NodeStem
      @@@Description:
        @@@@lang:en
        @@@@@: The node object referred to.
    @@Return:
      @@@Type: ManakaiDOMNode
      @@@Description:
        @@@@lang:en
        @@@@@: 
          The node reference.  It may implement specialized 
          interfaces for the specific document type or so on. 
      @@@PerlDef:
          my $nt = $object->{<Q::DOMCore:nodeType>};
          my $class;
          FIND: {
          if ($nt eq <Q::infoset:Element>) {
            my $ns;
            my $ln;
            if (defined $object->{<Q::infoset:localName>}) { ## Namespace-aware
              $ns = $object->{<Q::infoset:namespaceName>};
              $ns = '' unless defined $ns;
              $ln = $object->{<Q::infoset:localName>};
            } elsif ($object->{<Q::DOMCore:ownerDocument>}
                            ->{<Q::DOMCore:hasFeature>}->{HTML}) {
              $ns = <Q::xhtml1:>;
              $ln = lc $object->{<Q::DOMCore:name>};
            }
            if (defined $ln) {
              for my $pack ((sort {
                $Message::DOM::ClassPoint{$b} <=> $Message::DOM::ClassPoint{$a}
              } grep {
                $Message::DOM::ManakaiDOMElement::CompatClassET{$ns}
                        ->{$ln}->{$_} and
                $_->isa (<IFName::Element>)
              } keys %{$Message::DOM::ManakaiDOMElement::CompatClassET{$ns}
                               ->{$ln}}),
              (sort {
                $Message::DOM::ClassPoint{$b} <=> $Message::DOM::ClassPoint{$a}
              } grep {
                $Message::DOM::ManakaiDOMElement::CompatClassET{$ns}
                        ->{'*'}->{$_} and
                $_->isa (<IFName::Element>)
              } keys %{$Message::DOM::ManakaiDOMElement::CompatClassET{$ns}
                               ->{'*'}})) {
                $class = $pack;
                last FIND;
              }
            }
            for my $pack (sort {
              $Message::DOM::ClassPoint{$b} <=> $Message::DOM::ClassPoint{$a}
            } grep {
              $Message::DOM::ManakaiDOMElement::CompatClass{$_} and
              $_->isa (<IFName::Element>)
            } keys %{$Message::DOM::ManakaiDOMElement::CompatClass}) {
              $class = $pack;
              last FIND;
            }
            $class = <ClassName::ManakaiDOMElement>;
          } elsif ($nt eq <Q::infoset:Attribute>) {
            ## TODO: Find class by namespace URI and local name
            for my $pack (sort {
              $Message::DOM::ClassPoint{$b} <=> $Message::DOM::ClassPoint{$a}
            } grep {
              $Message::DOM::ManakaiDOMAttr::CompatClass{$_} and
              $_->isa (<IFName::Attr>)
            } keys %{$Message::DOM::ManakaiDOMAttr::CompatClass}) {
              $class = $pack;
              last FIND;
            }
            $class = <ClassName::ManakaiDOMAttr>;
          } elsif ($nt eq <Q::DOMCore:Text>) {
            for my $pack (sort {
              $Message::DOM::ClassPoint{$b} <=> $Message::DOM::ClassPoint{$a}
            } grep {
              $Message::DOM::ManakaiDOMText::CompatClass{$_} and
              $_->isa (<IFName::Text>)
            } keys %{$Message::DOM::ManakaiDOMText::CompatClass}) {
              $class = $pack;
              last FIND;
            }
            $class = <ClassName::ManakaiDOMText>;
          } elsif ($nt eq <Q::infoset:Comment>) {
            for my $pack (sort {
              $Message::DOM::ClassPoint{$b} <=> $Message::DOM::ClassPoint{$a}
            } grep {
              $Message::DOM::ManakaiDOMComment::CompatClass{$_} and
              $_->isa (<IFName::Comment>)
            } keys %{$Message::DOM::ManakaiDOMComment::CompatClass}) {
              $class = $pack;
              last FIND;
            }
            $class = <ClassName::ManakaiDOMComment>;
          } elsif ($nt eq <Q::infoset:Document>) {
            CHILD: for my $co (@{$object->{<Q::infoset:children>}}) {
              ## By root element type
              if ($co->{<Q::DOMCore:nodeType>} eq <Q::infoset:Element>) {
                my $ns;
                my $ln;
                if (defined $co->{<Q::infoset:localName>}) { ## Namespace-aware
                  $ns = $co->{<Q::infoset:namespaceName>};
                  $ns = '' unless defined $ns;
                  $ln = $co->{<Q::infoset:localName>};
                } elsif ($co->{<Q::DOMCore:ownerDocument>}
                            ->{<Q::DOMCore:hasFeature>}->{HTML}) {
                  $ns = <Q::xhtml1:>;
                  $ln = lc $co->{<Q::DOMCore:name>};
                }
                if (defined $ln) {
                  for my $pack ((sort {
                    $Message::DOM::ClassPoint{$b} <=>
                    $Message::DOM::ClassPoint{$a}
                  } grep {
                    $Message::DOM::ManakaiDOMDocument::CompatClassET{$ns}
                        ->{$ln}->{$_} and
                    $_->isa (<IFName::Document>)
                  } keys %{$Message::DOM::ManakaiDOMDocument::CompatClassET{$ns}
                               ->{$ln}}),
                  (sort {
                    $Message::DOM::ClassPoint{$b} <=>
                    $Message::DOM::ClassPoint{$a}
                  } grep {
                    $Message::DOM::ManakaiDOMDocument::CompatClassET{$ns}
                        ->{'*'}->{$_} and
                    $_->isa (<IFName::Document>)
                  } keys %{$Message::DOM::ManakaiDOMDocument::CompatClassET{$ns}
                               ->{'*'}})) {
                    $class = $pack;
                    last FIND;
                  }
                }
                last CHILD; # Not found

              ## By document type or by external subset identifier
              } elsif ($co->{<Q::DOMCore:nodeType>} eq
                       <Q::infoset:DocumentTypeDeclaration>) {

                # Not found --> checking root element
              }
            } # CHILD

            if ($object->{<Q::DOMCore:ownerDocument>}
                       ->{<Q::DOMCore:hasFeature>}->{HTML}) {
              for my $pack ((sort {
                    $Message::DOM::ClassPoint{$b} <=>
                    $Message::DOM::ClassPoint{$a}
              } grep {
                  $Message::DOM::ManakaiDOMDocument::CompatClassET{<Q::xhtml1:>}
                      ->{'*'}->{$_} and
                  $_->isa (<IFName::Document>)
              } keys %{$Message::DOM::ManakaiDOMDocument::CompatClassET{
                               <Q::xhtml1:>}->{'*'}})) {
                $class = $pack;
                last FIND;
              }
            }

            for my $pack (sort {
              $Message::DOM::ClassPoint{$b} <=> $Message::DOM::ClassPoint{$a}
            } grep {
              $Message::DOM::ManakaiDOMDocument::CompatClass{$_} and
              $_->isa (<IFName::Document>)
            } keys %{$Message::DOM::ManakaiDOMDocument::CompatClass}) {
              $class = $pack;
              last FIND;
            }
            $class = <ClassName::ManakaiDOMDocument>;
          } elsif ($nt eq <Q::infoset:ProcessingInstruction>) {
            ## TODO: Find class by namespace URI and local name
            for my $pack (sort {
              $Message::DOM::ClassPoint{$b} <=> $Message::DOM::ClassPoint{$a}
            } grep {
              $Message::DOM::ManakaiDOMProcessingInstruction::CompatClass{$_} and
              $_->isa (<IFName::DOMXML:ProcessingInstruction>)
            } keys %{$Message::DOM::ManakaiDOMProcessingInstruction::CompatClass
            }) {
              $class = $pack;
              last FIND;
            }
            $class = <ClassName::DOMXML:ManakaiDOMProcessingInstruction>;
          } elsif ($nt eq <Q::DOMXML:CDATASection>) {
            for my $pack (sort {
              $Message::DOM::ClassPoint{$b} <=> $Message::DOM::ClassPoint{$a}
            } grep {
              $Message::DOM::ManakaiDOMCDATASection::CompatClass{$_} and
              $_->isa (<IFName::DOMXML:CDATASection>)
            } keys %{$Message::DOM::ManakaiDOMCDATASection::CompatClass}) {
              $class = $pack;
              last FIND;
            }
            $class = <ClassName::DOMXML:ManakaiDOMCDATASection>;
          } elsif ($nt eq <Q::DOMXML:EntityReference>) {
            for my $pack (sort {
              $Message::DOM::ClassPoint{$b} <=> $Message::DOM::ClassPoint{$a}
            } grep {
              $Message::DOM::ManakaiDOMEntityReference::CompatClass{$_} and
              $_->isa (<IFName::DOMXML:EntityReference>)
            } keys %{$Message::DOM::ManakaiDOMEntityReference::CompatClass}) {
              $class = $pack;
              last FIND;
            }
            $class = <ClassName::DOMXML:ManakaiDOMEntityReference>;
          } elsif ($nt eq <Q::DOMCore:DocumentFragment>) {
            for my $pack (sort {
              $Message::DOM::ClassPoint{$b} <=> $Message::DOM::ClassPoint{$a}
            } grep {
              $Message::DOM::ManakaiDOMDocumentFragment::CompatClass{$_} and
              $_->isa (<IFName::DocumentFragment>)
            } keys %{$Message::DOM::ManakaiDOMDocumentFragment::CompatClass}) {
              $class = $pack;
              last FIND;
            }
            $class = <ClassName::ManakaiDOMDocumentFragment>;
          } elsif ($nt eq <Q::infoset:DocumentTypeDeclaration>) {
            for my $pack (sort {
              $Message::DOM::ClassPoint{$b} <=> $Message::DOM::ClassPoint{$a}
            } grep {
              $Message::DOM::ManakaiDOMDocumentType::CompatClass{$_} and
              $_->isa (<IFName::DOMXML:DocumentType>)
            } keys %{$Message::DOM::ManakaiDOMDocumentType::CompatClass}) {
              $class = $pack;
              last FIND;
            }
            $class = <ClassName::DOMXML:ManakaiDOMDocumentType>;
          } elsif ($nt eq <Q::DOMXML:Entity>) {
            for my $pack (sort {
              $Message::DOM::ClassPoint{$b} <=> $Message::DOM::ClassPoint{$a}
            } grep {
              $Message::DOM::ManakaiDOMEntity::CompatClass{$_} and
              $_->isa (<IFName::DOMXML:Entity>)
            } keys %{$Message::DOM::ManakaiDOMEntity::CompatClass}) {
              $class = $pack;
              last FIND;
            }
            $class = <ClassName::DOMXML:ManakaiDOMEntity>;
          } elsif ($nt eq <Q::infoset:Notation>) {
            for my $pack (sort {
              $Message::DOM::ClassPoint{$b} <=> $Message::DOM::ClassPoint{$a}
            } grep {
              $Message::DOM::ManakaiDOMNotation::CompatClass{$_} and
              $_->isa (<IFName::DOMXML:Notation>)
            } keys %{$Message::DOM::ManakaiDOMNotation::CompatClass}) {
              $class = $pack;
              last FIND;
            }
            $class = <ClassName::DOMXML:ManakaiDOMNotation>;
          ## TODO: Namespace
          } else {
            __EXCEPTION{
              MDOMX:MDOM_DEBUG_BUG||ManakaiDOM:Perl::
                MDOMX:values => {{
                  <Q::DOMCore:nodeType> => $nt,
                }},
            }__;
          }
          } # FIND
          __CODE{getNodeRef::
            $object => $object,
            $ref => $r,
            $class => $class,
          }__;

  @IntMethod:
    @@Name: getCoreNodeReference
    @@Description:
      @@@lang:en
      @@@@:
        Create a new "Node" object blessed with the appropriate class.
    @@Param:
      @@@Name: object
      @@@Type: NodeStem
      @@@Description:
        @@@@lang:en
        @@@@@: The node object referred to.
    @@Return:
      @@@Type: ManakaiDOMNode
      @@@Description:
        @@@@lang:en
        @@@@@: The node reference.
      @@@PerlDef:
          my $nt = $object->{<Q::DOMCore:nodeType>};
          my $class;
          if ($nt eq <Q::infoset:Element>) {
            $class = <ClassName::ManakaiDOMElement>;
          } elsif ($nt eq <Q::infoset:Attribute>) {
            $class = <ClassName::ManakaiDOMAttr>;
          } elsif ($nt eq <Q::DOMCore:Text>) {
            $class = <ClassName::ManakaiDOMText>;
          } elsif ($nt eq <Q::infoset:Comment>) {
            $class = <ClassName::ManakaiDOMComment>;
          } elsif ($nt eq <Q::infoset:Document>) {
            $class = <ClassName::ManakaiDOMDocument>;
          } elsif ($nt eq <Q::DOMCore:DocumentFragment>) {
            $class = <ClassName::ManakaiDOMDocumentFragment>;
          } elsif ($nt eq <Q::DOMXML:EntityReference>) {
            $class = <ClassName::DOMXML:ManakaiDOMEntityReference>;
          } elsif ($nt eq <Q::infoset:ProcessingInstruction>) {
            $class = <ClassName::DOMXML:ManakaiDOMProcessingInstruction>;
          } elsif ($nt eq <Q::DOMXML:Entity>) {
            $class = <ClassName::DOMXML:ManakaiDOMEntity>;
          } elsif ($nt eq <Q::DOMXML:CDATASection>) {
            $class = <ClassName::DOMXML:ManakaiDOMCDATASection>;
          } elsif ($nt eq <Q::infoset:Notation>) {
            $class = <ClassName::DOMXML:ManakaiDOMNotation>;
          } else {
            ## TODO: Use assertion
            __EXCEPTION{
              MDOMX:MDOM_DEBUG_BUG||ManakaiDOM:Perl::
                MDOMX:values => {{
                  <Q::DOMCore:nodeType> => $nt,
                }},
            }__;
          }
          __CODE{getNodeRef::
            $object => $object,
            $ref => $r,
            $class => $class,
          }__;
##Node

PropDef:
  @QName: dis|DOM3
  @ImplNote: Temporary.

ElementTypeBinding:
  @Name: RoleDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      DISLang:Role
    @@ForCheck:
      =ManakaiDOM:all

RoleDef:
  @QName: ElementRole
  @enDesc:
    Any class playing this role may be retrievable from 
    <M::Node.getFeature> method of an <IF::Element> node. 

RoleDef:
  @QName: AttributeRole
  @enDesc:
    Any class playing this role may be retrievable from 
    <M::Node.getFeature> method of an <IF::Attr> node. 

RoleDef:
  @QName: TextRole
  @enDesc:
    Any class playing this role may be retrievable from 
    <M::Node.getFeature> method of an <IF::Text> node. 

RoleDef:
  @QName: CommentRole
  @enDesc:
    Any class playing this role may be retrievable from 
    <M::Node.getFeature> method of an <IF::Comment> node. 

RoleDef:
  @QName: DocumentRole
  @enDesc:
    Any class playing this role may be retrievable from 
    <M::Node.getFeature> method of an <IF::Document> node. 

RoleDef:
  @QName: DocumentFragmentRole
  @enDesc:
    Any class playing this role may be retrievable from 
    <M::Node.getFeature> method of an <IF::DocumentFragment> node. 

RoleDef:
  @QName: DocumentTypeRole
  @enDesc:
    Any class playing this role may be retrievable from 
    <M::Node.getFeature> method of an <IF::DOMXML:DocumentType> node. 

RoleDef:
  @QName: EntityRole
  @enDesc:
    Any class playing this role may be retrievable from 
    <M::Node.getFeature> method of an <IF::DOMXML:Entity> node. 

RoleDef:
  @QName: EntityReferenceRole
  @enDesc:
    Any class playing this role may be retrievable from 
    <M::Node.getFeature> method of an <IF::DOMXML:EntityReference> node. 

RoleDef:
  @QName: ProcessingInstructionRole
  @enDesc:
    Any class playing this role may be retrievable from 
    <M::Node.getFeature> method of an <IF::DOMXML:ProcessingInstruction> node. 

RoleDef:
  @QName: NotationRole
  @enDesc:
    Any class playing this role may be retrievable from 
    <M::Node.getFeature> method of a <IF::DOMXML:Notation> node. 

RoleDef:
  @QName: CDATASectionRole
  @enDesc:
    Any class playing this role may be retrievable from 
    <M::Node.getFeature> method of a <IF::DOMXML:CDATASection> node. 

RoleDef:
  @QName: NamespaceRole
  @enDesc:
    Any class playing this role may be retrievable from 
    <M::Node.getFeature> method of a <IF::DOMXPath:Namespace> node. 

RoleDef:
  @QName: AnyNodeRole
  @enDesc:
    Any class playing this role may be retrievable from 
    <M::Node.getFeature> method of a <IF::Node> node. 
  @rdfs:subClassOf: ElementRole
  @rdfs:subClassOf: AttributeRole
  @rdfs:subClassOf: DocumentRole
  @rdfs:subClassOf: DocumentFragmentRole
  @rdfs:subClassOf: DocumentTypeRole
  @rdfs:subClassOf: TextRole
  @rdfs:subClassOf: CommentRole
  @rdfs:subClassOf: EntityRole
  @rdfs:subClassOf: EntityReferenceRole
  @rdfs:subClassOf: NotationRole
  @rdfs:subClassOf: ProcessingInstructionRole
  @rdfs:subClassOf: CDATASectionRole
  @rdfs:subClassOf: NamespaceRole

ClassDef:
  @QName: 
    ManakaiDOMCore:ManakaiDOMNodeObjectNode
  @ISA: ManakaiNode|ManakaiNodeStem||ManakaiDOM|Perl

  @Description:
    @@lang:en
    @@@:
      The extended internal interface for the "ManakaiDOMNodeObject" 
      object used as a "Node".

  @IntMethodC:
    @@Name: contentBaseURI
    @@Description:
      @@@lang:en
      @@@@:
        The base URI by which URI references in the content of 
        this node should be resolved, as per the XML Base Specification.
    @@Param:
      @@@Name:useInfosetProperty
      @@@Type:DOMMain|boolean||ManakaiDOM|all
      @@@Description:
        @@@@lang:en
        @@@@@:
          Whether the <InfosetP::base URI> property of the XML Infoset, 
          if any, should be used to compute the base URI.
    @@Return:
      @@@Type:
        ManakaiDOM:ManakaiDOMURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          The base URI.
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The DOM implementation is unable to obtain an absolute URI.
      @@@PerlDefC:
          $r = null;
          if ($useInfosetProperty and defined $self->{<Q::infoset:baseURI>}) {
            ## Note: In XML Infoset, infoset:Document, 
            ##       infoset:Element and infoset:ProcessingInstruction
            ##       allow infoset:baseURI.  In addition, 
            ##       DOMCore:Entity and DOMCore:EntityReference
            ##       may have it, if it is ManakaiDOM:isExternalEntity,
            ##       in this implementation.
            $r = $self->{<Q::infoset:baseURI>};
          } else {
            if ($self->{<Q::DOMCore:nodeType>} eq <Q::infoset:Element>) {
              if ($self->{<Q::infoset:attributes>}
                       ->{<Q::xml:>}->{'base'}) {
                $r = $self->{<Q::infoset:attributes>}
                          ->{<Q::xml:>}->{'base'}
                          -><M::ManakaiDOMCore:ManakaiDOMNodeObjectNode
                                     .contentBaseURI> ($useInfosetProperty);
              } elsif ($self->{<Q::infoset:attributes>}
                            ->{<Q::ManakaiDOM:noNS>}->{'xml:base'}) {
                $r = $self->{<Q::infoset:attributes>}
                          ->{<Q::ManakaiDOM:noNS>}->{'xml:base'}
                          -><M::ManakaiDOMCore:ManakaiDOMNodeObjectNode
                                     .contentBaseURI> ($useInfosetProperty);
              }
              if (not defined $r and $self->{<Q::infoset:parent>}) {
                $r = $self->{<Q::infoset:parent>}
                          -><M::ManakaiDOMCore:ManakaiDOMNodeObjectNode
                                     .contentBaseURI> ($useInfosetProperty);
              }
            } elsif ($self->{<Q::DOMCore:nodeType>} eq <Q::infoset:Attribute>) {
              if ((defined $self->{<Q::infoset:localName>} and
                   $self->{<Q::infoset:localName>} eq 'base' and
                   defined $self->{<Q::infoset:namespaceName>} and
                   $self->{<Q::infoset:namespaceName>} eq <Q::xml:>) or
                  (not defined $self->{<Q::infoset:localName>} and
                   $self->{<Q::DOMCore:name>} eq 'xml:base')) {
                my $attrcls = <ClassName::ManakaiDOMAttr>;
                $r = <Code::getWeakRef:: $object = $self, $class = $attrcls>
                          -><AG::Attr.value>;
                if (defined $r and
                    <Code::DOMMain:isRelativeDOMURI:: $INPUT = $r>) {
                  if ($self->{<Q::infoset:ownerElement>} and
                      $self->{<Q::infoset:ownerElement>}
                           ->{<Q::infoset:parent>}) {
                    my $base = $self->{<Q::infoset:ownerElement>}
                                    ->{<Q::infoset:parent>}
                                    -><M::ManakaiDOMCore:ManakaiDOMNodeObjectNode
                                            .contentBaseURI>
                                                     ($useInfosetProperty);
                    if (defined $base) {
                      require URI;
                      $r = URI->new_abs ($r, $base)->as_string;
                    } else {
                      $r = null;
                    }
                  } else {
                    $r = null;
                  }
                }
              } else { # not xml:base
                if ($self->{<Q::infoset:ownerElement>}) {
                  $r = $self->{<Q::infoset:ownerElement>}
                            -><M::ManakaiDOMCore:ManakaiDOMNodeObjectNode
                                    .contentBaseURI> ($useInfosetProperty);
                }
              }
            } elsif ({
                       <Q::DOMCore:Text> => 1,
                       <Q::DOMXML:CDATASection> => 1,
                       <Q::infoset:DocumentTypeDeclaration> => 1,
                       <Q::infoset:Comment> => 1,
                       <Q::infoset:ProcessingInstruction> => 1,
                       <Q::DOMXML:Notation> => 1, ## but does not have content
                     }->{$self->{<Q::DOMCore:nodeType>}}) {
              if ($self->{<Q::infoset:parent>}) {
                $r = $self->{<Q::infoset:parent>}
                          -><M::ManakaiDOMCore:ManakaiDOMNodeObjectNode
                                   .contentBaseURI> ($useInfosetProperty);
              }
            } elsif ($self->{<Q::DOMCore:nodeType>} eq <Q::infoset:Document>) {
              ## 2. The base URI of the protocol entity
                # infoset:baseURI
              ## 3. The URI to retrieve the protocol entity
              ## 4. The application defined base URI
              if (defined $self->{<Q::DOMCore:documentURI>} and
                  not <Code::DOMMain:isRelativeDOMURI:: $INPUT = $r>) {
                $r = $self->{<Q::DOMCore:documentURI>};
              }
            } elsif ({
                       <Q::DOMXML:Entity> => 1,
                       <Q::DOMXML:EntityReference> => 1,
                     }->{$self->{<Q::DOMCore:nodeType>}}) {
              if ($self->{<Q::ManakaiDOM:isExpanded>}) {
                if ($self->{<Q::ManakaiDOM:isExternalEntity>}) {
                  ## 2. The base URI of the protocol entity
                    # infoset:baseURI
                  ## 3. The URI to retrieve the protocol entity
                  ## 4. The application defined base URI
                  if (defined $self->{<Q::DOMCore:documentURI>} and
                      not <Code::DOMMain:isRelativeDOMURI:: $INPUT = $r>) {
                    $r = $self->{<Q::DOMCore:documentURI>};
                  }
                  ## Should infoset:systemIdentifier +
                  ## infoset:declarationBaseURI also be used?
                }
              } else {
                if ($self->{<Q::infoset:parent>}) {
                  $r = $self->{<Q::infoset:parent>}
                            -><M::ManakaiDOMCore:ManakaiDOMNodeObjectNode
                                    .contentBaseURI> ($useInfosetProperty);
                }
              }
            } else {
              # DOMCore:DocumentFragment or 
              # unknown node types
            }
          }
    @@ImplNote:
      @@@lang:en
      @@@@:
        This internal method assumes that the document is an XML 
        document and the base URI is computed by the XML Base 
        Specification.
    @@ImplNote:
      @@@lang:en
      @@@@:
        ISSUE: More study required for the base URI of document type- 
        or entity-related node types.
  @IntMethodC:
    @@Name:htmlBaseURI
    @@Description:
      @@@lang:en
      @@@@:
        Return the base URI, as the document is an HTML document.
    @@Return:
      @@@Type:
        ManakaiDOM:ManakaiDOMURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          An absolute URI.  Although the HTML 4 Specification 
          refers the RFC 2396, the return value is a DOM URI 
          (URI reference, IRI reference or some other identifier), 
          if the source document is broken (see HTML 4 Appendix) or 
          the base URI is provided from the source other than 
          the content of the HTML document (ex. the DOM URI 
          used to retrieve the document or the value of 
          the <A::Document.documentURI>).
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The DOM implementation was not able to obtain an 
            absolute URI.
      @@@PerlDefC:
          $r = null;
          my $doc = $self->{<Q::TreeCore:node>}->{<Q::DOMCore:ownerDocument>};
          if ($doc and $doc->{<Q::DOMCore:hasFeature>}->{HTML}) {
            HTML: {
              DOC: for (@{$doc->{<Q::infoset:children>}}) {
                if ($_->{<Q::DOMCore:nodeType>} eq <Q::infoset:Element> and
                    (defined $_->{<Q::infoset:localName>} and
                     $_->{<Q::infoset:localName>} eq 'html' and
                     ((defined $_->{<Q::infoset:namespaceName>} and
                       $_->{<Q::infoset:namespaceName>} eq <Q::xhtml1:>) or
                      not defined $_->{<Q::infoset:namespaceName>})) or
                    (not defined $_->{<Q::infoset:localName>} and
                     $_->{<Q::DOMCore:name>} eq 'html')) {
                  for (@{$_->{<Q::infoset:children>}}) {
                    if ($_->{<Q::DOMCore:nodeType>} eq <Q::infoset:Element> and
                        (defined $_->{<Q::infoset:localName>} and
                         $_->{<Q::infoset:localName>} eq 'head' and
                         ((defined $_->{<Q::infoset:namespaceName>} and
                           $_->{<Q::infoset:namespaceName>} eq <Q::xhtml1:>) or
                          not defined $_->{<Q::infoset:namespaceName>})) or
                        (not defined $_->{<Q::infoset:localName>} and
                         $_->{<Q::DOMCore:name>} eq 'head')) {
                      for (@{$_->{<Q::infoset:children>}}) {
                        if ($_->{<Q::DOMCore:nodeType>} eq <Q::infoset:Element> and
                            (defined $_->{<Q::infoset:localName>} and
                             $_->{<Q::infoset:localName>} eq 'base' and
                             ((defined $_->{<Q::infoset:namespaceName>} and
                               $_->{<Q::infoset:namespaceName>} eq <Q::xhtml1:>) or
                              not defined $_->{<Q::infoset:namespaceName>})) or
                            (not defined $_->{<Q::infoset:localName>} and
                             $_->{<Q::DOMCore:name>} eq 'base')) {
                          my $a = $_->{<Q::infoset:attributes>}
                                    ->{<Q::null:>}->{href} ||
                                  $_->{<Q::infoset:attributes>}
                                    ->{<Q::ManakaiDOM:noNS>}->{href};
                          if ($a) {
                            my $ac = <ClassName::ManakaiDOMAttr>;
                            $r = <Code::getWeakRef:: $object = $a, $class = $ac>
                                      -><AG::Attr.value>;
                            unless (<Code::DOMMain:isRelativeDOMURI::
                                             $INPUT = $r>) {
                              $r = null;
                            } else {
                              last HTML;
                            }
                          }
                          last DOC;
                        }
                      }
                      last DOC;
                    }
                  }
                  last DOC;
                }
              } # DOC
              if (defined $doc->{<Q::infoset:baseURI>}) {
                $r = $doc->{<Q::infoset:baseURI>};
                $r = null if <Code::DOMMain:isRelativeDOMURI:: $INPUT = $r>;
              } elsif (defined $doc->{<Q::DOMCore:documentURI>}) {
                $r = $doc->{<Q::DOMCore:documentURI>};
                $r = null if <Code::DOMMain:isRelativeDOMURI:: $INPUT = $r>;
              }
            } # HTML
          }
       @@@@ImplNote:
         @@@@@lang:en
         @@@@@@:
           TODO: <HA::codebase> attribute should be considered by option.
       @@@@ImplNote:
         @@@@@lang:en
         @@@@@@:
           ISSUE: How treat base URI of <IF::DOMXML:DocumentType>, ...
  @IntMethodC:
    @@Name:lookupNamespacePrefix
    @@Description:
      @@@lang:en
      @@@@:
        Lookup the namespace prefix associated to the given namespace URI. 
        This node must be of type <IF::Element>. 
    @@ImplNote:
      @@@lang:en
      @@@@:
        This internal method implements the <DOM::lookupNamespacePrefix> 
        <SRC::<CITE::DOM Level 3 Core Specification>
        <sw010:csection::B.2 Namespace Prefix Lookup>>.
    @@Param:
      @@@Name:namespaceURI
      @@@Type:
        ManakaiDOM:ManakaiDOMNamespaceURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          The namespace URI.  <DOM::null> is not allowed; it must be 
          checked before the call of this internal method.
    @@Param:
      @@@Name:originalElement
      @@@Type:
        ManakaiDOMCore:ManakaiDOMNodeObjectNode
      @@@Description:
        @@@@lang:en
        @@@@@:
          The element node object to which the original request to lookup the 
          <P::namespaceURI> is issued.
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The original node the request is issued is not an <IF::Element> node.
    @@Return:
      @@@Type: 
        @@@@@:
          DOMMain:ManakaiDOMNamespacePrefix
        @@@@ManakaiDOM:noInputNormalize:
          @@@@@@:1
          @@@@@ImplNote:
            @@@@@@lang:en
            @@@@@@@: An empty prefix should not be passed.
      @@@Description:
        @@@@lang:en
        @@@@@: The namespace prefix.
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The associated namespace prefix does not found.
      @@@PerlDefC:
          $r = null;
          FIND: {
          if ($originalElement) {
            if (defined $self->{<Q::infoset:namespaceName>} and
                $self->{<Q::infoset:namespaceName>} eq $namespaceURI and
                defined $self->{<Q::infoset:prefix>} and
                $originalElement-><M::ManakaiDOMCore:ManakaiDOMNodeObjectNode
                                         .lookupNamespaceURI>
                      ($self->{<Q::infoset:prefix>}) eq $namespaceURI) {
              $r = $self->{<Q::infoset:prefix>};
              last FIND;
            }
            my $ac = <ClassName::ManakaiDOMAttr>;
            for (values %{$self->{<Q::infoset:attributes>}->{<Q::xmlns:>}||{}}) {
              if (defined $_->{<Q::infoset:prefix>} and
                  $_->{<Q::infoset:prefix>} eq 'xmlns' and
                  <Code::getWeakRef:: $object = $_, $class = $ac>
                    -><AG::Attr.value> eq $namespaceURI and
                  $originalElement-><M::ManakaiDOMCore:ManakaiDOMNodeObjectNode
                                            .lookupNamespaceURI>
                            ($_->{<Q::infoset:localName>}) eq $namespaceURI) {
                $r = $_->{<Q::infoset:localName>};
                last FIND;
              }
            }
          }
            ## If element has ancestor element
            my $n = $self;
            ANCESTOR: {
              if ($n->{<Q::infoset:parent>}) {
                $n = $n->{<Q::infoset:parent>};
                if ($n->{<Q::DOMCore:nodeType>} eq <Q::infoset:Element>) {
                  $r = $n-><M::ManakaiDOMCore:ManakaiDOMNodeObjectNode
                                        .lookupNamespacePrefix>
                                             ($namespaceURI, $originalElement);
                  last FIND;
                } else {
                  redo ANCESTOR;
                }
              }
            }
          } # FIND
     @@ImplNote:
       @@@lang:en
       @@@@:
         Before returning found prefix, the algorithm needs to make 
         sure that the prefix is not redefined.  This is why 
         <P::originalElement> is required.
  @IntMethodC:
    @@Name:isDefaultNamespace
    @@Description:
      @@@lang:en
      @@@@:
        Return whether the given namespace URI is the 
        default namespace.
    @@ImplNote:
      @@@lang:en
      @@@@:
        This internal method implements the <DOM::isDefaultNamespace> 
        <SRC::<CITE::DOM Level 3 Core Specification> 
        <sw010:csection::B.3 Default Namespace Lookup>>.
    @@Param:
      @@@Name:namespaceURI
      @@@Type:
        @@@@@:
          ManakaiDOM:ManakaiDOMNamespaceURI
        @@@@ManakaiDOM:noInputNormalize:
          @@@@@@:1
          @@@@@ImplNote:
            @@@@@@lang:en
            @@@@@@@: An empty namespace URI should not be passed in DOM Level 2.
      @@@Description:
        @@@@lang:en
        @@@@@: The namespace URI to look for.
    @@Return:
      @@@Type:DOMMain|boolean||ManakaiDOM|all
      @@@PerlDefC:
          if ($self->{<Q::DOMCore:nodeType>} eq <Q::infoset:Element>) {
            if (not defined $self->{<Q::infoset:prefix>}) {
              if (defined $namespaceURI and
                  defined $self->{<Q::infoset:namespaceName>} and
                  $namespaceURI eq $self->{<Q::infoset:namespaceName>}) {
                $r = true;
              } elsif (not defined $namespaceURI and
                       not defined $self->{<Q::infoset:namespaceName>}) {
                $r = true;
              }
              # else false
            } elsif ($self->{<Q::infoset:attributes>}
                          ->{<Q::infoset:xmlns:>}->{xmlns}) {
              my $vo = $self->{<Q::infoset:attributes>}
                            ->{<Q::infoset:xmlns:>}->{xmlns};
              my $ac = <ClassName::ManakaiDOMAttr>;
              my $v = <Code::getWeakRef:: $object = $vo, $class = $ac>
                           -><AG::Attr.value>;
              if (defined $namespaceURI and $namespaceURI eq $v) {
                $r = true;
              } elsif (not defined $namespaceURI and not length $v) {
                $r = true;
              }
              # else false
            } else {
              ## If element has ancestor element
              my $n = $self;
              ANCESTOR: {
                if ($n->{<Q::infoset:parent>}) {
                  $n = $n->{<Q::infoset:parent>};
                  if ($n->{<Q::DOMCore:nodeType>} eq <Q::infoset:Element>) {
                    $r = $n-><M::ManakaiDOMCore:ManakaiDOMNodeObjectNode
                                   .isDefaultNamespace> ($namespaceURI);
                    last ANCESTOR;
                  } else {
                    redo ANCESTOR;
                  }
                }
                # false
              }
            }
          } elsif ($self->{<Q::DOMCore:nodeType>} eq <Q::infoset:Document>) {
            for (@{$self->{<Q::infoset:children>}}) {
              if ($_->{<Q::DOMCore:nodeType>} eq <Q::infoset:Element>) {
                $r = $_-><M::ManakaiDOMCore:ManakaiDOMNodeObjectNode
                                .isDefaultNamespace> ($namespaceURI);
                last;
              }
            }
          } elsif ($self->{<Q::DOMCore:nodeType>} eq <Q::infoset:Attribute>) {
            if ($self->{<Q::infoset:ownerElement>}) {
              $r = $self->{<Q::infoset:ownerElement>}
                        -><M::ManakaiDOMCore:ManakaiDOMNodeObjectNode
                                .isDefaultNamespace> ($namespaceURI);
              last FIND;
            }
          } elsif ({
                     <Q::DOMXML:Entity> => 1,
                     <Q::DOMXML:Notation> => 1,
                     <Q::DOMXML:DocumentType> => 1,
                     <Q::DOMCore:DocumentFragment> => 1,
                   }->{$self->{<Q::DOMCore:nodeType>}}) {
            #
          } else {
          #} elsif ({
          #           < Q::DOMCore:Text> => 1,
          #           < Q::DOMCore:Comment> => 1,
          #           < Q::DOMXML:EntityReference> => 1,
          #           < Q::DOMXML:CDATASection> => 1,
          #           < Q::infoset:ProcessingInstruction> => 1,
          #         }->{$self->{< Q::DOMCore:nodeType>}}) {
            ## If node has ancestor element
            my $n = $self;
            ANCESTOR: {
              if ($n->{<Q::infoset:parent>}) {
                $n = $n->{<Q::infoset:parent>};
                if ($n->{<Q::DOMCore:nodeType>} eq <Q::infoset:Element>) {
                  $r = $n-><M::ManakaiDOMCore:ManakaiDOMNodeObjectNode
                                .isDefaultNamespace> ($namespaceURI);
                  last ANCESTOR;
                } else {
                  redo ANCESTOR;
                }
              }
              # false
            }
          } # nodeType
  @IntMethodC:
    @@Name:lookupNamespaceURI
    @@Description:
      @@@lang:en
      @@@@:
        Lookup the namespace URI associated to the given prefix.
    @@ImplNote:
      @@@lang:en
      @@@@:
        This internal method implements the <DOM::lookupNamespaceURI> 
        <SRC::<CITE::DOM Level 3 Core Specification> 
        <sw010:csection::B.4 Namespace URI Lookup>>.
    @@Param:
      @@@Name:prefix
      @@@Type:
        @@@@@:
          DOMMain:ManakaiDOMNamespacePrefix
        @@@@ManakaiDOM:noInputNormalize:
          @@@@@@:1
          @@@@@ImplNote:
            @@@@@@lang:en
            @@@@@@@: An empty namespace prefix should not be specified.
      @@@Description:
        @@@@lang:en
        @@@@@: The namespace prefix.
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@: Look for the default namespace URI.
    @@Return:
      @@@Type:
        ManakaiDOM:ManakaiDOMNamespaceURI
      @@@Description:
        @@@@lang:en
        @@@@@: The namespace URI.
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@: No namespace URI associated.
      @@@PerlDefC:
          $r = null;
          FIND: {
          if ($self->{<Q::DOMCore:nodeType>} eq <Q::infoset:Element>) {
            if (defined $self->{<Q::infoset:localName>} and
                defined $self->{<Q::infoset:namespaceName>} and
                ((defined $self->{<Q::infoset:prefix>} and defined $prefix and
                  $self->{<Q::infoset:prefix>} eq $prefix) or
                 (not defined $self->{<Q::infoset:prefix>} and
                  not defined $prefix))) {
              $r = $self->{<Q::infoset:namespaceName>};
              last FIND;
            }
            my $ac = <ClassName::ManakaiDOMAttr>;
            for (values %{$self->{<Q::infoset:attributes>}->{<Q::xmlns:>}||{}}) {
              if (defined $_->{<Q::infoset:prefix>} and defined $prefix and
                  $_->{<Q::infoset:prefix>} eq 'xmlns' and
                  $_->{<Q::infoset:localName>} eq $prefix) {
                ## Non default namespace
                $r = <Code::getWeakRef:: $object = $_, $class = $ac>
                          -><AG::Attr.value>;
                $r = null unless length $r;
                last FIND;
              } elsif (not defined $prefix and
                       $_->{<Q::infoset:localName>} eq 'xmlns') {
                ## Default namespace
                $r = <Code::getWeakRef:: $object = $_, $class = $ac>
                          -><AG::Attr.value>;
                $r = null unless length $r;
                last FIND;
              }
            }
            ## If element has ancestor element
            my $n = $self;
            ANCESTOR: {
              if ($n->{<Q::infoset:parent>}) {
                $n = $n->{<Q::infoset:parent>};
                if ($n->{<Q::DOMCore:nodeType>} eq <Q::infoset:Element>) {
                  $r = $n-><M::ManakaiDOMCore:ManakaiDOMNodeObjectNode
                                  .lookupNamespaceURI> ($prefix);
                  last FIND;
                } else {
                  redo ANCESTOR;
                }
              }
            }
          } elsif ($self->{<Q::DOMCore:nodeType>} eq <Q::infoset:Document>) {
            for (@{$self->{<Q::infoset:children>}}) {
              if ($_->{<Q::DOMCore:nodeType>} eq <Q::infoset:Element>) {
                $r = $_-><M::ManakaiDOMCore:ManakaiDOMNodeObjectNode
                               .lookupNamespaceURI> ($prefix);
                last FIND;
              }
            }
          } elsif ($self->{<Q::DOMCore:nodeType>} eq <Q::infoset:Attribute>) {
            if ($self->{<Q::infoset:ownerElement>}) {
              $r = $self->{<Q::infoset:ownerElement>}
                        -><M::ManakaiDOMCore:ManakaiDOMNodeObjectNode
                                 .lookupNamespaceURI> ($prefix);
              last FIND;
            }
          } elsif ({
                     <Q::DOMXML:Entity> => 1,
                     <Q::DOMXML:Notation> => 1,
                     <Q::DOMXML:DocumentType> => 1,
                     <Q::DOMCore:DocumentFragment> => 1,
                   }->{$self->{<Q::DOMCore:nodeType>}}) {
            #
          } else {
          #} elsif ({
          #           < Q::DOMCore:Text> => 1,
          #           < Q::DOMCore:Comment> => 1,
          #           < Q::DOMXML:EntityReference> => 1,
          #           < Q::DOMXML:CDATASection> => 1,
          #           < Q::infoset:ProcessingInstruction> => 1,
          #         }->{$self->{< Q::DOMCore:nodeType>}}) {
            ## If node has ancestor element
            my $n = $self;
            ANCESTOR: {
              if ($n->{<Q::infoset:parent>}) {
                $n = $n->{<Q::infoset:parent>};
                if ($n->{<Q::DOMCore:nodeType>} eq <Q::infoset:Element>) {
                  $r = $n-><M::ManakaiDOMCore:ManakaiDOMNodeObjectNode
                                .lookupNamespaceURI> ($prefix);
                  last FIND;
                } else {
                  redo ANCESTOR;
                }
              }
            }
          } # nodeType
          } # FIND
      @@@ImplNote:
        @@@@lang:en
        @@@@@:
          Non namespace-aware nodes are ignored <SRC::DOM 3>.
  @IntMethodC:
    @@Name:getElementBy
    @@Description:
      @@@lang:en
      @@@@:
        Return an element that met the given condition.
    @@Param:
      @@@Name:check
      @@@Type:
        perl:CODE::ManakaiDOM:all
      @@@Description:
        @@@@lang:en
        @@@@@:
          A code reference.  The code referred is called with a 
          parameter of this <Class::ManakaiDOMCore|ManakaiDOMNodeObjectNode>
          object when an <IF::Element> node is determined whether it could 
          be returned.  The code should return either <DOM::true> or 
          <DOM::false>.
    @@Param:
      @@@Name:index
      @@@Type:
        perl:SCALAR::ManakaiDOM:all
      @@@Description:
        @@@@lang:en
        @@@@@:
          A reference to the ordinal index of the element to return.
      @@@In:1
      @@@Out:
        @@@@@:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The number of <IF::Element> nodes with which <P::check> has 
            returned <DOM::true> is minused from the original value. 
            \
            For example, if the original <P::index> is <CODE::4> and 
            there is three <P::check>-<DOM::true> <IF::Element> nodes, 
            then <P::index> would result in <CODE:1> and this method 
            itself would return <DOM::null>.  If there is five (or more)
            such nodes, 
            <P::index> would be <CODE:-1> and the return value would be 
            the fiveth matching node.
      @@@InCase:
        @@@@intValue:0
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The first <IF::Element> node with which <P::check> has returned 
            <DOM::true> is returned.
    @@Return:
      @@@Type:
        ManakaiDOMCore:ManakaiDOMNodeObjectNode
      @@@Description:
        @@@@lang:en
        @@@@@:
          The <IF::Element> node that met the condition.
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:There is no such node.
      @@@PerlDefC:
          for (@{$self->{<Q::infoset:children>}||[]}) {
            last if $$index < 0;
            if ($_->{<Q::DOMCore:nodeType>} eq <Q::infoset:Element>) {
              if ($check->($_)) {
                if ($$index-- == 0) {
                  $r = $_;
                  last;
                }
              }
              $r = $_-><M::ManakaiDOMCore:ManakaiDOMNodeObjectNode.getElementBy>
                          ($check, $index);
              last if $$index == -1;
            } elsif ({
                       <Q::DOMXML:EntityReference> => 1,
                     }->{$_->{<Q::DOMCore:nodeType>}}) {
              $r = $_-><M::ManakaiDOMCore:ManakaiDOMNodeObjectNode.getElementBy>
                         ($check, $index);
              last if $$index == -1;
            }
          }
  @IntMethodC:
    @@Name:getElementsBy
    @@Description:
      @@@lang:en
      @@@@:
        Return descendant elements that met the given condition.
    @@Param:
      @@@Name:check
      @@@Type:
        perl:CODE::ManakaiDOM:all
      @@@Description:
        @@@@lang:en
        @@@@@:
          A code reference.  The code referred is called with a 
          parameter of this <Class::ManakaiDOMCore|ManakaiDOMNodeObjectNode>
          object when an <IF::Element> node is determined whether it could 
          be returned.  The code should return either <DOM::true> or 
          <DOM::false>.
    @@Return:
      @@@Type:
        perl:ARRAY::ManakaiDOM:all
      @@@Description:
        @@@@lang:en
        @@@@@:
          An array reference to the <IF::Element> nodes that meet the condition.
      @@@PerlDefC:
          $r = [];
          for (@{$self->{<Q::infoset:children>}||[]}) {
            if ($_->{<Q::DOMCore:nodeType>} eq <Q::infoset:Element>) {
              if ($check->($_)) {
                push @$r, $_;
              }
         \    push @$r,
         \         @{$_-><M::ManakaiDOMCore:ManakaiDOMNodeObjectNode
         \                        .getElementsBy> ($check)};
            } elsif ({
                       <Q::DOMXML:EntityReference> => 1,
                     }->{$_->{<Q::DOMCore:nodeType>}}) {
         \    push @$r,
         \         @{$_-><M::ManakaiDOMCore:ManakaiDOMNodeObjectNode
         \                        .getElementsBy> ($check)};
            }
          }


    @ResourceDef:
      @@QName:
        DOMCore:getDocumentXMLVersion
      @@rdf:type:
        dis2pm:InlineCode
      @@Description:
        @@@lang:en
        @@@@: 
          Returns the XML version of a document.  If the document 
          does not support the <Feature::XML> feature, 
          <DOM::null> is returned.
      @@PerlDefC:
        ($DOCOBJ->{<Q::DOMCore:hasFeature>}->{XML}
             ? CORE::defined $DOCOBJ->{<Q::infoset:version>}
                   ? $DOCOBJ->{<Q::infoset:version>}
                   : '1.0'
             : null)

  @IntMethodC:
    @@Name: isEqualNode
    @@Operator:
      @@@@: ==
      @@@ContentType:
        lang:Perl
    @@Description:
      @@@lang:en
      @@@@:
        Checks whether this node and another node are equal or not. 
    @@Param:
      @@@Name: node
      @@@Type: 
        ManakaiDOMCore:ManakaiDOMNodeObjectNode
      @@@Description:
        @@@@lang:en
        @@@@@: Another node object to compare.
    @@Return:
      @@@Type:DOMMain|boolean||ManakaiDOM|all
      @@@InCase:
        @@@@Value:true
        @@@@Description:
          @@@@@lang:en
          @@@@@@: Two nodes are equal.
      @@@InCase:
        @@@@Value:false
        @@@@Description:
          @@@@@lang:en
          @@@@@@: Two nodes are not equal.
      @@@PerlDefC:
         my $nodeclass = <ClassName::ManakaiDOMNode>;
         $r = <M::DOMCore:ManakaiDOMNode.isEqualNode>
                (<Code::getWeakRef:: $object = $self,
                                                 $class = $nodeclass>,
                 <Code::getWeakRef:: $object = $node,
                                                 $class = $nodeclass>);

  @IntMethodC:
    @@Name:normalizeText
    @@Description:
      @@@lang:en
      @@@@:
        Puts all <IF::Text> nodes in the full depth of the subtree 
        underneath this node object, including attribute nodes attached 
        to the element nodes, into a <QUOTE::normalized> form where 
        only structure such as XML tags separates text nodes, i.e. 
        there are neither adjacent text nodes nor empty text nodes. 
        (For the support of DOM Level 1 <M::Element||ManakaiDOM|ManakaiDOM1
        .normalize> and DOM levels 2 and 3 <M::Node.normalize>.) 
        \
        In addition, this method may also normalize text nodes in the subtree, 
        i.e. the characters of the text nodes will be fully normalized. 
        (For the support of DOM Level 3 <M::Node.normalize> with the 
        configuration parameter <CP::normalize-characters> turned on.)
     @@Param:
       @@@Name:fullyNormalize
       @@@Type:DOMMain|boolean||ManakaiDOM|all
       @@@Description:
         @@@@lang:en
         @@@@@:
           Whether the characters in the text nodes in the subtree  
           should be fully normalized or not. 
     @@Param:
       @@@Name:isDescendant
       @@@Type:
         DOMMain:boolean||ManakaiDOM|all
       @@@Description:
         @@@@lang:en
         @@@@@:
           Whether this node is a descendant of the node to normalize or not. 
       @@@InCase:
         @@@@Value:true
         @@@@Description:
           @@@@@lang:en
           @@@@@@:
             This node is a descendant (or an attribute and 
             an descendant of attribute of the root or its descendant)
             of the node. 
       @@@InCase:
         @@@@Value:false
         @@@@Description:
           @@@@@lang:en
           @@@@@@:
             This node is the node to normalize. 
   @@Return:
       @@@Exception:
         @@@@@:
           MDOMX:NOMOD_THIS
         @@@@Description:
           @@@@@lang:en
           @@@@@@:
             This node is read-only. 
       @@@Exception:
         @@@@@:NOMOD_DESCENDANT_ERR
         @@@@Description:
           @@@@@lang:en
           @@@@@@:
             One of descendant (or attribute) is read-only. 
     @@@PerlDefC:
       @@@@@:
         if (@{$self->{<Q::infoset:children>}||[]}) {
           my @new;
           my $changed = false;
           my @change;
           my @removed;
           my $pchild;
           for my $child (@{$self->{<Q::infoset:children>}}) {
             if ($self->{<Q::DOMCore:nodeType>} eq <Q::DOMCore:Text>) {
               if (length $child->{<Q::infoset:content>}) {
                 if ($pchild) {
                   if ($self->{<Q::DOMCore:read-only>}) {
                     if ($isDescendant) {
                       __EXCEPTION{NOMOD_DESCENDANT_ERR::
                         DOMCore:nodeObject => {$self},
                       }__;
                     } else {
                       __EXCEPTION{MDOMX:NOMOD_THIS::
                         DOMCore:nodeObject => {$self},
                       }__;
                     }
                   } elsif ($pchild->{<Q::DOMCore:read-only>}) {
                     if ($child->{<Q::DOMCore:read-only>}) {
                       ## Creates a new node
                       my $text = <ClassM::ManakaiDOMText.newObject>;
                       $self-><M::NodeStem.importTree> ($text);
                       push @change, [$text, 'append', $pchild];
                       push @change, [$text, 'append', $child];
                       $text->{<Q::infoset:content>} = '';
                       $text->{<Q::DOMCore:ownerDocument>}
                                    = $child->{<Q::DOMCore:ownerDocument>};
                       $text->{<Q::infoset:parent>} = $self;
                       push @removed, $pchild, $child;
                       $pchild = $text;
                       push @new, $text;
                       $changed = true;
                     } else {
                       push @change, [$child, 'prepend', $pchild];
                       push @removed, $pchild;
                       $pchild = $child;
                       pop @new;
                       push @new, $child;
                       $changed = true;
                     }
                   } else {
                     push @change, [$pchild, 'append', $child];
                     push @removed, $child;
                     $changed = true;
                   }
                 } else {
                   $pchild = $child;
                   push @new, $child;
                 }
               } else { # length zero
                 if ($self->{<Q::DOMCore:read-only>}) {
                   if ($isDescendant) {
                     __EXCEPTION{NOMOD_DESCENDANT_ERR::
                       DOMCore:nodeObject => {$self},
                     }__;
                   } else {
                     __EXCEPTION{MDOMX:NOMOD_THIS::
                       DOMCore:nodeObject => {$self},
                     }__;
                   }
                 }
                 push @removed, $child;
                 $changed = true;
               }
             } elsif ({
                         <Q::infoset:Element> => 1,
                         <Q::DOMXML:EntityReference> => 1,
                      }->{$self->{<Q::DOMCore:nodeType>}}) {
               $pchild = null;
               push @new, $child;
               __DEEP{
                 $child-><M::ManakaiDOMCore:ManakaiDOMNodeObjectNode
                                       .normalizeText> ($fullyNormalize, true);
               }__;
             } else {
               $pchild = null;
               push @new, $child;
             }
           }

           if ($changed) {
             ## NOTE: Actual changes made here, to avoid breaking data 
             ##       when some of children are read-only. 
             for (@change) {
               if ($_->[1] eq 'append') {
                 $_->[0]->{<Q::infoset:content>}
                     .= $_->[2]->{<Q::infoset:content>};
               } elsif ($_->[1] eq 'preprend') {
                 $_->[0]->{<Q::infoset:content>}
                      = $_->[1]->{<Q::infoset:content>} . 
                        $_->[0]->{<Q::infoset:content>};
               } else {
                 __ASSERT{DISPerl:invariant::
                   msg => {qq{Normalizing operation "$_->[1]"}},
                 }__;
               }
             }
  
             for (@removed) {
               CORE::delete $_->{<Q::infoset:parent>};
               $_-><M::NodeStem.orphanate>;
             }
   
             $self->{<Q::infoset:children>} = \@new;

             ## infoset:specified should turn on if normalization occured.
             ## Otherwise, infoset does not change so that no change required. 
           }
         }

         if ($self->{<Q::DOMCore:nodeType>} eq <Q::infoset:Attribute>) {
           for (values %{$self->{<Q::infoset:attribute>}}) {
             for (values %$_) {
               $_-><M::ManakaiDOMCore:ManakaiDOMNodeObjectNode
                                       .normalizeText> ($fullyNormalize, true);
             }
           }
         }

         \## TODO: Normalization
       @@@@ImplNote:
         @@@@@lang:en
         @@@@@@:
           {NOTE:: Read-only status must not be changed by others
                   during this process.
           \
           }
    @@ImplNote:
      @@@lang:en
      @@@@:
        Normalization should be done after the merge of adjacent 
        text nodes, since the merge might change the status 
        of normalization. 
##ManakaiDOMNodeObjectNode

ElementTypeBinding:
  @Name: actualType
  @ElementType:
    dis:actualType
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass

ForDef:
  @QName:
    DOMCore:ForChildNodeList
  @Description:
    @@lang:en
    @@@:
      For <Class::ManakaiDOMCore:ManakaiDOMChildNodeList> class.
  @ISA: ManakaiDOM|ForClass

ForDef:
  @QName:
    DOMCore:ForGetNodeList
  @Description:
    @@lang:en
    @@@:
      For <Class::ManakaiDOMCore:ManakaiDOMGetElementsNodeList> class.
  @ISA: ManakaiDOM|ForClass

ResourceDef:
  @QName: getWeakRef
  @AliasFor:
    ManakaiNode:getWeakRef::ManakaiDOM:Perl
  @For: ManakaiDOM|ManakaiDOM !=ManakaiDOM|ManakaiDOM

ResourceDef:
  @rdf:type:
    @@@:
      dis:MultipleResource
    @@ForCheck:
      !ManakaiDOM:ForIF !DOMCore:ForChildNodeList !DOMCore:ForGetNodeList

  @resourceFor:
    ManakaiDOM:ForIF
  @rdf:type:
    @@@:
      ManakaiDOM:IF
    @@ForCheck:
      ManakaiDOM:ForIF
  @IFQName: NodeList

  @DOMMain:implementFeature:
    @@@: CoreFeature10
    @@ForCheck: ManakaiDOM|DOM1
  @DOMMain:implementFeature:
    @@@: CoreFeature20
    @@ForCheck: ManakaiDOM|DOM2
  @DOMMain:implementFeature:
    @@@: CoreFeature30
    @@ForCheck: ManakaiDOM|DOM3

  @resourceFor:
    @@@:
      DOMCore:ForChildNodeList
    @@For:
      ManakaiDOM:ManakaiDOM !=ManakaiDOM:ManakaiDOM
  @QName:
    @@@:
      ManakaiDOMCore:ManakaiDOMChildNodeList
    @@ForCheck:
      DOMCore:ForChildNodeList
  @rdf:type:
    @@@:
      ManakaiDOM:Class
    @@ForCheck:
      DOMCore:ForChildNodeList
  @ISA:
    @@@: ManakaiNode|ManakaiNodeRef||ManakaiDOM|Perl
    @@ForCheck:
      DOMCore:ForChildNodeList
  @ISA:
    @@@:
      ManakaiDOM:ManakaiDOMObject
    @@ForCheck:
      DOMCore:ForChildNodeList

  @AppISA:
    @@ForCheck:
      ForChildNodeList
    @@ContentType:
      lang:Perl
    @@@:
      Tie::Array

  @resourceFor:
    @@@: ForGetNodeList
    @@ForCheck:
      ManakaiDOM:ManakaiDOM !=ManakaiDOM:ManakaiDOM
  @QName:
    @@@:
      ManakaiDOMCore:ManakaiDOMGetElementsNodeList
    @@ForCheck: ForGetNodeList
  @rdf:type:
    @@@:
      ManakaiDOM:Class
    @@ForCheck: ForGetNodeList
  @ISA:
    @@@: ManakaiNode|ManakaiNodeRef||ManakaiDOM|Perl
    @@ForCheck:
      DOMCore:ForGetNodeList
  @ISA:
    @@@:
      ManakaiDOM:ManakaiDOMObject
    @@ForCheck: ForGetNodeList

  @AppISA:
    @@ForCheck:
      ForGetNodeList
    @@ContentType:
      lang:Perl
    @@@:
      Tie::Array

  @Implement:
    @@@: NodeList||ManakaiDOM|ManakaiDOM
    @@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM
  @Implement:
    @@@: NodeList||ManakaiDOM|ManakaiDOM1
    @@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM1
  @Implement:
    @@@: NodeList||ManakaiDOM|ManakaiDOM2
    @@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM2
  @Implement:
    @@@: NodeList||ManakaiDOM|ManakaiDOM3
    @@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM3
  @Implement:
    @@@: NodeList||ManakaiDOM|ManakaiDOMLatest
    @@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOMLatest

  @enDesc:
    Objects implementing the <IF::NodeList> interface are used
    to represent ordered collections of nodes.

    The <IF::NodeList> objects are live; which means
    that the <IF::NodeList> objects are always <QUOTE::up-to-date>.
    For example, a <IF::NodeList> obtained from the 
    <A::Node.childNodes> attribute of an empty element would 
    have its <A::NodeList.length> value of <CODE::1> after
    a <M::Node.appendChild> operation would have appended a node
    to the element.

    {NOTE:: How this collection is implemented is neither defined
            nor constrained.
    }

    The items in the <IF::NodeList> are accessible via
    an ordinal index, starting from zero.

  @enDesc:
    @@For: ManakaiDOM|ManakaiDOM
    @@@:
      In the manakai implementation, <IF::NodeList> can be 
      dereferenced as if it is an array reference.  For 
      example, <Perl::@a = @$nodeList> result in the array
      <Perl::@a> containing all <IF::Node>s in the <Perl::$nodeList>.
      Please note that <Perl::@a> is just a Perl array and
      it is <EM::not> live.

  @enDesc:
    {NOTE:: <IF::NodeList>s are different from <IF::NamedNodeMap>s
            in that <IF::NodeList>s are <EM::ordered> and
            <IF::NamedNodeMap>s are not.
    }

  @Method:
     @@Name:  item
     @@Perlop:FETCH
     @@Description:
       @@@lang:en
       @@@@:
         Return an item in the collection.
     @@Param:
        @@@Name:  index
        @@@Type:  
          DOMMain:unsigned-long||ManakaiDOM|all
        @@@Description:
          @@@@lang:en
          @@@@@: The index of the item into the collection.
        @@@ImplNote:
          @@@@lang:en
          @@@@@:
            A negative index is automatically translated to 
            a positive index when <Perl::FETCH>ed. 
          @@@@For:
            ManakaiDOM:ManakaiDOM
     @@Return:
        @@@Type:  Node
        @@@actualType: ManakaiDOMNode
        @@@Description:
          @@@@lang:en
          @@@@@: 
            The node at the "index"th position in the collection.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The "index" is invalid, i.e. it is greater than or 
              equal to the number of nodes in the list.
        @@@PerlDef:
          @@@@ForCheck:
            DOMCore:ForChildNodeList
          @@@@@:
            $r = $self->{<Q::TreeCore:node>}->{<Q::infoset:children>}->[$index];
            if (defined $r) {
              $r = <ClassM::ManakaiDOMNode.getNodeReference> ($r);
            }
        @@@PerlDef:
          @@@@ForCheck:ForGetNodeList
          @@@@@:
            $r = $self->{<Q::TreeCore:node>}
                      -><M::ManakaiDOMCore:ManakaiDOMNodeObjectNode
                                   .getElementBy> 
                          ($self->{<Q::ManakaiDOMCore:nodeMatch>}, \$index);
           if (defined $r) {
             $r = <ClassM::ManakaiDOMNode.getNodeReference> ($r, $self);
           }
         @@@@ImplNote:
           @@@@@lang:en
           @@@@@@:
             TODO: Cache mechanism required.

  @IntMethod:
    @@Perlop: STORE
    @@Description:
      @@@lang:en
      @@@@:
        Sets an item. 
    @@Param:
      @@@Name:index
      @@@Type:
        DOMMain:unsigned-long||ManakaiDOM|all
      @@@Description:
        @@@@lang:en
        @@@@@:
          An ordinal index in the list.  If the <P::index> is greater 
          than the number of items, then it is appended to the end of 
          the list.  A negative index is converted into a positive 
          index by Perl. 
    @@Param:
      @@@Name:value
      @@@Type: Node
      @@@Description:
        @@@@lang:en
        @@@@@:
          The node to set at the <P::index>th position in the list. 
    @@Return:
      @@@Type:Node
      @@@Description:
        @@@@lang:en
        @@@@@:
          The old node that has been replaced to the new <P::value>. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            No node has been removed from this list. 
      @@@Exception:
        @@@@@:NOMOD_NODELIST_ERR
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            A <IF::NodeList> returned by <M::Document.getElementsByTagNameNS> 
            or like is unable to be edited. 
        @@@@ForCheck:ForGetNodeList
      @@@disDef:
        @@@@DOMMain:raiseException:NOMOD_NODELIST_ERR
      @@@Exception:
        @@@@ForCheck:ForChildNodeList
          @@@@Type: DOMException
          @@@@Name: HIERARCHY_REQUEST_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Either this node is of a type that does not allow 
              children of the type of the "newChild" node [DOM 1, 2, 3],
              the node to put in is one of ancestors of this node 
              [DOM 1, 2, 3], the node to put in is this node itself
              [DOM 2 Errata, 3], or this 
              node is of type "Document" and the result of the 
              replacement would add a second "DocumentType" or "Element" node.
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              Special treatment required for the "DocumentFragment" node.
        @@@Exception:
        @@@@ForCheck:ForChildNodeList
          @@@@Type: DOMException
          @@@@Name: WRONG_DOCUMENT_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The new node was created from a different document.
        @@@Exception:
        @@@@ForCheck:ForChildNodeList
          @@@@Type: DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Either this node is read-only [DOM 1, 2, 3] or the parent of the 
              new node is read-only [DOM 1 SE, 2, 3].
      @@@PerlDef:
        @@@@ForCheck:ForChildNodeList
        @@@@@:
          if (CORE::exists $self->{<Q::TreeCore:node>}
                                ->{<Q::infoset:children>}->[$index]) {
            __DEEP{
              $r = $self-><M::ManakaiDOMNode.replaceChild>
                     ($value, $self-><M::ManakaiDOMCore:ManakaiDOMChildNodeList
                                               .item> ($index));
            }__;
          } else {
            __DEEP{
              $self-><M::ManakaiDOMNode.appendChild> ($value);
            }__;
          }

  @IntMethod:
    @@Perlop: DELETE
    @@Description:
      @@@lang:en
      @@@@:
        Removes an item from this list. 
        \
        Unlike the deletion for Perl's standard array, this method 
        removes an item and moves the rest of the array (i.e. items 
        whose index is greater than <P::index>) one position, since 
        the <IF::NodeList> cannot contain a <DOM::null> value. 
    @@Param:
      @@@Name:index
      @@@Type:
        DOMMain:unsigned-long||ManakaiDOM|all
      @@@Description:
        @@@@lang:en
        @@@@@:
          An ordinal index in the list.  If the <P::index> is greater 
          than the number of items, then no item is removed.
          A negative index is converted into a positive 
          index by Perl. 
    @@Return:
      @@@Type:Node
      @@@Description:
        @@@@lang:en
        @@@@@:
          The node removed from this list. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            No node has removed from this list. 
      @@@Exception:
        @@@@@:NOMOD_NODELIST_ERR
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            A <IF::NodeList> returned by <M::Document.getElementsByTagNameNS> 
            or like is unable to be edited. 
        @@@@ForCheck:ForGetNodeList
      @@@disDef:
        @@@@DOMMain:raiseException:NOMOD_NODELIST_ERR
      @@@Exception:
        @@@@ForCheck:ForChildNodeList
          @@@@Type: DOMException
          @@@@Name: HIERARCHY_REQUEST_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Either this node is of a type that does not allow 
              children of the type of the "newChild" node [DOM 1, 2, 3],
              the node to put in is one of ancestors of this node 
              [DOM 1, 2, 3], the node to put in is this node itself
              [DOM 2 Errata, 3], or this 
              node is of type "Document" and the result of the 
              replacement would add a second "DocumentType" or "Element" node.
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              Special treatment required for the "DocumentFragment" node.
      @@@Exception:
        @@@@ForCheck:ForChildNodeList
          @@@@Type: DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Either this node is read-only [DOM 1, 2, 3] or the parent of the 
              new node is read-only [DOM 1 SE, 2, 3].
      @@@PerlDef:
        @@@@ForCheck:ForChildNodeList
        @@@@@:
          if (CORE::exists $self->{<Q::TreeCore:node>}
                                ->{<Q::infoset:children>}->[$index]) {
            __DEEP{
              $r = $self-><M::ManakaiDOMNode.removeChild>
                          ($self-><M::ManakaiDOMCore:ManakaiDOMChildNodeList
                                         .item> ($index));
            }__;
          }

  @Attr:
     @@Name:  length
     @@Perlop: FETCHSIZE
     @@Description:
       @@@lang:en
       @@@@:
         The number of nodes in the list.
     @@Get:
        @@@Type:  
          DOMMain:unsigned-long||ManakaiDOM|all
        @@@PerlDef:
          @@@@ForCheck: ForChildNodeList
          @@@@@:
            $r = @{$self->{<Q::TreeCore:node>}->{<Q::infoset:children>}};
        @@@PerlDef:
          @@@@ForCheck: ForGetNodeList
          @@@@@:
            my $l = $self->{<Q::TreeCore:node>}
                         -><M::ManakaiDOMCore:ManakaiDOMNodeObjectNode
                                  .getElementsBy>
                             ($self->{<Q::ManakaiDOMCore:nodeMatch>});
            $r = @$l;

  @IntMethod:
    @@Perlop: STORESIZE
    @@Description:
      @@@lang:en
      @@@@:
        Changes the size of this node list.
    @@Param:
      @@@Name:count
      @@@Type:
        DOMMain:unsigned-long||ManakaiDOM|all
      @@@Description:
        @@@@lang:en
        @@@@@: 
          The new length of this list.  If the <P::count> 
          is smaller than the current <A::NodeList.length>, <P::count>th or 
          greater index'th items are removed from this list.  Otherwise, 
          no action.
    @@Return:
      @@@NoModGetNodeList:
      @@@PerlDef:
        @@@@ForCheck:ForChildNodeList
        @@@@@:
          my $len = @{$self->{<Q::TreeCore:node>}->{<Q::infoset:children>}};
          if ($len < $count) {
            __DEEP{
              my $node = <ClassM::ManakaiDOMNode.getCoreNodeReference>
                               ($self->{<Q::TreeCore:node>});
              for (my $i = $count - 1; $i >= $len; $i--) {
                my $cnode = <ClassM::ManakaiDOMNode.getCoreNodeReference>
                               ($self->{<Q::TreeCore:node>}
                                     ->{<Q::infoset:children>}->[$i]);
                $node-><M::Node.removeChild> ($cnode);
              }
            }__;
          }

  @IntMethod:
     @@Perlop: EXISTS
     @@Description:
       @@@lang:en
       @@@@:
         Returns whether an item exists in this list or not. 
     @@Param:
       @@@Name:index
       @@@Type:
         DOMMain:unsigned-long||ManakaiDOM|all
       @@@Description:
         @@@@lang:en
         @@@@@:
           The ordinal index of the item to test. 
     @@Return:
        @@@Type:  DOMMain|boolean||ManakaiDOM|all
        @@@PerlDef:
          @@@@ForCheck: ForChildNodeList
          @@@@@:
            $r = CORE::exists $self->{<Q::TreeCore:node>}
                                   ->{<Q::infoset:children>}->[$index];
        @@@PerlDef:
          @@@@ForCheck: ForGetNodeList
          @@@@@:
            __DEEP{
              $r = $self-><M::ManakaiDOMCore:ManakaiDOMGetElementsNodeList.item>
                               ($index) ? 1 : 0;
            }__;
  @IntMethod:
    @@Name: isEqualNodeList
    @@ForCheck: ForChildNodeList
    @@Perlop: ==
    @@Description:
      @@@lang:en
      @@@@:
        Checks whether two node lists are equal or not.  
        Two node lists are equal iff their <A::NodeList.length> are 
        equal and their item at the same index are equal. 
        \
        See <M::Node.isEqualNode>.
    @@Param:
      @@@Name:arg
      @@@Type: NodeList
      @@@Description:
        @@@@lang:en
        @@@@@:
          The node list to compare equality with.
    @@Return:
      @@@Type:DOMMain|boolean||ManakaiDOM|all
      @@@PerlDef:
        @@@@ForCheck: ForChildNodeList
        @@@@@:
          EQ: {
            last EQ unless @{$self->{<Q::TreeCore:node>}
                                  ->{<Q::infoset:children>}} ==
                           $arg-><AG::NodeList.length>;
            my $nc = <ClassName::ManakaiDOMNode>;
            for my $i (0..@{$self->{<Q::TreeCore:node>}
                                 ->{<Q::infoset:children>}}) {
              my $a = $self->{<Q::TreeCore:node>}
                                      ->{<Q::infoset:children>}->[$i];
              unless (<M::DOMCore:ManakaiDOMNode.isEqualNode>
                         (<Code::ManakaiNode:getWeakRef||ManakaiDOM:Perl::
                             $object = $a, $class = $nc>,
                          $arg-><M::NodeList.item> ($i))) {
                last EQ;
              }
            }
            $r = true;
          }

  @IntMethod:
    @@Perlop:TIEARRAY
    @@ManakaiDOM:isStatic:1
    @@Description:
      @@@lang:en
      @@@@:
        Binds a node list to an array.  This method is intended to 
        be called by Perl <Perl::tie> function. 
    @@Param:
      @@@Name: nodeList
      @@@Type: NodeList
      @@@Description:
        @@@@lang:en
        @@@@@:
          A node list that is tied with an array. 
    @@Return:
      @@@Type: NodeList
      @@@Description:
        @@@@lang:en
        @@@@@:
          The node list to which the array has bound, 
          i.e. <P::nodeList>.
      @@@PerlDef:
        $r = $nodeList;

  @IntMethod:
    @@Perlop:PUSH
    @@Description:
      @@@lang:en
      @@@@:
        Pushes an item to the last of this list. 
    @@Param:
      @@@Name:value
      @@@Type:Node
      @@@Description:
        @@@@lang:en
        @@@@@:
          The node to push. 
    @@Return:
      @@@Exception:
        @@@@@:NOMOD_NODELIST_ERR
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            A <IF::NodeList> returned by <M::Document.getElementsByTagNameNS> 
            or like is unable to be edited. 
        @@@@ForCheck:ForGetNodeList
      @@@disDef:
        @@@@DOMMain:raiseException:NOMOD_NODELIST_ERR
      @@@Exception:
        @@@@ForCheck:ForChildNodeList
          @@@@Type: DOMException
          @@@@Name: HIERARCHY_REQUEST_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Either this node is of a type that does not allow 
              children of the type of the "newChild" node [DOM 1, 2, 3],
              the node to put in is one of ancestors of this node 
              [DOM 1, 2, 3], the node to put in is this node itself
              [DOM 2 Errata, 3], or this 
              node is of type "Document" and the result of the 
              replacement would add a second "DocumentType" or "Element" node.
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              Special treatment required for the "DocumentFragment" node.
      @@@Exception:
        @@@@ForCheck:ForChildNodeList
          @@@@Type: DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Either this node is read-only [DOM 1, 2, 3] or the parent of the 
              new node is read-only [DOM 1 SE, 2, 3].
      @@@PerlDef:
        @@@@ForCheck:ForChildNodeList
        @@@@@:
          __DEEP{
            $self-><M::ManakaiDOMNode.insertBefore>
                           ($value,
                            $self-><M::ManakaiDOMCore:ManakaiDOMChildNodeList
                                            .item> (0));
          }__;

  @IntMethod:
    @@Perlop:POP
    @@Description:
      @@@lang:en
      @@@@:
        Pops an item from the last of this list. 
    @@Return:
      @@@Type:Node
      @@@Description:
        @@@@lang:en
        @@@@@:
          The node removed from the last of this list. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The list has been empty and no item is poped. 
      @@@NoModGetNodeList:
      @@@Exception:
        @@@@ForCheck:ForChildNodeList
          @@@@Type: DOMException
          @@@@Name: HIERARCHY_REQUEST_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Either this node is of a type that does not allow 
              children of the type of the "newChild" node [DOM 1, 2, 3],
              the node to put in is one of ancestors of this node 
              [DOM 1, 2, 3], the node to put in is this node itself
              [DOM 2 Errata, 3], or this 
              node is of type "Document" and the result of the 
              replacement would add a second "DocumentType" or "Element" node.
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              Special treatment required for the "DocumentFragment" node.
      @@@Exception:
        @@@@ForCheck:ForChildNodeList
          @@@@Type: DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Either this node is read-only [DOM 1, 2, 3] or the parent of the 
              new node is read-only [DOM 1 SE, 2, 3].
      @@@PerlDef:
        @@@@ForCheck:ForChildNodeList
        @@@@@:
          __DEEP{
            $self-><M::ManakaiDOMNode.removeChild>
                     ($self-><M::ManakaiDOMCore:ManakaiDOMChildNodeList.item>
                        ($self-><AG::ManakaiDOMCore:ManakaiDOMChildNodeList
                                       .length> - 1));
          }__;

  @IntMethod:
    @@Perlop:CLEAR
    @@Description:
      @@@lang:en
      @@@@:
        Removes all items from this list. 
    @@Return:
      @@@NoModGetNodeList:
      @@@Exception:
        @@@@ForCheck:ForChildNodeList
          @@@@Type: DOMException
          @@@@Name: HIERARCHY_REQUEST_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Either this node is of a type that does not allow 
              children of the type of the "newChild" node [DOM 1, 2, 3],
              the node to put in is one of ancestors of this node 
              [DOM 1, 2, 3], the node to put in is this node itself
              [DOM 2 Errata, 3], or this 
              node is of type "Document" and the result of the 
              replacement would add a second "DocumentType" or "Element" node.
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              Special treatment required for the "DocumentFragment" node.
      @@@Exception:
        @@@@ForCheck:ForChildNodeList
          @@@@Type: DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Either this node is read-only [DOM 1, 2, 3] or the parent of the 
              new node is read-only [DOM 1 SE, 2, 3].
      @@@PerlDef:
        @@@@ForCheck:ForChildNodeList
        @@@@@:
          __DEEP{
            my $length = $self-><AG::ManakaiDOMCore:ManakaiDOMChildNodeList
                                       .length> - 1;
            for (reverse $length..0) {
              $self-><M::ManakaiDOMNode.removeChild>
                 ($self-><M::ManakaiDOMCore:ManakaiDOMChildNodeList.item> ($_));
            }
          }__;

  @ImplNote:
    @@lang:en
    @@@:
      {TODO:: Optimize PUSH, POP, SHIFT, UNSHIFT, SPLICE. 
      \
      }

  @IntMethod:
    @@Perlop:@{}
    @@Description:
      @@@lang:en
      @@@@:
        Returns an array representation of this node list. 
        \
        {NOTE:: It is intended that most operations through the 
                array is as like ones in DOM Level 0 JavaScript 
                implementations as possible. 
        \
        }
    @@Return:
      @@@Type:
        perl:ARRAY::ManakaiDOM:all
      @@@PerlDef:
        tie my @list, ref $self, $self;
        $r = \@list;

  @IntMethod:
    @@Perlop:DESTROY
    @@Description:
      @@@lang:en
      @@@@:
        Redefines destructor for the class
        <Class::ManakaiNode|ManakaiNodeRef||ManakaiDOM|Perl>,
        since the <PerlModule::Tie::Array> also has its own empty destructor. 
    @@Return:
      @@@disDef:
        @@@@DISPerl:cloneCode:
          ManakaiNode|ManakaiNodeRef||ManakaiDOM|Perl.destroy

##NodeList

ElementTypeBinding:
  @Name:NoModGetNodeList
  @ElementType:
    rdf:type
  @ShadowContent:
    rdfs:Resource
  @ShadowSibling:
    @@ManakaiDOM:raises:
      @@@@:NOMOD_NODELIST_ERR
      @@@Description:
        @@@@lang:en
        @@@@@:
          A <IF::NodeList> returned by <M::Document.getElementsByTagNameNS> 
          or like is unable to be edited. 
      @@@ForCheck:ForGetNodeList
    @@disDef:
      @@@DOMMain:raiseException:NOMOD_NODELIST_ERR


ElementTypeBinding:
  @Name: Perlop
  @ElementType:
    dis:Operator
  @ShadowContent:
    @@ContentType:
      lang:Perl
    @@For:
      ManakaiDOM:ManakaiDOM

ForDef:
  @QName:
    DOMCore:ForAttrMap
  @Description:
    @@lang:en
    @@@:
      For <ClassM::ManakaiDOMCore:ManakaiDOMAttributes> class.
  @ISA: ManakaiDOM|ForClass

ForDef:
  @QName:
    DOMCore:ForEntityMap
  @Description:
    @@lang:en
    @@@:
      For <ClassM::ManakaiDOMXML:ManakaiDOMEntities> class.
  @ISA: ManakaiDOM|ForClass

ForDef:
  @QName:
    DOMCore:ForNotationMap
  @Description:
    @@lang:en
    @@@:
      For <ClassM::ManakaiDOMXML:ManakaiDOMNotations> class.
  @ISA: ManakaiDOM|ForClass

ResourceDef:
  @rdf:type:
    @@@:
      dis:MultipleResource
    @@ForCheck:
      !ManakaiDOM:ForIF !ForAttrMap !ForEntityMap !ForNotationMap

  @resourceFor:
    ManakaiDOM:ForIF
  @IFQName: NamedNodeMap
  @rdf:type:
    @@@:
      ManakaiDOM:IF
    @@ForCheck:
      ManakaiDOM:ForIF

  @DOMMain:implementFeature:
    @@@: CoreFeature10
    @@ForCheck: ManakaiDOM|DOM1
  @DOMMain:implementFeature:
    @@@: CoreFeature20
    @@ForCheck: ManakaiDOM|DOM2
  @DOMMain:implementFeature:
    @@@: CoreFeature30
    @@ForCheck: ManakaiDOM|DOM3

  @resourceFor:
    @@@: ForAttrMap
    @@For:
      ManakaiDOM:ManakaiDOM !=ManakaiDOM:ManakaiDOM
  @QName:
    @@@: 
      ManakaiDOMCore:ManakaiDOMAttributes
    @@ForCheck: ForAttrMap
  @rdf:type:
    @@@: 
      ManakaiDOM:Class
    @@ForCheck: ForAttrMap
  @ISA:
    @@@: ManakaiNode|ManakaiNodeRef||ManakaiDOM|Perl
    @@ForCheck:
      DOMCore:ForAttrMap
  @ISA:
    @@@:
      ManakaiDOM:ManakaiDOMObject
    @@ForCheck: ForAttrMap

  @resourceFor:
    @@@: ForEntityMap
    @@For:
      ManakaiDOM:ManakaiDOM !=ManakaiDOM:ManakaiDOM
  @QName:
    @@@: 
      ManakaiDOMXML:ManakaiDOMEntities
    @@ForCheck: ForEntityMap
  @rdf:type:
    @@@: 
      ManakaiDOM:Class
    @@ForCheck: ForEntityMap
  @ISA:
    @@@: ManakaiNode|ManakaiNodeRef||ManakaiDOM|Perl
    @@ForCheck:
      DOMCore:ForEntityMap
  @ISA:
    @@@:
      ManakaiDOM:ManakaiDOMObject
    @@ForCheck: ForEntityMap

  @DOMMain:implementFeature:
    @@@: 
      DOMXML:XMLFeature10
    @@ForCheck:
      ForEntityMap ManakaiDOM:DOM1
  @DOMMain:implementFeature:
    @@@: 
      DOMXML:XMLFeature20
    @@ForCheck:
      ForEntityMap ManakaiDOM:DOM2
  @DOMMain:implementFeature:
    @@@: 
      DOMXML:XMLFeature30
    @@ForCheck:
      ForEntityMap ManakaiDOM:DOM3

  @resourceFor:
    @@@: ForNotationMap
    @@For:
      ManakaiDOM:ManakaiDOM !=ManakaiDOM:ManakaiDOM
  @QName:
    @@@: 
      ManakaiDOMXML:ManakaiDOMNotations
    @@ForCheck: ForNotationMap
  @rdf:type:
    @@@: 
      ManakaiDOM:Class
    @@ForCheck: ForNotationMap
  @ISA:
    @@@: ManakaiNode|ManakaiNodeRef||ManakaiDOM|Perl
    @@ForCheck:
      DOMCore:ForNotationMap
  @ISA:
    @@@:
      ManakaiDOM:ManakaiDOMObject
    @@ForCheck: ForNotationMap

  @DOMMain:implementFeature:
    @@@: 
      DOMXML:XMLFeature10
    @@ForCheck:
      ForNotationMap ManakaiDOM:DOM1
  @DOMMain:implementFeature:
    @@@: 
      DOMXML:XMLFeature20
    @@ForCheck:
      ForNotationMap ManakaiDOM:DOM2
  @DOMMain:implementFeature:
    @@@: 
      DOMXML:XMLFeature30
    @@ForCheck:
      ForNotationMap ManakaiDOM:DOM3

  @Implement:
    @@@: NamedNodeMap||ManakaiDOM|ManakaiDOM
    @@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM
  @Implement:
    @@@: NamedNodeMap||ManakaiDOM|ManakaiDOM1
    @@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM1
  @Implement:
    @@@: NamedNodeMap||ManakaiDOM|ManakaiDOM2
    @@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM2
  @Implement:
    @@@: NamedNodeMap||ManakaiDOM|ManakaiDOM3
    @@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM3
  @Implement:
    @@@: NamedNodeMap||ManakaiDOM|ManakaiDOMLatest
    @@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOMLatest

  @enDesc:
    Objects implementing the <IF::NamedNodeMap> interface are 
    used to represent collections of nodes that can be
    accessed by name.

    <IF::NamedNodeMap>s do not maintain any particular order
    of <IF::Node>s, which is different from <IF::NodeList>s.
    Although <IF::Node>s in <IF::NamedNodeMap> may also be 
    accessed by an ordinal index, starting from <CODE::0>, 
    this is simply to allow convenient enumeration.

    <IF::NamedNodeMap>s are live.

  @enDesc:
    @@ForCheck: ForEntityMap
    @@@:
      The <Class::ManakaiDOMXML|ManakaiDOMEntities> class represents
      a collection of the general entities, both external and internal
      and both parsed and unparsed, declared in the DTD of the document.

      {NOTE:: Parameter entities and dupulicating (so that ignored) 
              entity declarations are not part of the collection.
      }

  @ImplNote:
    @@lang:en
    @@@:
      This interface is used by the attribute "DocumentType.entities". 
    @@ForCheck:ForEntityMap

  @enDesc:
    @@ForCheck: ForNotationMap
    @@@:
      The <Class::ManakaiDOMXML|ManakaiDOMNotations> class represents
      a collection of notations declared in the DTD of the document.

  @ImplNote:
    @@lang:en
    @@@:
      This interface is used by the attribute "DocumentType.notations".
    @@ForCheck:ForNotationMap

  @ImplNote:
    @@lang:en
    @@@:
      An element may have two (or more) attributes that have the same 
      <A::Node.nodeName>, but different <A::Node.namespaceURI>s. 
      Which of them is returned by DOM Level 1 methods is 
      implementation dependent.  The only guarantee is 
      that all methods that access a named item by its <A::Node.nodeName> 
      will access the same item, and all methods by its namespace URI
      and local name will access the same item. 
      <SRC::<CITE::DOM Level 2 Core> <sw010:csection::1.4.8 XML Namespaces>,
      <CITE::DOM Level 3 Core> <sw010:csection::1.3.3 XML Namespaces>>

  @enDesc:
    @@For: ManakaiDOM|ManakaiDOM
    @@@:
      In the manakai implementation, <IF::NamedNodeMap>s can be 
      dereferenced as if it is an array reference or a hash reference.
      Dereferencing as an array reference provides an access to
      items by ordinal index, like <M::.item> method; 
      Dereferencing as a hash reference
      provides by name, like <M::.getNamedItem> method.

      {TODO:: How namespace-aware node can be accessed?
      }

      {TODO:: This is <EM::not> implemented yet!
      }

  @Method:
     @@Name:  getNamedItem
     @@Description:
       @@@lang:en
       @@@@: Retrieve a node specified by name.
     @@NSVersion:.getNamedItemNS
     @@Param:
        @@@Name:  name
        @@@Type:  
          DOMMain:DOMString
        @@@actualType:
          @@@@@:
            DOMMain:ManakaiDOMXMLName
          @@@@ManakaiDOM:noInputNormalize:1
        @@@Description:
          @@@@lang:en
          @@@@@: The "nodeName" of a node to retrieve.
     @@Return:
        @@@Type:  Node
        @@@actualType:
          @@@@@: ManakaiDOMAttr
          @@@@ForCheck: ForAttrMap
        @@@Description:
          @@@@lang:en
          @@@@@:
            A "Node" (of any type) with the specified "nodeName".
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The "name" does not identify any node in this map.
         @@@disDef:
           @@@@ForCheck: ForAttrMap
           @@@@DISPerl:cloneCode:
             ManakaiDOMElement.getAttributeNode
  @Method:
     @@Name:  setNamedItem
     @@Description:
       @@@lang:en
       @@@@:
         Add a node using its "nodeName" attribute.  If a node with 
         that name is already present in this map, it is replaced 
         by the new one.  Replacing a node by itself has no effect.
     @@ImplNote:
       @@@lang:en
       @@@@: "Replacing ... no effect" is clarified by the DOM Level 2 Errata. 
     @@NSVersion:.setNamedItemNS
     @@Param:
        @@@Name:  arg
        @@@Type:  Node
        @@@actualType:
          @@@@@:ManakaiDOMAttr
          @@@@ForCheck:ForAttrMap
        @@@Description:
          @@@@lang:en
          @@@@@: A node to store in this map.
     @@Return:
        @@@Type:  Node
        @@@actualType:
          @@@@@:ManakaiDOMAttr
          @@@@ForCheck:ForAttrMap
        @@@Description:
          @@@@lang:en
          @@@@@:
            If the "arg" node replaces an existing node, the replaced node.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The "arg" node does not replace any node in the map.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: WRONG_DOCUMENT_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The "arg" node was created from a different document.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: This map is read-only.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: INUSE_ATTRIBUTE_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The "arg" node is an "Attr" that is already an 
              attribute of another "Element" object.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: HIERARCHY_REQUEST_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              An attempt is made to add a node that is unable to 
              belong to this map.
          @@@@SpecLevel:2
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@: This exception has added by the DOM Level 2 Errata.
       @@@PerlDef:
         @@@@ForCheck: ForAttrMap
         @@@@@:
           __DEEP{
             $self-><M::ManakaiDOMElement.setAttributeNode> ($arg);
           }__;
     @@ImplNote:
       @@@lang:en
       @@@@:
         Is it possible to add the node that has namespace URI and local 
         name?  If it is, can that node be retrieved via the "NS" methods? 
         Is it possible to add the node that has "nodeName" crushing 
         with existing "NS" node?
         \
              It is unclear whether the node should be returned if 
              the node is <QUOTE::replaced> by itself.
  @Method:
     @@Name:  removeNamedItem
     @@Description:
        @@@lang:en
        @@@@:
          Remove a node specified by name.
     @@NSVersion:.removeNamedItemNS
     @@Param:
        @@@Name:  name
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The "nodeName" of the node to remove.
     @@Return:
        @@@Type:  Node
        @@@actualType:
          @@@@ForCheck:ForAttrMap
          @@@@@: ManakaiDOMAttr
        @@@Description:
          @@@@lang:en
          @@@@@: The node removed from this map.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NOT_FOUND_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: There is no node named "name" in this map.
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              The DOM Level 1 First Edition also said that if there 
              is no node named "name", "null" is returned.  It has 
              removed by the DOM Level 1 First Edition Errata.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: This map is read-only.
          @@@@SpecLevel:1
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              This exception is added by the DOM Level 1 First Edition Errata.
        @@@PerlDef:
          @@@@ForCheck:ForAttrMap
          @@@@@:
            if ($self->{<Q::TreeCore:node>}->{<Q::DOMCore:read-only>}) {
              __EXCEPTION{
                MDOMX:NOMOD_THIS::
              }__;
            }
            my $obj;
            __CODE{selectAttrNodeObjectForRemove:: $r => $obj}__;
            if ($obj) {
              $r = <ClassM::ManakaiDOMNode.getNodeReference> ($obj)
                if defined wantarray;
              CORE::delete $obj->{<Q::infoset:ownerElement>};
              $obj-><M::NodeStem.orphanate>;
            } else {
              __EXCEPTION{
                ManakaiDOMException.NOT_FOUND_ERR::
              }__;
            }
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              TODO: Default attribute
            \
              This code is almost same as <M::Element.removeAttribute>. 
              This method returns an <IF::Attr> removed but that method 
              does not (<M::Element.removeAttributeNode> does).
  @Method:
     @@Name:  item
     @@Description:
       @@@lang:en
       @@@@: Return an item in the map.
     @@Param:
        @@@Name:  index
        @@@Type:  
          DOMMain:unsigned-long||ManakaiDOM|all
        @@@Description:
          @@@@lang:en
          @@@@@: The index of the item into this map.
     @@Return:
        @@@Type:  Node
        @@@actualType:
          @@@@ForCheck:ForAttrMap
          @@@@@:
            DOMCore:ManakaiDOMAttr
        @@@Description:
          @@@@lang:en
          @@@@@: The node at the "index"th position in the map.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: 
              The "index" is invalid, i.e. it is greater than or 
              equal to the number of nodes in this map.
        @@@PerlDef:
          @@@@ForCheck:ForAttrMap
          @@@@@:
            my $i = 0;
            FIND: for my $ns (sort keys %{$self->{<Q::TreeCore:node>}
                                               ->{<Q::infoset:attributes>}}) {
              for my $ln (sort keys %{$self->{<Q::TreeCore:node>}
                                           ->{<Q::infoset:attributes>}->{$ns}}) {
                if ($i++ == $index) {
                  $r = $self->{<Q::TreeCore:node>}->{<Q::infoset:attributes>}
                            ->{$ns}->{$ln};
                  last FIND;
                }
              }
            }
            if ($r) {
              $r = <ClassM::ManakaiDOMNode.getNodeReference> ($r);
            }
    @@ImplNote:
      @@@lang:en
      @@@@:
        Attribute order is not defined by the specifications.
  @Attr:
     @@Name:  length
     @@Description:
       @@@lang:en
       @@@@: The number of nodes in this map.
     @@Get:
        @@@Type:  
          DOMMain:unsigned-long||ManakaiDOM|all
        @@@PerlDef:
          @@@@ForCheck:ForAttrMap
          @@@@@:
            for (values %{$self->{<Q::TreeCore:node>}
                               ->{<Q::infoset:attributes>}}) {
              $r += keys %$_;
            }
  @Method:
     @@Name:  getNamedItemNS
     @@Description:
       @@@lang:en
       @@@@:
         Retrieve a node specified by local name and namespace URI.
     @@NoNSVersion:.getNamedItem
     @@Param:
        @@@Name:  namespaceURI
        @@@Type:
          DOMMain:DOMString
        @@@actualType:
          ManakaiDOM:ManakaiDOMNamespaceURI
        @@@Description:
          @@@@lang:en
          @@@@@:
            The namespace URI of the node to retrieve.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The node to retrieve has no namespace.
     @@Param:
        @@@Name:  localName
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The local name of the node to retrieve.
     @@Return:
        @@@Type:  Node
        @@@actualType:
          @@@@ForCheck:ForAttrMap
          @@@@@:ManakaiDOMAttr
        @@@Description:
          @@@@lang:en
          @@@@@:
            A "Node" (of any type) with the specified local name and 
            namespace URI.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The "namespaceURI" and "localName" does not identify 
              any node in this map.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NOT_SUPPORTED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The DOM implementation does not support the feature "XML" and 
              the language exposed through the "Document" does not 
              support XML Namespaces.
       @@@disDef:
         @@@@ForCheck:
           ForAttrMap ManakaiDOM:DOMXMLFeature
         @@@@DISPerl:cloneCode:
           ManakaiDOMElement.getAttributeNodeNS
        @@@disDef:
          @@@@ForCheck:
            !ManakaiDOM:DOMXMLFeature
          @@@@DOMMain:raiseException:
            MDOMX:MDOM_IMPL_NOSUPPORT_XMLNS
     @@DOMMain:implementFeature:
       @@@@: CoreFeature20
       @@@ForCheck:
         ManakaiDOM:DOM2
     @@DOMMain:implementFeature:
       @@@@: MDOMCoreFeature20
       @@@ForCheck:
         ForAttrMap ManakaiDOM:ManakaiDOM2
     @@DOMMain:implementFeature:
       @@@@: CoreFeature30
       @@@ForCheck:
         ManakaiDOM:DOM3
     @@DOMMain:implementFeature:
       @@@@: MDOMCoreFeature30
       @@@ForCheck:
         ForAttrMap ManakaiDOM:ManakaiDOM3
     @@For:
       ManakaiDOM:DOM2
     @@Level[list]:  2
     @@SpecLevel:2
     @@ImplNote:
       @@@lang:en
       @@@@:
         The DOM Level 2 Specification said that the HTML-only DOM 
         implenentations do not need to implement this method. 
         The DOM Level 2 Errata and the DOM Level 3 Specification 
         says that the <X::DOMException.NOT_SUPPORTED_ERR> should be raised.
  @Method:
     @@Name:  setNamedItemNS
     @@Description:
       @@@lang:en
       @@@@:
         Add a node using its "namespaceURI" and "localName". 
         If a node with that namespace URI and that local name 
         is already present in this map, it is replaced by the new one. 
         Replacing a node by itself has no effect.
     @@ImplNote:
       @@@lang:en
       @@@@: "Replacing ... no effect" is clarified by the DOM Level 2 Errata. 
     @@NoNSVersion:.setNamedItem
     @@Param:
        @@@Name:  arg
        @@@Type:  Node
        @@@actualType:
          @@@@ForCheck:ForAttrMap
          @@@@@:ManakaiDOMAttr
        @@@Description:
          @@@@lang:en
          @@@@@: A node to store in this map.
     @@Return:
        @@@Type:  Node
        @@@actualType:
          @@@@ForCheck:ForAttrMap
          @@@@@:ManakaiDOMAttr
        @@@Description:
          @@@@lang:en
          @@@@@:
            If the "arg" node replaces an existing node, the replaced node.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The "arg" node replaces no existing node in this map.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: WRONG_DOCUMENT_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The "arg" node was created from a different document.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: This map is read-only.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: INUSE_ATTRIBUTE_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The "arg" node is an "Attr" that is already an 
              attribute of another "Element" object.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: HIERARCHY_REQUEST_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              An attempt is made to add a node that is unable to 
              belong to this map.
          @@@@SpecLevel:2
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@: This exception has added by the DOM Level 2 Errata.
         @@@Exception:
           @@@@Type: DOMException
           @@@@Name: NOT_SUPPORTED_ERR
           @@@@Description:
             @@@@@lang:en
             @@@@@@:
             The DOM implementation does not support the feature "XML" and 
             the language exposed through the "Document" does not 
             support XML Namespaces
           @@@@SpecLevel:2
       @@@PerlDef:
         @@@@ForCheck:
           ForAttrMap ManakaiDOM:DOMXMLFeature
         @@@@@:
            if ($self->{<Q::TreeCore:node>}->{<Q::DOMCore:read-only>}) {
              __EXCEPTION{
                MDOMX:NOMOD_THIS::
              }__;
            }
            my $attrNode = $arg->{<Q::TreeCore:node>};
            if ($attrNode->{<Q::infoset:ownerElement>}) {
              __EXCEPTION{
                ManakaiDOMException.INUSE_ATTRIBUTE_ERR::
                  MDOMX:param-name => 'arg',
              }__;
            } elsif ($attrNode->{<Q::DOMCore:ownerDocument>}
                              ->{<Q::TreeCore:nodeID>} ne
                     $self->{<Q::TreeCore:node>}->{<Q::DOMCore:ownerDocument>}
                          ->{<Q::TreeCore:nodeID>}) {
              __EXCEPTION{
                ManakaiDOMException.WRONG_DOCUMENT_ERR::
              }__;
            } elsif ($attrNode->{<Q::DOMCore:nodeType>} ne
                     <Q::infoset:Attribute>) {
              __EXCEPTION{
                MDOMX:HIERARCHY_BAD_TYPE::
                  MDOMX:param-name => 'arg',
                  DOMCore:nodeType => {$attrNode->{<Q::DOMCore:nodeType>}},
              }__;
            }

            if (defined $attrNode->{<Q::infoset:localName>}) {
              $r = $self->{<Q::TreeCore:node>}->{<Q::infoset:attributes>}
                     ->{defined $attrNode->{<Q::infoset:namespaceName>}
                              ? $attrNode->{<Q::infoset:namespaceName>}
                              : <Q::null:>}
                     ->{$attrNode->{<Q::infoset:localName>}};
            } else {
              __EXCEPTION{
                MDOMX:MDOM_NODE_NOSUPPORT_XMLNS::
                  MDOMX:param-name => 'arg',
              }__;
            }

            if ($r->{<Q::TreeCore:nodeID>} eq $attrNode->{<Q::TreeCore:nodeID>}) {
              __WARNING{
                MDOMX:MDOM_REPLACE_BY_ITSELF_NO_EFFECT::
              }__;
              $r = $arg;
            } else {
              $attrNode->{<Q::infoset:ownerElement>} = $self->{<Q::TreeCore:node>};
              if (defined $attrNode->{<Q::infoset:localName>}) {
                $self->{<Q::TreeCore:node>}->{<Q::infoset:attributes>}
                     ->{defined $attrNode->{<Q::infoset:namespaceName>}
                              ? $attrNode->{<Q::infoset:namespaceName>}
                              : <Q::null:>}
                     ->{$attrNode->{<Q::infoset:localName>}} = $attrNode;
              } else {
                $self->{<Q::TreeCore:node>}->{<Q::infoset:attributes>}
                     ->{<Q::ManakaiDOM:noNS>}
                     ->{$attrNode->{<Q::DOMCore:name>}} = $attrNode;
              }
              if ($r) {
                my $obj = $r;
                $r = <ClassM::ManakaiDOMNode.getNodeReference> ($obj)
                  if defined wantarray;
                CORE::delete $obj->{<Q::infoset:parent>};
                $obj-><M::NodeStem.orphanate>;
              }
            }
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              It is unclear whether the node should be returned if 
              the node is <QUOTE::replaced> by itself.
             \
              This code is almost same as <M::Element.setAttributeNodeNS>
              without some points.
        @@@disDef:
          @@@@ForCheck:
            !ManakaiDOM:DOMXMLFeature
          @@@@DOMMain:raiseException:
            MDOMX:MDOM_IMPL_NOSUPPORT_XMLNS
     @@DOMMain:implementFeature:
       @@@@: CoreFeature20
       @@@ForCheck:
         ManakaiDOM:DOM2
     @@DOMMain:implementFeature:
       @@@@: MDOMCoreFeature20
       @@@ForCheck:
         ForAttrMap ManakaiDOM:ManakaiDOM2
     @@DOMMain:implementFeature:
       @@@@: CoreFeature30
       @@@ForCheck:
         ManakaiDOM:DOM3
     @@DOMMain:implementFeature:
       @@@@: MDOMCoreFeature30
       @@@ForCheck:
         ForAttrMap ManakaiDOM:ManakaiDOM3
     @@ImplNote:
       @@@lang:en
       @@@@:
         The DOM Level 2 Specification said that the HTML-only DOM 
         implenentations do not need to implement this method. 
         The DOM Level 2 Errata and the DOM Level 3 Specification 
         says that the NOT_SUPPORTED_ERR should be raised.
     @@Level[list]:  2
     @@SpecLevel:2
     @@For:
       ManakaiDOM:DOM2
  @Method:
     @@Name:  removeNamedItemNS
     @@Description:
        @@@lang:en
        @@@@:
          Remove a node specified by local name and namespace URI.
     @@ImplNote:
       @@@lang:en
       @@@@:
         New non-"specified" attribute will be generated if the schema 
         defines some default value for the attribute removed.
     @@NoNSVersion:.removeNamedItem
     @@Param:
        @@@Name:  namespaceURI
        @@@Type:
          DOMMain:DOMString
        @@@actualType:
          ManakaiDOM:ManakaiDOMNamespaceURI
        @@@Description:
          @@@@lang:en
          @@@@@: The namespace URI of the node to remove.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The node to remove has no namespace.
     @@Param:
        @@@Name:  localName
        @@@Type: 
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The local name of the node to remove.
     @@Return:
        @@@Type:  Node
        @@@actualType:
          @@@@ForCheck:ForAttrMap
          @@@@@:ManakaiDOMAttr
        @@@Description:
          @@@@lang:en
          @@@@@: The node removed from this map.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NOT_FOUND_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              There is no node with the specified "namespaceURI" and 
              "localName" in the map.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: This map is read-only.
         @@@Exception:
           @@@@Type: DOMException
           @@@@Name: NOT_SUPPORTED_ERR
           @@@@Description:
             @@@@@lang:en
             @@@@@@:
             The DOM implementation does not support the feature "XML" and 
             the language exposed through the "Document" does not 
             support XML Namespaces
       @@@PerlDef:
         @@@@ForCheck:
           ForAttrMap ManakaiDOM:DOMXMLFeature
         @@@@@:
            if ($self->{<Q::TreeCore:node>}->{<Q::DOMCore:read-only>}) {
              __EXCEPTION{
                MDOMX:NOMOD_THIS::
              }__;
            }
            __CODE{selectAttrNodeObjectForRemoveNS}__;
            if ($r) {
              my $obj = $r;
              $r = <ClassM::ManakaiDOMNode.getNodeReference> ($obj)
                  if defined wantarray;
              CORE::delete $obj->{<Q::infoset:ownerElement>};
              $obj-><M::NodeStem.orphanate>;
            } else {
              __EXCEPTION{
                ManakaiDOMException.NOT_FOUND_ERR::
              }__;
            }
        @@@disDef:
          @@@@ForCheck:
            !ManakaiDOM:DOMXMLFeature
          @@@@DOMMain:raiseException:
            MDOMX:MDOM_IMPL_NOSUPPORT_XMLNS
     @@DOMMain:implementFeature:
       @@@@: CoreFeature20
       @@@ForCheck:
         ManakaiDOM:DOM2
     @@DOMMain:implementFeature:
       @@@@: MDOMCoreFeature20
       @@@ForCheck:
         ForAttrMap ManakaiDOM:ManakaiDOM2
     @@DOMMain:implementFeature:
       @@@@: CoreFeature30
       @@@ForCheck:
         ManakaiDOM:DOM3
     @@DOMMain:implementFeature:
       @@@@: MDOMCoreFeature30
       @@@ForCheck:
         ForAttrMap ManakaiDOM:ManakaiDOM3
     @@ImplNote:
       @@@lang:en
       @@@@:
         The DOM Level 2 Specification said that the HTML-only DOM 
         implenentations do not need to implement this method. 
         The DOM Level 2 Errata and the DOM Level 3 Specification 
         says that the NOT_SUPPORTED_ERR should be raised.
     @@For:
       ManakaiDOM:DOM2
     @@Level[list]:  2
     @@SpecLevel:2

  @IntMethod:
    @@Name: isEqualNamedNodeMap
    @@ForCheck:
      !ManakaiDOM:ForIF
    @@Operator:
      @@@ContentType:
        lang:Perl
      @@@@:==
    @@Description:
      @@@lang:en
      @@@@:
        Return whether two <IF::NamedNodeMap>s are equal.
    @@Param:
      @@@Name:arg
      @@@Type:NamedNodeMap
      @@@Description:
        @@@@lang:en
        @@@@@:
          The node list to compare equality with.
    @@Return:
      @@@Type:DOMMain|boolean||ManakaiDOM|all
      @@@PerlDef:
        @@@@ForCheck:ForAttrMap
        @@@@@:
        __DEEP{
          EQ: {
            last EQ unless $self-><AG::NamedNodeMap.length>
                         != $arg-><AG::NamedNodeMap.length>;
            my $attr = $self->{<Q::TreeCore:node>}->{<Q::infoset:attributes>};
            my $nc = <ClassName::ManakaiDOMNode>;
            for (keys %{$attr->{<Q::ManakaiDOM:noNS>}}) {
              my $a = $attr->{<Q::ManakaiDOM:noNS>}->{$_};
              unless (<M::DOMCore:ManakaiDOMNode.isEqualNode>
                         (<Code::ManakaiNode:getWeakRef||ManakaiDOM:Perl::
                                  $object = $a, $class = $nc>,
                          $arg-><M::NamedNodeMap.getNamedItem> ($_))) {
                last EQ;
              }
            }
            for (keys %{$attr->{<Q::null:>}}) {
              my $a = $attr->{<Q::null:>}->{$_};
              unless (<M::DOMCore:ManakaiDOMNode.isEqualNode>
                         (<Code::ManakaiNode:getWeakRef||ManakaiDOM:Perl::
                                  $object = $a, $class = $nc>,
                          $arg-><M::NamedNodeMap.getNamedItemNS> (null, $_))) {
                last EQ;
              }
            }
            for my $ns (grep {$_ ne <Q::null> and $_ ne <Q::ManakaiDOM:noNS>}
                        keys %{$attr}) {
              for (keys %{$attr->{$ns}}) {
                my $a = $attr->{$ns}->{$_};
                unless (<M::DOMCore:ManakaiDOMNode.isEqualNode>
                           (<Code::ManakaiNode:getWeakRef||ManakaiDOM:Perl::
                                  $object = $a, $class = $nc>,
                            $arg-><M::NamedNodeMap.getNamedItemNS> ($ns, $_))) {
                  last EQ;
                }
              }
            }
            $r = true;
          }
        }__;
    @@ImplNote:
      @@@lang:en
      @@@@:
        See: <M::Node.isEqualNode>.
##NamedNodeMap

NodeTypeDef:
  @IFQName: CharacterData
  @ClsQName: ManakaiDOMCharacterData

  @enDesc:
    The <IF::CharacterData> interface extends the <IF::Node>
    interface with a set of attributes and methods for
    accessing character data in the DOM.  No DOM objects correspond 
    directly to the <IF::CharacterData> interface -- the
    <IF::Text> interface and the <IF::Comment> interface
    inherits this interface.

    {ps:: <doc:caption::Positions in character data>

    All <CODE::offset>s in this interface start from <CODE::0>.  Since strings in
    the DOM are represented in UTF-16, indexing
    on <IF::CharacterData> is done in 16-bit units, i.e. characters
    allocated in the range <CODE::U+10000> to <CODE::U+10FFFF>
    (inclusive) are counted as two units.
    }

    {NOTE:: DOM implementations may not put arbitary limits on 
            the amount of the data that may be stored in a 
            <IF::CharacterData> node.  This might make a node's
            data cannot fit into a single <TYPE::DOMMain:DOMString>.
            See also <X::DOMException.DOMSTRING_SIZE_ERR>.
    }

  @Attr:
    @@Name: data
    @@enDesc:
      The character data of the node.

      If the node is a <IF::DOMXML|CDATASection>, it is the
      content of the <XML::CDATA> section.  Since DOM implementation
      does no lexical check on the content of the <XML::CDATA>
      section, <A::CharacterData.data> might include the character
      sequence equals to <SGML::MSE>, i.e. <XML::]]<gt>> in XML.

     @@Get:
        @@@Type:  
          DOMMain:DOMString
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: DOMSTRING_SIZE_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The attribute would return more characters than 
              fit in a "DOMString" variable on the implementation 
              platform.
        @@@disDef:
          @@@@GetProp:
            infoset:content
     @@Set:
        @@@Type:  
          DOMMain:DOMString
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The node is read-only.
        @@@disDef:
          @@@@SetProp:
            @@@@@@:
              infoset:content
            @@@@@CheckReadOnly:1
  @Attr:
     @@Name:  length
     @@Description:
       @@@lang:en
       @@@@: 
         The number of 16-bit units of the "data".
     @@Get:
        @@@Type:  
          DOMMain:unsigned-long||ManakaiDOM|all
        @@@Description:
          @@@@lang:en
          @@@@@: The number of 16-bit units of the "data".
        @@@PerlDef:
          $r = CORE::length $self->{<Q::TreeCore:node>}->{<Q::infoset:content>};
          $r++ while $self->{<Q::TreeCore:node>}->{<Q::infoset:content>}
                       =~ /[\x{10000}-\x{10FFFF}]/g;
  @Method:
     @@Name:  substringData
     @@Description:
       @@@lang:en
       @@@@:
         Extract a range of data from the node.
     @@Param:
        @@@Name:  offset
        @@@Type:  
          DOMMain:unsigned-long||ManakaiDOM|all
        @@@Description:
          @@@@lang:en
          @@@@@: Start offset of substring to extract.
     @@Param:
        @@@Name:  count
        @@@Type:  
          DOMMain:unsigned-long||ManakaiDOM|all
        @@@Description:
          @@@@lang:en
          @@@@@:
          The number of 16-bit units to extract.  If the sum of the
          parameters offset and count exceeds the length of the
          DOMString then all 16-bit units from offset to the end
          of the DOMString are returned.
    @@Return:
      @@@Type: 
        DOMMain:DOMString
      @@@Description:
        @@@@lang:en
        @@@@@: The specified substring.
      @@@Exception:
        @@@@Type: DOMException
        @@@@Name: INDEX_SIZE_ERR
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The specified "offset" is negative or greater than
            the number of 16-bit units in the "DOMString", or the specified
            "count" is negative.
      @@@Exception:
        @@@@Type: DOMException
        @@@@Name: DOMSTRING_SIZE_ERR
        @@@@Description:
          @@@@@lang:en
          @@@@@@: The specified range does not fit into a "DOMString".
      @@@Exception:
        @@@@Type: 
          ManakaiDOM:ManakaiDOMImplementationException
        @@@@Name: MDOM_INDEX_IN_SURROGATE_PAIR
        @@@@Description:
          @@@@@lang:en
          @@@@@@: An attempt is made to break surrogate pair.
      @@@ImplNote:
        __DEEP{
          $r = <ClassM::DOMMain:ManakaiDOMString.substring>
                   (\$self->{ Q::TreeCore:node>}
                          ->{ Q::infoset:content>}, $offset, $count);
        }__;
  @Method:
     @@Name:  appendData
     @@Description:
       @@@lang:en
       @@@@:
         Append the string to the end of the character data of the node.
     @@Param:
        @@@Name:  arg
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The string to append.
     @@Return:
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: This node is read-only.
        @@@PerlDef:
            my $node = $self->{<Q::TreeCore:node>};
            if ($node->{<Q::DOMCore:read-only>}) {
              __EXCEPTION{
                MDOMX:NOMOD_THIS::
              }__;
            }
            $node->{<Q::infoset:content>} .= $arg;
  @Method:
     @@Name:  insertData
     @@Description:
       @@@lang:en
       @@@@: Insert a string at the specified 16-bit unit offset. 
    @@Param:
      @@@Name: offset
      @@@Type: 
        DOMMain:unsigned-long||ManakaiDOM|all
      @@@Description:
        @@@@lang:en
        @@@@@: The offset from which to insert.
    @@Param:
      @@@Name: arg
      @@@Type: 
        DOMMain:DOMString
      @@@Description:
        @@@@lang:en
        @@@@@: The DOMString to insert.
    @@Return:
      @@@Exception:
        @@@@Type: DOMException
        @@@@Name: INDEX_SIZE_ERR
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The specified "offset" is negative or greater than
            the number of 16-bit units in the DOMString.
      @@@Exception:
        @@@@Type: DOMException
        @@@@Name: NO_MODIFICATION_ALLOWED_ERR
        @@@@Description:
          @@@@@lang:en
          @@@@@@: This node is read-only.
      @@@Exception:
        @@@@Type: 
          ManakaiDOM:ManakaiDOMImplementationException
        @@@@Name: MDOM_INDEX_IN_SURROGATE_PAIR
        @@@@Description:
          @@@@@lang:en
          @@@@@@: An attempt is made to break surrogate pair.
      @@@ImplNote:
        if ($self->{ Q::TreeCore:node>}->{ Q::DOMCore:read-only>}) {
          __EXCEPTION{
            MDOMX:NOMOD_THIS::
          }__;
        }
        __DEEP{
          <ClassM::DOMMain:ManakaiDOMString.insert>
                   (\$self->{ Q::TreeCore:node>}
                          ->{ Q::infoset:content>}, $offset, $arg);
        }__;
  @Method:
     @@Name:  deleteData
     @@Description:
        @@@lang:en
        @@@@: 
          Remove a range of 16-bit units from the node.
    @@Param:
      @@@Name: offset
      @@@Type: 
        DOMMain:unsigned-long::ManakaiDOM:all
      @@@Description:
        @@@@lang:en
        @@@@@: The offset from which to start removing.
    @@Param:
      @@@Name: count
      @@@Type: 
        DOMMain:unsigned-long||ManakaiDOM|all
      @@@Description:
        @@@@lang:en
        @@@@@:
          The number of 16-bit units to delete.  If the sum of the
          parameters offset and count exceeds the length of the
          DOMString then all 16-bit units from offset to the end
          of the DOMString are deleted.
    @@Return:
      @@@Exception:
        @@@@Type: DOMException
        @@@@Name: INDEX_SIZE_ERR
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The specified "offset" is negative or greater than
            the number of 16-bit units in the DOMString, or the specified
            "count" is negative.
      @@@Exception:
        @@@@Type: DOMException
        @@@@Name: NO_MODIFICATION_ALLOWED_ERR
        @@@@Description:
          @@@@@lang:en
          @@@@@@: This node is read-only.
      @@@Exception:
        @@@@Type: 
          ManakaiDOM:ManakaiDOMImplementationException
        @@@@Name: MDOM_INDEX_IN_SURROGATE_PAIR
        @@@@Description:
          @@@@@lang:en
          @@@@@@: 
            An attempt is made to break surrogate pair.
      @@@ImplNote:
        if ($self->{ Q::TreeCore:node>}->{ Q::DOMCore:read-only>}) {
          __EXCEPTION{
            MDOMX:NOMOD_THIS::
          }__;
        }
        __DEEP{
          <ClassM::DOMMain:ManakaiDOMString.delete>
                   (\$self->{ Q::TreeCore:node>}
                          ->{ Q::infoset:content>}, $offset, $count);
        }__;
  @Method:
    @@Name:  replaceData
    @@Description:
      @@@lang:en
      @@@@:
        Replace the characters starting at the specified 16-bit unit 
        offset with the specified string.
    @@Param:
      @@@Name: offset
      @@@Type: 
        DOMMain:unsigned-long||ManakaiDOM|all
      @@@Description:
        @@@@lang:en
        @@@@@: The offset from which to start replacing.
    @@Param:
      @@@Name: count
      @@@Type: 
        DOMMain:unsigned-long||ManakaiDOM|all
      @@@Description:
        @@@@lang:en
        @@@@@:
          The number of 16-bit units to replace.  If the sum of the
          parameters offset and count exceeds the length of the
          DOMString then all 16-bit units from offset to the end
          of the DOMString are replaced.
    @@Param:
      @@@Name: arg
      @@@Type: 
        DOMMain:DOMString
      @@@Description:
        @@@@lang:en
        @@@@@: The DOMString with which the range is replaced.
    @@Return:
      @@@Exception:
        @@@@Type: DOMException
        @@@@Name: INDEX_SIZE_ERR
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The specified "offset" is negative or greater than
            the number of 16-bit units in the DOMString, or the specified
            "count" is negative.
      @@@Exception:
        @@@@Type: DOMException
        @@@@Name: NO_MODIFICATION_ALLOWED_ERR
        @@@@Description:
          @@@@@lang:en
          @@@@@@: This node is read-only.
      @@@Exception:
        @@@@Type: 
          ManakaiDOM:ManakaiDOMImplementationException
        @@@@Name: MDOM_INDEX_IN_SURROGATE_PAIR
        @@@@Description:
          @@@@@lang:en
          @@@@@@: An attempt is made to break surrogate pair.
      @@@ImplNote:
        if ($self->{ Q::TreeCore:node>}->{ Q::DOMCore:read-only>}) {
          __EXCEPTION{
            MDOMX:NOMOD_THIS::
          }__;
        }
        __DEEP{
          <ClassM::DOMMain:ManakaiDOMString.replace>
                   (\$self->{ Q::TreeCore:node>}
                          ->{ Q::infoset:content>}, $offset, $count, $arg);
        }__;
  @ReAttr:
     @@Name:  nodeValue
     @@Description:
       @@@lang:en
       @@@@: The value of this node.
     @@Get:
        @@@Type:  
          DOMMain:DOMString
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: DOMSTRING_SIZE_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: 
              The node value, i.e. same as "data".
        @@@disDef:
          @@@@DISPerl:cloneCode: .data.get
     @@Set:
        @@@Type:  
          DOMMain:DOMString
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: 
              The node is read-only.
        @@@Description:
          @@@@lang:en
          @@@@@:
            New node value.
        @@@disDef:
          @@@@DISPerl:cloneCode: .data.set
    @@Level[list]:
      1
      2
      3
    @@SpecLevel:1
  @ReAttr:
     @@Name:  textContent
     @@Description:
       @@@lang:en
       @@@@: The text content of this node and its descendants.
     @@ImplNote:
        @@@lang:en
        @@@@:
          CharacterData->data == CharacterData->nodeValue == 
          CharacterData->textContent.
     @@Get:
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            The text content of this node, i.e. the "nodeValue".
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: DOMSTRING_SIZE_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The attribute would return more characters than 
              fit in a "DOMString" variable on the implementation 
              platform.
        @@@disDef:
          @@@@DISPerl:cloneCode: .data.get
     @@Set:
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            The new text content of the node.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: 
              The text content is set to the empty.  Note that the 
              DOM specification does not specify how to treat the "null".
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: This node is read-only.
        @@@disDef:
          @@@@DISPerl:cloneCode: .data.set
     @@Level[list]:
        3
     @@SpecLevel:3
     @@For:
       ManakaiDOM:DOM3
##CharacterData

NodeTypeDef:
  @IFQName: Attr
  @ClsQName: ManakaiDOMAttr

  @DISLang:role: AttributeRole

  @Description:
    @@lang:en
    @@@:
      An attribute in an "Element" object.
    \
      The DOM Core treats the attribute values as a plain string, even if 
      the schema language defines them as having tokenized types.
  @ImplNote:
    @@lang:en
    @@@:
      If the implementation knows about the schema in use when 
      the attribute value is changed, and it is of a different type 
      than "CDATA", it may normalize it at that time. [SVG DOM, DOM 3]
  @Attr:
     @@Name:  name
     @@Description:
       @@@lang:en
       @@@@: The name of this attribute.
     @@Get:
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The attribute name. 
        @@@InCase:
          @@@@Label: Qualified name
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              If the "localName" is different from "null".
        @@@PerlDef:
            my $node = $self->{<Q::TreeCore:node>};
            if (defined $node->{<Q::infoset:localName>}) {
              $r = (defined $node->{<Q::infoset:prefix>} ?
                   $node->{<Q::infoset:prefix>} . ':' : '') . 
                   $node->{<Q::infoset:localName>};
            } else {
              $r = $node->{<Q::DOMCore:name>};
            }
        @@@ImplNote:
          @@@@lang:en
          @@@@@:
            "Element.tagName" is defined to return the uppercase name 
            if the document is an HTML document.  "Attr.name" is not 
            defined so.
  @Attr:
     @@Name:  specified
     @@Description:
       @@@lang:en
       @@@@: Whether this attribute is specified explicitly in the document.
     @@Get:
        @@@Type:  DOMMain|boolean||ManakaiDOM|all
        @@@InCase:
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              This attribute is explicitly given a value in the 
              instance document.
        @@@InCase:
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              This attribute is not explicitly given a value in the 
              instance document.
        @@@disDef:
          @@@@GetProp:
             infoset:specified
    @@ImplNote:
       @@@lang:en
       @@@@:
         This attribute is set to "true" if the DOM application 
         changed the value of this attribute node (even if it ends up 
         having the same value as the default value).
    @@ImplNote:
       @@@lang:en
       @@@@:
         The implementation may handle attributes with default 
         values from other schemas than DTD and XML Schema but 
         the DOM application should use "normalizeDocument" to 
         guarantee this information is up-to-date.
    @@ImplNote:
      @@@lang:en
      @@@@:
        Removing an attribute node may generate a new attribute 
        node with the default value and "specified" set to "false".
      \
        When "normalizeDocument" is invoked, non-"specified" 
        attribute nodes are recomputed according to the defaulu 
        attribute value.
    @@ImplNote:
      @@@lang:en
      @@@@: 
        The DOM Level 1 Specification (Second Edition) and the 
        DOM Level 2 Specification says that if the "ownerElement" 
        is "null", "specified" is always "true".  The DOM Level 3 
        Specification does not address this case.
## TODO: Some mechanism required to turn the "specified" attribute "true" 
## when some node operation is done.
  @Attr:
     @@Name:  value
     @@Description:
       @@@lang:en
       @@@@: The value of this attribute.
     @@Get:
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            The attribute value as a string.
        @@@disDef:
          @@@@DISPerl:cloneCode: 
            DOMCore:ManakaiDOMNode.textContent.get
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              This definition might be updated when the new level 
              of the DOM is introduced.
        @@@ImplNote:
          @@@@lang:en
          @@@@@:
            Although the specification says nothing, the Attr->value and 
            Attr->textContent should have the same value by nature.
     @@Set:
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            Setting of this attribute creates a "Text" node with 
            the value specified and replaces child nodes of this 
            node with it.
        @@@ImplNote:
          @@@@lang:en
          @@@@@:
            The DOM implementation may normalize the value [DOM 3, SVG DOM].
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: This node is read-only.
          @@@@SpecLevel:1
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              This exception is added in the DOM Level 1 Errata and 
              incorporated into the DOM Level 1 Second Edition.
        @@@PerlDef:
          __CODE{DOMCore:setNodeTextContent::
                    $node => $self, $given => $given}__;
  @Attr:
     @@Name:  ownerElement
     @@Description:
       @@@lang:en
       @@@@:
         The element to which this attribute is attached.
     @@Get:
        @@@Type:  Element
        @@@Description:
          @@@@lang:en
          @@@@@: The "Element" node.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: This attribute is not in use.
        @@@disDef:
          @@@@GetPropNode:
            infoset:ownerElement
     @@Level[list]:  
        2
        3
     @@SpecLevel:2
     @@For:
       ManakaiDOM:DOM2
  @Attr:
     @@Name:  schemaTypeInfo
     @@Description:
       @@@lang:en
       @@@@:
         The type information associated with this node.
        \
         Note that while this type information is guarantee 
         to be correct after loading the validation, 
         it may not be reliable if the node was moved.
     @@Get:
        @@@Type:  TypeInfo
        @@@Description:
          @@@@lang:en
          @@@@@: The type information.
     @@Level[list]:  3
     @@SpecLevel:3
     @@For:
       ManakaiDOM:DOM3

  @Attr:
     @@Name:  isId
     @@Description:
       @@@lang:en
       @@@@:
         Whether this attribute is known to be of type ID or not.
     @@ImplNote:
       @@@lang:en
       @@@@:
         The ways to determine whether an attribute node is known 
         to contain an identifier:
        \
         PSVI - If validation occurred using an XML Schema, the PSVI 
         contributions values are used to determine whether this 
         attribute is a Schema-determined ID attribute as the 
         XPointer specification defines, i.e. iif one of the following 
         is true:
        \
         1. The attribute information item has a [memeber type definition] or 
         [type definition] property whose value in turn has [name] eq "ID" 
         and [target namespace] eq "http://www.w3.org/2001/XMLSchema".
        \
         2. The attribute information item has a [base type definition] 
         property whose value in turn has [name] eq "ID"
         and [target namespace] eq "http://www.w3.org/2001/XMLSchema".
        \
         3. The attribute information item has a [base type definition] 
         property whose value has a [base type definition] property 
         whose value has ... whose value in turn has [name] eq "ID"
         and [target namespace] eq "http://www.w3.org/2001/XMLSchema".
        \
         4. The attribute information item has a [type definition name] 
         eq "ID" and a [type definition namespace] eq 
         "http://www.w3.org/2001/XMLSchema".
        \
         5. The attribute information item has a 
         [member type definition name] eq "ID" and a 
         [member type definition namespace] eq 
         "http://www.w3.org/2001/XMLSchema".
        \
         DTD - If validation occured using a DTD, the infoset 
         [type definition] value is used to determine whether 
         this attribute is a DTD-determined ID attribute as the 
         XPointer framework specification defines.  Iif the 
         attribute information item has a [type definition] property 
         eq "ID", it is a DTD-determined ID attribute.
        \
         User-determined - If the methods "setIdAttribute", 
         "setIdAttributeNS", "setIdAttributeNode" was used, 
         it is an user-determined ID attribute.
        \
         Externally-determined - Other mechanisms, including other 
         schema languages than DTD and XML Schema may provide 
         ways to determine whether it is a ID attribute.
     @@Get:
        @@@Type:  DOMMain|boolean||ManakaiDOM|all
        @@@InCase:
          @@@@Value:true
          @@@@Description:
            @@@@@lang:en
            @@@@@@: 
              This attribute is a ID attribute.
        @@@InCase:
          @@@@Value:false
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              This attribute is not a ID attribute.
        @@@PerlDef:
          @@@@@:
            $r = $self->{<Q::TreeCore:node>}->{<Q::DOMCore:userDeterminedId>};
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              TODO: Support non-user-determined ID attributes.

     @@Level[list]:  3
     @@SpecLevel:3

     @@For:
       ManakaiDOM:DOM3
     @@For:
       ManakaiDOM:ManakaiDOM

     @@ManakaiDOM:isForInternal:
       @@@@:1
       @@@ForCheck:
         !ManakaiDOM:DOM3
  
  @ReAttr:
     @@Name:  localName
     @@Description:
       @@@lang:en
       @@@@: The local part of the qualified name of this "Attr" node.
     @@Get:
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            The local name of the attribute.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The node is created with a DOM Level 1 methods.
        @@@disDef:
          @@@@GetProp:
            infoset:localName
     @@Level[list]:  2
     @@SpecLevel:2
     @@For:
       ManakaiDOM:DOM2
  @ReMethod:
     @@Name:  lookupPrefix
     @@Description:
       @@@lang:en
       @@@@:
         Lookup the namespace prefix associated to the given namespace 
         URI, starting from this node.
       \
         The default namespace declarations are ignored by this method. 
         To lookup default namespace, use the <M::Node.isDefaultNamespace>
         method.
     @@Param:
        @@@Name:  namespaceURI
        @@@Type:
          DOMMain:DOMString
        @@@actualType:
          ManakaiDOM:ManakaiDOMNamespaceURI
        @@@Description:
          @@@@lang:en
          @@@@@: The namespace URI to look for.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Always <DOM::null> will be returned.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Always <DOM::null> will be returned.
     @@Return:
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            An associated namespace prefix.
          \
            If more than one prefix are associated to the 
            namespace URI, which is returned is implementation 
            dependent.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              No namespace prefix is found.
        @@@PerlDef:
            if (not defined $namespaceURI) {
              $r = null;
            } else {
              my $n = $self->{<Q::TreeCore:node>};
              if ($n->{<Q::infoset:ownerElement>}) {
                $r = $n->{<Q::infoset:ownerElement>}
                       -><M::ManakaiDOMCore:ManakaiDOMNodeObjectNode
                             .lookupNamespacePrefix>
                                ($namespaceURI, $n->{<Q::infoset:ownerElement>});
              } else {
                $r = null;
              }
            }
     @@For:
       ManakaiDOM:DOM3
     @@Level[list]:  3
     @@SpecLevel:3
  @ReAttr:
     @@Name:  namespaceURI
     @@Description:
       @@@lang:en
       @@@@:
         The namespace URI of this node.
     @@Get:
        @@@Type:  
          DOMMain:DOMString
        @@@actualType:
          ManakaiDOM:ManakaiDOMNamespaceURI
        @@@Description:
          @@@@lang:en
          @@@@@: The namespace URI.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The namespace URI is unspecified (the attribute in a 
              per-element-type partition) or 
              the node is created with a DOM Level 1 methods.
        @@@disDef:
          @@@@GetProp:
            infoset:namespaceName
     @@For:
       ManakaiDOM:DOM2
     @@Level[list]:  2
     @@SpecLevel:2
  @ReAttr:
    @@Name: nodeName
    @@Description:
      @@@lang:en
      @@@@: The node name.
    @@DOMMain:isNamespaceUnaware:1
    @@Get:
      @@@Type: 
        DOMMain:DOMString
      @@@Description:
        @@@@lang:en
        @@@@@:
          The attribute name.  It is same as the value of the "name" 
          attribute.
      @@@disDef:
        @@@@DISPerl:cloneCode:
          .name.get
  @ReAttr:
    @@Name: nodeType
    @@Description:
      @@@lang:en
      @@@@: The type of this node.
    @@Get:
      @@@Type: 
        DOMMain:unsigned-short||ManakaiDOM|all
      @@@actualType: ManakaiDOMNodeType
      @@@InCase:
        @@@@Label: ATTRIBUTE_NODE
        @@@@Description:
          @@@@@lang:en
          @@@@@@: The node is an "Attr".
      @@@disDef:
        @@@@DISLang:constValue: 
          Node.ATTRIBUTE_NODE
  @ReAttr:
     @@Name:  nodeValue
     @@Description:
       @@@lang:en
       @@@@: The value of this node.
     @@Get:
        @@@Type:  
          DOMMain:DOMString
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: DOMSTRING_SIZE_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: 
              The attribute value, i.e. same as "value".
        @@@disDef:
          @@@@DISPerl:cloneCode:
            ManakaiDOMAttr.value.get
     @@Set:
        @@@Type:  
          DOMMain:DOMString
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: 
              The node is read-only.
        @@@Description:
          @@@@lang:en
          @@@@@:
            New node value.
        @@@disDef:
          @@@@DISPerl:cloneCode: ManakaiDOMAttr.value.set
    @@Level[list]:
        1
        2
        3
    @@SpecLevel:1
  @ReAttr:
     @@Name:  prefix
     @@Description:
       @@@lang:en
       @@@@: The namespace prefix of this node.
     @@DOMMain:isNamespaceAware:1
     @@Type:  
       DOMMain:DOMString
     @@actualType:
       DOMMain:ManakaiDOMNamespacePrefix
     @@Get:
        @@@Description:
          @@@@lang:en
          @@@@@: The namespace prefix.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Either the namespace prefix is unspecified or the node 
              is created with a DOM Level 1 method.
        @@@disDef:
          @@@@GetProp:
            infoset:prefix
     @@Set:
        @@@Description:
          @@@@lang:en
          @@@@@:
            The namespace prefix.
            Note that setting this attribute has no effect if 
            the namespace prefix is defined to be "null".
          \
            Note also that changing the prefix of an attribute that 
            is known to have a default value does not make a 
            new attribute with the default value and the original 
            prefix appear, since the "namespaceURI" and "localName" 
            do not change.  This is different from the defaulting 
            mechanism of the DTD, which is namespace-unaware.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The namespace prefix is unspecified.
        @@@InCase:
          @@@@Value: \
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The result is implementation dependent <SRC::DOM Level 3>.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: INVALID_CHARACTER_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The specified prefix contains an illegal character 
              accoding to the XML version in use in the document.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: This node is read-only.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NAMESPACE_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Either the specified prefix is malformed per the 
              XML Namespace specification, non-"null" prefix is 
              specified but the "namespaceURI" of this node is "null", 
              the specified prefix is "xml" and the "namespaceURI" 
              of this node is different from 
              "http://www.w3.org/XML/1998/namespace", the specified 
              prefix is "xmlns" and the "namespaceURI" of this node 
              is different from "http://www.w3.org/2000/xmlns/", or 
              the "qualifiedName" of this node is "xmlns".
        @@@PerlDef:
            my $node = $self->{<Q::TreeCore:node>};
            my $docnode = $node->{<Q::DOMCore:ownerDocument>};
            my $version = <Code::getDocumentXMLVersion:: $DOCOBJ = $docnode>;
            if (not defined $version) {
              __WARNING{
                MDOMX:MDOM_DOC_NOSUPPORT_XML::
              }__;
            } elsif (not defined $node->{<Q::infoset:localName>}) {
              __WARNING{
                MDOMX:MDOM_NODE_NOSUPPORT_XMLNS::
              }__;
            } elsif ($node->{<Q::DOMCore:read-only>}) {
              __WARNING{
                MDOMX:NOMOD_THIS::
              }__;
            } elsif (not defined $node->{<Q::infoset:prefix>} and
                     $node->{<Q::infoset:localName>} and
                     $node->{<Q::infoset:localName>} eq 'xmlns') {
              __EXCEPTION{
                MDOMX:MDOM_NS_QNAME_IS_XMLNS::
              }__;
            } else {
              __CODE{DOMMain:ensureNamespacePrefix::
                $INPUT => $given, $INPUT_PARAM_NAME => '',
                $XMLVERSION => $version,
              }__;
              my $nsURI = $node->{<Q::infoset:namespaceName>};
              if (not defined $given) {
                if (defined $nsURI) {
                  __EXCEPTION{MDOMX:MDOM_NS_NOPREFIX_WITH_NON_NULL_URI::
                    infoset:namespaceName
                        => {$node->{<Q::infoset:namespaceName>}},
                    DOMCore:qualifiedName => {$node->{<Q::infoset:localName>}},
                  }__;
                }
              } else {  ## Non-n u l l prefix
                if (not defined $nsURI) {
                  __EXCEPTION{
                    MDOMX:MDOM_NS_PREFIX_WITH_NULL_URI::
                      infoset:prefix => {$given},
                  }__;
                } elsif ($given eq 'xml' and $nsURI ne <Q::xml:>) {
                  __EXCEPTION{
                    MDOMX:MDOM_NS_XML_WITH_OTHER_URI::
                      infoset:prefix => {$given},
                      infoset:namespaceName => {$nsURI},
                  }__;
                } elsif ($given eq 'xmlns' and $nsURI ne <Q::xmlns:>) {
                  __EXCEPTION{
                    MDOMX:MDOM_NS_XMLNS_WITH_OTHER_URI::
                      infoset:prefix => {$given},
                      infoset:namespaceName => {$nsURI},
                  }__;
                } elsif ($nsURI eq <Q::xml:> and $given ne 'xml') {
                  __EXCEPTION{MDOMX:MDOM_NS_OTHER_WITH_XML_URI::
                    infoset:prefix => {$given},
                    infoset:namespaceName => {$nsURI},
                  }__;
                } elsif ($nsURI eq <Q::xmlns:> and $given ne 'xmlns') {
                  __EXCEPTION{MDOMX:MDOM_NS_OTHER_WITH_XMLNS_URI::
                    infoset:prefix => {$given},
                    infoset:namespaceName => {$nsURI},
                  }__;
                }
              }
              $node->{<Q::infoset:prefix>} = $given;
            }
     @@Level[list]:
       2
       3
     @@SpecLevel:2
     @@For:
       ManakaiDOM:DOM2

  @IntMethod:
    @@Name: newObject
    @@Description:
      @@@lang:en
      @@@@:
        Construct an object for a new instance of the <IF::Attr> node.
    @@ManakaiDOM:isStatic:1
    @@Return:
      @@@Type: NodeStem
      @@@Description:
        @@@@lang:en
        @@@@@:
          The new object for the <IF::Attr> node.
      @@@PerlDef:
          $r = <ClassM::ManakaiDOMNode.newObject>;
          push @{$r->{<Q::TreeCore:origin>}}, <Q::infoset:ownerElement>;
          push @{$r->{<Q::TreeCore:subnode>}}, <Q::infoset:children>;
          $r->{<Q::infoset:children>} = [];
          $r->{<Q::DOMCore:nodeType>} = <Q::infoset:Attribute>;
     @@ImplNote:
       @@@lang:en
       @@@@:
         Other properties required to be a legal <IF::Attr> object:
         Either <Q::DOMCore:name> or <Q::infoset:localName>, 
         <Q::DOMCore:ownerDocument>.
       \
         Other available properties: <Q::infoset:prefix>, 
         <Q::DOMCore:read-only>, <Q::infoset:specified>, 
         <Q::infoset:ownerElement>, <Q::infoset:children>, 
         <Q::infoset:namespaceName>, <Q::DOMCore:userDeterminedId>.

  @Method:
     @@Name:  getFeature
     @@enDesc:
       Returns a specialized object that implements the
       specialized interfaces of the specified feature and version.
     @@ManakaiDOM:isRedefining:1
     @@ForCheck: ManakaiDOM|ForClass ManakaiDOM|DOM3
     @@Param:
        @@@Name:  feature
        @@@Type:  
          DOMMain:DOMString
        @@@actualType: ManakaiDOM|ManakaiDOMFeatureName
        @@@enDesc:
          The feature name to request.
        @@@InCase:
          @@@@Label:
            @@@@@lang:en
            @@@@@@: 
              Feature name preceded by a <CHAR::PLUS SIGN>
          @@@@enDesc:
            The <CHAR::PLUS SIGN> is ignored.
     @@Param:
        @@@Name:  version
        @@@Type:  
          DOMMain:DOMString
        @@@actualType: ManakaiDOM|ManakaiDOMFeatureVersion
        @@@enDesc:
          The feature version to request.
        @@@nullCase:
          @@@@enDesc:
            No specific version is requested.
     @@Return:
        @@@Type:  
          DOMMain:DOMObject
        @@@enDesc:
          An object implementing the specialized interfaces.
          Note that the specialized object may or may not
          implement the <IF::Node> interface.
        @@@nullCase:
          @@@@enDesc:
            There is no object available that implements
            the specialized interfaces.
        @@@PerlDef:
            $feature =~ s/^\+//;
            if ($Message::DOM::ClassFeature{ref $self}->{$feature}->{$version}) {
              ## This class
              $r = $self;
            } else {
              ## Attribute name dependent classes
                ## TODO:
              ## Attribute name independent classes
              CLASS: for my $class (grep {
                $Message::DOM::ManakaiDOMAttr::CompatClass{$_}
              } keys %Message::DOM::ManakaiDOMAttr::CompatClass) {
                if ($Message::DOM::ClassFeature{$class}
                            ->{$feature}->{$version}) {
                  __CODE{getNodeRef::
                    $object => {$self->{<Q::TreeCore:node>}},
                    $ref => $r,
                    $class => $class,
                  }__;
                  last CLASS;
                }
              }
            }
##Attr

NodeTypeDef:
  @IFQName: Element
  @ClsQName: ManakaiDOMElement

  @DISLang:role: ElementRole

  @Description:
    @@lang:en
    @@@:
      An element in a document.
  @Attr:
     @@Name:  tagName
     @@Description:
       @@@lang:en
       @@@@: The element type name of this node.
     @@Get:
        @@@Type:  
          DOMMain:DOMString
        @@@InCase:
          @@@@Label:
            @@@@@@: Qualified name
            @@@@@lang:en
          @@@@actualType:
            DOMMain:ManakaiDOMXMLQName
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              If the <A::Node.localName> is different from <DOM::null>.
        @@@InCase:
          @@@@Label: 
            @@@@@@:Canonical uppercase form of name
            @@@@@lang:en
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              If this is an HTML element node.
        @@@PerlDef:
          @@@@@:
            my $node = $self->{<Q::TreeCore:node>};
            if (defined $node->{<Q::infoset:localName>}) {
              $r = (defined $node->{<Q::infoset:prefix>} ?
                   $node->{<Q::infoset:prefix>} . ':' : '') . 
                   $node->{<Q::infoset:localName>};
            } else {
              $r = $node->{<Q::DOMCore:name>};
            }
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              The manakai DOM implementation has HTML element type names 
              as uppercase normalized form so that no convertion is 
              required in this attribute.

  @ResourceDef:
    @@ForCheck:
      ManakaiDOM:ManakaiDOM ManakaiDOM:ForClass
    @@rdf:type:
      @@@@:
        dis:MultipleResource
      @@@ForCheck:
        !ForSelect !ForRemove
    @@resourceFor: ForSelect
    @@resourceFor: ForRemove

    @@QName:
      @@@@: selectAttrNodeObject
      @@@ForCheck: ForSelect
    @@NSVersion:
      @@@@: selectAttrNodeObjectNS
      @@@ForCheck: ForSelect
      @@@ContentType:
        dis:TFQNames
    @@rdf:type:
      @@@@:
        dis2pm:BlockCode
      @@@ForCheck: ForSelect

    @@QName:
      @@@@: selectAttrNodeObjectForRemove
      @@@ForCheck: ForRemove
    @@NSVersion:
      @@@@: selectAttrNodeObjectForRemoveNS
      @@@ForCheck: ForRemove
      @@@ContentType:
        dis:TFQNames
    @@rdf:type:
      @@@@:
        dis2pm:BlockCode
      @@@ForCheck: ForRemove

    @@Description:
      @@@lang:en
      @@@@:
        Select an <IF::ManakaiDOMNodeObject> object that represents an 
        <IF::Attr> node.

    @@Param:
      @@@Name:name
      @@@Type:
        @@@@@:
          DOMMain:ManakaiDOMXMLName
        @@@@ManakaiDOM:noInputNormalize:1
      @@@Description:
        @@@@lang:en
        @@@@@:
          The name of the attribute to select.
    @@Return:
      @@@Type: NodeStem
      @@@Description:
        @@@@lang:en
        @@@@@:
          The <IF::ManakaiDOMNodeObject> object.
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@: There is no such attribute.
    @@PerlDef:
            my $attr = $self->{<Q::TreeCore:node>}->{<Q::infoset:attributes>};
            if ($attr->{<Q::ManakaiDOM:noNS>}->{$name}) {
              $r = $attr->{<Q::ManakaiDOM:noNS>}->{$name};
              __FOR{ForRemove::
                CORE::delete $attr->{<Q::ManakaiDOM:noNS>};
              }__;
            } elsif ($name eq 'xmlns') {
              for my $a (keys %{$attr->{<Q::xmlns:>}||{}}) {
                if ($attr->{<Q::xmlns:>}->{$a}->{<Q::infoset:localName>}) {
                  $r = $attr->{<Q::xmlns:>}->{$a};
                  __FOR{ForRemove::
                    CORE::delete $attr->{<Q::xmlns:>}->{$a};
                  }__;
                  last;
               }
              }
            } elsif ($name eq 'xmlns:xmlns') {
              # 
            } else {
              for my $ns (keys %$attr) {
                if ($ns eq <Q::ManakaiDOM:noNS>) {
                  # 
                } else {
                  for my $a (keys %{$attr->{$ns}||{}}) {
                    if (defined $attr->{$ns}->{$a}->{<Q::infoset:prefix>} and
                        $attr->{$ns}->{$a}->{<Q::infoset:prefix>}.':'.
                        $attr->{$ns}->{$a}->{<Q::infoset:localName>} eq $name) {
                      $r = $attr->{$ns}->{$a};
                      __FOR{ForRemove::
                        CORE::delete $attr->{$ns}->{$a};
                      }__;
                      last;
                    } elsif (not defined $attr->{$ns}->{$a}
                                              ->{<Q::infoset:prefix>} and
                         $attr->{$ns}->{$a}->{<Q::infoset:localName>} eq $name) {
                      $r = $attr->{$ns}->{$a};
                      __FOR{ForRemove::
                        CORE::delete $attr->{$ns}->{$a};
                      }__;
                      last;
                    }
                  }
                }
              }
            }
  @Method:
     @@Name:  getAttribute
     @@Description:
       @@@lang:en
       @@@@:
         Retrieves an attribute value by name.
     @@NSVersion:.getAttribute
     @@Param:
        @@@Name:  name
        @@@Type:  
          DOMMain:DOMString
        @@@actualType:
          @@@@@:
            DOMMain:ManakaiDOMXMLName
          @@@@ManakaiDOM:noInputNormalize:1
        @@@Description:
          @@@@lang:en
          @@@@@:
            The name of the attribute to retrieve.
     @@Return:
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            The <IF::Attr> value as a string.
        @@@InCase:
          @@@@Value:\
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              That attribute does not have a specified or default value.
        @@@PerlDef:
          __CODE{selectAttrNodeObject}__;
          if ($r) {
            __CODE{ManakaiNode:getWeakReference||ManakaiDOM:Perl::
              $object => $r, $ref => $r,
              $class => {<ClassName::ManakaiDOMAttr>},
            }__;
            $r = $r-><AG::DOMCore:Node.textContent>;
          } else {
            $r = '';
          }
  @Method:
     @@Name:  setAttribute
     @@Description:
       @@@lang:en
       @@@@:
         Add a new attribute.  If an attribute with that name is 
         already present in the element, its value is changed. 
     @@NSVersion:.setAttributeNS
     @@Param:
        @@@Name:  name
        @@@Type:  
          DOMMain:DOMString
        @@@actualType:
          @@@@@:
            DOMMain:ManakaiDOMXMLName
          @@@@ManakaiDOM:noInputNormalize:1
        @@@Description:
          @@@@lang:en
          @@@@@: The name of the attribute to create or alter.
     @@Param:
        @@@Name:  value
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The value to set.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              How to process <DOM::null> <P::value> is not mentioned.
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The manakai DOM implementation converts <DOM::null> value 
              to an empty string. 
            @@@@@For:
              ManakaiDOM:ManakaiDOM
     @@Return:
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:INVALID_CHARACTER_ERR
          @@@@SubType:
            @@@@@QName:
              MDOMX:MDOM_BAD_NAME
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <P::name> is not a legal SGML or XML <CODE::Name>.
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:NO_MODIFICATION_ALLOWED_ERR
          @@@@SubType:
            @@@@@QName:
              MDOMX:NOMOD_THIS
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                This (<IF::Element>) node is read-only.
            @@@@@SpecLevel:1
          @@@@SubType:
            @@@@@QName:
              MDOMX:NOMOD_ATTR
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <IF::Attr> node to edit is read-only.
            @@@@@SpecLevel[list]:
        @@@PerlDef:
            if ($self->{<Q::TreeCore:node>}->{<Q::DOMCore:read-only>}) {
              __EXCEPTION{
                MDOMX:NOMOD_THIS::
              }__;
            }
            my $r;
            __CODE{selectAttrNodeObject}__;
            my $node = $self->{<Q::TreeCore:node>};
            if ($r) {
              if ($r->{<Q::DOMCore:read-only>}) {
                __EXCEPTION{
                  MDOMX:NOMOD_ATTR::
                }__;
              }
              my @children = @{$r->{<Q::infoset:children>}};
              $r->{<Q::infoset:children>} = [];
              for (@children) {
                CORE::delete $_->{<Q::infoset:parent>};
                $_-><M::NodeStem.orphanate>;
              }
            } else {
              my $docNode = $self->{<Q::DOMCore:ownerDocument>};
              my $version = <Code::getDocumentXMLVersion:: $DOCOBJ = $docNode>;
              __CODE{DOMMain:ensureXMLName:: $INPUT => $name,
                                             $INPUT_PARAM_NAME => 'name',
                                             $XMLVERSION => $version}__;
              $r = <ClassM::ManakaiDOMAttr.newObject>;
              $r->{<Q::DOMCore:name>} = $name;
              $node-><M::NodeStem.importTree> ($r);
              $r->{<Q::infoset:ownerElement>} = $node;
              $r->{<Q::DOMCore:ownerDocument>} = $node
                                                 ->{<Q::DOMCore:ownerDocument>};
              $node->{<Q::infoset:attributes>}
                   ->{<Q::ManakaiDOM:noNS>}->{$name} = $r;
            }
            my $text = <ClassM::ManakaiDOMText.newObject>;
            $node-><M::NodeStem.importTree> ($text);
            $text->{<Q::infoset:content>} = defined $value ? $value : '';
            $text->{<Q::DOMCore:ownerDocument>} = $self->{<Q::TreeCore:node>}
                                                 ->{<Q::DOMCore:ownerDocument>};
            $text->{<Q::infoset:parent>} = $r;
            $r->{<Q::infoset:children>} = [$text];
            $r->{<Q::infoset:specified>} = true;
     @@SpecLevel:1
  @Method:
     @@Name:  removeAttribute
     @@Description:
       @@@lang:en
       @@@@:
         Remove an attribute by name.
       \
         If a default value for the removed attribute is defined in 
         the DTD, a new attribute immediately appears.  The DOM 
         implementation may handle default values from other schemas.
     @@NSVersion:.removeAttributeNS
     @@Param:
        @@@Name:  name
        @@@Type:  
          DOMMain:DOMString
        @@@actualType:
          @@@@@:
            DOMMain:ManakaiDOMXMLName
          @@@@ManakaiDOM:noInputNormalize:1
        @@@Description:
          @@@@lang:en
          @@@@@:
            The name of the attribute to remove.  If no attribute 
            with this <P::name> is found, this method has no effect.
     @@Return:
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:NO_MODIFICATION_ALLOWED_ERR
          @@@@SubType:
            @@@@@QName:
              MDOMX:NOMOD_THIS
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                This (<IF::Element>) node is read-only.
        @@@PerlDef:
          @@@@@:
            if ($self->{<Q::TreeCore:node>}->{<Q::DOMCore:read-only>}) {
              __EXCEPTION{
                MDOMX:NOMOD_THIS::
              }__;
            }
            my $r;
            __CODE{selectAttrNodeObjectForRemove}__;
            if ($r) {
              CORE::delete $r->{<Q::infoset:ownerElement>};
              $r-><M::NodeStem.orphanate>;
            }
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              TODO: Default attribute
  @Method:
     @@Name:  getAttributeNode
     @@Description:
       @@@lang:en
       @@@@:
         Retrieve an attribute node by name.
     @@NSVersion:.getAttributeNodeNS
     @@Param:
        @@@Name:  name
        @@@Type:  
          DOMMain:DOMString
        @@@actualType:
          @@@@@:
            DOMMain:ManakaiDOMXMLName
          @@@@ManakaiDOM:noInputNormalize:1
        @@@Description:
          @@@@lang:en
          @@@@@:
            The name (<A::Node.nodeName>) of the attribute to retrieve.
     @@Return:
        @@@Type:  Attr
        @@@actualType: ManakaiDOMAttr
        @@@Description:
          @@@@lang:en
          @@@@@:
            The <IF::Attr> node with the specified name.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: There is no such attribute.
        @@@PerlDef:
            my $obj;
            __CODE{selectAttrNodeObject:: $r => $obj}__;
            if ($obj) {
              $r = <ClassM::ManakaiDOMNode.getNodeReference> ($obj);
            }
  @Method:
     @@Name:  setAttributeNode
     @@Description:
       @@@lang:en
       @@@@:
         Add a new attribute node.  If an attribute with that name is 
         already present in the element, it is replaced by the new one. 
         \
         Replacing an attribute node by itself has no effect.
     @@NSVersion:.setAttributeNodeNS
     @@Param:
        @@@Name:  newAttr
        @@@Type:  Attr
        @@@actualType: ManakaiDOMAttr
        @@@Description:
          @@@@lang:en
          @@@@@: 
            The <IF::Attr> node to add to the attribute list.
     @@Return:
        @@@Type:  Attr
        @@@actualType: ManakaiDOMAttr
        @@@Description:
          @@@@lang:en
          @@@@@:
            The replaced <IF::Attr> node.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              No <IF::Attr> node was replaced.
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:WRONG_DOCUMENT_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The <P::newAttr> node was created from a different document.
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:NO_MODIFICATION_ALLOWED_ERR
          @@@@SubType:
            @@@@@QName:
              MDOMX:NOMOD_THIS
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@: 
                This (<IF::Element>) node is read-only.
         @@@Exception:
           @@@@Type:DOMException
           @@@@Name:INUSE_ATTRIBUTE_ERR
           @@@@Description:
             @@@@@lang:en
             @@@@@@:
               The <P::newAttr> node is already used as an attribute 
               of another <IF::Element> object.
         @@@PerlDef:
            if ($self->{<Q::TreeCore:node>}->{<Q::DOMCore:read-only>}) {
              __EXCEPTION{
                MDOMX:NOMOD_THIS::
              }__;
            }
            my $attrNode = $newAttr->{<Q::TreeCore:node>};
            if ($attrNode->{<Q::infoset:ownerElement>}) {
              __EXCEPTION{
                ManakaiDOMException.INUSE_ATTRIBUTE_ERR::
                  MDOMX:param-name => 'newAttr',
              }__;
            } elsif ($attrNode->{<Q::DOMCore:ownerDocument>}
                              ->{<Q::TreeCore:nodeID>} ne
                     $self->{<Q::TreeCore:node>}->{<Q::DOMCore:ownerDocument>}
                          ->{<Q::TreeCore:nodeID>}) {
              __EXCEPTION{
                ManakaiDOMException.WRONG_DOCUMENT_ERR::
              }__;
            }

            if (defined $attrNode->{<Q::infoset:localName>}) {
              $r = $self->{<Q::TreeCore:node>}->{<Q::infoset:attributes>}
                     ->{defined $attrNode->{<Q::infoset:namespaceName>}
                              ? $attrNode->{<Q::infoset:namespaceName>}
                              : <Q::null:>}
                     ->{$attrNode->{<Q::infoset:localName>}};
            } else {
              $r = $self->{<Q::TreeCore:node>}->{<Q::infoset:attributes>}
                     ->{<Q::ManakaiDOM:noNS>}
                     ->{$attrNode->{<Q::DOMCore:name>}};
            }

            if (defined $r and
                $r->{<Q::TreeCore:nodeID>} eq $attrNode->{<Q::TreeCore:nodeID>}) {
              __WARNING{
                MDOMX:MDOM_REPLACE_BY_ITSELF_NO_EFFECT::
              }__;
              $r = $newAttr;
            } else {
              $attrNode->{<Q::infoset:ownerElement>} = $self->{<Q::TreeCore:node>};
              if (defined $attrNode->{<Q::infoset:localName>}) {
                $self->{<Q::TreeCore:node>}->{<Q::infoset:attributes>}
                     ->{defined $attrNode->{<Q::infoset:namespaceName>}
                              ? $attrNode->{<Q::infoset:namespaceName>}
                              : <Q::null:>}
                     ->{$attrNode->{<Q::infoset:localName>}} = $attrNode;
              } else {
                $self->{<Q::TreeCore:node>}->{<Q::infoset:attributes>}
                     ->{<Q::ManakaiDOM:noNS>}
                     ->{$attrNode->{<Q::DOMCore:name>}} = $attrNode;
              }
              if ($r) {
                my $obj = $r;
                $r = <ClassM::ManakaiDOMNode.getNodeReference> ($obj)
                  if defined wantarray;
                CORE::delete $obj->{<Q::infoset:parent>};
                $obj-><M::NodeStem.orphanate>;
              }
            }
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              It is unclear whether a node should be returned if 
              it is <QUOTE::replace>d by itself.
    @@Level[list]:
       1
       2
       3
    @@SpecLevel:1
  @Method:
     @@Name:  removeAttributeNode
     @@Description:
        @@@lang:en
        @@@@:
          Remove the specified attribute node.
        \
          If a default value for the removed attribute is defined 
          in the DTD, a new node immediately appears.  The DOM 
          implementation may handle default values from other schemas.
     @@Param:
        @@@Name:  oldAttr
        @@@Type:  Attr
        @@@actualType: ManakaiDOMAttr
        @@@Description:
          @@@@lang:en
          @@@@@: 
            The attribute node to remove from the attribute list.
     @@Return:
        @@@Type:  Attr
        @@@actualType: ManakaiDOMAttr
        @@@Description:
          @@@@lang:en
          @@@@@:
            The attribute node that was removed.
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:NO_MODIFICATION_ALLOWED_ERR
          @@@@SubType:
            @@@@@QName:
              MDOMX:NOMOD_THIS
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                This (<IF::Element>) node is read-only.
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:NOT_FOUND_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The <P::oldAttr> node is not an attribute of this element.
        @@@PerlDef:
            my $node = $self->{<Q::TreeCore:node>};
            if ($node->{<Q::DOMCore:read-only>}) {
              __EXCEPTION{
                MDOMX:NOMOD_THIS::
              }__;
            }
            $r = $oldAttr;
            my $attrNode = $r->{<Q::TreeCore:node>};
            FIND: {
              my $attrID = $attrNode->{<Q::TreeCore:nodeID>};
              for my $ns (keys %{$node->{<Q::infoset:attributes>}}) {
                for my $ln (keys %{$node->{<Q::infoset:attributes>}->{$ns}}) {
                  if ($attrID eq $node->{<Q::infoset:attributes>}->{$ns}->{$ln}
                                      ->{<Q::TreeCore:nodeID>}) {
                    CORE::delete $node->{<Q::infoset:attributes>}->{$ns}->{$ln};
                    last FIND;
                  }
                }
              }
              __EXCEPTION{
                ManakaiDOMException.NOT_FOUND_ERR::
                  MDOMX:param-name => 'oldAttr',
              }__;
            }
            CORE::delete $attrNode->{<Q::infoset:ownerElement>};
            $attrNode-><M::NodeStem.orphanate>;
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              TODO: Default attribute
  @Method:
     @@Name:  getElementsByTagName
     @@Description:
       @@@lang:en
       @@@@:
         Return a <IF::NodeList> of all descendant elements with a 
         given element type name, in the document order.
     @@Param:
        @@@Name:  name
        @@@Type:  
          DOMMain:DOMString
        @@@actualType:
          @@@@@:
            DOMMain:ManakaiDOMXMLName
          @@@@ManakaiDOM:noInputNormalize:1
        @@@Description:
          @@@@lang:en
          @@@@@:
            The name of the element type to match on.
        @@@InCase:
          @@@@Value:*
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Match all element type names.
     @@Return:
        @@@Type:  NodeList
        @@@actualType:
          ManakaiDOMCore:ManakaiDOMGetElementsNodeList
        @@@Description:
          @@@@lang:en
          @@@@@:
            A list of matching <IF::Element> nodes.
        @@@PerlDef:
            my $node = $self->{<Q::TreeCore:node>};
            my $chk;
            if (defined $name and $name eq '*') {
              $chk = sub { 1 };
            } else {
              $name = "$name";
              $chk = sub {
                my ($self) = @_;
                if (defined $self->{<Q::infoset:localName>}) {
                  if (defined $self->{<Q::infoset:prefix>}) {
                    return ($self->{<Q::infoset:prefix>} . ':' .
                            $self->{<Q::infoset:localName>} eq $name)
                               ? true : false;
                  } else {
                    return ($self->{<Q::infoset:localName>} eq $name)
                               ? true : false;
                  }
                } else {
                  return ($self->{<Q::DOMCore:name>} eq $name)
                               ? true : false;
                }
              };
            }
            __CODE{getNodeRef::
              $object => $node, $ref => $r,
              $class => {
                <ClassName::ManakaiDOMCore:ManakaiDOMGetElementsNodeList>
              },
            }__;
            $r->{<Q::ManakaiDOMCore:nodeMatch>} = $chk;
     @@NSVersion:.getElementsByTagNameNS

  @ResourceDef:
    @@ForCheck:
      ManakaiDOM:ManakaiDOM ManakaiDOM:ForClass
    @@rdf:type:
      @@@@:
        dis:MultipleResource
      @@@ForCheck: !ForRemove !ForSelect
    @@resourceFor: ForSelect
    @@resourceFor: ForRemove

    @@QName:
      @@@@: selectAttrNodeObjectNS
      @@@ForCheck: ForSelect
    @@NoNSVersion:
      @@@@: selectAttrNodeObject
      @@@ForCheck: ForSelect
      @@@ContentType:
        dis:TFQNames
    @@rdf:type:
      @@@@:
        dis2pm:BlockCode
      @@@ForCheck: ForSelect
    
    @@QName:
      @@@@: selectAttrNodeObjectForRemoveNS
      @@@ForCheck: ForRemove
    @@NoNSVersion:
      @@@@: selectAttrNodeObjectForRemove
      @@@ForCheck: ForRemove
      @@@ContentType:
        dis:TFQNames
    @@rdf:type:
      @@@@:
        dis2pm:BlockCode
      @@@ForCheck: ForRemove
    
     @@Description:
       @@@lang:en
       @@@@:
         Select a <Class::ManakaiDOMNodeObject> object that represents 
         an <IF::Attr> node, by namespace URI and local name.
     @@Param:
        @@@Name:  namespaceURI
        @@@Type:
          DOMMain:DOMString
        @@@actualType:
          ManakaiDOM:ManakaiDOMNamespaceURI
        @@@Description:
          @@@@lang:en
          @@@@@:
            The namespace URI of the attribute to select.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The attribute to select has no namespace.
     @@Param:
        @@@Name:  localName
        @@@Type:  
          @@@@@:
            DOMMain:ManakaiDOMXMLLocalName
          @@@@ManakaiDOM:noInputNormalize:1
        @@@Description:
          @@@@lang:en
          @@@@@: The local name of the attribute to select.
     @@Return:
        @@@Type: NodeStem
        @@@Description:
          @@@@lang:en
          @@@@@:
            The <Class::ManakaiDOM:ManakaiDOMNodeObject> object being selected.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: There is no such attribute.
     @@PerlDef:
            my $attr = $self->{<Q::TreeCore:node>}->{<Q::infoset:attributes>};
            $namespaceURI = <Q::null:> unless defined $namespaceURI;
            $r = $attr->{$namespaceURI}->{$localName};
            __FOR{ForRemove::
              CORE::delete $attr->{$namespaceURI}->{$localName} if $r;
            }__;
    @@ImplNote:
      @@@lang:en
      @@@@:
        The same method is defined in <IF::ManakaiDOMAttributes>.
  @Method:
     @@Name:  getAttributeNS
     @@Description:
       @@@lang:en
       @@@@:
         Retrieve an attribute value by local name and namespace URI.
     @@NoNSVersion:.getAttribute
     @@Param:
        @@@Name:  namespaceURI
        @@@Type:
          DOMMain:DOMString
        @@@actualType:
          ManakaiDOM:ManakaiDOMNamespaceURI
        @@@Description:
          @@@@lang:en
          @@@@@:
            The namespace URI of the attribute to retrieve.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The attribute to retrieve has no namespace.
     @@Param:
        @@@Name:  localName
        @@@Type:  
          DOMMain:DOMString
        @@@actualType:
          @@@@@: 
            DOMMain:ManakaiDOMXMLLocalName
          @@@@ManakaiDOM:noInputNormalize:1
        @@@Description:
          @@@@lang:en
          @@@@@: The local name of the attribute to retrieve.
     @@Return:
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            The <IF::Attr> value as a string.
        @@@InCase:
          @@@@Value:\
          @@@@Description:
            @@@@@lang:en
            @@@@@@: That attribute does not have a specified or default value.
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:NOT_SUPPORTED_ERR
          @@@@SubType:
            @@@@@QName:
              MDOMX:MDOM_IMPL_NOSUPPORT_XML
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The DOM implementation does not support the feature 
                <Feature::XML> and the language exposed through the 
                <IF::Document> does not support XML Namespaces.
        @@@PerlDef:
          @@@@@:
            __CODE{selectAttrNodeObjectNS}__;
            if ($r) {
              __CODE{ManakaiNode:getWeakReference||ManakaiDOM:Perl::
                $object => $r, $ref => $r,
                $class => {<ClassName::ManakaiDOMAttr>},
              }__;
              $r = $r-><AG::DOMCore:Node.textContent>;
            }
          @@@@For:
            ManakaiDOM:DOMXMLFeature
        @@@disDef:
          @@@@ForCheck:
            !ManakaiDOM:DOMXMLFeature
          @@@@DOMMain:raiseException:
            MDOMX:MDOM_IMPL_NOSUPPORT_XMLNS
     @@For:
       ManakaiDOM:DOM2
     @@Level[list]:  2
     @@SpecLevel:2
  @Method:
     @@Name:  setAttributeNS
     @@Description:
       @@@lang:en
       @@@@:
         Add a new attribute.  If an attribute with the same 
         local name and namespace URI is already present on the element, 
         its value is changed and its prefix is also changed to be the 
         prefix of the new qualified name. 
     @@NoNSVersion:.setAttribute
     @@Param:
        @@@Name:  namespaceURI
        @@@Type:
           DOMMain:DOMString
        @@@actualType:
          ManakaiDOM:ManakaiDOMNamespaceURI
        @@@Description:
          @@@@lang:en
          @@@@@:
            The namespace URI of the attribute to create or alter.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: 
              The attribute to create or alter has no namespace.
     @@Param:
        @@@Name:  qualifiedName
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:The qualified name of the attribute to create or alter.
     @@Param:
        @@@Name:  value
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The value to set.
     @@Return:
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: INVALID_CHARACTER_ERR
          @@@@SubType:
            @@@@@QName:
              MDOMX:MDOM_BAD_NAME
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <P::qualifiedName> is not an XML <CODE::Name>.
          @@@@SpecLevel:2
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NAMESPACE_ERR
          @@@@SubType:
            @@@@@QName:
              MDOMX:MDOM_NS_MALFORMED_QNAME
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@: 
                The <P::qualifiedName> is malformed as a qualified name.
            @@@@@SpecLevel:2
          @@@@SubType:
            @@@@@QName:
              MDOMX:MDOM_NS_PREFIX_WITH_NULL_URI
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <P::qualifiedName> has a prefix and the
                <P::namespaceURI> is <DOM::null>.
            @@@@@SpecLevel:2
          @@@@SubType:
            @@@@@QName:
              MDOMX:MDOM_NS_XML_WITH_OTHER_URI
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <P::qualifiedName> has a prefix that is <XML::xml> and the
                <P::namespaceURI> is different from
                <URI::http://www.w3.org/XML/1998/namespace>.
            @@@@@SpecLevel:2
          @@@@SubType:
            @@@@@QName:
              MDOMX:MDOM_NS_XMLNS_WITH_OTHER_URI
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <P::qualifiedName> has a prefix that is <XML::xmlns> and
                the <P::namespaceURI> is different from the
                <URI::http://www.w3.org/2000/xmlns>.
            @@@@@SpecLevel:3
          @@@@SubType:
            @@@@@QName:
              MDOMX:MDOM_NS_XMLNSQ_WITH_OTHER_URI
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <P::qualifiedName> is <XA::xmlns> and
                the <P::namespaceURI> is different from the
                <URI::http://www.w3.org/2000/xmlns>.
            @@@@@SpecLevel:2
          @@@@SubType:
            @@@@@QName:
              MDOMX:MDOM_NS_OTHER_WITH_XML_URI
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <P::namespaceURI> is 
                <URI::http://www.w3.org/XML/1998/namespace> and the 
                prefix of the <P::qualifiedName> is different from 
                <XA::xml>.
            @@@@@SpecLevel[list]:
          @@@@SubType:
            @@@@@QName:
              MDOMX:MDOM_NS_OTHER_WITH_XMLNS_URI
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <P::namespaceURI> is <URI::http://www.w3.org/2000/xmlns> and 
                neither the <P::qualifiedName> nor its prefix is <XML::xmlns>.
            @@@@@SpecLevel:3
          @@@@SubType:
            @@@@@QName:
              MDOMX:MDOM_NS_XMLNS_XMLNS
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <P::qualifiedName> is <XA::xmlns:xmlns>.
            @@@@@SpecLevel[list]:
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@: Is no-prefix with URI is OK?
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:NOT_SUPPORTED_ERR
          @@@@SubType:
            @@@@@QName:
              MDOMX:MDOM_DOC_NOSUPPORT_XML
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                This document does not support the <Feature::XML> 
                feature.
            @@@@@SpecLevel:2
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:NO_MODIFICATION_ALLOWED_ERR
          @@@@SubType:
            @@@@@QName:
              MDOMX:NOMOD_THIS
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                This (<IF::Element>) node is read-only.
            @@@@@SpecLevel:2
          @@@@SubType:
            @@@@@QName:
              MDOMX:NOMOD_ATTR
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <IF::Attr> node to edit is read-only.
            @@@@@SpecLevel[list]:
        @@@PerlDef:
          @@@@For:
            ManakaiDOM:DOMXMLFeature
          @@@@@:
            if ($self->{<Q::TreeCore:node>}->{<Q::DOMCore:read-only>}) {
              __EXCEPTION{
                MDOMX:NOMOD_THIS::
              }__;
            }
            my $docNode = $self->{<Q::TreeCore:node>}
                               ->{<Q::DOMCore:ownerDocument>};
            my $version = <Code::getDocumentXMLVersion:: $DOCOBJ = $docNode>;
            unless (defined $version) {
              __EXCEPTION{MDOMX:MDOM_DOC_NOSUPPORT_XMLNS}__;
            }
            __CODE{DOMMain:ensureXMLQName::
                     $INPUT = $qualifiedName, 
                     $INPUT_PARAM_NAME = 'qualifiedName',
                     $XMLVERSION = $version,
            }__;
            my ($prefix, $localName) = split /:/, $qualifiedName, 2;
            ($prefix, $localName) = (null, $prefix) unless defined $localName;
            __CODE{DOMMain:checkXMLNamesQName::
                     $PREFIX => $prefix, $NSURI => $namespaceURI,
                     $LNAME => $localName,
            }__;
            ## TODO: Check prefix if nsuri
            my $r;
            __CODE{selectAttrNodeObjectNS:: $localName => $localName}__;
            my $node = $self->{<Q::TreeCore:node>};
            if ($r) {
              if ($r->{<Q::DOMCore:read-only>}) {
                __EXCEPTION{
                  MDOMX:NOMOD_ATTR::
                }__;
              }
              my @children = @{$r->{<Q::infoset:children>}};
              $r->{<Q::infoset:children>} = [];
              for (@children) {
                CORE::delete $_->{<Q::infoset:parent>};
                $_-><M::NodeStem.orphanate>;
              }
            } else {
              $r = <ClassM::ManakaiDOMAttr.newObject>;
              $node-><M::NodeStem.importTree> ($r);
              $r->{<Q::DOMCore:ownerDocument>} = $node
                                                 ->{<Q::DOMCore:ownerDocument>};
              $r->{<Q::infoset:prefix>} = $prefix;
              $r->{<Q::infoset:namespaceName>} = $namespaceURI;
              $r->{<Q::infoset:localName>} = $localName;
              $r->{<Q::infoset:ownerElement>} = $node;
              $node->{<Q::infoset:attributes>}
                   ->{defined $namespaceURI ? $namespaceURI : <Q::null:>}
                   ->{$localName} = $r;
            }
            my $text = <ClassM::ManakaiDOMText.newObject>;
            $node-><M::NodeStem.importTree> ($text);
            $text->{<Q::DOMCore:ownerDocument>} = $self->{<Q::TreeCore:node>}
                                                 ->{<Q::DOMCore:ownerDocument>};
            $text->{<Q::infoset:content>} = defined $value ? $value : '';
            $text->{<Q::infoset:parent>} = $r;
            $r->{<Q::infoset:children>} = [$text];
            $r->{<Q::infoset:specified>} = true;
        @@@disDef:
          @@@@ForCheck:
            !ManakaiDOM:DOMXMLFeature
          @@@@DOMMain:raiseException:
            MDOMX:MDOM_IMPL_NOSUPPORT_XMLNS
     @@For:
       ManakaiDOM:DOM2
     @@Level[list]:  2
     @@SpecLevel:2
  @Method:
     @@Name:  removeAttributeNS
     @@Description:
       @@@lang:en
       @@@@:
         Remove an attribute by local name and namespace URI.
       \
         If a default value for the removed attribute is defined 
         in the DTD, a new attribute is immediately appears. 
         The DOM implementation may handle default values from 
         other schemas.
     @@NoNSVersion:.removeAttribute
     @@Param:
        @@@Name:  namespaceURI
        @@@Type:
          DOMMain:DOMString
        @@@actualType:
          ManakaiDOM:ManakaiDOMNamespaceURI
        @@@Description:
          @@@@lang:en
          @@@@@: The namespace URI of the attribute to remove.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The attribute to remove has no namespace.
     @@Param:
        @@@Name:  localName
        @@@Type:  
          DOMMain:DOMString
        @@@actualType:
          @@@@@:
            DOMMain:ManakaiDOMXMLLocalName
          @@@@ManakaiDOM:noInputNormalize:1
        @@@Description:
          @@@@lang:en
          @@@@@:
            The local name of the attribute to remove.
          \
            If no attribute with this <P::localName> and 
            <P::namespaceURI> is found, this method has no effect.
     @@Return:
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:NO_MODIFICATION_ALLOWED_ERR
          @@@@SubType:
            @@@@@QName:
              MDOMX:NOMOD_THIS
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                This (<IF::Element>) node is read-only.
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:NOT_SUPPORTED_ERR
          @@@@SubType:
            @@@@@QName:
              MDOMX:MDOM_IMPL_NOSUPPORT_XML
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The DOM implementation does not support the feature 
                <Feature::XML> and the language exposed through 
                the <IF::Document> does not support XML Namespaces.
        @@@PerlDef:
          @@@@For:
            ManakaiDOM:DOMXMLFeature
          @@@@@:
            if ($self->{<Q::TreeCore:node>}->{<Q::DOMCore:read-only>}) {
              __EXCEPTION{
                MDOMX:NOMOD_THIS::
              }__;
            }
            my $r;
            __CODE{selectAttrNodeObjectForRemoveNS}__;
            if ($r) {
              CORE::delete $r->{<Q::infoset:ownerElement>};
              $r-><M::NodeStem.orphanate>;
            }
         @@@@ImplNote:
           @@@@@lang:en
           @@@@@@:
             TODO: default attribute
           \
             Almost same as <M::ManakaiDOMAttributes.removeNamedItemNS>.
        @@@disDef:
          @@@@ForCheck:
            !ManakaiDOM:DOMXMLFeature
          @@@@DOMMain:raiseException:
            MDOMX:MDOM_IMPL_NOSUPPORT_XMLNS
     @@For:
       ManakaiDOM:DOM2
     @@Level[list]:  2
     @@SpecLevel:2
  @Method:
     @@Name:  getAttributeNodeNS
     @@Description:
       @@@lang:en
       @@@@:
         Retrieve an <IF::Attr> node by local name and namespace URI.
     @@NoNSVersion:.getAttributeNode
     @@Param:
        @@@Name:  namespaceURI
        @@@Type:
          DOMMain:DOMString
        @@@actualType:
          ManakaiDOM:ManakaiDOMNamespaceURI
        @@@Description:
          @@@@lang:en
          @@@@@: The namespace URI of the attribute to retrieve.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The attribute to retrieve have no namespace.
     @@Param:
        @@@Name:  localName
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The local name of the attribute to retrieve.
     @@Return:
        @@@Type:  Attr
        @@@Description:
          @@@@lang:en
          @@@@@:
            The <IF::Attr> node.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: There is no such attribute.
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:NOT_SUPPORTED_ERR
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The DOM implementation does not support the feature 
                <Feature::XML> and the language exposed through the 
                <IF::Document> does not support XML Namespaces.
        @@@PerlDef:
          @@@@For:
            ManakaiDOM:DOMXMLFeature
          @@@@@:
            my $obj;
            __CODE{selectAttrNodeObjectNS:: $r => $obj}__;
            if ($obj) {
              $r = <ClassM::ManakaiDOMNode.getNodeReference> ($obj);
            }
        @@@disDef:
          @@@@ForCheck:
            !ManakaiDOM:DOMXMLFeature
          @@@@DOMMain:raiseException:
            MDOMX:MDOM_IMPL_NOSUPPORT_XMLNS
     @@Level[list]:
        2
        3
     @@SpecLevel:2
     @@For:
       ManakaiDOM:DOM2
  @Method:
     @@Name:  setAttributeNodeNS
     @@Description:
       @@@lang:en
       @@@@:
         Add a new attribute.  If an attribute with that local name and 
         namespace URI is already present in the element, 
         it is replaced by the new node.
       \
         Replacing an attribute node by itself has no effect.
     @@NoNSVersion:.setAttributeNS
     @@Param:
        @@@Name:  newAttr
        @@@Type:  Attr
        @@@actualType: ManakaiDOMAttr
        @@@Description:
          @@@@lang:en
          @@@@@:
            The attribute node to add to the attribute list.
     @@Return:
        @@@Type:  Attr
        @@@actualType: ManakaiDOMAttr
        @@@Description:
          @@@@lang:en
          @@@@@:
            The <IF::Attr> node replaced by the <P::newAttr> node.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The <P::newAttr> node replaces no existing node.
         @@@Exception:
           @@@@Name:WRONG_DOCUMENT_ERR
           @@@@Type:DOMException
           @@@@Description:
             @@@@@lang:en
             @@@@@@:
               The <P::newAttr> node was created from a different document.
         @@@Exception:
           @@@@Name:NO_MODIFICATION_ALLOWED_ERR
           @@@@Type:DOMException
           @@@@SubType:
             @@@@@QName: 
               MDOMX:NOMOD_THIS
             @@@@@Description:
               @@@@@@lang:en
               @@@@@@@:
                 This (<IF::Element>) node is read-only.
         @@@Exception:
           @@@@Name:INUSE_ATTRIBUTE_ERR
           @@@@Type:DOMException
           @@@@Description:
             @@@@@lang:en
             @@@@@@:
               The <P::newAttr> node is already used as an attribute 
               of another <IF::Element> object.
         @@@Exception:
           @@@@Name:NOT_SUPPORTED_ERR
           @@@@Type:DOMException
           @@@@SubType:
             @@@@@QName:
               MDOMX:MDOM_IMPL_NOSUPPORT_XML
             @@@@@Description:
               @@@@@@lang:en
               @@@@@@@:
                 The DOM implementation does not support the feature 
                 <Feature::XML> and the language exposed through the 
                 <IF::Document> does not support XML Namespaces.
             @@@@@SpecLevel:2
           @@@@SubType:
             @@@@@QName:
               MDOMX:MDOM_NODE_NOSUPPORT_XMLNS
             @@@@@Description:
               @@@@@@lang:en
               @@@@@@@:
                 The <P::newAttr> node does not support XML Namespace.
             @@@@@SpecLevel[list]:
         @@@PerlDef:
           @@@@For:
             ManakaiDOM:DOMXMLFeature
           @@@@@:
            if ($self->{<Q::TreeCore:node>}->{<Q::DOMCore:read-only>}) {
              __EXCEPTION{
                MDOMX:NOMOD_THIS::
              }__;
            }
            my $attrNode = $newAttr->{<Q::TreeCore:node>};
            if ($attrNode->{<Q::infoset:ownerElement>}) {
              __EXCEPTION{
                ManakaiDOMException.INUSE_ATTRIBUTE_ERR::
                  MDOMX:param-name => 'newAttr',
              }__;
            } elsif ($attrNode->{<Q::DOMCore:ownerDocument>}
                              ->{<Q::TreeCore:nodeID>} ne
                     $self->{<Q::TreeCore:node>}->{<Q::DOMCore:ownerDocument>}
                          ->{<Q::TreeCore:nodeID>}) {
              __EXCEPTION{
                ManakaiDOMException.WRONG_DOCUMENT_ERR::
              }__;
            }

            if (defined $attrNode->{<Q::infoset:localName>}) {
              $r = $self->{<Q::TreeCore:node>}->{<Q::infoset:attributes>}
                     ->{defined $attrNode->{<Q::infoset:namespaceName>}
                              ? $attrNode->{<Q::infoset:namespaceName>}
                              : <Q::null:>}
                     ->{$attrNode->{<Q::infoset:localName>}};
            } else {
              __EXCEPTION{
                MDOMX:MDOM_NODE_NOSUPPORT_XMLNS::
                  MDOMX:param-name => 'newAttr',
              }__;
            }

            if (defined $r and
                $r->{<Q::TreeCore:nodeID>} eq $attrNode->{<Q::TreeCore:nodeID>}) {
              __WARNING{
                MDOMX:MDOM_REPLACE_BY_ITSELF_NO_EFFECT::
                  MDOMX:param-name => 'newAttr',
              }__;
              $r = $newAttr;
            } else {
              $attrNode->{<Q::infoset:ownerElement>} = $self->{<Q::TreeCore:node>};
              if (defined $attrNode->{<Q::infoset:localName>}) {
                $self->{<Q::TreeCore:node>}->{<Q::infoset:attributes>}
                     ->{defined $attrNode->{<Q::infoset:namespaceName>}
                              ? $attrNode->{<Q::infoset:namespaceName>}
                              : <Q::null:>}
                     ->{$attrNode->{<Q::infoset:localName>}} = $attrNode;
              } else {
                $self->{<Q::TreeCore:node>}->{<Q::infoset:attributes>}
                     ->{<Q::ManakaiDOM:noNS>}
                     ->{$attrNode->{<Q::DOMCore:name>}} = $attrNode;
              }
              if ($r) {
                my $obj = $r;
                $r = <ClassM::ManakaiDOMNode.getNodeReference> ($obj)
                  if defined wantarray;
                CORE::delete $obj->{<Q::infoset:parent>};
                $obj-><M::NodeStem.orphanate>;
              }
            }
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              It is unclear whether the node should be returned if 
              the node is <QUOTE::replaced> by itself.
        @@@disDef:
          @@@@ForCheck:
            !ManakaiDOM:DOMXMLFeature
          @@@@DOMMain:raiseException:
            MDOMX:MDOM_IMPL_NOSUPPORT_XMLNS
     @@Level[list]:  
        2
        3
     @@SpecLevel:2
     @@For:
       ManakaiDOM:DOM2
  @Method:
     @@Name:  getElementsByTagNameNS
     @@Description: 
       @@@lang:en
       @@@@:
         Return a <IF::NodeList> of all the descendant <IF::Element> nodes 
         with a given local name and namespace URI pair in the document 
         order.
     @@Param:
        @@@Name:  namespaceURI
        @@@Type:  
          DOMMain:DOMString
        @@@actualType:
          ManakaiDOM:ManakaiDOMNamespaceURI
        @@@Description:
          @@@@lang:en
          @@@@@:
            The namespace URI of the elements to match on.
        @@@InCase:
          @@@@Value:*
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Mathch all namespaces.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
     @@Param:
        @@@Name:  localName
        @@@Type:  
          DOMMain:DOMString
        @@@actualType:
          @@@@@:
            DOMMain:ManakaiDOMXMLLocalName
          @@@@ManakaiDOM:noInputNormalize:1
        @@@Description:
          @@@@lang:en
          @@@@@:
            The local name of the elements to match on.
        @@@InCase:
          @@@@Value:*
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Match all local names.
     @@Return:
        @@@Type:  NodeList
        @@@actualType:
          ManakaiDOMCore:ManakaiDOMGetElementsNodeList
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:NOT_SUPPORTED_ERR
          @@@@SubType:
            @@@@@QName:
              MDOMX:MDOM_IMPL_NOSUPPORT_XML
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The DOM implementation does not support the 
                <Feature::XML> feature and the language exposed 
                through the <IF::Document> does not support XML 
                Namespaces.
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              The <CITE::DOM Level 2 Core Specification> was stated 
              that HTML-only DOM implementations were not required 
              to implement this method.  Its Errata and the 
              <CITE::DOM Level 3 Core Specification> ammend it to 
              throw an exception.
        @@@Description:
          @@@@lang:en
          @@@@@:
            A new <IF::NodeList> object containing all the matched 
            <IF::Element> nodes.
        @@@PerlDef:
          @@@@For:
            ManakaiDOM:DOMXMLFeature
          @@@@@:
            my $node = $self->{<Q::TreeCore:node>};
            my $chk;
            if (defined $namespaceURI) {
              if ($namespaceURI eq '*') {
                if (defined $localName and $localName eq '*') {
                  $chk = sub {
                    my ($self) = @_;
                    return defined $self->{<Q::infoset:localName>}
                             ? true : false;
                      ## Any element node with local name
                  };
                } else {
                  $localName = "$localName";
                  $chk = sub {
                    my ($self) = @_;
                    return
                        (defined $self->{<Q::infoset:localName>} and
                         $self->{<Q::infoset:localName>} eq $localName)
                           ? true : false;
                  };
                }
              } else { ## Non-n u l l namespace URI
                $namespaceURI = "$namespaceURI";
                if (defined $localName and $localName eq '*') {
                  $chk = sub {
                    my ($self) = @_;
                    return (defined $self->{<Q::infoset:namespaceName>} and
                            $self->{<Q::infoset:namespaceName>} eq $namespaceURI)
                              ? true : false;
                  };
                } else {
                  $localName = "$localName";
                  $chk = sub {
                    my ($self) = @_;
                    return
                        (defined $self->{<Q::infoset:localName>} and
                         defined $self->{<Q::infoset:namespaceName>} and
                         $self->{<Q::infoset:namespaceName>} eq $namespaceURI and
                         $self->{<Q::infoset:localName>} eq $localName)
                           ? true : false;
                  };
                }
              }
            } else { ## Null namespace
              if (defined $localName and $localName eq '*') {
                $chk = sub {
                  my ($self) = @_;
                  return (defined $self->{<Q::infoset:localName>} and
                          not defined $self->{<Q::infoset:namespaceName>})
                            ? true : false;
                    ## Any element node with local name but not namespace URI
                };
              } else {
                $localName = "$localName";
                $chk = sub {
                  my ($self) = @_;
                  return
                      (defined $self->{<Q::infoset:localName>} and
                       not defined $self->{<Q::infoset:namespaceName>} and
                       $self->{<Q::infoset:localName>} eq $localName)
                         ? true : false;
                };
              }
            }
            __CODE{getNodeRef::
              $object => $node, $ref => $r,
              $class => {
                <ClassName::ManakaiDOMCore:ManakaiDOMGetElementsNodeList>
              },
            }__;
            $r->{<Q::ManakaiDOMCore:nodeMatch>} = $chk;
        @@@disDef:
          @@@@ForCheck:
            !ManakaiDOM:DOMXMLFeature
          @@@@DOMMain:raiseException:
            MDOMX:MDOM_IMPL_NOSUPPORT_XMLNS
     @@Level[list]:  
       2
       3
     @@SpecLevel:2
     @@For:
       ManakaiDOM:DOM2
     @@NoNSVersion:.getElementsByTagName
  @Method:
     @@Name:  hasAttribute
     @@Description:
       @@@lang:en
       @@@@:
         Whether an attribute with the given name is specified on 
         this element or has a default value.
     @@NSVersion:.hasAttributeNS
     @@Param:
        @@@Name:  name
        @@@Type:  
          DOMMain:DOMString
        @@@actualType:
          @@@@@:
            DOMMain:ManakaiDOMXMLName
          @@@@ManakaiDOM:noInputNormalize:1
        @@Description:
          @@@lang:en
          @@@@: The name of the attribute to look for.
     @@Return:
        @@@Type:  DOMMain|boolean||ManakaiDOM|all
        @@@InCase:
          @@@@Value:true
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              An attribute with the given name is specified on 
              this element or has a default value.
        @@@InCase:
          @@@@Value:false
          @@@@Description:
            @@@@@lang:en
            @@@@@@: 
              There is no such attribute.
        @@@PerlDef:
            __CODE{selectAttrNodeObject}__;
            $r = true if $r;
     @@Level[list]:  2
     @@SpecLevel:2
     @@For:
       ManakaiDOM:DOM2
  @Method:
     @@Name:  hasAttributeNS
     @@Description:
       @@@lang:en
       @@@@:
         Whether an attribute with a given local name and namespace URI 
         is specified on this element or has a default value.
     @@NoNSVersion:.hasAttribute
     @@Param:
        @@@Name:  namespaceURI
        @@@Type: 
          DOMMain:DOMString
        @@@actualType:
          ManakaiDOM:ManakaiDOMNamespaceURI
        @@@Description:
          @@@@lang:en
          @@@@@: The namespace URI of the attribute to look for.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The attribute to look for has no namespace.
     @@Param:
        @@@Name:  localName
        @@@Type:  
          DOMMain:DOMString
        @@@actualType:
          @@@@@:
            DOMMain:ManakaiDOMXMLLocalName
          @@@@ManakaiDOM:noInputNormalize:1
        @@@Description:
          @@@@lang:en
          @@@@@: The local name of the attribute to look for.
     @@Return:
        @@@Type:  DOMMain|boolean||ManakaiDOM|all
        @@@InCase:
          @@@@Value:true
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              An attribute with given local name and namespace URI is 
              specified or has a default value on this element.
        @@@InCase:
          @@@@Value:false
          @@@@Description:
            @@@@@lang:en
            @@@@@@: There is no such attribute.
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:NOT_SUPPORTED_ERR
          @@@@SubType:
            @@@@@QName:
              MDOMX:MDOM_IMPL_NOSUPPORT_XML
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The DOM implementation does not support the feature 
                <Feature::XML> and the language exposed through the 
                <IF::Document> does not support XML Namespaces.
        @@@PerlDef:
          @@@@For:
            ManakaiDOM:DOMXMLFeature
          @@@@@:
            __CODE{selectAttrNodeObjectNS}__;
            $r = $r ? true : false;
        @@@disDef:
          @@@@ForCheck:
            !ManakaiDOM:DOMXMLFeature
          @@@@DOMMain:raiseException:
            MDOMX:MDOM_IMPL_NOSUPPORT_XMLNS
     @@Level[list]:  2
     @@SpecLevel:2
     @@For:
       ManakaiDOM:DOM2
  @Attr:
     @@Name:  schemaTypeInfo
     @@Description:
        @@@lang:en
        @@@@: The type information associated with this element.
     @@Get:
        @@@Type:  TypeInfo
        @@@Description:
          @@@@lang:en
          @@@@@: The type information.
     @@L3:
     @@Level[list]:  3
     @@SpecLevel:3
     @@For:
       ManakaiDOM:DOM3
     @@ImplNote:
       @@@lang:en
       @@@@:
         TODO: More study required for the relationship to schemas.
  @Method:
     @@Name:  setIdAttribute
     @@Description:
       @@@lang:en
       @@@@:
         Set whether an attribute is a user-determined ID attribute or not.
       \
         Note that this does not affect any schema that may be 
         in use.  Whether this attribute is a DTD-, Schema- or 
         externally-determined ID attribute is unable to change by 
         this method.
     @@NSVersion:.setIdAttributeNS
     @@Param:
        @@@Name:  name
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The name of the attribute.
     @@Param:
        @@@Name:  isId
        @@@Type:  DOMMain|boolean||ManakaiDOM|all
        @@@Description:
          @@@@lang:en
          @@@@@:
            Whether the attribtue is a user-determined ID attribute.
        @@@InCase:
          @@@@Value:true
          @@@@Description:
            @@@@@lang:en
            @@@@@@: 
              Declare the attribute to be a user-determined ID attribute.
        @@@InCase:
          @@@@Value:false
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Undeclare the attribute for being a user-determined ID attribute.
     @@Return:
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:NO_MODIFICATION_ALLOWED_ERR
          @@@@SubType:
            @@@@@QName:
              MDOMX:NOMOD_THIS
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                This (<IF::Element>) node is read-only.
            @@@@@SpecLevel:3
          @@@@SubType:
            @@@@@QName:
              MDOMX:NOMOD_ATTR
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The attribute node is read-only.
            @@@@@SpecLevel[list]:
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              Is <QUOTE::user-determined ID> a property of the 
              <IF::Attr> or of the <IF::Element>?
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:NOT_FOUND_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              There is no such attribute.
        @@@PerlDef:
            if ($self->{<Q::TreeCore:node>}->{<Q::DOMCore:read-only>}) {
              __EXCEPTION{
                MDOMX:NOMOD_THIS::
              }__;
            }
            my $r;
            __CODE{selectAttrNodeObject}__;
            unless ($r) {
              __EXCEPTION{
                ManakaiDOMException.NOT_FOUND_ERR::
              }__;
            }
            if ($r->{<Q::DOMCore:read-only>}) {
              __EXCEPTION{
                MDOMX:NOMOD_ATTR::
              }__;
            }
            $r->{<Q::DOMCore:userDeterminedId>} = $isId;
     @@L3:
     @@Level[list]:  3
     @@SpecLevel:3
     @@For:
       ManakaiDOM:DOM3
  @Method:
     @@Name:  setIdAttributeNS
     @@Description:
       @@@lang:en
       @@@@:
         Set whether an attribute is a user-determined ID attribute or not.
       \
         Note that this does not affect any schema that may be 
         in use.  Whether this attribute is a DTD-, Schema- or 
         externally-determined ID attribute is unable to change by 
         this method.
     @@NoNSVersion:.setIdAttribute
     @@Param:
        @@@Name:  namespaceURI
        @@@Type: 
          DOMMain:DOMString
        @@@actualType:
          ManakaiDOM:ManakaiDOMNamespaceURI
        @@@Description:
          @@@@lang:en
          @@@@@: The namespace URI of the attribute.
     @@Param:
        @@@Name:  localName
        @@@Type:  
          DOMMain:DOMString
        @@@actualType:
          @@@@@:
            DOMMain:ManakaiDOMXMLLocalName
          @@@@ManakaiDOM:noInputNormalize:1
        @@@Description:
          @@@@lang:en
          @@@@@: The local name of the attribute.
     @@Param:
        @@@Name:  isId
        @@@Type:  DOMMain|boolean||ManakaiDOM|all
        @@@Description:
          @@@@lang:en
          @@@@@:
            Whether the attribtue is a user-determined ID attribute.
        @@@InCase:
          @@@@Value:true
          @@@@Description:
            @@@@@lang:en
            @@@@@@: 
              Declare the attribute to be a user-determined ID attribute.
        @@@InCase:
          @@@@Value:false
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Undeclare the attribute for being a user-determined ID attribute.
     @@Return:
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:NO_MODIFICATION_ALLOWED_ERR
          @@@@SubType:
            @@@@@QName:
              MDOMX:NOMOD_THIS
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                This (<IF::Element>) node is read-only.
            @@@@@SpecLevel:3
          @@@@SubType:
            @@@@@QName:
              MDOMX:NOMOD_ATTR
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The attribute node is read-only.
            @@@@@SpecLevel[list]:
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              Is <QUOTE::user-determined ID> a property of the 
              <IF::Attr> or of the <IF::Element>?
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:NOT_FOUND_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              There is no such attribute.
        @@@PerlDef:
          @@@@For:
            ManakaiDOM:DOMXMLFeature
          @@@@@:
            if ($self->{<Q::TreeCore:node>}->{<Q::DOMCore:read-only>}) {
              __EXCEPTION{
                MDOMX:NOMOD_THIS::
              }__;
            }
            my $r;
            __CODE{selectAttrNodeObjectNS}__;
            unless ($r) {
              __EXCEPTION{
                ManakaiDOMException.NOT_FOUND_ERR::
              }__;
            }
            if ($r->{<Q::DOMCore:read-only>}) {
              __EXCEPTION{
                MDOMX:NOMOD_ATTR::
              }__;
            }
            $r->{<Q::DOMCore:userDeterminedId>} = $isId;
        @@@disDef:
          @@@@ForCheck:
            !ManakaiDOM:DOMXMLFeature
          @@@@DOMMain:raiseException:
            MDOMX:MDOM_IMPL_NOSUPPORT_XMLNS
     @@L3:
     @@Level[list]:  3
     @@SpecLevel:3
     @@For:
       ManakaiDOM:DOM3
  @Method:
     @@Name:  setIdAttributeNode
     @@Description:
       @@@lang:en
       @@@@:
         Set whether an attribute is a user-determined ID attribute or not.
       \
         Note that this does not affect any schema that may be 
         in use.  Whether this attribute is a DTD-, Schema- or 
         externally-determined ID attribute is unable to change by 
         this method.
     @@Param:
        @@@Name:  idAttr
        @@@Type:  Attr
        @@@actualType: ManakaiDOMAttr
        @@@Description:
          @@@@lang:en
          @@@@@: The attribute node.
     @@Param:
        @@@Name:  isId
        @@@Type:  DOMMain|boolean||ManakaiDOM|all
        @@@Description:
          @@@@lang:en
          @@@@@:
            Whether the attribtue is a user-determined ID attribute.
        @@@InCase:
          @@@@Value:true
          @@@@Description:
            @@@@@lang:en
            @@@@@@: 
              Declare the attribute to be a user-determined ID attribute.
        @@@InCase:
          @@@@Value:false
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Undeclare the attribute for being a user-determined ID attribute.
     @@Return:
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:NO_MODIFICATION_ALLOWED_ERR
          @@@@SubType:
            @@@@@QName:
              MDOMX:NOMOD_THIS
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                This (<IF::Element>) node is read-only.
            @@@@@SpecLevel:3
          @@@@SubType:
            @@@@@QName:
              MDOMX:NOMOD_ATTR
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The attribute node is read-only.
            @@@@@SpecLevel[list]:
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              Is <QUOTE::user-determined ID> a property of the 
              <IF::Attr> or of the <IF::Element>?
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:NOT_FOUND_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The <P::idAttr> is not an attribute of this element.
        @@@PerlDef:
            if ($self->{<Q::TreeCore:node>}->{<Q::DOMCore:read-only>}) {
              __EXCEPTION{
                MDOMX:NOMOD_THIS::
              }__;
            }
            unless ($idAttr->{<Q::TreeCore:node>}->{<Q::infoset:ownerElement>} and
                    $idAttr->{<Q::TreeCore:node>}->{<Q::infoset:ownerElement>}
                           ->{<Q::TreeCore:nodeID>} eq
                    $self->{<Q::TreeCore:node>}->{<Q::TreeCore:nodeID>}) {
              __EXCEPTION{
                ManakaiDOMException.NOT_FOUND_ERR::
              }__;
            }
            if ($idAttr->{<Q::TreeCore:node>}->{<Q::DOMCore:read-only>}) {
              __EXCEPTION{
                MDOMX:NOMOD_ATTR::
              }__;
            }
            $idAttr->{<Q::TreeCore:node>}
                   ->{<Q::DOMCore:userDeterminedId>} = $isId;
     @@L3:
     @@Level[list]:  3
     @@SpecLevel:3
     @@For:
       ManakaiDOM:DOM3
  @Method:
    @@Name: normalize
    @@Description:
      @@@lang:en
      @@@@:
         Puts all <IF::Text> nodes in the full depth of the sub-tree 
         underneath this <IF::Node>, including attribute nodes 
         attaced to the <IF::Element>, 
         into a <QUOTE::normal> form where only structure separates 
         <IF::Text> nodes, i.e. there are neither adjacent <IF::Text> 
         nodes nor empty <IF::Text> nodes. 

      Although the <IF::DOMXML:CDATASection> interface implements the
      <IF::Text> interface, the <M::Node.normalize> method does 
      not merge adjacent <IF::DOMXML:CDATASection> nodes.
    @@ImplNote:
      @@@lang:en
      @@@@:
        DOM level 2 and 3 defines <M::Node.normalize> instead 
        of <M::Element::ManakaiDOM|ManakaiDOM1.normalize>. 
    @@DOMMain:implementFeature: CoreFeature10
    @@For:
      ManakaiDOM:DOM1 !ManakaiDOM:DOM2
    @@Return:
       @@@Exception:
         @@@@@:
           MDOMX:NOMOD_THIS
         @@@@Description:
           @@@@@lang:en
           @@@@@@:
             This node is read-only. 
         @@@@For:
           ManakaiDOM:ManakaiDOM
       @@@Exception:
         @@@@@:NOMOD_DESCENDANT_ERR
         @@@@Description:
           @@@@@lang:en
           @@@@@@:
             One of descendant (or attribute) is read-only. 
        @@@@For:
          ManakaiDOM:ManakaiDOM
      @@@PerlDef:
       __DEEP{
         $self->{<Q::TreeCore:node>}
              -><M::ManakaiDOMCore:ManakaiDOMNodeObjectNode.normalizeText>;
       }__;
  
  @ReAttr:
    @@Name: attributes
    @@Description:
      @@@lang:en
      @@@@:
        A node map containing the attributes of this node.
    @@Get:
      @@@Type: NamedNodeMap
      @@@actualType:
        ManakaiDOMCore:ManakaiDOMAttributes
      @@@Description:
        @@@@lang:en
        @@@@@:
          A <IF::NamedNodeMap> object.
      @@@PerlDef:
        __CODE{getNodeRef::
          $object => {$self->{<Q::TreeCore:node>}},
          $ref => $r,
          $class => {
            <ClassName::ManakaiDOMCore:ManakaiDOMAttributes>
          },
        }__;
  @ReAttr:
    @@Name:baseURI
    @@Description:
      @@@lang:en
      @@@@:
        The base URI of this element.
    @@Get:
      @@@Type:
        DOMMain:DOMString
      @@@actualType:
        ManakaiDOM:ManakaiDOMURI
      @@@Description:
        @@@@lang:en
        @@@@@: The base URI.
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The DOM implementation is unable to obtain an absolute URI.
      @@@PerlDef:
          if ($self->{<Q::TreeCore:node>}->{<Q::DOMCore:hasFeature>}->{HTML}) {
            $r = $self->{<Q::TreeCore:node>}
                      -><M::ManakaiDOMCore:ManakaiDOMNodeObjectNode
                                   .htmlBaseURI>;
          } else {
            $r = $self->{<Q::TreeCore:node>}
                      -><M::ManakaiDOMCore:ManakaiDOMNodeObjectNode
                                   .contentBaseURI> (false);
          }
       @@@ImplNote:
         @@@@lang:en
         @@@@@:
           If a document has both a <HE::base> element and 
           an <XA::xml:base> attribute, or even in the case that 
           an XHTML 1 document has an <XA::xml:base> attribute, 
           its result is not defined by any W3C specification.
    @@SpecLevel:3
    @@Level[list]:3
    @@For:
      ManakaiDOM:DOM3
    @@L3:
  @ReAttr:
     @@Name:  localName
     @@Description:
       @@@lang:en
       @@@@: The local part of the qualified name of this "Element" node.
     @@DOMMain:isNamespaceAware:1
     @@Get:
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            The local name of the element type.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The node is created with a DOM Level 1 methods.
        @@@disDef:
          @@@@GetProp:
            infoset:localName
     @@Level[list]:  2
     @@SpecLevel:2
     @@For:
       ManakaiDOM:DOM2
     @@L2:
  @ReMethod:
     @@Name:  lookupPrefix
     @@Description:
       @@@lang:en
       @@@@:
         Lookup the namespace prefix associated to the given namespace 
         URI, starting from this node.
       \
         The default namespace declarations are ignored by this method. 
         To lookup default namespace, use the <M::Node.isDefaultNamespace>
         method.
     @@DOMMain:isNamespaceAware:1
     @@Param:
        @@@Name:  namespaceURI
        @@@Type:
          DOMMain:DOMString
        @@@actualType:
          ManakaiDOM:ManakaiDOMNamespaceURI
        @@@Description:
          @@@@lang:en
          @@@@@: The namespace URI to look for.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Always <DOM::null> will be returned.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Always <DOM::null> will be returned.
     @@Return:
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            An associated namespace prefix.
          \
            If more than one prefix are associated to the 
            namespace URI, which is returned is implementation 
            dependent.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              No namespace prefix is found.
        @@@PerlDef:
            if (not defined $namespaceURI) {
              $r = null;
            } else {
              my $n = $self->{<Q::TreeCore:node>};
              __DEEP{
                $r = $n-><M::ManakaiDOMCore:ManakaiDOMNodeObjectNode
                                .lookupNamespacePrefix>
                                                 ($namespaceURI, $n);
              }__;
            }
     @@Level[list]:  3
     @@SpecLevel:3
     @@For:
       ManakaiDOM:DOM3
     @@L3:
  @ReAttr:
     @@Name:  namespaceURI
     @@Description:
       @@@lang:en
       @@@@:
         The namespace URI of this node.
     @@DOMMain:isNamespaceAware:1
     @@Get:
        @@@Type:
          DOMMain:DOMString
        @@@actualType:
          ManakaiDOM:ManakaiDOMNamespaceURI
        @@@Description:
          @@@@lang:en
          @@@@@: The namespace URI.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The namespace URI is unspecified (the "null" namespace) or 
              the node is created with a DOM Level 1 methods.
        @@@disDef:
          @@@@GetProp:
            infoset:namespaceName
     @@Level[list]:  2
     @@SpecLevel:2
     @@For:
       ManakaiDOM:DOM2
     @@L2:
  @ReAttr:
    @@Name: nodeName
    @@Description:
      @@@lang:en
      @@@@: The node name.
    @@DOMMain:isNamespaceUnaware:1
    @@L1:
    @@Get:
      @@@Type: 
        DOMMain:DOMString
      @@@Description:
        @@@@lang:en
        @@@@@: The element type name, i.e. same as "tagName" attribute.
      @@@disDef:
        @@@@DISPerl:cloneCode:.tagName.get
  @ReAttr:
    @@Name: nodeType
    @@Description:
      @@@lang:en
      @@@@: The type of this node.
    @@L1:
    @@Get:
      @@@Type: 
        DOMMain:unsigned-short||ManakaiDOM|all
      @@@actualType:ManakaiDOMNodeType
      @@@InCase:
        @@@@Label: ELEMENT_NODE
        @@@@Description:
          @@@@@lang:en
          @@@@@@: The node is an "Element".
      @@@disDef:
        @@@@DISLang:constValue: Node.ELEMENT_NODE
  @ReAttr:
     @@Name:  prefix
     @@Description:
       @@@lang:en
       @@@@: The namespace prefix of this node.
     @@DOMMain:isNamespaceAware:1
     @@Get:
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The namespace prefix.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Either the namespace prefix is unspecified or the node 
              is created with a DOM Level 1 method.
        @@@disDef:
          @@@@GetProp:
            infoset:prefix
     @@Set:
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            The namespace prefix.
            Note that setting this attribute has no effect if 
            the namespace prefix is defined to be "null".
        @@@ImplNote:
          @@@@lang:en
          @@@@@:
            It is unclear whether the default attribute should be 
            added or deleted as the DTD declares.  The DOM Level 2 
            and 3 specifications mentions that changing of the 
            attribute name prefix does not make the default 
            attribute supplied, since the namespace URI does not change.
            This logic might be applied to the element node.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The namespace prefix is unspecified.
        @@@InCase:
          @@@@Value: \
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The result is implementation dependent in DOM Level 3.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: INVALID_CHARACTER_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The specified prefix contains an illegal character 
              accoding to the XML version in use in the document.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: This node is read-only.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NAMESPACE_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Either the specified prefix is malformed per the 
              XML Namespace specification, non-"null" prefix is 
              specified but the "namespaceURI" of this node is "null" or 
              the specified prefix is "xml" and the "namespaceURI" 
              of this node is different from 
              "http://www.w3.org/XML/1998/namespace".
        @@@PerlDef:
            my $node = $self->{<Q::TreeCore:node>};
            my $docNode = $node->{<Q::DOMCore:ownerDocument>};
            my $version = <Code::getDocumentXMLVersion:: $DOCOBJ = $docNode>;
            if (not defined $version) {
              __WARNING{DOMMain:MDOMX_NOEFFECT_SINCE_DOC_NOSUPPORT_XML}__;
            } elsif (not defined $node->{<Q::infoset:localName>}) {
              __WARNING{DOMMain:MDOMX_NOEFFECT_SINCE_NODE_NOSUPPORT_XMLNS}__;
            } elsif ($node->{<Q::DOMCore:read-only>}) {
              __EXCEPTION{MDOMX:NOMOD_THIS}__;
            } else {
              __CODE{DOMMain:ensureNamespacePrefix::
                $INPUT => $given, $INPUT_PARAM_NAME => '',
                $XMLVERSION => $version,
              }__;
              my $nsURI = $node->{<Q::infoset:namespaceName>};
              if (not defined $given) {
                if ($nsURI eq <Q::xml:>) {
                  __EXCEPTION{MDOMX:MDOM_NS_OTHER_WITH_XML_URI::
                    infoset:prefix => {undef},
                    infoset:namespaceName => {$nsURI},
                  }__;
                } elsif ($nsURI eq <Q::xmlns:>) {
                  __EXCEPTION{MDOMX:MDOM_NS_OTHER_WITH_XMLNS_URI::
                    infoset:prefix => {undef},
                    infoset:namespaceName => {$nsURI},
                  }__;
                }
              } else {
                if (not defined $nsURI) {
                  __EXCEPTION{
                    MDOMX:MDOM_NS_PREFIX_WITH_NULL_URI::
                      infoset:prefix => {$given},
                  }__;
                } elsif ($given eq 'xml' and $nsURI ne <Q::xml:>) {
                  __EXCEPTION{
                    MDOMX:MDOM_NS_XML_WITH_OTHER_URI::
                      infoset:prefix => {$given},
                      infoset:namespaceName => {$nsURI},
                  }__;
                } elsif ($given eq 'xmlns' and $nsURI ne <Q::xmlns:>) {
                  __EXCEPTION{
                    MDOMX:MDOM_NS_XMLNS_WITH_OTHER_URI::
                      infoset:prefix => {$given},
                      infoset:namespaceName => {$nsURI},
                  }__;
                } elsif ($nsURI eq <Q::xml:> and $given ne 'xml') {
                  __EXCEPTION{MDOMX:MDOM_NS_OTHER_WITH_XML_URI::
                    infoset:prefix => {$given},
                    infoset:namespaceName => {$nsURI},
                  }__;
                } elsif ($nsURI eq <Q::xmlns:> and $given ne 'xmlns') {
                  __EXCEPTION{MDOMX:MDOM_NS_OTHER_WITH_XMLNS_URI::
                    infoset:prefix => {$given},
                    infoset:namespaceName => {$nsURI},
                  }__;
                }
              }
              $node->{<Q::infoset:prefix>} = $given;
            }
     @@Level[list]:
       2
       3
     @@SpecLevel:2
     @@For:
       ManakaiDOM:DOM2
     @@L2:
  
  @IntMethod:
    @@Name: newObject
    @@Description:
      @@@lang:en
      @@@@:
        Construct an object for a new instance of the <IF::Element> node.
    @@Return:
      @@@Type: NodeStem
      @@@Description:
        @@@@lang:en
        @@@@@:
          The new object for the <IF::Element> node.
      @@@PerlDef:
        $r = <ClassM::ManakaiDOMNode.newObject>;
        push @{$r->{<Q::TreeCore:origin>}}, <Q::infoset:parent>;
        push @{$r->{<Q::TreeCore:subnode2>}}, <Q::infoset:attributes>;
        $r->{<Q::infoset:attributes>} = {};
        push @{$r->{<Q::TreeCore:subnode>}}, <Q::infoset:children>;
        $r->{<Q::infoset:children>} = [];
        $r->{<Q::DOMCore:nodeType>} = <Q::infoset:Element>;
     @@ImplNote:
       @@@lang:en
       @@@@:
         Other properties required to be a legal <IF::Element> object:
         Either <Q::DOMCore:name> or <Q::infoset:localName>, 
         <Q::DOMCore:ownerDocument>.
       \
         Other available properties: <Q::infoset:prefix>, 
         <Q::DOMCore:read-only>, <Q::infoset:parent>, <Q::infoset:children>, 
         <Q::infoset:attributes>, <Q::infoset:namespaceName>.

  @Method:
     @@Name:  getFeature
     @@enDesc:
       Returns a specialized object that implements the
       specialized interfaces of the specified feature and version.
     @@ManakaiDOM:isRedefining:1
     @@ForCheck: ManakaiDOM|ForClass ManakaiDOM|DOM3
     @@Param:
        @@@Name:  feature
        @@@Type:  
          DOMMain:DOMString
        @@@actualType: ManakaiDOM|ManakaiDOMFeatureName
        @@@enDesc:
          The feature name to request.
        @@@InCase:
          @@@@Label:
            @@@@@lang:en
            @@@@@@: 
              Feature name preceded by a <CHAR::PLUS SIGN>
          @@@@enDesc:
            The <CHAR::PLUS SIGN> is ignored.
     @@Param:
        @@@Name:  version
        @@@Type:  
          DOMMain:DOMString
        @@@actualType: ManakaiDOM|ManakaiDOMFeatureVersion
        @@@enDesc:
          The feature version to request.
        @@@nullCase:
          @@@@enDesc:
            No specific version is requested.
     @@Return:
        @@@Type:  
          DOMMain:DOMObject
        @@@enDesc:
          An object implementing the specialized interfaces.
          Note that the specialized object may or may not
          implement the <IF::Node> interface.
        @@@nullCase:
          @@@@enDesc:
            There is no object available that implements
            the specialized interfaces.
        @@@PerlDef:
            $feature =~ s/^\+//;
            if ($Message::DOM::ClassFeature{ref $self}->{$feature}->{$version}) {
              ## This class
              $r = $self;
            } else {
              ## Element type dependent classes
              my $object = $self->{<Q::TreeCore:node>};
              my $ns;
              my $ln;
              if (defined $object->{<Q::infoset:localName>}) { ## Namespace-aware
                $ns = $object->{<Q::infoset:namespaceName>};
                $ns = '' unless defined $ns;
                $ln = $object->{<Q::infoset:localName>};
              } elsif ($object->{<Q::DOMCore:ownerDocument>}
                              ->{<Q::DOMCore:hasFeature>}->{HTML}) {
                $ns = <Q::xhtml1:>;
                $ln = lc $object->{<Q::DOMCore:name>};
              }
              if (defined $ln) {
                for my $pack ((sort {
                  $Message::DOM::ClassPoint{$b} <=> $Message::DOM::ClassPoint{$a}
                } grep {
                  $Message::DOM::ManakaiDOMElement::CompatClassET{$ns}
                          ->{$ln}->{$_}
                } keys %{$Message::DOM::ManakaiDOMElement::CompatClassET{$ns}
                                 ->{$ln}}),
                (sort {
                  $Message::DOM::ClassPoint{$b} <=> $Message::DOM::ClassPoint{$a}
                } grep {
                  $Message::DOM::ManakaiDOMElement::CompatClassET{$ns}
                          ->{'*'}->{$_}
                } keys %{$Message::DOM::ManakaiDOMElement::CompatClassET{$ns}
                                 ->{'*'}})) {
                  if ($Message::DOM::ClassFeature{$pack}
                            ->{$feature}->{$version}) {
                    __CODE{getNodeRef::
                      $object => {$self->{<Q::TreeCore:node>}},
                      $ref => $r,
                      $class => $pack,
                    }__;
                    last CLASS;
                  }
                }
              }

              ## Element type independent classes
              CLASS: for my $class (grep {
                $Message::DOM::ManakaiDOMElement::CompatClass{$_}
              } keys %Message::DOM::ManakaiDOMElement::CompatClass) {
                if ($Message::DOM::ClassFeature{$class}
                            ->{$feature}->{$version}) {
                  __CODE{getNodeRef::
                    $object => {$self->{<Q::TreeCore:node>}},
                    $ref => $r,
                    $class => $class,
                  }__;
                  last CLASS;
                }
              }
            }
##Element


ElementTypeBinding:
  @Name: TrueCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:InCase
    @@Value:
      @@@@: 1
      @@@ContentType: DISCore|Boolean
    @@Type:
      DOMMain:boolean::ManakaiDOM:all

ElementTypeBinding:
  @Name: FalseCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:InCase
    @@Value:
      @@@@: 0
      @@@ContentType: DISCore|Boolean
    @@Type:
      DOMMain:boolean::ManakaiDOM:all

ElementTypeBinding:
  @Name: intValue
  @ElementType:
    dis:Value
  @ShadowContent:
    @@ContentType: DISCore|Integer

ResourceDef:
  @QName: getNodeRef
  @AliasFor: ManakaiNode|getNewReference||ManakaiDOM|Perl
  @For: ManakaiDOM|ManakaiDOM !=ManakaiDOM|ManakaiDOM

ForDef:
  @QName:
    DOMCore:ForSelect
  @enDesc:
    For selecting an attribute node for the purpose other than
    removing the node.

ForDef:
  @QName:
    DOMCore:ForRemove
  @enDesc:
    For selecting an attribute node for the purpose of removing.

ElementTypeBinding:
  @Name: enDesc
  @ElementType:
    dis:Description
  @ShadowContent:
    @@lang:en

IFCls1Def:
  @IFQName: Text
  @ClsQName: ManakaiDOMText

  @IFISA: CharacterData
  @ClsISA: ManakaiDOMCharacterData
  
  @DISLang:role: TextRole

  @Description:
    @@lang:en
    @@@:
      The textual content of an "Element" or "Attr".
    \
      When a document is first made available via the DOM, 
      there is only one "Text" node for each block of text. 
      DOM applications may create adjust "Text" nodes that 
      represent the contents of a given node (but there is no 
      way to represent the separation between these nodes in 
      XML or HTML so they will not persist between DOM editing sessions 
      in general).

  @Method:
     @@Name:  splitText
     @@Description:
       @@@lang:en
       @@@@:
         Break this node into two nodes.  After being split, 
         this node will contain all the content up to the break point 
         and a new node of the same type will contain all the content 
         at and after the break point.
      \
         If the original node had a parent node, the new node is 
         inserted as the next sibling of this node.
     @@L1:
     @@Param:
        @@@Name:  offset
        @@@Type:  
          DOMMain:unsigned-long||ManakaiDOM|all
        @@@Description:
          @@@@lang:en
          @@@@@:
            The 16-bit unit offset at which to split.
     @@Return:
        @@@Type:  Text
        @@@Description:
          @@@@lang:en
          @@@@@: The new node, of the same type as this node.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: INDEX_SIZE_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The "offset" is negative or greater than the number 
              of 16-bit units.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Either this node is read-only [DOM 1, 2, 3] or 
              the parent node of this node is read-only.
      @@@Exception:
        @@@@Type: 
          ManakaiDOM:ManakaiDOMImplementationException
        @@@@Name: MDOM_INDEX_IN_SURROGATE_PAIR
        @@@@Description:
          @@@@@lang:en
          @@@@@@: An attempt is made to break surrogate pair.
      @@@PerlDef:
        @@@@For:!ManakaiDOM|all
        @@@@@:
          my $node = $self->{<Q::TreeCore:node>};
          my $parentNode = $node->{<Q::infoset:parent>};
          if ($node->{<Q::DOMCore:read-only>}) {
            __EXCEPTION{
              MDOMX:NOMOD_THIS::
            }__;
          } elsif ($parentNode and $parentNode->{<Q::DOMCore:read-only>}) {
            __EXCEPTION{
              MDOMX:NOMOD_PARENT::
            }__;
          }
          my $ds = \$node->{<Q::infoset:content>};
          my $len = CORE::length ($$ds) * 2;
          my $after;
          __DEEP{
            $after = <ClassM::DOMMain:ManakaiDOMString.substring>
                                         ($ds, $offset, $len);
            <ClassM::DOMMain:ManakaiDOMString.delete> ($ds, $offset, $len);
          }__;
          my $newNode;
          if ($node->{<Q::DOMCore:nodeType>} eq <Q::DOMCore:Text>) {
            $newNode = <ClassM::ManakaiDOMText.newObject>;
          } elsif ($node->{<Q::DOMCore:nodeType>} eq <Q::DOMXML:CDATASection>) {
            $newNode = <ClassM::DOMXML:ManakaiDOMCDATASection.newObject>;
          } else {
            __EXCEPTION{
              MDOMX:MDOM_DEBUG_BUG||ManakaiDOM:Perl::
                MDOMX:values => {+{
                  <Q::DOMCore:nodeType> => $node->{<Q::DOMCore:nodeType>},
                }},
            }__;
          }
          $newNode->{<Q::infoset:content>} = $after;
          $newNode->{<Q::DOMCore:ownerDocument>} = $parentNode
                                                 ->{<Q::DOMCore:ownerDocument>};
          if ($parentNode) {
            $parentNode-><M::NodeStem.importTree> ($newNode);
            for my $i (0..$#{$parentNode->{<Q::infoset:children>}}) {
              if ($parentNode->{<Q::infoset:children>}->[$i]
                             ->{<Q::TreeCore:nodeID>} eq
                  $node->{<Q::TreeCore:nodeID>}) {
                splice @{$parentNode->{<Q::infoset:children>}},
                       $i + 1, 0, $newNode;
                last;
              }
            }
            $newNode->{<Q::infoset:parent>} = $parentNode;
          }
          $newNode->{<Q::DOMCore:ownerDocument>}
                                           = $node->{<Q::DOMCore:ownerDocument>};
  @Attr:
     @@Name:  isElementContentWhitespace
     @@Description:
       @@@lang:en
       @@@@:
         Whether this text node contains element content whitespaces.
     @@Get:
        @@@Type:  DOMMain|boolean||ManakaiDOM|all
        @@@InCase:
          @@@@Value:true
          @@@@Description:
            @@@@@lang:en
            @@@@@@: This text node contains element content whitespaces.
        @@@InCase:
          @@@@Value:false
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              This text node contains element content whitespaces or 
              no validation occurs so that it is unknown.
        @@@disDef:
          @@@@GetProp:
            infoset:elementContentWhitespace
     @@Level[list]:  3
     @@SpecLevel:3
     @@For:
       ManakaiDOM:DOM3
     @@L3:
  @Attr:
     @@Name:  wholeText
     @@Description:
       @@@lang:en
       @@@@:
         All text of logically-adjacent text nodes.
     @@ImplNote:
       @@@lang:en
       @@@@:
         The DOM Level 3 Core Specification is unclear about 
         <IF::DOMXML:CDATASection>s.
         They should also be included (c.f. the definition for 
         <A::Text.replaceWholeText>).
         \
         What about unexpanded entity references?
     @@Get:
        @@@Type:  
          DOMMain:DOMString
        @@@ImplNote:
          @@@@ContentType:
            lang:Perl
          @@@@@:
            my $parent = $self-><AG::DOMCore:Node.parentNode>;
            if ($parent-><AG::DOMCore:Node.nodeType> !=
                <C::DOMCore:Node.ENTITY_REFERENCE_NODE>) {
              my $start = -1;
              my $end = -1;
              my $mfound = 0;
              my $sibs = $parent-><AG::DOMCore:Node.childNodes>;
              my $sibl = $sibs-><AG::DOMCore:NodeList.length>;
              for (my $i = 0; $i < $sibl; $i++) {
                my $sib = $sibs-><AG::DOMCore:NodeList.item> ($i);
                if (not $mfound and $sib-><M::DOMCore:Node.isSameNode> ($self)) {
                  $start = $i if $start == -1;
                  $end = $i;
                  $mfound = 1;
                } elsif ({
                           <C::Node.TEXT_NODE> => 1,
                           <C::Node.CDATA_SECTION_NODE> => 1,
                         }->{$sib-><AG::DOMCore:Node.nodeType>}) {
                  if ($mfound) {
                    $end = $i;
                  } else {
                    $start = $end = $i;
                  }
                } elsif ($sib-><AG::DOMCore:Node.nodeType> ==
                         <C::Node.ENTITY_REFERENCE_NODE>) {
                  if ($mfound) {
                    
                  } else {

                  }
                }
              }
            }

   TODO: Implement this.
            my $node = $self->{<Q::TreeCore:node>};
            if ($node->{<Q::infoset:parent>}) {
              my $parentNode = $node->{<Q::infoset:parent>};
              my (@t, @tr1, @tr2);
              my ($found, $first, $last);
              for my $i (0..$#{$parentNode->{<Q::infoset:children>}}) {
                if ({
                      <Q::DOMCore:Text> => 1,
                      <Q::DOMXML:CDATASection> => 1,
                    }->{$parentNode->{<Q::infoset:children>}->[$i]
                                   ->{<Q::DOMCore:nodeType>}}) {
                  push @t, $parentNode->{<Q::infoset:children>}->[$i];
                  $first = ($i == 0);
                  $last = ($i == $#{$parentNode->{<Q::infoset:children>}});
                  $found = 1 if $parentNode->{<Q::infoset:children>}->[$i]
                                           ->{<Q::TreeCore:nodeID>} eq
                                $parentNode->{<Q::TreeCore:nodeID>};
                } elsif ($parentNode->{<Q::infoset:children>}->[$i]
                                   ->{<Q::DOMCore:nodeType>} eq
                         <Q::DOMXML:EntityReference>) {
                  if ($found) {
                    push @tr2, $parentNode->{<Q::infoset:children>}->[$i];
                    $last = ($i == $#{$parentNode->{<Q::infoset:children>}});
                  } else {
                    push @tr1, $parentNode->{<Q::infoset:children>}->[$i];
                  }
                } else {
                  if ($found) {
                    last;
                  } else {
                    $first = 0;
                    $last = 0;
                    @t = ();
                  }
                }
              }
              if ($parentNode->{<Q::DOMCore:nodeType>} eq
                  <Q::DOMXML:EntityReference> and 
                  $parentNode->{<Q::infoset:parent>}) {
                
              }
            } else {
              $r = $node->__ SUPER{ManakaiDOMNodeObjectNode::}__::__ INT{textContent}__;
            }
     @@L3:
     @@Level[list]:  3
     @@SpecLevel:3
     @@For:
       ManakaiDOM:DOM3
  @Method:
     @@Name:  replaceWholeText
     @@Return:
        @@@Type:  Text
        @@@Exception[list]:  DOMException
     @@Param:
        @@@Name:  content
        @@@Type:  
          DOMMain:DOMString
     @@Level[list]:  3
     @@SpecLevel:3
     @@For:
       ManakaiDOM:DOM3
     @@L3:
  
  @ReAttr:
    @@Name: nodeName
    @@Description:
      @@@lang:en
      @@@@: The node name.
    @@Spec:
      @@@DOM3[list]:
        http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-F68D095
        http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-1841493061
    @@DOMMain:isNamespaceUnaware:1
    @@L1:
    @@Get:
      @@@Type: 
        DOMMain:DOMString
      @@@InCase:
        @@@@Value:\#text
        @@@@Description:
          @@@@@lang:en
          @@@@@@: Always this value for the "Text" node.
      @@@DefaultValue:
        @@@@@: \#text
        @@@@ContentType:
          DISCore:String
      @@@disDef:
        @@@@DISLang:nop:
  @ReAttr:
    @@Name: nodeType
    @@Description:
      @@@lang:en
      @@@@: The type of this node.
    @@L1:
    @@Get:
      @@@Type: 
        DOMMain:unsigned-short||ManakaiDOM|all
      @@@InCase:
        @@@@Label: TEXT_NODE
        @@@@Description:
          @@@@@lang:en
          @@@@@@: The node is a "Text".
      @@@disDef:
        @@@@DISLang:constValue:Node.TEXT_NODE

  @IntMethod:
    @@Name: newObject
    @@Description:
      @@@lang:en
      @@@@:
        Construct an object for a new instance of the <IF::Text> node.
    @@Return:
      @@@Type: NodeStem
      @@@Description:
        @@@@lang:en
        @@@@@:
          The new object for the <IF::Text> node.
      @@@PerlDef:
          $r = <ClassM::ManakaiDOMNode.newObject>;
          push @{$r->{<Q::TreeCore:origin>}}, <Q::infoset:parent>;
          $r->{<Q::DOMCore:nodeType>} = <Q::DOMCore:Text>;
          $r->{<Q::infoset:content>} = '';
     @@ImplNote:
       @@@lang:en
       @@@@:
         Other properties requires to be a legal <IF::Text>:
         <Q::DOMCore:ownerDocument>.
         \
         Other available properties: <Q::infoset:ElementContentWhitespace>, 
         <Q::infoset:parent>, <Q::infoset:content>, <Q::DOMCore:read-only>.

  @Method:
     @@Name:  getFeature
     @@enDesc:
       Returns a specialized object that implements the
       specialized interfaces of the specified feature and version.
     @@ManakaiDOM:isRedefining:1
     @@ForCheck: ManakaiDOM|ForClass ManakaiDOM|DOM3
     @@Param:
        @@@Name:  feature
        @@@Type:  
          DOMMain:DOMString
        @@@actualType: ManakaiDOM|ManakaiDOMFeatureName
        @@@enDesc:
          The feature name to request.
        @@@InCase:
          @@@@Label:
            @@@@@lang:en
            @@@@@@: 
              Feature name preceded by a <CHAR::PLUS SIGN>
          @@@@enDesc:
            The <CHAR::PLUS SIGN> is ignored.
     @@Param:
        @@@Name:  version
        @@@Type:  
          DOMMain:DOMString
        @@@actualType: ManakaiDOM|ManakaiDOMFeatureVersion
        @@@enDesc:
          The feature version to request.
        @@@nullCase:
          @@@@enDesc:
            No specific version is requested.
     @@Return:
        @@@Type:  
          DOMMain:DOMObject
        @@@enDesc:
          An object implementing the specialized interfaces.
          Note that the specialized object may or may not
          implement the <IF::Node> interface.
        @@@nullCase:
          @@@@enDesc:
            There is no object available that implements
            the specialized interfaces.
        @@@PerlDef:
            $feature =~ s/^\+//;
            if ($Message::DOM::ClassFeature{ref $self}->{$feature}->{$version}) {
              ## This class
              $r = $self;
            } else {
              CLASS: for my $class (grep {
                $Message::DOM::ManakaiDOMText::CompatClass{$_}
              } keys %Message::DOM::ManakaiDOMText::CompatClass) {
                if ($Message::DOM::ClassFeature{$class}
                            ->{$feature}->{$version}) {
                  __CODE{getNodeRef::
                    $object => {$self->{<Q::TreeCore:node>}},
                    $ref => $r,
                    $class => $class,
                  }__;
                  last CLASS;
                }
              }
            }
##Text

IFCls1Def:
  @IFQName: Comment
  @ClsQName: ManakaiDOMComment

  @IFISA: CharacterData
  @ClsISA: ManakaiDOMCharacterData
  
  @DISLang:role: CommentRole

  @Description:
    @@lang:en
    @@@:
      A comment, corresponding to a comment declaration in the HTML or 
      XML or a comment information item in the XML Infoset.
  @ImplNote:
    @@lang:en
    @@@:
      HTML comment declaration might have multiple "comment".  DOM 
      does not support it.
  
  @ReAttr:
    @@Name: nodeName
    @@Spec:
      @@@DOM3[list]:
        http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-F68D095
        http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-1841493061
    @@DOMMain:isNamespaceUnaware:1
    @@L1:
    @@Description:
      @@@lang:en
      @@@@: The node name.
    @@DOMMain:isNamespaceUnaware:1
    @@Get:
      @@@Type: 
        DOMMain:DOMString
      @@@InCase:
        @@@@Value: \#comment
        @@@@Description:
          @@@@@lang:en
          @@@@@@: Always this value for the "Comment" node.
      @@@disDef: 
        @@@@DISLang:value:
          @@@@@@: \#comment
          @@@@@ContentType:
            DISCore:String
  @ReAttr:
    @@Name: nodeType
    @@Description:
      @@@lang:en
      @@@@: The type of this node.
    @@L1:
    @@Get:
      @@@Type: 
        DOMMain:unsigned-short||ManakaiDOM|all
      @@@InCase:
        @@@@Label: COMMENT_NODE
        @@@@Description:
          @@@@@lang:en
          @@@@@@: The node is a "Comment".
      @@@disDef:
        @@@@DISLang:constValue: Node.COMMENT_NODE

  @IntMethod:
    @@Name: newObject
    @@Description:
      @@@lang:en
      @@@@:
        Construct an object for a new instance of the <IF::Comment> node.
    @@Return:
      @@@Type: NodeStem
      @@@Description:
        @@@@lang:en
        @@@@@:
          The new object for the <IF::Comment> node.
      @@@PerlDef:
          $r = <ClassM::ManakaiDOMNode.newObject>;
          push @{$r->{<Q::TreeCore:origin>}}, <Q::infoset:parent>;
          $r->{<Q::DOMCore:nodeType>} = <Q::infoset:Comment>;    
          $r->{<Q::infoset:content>} = '';
     @@ImplNote:
       @@@lang:en
       @@@@:
         Other properties required to be a legal <IF::Comment> object:
         <Q::DOMCore:ownerDocument>.
        \
         Other available properties: <Q::infoset:parent>, <Q::infoset:content>, 
         <Q::DOMCore:read-only>.

  @Method:
     @@Name:  getFeature
     @@enDesc:
       Returns a specialized object that implements the
       specialized interfaces of the specified feature and version.
     @@ManakaiDOM:isRedefining:1
     @@ForCheck: ManakaiDOM|ForClass ManakaiDOM|DOM3
     @@Param:
        @@@Name:  feature
        @@@Type:  
          DOMMain:DOMString
        @@@actualType: ManakaiDOM|ManakaiDOMFeatureName
        @@@enDesc:
          The feature name to request.
        @@@InCase:
          @@@@Label:
            @@@@@lang:en
            @@@@@@: 
              Feature name preceded by a <CHAR::PLUS SIGN>
          @@@@enDesc:
            The <CHAR::PLUS SIGN> is ignored.
     @@Param:
        @@@Name:  version
        @@@Type:  
          DOMMain:DOMString
        @@@actualType: ManakaiDOM|ManakaiDOMFeatureVersion
        @@@enDesc:
          The feature version to request.
        @@@nullCase:
          @@@@enDesc:
            No specific version is requested.
     @@Return:
        @@@Type:  
          DOMMain:DOMObject
        @@@enDesc:
          An object implementing the specialized interfaces.
          Note that the specialized object may or may not
          implement the <IF::Node> interface.
        @@@nullCase:
          @@@@enDesc:
            There is no object available that implements
            the specialized interfaces.
        @@@PerlDef:
            $feature =~ s/^\+//;
            if ($Message::DOM::ClassFeature{ref $self}->{$feature}->{$version}) {
              ## This class
              $r = $self;
            } else {
              CLASS: for my $class (grep {
                $Message::DOM::ManakaiDOMComment::CompatClass{$_}
              } keys %Message::DOM::ManakaiDOMComment::CompatClass) {
                if ($Message::DOM::ClassFeature{$class}
                            ->{$feature}->{$version}) {
                  __CODE{getNodeRef::
                    $object => {$self->{<Q::TreeCore:node>}},
                    $ref => $r,
                    $class => $class,
                  }__;
                  last CLASS;
                }
              }
            }
##Comment

IFDef:
  @Name: TypeInfo
  @Description:
    @@lang:en
    @@@:
      A type referenced from "Element" or "Attr" nodes, 
      specified in the schemas associated with the document.
    \
      The type is a pair of namespace URI and name.  It depsnds 
      on the schema language in use.
  @ImplNote:
    @@lang:en
    @@@:
      If the schema language is the XML Schema:
     \
      - If [validity] property exists and its value is 
      "invalid" or "notKnown": ("typeNamespace", "typeName") = 
      ({target namespace}, {name}) or ("null", "null").
     \
      NOTE: The XML Schema specification does not require 
      exposing the declared type.  DOM implementation might choose 
      not to provide type information if validity is not valid.
     \
      - If [validity] exists and its value is "valid":
     \
      -- If [member type definition] exists:
     \
      --- If {name} is not absent: ("typeNamespace", "typeName") = 
      [member type definition].({target namespace}, {name}).
     \
      --- Otherwise: ("typeNamespace", "typeName") = 
      (namespace, local name) of the corresponding anonymous type name.
     \
      -- If [type definition] exists:
     \
      --- If {name} is not absent: ("typeNamespace", "typeName") =
      [type definition].({target namespace}, {name}).
     \
      --- Otherwise: ("typeNamespace", "typeName") =
      (namespace, local name) of the corresponding anonymous type name.
     \
      -- If [member type definition anonymous] exists:
     \
      --- If false: ("typeNamespace", "typeName") =
      ([member type definition namespace], [member type definition name]).
     \
      --- Otherwise: ("typeNamespace", "typeName") =
      (namespace, local name) of the corresponding anonymous type name.
     \
      -- If [type definition anonymous] exists:
     \
      --- If false: ("typeNamespace", "typeName") =
      ([type definition namespace], [type definition name]).
     \
      --- Otherwise: ("typeNamespace", "typeName") =
      (namespace, local name) of the corresponding anonymous type name.
     \
      Other schema languages are outside of the scope of the W3C and 
      should define how to represent their type systems using "TypeInfo".
  @Level[list]:  3
  @SpecLevel:3
  @L3:
  @For:
    ManakaiDOM:DOM3
  @For:
    =ManakaiDOM:ManakaiDOM
  @Attr:
     @@Name:  typeName
     @@Description:
       @@@lang:en
       @@@@: The name of the type.
     @@L3:
     @@Get:
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The name of the type.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The name is unknown.
       
  @Attr:
     @@Name:  typeNamespace
     @@Description:
       @@@lang:en
       @@@@: The namespace of the type.
     @@L3:
     @@Get:
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The namespace of the type.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Either the associated element or attribute does not have 
              declaration or no namespace information is available.
        @@@InCase:
          @@@@Value:
            http://www.w3.org/TR/REC-xml
          @@@@Description:
            @@@@@lang:en
            @@@@@@: 
              The schema language is the XML DTD and the node 
              associated is an "Attr".
            \
              In this case, the "typeName" is the value of 
              the [attribute type] property of the XML Infoset.
     @@ImplNote:
       @@@lang:en
       @@@@: Is this namespace *URI*?
  @ConstGroup:
     @@QName: DerivationMethods
     @@PerlName: DerivationMethods
     @@Description:
       @@@lang:en
       @@@@:
         A set of possible types of derivation.
     @@rdfs:subClassOf: 
       @@@@: DOMMain|unsigned-long||ManakaiDOM|all
       @@@ForCheck: ManakaiDOM|ForClass
     @@Type:
       DOMMain:unsigned-long::ManakaiDOM:all
     @@IsBitMask:1
     @@ImplNote:
       @@@lang:en
       @@@@:
         Any type derives from "xsd:anyType".
     @@Const:
        @@@Name:  DERIVATION_RESTRICTION
        @@@Value:  0x00000001
        @@@Description:
          @@@@lang:en
          @@@@@:
            The derivation by restriction.
        @@@ImplNote:
          @@@@lang:en
          @@@@@:
            Other type definition = reference type definition or 
            reference type definition.{base type definition}. ... 
            .{base type definition} = other type definition and 
            all the derivation methods involved are restriction.
          \
            Any simple type derives from "xsd:anySimpleType" by restriction.
     @@Const:
        @@@Name:  DERIVATION_EXTENSION
        @@@Value:  0x00000002
        @@@Description:
          @@@@lang:en
          @@@@@:
            The derivation by extension.
        @@@ImplNote:
          @@@@lang:en
          @@@@@:
            Reference type definition.{base type definition}.
            ... .{base type definition} = other type definition 
            and at least one of the derivation methods 
            involeved is an extension. 
          \
            Both types are complex types or both are simple types.
     @@Const:
        @@@Name:  DERIVATION_UNION
        @@@Value:  0x00000004
        @@@Description:
          @@@@lang:en
          @@@@@: The union.
        @@@ImplNote:
          @@@@lang:en
          @@@@@:
            Other type definition --derive[DERIVATION_RESTRICTION]--> T2 
            or other type definition = T2,
            T1 --derive[DERIVATION_RESTRICTION or DERIVATION_EXTENSION]--> 
            reference type definition or T1 = reference type definition, 
            T1.{variety} = union and T1.{member type definition} = T2.
     @@Const:
        @@@Name:  DERIVATION_LIST
        @@@Value:  0x00000008
        @@@Description:
          @@@@lang:en
          @@@@@: The list.
        @@@ImplNote:
          @@@@lang:en
          @@@@@: 
            Other type definition --derive[DERIVATION_RESTRICTION]--> T2 
            or other type definition = T2,
            T1 --derive[DERIVATION_RESTRICTION or DERIVATION_EXTENSION]--> 
            reference type definition or T1 = reference type definition, 
            T1.{variety} = list and T1.{item type definition} = T2.
  @Method:
     @@Name:  isDerivedFrom
     @@Description:
       @@@lang:en
       @@@@:
         Return whether there is a derivation between the definition 
         of this type and the other type definition.
     @@Param:
        @@@Name:  typeNamespaceArg
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The namespace of the other type definition.
     @@Param:
        @@@Name:  typeNameArg
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The name of the other type definition.
     @@Param:
        @@@Name:  derivationMethod
        @@@Type:  
          DOMMain:unsigned-long||ManakaiDOM|all
        @@@actualType: DerivationMethods
        @@@Description:
          @@@@lang:en
          @@@@@:
            The type of derivation and conditions applied between 
            two types.
     @@Return:
        @@@Type:  DOMMain|boolean||ManakaiDOM|all
        @@@InCase:
          @@@@Value:true
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The schema language is the XML Schema and 
              the definition of this type is derived from the 
              other type definition according to the derivation 
              parameter.
            \
              If the "derivationMethod" is "0", the other 
              type definition can be reached by recursing any 
              combination of {base type definition}, 
              {item type definition} or {member type definition} 
              from the definition of this type.
        @@@InCase:
          @@@@Value:false
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Either the schema language is the XML Schema and 
              the other type definition is not derived from 
              the definition of this type, the schema language 
              is the XML DTD or no schama language is associated.

IFDef:
  @Name:  UserDataHandler
  @Description:
    @@lang:en
    @@@:
      A handler to implement various behaviors regarding the 
      data associated to the DOM nodes.
  @Level[list]:  3
  @SpecLevel:3
  @For:
    =ManakaiDOM:ManakaiDOM
  @For:
    ManakaiDOM:DOM3
  @ConstGroup:
     @@QName:  OperationType
     @@PerlName: OperationType
     @@rdfs:subClassOf: 
       @@@@: DOMMain|unsigned-short||ManakaiDOM|all
       @@@ForCheck: ManakaiDOM|ForClass
     @@Type:
       DOMMain:unsigned-short::ManakaiDOM:all
     @@Description:
       @@@lang:en
       @@@@: The type of operation being performed on a node.
     @@Const:
        @@@Name:  NODE_CLONED
        @@@Value:  1
        @@@Description:
          @@@@lang:en
          @@@@@: The node is cloned.
        @@@ImplNote:
          @@@@lang:en
          @@@@@: The node is cloned.
        @@@ImplNote:
          @@@@lang:en
          @@@@@: "Node.cloneNode".
     @@Const:
        @@@Name:  NODE_IMPORTED
        @@@Value:  2
        @@@Description:
          @@@@lang:en
          @@@@@: The node is imported.
        @@@ImplNote:
          @@@@lang:en
          @@@@@: "Document.importNode".
     @@Const:
        @@@Name:  NODE_DELETED
        @@@Value:  3
        @@@Description:
          @@@@lang:en
          @@@@@:
            The node is deleted.
        @@@ImplNote:
          @@@@lang:en
          @@@@@:
            This may not be supported or may not be reliable in certain 
            environment, such as Java, where the DOM implementation 
            has no real control over when objects are actually deleted.
     @@Const:
        @@@Name:  NODE_RENAMED
        @@@Value:  4
        @@@Description:
          @@@@lang:en
          @@@@@: The node is renamed.
        @@@ImplNote:
          @@@@lang:en
          @@@@@: "Document.renameNode".
     @@Const:
        @@@Name:  NODE_ADOPTED
        @@@Value:  5
        @@@Description:
          @@@@lang:en
          @@@@@: The node is adopted.
        @@@ImplNote:
          @@@@lang:en
          @@@@@: "Document.adoptNode".
  @Method:
     @@Name:  handle
     @@Description:
       @@@lang:en
       @@@@:
         Called whenever the node for which the handler is registered 
         is imported or cloned.
       \
         DOM applications MUST NOT raise exceptions in a 
         "UserDataHandler".  The effect of throwing exceptions 
         from the handler is implementation dependent.
     @@ImplNote:
       @@@lang:en
       @@@@:
         The manakai DOM implementation does NOT warn when 
         an exception is thrown.
     @@Param:
        @@@Name:  operation
        @@@Type:  
          DOMMain:unsigned-short||ManakaiDOM|all
        @@@actualType: OperationType
        @@@Description:
          @@@@lang:en
          @@@@@: The type of operation that is being performed on the node.
     @@Param:
        @@@Name:  key
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The key for which this handler is being called.
     @@Param:
        @@@Name:  data
        @@@Type:  
          DOMMain:DOMUserData
        @@@Description:
          @@@@lang:en
          @@@@@: The data for which this handler is being called.
     @@Param:
        @@@Name:  src
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@: 
            The node being cloned, adopted, imported or renamed.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The node is being deleted.
     @@Param:
        @@@Name:  dst
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@: The node newly created.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: No node is newly created.
      @@Return:

IFCls3Def:
  @IFQName: DOMError
  @ClsQName: ManakaiDOMError

  @rdf:type:
    @@@:
      DOMMain:ErrorClass
    @@ForCheck:
      ManakaiDOM:ForClass

  @ClsISA:
    @@@: ManakaiDOM|ManakaiDOMExceptionOrWarning||ManakaiDOM|Perl
    @@ForCheck: ManakaiDOM|ForClass
  @ClsISA: ManakaiDOM|ManakaiDOMObject

  @Description:
    @@lang:en
    @@@: Describes an error.

  @ConstGroup:
    @@IFQName: ErrorSeverity
    @@ClsQName: ManakaiDOMErrorSeverity
    @@PerlName: ErrorSeverity
  
     @@rdfs:subClassOf: 
       @@@@: DOMMain|unsigned-short||ManakaiDOM|all
       @@@ForCheck: ManakaiDOM|ForClass
     @@Type: 
       DOMMain:unsigned-short::ManakaiDOM:all
     @@Description:
       @@@lang:en
       @@@@: The severity of the error.
     @@Const:
        @@@Name:  SEVERITY_WARNING
        @@@Value:  1
        @@@Description:
          @@@@lang:en
          @@@@@:
            Warning.  It will not cause the processing stop unless 
            <M::DOMErrorHandler.handleError> returns <DOM::false>.
     @@Const:
        @@@Name:  SEVERITY_ERROR
        @@@Value:  2
        @@@Description:
          @@@@lang:en
          @@@@@:
            Error.  It may not cause the processing to stop 
            if the error can be recovered, unless 
            <M::DOMErrorHandler.handleError> returns <DOM::false>.
     @@Const:
        @@@Name:  SEVERITY_FATAL_ERROR
        @@@Value:  3
        @@@Description:
          @@@@lang:en
          @@@@@:
            Fatal error.  It will cause the normal processing to stop.  
            The return value of <M::DOMErrorHandler.handleError> is 
            ignored unless the implementation chooses to continue, 
            in which case the behavior becomes undefined.
  @Attr:
     @@Name:  severity
     @@Description:
       @@@lang:en
       @@@@:
         The severity of the error.
     @@Get:
        @@@Type:  
          DOMMain:unsigned-short||ManakaiDOM|all
        @@@actualType:ManakaiDOMErrorSeverity
        @@@PerlDef:
          $r = $self->{<Q::MUErrorCore:def>}->{<Q::DOMCore:severity>};
  @Attr:
     @@Name:  message
     @@Description:
       @@@lang:en
       @@@@:
         An implementation specific string describing the error that occurred.
     @@Get:
        @@@Type:  
          DOMMain:DOMString
        @@@PerlDef:
          @@@@@:
            __DEEP{
              $r = $self->text;
            }__;
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              This attribute getter returns the text returned from 
              <Perl::Message::Util::Error>'s <Perl::text> method. 
              \
              {ISSUE:: It should be <Perl::stringify> instead? 
                       Or, it should be localized.
              \
              }
  @Attr:
     @@Name:  type
     @@Description:
       @@@lang:en
       @@@@:
         A string indicating which related data is expected in 
         "relatedData".
       \
         Implementators of DOM applications should refer to the 
         specification of the error in order to find "type" and 
         "relatedData" defiition if any.
     @@ImplNote:
       @@@lang:en
       @@@@: "Document.normalizeDocument".
     @@Get:
        @@@Type:  
          DOMMain:DOMString
        @@@actualType:DOMErrorType
        @@@PerlDef:
          $r = $self->{<Q::MUErrorCore:def>}->{<Q::DOMCore:type>};
  @Attr:
     @@Name:  relatedException
     @@Description:
       @@@lang:en
       @@@@: 
         The related platform dependent exception if any. 
         \
         An example would be an <CODE::IOException> or 
         <CODE::SecurityException> when using the <IF::DOMLS:LSParser>. 
     @@Get:
        @@@Type:  
          DOMMain:DOMObject
  @Attr:
     @@Name:  relatedData
     @@Description:
       @@@lang:en
       @@@@:
         The related <A::DOMError.type> dependent data if any.
     @@Get:
        @@@Type:  
          DOMMain:DOMObject
  @Attr:
     @@Name:  location
     @@Description:
       @@@lang:en
       @@@@: The location of the error.
     @@Get:
        @@@Type:  DOMLocator

  @ErrorSet:
    @@QName:
      @@@@:ManakaiDOMErrorCode
      @@@ForCheck:
        ManakaiDOM:ForClass
    @@Description:
      @@@lang:en
      @@@@:
        Errors that might be reported during the invocation of 
        the <M::Document.normalizeDocument> method.  These errors 
        might be reported during the invocation of other methods. 
    
    @@ErrorDef:
      @@@QName: check-character-normalization-failure
      @@@ErrName:check-character-normalization-failure
      @@@Value:1
      @@@Description:
        @@@@lang:en
        @@@@@:
          A string is encountered that fails normalization checking, 
          while the parameter <CP::check-character-normalization> 
          is set to <DOM::true>. 
      @@@DOMCore:severity:Error
      @@@DOMCore:relatedData:
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The node in which the string that fails checking is. 
          @@@@@ForCheck:
            ManakaiDOM:ManakaiDOM
      @@@ImplNote:
        @@@@lang:en
        @@@@@:
          This error is also used by DOM Level 3 LS <IF::DOMLS:LSParser>. 
    @@ErrorDef:
      @@@QName:cdata-section-splitted
      @@@ErrName:cdata-section-splitted
      @@@Value:2
      @@@Description:
        @@@@lang:en
        @@@@@:
          A character data section is split while <CP::split-cdata-sections> 
          is set to <DOM::true>. 
      @@@DOMCore:severity:Warning
      @@@DOMCore:relatedData:
        @@@@Type:
          DOMXML:CDATASection
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The first <IF::DOMXML:CDATASection> node in the document order 
            resulting from the split. 
    @@ErrorDef:
      @@@QName:wf-invalid-character-in-node-name
      @@@ErrName:wf-invalid-character-in-node-name
      @@@DOMCore:severity:FatalError
      @@@Value:3
      @@@Description:
        @@@@lang:en
        @@@@@:
          A <A::Node.nodeName> contains an invalid character according 
          to its node type. 
      @@@ErrSubTypeDef:
        @@@@QName:
          ManakaiDOMCore:normalize-invalid-character
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            A <A::Node.nodeName> attribute contains an invalid character 
            according to its node type while the parameter 
            <CP::well-formed> is set to <DOM::true>. 
        @@@@DOMCore:severity:Error
      @@@ErrSubTypeDef:
        @@@@QName:
          ManakaiDOMLS:serialize-invalid-character
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            A character that cannot be represented in the output character 
            encoding is encountered within markup but outside of attribute 
            values. 
        @@@@DOMCore:severity:FatalError
    @@ErrorDef:
      @@@QName:wf-invalid-character
      @@@ErrName:wf-invalid-character
      @@@Value:4
      @@@Description:
        @@@@lang:en
        @@@@@:
          The text inside an <IF::Attr>, <IF::Element>, <IF::Comment>, 
          <IF::Text> or <IF::DOMXML:CDATASection> node or the data 
          inside a <IF::DOMXML:ProcessingInstruction> node contains an 
          invalid character, while the parameter <CP::well-formed>
          is set to <DOM::true>. 
      @@@DOMCore:severity:Error
##DOMError

ElementTypeBinding:
  @Name: FormatDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISCore|LexicalType
    @@For: =ManakaiDOM|all
    @@rdfs:subClassOf:
      DISCore:String::ManakaiDOM:all

FormatDef:
  @QName:DOMErrorType
  @Description:
    @@lang:en
    @@@:
      Types of DOM errors, i.e. values for <AG::DOMError.type>. 

PropDef:
  @QName: xmlEncoding
  @enDesc:
    <A::Document.xmlEncoding>

PropDef:
  @QName:
    DOMCore:type
  @Description:
    @@lang:en
    @@@:
      The type of a DOM error. 
  @rdfs:range:
    DOMCore:DOMErrorType

IFCls3Def:
  @IFQName: DOMErrorHandler
  @ClsQName: ManakaiDOMErrorHandler

  @ClsISA: ManakaiDOM|ManakaiDOMObject

  @enDesc:
    The <IF::DOMErrorHandler> is a callback interface that the DOM
    implementation can call when reporting errors that happens
    while processing (e.g. parsing an XML entity or validating a 
    document).

    A <IF::DOMErrorHandler> object can be attached to a <IF::Document>
    using the <CP::error-handler> parameter on the <A::Document.domConfig>
    object.  DOM applications can create their own 
    <IF::DOMErrorHandler> objects to process reported errors.

    If more than one error need to be reported during an operation,
    the sequence and numbers of the errors passed to the error
    handler are implementation dependent <SRC::<CITE::DOM Level 3 Core>>.

  @enDesc:
    @@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM
    @@@:
      In the manakai implementation, any Perl reference to
      <Perl::CODE> can be used as if it implements the 
      <IF::DOMErrorHandler> interface and its <M::DOMErrorHandler
      .handleError> method is the <Perl::CODE> itself.

  @ResourceDef:
    @@rdf:type: DISLang|InputProcessor
    @@PerlDefC:
      $INPUT = bless $INPUT, __PACKAGE__ if ref $INPUT eq 'CODE';
    @@ImplNote:
      @@@lang:en
      @@@@:
        Classes inheriting this class must redefine this normalizer 
        because of <Perl::__PACKAGE__>. 

  @Method:
     @@Name:  handleError
     @@enDesc:
       DOM implementation calls this method when an error occurs.
     @@Param:
        @@@Name:  error
        @@@Type:  DOMError
        @@@Description:
          @@@@lang:en
          @@@@@:
            The error object that describes the error.
          \
            This object may be reused by the DOM implementation 
            across multiple calls to the method <M::DOMErrorHandler.handleError>.
     @@Return:
        @@@Type:  DOMMain|boolean||ManakaiDOM|all
        @@@Description:
          @@@@lang:en
          @@@@@:
            Whether the processing should be continued.
          \
            Throwing an exception from this method is considered 
            to be equivalent of returning "true".
        @@@InCase:
          @@@@Value: true
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The processing may continue depending on <A::DOMError.severity>.
        @@@InCase:
          @@@@Value:false
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The processing should be stopped when possible.
        @@@PerlDef:
          $r = $self->($error);
  @IntMethod:
    @@Name:createNOPHandler
    @@ManakaiDOM:isStatic:1
    @@Description:
      @@@lang:en
      @@@@:
        Creates a no-op error handler, i.e. a <IF::DOMErrorHandler> 
        with a <M::DOMErrorHandler.handleError> method that only 
        returns <DOM::true>. 
    @@Return:
      @@@Type: ManakaiDOMErrorHandler
      @@@PerlDef:
        $r = bless sub {return true}, ref $self ? ref $self : $self;
##DOMErrorHandler

IFDef:
  @Name:  DOMLocator
  @Level[list]:  3
  @SpecLevel:3
  @For:
    ManakaiDOM:DOM3
  @For:
    =ManakaiDOM:ManakaiDOM
  @Description:
    @@lang:en
    @@@: Describes a location.
  @Attr:
     @@Name:  lineNumber
     @@Description:
        @@@lang:en
        @@@@: The line number to which this locator is pointing.
     @@Get:
        @@@Type:  
          DOMMain:long::ManakaiDOM:all
        @@@Description:
          @@@@lang:en
          @@@@@: The line number.
        @@@InCase:
          @@@@Value:-1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: There is no column number available.
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              <QUOTE::Column> in the DOM 3 Specification should be 
              <QUOTE::line>?  Or is this description correct?
  @Attr:
     @@Name:  columnNumber
     @@Description:
       @@@lang:en
       @@@@: The column number to which this locator is pointing.
     @@Get:
        @@@Type:  
          DOMMain:long::ManakaiDOM:all
        @@@Description:
          @@@@lang:en
          @@@@@: The column number.
        @@@InCase:
          @@@@Value:-1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              There is no column number available.
  @Attr:
     @@Name:  byteOffset
     @@Description:
       @@@lang:en
       @@@@:
         The byte offset into the input source to which this locator 
         is pointing.
     @@Get:
        @@@Type:  
          DOMMain:long::ManakaiDOM:all
        @@@Description:
          @@@@lang:en
          @@@@@: The byte offset.
        @@@InCase:
          @@@@Value: -1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: There is no byte offset available.
  @Attr:
     @@Name:  utf16Offset
     @@PerlName: utf16_offset
     @@Description:
       @@@lang:en
       @@@@:
         The UTF-16 offset into the input source to which 
         this locator is pointing.
     @@Get:
        @@@Type:  
          DOMMain:long::ManakaiDOM:all
        @@@Description:
          @@@@lang:en
          @@@@@: The UTF-16 offset.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: There is no UTF-16 offset available.
  @Attr:
     @@Name:  relatedNode
     @@Description:
       @@@lang:en
       @@@@: The node to which this locator is pointing.
     @@Get:
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@: The node pointed.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: There is no node available.
  @Attr:
     @@Name:  uri
     @@Description:
       @@@lang:en
       @@@@: The URI to which this locator is pointing.
     @@Get:
        @@@Type:
          DOMMain:DOMString
        @@@actualType:
          ManakaiDOM:ManakaiDOMURI
        @@@Description:
          @@@@lang:en
          @@@@@: The URI.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: There is no URI is available.

ElementTypeBinding:
  @Name: PerlName
  @ElementType:
    dis:AppName
  @ShadowContent:
    @@ContentType: lang|Perl
    @@For: ManakaiDOM|Perl

IFDef:
  @Name:  DOMConfiguration
  @Description:
    @@lang:en
    @@@:
      The configuration of a document.  It maintains a table 
      of recognized parameters.
  @ImplNote:
    @@lang:en
    @@@:
      Parameters affect: <M::Document.normalizeDocument>, 
      validation, <IF::DOMParser>, <IF::DOMSerializer>, etc.
  @Level[list]:  3
  @SpecLevel:3
  @For:
    =ManakaiDOM:ManakaiDOM
  @For:
    ManakaiDOM:DOM3
  @Method:
     @@Name:  setParameter
     @@Description:
       @@@lang:en
       @@@@:
         Set the value of a parameter.
     @@Param:
        @@@Name:  name
        @@@Type:
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The name of the parameter to set.
     @@Param:
        @@@Name:  value
        @@@Type:  
          DOMMain:DOMUserData
        @@@Description:
          @@@@lang:en
          @@@@@: 
            The new value.  The object type must match the type 
            defined by the definition of the parameter.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: Unset the parameter.
     @@Return:
        @@@Exception:
          @@@@Name: NOT_FOUND_ERR
          @@@@Type: DOMException
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The parameter name is not recognized.
        @@@Exception:
          @@@@Name: NOT_SUPPORTED_ERR
          @@@@Type: DOMException
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The parameter name is recognized but the requested 
              value cannot be set.
        @@@Exception:
          @@@@Name: TYPE_MISMATCH_ERR
          @@@@Type: DOMException
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The value type for this parameter name is 
              incompatible with the expected value type.
  @Method:
     @@Name:  getParameter
     @@Description:
       @@@lang:en
       @@@@: Return the value of a parameter.
     @@Param:
        @@@Name:  name
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            The name of the parameter.
     @@Return:
        @@@Type:  
          DOMMain:DOMUserData
        @@@Description:
          @@@@lang:en
          @@@@@:
            The current object associated with the specified 
            parameter.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Either no object has been associated or the parameter 
              is not supported.
        @@@Exception:
          @@@@Name: NOT_FOUND_ERR
          @@@@Type: DOMException
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The parameter name is not recognized.
  @Method:
     @@Name:  canSetParameter
     @@Description:
       @@@lang:en
       @@@@:
         Check if setting a parameter to a specific value is supported. 
         The current value of the parameter itself is not changed.
     @@Param:
        @@@Name:  name
        @@@Type:
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            The name of the parameter to check.
     @@Param:
        @@@Name:  value
        @@@Type:  
          DOMMain:DOMUserData
        @@@Description:
          @@@@lang:en
          @@@@@:
            An object to check.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: 
              \ <DOM::true> will be returned.
     @@Return:
        @@@Type:  DOMMain|boolean||ManakaiDOM|all
        @@@InCase:
          @@@@Value:true
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The parameter could be successfully set to the 
              specified value.
        @@@InCase:
          @@@@Value:false
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The parameter is not recognized or the 
              requested value is not supported.
  @Attr:
     @@Name:  parameterNames
     @@Description:
       @@@lang:en
       @@@@:
         The list of the parameters supported by this 
         <IF::DOMConfiguration> object and for which at least 
         one value can be set by the DOM application.
     @@ImplNote:
       @@@lang:en
       @@@@:
         Parameternames defined outside the DOM Level 3 Core Specification 
         also contained.
     @@Get:
        @@@Type:  DOMStringList

NodeTypeDef:
  @IFQName: DocumentFragment
  @ClsQName: ManakaiDOMDocumentFragment
  
  @DISLang:role: DocumentFragmentRole

  @enDesc:
    <IF::DocumentFragment> is a <QUOTE::lightweight> or <QUOTE::minimal>
    <IF::Document> object.  It is useful to extract a portion of
    a document tree or to create a new fragment of a document.

    In various operations, such as inserting nodes as children
    of another <IF::Node> by <M::Node.appendChild>, 
    a <IF::DocumentFragment> node is treated <QUOTE::transparent> -- 
    it results in all the child nodes of the <IF::DocumentFragment>
    being moved to the child list of that <IF::Node>.

  @IntMethod:
    @@Name: newObject
    @@Description:
      @@@lang:en
      @@@@:
        Construct a node stem for a new instance of the
        <IF::DocumentFragment> object.
      \
        Note that this method is for the internal use.  The DOM 
        applications must use the <M::Document.createDocumentFragment> method 
        to create a new <IF::DocumentFragment> object.
    @@Return:
      @@@Type: NodeStem
      @@@Description:
        @@@@lang:en
        @@@@@: 
          The new node stem object of type <IF::DocumentFragment>.
      @@@PerlDef:
          $r = <ClassM::ManakaiDOMNode.newObject>;
          push @{$r->{<Q::TreeCore:origin>}}, <Q::infoset:parent>;
          push @{$r->{<Q::TreeCore:subnode>}}, <Q::infoset:children>;
          $r->{<Q::infoset:children>} = [];
          $r->{<Q::DOMCore:nodeType>} = <Q::DOMCore:DocumentFragment>;          
       @@@ImplNote:
         @@@@lang:en
         @@@@@:
           Other properties required to be a legal <IF::DocumentFragment> 
           object: <Q::DOMCore:ownerDocument>. 
         \
           Other available properties: <Q::infoset:children>, 
           <Q::DOMCore:read-only>.
  
  @ReMethod:
     @@Name:  lookupPrefix
     @@Description:
       @@@lang:en
       @@@@:
         Lookup the namespace prefix associated to the given namespace 
         URI, starting from this node.
       \
         The default namespace declarations are ignored by this method. 
         To lookup default namespace, use the <M::Node.isDefaultNamespace>
         method.
     @@Param:
        @@@Name:  namespaceURI
        @@@Type:
          DOMMain:DOMString
        @@@actualType:
          ManakaiDOM:ManakaiDOMNamespaceURI
        @@@Description:
          @@@@lang:en
          @@@@@: The namespace URI to look for.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Always <DOM::null> will be returned.
        @@@InCase:
          @@@@Value:\
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Always <DOM::null> will be returned.
     @@Return:
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            An associated namespace prefix.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              No namespace prefix is found.  Always <DOM::null> is 
              returned for the <IF::DocumentFragment> node.
        @@@PerlDef:
          @@@@@: $r = null;
     @@Level[list]:  3
     @@SpecLevel:3
     @@For:
       ManakaiDOM:DOM3
  @ReAttr:
    @@Name: nodeName
    @@Description:
      @@@lang:en
      @@@@: The node name.
    @@Spec:
      @@@DOM3[list]:
        http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-F68D095
        http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-1841493061
    @@DOMMain:isNamespaceUnaware:1
    @@Get:
      @@@Type: 
        DOMMain:DOMString
      @@@InCase:
        @@@@Value:\#document-fragment
        @@@@Description:
          @@@@@lang:en
          @@@@@@: Always this value for the "DocumentFragment" node.
      @@@disDef:
        @@@@DISLang:value:
          @@@@@@: \#document-fragment
          @@@@@ContentType:
            DISCore:String
  @ReAttr:
    @@Name: nodeType
    @@Description:
      @@@lang:en
      @@@@: The type of this node.
    @@Get:
      @@@Type: 
        DOMMain:unsigned-short||ManakaiDOM|all
      @@@InCase:
        @@@@Label:
          <C::Node.DOCUMENT_FRAGMENT_NODE>
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The node is a <IF::DocumentFragment>.
      @@@disDef:
        @@@@DISLang:constValue: Node.DOCUMENT_FRAGMENT_NODE


  @Method:
     @@Name:  getFeature
     @@enDesc:
       Returns a specialized object that implements the
       specialized interfaces of the specified feature and version.
     @@ManakaiDOM:isRedefining:1
     @@ForCheck: ManakaiDOM|ForClass ManakaiDOM|DOM3
     @@Param:
        @@@Name:  feature
        @@@Type:  
          DOMMain:DOMString
        @@@actualType: ManakaiDOM|ManakaiDOMFeatureName
        @@@enDesc:
          The feature name to request.
        @@@InCase:
          @@@@Label:
            @@@@@lang:en
            @@@@@@: 
              Feature name preceded by a <CHAR::PLUS SIGN>
          @@@@enDesc:
            The <CHAR::PLUS SIGN> is ignored.
     @@Param:
        @@@Name:  version
        @@@Type:  
          DOMMain:DOMString
        @@@actualType: ManakaiDOM|ManakaiDOMFeatureVersion
        @@@enDesc:
          The feature version to request.
        @@@nullCase:
          @@@@enDesc:
            No specific version is requested.
     @@Return:
        @@@Type:  
          DOMMain:DOMObject
        @@@enDesc:
          An object implementing the specialized interfaces.
          Note that the specialized object may or may not
          implement the <IF::Node> interface.
        @@@nullCase:
          @@@@enDesc:
            There is no object available that implements
            the specialized interfaces.
        @@@PerlDef:
            $feature =~ s/^\+//;
            if ($Message::DOM::ClassFeature{ref $self}->{$feature}->{$version}) {
              ## This class
              $r = $self;
            } else {
              CLASS: for my $class (grep {
                $Message::DOM::ManakaiDOMDocumentFragment::CompatClass{$_}
              } keys %Message::DOM::ManakaiDOMDocumentFragment::CompatClass) {
                if ($Message::DOM::ClassFeature{$class}
                            ->{$feature}->{$version}) {
                  __CODE{getNodeRef::
                    $object => {$self->{<Q::TreeCore:node>}},
                    $ref => $r,
                    $class => $class,
                  }__;
                  last CLASS;
                }
              }
            }
##DocumentFragment

NodeTypeDef:
  @IFQName: Document
  @ClsQName: ManakaiDOMDocument
  
  @DISLang:role: DocumentRole

  @enDesc:
    A <IF::Document> object represents the entire HTML or XML document.
    It is conceptually the root of the document tree and
    corresponding to the <InfoItem::Document Information Item>
    in XML information set.

    Since nodes of type element, text, comment, etc. cannot exists
    outside the context of a <IF::Document>, the <IF::Document>
    interface also contains the factory methods needed to
    create these objects.

    {NOTE:: A <IF::DocumentType> node can be created by
            <M::DOMImplementation.createDocumentType> method.
            A <IF::Document> node can be created by 
            <M::DOMImplementation.createDocument> method.
    }

  @Attr:
     @@Name:  doctype
     @@Description:
       @@@lang:en
       @@@@:
         The "DocumentType" object associated with the "Document".
       \
         Note that even this attribute is defined as read-only, 
         the direct manipulations of child nodes (by the method "insertBefore" 
         for example) can change the document type.
     @@Level[list]:
       1
       2
       3
     @@SpecLevel[list]:
       1
       3
     @@Get:
        @@@Type:  
          DOMXML:DocumentType
        @@@Description:
          @@@@lang:en
          @@@@@:
            The "DocumentType" object for the "Document".
        @@@InCase:
          @@@@Value: 
            @@@@@is-null: 1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The document type declaration is omitted or it is an HTML 
              document.
            \
              Note: If it is an HTML document, the "doctype" attribute is 
              always "null" in DOM Level 1 and Level 2.  In DOM Level 3, 
              a "DocumentType" object may be returned even if the document 
              does not have explicit document type declaration.
        @@@PerlDef:
            for (@{$self->{<Q::TreeCore:node>}->{<Q::infoset:children>}}) {
              if ($_->{<Q::DOMCore:nodeType>} eq <Q::DOMCore:DocumentType>) {
                $r = <ClassM::ManakaiDOMNode.getNodeReference> ($_);
                last;
              } elsif ($_->{<Q::DOMCore:nodeType>} eq <Q::infoset:Element>) {
                last;
              }
            }
  @Attr:
     @@Name:  implementation
     @@Description:
       @@@lang:en
       @@@@:
         The "DOMImplementation" object that handles the "Document".
     @@Get:
        @@@Type:  DOMImplementation
        @@@disDef:
          @@@@GetProp:
            DOMCore:implementation
  @Attr:
     @@Name:  documentElement
     @@Description:
       @@@lang:en
       @@@@: The child node that is the document element of the document.
     @@Get:
        @@@Type:  Element
        @@@Description:
          @@@@lang:en
          @@@@@: The document element.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The document element not found.
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              The DOM specifications don't mention this case but for example 
              the DOMImplementation.createDocument (null, null, null) can 
              create a Document that does not have the document element.
        @@@PerlDef:
            for (@{$self->{<Q::TreeCore:node>}->{<Q::infoset:children>}}) {
              if ($_->{<Q::DOMCore:nodeType>} eq <Q::infoset:Element>) {
                $r = <ClassM::ManakaiDOMNode.getNodeReference> ($_);
                last;
              }
            }
  @Method:
     @@Name:  createElement
     @@Description:
       @@@lang:en
       @@@@:
         Create an element.
       \
         If there are known attributes with default values, 
         <IF::Attr> nodes representing them are automatically 
         created and attached to the element created.
     @@NSVersion:.createElementNS
     @@Param:
        @@@Name:  tagName
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            The name of the element type to instantiate.
          \
            The case-sensitivity depends on that of the markup language 
            in use.  If it is case-insensitive, the <P::tagName> is 
            mapped to the canonical form of that markup language 
            by the DOM implementation.
     @@Return:
        @@@Type:  Element
        @@@actualType: ManakaiDOMElement
        @@@Description:
          @@@@lang:en
          @@@@@:
            A newly created <IF::Element> object.
        @@@Exception:
          @@@@@:
            MDOMX:MDOM_BAD_NAME
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The <P::tagName> is not a legal SGML or XML Name.
        @@@PerlDef:
            my $docNode = $self->{<Q::TreeCore:node>};
            my $version = <Code::getDocumentXMLVersion:: $DOCOBJ = $docNode>;
            __CODE{DOMMain:ensureXMLName:: $INPUT => $tagName,
                                           $INPUT_PARAM_NAME => 'tagName',
                                           $XMLVERSION => $version}__;
            my $node = <ClassM::ManakaiDOMElement.newObject>;
            $node->{<Q::DOMCore:ownerDocument>} = $docNode;
            $node->{<Q::DOMCore:name>} = $tagName;
            $r = <ClassM::ManakaiDOMNode.getNodeReference> ($node);
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              TODO: <P::tagName> should be normalized to uppercases if HTML.
            \
              TODO: Default attribute should be implemented.
  @Method:
     @@Name:  createDocumentFragment
     @@Description:
       @@@lang:en
       @@@@:
         Create an empty <IF::DocumentFragment> object.
     @@Return:
        @@@Type:  DocumentFragment
        @@@Description:
          @@@@lang:en
          @@@@@:
            The new <IF::DocumentFragment> object.
        @@@PerlDef:
            my $docNode = $self->{<Q::TreeCore:node>};
            my $node = <ClassM::ManakaiDOMDocumentFragment.newObject>;
            $node->{<Q::DOMCore:ownerDocument>} = $docNode;
            $r = <ClassM::ManakaiDOMNode.getNodeReference> ($node);
    @@SpecLevel:1
    @@Level[list]:
      1
      2
      3
  @Method:
     @@Name:  createTextNode
     @@Description:
       @@@lang:en
       @@@@:
         Create a <IF::Text> node.
     @@Param:
        @@@Name:  data
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The data for the node.
     @@Return:
        @@@Type:  Text
        @@@Description:
          @@@@lang:en
          @@@@@:
            The new <IF::Text> object.
        @@@PerlDef:
            my $docNode = $self->{<Q::TreeCore:node>};
            my $node = <ClassM::ManakaiDOMText.newObject>;
            $node->{<Q::DOMCore:ownerDocument>} = $docNode;
            $node->{<Q::infoset:content>} = defined $data ? $data : '';
            $r = <ClassM::ManakaiDOMNode.getNodeReference> ($node);
    @@SpecLevel:1
    @@Level[list]:
      1
      2
      3
  @Method:
     @@Name:  createComment
     @@Description:
       @@@lang:en
       @@@@:
         Create a <IF::Comment> node.
     @@Param:
        @@@Name:  data
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The data for the node.
     @@Return:
        @@@Type:  Comment
        @@@Description:
          @@@@lang:en
          @@@@@:
            The new <IF::Comment> object.
        @@@PerlDef:
            my $docNode = $self->{<Q::TreeCore:node>};
            my $node = <ClassM::ManakaiDOMComment.newObject>;
            $node->{<Q::DOMCore:ownerDocument>} = $docNode;
            $node->{<Q::infoset:content>} = defined $data ? $data : '';
            $r = <ClassM::ManakaiDOMNode.getNodeReference> ($node);
    @@SpecLevel:1
    @@Level[list]:
      1
      2
      3
  @Method:
     @@Name:  createCDATASection
     @@Description:
       @@@lang:en
       @@@@:
         Create a <IF::DOMXML:CDATASection> node.
     @@Param:
        @@@Name:  data
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            The data for the <XML::CDATA> section.
     @@Return:
        @@@Type:  
          DOMXML:CDATASection
        @@@Description:
          @@@@lang:en
          @@@@@: 
            The newly created <IF::DOMXML:CDATASection> node.
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:NOT_SUPPORTED_ERR
          @@@@SubType:
            @@@@@QName:
              MDOMX:MDOM_DOC_NOSUPPORT_XML
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                This document does not support the <Feature::XML> feature. 
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              HTML-only DOM implementations must also implement this method. 
              The DOM Level 3 Core Specification should have changed 
              the description from <QUOTE::if this document is an HTML document> 
              to <QUOTE::if this document does not support the <Feature::XML> 
              feature> for consistency with other non-HTML methods.
        @@@PerlDef:
            my $docNode = $self->{<Q::TreeCore:node>};
            unless (<Code::DOMMain:docSupportsXMLFeature::
                              $DOCOBJ = $docNode>) {
              __EXCEPTION{
                MDOMX:MDOM_DOC_NOSUPPORT_XML::
              }__;
            }
            my $node = <ClassM::DOMXML:ManakaiDOMCDATASection.newObject>;
            $node->{<Q::DOMCore:ownerDocument>} = $docNode;
            $node->{<Q::infoset:content>} = defined $data ? $data : '';
            $r = <ClassM::ManakaiDOMNode.getNodeReference> ($node);
    @@SpecLevel:1
    @@Level[list]:
      1
      2
      3
  @Method:
     @@Name:  createProcessingInstruction
     @@Description:
       @@@lang:en
       @@@@:
         Create a <IF::DOMXML:ProcessingInstruction> node.
     @@Param:
        @@@Name:  target
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            The target name of the processing instruction to create.
        @@@ImplNote:
          @@@@lang:en
          @@@@@:
            This is an XML <CODE::Name>, not an XML Names <CODE::NCName>.
        @@@ImplNote:
          @@@@lang:en
          @@@@@:
            The XML Specifications prohibit target names 
            matching to <XML::xml> in any lower/upper-case. 
            The DOM Specifications does not.
     @@Param:
        @@@Name:  data
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            The data for the node.
     @@Return:
        @@@Type:  
          DOMXML:ProcessingInstruction
        @@@Description:
          @@@@lang:en
          @@@@@:
            The new <IF::DOMXML:ProcessingInstruction> object.
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:INVALID_CHARACTER_ERR
          @@@@SubType:
            @@@@@QName:
              MDOMX:MDOM_BAD_NAME
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <P::name> is not an XML <CODE::Name>.
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:NOT_SUPPORTED_ERR
          @@@@SubType:
            @@@@@QName:
              MDOMX:MDOM_DOC_NOSUPPORT_XML
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                This document does not support the <Feature::XML> feature.
        @@@PerlDef:
            my $docNode = $self->{<Q::TreeCore:node>};
            my $version = <Code::getDocumentXMLVersion::
                                    $DOCOBJ = $docNode>;
            unless (defined $version) {
              __EXCEPTION{
                MDOMX:MDOM_DOC_NOSUPPORT_XML::
              }__;
            }
            __CODE{DOMMain:ensureXMLName:: $INPUT => $target,
                                           $INPUT_PARAM_NAME => 'target',
                                           $XMLVERSION => $version}__;
            my $node = <ClassM::DOMXML:ManakaiDOMProcessingInstruction
                                               .newObject>;
            $node->{<Q::DOMCore:ownerDocument>} = $docNode;
            $node->{<Q::infoset:target>} = $target;
            $node->{<Q::infoset:content>} = defined $data ? $data : '';
            $r = <ClassM::ManakaiDOMNode.getNodeReference> ($node);
    @@SpecLevel:1
    @@Level[list]:
      1
      2
      3
  @Method:
     @@Name:  createAttribute
     @@Description:
       @@@lang:en
       @@@@:
         Create an <IF::Attr> node.
     @@NSVersion: .createAttributeNS
     @@Param:
        @@@Name:  name
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The name of the attribute.
        @@@ImplNote:
          @@@@lang:en
          @@@@@:
            There is no case-sensitivility consideration of the <P::name> 
            in the DOM Specifications.  Maybe attribute names are 
            lower-cased if it is an HTML document.
     @@Return:
        @@@Type:  Attr
        @@@Description:
          @@@@lang:en
          @@@@@:
            A new <IF::Attr> object.
        @@@ImplNote:
          @@@@lang:en
          @@@@@:
          <A::Node.nodeName> := <P::name>, <A::Node.localName> := <DOM::null>, 
          <A::Node.prefix> := <DOM::null>, <A::Node.namespaceURI> := <DOM::null>, 
          value := empty.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: INVALID_CHARACTER_ERR
          @@@@SubType:
            @@@@@QName:
              MDOMX:MDOM_BAD_NAME
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <P::name> is not a SGML or XML <CODE::Name>.
        @@@PerlDef:
            my $docNode = $self->{<Q::TreeCore:node>};
            my $version = <Code::getDocumentXMLVersion::
                                   $DOCOBJ = $docNode>;
            __CODE{DOMMain:ensureXMLName:: $INPUT => $name,
                                           $INPUT_PARAM_NAME => 'name',
                                           $XMLVERSION => $version}__;
            my $node = <ClassM::ManakaiDOMAttr.newObject>;
            $node->{<Q::DOMCore:ownerDocument>} = $docNode;
            $node->{<Q::DOMCore:name>} = $name;
            $r = <ClassM::ManakaiDOMNode.getNodeReference> ($node);
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              TODO: The name should be case-normalized by the definition 
              of the markup language in use.
  @Method:
     @@Name:  createEntityReference
     @@Description:
       @@@lang:en
       @@@@:
         Create an <IF::DOMXML:EntityReference> object.  If the entity referred 
         is known, the child list of the <IF::DOMXML:EntityReference> is 
         made the same as that of the corresponding <IF::DOMXML:Entity> node.
       \
         {NOTE:: If any descendant of the <IF::DOMXML:Entity> node has an 
         unbound namespace prefix, the corresponding descendant of 
         the <IF::DOMXML:EntityReference> node created is also unbound.
         }
     @@ImplNote:
       @@@lang:en
       @@@@:
         In this NOTEd case, that node might have <Q::infoset:prefix> 
         but will not have <Q::infoset:namespaceName>.
     @@NSVersion:\
     @@Param:
        @@@Name:  name
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            The name of the entity to refer.
        @@@ImplNote:
          @@@@lang:en
          @@@@@:
            This is an XML <CODE::Name>, not an XML Names <CODE::NCName>.
     @@Return:
        @@@Type:  
          DOMXML:EntityReference
        @@@Description:
          @@@@lang:en
          @@@@@:
            The new <IF::DOMXML:EntityReference> object.
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:INVALID_CHARACTER_ERR
          @@@@SubType:
            @@@@@QName:
              MDOMX:MDOM_BAD_NAME
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <P::name> is not an XML <CODE::Name>.
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:NOT_SUPPORTED_ERR
          @@@@SubType:
            @@@@@QName:
              MDOMX:MDOM_DOC_NOSUPPORT_XML
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                This document does not support the <Feature::XML> feature.
        @@@PerlDef:
            my $docNode = $self->{<Q::TreeCore:node>};
            my $version = <Code::getDocumentXMLVersion::
                                    $DOCOBJ = $docNode>;
            unless (defined $version) {
              __EXCEPTION{
                MDOMX:MDOM_DOC_NOSUPPORT_XML::
              }__;
            }
            __CODE{DOMMain:ensureXMLName::
                        $INPUT => $name, $XMLVERSION => $version,
                        $INPUT_PARAM_NAME => 'name'}__;
            my $node = <ClassM::DOMXML:ManakaiDOMEntityReference.newObject>;
            $node->{<Q::DOMCore:ownerDocument>} = $docNode;
            $node->{<Q::DOMCore:name>} = $name;
            #$node->{< Q::??:expanded>} = false;
            $r = <ClassM::ManakaiDOMNode.getNodeReference> ($node);
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              TODO: Expand the reference.
    @@L1:
    @@SpecLevel:1
    @@Level[list]:
      1
      2
      3
  @Method:
     @@Name:  getElementsByTagName
     @@Description:
       @@@lang:en
       @@@@:
         Return a <IF::NodeList> of all the <IF::Element> in document 
         order with a given element type name and are contained in the document.
         \
         {NOTE:: <IF::Element> nodes also have the 
                 <M::Element.getElementsByTagName> method.
         \
         }
     @@ImplNote:
       @@@lang:en
       @@@@:
         Does <QUOTE::contained> mean that an <IF::Element> node 
         which is not a descendant of the <IF::Document> does not match?
       \
         The DOM Level 2 Specification specifies as <QUOTE::pre-order 
         traversal>.  The DOM Level 3 Specifies it by 
         <QUOTE::in document order> and this makes the ambigiousness.
       \
         Should <IF::Element> nodes in <IF::DOMXML:Entity> nodes be matched?
     @@Param:
        @@@Name:  tagname
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            The name of the element type to match on.
          \
            The case-sensitivility depends on the markup language in use.
        @@@InCase:
          @@@@Value:*
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Match all element type names.
     @@Return:
        @@@Type:NodeList
        @@@actualType:  
          ManakaiDOMCore:ManakaiDOMGetElementsNodeList
        @@@Description:
          @@@@lang:en
          @@@@@:
            A new <IF::NodeList> object containing all the matched 
            <IF::Element> objects.
        @@@PerlDef:
            my $node = $self->{<Q::TreeCore:node>};
            my $chk;
            if (defined $tagname and $tagname eq '*') {
              $chk = sub { 1 };
            } else {
              my $name = "$tagname";
              $chk = sub {
                my ($self) = @_;
                if (defined $self->{<Q::infoset:localName>}) {
                  if (defined $self->{<Q::infoset:prefix>}) {
                    return ($self->{<Q::infoset:prefix>} . ':' .
                            $self->{<Q::infoset:localName>} eq $name)
                               ? true : false;
                  } else {
                    return ($self->{<Q::infoset:localName>} eq $name)
                               ? true : false;
                  }
                } else {
                  return ($self->{<Q::DOMCore:name>} eq $name)
                               ? true : false;
                }
              };
            }
            __CODE{getNodeRef::
              $object => $node, $ref => $r,
              $class => {
                <ClassName::ManakaiDOMCore:ManakaiDOMGetElementsNodeList>
              },
            }__;
            $r->{<Q::ManakaiDOMCore:nodeMatch>} = $chk;
    @@NSVersion:.getElementsByTagNameNS
  @Method:
     @@Name:  importNode
     @@Description:
       @@@lang:en
       @@@@:
         Import a node from another document to this document, 
         without altering or removing the source node from 
         the original document (i.e. create a new copy of 
         the source node in this document).
     @@ImplNote:
       @@@lang:en
       @@@@:
         Copied: <A::Node.nodeName>, <A::Node.nodeType>, <A::Node.prefix>, 
         <A::Node.localName>, <A::Node.namespaceURI>, <A::Entity.publicId>, 
         <A::Entity.systemId>, <A::Entity.notationName>, 
         <A::Notation.publicId>, <A::Notation.systemId>, 
         <A::ProcessingInstruction.target>, <A::ProcessingInstruction.data>, 
         <A::CharacterData.data>, <A::CharacterData.length>.
       \
         User data is not carried over.  However, if any 
         <IF::UserDataHandler>s has specified, these handlers will 
         be called with the appropriate parameters before this method 
         returns.
       \
         <A::Node.parentNode> := <DOM::null>.
         <A::Attr.ownerElement> := <DOM::null>. 
         <A::Attr.specified> := <DOM::true>.
         Specified attribute nodes attached to the <IF::Element> node 
         are imported.  Default attributes are created if exists.
     @@Param:
        @@@Name:  importedNode
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@:
            The node to import.
            \
            Note that <IF::Document> or <IF::DOMXML:DocumentType> nodes cannot 
            be imported.
     @@Param:
        @@@Name:  deep
        @@@Type:  DOMMain|boolean||ManakaiDOM|all
        @@@Description:
          @@@@lang:en
          @@@@@:
            Whether the subtree under the <P::importedNode> 
            is recursively imported or not.
            \
            This parameter has no effect on <IF::Attr>,
            <IF::DOMXML:EntityReference>, 
            <IF::DOMXML:Notation>, <IF::DOMXML:ProcessingInstruction>,
            <IF::Text>, 
            <IF::DOMXML:CDATASection> and <IF::Comment> nodes.
            The descendants of 
            the <IF::Attr> node are 
            always imported.  The descendants of the
            <IF::DOMXML:EntityReference> 
            node are always not imported.
        @@@InCase:
          @@@@Value:true
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The descendants are recursively imported if the 
              <P::importedNode> is of <IF::DocumentFragment>, <IF::Element> or 
              <IF::DOMXML:Entity>.
        @@@InCase:
          @@@@Value:false
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Import only the node itself.
     @@Return:
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@:
            The imported node.
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:NOT_SUPPORTED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The type of node being imported is not supported.
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              Maybe, if this document is not <Feature::XML> and 
              the node type is either <IF::DOMXML:ProcessingInstruction>, 
              <IF::DOMXML:Notation>, <IF::DOMXML:EntityReference>,
              <IF::DOMXML:Entity> or 
              <IF::DOMXML:CDATASection>.  And if namespaced nodes are imported?
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:INVALID_CHARACTER_ERR
          @@@@SubType:
            @@@@@QName:
              MDOMX:MDOM_BAD_NAME
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                One of the imported names is not a SGML or XML <CODE::Name>.
     @@L2:
     @@Level[list]:  2
     @@SpecLevel:2
     @@For:
       ManakaiDOM:DOM2
  @Method:
     @@Name:  createElementNS
     @@Description:
       @@@lang:en
       @@@@:
         Create an element.
       \
         If there are known attributes with default values, 
         <IF::Attr> nodes representing them are automatically 
         created and attached to the element created.
     @@NoNSVersion:.createElement
     @@Param:
        @@@Name:  namespaceURI
        @@@Type:
          DOMMain:DOMString
        @@@actualType:
          ManakaiDOM:ManakaiDOMNamespaceURI
        @@@Description:
          @@@@lang:en
          @@@@@:
            The namespace URI of the element to create.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The element to create will have no namespace.
     @@Param:
        @@@Name:  qualifiedName
        @@@Type:  
          DOMMain:DOMString
        @@@actualType:
          @@@@@:
            DOMMain:ManakaiDOMXMLQName
          @@@@ManakaiDOM:noInputNormalize:1
        @@@Description:
          @@@@lang:en
          @@@@@:
            The qualified name of the type of the element to create.
     @@Return:
        @@@Type:  Element
        @@@actualType: ManakaiDOMElement
        @@@Description:
          @@@@lang:en
          @@@@@:
            A new <IF::Element> object.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: INVALID_CHARACTER_ERR
          @@@@SubType:
            @@@@@QName:
              MDOMX:MDOM_BAD_NAME
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <P::qualifiedName> is not an XML <CODE::Name>.
            @@@@@SpecLevel:2
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NAMESPACE_ERR
          @@@@SubType:
            @@@@@QName:
              MDOMX:MDOM_NS_MALFORMED_QNAME
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@: 
                The <P::qualifiedName> is malformed as a qualified name.
            @@@@@SpecLevel:2
          @@@@SubType:
            @@@@@QName:
              MDOMX:MDOM_NS_PREFIX_WITH_NULL_URI
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <P::qualifiedName> has a prefix and the
                <P::namespaceURI> is <DOM::null>.
            @@@@@SpecLevel:2
          @@@@SubType:
            @@@@@QName:
              MDOMX:MDOM_NS_XML_WITH_OTHER_URI
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <P::qualifiedName> has a prefix that is <CODE::xml> and the
                <P::namespaceURI> is different from
                <URI::http://www.w3.org/XML/1998/namespace>.
            @@@@@SpecLevel:2
          @@@@SubType:
            @@@@@QName:
              MDOMX:MDOM_NS_XMLNS_WITH_OTHER_URI
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <P::qualifiedName> has a prefix that is <XML::xmlns> and
                the <P::namespaceURI> is different from the
                <URI::http://www.w3.org/2000/xmlns>.
            @@@@@SpecLevel:3
          @@@@SubType:
            @@@@@QName:
              MDOMX:MDOM_NS_XMLNSQ_WITH_OTHER_URI
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <P::qualifiedName> is <XA::xmlns> and
                the <P::namespaceURI> is different from the
                <URI::http://www.w3.org/2000/xmlns>.
            @@@@@SpecLevel:3
          @@@@SubType:
            @@@@@QName:
              MDOMX:MDOM_NS_OTHER_WITH_XML_URI
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <P::namespaceURI> is 
                <URI::http://www.w3.org/XML/1998/namespace> and the 
                prefix of the <P::qualifiedName> is different from 
                <XML::xml>.
            @@@@@SpecLevel[list]:
          @@@@SubType:
            @@@@@QName:
              MDOMX:MDOM_NS_OTHER_WITH_XMLNS_URI
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <P::namespaceURI> is <URI::http://www.w3.org/2000/xmlns> and 
                neither the <P::qualifiedName> nor its prefix is <XML::xmlns>.
            @@@@@SpecLevel:3
          @@@@SubType:
            @@@@@QName:
              MDOMX:MDOM_NS_XMLNS_XMLNS
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <P::qualifiedName> is <XA::xmlns:xmlns>.
            @@@@@SpecLevel[list]:
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:NOT_SUPPORTED_ERR
          @@@@SubType:
            @@@@@QName:
              MDOMX:MDOM_DOC_NOSUPPORT_XML
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                This document does not support the <Feature::XML> 
                feature.
        @@@PerlDef:
          @@@@For:
            ManakaiDOM:DOMXMLFeature
          @@@@@:
            my $docNode = $self->{<Q::TreeCore:node>};
            my $version = <Code::getDocumentXMLVersion:: $DOCOBJ = $docNode>;
            unless (defined $version) {
              __EXCEPTION{MDOMX:MDOM_DOC_NOSUPPORT_XMLNS}__;
            }
            __CODE{DOMMain:ensureXMLQName::
                     $INPUT = $qualifiedName, 
                     $INPUT_PARAM_NAME = 'qualifiedName',
                     $XMLVERSION = $version,
            }__;
            my ($prefix, $lname) = split /:/, $qualifiedName, 2;
            ($prefix, $lname) = (null, $prefix) unless defined $lname;
            __CODE{DOMMain:checkXMLNamesQName::
                     $PREFIX => $prefix, $NSURI => $namespaceURI,
                     $LNAME => $lname,
            }__;

            my $node = <ClassM::ManakaiDOMElement.newObject>;
            $node->{<Q::DOMCore:ownerDocument>} = $docNode;
            $node->{<Q::infoset:namespaceName>} = $namespaceURI;
            $node->{<Q::infoset:prefix>} = $prefix;
            $node->{<Q::infoset:localName>} = $lname;
            $r = <ClassM::ManakaiDOMNode.getNodeReference> ($node);
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              TODO: Default attribute should be implemented.
        @@@disDef:
          @@@@ForCheck:
            !ManakaiDOM:DOMXMLFeature
          @@@@DOMMain:raiseException:
            MDOMX:MDOM_IMPL_NOSUPPORT_XMLNS
    @@L2:
    @@SpecLevel:2
    @@Level[list]:
      2
      3
    @@For:
      ManakaiDOM:DOM2
  @Method:
     @@Name:  createAttributeNS
     @@Description:
       @@@lang:en
       @@@@:
         Create an attribute of the given qualified name and namespace URI.
     @@NoNSVersion: .createAttribute
     @@Param:
        @@@Name:  namespaceURI
        @@@Type:
          DOMMain:DOMString
        @@@actualType:
          ManakaiDOM:ManakaiDOMNamespaceURI
        @@@Description:
          @@@@lang:en
          @@@@@: The namespace URI of the attribute to create.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The attribute has no namespace.
     @@Param:
        @@@Name:  qualifiedName
        @@@Type:  
          DOMMain:DOMString
        @@@actualType:
          @@@@@:
            DOMMain:ManakaiDOMXMLQName
          @@@@ManakaiDOM:noInputNormalize:1
        @@@Description:
          @@@@lang:en
          @@@@@: The qualified name of the attribute to create.
     @@Return:
        @@@Type:  Attr
        @@@actualType: ManakaiDOMAttr
        @@@Description:
          @@@@lang:en
          @@@@@: A new attribute object.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: INVALID_CHARACTER_ERR
          @@@@SubType:
            @@@@@QName:
              MDOMX:MDOM_BAD_NAME
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <P::qualifiedName> is not an XML <CODE::Name>.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NAMESPACE_ERR
          @@@@SubType:
            @@@@@QName:
              MDOMX:MDOM_NS_MALFORMED_QNAME
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@: 
                The <P::qualifiedName> is malformed as a qualified name.
            @@@@@SpecLevel:2
          @@@@SubType:
            @@@@@QName:
              MDOMX:MDOM_NS_PREFIX_WITH_NULL_URI
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <P::qualifiedName> has a prefix and the
                <P::namespaceURI> is <DOM::null>.
            @@@@@SpecLevel:2
          @@@@SubType:
            @@@@@QName:
              MDOMX:MDOM_NS_XML_WITH_OTHER_URI
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <P::qualifiedName> has a prefix that is <CODE::xml> and the
                <P::namespaceURI> is different from
                <URI::http://www.w3.org/XML/1998/namespace>.
            @@@@@SpecLevel:2
          @@@@SubType:
            @@@@@QName:
              MDOMX:MDOM_NS_XMLNS_WITH_OTHER_URI
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <P::qualifiedName> has a prefix that is <XML::xmlns> and
                the <P::namespaceURI> is different from the
                <URI::http://www.w3.org/2000/xmlns>.
            @@@@@SpecLevel:3
          @@@@SubType:
            @@@@@QName:
              MDOMX:MDOM_NS_XMLNSQ_WITH_OTHER_URI
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <P::qualifiedName> is <XA::xmlns> and
                the <P::namespaceURI> is different from the
                <URI::http://www.w3.org/2000/xmlns>.
            @@@@@SpecLevel:2
          @@@@SubType:
            @@@@@QName:
              MDOMX:MDOM_NS_OTHER_WITH_XML_URI
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <P::namespaceURI> is 
                <URI::http://www.w3.org/XML/1998/namespace> and the 
                prefix of the <P::qualifiedName> is different from 
                <XML::xml>.
            @@@@@SpecLevel[list]:
          @@@@SubType:
            @@@@@QName:
              MDOMX:MDOM_NS_OTHER_WITH_XMLNS_URI
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <P::namespaceURI> is <URI::http://www.w3.org/2000/xmlns> and 
                neither the <P::qualifiedName> nor its prefix is <XML::xmlns>.
            @@@@@SpecLevel:3
          @@@@SubType:
            @@@@@QName:
              MDOMX:MDOM_NS_XMLNS_XMLNS
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <P::qualifiedName> is <XA::xmlns:xmlns>.
            @@@@@SpecLevel[list]:
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@: Is no-prefix with URI is OK?
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:NOT_SUPPORTED_ERR
          @@@@SubType:
            @@@@@QName:
              MDOMX:MDOM_DOC_NOSUPPORT_XML
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                This document does not support the <Feature::XML> 
                feature.
        @@@PerlDef:
          @@@@For:
            ManakaiDOM:DOMXMLFeature
          @@@@@:
            my $docNode = $self->{<Q::TreeCore:node>};
            my $version = <Code::getDocumentXMLVersion:: $DOCOBJ = $docNode>;
            unless (defined $version) {
              __EXCEPTION{MDOMX:MDOM_DOC_NOSUPPORT_XMLNS}__;
            }
            __CODE{DOMMain:ensureXMLQName::
                     $INPUT = $qualifiedName, 
                     $INPUT_PARAM_NAME = 'qualifiedName',
                     $XMLVERSION = $version,
            }__;
            my ($prefix, $lname) = split /:/, $qualifiedName, 2;
            ($prefix, $lname) = (null, $prefix) unless defined $lname;
            __CODE{DOMMain:checkXMLNamesQName::
                     $PREFIX => $prefix, $NSURI => $namespaceURI,
                     $LNAME => $lname,
            }__;
            
            my $node = <ClassM::ManakaiDOMAttr.newObject>;
            $node->{<Q::DOMCore:ownerDocument>} = $docNode;
            $node->{<Q::infoset:localName>} = $lname;
            $node->{<Q::infoset:namespaceName>} = $namespaceURI;
            $node->{<Q::infoset:prefix>} = $prefix;
            $node->{<Q::infoset:specified>} = true;
            $r = <ClassM::ManakaiDOMNode.getNodeReference> ($node);
        @@@disDef:
          @@@@ForCheck:
            !ManakaiDOM:DOMXMLFeature
          @@@@DOMMain:raiseException:
            MDOMX:MDOM_IMPL_NOSUPPORT_XMLNS
    @@SpecLevel:2
    @@Level[list]:
      2
      3
    @@For:
      ManakaiDOM:DOM2
  @Method:
     @@Name:  getElementsByTagNameNS
     @@Description:
        @@@lang:en
        @@@@:
          Return a <IF::NodeList> of all the <IF::Element> nodes 
          with a given local name and namespace URI in document order.
          \
          {NOTE:: <IF::Element> nodes also have the 
                  <M::Element.getElementsByTagNameNS> method.
          \
          }
     @@Param:
        @@@Name:  namespaceURI
        @@@Type:
          DOMMain:DOMString
        @@@actualType:
          ManakaiDOM:ManakaiDOMNamespaceURI
        @@@Description:
          @@@@lang:en
          @@@@@:
            The namespace URI of the elements to match on.
        @@@InCase:
          @@@@Value:*
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Match all namespaces.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
     @@Param:
        @@@Name:  localName
        @@@Type:  
          DOMMain:DOMString
        @@@actualType:
          @@@@@:
            DOMMain:ManakaiDOMXMLLocalName
          @@@@ManakaiDOM:noInputNormalize:1
        @@@Description:
          @@@@lang:en
          @@@@@:
            The local name of the elements to match on.
        @@@InCase:
          @@@@Value:*
          @@@@Description:
            @@@@@lang:en
            @@@@@@: Match all local names.
     @@Return:
        @@@Type:NodeList
        @@@actualType:
          ManakaiDOMCore:ManakaiDOMGetElementsNodeList
        @@@Description:
          @@@@lang:en
          @@@@@:
            A new <IF::NodeList> object containing all the 
            matched <IF::Element> objects.
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:NOT_SUPPORTED_ERR
          @@@@SubType:
            @@@@@QName:
              MDOMX:MDOM_IMPL_NOSUPPORT_XML
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The DOM implementation does not support the <Feature::XML> 
                feature and the language exposed through the 
                <IF::Document> is not support XML Namespaces.
          @@@@SpecLevel:
        @@@ImplNote:
          @@@@lang:en
          @@@@@:
            For <M::Element.getElementsByTagNameNS>, DOM Level 2 allows 
            HTML-only DOM implementations not to implement that method 
            and its Errata and DOM Level 3 say to raise 
            <X::DOMException.NOT_SUPPORTED_ERROR> if it is called.  
            <M::Document.getElementsByTagNameNS> should also raise the 
            exception, shouldn't it?
        @@@PerlDef:
          @@@@For:
            ManakaiDOM:DOMXMLFeature
          @@@@@:
            my $node = $self->{<Q::TreeCore:node>};
            my $chk;
            if (defined $namespaceURI) {
              if ($namespaceURI eq '*') {
                if (defined $localName and $localName eq '*') {
                  $chk = sub {
                    my ($self) = @_;
                    return defined $self->{<Q::infoset:localName>}
                             ? true : false;
                      ## Any element node with local name
                  };
                } else {
                  $localName = "$localName";
                  $chk = sub {
                    my ($self) = @_;
                    return
                        (defined $self->{<Q::infoset:localName>} and
                         $self->{<Q::infoset:localName>} eq $localName)
                           ? true : false;
                  };
                }
              } else { ## Non-n u l l namespace URI
                $namespaceURI = "$namespaceURI";
                if (defined $localName and $localName eq '*') {
                  $chk = sub {
                    my ($self) = @_;
                    return (defined $self->{<Q::infoset:namespaceName>} and
                            $self->{<Q::infoset:namespaceName>} eq $namespaceURI)
                              ? true : false;
                  };
                } else {
                  $localName = "$localName";
                  $chk = sub {
                    my ($self) = @_;
                    return
                        (defined $self->{<Q::infoset:localName>} and
                         defined $self->{<Q::infoset:namespaceName>} and
                         $self->{<Q::infoset:namespaceName>} eq $namespaceURI and
                         $self->{<Q::infoset:localName>} eq $localName)
                           ? true : false;
                  };
                }
              }
            } else { ## Null namespace
              if (defined $localName and $localName eq '*') {
                $chk = sub {
                  my ($self) = @_;
                  return (defined $self->{<Q::infoset:localName>} and
                          not defined $self->{<Q::infoset:namespaceName>})
                            ? true : false;
                    ## Any element node with local name but not namespace URI
                };
              } else {
                $localName = "$localName";
                $chk = sub {
                  my ($self) = @_;
                  return
                      (defined $self->{<Q::infoset:localName>} and
                       not defined $self->{<Q::infoset:namespaceName>} and
                       $self->{<Q::infoset:localName>} eq $localName)
                         ? true : false;
                };
              }
            }
            __CODE{getNodeRef::
              $object => $node, $ref => $r,
              $class => {
                <ClassName::ManakaiDOMCore:ManakaiDOMGetElementsNodeList>
              },
            }__;
            $r->{<Q::ManakaiDOMCore:nodeMatch>} = $chk;
        @@@disDef:
          @@@@ForCheck:
            !ManakaiDOM:DOMXMLFeature
          @@@@DOMMain:raiseException:
            MDOMX:MDOM_IMPL_NOSUPPORT_XMLNS
     @@Level[list]:  
       2
       3
     @@SpecLevel:2
     @@For:
       ManakaiDOM:DOM2
     @@NoNSVersion:.getElementsByTagName
  @Method:
     @@Name:  getElementById
     @@Description:
       @@@lang:en
       @@@@:
         Return the <IF::Element> that has an <SGML::ID> attribute 
         with the given value.
       \
         If more than one element has an <SGML::ID> attribute 
         with that value, what is returned is undefined.
     @@ImplNote:
       @@@lang:en
       @@@@:
         DOM implementations are expected to use the <A::Attr.isId> 
         to detect an <SGML::ID> attribute.
       \
         <XML::ID> ATTRIBUTES, not <XML::ID> ELEMENTS.
       \
         Can an <IF::Element> that is not a descendant of the <IF::Document> 
         be returned?
     @@Param:
        @@@Name:  elementId
        @@@Type:  
          DOMMain:DOMString
        @@@actualType:
          @@@@@:
            DOMMain:ManakaiDOMXMLName
          @@@@ManakaiDOM:noInputNormalize:1
        @@@Description:
          @@@@lang:en
          @@@@@:
            The unique identifier for an element.
     @@Level[list]:  2
     @@SpecLevel:2
     @@For:
       ManakaiDOM:DOM2
     @@ImplNote:
       @@@lang:en
       @@@@:
         This method was first defined in the interface <IF::HTMLDocument> 
         in the DOM Level 1.
     @@Return:
        @@@Type:  Element
        @@@actualType: ManakaiDOMElement
        @@@Description:
          @@@@lang:en
          @@@@@:
            The matching element.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              No element with the specified <SGML::ID> exists.
       @@@PerlDef:
         my @nodeo = (@{$self->{<Q::TreeCore:node>}->{<Q::infoset:children>}});
         NODES: while (my $nodeo = shift @nodeo) {
           next unless $nodeo->{<Q::DOMCore:nodeType>} eq <Q::infoset:Element>;
           for my $attro (map {values %$_}
                          values %{$nodeo->{<Q::infoset:attributes>}}) {
             my $attr;
             __CODE{ManakaiNode:getWeakReference
                    ||ManakaiDOM:Perl::
                      $object => $attro, $ref => $attr,
                      $class => {<ClassName::ManakaiDOMAttr>},
             }__;
             if ($attr-><AG::ManakaiDOMAttr.isId> and
                 $attr-><AG::ManakaiDOMAttr.value> eq $elementId) {
               $r = <ClassM::ManakaiDOMNode.getNodeReference> ($nodeo);
               last NODES;
             }
           }
           push @nodeo, @{$nodeo->{<Q::infoset:children>}};
         }
  @Attr:
     @@Name:  inputEncoding
     @@Description:
       @@@lang:en
       @@@@:
         The encoding used for this document at the time of 
         the parsing.
       \
         This attribute is corresponding to the [character encoding scheme] 
         property of the document infomation item.
     @@ImplNote:
        @@@lang:en
        @@@@:
          It is unclear what type of values are permitted. 
          IANA-registered charset names? XML encoding declaration 
          names?  Or, any names passed from the upper-level protocols?
     @@Get:
        @@@Type:  
          DOMMain:DOMString
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The input encoding is not known.
        @@@disDef:
          @@@@GetProp:
            infoset:characterEncodingScheme
     @@Level[list]:  3
     @@SpecLevel:3
     @@For:
       ManakaiDOM:DOM3
  @Attr:
     @@Name:  xmlEncoding
     @@Description:
       @@@lang:en
       @@@@:
         The value of the encoding declaration in the XML declaration 
         of the document.
     @@ImplNote:
       @@@lang:en
       @@@@:
         This attribute is NOT equal to the [character encoding scheme] 
         property of the document information item of the Infoset.
     @@Get:
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The encoding.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The encoding is not specified or not known.
        @@@disDef:
          @@@@GetProp:
            DOMCore:xmlEncoding
     @@Level[list]:  3
     @@SpecLevel:3
     @@For:
       ManakaiDOM:DOM3
  @Attr:
     @@Name:  xmlStandalone
     @@Description:
       @@@lang:en
       @@@@: 
         Whether the document is standalone or not.
       \
         This attribute is corresponding to the standalone declaration 
         in the XML declaration and the [standalone] property of the 
         document information item of the XML Infoset.
     @@ImplNote:
       @@@lang:en
       @@@@: Default false.
     @@Get:
        @@@Type:  
          DOMMain:boolean||ManakaiDOM|all
        @@@disDef:
          @@@@GetProp:
            infoset:standalone
     @@Set:
        @@@Type:  
          DOMMain:boolean||ManakaiDOM|all
        @@@Description:
          @@@@lang:en
          @@@@@: Whether standalone or not.
        @@@InCase:
          @@@@Value: true
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Standalone "yes".  Note that no verification is done when 
              setting the value.  DOM applications should use 
              the method "normalizeDocument" with the "validate" parameter 
              to verify whether the value match the Validity Constraint.
        @@@InCase:
          @@@@Value: false
          @@@@Description:
            @@@@@lang:en
            @@@@@@: Standalone "no".
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:NOT_SUPPORTED_ERR
          @@@@SubType:
            @@@@@QName:
              MDOMX:MDOM_DOC_NOSUPPORT_XML
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The current document does not support the <Feature::XML> 
                feature.
        @@@disDef:
          @@@@SetProp:
            infoset:standalone
        @@@ImplNote:
          @@@@lang:en
          @@@@@:
            Isn't <X::DOMException.NO_MODIFICATION_ALLOWED_ERR> raised?
            (Since DOM Level 1-3 does not have read-only <IF::Document> node?)
     @@Level[list]:  3
     @@SpecLevel:3
     @@For:
       ManakaiDOM:DOM3
  @Attr:
     @@Name:  xmlVersion
     @@Description:
       @@@lang:en
       @@@@:
         The version number of the document.
      \
         This attribute is corresponding to the version declaration in the 
         XML declaration and [version] property of the document information 
         item of the XML Infoset.
     @@Get:
        @@@Type:  
          DOMMain:DOMString
        @@@InCase:
          @@@@Value: 1.0
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The XML version is specified as XML 1.0 or the XML document 
              has no version declaration.
        @@@InCase:
          @@@@Value: 1.1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The XML version is specified as XML 1.1.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The document does not support the "XML" feature.
        @@@disDef:
          @@@@GetProp:
            infoset:version
     @@Set:
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            The XML version number of the document.  Note that 
            changing this attribute will affect methods that 
            check for invalid characters in XML "Name"s.  DOM 
            application should invoke the method "normalizeDocument" in 
            order to check for invalid characters in the "Node"s that 
            are already part of the document.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NOT_SUPPORTED_ERR
        @@@PerlDef:
            my $node = $self->{<Q::TreeCore:node>};
            if (defined $node->{<Q::DOMCore:hasFeature>}->{XML}) {
              if ($given and
                  ($given eq '1.0' or $given eq '1.1')) {
                $node->{<Q::infoset:version>} = $given;
              } else {
                __EXCEPTION{
                  MDOMX:MDOM_IMPL_NOSUPPORT_XMLVER::
                    infoset:version => {$given},
                }__;
              }
            } else {
              __EXCEPTION{
                MDOMX:MDOM_DOC_NOSUPPORT_XML::
              }__;
            }
     @@Level[list]:  3
     @@SpecLevel:3
     @@For:
       ManakaiDOM:DOM3
  @Attr:
     @@Name:  strictErrorChecking
     @@Description:
       @@@lang:en
       @@@@:
         Whether error checking is enforced or not.
     @@Get:
        @@@Type:  
          DOMMain:boolean||ManakaiDOM|all
        @@@disDef:
          @@@@GetProp:
            DOMCore:strictErrorChecking
     @@Set:
        @@@Type:  
          DOMMain:boolean||ManakaiDOM|all
        @@@Description:
          @@@@lang:en
          @@@@@: Whether error checking is enforced or not.
        @@@InCase:
          @@@@Value: false
          @@@@@: 
            The implementation is free to not every possible error 
            case normally defined on DOM operations, and not raise any 
            "DOMException" on DOM operations or report error 
            while using method "normalizeDocument".  In case of error, 
            the behavior is undefined.
        @@@disDef:
          @@@@SetProp:
            DOMCore:strictErrorChecking
     @@Level[list]:  3
     @@SpecLevel:3
     @@For:
       ManakaiDOM:DOM3
     @@ImplNote:
       @@@lang:en
       @@@@: This attribute is "true" by default.
  @Attr:
     @@Name:  documentURI
     @@Description:
       @@@lang:en
       @@@@: The location of the document.
     @@Level[list]:  3
     @@SpecLevel:3
     @@For:
       ManakaiDOM:DOM3
     @@Get:
        @@@Type:
          ManakaiDOM:ManakaiDOMURI
        @@@Description:
          @@@@lang:en
          @@@@@: The location of the document.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The location is undefined or the "Document" was created using 
              the method "createDocument".
        @@@disDef:
          @@@@GetProp:
            DOMCore:documentURI
     @@Set:
        @@@Type:
          ManakaiDOM:ManakaiDOMURI
        @@@Description:
          @@@@lang:en
          @@@@@: 
            The location of the document.  Note that no lexical checking is 
            performed.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The location is undefined.
        @@@disDef:
          @@@@SetProp:
            DOMCore:documentURI
  @Method:
     @@Name:  adoptNode
     @@Param:
        @@@Name:  source
        @@@Type:  Node
     @@Return:
        @@@Type:  Node
        @@@actualType: ManakaiDOMNode
        @@@Exception[list]:  DOMException
     @@Level[list]:  3
     @@SpecLevel:3
     @@For:
       ManakaiDOM:DOM3
  @Attr:
     @@Name:  domConfig
     @@Description:
       @@@lang:en
       @@@@: The configuration used when "normalizeDocument" is invoked.
     @@Get:
        @@@Type:  DOMConfiguration
        @@@Description:
          @@@@lang:en
          @@@@@: The DOM configuration object.
        @@@disDef:
          @@@@GetProp:
            DOMCore:domConfig
     @@For:
       ManakaiDOM:DOM3
     @@Level[list]:  3
     @@SpecLevel:3
     @@For:
       ManakaiDOM:DOM3
  @Method:
     @@Name:  normalizeDocument
     @@Description:
       @@@lang:en
       @@@@:
         Act as if the document was going through a save and 
         load cycle, putting the document in a "normal" form.
       \
         - Update the replacement tree of <IF::DOMXML:EntityReference> nodes.
       \
         - Normalize <IF::Text> nodes, as the method <M::Node.normalize> does.
       \
         - Other normalization specified by the <A::Document.domConfig>.
       \
         Mutation events, when supported, are generated to reflect  
         the changes occuring on the document.
       \
         If errors occur, such as an attempt to update a read-only 
         node or a <A::Node.nodeName> contains an invalid character, 
         (fatal and non-fatal) errors and warnings will be reported using 
         the <IF::DOMErrorHandler> object associated with the 
         <DOM::error-handler> parameter.
     @@Return:
     @@Level[list]:  3
     @@SpecLevel:3
     @@For:
       ManakaiDOM:DOM3
  @Method:
     @@Name:  renameNode
     @@Description:
       @@@lang:en
       @@@@:
         Rename an <IF::Element> or <IF::Attr> node. 
      \
         When possible, this simply changes the name of the 
         given node.  Otherwise, this creates a new node 
         with the specified name and replaces the existing node 
         with the new node.
     @@DOMMain:isNamespaceAware:1
     @@ImplNote:
       @@@lang:en
       @@@@:
         Non-simple way:
       \
         = Create a node.
       \
         = Any registered event listener is registered on the new node. 
       \
         = Any user data is removed from the old node.
       \
         = The old node is removed from its parent if any.
       \
         = The children are moved to the new node.
       \
         = The specified attributes are moved to the new node.
       \
         = The new node is inserted at the position the old node 
           used to have in its parent's child nodes list.
       \
         = The user data is attached to the new node.
       \
         Default attributes from the DTD are updated according to 
         the new element type name.  The implementation may 
         update from other schemas.
       \ 
         <IF::Attr> attached to an <IF::Element> is first removed from 
         the <IF::Element>.  Then either modifying the existing node 
         or creating a new node and put is back.
       \
         A user data event <DOM::NODE_RENAMED> is fired and if 
         the implementation supports the <Feature::MutationNameEvents>, 
         each mutation operation involved fires the appropriate event 
         and in the end 
         <Q::ev:DOMElementNameChanged> or <Q::ev:DOMAttributeNameChanged> 
         is fired.
     @@Param:
        @@@Name:  n
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@:
            The node to rename.
     @@Param:
        @@@Name:  namespaceURI
        @@@Type:
          ManakaiDOM:ManakaiDOMNamespaceURI
        @@@Description:
          @@@@lang:en
          @@@@@:
            The new namespace URI.
     @@Param:
        @@@Name:  qualifiedName
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            The new qualified name.
     @@Return:
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@:
            The renamed node.
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:NOT_SUPPORTED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The type of the specified node is neither 
              <IF::Element> nor <IF::Attr>, or the DOM implementation 
              does not support the renaming of the document element.
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:INVALID_CHARACTER_ERR
          @@@@SubType:
            @@@@@QName:
              MDOMX:MDOM_BAD_NAME
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <P::qualifiedName> is not an XML <XML::Name>.
       @@@Exception:
         @@@@Type:DOMException
         @@@@Name:WRONG_DOCUMENT_ERR
         @@@@Description:
           @@@@@lang:en
           @@@@@@:
             The <P::n> was created from a different document.
       @@@Exception:
         @@@@Type:DOMException
         @@@@Name:NAMESPACE_ERR
         @@@@Description:
           @@@@@lang:en
           @@@@@@:
             Either the <P::qualifiedName> is malformed, 
             the <P::qualifiedName> has a prefix and the <P::namespaceURI> 
             is <DOM::null>, the <P::qualifiedName> has a prefix that 
             is <XML::xml> and the <P::namespaceURI> is different 
             from <URI::http://www.w3.org/XML/1998/namespace>, 
             the <P::n> is an attribute and <P::qualifiedName> or its 
             prefix is <XML::xmlns> and the <P::namespaceURI> is 
             different from <URI::http://www.w3.org/2000/xmlns/>.
     @@ImplNote:
       @@@lang:en
       @@@@:
         What should be happen if non-XML or non-namespace node 
         is tried to rename?
     @@Level[list]:  3
     @@SpecLevel:3
     @@For:
       ManakaiDOM:DOM3
  
  @ReAttr:
    @@Name:baseURI
    @@Description:
      @@@lang:en
      @@@@:
        The base URI of this document.
    @@Get:
      @@@Type:
        ManakaiDOM:ManakaiDOMURI
      @@@Description:
        @@@@lang:en
        @@@@@: The base URI.
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The DOM implementation is unable to obtain an absolute URI.
      @@@PerlDef:
          if ($self->{<Q::TreeCore:node>}->{<Q::DOMCore:hasFeature>}->{HTML}) {
            $r = $self->{<Q::TreeCore:node>}
                      -><M::ManakaiDOMCore:ManakaiDOMNodeObjectNode
                                        .htmlBaseURI>;
          } else {
            $r = $self->{<Q::TreeCore:node>}
                      -><M::ManakaiDOMCore:ManakaiDOMNodeObjectNode
                                        .contentBaseURI> (false);
          }
       @@@ImplNote:
         @@@@lang:en
         @@@@@:
           If a document has both a <HE::base> element and 
           an <XA::xml:base> attribute, or even in the case that 
           an XHTML 1 document has an <XA::xml:base> attribute, 
           its result is not defined by any W3C specification.
    @@SpecLevel:3
    @@Level[list]:3
    @@For:
      ManakaiDOM:DOM3
  @ReMethod:
     @@Name:  lookupPrefix
     @@Description:
       @@@lang:en
       @@@@:
         Lookup the namespace prefix associated to the given namespace 
         URI, starting from this node.
       \
         The default namespace declarations are ignored by this method. 
         To lookup default namespace, use the <M::Node.isDefaultNamespace>
         method.
     @@Param:
        @@@Name:  namespaceURI
        @@@Type:
          ManakaiDOM:ManakaiDOMNamespaceURI
        @@@Description:
          @@@@lang:en
          @@@@@: The namespace URI to look for.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Always <DOM::null> will be returned.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Always <DOM::null> will be returned.
     @@Return:
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            An associated namespace prefix.
          \
            If more than one prefix are associated to the 
            namespace URI, which is returned is implementation 
            dependent.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              No namespace prefix is found.
        @@@PerlDef:
            if (not defined $namespaceURI) {
              $r = null;
            } else {
              __DEEP{
                for (@{$self->{<Q::TreeCore:node>}->{<Q::infoset:children>}}) {
                  if ($_->{<Q::DOMCore:nodeType>} eq <Q::infoset:Element>) {
                    $r = $_-><M::ManakaiDOMCore:ManakaiDOMNodeObjectNode
                                   .lookupNamespacePrefix>
                                                   ($namespaceURI, $_);
                    last;
                  }
                }
              }__;
            }
     @@Level[list]:  3
     @@SpecLevel:3
     @@For:
       ManakaiDOM:DOM3
  @ReAttr:
    @@Name: nodeName
    @@Description:
      @@@lang:en
      @@@@: The node name.
    @@Spec:
      @@@DOM3[list]:
        http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-F68D095
        http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-1841493061
    @@DOMMain:isNamespaceUnaware:1
    @@Get:
      @@@Type: 
        DOMMain:DOMString
      @@@InCase:
        @@@@Value:\#document
        @@@@Description:
          @@@@@lang:en
          @@@@@@: Always this value for the "Document" node.
      @@@disDef:
        @@@@DISLang:value:
          @@@@@@: \#document
          @@@@@ContentType:
            DISCore:String
  @ReAttr:
    @@Name: nodeType
    @@Description:
      @@@lang:en
      @@@@: The type of this node.
    @@Get:
      @@@Type: 
        DOMMain:unsigned-short||ManakaiDOM|all
      @@@actualType: ManakaiDOMNodeType
      @@@InCase:
        @@@@Label: DOCUMENT_NODE
        @@@@Description:
          @@@@@lang:en
          @@@@@@: The node is a "Document".
      @@@disDef:
        @@@@DISLang:constValue: Node.DOCUMENT_NODE
  @ReAttr:
     @@Name:  textContent
     @@Description:
       @@@lang:en
       @@@@:
         The text content of this node and its descendants.
     @@Get:
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The text content of this node.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The text content is defined to be "null".
        @@@PerlDef:
          @@@@@: $r = null;
     @@Set:
        @@@Type:  
          DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: Setting this attribute has no effect.
        @@@Warning:
          @@@@Type:
            ManakaiDOM:ManakaiDOMImplementationWarning
          @@@@Name: ATTR_SET_NO_EFFECT
          @@@@Description:
            @@@@@lang:en
            @@@@@@: Setting this attribute has no effect.
        @@@PerlDef: \
     @@Level[list]: 3
     @@SpecLevel:3
     @@For:
       ManakaiDOM:DOM3
  @IntMethod:
    @@Name: newObject
    @@Description:
      @@@lang:en
      @@@@:
        Construct an object for the new instance of the "Document".
      \
        Note that this method is for the internal use.  DOM 
        applications must use the "createDocument" method 
        of the "DOMImplementation" interface to create a new "Document".
    @@ImplNote:
      @@@lang:en
      @@@@:
        The caller of this internal method MUST ensure to set 
        the attributes: <CODE::TreeCore:implementation>.
    @@Return:
      @@@Type: NodeStem
      @@@Description:
        @@@@lang:en
        @@@@@: The new object for the "Document".
      @@@PerlDef:
          $r = <ClassM::ManakaiDOMNode.newObject>;
          push @{$r->{<Q::TreeCore:origin>}}, <Q::infoset:parent>;
          $r->{<Q::DOMCore:nodeType>} = <Q::infoset:Document>;
          $r->{<Q::infoset:version>} = '1.0';
          $r->{<Q::DOMCore:strictErrorChecking>} = true;
          push @{$r->{<Q::TreeCore:subnode>}},
               <Q::infoset:children>, <Q::DOMViews:view>;
          $r->{<Q::infoset:children>} = [];
          $r->{<Q::DOMViews:view>} = [];
       @@@ImplNote:
         @@@@lang:en
         @@@@@:
           Other properties required to be a legal <IF::Document> object:
           <Q::DOMCore:implementation>, <Q::ManakaiDOM:implID>, 
           <Q::DOMCore:hasFeature>.
         \
           Other available properties: <Q::DOMCore:read-only>,
           <Q::infoset:characterEncodingScheme>, <Q::DOMCore:xmlEncoding>,
           <Q::infoset:standalone>, <Q::infoset:version>,
           <Q::DOMCore:documentURI>, <Q::DOMCore:strictErrorChecking>, 
           <Q::infoset:children>, <Q::DOMViews:view>.


  @Method:
     @@Name:  getFeature
     @@enDesc:
       Returns a specialized object that implements the
       specialized interfaces of the specified feature and version.
     @@ManakaiDOM:isRedefining:1
     @@ForCheck: ManakaiDOM|ForClass ManakaiDOM|DOM3
     @@Param:
        @@@Name:  feature
        @@@Type:  
          DOMMain:DOMString
        @@@actualType: ManakaiDOM|ManakaiDOMFeatureName
        @@@enDesc:
          The feature name to request.
        @@@InCase:
          @@@@Label:
            @@@@@lang:en
            @@@@@@: 
              Feature name preceded by a <CHAR::PLUS SIGN>
          @@@@enDesc:
            The <CHAR::PLUS SIGN> is ignored.
     @@Param:
        @@@Name:  version
        @@@Type:  
          DOMMain:DOMString
        @@@actualType: ManakaiDOM|ManakaiDOMFeatureVersion
        @@@enDesc:
          The feature version to request.
        @@@nullCase:
          @@@@enDesc:
            No specific version is requested.
     @@Return:
        @@@Type:  
          DOMMain:DOMObject
        @@@enDesc:
          An object implementing the specialized interfaces.
          Note that the specialized object may or may not
          implement the <IF::Node> interface.
        @@@nullCase:
          @@@@enDesc:
            There is no object available that implements
            the specialized interfaces.
        @@@PerlDef:
            $feature =~ s/^\+//;
            if ($Message::DOM::ClassFeature{ref $self}->{$feature}->{$version}) {
              ## This class
              $r = $self;
            } else {
              ## Root element type dependent classes
                ## TODO:
              ## Document type dependent classes
                ## TODO:
              ## Document type independent classes
              CLASS: for my $class (grep {
                $Message::DOM::ManakaiDOMDocument::CompatClass{$_}
              } keys %Message::DOM::ManakaiDOMDocument::CompatClass) {
                if ($Message::DOM::ClassFeature{$class}
                            ->{$feature}->{$version}) {
                  __CODE{getNodeRef::
                    $object => {$self->{<Q::TreeCore:node>}},
                    $ref => $r,
                    $class => $class,
                  }__;
                  last CLASS;
                }
              }
            }
##Document

PropDef:
  @QName: ownerDocument
  @enDesc:
    <A::Node.ownerDocument>.

PropDef:
  @QName: documentURI
  @enDesc:
    <A::Document.documentURI>.

PropDef:
  @QName: domConfig
  @enDesc:
    The DOM configuration object (<IF::DOMConfiguration>)
    associated with the subject resource.
  @rdfs:range:
    DOMConfiguration

PropDef:
  @QName: strictErrorChecking
  @enDesc:
    <A::Document.strictErrorChecking>.

PropDef:
  @Name: name
  @Description:
    @@lang:en
    @@@:
      A name.

PropDef:
  @QName: hasFeature
  @Description:
    @@lang:en
    @@@:
      For <IF::Document> nodes: what features the subject node has. 
      \
      Whether a document supports a feature or not is different from 
      whether a node implementation supports a feature or not; for 
      example, an <Feature::XML>-aware node implementation might be 
      instantiated for a pure (non-XML) HTML node object. 
      \
      {P:: Whether a document supports the <Feature::HTML> feature or not 
           is significant for:
        \
        - <A::Node.baseURI>.
        \
      }
      \
      {P:: Whether a document supports the <Feature::XML> feature or not 
           is significant for:
        \
        - <A::Document.xmlVersion>, 
        \
        - <A::Document.xmlEncoding>, 
        \
        - <M::Document.createAttributeNS> and 
        \
        - <M::Document.createElementNS>.
        \
       }

ConfigParam:
  @ForCheck: !ManakaiDOM|all

  @Description:
    @@lang:en
    @@@:
      A parameter name used with the <IF::DOMConfiguration>.
    \
      Names are case-insensitive.  To avoid possible conflicts, 
      names referring to parameters defined outside the DOM 
      specification should be made unique.  Names are 
      recommended to follow the Unicode identifier specification 
      with the addition of the character <CHAR:HYPHEN-MINUS>.
  @ImplNote:
    @@lang:en
    @@@:
      DOM implementations must recognize all parameters 
      and some parameter values defined in the DOM Level 3 Core Specification.
    \
      DOM parameters are similar to features and properties of SAX2.
  @CParam:
    @@Name: canonical-form
    @@IsSupportRequired:1
    @@Type: DOMMain|boolean||ManakaiDOM|all
    @@InCase:
      @@@Value: true
      @@@Target:
        @@@@TargetMethod:
          Document::.normalizeDocument
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            Canonicalize the document accoding to the rules specified in 
            the XML C14N Version 1.0 Specification.
        \
            This is limited to what can be represented in the DOM.  
            For example, there is no way to specify the order of 
            the attributes in the DOM.
      @@@Target:
        @@@@TargetModule:
          DOMLS:LSSerializer::
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            Write the document according to the rules specified in 
            the XML C14N Version 1.0 Specification.
            \
            Serializing an XML 1.1 document will generate a fatal error.
        @@@@ImplNote:
          @@@@@lang:en
          @@@@@@:
            Why error? Because c14n does not support XML 1.1?
      ## From DOM Level 3 Core
      @@@SetParam:
        @@@@Name: entities
        @@@@Type: DOMMain|boolean||ManakaiDOM|all
        @@@@Value: false
      @@@SetParam:
        @@@@Name: normalize-characters
        @@@@Type: DOMMain|boolean||ManakaiDOM|all
        @@@@Value: false
      @@@SetParam:
        @@@@Name: cdata-sections
        @@@@Type: DOMMain|boolean||ManakaiDOM|all
        @@@@Value: false
      @@@SetParam:
        @@@@Name: namespaces
        @@@@Type: DOMMain|boolean||ManakaiDOM|all
        @@@@Value: true
      @@@SetParam:
        @@@@Name: namespace-declarations
        @@@@Type: DOMMain|boolean||ManakaiDOM|all
        @@@@Value: true
      @@@SetParam:
        @@@@Name: well-formed
        @@@@Type: DOMMain|boolean||ManakaiDOM|all
        @@@@Value: true
      @@@SetParam:
        @@@@Name: element-content-whitespace
        @@@@Type: DOMMain|boolean||ManakaiDOM|all
        @@@@Value: true
      ## From DOM Level 3 LS
      @@@SetParam:
        @@@@Name:format-pretty-print
        @@@@Type:DOMMain|boolean||ManakaiDOM|all
        @@@@Value:false
      @@@SetParam:
        @@@@Name:discade-default-content
        @@@@Type:DOMMain|boolean||ManakaiDOM|all
        @@@@Value:false
      @@@SetParam:
        @@@@Name:xml-declaration
        @@@@Type:DOMMain|boolean||ManakaiDOM|all
        @@@@Value:false
    @@InCase:
      @@@Value: false
      @@@IsSupportRequired:1
      @@@IsDefault:1
      @@@Description:
        @@@@lang:en
        @@@@@: Do not canonicalize the document or the output.
  @CParam:
    @@Name: cdata-sections
    @@IsSupportRequired:1
    @@Type:DOMMain|boolean||ManakaiDOM|all
    @@InCase:
      @@@Value: true
      @@@IsSupportRequired:1
      @@@IsDefault:1
      @@@Description:
        @@@@lang:en
        @@@@@:
          Keep <IF::DOMXML:CDATASection> nodes in the document.
      @@@SetParam:
        @@@@Name: canonical-form
        @@@@Type:DOMMain|boolean||ManakaiDOM|all
        @@@@Value:false
    @@InCase:
      @@@Value: false
      @@@IsSupportRequred:1
      @@@Description:
        @@@@lang:en
        @@@@@:
          Transform <IF::DOMXML:CDATASection> nodes in the document into 
          <IF::Text> nodes.  The new <IF::Text> node is then 
          combined with any adjacent <IF::Text> node.
  @CParam:
    @@Name: check-character-normalization
    @@IsSupportRequired
    @@Type:DOMMain|boolean||ManakaiDOM|all
    @@InCase:
      @@@Value: true
      @@@Description:
        @@@@lang:en
        @@@@@:
          Check whether the characters in the document are fully normalized 
          as defined in Appendix B of the XML 1.1 Specification.  When 
          a sequence of characters is encountered that fails 
          normalization checking, an error with the 
          <A::DOMError.type> equals to 
          <DOM::check-character-normalization-failure> is issued.
    @@InCase:
      @@@Value: false
      @@@IsSupportRequired:1
      @@@IsDefault:1
      @@@Description:
        @@@@lang:en
        @@@@@: Do not check whether characters are normalized.
  @CParam:
    @@Name: comments
    @@IsSupportRequired:1
    @@Type:DOMMain|boolean||ManakaiDOM|all
    @@InCase:
      @@@Value:true
      @@@IsSupportRequired:1
      @@@IsDefault:1
      @@@Description:
        @@@@lang:en
        @@@@@:
          Keep <IF::Comment> nodes in the document.
    @@InCase:
      @@@Value:false
      @@@IsSupportRequired:1
      @@@Description:
        @@@@lang:en
        @@@@@:
           Discard <IF::Comment> nodes in the document.
  @CParam:
    @@Name: datatype-normalization
    @@IsSupportRequired:1
    @@Type:DOMMain|boolean||ManakaiDOM|all
    @@InCase:
      @@@Value:true
      @@@Description:
        @@@@lang:en
        @@@@@:
          Expose schema normalized values in the tree.
        \
          This parameter required to have <DOM::validate> parameter 
          equals to <DOM::true>, or this parameter has no effect.
        \
          Note that the attribute value normalization as defined 
          in the XML Specifications does not applied.  This 
          parameter is only meant for schema languages other 
          than the DTD.
    @@InCase:
      @@@Value:false
      @@@IsSupportRequired:1
      @@@IsDefault:0
      @@@Description:
        @@@@lang:en
        @@@@@: Do not perform schema normalization on the tree.
  @CParam:
    @@Name: element-content-whitespace
    @@IsSupportRequired:1
    @@Type:DOMMain|boolean||ManakaiDOM|all
    @@InCase:
      @@@Value:true
      @@@IsSupportRequired:1
      @@@IsDefault:1
      @@@Description:
        @@@@lang:en
        @@@@@:
          Keep all whitespaces in the document.
    @@InCase:
      @@@Value:false
      @@@Description:
        @@@@lang:en
        @@@@@:
          Discard all <IF::Text> nodes that contain whitespaces 
          in element content.
      @@@ImplNote:
        @@@@lang:en
        @@@@@:
          DOM implementations are expected to use the attribute 
          <A::Text.isElementContentWhitespace> to determine 
          whether a <IF::Text> node should be discarded.
      @@@SetParam:
        @@@@Name:canonical-form
        @@@@Type:DOMMain|boolean||ManakaiDOM|all
        @@@@Value:false
  @CParam:
    @@Name: entities
    @@Type:DOMMain|boolean||ManakaiDOM|all
    @@IsSupportRequired:1
    @@InCase:
      @@@Value:true
      @@@IsSupportRequired:1
      @@@IsDefault:1
      @@@Description:
        @@@@lang:en
        @@@@@:
          Keep <IF::DOMXML:EntityReferences> nodes in the document.
      @@@SetParam:
        @@@@Name:canonical-form
        @@@@Type:DOMMain|boolean||ManakaiDOM|all
        @@@@Value:false
    @@InCase:
      @@@Value:false
      @@@IsSupportRequired:1
      @@@Description:
        @@@@lang:en
        @@@@@:
          Remove all <IF::DOMXML:EntityReference> nodes from the document, 
          putting the entity expansions directly in their place. 
          <IF::Text> nodes are normalized as defined in 
          <M::Node.normalize>.  Only unexpanded entity references 
          are kept in the document.
      @@@ImplNote:
        @@@@lang:en
        @@@@@:
          This parameter does not affect <IF::DOMXML:Entity> nodes.
  @CParam:
    @@Name: error-handler
    @@Type: 
      DOMCore:DOMErrorHandler
    @@IsSupportRequired:1
    @@Description:
      @@@lang:en
      @@@@:
        If an error is encountered in the document, the DOM 
        implementation will callback the <IF::DOMErrorHandler>. 
      \
        When called, <A::DOMError.relatedData> will contain 
        the closest node to where the error occurred. 
        If the implementation is unable to determine the node 
        where the error occurs, <A::DOMError.relatedData> will 
        contain the <IF::Document> node. 
      \
        Mutations to the document from within an error handler 
        will result in implementation dependent behavior.
    @@ImplNote:
      @@@lang:en
      @@@@:
        DOM implementations may provide a default <IF::DOMErrorHandler> 
        object.  
    @@ImplNote:
      @@@lang:en
      @@@@:
        {P:: This parameter is used in:
        \
        {LI:: <M::Document.normalizeDocument>:: If errors occurs, such as an 
          attempt to update a read-only node or a <A::Node.nodeName> 
          contains an invalid character.  This method might report 
          fatal errors.
        \
        }
        \
        }
  @CParam:
    @@Name: infoset
    @@IsSupportRequired:1
    @@Type:DOMMain|boolean||ManakaiDOM|all
    @@InCase:
      @@@Value:true
      @@@IsSupportRequired:1
      @@@Description:
        @@@@lang:en
        @@@@@:
          Keep in the document information defined in the 
          XML Infoset Specification.
      @@@SetParam:
        @@@@Name: validate-if-schema
        @@@@Type: DOMMain|boolean||ManakaiDOM|all
        @@@@Value:false
      @@@SetParam:
        @@@@Name: entities
        @@@@Type:DOMMain|boolean||ManakaiDOM|all
        @@@@Value:false
      @@@SetParam:
        @@@@Name:datatype-normalization
        @@@@Type:DOMMain|boolean||ManakaiDOM|all
        @@@@Value:false
      @@@SetParam:
        @@@@Name:cdata-sections
        @@@@Type:DOMMain|boolean||ManakaiDOM|all
        @@@@Value:false
      @@@SetParam:
        @@@@Name:namespace-declarations
        @@@@Type:DOMMain|boolean||ManakaiDOM|all
        @@@@Value:true
      @@@SetParam:
        @@@@Name:well-formed
        @@@@Type:DOMMain|boolean||ManakaiDOM|all
        @@@@Value:true
      @@@SetParam:
        @@@@Name:element-content-whitespace
        @@@@Type:DOMMain|boolean||ManakaiDOM|all
        @@@@Value:true
      @@@SetParam:
        @@@@Name:comments
        @@@@Type:DOMMain|boolean||ManakaiDOM|all
        @@@@Value:true
      @@@SetParam:
        @@@@Name:namespaces
        @@@@Type:DOMMain|boolean||ManakaiDOM|all
        @@@@Value:true
      @@@ImplNote:
        @@@@lang:en
        @@@@@:
          <M::DOMConfiguration.getParameter> with this parameter 
          returns <DOM::true> iif <CODE::!<DOM::validate-if-schema> && 
          !<DOM::entities> && !<DOM::datatype-normalization> && 
          !<DOM::cdata-sections> && <DOM::namespace-declarations> && 
          <DOM::well-formed> && <DOM::element-content-whitespace> && 
          <DOM::comment> && <DOM::namespaces>>.
    @@InCase:
      @@@Value:false
      @@@Description:
        @@@@lang:en
        @@@@@:
          Setting <DOM::infoset> to <DOM::false> has no effect.
    @@Get:
      @@@PerlDef:
        @@@@@:
          $r = !$cfg->{<Q::DOMCoreParam:validate-if-schema>} &&
               !$cfg->{<Q::DOMCoreParam:entities>} &&
               !$cfg->{<Q::DOMCoreParam:datatype-normalization>} &&
               !$cfg->{<Q::DOMCoreParam:cdata-sections>} && 
               $cfg->{<Q::DOMCoreParam:namespace-declarations>} &&
               $cfg->{<Q::DOMCoreParam:well-formed>} &&
               $cfg->{<Q::DOMCoreParam:element-content-whitespace>} &&
               $cfg->{<Q::DOMCoreParam:comment>} && 
               $cfg->{<Q::DOMCoreParam:namespaces>}
             ? true : false;
  @CParam:
    @@Name: namespaces
    @@Type:DOMMain|boolean||ManakaiDOM|all
    @@IsSupportRequired:1
    @@InCase:
      @@@Value:true
      @@@IsSupportRequired:1
      @@@IsDefault:1
      @@@Description:
        @@@@lang:en
        @@@@@:
          Perform the namespace normalization processing.
    @@InCase:
      @@@Value:false
      @@@Description:
        @@@@lang:en
        @@@@@:
          Do not perform the namespace processing.
      @@@SetParam:
        @@@@Name:canonical-form
        @@@@Type:DOMMain|boolean||ManakaiDOM|all
        @@@@Value:false
  @CParam:
    @@Name: namespace-declarations
    @@IsSupportRequired:1
    @@Type:DOMMain|boolean||ManakaiDOM|all
    @@InCase:
      @@@Value:true
      @@@IsSupportRequired:1
      @@@IsDefault:1
      @@@Description:
        @@@@lang:en
        @@@@@:
          Include namespace declaration attributes, specified or 
          defaulted from the schema, in the document.
    @@InCase:
      @@@Value:false
      @@@IsSupportRequired:1
      @@@Description:
        @@@@lang:en
        @@@@@:
          Discade all namespace declaration attributes.  The namespace 
          prefixes are retained.
      @@@SetParam:
        @@@@Name:canonical-form
        @@@@Type:DOMMain|boolean||ManakaiDOM|all
        @@@@Value:false
  @CParam:
    @@Name: normalize-characters
    @@Type:DOMMain|boolean||ManakaiDOM|all
    @@IsSupportRequired:1
    @@InCase:
      @@@Value:true
      @@@Target:
        @@@@TargetMethod:
          Document::.normalizeDocument
        @@@@IsDefault:0
      @@@Target:
        @@@@TargetModule:
          DOMLS:LSSerializer::
        @@@@IsDefault:1
        @@@@ImplNote:
          @@@@@lang:en
          @@@@@@:
            The default is <DOM::true> but fully-normalization is 
            not required to be supported <SRC::DOM Level 3 LS>.
      @@@Description:
        @@@@lang:en
        @@@@@: 
          Fully normalize the characters in the document as defined in 
          the Appendix B of the XML 1.1 Specification.
      @@@SetParam:
        @@@@Name:canonical-form
        @@@@Type:DOMMain|boolean||ManakaiDOM|all
        @@@@Value:false
    @@InCase:
      @@@Value:false
      @@@IsSupportRequired:1
      @@@Target:
        @@@@TargetMethod:
          Document::.normalizeDocument
        @@@@IsDefault:1
      @@@Target:
        @@@@TargetModule:
          DOMLS:LSSerializer::
        @@@@IsDefault:0
      @@@Description:
        @@@@lang:en
        @@@@@: Do not perform character normalization.
  @CParam:
    @@Name:schema-location
    @@IsSupportRequired:1
    @@Type:
      DOMMain:DOMString
    @@InCase:
      @@@Label:
        @@@@lang:en
        @@@@@: A list of DOM URIs, separated by whitespaces
      @@@IsSupportRequired:0
      @@@Description:
        @@@@lang:en
        @@@@@:
          The schemas against which validation should occur, i.e. 
          the current schema.
      \
        The types of schemas must match the <DOM::schema-type>, 
        otherwise the behaviour is undefined.
      \
        The schemas specified here take precedence to the schema 
        specified in the document itself.  For namespace aware schema, 
        if a schema specified using this parameter and a schema 
        specified in the document instance in a schema document 
        share the same <CODE::targetNamespace>, the schema specified 
        by the DOM application will be used.  If two schemas 
        specified by the application share the same 
        <CODE::targetNamespace> or have no namespace, the behavior 
        is implementation dependent.
      \
        This parameter is ignored unless the <DOM::schema-type> 
        value is set.
      @@@ImplNote:
        @@@@lang:en
        @@@@@:
        Whitespace = <CODE::S> in the XML 1.0 Specification.
      \
        It is strongly recommended that the <A::Document.documentURI>, 
        will be set so that an implementation can successfully resolve 
        any external entities referred. 
    @@InCase:
      @@@Value:
        @@@@@is-null:1
      @@@Description:
        @@@@lang:en
        @@@@@: No location has been provided.
  @CParam:
    @@Name:schema-type
    @@IsSupportRequired:1
    @@Type:
      DOMMain:ManakaiDOMSchemaType
    @@InCase:
      @@@Label:
        @@@@lang:en
        @@@@@:
          An absolute DOM URI
      @@@IsSupportRequired:0
      @@@Description:
        @@@@lang:en
        @@@@@:
          The type of the schema language used to validate a document against.
        \
          No lexical cheking is done on the absolute URI.
        \
          A default value may be provided by the DOM implementation, 
          based on the schema languages supported and on the 
          schema language used at load time.
    @@InCase:
      @@@Value:
        @@@@is-null:1
      @@@Description:
        @@@@lang:en
        @@@@@: No value is provided.
  @CParam:
    @@Name: split-cdata-sections
    @@Type:DOMMain|boolean||ManakaiDOM|all
    @@IsSupportRequired:1
    @@InCase:
      @@@Value:true
      @@@IsSupportRequired:1
      @@@IsDefault:1
      @@@Description:
        @@@@lang:en
        @@@@@:
          Split CDATA sections containing the <SGML::MSE> 
          (<XML::]]<gt>>).
        \
          When CDATA section is split, a warning is issued with 
          a <A::DOMError.type> equals to <DOM::cdata-sections-splitted> 
          and <A::DOMError.relatedData> equals to the first 
          <IF::DOMXML:CDATASection> node in document order.
    @@InCase:
      @@@Value:false
      @@@IsSupportRequired:1
      @@@Description:
        @@@@lang:en
        @@@@@:
          Signal an error if <IF::DOMXML:CDATASection> contains an 
          unrepresentable character.
  @CParam:
    @@Name:validate
    @@IsSupportRequired:1
    @@Type:DOMMain|boolean||ManakaiDOM|all
    @@InCase:
      @@@Value:true
      @@@Description:
        @@@@lang:en
        @@@@@:
          Require the validation against a schema of the document 
          as it is being normalized as defined by the XML 1.0 Specification. 
        \
          If validation errors are found or no schema was found, 
          the error handler is notified.
        \
          Schema-normalized values will not exposed unless the 
          parameter <DOM::datatype-normalization> is <DOM::true>.
        \
          Following attributes are revaluated:
        \
          - Attribute nodes with <A::Attr.specified> equals to <DOM::false>.
        \
          - The value of the attribute <A::Text.isElementContentWhitespace> 
          for all <IF::Text> nodes.
        \
          - The value of the attribute <A::Attr.isId> for all <IF::Attr> nodes.
        \
          - The attributes <A::Element.schemaTypeInfo> and 
          <A::Attr.schemaTypeInfo>.
        \
          DOM applications should consider setting the parameter 
          <DOM::well-formed> to <DOM::true>.
      @@@SetParam:
        @@@@Name: validate-if-schema
        @@@@Type:DOMMain|boolean||ManakaiDOM|all
        @@@@Value: false
    @@InCase:
      @@@Value:false
      @@@IsSupportRequired:1
      @@@IsDefault:1
      @@@Description:
        @@@@lang:en
        @@@@@:
          Do not accomplish schema processing, including internal subset 
          processing.  Default attribute information are kept.
        \
          Note that validation might still happen in case 
          <DOM::validate-if-schema> is <DOM::true>.
  @CParam:
    @@Name:validate-if-schema
    @@Type:DOMMain|boolean||ManakaiDOM|all
    @@IsSupportRequired:1
    @@InCase:
      @@@Value:true
      @@@Description:
        @@@@lang:en
        @@@@@:
          Enable validation only if a declaration for the document 
          element can be found in a schema.  If validation is enabled, 
          this parameter has the same behavior as the parameter 
          <DOM::validate> set to <DOM::true>.
      @@@SetParam:
        @@@@Name:validate
        @@@@Type:DOMMain|boolean||ManakaiDOM|all
        @@@@Value:false
    @@InCase:
      @@@Value:false
      @@@IsSupportRequired:1
      @@@IsDefault:1
      @@@Description:
        @@@@lang:en
        @@@@@:
          No schema processing should be performed if the document has 
          a schema, including internal subset 
          processing.  Default attribute information are kept.
        \
          Note that validation might still happen in case 
          <DOM::validate> is <DOM::true>.
  @CParam:
    @@Name:well-formed
    @@Type:DOMMain|boolean||ManakaiDOM|all
    @@IsSupportRequired:1
    @@InCase:
      @@@Value:true
      @@@IsSupportRequired:1
      @@@IsDefault:1
      @@@Description:
        @@@@lang:en
        @@@@@:
          Check if all nodes are well-formed according to the XML 
          version in use (<A::Document.xmlVersion>), i.e.:
        \
          - Check if the attribute <A::Node.nodeName> contains 
          invalid characters according to its node type and generate 
          a <IF::DOMError> of type <DOM::wf-invalid-character-in-node-name>, 
          with a <DOM::SEVERITY_ERROR> severity, if necessary.
        \
          - Check if the text content inside <IF::Attr>, <IF::Element>, 
          <IF::Comment>, <IF::Text> and <IF::DOMXML:CDATASection> nodes for 
          invalid characters and generate a <IF::DOMError> of type 
          <DOM::wf-invalid-character>, with a 
          <DOM::SEVERITY_ERROR> severity, if necessary.
        \
          - Check if the data inside <IF::DOMXML:ProcessingInstruction> nodes 
          for invalid characters and generate a <IF::DOMError> 
          of type <DOM::wf-invalid-character>, with a
          <DOM::SEVERITY_ERROR> severity, if necessary.
    @@InCase:
      @@@Value:false
      @@@Description:
        @@@@lang:en
        @@@@@: Do not check for XML well-formedness.
      @@@SetParam:
        @@@@Name:canonical-form
        @@@@Type:DOMMain|boolean||ManakaiDOM|all
        @@@@Value:false
##ConfigParam:Document

ElementTypeBinding:
  @Name: PropDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      rdf:Property

PropDef:
  @QName: severity
  @Description:
    @@lang:en
    @@@: The severity of an error.
PropDef:
  @QName: relatedData
  @Description:
    @@lang:en
    @@@: A related data.
