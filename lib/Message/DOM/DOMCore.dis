Namespace:
  @DOMLS:
    http://suika.fam.cx/~wakaba/archive/2004/dom/ls#
  @DOMXML:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#
  @infoset:
     http://www.w3.org/2001/04/infoset#
  @lang:
     http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#
  @license:
     http://suika.fam.cx/~wakaba/archive/2004/8/18/license#
  @ManakaiDOMLS:
    http://suika.fam.cx/~wakaba/archive/2004/mdom-ls#
  @ManakaiDOMXML:
    http://suika.fam.cx/~wakaba/archive/2004/mdom-core#
  @MDOM_EXCEPTION:
     http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#
  @null:
    http://suika.fam.cx/~wakaba/-temp/2003/09/27/null
  @TreeCore: \
  @xml:
    http://www.w3.org/XML/1998/namespace
  @xmlns:
    http://www.w3.org/2000/xmlns/
Module:
  @Name:DOMCore
  @BindingName:
    @@@:  dom
    @@prefix:  w3c.org
    @@Type:
      lang:IDL-DOM
  @FullName:
    @@lang:en
    @@@: DOM Core Module
  @Spec:
    @@DOM3:
      http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-BBACDC08
  @Namespace:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#
  
  @Description:
    @@lang:en
    @@@:
      The DOM Core Module.  The interfaces defined in this module is 
      the fundemental DOM interfaces that must be fully implemented by 
      all conforming DOM implementations.
  
  @Author:
    @@FullName:Wakaba
    @@Mail:w@suika.fam.cx
  @License:
     license:Perl+MPL
  @Date.RCS:
     $Date: 2004/10/10 00:01:08 $

  @ConditionDef:
    @@Name: DOM1
  @ConditionDef:
    @@Name: DOM2
    @@ISA:DOM1
  @ConditionDef:
    @@Name: DOM3
    @@ISA:DOM2
  
  @Require:
    @@Module:
      @@@Name: ManakaiDOMCore
      @@@Namespace:
        http://suika.fam.cx/~wakaba/archive/2004/mdom-core#

  @Feature:
    @@Name: Core
    @@Version: 2.0
    @@Condition[list]:
      DOM2
      DOM3
    @@Spec:
      @@@DOM3:
        http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-BBACDC08
    @@Description:
      @@@lang:en
      @@@@: The DOM Core Module, Level 2.
    @@Contrib:
      DOMImplementation::DOM2
    @@Contrib:
      DOMImplementation::DOM3
    @@Contrib:
      Node::DOM2
    @@Condition:
      Node::DOM3
  @Feature:
    @@Name: Core
    @@Version: 3.0
    @@Condition[list]:
      DOM3
    @@Spec:
      @@@DOM3:
        http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-BBACDC08
    @@Description:
      @@@lang:en
      @@@@: The DOM Core Module, Level 3.
    @@Contrib:
      DOMImplementation::DOM3
    @@Contrib:
      Node::DOM3

Exception:
  @Name:  DOMException
  @Spec:
    @@DOM3:
      http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-17189187
  @Description:
    @@lang:en
    @@@:
      Exceptions common to the DOM modules.
  @Attr:
     @@Name:  code
     @@Get:
       @@@Type:  unsigned-short
       @@@Description:
         @@@@lang:en
         @@@@@: The error code from the constant value group ExceptionCode.
  @ConstGroup:
     @@Name:  ExceptionCode
     @@Spec:
       @@@DOM3:
         http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-258A00AF
     @@Description:
       @@@lang:en
       @@@@: Integers indicating the type of error generated.
     @@Const:
        @@@Name:  INDEX_SIZE_ERR
        @@@Type:  unsigned-short
        @@@Value:  1
        @@@Param:
          @@@@QName:
            MDOM_EXCEPTION:param-name
          @@@@Description:
            @@@@@lang:en
            @@@@@@: Parameter to which inappropriate value specified.
        @@@Description:
          @@@@lang:en
          @@@@@: Index or size is negative, or greater than the allowed value.
        @@@Description:
          @@@@lang:en
          @@@@Type:
            lang:muf
          @@@@@: 
              Index or size specified as parameter%t (
                name => {<Q:MDOM_EXCEPTION:param-name>},
                prefix => { "}, suffix => {"}); is negative, or 
              greater than the allowed value.
     @@Const:
        @@@Name:  DOMSTRING_SIZE_ERR
        @@@Type:  unsigned-short
        @@@Value:  2
        @@@Description:
          @@@@lang:en
          @@@@@: The specified range of text does not fit into a DOMString.
     @@Const:
        @@@Name:  HIERARCHY_REQUEST_ERR
        @@@Type:  unsigned-short
        @@@Value:  3
        @@@Description:
          @@@@lang:en
          @@@@@:
            An attempt is made to insert a node somewhere it does not belong.
        @@@SubType:
          @@@@QName:
            MDOM_EXCEPTION:HIERARCHY_ANCHESTOR_OR_SELF
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              An attempt is made to insert a node that is one of 
              ancestor of this node or that is this node itself.
          @@@@Param:
            @@@@@QName:
              MDOM_EXCEPTION:param-name
            @@@@@Type:DOMString
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@: The name of the parameter that specifies the node.
        @@@SubType:
          @@@@QName:
            MDOM_EXCEPTION:HIERARCHY_BAD_TYPE
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              An attempt is made to insert a node whose type is not allowed.
          @@@@Param:
            @@@@@QName:
              infoset:nodeType
            @@@@@Type:
              ManakaiDOM:ManakaiDOMURI
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@: The type of the node being tried to insert.
          @@@@Param:
            @@@@@QName:
              MDOM_EXCEPTION:param-name
            @@@@@Type:DOMString
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The name of the parameter that specifies the node.
        @@@SubType:
          @@@@QName:
            MDOM_EXCEPTION:MDOM_SECOND_DOC_ELEMENT
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              An attempt is made to insert a second document element node.
          @@@@Param:
            @@@@@QName:
              MDOM_EXCEPTION:param-name
            @@@@@Type: DOMString
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The name of the parameter the node is specified.
        @@@SubType:
          @@@@QName:
            MDOM_EXCEPTION:MDOM_SECOND_DOCTYPE
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              An attempt is made to insert a second document type node.
          @@@@Param:
            @@@@@QName:
              MDOM_EXCEPTION:param-name
            @@@@@Type: DOMString
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The name of the parameter the node is specified.
     @@Const:
        @@@Name:  WRONG_DOCUMENT_ERR
        @@@Type:  unsigned-short
        @@@Value:  4
        @@@Description:
          @@@@lang:en
          @@@@@:
            A node is used in a different document than the one
            that created it.
     @@Const:
        @@@Name:  INVALID_CHARACTER_ERR
        @@@Type:  unsigned-short
        @@@Value:  5
        @@@Description:
          @@@@lang:en
          @@@@@: An invalid or illegal character is specified.
        @@@SubType:
          @@@@QName:
            MDOM_EXCEPTION:MDOM_BAD_NAME
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The specified name is not a SGML or XML <XML:Name>.
          @@@@Param:
            @@@@@QName:
              DOMCore:name
            @@@@@Type:
              DOMMain:DOMString
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@: 
                The <XML:Name> specified.
     @@Const:
        @@@Name:  NO_DATA_ALLOWED_ERR
        @@@Type:  unsigned-short
        @@@Value:  6
        @@@Description:
          @@@@lang:en
          @@@@@: Data is specified for a node that does not support data.
     @@Const:
        @@@Name:  NO_MODIFICATION_ALLOWED_ERR
        @@@Type:  unsigned-short
        @@@Value:  7
        @@@Description:
          @@@@lang:en
          @@@@@:
            An attempt is made to modify an object where 
            modifications are not allowed. 
        @@@SubType:
          @@@@QName:
            MDOM_EXCEPTION:NOMOD_ATTR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              One of attribute nodes is read-only. 
        @@@SubType:
          @@@@QName:
            MDOM_EXCEPTION:NOMOD_CHILD
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              One of child nodes is read-only. 
        @@@SubType:
          @@@@QName:
            MDOM_EXCEPTION:NOMOD_PARENT
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The parent node of this node is read-only.
        @@@SubType:
          @@@@QName:
            MDOM_EXCEPTION:NOMOD_SRC_PARENT
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The parent node of the source node is read-only.
          @@@@Param:
            @@@@@QName:
              MDOM_EXCEPTION:param-name
            @@@@@Type:DOMString
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@: The parameter by which the source node is specified.
        @@@SubType:
          @@@@QName:
            MDOM_EXCEPTION:NOMOD_THIS
          @@@@Description:
            @@@@@lang:en
            @@@@@@: This node is read-only.
     @@Const:
        @@@Name:  NOT_FOUND_ERR
        @@@Type:  unsigned-short
        @@@Value:  8
        @@@Description:
          @@@@lang:en
          @@@@@:
            An attempt is made to refer a node in a context where 
            it does not exist.
     @@Const:
        @@@Name:  NOT_SUPPORTED_ERR
        @@@Type:  unsigned-short
        @@@Value:  9
        @@@Description:
          @@@@lang:en
          @@@@@:
            The DOM implementation does not support the type of object requested.
        @@@SubType:
          @@@@QName:
            MDOM_EXCEPTION:MDOM_DOC_NOSUPPORT_XML
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The document does not support the <DOM:XML> feature.
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              XML-specific operations were specified as HTML-only 
              DOM implementations does not have to implement them 
              in the DOM Level 2 Specification.  The DOM Level 2 
              Errata and the DOM Level 3 Specification define as 
              the DOM implementation raise an exception of code 
              <X:DOMException.NOT_SUPPORTED_ERR>.
           \
              This DOM implementation throws the exception in 
              both levels.
        @@@SubType:
          @@@@QName:
            MDOM_EXCEPTION:MDOM_IMPL_NOSUPPORT_SCHEMA
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The DOM implementation does not support the schema language.
          @@@@Param:
            @@@@@QName:
              DOMCore:schemaType
            @@@@@Type:
              ManakaiDOM:ManakaiDOMNamespaceURI
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The absolute URI representing the schema language requested.
          @@@@Description:
            @@@@@lang:en
            @@@@@Type:
              lang:muf
            @@@@@@:
              The schema language specified %p (prefix => {<},
              suffix => {>}, name => {<Q:DOMCore:schemaType>}); 
              is not supported
        @@@SubType:
          @@@@QName:
            MDOM_EXCEPTION:MDOM_IMPL_NOSUPPORT_XML
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The DOM implementation does not support the <DOM:XML> feature.
        @@@SubType:
          @@@@QName:
            MDOM_EXCEPTION:MDOM_IMPL_NOSUPPORT_XMLVER
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The DOM implementation does not support the XML 
              version specified.
          @@@@Param:
            @@@@@QName:
              infoset:version
            @@@@@Type:DOMString
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@: The XML version
        @@@SubType:
          @@@@QName:
            MDOM_EXCEPTION:MDOM_NODE_NOSUPPORT_XMLNS
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The node does not support XML Namespaces.  The node 
              might have been created by the DOM Level 1 methods or
              instantiated from the markup language that does not 
              support XML Namespaces.
          @@@@Param:
            @@@@@QName:
              MDOM_EXCEPTION:param-name
            @@@@@Type: 
              DOMMain:DOMString
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The name of the parameter that provides the node 
                that does not support XML Namespaces.
        @@@SubType:
          @@@@QName:
            ManakaiDOMLS:MDOMLS_IMPL_NOSUPPORT_MODE
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The DOM implementation does not support the requested mode.
          @@@@Param: 
            @@@@@QName:
              DOMLS:mode
            @@@@@Type:
              DOMLS:DOMImplementationLSMode
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@: The requested mode.
          @@@@Description:
            @@@@@lang:en
            @@@@@Type:
              lang:muf
            @@@@@@:
              The requested mode "%p (name => {<Q:DOMLS:mode>});" 
              is not supported
     @@Const:
        @@@Name:  INUSE_ATTRIBUTE_ERR
        @@@Type:  unsigned-short
        @@@Value:  10
        @@@Description:
          @@@@lang:en
          @@@@@: 
            An attempt is made to add an attribute that is already inuse 
            elsewhere.
     @@Const:
        @@@Name:  INVALID_STATE_ERR
        @@@Type:  unsigned-short
        @@@Value:  11
        @@@Level[list]:  2
        @@@SpecLevel: 2
        @@@Description:
          @@@@lang:en
          @@@@@:
            An attempt is made to use an object that is not (or no longer) 
            usable.
        @@@SubType:
          @@@@QName:
            ManakaiDOMLS:MDOMLS_BUSY
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The parser is busy.
     @@Const:
        @@@Name:  SYNTAX_ERR
        @@@Type:  unsigned-short
        @@@Value:  12
        @@@Level[list]:  2
        @@@SpecLevel: 2
        @@@Description:
          @@@@lang:en
          @@@@@: An invalid or illegal string is specified.
     @@Const:
        @@@Name:  INVALID_MODIFICATION_ERR
        @@@Type:  unsigned-short
        @@@Value:  13
        @@@Level[list]:  2
        @@@SpecLevel: 2
        @@@Description:
          @@@@lang:en
          @@@@@: An attempt is made to modify the type of underlying object.
     @@Const:
        @@@Name:  NAMESPACE_ERR
        @@@Type:  unsigned-short
        @@@Value:  14
        @@@SpecLevel: 2
        @@@Level[list]:  2
        @@@Description:
          @@@@lang:en
          @@@@@:
            An attempt is made to create or change an object in 
            a way that is incorrect with regard to namespaces.
        @@@SubType:
          @@@@QName:
            MDOM_EXCEPTION:MDOM_NS_BAD_NCNAME
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The specified <XML:NCName> is illegal according to 
              the XML version in use.
          @@@@Param:
            @@@@@QName:
              infoset:name
            @@@@@Type:
              DOMMain:DOMString
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <XML:NCName> specified.
        @@@SubType:
          @@@@QName:
            MDOM_EXCEPTION:MDOM_NS_MALFORMED_QNAME
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The specified qualified name is malformed according 
              to the XML version in use.
          @@@@Param:
            @@@@@QName:
              DOMCore:qualifiedName
            @@@@@Type:
              DOMMain:DOMString
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@: The qualified name specified.
        @@@SubType:
          @@@@QName:
            MDOM_EXCEPTION:MDOM_NS_NULL_QNAME_WITH_NON_NULL_URI
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The qualified name specified is not <DOM:null> but 
              the namespace URI that is not <DOM:null> is specified.
          @@@@Param:
            @@@@@QName:
              infoset:namespaceName
            @@@@@Type:
              ManakaiDOM:ManakaiDOMNamespaceURI
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@: The namespace URI specified.
        @@@SubType:
          @@@@QName:
            MDOM_EXCEPTION:MDOM_NS_OTHER_WITH_XML_URI
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The namespace prefix specified is not equal to <XML:xml> 
              while the namespace URI is 
              <URI:http://www.w3.org/XML/1998/namespace>.
          @@@@Param:
            @@@@@QName:
              infoset:prefix
            @@@@@Type: DOMString
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@: The namespace prefix.
          @@@@Param:
            @@@@@QName:
              DOMCore:qualifiedName
            @@@@@Type: DOMString
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@: The qualified name.
        @@@SubType:
          @@@@QName:
            MDOM_EXCEPTION:MDOM_NS_OTHER_WITH_XMLNS_URI
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The namespace prefix specified is not equal to <XML:xmlns> 
              while the namespace URI is 
              <URI:http://www.w3.org/2000/xmlns>.
          @@@@Param:
            @@@@@QName:
              infoset:prefix
            @@@@@Type: DOMString
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@: The namespace prefix.
          @@@@Param:
            @@@@@QName:
              DOMCore:qualifiedName
            @@@@@Type: DOMString
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@: The qualified name.
        @@@SubType:
          @@@@QName:
            MDOM_EXCEPTION:MDOM_NS_PREFIX_WITH_NULL_URI
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The namespace prefix is specified but the namespace URI 
              is <DOM:null>.
          @@@@Param:
            @@@@@QName:
              infoset:prefix
            @@@@@Type:
              DOMMain:DOMString
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@: The namespace prefix specified.
        @@@SubType:
          @@@@QName:
            MDOM_EXCEPTION:MDOM_NS_QNAME_IS_XMLNS
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The qualified name specified equals to <XML:xmlns>.
        @@@SubType:
          @@@@QName:
            MDOM_EXCEPTION:MDOM_NS_XML_WITH_OTHER_URI
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The namespace prefix specified is <XML:xml> and 
              the namespace URI is other than 
              <URI:http://www.w3.org/XML/1998/namespace>.
          @@@@Param:
            @@@@@QName:
              infoset:namespaceName
            @@@@@Type:
              ManakaiDOM:ManakaiDOMNamespaceURI
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@: The namespace URI.
        @@@SubType:
          @@@@QName:
            MDOM_EXCEPTION:MDOM_NS_XMLNS_WITH_OTHER_URI
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The namespace prefix specified is <XML:xmlns> and 
              the namespace URI is other than 
              <URI:http://www.w3.org/2000/xmlns>.
          @@@@Param:
            @@@@@QName:
              infoset:namespaceName
            @@@@@Type:
              ManakaiDOM:ManakaiDOMNamespaceURI
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@: The namespace URI.
        @@@SubType:
          @@@@QName:
            MDOM_EXCEPTION:MDOM_NS_XMLNSQ_WITH_OTHER_URI
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The qualified name is <XML:xmlns> and 
              the namespace URI is other than 
              <URI:http://www.w3.org/2000/xmlns>.
          @@@@Param:
            @@@@@QName:
              infoset:namespaceName
            @@@@@Type:
              ManakaiDOM:ManakaiDOMNamespaceURI
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@: The namespace URI.
       @@@SubType:
         @@@@QName:
           MDOM_EXCEPTION:MDOM_NS_XMLNS_XMLNS
         @@@@Description:
           @@@@@lang:en
           @@@@@@:
             The qualified name is <XML:xmlns:xmlns>.  It is prohibited 
             by the XML Namespace Specifications.
     @@Const:
        @@@Name:  INVALID_ACCESS_ERR
        @@@Type:  unsigned-short
        @@@Value:  15
        @@@Level[list]:  2
        @@@SpecLevel: 2
        @@@Description:
          @@@@lang:en
          @@@@@:
            A parameter or an operation is not supported by the 
            underlying object.
     @@Const:
        @@@Name:  VALIDATION_ERR
        @@@Type:  unsigned-short
        @@@Value:  16
        @@@Level[list]:  3
        @@@SpecLevel:3
        @@@Description:
          @@@@lang:en
          @@@@@:
            An attempt is made to modify an object where the modification 
            would make the Node invalid with respect to partial validity.

     @@Const:
        @@@Name:  TYPE_MISMATCH_ERR
        @@@Type:  unsigned-short
        @@@Value:  17
        @@@Level[list]:  3
        @@@SpecLevel:3
        @@@Description:
          @@@@lang:en
          @@@@@:
            The type of an object is incompatible with the expected 
            type of the parameter associated to the object.

IF:
  @Name:  DOMStringList
  @Level[list]:  3
  @SpecLevel:3
  @Spec:
    @@DOM3:
      http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#DOMStringList
  @Description:
    @@lang:en
    @@@:
      An ordered collection of "DOMString" values.
  @ImplNote:
    @@lang:en
    @@@:
      How the collection is implemented is not defined by the 
      specification.
  @Method:
     @@Name:  item
     @@Spec:
       @@@DOM3:
         http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#DOMStringList-item
     @@Description:
       @@@lang:en
       @@@@: Return a "DOMString" in the collection.
     @@Param:
        @@@Name:  index
        @@@Type:  unsigned-long
        @@@Description:
          @@@@lang:en
          @@@@@: Index into the collection.
        @@@InCase:
          @@@@Value: 0
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The first item.
        @@@InCase: 
          @@@@Label: "length" - 1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The last item.
     @@Return:
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            The "DOMString" at the "index"th position in the collection.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The specified "index" is negative or greater than or equal to 
              the number of "DOMString"s in the list.
        @@@Def:
          if (not defined $index or
              $index < 0 or
              $index > $#$self) {
            $r = null;
          } else {
            __INT__;
          }
        @@@IntDef:
          $r = $self->[$index];
  @Attr:
     @@Name:  length
     @@Spec:
       @@@DOM3:
         http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#DOMStringList-length
     @@Description:
       @@@lang:en
       @@@@: 
         The number of "DOMString"s in the list.
     @@Get:
        @@@Type:  unsigned-long
        @@@Description:
          @@@@lang:en
          @@@@@: The number of "DOMString"s in the list.
        @@@Def:
          $r = @$self;
  @Method:
     @@Name:  contains
     @@Spec:
       @@@DOM3: 
         http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#DOMStringList-contains
     @@Description:
       @@@lang:en
       @@@@: Test if a string is part of the list.
     @@Param:
        @@@Name:  str
        @@@Type:  DOMString
        @@@Description:
          @@@@labg:en
          @@@@@: The string to look for.
     @@Return:
        @@@Type:  boolean
        @@@Description:
          @@@@lang:en
          @@@@@: Whether the string is part of the list.
        @@@InCase:
          @@@@Value: true
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The string has been found.
        @@@InCase:
          @@@@Value: false
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The string has not been found.
        @@@Def:
          CHK: {
            __DEEP{
              for (@$self) {
                if ($str eq $_) {
                  $r = true;
                  last CHK;
                }
              }
            }__;
          }

IF:
  @Name:  NameList
  @Level[list]:  3
  @SpecLevel:3
  @Spec:
    @@DOM3:
      http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#NameList
  @Description:
    @@lang:en
    @@@:
      An ordered collection of parallel pairs of name and namespace values.
  @ImplNote:
    @@lang:en
    @@@: How this collection is implemented is not defined by the specification.
  @Method:
     @@Name:  getName
     @@Spec:
       @@@DOM3:
         http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#NameList-getName
     @@Description:
        @@@lang:en
        @@@@: Return the "index"th name item in the collection.
     @@Param:
        @@@Name:  index
        @@@Type:  unsigned-long
        @@@Description:
          @@@@lang:en
          @@@@@: The index into the collection.
        @@@InCase:
          @@@@Value: 0
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The first item.
        @@@InCase:
          @@@@Label: "length" - 1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The last item.
     @@Return:
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The name at the "index"th position in the "NameList".
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
            There is no name for the specified "index" or
            the "index" is out of range.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
          if (not defined $index or
              $index < 0 or
              $index > $#$self) {
            $r = null;
          } else {
            __INT__;
          }
        @@@IntDef:
          @@@@Type:
            lang:Perl
          @@@@@:
          $r = $self->[$index]->{name};
  @Method:
     @@Name:  getNamespaceURI
     @@Spec:
       @@@DOM3:
         http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#NameList-getNamespaceURI
     @@Description:
       @@@lang:en
       @@@@: Return the "index"th namespace URI item in the collection.
     @@Param:
        @@@Name:  index
        @@@Type:  unsigned-long
        @@@Description:
          @@@@lang:en
          @@@@@: The index into the collection.
        @@@InCase:
          @@@@Value: 0
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The first item.
        @@@InCase:
          @@@@Label: "length" - 1
          @@@@Description: 
            @@@@@lang:en
            @@@@@@: The last item.
     @@Return:
        @@@Type:
          ManakaiDOM:ManakaiDOMNamespaceURI
        @@@Description:
          @@@@lang:en
          @@@@@: The namespace URI at the "index" position in the "NameList".
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
            There is no namespace URI for the specified "index" or 
            if the "index" is out of range.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
          if (not defined $index or
              $index < 0 or
              $index > $#$self) {
            $r = null;
          } else {
            __INT__;
          }
        @@@IntDef:
          @@@@Type:
            lang:Perl
          @@@@@:
          $r = $self->[$index]->{nsURI};
  @Attr:
     @@Name:  length
     @@Spec:
       @@@DOM3:
         http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#NameList-length
     @@Description:
       @@@lang:en
       @@@@: 
         The number of name and namespace URI pairs in the list.
     @@Get:
        @@@Type:  unsigned-long
        @@@Description:
          @@@@lang:en
          @@@@@: The number of pairs.
        @@@Def:
          $r = @$self;
  @Method:
     @@Name:  contains
     @@Spec:
       @@@DOM3:
         http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#NameList-contains
     @@Description:
       @@@lang:en
       @@@@: Test if a name is part of the collection.
     @@Param:
        @@@Name:  str
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The name to look for.
     @@Return:
        @@@Type:  boolean
        @@@InCase:
          @@@@Value: true
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The name has been found.
        @@@InCase:
          @@@@Value: false
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The name has not been found.
        @@@Def:
          $r = false;
          CHK: {
            __DEEP{
              for (@$self) {
                if ($str eq $_->{name}) {
                  $r = true;
                  last CHK;
                }
              }
            }__;
          }
  @Method:
     @@Name:  containsNS
     @@Spec:
       @@@DOM3:
         http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#NameList-containsNS
     @@Description:
       @@@lang:en
       @@@@: 
         Test if the pair of namespace URI and name is part of the collection.
     @@Param:
        @@@Name:  namespaceURI
        @@@Type:
          ManakaiDOM:ManakaiDOMNamespaceURI
        @@@Description:
          @@@@lang:en
          @@@@@: The namespace URI to look for.
     @@Param:
        @@@Name:  name
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The name to look for.
     @@Return:
        @@@Type:  boolean
        @@@InCase:
          @@@@Value: true
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The pair has been found.
        @@@InCase:
          @@@@Value: false
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The pair has not been found.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
          $r = false;
          CHK: {
            __DEEP{
              for (@$self) {
                if ($namespaceURI eq $_->{nsURI} and
                    $name eq $_->{name}) {
                  $r = true;
                  last CHK;
                }
              }
            }__;
          }

IF:
  @Name:  DOMImplementationList
  @Level[list]:  3
  @SpecLevel:3
  @Spec:
    @@DOM3:
      http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#DOMImplementationList
  @Description:
    @@lang:en
    @@@: 
      An ordered collection of DOM implementations.
  @ImplNote:
    @@lang:en
    @@@:
      How this collection is implemented is not specified by the specification.
  @Method:
     @@Name:  item
     @@Spec:
       @@@DOM3:
         http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#DOMImplementationList-item
     @@Description:
       @@@lang:en
       @@@@: Return the "index"th item in the collection.
     @@Param:
        @@@Name:  index
        @@@Type:  unsigned-long
        @@@Description:
          @@@@lang:en
          @@@@@: The index into the collection.
        @@@InCase:
          @@@@Value: 0
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The first item.
        @@@InCase:
          @@@@Label: "length" - 1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The last item.
     @@Return:
        @@@Type:  DOMImplementation
        @@@Description:
          @@@@lang:en
          @@@@@: 
            The "DOMImplementation" at the "index"th position in 
            the collection.
        @@@InCase:
          @@@@Value: null
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              There is no "DOMImplementation" for the specified "index", 
              or the "index" is out of range.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
          if (not defined $index or
              $index < 0 or
              $index > $#$self) {
            $r = null;
          } else {
            __INT__;
          }
        @@@IntDef:
          @@@@Type:
            lang:Perl
          @@@@@:
          $r = $self->[$index];
  @Attr:
     @@Name:  length
     @@Description:
       @@@lang:en
       @@@@: The number of "DOMImplementation"s in the list.
     @@Spec:
       @@@DOM3:
         http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#DOMImplementationList-length
     @@Get:
        @@@Type:  unsigned-long
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            $r = @$self;
  @IntMethod:
    @@Name: new
    @@Description:
      @@@lang:en
      @@@@: Construct a new instance of the "DOMImplementationList".
    @@Return:
      @@@Type: DOMImplementationList
      @@@Description:
        @@@@lang:en
        @@@@@: The new instance constructed.
      @@@Def:
        @@@@Type:
          lang:Perl
        @@@@@:
          $r = bless [], ref $self ? ref $self : $self;
  @IntMethod:
    @@Name: add
    @@Description:
      @@@lang: en
      @@@@:
        Add one or more <IF:DOMImplementation> objects to this list.
    @@Param:
      @@@Name: list
      @@@Type: DOMImplementationList
      @@@Description:
        @@@@lang:en
        @@@@@:
          A list of <IF:DOMImplementation> objects to add.
      @@@InCase:
        @@@@Label:
          One or more <IF:DOMImplementation> and/or 
          <IF:DOMImplementationList> objects
        @@@@Description:
           @@@@@lang:en
           @@@@@@:
           \  <IF:DOMImplementation> objects to add.
         @@@@For:
           lang:Perl
    @@Return:
      @@@Exception:
        @@@@Type:
          ManakaiDOM:ManakaiDOMImplementationException
        @@@@Name: MDOM_TYPE_MISMATCH_ERR
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The <P:list> or its item is not a <IF:DOMImplementation> object.
      @@@Def:
        @@@@Type:
          lang:Perl
        @@@@auto-argument: 0
        @@@@@:
          my $self = shift;
          for (@_) {
            if ($_->isa ("__IIF{DOMImplementationList::}__")) {
              push @$self, @$_;
            } elsif ($_->isa ("__IIF{DOMImplementation::}__")) {
              push @$self, $_;
            } elsif ($_->isa ("__IF{DOMImplementationList}__")) {
              __DEEP{
                my $len = $_->length; 
                for (my $i = 0; $i < $len; $i++) {
                  push @$self, $_->item ($i);
                }
              }__;
            } elsif ($_->isa ("__IF{DOMImplementation}__")) {
              push @$self, $_;
            } else {
              __EXCEPTION{ManakaiDOMImplementationException.
                          MDOM_TYPE_MISMATCH_ERR::
                <Q:MDOM_EXCEPTION:param-name> => 'list',
                <Q:MDOM_EXCEPTION:class> => ref $_,
              }__;
            }
          }

IF:
  @Name:  DOMImplementationSource
  @Level[list]:  3
  @SpecLevel:3
  @Description:
    @@lang:en
    @@@:
      This interface provides access to DOM implementations available.
  @Spec:
    @@DOM3:
      http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#DOMImplementationSource

  @Role:
    DOMCore:DOMImplementationSource

  @Method:
     @@Name:  getDOMImplementation
     @@Spec:
       @@@DOM3:
         http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-getDOMImpl
     @@Description:
        @@@lang:en
        @@@@: 
          Return the first DOM implementation that supports the specified 
          features and versions.
     @@Param:
        @@@Name:  features
        @@@Type:
          ManakaiDOM:ManakaiDOMFeatures
        @@@Description:
          @@@@lang:en
          @@@@@:
            A string that specifies which features and versions are 
            required.
     @@Return:
        @@@Type:  DOMImplementation
        @@@Description:
          @@@@lang:en
          @@@@@: 
            The first DOM implementation that support the desired 
            features and versions.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: 
              This source has no DOM implementation that supports the 
              desired features and versions.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            my %features;
            __CODE{ParseFeatures: in => features, out => features}__;
            for my $class (reverse @{$__PACKAGE{Global}__::Role{<Q:DOMCore:DOMImplementation>}||{}}) {
              if (my $new = $class->{class}->can ('new')) {
                if ($class->{class}->__INT{SP:classHasFeature}__ (%features)) {
                  $r = $new->($class->{class});
                }
                last;
              }
            }
  @Method:
     @@Name:  getDOMImplementationList
     @@Description:
       @@@lang:en
       @@@@:
         Return a list of DOM implementations that support the specified 
         features and versions.
     @@Param:
        @@@Name:  features
        @@@Type:
          ManakaiDOM:ManakaiDOMFeatures
        @@@Description:
          @@@@lang:en
          @@@@@:
            A string that specifies which features and versions are required.
     @@Return:
        @@@Type:  DOMImplementationList
        @@@Description:
          @@@@lang:en
          @@@@@:
            A list of DOM implementations that support the desired 
            features and versions.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            my %features;
            __CODE{ParseFeatures: in => features, out => features}__;
                 ## Condition sensitive
            $r = __CLASS{DOMImplementationList}__->__INT{new}__;
            for my $class (reverse @{$__PACKAGE{Global}__::Role{<Q:DOMCore:DOMImplementation>}||{}}) {
              if (my $new = $class->{class}->can ('new')) {
                if ($class->{class}->__INT{SP:classHasFeature}__ (%features)) {
                  $r->__INT{add}__ ($new->($class->{class}));
                }
              }
            }
    @@Level:3
    @@SpecLevel:3

IF:
  @Name:  DOMImplementation
  @Spec:
    @@DOM3:
      http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-102161490
  @Description:
    @@lang:en
    @@@:
      This interface provides a number of methods for performing 
      operations that are independent of any particular instance 
      of the document object model.
  @Require:
    @@Module:
      @@@Def:
        @@@@Type:
          lang:Perl
        @@@@use:
          @@@@@@:
            Char::Class::XML
          @@@@@Import[list]:
            InXMLNameChar10
            InXML_NameStartChar10
            InXMLNCNameChar10
            InXML_NCNameStartChar10
    @@Condition[list]:
      DOM2
      DOM3

  @ISA:
    ManakaiDOM:ManakaiDOMNodeReference::
  @Role:
    @@@:
      DOMCore:DOMImplementation
    @@compat:
      ManakaiDOMCore:DOMImplementation

  @Method:
     @@Name:  hasFeature
     @@Spec:
       @@DOM3[list]:
         http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-5CED94D7
         http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#DOMFeatures
     @@Description:
       @@@lang:en
       @@@@:
         Test if the DOM implementation implements a specific feature 
         and version.
     @@Param:
        @@@Name:  feature
        @@@Type:
          ManakaiDOM:ManakaiDOMFeatureName
        @@@Description:
          @@@@lang:en
          @@@@@: The name of the feature to test.
        @@@InCase:
          @@@@Value: HTML
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The DOM HTML feature.
              This is one of the allowed values in DOM Level 1 First Edition.
        @@@InCase:
          @@@@Value: XML
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The DOM XML feature.
              This is one of the allowed values in DOM Level 1 First Edition.
        @@@InCase:
          @@@@Label: XML 1.0 Name
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Only an XML 1.0 Name is allowed in DOM Level 1 Second Edition 
              and DOM Level 2.
        @@@InCase:
          @@@@Label: Reversed Internet domain name
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              DOM Level 1 First Edition and DOM Level 2 specifications 
              says that the feature name defined outside the DOM specifications 
              should use the reversed Internet domain name to avoid 
              possible confliction.
            \
              This recommendation is withdrawn by the Errata of the DOM Level 2 
              Specifications.
        @@@InCase:
          @@@@Label:
            @@@@@lang:en
            @@@@@@:
              The feature name prepended by the PLUS SIGN ("+")
          @@@@Type: DOMString
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The specified feature may not be directly castable
              but would be available through the method "getFeature".
     @@Param:
        @@@Name:  version
        @@@Type:
          ManakaiDOM:ManakaiDOMFeatureVersion
        @@@Description:
          @@@@lang:en
          @@@@@:
            The version number of the feature to test.
        @@@IsOptional:1
        @@@InCase:
          @@@@Value: 1.0
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              DOM Level 1.
              This is the only allowed value in DOM Level 1 and
              one of allowed values in DOM Level 2.
        @@@InCase:
          @@@@Value: 2.0
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              DOM Level 2.
              This is one of allowed values in DOM Level 2.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              No particular version is specified.
              \
              It is implied that this value is allowed in DOM 
              Level 1 and Level 2.  DOM Level 2 Errata and DOM 
              Level 3 explicitly allow this value specified.
        @@@InCase:
          @@@@Value: \
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              No particular version is specified.
              \
              This value is allowed in DOM Level 2 Errata and 
              DOM Level 3.
     @@Return:
        @@@Type:  boolean
        @@@Description:
          @@@@lang:en
          @@@@@: Whether the feature is implemented or not.
        @@@InCase:
          @@@@Value: true
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The feature is implemented in the specified version.
        @@@InCase:
          @@@@Value: false
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The feature is not implemented.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            if (defined $feature) {
              undef $version if defined $version and not length $version;
              my $plus = 1 if $feature =~ s/^\+//;
              $r = $self->__INT{SP:classHasFeature}__
                             (lc $feature => {version => $version,
                                              plus => $plus});
            }
  @Method:
     @@Name:  createDocumentType
     @@Description:
       @@@lang:en
       @@@@:
         Create an empty "DocumentType" node.
     @@ImplNote:
       @@@lang:en
       @@@@: 
         HTML-only DOM Level 2 implementations do not need to implement 
         this method.
     @@NoNSVersion:\
     @@Param:
        @@@Name:  qualifiedName
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The qualified name of the document type to be created.
     @@Param:
        @@@Name:  publicId
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The external subset public identifier.
     @@Param:
        @@@Name:  systemId
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The external subset system identifier.
     @@SpecLevel: 2
     @@Level[list]:  
        2
        3
     @@Return:
        @@@Type:  DocumentType
        @@@Description:
          @@@@lang:en
          @@@@@: A new "DocumentType" node.
        @@@ImplNote:
          @@@@lang:en
          @@@@@: The "ownerDocument" attribute is set to "null".
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: INVALID_CHARACTER_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: 
              The "qualifiedName" is not an XML name 
              accoding to the XML 1.0 specification.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NAMESPACE_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The "qualifiedName" is malformed.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NOT_SUPPORTED_ERR
          @@@@SubType:
            @@@@@QName:
              MDOM_EXCEPTION:MDOM_IMPL_NOSUPPORT_XML
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
              The DOM implementation does not support the <DOM:XML> feature and 
              the language exposed through the <IF:Document> does not support 
              XML Namespaces.
        @@@Exception:
          @@@@Type: 
            ManakaiDOM:ManakaiDOMImplementationException
          @@@@Name: PARAM_NULL_POINTER
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The "qualifiedName" is the "null" value.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            __CODE{CheckNull: s => qualifiedName}__;
            __CODE{CheckQName: version => 1.0,
                               qname => qualifiedName}__; # [DOM 2,3]
            ## If namespace not supported: # [DOM 3]
            #__EXCEPTION{
            #  DOMException.NOT_SUPPORTED_ERR.
            #  MDOM_EXCEPTION:MDOM_IMPL_NOSUPPORT_XML::
            #}__;
            my ($prefix, $lname);
            if (($lname = $qualifiedName) =~ s/^([^:]+)://) {
              $prefix = $1;
            }
                        ## Condition sensitive
            my $node = __CLASS{DocumentType}__->__INT{newObject}__;
            $node->{<Q:infoset:prefix>} = $prefix;
            $node->{<Q:infoset:localName>} = $lname;
            $node->{<Q:infoset:publicIdentifier>} = $publicId;
            $node->{<Q:infoset:systemIdentifier>} = $systemId; 
            ## Note: No DOM Level 3 method/attribute provides access 
            ##       to the DOM implementation object when the "DocumentType" 
            ##       does not have the parent node (= owner "Document").
            $node->{<Q:DOMCore:implementation>} = $self;
            $node->{<Q:ManakaiDOM:implID>}
                        = $self->{<Q:TreeCore:node>}->{<Q:ManakaiDOM:implID>};
                 ## Condition sensitive
            $r = __CLASS{Node}__->__INT{getNodeReference}__ ($node);
  @Method:
     @@Name:  createDocument
     @@Description:
       @@@lang:en
       @@@@:
         Create a "Document" object of the specified type with its 
         document element.
     @@ImplNote:
       @@@lang:en
       @@@@: 
         The DOM Level 2 specification said that the HTML-only 
         implementations do not need to implement this method.
     @@ImplNote:
       @@@lang:en
       @@@@:
         Document creation is an operation specific to an 
         implementation in the DOM Level 1.
     @@NoNSVersion:\
     @@Param:
        @@@Name:  namespaceURI
        @@@Type:
          ManakaiDOM:ManakaiDOMNamespaceURI
        @@@Description:
          @@@@lang:en
          @@@@@: The namespace URI of the document element to create.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The null namespace name.
        @@@InCase:
          @@@@Value: \
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Considered as a namespace URI in DOM Level 2 or 
              treated as the "null" value in DOM Level 3.
     @@Param:
        @@@Name:  qualifiedName
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The qualified name of the document element to create.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: Document element is not created.
     @@Param:
        @@@Name:  doctype
        @@@Type:  DocumentType
        @@@Description:
          @@@@lang:en
          @@@@@: The type of document to create.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The document to be created does not have the "DocumentType" 
              node.
        @@@ImplNote:
          @@@@lang:en
          @@@@@:
            "doctype"."ownerDocument" is set to the document being 
            created unless "doctype" is "null".
     @@Return:
        @@@Type:  Document
        @@@Description:
          @@@@lang:en
          @@@@@:
            A new Document object.
          \
            Note that the object returned may be a specialized "Document" 
            object based on the "doctype" given.  For example. it might 
            implement the "HTMLDocument" interface.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: INVALID_CHARACTER_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The specified qualified name is not an XML name 
              accoding to the XML 1.0 specification.
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              DOM Level 3 specification defines to rely the XML 1.0 
              specification.  DOM Level 2 specification does not 
              explicitly defines but the definition for "INVALID_CHARACTER_ERR"
              refers the XML 1.0 specification.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NAMESPACE_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Either the "qualifiedName" is malformed, the "qualifiedName" 
              has a prefix and the "namespaceURI" is "null", the 
              "qualifiedName" is "null" and the "namespaceURI" is 
              different from "null", the "qualifiedName" has 
              a prefix that is "xml" and the "namespaceURI" is 
              different from "http://www.w3.org/XML/1998/namespace" or
              the DOM implementation does not support the "XML" feature 
              but a non-null "namespaceURI" is provided.
         @@@ImplNote:
           @@@@lang:en
           @@@@@:
              In addition, it is possible to raise an exception 
              either if the "qualifiedName" has a prefix that is 
              "xmlns" and the "namespaceURI" is different from 
              "http://www.w3.org/2000/xmlns/", if the "namespaceURI" 
              is "http://www.w3.org/XML/1998/namespace" and the 
              "qualifiedName" has a prefix is different from "xml" or 
              if the "namespaceURI" is "http://www.w3.org/2000/xmlns/" 
              and the "qualifiedName" has a prefix is different from "xmlns".
              But this DOM implementation only report a warning on 
              these cases since the specification does not mention 
              to raise any exception.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: WRONG_DOCUMENT_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The "doctype" has already been used with a different 
              document or was created from a different implementation.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NOT_SUPPORTED_ERR
          @@@@SubType:
            @@@@@QName:
              MDOM_EXCEPTION:MDOM_IMPL_NOSUPPORT_XML
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
              The DOM implementation does not support the <DOM:XML> feature and 
              the language exposed through the <IF:Document> does not support 
              XML Namespaces.
        @@@Exception:
          @@@@Type: 
            ManakaiDOM:ManakaiDOMImplementationException
          @@@@Name: MDOM_TYPE_MISMATCH_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: 
              The object specified to the "doctype" parameter is not a 
              "DocumentType".
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            my ($prefix, $lname);
            if (defined $qualifiedName) {     
                     ## Condition sensitive
              __CODE{CheckQName: version => 1.0,
                                 qname => qualifiedName}__; # [DOM 2,3]
              if (($lname = $qualifiedName) =~ s/^([^:]+)://) {
                $prefix = $1;
              }
              if (defined $namespaceURI) {    # ($uri, $qname, $doctype)
                ## If namespace not supported: # [DOM 3]
                #__EXCEPTION{
                #  DOMException.NOT_SUPPORTED_ERR.
                #  MDOM_EXCEPTION:MDOM_IMPL_NOSUPPORT_XML::
                #}__;
              } else {                        # (null, $qname, $doctype)
                if ($prefix) {
                  __EXCEPTION{
                    DOMException.NAMESPACE_ERR.
                    MDOM_EXCEPTION:MDOM_NS_PREFIX_WITH_NULL_URI::
                      <Q:infoset:prefix> => $prefix,
                  }__;                        # [DOM 2,3]
                }
              }
            } elsif (defined $namespaceURI) { # ($uri, null, $doctype)
              __EXCEPTION{
                DOMException.NAMESPACE_ERR.
                MDOM_EXCEPTION:MDOM_NS_NULL_QNAME_WITH_NON_NULL_URI::
                  <Q:infoset:namespaceName> => $namespaceURI,
              }__;                            # [DOM 3]
            }
            if (not $prefix) {
              if ($prefix eq 'xml' and 
                  (not $namespaceURI or
                   $namespaceURI ne q<http://www.w3.org/XML/1998/namespace>)) {
                __EXCEPTION{
                  DOMException.NAMESPACE_ERR.
                  MDOM_EXCEPTION:MDOM_NS_XML_WITH_OTHER_URI::
                    <Q:infoset:namespaceName> => $namespaceURI,
                }__;                          # [DOM 2,3]
              } elsif ($prefix eq 'xmlns' and
                  (not $namespaceURI or
                   $namespaceURI ne q<http://www.w3.org/2000/xmlns/>)) {
                __WARNING{
                  ManakaiDOMImplementationWarning.MDOM_WARN_NAMESPACE_ERR.
                  MDOM_EXCEPTION:MDOM_NS_XMLNS_WITH_OTHER_URI::
                    <Q:infoset:namespaceName> => $namespaceURI,
                }__;                          # DOM doesn't specify this
              }
            }
            if (defined $namespaceURI) {
              if ($namespaceURI eq q<http://www.w3.org/XML/1998/namespace> and
                  (not $prefix or $prefix ne 'xml')) {
                __WARNING{
                  ManakaiDOMImplementationWarning.MDOM_WARN_NAMESPACE_ERR.
                  MDOM_EXCEPTION:MDOM_NS_OTHER_WITH_XML_URI::
                    <Q:infoset:prefix> => $prefix,
                }__;                          # DOM doesn't specify this
              } elsif ($namespaceURI eq q<http://www.w3.org/2000/xmlns/> and
                  (not $prefix or $prefix ne 'xmlns')) {
                __WARNING{
                  ManakaiDOMImplementationWarning.MDOM_WARN_NAMESPACE_ERR.
                  MDOM_EXCEPTION:MDOM_NS_OTHER_WITH_XMLNS_URI::
                    <Q:infoset:prefix> => $prefix,
                }__;                          # DOM doesn't specify this
              }
            }
 \## ISSUE: Should be exception not warning ("malformed"!)
 \## ISSUE: Should be "xmlns" and "xmlns:xmlns" checked
                       ## Condition sensitive
            my $node = __CLASS{Document}__->__INT{newObject}__; 
            $node->{<Q:DOMCore:implementation>} = $self;
            $node->{<Q:ManakaiDOM:implID>}
                = $self->{<Q:TreeCore:node>}->{<Q:ManakaiDOM:implID>};
            if ($doctype) {
              if (not $doctype->isa ('__IIF{DocumentType::}__')) {
                __EXCEPTION{
                  ManakaiDOMImplementationException.MDOM_TYPE_MISMATCH_ERR::
 \## TODO: Should be HIERARCHY error?
                    <Q:MDOM_EXCEPTION:param-name> => q<doctype>,
                    <Q:MDOM_EXCEPTION:class> => ref $doctype,
                }__;
              }
              my $doctypeNode = $doctype->{<Q:TreeCore:node>};
              if ($node->{<Q:TreeCore:treeID>} ne
                  $doctypeNode->{<Q:TreeCore:treeID>} or
                  $doctypeNode->{<Q:DOMCore:ownerDocument>} or
                  $doctypeNode->{<Q:ManakaiDOM:implID>} ne 
                    $node->{<Q:ManakaiDOM:implID>}) {
                __EXCEPTION{
                  DOMException.WRONG_DOCUMENT_ERR::
                }__;                          # [DOM 2,3]
              }
              $doctypeNode
                   ->__SUPER{ManakaiDOMNodeObject::}__::__INT{importTree}__
                                                                     ($node);
              $doctypeNode->{<Q:DOMCore:ownerDocument>} = $node;
              $doctypeNode->{<Q:infoset:parent>} = $node;
              push @{$node->{<Q:infoset:children>}}, $doctypeNode;
            }
            if ($lname) { ## Condition sensitive
              my $docEl = __CLASS{Element}__->__INT{new}__;
              my $docNode = $docEl->{<Q:TreeCore:node>};
              $node->__SUPER{ManakaiDOMNodeObject::}__->__INT{importTree}__
                                                        ($docNode);
              $docNode->{<Q:infoset:prefix>} = $prefix;
              $docNode->{<Q:infoset:namespaceName>} = $namespaceURI;
              $docNode->{<Q:infoset:localName>} = $lname;
              $docNode->{<Q:infoset:parent>} = $node;
              push @{$node->{<Q:infoset:children>}}, $docNode;
            }
                 ## Condition sensitive
            $r = __CLASS{Node}__->__INT{getNodeReference}__ ($node);
     @@SpecLevel:2
     @@Level[list]:
       2
       3
        
  @Method:
     @@Name:  getFeature
     @@Description:
        @@@lang:en
        @@@@: 
          Return a specialized object that implements the specialized 
          APIs of the specified feature and version.
     @@Param:
        @@@Name:  feature
        @@@Type:
          ManakaiDOM:ManakaiDOMFeatureName
        @@@Description:
          @@@@lang:en
          @@@@@:
            The name of the feature requested.
        @@@InCase: 
          @@@@Label: 
            The feature name prepended by the <CHAR:PLUS SIGN> (<DOM:+>)
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              An <CHAR:PLUS SIGN> before the feature name is ignored.
     @@Param:
        @@@Name:  version
        @@@Type:
          ManakaiDOM:ManakaiDOMFeatureVersion
        @@@Description:
          @@@@lang:en
          @@@@@:
            The version number of the feature to test.
     @@SpecLevel:3
     @@Level[list]:  3
     @@Return:
        @@@Type:  DOMObject
        @@@Description:
          @@@@lang:en
          @@@@@:
            An object that implements the specialized APIs of the 
            specified feature and version.  That might or might not 
            implements the <IF:DOMImplementation> interface.
        @@@InCase:
          @@@@Type: DOMImplementation
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              An object that implements both the specialized APIs 
              and the <IF:DOMImplementation> interface.
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              This kind of object must delegate to the primary core 
              <IF:DOMImplementation> and not return results inconsistent 
              with the primary core <IF:DOMImplementation> such as 
              <M:hasFeature>, <M:getFeature>, etc.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@@: 
            There is no object that implements interfaces associated 
            with the feature and version.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            if (defined $feature) {
              undef $version if defined $version and not length $version;
              my $plus = 1 if $feature =~ s/^\+//;
              $feature = lc $feature;
              for (reverse @{$__PACKAGE{Global}__::Role{
                     <Q:DOMCore:DOMImplementation>}||[]}) {
                if ($_->{compat} eq <Q:ManakaiDOMCore:DOMImplementation>) {
                  if ($_->{class}->__INT{SP:classHasFeature}__
                                     ($feature => {version => $version})) {
                    $r = $self->{<Q:TreeCore:node>}
                              ->__SUPER{ManakaiDOMNodeObject::}__::__INT{newReference}__
                                     ($_->{class});
                    last;
                  }
                }
              }
            }

  @IntMethod:
    @@Name:new
    @@Operator:
      @@@@:new
      @@@Type:
        lang:Perl
    @@Description:
      @@@lang:en
      @@@@:
        Construct a new instance of the <IF:DOMImplementation>.
    @@Return:
      @@@Type: DOMImplementation
      @@@Description:
        @@@@lang:en
        @@@@@:The new DOM implementation object.
      @@@Def:
        @@@@Type:
            lang:Perl
        @@@@@:
            my $node = __CLASS{ManakaiDOMNodeObject::}__->__INT{new}__;
            $r = $node->__SUPER{ManakaiDOMNodeObject::}__::__INT{newReference}__
                                                                   ($self);
            $node->{<Q:ManakaiDOM:implID>} = $node->{<Q:TreeCore:nodeID>};
      
##IF:DOMImplementation

IF:
  @Name:  Node
  @Description:
    @@lang:en
    @@@:
      The primary datatype for the entire Document Object Model, 
      that represents a single node in the document tree.
  @ISA:
    ManakaiDOM:ManakaiDOMNodeReference::
  @ImplNote:
    @@lang:en
    @@@:
      "Attr", "Element", "Document", "DocumentFragment", "DocumentType", 
      "Entity", "EntityReference", "Notation", "ProcessingInstriction" 
      and "CharacterData" are "Node".  "Comment" and "Text" are 
      "CharacterData".  "CDATASection" is a "Text".
  @IsFinal:-1
  @ConstGroup:
     @@Name:  NodeType
     @@Description:
       @@@lang:en
       @@@@: An integer indicating which type of node this is.
     @@ImplNote:
       @@@lang:en
       @@@@: Codes <= 200 are reserved to W3C for possible future use.
     @@Const:
        @@@Name:  ELEMENT_NODE
        @@@Type:  unsigned-short
        @@@Value:  1
        @@@Description:
          @@@@lang:en
          @@@@@: The node is an "Element".
     @@Const:
        @@@Name:  ATTRIBUTE_NODE
        @@@Type:  unsigned-short
        @@@Value:  2
        @@@Description:
          @@@@lang:en
          @@@@@: The node is an "Attr".
     @@Const:
        @@@Name:  TEXT_NODE
        @@@Type:  unsigned-short
        @@@Value:  3
        @@@Description:
          @@@@lang:en
          @@@@@: The node is a "Text".
     @@Const:
        @@@Name:  CDATA_SECTION_NODE
        @@@Type:  unsigned-short
        @@@Value:  4
        @@@Description:
          @@@@lang:en
          @@@@@: The node is a "CDATASection".
     @@Const:
        @@@Name:  ENTITY_REFERENCE_NODE
        @@@Type:  unsigned-short
        @@@Value:  5
        @@@Description:
          @@@@lang:en
          @@@@@: The node is an "EntityReference".
     @@Const:
        @@@Name:  ENTITY_NODE
        @@@Type:  unsigned-short
        @@@Value:  6
        @@@Description:
          @@@@lang:en
          @@@@@: The node is an "Entity".
     @@Const:
        @@@Name:  PROCESSING_INSTRUCTION_NODE
        @@@Type:  unsigned-short
        @@@Value:  7
        @@@Description:
          @@@@lang:en
          @@@@@: The node is a "ProcessingInstruction".
     @@Const:
        @@@Name:  COMMENT_NODE
        @@@Type:  unsigned-short
        @@@Value:  8
        @@@Description:
          @@@@lang:en
          @@@@@: The node is a "Comment".
     @@Const:
        @@@Name:  DOCUMENT_NODE
        @@@Type:  unsigned-short
        @@@Value:  9
        @@@Description:
          @@@@lang:en
          @@@@@: The node is a "Document".
     @@Const:
        @@@Name:  DOCUMENT_TYPE_NODE
        @@@Type:  unsigned-short
        @@@Value:  10
        @@@Description:
          @@@@lang:en
          @@@@@: The node is a "DocumentType".
     @@Const:
        @@@Name:  DOCUMENT_FRAGMENT_NODE
        @@@Type:  unsigned-short
        @@@Value:  11
        @@@Description:
          @@@@lang:en
          @@@@@: The node is a "DocumentFragment".
     @@Const:
        @@@Name:  NOTATION_NODE
        @@@Type:  unsigned-short
        @@@Value:  12
        @@@Description:
          @@@@lang:en
          @@@@@: The node is a "Notation".
  @Attr:
     @@Name:  nodeName
     @@Description:
        @@@lang:en
        @@@@: The node name.
     @@NSVersion[list]:
       Node.prefix
       Node.localName
     @@Get:
        @@@Type:  DOMString
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@: $r = null;
     @@RedefinedBy: Attr
     @@RedefinedBy: CDATASection
     @@RedefinedBy: Comment
     @@RedefinedBy: Document
     @@RedefinedBy: DocumentFragment
     @@RedefinedBy: DocumentType
     @@RedefinedBy: Element
     @@RedefinedBy: Entity
     @@RedefinedBy: EntityReference
     @@RedefinedBy: Notation
     @@RedefinedBy: ProcessingInstruction
     @@RedefinedBy: Text
  @Attr:
     @@Name:  nodeValue
     @@Description:
       @@@lang:en
       @@@@: The value of this node.
     @@Get:
        @@@Type:  DOMString
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: DOMSTRING_SIZE_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: 
              The attribute would return more characters than fit in 
              a DOMString variable on the implementation platform.
        @@@Def:
          @@@@Type: 
            lang:Perl
          @@@@@: $r = null;
     @@Set:
        @@@Type:  DOMString
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: 
              The node is read-only and the node is not defined to be "null".
        @@@Description:
          @@@@lang:en
          @@@@@:
            New node value.
            Note that setting this attribute has no effect if 
            the node value is defined to be "null".
        @@@Warning:
          @@@@Type: 
            ManakaiDOM:ManakaiDOMImplementationWarning
          @@@@Name: ATTR_SET_NO_EFFECT
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Setting this attribute has no effect since the node 
              value is defined to be "null".
        @@@ImplNote:
          @@@@lang:en
          @@@@@:
            Don't raise an exception even if the node is read-only when 
            the node value is defined to be "null".  Note that 
            "even if read-only" has been clarified by the DOM Level 2 Errata.
        @@@Def: \
    @@RedefinedBy: Attr
    @@RedefinedBy: CharacterData
    @@RedefinedBy: ProcessingInstruction
  @Attr:
     @@Name:  nodeType
     @@Description:
       @@@lang:en
       @@@@: The type of this node.
     @@Get:
        @@@Type:  unsigned-short
        @@@Description:
          @@@@lang:en
          @@@@@: The code representing the type of the underlying object.
        @@@Def: \
     @@RedefinedBy: Attr
     @@RedefinedBy: CDATASection
     @@RedefinedBy: Comment
     @@RedefinedBy: Document
     @@RedefinedBy: DocumentFragment
     @@RedefinedBy: DocumentType
     @@RedefinedBy: Element
     @@RedefinedBy: Entity
     @@RedefinedBy: EntityReference
     @@RedefinedBy: Notation
     @@RedefinedBy: ProcessingInstruction
     @@RedefinedBy: Text
  @Attr:
     @@Name:  parentNode
     @@Description:
       @@@lang:en
       @@@@: The parent of this node.
     @@Get:
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@: The parent node.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The node does not have a parent since its type is either 
              "Attr", "Document", "DocumentFragment", "Entity", 
              or "Notation", since it has just been created 
              and not yet added, or since it has been removed from the tree.
        @@@Def:
          @@@@Type:
            lang:dis
                     ## Conditional
          @@@@GetPropNode:
            infoset:parent
    @@Level[list]:
      1
      2
      3
    @@SpecLevel:1
  @Attr:
     @@Name:  childNodes
     @@Description:
       @@@lang:en
       @@@@:
         A list of node that contains all children of this node if any.
     @@Get:
        @@@Type:
          ManakaiDOM:ManakaiDOMChildNodeList
        @@@Description:
          @@@@lang:en
          @@@@@:
            A <IF:NodeList> object.
        @@@InCase:
          @@@@Label:
            @@@@@lang:en
            @@@@@@:
              A <IF:NodeList> containing no nodes
          @@@@Type:
            ManakaiDOM:ManakaiDOMChildNodeList
          @@@@Description:
            @@@@@lang:en
            @@@@@@: This node has no child node.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            $r = $self->{<Q:TreeCore:node>}->
                   __SUPER{ManakaiDOMNodeObject::}__::__INT{newReference}__
                         ## Condition sensitive
                        ('__CLASS{ManakaiDOMChildNodeList}__');
     @@SpecLevel:1
     @@Level[list]:
       1
       2
       3
  @Attr:
     @@Name:  firstChild
     @@Description:
       @@@lang:en
       @@@@: The first child of this node.
     @@Get:
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@: The first child node.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: There is no child node.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            $r = $self->{<Q:TreeCore:node>}->{<Q:infoset:children>}->[0];
                      ## Condition sensitive
            $r = $r ? __CLASS{Node}__->__INT{getNodeReference}__ ($r)
                    : null;
    @@Level[list]:
      1
      2
      3
    @@SpecLevel:1
  @Attr:
     @@Name:  lastChild
     @@Description:
        @@@lang:en
        @@@@: The last child of this node.
     @@Get:
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@: The last child node.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: There is no child node.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            $r = $self->{<Q:TreeCore:node>}->{<Q:infoset:children>}->[-1];
                      ## Condition sensitive
            $r = $r ? __CLASS{Node}__->__INT{getNodeReference}__ ($r)
                    : null;
     @@Level[list]:
        1
        2
        3
     @@SpecLevel:1
  @Attr:
     @@Name:  previousSibling
     @@Description:
        @@@lang:en
        @@@@:
          The node immediately preceding this node.
     @@Get:
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@: The node immediately preceding this node.
        @@@InCase:
          @@@@Value:
             @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: There is no such node.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            if (my $parent = $self->{<Q:TreeCore:node>}->{<Q:infoset:parent>}) {
              for (@{$parent->{<Q:infoset:children>}}) {
                if ($_->{<Q:TreeCore:nodeID>} eq
                         $self->{<Q:TreeCore:node>}->{<Q:TreeCore:nodeID>}) {
                  last;
                } else {
                  $r = $_;
                }
              }
            }
            if ($r) {
                   ## Condition sensitive
              $r = __CLASS{Node}__->__INT{getNodeReference}__ ($r);
            }
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              This code will return incorrect answer if the infoset:children 
              of the infoset:parent does not have "this" node 
              (i.e. the tree is broken).
    @@Level[list]:
      1
      2
      3
    @@SpecLevel:1
  @Attr:
     @@Name:  nextSibling
     @@Description:
        @@@lang:en
        @@@@: The node immediately following this node.
     @@Get:
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@: The node immediately following this node.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: There is no such node.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            if (my $parent = $self->{<Q:TreeCore:node>}->{<Q:infoset:parent>}) {
              my $next = 0;
              for (@{$parent->{<Q:infoset:children>}}) {
                if ($next) {
                       ## Condition sensitive
                  $r = __CLASS{Node}__->__INT{getNodeReference}__ ($_);
                  last;
                } elsif ($_->{<Q:TreeCore:nodeID>} eq
                         $self->{<Q:TreeCore:node>}->{<Q:TreeCore:nodeID>}) {
                  $next = 1;
                }
              }
            }
    @@Level[list]:
      1
      2
      3
    @@SpecLevel:1
  @Attr:
     @@Name:  attributes
     @@Description:
       @@@lang:en
       @@@@:
         A node map containing the attributes of this node.
     @@Get:
        @@@Type: NamedNodeMap
        @@@Description:
          @@@@lang:en
          @@@@@:
            A (possibly empty) <IF:NamedNodeMap> object.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              This node is not of type <IF:Element>.
        @@@Def:\
    @@RedefinedBy:Element
  @Attr:
     @@Name:  ownerDocument
     @@Description:
       @@@lang:en
       @@@@:
         The "Document" object associated with this node.
     @@Get:
        @@@Type:  Document
        @@@Description:
          @@@@lang:en
          @@@@@: The "Document" object associated with this node.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The node is a "Document" or the node is a "DocumentType" 
              that is not used with any "Document" yet.
        @@@Def:
          @@@@Type:
            lang:dis
                         ## Condition sensitive
          @@@@GetPropNode:
            DOMCore:ownerDocument
     @@SpecLevel[list]:
        1
        2
     @@Level[list]:
        1
        2
        3
     @@ImplNote:
        @@@lang:en
        @@@@:
          The DOM Level 1 specification does not take the "DocumentType" 
          without any "Document" into account since DOM Level 1 
          does not have "createDocumentType" so that no "DocumentType" 
          object can be exist without its parent of the "Document".
  @Method:
     @@Name:  insertBefore
     @@Description:
       @@@lang:en
       @@@@:
         Insert a node before the existing child node.
     @@Param:
        @@@Name:  newChild
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@:
            The node to insert.  If the "newChild" node is already 
            in the tree, it is first removed.
        @@@InCase:
          @@@@Type: DocumentFragment
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              All of the children are inserted, in the same order. 
              After the insertion, the children list of the 
              "newChild" is empty.
          @@@@SpecLevel: 1
     @@Param:
        @@@Name:  refChild
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@:
            The reference node.  The "newChild" node is inserted before 
            the "refChild" node.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The "newChild" is inserted at the end of the list of children. 
        @@@InCase:
          @@@@Label: Same as "newChild"
          @@@@Description:
            @@@@@lang:en
            @@@@@@: Inserting a node before itself is implementation dependent.
          @@@@SpecLevel:3
     @@Return:
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@: The node being inserted.
        @@@ImplNote:
          @@@@lang:en
          @@@@@:
            What should be returned when the "newChild" is a "DocumentFragment" 
            is unclear.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: HIERARCHY_REQUEST_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: 
              Either this node is of a type that does not allow 
              children of the type of the "newChild" node [DOM 1, 2, 3],
              the node to insert is one of ancestors of this node 
              [DOM 1, 2, 3], the node to insert is this node itself
              [DOM 2 Errata, 3], or this node is of type "Document" 
              and the attemption 
              to insert a second "DocumentType" or "Element" node 
              is made [DOM 3].
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@: 
              Special treatment required if it is a "DocumentFragment".
              Whether the node is hierarchically valid must be 
              ensured for each child nodes.
            \
              For example, the attemption to add more than one elements 
              using "DocumentFragment" to the empty "Document" must 
              be detected.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: WRONG_DOCUMENT_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The "newChild" node was created from a different 
              document.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Either this node is read-only [DOM 1, 2, 3] or the parent of 
              the node being inserted is read-only [DOM 1 SE, 2, 3].
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NOT_SUPPORTED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              This node is of type "Document" and the DOM implementation 
              does not support the insertion of a "DocumentType" or 
              "Element" node.
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              While the specification does not address, 
              in case that the parent of the "newChild" is a "Document" 
              and the DOM implementation does not support the 
              removal from it, this error should also be raised.
          @@@@SpecLevel:3
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            my $node;
            my $newNode;
            CHKDOC: {
              if (ref $newChild and $newChild->isa ('__IIF{Node::}__')) {
                $node = $self->{<Q:TreeCore:node>};
                $newNode = $newChild->{<Q:TreeCore:node>};
                if ($node->{<Q:DOMCore:ownerDocument>}) {
                  if ($newNode->{<Q:DOMCore:ownerDocument>}) {
                    last CHKDOC if $node->{<Q:DOMCore:ownerDocument>}
                                        ->{<Q:TreeCore:nodeID>} eq
                                   $newNode->{<Q:DOMCore:ownerDocument>}
                                        ->{<Q:TreeCore:nodeID>};
                  }
                } else { ## I'm "Document" or "DocumentType" node.
                  if ($node->{<Q:DOMCore:nodeType>} eq <Q:infoset:Document>) {
                    last CHKDOC;
                  }
                }
              }
              __EXCEPTION{
                DOMException.WRONG_DOCUMENT_ERR::
                  <Q:MDOM_EXCEPTION:param-name> => 'newChild',
              }__;
            } # CHKDOC
            my @newNode = ($newNode);
            if ($newNode->{<Q:DOMCore:nodeType>} eq
                <Q:DOMCore:DocumentFragment>) {
       \       @newNode = @{$newNode->{<Q:infoset:children>}};
            }
            if (@newNode) {
              my $parentNode = $newNode[0]->{<Q:infoset:parent>};

              ## Read-only?
              if ($node->{<Q:DOMCore:read-only>}) {
                ## This node is read-only.
                __EXCEPTION{
                  DOMException.NO_MODIFICATION_ALLOWED_ERR.
                  MDOM_EXCEPTION:NOMOD_THIS::
                }__;
              } elsif ($parentNode and $parentNode->{<Q:DOMCore:read-only>}) {
                ## Parent of new node(s) is read-only
                __EXCEPTION{
                  DOMException.NO_MODIFICATION_ALLOWED_ERR.
                  MDOM_EXCEPTION:NOMOD_SRC_PARENT::
                    <Q:MDOM_EXCEPTION:param-name> => 'newChild',
                }__;
              }
              
              ## Check type of this node and new child node
              CHKTYPE: {
                if ({
                      <Q:infoset:Element> => 1,
                      <Q:DOMCore:DocumentFragment> => 1,
                      <Q:DOMXML:Entity> => 1,
                      <Q:DOMXML:EntityReference> => 1,
                    }->{$node->{<Q:DOMCore:nodeType>}}) {
                  CHILDTYPE: {
                    for (@newNode) {
                      unless ({
                            <Q:infoset:Element> => 1,
                            <Q:DOMCore:Text> => 1,
                            <Q:infoset:Comment> => 1,
                            <Q:infoset:ProcessingInstruction> => 1,
                            <Q:DOMXML:CDATASection> => 1,
                            <Q:DOMXML:EntityReference> => 1,
                          }->{$_->{<Q:DOMCore:nodeType>}}) {
                        last CHILDTYPE;
                      }
                    }
                    last CHKTYPE; # No problem
                  }
                } elsif ($node->{<Q:DOMCore:nodeType>} eq <Q:infoset:Document>) {
                  CHILDTYPE: {
                    my %has;
                    EACHNEWNODE: for my $newNode (@newNode) {
                      if ({
                            <Q:infoset:Element> => 1,
                            <Q:infoset:DocumentTypeDeclaration> => 1,
                          }->{$newNode->{<Q:DOMCore:nodeType>}}) {
                        FOUND: {
                          if ($has{$newNode->{<Q:DOMCore:nodeType>}}) {
                            ## DOCTYPE or document element is waiting 
                            ## to be added
                            last FOUND;
                          }
                          for (@{$node->{<Q:infoset:children>}}) {
                            ## Document already has a DOCTYPE or doc.element
                            last FOUND if $_->{<Q:DOMCore:nodeType>} eq
                                          $newNode->{<Q:DOMCore:nodeType>};
                          }
                          $has{$newNode->{<Q:DOMCore:nodeType>}} = 1;
                          next EACHNEWNODE;
                        }
                        if ($newNode->{<Q:DOMCore:nodeType>} eq
                            <Q:infoset:Element>) {
                          __EXCEPTION{
                            DOMException.HIERARCHY_REQUEST_ERR.
                            MDOM_EXCEPTION:MDOM_SECOND_DOC_ELEMENT::
                              <Q:MDOM_EXCEPTION:param-name> => 'newChild',
                          }__;
                        } else { # <Q:infoset:DocumentTypeDeclaration>
                          __EXCEPTION{
                            DOMException.HIERARCHY_REQUEST_ERR.
                            MDOM_EXCEPTION:MDOM_SECOND_DOCTYPE::
                              <Q:MDOM_EXCEPTION:param-name> => 'newChild',
                          }__;
                        }
                      } elsif (not {
                                 <Q:infoset:Comment> => 1,
                                 <Q:infoset:ProcessingInstruction> => 1,
                               }->{$newNode->{<Q:DOMCore:nodeType>}}) {
                        last CHILDTYPE;
                      }
                    } # EACHNEWNODE
                    last CHKTYPE; # No problem
                  } # CHILDTYPE
                } elsif ($node->{<Q:DOMCore:nodeType>} eq
                         <Q:infoset:Attribute>) {
                  CHILDTYPE: {
                    for my $newNode (@newNode) {
                      unless ({
                            <Q:DOMCore:Text> => 1,
                            <Q:DOMXML:EntityReference> => 1,
                          }->{$newNode->{<Q:DOMCore:nodeType>}}) {
                        last CHILDTYPE;
                      }
                    }
                    last CHKTYPE; # No problem
                  }
                } # $node->{<Q:DOMCore:nodeType>}
                __EXCEPTION{
                  DOMException.HIERARCHY_REQUEST_ERR.
                  MDOM_EXCEPTION:HIERARCHY_BAD_TYPE::
                    <Q:infoset:nodeType> => $newNode->{<Q:infoset:nodeType>},
                    <Q:MDOM_EXCEPTION:param-name> => 'newChild',
                }__;
              } # CHKTYPE
              
              ## Check $newNode (not $newNode[0]) = ancestor-or-self::node()
              if ($node->{<Q:TreeCore:treeID>} eq
                  $newNode->{<Q:TreeCore:treeID>}) {
                my $n = $node;
                {
                  if ($newNode->{<Q:TreeCore:nodeID>} eq
                      $n->{<Q:TreeCore:nodeID>}) {
                    __EXCEPTION{
                      DOMException.HIERARCHY_REQUEST_ERR.
                      MDOM_EXCEPTION:HIERARCHY_ANCESTOR_OR_SELF::
                        <Q:MDOM_EXCEPTION:param-name> => 'newChild',
                    }__;
                  }
                  if ($n->{<Q:infoset:parent>}) {
                    $n = $n->{<Q:infoset:parent>};
                    redo;
                  }
                }
              }
              
              ## Seek the $refChild
              my $newIndex = @{$node->{<Q:infoset:children>}};
              REFCHILD: {
                if (defined $refChild) {
                  my $refID = $refChild->{<Q:TreeCore:node>}
                                       ->{<Q:TreeCore:nodeID>};
                  for my $i (0..$#{$node->{<Q:infoset:children>}}) {
                    if ($node->{<Q:infoset:children>}->[$i]
                             ->{<Q:TreeCore:nodeID>} eq $refID) {
                      $newIndex = $i;
                      last REFCHILD;
                    }
                  }
                  __EXCEPTION{
                    DOMException.NOT_FOUND_ERR::
                      <Q:MDOM_EXCEPTION:param-name> => 'refChild',
                  }__;
                }
              } # REFCHILD
              if ($newNode[0]->{<Q:infoset:parent>} and
                  $newNode[0]->{<Q:infoset:parent>}->{<Q:TreeCore:nodeID>} eq
                  $node->{<Q:TreeCore:nodeID>}) {
                if (@newNode > 1) {
                  __EXCEPTION{
                    ManakaiDOMImplementationException.MDOM_DEBUG_BUG::
                  }__;
                } elsif (ref $refChild and
                         $newNode[0]->{<Q:TreeCore:nodeID>} eq
                         $refChild->{<Q:TreeCore:node>}->{<Q:TreeCore:nodeID>}) {
                  __WARNING{
                    ManakaiDOMImplementationWarning.MDOM_NEWCHILD_IS_REFCHILD::
                      <Q:MDOM_EXCEPTION:newChild-param-name> => 'newChild',
                      <Q:MDOM_EXCEPTION:refChild-param-name> => 'refChild',
                  }__;
                  ## And no action.
                } else {
                  my $currentIndex;
                  for my $i (0..$#{$node->{<Q:infoset:children>}}) {
                    if ($node->{<Q:infoset:children>}->[$i]
                             ->{<Q:TreeCore:nodeID>} eq
                        $newNode[0]->{<Q:TreeCore:nodeID>}) {
                      $currentIndex = $i;
                    }
                  }
                  if ($newIndex < $currentIndex) {
                    delete $node->{<Q:infoset:children>}->[$currentIndex];
                    splice @{$node->{<Q:infoset:children>}},
                           $newIndex, 0, @newNode;
                  } else {
                    splice @{$node->{<Q:infoset:children>}},
                           $newIndex, 0, @newNode;
                    delete $node->{<Q:infoset:children>}->[$currentIndex];
                  }
                }
              } else { ## $newChild->parentNode ne $self
                for my $newNode (@newNode) {
                  delete $newNode->{<Q:infoset:parent>};
                  $node->__SUPER{ManakaiDOMNodeObject::}__::__INT{importTree}__
                                                                   ($newNode);
                  $newNode->{<Q:infoset:parent>} = $node;
                }
                splice @{$node->{<Q:infoset:children>}},
                       $newIndex, 0, @newNode;
              }
              
              if ($newNode->{<Q:DOMCore:nodeType>} eq
                  <Q:DOMCore:DocumentFragment>) {
                $newNode->{<Q:infoset:children>} = [];
              } elsif ($parentNode) {
                for my $i (0..$#{$parentNode->{<Q:infoset:children>}}) {
                  if ($parentNode->{<Q:infoset:children>}->[$i]
                                 ->{<Q:TreeCore:nodeID>} eq
                      $node->{<Q:TreeCore:nodeID>}) {
                    delete $parentNode->{<Q:infoset:children>}->[$i];
                    last;
                  }
                }
              }
            } # @newNode
            $r = $newChild;
     @@Level[list]:
        1
     @@SpecLevel[list]:
        1
        3
  @Method:
     @@Name:  replaceChild
     @@Description:
        @@@lang:en
        @@@@:
          Replace a child node with the other node.
     @@Param:
        @@@Name:  newChild
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@:
            The new node to put in the child list.  If the "newChild" node 
            is already in the tree, it is first removed.
        @@@InCase:
          @@@@Type: DocumentFragment
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The "oldChild" node is replaced by all of the 
              child nodes of the "newChild" node, in the same order. 
              The child list of the "newChild" is to be empty. 
              [DOM 1 SE, 2, 3]
     @@Param:
        @@@Name:  oldChild
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@:
            The node being replaced in the child list.
        @@@InCase:
          @@@@Label: Same as the "newChild" node
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Replacing a node with itself is implementation dependent.
          @@@@SpecLevel: 3
     @@Return:
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@: The node replaced.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: HIERARCHY_REQUEST_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Either this node is of a type that does not allow 
              children of the type of the "newChild" node [DOM 1, 2, 3],
              the node to put in is one of ancestors of this node 
              [DOM 1, 2, 3], the node to put in is this node itself
              [DOM 2 Errata, 3], or this 
              node is of type "Document" and the result of the 
              replacement would add a second "DocumentType" or "Element" node.
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              Special treatment required for the "DocumentFragment" node.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: WRONG_DOCUMENT_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The new node was created from a different document.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Either this node is read-only [DOM 1, 2, 3] or the parent of the 
              new node is read-only [DOM 1 SE, 2, 3].
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NOT_FOUND_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The "oldChild" node is not a child of this node.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NOT_SUPPORTED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              This node is of type "Document" and the DOM implementation 
              does not support the replacement of the "DocumentType" or 
              "Element" child.
          @@@@SpecLevel:3
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            my $node;
            my $newNode;
            CHKDOC: {
              if (ref $newChild and $newChild->isa ('__IIF{Node::}__')) {
                $node = $self->{<Q:TreeCore:node>};
                $newNode = $newChild->{<Q:TreeCore:node>};
                if ($node->{<Q:DOMCore:ownerDocument>}) {
                  if ($newNode->{<Q:DOMCore:ownerDocument>}) {
                    last CHKDOC if $node->{<Q:DOMCore:ownerDocument>}
                                        ->{<Q:TreeCore:nodeID>} eq
                                   $newNode->{<Q:DOMCore:ownerDocument>}
                                        ->{<Q:TreeCore:nodeID>};
                  }
                } else { ## I'm "Document" or "DocumentType" node.
                  if ($node->{<Q:DOMCore:nodeType>} eq <Q:infoset:Document>) {
                    last CHKDOC;
                  }
                }
              }
              __EXCEPTION{
                DOMException.WRONG_DOCUMENT_ERR::
                  <Q:MDOM_EXCEPTION:param-name> => 'newChild',
              }__;
            } # CHKDOC
            my @newNode = ($newNode);
            if ($newNode->{<Q:DOMCore:nodeType>} eq
                <Q:DOMCore:DocumentFragment>) {
       \       @newNode = @{$newNode->{<Q:infoset:children>}};
            }
            if (@newNode) {
              my $parentNode = $newNode[0]->{<Q:infoset:parent>};

              ## Read-only?
              if ($node->{<Q:DOMCore:read-only>}) {
                ## This node is read-only.
                __EXCEPTION{
                  DOMException.NO_MODIFICATION_ALLOWED_ERR.
                    MDOM_EXCEPTION:NOMOD_THIS::
                }__;
              } elsif ($parentNode and $parentNode->{<Q:DOMCore:read-only>}) {
                ## Parent of new node(s) is read-only
                __EXCEPTION{
                  DOMException.NO_MODIFICATION_ALLOWED_ERR.
                  MDOM_EXCEPTION:NOMOD_SRC_PARENT::
                    <Q:MDOM_EXCEPTION:param-name> => 'newChild',
                }__;
              }
              
              ## Check type of this node and new child node
              CHKTYPE: {
                if ({
                      <Q:infoset:Element> => 1,
                      <Q:DOMCore:DocumentFragment> => 1,
                      <Q:DOMXML:Entity> => 1,
                      <Q:DOMXML:EntityReference> => 1,
                    }->{$node->{<Q:DOMCore:nodeType>}}) {
                  CHILDTYPE: {
                    for (@newNode) {
                      unless ({
                            <Q:infoset:Element> => 1,
                            <Q:DOMCore:Text> => 1,
                            <Q:infoset:Comment> => 1,
                            <Q:infoset:ProcessingInstruction> => 1,
                            <Q:DOMXML:CDATASection> => 1,
                            <Q:DOMXML:EntityReference> => 1,
                          }->{$_->{<Q:DOMCore:nodeType>}}) {
                        last CHILDTYPE;
                      }
                    }
                    last CHKTYPE; # No problem
                  }
                } elsif ($node->{<Q:DOMCore:nodeType>} eq <Q:infoset:Document>) {
                  CHILDTYPE: {
                    my %has;
                    EACHNEWNODE: for my $newNode (@newNode) {
                      if ({
                            <Q:infoset:Element> => 1,
                            <Q:infoset:DocumentTypeDeclaration> => 1,
                          }->{$newNode->{<Q:DOMCore:nodeType>}}) {
                        FOUND: {
                          if ($has{$newNode->{<Q:DOMCore:nodeType>}}) {
                            ## DOCTYPE or document element is waiting 
                            ## to be added
                            last FOUND;
                          }
                          for (@{$node->{<Q:infoset:children>}}) {
                            ## Document already has a DOCTYPE or doc.element
                            last FOUND if $_->{<Q:DOMCore:nodeType>} eq
                                          $newNode->{<Q:DOMCore:nodeType>};
                          }
                          $has{$newNode->{<Q:DOMCore:nodeType>}} = 1;
                          next EACHNEWNODE;
                        }
                        if ($newNode->{<Q:DOMCore:nodeType>} eq
                            <Q:infoset:Element>) {
                          __EXCEPTION{
                            DOMException.HIERARCHY_REQUEST_ERR.
                            MDOM_EXCEPTION:MDOM_SECOND_DOC_ELEMENT::
                              <Q:MDOM_EXCEPTION:param-name> => 'newChild',
                          }__;
                        } else { # <Q:infoset:DocumentTypeDeclaration>
                          __EXCEPTION{
                            DOMException.HIERARCHY_REQUEST_ERR.
                            MDOM_EXCEPTION:MDOM_SECOND_DOCTYPE::
                              <Q:MDOM_EXCEPTION:param-name> => 'newChild',
                          }__;
                        }
                      } elsif (not {
                                 <Q:infoset:Comment> => 1,
                                 <Q:infoset:ProcessingInstruction> => 1,
                               }->{$newNode->{<Q:DOMCore:nodeType>}}) {
                        last CHILDTYPE;
                      }
                    } # EACHNEWNODE
                    last CHKTYPE; # No problem
                  } # CHILDTYPE
                } elsif ($node->{<Q:DOMCore:nodeType>} eq
                         <Q:infoset:Attribute>) {
                  CHILDTYPE: {
                    for my $newNode (@newNode) {
                      unless ({
                            <Q:DOMCore:Text> => 1,
                            <Q:DOMXML:EntityReference> => 1,
                          }->{$newNode->{<Q:DOMCore:nodeType>}}) {
                        last CHILDTYPE;
                      }
                    }
                    last CHKTYPE; # No problem
                  }
                } # $node->{<Q:DOMCore:nodeType>}
                __EXCEPTION{
                  DOMException.HIERARCHY_REQUEST_ERR.
                  MDOM_EXCEPTION::HIERARCHY_BAD_TYPE::
                    <Q:infoset:nodeType> => $newNode->{<Q:infoset:nodeType>},
                    <Q:MDOM_EXCEPTION:param-name> => 'newChild',
                }__;
              } # CHKTYPE
              
              ## Check $newNode (not $newNode[0]) = ancestor-or-self::node()
              if ($node->{<Q:TreeCore:treeID>} eq
                  $newNode->{<Q:TreeCore:treeID>}) {
                my $n = $node;
                {
                  if ($newNode->{<Q:TreeCore:nodeID>} eq
                      $n->{<Q:TreeCore:nodeID>}) {
                    __EXCEPTION{
                      DOMException.HIERARCHY_REQUEST_ERR.
                      MDOM_EXCEPTION:HIERARCHY_ANCESTOR_OR_SELF::
                        <Q:MDOM_EXCEPTION:param-name> => 'newChild',
                    }__;
                  }
                  if ($n->{<Q:infoset:parent>}) {
                    $n = $n->{<Q:infoset:parent>};
                    redo;
                  }
                }
              }
              
              ## Seek the $oldChild
              my $newIndex = @{$node->{<Q:infoset:children>}};
              REFCHILD: {
                if (defined $oldChild) {
                  my $refID = $oldChild->{<Q:TreeCore:node>}
                                       ->{<Q:TreeCore:nodeID>};
                  for my $i (0..$#{$node->{<Q:infoset:children>}}) {
                    if ($node->{<Q:infoset:children>}->[$i]
                             ->{<Q:TreeCore:nodeID>} eq $refID) {
                      $newIndex = $i;
                      last REFCHILD;
                    }
                  }
                  __EXCEPTION{
                    DOMException.NOT_FOUND_ERR::
                      <Q:MDOM_EXCEPTION:param-name> => 'oldChild',
                  }__;
                }
              } # REFCHILD
              if ($newNode[0]->{<Q:infoset:parent>} and
                  $newNode[0]->{<Q:infoset:parent>}->{<Q:TreeCore:nodeID>} eq
                  $node->{<Q:TreeCore:nodeID>}) {
                if (@newNode > 1) {
                  __EXCEPTION{
                    ManakaiDOMImplementationException.MDOM_DEBUG_BUG::
                  }__;
                } elsif (ref $oldChild and
                         $newNode[0]->{<Q:TreeCore:nodeID>} eq
                         $oldChild->{<Q:TreeCore:node>}->{<Q:TreeCore:nodeID>}) {
                  __WARNING{
                    ManakaiDOMImplementationWarning.MDOM_NEWCHILD_IS_REFCHILD:: 
                      <Q:MDOM_EXCEPTION:newChild-param-name> => 'newChild',
                      <Q:MDOM_EXCEPTION:refChild-param-name> => 'oldChild',
                  }__;
                  ## And no action.
                } else {
                  my $currentIndex;
                  for my $i (0..$#{$node->{<Q:infoset:children>}}) {
                    if ($node->{<Q:infoset:children>}->[$i]
                             ->{<Q:TreeCore:nodeID>} eq
                        $newNode[0]->{<Q:TreeCore:nodeID>}) {
                      $currentIndex = $i;
                    }
                  }
                  if ($newIndex < $currentIndex) {
                    delete $node->{<Q:infoset:children>}->[$currentIndex];
                    splice @{$node->{<Q:infoset:children>}},
                           $newIndex, 1, @newNode;
                  } else {
                    splice @{$node->{<Q:infoset:children>}},
                           $newIndex, 1, @newNode;
                    delete $node->{<Q:infoset:children>}->[$currentIndex];
                  }
                }
              } else { ## $newChild->parentNode ne $self
                for my $newNode (@newNode) {
                  delete $newNode->{<Q:infoset:parent>};
                  $node->__SUPER{ManakaiDOMNodeObject::}__::__INT{importTree}__
                                                                   ($newNode);
                  $newNode->{<Q:infoset:parent>} = $node;
                }
                splice @{$node->{<Q:infoset:children>}},
                       $newIndex, 1, @newNode;
              }
              
              if ($newNode->{<Q:DOMCore:nodeType>} eq
                  <Q:DOMCore:DocumentFragment>) {
                $newNode->{<Q:infoset:children>} = [];
              } elsif ($parentNode) {
                for my $i (0..$#{$parentNode->{<Q:infoset:children>}}) {
                  if ($parentNode->{<Q:infoset:children>}->[$i]
                                 ->{<Q:TreeCore:nodeID>} eq
                      $node->{<Q:TreeCore:nodeID>}) {
                    delete $parentNode->{<Q:infoset:children>}->[$i];
                    last;
                  }
                }
              }
              delete $oldChild->{<Q:TreeCore:node>}->{<Q:infoset:parent>};
              $oldChild->{<Q:TreeCore:node>}
                       ->__SUPER{ManakaiDOMNodeObject::}__::__INT{orphanate}__;
            } # @newNode
            $r = $oldChild;
     @@Level[list]:
        1
        3
     @@SpecLevel[list]:
        1
        3
  @Method:
     @@Name:  removeChild
     @@Description:
       @@@lang:en
       @@@@:
         Remove a child node from the list of children and return it.
     @@Param:
        @@@Name:  oldChild
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@: The node being removed.
     @@Return:
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@: The node removed.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: This node is read-only.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NOT_FOUND_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The "oldChild" is not a child of this node.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NOT_SUPPORTED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              This node is of type "Document" and the DOM implementation 
              does not support the removal of the "DocumentType" or 
              "Element" child.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            my $node = $self->{<Q:TreeCore:node>};
            if ($node->{<Q:DOMCore:read-only>}) {
              __EXCEPTION{
                DOMException.NO_MODIFICATION_ALLOWED_ERR.
                MDOM_EXCEPTION:NOMOD_THIS::
              }__;
            }
            my $oldChildID = ref $oldChild ?
                               $oldChild->{<Q:TreeCore:node>}
                                        ->{<Q:TreeCore:nodeID>} : '';
            FIND: {
              for my $i (0..$#{$node->{<Q:infoset:children>}}) {
                if ($node->{<Q:infoset:children>}->[$i]
                         ->{<Q:TreeCore:nodeID>} eq $oldChildID) {
                  delete $node->{<Q:infoset:children>}->[$i];
                  last FIND;
                }
              }
              __EXCEPTION{
                DOMException.NOT_FOUND_ERR::
              }__;
            }
            if (ref $oldChild) {
              $r = $oldChild;
              delete $oldChild->{<Q:TreeCore:node>}->{<Q:infoset:parent>};
              $oldChild->{<Q:TreeCore:node>}
                ->__SUPER{ManakaiDONNodeObject::}__::__INT{orphanate}__;
            }
     @@Level[list]:  3
     @@SpecLevel:3
  @Method:
     @@Name:  appendChild
     @@Description:
       @@@lang:en
       @@@@:
         Add a node to the end of the list of children of this node.
     @@Param:
        @@@Name:  newChild
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@:
            The node to add.  If it is already in the tree, 
            it is first removed.
        @@@InCase:
          @@@@Type: DocumentFragment
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The entire contents of the document fragment 
              are moved into the child list of this node. 
              The child list of the "newChild" is to be empty.
     @@Return:
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@: The node added.
        @@@ImplNote:
          @@@@lang:en
          @@@@@:
            What should be returned when the "newChild" node is a 
            "DocumentFragment" is unclear.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: HIERARCHY_REQUEST_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Either this node is of a type that does not allow 
              children of the type of the "newChild" node [DOM 1, 2, 3], 
              the node to add is one of ancestors of this node [DOM 1, 2, 3],
              the node to add is this node itself [DOM 2 Errata, 3] or 
              this node is of type "Document" and the attemption 
              to append a second "DocumentType" or "Element" node 
              is made [DOM 3].
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              Is this error raised if this node is of type "Document" and 
              it has an "Element" node but no "DocumentType" node then 
              the attemption to add a "DocumentType" is made?
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: WRONG_DOCUMENT_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The "newChild" node was created from a different document 
              than the one that created this node.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Either this node is read-only [DOM 1, 2, 3] or
              the previous (current) parent 
              of the "newChild" node is read-only [DOM 2 Errata, 3].
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NOT_SUPPORTED_ERR
          @@@@Level: 3
          @@@@SpecLevel:3
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The "newChild" node is a child of the "Document" node and 
              the DOM implementation does not support the removal of 
              the "DocumentType" or "Element" child node from the 
              "Document" node.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            my $node;
            my $newNode;
            CHKDOC: {
              if (ref $newChild and $newChild->isa ('__IIF{Node::}__')) {
                $node = $self->{<Q:TreeCore:node>};
                $newNode = $newChild->{<Q:TreeCore:node>};
                if ($node->{<Q:DOMCore:ownerDocument>}) {
                  if ($newNode->{<Q:DOMCore:ownerDocument>}) {
                    last CHKDOC if $node->{<Q:DOMCore:ownerDocument>}
                                        ->{<Q:TreeCore:nodeID>} eq
                                   $newNode->{<Q:DOMCore:ownerDocument>}
                                        ->{<Q:TreeCore:nodeID>};
                  }
                } else { ## I'm "Document" or "DocumentType" node.
                  if ($node->{<Q:DOMCore:nodeType>} eq <Q:infoset:Document>) {
                    last CHKDOC;
                  }
                }
              }
              __EXCEPTION{
                DOMException.WRONG_DOCUMENT_ERR::
                  <Q:MDOM_EXCEPTION:param-name> => 'newChild',
              }__;
            } # CHKDOC
            my @newNode = ($newNode);
            if ($newNode->{<Q:DOMCore:nodeType>} eq
                <Q:DOMCore:DocumentFragment>) {
       \       @newNode = @{$newNode->{<Q:infoset:children>}};
            }
            if (@newNode) {
              my $parentNode = $newNode[0]->{<Q:infoset:parent>};

              ## Read-only?
              if ($node->{<Q:DOMCore:read-only>}) {
                ## This node is read-only.
                __EXCEPTION{
                  DOMException.NO_MODIFICATION_ALLOWED_ERR.
                  MDOM_EXCEPTION:NOMOD_THIS::
                }__;
              } elsif ($parentNode and $parentNode->{<Q:DOMCore:read-only>}) {
                ## Parent of new node(s) is read-only
                __EXCEPTION{
                  DOMException.NO_MODIFICATION_ALLOWED_ERR.
                  MDOM_EXCEPTION:NOMOD_SRC_PARENT::
                    <Q:MDOM_EXCEPTION:param-name> => 'newChild',
                }__;
              }
              
              ## Check type of this node and new child node
              CHKTYPE: {
                if ({
                      <Q:infoset:Element> => 1,
                      <Q:DOMCore:DocumentFragment> => 1,
                      <Q:DOMXML:Entity> => 1,
                      <Q:DOMXML:EntityReference> => 1,
                    }->{$node->{<Q:DOMCore:nodeType>}}) {
                  CHILDTYPE: {
                    for (@newNode) {
                      unless ({
                            <Q:infoset:Element> => 1,
                            <Q:DOMCore:Text> => 1,
                            <Q:infoset:Comment> => 1,
                            <Q:infoset:ProcessingInstruction> => 1,
                            <Q:DOMXML:CDATASection> => 1,
                            <Q:DOMXML:EntityReference> => 1,
                          }->{$_->{<Q:DOMCore:nodeType>}}) {
                        last CHILDTYPE;
                      }
                    }
                    last CHKTYPE; # No problem
                  }
                } elsif ($node->{<Q:DOMCore:nodeType>} eq <Q:infoset:Document>) {
                  CHILDTYPE: {
                    my %has;
                    EACHNEWNODE: for my $newNode (@newNode) {
                      if ({
                            <Q:infoset:Element> => 1,
                            <Q:infoset:DocumentTypeDeclaration> => 1,
                          }->{$newNode->{<Q:DOMCore:nodeType>}}) {
                        FOUND: {
                          if ($has{$newNode->{<Q:DOMCore:nodeType>}}) {
                            ## DOCTYPE or document element is waiting 
                            ## to be added
                            last FOUND;
                          }
                          for (@{$node->{<Q:infoset:children>}}) {
                            ## Document already has a DOCTYPE or doc.element
                            last FOUND if $_->{<Q:DOMCore:nodeType>} eq
                                          $newNode->{<Q:DOMCore:nodeType>};
                          }
                          $has{$newNode->{<Q:DOMCore:nodeType>}} = 1;
                          next EACHNEWNODE;
                        }
                        if ($newNode->{<Q:DOMCore:nodeType>} eq
                            <Q:infoset:Element>) {
                          __EXCEPTION{
                            DOMException.HIERARCHY_REQUEST_ERR.
                            MDOM_EXCEPTION:MDOM_SECOND_DOC_ELEMENT::
                              <Q:MDOM_EXCEPTION:param-name> => 'newChild',
                          }__;
                        } else { # <Q:infoset:DocumentTypeDeclaration>
                          __EXCEPTION{
                            DOMException.HIERARCHY_REQUEST_ERR.
                            MDOM_EXCEPTION:MDOM_SECOND_DOCTYPE::
                              <Q:MDOM_EXCEPTION:param-name> => 'newChild',
                          }__;
                        }
                      } elsif (not {
                                 <Q:infoset:Comment> => 1,
                                 <Q:infoset:ProcessingInstruction> => 1,
                               }->{$newNode->{<Q:DOMCore:nodeType>}}) {
                        last CHILDTYPE;
                      }
                    } # EACHNEWNODE
                    last CHKTYPE; # No problem
                  } # CHILDTYPE
                } elsif ($node->{<Q:DOMCore:nodeType>} eq
                         <Q:infoset:Attribute>) {
                  CHILDTYPE: {
                    for my $newNode (@newNode) {
                      unless ({
                            <Q:DOMCore:Text> => 1,
                            <Q:DOMXML:EntityReference> => 1,
                          }->{$newNode->{<Q:DOMCore:nodeType>}}) {
                        last CHILDTYPE;
                      }
                    }
                    last CHKTYPE; # No problem
                  }
                } # $node->{<Q:DOMCore:nodeType>}
                __EXCEPTION{
                  DOMException.HIERARCHY_REQUEST_ERR.
                  MDOM_EXCEPTION:HIERARCHY_BAD_TYPE::
                    <Q:infoset:nodeType> => $newNode->{<Q:infoset:nodeType>},
                    <Q:MDOM_EXCEPTION:param-name> => 'newChild',
                }__;
              } # CHKTYPE
              
              ## Check $newNode (not $newNode[0]) = ancestor-or-self::node()
              if ($node->{<Q:TreeCore:treeID>} eq
                  $newNode->{<Q:TreeCore:treeID>}) {
                my $n = $node;
                {
                  if ($newNode->{<Q:TreeCore:nodeID>} eq
                      $n->{<Q:TreeCore:nodeID>}) {
                    __EXCEPTION{
                      DOMException.HIERARCHY_REQUEST_ERR.
                      MDOM_EXCEPTION:HIERARCHY_ANCESTOR_OR_SELF::
                        <Q:MDOM_EXCEPTION:param-name> => 'newChild',
                    }__;
                  }
                  if ($n->{<Q:infoset:parent>}) {
                    $n = $n->{<Q:infoset:parent>};
                    redo;
                  }
                }
              }
              
              for my $newNode (@newNode) {
                delete $newNode->{<Q:infoset:parent>};
                $node->__SUPER{ManakaiDOMNodeObject::}__::__INT{importTree}__
                                                                 ($newNode);
                $newNode->{<Q:infoset:parent>} = $node;
              }
              push @{$node->{<Q:infoset:children>}}, @newNode;

              if ($newNode->{<Q:DOMCore:nodeType>} eq
                  <Q:DOMCore:DocumentFragment>) {
                $newNode->{<Q:infoset:children>} = [];
              } elsif ($parentNode) {
                for my $i (0..$#{$parentNode->{<Q:infoset:children>}}) {
                  if ($parentNode->{<Q:infoset:children>}->[$i]
                                 ->{<Q:TreeCore:nodeID>} eq
                      $node->{<Q:TreeCore:nodeID>}) {
                    delete $parentNode->{<Q:infoset:children>}->[$i];
                    last;
                  }
                }
              }
            } # @newNode
            $r = $newChild;
     @@Level[list]:
        1
        3
     @@SpecLevel[list]:
        1
        3
     @@ImplNote:
       @@@lang:en
       @@@@: See also the implementation note of the "insertBefore" method.
  @Method:
     @@Name:  hasChildNodes
     @@Description:
       @@@lang:en
       @@@@: Return whether this node has any children.
     @@Return:
        @@@Type:  boolean
        @@@InCase:
          @@@@Value: true
          @@@@Description:
            @@@@@lang:en
            @@@@@@: This node has any child nodes.
        @@@InCase:
          @@@@Value: false
          @@@@Description:
            @@@@@lang:en
            @@@@@@: This node does not have any child node.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            $r = @{$self->{<Q:TreeCore:node>}->{<Q:infoset:children>}}
                   ? true : false;
  @Method:
     @@Name:  cloneNode
     @@Return:
        @@@Type:  Node
     @@Param:
        @@@Name:  deep
        @@@Type:  boolean
  @Method:
     @@Name:  normalize
     @@Description:
       @@@lang:en
       @@@@:
         Put all <IF:Text> nodes in the full depth of the sub-tree 
         underneath this <IF:Node>, including attribute nodes 
         attaced to the <IF:Element>, 
         into a "normal" form where only structure separates 
         <IF:Text> nodes, i.e. there are neither adjacent <IF:Text> 
         nodes nor empty <IF:Text> nodes. <SRC:DOM 1, 2, 3>
       \
         If the parameter <DOM:normalize-characters> of the 
         <A:Document.domConfig> is <DOM:true>, the characters 
         of the <IF:Text> nodes will also be fully normalized. 
         <SRC:DOM 3>
     @@ImplNote:
       @@@lang:en
       @@@@:
         Isn't <IF:CDATASection> node fully-normalized?
     @@Level[list]:
       2
       3
     @@SpecLevel[list]:
       2
       3
     @@ImplNote:
       @@@lang:en
       @@@@:
         This method was defined in the "Element" interface in the DOM 
         Level 1, but has beem moved to the "Node" interface in the 
         DOM Level 2.
     @@RedefinedBy:Element
  @Method:
     @@Name:  isSupported
     @@Return:
        @@@Type:  boolean
     @@Param:
        @@@Name:  feature
        @@@Type:  DOMString
     @@Param:
        @@@Name:  version
        @@@Type:  DOMString
     @@Level[list]:  2
     @@SpecLevel:2
  @Attr:
     @@Name:  namespaceURI
     @@Description:
       @@@lang:en
       @@@@:
         The namespace URI of this node.
       \
         Note that this is not a computed value that is the result 
         of a namespace lookup based on an examination of the 
         namespace declarations in scope, but is merely the 
         namespace URI given at creation time.
     @@Get:
        @@@Type:
          ManakaiDOM:ManakaiDOMNamespaceURI
        @@@Description:
          @@@@lang:en
          @@@@@: The namespace URI.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The namespace URI is unspecified (the "null" namespace or 
              the attribute in a per-element-type partition),
              the type of the node is other than "ELEMENT_NODE" or 
              "ATTRIBUTE_NODE", or 
              the node is created with a DOM Level 1 methods.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@: $r = null;
     @@Level[list]:  2
     @@SpecLevel:2
     @@RedefinedBy: Element
     @@RedefinedBy: Attr
  @Attr:
     @@Name:  prefix
     @@Description:
       @@@lang:en
       @@@@: The namespace prefix of this node.
     @@Get:
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The namespace prefix.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Either the namespace prefix is unspecified, the node 
              is created with a DOM Level 1 method, or the type 
              of the node is other than "ELEMENT_NODE" and 
              "ATTRIBUTE_NODE".
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@: $r = null;
     @@Set:
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            The namespace prefix.
            Note that setting this attribute has no effect if 
            the namespace prefix is defined to be "null".
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The namespace prefix is unspecified.
        @@@InCase:
          @@@@Value: \
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The result is implementation dependent.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: INVALID_CHARACTER_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The specified prefix contains an illegal character 
              accoding to the XML version in use in the document.
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              The DOM Level 2 Errata clarifies that the "illegal"ness 
              is accoding to the XML 1.0 Specification.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: This node is read-only.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NAMESPACE_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Either the specified prefix is malformed per the 
              XML Namespace specification, non-"null" prefix is 
              specified but the "namespaceURI" of this node is "null", 
              the specified prefix is "xml" and the "namespaceURI" 
              of this node is different from 
              "http://www.w3.org/XML/1998/namespace", if this 
              node is an attribute and the specified prefix is "xmlns" 
              and the "namespaceURI" of this node is different from 
              "http://www.w3.org/2000/xmlns/", or if this node is 
              an attribute and the "qualifiedName" of this node is 
              "xmlns".
        @@@Warning:
          @@@@Type:
            ManakaiDOM:ManakaiDOMImplementationWarning
          @@@@Name: ATTR_SET_NO_EFFECT
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Setting this attribute has no effect.
        @@@Def: \
     @@Level[list]:  2
     @@SpecLevel:2
     @@RedefinedBy: Attr
     @@RedefinedBy: Element
  @Attr:
     @@Name:  localName
     @@Description:
       @@@lang:en
       @@@@: The local part of the qualified name of this node.
     @@Get:
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            The local name.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The type of the node is other than "ELEMENT_NODE" or 
              "ATTRIBUTE_NODE", or the node is created with a DOM Level 1 
              methods.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@: $r = null;
     @@Level[list]:  2
     @@SpecLevel:2
     @@RedefinedBy: Element
     @@RedefinedBy: Attr
  @Method:
     @@Name:  hasAttributes
     @@Description:
       @@@lang:en
       @@@@:
         Return whether this node has any attributes.
     @@Return:
        @@@Type:  boolean
        @@@InCase:
          @@@@Value:true
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              This node is an <IF:Element> and has any attributes.
        @@@InCase:
          @@@@Value:false
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              This node does not have any attribute.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            for (values %{$self->{<Q:TreeCore:node>}
                               ->{<Q:infoset:attributes>}}) {
              if (keys %$_) {
                $r = true;
                last;
              }
            }
     @@Level[list]:  2
     @@SpecLevel:2
  @Attr:
     @@Name:  baseURI
     @@Description:
       @@@lang:en
       @@@@:
         The base URI of this node.
     @@Get:
        @@@Type: 
          ManakaiDOM:ManakaiDOMURI
        @@@Description:
          @@@@lang:en
          @@@@@:
            The absolute base URI.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The DOM implementation was not able to obtain 
              an absolute URI.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            if ($self->{<Q:TreeCore:node>}->{<Q:DOMCore:hasFeature>}->{HTML}) {
              $r = $self->{<Q:TreeCore:node>}
                        ->__SUPER{ManakaiDOMNodeObjectNode::}__::__INT{htmlBaseURI}__;
            } else {
              $r = null;
            }
     @@ImplNote:
       @@@lang:en
       @@@@:
         = If the <IF:Document> support the feature <Feature:HTML>,
       \
         == If there is a <HTML:base> element with the <HTML:base> attribute, 
            the base URI is its value.
       \
         == Otherwise, the base URI is the value of <A:Document.documentURI>.
       \
         = Elsif the <IF:Document> support the feature <Feature:XML>, 
           compute the base URI accodint to the XML Base Specification.
     @@ImplNote:
       @@@lang:en
       @@@@:
         The descriptions in the sections of Base URIs (DOM Level 3 Core 
         1.3.4) and <A:Node.baseURI> (and some readings from XML Base 
         and XML Infoset specifications) is insufficient to understand 
         and implement this attribute.  The <CITE:Infoset Mapping>, a 
         normative appendix of the DOM Level 3 Core Specification, is 
         useful for this purpose.
     @@ImplNote:
       @@@lang:en
       @@@@:
         The DOM Level 3 Specification does not address to 
         <HTML:codebase> attributes.
     @@Level[list]:  3
     @@SpecLevel:3
     @@Spec:
       @@@DOM3:
         http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#baseURIs-Considerations
    @@RedefinedBy:Document
    @@RedefinedBy:Element
    @@RedefinedBy:
      DOMXML:ProcessingInstruction
    @@RedefinedBy:
      DOMXML:EntityReference
    @@RedefinedBy:
      DOMXML:Entity
    @@RedefinedBy:
      DOMXML:Notation
  @ConstGroup:
     @@Name:  DocumentPosition
     @@Description:
       @@@lang:en
       @@@@:
         A bitmask indicating the relative document position of a node 
         with respect to another node.
     @@Level: 3
     @@SpecLevel:3
     @@Const:
        @@@Name:  DOCUMENT_POSITION_DISCONNECTED
        @@@Type:  unsigned-short
        @@@Value:  0x01
        @@@Description:
          @@@@lang:en
          @@@@@:
            The two nodes are disconnected.  Order between disconnected nodes 
            is always implementation-specific.
     @@Const:
        @@@Name:  DOCUMENT_POSITION_PRECEDING
        @@@Type:  unsigned-short
        @@@Value:  0x02
        @@@Description:
          @@@@lang:en
          @@@@@:
            The node precedes the reference node.
     @@Const:
        @@@Name:  DOCUMENT_POSITION_FOLLOWING
        @@@Type:  unsigned-short
        @@@Value:  0x04
        @@@Description:
          @@@@lang:en
          @@@@@: The node fllows the reference node.
     @@Const:
        @@@Name:  DOCUMENT_POSITION_CONTAINS
        @@@Type:  unsigned-short
        @@@Value:  0x08
        @@@Description: 
          @@@@lang:en
          @@@@@:
            The node contains the reference node.  A node that 
            contains is always preceding, too.
     @@Const:
        @@@Name:  DOCUMENT_POSITION_CONTAINED_BY
        @@@Type:  unsigned-short
        @@@Value:  0x10
        @@@Description:
          @@@@lang:en
          @@@@@:
            The node is contained by the reference node. 
            A node that is contained is always following, too.
     @@Const:
        @@@Name:  DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC
        @@@Type:  unsigned-short
        @@@Value:  0x20
        @@@Description:
          @@@@lang:en
          @@@@@:
            The determination of preceding versus following is 
            implementation-specific.
  @Method:
     @@Name:  compareDocumentPosition
     @@Return:
        @@@Type:  unsigned-short
        @@@Exception[list]:  DOMException
     @@Param:
        @@@Name:  other
        @@@Type:  Node
     @@Level[list]:  3
     @@SpecLevel:3
  @Attr:
     @@Name:  textContent
     @@Description:
       @@@lang:en
       @@@@:
         The text content of this node and its descendants. 
         Note that element content whitespaces are not considered 
         as the text content of an "Element".
     @@Get:
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            The text content of this node.
        @@@InCase:
          @@@@Label: Concatenation of the text content of child nodes
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
            For the node of type "Element", "Attr", "Entity", 
            "EntityReference" or "DocumentFragment",  
            concatenation of the "textContent" value of every 
            child node, excluding of type "Comment" or 
            "ProcessingInstruction", is the text content.
        @@@InCase:
          @@@@Label: "nodeValue"
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              For the node of type "Text", "CDATASection", 
              "Comment" or "ProcessingInstruction", the text content 
              is same as the value of the attribute "nodeValue".
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              For the node of type "Document", "DocumentType" or 
              "Notation", the text content is defined to be "null".
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: DOMSTRING_SIZE_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The attribute would return more characters than 
              fit in a "DOMString" variable on the implementation 
              platform.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            $r = $self->{<Q:TreeCore:node>}
                  ->__SUPER{ManakaiDOMNodeObjectNode::}__::__INT{textContent}__;
     @@Set:
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            Any child nodes of this node are removed and 
            replaced by a single "Text" node containing the string 
            specified.
          \
            Note that when the "textContent" is defined to be "null", 
            setting the value has no effect.
        @@@InCase:
          @@@@Value:\
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Any child nodes are removed if the value is not defined to 
              be "null".
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: 
              Any child nodes are removed if the value is not defined 
              to be "null".
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: This node is read-only.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            my $node = $self->{<Q:TreeCore:node>};
            if ($node->{<Q:DOMCore:read-only>}) {
              __EXCEPTION{
                DOMException.NO_MODIFICATION_ALLOWED_ERR.
                MDOM_EXCEPTION:NOMOD_THIS::
              }__;
            }
            my @oldChild = @{$node->{<Q:infoset:children>}};
            for (@oldChild) {
              delete $_->{<Q:infoset:parent>};
            }
                           ## Condition sensitive
            my $textNode = __CLASS{Text}__->__INT{newObject}__;
            $textNode->{<Q:DOMCore:ownerDocument>}
                                   = $node->{<Q:DOMCore:ownerDocument>};
            $node->__SUPER{ManakaiDOMNodeObject::}__::__INT{importTree}__
                                                           ($textNode);
            $textNode->{<Q:infoset:content>} = $given;
            $node->{<Q:infoset:children>} = [$textNode];
            for (@oldChild) {
              $_->__SUPER{ManakaiDOMNodeObject::}__::__INT{orphanate}__;
            }
     @@Level[list]:
        3
     @@SpecLevel:3
     @@RedefinedBy: Document
     @@RedefinedBy: DocumentType
     @@RedefinedBy: Notation
     @@RedefinedBy: CharacterData
     @@RedefinedBy: ProcessingInstrction
  @Method:
     @@Name:  isSameNode
     @@Description:
        @@@lang:en
        @@@@:
          Return whether this node is the same node as the given one.
        \
          When two "Node" references are references to the same object, 
          even if through a proxy, the references may be used completely 
          interchangably, such that all attributes have the same values 
          and calling the same method on either reference always has 
          exactly same effect.
     @@Operator:
        @@@@: eq
        @@@Type:
          lang:Perl
     @@Param:
        @@@Name:  other
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@: The node to test against.
     @@Return:
        @@@Type:  boolean
        @@@InCase:
          @@@@Value: true
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The two nodes are the same.
        @@@InCase:
          @@@@Value: false
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The two nodes are not same.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            if (ref $other and
                $other->isa ('__IIF{ManakaiDOMNodeReference::}__') and
                $other->{<Q:TreeCore:node>}->{<Q:TreeCore:nodeID>}
                  eq $self->{<Q:TreeCore:node>}->{<Q:TreeCore:nodeID>}) {
              $r = true;
            }
     @@Level[list]:  3
     @@SpecLevel:3
  @Method:
     @@Name:  lookupPrefix
     @@Description:
       @@@lang:en
       @@@@:
         Lookup the namespace prefix associated to the given namespace 
         URI, starting from this node.
       \
         The default namespace declarations are ignored by this method. 
         To lookup default namespace, use the <M:Node.isDefaultNamespace>
         method.
     @@Param:
        @@@Name:  namespaceURI
        @@@Type:
          ManakaiDOM:ManakaiDOMNamespaceURI
        @@@Description:
          @@@@lang:en
          @@@@@: The namespace URI to look for.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Always <DOM:null> will be returned.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Always <DOM:null> will be returned.
     @@Return:
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            An associated namespace prefix.
          \
            If more than one prefix are associated to the 
            namespace URI, which is returned is implementation 
            dependent.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              No namespace prefix is found.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            if (not defined $namespaceURI) {
              $r = null;
            } else {
              my $n = $self->{<Q:TreeCore:node>};
              ANCESTOR: {
                if ($n->{<Q:infoset:parent>}) {
                  $n = $n->{<Q:infoset:parent>};
                  if ($n->{<Q:DOMCore:nodeType>} eq <Q:infoset:Element>) {
                    $r = $n->__SUPER{ManakaiDOMNodeObjectNode::}__::__INT{lookupNamespacePrefix}__
                                                 ($namespaceURI, $n);
                    last ANCESTOR;
                  } else {
                    redo ANCESTOR;
                  }
                }
                $r = null;
              } # ANCESTOR
            }
     @@Level[list]:  3
     @@SpecLevel:3
     @@RedefinedBy: Attr
     @@RedefinedBy:
       DOMXML:DocumentType
     @@RedefinedBy:
       DOMCore:DocumentFragment
     @@RedefinedBy:
       DOMXML:Notation
     @@RedefinedBy:
       DOMXML:Entity
     @@RedefinedBy:
       DOMCore:Document
     @@RedefinedBy:Element
  @Method:
     @@Name:  isDefaultNamespace
     @@Description:
       @@@lang:en
       @@@@:
         Return whether the given namespace URI is the default namespace.
     @@Param:
        @@@Name:  namespaceURI
        @@@Type:
          ManakaiDOM:ManakaiDOMNamespaceURI
        @@@Description:
          @@@@lang:en
          @@@@@:
            The namespace URI to look for.
     @@Return:
        @@@Type:  boolean
        @@@InCase:
          @@@@Value:true
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The specified <P:namespaceURI> is the default namespace.
        @@@InCase:
          @@@@Value:false
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The specified <P:namespaceURI> is not the default namespace.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            $r = $self->{<Q:TreeCore:node>}
                      ->__SUPER{ManakaiDOMNodeObjectNode::}__::__INT{isDefaultNamespace}__
                                           ($namespaceURI);
     @@Level[list]:  3
     @@SpecLevel:3
  @Method:
     @@Name:  lookupNamespaceURI
     @@Description:
       @@@lang:en
       @@@@:
         Lookup the namespace URI associated to the given 
         prefix, starting from this node.
     @@Param:
        @@@Name:  prefix
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            The prefix to look for.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Return the default namespace URI if any.
     @@Return:
        @@@Type:
          ManakaiDOM:ManakaiDOMNamespaceURI
        @@@Description:
          @@@@lang:en
          @@@@@:
            The associated namespace URI.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              No associated namespace URI found.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            $r = $self->{<Q:TreeCore:node>}
                      ->__SUPER{ManakaiDOMNodeObjectNode::}__::__INT{lookupNamespaceURI}__
                        ($prefix);
     @@Level[list]:  3
     @@SpecLevel:3
  @Method:
     @@Name:  isEqualNode
     @@Operator:
       @@@@: ==
       @@@Type:
          lang:Perl
     @@Description:
       @@@lang:en
       @@@@: 
         Test whether two nodes are equal.
       \
         Two nodes are equal if their node types, node names, 
         contents, attributes and some DOM attributes are equal. 
         Their parent nodes, schema type, user data and some other DOM 
         attributes do not affect equality.  Future versions of 
         DOM may take into account more DOM attributes.
      @@ImplNote:
        @@@lang:en
        @@@@:
          DOM implementations are expected to be updated when 
          future versions of DOM specify to take into 
          account more DOM attributes.
      @@Param:
        @@@Name:  arg
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@: The node to compare equality with.
     @@Return:
        @@@Type:  boolean
        @@@InCase:
          @@@@Value:true
          @@@@Description:
            @@@@@lang:en
            @@@@@@: Two nodes are equal.
        @@@InCase:
          @@@@Value:false
          @@@@Description:
            @@@@@lang:en
            @@@@@@: Two nodes are not equal.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            EQ: {
              last EQ unless $self->nodeType eq $arg->nodeType;
              for my $v ([$self->nodeName, $arg->nodeName],
                         [$self->localName, $arg->localName],
                         [$self->namespaceURI, $arg->namespaceURI],
                         [$self->prefix, $arg->prefix], 
                         [$self->nodeValue, $arg->nodeValue]) {
                if (not defined $v->[0] and not defined $v->[1]) {
                  #
                } elsif (defined $v->[0] and defined $v->[1] and
                         ''.$v->[0] eq ''.$v->[1]) {
                  # 
                } else {
                  last EQ;
                }
              }
              for my $v ([$self->attributes, $arg->attributes],
                         [$self->childNodes, $arg->childNodes]) {
                if (not defined $v->[0] and not defined $v->[1]) {
                  #
                } elsif (defined $v->[0] and defined $v->[1] and
                         $v->[0] == $v->[1]) {
                  #
                } else {
                  last EQ;
                }
              }
              if ($self->nodeType eq $self->DOCUMENT_TYPE_NODE) {
                for my $v ([$self->publicId, $arg->publicId],
                           [$self->sysyemId, $arg->systemId],
                           [$self->internalSubset, $arg->internalSubset]) {
                  if (not defined $v->[0] and not defined $v->[1]) {
                    #
                  } elsif (defined $v->[0] and defined $v->[1] and
                           ''.$v->[0] eq ''.$v->[1]) {
                    # 
                  } else {
                    last EQ;
                  }
                }
                for my $v ([$self->entities, $arg->entities],
                           [$self->notations, $arg->notations]) {
                  if (not defined $v->[0] and not defined $v->[1]) {
                    #
                  } elsif (defined $v->[0] and defined $v->[1] and
                           $v->[0] == $v->[1]) {
                    #
                  } else {
                    last EQ;
                  }
                }
              }
              $r = true;
            } # EQ
    @@Level[list]:  3
     @@SpecLevel:3
  @Method:
     @@Name:  getFeature
     @@Return:
        @@@Type:  DOMObject
     @@Param:
        @@@Name:  feature
        @@@Type:  DOMString
     @@Param:
        @@@Name:  version
        @@@Type:  DOMString
     @@Level[list]:  3
     @@SpecLevel:3
  @Method:
     @@Name:  setUserData
     @@Return:
        @@@Type:  DOMUserData
     @@Param:
        @@@Name:  key
        @@@Type:  DOMString
     @@Param:
        @@@Name:  data
        @@@Type:  DOMUserData
     @@Param:
        @@@Name:  handler
        @@@Type:  UserDataHandler
     @@Level[list]:  3
     @@SpecLevel:3
  @Method:
     @@Name:  getUserData
     @@Return:
        @@@Type:  DOMUserData
     @@Param:
        @@@Name:  key
        @@@Type:  DOMString
     @@Level[list]:  3
     @@SpecLevel:3

  @IntMethod:
    @@Name: newObject
    @@Description:
      @@@lang:en
      @@@@: Construct an object for a new instance of the "Node".
    @@Return:
      @@@Type:
        ManakaiDOM:ManakaiDOMNodeObject
      @@@Description:
        @@@@lang:en
        @@@@@: The object for the "Node" to be created.
      @@@Def:
        @@@@Type:
          lang:Perl
        @@@@@:
          my $node = $r = __CLASS{ManakaiDOMNodeObject::}__->__INT{new}__;
          push @{$node->{<Q:TreeCore:origin>}}, <Q:infoset:parent>,
                                                <Q:infoset:ownerElement>;
          push @{$node->{<Q:TreeCore:subnode>}}, <Q:infoset:children>;
          push @{$node->{<Q:TreeCore:subnode2>}}, <Q:infoset:attributes>;
          push @{$node->{<Q:TreeCore:irefnode>}}, <Q:DOMCore:ownerDocument>;
          $node->{<Q:infoset:children>} = [];
          $node->{<Q:infoset:attributes>} = {};
          $node->{<Q:DOMCore:hasFeature>}->{XML} = true;
              ## More consideration required for the feature
       @@@ImplNote:
         @@@@lang:en
         @@@@@:
           Other properties required to be a legal "Node" object:
           <Q:DOMCore:nodeType>.
         \
           Optional properties: <Q:infoset:localName>, <Q:infoset:prefix>,
           <Q:DOMCore:ownerDocument> (required for an <IF:Node> whose 
           type is other than <IF:Document> and <IF:DocumentType>), 
           <Q:infoset:namespaceName>, <Q:DOMCore:name>,
           <Q:DOMCore:read-only>.

  @IntMethod:
    @@Name: getNodeReference
    @@Description:
      @@@lang:en
      @@@@:
        Create a new "Node" object blessed with the appropriate class.
      \
        To create a new "Document", use the internal method 
        "newByDocumentType" of the "Document" interface.
    @@Param:
      @@@Name: object
      @@@Type:
        ManakaiDOM:ManakaiDOMNodeObject
      @@@Description:
        @@@@lang:en
        @@@@@: The node object referred to.
    @@Param:
      @@@Name:noSpecializedInterface
      @@@Type:boolean
      @@@Description:
        @@@@lang:en
        @@@@@:
          Whether the specialized interface for the type (such as 
          element type or document type) is selected if available.
      @@@InCase:
        @@@@Value:true
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            Specialized object is not returned however the 
            configuration parameter value is set.
          \
            Note that even if the specialized interface is not 
            selected by default, the specialized object can be 
            obtained from <M:Node.getFeature>.
      @@@InCase:
        @@@@Value:false
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            Specialized object is returned unless the configuration 
            disables it.
    @@Return:
      @@@Type: Node
      @@@Description:
        @@@@lang:en
        @@@@@: The node reference.
      @@@Def:
        @@@@Type:
          lang:Perl
        @@@@@:
          my $nt = $object->{<Q:DOMCore:nodeType>};
                        ## Condition sensitive
          my $class = q<__CLASS{Node}__>;
          if ($nt eq <Q:infoset:Element>) {
            ## TODO: Find class by namespace URI and local name
                       ## Condition sensitive
            $class = q<__CLASS{Element}__>;
          } elsif ($nt eq <Q:infoset:Attribute>) {
            ## TODO: Find class by namespace URI and local name
                       ## Condition sensitive
            $class = q<__CLASS{Attr}__>;
          } elsif ($nt eq <Q:DOMCore:Text>) {
                       ## Condition sensitive
            $class = q<__CLASS{Text}__>;
          } elsif ($nt eq <Q:infoset:Comment>) {
                       ## Condition sensitive
            $class = q<__CLASS{Comment}__>;
          } elsif ($nt eq <Q:infoset:Document>) {
            ## TODO: Find class by doctype
                       ## Condition sensitive
            $class = q<__CLASS{Document}__>;
          } elsif ($nt eq <Q:DOMCore:DocumentFragment>) {
                       ## Condition sensitive
            $class = q<__CLASS{DocumentFragment}__>;
          } elsif ($nt eq <Q:DOMXML:EntityReference>) {
                       ## Condition sensitive
            $class = q<__CLASS{EntityReference}__>;
          } elsif ($nt eq <Q:infoset:ProcessingInstruction>) {
            ## TODO: Find class by namespace URI and local name
                       ## Condition sensitive
            $class = q<__CLASS{ProcessingInstruction}__>;
          } elsif ($nt eq <Q:DOMXML:Entity>) {
                       ## Condition sensitive
            $class = q<__CLASS{Entity}__>;
          } elsif ($nt eq <Q:DOMXML:CDATASection>) {
                       ## Condition sensitive
            $class = q<__CLASS{CDATASection}__>;
          } elsif ($nt eq <Q:infoset:Notation>) {
                       ## Condition sensitive
            $class = q<__CLASS{Notation}__>;
          } else {
            __EXCEPTION{
              ManakaiDOMImplementationException.MDOM_DEBUG_BUG::
                <Q:MDOM_EXCEPTION:values> => {
                  <Q:DOMCore:nodeType> => $nt,
                },
            }__;
          }
          $r = $object->__SUPER{ManakaiDOMNodeObject::}__::__INT{newReference}__
                                                                      ($class);
    @@Level[list]:
       1
       2
       3

## IF: Node

IF:
  @Name:  NodeList
  @Description:
    @@lang:en
    @@@:
      An ordered collection of nodes.
    \
      Node objects contained in a <IF:NodeList> may be accessed 
      by an ordinal index, starting from zero.
    \
    \ <IF:NodeList> objects are <QUOTE:live>.
  @ImplNote:
    @@lang:en
    @@@:
      How this collection is implemented is not defined or constrained.
  @IsAbstract:1
  @Method:
     @@Name:  item
     @@Description:
       @@@lang:en
       @@@@:
         Return an item in the collection.
     @@Param:
        @@@Name:  index
        @@@Type:  unsigned-long
        @@@Description:
          @@@@lang:en
          @@@@@: The index of the item into the collection.
     @@Return:
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@: 
            The node at the "index"th position in the collection.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The "index" is invalid, i.e. it is greater than or 
              equal to the number of nodes in the list.
     @@IsAbstract:1
  @Attr:
     @@Name:  length
     @@Description:
       @@@lang:en
       @@@@:
         The number of nodes in the list.
     @@Get:
        @@@Type:  unsigned-long
     @@IsAbstract:1

IF:
  @Name:  NamedNodeMap
  @Description:
    @@lang:en
    @@@:
      A unordered collection of nodes that can be accessed by name. 
    \
      Node objects contained in a <IF:NamedNodeMap> may also 
      be accessed by an ordinal index, starting from zero. 
      However, this is simply to allow convenient enumeration of 
      a <IF:NamedNodeMap>.
    \
    \ <IF:NamedNodeMap> objects are <QUOTE:live>.
  @IsAbstract:1
  @Method:
     @@Name:  getNamedItem
     @@Description:
       @@@lang:en
       @@@@: Retrieve a node specified by name.
     @@NSVersion:getNamedItemNS
     @@Param:
        @@@Name:  name
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The "nodeName" of a node to retrieve.
     @@Return:
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@:
            A "Node" (of any type) with the specified "nodeName".
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The "name" does not identify any node in this map.
      @@IsAbstract:1
  @Method:
     @@Name:  setNamedItem
     @@Description:
       @@@lang:en
       @@@@:
         Add a node using its "nodeName" attribute.  If a node with 
         that name is already present in this map, it is replaced 
         by the new one.  Replacing a node by itself has no effect.
     @@ImplNote:
       @@@lang:en
       @@@@: "Replacing ... no effect" is clarified by the DOM Level 2 Errata. 
     @@NSVersion:setNamedItemNS
     @@Param:
        @@@Name:  arg
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@: A node to store in this map.
     @@Return:
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@:
            If the "arg" node replaces an existing node, the replaced node.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The "arg" node does not replace any node in the map.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: WRONG_DOCUMENT_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The "arg" node was created from a different document.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: This map is read-only.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: INUSE_ATTRIBUTE_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The "arg" node is an "Attr" that is already an 
              attribute of another "Element" object.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: HIERARCHY_REQUEST_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              An attempt is made to add a node that is unable to 
              belong to this map.
          @@@@SpecLevel:2
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@: This exception has added by the DOM Level 2 Errata.
     @@ImplNote:
       @@@lang:en
       @@@@:
         Is it possible to add the node that has namespace URI and local 
         name?  If it is, can that node be retrieved via the "NS" methods? 
         Is it possible to add the node that has "nodeName" crushing 
         with existing "NS" node?
    @@IsAbstract:1
  @Method:
     @@Name:  removeNamedItem
     @@Description:
        @@@lang:en
        @@@@:
          Remove a node specified by name.
     @@NSVersion:removeNamedItemNS
     @@Param:
        @@@Name:  name
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The "nodeName" of the node to remove.
     @@Return:
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@: The node removed from this map.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NOT_FOUND_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: There is no node named "name" in this map.
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              The DOM Level 1 First Edition also said that if there 
              is no node named "name", "null" is returned.  It has 
              removed by the DOM Level 1 First Edition Errata.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: This map is read-only.
          @@@@SpecLevel:1
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              This exception is added by the DOM Level 1 First Edition Errata.
    @@IsAbstract:1
  @Method:
     @@Name:  item
     @@Description:
       @@@lang:en
       @@@@: Return an item in the map.
     @@Param:
        @@@Name:  index
        @@@Type:  unsigned-long
        @@@Description:
          @@@@lang:en
          @@@@@: The index of the item into this map.
     @@Return:
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@: The node at the "index"th position in the map.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: 
              The "index" is invalid, i.e. it is greater than or 
              equal to the number of nodes in this map.
      @@IsAbstract:1
  @Attr:
     @@Name:  length
     @@Description:
       @@@lang:en
       @@@@: The number of nodes in this map.
     @@Get:
        @@@Type:  unsigned-long
    @@IsAbstract:1
  @Method:
     @@Name:  getNamedItemNS
     @@Description:
       @@@lang:en
       @@@@:
         Retrieve a node specified by local name and namespace URI.
     @@NoNSVersion:getNamedItem
     @@Param:
        @@@Name:  namespaceURI
        @@@Type:
          ManakaiDOM:ManakaiDOMNamespaceURI
        @@@Description:
          @@@@lang:en
          @@@@@:
            The namespace URI of the node to retrieve.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The node to retrieve has no namespace.
     @@Param:
        @@@Name:  localName
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The local name of the node to retrieve.
     @@Return:
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@:
            A "Node" (of any type) with the specified local name and 
            namespace URI.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The "namespaceURI" and "localName" does not identify 
              any node in this map.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NOT_SUPPORTED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The DOM implementation does not support the feature "XML" and 
              the language exposed through the "Document" does not 
              support XML Namespaces.
     @@IsAbstract:1
     @@Level[list]:  2
     @@SpecLevel:2
     @@ImplNote:
       @@@lang:en
       @@@@:
         The DOM Level 2 Specification said that the HTML-only DOM 
         implenentations do not need to implement this method. 
         The DOM Level 2 Errata and the DOM Level 3 Specification 
         says that the <Q:NOT_SUPPORTED_ERR> should be raised.
  @Method:
     @@Name:  setNamedItemNS
     @@Description:
       @@@lang:en
       @@@@:
         Add a node using its "namespaceURI" and "localName". 
         If a node with that namespace URI and that local name 
         is already present in this map, it is replaced by the new one. 
         Replacing a node by itself has no effect.
     @@ImplNote:
       @@@lang:en
       @@@@: "Replacing ... no effect" is clarified by the DOM Level 2 Errata. 
     @@NoNSVersion:setNamedItem
     @@Param:
        @@@Name:  arg
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@: A node to store in this map.
     @@Return:
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@:
            If the "arg" node replaces an existing node, the replaced node.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The "arg" node replaces no existing node in this map.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: WRONG_DOCUMENT_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The "arg" node was created from a different document.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: This map is read-only.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: INUSE_ATTRIBUTE_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The "arg" node is an "Attr" that is already an 
              attribute of another "Element" object.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: HIERARCHY_REQUEST_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              An attempt is made to add a node that is unable to 
              belong to this map.
          @@@@SpecLevel:2
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@: This exception has added by the DOM Level 2 Errata.
         @@@Exception:
           @@@@Type: DOMException
           @@@@Name: NOT_SUPPORTED_ERR
           @@@@Description:
             @@@@@lang:en
             @@@@@@:
             The DOM implementation does not support the feature "XML" and 
             the language exposed through the "Document" does not 
             support XML Namespaces
           @@@@SpecLevel:2
     @@IsAbstract:1
     @@ImplNote:
       @@@lang:en
       @@@@:
         The DOM Level 2 Specification said that the HTML-only DOM 
         implenentations do not need to implement this method. 
         The DOM Level 2 Errata and the DOM Level 3 Specification 
         says that the NOT_SUPPORTED_ERR should be raised.
     @@Level[list]:  2
     @@SpecLevel:2
  @Method:
     @@Name:  removeNamedItemNS
     @@Description:
        @@@lang:en
        @@@@:
          Remove a node specified by local name and namespace URI.
     @@NoNSVersion:removeNamedItem
     @@Param:
        @@@Name:  namespaceURI
        @@@Type:
          ManakaiDOM:ManakaiDOMNamespaceURI
        @@@Description:
          @@@@lang:en
          @@@@@: The namespace URI of the node to remove.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The node to remove has no namespace.
     @@Param:
        @@@Name:  localName
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The local name of the node to remove.
     @@Return:
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@: The node removed from this map.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NOT_FOUND_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              There is no node with the specified "namespaceURI" and 
              "localName" in the map.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: This map is read-only.
         @@@Exception:
           @@@@Type: DOMException
           @@@@Name: NOT_SUPPORTED_ERR
           @@@@Description:
             @@@@@lang:en
             @@@@@@:
             The DOM implementation does not support the feature "XML" and 
             the language exposed through the "Document" does not 
             support XML Namespaces
     @@IsAbstract:1
     @@ImplNote:
       @@@lang:en
       @@@@:
         The DOM Level 2 Specification said that the HTML-only DOM 
         implenentations do not need to implement this method. 
         The DOM Level 2 Errata and the DOM Level 3 Specification 
         says that the NOT_SUPPORTED_ERR should be raised.
     @@Level[list]:  2
     @@SpecLevel:2
## IF:NamedNodeMap

IF:
  @Name:  CharacterData
  @ISA: Node
  @ImplNote:
    @@lang:en
    @@@:
      The DOM implementation may not put arbitary limits on the 
      amount of the data that may be stored in a "CharacterData" node. 
      However, the implementation limits may mean that the entirety of 
      a node's data may not fit into a single "DOMString".
  @ImplNote:
    @@lang:en
    @@@:
      "Comment" and "Text" are "CharacterData".  "CDATASection" is a "Text".
  @Attr:
     @@Name:  data
     @@Description:
       @@@lang:en
       @@@@: The character data of the node.
     @@Get:
        @@@Type:  DOMString
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: DOMSTRING_SIZE_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The attribute would return more characters than 
              fit in a "DOMString" variable on the implementation 
              platform.
        @@@Def:
          @@@@Type:
            lang:dis
          @@@@GetProp:
            infoset:content
     @@Set:
        @@@Type:  DOMString
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The node is read-only.
        @@@Def:
          @@@@Type:
            lang:dis
          @@@@SetProp:
            @@@@@@:
              infoset:content
            @@@@@CheckReadOnly:1
  @IntMethod:
    @@Name: getDOMStringValue
    @@Description:
      @@@lang:en
      @@@@: Get the value as DOMString.
    @@Return:
      @@@Type: DOMString
      @@@Def:
        @@@@Type:
          lang:Perl
        @@@@@:
          if (ref $self->{<Q:TreeCore:node>}->{<Q:infoset:content>} and
              $self->{<Q:TreeCore:node>}->{<Q:infoset:content>}
                   ->isa ('__IIF{DOMString::}__')) {
            $r = $self->{<Q:TreeCore:node>}->{<Q:infoset:content>};
          } else {
            $r = \$self->{<Q:TreeCore:node>}->{<Q:infoset:content>};
            if (defined $$r) {
              __CODE{DOMString: s => r, r => r}__;
            } else {
              $r = null;
            }
          }
  @Attr:
     @@Name:  length
     @@Description:
       @@@lang:en
       @@@@: 
         The number of 16-bit units of the "data".
     @@Get:
        @@@Type:  unsigned-long
        @@@Description:
          @@@@lang:en
          @@@@@: The number of 16-bit units of the "data".
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            __INT{{getDOMStringValue}}__;
            if (defined $r) {
              __DEEP{
                $r = $r->length;
              }__;
            } else {
              $r = 0;
            }
  @Method:
     @@Name:  substringData
     @@Description:
       @@@lang:en
       @@@@:
         Extract a range of data from the node.
     @@Param:
        @@@Name:  offset
        @@@Type:  unsigned-long
        @@@Description:
          @@@@lang:en
          @@@@@: Start offset of substring to extract.
     @@Param:
        @@@Name:  count
        @@@Type:  unsigned-long
        @@@Description:
          @@@@lang:en
          @@@@@:
          The number of 16-bit units to extract.  If the sum of the
          parameters offset and count exceeds the length of the
          DOMString then all 16-bit units from offset to the end
          of the DOMString are returned.
    @@Return:
      @@@Type: DOMString
      @@@Description:
        @@@@lang:en
        @@@@@: The specified substring.
      @@@Exception:
        @@@@Type: DOMException
        @@@@Name: INDEX_SIZE_ERR
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The specified "offset" is negative or greater than
            the number of 16-bit units in the "DOMString", or the specified
            "count" is negative.
      @@@Exception:
        @@@@Type: DOMException
        @@@@Name: DOMSTRING_SIZE_ERR
        @@@@Description:
          @@@@@lang:en
          @@@@@@: The specified range does not fit into a "DOMString".
      @@@Exception:
        @@@@Type: 
          ManakaiDOM:ManakaiDOMImplementationException
        @@@@Name: MDOM_INDEX_IN_SURROGATE_PAIR
        @@@@Description:
          @@@@@lang:en
          @@@@@@: An attempt is made to break surrogate pair.
      @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            __INT{{getDOMStringValue}}__;
            __DEEP{
              $r = $r->__INT{substring}__ ($offset, $count);
            }__;
  @Method:
     @@Name:  appendData
     @@Description:
       @@@lang:en
       @@@@:
         Append the string to the end of the character data of the node.
     @@Param:
        @@@Name:  arg
        @@@Type:  DOMString
        @@@Descroption:
          @@@@lang:en
          @@@@@: The string to append.
     @@Return:
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: This node is read-only.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            my $node = $self->{<Q:TreeCore:node>};
            if ($node->{<Q:DOMCore:read-only>}) {
              __EXCEPTION{
                DOMException.NO_MODIFICATION_ALLOWED_ERR.
                MDOM_EXCEPTION:NOMOD_THIS::
              }__;
            }
            $node->{<Q:infoset:content>} .= $arg;
  @Method:
     @@Name:  insertData
     @@Description:
       @@@lang:en
       @@@@: Insert a string at the specified 16-bit unit offset. 
    @@Param:
      @@@Name: offset
      @@@Type: unsigned-long
      @@@Description:
        @@@@lang:en
        @@@@@: The offset from which to insert.
    @@Param:
      @@@Name: arg
      @@@Type: DOMString
      @@@Description:
        @@@@lang:en
        @@@@@: The DOMString to insert.
    @@Return:
      @@@Exception:
        @@@@Type: DOMException
        @@@@Name: INDEX_SIZE_ERR
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The specified "offset" is negative or greater than
            the number of 16-bit units in the DOMString.
      @@@Exception:
        @@@@Type: DOMException
        @@@@Name: NO_MODIFICATION_ALLOWED_ERR
        @@@@Description:
          @@@@@lang:en
          @@@@@@: This node is read-only.
      @@@Exception:
        @@@@Type: 
          ManakaiDOM:ManakaiDOMImplementationException
        @@@@Name: MDOM_INDEX_IN_SURROGATE_PAIR
        @@@@Description:
          @@@@@lang:en
          @@@@@@: An attempt is made to break surrogate pair.
      @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
          if ($self->{<Q:TreeCore:node>}->{<Q:DOMCore:read-only>}) {
            __EXCEPTION{
              DOMException.NO_MODIFICATION_ALLOWED_ERR.
              MDOM_EXCEPTION:NOMOD_THIS::
            }__;
          }
          my $r;
            __INT{{getDOMStringValue}}__;
            __DEEP{
              $r = $r->__INT{insert}__ ($offset, $arg);
            }__;
  @Method:
     @@Name:  deleteData
     @@Description:
        @@@lang:en
        @@@@: 
          Remove a range of 16-bit units from the node.
    @@Param:
      @@@Name: offset
      @@@Type: unsigned-long
      @@@Description:
        @@@@lang:en
        @@@@@: The offset from which to start removing.
    @@Param:
      @@@Name: count
      @@@Type: unsigned-long
      @@@Description:
        @@@@lang:en
        @@@@@:
          The number of 16-bit units to delete.  If the sum of the
          parameters offset and count exceeds the length of the
          DOMString then all 16-bit units from offset to the end
          of the DOMString are deleted.
    @@Return:
      @@@Exception:
        @@@@Type: DOMException
        @@@@Name: INDEX_SIZE_ERR
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The specified "offset" is negative or greater than
            the number of 16-bit units in the DOMString, or the specified
            "count" is negative.
      @@@Exception:
        @@@@Type: DOMException
        @@@@Name: NO_MODIFICATION_ALLOWED_ERR
        @@@@Description:
          @@@@@lang:en
          @@@@@@: This node is read-only.
      @@@Exception:
        @@@@Type: 
          ManakaiDOM:ManakaiDOMImplementationException
        @@@@Name: MDOM_INDEX_IN_SURROGATE_PAIR
        @@@@Description:
          @@@@@lang:en
          @@@@@@: 
            An attempt is made to break surrogate pair.
      @@@Def:
        @@@@Type:
          lang:Perl
        @@@@@:
          if ($self->{<Q:TreeCore:node>}->{<Q:DOMCore:read-only>}) {
            __EXCEPTION{
              DOMException.NO_MODIFICATION_ALLOWED_ERR.
              MDOM_EXCEPTION:NOMOD_THIS::
            }__;
          }
          my $r;
            __INT{{getDOMStringValue}}__;
            __DEEP{
              $r->__INT{delete}__ ($offset, $count);
            }__;
  @Method:
    @@Name:  replaceData
    @@Description:
      @@@lang:en
      @@@@:
        Replace the characters starting at the specified 16-bit unit 
        offset with the specified string.
    @@Param:
      @@@Name: offset
      @@@Type: unsigned-long
      @@@Description:
        @@@@lang:en
        @@@@@: The offset from which to start replacing.
    @@Param:
      @@@Name: count
      @@@Type: unsigned-long
      @@@Description:
        @@@@lang:en
        @@@@@:
          The number of 16-bit units to replace.  If the sum of the
          parameters offset and count exceeds the length of the
          DOMString then all 16-bit units from offset to the end
          of the DOMString are replaced.
    @@Param:
      @@@Name: arg
      @@@Type: DOMString
      @@@Description:
        @@@@lang:en
        @@@@@: The DOMString with which the range is replaced.
    @@Return:
      @@@Exception:
        @@@@Type: DOMException
        @@@@Name: INDEX_SIZE_ERR
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The specified "offset" is negative or greater than
            the number of 16-bit units in the DOMString, or the specified
            "count" is negative.
      @@@Exception:
        @@@@Type: DOMException
        @@@@Name: NO_MODIFICATION_ALLOWED_ERR
        @@@@Description:
          @@@@@lang:en
          @@@@@@: This node is read-only.
      @@@Exception:
        @@@@Type: 
          ManakaiDOM:ManakaiDOMImplementationException
        @@@@Name: MDOM_INDEX_IN_SURROGATE_PAIR
        @@@@Description:
          @@@@@lang:en
          @@@@@@: An attempt is made to break surrogate pair.
      @@@Def:
        @@@@Type:
          lang:Perl
        @@@@@:
          if ($self->{<Q:TreeCore:node>}->{<Q:DOMCore:read-only>}) {
            __EXCEPTION{
              DOMException.NO_MODIFICATION_ALLOWED_ERR.
              MDOM_EXCEPTION:NOMOD_THIS::
            }__;
          }
          my $r;
            __INT{{getDOMStringValue}}__;
            __DEEP{
              $r = $r->__INT{replace}__ ($offset, $count, $arg);
            }__;
  @ReAttr:
     @@Name:  nodeValue
     @@Description:
       @@@lang:en
       @@@@: The value of this node.
     @@Get:
        @@@Type:  DOMString
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: DOMSTRING_SIZE_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: 
              The node value, i.e. same as "data".
        @@@Def:
          @@@@Type: 
            lang:Perl
          @@@@@: __INT{{data}}__;
     @@Set:
        @@@Type:  DOMString
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: 
              The node is read-only.
        @@@Description:
          @@@@lang:en
          @@@@@:
            New node value.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
                           ## Condition sensitive
            __DEEP{ $self->__SUPER{CharacterData}__::data ($given) }__;
    @@Redefine: Node
    @@Level[list]:
      1
      2
      3
    @@SpecLevel:1
  @ReAttr:
     @@Name:  textContent
     @@Description:
       @@@lang:en
       @@@@: The text content of this node and its descendants.
     @@ImplNote:
        @@@lang:en
        @@@@:
          CharacterData->data == CharacterData->nodeValue == 
          CharacterData->textContent.
     @@Get:
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            The text content of this node, i.e. the "nodeValue".
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: DOMSTRING_SIZE_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The attribute would return more characters than 
              fit in a "DOMString" variable on the implementation 
              platform.
        @@@Def:
          @@@@Type: 
            lang:Perl
          @@@@@: __INT{{data}}__;
     @@Set:
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            The new text content of the node.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: 
              The text content is set to the empty.  Note that the 
              DOM specification does not specify how to treat the "null".
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: This node is read-only.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
                           ## Condition sensitive
            __DEEP{ $self->__SUPER{CharacterData}__::data ($given) }__;
     @@Level[list]:
        3
     @@SpecLevel:3
     @@Redefine: Node
## IF: CharacterData

IF:
  @Name:  Attr
  @Description:
    @@lang:en
    @@@:
      An attribute in an "Element" object.
    \
      The DOM Core treats the attribute values as a plain string, even if 
      the schema language defines them as having tokenized types.
  @ISA:  Node
  @Require:
    @@Module:
      @@@Def:
        @@@@Type:
          lang:Perl
        @@@@use: 
          @@@@@@:
            Char::Class::XML
          @@@@@Import[list]:
            InXML_NameStartChar10
            InXMLNameChar10
            InXMLNameStartChar11
            InXMLNameChar11
      @@@Condition[list]:
        DOM1
        DOM2
        DOM3
  @ImplNote:
    @@lang:en
    @@@:
      If the implementation knows about the schema in use when 
      the attribute value is changed, and it is of a different type 
      than "CDATA", it may normalize it at that time. [SVG DOM, DOM 3]
  @Attr:
     @@Name:  name
     @@Description:
       @@@lang:en
       @@@@: The name of this attribute.
     @@Get:
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The attribute name. 
        @@@InCase:
          @@@@Label: Qualified name
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              If the "localName" is different from "null".
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            my $node = $self->{<Q:TreeCore:node>};
            if (defined $node->{<Q:infoset:localName>}) {
              $r = (defined $node->{<Q:infoset:prefix>} ?
                   $node->{<Q:infoset:prefix>} . ':' : '') . 
                   $node->{<Q:infoset:localName>};
            } else {
              $r = $node->{<Q:DOMCore:name>};
            }
        @@@ImplNote:
          @@@@lang:en
          @@@@@:
            "Element.tagName" is defined to return the uppercase name 
            if the document is an HTML document.  "Attr.name" is not 
            defined so.
  @Attr:
     @@Name:  specified
     @@Description:
       @@@lang:en
       @@@@: Whether this attribute is specified explicitly in the document.
     @@Get:
        @@@Type:  boolean
        @@@InCase:
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              This attribute is explicitly given a value in the 
              instance document.
        @@@InCase:
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              This attribute is not explicitly given a value in the 
              instance document.
        @@@Def:
          @@@@Type:
             lang:dis
          @@@@GetProp:
             infoset:specified
    @@ImplNote:
       @@@lang:en
       @@@@:
         This attribute is set to "true" if the DOM application 
         changed the value of this attribute node (even if it ends up 
         having the same value as the default value).
    @@ImplNote:
       @@@lang:en
       @@@@:
         The implementation may handle attributes with default 
         values from other schemas than DTD and XML Schema but 
         the DOM application should use "normalizeDocument" to 
         guarantee this information is up-to-date.
    @@ImplNote:
      @@@lang:en
      @@@@:
        Removing an attribute node may generate a new attribute 
        node with the default value and "specified" set to "false".
      \
        When "normalizeDocument" is invoked, non-"specified" 
        attribute nodes are recomputed according to the defaulu 
        attribute value.
    @@ImplNote:
      @@@lang:en
      @@@@: 
        The DOM Level 1 Specification (Second Edition) and the 
        DOM Level 2 Specification says that if the "ownerElement" 
        is "null", "specified" is always "true".  The DOM Level 3 
        Specification does not address this case.
## TODO: Some mechanism required to turn the "specified" attribute "true" 
## when some node operation is done.
  @Attr:
     @@Name:  value
     @@Description:
       @@@lang:en
       @@@@: The value of this attribute.
     @@Get:
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            The attribute value as a string.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            __DEEP{
              $r = $self->{<Q:TreeCore:node>}
                  ->__SUPER{ManakaiDOMNodeObjectNode::}__::__INT{textContent}__;
            }__;
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              This definition might be updated when the new level 
              of the DOM is introduced.
        @@@ImplNote:
          @@@@lang:en
          @@@@@:
            Although the specification says nothing, the Attr->value and 
            Attr->textContent should have the same value by nature.
     @@Set:
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            Setting of this attribute creates a "Text" node with 
            the value specified and replaces child nodes of this 
            node with it.
        @@@ImplNote:
          @@@@lang:en
          @@@@@:
            The DOM implementation may normalize the value [DOM 3, SVG DOM].
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: This node is read-only.
          @@@@SpecLevel:1
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              This exception is added in the DOM Level 1 Errata and 
              incorporated into the DOM Level 1 Second Edition.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            __DEEP{
              $self->__SUPER{Attr::DOM3}__::textContent ($given);
            }__;
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              This definition might be updated when the new level 
              of the DOM is introduced.
      @@SpecLevel[list]:
         1
      @@Level[list]: 1
            
  @Attr:
     @@Name:  ownerElement
     @@Description:
       @@@lang:en
       @@@@:
         The element to which this attribute is attached.
     @@Get:
        @@@Type:  Element
        @@@Description:
          @@@@lang:en
          @@@@@: The "Element" node.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: This attribute is not in use.
        @@@Def:
          @@@@Type:
            lang:dis
                     ## Conditional
          @@@@GetPropNode:
            infoset:ownerElement
     @@Level[list]:  
        2
        3
     @@SpecLevel:2
  @Attr:
     @@Name:  schemaTypeInfo
     @@Description:
       @@@lang:en
       @@@@:
         The type information associated with this node.
        \
         Note that while this type information is guarantee 
         to be correct after loading the validation, 
         it may not be reliable if the node was moved.
     @@Get:
        @@@Type:  TypeInfo
        @@@Description:
          @@@@lang:en
          @@@@@: The type information.
     @@Level[list]:  3
     @@SpecLevel:3
  @Attr:
     @@Name:  isId
     @@Description:
       @@@lang:en
       @@@@:
         Whether this attribute is known to be of type ID or not.
     @@ImplNote:
       @@@lang:en
       @@@@:
         The ways to determine whether an attribute node is known 
         to contain an identifier:
        \
         PSVI - If validation occurred using an XML Schema, the PSVI 
         contributions values are used to determine whether this 
         attribute is a Schema-determined ID attribute as the 
         XPointer specification defines, i.e. iif one of the following 
         is true:
        \
         1. The attribute information item has a [memeber type definition] or 
         [type definition] property whose value in turn has [name] eq "ID" 
         and [target namespace] eq "http://www.w3.org/2001/XMLSchema".
        \
         2. The attribute information item has a [base type definition] 
         property whose value in turn has [name] eq "ID"
         and [target namespace] eq "http://www.w3.org/2001/XMLSchema".
        \
         3. The attribute information item has a [base type definition] 
         property whose value has a [base type definition] property 
         whose value has ... whose value in turn has [name] eq "ID"
         and [target namespace] eq "http://www.w3.org/2001/XMLSchema".
        \
         4. The attribute information item has a [type definition name] 
         eq "ID" and a [type definition namespace] eq 
         "http://www.w3.org/2001/XMLSchema".
        \
         5. The attribute information item has a 
         [member type definition name] eq "ID" and a 
         [member type definition namespace] eq 
         "http://www.w3.org/2001/XMLSchema".
        \
         DTD - If validation occured using a DTD, the infoset 
         [type definition] value is used to determine whether 
         this attribute is a DTD-determined ID attribute as the 
         XPointer framework specification defines.  Iif the 
         attribute information item has a [type definition] property 
         eq "ID", it is a DTD-determined ID attribute.
        \
         User-determined - If the methods "setIdAttribute", 
         "setIdAttributeNS", "setIdAttributeNode" was used, 
         it is an user-determined ID attribute.
        \
         Externally-determined - Other mechanisms, including other 
         schema languages than DTD and XML Schema may provide 
         ways to determine whether it is a ID attribute.
     @@Get:
        @@@Type:  boolean
        @@@InCase:
          @@@@Value:true
          @@@@Description:
            @@@@@lang:en
            @@@@@@: 
              This attribute is a ID attribute.
        @@@InCase:
          @@@@Value:false
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              This attribute is not a ID attribute.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            $r = $self->{<Q:TreeCore:node>}->{<Q:DOMCore:userDeterminedId>};
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              TODO: Support non-user-determined ID attributes.
     @@Level[list]:  3
     @@SpecLevel:3
  
  @ReAttr:
     @@Name:  localName
     @@Description:
       @@@lang:en
       @@@@: The local part of the qualified name of this "Attr" node.
     @@Get:
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            The local name of the attribute.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The node is created with a DOM Level 1 methods.
        @@@Def:
          @@@@Type:
            lang:dis
          @@@@GetProp:
            infoset:localName
     @@Level[list]:  2
     @@SpecLevel:2
     @@Redefine: Node
  @ReMethod:
     @@Name:  lookupPrefix
     @@Description:
       @@@lang:en
       @@@@:
         Lookup the namespace prefix associated to the given namespace 
         URI, starting from this node.
       \
         The default namespace declarations are ignored by this method. 
         To lookup default namespace, use the <M:Node.isDefaultNamespace>
         method.
     @@Param:
        @@@Name:  namespaceURI
        @@@Type:
          ManakaiDOM:ManakaiDOMNamespaceURI
        @@@Description:
          @@@@lang:en
          @@@@@: The namespace URI to look for.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Always <DOM:null> will be returned.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Always <DOM:null> will be returned.
     @@Return:
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            An associated namespace prefix.
          \
            If more than one prefix are associated to the 
            namespace URI, which is returned is implementation 
            dependent.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              No namespace prefix is found.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            if (not defined $namespaceURI) {
              $r = null;
            } else {
              my $n = $self->{<Q:TreeCore:node>};
              if ($n->{<Q:infoset:ownerElement>}) {
                $r = $n->{<Q:infoset:ownerElement>}
                       ->__SUPER{ManakaiDOMNodeObjectNode::}__::__INT{lookupNamespacePrefix}__
                                ($namespaceURI, $n->{<Q:infoset:ownerElement>});
              } else {
                $r = null;
              }
            }
     @@Level[list]:  3
     @@SpecLevel:3
     @@Redefine:Node
  @ReAttr:
     @@Name:  namespaceURI
     @@Description:
       @@@lang:en
       @@@@:
         The namespace URI of this node.
     @@Get:
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The namespace URI.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The namespace URI is unspecified (the attribute in a 
              per-element-type partition) or 
              the node is created with a DOM Level 1 methods.
        @@@Def:
          @@@@Type:
            lang:dis
          @@@@GetProp:
            infoset:namespaceName
     @@Level[list]:  2
     @@SpecLevel:2
     @@Redefined: Node
  @ReAttr:
    @@Name: nodeName
    @@Description:
      @@@lang:en
      @@@@: The node name.
    @@NSVersion[list]:
      Node.prefix
      Node.localName
    @@Get:
      @@@Type: DOMString
      @@@Description:
        @@@@lang:en
        @@@@@:
          The attribute name.  It is same as the value of the "name" 
          attribute.
      @@@Def:
        @@@@Type:
          lang:Perl
        @@@@@: __INT{{name}}__;
    @@Redefine: Node
  @ReAttr:
    @@Name: nodeType
    @@Description:
      @@@lang:en
      @@@@: The type of this node.
    @@Get:
      @@@Type: unsigned-short
      @@@InCase:
        @@@@Label: ATTRIBUTE_NODE
        @@@@Description:
          @@@@@lang:en
          @@@@@@: The node is an "Attr".
      @@@Def:
        @@@@Type:
          lang:Perl
        @@@@@: $r = __SUPER{Node}__->ATTRIBUTE_NODE;
    @@Redefine: Node
  @ReAttr:
     @@Name:  nodeValue
     @@Description:
       @@@lang:en
       @@@@: The value of this node.
     @@Get:
        @@@Type:  DOMString
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: DOMSTRING_SIZE_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: 
              The attribute value, i.e. same as "value".
        @@@Def:
          @@@@Type: 
            lang:Perl
          @@@@@: __INT{{value}}__;
     @@Set:
        @@@Type:  DOMString
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: 
              The node is read-only.
        @@@Description:
          @@@@lang:en
          @@@@@:
            New node value.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
                           ## Condition sensitive
            __DEEP{ $self->__SUPER{Attr}__::name ($given) }__;
    @@Redefine: Node
    @@Level[list]:
        1
        2
        3
    @@SpecLevel:1
  @ReAttr:
     @@Name:  prefix
     @@Description:
       @@@lang:en
       @@@@: The namespace prefix of this node.
     @@Get:
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The namespace prefix.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Either the namespace prefix is unspecified or the node 
              is created with a DOM Level 1 method.
        @@@Def:
          @@@@Type:
            lang:dis
          @@@@GetProp:
            infoset:prefix
     @@Set:
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            The namespace prefix.
            Note that setting this attribute has no effect if 
            the namespace prefix is defined to be "null".
          \
            Note also that changing the prefix of an attribute that 
            is known to have a default value does not make a 
            new attribute with the default value and the original 
            prefix appear, since the "namespaceURI" and "localName" 
            do not change.  This is different from the defaulting 
            mechanism of the DTD, which is namespace-unaware.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The namespace prefix is unspecified.
        @@@InCase:
          @@@@Value: \
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The result is implementation dependent in DOM Level 3.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: INVALID_CHARACTER_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The specified prefix contains an illegal character 
              accoding to the XML version in use in the document.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: This node is read-only.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NAMESPACE_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Either the specified prefix is malformed per the 
              XML Namespace specification, non-"null" prefix is 
              specified but the "namespaceURI" of this node is "null", 
              the specified prefix is "xml" and the "namespaceURI" 
              of this node is different from 
              "http://www.w3.org/XML/1998/namespace", the specified 
              prefix is "xmlns" and the "namespaceURI" of this node 
              is different from "http://www.w3.org/2000/xmlns/", or 
              the "qualifiedName" of this node is "xmlns".
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            my $node = $self->{<Q:TreeCore:node>};
            my $docnode = $node->{<Q:DOMCore:ownerDocument>};
            my $version;
            __CODE{XMLVersion: out => version, docNode => docnode}__;
            if (not defined $version) {
              __WARNING{
                ManakaiDOMImplementationWarning.ATTR_SET_NO_EFFECT.
                MDOM_EXCEPTION:MDOM_DOC_NOSUPPORT_XML::
              }__;
            } elsif (not defined $node->{<Q:infoset:localName>}) {
              __WARNING{
                ManakaiDOMImplementationWarning.ATTR_SET_NO_EFFECT.
                MDOM_EXCEPTION:MDOM_NODE_NOSUPPORT_XMLNS::
              }__;
            } elsif ($node->{<Q:DOMCore:read-only>}) {
              __WARNING{
                DOMException.NO_MODIFICATION_ALLOWED_ERR.
                MDOM_EXCEPTION:NOMOD_THIS::
              }__;
            } elsif (not defined $node->{<Q:infoset:prefix>} and
                     $node->{<Q:infoset:localName>} and
                     $node->{<Q:infoset:localName>} eq 'xmlns') {
              __EXCEPTION{
                DOMException.NAMESPACE_ERR.
                MDOM_EXCEPTION:MDOM_NS_QNAME_IS_XMLNS::
              }__;
            } else {
              __CODE{CheckNCName: ncname => given, version => version,
                                  empty => warn3}__;
              if (not defined $given) {
                #
              } else {
                if (not defined $node->{<Q:infoset:namespaceName>}) {
                  __EXCEPTION{
                    DOMException.NAMESPACE_ERR.
                    MDOM_NS_PREFIX_WITH_NULL_URI::
                      <Q:infoset:prefix> => $given,
                  }__;
                } elsif ($given eq 'xml' and
                         (not $node->{<Q:infoset:namespaceName>} or
                          $node->{<Q:infoset:namespaceName>} ne <Q:xml:>)) {
                  __EXCEPTION{
                    DOMException.NAMESPACE_ERR.
                    MDOM_EXCEPTION:MDOM_NS_XML_WITH_OTHER_URI::
                      <Q:infoset:namespaceName>
                           => $node->{<Q:infoset:namespaceName>},
                  }__;
                } elsif ($given eq 'xmlns' and
                         (not $node->{<Q:infoset:namespaceName>} or
                          $node->{<Q:infoset:nanespaceName>} eq <Q:xmlns:>)) {
                  __EXCEPTION{
                    DOMException.NAMESPACE_ERR.
                    MDOM_EXCEPTION:MDOM_NS_XMLNS_WITH_OTHER_URI::
                      <Q:infoset:namespaceName>
                           => $node->{<Q:infoset:namespaceName>},
                  }__;
                }
              }
              $node->{<Q:infoset:prefix>} = $given;
            }
     @@Level[list]:
       2
       3
     @@SpecLevel:2
     @@Redefine: Node

  @IntMethod:
    @@Name: newObject
    @@Description:
      @@@lang:en
      @@@@:
        Construct an object for a new instance of the <IF:Attr> node.
    @@Return:
      @@@Type:
        ManakaiDOM:ManakaiDOMNodeObject
      @@@Description:
        @@@@lang:en
        @@@@@:
          The new object for the <IF:Attr> node.
      @@@Def:
        @@@@Type:
          lang:Perl
        @@@@@:
               ## Condition sensitive
          $r = __CLASS{Node}__->__INT{newObject}__;
          $r->{<Q:DOMCore:nodeType>} = <Q:infoset:Attribute>;
     @@Level[list]:
       1
       2
       3
     @@ImplNote:
       @@@lang:en
       @@@@:
         Other properties required to be a legal <IF:Attr> object:
         Either <Q:DOMCore:name> or <Q:infoset:localName>, 
         <Q:DOMCore:ownerDocument>.
       \
         Other available properties: <Q:infoset:prefix>, 
         <Q:DOMCore:read-only>, <Q:infoset:specified>, 
         <Q:infoset:ownerElement>, <Q:infoset:children>, 
         <Q:infoset:namespaceName>, <Q:DOMCore:userDeterminedId>.
## IF:Attr

IF:
  @Name:  Element
  @Description:
    @@lang:en
    @@@:
      An element in a document.
  @ISA:  Node
  @Require:
    @@Module:
      @@@Def:
        @@@@Type:
          lang:Perl
        @@@@use: 
          @@@@@@:
            Char::Class::XML
          @@@@@Import[list]:
            InXML_NameStartChar10
            InXMLNameChar10
            InXML_NCNameStartChar10
            InXMLNCNameChar10
            InXMLNameStartChar11
            InXMLNameChar11
            InXMLNCNameStartChar11
            InXMLNCNameChar11
      @@@Condition[list]:
        DOM1
        DOM2
        DOM3
  @Attr:
     @@Name:  tagName
     @@Description:
       @@@lang:en
       @@@@: The element type name of this node.
     @@Get:
        @@@Type:  DOMString
        @@@InCase:
          @@@@Label: Qualified name
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              If the "localName" is different from "null".
        @@@InCase:
          @@@@Label: Canonical uppercase form of name
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              If this is an HTML element node.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            my $node = $self->{<Q:TreeCore:node>};
            if (defined $node->{<Q:infoset:localName>}) {
              $r = (defined $node->{<Q:infoset:prefix>} ?
                   $node->{<Q:infoset:prefix>} . ':' : '') . 
                   $node->{<Q:infoset:localName>};
            } else {
              $r = $node->{<Q:DOMCore:name>};
            }
 ## TODO: toUpper if HTML
 ## ISSUE: What to do if XHTML?       
  @IntMethod:
    @@Name:selectAttrNodeObject
    @@Description:
      @@@lang:en
      @@@@:
        Select an <IF:ManakaiDOMNodeObject> object that represents an 
        <IF:Attr> node.
    @@NSVersion:selectAttrNodeObjectNS
    @@Param:
      @@@Name:name
      @@@Type:
        DOMMain:DOMString
      @@@Description:
        @@@@lang:en
        @@@@@:
          The name of the attribute to select.
    @@Return:
      @@@Type: 
        ManakaiDOM:ManakaiDOMNodeObject
      @@@Description:
        @@@@lang:en
        @@@@@:
          The <IF:ManakaiDOMNodeObject> object.
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@: There is no such attribute.
      @@@Def:
        @@@@Type:
          lang:Perl
        @@@@@:
            my $attr = $self->{<Q:TreeCore:node>}->{<Q:infoset:attributes>};
            if ($attr->{<Q:ManakaiDOM:noNS>}->{$name}) {
              $r = $attr->{<Q:ManakaiDOM:noNS>}->{$name};
              __WHEN{IS{<Q:DOMCore:removeAttribute>}::
                delete $attr->{<Q:ManakaiDOM:noNS>};
              }__;
            } elsif ($name eq 'xmlns') {
              for my $a (keys %{$attr->{<Q:xmlns:>}||{}}) {
                if ($attr->{<Q:xmlns:>}->{$a}->{<Q:infoset:localName>}) {
                  $r = $attr->{<Q:xmlns:>}->{$a};
                  __WHEN{IS{<Q:DOMCore:removeAttribute>}::
                    delete $attr->{<Q:xmlns:>}->{$a};
                  }__;
                  last;
                }
              }
            } elsif ($name eq 'xmlns:xmlns') {
              # 
            } else {
              for my $ns (keys %$attr) {
                if ($ns eq <Q:ManakaiDOM:noNS>) {
                  # 
                } else {
                  for my $a (keys %{$attr->{$ns}||{}}) {
                    if (defined $attr->{$ns}->{$a}->{<Q:infoset:prefix>} and
                        $attr->{$ns}->{$a}->{<Q:infoset:prefix>}.':'.
                        $attr->{$ns}->{$a}->{<Q:infoset:localName>} eq $name) {
                      $r = $attr->{$ns}->{$a};
                      __WHEN{IS{<Q:DOMCore:removeAttribute>}::
                        delete $attr->{$ns}->{$a};
                      }__;
                      last;
                    } elsif (not defined $attr->{$ns}->{$a}->{<Q:infoset:prefix>}
                         and
                         $attr->{$ns}->{$a}->{<Q:infoset:localName>} eq $name) {
                      $r = $attr->{$ns}->{$a};
                      __WHEN{IS{<Q:DOMCore:removeAttribute>}::
                        delete $attr->{$ns}->{$a};
                      }__;
                      last;
                    }
                  }
                }
              }
            }
  @Method:
     @@Name:  getAttribute
     @@Description:
       @@@lang:en
       @@@@:
         Retrieve an attribute value by name.
     @@NSVersion:getAttribute
     @@Param:
        @@@Name:  name
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            The name of the attribute to retrieve.
     @@Return:
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            The <IF:Attr> value as a string.
        @@@InCase:
          @@@@Value:\
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              That attribute does not have a specified or default value.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            __INT{{selectAttrNodeObject}}__;
            if ($r) {
                         ## Condition insensitive
              $r = $r->__SUPER{ManakaiDOMNodeObjectNode::}__::__INT{textContent}__;
            }
    @@SpecLevel:1
  @Method:
     @@Name:  setAttribute
     @@Description:
       @@@lang:en
       @@@@:
         Add a new attribute.  If an attribute with that name is 
         already present in the element, its value is changed. 
     @@NSVersion:setAttributeNS
     @@Param:
        @@@Name:  name
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The name of the attribute to create or alter.
     @@Param:
        @@@Name:  value
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The value to set.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              How <DOM:null> should be treated is not specified. 
              This DOM implementation converts it to an empty string.
     @@Return:
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:INVALID_CHARACTER_ERR
          @@@@SubType:
            @@@@@QName:
              MDOM_EXCEPTION:MDOM_BAD_NAME
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <P:name> is not a legal SGML or XML <XML:Name>.
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:NO_MODIFICATION_ALLOWED_ERR
          @@@@SubType:
            @@@@@QName:
              MDOM_EXCEPTION:NOMOD_THIS
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                This (<IF:Element>) node is read-only.
            @@@@@SpecLevel:1
          @@@@SubType:
            @@@@@QName:
              MDOM_EXCEPTION:NOMOD_ATTR
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <IF:Attr> node to edit is read-only.
            @@@@@SpecLevel[list]:
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            if ($self->{<Q:TreeCore:node>}->{<Q:DOMCore:read-only>}) {
              __EXCEPTION{
                DOMException.NO_MODIFICATION_ALLOWED_ERR.
                MDOM_EXCEPTION:NOMOD_THIS::
              }__;
            }
            my $r;
            __INT{{selectAttrNodeObject}}__;
            my $node = $self->{<Q:TreeCore:node>};
            if ($r) {
              if ($r->{<Q:DOMCore:read-only>}) {
                __EXCEPTION{
                  DOMException.NO_MODIFICATION_ALLOWED_ERR.
                  MDOM_EXCEPTION:NOMOD_ATTR::
                }__;
              }
              my @children = @{$r->{<Q:infoset:children>}};
              $r->{<Q:infoset:children>} = [];
              for (@children) {
                delete $_->{<Q:infoset:parent>};
                $_->__SUPER{ManakaiDOMNodeObject::}__::__INT{orphanate}__;
              }
            } else {
                   ## Condition insensitive
              $r = __CLASS{Attr::}__->__INT{newObject}__;
              $r->{<Q:DOMCore:name>} = $name;
              $node->__SUPER{ManakaiDOMNodeObject::}__::__INT{importTree}__ ($r);
              $r->{<Q:infoset:ownerElement>} = $node;
              $r->{<Q:DOMCore:ownerDocument>} = $node
                                                 ->{<Q:DOMCore:ownerDocument>};
              $node->{<Q:infoset:attributes>}
                   ->{<Q:ManakaiDOM:noNS>}->{$name} = $r;
            }
                       ## Condition insensitive
            my $text = __CLASS{Text::}__->__INT{newObject}__;
            $node->__SUPER{ManakaiDOMNodeObject::}__::__INT{importTree}__
                                                                    ($text);
            $text->{<Q:infoset:content>} = defined $value ? $value : '';
            $text->{<Q:DOMCore:ownerDocument>} = $self->{<Q:TreeCore:node>}
                                                 ->{<Q:DOMCore:ownerDocument>};
            $text->{<Q:infoset:parent>} = $r;
            $r->{<Q:infoset:children>} = [$text];
            $r->{<Q:infoset:specified>} = true;
     @@SpecLevel:1
  @Method:
     @@Name:  removeAttribute
     @@Description:
       @@@lang:en
       @@@@:
         Remove an attribute by name.
       \
         If a default value for the removed attribute is defined in 
         the DTD, a new attribute immediately appears.  The DOM 
         implementation may handle default values from other schemas.
     @@NSVersion:removeAttributeNS
     @@Param:
        @@@Name:  name
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            The name of the attribute to remove.  If no attribute 
            with this <P:name> is found, this method has no effect.
     @@Return:
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:NO_MODIFICATION_ALLOWED_ERR
          @@@@SubType:
            @@@@@QName:
              MDOM_EXCEPTION:NOMOD_THIS
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                This (<IF:Element>) node is read-only.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            if ($self->{<Q:TreeCore:node>}->{<Q:DOMCore:read-only>}) {
              __EXCEPTION{
                DOMException.NO_MODIFICATION_ALLOWED_ERR.
                MDOM_EXCEPTION:NOMOD_THIS::
              }__;
            }
            my $r;
            __INT{{selectAttrNodeObject: <Q:DOMCore:removeAttribute>}}__;
            if ($r) {
              delete $r->{<Q:infoset:ownerElement>};
              $r->__SUPER{ManakaiDOMNodeObject::}__::__INT{orphanate}__;
            }
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              TODO: Default attribute
  @Method:
     @@Name:  getAttributeNode
     @@Description:
       @@@lang:en
       @@@@:
         Retrieve an attribute node by name.
     @@NSVersion:getAttributeNodeNS
     @@Param:
        @@@Name:  name
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            The name (<A:nodeName>) of the attribute to retrieve.
     @@Return:
        @@@Type:  Attr
        @@@Description:
          @@@@lang:en
          @@@@@:
            The <IF:Attr> node with the specified name.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: There is no such attribute.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            __INT{{selectAttrNodeObject}}__;
            if ($r) {
                         ## Condition sensitive
              $r = __CLASS{Node}__->__INT{getNodeReference}__ ($r, $self);
            }
    @SpecLevel:1
    @Level[list]:
     1
     2
     3
  @Method:
     @@Name:  setAttributeNode
     @@Description:
       @@@lang:en
       @@@@:
         Add a new attribute node.  If an attribute with that name is 
         already present in the element, it is replaced by the new one. 
         \
         Replacing an attribute node by itself has no effect.
     @@NSVersion:setAttributeNodeNS
     @@Param:
        @@@Name:  newAttr
        @@@Type:  Attr
        @@@Description:
          @@@@lang:en
          @@@@@: 
            The <IF:Attr> node to add to the attribute list.
     @@Return:
        @@@Type:  Attr
        @@@Description:
          @@@@lang:en
          @@@@@:
            The replaced <IF:Attr> node.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              No <IF:Attr> node was replaced.
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:WRONG_DOCUMENT_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The <P:newAttr> node was created from a different document.
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:NO_MODIFICATION_ALLOWED_ERR
          @@@@SubType:
            @@@@@QName:
              MDOM_EXCEPTION:NOMOD_THIS
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@: 
                This (<IF:Element>) node is read-only.
         @@@Exception:
           @@@@Type:DOMException
           @@@@Name:INUSE_ATTRIBUTE_ERR
           @@@@Description:
             @@@@@lang:en
             @@@@@@:
               The <P:newAttr> node is already used as an attribute 
               of another <IF:Element> object.
         @@@Def:
           @@@@Type:
             lang:Perl
           @@@@@:
            if ($self->{<Q:TreeCore:node>}->{<Q:DOMCore:read-only>}) {
              __EXCEPTION{
                DOMException.NO_MODIFICATION_ALLOWED_ERR.
                MDOM_EXCEPTION:NOMOD_THIS::
              }__;
            }
            my $attrNode = $newAttr->{<Q:TreeCore:node>};
            if ($attrNode->{<Q:infoset:ownerElement>}) {
              __EXCEPTION{
                DOMException.INUSE_ATTRIBUTE_ERR::
                  <Q:MDOM_EXCEPTION:param-name> => 'newAttr',
              }__;
            } elsif ($attrNode->{<Q:DOMCore:ownerDocument>}
                              ->{<Q:TreeCore:nodeID>} ne
                     $self->{<Q:TreeCore:node>}->{<Q:DOMCore:ownerDocument>}
                          ->{<Q:TreeCore:nodeID>}) {
              __EXCEPTION{
                DOMException.WRONG_DOCUMENT_ERR::
              }__;
            }

            if (defined $attrNode->{<Q:infoset:localName>}) {
              $r = $self->{<Q:TreeCore:node>}->{<Q:infoset:attributes>}
                     ->{defined $attrNode->{<Q:infoset:namespaceName>}
                              ? $attrNode->{<Q:infoset:namespaceName>}
                              : <Q:null:>}
                     ->{$attrNode->{<Q:infoset:localName>}};
            } else {
              $r = $self->{<Q:TreeCore:node>}->{<Q:infoset:attributes>}
                     ->{<Q:ManakaiDOM:noNS>}
                     ->{$attrNode->{<Q:DOMCore:name>}};
            }

            if ($r->{<Q:TreeCore:nodeID>} eq $attrNode->{<Q:TreeCore:nodeID>}) {
              __WARNING{
                ManakaiDOMImplementationException.
                MDOM_REPLACE_BY_ITSELF_NO_EFFECT::
              }__;
              $r = $newAttr;
            } else {
              $attrNode->{<Q:infoset:ownerElement>} = $self->{<Q:TreeCore:node>};
              if (defined $attrNode->{<Q:infoset:localName>}) {
                $self->{<Q:TreeCore:node>}->{<Q:infoset:attributes>}
                     ->{defined $attrNode->{<Q:infoset:namespaceName>}
                              ? $attrNode->{<Q:infoset:namespaceName>}
                              : <Q:null:>}
                     ->{$attrNode->{<Q:infoset:localName>}} = $attrNode;
              } else {
                $self->{<Q:TreeCore:node>}->{<Q:infoset:attributes>}
                     ->{<Q:ManakaiDOM:noNS>}
                     ->{$attrNode->{<Q:DOMCore:name>}} = $attrNode;
              }
              if ($r) {
                delete $r->{<Q:infoset:parent>};
                $r->__SUPER{ManakaiDOMNodeObject::}__::__INT{orphanate}__;
                     ## Condition sensitive
                $r = __CLASS{Node}__->__INT{getNodeReference}__ ($r, $self)
                  if defined wantarray;
              }
            }
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              It is unclear whether the node should be returned if 
              the node is <QUOTE:replaced> by itself.
    @@Level[list]:
       1
       2
       3
    @@SpecLevel:1
  @Method:
     @@Name:  removeAttributeNode
     @@Description:
        @@@lang:en
        @@@@:
          Remove the specified attribute node.
        \
          If a default value for the removed attribute is defined 
          in the DTD, a new node immediately appears.  The DOM 
          implementation may handle default values from other schemas.
     @@Param:
        @@@Name:  oldAttr
        @@@Type:  Attr
        @@@Description:
          @@@@lang:en
          @@@@@: 
            The attribute node to remove from the attribute list.
     @@Return:
        @@@Type:  Attr
        @@@Description:
          @@@@lang:en
          @@@@@:
            The attribute node that was removed.
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:NO_MODIFICATION_ALLOWED_ERR
          @@@@SubType:
            @@@@@QName:
              MDOM_EXCEPTION:NOMOD_THIS
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                This (<IF:Element>) node is read-only.
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:NOT_FOUND_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The <P:oldAttr> node is not an attribute of this element.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            my $node = $self->{<Q:TreeCore:node>};
            if ($node->{<Q:DOMCore:read-only>}) {
              __EXCEPTION{
                DOMException.NO_MODIFICATION_ALLOWED_ERR.
                MDOM_EXCEPTION:NOMOD_THIS::
              }__;
            }
            $r = $oldAttr;
            my $attrNode = $r->{<Q:TreeCore:node>};
            FIND: {
              my $attrID = $attrNode->{<Q:TreeCore:nodeID>};
              for my $ns (keys %{$node->{<Q:infoset:attributes>}}) {
                for my $ln (keys %{$node->{<Q:infoset:attributes>}->{$ns}}) {
                  if ($attrID eq $node->{<Q:infoset:attributes>}->{$ns}->{$ln}
                                      ->{<Q:TreeCore:nodeID>}) {
                    delete $node->{<Q:infoset:attributes>}->{$ns}->{$ln};
                    last FIND;
                  }
                }
              }
              __EXCEPTION{
                DOMException.NOT_FOUND_ERR::
                  <Q:MDOM_EXCEPTION:param-name> => 'oldAttr',
              }__;
            }
            delete $attrNode->{<Q:infoset:ownerElement>};
            $attrNode->__SUPER{ManakaiDOMNodeObject::}__::__INT{orphanate}__; 
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              TODO: Default attribute
  @Method:
     @@Name:  getElementsByTagName
     @@Param:
        @@@Name:  name
        @@@Type:  DOMString
     @@Return:
        @@@Type:  NodeList
  @IntMethod:
     @@Name: selectAttrNodeObjectNS
     @@Description:
       @@@lang:en
       @@@@:
         Select a <IF:ManakaiDOMNodeObject> object that represents 
         an <IF:Attr> node, by namespace URI and local name.
     @@NoNSVersion:selectAttrNodeObject
     @@Param:
        @@@Name:  namespaceURI
        @@@Type:
          ManakaiDOM:ManakaiDOMNamespaceURI
        @@@Description:
          @@@@lang:en
          @@@@@:
            The namespace URI of the attribute to select.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The attribute to select has no namespace.
     @@Param:
        @@@Name:  localName
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The local name of the attribute to select.
     @@Return:
        @@@Type:
          ManakaiDOM:ManakaiDOMNodeObject
        @@@Description:
          @@@@lang:en
          @@@@@:
            The <IF:ManakaiDOMNOdeObject> object.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: There is no such attribute.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            my $attr = $self->{<Q:TreeCore:node>}->{<Q:infoset:attributes>};
            $namespaceURI = <Q:null:> unless defined $namespaceURI;
            $r = $attr->{$namespaceURI}->{$localName};
            __WHEN{IS{<Q:DOMCore:removeAttribute>}::
              delete $attr->{$namespaceURI}->{$localName} if $r;
            }__;
    @@ImplNote:
      @@@lang:en
      @@@@:
        The same method is defined in <IF:ManakaiDOMAttributes>.
  @Method:
     @@Name:  getAttributeNS
     @@Description:
       @@@lang:en
       @@@@:
         Retrieve an attribute value by local name and namespace URI.
     @@NoNSVersion:getAttribute
     @@Param:
        @@@Name:  namespaceURI
        @@@Type:
          ManakaiDOM:ManakaiDOMNamespaceURI
        @@@Description:
          @@@@lang:en
          @@@@@:
            The namespace URI of the attribute to retrieve.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The attribute to retrieve has no namespace.
     @@Param:
        @@@Name:  localName
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The local name of the attribute to retrieve.
     @@Return:
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            The <IF:Attr> value as a string.
        @@@InCase:
          @@@@Value:\
          @@@@Description:
            @@@@@lang:en
            @@@@@@: That attribute does not have a specified or default value.
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:NOT_SUPPORTED_ERR
          @@@@SubType:
            @@@@@QName:
              MDOM_EXCEPTION:MDOM_IMPL_NOSUPPORT_XML
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The DOM implementation does not support the feature 
                <Feature:XML> and the language exposed through the 
                <IF:Document> does not support XML Namespaces.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            __INT{{selectAttrNodeObjectNS}}__;
            if ($r) {
                         ## Condition insensitive
              $r = $r->__SUPER{ManakaiDOMNodeObjectNode}__::__INT{textContent}__;
            }
     @@Level[list]:  2
     @@SpecLevel:2
  @Method:
     @@Name:  setAttributeNS
     @@Description:
       @@@lang:en
       @@@@:
         Add a new attribute.  If an attribute with the same 
         local name and namespace URI is already present on the element, 
         its value is changed and its prefix is also changed to be the 
         prefix of the new qualified name. 
     @@NoNSVersion:setAttribute
     @@Param:
        @@@Name:  namespaceURI
        @@@Type:
          ManakaiDOM:ManakaiDOMNamespaceURI
        @@@Description:
          @@@@lang:en
          @@@@@:
            The namespace URI of the attribute to create or alter.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: 
              The attribute to create or alter has no namespace.
     @@Param:
        @@@Name:  qualifiedName
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:The qualified name of the attribute to create or alter.
     @@Param:
        @@@Name:  value
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The value to set.
     @@Return:
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: INVALID_CHARACTER_ERR
          @@@@SubType:
            @@@@@QName:
              MDOM_EXCEPTION:MDOM_BAD_NAME
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <P:qualifiedName> is not an XML <XML:Name>.
          @@@@SpecLevel:2
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NAMESPACE_ERR
          @@@@SubType:
            @@@@@QName:
              MDOM_EXCEPTION:MDOM_NS_MALFORMED_QNAME
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@: 
                The <P:qualifiedName> is malformed as a qualified name.
            @@@@@SpecLevel:2
          @@@@SubType:
            @@@@@QName:
              MDOM_EXCEPTION:MDOM_NS_PREFIX_WITH_NULL_URI
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <P:qualifiedName> has a prefix and the
                <P:namespaceURI> is <DOM:null>.
            @@@@@SpecLevel:2
          @@@@SubType:
            @@@@@QName:
              MDOM_EXCEPTION:MDOM_NS_XML_WITH_OTHER_URI
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <P:qualifiedName> has a prefix that is <XML:xml> and the
                <P:namespaceURI> is different from
                <URI:http://www.w3.org/XML/1998/namespace>.
            @@@@@SpecLevel:2
          @@@@SubType:
            @@@@@QName:
              MDOM_EXCEPTION:MDOM_NS_XMLNS_WITH_OTHER_URI
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <P:qualifiedName> has a prefix that is <XML:xmlns> and
                the <P:namespaceURI> is different from the
                <URI:http://www.w3.org/2000/xmlns>.
            @@@@@SpecLevel:3
          @@@@SubType:
            @@@@@QName:
              MDOM_EXCEPTION:MDOM_NS_XMLNSQ_WITH_OTHER_URI
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <P:qualifiedName> is <XML:xmlns> and
                the <P:namespaceURI> is different from the
                <URI:http://www.w3.org/2000/xmlns>.
            @@@@@SpecLevel:2
          @@@@SubType:
            @@@@@QName:
              MDOM_EXCEPTION:MDOM_NS_OTHER_WITH_XML_URI
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <P:namespaceURI> is 
                <URI:http://www.w3.org/XML/1998/namespace> and the 
                prefix of the <P:qualifiedName> is different from 
                <XML:xml>.
            @@@@@SpecLevel[list]:
          @@@@SubType:
            @@@@@QName:
              MDOM_EXCEPTION:MDOM_NS_OTHER_WITH_XMLNS_URI
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <P:namespaceURI> is <URI:http://www.w3.org/2000/xmlns> and 
                neither the <P:qualifiedName> nor its prefix is <XML:xmlns>.
            @@@@@SpecLevel:3
          @@@@SubType:
            @@@@@QName:
              MDOM_EXCEPTION:MDOM_NS_XMLNS_XMLNS
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <P:qualifiedName> is <XML:xmlns:xmlns>.
            @@@@@SpecLevel[list]:
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@: Is no-prefix with URI is OK?
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:NOT_SUPPORTED_ERR
          @@@@SubType:
            @@@@@QName:
              MDOM_EXCEPTION:MDOM_DOC_NOSUPPORT_XML
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                This document does not support the <Feature:XML> 
                feature.
            @@@@@SpecLevel:2
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:NO_MODIFICATION_ALLOWED_ERR
          @@@@SubType:
            @@@@@QName:
              MDOM_EXCEPTION:NOMOD_THIS
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                This (<IF:Element>) node is read-only.
            @@@@@SpecLevel:2
          @@@@SubType:
            @@@@@QName:
              MDOM_EXCEPTION:NOMOD_ATTR
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <IF:Attr> node to edit is read-only.
            @@@@@SpecLevel[list]:
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            if ($self->{<Q:TreeCore:node>}->{<Q:DOMCore:read-only>}) {
              __EXCEPTION{
                DOMException.NO_MODIFICATION_ALLOWED_ERR.
                MDOM_EXCEPTION:NOMOD_THIS::
              }__;
            }
            my ($version, $prefix, $localName);
            my $docNode = $self->{<Q:TreeCore:node>};
            __CODE{XMLNS: docNode => docNode,
                          qualifiedName => qualifiedName,
                          namespaceURI => namespaceURI,
                          out-version => version,
                          out-localName => localName,
                          out-prefix => prefix}__;
            my $r;
            __INT{{selectAttrNodeObjectNS}}__;
            my $node = $self->{<Q:TreeCore:node>};
            if ($r) {
              if ($r->{<Q:DOMCore:read-only>}) {
                __EXCEPTION{
                  DOMException.NO_MODIFICATION_ALLOWED_ERR.
                  MDOM_EXCEPTION:NOMOD_ATTR::
                }__;
              }
              my @children = @{$r->{<Q:infoset:children>}};
              $r->{<Q:infoset:children>} = [];
              for (@children) {
                delete $_->{<Q:infoset:parent>};
                $_->__SUPER{ManakaiDOMNodeObject::}__::__INT{orphanate}__;
              }
            } else {
                   ## Condition insensitive
              $r = __CLASS{Attr::}__->__INT{newObject}__;
              $node->__SUPER{ManakaiDOMNodeObject::}__::__INT{importTree}__ ($r);
              $r->{<Q:DOMCore:ownerDocument>} = $node
                                                 ->{<Q:DOMCore:ownerDocument>};
              $r->{<Q:infoset:prefix>} = $prefix;
              $r->{<Q:infoset:namespaceName>} = $namespaceURI;
              $r->{<Q:infoset:localName>} = $localName;
              $r->{<Q:infoset:ownerElement>} = $node;
              $node->{<Q:infoset:attributes>}
                   ->{defined $namespaceURI ? $namespaceURI : <Q:null:>}
                   ->{$localName} = $r;
            }
                       ## Condition insensitive
            my $text = __CLASS{Text::}__->__INT{newObject}__;
            $node->__SUPER{ManakaiDOMNodeObject::}__::__INT{importTree}__ 
                                                                    ($text);
            $text->{<Q:DOMCore:ownerDocument>} = $self->{<Q:TreeCore:node>}
                                                 ->{<Q:DOMCore:ownerDocument>};
            $text->{<Q:infoset:content>} = defined $value ? $value : '';
            $text->{<Q:infoset:parent>} = $r;
            $r->{<Q:infoset:children>} = [$text];
            $r->{<Q:infoset:specified>} = true;
     @@Level[list]:  2
     @@SpecLevel:2
  @Method:
     @@Name:  removeAttributeNS
     @@Description:
       @@@lang:en
       @@@@:
         Remove an attribute by local name and namespace URI.
       \
         If a default value for the removed attribute is defined 
         in the DTD, a new attribute is immediately appears. 
         The DOM implementation may handle default values from 
         other schemas.
     @@NoNSVersion:removeAttribute
     @@Param:
        @@@Name:  namespaceURI
        @@@Type:
          ManakaiDOM:ManakaiDOMNamespaceURI
        @@@Description:
          @@@@lang:en
          @@@@@: The namespace URI of the attribute to remove.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The attribute to remove has no namespace.
     @@Param:
        @@@Name:  localName
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            The local name of the attribute to remove.
          \
            If no attribute with this <P:localName> and 
            <P:namespaceURI> is found, this method has no effect.
     @@Return:
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:NO_MODIFICATION_ALLOWED_ERR
          @@@@SubType:
            @@@@@QName:
              MDOM_EXCEPTION:NOMOD_THIS
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                This (<IF:Element>) node is read-only.
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:NOT_SUPPORTED_ERR
          @@@@SubType:
            @@@@@QName:
              MDOM_EXCEPTION:MDOM_IMPL_NOSUPPORT_XML
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The DOM implementation does not support the feature 
                <Feature:XML> and the language exposed through 
                the <IF:Document> does not support XML Namespaces.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            if ($self->{<Q:TreeCore:node>}->{<Q:DOMCore:read-only>}) {
              __EXCEPTION{
                DOMException.NO_MODIFICATION_ALLOWED_ERR.
                MDOM_EXCEPTION:NOMOD_THIS::
              }__;
            }
            my $r;
            __INT{{selectAttrNodeObjectNS: <Q:DOMCore:removeAttribute>}}__;
            if ($r) {
              delete $r->{<Q:infoset:ownerElement>};
              $r->__SUPER{ManakaiDOMNodeObject::}__::__INT{orphanate}__;
            }
         @@@@ImplNote:
           @@@@@lang:en
           @@@@@@:
             TODO: default attribute
           \
             Almost same as <M:ManakaiDOMAttributes.removeNamedItemNS>.
     @@Level[list]:  2
     @@SpecLevel:2
  @Method:
     @@Name:  getAttributeNodeNS
     @@Description:
       @@@lang:en
       @@@@:
         Retrieve an <IF:Attr> node by local name and namespace URI.
     @@NoNSVersion:getAttributeNode
     @@Param:
        @@@Name:  namespaceURI
        @@@Type:
          ManakaiDOM:ManakaiDOMNamespaceURI
        @@@Description:
          @@@@lang:en
          @@@@@: The namespace URI of the attribute to retrieve.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The attribute to retrieve have no namespace.
     @@Param:
        @@@Name:  localName
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The local name of the attribute to retrieve.
     @@Return:
        @@@Type:  Attr
        @@@Description:
          @@@@lang:en
          @@@@@:
            The <IF:Attr> node.
        @@@@InCase:
          @@@@@Value:
            @@@@@@is-null:1
          @@@@@Description:
            @@@@@@lang:en
            @@@@@@@: There is no such attribute.
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:NOT_SUPPORTED_ERR
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The DOM implementation does not support the feature 
                <Feature:XML> and the language exposed through the 
                <IF:Document> does not support XML Namespaces.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            __INT{{selectAttrNodeObjectNS}}__;
            if ($r) {
                         ## Condition sensitive
              $r = __CLASS{Node}__->__INT{getNodeReference}__ ($r, $self);
            }
     @@Level[list]:
        2
        3
     @@SpecLevel:2
  @Method:
     @@Name:  setAttributeNodeNS
     @@Description:
       @@@lang:en
       @@@@:
         Add a new attribute.  If an attribute with that local name and 
         namespace URI is already present in the element, 
         it is replaced by the new node.
       \
         Replacing an attribute node by itself has no effect.
     @@NoNSVersion:setAttributeNS
     @@Param:
        @@@Name:  newAttr
        @@@Type:  Attr
        @@@Description:
          @@@@lang:en
          @@@@@:
            The attribute node to add to the attribute list.
     @@Return:
        @@@Type:  Attr
        @@@Description:
          @@@@lang:en
          @@@@@:
            The <IF:Attr> node replaced by the <P:newAttr> node.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The <P:newAttr> node replaces no existing node.
         @@@Exception:
           @@@@Name:WRONG_DOCUMENT_ERR
           @@@@Type:DOMException
           @@@@Description:
             @@@@@lang:en
             @@@@@@:
               The <P:newAttr> node was created from a different document.
         @@@Exception:
           @@@@Name:NO_MODIFICATION_ALLOWED_ERR
           @@@@Type:DOMException
           @@@@SubType:
             @@@@@QName: 
               MDOM_EXCEPTION:NOMOD_THIS
             @@@@@Description:
               @@@@@@lang:en
               @@@@@@@:
                 This (<IF:Element>) node is read-only.
         @@@Exception:
           @@@@Name:INUSE_ATTRIBUTE_ERR
           @@@@Type:DOMException
           @@@@Description:
             @@@@@lang:en
             @@@@@@:
               The <P:newAttr> node is already used as an attribute 
               of another <IF:Element> object.
         @@@Exception:
           @@@@Name:NOT_SUPPORTED_ERR
           @@@@Type:DOMException
           @@@@SubType:
             @@@@@QName:
               MDOM_EXCEPTION:MDOM_IMPL_NOSUPPORT_XML
             @@@@@Description:
               @@@@@@lang:en
               @@@@@@@:
                 The DOM implementation does not support the feature 
                 <Feature:XML> and the language exposed through the 
                 <IF:Document> does not support XML Namespaces.
             @@@@@SpecLevel:2
           @@@@SubType:
             @@@@@QName:
               MDOM_EXCEPTION:MDOM_NODE_NOSUPPORT_XMLNS
             @@@@@Description:
               @@@@@@lang:en
               @@@@@@@:
                 The <P:newAttr> node does not support XML Namespace.
             @@@@@SpecLevel[list]:
         @@@Def:
           @@@@Type:
             lang:Perl
           @@@@@:
            if ($self->{<Q:TreeCore:node>}->{<Q:DOMCore:read-only>}) {
              __EXCEPTION{
                DOMException.NO_MODIFICATION_ALLOWED_ERR.
                MDOM_EXCEPTION:NOMOD_THIS::
              }__;
            }
            my $attrNode = $newAttr->{<Q:TreeCore:node>};
            if ($attrNode->{<Q:infoset:ownerElement>}) {
              __EXCEPTION{
                DOMException.INUSE_ATTRIBUTE_ERR::
                  <Q:MDOM_EXCEPTION:param-name> => 'newAttr',
              }__;
            } elsif ($attrNode->{<Q:DOMCore:ownerDocument>}
                              ->{<Q:TreeCore:nodeID>} ne
                     $self->{<Q:TreeCore:node>}->{<Q:DOMCore:ownerDocument>}
                          ->{<Q:TreeCore:nodeID>}) {
              __EXCEPTION{
                DOMException.WRONG_DOCUMENT_ERR::
              }__;
            }

            if (defined $attrNode->{<Q:infoset:localName>}) {
              $r = $self->{<Q:TreeCore:node>}->{<Q:infoset:attributes>}
                     ->{defined $attrNode->{<Q:infoset:namespaceName>}
                              ? $attrNode->{<Q:infoset:namespaceName>}
                              : <Q:null:>}
                     ->{$attrNode->{<Q:infoset:localName>}};
            } else {
              __EXCEPTION{
                DOMException.NOT_SUPPORTED_ERR.
                MDOM_EXCEPTION:MDOM_NODE_NOSUPPORT_XMLNS::
                  <Q:MDOM_EXCEPTION:param-name> => 'newAttr',
              }__;
            }

            if ($r->{<Q:TreeCore:nodeID>} eq $attrNode->{<Q:TreeCore:nodeID>}) {
              __WARNING{
                ManakaiDOMImplementationException.
                MDOM_REPLACE_BY_ITSELF_NO_EFFECT::
              }__;
              $r = $newAttr;
            } else {
              $attrNode->{<Q:infoset:ownerElement>} = $self->{<Q:TreeCore:node>};
              if (defined $attrNode->{<Q:infoset:localName>}) {
                $self->{<Q:TreeCore:node>}->{<Q:infoset:attributes>}
                     ->{defined $attrNode->{<Q:infoset:namespaceName>}
                              ? $attrNode->{<Q:infoset:namespaceName>}
                              : <Q:null:>}
                     ->{$attrNode->{<Q:infoset:localName>}} = $attrNode;
              } else {
                $self->{<Q:TreeCore:node>}->{<Q:infoset:attributes>}
                     ->{<Q:ManakaiDOM:noNS>}
                     ->{$attrNode->{<Q:DOMCore:name>}} = $attrNode;
              }
              if ($r) {
                delete $r->{<Q:infoset:parent>};
                $r->__SUPER{ManakaiDOMNodeObject::}__::__INT{orphanate}__;
                     ## Condition sensitive
                $r = __CLASS{Node}__->__INT{getNodeReference}__ ($r, $self)
                  if defined wantarray;
              }
            }
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              It is unclear whether the node should be returned if 
              the node is <QUOTE:replaced> by itself.
     @@Level[list]:  
        2
        3
     @@SpecLevel:2
  @Method:
     @@Name:  getElementsByTagNameNS
     @@Param:
        @@@Name:  namespaceURI
        @@@Type:  DOMString
     @@Param:
        @@@Name:  localName
        @@@Type:  DOMString
     @@Return:
        @@@Type:  NodeList
        @@@Exception[list]:  DOMException
     @@Level[list]:  2
     @@SpecLevel:2
  @Method:
     @@Name:  hasAttribute
     @@Description:
       @@@lang:en
       @@@@:
         Whether an attribute with the given name is specified on 
         this element or has a default value.
     @@NSVersion:hasAttributeNS
     @@Param:
        @@@Name:  name
        @@@Type:  DOMString
        @@Description:
          @@@lang:en
          @@@@: The name of the attribute to look for.
     @@Return:
        @@@Type:  boolean
        @@@InCase:
          @@@@Value:true
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              An attribute with the given name is specified on 
              this element or has a default value.
        @@@InCase:
          @@@@Value:false
          @@@@Description:
            @@@@@lang:en
            @@@@@@: 
              There is no such attribute.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            __INT{{selectAttrNodeObject}}__;
            $r = true if $r;
     @@Level[list]:  2
     @@SpecLevel:2
  @Method:
     @@Name:  hasAttributeNS
     @@Description:
       @@@lang:en
       @@@@:
         Whether an attribute with a given local name and namespace URI 
         is specified on this element or has a default value.
     @@NoNSVersion:hasAttribute
     @@Param:
        @@@Name:  namespaceURI
        @@@Type: 
          ManakaiDOM:ManakaiDOMNamespaceURI
        @@@Description:
          @@@@lang:en
          @@@@@: The namespace URI of the attribute to look for.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The attribute to look for has no namespace.
     @@Param:
        @@@Name:  localName
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The local name of the attribute to look for.
     @@Return:
        @@@Type:  boolean
        @@@InCase:
          @@@@Value:true
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              An attribute with given local name and namespace URI is 
              specified or has a default value on this element.
        @@@InCase:
          @@@@Value:false
          @@@@Description:
            @@@@@lang:en
            @@@@@@: There is no such attribute.
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:NOT_SUPPORTED_ERR
          @@@@SubType:
            @@@@@QName:
              MDOM_EXCEPTION:MDOM_IMPL_NOSUPPORT_XML
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The DOM implementation does not support the feature 
                <Feature:XML> and the language exposed through the 
                <IF:Document> does not support XML Namespaces.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            __INT{{selectAttrNodeObjectNS}}__;
            $r = $r ? true : false;
     @@Level[list]:  2
     @@SpecLevel:2
  @Attr:
     @@Name:  schemaTypeInfo
     @@Description:
        @@@lang:en
        @@@@: The type information associated with this element.
     @@Get:
        @@@Type:  TypeInfo
        @@@Description:
          @@@@lang:en
          @@@@@: The type information.
     @@Level[list]:  3
     @@SpecLevel:3
     @@ImplNote:
       @@@lang:en
       @@@@:
         TODO: More study required for the relationship to schemas.
  @Method:
     @@Name:  setIdAttribute
     @@Description:
       @@@lang:en
       @@@@:
         Set whether an attribute is a user-determined ID attribute or not.
       \
         Note that this does not affect any schema that may be 
         in use.  Whether this attribute is a DTD-, Schema- or 
         externally-determined ID attribute is unable to change by 
         this method.
     @@NSVersion:setIdAttributeNS
     @@Param:
        @@@Name:  name
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The name of the attribute.
     @@Param:
        @@@Name:  isId
        @@@Type:  boolean
        @@@Description:
          @@@@lang:en
          @@@@@:
            Whether the attribtue is a user-determined ID attribute.
        @@@InCase:
          @@@@Value:true
          @@@@Description:
            @@@@@lang:en
            @@@@@@: 
              Declare the attribute to be a user-determined ID attribute.
        @@@InCase:
          @@@@Value:false
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Undeclare the attribute for being a user-determined ID attribute.
     @@Return:
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:NO_MODIFICATION_ALLOWED_ERR
          @@@@SubType:
            @@@@@QName:
              MDOM_EXCEPTION:NOMOD_THIS
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                This (<IF:Element>) node is read-only.
            @@@@@SpecLevel:3
          @@@@SubType:
            @@@@@QName:
              MDOM_EXCEPTION:NOMOD_ATTR
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The attribute node is read-only.
            @@@@@SpecLevel[list]:
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              Is <QUOTE:user-determined ID> a property of the 
              <IF:Attr> or of the <IF:Element>?
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:NOT_FOUND_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              There is no such attribute.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            if ($self->{<Q:TreeCore:node>}->{<Q:DOMCore:read-only>}) {
              __EXCEPTION{
                DOMException.NO_MODIFICATION_ALLOWED_ERR.
                MDOM_EXCEPTION:NOMOD_THIS::
              }__;
            }
            my $r;
            __INT{{selectAttrNodeObject}}__;
            unless ($r) {
              __EXCEPTION{
                DOMException.NOT_FOUND_ERR::
              }__;
            }
            if ($r->{<Q:DOMCore:read-only>}) {
              __EXCEPTION{
                DOMException.NO_MODIFICATION_ALLOWED_ERR.
                MDOM_EXCEPTION:NOMOD_ATTR::
              }__;
            }
            $r->{<Q:DOMCore:userDeterminedId>} = $isId;
     @@Level[list]:  3
     @@SpecLevel:3
  @Method:
     @@Name:  setIdAttributeNS
     @@Description:
       @@@lang:en
       @@@@:
         Set whether an attribute is a user-determined ID attribute or not.
       \
         Note that this does not affect any schema that may be 
         in use.  Whether this attribute is a DTD-, Schema- or 
         externally-determined ID attribute is unable to change by 
         this method.
     @@NoNSVersion:setIdAttribute
     @@Param:
        @@@Name:  namespaceURI
        @@@Type: 
          ManakaiDOM:ManakaiDOMNamespaceURI
        @@@Description:
          @@@@lang:en
          @@@@@: The namespace URI of the attribute.
     @@Param:
        @@@Name:  localName
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The local name of the attribute.
     @@Param:
        @@@Name:  isId
        @@@Type:  boolean
        @@@Description:
          @@@@lang:en
          @@@@@:
            Whether the attribtue is a user-determined ID attribute.
        @@@InCase:
          @@@@Value:true
          @@@@Description:
            @@@@@lang:en
            @@@@@@: 
              Declare the attribute to be a user-determined ID attribute.
        @@@InCase:
          @@@@Value:false
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Undeclare the attribute for being a user-determined ID attribute.
     @@Return:
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:NO_MODIFICATION_ALLOWED_ERR
          @@@@SubType:
            @@@@@QName:
              MDOM_EXCEPTION:NOMOD_THIS
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                This (<IF:Element>) node is read-only.
            @@@@@SpecLevel:3
          @@@@SubType:
            @@@@@QName:
              MDOM_EXCEPTION:NOMOD_ATTR
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The attribute node is read-only.
            @@@@@SpecLevel[list]:
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              Is <QUOTE:user-determined ID> a property of the 
              <IF:Attr> or of the <IF:Element>?
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:NOT_FOUND_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              There is no such attribute.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            if ($self->{<Q:TreeCore:node>}->{<Q:DOMCore:read-only>}) {
              __EXCEPTION{
                DOMException.NO_MODIFICATION_ALLOWED_ERR.
                MDOM_EXCEPTION:NOMOD_THIS::
              }__;
            }
            my $r;
            __INT{{selectAttrNodeObjectNS}}__;
            unless ($r) {
              __EXCEPTION{
                DOMException.NOT_FOUND_ERR::
              }__;
            }
            if ($r->{<Q:DOMCore:read-only>}) {
              __EXCEPTION{
                DOMException.NO_MODIFICATION_ALLOWED_ERR.
                MDOM_EXCEPTION:NOMOD_ATTR::
              }__;
            }
            $r->{<Q:DOMCore:userDeterminedId>} = $isId;
     @@Level[list]:  3
     @@SpecLevel:3
  @Method:
     @@Name:  setIdAttributeNode
     @@Description:
       @@@lang:en
       @@@@:
         Set whether an attribute is a user-determined ID attribute or not.
       \
         Note that this does not affect any schema that may be 
         in use.  Whether this attribute is a DTD-, Schema- or 
         externally-determined ID attribute is unable to change by 
         this method.
     @@Param:
        @@@Name:  idAttr
        @@@Type:  Attr
        @@@Description:
          @@@@lang:en
          @@@@@: The attribute node.
     @@Param:
        @@@Name:  isId
        @@@Type:  boolean
        @@@Description:
          @@@@lang:en
          @@@@@:
            Whether the attribtue is a user-determined ID attribute.
        @@@InCase:
          @@@@Value:true
          @@@@Description:
            @@@@@lang:en
            @@@@@@: 
              Declare the attribute to be a user-determined ID attribute.
        @@@InCase:
          @@@@Value:false
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Undeclare the attribute for being a user-determined ID attribute.
     @@Return:
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:NO_MODIFICATION_ALLOWED_ERR
          @@@@SubType:
            @@@@@QName:
              MDOM_EXCEPTION:NOMOD_THIS
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                This (<IF:Element>) node is read-only.
            @@@@@SpecLevel:3
          @@@@SubType:
            @@@@@QName:
              MDOM_EXCEPTION:NOMOD_ATTR
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The attribute node is read-only.
            @@@@@SpecLevel[list]:
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              Is <QUOTE:user-determined ID> a property of the 
              <IF:Attr> or of the <IF:Element>?
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:NOT_FOUND_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The <P:idAttr> is not an attribute of this element.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            if ($self->{<Q:TreeCore:node>}->{<Q:DOMCore:read-only>}) {
              __EXCEPTION{
                DOMException.NO_MODIFICATION_ALLOWED_ERR.
                MDOM_EXCEPTION:NOMOD_THIS::
              }__;
            }
            unless ($idAttr->{<Q:TreeCore:node>}->{<Q:infoset:ownerElement>} and
                    $idAttr->{<Q:TreeCore:node>}->{<Q:infoset:ownerElement>}
                           ->{<Q:TreeCore:nodeID>} eq
                    $self->{<Q:TreeCore:node>}->{<Q:TreeCore:nodeID>}) {
              __EXCEPTION{
                DOMException.NOT_FOUND_ERR::
              }__;
            }
            if ($idAttr->{<Q:TreeCore:node>}->{<Q:DOMCore:read-only>}) {
              __EXCEPTION{
                DOMException.NO_MODIFICATION_ALLOWED_ERR.
                MDOM_EXCEPTION:NOMOD_ATTR::
              }__;
            }
            $idAttr->{<Q:TreeCore:node>}
                   ->{<Q:DOMCore:userDeterminedId>} = $isId;
     @@Level[list]:  3
     @@SpecLevel:3
  @ReMethod:
    @@Name: normalize
    @@Description:
      @@@lang:en
      @@@@:
         Put all <IF:Text> nodes in the full depth of the sub-tree 
         underneath this <IF:Node>, including attribute nodes 
         attaced to the <IF:Element>, 
         into a "normal" form where only structure separates 
         <IF:Text> nodes, i.e. there are neither adjacent <IF:Text> 
         nodes nor empty <IF:Text> nodes. <SRC:DOM 1, 2, 3>
    @@ImplNote:
      @@@lang:en
      @@@@:
        The method "normalize" was defined in the "Element" interface in 
        the DOM Level 1 but has been moved to 
        the "Node" interface in the DOM Level 2 and higher.
    @@Level[list]:
      1
      2
      3
    @@SpecLevel[list]:
      1
      2
      3
    @@Redefine:Node
  
  @ReAttr:
    @@Name: attributes
    @@Description:
      @@@lang:en
      @@@@:
        A node map containing the attributes of this node.
    @@Get:
      @@@Type:
        ManakaiDOM:ManakaiDOMAttributes
      @@@Description:
        @@@@lang:en
        @@@@@:
          A <IF:NamedNodeMap> object.
      @@@Def:
        @@@@Type:
          lang:Perl
        @@@@@:
          $r = $self->{<Q:TreeCore:node>}
                    ->__SUPER{ManakaiDOMNodeObject::}__::__INT{newReference}__
                         ## Condition sensitive
                        ('__CLASS{ManakaiDOMAttributes}__');
    @@SpecLevel:1
    @@Level[list]:
      1
      2
      3
    @@Redefine:Node
  @ReAttr:
    @@Name:baseURI
    @@Description:
      @@@lang:en
      @@@@:
        The base URI of this element.
    @@Get:
      @@@Type:
        ManakaiDOM:ManakaiDOMURI
      @@@Description:
        @@@@lang:en
        @@@@@: The base URI.
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The DOM implementation is unable to obtain an absolute URI.
      @@@Def:
        @@@@Type:
          lang:Perl
        @@@@@:
          if ($self->{<Q:TreeCore:node>}->{<Q:DOMCore:hasFeature>}->{HTML}) {
            $r = $self->{<Q:TreeCore:node>}
                      ->__SUPER{ManakaiDOMNodeObjectNode::}__::__INT{htmlBaseURI}__;
          } else {
            $r = $self->{<Q:TreeCore:node>}
                      ->__SUPER{ManakaiDOMNodeObjectNode::}__::__INT{contentBaseURI}__
                                                 (false);
          }
       @@@ImplNote:
         @@@@lang:en
         @@@@@:
           If a document has both a <HTML:base> element and 
           an <XML:xml:base> attribute, or even in the case that 
           an XHTML 1 document has an <XML:xml:base> attribute, 
           its result is not defined by any W3C specification.
    @@SpecLevel:3
    @@Level[list]:3
    @@Redefine:Node
  @ReAttr:
     @@Name:  localName
     @@Description:
       @@@lang:en
       @@@@: The local part of the qualified name of this "Element" node.
     @@Get:
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            The local name of the element type.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The node is created with a DOM Level 1 methods.
        @@@Def:
          @@@@Type:
            lang:dis
          @@@@GetProp:
            infoset:localName
     @@Level[list]:  2
     @@SpecLevel:2
     @@Redefine: Node
  @ReMethod:
     @@Name:  lookupPrefix
     @@Description:
       @@@lang:en
       @@@@:
         Lookup the namespace prefix associated to the given namespace 
         URI, starting from this node.
       \
         The default namespace declarations are ignored by this method. 
         To lookup default namespace, use the <M:Node.isDefaultNamespace>
         method.
     @@Param:
        @@@Name:  namespaceURI
        @@@Type:
          ManakaiDOM:ManakaiDOMNamespaceURI
        @@@Description:
          @@@@lang:en
          @@@@@: The namespace URI to look for.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Always <DOM:null> will be returned.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Always <DOM:null> will be returned.
     @@Return:
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            An associated namespace prefix.
          \
            If more than one prefix are associated to the 
            namespace URI, which is returned is implementation 
            dependent.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              No namespace prefix is found.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            if (not defined $namespaceURI) {
              $r = null;
            } else {
              my $n = $self->{<Q:TreeCore:node>};
              $r = $n->__SUPER{ManakaiDOMNodeObjectNode::}__::__INT{lookupNamespacePrefix}__
                                                 ($namespaceURI, $n);
            }
     @@Level[list]:  3
     @@SpecLevel:3
     @@Redefine:Node
  @Attr:
     @@Name:  namespaceURI
     @@Description:
       @@@lang:en
       @@@@:
         The namespace URI of this node.
     @@Get:
        @@@Type:
          ManakaiDOM:ManakaiDOMNamespaceURI
        @@@Description:
          @@@@lang:en
          @@@@@: The namespace URI.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The namespace URI is unspecified (the "null" namespace) or 
              the node is created with a DOM Level 1 methods.
        @@@Def:
          @@@@Type:
            lang:dis
          @@@@GetProp:
            infoset:namespaceName
     @@Level[list]:  2
     @@SpecLevel:2
     @@Redefined: Node
  @ReAttr:
    @@Name: nodeName
    @@Description:
      @@@lang:en
      @@@@: The node name.
    @@NSVersion[list]:
      Node.prefix
      Node.localName
    @@Get:
      @@@Type: DOMString
      @@@Description:
        @@@@lang:en
        @@@@@: The element type name, i.e. same as "tagName" attribute.
      @@@Def:
        @@@@Type:
          lang:Perl
        @@@@@: __INT{{tagName}}__;
    @@Redefine: Node
  @ReAttr:
    @@Name: nodeType
    @@Description:
      @@@lang:en
      @@@@: The type of this node.
    @@Get:
      @@@Type: unsigned-short
      @@@InCase:
        @@@@Label: ELEMENT_NODE
        @@@@Description:
          @@@@@lang:en
          @@@@@@: The node is an "Element".
      @@@Def:
        @@@@Type:
          lang:Perl
        @@@@@: $r = __SUPER{Node}__->ELEMENT_NODE;
    @@Redefine: Node
  @ReAttr:
     @@Name:  prefix
     @@Description:
       @@@lang:en
       @@@@: The namespace prefix of this node.
     @@Get:
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The namespace prefix.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Either the namespace prefix is unspecified or the node 
              is created with a DOM Level 1 method.
        @@@Def:
          @@@@Type:
            lang:dis
          @@@@GetProp:
            infoset:prefix
     @@Set:
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            The namespace prefix.
            Note that setting this attribute has no effect if 
            the namespace prefix is defined to be "null".
        @@@ImplNote:
          @@@@lang:en
          @@@@@:
            It is unclear whether the default attribute should be 
            added or deleted as the DTD declares.  The DOM Level 2 
            and 3 specifications mentions that changing of the 
            attribute name prefix does not make the default 
            attribute supplied, since the namespace URI does not change.
            This logic might be applied to the element node.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The namespace prefix is unspecified.
        @@@InCase:
          @@@@Value: \
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The result is implementation dependent in DOM Level 3.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: INVALID_CHARACTER_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The specified prefix contains an illegal character 
              accoding to the XML version in use in the document.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: This node is read-only.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NAMESPACE_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Either the specified prefix is malformed per the 
              XML Namespace specification, non-"null" prefix is 
              specified but the "namespaceURI" of this node is "null" or 
              the specified prefix is "xml" and the "namespaceURI" 
              of this node is different from 
              "http://www.w3.org/XML/1998/namespace".
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            my $node = $self->{<Q:TreeCore:node>};
            my $version;
            my $docNode = $node->{<Q:DOMCore:ownerDocument>};
            __CODE{XMLVersion: out => version, docNode => node}__;
            if (not defined $version) {
              __WARNING{
                ManakaiDOMImplementationWarning.ATTR_SET_NO_EFFECT.
                MDOM_EXCEPTION:MDOM_DOC_NOSUPPORT_XML::
              }__;
            } elsif (not defined $node->{<Q:infoset:localName>}) {
              __WARNING{
                ManakaiDOMImplementationWarning.ATTR_SET_NO_EFFECT.
                MDOM_EXCEPTION:MDOM_NODE_NOSUPPORT_XMLNS::
              }__;
            } elsif ($node->{<Q:DOMCore:read-only>}) {
              __WARNING{
                DOMException.NO_MODIFICATION_ALLOWED_ERR.
                MDOM_EXCEPTION:NOMOD_THIS::
              }__;
            } else {
              __CODE{CheckNCName: ncname => given, version => version,
                                  empty => warn3}__;
              if (not defined $given) {
                #
              } else {
                if (not defined $node->{<Q:infoset:namespaceName>}) {
                  __EXCEPTION{
                    DOMException.NAMESPACE_ERR.
                    MDOM_EXCEPTION:MDOM_NS_PREFIX_WITH_NULL_URI::
                      <Q:infoset:prefix> => $given,
                  }__;
                } elsif ($given eq 'xml' and
                         (not $node->{<Q:infoset:namespaceName>} or
                          $node->{<Q:infoset:namespaceName>} ne <Q:xml:>)) {
                  __EXCEPTION{
                    DOMException.NAMESPACE_ERR.
                    MDOM_EXCEPTION:MDOM_NS_XML_WITH_OTHER_URI::
                      <Q:infoset:namespaceName>
                           => $node->{<Q:infoset:namespaceName>},
                  }__;
                }
              }
              $node->{<Q:infoset:prefix>} = $given;
            }
     @@Level[list]:
       2
       3
     @@SpecLevel:2
     @@Redefine: Node
  
  @IntMethod:
    @@Name: newObject
    @@Description:
      @@@lang:en
      @@@@:
        Construct an object for a new instance of the <IF:Element> node.
    @@Return:
      @@@Type:
        ManakaiDOM:ManakaiDOMNodeObject
      @@@Description:
        @@@@lang:en
        @@@@@:
          The new object for the <IF:Element> node.
      @@@Def:
        @@@@Type:
          lang:Perl
        @@@@@:
               ## Condition sensitive
          $r = __CLASS{Node}__->__INT{newObject}__;
          $r->{<Q:DOMCore:nodeType>} = <Q:infoset:Element>;
     @@Level[list]:
       1
       2
       3
     @@ImplNote:
       @@@lang:en
       @@@@:
         Other properties required to be a legal <IF:Element> object:
         Either <Q:DOMCore:name> or <Q:infoset:localName>, 
         <Q:DOMCore:ownerDocument>.
       \
         Other available properties: <Q:infoset:prefix>, 
         <Q:DOMCore:read-only>, <Q:infoset:parent>, <Q:infoset:children>, 
         <Q:infoset:attributes>, <Q:infoset:namespaceName>.
## IF:Element

IF:
  @Name:  Text
  @ISA:  CharacterData
  @Description:
    @@lang:en
    @@@:
      The textual content of an "Element" or "Attr".
    \
      When a document is first made available via the DOM, 
      there is only one "Text" node for each block of text. 
      DOM applications may create adjust "Text" nodes that 
      represent the contents of a given node (but there is no 
      way to represent the separation between these nodes in 
      XML or HTML so they will not persist between DOM editing sessions 
      in general).
  @ImplNote:
    @@lang:en
    @@@:
     "Text" is a "CharacterData" is a "Node".  "CDATASection" is a "Text".
  @Method:
     @@Name:  splitText
     @@Description:
       @@@lang:en
       @@@@:
         Break this node into two nodes.  After being split, 
         this node will contain all the content up to the break point 
         and a new node of the same type will contain all the content 
         at and after the break point.
      \
         If the original node had a parent node, the new node is 
         inserted as the next sibling of this node.
     @@Param:
        @@@Name:  offset
        @@@Type:  unsigned-long
        @@@Description:
          @@@@lang:en
          @@@@@:
            The 16-bit unit offset at which to split.
     @@Return:
        @@@Type:  Text
        @@@Description:
          @@@@lang:en
          @@@@@: The new node, of the same type as this node.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: INDEX_SIZE_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The "offset" is negative or greater than the number 
              of 16-bit units.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Either this node is read-only [DOM 1, 2, 3] or 
              the parent node of this node is read-only.
      @@@Exception:
        @@@@Type: 
          ManakaiDOM:ManakaiDOMImplementationException
        @@@@Name: MDOM_INDEX_IN_SURROGATE_PAIR
        @@@@Description:
          @@@@@lang:en
          @@@@@@: An attempt is made to break surrogate pair.
      @@@Def:
        @@@@Type:
          lang:Perl
        @@@@@:
          my $node = $self->{<Q:TreeCore:node>};
          my $parentNode = $node->{<Q:infoset:parent>};
          if ($node->{<Q:DOMCore:read-only>}) {
            __EXCEPTION{
              DOMException.NO_MODIFICATION_ALLOWED_ERR.
              MDOM_EXCEPTION:NOMOD_THIS::
            }__;
          } elsif ($parentNode and $parentNode->{<Q:DOMCore:read-only>}) {
            __EXCEPTION{
              DOMException.NO_MODIFICATION_ALLOWED_ERR.
              MDOM_EXCEPTION:NOMOD_PARENT::
            }__;
          }
                          ## Condition sensitive
          my $ds = $self->__SUPER{CharacterData}__::__INT{getDOMStringValue}__;
          my $len = length ($node->{<Q:infoset:content>}) * 2;
          my $after;
          __DEEP{
            $after = $ds->__INT{substring}__ ($offset, $len);
            $ds->__INT{delete}__ ($offset, $len);
          }__;
          my $newNode;
          if ($node->{<Q:DOMCore:nodeType>} eq <Q:DOMCore:Text>) {
                        ## Condition sensitive
            $newNode = __CLASS{Text}__->__INT{newObject}__;
          } elsif ($node->{<Q:DOMCore:nodeType>} eq <Q:DOMXML:CDATASection>) {
                        ## Condition sensitive
            $newNode = __CLASS{CDATASection}__->__INT{newObject}__;
          } else {
            __EXCEPTION{
              ManakaiDOMImplementationException.MDOM_DEBUG_BUG::
                <Q:MDOM_EXCEPTION:values> => {
                  <Q:DOMCore:nodeType> => $node->{<Q:DOMCore:nodeType>},
                },
            }__;
          }
          $newNode->{<Q:infoset:content>} = $after;
          $newNode->{<Q:DOMCore:ownerDocument>} = $parentNode
                                                 ->{<Q:DOMCore:ownerDocument>};
          if ($parentNode) {
            $parentNode->__SUPER{ManakaiDOMNodeObject::}__::__INT{importTree}__
                                                                   ($newNode);
            for my $i (0..$#{$parentNode->{<Q:infoset:children>}}) {
              if ($parentNode->{<Q:infoset:children>}->[$i]
                             ->{<Q:TreeCore:nodeID>} eq
                  $node->{<Q:TreeCore:nodeID>}) {
                splice @{$parentNode->{<Q:infoset:children>}},
                       $i + 1, 0, $newNode;
                last;
              }
            }
            $newNode->{<Q:infoset:parent>} = $parentNode;
          }
          $newNode->{<Q:DOMCore:ownerDocument>}
                                           = $node->{<Q:DOMCore:ownerDocument>};
    @@SpecLevel:1
    @@Level[list]:
      1
      2
      3
  @Attr:
     @@Name:  isElementContentWhitespace
     @@Description:
       @@@lang:en
       @@@@:
         Whether this text node contains element content whitespaces.
     @@Get:
        @@@Type:  boolean
        @@@InCase:
          @@@@Value:true
          @@@@Description:
            @@@@@lang:en
            @@@@@@: This text node contains element content whitespaces.
        @@@InCase:
          @@@@Value:false
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              This text node contains element content whitespaces or 
              no validation occurs so that it is unknown.
        @@@Def:
          @@@@Type:
            lang:dis
          @@@@GetProp:
            infoset:elementContentWhitespace
     @@Level[list]:  3
     @@SpecLevel:3
  @Attr:
     @@Name:  wholeText
     @@Description:
       @@@lang:en
       @@@@:
         All text of logically-adjacent text nodes.
     @@ImplNote:
       @@@lang:en
       @@@@:
         The DOM Level 3 Core Specification is unclear about <IF:CDATASection>s.
         They should also be included (c.f. the definition for 
         <A:Text.replaceWholeText>).
     @@Get:
        @@@Type:  DOMString
        @@@ImplNote:
          @@@@Type:
            lang:Perl
          @@@@@:
   TODO: Implement this.
            my $node = $self->{<Q:TreeCore:node>};
            if ($node->{<Q:infoset:parent>}) {
              my $parentNode = $node->{<Q:infoset:parent>};
              my (@t, @tr1, @tr2);
              my ($found, $first, $last);
              for my $i (0..$#{$parentNode->{<Q:infoset:children>}}) {
                if ({
                      <Q:DOMCore:Text> => 1,
                      <Q:DOMXML:CDATASection> => 1,
                    }->{$parentNode->{<Q:infoset:children>}->[$i]
                                   ->{<Q:DOMCore:nodeType>}}) {
                  push @t, $parentNode->{<Q:infoset:children>}->[$i];
                  $first = ($i == 0);
                  $last = ($i == $#{$parentNode->{<Q:infoset:children>}});
                  $found = 1 if $parentNode->{<Q:infoset:children>}->[$i]
                                           ->{<Q:TreeCore:nodeID>} eq
                                $parentNode->{<Q:TreeCore:nodeID>};
                } elsif ($parentNode->{<Q:infoset:children>}->[$i]
                                   ->{<Q:DOMCore:nodeType>} eq
                         <Q:DOMXML:EntityReference>) {
                  if ($found) {
                    push @tr2, $parentNode->{<Q:infoset:children>}->[$i];
                    $last = ($i == $#{$parentNode->{<Q:infoset:children>}});
                  } else {
                    push @tr1, $parentNode->{<Q:infoset:children>}->[$i];
                  }
                } else {
                  if ($found) {
                    last;
                  } else {
                    $first = 0;
                    $last = 0;
                    @t = ();
                  }
                }
              }
              if ($parentNode->{<Q:DOMCore:nodeType>} eq
                  <Q:DOMXML:EntityReference> and 
                  $parentNode->{<Q:infoset:parent>}) {
                
              }
            } else {
              $r = $node->__SUPER{ManakaiDOMNodeObjectNode::}__::__INT{textContent}__;
            }
     @@Level[list]:  3
     @@SpecLevel:3
  @Method:
     @@Name:  replaceWholeText
     @@Return:
        @@@Type:  Text
        @@@Exception[list]:  DOMException
     @@Param:
        @@@Name:  content
        @@@Type:  DOMString
     @@Level[list]:  3
     @@SpecLevel:3
  
  @ReAttr:
    @@Name: nodeName
    @@Description:
      @@@lang:en
      @@@@: The node name.
    @@Spec:
      @@@DOM3[list]:
        http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-F68D095
        http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-1841493061
    @@NSVersion[list]:
      Node.prefix
      Node.localName
    @@Get:
      @@@Type: DOMString
      @@@InCase:
        @@@@Value:\#text
        @@@@Description:
          @@@@@lang:en
          @@@@@@: Always this value for the "Text" node.
      @@@DefaultValue: \#text
      @@@Def: \
  @ReAttr:
    @@Name: nodeType
    @@Description:
      @@@lang:en
      @@@@: The type of this node.
    @@Get:
      @@@Type: unsigned-short
      @@@InCase:
        @@@@Label: TEXT_NODE
        @@@@Description:
          @@@@@lang:en
          @@@@@@: The node is a "Text".
      @@@Def:
        @@@@Type:
          lang:Perl
        @@@@@: $r = __SUPER{Node}__->TEXT_NODE;
    @@Redefine: Node
    @@RedefinedBy: CDATASection

  @IntMethod:
    @@Name: newObject
    @@Description:
      @@@lang:en
      @@@@:
        Construct an object for a new instance of the <IF:Text> node.
    @@Return:
      @@@Type:
        ManakaiDOM:ManakaiDOMNodeObject
      @@@Description:
        @@@@lang:en
        @@@@@:
          The new object for the <IF:Text> node.
      @@@Def:
        @@@@Type:
          lang:Perl
        @@@@@:
               ## Condition sensitive
          $r = __CLASS{Node}__->__INT{newObject}__;
          $r->{<Q:DOMCore:nodeType>} = <Q:DOMCore:Text>;
          $r->{<Q:infoset:content>} = '';
     @@Level[list]:
       1
       2
       3
     @@ImplNote:
       @@@lang:en
       @@@@:
         Other properties requires to be a legal <IF:Text>:
         <Q:DOMCore:ownerDocument>.
         \
         Other available properties: <Q:infoset:ElementContentWhitespace>, 
         <Q:infoset:parent>, <Q:infoset:content>, <Q:DOMCore:read-only>.
## IF:Text

IF:
  @Name:  Comment
  @ISA:  CharacterData
  @Description:
    @@lang:en
    @@@:
      A comment, corresponding to a comment declaration in the HTML or 
      XML or a comment information item in the XML Infoset.
  @ImplNote:
    @@lang:en
    @@@:
      "Comment" is a "CharacterData" is a "Node".
  @ImplNote:
    @@lang:en
    @@@:
      HTML comment declaration might have multiple "comment". 
  
  @ReAttr:
    @@Name: nodeName
    @@Spec:
      @@@DOM3[list]:
        http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-F68D095
        http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-1841493061
    @@Description:
      @@@lang:en
      @@@@: The node name.
    @@NSVersion[list]:
      Node.prefix
      Node.localName
    @@Get:
      @@@Type: DOMString
      @@@InCase:
        @@@@Value: \#comment
        @@@@Description:
          @@@@@lang:en
          @@@@@@: Always this value for the "Comment" node.
      @@@DefaultValue: \#comment
      @@@Def: \
  @ReAttr:
    @@Name: nodeType
    @@Description:
      @@@lang:en
      @@@@: The type of this node.
    @@Get:
      @@@Type: unsigned-short
      @@@InCase:
        @@@@Label: COMMENT_NODE
        @@@@Description:
          @@@@@lang:en
          @@@@@@: The node is a "Comment".
      @@@Def:
        @@@@Type:
          lang:Perl
        @@@@@: $r = __SUPER{Node}__->COMMENT_NODE;
    @@Redefine: Node

  @IntMethod:
    @@Name: newObject
    @@Description:
      @@@lang:en
      @@@@:
        Construct an object for a new instance of the <IF:Comment> node.
    @@Return:
      @@@Type:
        ManakaiDOM:ManakaiDOMNodeObject
      @@@Description:
        @@@@lang:en
        @@@@@:
          The new object for the <IF:Comment> node.
      @@@Def:
        @@@@Type:
          lang:Perl
        @@@@@:
               ## Condition sensitive
          $r = __CLASS{Node}__->__INT{newObject}__;
          $r->{<Q:DOMCore:nodeType>} = <Q:infoset:Comment>;    
          $r->{<Q:infoset:content>} = '';
     @@Level[list]:
       1
       2
       3
     @@ImplNote:
       @@@lang:en
       @@@@:
         Other properties required to be a legal <IF:Comment> object:
         <Q:DOMCore:ownerDocument>.
        \
         Other available properties: <Q:infoset:parent>, <Q:infoset:content>, 
         <Q:DOMCore:read-only>.
## IF:Comment

IF:
  @Name:  TypeInfo
  @Description:
    @@lang:en
    @@@:
      A type referenced from "Element" or "Attr" nodes, 
      specified in the schemas associated with the document.
    \
      The type is a pair of namespace URI and name.  It depsnds 
      on the schema language in use.
  @ImplNote:
    @@lang:en
    @@@:
      If the schema language is the XML Schema:
     \
      - If [validity] property exists and its value is 
      "invalid" or "notKnown": ("typeNamespace", "typeName") = 
      ({target namespace}, {name}) or ("null", "null").
     \
      NOTE: The XML Schema specification does not require 
      exposing the declared type.  DOM implementation might choose 
      not to provide type information if validity is not valid.
     \
      - If [validity] exists and its value is "valid":
     \
      -- If [member type definition] exists:
     \
      --- If {name} is not absent: ("typeNamespace", "typeName") = 
      [member type definition].({target namespace}, {name}).
     \
      --- Otherwise: ("typeNamespace", "typeName") = 
      (namespace, local name) of the corresponding anonymous type name.
     \
      -- If [type definition] exists:
     \
      --- If {name} is not absent: ("typeNamespace", "typeName") =
      [type definition].({target namespace}, {name}).
     \
      --- Otherwise: ("typeNamespace", "typeName") =
      (namespace, local name) of the corresponding anonymous type name.
     \
      -- If [member type definition anonymous] exists:
     \
      --- If false: ("typeNamespace", "typeName") =
      ([member type definition namespace], [member type definition name]).
     \
      --- Otherwise: ("typeNamespace", "typeName") =
      (namespace, local name) of the corresponding anonymous type name.
     \
      -- If [type definition anonymous] exists:
     \
      --- If false: ("typeNamespace", "typeName") =
      ([type definition namespace], [type definition name]).
     \
      --- Otherwise: ("typeNamespace", "typeName") =
      (namespace, local name) of the corresponding anonymous type name.
     \
      Other schema languages are outside of the scope of the W3C and 
      should define how to represent their type systems using "TypeInfo".
  @Level[list]:  3
  @SpecLevel:3
  @Attr:
     @@Name:  typeName
     @@Description:
       @@@lang:en
       @@@@: The name of the type.
     @@Get:
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The name of the type.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The name is unknown.
       
  @Attr:
     @@Name:  typeNamespace
     @@Description:
       @@@lang:en
       @@@@: The namespace of the type.
     @@Get:
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The namespace of the type.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Either the associated element or attribute does not have 
              declaration or no namespace information is available.
        @@@InCase:
          @@@@Value:
            http://www.w3.org/TR/REC-xml
          @@@@Description:
            @@@@@lang:en
            @@@@@@: 
              The schema language is the XML DTD and the node 
              associated is an "Attr".
            \
              In this case, the "typeName" is the value of 
              the [attribute type] property of the XML Infoset.
     @@ImplNote:
       @@@lang:en
       @@@@: Is this namespace *URI*?
  @ConstGroup:
     @@Name:  DerivationMethods
     @@Description:
       @@@lang:en
       @@@@:
         A set of possible types of derivation.
     @@Type: unsigned-long
     @@IsBitMask:1
     @@ImplNote:
       @@@lang:en
       @@@@:
         Any type derives from "xsd:anyType".
     @@Const:
        @@@Name:  DERIVATION_RESTRICTION
        @@@Type:  unsigned-long
        @@@Value:  0x00000001
        @@@Description:
          @@@@lang:en
          @@@@@:
            The derivation by restriction.
        @@@ImplNote:
          @@@@lang:en
          @@@@@:
            Other type definition = reference type definition or 
            reference type definition.{base type definition}. ... 
            .{base type definition} = other type definition and 
            all the derivation methods involved are restriction.
          \
            Any simple type derives from "xsd:anySimpleType" by restriction.
     @@Const:
        @@@Name:  DERIVATION_EXTENSION
        @@@Type:  unsigned-long
        @@@Value:  0x00000002
        @@@Description:
          @@@@lang:en
          @@@@@:
            The derivation by extension.
        @@@ImplNote:
          @@@@lang:en
          @@@@@:
            Reference type definition.{base type definition}.
            ... .{base type definition} = other type definition 
            and at least one of the derivation methods 
            involeved is an extension. 
          \
            Both types are complex types or both are simple types.
     @@Const:
        @@@Name:  DERIVATION_UNION
        @@@Type:  unsigned-long
        @@@Value:  0x00000004
        @@@Description:
          @@@@lang:en
          @@@@@: The union.
        @@@ImplNote:
          @@@@lang:en
          @@@@@:
            Other type definition --derive<DERIVATION_RESTRICTION>--> T2 
            or other type definition = T2,
            T1 --derive<DERIVATION_RESTRICTION or DERIVATION_EXTENSION>--> 
            reference type definition or T1 = reference type definition, 
            T1.{variety} = union and T1.{member type definition} = T2.
     @@Const:
        @@@Name:  DERIVATION_LIST
        @@@Type:  unsigned-long
        @@@Value:  0x00000008
        @@@Description:
          @@@@lang:en
          @@@@@: The list.
        @@@ImplNote:
          @@@@lang:en
          @@@@@: 
            Other type definition --derive<DERIVATION_RESTRICTION>--> T2 
            or other type definition = T2,
            T1 --derive<DERIVATION_RESTRICTION or DERIVATION_EXTENSION>--> 
            reference type definition or T1 = reference type definition, 
            T1.{variety} = list and T1.{item type definition} = T2.
  @Method:
     @@Name:  isDerivedFrom
     @@Description:
       @@@lang:en
       @@@@:
         Return whether there is a derivation between the definition 
         of this type and the other type definition.
     @@Param:
        @@@Name:  typeNamespaceArg
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The namespace of the other type definition.
     @@Param:
        @@@Name:  typeNameArg
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The name of the other type definition.
     @@Param:
        @@@Name:  derivationMethod
        @@@Type:  DerivationMethods
        @@@Description:
          @@@@lang:en
          @@@@@:
            The type of derivation and conditions applied between 
            two types.
     @@Return:
        @@@Type:  boolean
        @@@InCase:
          @@@@Value:true
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The schema language is the XML Schema and 
              the definition of this type is derived from the 
              other type definition according to the derivation 
              parameter.
            \
              If the "derivationMethod" is "0", the other 
              type definition can be reached by recursing any 
              combination of {base type definition}, 
              {item type definition} or {member type definition} 
              from the definition of this type.
        @@@InCase:
          @@@@Value:false
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Either the schema language is the XML Schema and 
              the other type definition is not derived from 
              the definition of this type, the schema language 
              is the XML DTD or no schama language is associated.

IF:
  @Name:  UserDataHandler
  @Description:
    @@lang:en
    @@@:
      A handler to implement various behaviors regarding the 
      data associated to the DOM nodes.
  @Level[list]:  3
  @SpecLevel:3
  @ConstGroup:
     @@Name:  OperationType
     @@Type: unsigned-short
     @@Description:
       @@@lang:en
       @@@@: The type of operation being performed on a node.
     @@Const:
        @@@Name:  NODE_CLONED
        @@@Type:  unsigned-short
        @@@Value:  1
        @@@Description:
          @@@@lang:en
          @@@@@: The node is cloned.
        @@@ImplNote:
          @@@@lang:en
          @@@@@: The node is cloned.
        @@@ImplNote:
          @@@@lang:en
          @@@@@: "Node.cloneNode".
     @@Const:
        @@@Name:  NODE_IMPORTED
        @@@Type:  unsigned-short
        @@@Value:  2
        @@@Description:
          @@@@lang:en
          @@@@@: The node is imported.
        @@@ImplNote:
          @@@@lang:en
          @@@@@: "Document.importNode".
     @@Const:
        @@@Name:  NODE_DELETED
        @@@Type:  unsigned-short
        @@@Value:  3
        @@@Description:
          @@@@lang:en
          @@@@@:
            The node is deleted.
        @@@ImplNote:
          @@@@lang:en
          @@@@@:
            This may not be supported or may not be reliable in certain 
            environment, such as Java, where the DOM implementation 
            has no real control over when objects are actually deleted.
     @@Const:
        @@@Name:  NODE_RENAMED
        @@@Type:  unsigned-short
        @@@Value:  4
        @@@Description:
          @@@@lang:en
          @@@@@: The node is renamed.
        @@@ImplNote:
          @@@@lang:en
          @@@@@: "Document.renameNode".
     @@Const:
        @@@Name:  NODE_ADOPTED
        @@@Type:  unsigned-short
        @@@Value:  5
        @@@Description:
          @@@@lang:en
          @@@@@: The node is adopted.
        @@@ImplNote:
          @@@@lang:en
          @@@@@: "Document.adoptNode".
  @Method:
     @@Name:  handle
     @@Description:
       @@@lang:en
       @@@@:
         Called whenever the node for which the handler is registered 
         is imported or cloned.
       \
         DOM applications MUST NOT raise exceptions in a 
         "UserDataHandler".  The effect of throwing exceptions 
         from the handler is implementation dependent.
     @@ImplNote:
       @@@lang:en
       @@@@:
         The manakai DOM implementation does NOT warn when 
         an exception is thrown.
     @@Param:
        @@@Name:  operation
        @@@Type:  OperationType
        @@@Description:
          @@@@lang:en
          @@@@@: The type of operation that is being performed on the node.
     @@Param:
        @@@Name:  key
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The key for which this handler is being called.
     @@Param:
        @@@Name:  data
        @@@Type:  DOMUserData
        @@@Description:
          @@@@lang:en
          @@@@@: The data for which this handler is being called.
     @@Param:
        @@@Name:  src
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@: 
            The node being cloned, adopted, imported or renamed.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The node is being deleted.
     @@Param:
        @@@Name:  dst
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@: The node newly created.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: No node is newly created.

IF:
  @Name:  DOMError
  @Description:
    @@lang:en
    @@@: Describes an error.
  @Level[list]:  3
  @SpecLevel:3
  @ConstGroup:
     @@Name:  ErrorSeverity
     @@Type: unsigned-short
     @@Description:
       @@@lang:en
       @@@@: The severity of the error.
     @@Const:
        @@@Name:  SEVERITY_WARNING
        @@@Type:  unsigned-short
        @@@Value:  1
        @@@Description:
          @@@@lang:en
          @@@@@:
            Warning.  It will not cause the processing stop unless 
            "DOMErrorHandler.handleError" returns "false".
     @@Const:
        @@@Name:  SEVERITY_ERROR
        @@@Type:  unsigned-short
        @@@Value:  2
        @@@Description:
          @@@@lang:en
          @@@@@:
            Error.  It may not cause the processing to stop 
            if the error can be recovered, unless 
            "DOMErrorHandler.handleError" returns "false".
     @@Const:
        @@@Name:  SEVERITY_FATAL_ERROR
        @@@Type:  unsigned-short
        @@@Value:  3
        @@@Description:
          @@@@lang:en
          @@@@@:
            Fatal error.  It will cause the normal processing to stop.  
            The return value of "DOMErrorHandler.handleError" is 
            ignored unless the implementation chooses to continue, 
            in which case the behavior becomes undefined.
  @Attr:
     @@Name:  severity
     @@Description:
       @@@lang:en
       @@@@:
         The severity of the error.
     @@Get:
        @@@Type:  ErrorSeverity     
  @Attr:
     @@Name:  message
     @@Description:
       @@@lang:en
       @@@@:
         An implementation specific string describing the error that occurred.
     @@Get:
        @@@Type:  DOMString
  @Attr:
     @@Name:  type
     @@Description:
       @@@lang:en
       @@@@:
         A string indicating which related data is expected in 
         "relatedData".
       \
         Implementators of DOM applications should refer to the 
         specification of the error in order to find "type" and 
         "relatedData" defiition if any.
     @@ImplNote:
       @@@lang:en
       @@@@: "Document.normalizeDocument".
     @@Get:
        @@@Type:  DOMString
  @Attr:
     @@Name:  relatedException
     @@Description:
       @@@lang:en
       @@@@: The related platform dependent exception if any.
     @@Get:
        @@@Type:  DOMObject
  @Attr:
     @@Name:  relatedData
     @@Description:
       @@@lang:en
       @@@@:
         The related "DOMError.type" dependent data if any.
     @@Get:
        @@@Type:  DOMObject
  @Attr:
     @@Name:  location
     @@Description:
       @@@lang:en
       @@@@: The location of the error.
     @@Get:
        @@@Type:  DOMLocator

IF:
  @Name:  DOMErrorHandler
  @Description:
    @@lang:en
    @@@:
      A callback interface that the DOM implementation can call when 
      reporting errors that happens while processing XML data or 
      when doing some other processing.
    \
      A "DOMErrorHandler" object can be attached to a "Document" using 
      the "error-handler" on the "DOMConfiguration" interface.
    \
      If more than one error needs to be reported during an operation, 
      the sequence and numbers of the errors passed to the error handler 
      are implementation dependent.
  @Level[list]:  3
  @SpecLevel:3
  @Method:
     @@Name:  handleError
     @@Description:
       @@@lang:en
       @@@@:
         Called when an error occurs.
     @@Param:
        @@@Name:  error
        @@@Type:  DOMError
        @@@Description:
          @@@@lang:en
          @@@@@:
            The error object that describes the error.
          \
            This object may be reused by the DOM implementation 
            across multiple calls to the method "handleError".
     @@Return:
        @@@Type:  boolean
        @@@Description:
          @@@@lang:en
          @@@@@:
            Whether the processing should be continued.
          \
            Throwing an exception from this method is considered 
            to be equivalent of returning "true".
        @@@InCase:
          @@@@Value: true
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The processing may continue depending on "DOMError.severity".
        @@@InCase:
          @@@@Value:false
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The processing should be stopped when possible.
        @@@Exception:
          @@@@Type: 
            ManakaiDOM:ManakaiDOMImplementationException
          @@@@Name: MDOM_IMPL_BY_APP
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The method MUST be implemented by the DOM application.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            __EXCEPTION{
              ManakaiDOMImplementationException.MDOM_IMPL_BY_APP::
            }__;

IF:
  @Name:  DOMLocator
  @Level[list]:  3
  @SpecLevel:3
  @Description:
    @@lang:en
    @@@: Describes a location.
  @Attr:
     @@Name:  lineNumber
     @@Description:
        @@@lang:en
        @@@@: The line number to which this locator is pointing.
     @@Get:
        @@@Type:  long
        @@@Description:
          @@@@lang:en
          @@@@@: The line number.
        @@@InCase:
          @@@@Value:-1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: There is no column number available.
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              "Column" in the DOM 3 Specification should be "line"? 
              Or this is correct?
  @Attr:
     @@Name:  columnNumber
     @@Description:
       @@@lang:en
       @@@@: The column number to which this locator is pointing.
     @@Get:
        @@@Type:  long
        @@@Description:
          @@@@lang:en
          @@@@@: The column number.
        @@@InCase:
          @@@@Value:-1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              There is no column number available.
  @Attr:
     @@Name:  byteOffset
     @@Description:
       @@@lang:en
       @@@@:
         The byte offset into the input source to which this locator 
         is pointing.
     @@Get:
        @@@Type:  long
        @@@Description:
          @@@@lang:en
          @@@@@: The byte offset.
        @@@InCase:
          @@@@Value: -1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: There is no byte offset available.
  @Attr:
     @@Name:  utf16Offset
     @@Description:
       @@@lang:en
       @@@@:
         The UTF-16 offset into the input source to which 
         this locator is pointing.
     @@Get:
        @@@Type:  long
        @@@Description:
          @@@@lang:en
          @@@@@: The UTF-16 offset.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: There is no UTF-16 offset available.
  @Attr:
     @@Name:  relatedNode
     @@Description:
       @@@lang:en
       @@@@: The node to which this locator is pointing.
     @@Get:
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@: The node pointed.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: There is no node available.
  @Attr:
     @@Name:  uri
     @@Description:
       @@@lang:en
       @@@@: The URI to which this locator is pointing.
     @@Get:
        @@@Type:
          ManakaiDOM:ManakaiDOMURI
        @@@Description:
          @@@@lang:en
          @@@@@: The URI.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: There is no URI is available.

IF:
  @Name:  DOMConfiguration
  @Description:
    @@lang:en
    @@@:
      The configuration of a document.  It maintains a table 
      of recognized parameters.
  @ImplNote:
    @@lang:en
    @@@:
      Parameters affect: <M:Document.normalizeDocument>, 
      validation, <IF:DOMParser>, <IF:DOMSerializer>, etc.
  @Level[list]:  3
  @SpecLevel:3
  @Method:
     @@Name:  setParameter
     @@Description:
       @@@lang:en
       @@@@:
         Set the value of a parameter.
     @@Param:
        @@@Name:  name
        @@@Type:
          ManakaiDOMCore:ManakaiDOMConfigurationParameter
        @@@Description:
          @@@@lang:en
          @@@@@: The name of the parameter to set.
     @@Param:
        @@@Name:  value
        @@@Type:  DOMUserData
        @@@Description:
          @@@@lang:en
          @@@@@: 
            The new value.  The object type must match the type 
            defined by the definition of the parameter.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: Unset the parameter.
     @@Return:
        @@@Exception:
          @@@@Name: NOT_FOUND_ERR
          @@@@Type: DOMException
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The parameter name is not recognized.
        @@@Exception:
          @@@@Name: NOT_SUPPORTED_ERR
          @@@@Type: DOMException
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The parameter name is recognized but the requested 
              value cannot be set.
        @@@Exception:
          @@@@Name: TYPE_MISMATCH_ERR
          @@@@Type: DOMException
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The value type for this parameter name is 
              incompatible with the expected value type.
  @Method:
     @@Name:  getParameter
     @@Description:
       @@@lang:en
       @@@@: Return the value of a parameter.
     @@Param:
        @@@Name:  name
        @@@Type:  
          ManakaiDOMCore:ManakaiDOMConfigurationParameter
        @@@Description:
          @@@@lang:en
          @@@@@:
            The name of the parameter.
     @@Return:
        @@@Type:  DOMUserData
        @@@Description:
          @@@@lang:en
          @@@@@:
            The current object associated with the specified 
            parameter.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Either no object has been associated or the parameter 
              is not supported.
        @@@Exception:
          @@@@Name: NOT_FOUND_ERR
          @@@@Type: DOMException
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The parameter name is not recognized.
  @Method:
     @@Name:  canSetParameter
     @@Description:
       @@@lang:en
       @@@@:
         Check if setting a parameter to a specific value is supported. 
         The current value of the parameter itself is not changed.
     @@Param:
        @@@Name:  name
        @@@Type:
          ManakaiDOMCore:ManakaiDOMConfigurationParameter
        @@@Description:
          @@@@lang:en
          @@@@@:
            The name of the parameter to check.
     @@Param:
        @@@Name:  value
        @@@Type:  DOMUserData
        @@@Description:
          @@@@lang:en
          @@@@@:
            An object to check.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: 
              \ <DOM:true> will be returned.
     @@Return:
        @@@Type:  boolean
        @@@InCase:
          @@@@Value:true
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The parameter could be successfully set to the 
              specified value.
        @@@InCase:
          @@@@Value:false
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The parameter is not recognized or the 
              requested value is not supported.
  @Attr:
     @@Name:  parameterNames
     @@Description:
       @@@lang:en
       @@@@:
         The list of the parameters supported by this 
         <IF:DOMConfiguration> object and for which at least 
         one value can be set by the DOM application.
     @@ImplNote:
       @@@lang:en
       @@@@:
         Parameternames defined outside the DOM Level 3 Core Specification 
         also contained.
     @@Get:
        @@@Type:  DOMStringList

IF:
  @Name:  DocumentFragment
  @Description:
    @@lang:en
    @@@: A "lightweight" or "minimal" "Document" object.
  @ISA:  Node

  @IntMethod:
    @@Name: newObject
    @@Description:
      @@@lang:en
      @@@@:
        Construct an object for a new instance of the "DocumentFragment".
      \
        Note that this method is for the internal use.  DOM 
        applications must use the "createDocumentFragment" method 
        of the "Document" interface to create a new "DocumentFragment".
    @@Return:
      @@@Type:
        ManakaiDOM:ManakaiDOMNodeObject
      @@@Description:
        @@@@lang:en
        @@@@@: The new object for the "DocumentFragment".
      @@@Def:
        @@@@Type:
          lang:Perl
        @@@@@:
               ## Condition sensitive
          $r = __CLASS{Node}__->__INT{newObject}__;
          $r->{<Q:DOMCore:nodeType>} = <Q:DOMCore:DocumentFragment>;          
       @@@ImplNote:
         @@@@lang:en
         @@@@@:
           Other properties required to be a legal <IF:DocumentFragment> 
           object: <Q:DOMCore:ownerDocument>. 
         \
           Other available properties: <Q:infoset:children>, 
           <Q:DOMCore:read-only>.
     @@Level[list]:
       1
       2
       3
  
  @ReMethod:
     @@Name:  lookupPrefix
     @@Description:
       @@@lang:en
       @@@@:
         Lookup the namespace prefix associated to the given namespace 
         URI, starting from this node.
       \
         The default namespace declarations are ignored by this method. 
         To lookup default namespace, use the <M:Node.isDefaultNamespace>
         method.
     @@Param:
        @@@Name:  namespaceURI
        @@@Type:
          ManakaiDOM:ManakaiDOMNamespaceURI
        @@@Description:
          @@@@lang:en
          @@@@@: The namespace URI to look for.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Always <DOM:null> will be returned.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Always <DOM:null> will be returned.
     @@Return:
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            An associated namespace prefix.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              No namespace prefix is found.  Always <DOM:null> is 
              returned for the <IF:DocumentFragment> node.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@: $r = null;
     @@Level[list]:  3
     @@SpecLevel:3
     @@Redefine:Node
  @ReAttr:
    @@Name: nodeName
    @@Description:
      @@@lang:en
      @@@@: The node name.
    @@Spec:
      @@@DOM3[list]:
        http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-F68D095
        http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-1841493061
    @@NSVersion[list]:
      Node.prefix
      Node.localName
    @@Get:
      @@@Type: DOMString
      @@@InCase:
        @@@@Value:\#document-fragment
        @@@@Description:
          @@@@@lang:en
          @@@@@@: Always this value for the "DocumentFragment" node.
      @@@DefaultValue: \#document-fragment
      @@@Def: \
  @ReAttr:
    @@Name: nodeType
    @@Description:
      @@@lang:en
      @@@@: The type of this node.
    @@Get:
      @@@Type: unsigned-short
      @@@InCase:
        @@@@Label: DOCUMENT_FRAGMENT_NODE
        @@@@Description:
          @@@@@lang:en
          @@@@@@: The node is a "DocumentFragment".
      @@@Def:
        @@@@Type:
          lang:Perl
        @@@@@: $r = __SUPER{Node}__->DOCUMENT_FRAGMENT_NODE;
    @@Redefine: Node

## IF: DocumentFragment

IF:
  @Name:  Document
  @Description:
    @@lang:en
    @@@: 
      The entire document.  It is conceptually the root of the 
      document tree and it provides the primary access to the 
      document's data.

  @ISA:  Node
  @Require:
    @@Module:
      @@@Def:
        @@@@Type:
          lang:Perl
        @@@@use:
          @@@@@@:
            Char::Class::XML
          @@@@@Import[list]:
            InXML_NameStartChar10
            InXMLNameChar10
            InXML_NCNameStartChar10
            InXMLNCNameChar10
            InXMLNameStartChar11
            InXMLNameChar11
            InXMLNCNameStartChar11
            InXMLNCNameChar11
    @@Condition[list]:
      DOM1
      DOM2
      DOM3
    
  @Attr:
     @@Name:  doctype
     @@Description:
       @@@lang:en
       @@@@:
         The "DocumentType" object associated with the "Document".
       \
         Note that even this attribute is defined as read-only, 
         the direct manipulations of child nodes (by the method "insertBefore" 
         for example) can change the document type.
     @@Level[list]:
       1
       2
       3
     @@SpecLevel[list]:
       1
       3
     @@Get:
        @@@Type:  DocumentType
        @@@Description:
          @@@@lang:en
          @@@@@:
            The "DocumentType" object for the "Document".
        @@@InCase:
          @@@@Value: 
            @@@@@is-null: 1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The document type declaration is omitted or it is an HTML 
              document.
            \
              Note: If it is an HTML document, the "doctype" attribute is 
              always "null" in DOM Level 1 and Level 2.  In DOM Level 3, 
              a "DocumentType" object may be returned even if the document 
              does not have explicit document type declaration.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            for (@{$self->{<Q:TreeCore:node>}->{<Q:infoset:children>}}) {
              if ($_->{<Q:DOMCore:nodeType>} eq <Q:DOMCore:DocumentType>) {
                     ## Condition sensitive
                $r = __CLASS{Node}__->__INT{getNodeReference}__ ($_);
                last;
              } elsif ($_->{<Q:DOMCore:nodeType>} eq <Q:infoset:Element>) {
                last;
              }
            }
  @Attr:
     @@Name:  implementation
     @@Description:
       @@@lang:en
       @@@@:
         The "DOMImplementation" object that handles the "Document".
     @@Get:
        @@@Type:  DOMImplementation
        @@@Def:
          @@@@Type:
            lang:dis
          @@@@GetProp:
            DOMCore:implementation
  @Attr:
     @@Name:  documentElement
     @@Description:
       @@@lang:en
       @@@@: The child node that is the document element of the document.
     @@Get:
        @@@Type:  Element
        @@@Description:
          @@@@lang:en
          @@@@@: The document element.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The document element not found.
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              The DOM specifications don't mention this case but for example 
              the DOMImplementation.createDocument (null, null, null) can 
              create a Document that does not have the document element.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            for (@{$self->{<Q:TreeCore:node>}->{<Q:infoset:children>}}) {
              if ($_->{<Q:DOMCore:nodeType>} eq <Q:infoset:Element>) {
                     ## Condition sensitive
                $r = __CLASS{Node}__->__INT{getNodeReference}__ ($_);
                last;
              }
            }
    @@Level[list]:
      1
      2
      3
    @@SpecLevel:1
  @Method:
     @@Name:  createElement
     @@Description:
       @@@lang:en
       @@@@:
         Create an element.
       \
         If there are known attributes with default values, 
         <IF:Attr> nodes representing them are automatically 
         created and attached to the element created.
     @@NSVersion:createElementNS
     @@Param:
        @@@Name:  tagName
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            The name of the element type to instantiate.
          \
            The case-sensitivity depends on that of the markup language 
            in use.  If it is case-insensitive, the <P:tagName> is 
            mapped to the canonical form of that markup language 
            by the DOM implementation.
     @@Return:
        @@@Type:  Element
        @@@Description:
          @@@@lang:en
          @@@@@:
            A new <IF:Element> object.
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:INVALID_CHARACTER_ERR
          @@@@SubType:
            @@@@@QName:
              MDOM_EXCEPTION:MDOM_BAD_NAME
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <P:tagName> is not a SGML or XML <XML:Name>.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            my $version;
            my $docNode = $self->{<Q:TreeCore:node>};
            __CODE{XMLVersion: out => version, docNode => docNode}__;
            __CODE{CheckName: name => tagName, version => version}__;
                       ## Condition sensitive
            my $node = __CLASS{Element}__->__INT{newObject}__;
            $node->{<Q:DOMCore:ownerDocument>} = $docNode;
            $node->{<Q:DOMCore:name>} = $tagName;
                 ## Condition sensitive
            $r = __CLASS{Node}__->__INT{getNodeReference}__ ($node, $self);
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              TODO: <P:tagName> should be normalized to uppercases if HTML.
            \
              TODO: Default attribute should be implemented.
    @@SpecLevel:1
    @@Level[list]:
      1
      2
      3
  @Method:
     @@Name:  createDocumentFragment
     @@Description:
       @@@lang:en
       @@@@:
         Create an empty <IF:DocumentFragment> object.
     @@Return:
        @@@Type:  DocumentFragment 
        @@@Description:
          @@@@lang:en
          @@@@@:
            The new <IF:DocumentFragment> object.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            my $docNode = $self->{<Q:TreeCore:node>};
                       ## Condition sensitive
            my $node = __CLASS{DocumentFragment}__->__INT{newObject}__;
            $node->{<Q:DOMCore:ownerDocument>} = $docNode;
                 ## Condition sensitive
            $r = __CLASS{Node}__->__INT{getNodeReference}__ ($node, $self);
    @@SpecLevel:1
    @@Level[list]:
      1
      2
      3
  @Method:
     @@Name:  createTextNode
     @@Description:
       @@@lang:en
       @@@@:
         Create a <IF:Text> node.
     @@Param:
        @@@Name:  data
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The data for the node.
     @@Return:
        @@@Type:  Text
        @@@Description:
          @@@@lang:en
          @@@@@:
            The new <IF:Text> object.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            my $docNode = $self->{<Q:TreeCore:node>};
                       ## Condition sensitive
            my $node = __CLASS{Text}__->__INT{newObject}__;
            $node->{<Q:DOMCore:ownerDocument>} = $docNode;
            $node->{<Q:infoset:content>} = defined $data ? $data : '';
                 ## Condition sensitive
            $r = __CLASS{Node}__->__INT{getNodeReference}__ ($node, $self);
    @@SpecLevel:1
    @@Level[list]:
      1
      2
      3
  @Method:
     @@Name:  createComment
     @@Description:
       @@@lang:en
       @@@@:
         Create a <IF:Comment> node.
     @@Param:
        @@@Name:  data
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The data for the node.
     @@Return:
        @@@Type:  Comment
        @@@Description:
          @@@@lang:en
          @@@@@:
            The new <IF:Comment> object.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            my $docNode = $self->{<Q:TreeCore:node>};
                       ## Condition sensitive
            my $node = __CLASS{Comment}__->__INT{newObject}__;
            $node->{<Q:DOMCore:ownerDocument>} = $docNode;
            $node->{<Q:infoset:content>} = defined $data ? $data : '';
                 ## Condition sensitive
            $r = __CLASS{Node}__->__INT{getNodeReference}__ ($node, $self);
    @@SpecLevel:1
    @@Level[list]:
      1
      2
      3
  @Method:
     @@Name:  createCDATASection
     @@Description:
       @@@lang:en
       @@@@:
         Create a <IF:CDATASection> node.
     @@Param:
        @@@Name:  data
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            The data for the <XML:CDATA> section.
     @@Return:
        @@@Type:  CDATASection
        @@@Description:
          @@@@lang:en
          @@@@@: 
            The new <IF:CDATASection> object.
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:NOT_SUPPORTED_ERR
          @@@@SubType:
            @@@@@QName:
              MDOM_EXCEPTION:MDOM_DOC_NOSUPPORT_XML
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                This document does not support the <Feature:XML> feature. 
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              HTML-only DOM implementations must also implement this method. 
              The DOM Level 3 Core Specification should have changed 
              the description from <QUOTE:if this document is an HTML document> 
              to <QUOTE:if this document does not support the <Feature:XML> 
              feature> for consistency with other non-HTML methods.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            my $version;
            my $docNode = $self->{<Q:TreeCore:node>};
            __CODE{XMLVersion: out => version, docNode => docNode}__;
            unless (defined $version) {
              __EXCEPTION{
                DOMException.NOT_SUPPORTED_ERR.
                MDOM_EXCEPTION:MDOM_DOC_NOSUPPORT_XML::
              }__;
            }
            __REQUIRE{DOMXML}__;
                       ## Condition sensitive
            my $node = __CLASS{CDATASection}__->__INT{newObject}__;
            $node->{<Q:DOMCore:ownerDocument>} = $docNode;
            $node->{<Q:infoset:content>} = defined $data ? $data : '';
                 ## Condition sensitive
            $r = __CLASS{Node}__->__INT{getNodeReference}__ ($node, $self);
    @@SpecLevel:1
    @@Level[list]:
      1
      2
      3
  @Method:
     @@Name:  createProcessingInstruction
     @@Description:
       @@@lang:en
       @@@@:
         Create a <IF:ProcessingInstruction> node.
     @@Param:
        @@@Name:  target
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            The target name of the processing instruction to create.
        @@@ImplNote:
          @@@@lang:en
          @@@@@:
            This is an XML <XML:Name>, not an XML Names <XML:NCName>.
        @@@ImplNote:
          @@@@lang:en
          @@@@@:
            The XML Specifications prohibit target names 
            matching to <XML:xml> in any lower/upper-case. 
            The DOM Specifications does not.
     @@Param:
        @@@Name:  data
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            The data for the node.
     @@Return:
        @@@Type:  ProcessingInstruction
        @@@Description:
          @@@@lang:en
          @@@@@:
            The new <IF:ProcessingInstruction> object.
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:INVALID_CHARACTER_ERR
          @@@@SubType:
            @@@@@QName:
              MDOM_EXCEPTION:MDOM_BAD_NAME
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <P:name> is not an XML <XML:Name>.
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:NOT_SUPPORTED_ERR
          @@@@SubType:
            @@@@@QName:
              MDOM_EXCEPTION:MDOM_DOC_NOSUPPORT_XML
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                This document does not support the <Feature:XML> feature.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            my $version;
            my $docNode = $self->{<Q:TreeCore:node>};
            __CODE{XMLVersion: out => version, docNode => docNode}__;
            unless (defined $version) {
              __EXCEPTION{
                DOMException.NOT_SUPPORTED_ERR.
                MDOM_EXCEPTION:MDOM_DOC_NOSUPPORT_XML::
              }__;
            }
            __CODE{CheckName: name => target, version => version}__;
            __REQUIRE{DOMXML}__;
                       ## Condition sensitive
            my $node = __CLASS{ProcessingInstruction}__->__INT{newObject}__;
            $node->{<Q:DOMCore:ownerDocument>} = $docNode;
            $node->{<Q:infoset:target>} = $target;
            $node->{<Q:infoset:content>} = defined $data ? $data : '';
                 ## Condition sensitive
            $r = __CLASS{Node}__->__INT{getNodeReference}__ ($node, $self);
    @@SpecLevel:1
    @@Level[list]:
      1
      2
      3
  @Method:
     @@Name:  createAttribute
     @@Description:
       @@@lang:en
       @@@@:
         Create an <IF:Attr> node.
     @@NSVersion: createAttributeNS
     @@Param:
        @@@Name:  name
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The name of the attribute.
        @@@ImplNote:
          @@@@lang:en
          @@@@@:
            There is no case-sensitivility consideration of the <P:name> 
            in the DOM Specifications.  Maybe attribute names are 
            lower-cased if it is an HTML document.
     @@Return:
        @@@Type:  Attr
        @@@Description:
          @@@@lang:en
          @@@@@:
            A new <IF:Attr> object.
        @@@ImplNote:
          @@@@lang:en
          @@@@@:
            <A:Node.nodeName> := <P:name>, <A:Node.localName> := <DOM:null>, 
            <A:Node.prefix> := <DOM:null>, <A:Node.namespaceURI> := <DOM:null>, 
            value := empty.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: INVALID_CHARACTER_ERR
          @@@@SubType:
            @@@@@QName:
              MDOM_EXCEPTION:MDOM_BAD_NAME
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <P:name> is not a SGML or XML <XML:Name>.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            my $version;
            my $docNode = $self->{<Q:TreeCore:node>};
            __CODE{XMLVersion: out => version, docNode => docNode}__;
            __CODE{CheckName: name => name, version => version}__;
                       ## Condition sensitive
            my $node = __CLASS{Attr}__->__INT{newObject}__;
            $node->{<Q:DOMCore:ownerDocument>} = $docNode;
            $node->{<Q:DOMCore:name>} = $name;
                 ## Condition sensitive
            $r = __CLASS{Node}__->__INT{getNodeReference}__ ($node, $self);
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              TODO: The name should be case-normalized by the definition 
              of the markup language in use.
    @@SpecLevel:1
    @@Level[list]:
      1
      2
      3
  @Method:
     @@Name:  createEntityReference
     @@Description:
       @@@lang:en
       @@@@:
         Create an <IF:EntityReference> object.  If the entity referred 
         is known, the child list of the <IF:EntityReference> is 
         made the same as that of the corresponding <IF:Entity> node.
       \
         NOTE: If any descendant of the <IF:Entity> node has an 
         unbound namespace prefix, the corresponding descendant of 
         the <IF:EntityReference> node created is also unbound.
     @@ImplNote:
       @@@lang:en
       @@@@:
         In this NOTEd case, that node might have <Q:infoset:prefix> 
         but will not have <Q:infoset:namespaceName>.
     @@NSVersion:\
     @@Param:
        @@@Name:  name
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            The name of the entity to refer.
        @@@ImplNote:
          @@@@lang:en
          @@@@@:
            This is an XML <XML:Name>, not an XML Names <XML:NCName>.
     @@Return:
        @@@Type:  EntityReference
        @@@Description:
          @@@@lang:en
          @@@@@:
            The new <IF:EntityReference> object.
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:INVALID_CHARACTER_ERR
          @@@@SubType:
            @@@@@QName:
              MDOM_EXCEPTION:MDOM_BAD_NAME
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <P:name> is not an XML <XML:Name>.
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:NOT_SUPPORTED_ERR
          @@@@SubType:
            @@@@@QName:
              MDOM_EXCEPTION:MDOM_DOC_NOSUPPORT_XML
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                This document does not support the <Feature:XML> feature.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            my $version;
            my $docNode = $self->{<Q:TreeCore:node>};
            __CODE{XMLVersion: out => version, docNode => docNode}__;
            unless (defined $version) {
              __EXCEPTION{
                DOMException.NOT_SUPPORTED_ERR.
                MDOM_EXCEPTION:MDOM_DOC_NOSUPPORT_XML::
              }__;
            }
            __CODE{CheckName: name => name, version => version}__;
            __REQUIRE{DOMXML}__;
                       ## Condition sensitive
            my $node = __CLASS{EntityReference}__->__INT{newObject}__;
            $node->{<Q:DOMCore:ownerDocument>} = $docNode;
            $node->{<Q:DOMCore:name>} = $name;
            #$node->{<Q:??:expanded>} = false;
                 ## Condition sensitive
            $r = __CLASS{Node}__->__INT{getNodeReference}__ ($node, $self);
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              TODO: Expand the reference.
    @@SpecLevel:1
    @@Level[list]:
      1
      2
      3
  @Method:
     @@Name:  getElementsByTagName
     @@Description:
       @@@lang:en
       @@@@:
         Return a <IF:NodeList> of all the <IF:Element> in document 
         order with a given element type name and are contained in the document.
     @@ImplNote:
       @@@lang:en
       @@@@:
         Does <QUOTE:contained> mean that an <IF:Element> node 
         which is not a descendant of the <IF:Document> does not match?
       \
         The DOM Level 2 Specification specifies as <QUOTE:pre-order 
         traversal>.  The DOM Level 3 Specifies it by 
         <QUOTE:in document order> and this makes the ambigiousness.
     @@Param:
        @@@Name:  tagname
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            The name of the element type to match on.
          \
            The case-sensitivility depends on the markup language in use.
        @@@InCase:
          @@@@Value:*
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Match all element type names.
     @@Return:
        @@@Type:  
          ManakaiDOM:ManakaiDOMGetElementsNodeList
        @@@Description:
          @@@@lang:en
          @@@@@:
            A new <IF:NodeList> object containing all the matched 
            <IF:Element> objects.
  @Method:
     @@Name:  importNode
     @@Description:
       @@@lang:en
       @@@@:
         Import a node from another document to this document, 
         without altering or removing the source node from 
         the original document (i.e. create a new copy of 
         the source node in this document).
     @@ImplNote:
       @@@lang:en
       @@@@:
         Copied: <A:nodeName>, <A:nodeType>, <A:prefix>, 
         <A:localName>, <A:namespaceURI>, <A:Entity.publicId>, 
         <A:Entity.systemId>, <A:Entity.notationName>, 
         <A:Notation.publicId>, <A:Notation.systemId>, 
         <A:ProcessingInstruction.target>, <A:ProcessingInstruction.data>, 
         <A:CharacterData.data>, <A:CharacterData.length>.
       \
         User data is not carried over.  However, if any 
         <IF:UserDataHandler>s has specified, these handlers will 
         be called with the appropriate parameters before this method 
         returns.
       \
         <A:parentNode> := <DOM:null>.  <A:Attr.ownerElement> := <DOM:null>. 
         <A:Attr.specified> := <DOM:true>.
         Specified attribute nodes attached to the <IF:Element> node 
         are imported.  Default attributes are created if exists.
     @@Param:
        @@@Name:  importedNode
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@:
            The node to import.
            \
            Note that <IF:Document> or <IF:DocumentType> nodes cannot 
            be imported.
     @@Param:
        @@@Name:  deep
        @@@Type:  boolean
        @@@Description:
          @@@@lang:en
          @@@@@:
            Whether the subtree under the <P:importedNode> 
            is recursively imported or not.
            \
            This parameter has no effect on <IF:Attr>, <IF:EntityReference>, 
            <IF:Notation>, <IF:ProcessingInstruction>, <IF:Text>, 
            <IF:CDATASection> and <IF:Comment> nodes.  The descendants of 
            the <IF:Attr> node are 
            always imported.  The descendants of the <IF:EntityReference> 
            node are always not imported.
        @@@InCase:
          @@@@Value:true
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The descendants are recursively imported if the 
              <P:importedNode> is of <IF:DocumentFragment>, <IF:Element> or 
              <IF:Entity>.
        @@@InCase:
          @@@@Value:false
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Import only the node itself.
     @@Return:
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@:
            The imported node.
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:NOT_SUPPORTED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The type of node being imported is not supported.
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              Maybe, if this document is not <Feature:XML> and 
              the node type is either <IF:ProcessingInstruction>, 
              <IF:Notation>, <IF:EntityReference>, <IF:Entity> or 
              <IF:CDATASection>.  And if namespaced nodes are imported?
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:INVALID_CHARACTER_ERR
          @@@@SubType:
            @@@@@QName:
              MDOM_EXCEPTION:MDOM_BAD_NAME
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                One of the imported names is not a SGML or XML <XML:Name>.
     @@Level[list]:  2
     @@SpecLevel:2
  @Method:
     @@Name:  createElementNS
     @@Description:
       @@@lang:en
       @@@@:
         Create an element.
       \
         If there are known attributes with default values, 
         <IF:Attr> nodes representing them are automatically 
         created and attached to the element created.
     @@NoNSVersion:createElement
     @@Param:
        @@@Name:  namespaceURI
        @@@Type:
          ManakaiDOM:ManakaiDOMNamespaceURI
        @@@Description:
          @@@@lang:en
          @@@@@:
            The namespace URI of the element to create.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The element to create will have no namespace.
     @@Param:
        @@@Name:  qualifiedName
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            The qualified name of the type of the element to create.
     @@Return:
        @@@Type:  Element
        @@@Description:
          @@@@lang:en
          @@@@@:
            A new <IF:Element> object.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: INVALID_CHARACTER_ERR
          @@@@SubType:
            @@@@@QName:
              MDOM_EXCEPTION:MDOM_BAD_NAME
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <P:qualifiedName> is not an XML <XML:Name>.
            @@@@@SpecLevel:2
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NAMESPACE_ERR
          @@@@SubType:
            @@@@@QName:
              MDOM_EXCEPTION:MDOM_NS_MALFORMED_QNAME
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@: 
                The <P:qualifiedName> is malformed as a qualified name.
            @@@@@SpecLevel:2
          @@@@SubType:
            @@@@@QName:
              MDOM_EXCEPTION:MDOM_NS_PREFIX_WITH_NULL_URI
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <P:qualifiedName> has a prefix and the
                <P:namespaceURI> is <DOM:null>.
            @@@@@SpecLevel:2
          @@@@SubType:
            @@@@@QName:
              MDOM_EXCEPTION:MDOM_NS_XML_WITH_OTHER_URI
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <P:qualifiedName> has a prefix that is <XML:xml> and the
                <P:namespaceURI> is different from
                <URI:http://www.w3.org/XML/1998/namespace>.
            @@@@@SpecLevel:2
          @@@@SubType:
            @@@@@QName:
              MDOM_EXCEPTION:MDOM_NS_XMLNS_WITH_OTHER_URI
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <P:qualifiedName> has a prefix that is <XML:xmlns> and
                the <P:namespaceURI> is different from the
                <URI:http://www.w3.org/2000/xmlns>.
            @@@@@SpecLevel:3
          @@@@SubType:
            @@@@@QName:
              MDOM_EXCEPTION:MDOM_NS_XMLNSQ_WITH_OTHER_URI
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <P:qualifiedName> is <XML:xmlns> and
                the <P:namespaceURI> is different from the
                <URI:http://www.w3.org/2000/xmlns>.
            @@@@@SpecLevel:3
          @@@@SubType:
            @@@@@QName:
              MDOM_EXCEPTION:MDOM_NS_OTHER_WITH_XML_URI
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <P:namespaceURI> is 
                <URI:http://www.w3.org/XML/1998/namespace> and the 
                prefix of the <P:qualifiedName> is different from 
                <XML:xml>.
            @@@@@SpecLevel[list]:
          @@@@SubType:
            @@@@@QName:
              MDOM_EXCEPTION:MDOM_NS_OTHER_WITH_XMLNS_URI
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <P:namespaceURI> is <URI:http://www.w3.org/2000/xmlns> and 
                neither the <P:qualifiedName> nor its prefix is <XML:xmlns>.
            @@@@@SpecLevel:3
          @@@@SubType:
            @@@@@QName:
              MDOM_EXCEPTION:MDOM_NS_XMLNS_XMLNS
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <P:qualifiedName> is <XML:xmlns:xmlns>.
            @@@@@SpecLevel[list]:
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:NOT_SUPPORTED_ERR
          @@@@SubType:
            @@@@@QName:
              MDOM_EXCEPTION:MDOM_DOC_NOSUPPORT_XML
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                This document does not support the <Feature:XML> 
                feature.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            my ($version, $prefix, $localName);
            my $docNode = $self->{<Q:TreeCore:node>};
            __CODE{XMLNS: docNode => docNode,
                          qualifiedName => qualifiedName,
                          namespaceURI => namespaceURI,
                          out-version => version,
                          out-localName => localName,
                          out-prefix => prefix}__;

                       ## Condition sensitive
            my $node = __CLASS{Element}__->__INT{newObject}__;
            $node->{<Q:DOMCore:ownerDocument>} = $docNode;
            $node->{<Q:infoset:namespaceName>} = $namespaceURI;
            $node->{<Q:infoset:prefix>} = $prefix;
            $node->{<Q:infoset:localName>} = $localName;
                 ## Condition sensitive
            $r = __CLASS{Node}__->__INT{getNodeReference}__ ($node, $self);
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              TODO: Default attribute should be implemented.
    @@SpecLevel:2
    @@Level[list]:
      2
      3
  @Method:
     @@Name:  createAttributeNS
     @@Description:
       @@@lang:en
       @@@@:
         Create an attribute of the given qualified name and namespace URI.
     @@NoNSVersion: createAttribute
     @@Param:
        @@@Name:  namespaceURI
        @@@Type:
          ManakaiDOM:ManakaiDOMNamespaceURI
        @@@Description:
          @@@@lang:en
          @@@@@: The namespace URI of the attribute to create.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The attribute has no namespace.
     @@Param:
        @@@Name:  qualifiedName
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The qualified name of the attribute to create.
     @@Return:
        @@@Type:  Attr
        @@@Description:
          @@@@lang:en
          @@@@@: A new attribute object.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: INVALID_CHARACTER_ERR
          @@@@SubType:
            @@@@@QName:
              MDOM_EXCEPTION:MDOM_BAD_NAME
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <P:qualifiedName> is not an XML <XML:Name>.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NAMESPACE_ERR
          @@@@SubType:
            @@@@@QName:
              MDOM_EXCEPTION:MDOM_NS_MALFORMED_QNAME
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@: 
                The <P:qualifiedName> is malformed as a qualified name.
            @@@@@SpecLevel:2
          @@@@SubType:
            @@@@@QName:
              MDOM_EXCEPTION:MDOM_NS_PREFIX_WITH_NULL_URI
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <P:qualifiedName> has a prefix and the
                <P:namespaceURI> is <DOM:null>.
            @@@@@SpecLevel:2
          @@@@SubType:
            @@@@@QName:
              MDOM_EXCEPTION:MDOM_NS_XML_WITH_OTHER_URI
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <P:qualifiedName> has a prefix that is <XML:xml> and the
                <P:namespaceURI> is different from
                <URI:http://www.w3.org/XML/1998/namespace>.
            @@@@@SpecLevel:2
          @@@@SubType:
            @@@@@QName:
              MDOM_EXCEPTION:MDOM_NS_XMLNS_WITH_OTHER_URI
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <P:qualifiedName> has a prefix that is <XML:xmlns> and
                the <P:namespaceURI> is different from the
                <URI:http://www.w3.org/2000/xmlns>.
            @@@@@SpecLevel:3
          @@@@SubType:
            @@@@@QName:
              MDOM_EXCEPTION:MDOM_NS_XMLNSQ_WITH_OTHER_URI
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <P:qualifiedName> is <XML:xmlns> and
                the <P:namespaceURI> is different from the
                <URI:http://www.w3.org/2000/xmlns>.
            @@@@@SpecLevel:2
          @@@@SubType:
            @@@@@QName:
              MDOM_EXCEPTION:MDOM_NS_OTHER_WITH_XML_URI
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <P:namespaceURI> is 
                <URI:http://www.w3.org/XML/1998/namespace> and the 
                prefix of the <P:qualifiedName> is different from 
                <XML:xml>.
            @@@@@SpecLevel[list]:
          @@@@SubType:
            @@@@@QName:
              MDOM_EXCEPTION:MDOM_NS_OTHER_WITH_XMLNS_URI
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <P:namespaceURI> is <URI:http://www.w3.org/2000/xmlns> and 
                neither the <P:qualifiedName> nor its prefix is <XML:xmlns>.
            @@@@@SpecLevel:3
          @@@@SubType:
            @@@@@QName:
              MDOM_EXCEPTION:MDOM_NS_XMLNS_XMLNS
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <P:qualifiedName> is <XML:xmlns:xmlns>.
            @@@@@SpecLevel[list]:
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@: Is no-prefix with URI is OK?
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:NOT_SUPPORTED_ERR
          @@@@SubType:
            @@@@@QName:
              MDOM_EXCEPTION:MDOM_DOC_NOSUPPORT_XML
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                This document does not support the <Feature:XML> 
                feature.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            my ($version, $prefix, $localName);
            my $docNode = $self->{<Q:TreeCore:node>};
            __CODE{XMLNS: docNode => docNode,
                          qualifiedName => qualifiedName,
                          namespaceURI => namespaceURI,
                          out-version => version,
                          out-localName => localName,
                          out-prefix => prefix}__;

                       ## Condition insensitive
            my $node = __CLASS{Attr::}__->__INT{newObject}__;
            $node->{<Q:DOMCore:ownerDocument>} = $docNode;
            $node->{<Q:infoset:localName>} = $localName;
            $node->{<Q:infoset:namespaceName>} = $namespaceURI;
            $node->{<Q:infoset:prefix>} = $prefix;
            $node->{<Q:infoset:specified>} = true;
                 ## Condition sensitive
            $r = __CLASS{Node}__->__INT{getNodeReference}__ ($node, $self);
    @@SpecLevel:2
    @@Level[list]:
      2
      3
  @Method:
     @@Name:  getElementsByTagNameNS
     @@Description:
        @@@lang:en
        @@@@:
          Return a <IF:NodeList> of all the <IF:Element> nodes 
          with a given local name and namespace URI in document order.
     @@Param:
        @@@Name:  namespaceURI
        @@@Type:
          ManakaiDOM:ManakaiDOMNamespaceURI
        @@@Description:
          @@@@lang:en
          @@@@@:
            The namespace URI of the elements to match on.
        @@@InCase:
          @@@@Value:*
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Match all namespaces.
     @@Param:
        @@@Name:  localName
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            The local name of the elements to match on.
        @@@InCase:
          @@@@Value:*
          @@@@Description:
            @@@@@lang:en
            @@@@@@: Match all local names.
     @@Return:
        @@@Type:
          ManakaiDOM:ManakaiDOMGetElementsNodeList
        @@@Description:
          @@@@lang:en
          @@@@@:
            A new <IF:NodeList> object containing all the 
            matched <IF:Element> objects.
        @@@ImplNote:
          @@@@lang:en
          @@@@@:
            In <M:Element.getElementsByTagName>, HTML-only implementations 
            may raise an exception.
     @@Level[list]:  2
     @@SpecLevel:2
  @Method:
     @@Name:  getElementById
     @@Description:
       @@@lang:en
       @@@@:
         Return the <IF:Element> that has an <SGML:ID> attribute 
         with the given value.
       \
         If more than one element has an <SGML:ID> attribute 
         with that value, what is returned is undefined.
     @@ImplNote:
       @@@lang:en
       @@@@:
         DOM implementations are expected to use the <A:Attr.isId> 
         to detect an <SGML:ID> attribute.
       \
         <XML:ID> ATTRIBUTES, not <XML:ID> ELEMENTS.
       \
         Can an <IF:Element> that is not a descendant of the <IF:Document> 
         be returned?
     @@Param:
        @@@Name:  elementId
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            The unique identifier for an element.
     @@Level[list]:  2
     @@SpecLevel:2
     @@ImplNote:
       @@@lang:en
       @@@@:
         This method is defined in the interface <IF:HTMLDocument> 
         in the DOM Level 1.
     @@Return:
        @@@Type:  Element
        @@@Description:
          @@@@lang:en
          @@@@@:
            The matching element.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              No element with the specified <SGML:ID> exists.
  @Attr:
     @@Name:  inputEncoding
     @@Description:
       @@@lang:en
       @@@@:
         The encoding used for this document at the time of 
         the parsing.
       \
         This attribute is corresponding to the [character encoding scheme] 
         property of the document infomation item.
     @@ImplNote:
        @@@lang:en
        @@@@:
          It is unclear what type of values are permitted. 
          IANA-registered charset names? XML encoding declaration 
          names?  Or, any names passed from the upper-level protocols?
     @@Get:
        @@@Type:  DOMString
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The input encoding is not known.
        @@@Def:
          @@@@Type:
            lang:dis
          @@@@GetProp:
            infoset:characterEncodingScheme
     @@Level[list]:  3
     @@SpecLevel:3
  @Attr:
     @@Name:  xmlEncoding
     @@Description:
       @@@lang:en
       @@@@:
         The value of the encoding declaration in the XML declaration 
         of the document.
     @@ImplNote:
       @@@lang:en
       @@@@:
         This attribute is NOT equal to the [character encoding scheme] 
         property of the document information item of the Infoset.
     @@Get:
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The encoding.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The encoding is not specified or not known.
        @@@Def:
          @@@@Type:
            lang:dis
          @@@@GetProp:
            DOMCore:xmlEncoding
     @@Level[list]:  3
     @@SpecLevel:3
  @Attr:
     @@Name:  xmlStandalone
     @@Description:
       @@@lang:en
       @@@@: 
         Whether the document is standalone or not.
       \
         This attribute is corresponding to the standalone declaration 
         in the XML declaration and the [standalone] property of the 
         document information item of the XML Infoset.
     @@ImplNote:
       @@@lang:en
       @@@@: Default false.
     @@Get:
        @@@Type:  boolean
        @@@Def:
          @@@@Type:
            lang:dis
          @@@@GetProp:
            infoset:standalone
     @@Set:
        @@@Type:  boolean
        @@@Description:
          @@@@lang:en
          @@@@@: Whether standalone or not.
        @@@InCase:
          @@@@Value: true
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Standalone "yes".  Note that no verification is done when 
              setting the value.  DOM applications should use 
              the method "normalizeDocument" with the "validate" parameter 
              to verify whether the value match the Validity Constraint.
        @@@InCase:
          @@@@Value: false
          @@@@Description:
            @@@@@lang:en
            @@@@@@: Standalone "no".
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:NOT_SUPPORTED_ERR
          @@@@SubType:
            @@@@@QName:
              MDOM_EXCEPTION:MDOM_DOC_NOSUPPORT_XML
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The current document does not support the <Feature:XML> 
                feature.
        @@@Def:
          @@@@Type:
            lang:dis
          @@@@SetProp:
            infoset:standalone
        @@@ImplNote:
          @@@@lang:en
          @@@@@:
            Isn't <X:DOMException.NO_MODIFICATION_ALLOWED_ERR> raised?
            (Since DOM Level 1-3 does not have read-only <IF:Document> node?)
     @@Level[list]:  3
     @@SpecLevel:3
  @Attr:
     @@Name:  xmlVersion
     @@Description:
       @@@lang:en
       @@@@:
         The version number of the document.
      \
         This attribute is corresponding to the version declaration in the 
         XML declaration and [version] property of the document information 
         item of the XML Infoset.
     @@Get:
        @@@Type:  DOMString
        @@@InCase:
          @@@@Value: 1.0
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The XML version is specified as XML 1.0 or the XML document 
              has no version declaration.
        @@@InCase:
          @@@@Value: 1.1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The XML version is specified as XML 1.1.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The document does not support the "XML" feature.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            my $node = $self->{<Q:TreeCore:node>};
            __CODE{XMLVersion: out => r, docNode => node}__;
     @@Set:
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            The XML version number of the document.  Note that 
            changing this attribute will affect methods that 
            check for invalid characters in XML "Name"s.  DOM 
            application should invoke the method "normalizeDocument" in 
            order to check for invalid characters in the "Node"s that 
            are already part of the document.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NOT_SUPPORTED_ERR
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            my $node = $self->{<Q:TreeCore:node>};
            if (defined $node->{<Q:DOMCore:hasFeature>}->{XML}) {
              if ($given and
                  ($given eq '1.0' or $given eq '1.1')) {
                $node->{<Q:infoset:version>} = $given;
              } else {
                __EXCEPTION{
                  DOMException.NOT_SUPPORTED_ERR.
                  MDOM_EXCEPTION:MDOM_IMPL_NOSUPPORT_XMLVER::
                    <Q:infoset:version> => $given,
                }__;
              }
            } else {
              __EXCEPTION{
                DOMException.NOT_SUPPORTED_ERR.
                MDOM_EXCEPTION:MDOM_DOC_NOSUPPORT_XML::
              }__;
            }
     @@Level[list]:  3
     @@SpecLevel:3
  @Attr:
     @@Name:  strictErrorChecking
     @@Description:
       @@@lang:en
       @@@@:
         Whether error checking is enforced or not.
     @@Get:
        @@@Type:  boolean
        @@@Def:
          @@@@Type:
            lang:dis
          @@@@GetProp:
            DOMCore:strictErrorChecking
     @@Set:
        @@@Type:  boolean
        @@@Description:
          @@@@lang:en
          @@@@@: Whether error checking is enforced or not.
        @@@InCase:
          @@@@Value: false
          @@@@@: 
            The implementation is free to not every possible error 
            case normally defined on DOM operations, and not raise any 
            "DOMException" on DOM operations or report error 
            while using method "normalizeDocument".  In case of error, 
            the behavior is undefined.
        @@@Def:
          @@@@Type:
            lang:dis
          @@@@SetProp:
            DOMCore:strictErrorChecking
     @@Level[list]:  3
     @@SpecLevel:3
     @@ImplNote:
       @@@lang:en
       @@@@: This attribute is "true" by default.
  @Attr:
     @@Name:  documentURI
     @@Description:
       @@@lang:en
       @@@@: The location of the document.
     @@Level[list]:  3
     @@SpecLevel:3
     @@Get:
        @@@Type:
          ManakaiDOM:ManakaiDOMURI
        @@@Description:
          @@@@lang:en
          @@@@@: The location of the document.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The location is undefined or the "Document" was created using 
              the method "createDocument".
        @@@Def:
          @@@@Type:
            lang:dis
          @@@@GetProp:
            DOMCore:documentURI
     @@Set:
        @@@Type:
          ManakaiDOM:ManakaiDOMURI
        @@@Description:
          @@@@lang:en
          @@@@@: 
            The location of the document.  Note that no lexical checking is 
            performed.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The location is undefined.
        @@@Def:
          @@@@Type:
            lang:dis
          @@@@SetProp:
            DOMCore:documentURI
  @Method:
     @@Name:  adoptNode
     @@Return:
        @@@Type:  Node
        @@@Exception[list]:  DOMException
     @@Param:
        @@@Name:  source
        @@@Type:  Node
     @@Level[list]:  3
     @@SpecLevel:3
  @Attr:
     @@Name:  domConfig
     @@Description:
       @@@lang:en
       @@@@: The configuration used when "normalizeDocument" is invoked.
     @@Get:
        @@@Type:  DOMConfiguration
        @@@Description:
          @@@@lang:en
          @@@@@: The DOM configuration object.
        @@@Def:
          @@@@Type:
            lang:dis
          @@@@GetProp:
            DOMCore:domConfig
     @@Level[list]:  3
     @@SpecLevel:3
  @Method:
     @@Name:  normalizeDocument
     @@Description:
       @@@lang:en
       @@@@:
         Act as if the document was going through a save and 
         load cycle, putting the document in a "normal" form.
       \
         - Update the replacement tree of <IF:EntityReference> nodes.
       \
         - Normalize <IF:Text> nodes, as the method <M:Node.normalize> does.
       \
         - Other normalization specified by the <M:Document.domConfig>.
       \
         Mutation events, when supported, are generated to reflect  
         the changes occuring on the document.
       \
         If errors occur, such as an attempt to update a read-only 
         node or a <A:Node.nodeName> contains an invalid character, 
         (fatal and non-fatal) errors and warnings will be reported using 
         the <IF:DOMErrorHandler> object associated with the 
         <DOM:error-handler> parameter.
     @@Level[list]:  3
     @@SpecLevel:3
  @Method:
     @@Name:  renameNode
     @@Description:
       @@@lang:en
       @@@@:
         Rename an <IF:Element> or <IF:Attr> node. 
      \
         When possible, this simply changes the name of the 
         given node.  Otherwise, this creates a new node 
         with the specified name and replaces the existing node 
         with the new node.
     @@ImplNote:
       @@@lang:en
       @@@@:
         Non-simple way:
       \
         = Create a node.
       \
         = Any registered event listener is registered on the new node. 
       \
         = Any user data is removed from the old node.
       \
         = The old node is removed from its parent if any.
       \
         = The children are moved to the new node.
       \
         = The specified attributes are moved to the new node.
       \
         = The new node is inserted at the position the old node 
           used to have in its parent's child nodes list.
       \
         = The user data is attached to the new node.
       \
         Default attributes from the DTD are updated according to 
         the new element type name.  The implementation may 
         update from other schemas.
       \ 
         <IF:Attr> attached to an <IF:Element> is first removed from 
         the <IF:Element>.  Then either modifying the existing node 
         or creating a new node and put is back.
       \
         A user data event <DOM:NODE_RENAMED> is fired and if 
         the implementation supports the <Feature:MutationNameEvents>, 
         each mutation operation involved fires the appropriate event 
         and in the end 
         <Q:ev:DOMElementNameChanged> or <Q:ev:DOMAttributeNameChanged> 
         is fired.
     @@Param:
        @@@Name:  n
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@:
            The node to rename.
     @@Param:
        @@@Name:  namespaceURI
        @@@Type:
          ManakaiDOM:ManakaiDOMNamespaceURI
        @@@Description:
          @@@@lang:en
          @@@@@:
            The new namespace URI.
     @@Param:
        @@@Name:  qualifiedName
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            The new qualified name.
     @@Return:
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@:
            The renamed node.
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:NOT_SUPPORTED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The type of the specified node is neither 
              <IF:Element> nor <IF:Attr>, or the DOM implementation 
              does not support the renaming of the document element.
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:INVALID_CHARACTER_ERR
          @@@@SubType:
            @@@@@QName:
              MDOM_EXCEPTION:MDOM_BAD_NAME
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The <P:qualifiedName> is not an XML <XML:Name>.
       @@@Exception:
         @@@@Type:DOMException
         @@@@Name:WRONG_DOCUMENT_ERR
         @@@@Description:
           @@@@@lang:en
           @@@@@@:
             The <P:n> was created from a different document.
       @@@Exception:
         @@@@Type:DOMException
         @@@@Name:NAMESPACE_ERR
         @@@@Description:
           @@@@@lang:en
           @@@@@@:
             Either the <P:qualifiedName> is malformed, 
             the <P:qualifiedName> has a prefix and the <P:namespaceURI> 
             is <DOM:null>, the <P:qualifiedName> has a prefix that 
             is <XML:xml> and the <P:namespaceURI> is different 
             from <URI:http://www.w3.org/XML/1998/namespace>, 
             the <P:n> is an attribute and <P:qualifiedName> or its 
             prefix is <XML:xmlns> and the <P:namespaceURI> is 
             different from <URI:http://www.w3.org/2000/xmlns/>.
     @@ImplNote:
       @@@lang:en
       @@@@:
         What should be happen if non-XML or non-namespace node 
         is tried to rename?
     @@Level[list]:  3
     @@SpecLevel:3
  
  @ReAttr:
    @@Name:baseURI
    @@Description:
      @@@lang:en
      @@@@:
        The base URI of this document.
    @@Get:
      @@@Type:
        ManakaiDOM:ManakaiDOMURI
      @@@Description:
        @@@@lang:en
        @@@@@: The base URI.
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The DOM implementation is unable to obtain an absolute URI.
      @@@Def:
        @@@@Type:
          lang:Perl
        @@@@@:
          if ($self->{<Q:TreeCore:node>}->{<Q:DOMCore:hasFeature>}->{HTML}) {
            $r = $self->{<Q:TreeCore:node>}
                      ->__SUPER{ManakaiDOMNodeObjectNode::}__::__INT{htmlBaseURI}__;
          } else {
            $r = $self->{<Q:TreeCore:node>}
                      ->__SUPER{ManakaiDOMNodeObjectNode::}__::__INT{contentBaseURI}__
                                                 (false);
          }
       @@@ImplNote:
         @@@@lang:en
         @@@@@:
           If a document has both a <HTML:base> element and 
           an <XML:xml:base> attribute, or even in the case that 
           an XHTML 1 document has an <XML:xml:base> attribute, 
           its result is not defined by any W3C specification.
    @@SpecLevel:3
    @@Level[list]:3
    @@Redefine:Node
  @ReMethod:
     @@Name:  lookupPrefix
     @@Description:
       @@@lang:en
       @@@@:
         Lookup the namespace prefix associated to the given namespace 
         URI, starting from this node.
       \
         The default namespace declarations are ignored by this method. 
         To lookup default namespace, use the <M:Node.isDefaultNamespace>
         method.
     @@Param:
        @@@Name:  namespaceURI
        @@@Type:
          ManakaiDOM:ManakaiDOMNamespaceURI
        @@@Description:
          @@@@lang:en
          @@@@@: The namespace URI to look for.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Always <DOM:null> will be returned.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Always <DOM:null> will be returned.
     @@Return:
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            An associated namespace prefix.
          \
            If more than one prefix are associated to the 
            namespace URI, which is returned is implementation 
            dependent.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              No namespace prefix is found.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            if (not defined $namespaceURI) {
              $r = null;
            } else {
              for (@{$self->{<Q:TreeCore:node>}->{<Q:infoset:children>}}) {
                if ($_->{<Q:DOMCore:nodeType>} eq <Q:infoset:Element>) {
                  $r = $_->__SUPER{ManakaiDOMNodeObjectNode::}__::__INT{lookupNamespacePrefix}__
                                                 ($namespaceURI, $_);
                  last;
                }
              }
            }
     @@Level[list]:  3
     @@SpecLevel:3
     @@Redefine:Node
  @ReAttr:
    @@Name: nodeName
    @@Description:
      @@@lang:en
      @@@@: The node name.
    @@Spec:
      @@@DOM3[list]:
        http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-F68D095
        http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-1841493061
    @@NSVersion[list]:
      Node.prefix
      Node.localName
    @@Get:
      @@@Type: DOMString
      @@@InCase:
        @@@@Value:\#document
        @@@@Description:
          @@@@@lang:en
          @@@@@@: Always this value for the "Document" node.
      @@@DefaultValue: \#document
      @@@Def: \
  @ReAttr:
    @@Name: nodeType
    @@Description:
      @@@lang:en
      @@@@: The type of this node.
    @@Get:
      @@@Type: unsigned-short
      @@@InCase:
        @@@@Label: DOCUMENT_NODE
        @@@@Description:
          @@@@@lang:en
          @@@@@@: The node is a "Document".
      @@@Def:
        @@@@Type:
          lang:Perl
        @@@@@: $r = __SUPER{Node}__->DOCUMENT_NODE;
    @@Redefine: Node
  @ReAttr:
     @@Name:  textContent
     @@Description:
       @@@lang:en
       @@@@:
         The text content of this node and its descendants.
     @@Get:
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The text content of this node.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The text content is defined to be "null".
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@: $r = null;
     @@Set:
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: Setting this attribute has no effect.
        @@@Warning:
          @@@@Type:
            ManakaiDOM:ManakaiDOMImplementationWarning
          @@@@Name: ATTR_SET_NO_EFFECT
          @@@@Description:
            @@@@@lang:en
            @@@@@@: Setting this attribute has no effect.
        @@@Def: \
     @@Level[list]: 3
     @@SpecLevel:3
     @@Redefine: Node
  @IntMethod:
    @@Name: newObject
    @@Description:
      @@@lang:en
      @@@@:
        Construct an object for the new instance of the "Document".
      \
        Note that this method is for the internal use.  DOM 
        applications must use the "createDocument" method 
        of the "DOMImplementation" interface to create a new "Document".
    @@ImplNote:
      @@@lang:en
      @@@@:
        The caller of this internal method MUST ensure to set 
        the attributes: <Q:TreeCore:implementation>.
    @@Return:
      @@@Type:
        ManakaiDOM:ManakaiDOMNodeObject
      @@@Description:
        @@@@lang:en
        @@@@@: The new object for the "Document".
      @@@Def:
        @@@@Type:
          lang:Perl
        @@@@@:
          $r = __CLASS{Node}__->__INT{newObject}__;
          $r->{<Q:DOMCore:nodeType>} = <Q:infoset:Document>;
          $r->{<Q:infoset:version>} = '1.0';
          $r->{<Q:DOMCore:strictErrorChecking>} = true;
       @@@ImplNote:
         @@@@lang:en
         @@@@@:
           Other properties required to be a legal <IF:Document> object:
           <Q:DOMCore:implementation>, <Q:ManakaiDOM:implID>.
         \
           Other available properties: <Q:DOMCore:read-only>,
           <Q:infoset:characterEncodingScheme>, <Q:DOMCore:xmlEncoding>,
           <Q:infoset:standalone>, <Q:infoset:version>,
           <Q:DOMCore:documentURI>, <Q:DOMCore:strictErrorChecking>, 
           <Q:infoset:children>.
    @@Level[list]:
      1
      2
      3

## IF: Document

ConfigParam:
  @Description:
    @@lang:en
    @@@:
      A parameter name used with the <IF:DOMConfiguration>.
    \
      Names are case-insensitive.  To avoid possible conflicts, 
      names referring to parameters defined outside the DOM 
      specification should be made unique.  Names are 
      recommended to follow the Unicode identifier specification 
      with the addition of the character <CHAR:HYPHEN-MINUS>.
  @ImplNote:
    @@lang:en
    @@@:
      DOM implementations must recognize all parameters 
      and some parameter values defined in the DOM Level 3 Core Specification.
    \
      DOM parameters are similar to features and properties of SAX2.
  @Param:
    @@Name: canonical-form
    @@IsSupportRequired:1
    @@Type: boolean
    @@InCase:
      @@@Value: true
      @@@Target:
        @@@@TargetMethod:
          Document::.normalizeDocument
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            Canonicalize the document accoding to the rules specified in 
            the XML C14N Version 1.0 Specification.
        \
            This is limited to what can be represented in the DOM.  
            For example, there is no way to specify the order of 
            the attributes in the DOM.
      @@@Target:
        @@@@TargetModule:
          DOMLS:LSSerializer::
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            Write the document according to the rules specified in 
            the XML C14N Version 1.0 Specification.
            \
            Serializing an XML 1.1 document will generate a fatal error.
        @@@@ImplNote:
          @@@@@lang:en
          @@@@@@:
            Why error? Because c14n does not support XML 1.1?
      ## From DOM Level 3 Core
      @@@SetParam:
        @@@@Name: entities
        @@@@Type: boolean
        @@@@Value: false
      @@@SetParam:
        @@@@Name: normalize-characters
        @@@@Type: boolean
        @@@@Value: false
      @@@SetParam:
        @@@@Name: cdata-sections
        @@@@Type: boolean
        @@@@Value: false
      @@@SetParam:
        @@@@Name: namespaces
        @@@@Type: boolean
        @@@@Value: true
      @@@SetParam:
        @@@@Name: namespace-declarations
        @@@@Type: boolean
        @@@@Value: true
      @@@SetParam:
        @@@@Name: well-formed
        @@@@Type: boolean
        @@@@Value: true
      @@@SetParam:
        @@@@Name: element-content-whitespace
        @@@@Type: boolean
        @@@@Value: true
      ## From DOM Level 3 LS
      @@@SetParam:
        @@@@Name:format-pretty-print
        @@@@Type:boolean
        @@@@Value:false
      @@@SetParam:
        @@@@Name:discade-default-content
        @@@@Type:boolean
        @@@@Value:false
      @@@SetParam:
        @@@@Name:xml-declaration
        @@@@Type:boolean
        @@@@Value:false
    @@InCase:
      @@@Value: false
      @@@IsSupportRequired:1
      @@@IsDefault:1
      @@@Description:
        @@@@lang:en
        @@@@@: Do not canonicalize the document or the output.
  @Param:
    @@Name: cdata-sections
    @@IsSupportRequired:1
    @@Type:boolean
    @@InCase:
      @@@Value: true
      @@@IsSupportRequired:1
      @@@IsDefault:1
      @@@Description:
        @@@@lang:en
        @@@@@:
          Keep <IF:CDATASection> nodes in the document.
      @@@SetParam:
        @@@@Name: canonicel-form
        @@@@Type:boolean
        @@@@Value:false
    @@InCase:
      @@@Value: false
      @@@IsSupportRequred:1
      @@@Description:
        @@@@lang:en
        @@@@@:
          Transform <IF:CDATASection> nodes in the document into 
          <IF:Text> nodes.  The new <IF:Text> node is then 
          combined with any adjacent <IF:Text> node.
  @Param:
    @@Name: check-character-normalization
    @@IsSupportRequired
    @@Type:boolean
    @@InCase:
      @@@Value: true
      @@@Description:
        @@@@lang:en
        @@@@@:
          Check whether the characters in the document are fully normalized 
          as defined in Appendix B of the XML 1.1 Specification.  When 
          a sequence of characters is encountered that fails 
          normalization checking, an error with the 
          <A:DOMError.type> equals to 
          <DOM:check-character-normalization-failure> is issued.
    @@InCase:
      @@@Value: false
      @@@IsSupportRequired:1
      @@@IsDefault:1
      @@@Description:
        @@@@lang:en
        @@@@@: Do not check whether characters are normalized.
  @Param:
    @@Name: comments
    @@IsSupportRequired:1
    @@Type:boolean
    @@InCase:
      @@@Value:true
      @@@IsSupportRequired:1
      @@@IsDefault:1
      @@@Description:
        @@@@lang:en
        @@@@@:
          Keep <IF:Comment> nodes in the document.
    @@InCase:
      @@@Value:false
      @@@IsSupportRequired:1
      @@@Description:
        @@@@lang:en
        @@@@@:
           Discard <IF:Comment> nodes in the document.
  @Param:
    @@Name: datatype-normalization
    @@IsSupportRequired:1
    @@Type:boolean
    @@InCase:
      @@@Value:true
      @@@Description:
        @@@@lang:en
        @@@@@:
          Expose schema normalized values in the tree.
        \
          This parameter required to have <DOM:validate> parameter 
          equals to <DOM:true>, or this parameter has no effect.
        \
          Note that the attribute value normalization as defined 
          in the XML Specifications does not applied.  This 
          parameter is only meant for schema languages other 
          than the DTD.
    @@InCase:
      @@@Value:false
      @@@IsSupportRequired:1
      @@@IsDefault:0
      @@@Description:
        @@@@lang:en
        @@@@@: Do not perform schema normalization on the tree.
  @Param:
    @@Name: element-content-whitespace
    @@IsSupportRequired:1
    @@Type:boolean
    @@InCase:
      @@@Value:true
      @@@IsSupportRequired:1
      @@@IsDefault:1
      @@@Description:
        @@@@lang:en
        @@@@@:
          Keep all whitespaces in the document.
    @@InCase:
      @@@Value:false
      @@@Description:
        @@@@lang:en
        @@@@@:
          Discard all <IF:Text> nodes that contain whitespaces 
          in element content.
      @@@ImplNote:
        @@@@lang:en
        @@@@@:
          DOM implementations are expected to use the attribute 
          <A:Text.isElementContentWhitespace> to determine 
          whether a <IF:Text> node should be discarded.
      @@@SetParam:
        @@@@Name:canonical-form
        @@@@Type:boolean
        @@@@Value:false
  @Param:
    @@Name: entities
    @@Type:boolean
    @@IsSupportRequired:1
    @@InCase:
      @@@Value:true
      @@@IsSupportRequired:1
      @@@IsDefault:1
      @@@Description:
        @@@@lang:en
        @@@@@:
          Keep <IF:EntityReferences> nodes in the document.
      @@@SetParam:
        @@@@Name:canonical-form
        @@@@Type:boolean
        @@@@Value:false
    @@InCase:
      @@@Value:false
      @@@IsSupportRequired:1
      @@@Description:
        @@@@lang:en
        @@@@@:
          Remove all <IF:EntityReference> nodes from the document, 
          putting the entity expansions directly in their place. 
          <IF:Text> nodes are normalized as defined in 
          <M:Node.normalize>.  Only unexpanded entity references 
          are kept in the document.
      @@@ImplNote:
        @@@@lang:en
        @@@@@:
          This parameter does not affect <IF:Entity> nodes.
  @Param:
    @@Name: error-handler
    @@Type: 
      DOMCore:DOMErrorHandler
    @@IsSupportRequired:1
    @@Description:
      @@@lang:en
      @@@@:
        If an error is encountered in the document, the DOM 
        implementation will callback the <IF:DOMErrorHandler>. 
      \
        When called, <A:DOMError.relatedData> will contain 
        the closest node to where the error occurred. 
        If the implementation is unable to determine the node 
        where the error occurs, <A:DOMError.relatedData> will 
        contain the <IF:Document> node. 
      \
        Mutations to the document from within an error handler 
        will result in implementation dependent behavior.
    @@ImplNote:
      @@@lang:en
      @@@@:
        DOM implementations may provide a default <IF:DOMErrorHandler> 
        object.  
    @@ImplNote:
      @@@lang:en
      @@@@:
        {P:: This parameter is used in:
        \
        {LI:: <M:Document.normalizeDocument>:: If errors occurs, such as an 
          attempt to update a read-only node or a <A:Node.nodeName> 
          contains an invalid character.  This method might report 
          fatal errors.
        \
        }
        \
        }
  @Param:
    @@Name: infoset
    @@IsSupportRequired:1
    @@Type:boolean
    @@InCase:
      @@@Value:true
      @@@IsSupportRequired:1
      @@@Description:
        @@@@lang:en
        @@@@@:
          Keep in the document information defined in the 
          XML Infoset Specification.
      @@@SetParam:
        @@@@Name: validate-if-schema
        @@@@Type: boolean
        @@@@Value:false
      @@@SetParam:
        @@@@Name: entities
        @@@@Type:boolean
        @@@@Value:false
      @@@SetParam:
        @@@@Name:datatype-normalization
        @@@@Type:boolean
        @@@@Value:false
      @@@SetParam:
        @@@@Name:cdata-sections
        @@@@Type:boolean
        @@@@Value:false
      @@@SetParam:
        @@@@Name:namespace-declarations
        @@@@Type:boolean
        @@@@Value:true
      @@@SetParam:
        @@@@Name:well-formed
        @@@@Type:boolean
        @@@@Value:true
      @@@SetParam:
        @@@@Name:element-content-whitespace
        @@@@Type:boolean
        @@@@Value:true
      @@@SetParam:
        @@@@Name:comments
        @@@@Type:boolean
        @@@@Value:true
      @@@SetParam:
        @@@@Name:namespaces
        @@@@Type:boolean
        @@@@Value:true
      @@@ImplNote:
        @@@@lang:en
        @@@@@:
          <M:DOMConfiguration.getParameter> with this parameter 
          returns <DOM:true> iif <CODE:!<DOM:validate-if-schema> && 
          !<DOM:entities> && !<DOM:datatype-normalization> && 
          !<DOM:cdata-sections> && <DOM:namespace-declarations> && 
          <DOM:well-formed> && <DOM:element-content-whitespace> && 
          <DOM:comment> && <DOM:namespaces>>.
    @@InCase:
      @@@Value:false
      @@@Description:
        @@@@lang:en
        @@@@@:
          Setting <DOM:infoset> to <DOM:false> has no effect.
    @@Get:
      @@@Def:
        @@@@Type:
          lang:Perl
        @@@@@:
          $r = !$cfg->{<Q:DOMCoreParam:validate-if-schema>} &&
               !$cfg->{<Q:DOMCoreParam:entities>} &&
               !$cfg->{<Q:DOMCoreParam:datatype-normalization>} &&
               !$cfg->{<Q:DOMCoreParam:cdata-sections>} && 
               $cfg->{<Q:DOMCoreParam:namespace-declarations>} &&
               $cfg->{<Q:DOMCoreParam:well-formed>} &&
               $cfg->{<Q:DOMCoreParam:element-content-whitespace>} &&
               $cfg->{<Q:DOMCoreParam:comment>} && 
               $cfg->{<Q:DOMCoreParam:namespaces>}
             ? true : false;
  @Param:
    @@Name: namespaces
    @@Type:boolean
    @@IsSupportRequired:1
    @@InCase:
      @@@Value:true
      @@@IsSupportRequired:1
      @@@IsDefault:1
      @@@Description:
        @@@@lang:en
        @@@@@:
          Perform the namespace normalization processing.
    @@InCase:
      @@@Value:false
      @@@Description:
        @@@@lang:en
        @@@@@:
          Do not perform the namespace processing.
      @@@SetParam:
        @@@@Name:canonical-form
        @@@@Type:boolean
        @@@@Value:false
  @Param:
    @@Name: namespace-declarations
    @@IsSupportRequired:1
    @@Type:boolean
    @@InCase:
      @@@Value:true
      @@@IsSupportRequired:1
      @@@IsDefault:1
      @@@Description:
        @@@@lang:en
        @@@@@:
          Include namespace declaration attributes, specified or 
          defaulted from the schema, in the document.
    @@InCase:
      @@@Value:false
      @@@IsSupportRequired:1
      @@@Description:
        @@@@lang:en
        @@@@@:
          Discade all namespace declaration attributes.  The namespace 
          prefixes are retained.
      @@@SetParam:
        @@@@Name:canonical-form
        @@@@Type:boolean
        @@@@Value:false
  @Param:
    @@Name: normalize-characters
    @@Type:boolean
    @@IsSupportRequired:1
    @@InCase:
      @@@Value:true
      @@@Target:
        @@@@TargetMethod:
          Document::.normalizeDocument
        @@@@IsDefault:0
      @@@Target:
        @@@@TargetModule:
          DOMLS:LSSerializer::
        @@@@IsDefault:1
        @@@@ImplNote:
          @@@@@lang:en
          @@@@@@:
            The default is <DOM:true> but fully-normalization is 
            not required to be supported <SRC:DOM Level 3 LS>.
      @@@Description:
        @@@@lang:en
        @@@@@: 
          Fully normalize the characters in the document as defined in 
          the Appendix B of the XML 1.1 Specification.
      @@@SetParam:
        @@@@Name:canonical-form
        @@@@Type:boolean
        @@@@Value:false
    @@InCase:
      @@@Value:false
      @@@IsSupportRequired:1
      @@@Target:
        @@@@TargetMethod:
          Document::.normalizeDocument
        @@@@IsDefault:1
      @@@Target:
        @@@@TargetModule:
          DOMLS:LSSerializer::
        @@@@IsDefault:0
      @@@Description:
        @@@@lang:en
        @@@@@: Do not perform character normalization.
  @Param:
    @@Name:schema-location
    @@IsSupportRequired:1
    @@Type:
      DOMMain:DOMString
    @@InCase:
      @@@Label:
        @@@@lang:en
        @@@@@: A list of DOM URIs, separated by whitespaces
      @@@IsSupportRequired:0
      @@@Description:
        @@@@lang:en
        @@@@@:
          The schemas against which validation should occur, i.e. 
          the current schema.
      \
        The types of schemas must match the <DOM:schema-type>, 
        otherwise the behaviour is undefined.
      \
        The schemas specified here take precedence to the schema 
        specified in the document itself.  For namespace aware schema, 
        if a schema specified using this parameter and a schema 
        specified in the document instance in a schema document 
        share the same <CODE:targetNamespace>, the schema specified 
        by the DOM application will be used.  If two schemas 
        specified by the application share the same 
        <CODE:targetNamespace> or have no namespace, the behavior 
        is implementation dependent.
      \
        This parameter is ignored unless the <DOM:schema-type> 
        value is set.
      @@@ImplNote:
        @@@@lang:en
        @@@@@:
        Whitespace = <XML:S> in the XML 1.0 Specification.
      \
        It is strongly recommended that the <A:Document.documentURI>, 
        will be set so that an implementation can successfully resolve 
        any external entities referred. 
    @@InCase:
      @@@Value:
        @@@@@is-null:1
      @@@Description:
        @@@@lang:en
        @@@@@: No location has been provided.
  @Param:
    @@Name:schema-type
    @@IsSupportRequired:1
    @@Type:
      ManakaiDOM:ManakaiDOMURI
    @@InCase:
      @@@Label:
        @@@@lang:en
        @@@@@:
          An absolute DOM URI
      @@@IsSupportRequired:0
      @@@Description:
        @@@@lang:en
        @@@@@:
          The type of the schema language used to validate a document against.
        \
          No lexical cheking is done on the absolute URI.
        \
          A default value may be provided by the DOM implementation, 
          based on the schema languages supported and on the 
          schema language used at load time.
    @@InCase:
      @@@Value:
        http://www.w3.org/TR/REC-xml
      @@@Description:
        @@@@lang:en
        @@@@@: The XML DTD.
    @@InCase:
      @@@Value:
        http://www.w3.org/2001/XMLSchema
      @@@Description:
        @@@@lang:en
        @@@@@: The XML Schema.
    @@InCase:
      @@@Value:
        @@@@is-null:1
      @@@Description:
        @@@@lang:en
        @@@@@: No valus is provided.
    @@ImplNote:
      @@@lang:en
      @@@@:
        Other schema languages are outside the scope of the W3C 
        and should recommentd an absolute URI in order to use here.
  @Param:
    @@Name: split-cdata-sections
    @@Type:boolean
    @@IsSupportRequired:1
    @@InCase:
      @@@Value:true
      @@@IsSupportRequired:1
      @@@IsDefault:1
      @@@Description:
        @@@@lang:en
        @@@@@:
          Split CDATA sections containing the <SGML:MSE> 
          (<XML:]]<gt>>).
        \
          When CDATA section is split, a warning is issued with 
          a <A:DOMError.type> equals to <DOM:cdata-sections-splitted> 
          and <A:DOMError.relatedData> equals to the first 
          <IF:CDATASection> node in document order.
    @@InCase:
      @@@Value:false
      @@@IsSupportRequired:1
      @@@Description:
        @@@@lang:en
        @@@@@:
          Signal an error if <IF:CDATASection> contains an 
          unrepresentable character.
  @Param:
    @@Name:validate
    @@IsSupportRequired:1
    @@Type:boolean
    @@InCase:
      @@@Value:true
      @@@Description:
        @@@@lang:en
        @@@@@:
          Require the validation against a schema of the document 
          as it is being normalized as defined by the XML 1.0 Specification. 
        \
          If validation errors are found or no schema was found, 
          the error handler is notified.
        \
          Schema-normalized values will not exposed unless the 
          parameter <DOM:datatype-normalization> is <DOM:true>.
        \
          Following attributes are revaluated:
        \
          - Attribute nodes with <A:Attr.specified> equals to <DOM:false>.
        \
          - The value of the attribute <A:Text.isElementContentWhitespace> 
          for all <IF:Text> nodes.
        \
          - The value of the attribute <A:Attr.isId> for all <IF:Attr> nodes.
        \
          - The attributes <A:Element.schemaTypeInfo> and 
          <A:Attr.schemaTypeInfo>.
        \
          DOM applications should consider setting the parameter 
          <DOM:well-formed> to <DOM:true>.
      @@@SetParam:
        @@@@Name: validate-if-schema
        @@@@Type:boolean
        @@@@Value: false
    @@InCase:
      @@@Value:false
      @@@IsSupportRequired:1
      @@@IsDefault:1
      @@@Description:
        @@@@lang:en
        @@@@@:
          Do not accomplish schema processing, including internal subset 
          processing.  Default attribute information are kept.
        \
          Note that validation might still happen in case 
          <DOM:validate-if-schema> is <DOM:true>.
  @Param:
    @@Name:validate-if-schema
    @@Type:boolean
    @@IsSupportRequired:1
    @@InCase:
      @@@Value:true
      @@@Description:
        @@@@lang:en
        @@@@@:
          Enable validation only if a declaration for the document 
          element can be found in a schema.  If validation is enabled, 
          this parameter has the same behavior as the parameter 
          <DOM:validate> set to <DOM:true>.
      @@@SetParam:
        @@@@Name:validate
        @@@@Type:boolean
        @@@@Value:false
    @@InCase:
      @@@Value:false
      @@@IsSupportRequired:1
      @@@IsDefault:1
      @@@Description:
        @@@@lang:en
        @@@@@:
          No schema processing should be performed if the document has 
          a schema, including internal subset 
          processing.  Default attribute information are kept.
        \
          Note that validation might still happen in case 
          <DOM:validate> is <DOM:true>.
  @Param:
    @@Name:well-formed
    @@Type:boolean
    @@IsSupportRequired:1
    @@InCase:
      @@@Value:true
      @@@IsSupportRequired:1
      @@@IsDefault:1
      @@@Description:
        @@@@lang:en
        @@@@@:
          Check if all nodes are well-formed according to the XML 
          version in use (<A:Document.xmlVersion>), i.e.:
        \
          - Check if the attribute <A:Node.nodeName> contains 
          invalid characters according to its node type and generate 
          a <IF:DOMError> of type <DOM:wf-invalid-character-in-node-name>, 
          with a <DOM:SEVERITY_ERROR> severity, if necessary.
        \
          - Check if the text content inside <IF:Attr>, <IF:Element>, 
          <IF:Comment>, <IF:Text> and <IF:CDATASection> nodes for 
          invalid characters and generate a <IF:DOMError> of type 
          <DOM:wf-invalid-character>, with a 
          <DOM:SEVERITY_ERROR> severity, if necessary.
        \
          - Check if the data inside <IF:ProcessingInstruction> nodes 
          for invalid characters and generate a <IF:DOMError> 
          of type <DOM:wf-invalid-character>, with a
          <DOM:SEVERITY_ERROR> severity, if necessary.
    @@InCase:
      @@@Value:false
      @@@Description:
        @@@@lang:en
        @@@@@: Do not check for XML well-formedness.
      @@@SetParam:
        @@@@Name:canonical-form
        @@@@Type:boolean
        @@@@Value:false
##ConfigParam:Document

ErrorSet:
  @Description:
    @@lang:en
    @@@:
      Errors that might be reported during the invocation of the 
      <M:Document.normalizeDocument> method. 

  @SpecLevel:3

  @Error:
    @@Name:check-character-normalization-failure
    @@Description:
      @@@lang:en
      @@@@:
        The parameter <CP:check-character-normalization> is set to
        <DOM:true> and a string is encountered that fails normalization 
        checking.
    @@Severity:Error
    @@RelatedData:
      @@@ImplNote:
        @@@@lang:en
        @@@@@:
          Not specified; it should be the node in which the sequence is. 
    @@ImplNote:
      @@@lang:en
      @@@@:
        Used by DOM 3 Core and DOM 3 LS <IF:LSParser>; 
        see also <Module:DOMLS>.

  @Error:
    @@Name:cdata-sections-splitted
    @@Description:
      @@@lang:en
      @@@@:
        <CP:split-cdata-sections> is <DOM:true> and 
        a <XML:CDATA> section is split.
    @@Severity:Warning
    @@RelatedData:
      @@@Type:
        DOMXML:CDATASection
      @@@Description:
        @@@@lang:en
        @@@@@:
          The first <IF:CDATASection> node in document order 
          resulting from the split.

  @Error:
    @@Name:wf-invalid-character-in-node-name
    @@SubType:
      @@@QName:
        ManakaiDOMCore:normalize-invalid-character
      @@@Description:
        @@@@lang:en
        @@@@@:
          The parameter <CP:well-formed> is set to <DOM:true> and 
          the attribute <A:Node.nodeName> contains an invalid character 
          according to its node type.
      @@@Severity:Error
    @@SubType:
      @@@QName:
        ManakaiDOMLS:serialize-invalid-character
      @@@Description:
        @@@@lang:en
        @@@@@:
          A character that cannot be represented in the output 
          character encoding is encountered within markup but 
          outside of attribute values.
      @@@Severity:FatalError

  @Error:
    @@Name:wf-invalid-character
    @@Description:
      @@@lang:en
      @@@@:
        <CP:well-formed> is <DOM:true> and the text inside an 
        <IF:Attr>, <IF:Element>, <IF:Comment>, <IF:Text> or 
        <IF:CDATASection> node or the data inside 
        <IF:ProcessingInstruction> node contains an invalid character.
    @@Severity:Error
## Error:normalizeDocument

## DOMCore.dis ends here
