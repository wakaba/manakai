Namespace:
  @DocTree:
    http://suika.fam.cx/~wakaba/archive/2004/9/10/dom#
  @DOMCore:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#
  @infoset:
     http://www.w3.org/2001/04/infoset#
  @lang:
     http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#
  @license:
     http://suika.fam.cx/~wakaba/archive/2004/8/18/license#
  @DOM3Core:
     http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/
  @ManakaiDOMXML:
    http://suika.fam.cx/~wakaba/archive/2004/mdom-core#
  @MDOM_EXCEPTION:
     http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#
  @TreeCore: \
  @xml:
    http://www.w3.org/XML/1998/namespace
  @xmlns:
    http://www.w3.org/2000/xmlns/
Module:
  @Name:  dom
    @@Prefix:  w3c.org
  @FullName:
    @@lang:en
    @@@: DOM Core Module
  @Spec:
    @@DOM3:
      http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-BBACDC08
  @Namespace:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#
  @Package:
    @@Type:
      lang:Perl
    @@@: __CLASS{DOMCore}__
  
  @Description:
    @@lang:en
    @@@:
      The DOM Core Module.  The interfaces defined in this module is 
      the fundemental DOM interfaces that must be fully implemented by 
      all conforming DOM implementations.
  
  @License:
     license:Perl
  @Date.RCS:
     $Date: 2004/09/20 05:53:13 $

  @ConditionDef:
    @@Name: DOM1
  @ConditionDef:
    @@Name: DOM2
  @ConditionDef:
    @@Name: DOM3
  
  @Require:
    @@Module:
      @@@Name: ManakaiDOMCore
      @@@Namespace:
        http://suika.fam.cx/~wakaba/archive/2004/mdom-core#

  @Feature:
    @@Name: Core
    @@Version: 2.0
    @@Condition[list]:
      DOM2
      DOM3
    @@Spec:
      @@@DOM3:
        http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-BBACDC08
    @@Description:
      @@@lang:en
      @@@@: The DOM Core Module, Level 2.
  @Feature:
    @@Name: Core
    @@Version: 3.0
    @@Condition[list]:
      DOM3
    @@Spec:
      @@@DOM3:
        http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-BBACDC08
    @@Description:
      @@@lang:en
      @@@@: The DOM Core Module, Level 3.

Exception:
  @Name:  DOMException
  @Spec:
    @@DOM3:
      http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-17189187
  @Description:
    @@lang:en
    @@@:
      Exceptions common to the DOM modules.
  @Attr:
     @@Name:  code
     @@Get:
       @@@Type:  unsigned-short
       @@@Description:
         @@@@lang:en
         @@@@@: The error code from the constant value group ExceptionCode.
  @ConstGroup:
     @@Name:  ExceptionCode
     @@Spec:
       @@@DOM3:
         http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-258A00AF
     @@Description:
       @@@lang:en
       @@@@: Integers indicating the type of error generated.
     @@Const:
        @@@Name:  INDEX_SIZE_ERR
        @@@Type:  unsigned-short
        @@@Value:  1
        @@@Param:
          @@@@QName:
            MDOM_EXCEPTION:param-name
          @@@@Description:
            @@@@@lang:en
            @@@@@@: Parameter to which inappropriate value specified.
        @@@Description:
          @@@@lang:en
          @@@@@: Index or size is negative, or greater than the allowed value.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@Description:
            @@@@@lang:en
            @@@@@@: 
              Index or size specified as parameter%t (
                name => {<Q:MDOM_EXCEPTION:param-name>},
                prefix => { "}, suffix => {"}); is negative, or 
              greater than the allowed value.
     @@Const:
        @@@Name:  DOMSTRING_SIZE_ERR
        @@@Type:  unsigned-short
        @@@Value:  2
        @@@Description:
          @@@@lang:en
          @@@@@: The specified range of text does not fit into a DOMString.
     @@Const:
        @@@Name:  HIERARCHY_REQUEST_ERR
        @@@Type:  unsigned-short
        @@@Value:  3
        @@@Description:
          @@@@lang:en
          @@@@@:
            An attempt is made to insert a node somewhere it does not belong.
     @@Const:
        @@@Name:  WRONG_DOCUMENT_ERR
        @@@Type:  unsigned-short
        @@@Value:  4
        @@@Description:
          @@@@lang:en
          @@@@@:
            A node is used in a different document than the one
            that created it.
     @@Const:
        @@@Name:  INVALID_CHARACTER_ERR
        @@@Type:  unsigned-short
        @@@Value:  5
        @@@Description:
          @@@@lang:en
          @@@@@: An invalid or illegal character is specified.
     @@Const:
        @@@Name:  NO_DATA_ALLOWED_ERR
        @@@Type:  unsigned-short
        @@@Value:  6
        @@@Description:
          @@@@lang:en
          @@@@@: Data is specified for a node that does not support data.
     @@Const:
        @@@Name:  NO_MODIFICATION_ALLOWED_ERR
        @@@Type:  unsigned-short
        @@@Value:  7
        @@@Description:
          @@@@lang:en
          @@@@@:
            An attempt is made to modify an object where 
            modifications are not allowed. 
     @@Const:
        @@@Name:  NOT_FOUND_ERR
        @@@Type:  unsigned-short
        @@@Value:  8
        @@@Description:
          @@@@lang:en
          @@@@@:
            An attempt is made to refer a node in a context where 
            it does not exist.
     @@Const:
        @@@Name:  NOT_SUPPORTED_ERR
        @@@Type:  unsigned-short
        @@@Value:  9
        @@@Param:
          @@@@QName:
            MDOM_EXCEPTION:if
          @@@@Type: DOMString
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The interface name.
        @@@Param:
          @@@@QName:
            MDOM_EXCEPTION:method
          @@@@Type: DOMString
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The method name.
        @@@Param:
          @@@@QName:
            MDOM_EXCEPTION:attr
          @@@@Type: DOMString
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The attribute name.
        @@@Param:
          @@@@QName:
            MDOM_EXCEPTION:on
          @@@@Type: DOMString
          @@@@Description:
            @@@@@lang:en
            @@@@@@: Type of the attribute procedure.
          @@@@InCase:
            @@@@@Value: get
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@: On getting.
          @@@@InCase:
            @@@@@Value: set
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@: On setting.
        @@@Description:
          @@@@lang:en
          @@@@@:
            The implementation does not support the type of object requested.
     @@Const:
        @@@Name:  INUSE_ATTRIBUTE_ERR
        @@@Type:  unsigned-short
        @@@Value:  10
        @@@Description:
          @@@@lang:en
          @@@@@: 
            An attempt is made to add an attribute that is already inuse 
            elsewhere.
     @@Const:
        @@@Name:  INVALID_STATE_ERR
        @@@Type:  unsigned-short
        @@@Value:  11
        @@@Level[list]:  2
        @@@SpecLevel: 2
        @@@Description:
          @@@@lang:en
          @@@@@:
            An attempt is made to use an object that is not (or no longer) 
            usable.
     @@Const:
        @@@Name:  SYNTAX_ERR
        @@@Type:  unsigned-short
        @@@Value:  12
        @@@Level[list]:  2
        @@@SpecLevel: 2
        @@@Description:
          @@@@lang:en
          @@@@@: An invalid or illegal string is specified.
     @@Const:
        @@@Name:  INVALID_MODIFICATION_ERR
        @@@Type:  unsigned-short
        @@@Value:  13
        @@@Level[list]:  2
        @@@SpecLevel: 2
        @@@Description:
          @@@@lang:en
          @@@@@: An attempt is made to modify the type of underlying object.
     @@Const:
        @@@Name:  NAMESPACE_ERR
        @@@Type:  unsigned-short
        @@@Value:  14
        @@@SpecLevel: 2
        @@@Level[list]:  2
        @@@Description:
          @@@@lang:en
          @@@@@:
            An attempt is made to create or change an object in 
            a way that is incorrect with regard to namespaces.
     @@Const:
        @@@Name:  INVALID_ACCESS_ERR
        @@@Type:  unsigned-short
        @@@Value:  15
        @@@Level[list]:  2
        @@@SpecLevel: 2
        @@@Description:
          @@@@lang:en
          @@@@@:
            A parameter or an operation is not supported by the 
            underlying object.
     @@Const:
        @@@Name:  VALIDATION_ERR
        @@@Type:  unsigned-short
        @@@Value:  16
        @@@Level[list]:  3
        @@@SpecLevel:3
        @@@Description:
          @@@@lang:en
          @@@@@:
            An attempt is made to modify an object where the modification 
            would make the Node invalid with respect to partial validity.

     @@Const:
        @@@Name:  TYPE_MISMATCH_ERR
        @@@Type:  unsigned-short
        @@@Value:  17
        @@@Level[list]:  3
        @@@SpecLevel:3
        @@@Description:
          @@@@lang:en
          @@@@@:
            The type of an object is incompatible with the expected 
            type of the parameter associated to the object.

IF:
  @Name:  DOMStringList
  @Level[list]:  3
  @SpecLevel:3
  @Spec:
    @@DOM3:
      http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#DOMStringList
  @Description:
    @@lang:en
    @@@:
      An ordered collection of "DOMString" values.
  @ImplNote:
    @@lang:en
    @@@:
      How the collection is implemented is not defined by the 
      specification.
  @Method:
     @@Name:  item
     @@Spec:
       @@@DOM3:
         http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#DOMStringList-item
     @@Description:
       @@@lang:en
       @@@@: Return a "DOMString" in the collection.
     @@Param:
        @@@Name:  index
        @@@Type:  unsigned-long
        @@@Description:
          @@@@lang:en
          @@@@@: Index into the collection.
        @@@InCase:
          @@@@Value: 0
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The first item.
        @@@InCase: 
          @@@@Label: "length" - 1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The last item.
     @@Return:
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            The "DOMString" at the "index"th position in the collection.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The specified "index" is negative or greater than or equal to 
              the number of "DOMString"s in the list.
        @@@Def:
          if (not defined $index or
              $index < 0 or
              $index > $#$self) {
            $r = null;
          } else {
            __INT__;
          }
        @@@IntDef:
          $r = $self->[$index];
  @Attr:
     @@Name:  length
     @@Spec:
       @@@DOM3:
         http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#DOMStringList-length
     @@Description:
       @@@lang:en
       @@@@: 
         The number of "DOMString"s in the list.
     @@Get:
        @@@Type:  unsigned-long
        @@@Description:
          @@@@lang:en
          @@@@@: The number of "DOMString"s in the list.
        @@@Def:
          $r = @$self;
  @Method:
     @@Name:  contains
     @@Spec:
       @@@DOM3: 
         http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#DOMStringList-contains
     @@Description:
       @@@lang:en
       @@@@: Test if a string is part of the list.
     @@Param:
        @@@Name:  str
        @@@Type:  DOMString
        @@@Description:
          @@@@labg:en
          @@@@@: The string to look for.
     @@Return:
        @@@Type:  boolean
        @@@Description:
          @@@@lang:en
          @@@@@: Whether the string is part of the list.
        @@@InCase:
          @@@@Value: true
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The string has been found.
        @@@InCase:
          @@@@Value: false
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The string has not been found.
        @@@Def:
          CHK: {
            __DEEP{
              for (@$self) {
                if ($str eq $_) {
                  $r = true;
                  last CHK;
                }
              }
            }__;
          }

IF:
  @Name:  NameList
  @Level[list]:  3
  @SpecLevel:3
  @Spec:
    @@DOM3:
      http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#NameList
  @Description:
    @@lang:en
    @@@:
      An ordered collection of parallel pairs of name and namespace values.
  @ImplNote:
    @@lang:en
    @@@: How this collection is implemented is not defined by the specification.
  @Method:
     @@Name:  getName
     @@Spec:
       @@@DOM3:
         http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#NameList-getName
     @@Description:
        @@@lang:en
        @@@@: Return the "index"th name item in the collection.
     @@Param:
        @@@Name:  index
        @@@Type:  unsigned-long
        @@@Description:
          @@@@lang:en
          @@@@@: The index into the collection.
        @@@InCase:
          @@@@Value: 0
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The first item.
        @@@InCase:
          @@@@Label: "length" - 1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The last item.
     @@Return:
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The name at the "index"th position in the "NameList".
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
            There is no name for the specified "index" or
            the "index" is out of range.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
          if (not defined $index or
              $index < 0 or
              $index > $#$self) {
            $r = null;
          } else {
            __INT__;
          }
        @@@IntDef:
          @@@@Type:
            lang:Perl
          @@@@@:
          $r = $self->[$index]->{name};
  @Method:
     @@Name:  getNamespaceURI
     @@Spec:
       @@@DOM3:
         http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#NameList-getNamespaceURI
     @@Description:
       @@@lang:en
       @@@@: Return the "index"th namespace URI item in the collection.
     @@Param:
        @@@Name:  index
        @@@Type:  unsigned-long
        @@@Description:
          @@@@lang:en
          @@@@@: The index into the collection.
        @@@InCase:
          @@@@Value: 0
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The first item.
        @@@InCase:
          @@@@Label: "length" - 1
          @@@@Description: 
            @@@@@lang:en
            @@@@@@: The last item.
     @@Return:
        @@@Type:
          ManakaiDOM:ManakaiDOMNamespaceURI
        @@@Description:
          @@@@lang:en
          @@@@@: The namespace URI at the "index" position in the "NameList".
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
            There is no namespace URI for the specified "index" or 
            if the "index" is out of range.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
          if (not defined $index or
              $index < 0 or
              $index > $#$self) {
            $r = null;
          } else {
            __INT__;
          }
        @@@IntDef:
          @@@@Type:
            lang:Perl
          @@@@@:
          $r = $self->[$index]->{nsURI};
  @Attr:
     @@Name:  length
     @@Spec:
       @@@DOM3:
         http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#NameList-length
     @@Description:
       @@@lang:en
       @@@@: 
         The number of name and namespace URI pairs in the list.
     @@Get:
        @@@Type:  unsigned-long
        @@@Description:
          @@@@lang:en
          @@@@@: The number of pairs.
        @@@Def:
          $r = @$self;
  @Method:
     @@Name:  contains
     @@Spec:
       @@@DOM3:
         http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#NameList-contains
     @@Description:
       @@@lang:en
       @@@@: Test if a name is part of the collection.
     @@Param:
        @@@Name:  str
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The name to look for.
     @@Return:
        @@@Type:  boolean
        @@@InCase:
          @@@@Value: true
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The name has been found.
        @@@InCase:
          @@@@Value: false
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The name has not been found.
        @@@Def:
          $r = false;
          CHK: {
            __DEEP{
              for (@$self) {
                if ($str eq $_->{name}) {
                  $r = true;
                  last CHK;
                }
              }
            }__;
          }
  @Method:
     @@Name:  containsNS
     @@Spec:
       @@@DOM3:
         http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#NameList-containsNS
     @@Description:
       @@@lang:en
       @@@@: 
         Test if the pair of namespace URI and name is part of the collection.
     @@Param:
        @@@Name:  namespaceURI
        @@@Type:
          ManakaiDOM:ManakaiDOMNamespaceURI
        @@@Description:
          @@@@lang:en
          @@@@@: The namespace URI to look for.
     @@Param:
        @@@Name:  name
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The name to look for.
     @@Return:
        @@@Type:  boolean
        @@@InCase:
          @@@@Value: true
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The pair has been found.
        @@@InCase:
          @@@@Value: false
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The pair has not been found.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
          $r = false;
          CHK: {
            __DEEP{
              for (@$self) {
                if ($namespaceURI eq $_->{nsURI} and
                    $name eq $_->{name}) {
                  $r = true;
                  last CHK;
                }
              }
            }__;
          }

IF:
  @Name:  DOMImplementationList
  @Level[list]:  3
  @SpecLevel:3
  @Spec:
    @@DOM3:
      http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#DOMImplementationList
  @Description:
    @@lang:en
    @@@: 
      An ordered collection of DOM implementations.
  @ImplNote:
    @@lang:en
    @@@:
      How this collection is implemented is not specified by the specification.
  @Method:
     @@Name:  item
     @@Spec:
       @@@DOM3:
         http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#DOMImplementationList-item
     @@Description:
       @@@lang:en
       @@@@: Return the "index"th item in the collection.
     @@Param:
        @@@Name:  index
        @@@Type:  unsigned-long
        @@@Description:
          @@@@lang:en
          @@@@@: The index into the collection.
        @@@InCase:
          @@@@Value: 0
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The first item.
        @@@InCase:
          @@@@Label: "length" - 1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The last item.
     @@Return:
        @@@Type:  DOMImplementation
        @@@Description:
          @@@@lang:en
          @@@@@: 
            The "DOMImplementation" at the "index"th position in 
            the collection.
        @@@InCase:
          @@@@Value: null
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              There is no "DOMImplementation" for the specified "index", 
              or the "index" is out of range.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
          if (not defined $index or
              $index < 0 or
              $index > $#$self) {
            $r = null;
          } else {
            __INT__;
          }
        @@@IntDef:
          @@@@Type:
            lang:Perl
          @@@@@:
          $r = $self->[$index];
  @Attr:
     @@Name:  length
     @@Description:
       @@@lang:en
       @@@@: The number of "DOMImplementation"s in the list.
     @@Spec:
       @@@DOM3:
         http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#DOMImplementationList-length
     @@Get:
        @@@Type:  unsigned-long
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            $r = @$self;
  @IntMethod:
    @@Name: new
    @@Description:
      @@@lang:en
      @@@@: Construct a new instance of the "DOMImplementationList".
    @@Return:
      @@@Type: DOMImplementationList
      @@@Description:
        @@@@lang:en
        @@@@@: The new instance constructed.
      @@@Def:
        @@@@Type:
          lang:Perl
        @@@@@:
          $r = bless [], ref $self ? ref $self : $self;
  @IntMethod:
    @@Name: add
    @@Description:
      @@@lang: en
      @@@@: Add one or more "DOMImplementation"s to the list.
    @@Param:
      @@@Name: list
      @@@Type: DOMImplementationList
      @@@Description:
        @@@@lang:en
        @@@@@:
          A list of "DOMImplementation"s to be added.
      @@@InCase:
        @@@@Label:
          One or more "DOMImplementation"s and/or "DOMImplementationList"s
        @@@@Description:
           @@@@@lang:en
           @@@@@@:
             "DOMImplementation"s and/or lists of them to be added.
    @@Return:
      @@@Exception:
        @@@@Type:
          ManakaiDOM:ManakaiDOMImplementationException
        @@@@Name: MDOM_TYPE_MISMATCH_ERR
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The parameter specified is neither a DOMImplementation object 
            or a DOMImplementationList object.
      @@@Def:
        @@@@Type:
          lang:Perl
        @@@@auto-argument: 0
        @@@@@:
          my $self = shift;
          for (@_) {
            if ($_->isa ("__IIF{DOMImplementationList::}__")) {
              push @$self, @$_;
            } elsif ($_->isa ("__IIF{DOMImplementation::}__")) {
              push @$self, $_;
            } elsif ($_->isa ("__IF{DOMImplementationList}__")) {
              __DEEP{
                my $len = $_->length; 
                for (my $i = 0; $i < $len; $i++) {
                  push @$self, $_->item ($i);
                }
              }__;
            } elsif ($_->isa ("__IF{DOMImplementation}__")) {
              push @$self, $_;
            } else {
              __EXCEPTION{ManakaiDOMImplementationException.
                          MDOM_TYPE_MISMATCH_ERR:
                <Q:MDOM_EXCEPTION:param-name> => 'list',
                <Q:MDOM_EXCEPTION:class> => ref $_,
              }__;
            }
          }

IF:
  @Name:  DOMImplementationSource
  @Level[list]:  3
  @SpecLevel:3
  @Description:
    @@lang:en
    @@@:
      This interface provides access to DOM implementations available.
  @Spec:
    @@DOM3:
      http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#DOMImplementationSource
  @Method:
     @@Name:  getDOMImplementation
     @@Spec:
       @@@DOM3:
         http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-getDOMImpl
     @@Description:
        @@@lang:en
        @@@@: 
          Return the first DOM implementation that supports the specified 
          features and versions.
     @@Param:
        @@@Name:  features
        @@@Type:
          ManakaiDOM:ManakaiDOMFeatures
        @@@Description:
          @@@@lang:en
          @@@@@:
            A string that specifies which features and versions are 
            required.
     @@Return:
        @@@Type:  DOMImplementation
        @@@Description:
          @@@@lang:en
          @@@@@: 
            The first DOM implementation that support the desired 
            features and versions.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: 
              This source has no DOM implementation that supports the 
              desired features and versions.
## TODO: Implement this.
  @Method:
     @@Name:  getDOMImplementationList
     @@Description:
       @@@lang:en
       @@@@:
         Return a list of DOM implementations that support the specified 
         features and versions.
     @@Return:
        @@@Type:  DOMImplementationList
        @@@Description:
          @@@@lang:en
          @@@@@:
            A list of DOM implementations that support the desired 
            features and versions.
## TODO: implement this
     @@Param:
        @@@Name:  features
        @@@Type:
          ManakaiDOM:ManakaiDOMFeatures
        @@@Description:
          @@@@lang:en
          @@@@@:
            A string that specifies which features and versions are required.

IF:
  @Name:  DOMImplementation
  @Spec:
    @@DOM3:
      http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-102161490
  @Description:
    @@lang:en
    @@@:
      This interface provides a number of methods for performing 
      operations that are independent of any particular instance 
      of the document object model.
  @Require:
    @@Module:
      @@@Def:
        @@@@Type:
          lang:Perl
        @@@@use:
          @@@@@@:
            Char::Class::XML
          @@@@@Import[list]:
            InXMLNameChar10
            InXML_NameStartChar10
            InXMLNCNameChar10
            InXML_NCNameStartChar10
    @@Condition[list]:
      DOM2
      DOM3
  @ISA:
    ManakaiDOM:ManakaiDOMNodeReference::
  @Method:
     @@Name:  hasFeature
     @@Spec:
       @@DOM3[list]:
         http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-5CED94D7
         http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#DOMFeatures
     @@Description:
       @@@lang:en
       @@@@:
         Test if the DOM implementation implements a specific feature 
         and version.
     @@Param:
        @@@Name:  feature
        @@@Type:
          ManakaiDOM:ManakaiDOMFeatureName
        @@@Description:
          @@@@lang:en
          @@@@@: The name of the feature to test.
        @@@InCase:
          @@@@Value: HTML
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The DOM HTML feature.
              This is one of the allowed values in DOM Level 1 First Edition.
        @@@InCase:
          @@@@Value: XML
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The DOM XML feature.
              This is one of the allowed values in DOM Level 1 First Edition.
        @@@InCase:
          @@@@Label: XML 1.0 Name
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Only an XML 1.0 Name is allowed in DOM Level 1 Second Edition 
              and DOM Level 2.
        @@@InCase:
          @@@@Label: Reversed Internet domain name
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              DOM Level 1 First Edition and DOM Level 2 specifications 
              says that the feature name defined outside the DOM specifications 
              should use the reversed Internet domain name to avoid 
              possible confliction.
            \
              This recommendation is withdrawn by the Errata of the DOM Level 2 
              Specifications.
        @@@InCase:
          @@@@Label:
            @@@@@lang:en
            @@@@@@:
              The feature name prepended by the PLUS SIGN ("+")
          @@@@Type: DOMString
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The specified feature may not be directly castable
              but would be available through the method "getFeature".
     @@Param:
        @@@Name:  version
        @@@Type:
          ManakaiDOM:ManakaiDOMFeatureVersion
        @@@Description:
          @@@@lang:en
          @@@@@:
            The version number of the feature to test.
        @@@IsOptional:1
        @@@InCase:
          @@@@Value: 1.0
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              DOM Level 1.
              This is the only allowed value in DOM Level 1 and
              one of allowed values in DOM Level 2.
        @@@InCase:
          @@@@Value: 2.0
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              DOM Level 2.
              This is one of allowed values in DOM Level 2.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              No particular version is specified.
              \
              It is implied that this value is allowed in DOM 
              Level 1 and Level 2.  DOM Level 2 Errata and DOM 
              Level 3 explicitly allow this value specified.
        @@@InCase:
          @@@@Value: \
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              No particular version is specified.
              \
              This value is allowed in DOM Level 2 Errata and 
              DOM Level 3.
     @@Return:
        @@@Type:  boolean
        @@@Description:
          @@@@lang:en
          @@@@@: Whether the feature is implemented or not.
        @@@InCase:
          @@@@Value: true
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The feature is implemented in the specified version.
        @@@InCase:
          @@@@Value: false
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The feature is not implemented.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            __CODE{CheckNull: s => feature}__;
## TODO: feature and version checking
            $feature = lc $feature;
            if (defined $version and $version ne '') {
              $r = $__PACKAGE{Global}__::FeatureImplemented{$feature}
                                                           ->{$version} ?
                   true : false;
            } else {
              for (keys %{$__PACKAGE{Global}__::FeatureImplemented{$feature}}) {
                if ($__PACKAGE{Global}__::FeatureImplemented{$feature}->{$_}) {
                  $r = true;
                  last;
                }
              }
            }
  @Method:
     @@Name:  createDocumentType
     @@Description:
       @@@lang:en
       @@@@:
         Create an empty "DocumentType" node.
     @@ImplNote:
       @@@lang:en
       @@@@: 
         HTML-only DOM Level 2 implementations do not need to implement 
         this method.
     @@Param:
        @@@Name:  qualifiedName
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The qualified name of the document type to be created.
     @@Param:
        @@@Name:  publicId
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The external subset public identifier.
     @@Param:
        @@@Name:  systemId
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The external subset system identifier.
     @@SpecLevel: 2
     @@Level[list]:  
        2
        3
     @@Return:
        @@@Type:  DocumentType
        @@@Description:
          @@@@lang:en
          @@@@@: A new "DocumentType" node.
        @@@ImplNote:
          @@@@lang:en
          @@@@@: The "ownerDocument" attribute is set to "null".
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: INVALID_CHARACTER_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: 
              The "qualifiedName" is not an XML name 
              accoding to the XML 1.0 specification.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NAMESPACE_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The "qualifiedName" is malformed.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NOT_SUPPORTED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The DOM implementation does not support the "XML" feature and 
              the language exposed through the "Document" does not support 
              XML Namespaces.
        @@@Exception:
          @@@@Type: 
            ManakaiDOM:ManakaiDOMImplementationException
          @@@@Name: PARAM_NULL_POINTER
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The "qualifiedName" is the "null" value.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            __CODE{CheckNull: s => qualifiedName}__;
            __CODE{CheckQName: version => 1.0,
                               qname => qualifiedName}__; # [DOM 2,3]
            ## If namespace not supported: # [DOM 3]
            #__EXCEPTION{
            #  DOMException.NOT_SUPPORTED_ERR:
            #    <Q:MDOM_EXCEPTION:subtype> 
            #       => <Q:MDOM_EXCEPTION:NS_NOT_SUPPORTED>,
            #}__;
            my ($prefix, $lname);
            if (($lname = $qualifiedName) =~ s/^([^:]+)://) {
              $prefix = $1;
            }
                        ## Condition sensitive
            my $node = __CLASS{DocumentType}__->__INT{newObject}__;
            $node->{<Q:infoset:prefix>} = $prefix;
            $node->{<Q:infoset:localName>} = $lname;
            $node->{<Q:infoset:publicIdentifier>} = $publicId;
            $node->{<Q:infoset:systemIdentifier>} = $systemId; 
            ## Note: No DOM Level 3 method/attribute provides access 
            ##       to the DOM implementation object when the "DocumentType" 
            ##       does not have the parent node (= owner "Document").
            $node->{<Q:DOMCore:implementation>} = $self;
            $node->{<Q:ManakaiDOM:implID>}
                        = $self->{<Q:TreeCore:node>}->{<Q:ManakaiDOM:implID>};
                 ## Condition sensitive
            $r = __CLASS{Node}__->__INT{getNodeReference}__ ($node);
  @Method:
     @@Name:  createDocument
     @@Description:
       @@@lang:en
       @@@@:
         Create a "Document" object of the specified type with its 
         document element.
     @@ImplNote:
       @@@lang:en
       @@@@: 
         The DOM Level 2 specification said that the HTML-only 
         implementations do not need to implement this method.
     @@ImplNote:
       @@@lang:en
       @@@@:
         Document creation is an operation specific to an 
         implementation in the DOM Level 1.
     @@Param:
        @@@Name:  namespaceURI
        @@@Type:
          ManakaiDOM:ManakaiDOMNamespaceURI
        @@@Description:
          @@@@lang:en
          @@@@@: The namespace URI of the document element to create.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The null namespace name.
        @@@InCase:
          @@@@Value: \
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Considered as a namespace URI in DOM Level 2 or 
              treated as the "null" value in DOM Level 3.
     @@Param:
        @@@Name:  qualifiedName
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The qualified name of the document element to create.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: Document element is not created.
     @@Param:
        @@@Name:  doctype
        @@@Type:  DocumentType
        @@@Description:
          @@@@lang:en
          @@@@@: The type of document to create.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The document to be created does not have the "DocumentType" 
              node.
        @@@ImplNote:
          @@@@lang:en
          @@@@@:
            "doctype"."ownerDocument" is set to the document being 
            created unless "doctype" is "null".
     @@SpecLevel:2
     @@Level[list]:
       2
       3
     @@Return:
        @@@Type:  Document
        @@@Description:
          @@@@lang:en
          @@@@@:
            A new Document object.
          \
            Note that the object returned may be a specialized "Document" 
            object based on the "doctype" given.  For example. it might 
            implement the "HTMLDocument" interface.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: INVALID_CHARACTER_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The specified qualified name is not an XML name 
              accoding to the XML 1.0 specification.
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              DOM Level 3 specification defines to rely the XML 1.0 
              specification.  DOM Level 2 specification does not 
              explicitly defines but the definition for "INVALID_CHARACTER_ERR"
              refers the XML 1.0 specification.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NAMESPACE_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Either the "qualifiedName" is malformed, the "qualifiedName" 
              has a prefix and the "namespaceURI" is "null", the 
              "qualifiedName" is "null" and the "namespaceURI" is 
              different from "null", the "qualifiedName" has 
              a prefix that is "xml" and the "namespaceURI" is 
              different from "http://www.w3.org/XML/1998/namespace" or
              the DOM implementation does not support the "XML" feature 
              but a non-null "namespaceURI" is provided.
         @@@ImplNote:
           @@@@lang:en
           @@@@@:
              In addition, it is possible to raise an exception 
              either if the "qualifiedName" has a prefix that is 
              "xmlns" and the "namespaceURI" is different from 
              "http://www.w3.org/2000/xmlns/", if the "namespaceURI" 
              is "http://www.w3.org/XML/1998/namespace" and the 
              "qualifiedName" has a prefix is different from "xml" or 
              if the "namespaceURI" is "http://www.w3.org/2000/xmlns/" 
              and the "qualifiedName" has a prefix is different from "xmlns".
              But this DOM implementation only report a warning on 
              these cases since the specification does not mention 
              to raise any exception.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: WRONG_DOCUMENT_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The "doctype" has already been used with a different 
              document or was created from a different implementation.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NOT_SUPPORTED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The DOM implementation does not support the "XML" feature 
              and the language exposed through the "Document" does 
              not support XML Namespaces.
        @@@Exception:
          @@@@Type: 
            ManakaiDOM:ManakaiDOMImplementationException
          @@@@Name: MDOM_TYPE_MISMATCH_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: 
              The object specified to the "doctype" parameter is not a 
              "DocumentType".
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            my ($prefix, $lname);
            if (defined $qualifiedName) {     
              __CODE{CheckQName: version => 1.0,
                                 qname => qualifiedName}__; # [DOM 2,3]
              if (($lname = $qualifiedName) =~ s/^([^:]+)://) {
                $prefix = $1;
              }
              if (defined $namespaceURI) {    # ($uri, $qname, $doctype)
                ## If namespace not supported: # [DOM 3]
                #__EXCEPTION{
                ##  DOMException.NAMESPACE_ERR:
                #  DOMException.NOT_SUPPORTED_ERR:
                #    <Q:MDOM_EXCEPTION:subtype> 
                #       => <Q:MDOM_EXCEPTION:NS_NOT_SUPPORTED>,
                #}__;
              } else {                        # (null, $qname, $doctype)
                if ($prefix) {
                  __EXCEPTION{
                    DOMException.NAMESPACE_ERR:
                      <Q:MDOM_EXCEPTION:subtype>
                         => <Q:MDOM_EXCEPTION:NS_PREFIX_WITH_NULL_URI>,
                      <Q:infoset:prefix> => $prefix,
                  }__;                        # [DOM 2,3]
                }
              }
            } elsif (defined $namespaceURI) { # ($uri, null, $doctype)
              __EXCEPTION{
                DOMException.NAMESPACE_ERR:
                  <Q:MDOM_EXCEPTION:subtype>
                     => <Q:MDOM_EXCEPTION:NS_NULL_QNAME_NON_NULL_URI>,
                  <Q:infoset:namespaceName> => $namespaceURI,
              }__;                            # [DOM 3]
            }
            if (not $prefix) {
              if ($prefix eq 'xml' and 
                  (not $namespaceURI or
                   $namespaceURI ne q<http://www.w3.org/XML/1998/namespace>)) {
                __EXCEPTION{
                  DOMException.NAMESPACE_ERR:
                    <Q:MDOM_EXCEPTION:subtype>
                       => <Q:MDOM_EXCEPTION:NS_XML_WITH_OTHER_URI>,
                    <Q:infoset:namespaceName> => $namespaceURI,
                }__;                          # [DOM 2,3]
              } elsif ($prefix eq 'xmlns' and
                  (not $namespaceURI or
                   $namespaceURI ne q<http://www.w3.org/2000/xmlns/>)) {
                __WARNING{
                  ManakaiDOMImplementationWarning.MDOM_WARN_NAMESPACE_ERR:
                    <Q:MDOM_EXCEPTION:subtype>
                       => <Q:MDOM_EXCEPTION:NS_XMLNS_WITH_OTHER_URI>,
                    <Q:infoset:namespaceName> => $namespaceURI,
                }__;                          # DOM doesn't specify this
              }
            }
            if (defined $namespaceURI) {
              if ($namespaceURI eq q<http://www.w3.org/XML/1998/namespace> and
                  (not $prefix or $prefix ne 'xml')) {
                __WARNING{
                  ManakaiDOMImplementationWarning.MDOM_WARN_NAMESPACE_ERR:
                    <Q:MDOM_EXCEPTION:subtype>
                       => <Q:MDOM_EXCEPTION:NS_XML_URI_WITH_OTHER_PREFIX>,
                    <Q:infoset:prefix> => $prefix,
                }__;                          # DOM doesn't specify this
              } elsif ($namespaceURI eq q<http://www.w3.org/2000/xmlns/> and
                  (not $prefix or $prefix ne 'xmlns')) {
                __WARNING{
                  ManakaiDOMImplementationWarning.MDOM_WARN_NAMESPACE_ERR:
                    <Q:MDOM_EXCEPTION:subtype>
                       => <Q:MDOM_EXCEPTION:NS_XMLNS_URI_WITH_OTHER_PREFIX>,
                    <Q:infoset:prefix> => $prefix,
                }__;                          # DOM doesn't specify this
              }
            }
                       ## Condition sensitive
            my $node = __CLASS{Document}__->__INT{newObject}__; 
            $node->{<Q:DOMCore:implementation>} = $self;
            $node->{<Q:ManakaiDOM:implID>}
                = $self->{<Q:TreeCore:node>}->{<Q:ManakaiDOM:implID>};
            if ($doctype) {
              if (not $doctype->isa ('__IIF{DocumentType::}__')) {
                __EXCEPTION{
                  ManakaiDOMImplementationException.MDOM_TYPE_MISMATCH_ERR:
                    <Q:MDOM_EXCEPTION:param-name> => q<doctype>,
                    <Q:MDOM_EXCEPTION:class> => ref $doctype,
                }__;
              }
              my $doctypeNode = $doctype->{<Q:TreeCore:node>};
              if ($node->{<Q:TreeCore:treeID>} ne
                  $doctypeNode->{<Q:TreeCore:treeID>} or
                  $doctypeNode->{<Q:DOMCore:ownerDocument>} or
                  $doctypeNode->{<Q:ManakaiDOM:implID>} ne 
                    $node->{<Q:ManakaiDOM:implID>}) {
                __EXCEPTION{
                  DOMException.WRONG_DOCUMENT_ERR:
                }__;                          # [DOM 2,3]
              }
              $doctypeNode
                   ->__SUPER{ManakaiDOMNodeObject::}__::__INT{importTree}__
                                                                     ($node);
              $doctypeNode->{<Q:DOMCore:ownerDocument>} = $node;
              $doctypeNode->{<Q:infoset:parent>} = $node;
              push @{$node->{<Q:infoset:children>}}, $doctypeNode;
            }
            if ($lname) { ## Condition sensitive
              my $docEl = __CLASS{Element}__->__INT{new}__;
              my $docNode = $docEl->{<Q:TreeCore:node>};
              $node->__SUPER{ManakaiDOMNodeObject::}__->__INT{importTree}__
                                                        ($docNode);
              $docNode->{<Q:infoset:prefix>} = $prefix;
              $docNode->{<Q:infoset:namespaceName>} = $namespaceURI;
              $docNode->{<Q:infoset:localName>} = $lname;
              $docNode->{<Q:infoset:parent>} = $node;
              push @{$node->{<Q:infoset:children>}}, $docNode;
            }
                 ## Condition sensitive
            $r = __CLASS{Node}__::__INT{getNodeReference}__ ($node);
        
  @Method:
     @@Name:  getFeature
     @@Description:
        @@@lang:en
        @@@@: 
          Return a specialized object that implements the specialized 
          APIs of the specified feature and version.
     @@Param:
        @@@Name:  feature
        @@@Type:
          ManakaiDOM:ManakaiDOMFeatureName
        @@@Description:
          @@@@lang:en
          @@@@@:
            The name of the feature requested.
        @@@InCase: 
          @@@@Label: 
            The feature name prepended by the PLUS SIGN ("+")
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The PLUS SIGN is ignored.
     @@Param:
        @@@Name:  version
        @@@Type:
          ManakaiDOM:ManakaiDOMFeatureVersion
        @@@Description:
          @@@@lang:en
          @@@@@:
            The version number of the feature to test.
     @@SpecLevel:3
     @@Level[list]:  3
     @@Return:
        @@@Type:  DOMObject
        @@@Description:
          @@@@lang:en
          @@@@@:
            An object that implements the specialized APIs of the 
            specified feature and version.  That might or might not 
            implements the "DOMImplementation" interface.
        @@@InCase:
          @@@@Type: DOMImplementation
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              An object that implements both the specialized APIs 
              and the "DOMImplementation" interface.
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              This kind of object must delegate to the primary core 
              "DOMImplementation" and not return results inconsistent 
              with the primary core "DOMImplementation" such as 
              "hasFeature", "getFeature", etc.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@@: 
            There is no object that implements interfaces associated 
            with the feature and version.
## TODO: implement this
    @@IntMethod:
      @@@Name: new
      @@@Description:
        @@@@lang:en
        @@@@@: Construct a new instance of the "DOMImplementation".
      @@@Return:
        @@@@Type: DOMImplementation
        @@@@Description:
          @@@@@lang:en
          @@@@@@: The "DOMImplementation" created.
        @@@@Def:
          @@@@@Type:
            lang:Perl
          @@@@@@:
            my $node = __CLASS{ManakaiDOMNodeObject::}__->__INT{new}__;
            $r = $node->__SUPER{ManakaiDOMNodeObject::}__::__INT{newReference}__
                                                                   ($self);
            $node->{<Q:ManakaiDOM:implID>} = $node->{<Q:ManakaiDOM:implID>};

IF:
  @Name:  Node
  @Description:
    @@lang:en
    @@@:
      The primary datatype for the entire Document Object Model, 
      that represents a single node in the document tree.
  @ISA:
    ManakaiDOM:ManakaiDOMNodeReference::
  @ImplNote:
    @@lang:en
    @@@:
      "Attr", "Element", "Document", "DocumentFragment", "DocumentType", 
      "Entity", "EntityReference", "Notation", "ProcessingInstriction" 
      and "CharacterData" are "Node".  "Comment" and "Text" are 
      "CharacterData".  "CDATASection" is a "Text".
  @ConstGroup:
     @@Name:  NodeType
     @@Description:
       @@@lang:en
       @@@@: An integer indicating which type of node this is.
     @@ImplNote:
       @@@lang:en
       @@@@: Codes <= 200 are reserved to W3C for possible future use.
     @@Const:
        @@@Name:  ELEMENT_NODE
        @@@Type:  unsigned-short
        @@@Value:  1
        @@@Description:
          @@@@lang:en
          @@@@@: The node is an "Element".
     @@Const:
        @@@Name:  ATTRIBUTE_NODE
        @@@Type:  unsigned-short
        @@@Value:  2
        @@@Description:
          @@@@lang:en
          @@@@@: The node is an "Attr".
     @@Const:
        @@@Name:  TEXT_NODE
        @@@Type:  unsigned-short
        @@@Value:  3
        @@@Description:
          @@@@lang:en
          @@@@@: The node is a "Text".
     @@Const:
        @@@Name:  CDATA_SECTION_NODE
        @@@Type:  unsigned-short
        @@@Value:  4
        @@@Description:
          @@@@lang:en
          @@@@@: The node is a "CDATASection".
     @@Const:
        @@@Name:  ENTITY_REFERENCE_NODE
        @@@Type:  unsigned-short
        @@@Value:  5
        @@@Description:
          @@@@lang:en
          @@@@@: The node is an "EntityReference".
     @@Const:
        @@@Name:  ENTITY_NODE
        @@@Type:  unsigned-short
        @@@Value:  6
        @@@Description:
          @@@@lang:en
          @@@@@: The node is an "Entity".
     @@Const:
        @@@Name:  PROCESSING_INSTRUCTION_NODE
        @@@Type:  unsigned-short
        @@@Value:  7
        @@@Description:
          @@@@lang:en
          @@@@@: The node is a "ProcessingInstruction".
     @@Const:
        @@@Name:  COMMENT_NODE
        @@@Type:  unsigned-short
        @@@Value:  8
        @@@Description:
          @@@@lang:en
          @@@@@: The node is a "Comment".
     @@Const:
        @@@Name:  DOCUMENT_NODE
        @@@Type:  unsigned-short
        @@@Value:  9
        @@@Description:
          @@@@lang:en
          @@@@@: The node is a "Document".
     @@Const:
        @@@Name:  DOCUMENT_TYPE_NODE
        @@@Type:  unsigned-short
        @@@Value:  10
        @@@Description:
          @@@@lang:en
          @@@@@: The node is a "DocumentType".
     @@Const:
        @@@Name:  DOCUMENT_FRAGMENT_NODE
        @@@Type:  unsigned-short
        @@@Value:  11
        @@@Description:
          @@@@lang:en
          @@@@@: The node is a "DocumentFragment".
     @@Const:
        @@@Name:  NOTATION_NODE
        @@@Type:  unsigned-short
        @@@Value:  12
        @@@Description:
          @@@@lang:en
          @@@@@: The node is a "Notation".
  @Attr:
     @@Name:  nodeName
     @@Description:
        @@@lang:en
        @@@@: The node name.
     @@Get:
        @@@Type:  DOMString
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@: $r = null;
     @@RedefinedBy: Attr
     @@RedefinedBy: CDATASection
     @@RedefinedBy: Comment
     @@RedefinedBy: Document
     @@RedefinedBy: DocumentFragment
     @@RedefinedBy: DocumentType
     @@RedefinedBy: Element
     @@RedefinedBy: Entity
     @@RedefinedBy: EntityReference
     @@RedefinedBy: Notation
     @@RedefinedBy: ProcessingInstruction
     @@RedefinedBy: Text
  @Attr:
     @@Name:  nodeValue
     @@Description:
       @@@lang:en
       @@@@: The value of this node.
     @@Get:
        @@@Type:  DOMString
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: DOMSTRING_SIZE_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: 
              The attribute would return more characters than fit in 
              a DOMString variable on the implementation platform.
        @@@Def:
          @@@@Type: 
            lang:Perl
          @@@@@: $r = null;
     @@Set:
        @@@Type:  DOMString
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: 
              The node is read-only and the node is not defined to be "null".
        @@@Description:
          @@@@lang:en
          @@@@@:
            New node value.
            Note that setting this attribute has no effect if 
            the node value is defined to be "null".
        @@@Warning:
          @@@@Type: 
            ManakaiDOM:ManakaiDOMImplementationWarning
          @@@@Name: ATTR_SET_NO_EFFECT
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Setting this attribute has no effect since the node 
              value is defined to be "null".
        @@@ImplNote:
          @@@@lang:en
          @@@@@:
            Don't raise an exception even if the node is read-only when 
            the node value is defined to be "null".  Note that 
            "even if read-only" has been clarified by the DOM Level 2 Errata.
        @@@Def: \
    @@RedefinedBy: Attr
    @@RedefinedBy: CharacterData
    @@RedefinedBy: ProcessingInstruction
  @Attr:
     @@Name:  nodeType
     @@Description:
       @@@lang:en
       @@@@: The type of this node.
     @@Get:
        @@@Type:  unsigned-short
        @@@Description:
          @@@@lang:en
          @@@@@: The code representing the type of the underlying object.
        @@@Def: \
     @@RedefinedBy: Attr
     @@RedefinedBy: CDATASection
     @@RedefinedBy: Comment
     @@RedefinedBy: Document
     @@RedefinedBy: DocumentFragment
     @@RedefinedBy: DocumentType
     @@RedefinedBy: Element
     @@RedefinedBy: Entity
     @@RedefinedBy: EntityReference
     @@RedefinedBy: Notation
     @@RedefinedBy: ProcessingInstruction
     @@RedefinedBy: Text
  @Attr:
     @@Name:  parentNode
     @@Description:
       @@@lang:en
       @@@@: The parent of this node.
     @@Get:
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@: The parent node.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The node does not have a parent since its type is either 
              "Attr", "Document", "DocumentFragment", "Entity", 
              or "Notation", since it has just been created 
              and not yet added, or since it has been removed from the tree.
        @@@Def:
          @@@@Type:
            lang:dis
          @@@@GetPropNode:
            infoset:parent
  @Attr:
     @@Name:  childNodes
     @@Get:
        @@@Type:  NodeList
  @Attr:
     @@Name:  firstChild
     @@Description:
       @@@lang:en
       @@@@: The first child of this node.
     @@Get:
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@: The first child node.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: There is no child node.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            $r = $self->{<Q:TreeCore:node>}->{<Q:infoset:children>}->[0];
                      ## Condition sensitive
            $r = $r ? __CLASS{Node}__->__INT{getNodeReference}__ ($r)
                    : null;
    @@Level[list]:
      1
      2
      3
    @@SpecLevel:1
  @Attr:
     @@Name:  lastChild
     @@Description:
        @@@lang:en
        @@@@: The last child of this node.
     @@Get:
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@: The last child node.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: There is no child node.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            $r = $self->{<Q:TreeCore:node>}->{<Q:infoset:children>}->[-1];
                      ## Condition sensitive
            $r = $r ? __CLASS{Node}__->__INT{getNodeReference}__ ($r)
                    : null;
     @@Level[list]:
        1
        2
        3
     @@SpecLevel:1
  @Attr:
     @@Name:  previousSibling
     @@Description:
        @@@lang:en
        @@@@:
          The node immediately preceding this node.
     @@Get:
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@: The node immediately preceding this node.
        @@@InCase:
          @@@@Value:
             @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: There is no such node.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            if (my $parent = $self->{<Q:TreeCore:node>}->{<Q:infoset:parent>}) {
              for (@{$parent->{<Q:infoset:children>}}) {
                if ($_->{<Q:TreeCore:nodeID>} eq
                         $self->{<Q:TreeCore:node>}->{<Q:TreeCore:nodeID>}) {
                  last;
                } else {
                  $r = $_;
                }
              }
            }
            if ($r) {
                   ## Condition sensitive
              $r = __CLASS{Node}__->__INT{getNodeReference}__ ($r);
            }
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              This code will return incorrect answer if the infoset:children 
              of the infoset:parent does not have "this" node 
              (i.e. the tree is broken).
    @@Level[list]:
      1
      2
      3
    @@SpecLevel:1
  @Attr:
     @@Name:  nextSibling
     @@Description:
        @@@lang:en
        @@@@: The node immediately following this node.
     @@Get:
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@: The node immediately following this node.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: There is no such node.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            if (my $parent = $self->{<Q:TreeCore:node>}->{<Q:infoset:parent>}) {
              my $next = 0;
              for (@{$parent->{<Q:infoset:children>}}) {
                if ($next) {
                       ## Condition sensitive
                  $r = __CLASS{Node}__->__INT{getNodeReference}__ ($_);
                  last;
                } elsif ($_->{<Q:TreeCore:nodeID>} eq
                         $self->{<Q:TreeCore:node>}->{<Q:TreeCore:nodeID>}) {
                  $next = 1;
                }
              }
            }
    @@Level[list]:
      1
      2
      3
    @@SpecLevel:1
  @Attr:
     @@Name:  attributes
     @@Get:
        @@@Type:  NamedNodeMap
  @Attr:
     @@Name:  ownerDocument
     @@Description:
       @@@lang:en
       @@@@:
         The "Document" object associated with this node.
     @@Get:
        @@@Type:  Document
        @@@Description:
          @@@@lang:en
          @@@@@: The "Document" object associated with this node.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The node is a "Document" or the node is a "DocumentType" 
              that is not used with any "Document" yet.
        @@@Def:
          @@@@Type:
            lang:dis
          @@@@GetPropNode:
            DOMCore:ownerDocument
     @@SpecLevel[list]:
        1
        2
     @@Level[list]:
        1
     @@ImplNote:
        @@@lang:en
        @@@@:
          The DOM Level 1 specification does not take the "DocumentType" 
          without any "Document" into account since DOM Level 1 
          does not have "createDocumentType" so that no "DocumentType" 
          object can be exist without its parent of the "Document".
  @Method:
     @@Name:  insertBefore
     @@Description:
       @@@lang:en
       @@@@:
         Insert a node before the existing child node.
     @@Param:
        @@@Name:  newChild
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@:
            The node to insert.  If the "newChild" node is already 
            in the tree, it is first removed.
        @@@InCase:
          @@@@Type: DocumentFragment
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              All of the children are inserted, in the same order. 
              After the insertion, the children list of the 
              "newChild" is empty.
          @@@@SpecLevel: 1
     @@Param:
        @@@Name:  refChild
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@:
            The reference node.  The "newChild" node is inserted before 
            the "refChild" node.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The "newChild" is inserted at the end of the list of children. 
        @@@InCase:
          @@@@Label: Same as "newChild"
          @@@@Description:
            @@@@@lang:en
            @@@@@@: Inserting a node before itself is implementation dependent.
          @@@@SpecLevel:3
     @@Return:
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@: The node being inserted.
        @@@ImplNote:
          @@@@lang:en
          @@@@@:
            What should be returned when the "newChild" is a "DocumentFragment" 
            is unclear.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: HIERARCHY_REQUEST_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: 
              Either this node is of a type that does not allow 
              children of the type of the "newChild" node [DOM 1, 2, 3],
              the node to insert is one of ancestors of this node 
              [DOM 1, 2, 3], the node to insert is this node itself
              [DOM 2 Errata, 3], or this node is of type "Document" 
              and the attemption 
              to insert a second "DocumentType" or "Element" node 
              is made [DOM 3].
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@: 
              Special treatment required if it is a "DocumentFragment".
              Whether the node is hierarchically valid must be 
              ensured for each child nodes.
            \
              For example, the attemption to add more than one elements 
              using "DocumentFragment" to the empty "Document" must 
              be detected.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: WRONG_DOCUMENT_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The "newChild" node was created from a different 
              document.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Either this node is read-only [DOM 1, 2, 3] or the parent of 
              the node being inserted is read-only [DOM 1 SE, 2, 3].
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NOT_SUPPORTED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              This node is of type "Document" and the DOM implementation 
              does not support the insertion of a "DocumentType" or 
              "Element" node.
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              While the specification does not address, 
              in case that the parent of the "newChild" is a "Document" 
              and the DOM implementation does not support the 
              removal from it, this error should also be raised.
          @@@@SpecLevel:3
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            my $node;
            my $newNode;
            CHKDOC: {
              if (ref $newChild and $newChild->isa ('__IIF{Node::}__')) {
                $node = $self->{<Q:TreeCore:node>};
                $newNode = $newChild->{<Q:TreeCore:node>};
                if ($node->{<Q:DOMCore:ownerDocument>}) {
                  if ($newNode->{<Q:DOMCore:ownerDocument>}) {
                    last CHKDOC if $node->{<Q:DOMCore:ownerDocument>}
                                        ->{<Q:TreeCore:nodeID>} eq
                                   $newNode->{<Q:DOMCore:ownerDocument>}
                                        ->{<Q:TreeCore:nodeID>};
                  }
                } else { ## I'm "Document" or "DocumentType" node.
                  if ($node->{<Q:DOMCore:nodeType>} eq <Q:infoset:Document>) {
                    last CHKDOC;
                  }
                }
              }
              __EXCEPTION{
                DOMException.WRONG_DOCUMENT_ERR:
                  <Q:MDOM_EXCEPTION:param-name> => 'newChild',
              }__;
            } # CHKDOC
            my @newNode = ($newNode);
            if ($newNode->{<Q:DOMCore:nodeType>} eq
                <Q:DOMCore:DocumentFragment>) {
       \       @newNode = @{$newNode->{<Q:infoset:children>}};
            }
            if (@newNode) {
              my $parentNode = $newNode[0]->{<Q:infoset:parent>};

              ## Read-only?
              if ($node->{<Q:DOMCore:read-only>}) {
                ## This node is read-only.
                __EXCEPTION{
                  DOMException.NO_MODIFICATION_ALLOWED_ERR:
                    <Q:MDOM_EXCEPTION:subtype>
                                    => <Q:MDOM_EXCEPTION:NOMOD_THIS>,
                }__;
              } elsif ($parentNode and $parentNode->{<Q:DOMCore:read-only>}) {
                ## Parent of new node(s) is read-only
                __EXCEPTION{
                  DOMException.NO_MODIFICATION_ALLOWED_ERR:
                    <Q:MDOM_EXCEPTION:subtype>
                                     => <Q:MDOM_EXCEPTION:NOMOD_SRC_PARENT>,
                    <Q:MDOM_EXCEPTION:param-name> => 'newChild',
                }__;
              }
              
              ## Check type of this node and new child node
              CHKTYPE: {
                if ({
                      <Q:infoset:Element> => 1,
                      <Q:DOMCore:DocumentFragment> => 1,
                      <Q:DOMCore:Entity> => 1,
                      <Q:DOMCore:EntityReference> => 1,
                    }->{$node->{<Q:DOMCore:nodeType>}}) {
                  CHILDTYPE: {
                    for (@newNode) {
                      unless ({
                            <Q:infoset:Element> => 1,
                            <Q:DOMCore:Text> => 1,
                            <Q:infoset:Comment> => 1,
                            <Q:infoset:ProcessingInstruction> => 1,
                            <Q:DOMCore:CDATASection> => 1,
                            <Q:DOMCore:EntityReference> => 1,
                          }->{$_->{<Q:DOMCore:nodeType>}}) {
                        last CHILDTYPE;
                      }
                    }
                    last CHKTYPE; # No problem
                  }
                } elsif ($node->{<Q:DOMCore:nodeType>} eq <Q:infoset:Document>) {
                  CHILDTYPE: {
                    my %has;
                    EACHNEWNODE: for my $newNode (@newNode) {
                      if ({
                            <Q:infoset:Element> => 1,
                            <Q:infoset:DocumentTypeDeclaration> => 1,
                          }->{$newNode->{<Q:DOMCore:nodeType>}}) {
                        FOUND: {
                          if ($has{$newNode->{<Q:DOMCore:nodeType>}}) {
                            ## DOCTYPE or document element is waiting 
                            ## to be added
                            last FOUND;
                          }
                          for (@{$node->{<Q:infoset:children>}}) {
                            ## Document already has a DOCTYPE or doc.element
                            last FOUND if $_->{<Q:DOMCore:nodeType>} eq
                                          $newNode->{<Q:DOMCore:nodeType>};
                          }
                          $has{$newNode->{<Q:DOMCore:nodeType>}} = 1;
                          next EACHNEWNODE;
                        }
                        __EXCEPTION{
                          DOMException.HIERARCHY_REQUEST_ERR:
                            <Q:MDOM_EXCEPTION:subtype>
                                 => <Q:MDOM_EXCEPTION:HIERARCHY_TOO_MANY_NODES>,
                            <Q:DOMCore:nodeType>
                                 => $newNode->{<Q:DOMCore:nodeType>},
                            <Q:MDOM_EXCEPTION:param-name> => 'newChild',
                        }__;
                      } elsif (not {
                                 <Q:infoset:Comment> => 1,
                                 <Q:infoset:ProcessingInstruction> => 1,
                               }->{$newNode->{<Q:DOMCore:nodeType>}}) {
                        last CHILDTYPE;
                      }
                    } # EACHNEWNODE
                    last CHKTYPE; # No problem
                  } # CHILDTYPE
                } elsif ($node->{<Q:DOMCore:nodeType>} eq
                         <Q:infoset:Attribute>) {
                  CHILDTYPE: {
                    for my $newNode (@newNode) {
                      unless ({
                            <Q:DOMCore:Text> => 1,
                            <Q:DOMCore:EntityReference> => 1,
                          }->{$newNode->{<Q:DOMCore:nodeType>}}) {
                        last CHILDTYPE;
                      }
                    }
                    last CHKTYPE; # No problem
                  }
                } # $node->{<Q:DOMCore:nodeType>}
                __EXCEPTION{
                  DOMException.HIERARCHY_REQUEST_ERR:
                    <Q:MDOM_EXCEPTION:subtype>
                         => <Q:MDOM_EXCEPTION:HIERARCHY_BAD_TYPE>,
                    <Q:infoset:nodeType> => $newNode->{<Q:infoset:nodeType>},
                    <Q:MDOM_EXCEPTION:param-name> => 'newChild',
                }__;
              } # CHKTYPE
              
              ## Check $newNode (not $newNode[0]) = ancestor-or-self::node()
              if ($node->{<Q:TreeCore:treeID>} eq
                  $newNode->{<Q:TreeCore:treeID>}) {
                my $n = $node;
                {
                  if ($newNode->{<Q:TreeCore:nodeID>} eq
                      $n->{<Q:TreeCore:nodeID>}) {
                    __EXCEPTION{
                      DOMException.HIERARCHY_REQUEST_ERR:
                        <Q:MDOM_EXCEPTION:subtype>
                             => <Q:MDOM_EXCEPTION:HIERARCHY_ANCESTOR_OR_SELF>,
                        <Q:MDOM_EXCEPTION:param-name> => 'newChild',
                    }__;
                  }
                  if ($n->{<Q:infoset:parent>}) {
                    $n = $n->{<Q:infoset:parent>};
                    redo;
                  }
                }
              }
              
              ## Seek the $refChild
              my $newIndex = @{$node->{<Q:infoset:children>}};
              REFCHILD: {
                if (defined $refChild) {
                  my $refID = $refChild->{<Q:TreeCore:node>}
                                       ->{<Q:TreeCore:nodeID>};
                  for my $i (0..$#{$node->{<Q:infoset:children>}}) {
                    if ($node->{<Q:infoset:children>}->[$i]
                             ->{<Q:TreeCore:nodeID>} eq $refID) {
                      $newIndex = $i;
                      last REFCHILD;
                    }
                  }
                  __EXCEPTION{
                    DOMException.NOT_FOUND_ERR:
                      <Q:MDOM_EXCEPTION:param-name> => 'refChild',
                  }__;
                }
              } # REFCHILD
              if ($newNode[0]->{<Q:infoset:parent>} and
                  $newNode[0]->{<Q:infoset:parent>}->{<Q:TreeCore:nodeID>} eq
                  $node->{<Q:TreeCore:nodeID>}) {
                if (@newNode > 1) {
                  __EXCEPTION{
                    ManakaiDOMImplementationException.MDOM_DEBUG_BUG:
                  }__;
                } elsif (ref $refChild and
                         $newNode[0]->{<Q:TreeCore:nodeID>} eq
                         $refChild->{<Q:TreeCore:node>}->{<Q:TreeCore:nodeID>}) {
                  __WARNING{
                    ManakaiDOMImplementationWarning.MDOM_NEWCHILD_IS_REFCHILD: 
                      <Q:MDOM_EXCEPTION:newChild-param-name> => 'newChild',
                      <Q:MDOM_EXCEPTION:refChild-param-name> => 'refChild',
                  }__;
                  ## And no action.
                } else {
                  my $currentIndex;
                  for my $i (0..$#{$node->{<Q:infoset:children>}}) {
                    if ($node->{<Q:infoset:children>}->[$i]
                             ->{<Q:TreeCore:nodeID>} eq
                        $newNode[0]->{<Q:TreeCore:nodeID>}) {
                      $currentIndex = $i;
                    }
                  }
                  if ($newIndex < $currentIndex) {
                    delete $node->{<Q:infoset:children>}->[$currentIndex];
                    splice @{$node->{<Q:infoset:children>}},
                           $newIndex, 0, @newNode;
                  } else {
                    splice @{$node->{<Q:infoset:children>}},
                           $newIndex, 0, @newNode;
                    delete $node->{<Q:infoset:children>}->[$currentIndex];
                  }
                }
              } else { ## $newChild->parentNode ne $self
                for my $newNode (@newNode) {
                  delete $newNode->{<Q:infoset:parent>};
                  $node->__SUPER{ManakaiDOMNodeObject::}__::__INT{importTree}__
                                                                   ($newNode);
                  $newNode->{<Q:infoset:parent>} = $node;
                }
                splice @{$node->{<Q:infoset:children>}},
                       $newIndex, 0, @newNode;
              }
              
              if ($newNode->{<Q:DOMCore:nodeType>} eq
                  <Q:DOMCore:DocumentFragment>) {
                $newNode->{<Q:infoset:children>} = [];
              } elsif ($parentNode) {
                for my $i (0..$#{$parentNode->{<Q:infoset:children>}}) {
                  if ($parentNode->{<Q:infoset:children>}->[$i]
                                 ->{<Q:TreeCore:nodeID>} eq
                      $node->{<Q:TreeCore:nodeID>}) {
                    delete $parentNode->{<Q:infoset:children>}->[$i];
                    last;
                  }
                }
              }
            } # @newNode
            $r = $newChild;
     @@Level[list]:
        1
     @@SpecLevel[list]:
        1
        3
  @Method:
     @@Name:  replaceChild
     @@Description:
        @@@lang:en
        @@@@:
          Replace a child node with the other node.
     @@Param:
        @@@Name:  newChild
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@:
            The new node to put in the child list.  If the "newChild" node 
            is already in the tree, it is first removed.
        @@@InCase:
          @@@@Type: DocumentFragment
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The "oldChild" node is replaced by all of the 
              child nodes of the "newChild" node, in the same order. 
              The child list of the "newChild" is to be empty. 
              [DOM 1 SE, 2, 3]
     @@Param:
        @@@Name:  oldChild
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@:
            The node being replaced in the child list.
        @@@InCase:
          @@@@Label: Same as the "newChild" node
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Replacing a node with itself is implementation dependent.
          @@@@SpecLevel: 3
     @@Return:
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@: The node replaced.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: HIERARCHY_REQUEST_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Either this node is of a type that does not allow 
              children of the type of the "newChild" node [DOM 1, 2, 3],
              the node to put in is one of ancestors of this node 
              [DOM 1, 2, 3], the node to put in is this node itself
              [DOM 2 Errata, 3], or this 
              node is of type "Document" and the result of the 
              replacement would add a second "DocumentType" or "Element" node.
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              Special treatment required for the "DocumentFragment" node.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: WRONG_DOCUMENT_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The new node was created from a different document.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Either this node is read-only [DOM 1, 2, 3] or the parent of the 
              new node is read-only [DOM 1 SE, 2, 3].
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NOT_FOUND_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The "oldChild" node is not a child of this node.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NOT_SUPPORTED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              This node is of type "Document" and the DOM implementation 
              does not support the replacement of the "DocumentType" or 
              "Element" child.
          @@@@SpecLevel:3
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            my $node;
            my $newNode;
            CHKDOC: {
              if (ref $newChild and $newChild->isa ('__IIF{Node::}__')) {
                $node = $self->{<Q:TreeCore:node>};
                $newNode = $newChild->{<Q:TreeCore:node>};
                if ($node->{<Q:DOMCore:ownerDocument>}) {
                  if ($newNode->{<Q:DOMCore:ownerDocument>}) {
                    last CHKDOC if $node->{<Q:DOMCore:ownerDocument>}
                                        ->{<Q:TreeCore:nodeID>} eq
                                   $newNode->{<Q:DOMCore:ownerDocument>}
                                        ->{<Q:TreeCore:nodeID>};
                  }
                } else { ## I'm "Document" or "DocumentType" node.
                  if ($node->{<Q:DOMCore:nodeType>} eq <Q:infoset:Document>) {
                    last CHKDOC;
                  }
                }
              }
              __EXCEPTION{
                DOMException.WRONG_DOCUMENT_ERR:
                  <Q:MDOM_EXCEPTION:param-name> => 'newChild',
              }__;
            } # CHKDOC
            my @newNode = ($newNode);
            if ($newNode->{<Q:DOMCore:nodeType>} eq
                <Q:DOMCore:DocumentFragment>) {
       \       @newNode = @{$newNode->{<Q:infoset:children>}};
            }
            if (@newNode) {
              my $parentNode = $newNode[0]->{<Q:infoset:parent>};

              ## Read-only?
              if ($node->{<Q:DOMCore:read-only>}) {
                ## This node is read-only.
                __EXCEPTION{
                  DOMException.NO_MODIFICATION_ALLOWED_ERR:
                    <Q:MDOM_EXCEPTION:subtype> => <Q:MDOM_EXCEPTION:NOMOD_THIS>,
                }__;
              } elsif ($parentNode and $parentNode->{<Q:DOMCore:read-only>}) {
                ## Parent of new node(s) is read-only
                __EXCEPTION{
                  DOMException.NO_MODIFICATION_ALLOWED_ERR:
                    <Q:MDOM_EXCEPTION:subtype>
                                          => <Q:MDOM_EXCEPTION:NOMOD_SRC_PARENT>,
                    <Q:MDOM_EXCEPTION:param-name> => 'newChild',
                }__;
              }
              
              ## Check type of this node and new child node
              CHKTYPE: {
                if ({
                      <Q:infoset:Element> => 1,
                      <Q:DOMCore:DocumentFragment> => 1,
                      <Q:DOMCore:Entity> => 1,
                      <Q:DOMCore:EntityReference> => 1,
                    }->{$node->{<Q:DOMCore:nodeType>}}) {
                  CHILDTYPE: {
                    for (@newNode) {
                      unless ({
                            <Q:infoset:Element> => 1,
                            <Q:DOMCore:Text> => 1,
                            <Q:infoset:Comment> => 1,
                            <Q:infoset:ProcessingInstruction> => 1,
                            <Q:DOMCore:CDATASection> => 1,
                            <Q:DOMCore:EntityReference> => 1,
                          }->{$_->{<Q:DOMCore:nodeType>}}) {
                        last CHILDTYPE;
                      }
                    }
                    last CHKTYPE; # No problem
                  }
                } elsif ($node->{<Q:DOMCore:nodeType>} eq <Q:infoset:Document>) {
                  CHILDTYPE: {
                    my %has;
                    EACHNEWNODE: for my $newNode (@newNode) {
                      if ({
                            <Q:infoset:Element> => 1,
                            <Q:infoset:DocumentTypeDeclaration> => 1,
                          }->{$newNode->{<Q:DOMCore:nodeType>}}) {
                        FOUND: {
                          if ($has{$newNode->{<Q:DOMCore:nodeType>}}) {
                            ## DOCTYPE or document element is waiting 
                            ## to be added
                            last FOUND;
                          }
                          for (@{$node->{<Q:infoset:children>}}) {
                            ## Document already has a DOCTYPE or doc.element
                            last FOUND if $_->{<Q:DOMCore:nodeType>} eq
                                          $newNode->{<Q:DOMCore:nodeType>};
                          }
                          $has{$newNode->{<Q:DOMCore:nodeType>}} = 1;
                          next EACHNEWNODE;
                        }
                        __EXCEPTION{
                          DOMException.HIERARCHY_REQUEST_ERR:
                            <Q:MDOM_EXCEPTION:subtype>
                                 => <Q:MDOM_EXCEPTION:HIERARCHY_TOO_MANY_NODES>,
                            <Q:DOMCore:nodeType>
                                 => $newNode->{<Q:DOMCore:nodeType>},
                            <Q:MDOM_EXCEPTION:param-name> => 'newChild',
                        }__;
                      } elsif (not {
                                 <Q:infoset:Comment> => 1,
                                 <Q:infoset:ProcessingInstruction> => 1,
                               }->{$newNode->{<Q:DOMCore:nodeType>}}) {
                        last CHILDTYPE;
                      }
                    } # EACHNEWNODE
                    last CHKTYPE; # No problem
                  } # CHILDTYPE
                } elsif ($node->{<Q:DOMCore:nodeType>} eq
                         <Q:infoset:Attribute>) {
                  CHILDTYPE: {
                    for my $newNode (@newNode) {
                      unless ({
                            <Q:DOMCore:Text> => 1,
                            <Q:DOMCore:EntityReference> => 1,
                          }->{$newNode->{<Q:DOMCore:nodeType>}}) {
                        last CHILDTYPE;
                      }
                    }
                    last CHKTYPE; # No problem
                  }
                } # $node->{<Q:DOMCore:nodeType>}
                __EXCEPTION{
                  DOMException.HIERARCHY_REQUEST_ERR:
                    <Q:MDOM_EXCEPTION:subtype>
                         => <Q:MDOM_EXCEPTION:HIERARCHY_BAD_TYPE>,
                    <Q:infoset:nodeType> => $newNode->{<Q:infoset:nodeType>},
                    <Q:MDOM_EXCEPTION:param-name> => 'newChild',
                }__;
              } # CHKTYPE
              
              ## Check $newNode (not $newNode[0]) = ancestor-or-self::node()
              if ($node->{<Q:TreeCore:treeID>} eq
                  $newNode->{<Q:TreeCore:treeID>}) {
                my $n = $node;
                {
                  if ($newNode->{<Q:TreeCore:nodeID>} eq
                      $n->{<Q:TreeCore:nodeID>}) {
                    __EXCEPTION{
                      DOMException.HIERARCHY_REQUEST_ERR:
                        <Q:MDOM_EXCEPTION:subtype>
                             => <Q:MDOM_EXCEPTION:HIERARCHY_ANCESTOR_OR_SELF>,
                        <Q:MDOM_EXCEPTION:param-name> => 'newChild',
                    }__;
                  }
                  if ($n->{<Q:infoset:parent>}) {
                    $n = $n->{<Q:infoset:parent>};
                    redo;
                  }
                }
              }
              
              ## Seek the $oldChild
              my $newIndex = @{$node->{<Q:infoset:children>}};
              REFCHILD: {
                if (defined $oldChild) {
                  my $refID = $oldChild->{<Q:TreeCore:node>}
                                       ->{<Q:TreeCore:nodeID>};
                  for my $i (0..$#{$node->{<Q:infoset:children>}}) {
                    if ($node->{<Q:infoset:children>}->[$i]
                             ->{<Q:TreeCore:nodeID>} eq $refID) {
                      $newIndex = $i;
                      last REFCHILD;
                    }
                  }
                  __EXCEPTION{
                    DOMException.NOT_FOUND_ERR:
                      <Q:MDOM_EXCEPTION:param-name> => 'oldChild',
                  }__;
                }
              } # REFCHILD
              if ($newNode[0]->{<Q:infoset:parent>} and
                  $newNode[0]->{<Q:infoset:parent>}->{<Q:TreeCore:nodeID>} eq
                  $node->{<Q:TreeCore:nodeID>}) {
                if (@newNode > 1) {
                  __EXCEPTION{
                    ManakaiDOMImplementationException.MDOM_DEBUG_BUG:
                  }__;
                } elsif (ref $oldChild and
                         $newNode[0]->{<Q:TreeCore:nodeID>} eq
                         $oldChild->{<Q:TreeCore:node>}->{<Q:TreeCore:nodeID>}) {
                  __WARNING{
                    ManakaiDOMImplementationWarning.MDOM_NEWCHILD_IS_REFCHILD: 
                      <Q:MDOM_EXCEPTION:newChild-param-name> => 'newChild',
                      <Q:MDOM_EXCEPTION:refChild-param-name> => 'oldChild',
                  }__;
                  ## And no action.
                } else {
                  my $currentIndex;
                  for my $i (0..$#{$node->{<Q:infoset:children>}}) {
                    if ($node->{<Q:infoset:children>}->[$i]
                             ->{<Q:TreeCore:nodeID>} eq
                        $newNode[0]->{<Q:TreeCore:nodeID>}) {
                      $currentIndex = $i;
                    }
                  }
                  if ($newIndex < $currentIndex) {
                    delete $node->{<Q:infoset:children>}->[$currentIndex];
                    splice @{$node->{<Q:infoset:children>}},
                           $newIndex, 1, @newNode;
                  } else {
                    splice @{$node->{<Q:infoset:children>}},
                           $newIndex, 1, @newNode;
                    delete $node->{<Q:infoset:children>}->[$currentIndex];
                  }
                }
              } else { ## $newChild->parentNode ne $self
                for my $newNode (@newNode) {
                  delete $newNode->{<Q:infoset:parent>};
                  $node->__SUPER{ManakaiDOMNodeObject::}__::__INT{importTree}__
                                                                   ($newNode);
                  $newNode->{<Q:infoset:parent>} = $node;
                }
                splice @{$node->{<Q:infoset:children>}},
                       $newIndex, 1, @newNode;
              }
              
              if ($newNode->{<Q:DOMCore:nodeType>} eq
                  <Q:DOMCore:DocumentFragment>) {
                $newNode->{<Q:infoset:children>} = [];
              } elsif ($parentNode) {
                for my $i (0..$#{$parentNode->{<Q:infoset:children>}}) {
                  if ($parentNode->{<Q:infoset:children>}->[$i]
                                 ->{<Q:TreeCore:nodeID>} eq
                      $node->{<Q:TreeCore:nodeID>}) {
                    delete $parentNode->{<Q:infoset:children>}->[$i];
                    last;
                  }
                }
              }
              delete $oldChild->{<Q:TreeCore:node>}->{<Q:infoset:parent>};
              $oldChild->{<Q:TreeCore:node>}
                       ->__SUPER{ManakaiDOMNodeObject::}__::__INT{orphanate}__;
            } # @newNode
            $r = $oldChild;
     @@Level[list]:
        1
        3
     @@SpecLevel[list]:
        1
        3
  @Method:
     @@Name:  removeChild
     @@Description:
       @@@lang:en
       @@@@:
         Remove a child node from the list of children and return it.
     @@Param:
        @@@Name:  oldChild
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@: The node being removed.
     @@Return:
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@: The node removed.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: This node is read-only.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NOT_FOUND_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The "oldChild" is not a child of this node.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NOT_SUPPORTED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              This node is of type "Document" and the DOM implementation 
              does not support the removal of the "DocumentType" or 
              "Element" child.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            my $node = $self->{<Q:TreeCore:node>};
            if ($node->{<Q:DOMCore:read-only>}) {
              __EXCEPTION{
                DOMException.NO_MODIFICATION_ALLOWED_ERR:
                  <Q:MDOM_EXCEPTION:subtype> => <Q:MDOM_EXCEPTION:NOMOD_THIS>,
              }__;
            }
            my $oldChildID = ref $oldChild ?
                               $oldChild->{<Q:TreeCore:node>}
                                        ->{<Q:TreeCore:nodeID>} : '';
            FIND: {
              for my $i (0..$#{$node->{<Q:infoset:children>}}) {
                if ($node->{<Q:infoset:children>}->[$i]
                         ->{<Q:TreeCore:nodeID>} eq $oldChildID) {
                  delete $node->{<Q:infoset:children>}->[$i];
                  last FIND;
                }
              }
              __EXCEPTION{
                DOMException.NOT_FOUND_ERR:
              }__;
            }
            if (ref $oldChild) {
              $r = $oldChild;
              delete $oldChild->{<Q:TreeCore:node>}->{<Q:infoset:parent>};
              $oldChild->{<Q:TreeCore:node>}
                ->__SUPER{ManakaiDONNodeObject::}__::__INT{orphanate}__;
            }
     @@Level[list]:  3
     @@SpecLevel:3
  @Method:
     @@Name:  appendChild
     @@Description:
       @@@lang:en
       @@@@:
         Add a node to the end of the list of children of this node.
     @@Param:
        @@@Name:  newChild
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@:
            The node to add.  If it is already in the tree, 
            it is first removed.
        @@@InCase:
          @@@@Type: DocumentFragment
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The entire contents of the document fragment 
              are moved into the child list of this node. 
              The child list of the "newChild" is to be empty.
     @@Return:
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@: The node added.
        @@@ImplNote:
          @@@@lang:en
          @@@@@:
            What should be returned when the "newChild" node is a 
            "DocumentFragment" is unclear.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: HIERARCHY_REQUEST_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Either this node is of a type that does not allow 
              children of the type of the "newChild" node [DOM 1, 2, 3], 
              the node to add is one of ancestors of this node [DOM 1, 2, 3],
              the node to add is this node itself [DOM 2 Errata, 3] or 
              this node is of type "Document" and the attemption 
              to append a second "DocumentType" or "Element" node 
              is made [DOM 3].
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              Is this error raised if this node is of type "Document" and 
              it has an "Element" node but no "DocumentType" node then 
              the attemption to add a "DocumentType" is made?
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: WRONG_DOCUMENT_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The "newChild" node was created from a different document 
              than the one that created this node.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Either this node is read-only [DOM 1, 2, 3] or
              the previous (current) parent 
              of the "newChild" node is read-only [DOM 2 Errata, 3].
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NOT_SUPPORTED_ERR
          @@@@Level: 3
          @@@@SpecLevel:3
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The "newChild" node is a child of the "Document" node and 
              the DOM implementation does not support the removal of 
              the "DocumentType" or "Element" child node from the 
              "Document" node.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            my $node;
            my $newNode;
            CHKDOC: {
              if (ref $newChild and $newChild->isa ('__IIF{Node::}__')) {
                $node = $self->{<Q:TreeCore:node>};
                $newNode = $newChild->{<Q:TreeCore:node>};
                if ($node->{<Q:DOMCore:ownerDocument>}) {
                  if ($newNode->{<Q:DOMCore:ownerDocument>}) {
                    last CHKDOC if $node->{<Q:DOMCore:ownerDocument>}
                                        ->{<Q:TreeCore:nodeID>} eq
                                   $newNode->{<Q:DOMCore:ownerDocument>}
                                        ->{<Q:TreeCore:nodeID>};
                  }
                } else { ## I'm "Document" or "DocumentType" node.
                  if ($node->{<Q:DOMCore:nodeType>} eq <Q:infoset:Document>) {
                    last CHKDOC;
                  }
                }
              }
              __EXCEPTION{
                DOMException.WRONG_DOCUMENT_ERR:
                  <Q:MDOM_EXCEPTION:param-name> => 'newChild',
              }__;
            } # CHKDOC
            my @newNode = ($newNode);
            if ($newNode->{<Q:DOMCore:nodeType>} eq
                <Q:DOMCore:DocumentFragment>) {
       \       @newNode = @{$newNode->{<Q:infoset:children>}};
            }
            if (@newNode) {
              my $parentNode = $newNode[0]->{<Q:infoset:parent>};

              ## Read-only?
              if ($node->{<Q:DOMCore:read-only>}) {
                ## This node is read-only.
                __EXCEPTION{
                  DOMException.NO_MODIFICATION_ALLOWED_ERR:
                    <Q:MDOM_EXCEPTION:subtype> => <Q:MDOM_EXCEPTION:NOMOD_THIS>,
                }__;
              } elsif ($parentNode and $parentNode->{<Q:DOMCore:read-only>}) {
                ## Parent of new node(s) is read-only
                __EXCEPTION{
                  DOMException.NO_MODIFICATION_ALLOWED_ERR:
                    <Q:MDOM_EXCEPTION:subtype>
                                       => <Q:MDOM_EXCEPTION:NOMOD_SRC_PARENT>,
                    <Q:MDOM_EXCEPTION:param-name> => 'newChild',
                }__;
              }
              
              ## Check type of this node and new child node
              CHKTYPE: {
                if ({
                      <Q:infoset:Element> => 1,
                      <Q:DOMCore:DocumentFragment> => 1,
                      <Q:DOMCore:Entity> => 1,
                      <Q:DOMCore:EntityReference> => 1,
                    }->{$node->{<Q:DOMCore:nodeType>}}) {
                  CHILDTYPE: {
                    for (@newNode) {
                      unless ({
                            <Q:infoset:Element> => 1,
                            <Q:DOMCore:Text> => 1,
                            <Q:infoset:Comment> => 1,
                            <Q:infoset:ProcessingInstruction> => 1,
                            <Q:DOMCore:CDATASection> => 1,
                            <Q:DOMCore:EntityReference> => 1,
                          }->{$_->{<Q:DOMCore:nodeType>}}) {
                        last CHILDTYPE;
                      }
                    }
                    last CHKTYPE; # No problem
                  }
                } elsif ($node->{<Q:DOMCore:nodeType>} eq <Q:infoset:Document>) {
                  CHILDTYPE: {
                    my %has;
                    EACHNEWNODE: for my $newNode (@newNode) {
                      if ({
                            <Q:infoset:Element> => 1,
                            <Q:infoset:DocumentTypeDeclaration> => 1,
                          }->{$newNode->{<Q:DOMCore:nodeType>}}) {
                        FOUND: {
                          if ($has{$newNode->{<Q:DOMCore:nodeType>}}) {
                            ## DOCTYPE or document element is waiting 
                            ## to be added
                            last FOUND;
                          }
                          for (@{$node->{<Q:infoset:children>}}) {
                            ## Document already has a DOCTYPE or doc.element
                            last FOUND if $_->{<Q:DOMCore:nodeType>} eq
                                          $newNode->{<Q:DOMCore:nodeType>};
                          }
                          $has{$newNode->{<Q:DOMCore:nodeType>}} = 1;
                          next EACHNEWNODE;
                        }
                        __EXCEPTION{
                          DOMException.HIERARCHY_REQUEST_ERR:
                            <Q:MDOM_EXCEPTION:subtype>
                                 => <Q:MDOM_EXCEPTION:HIERARCHY_TOO_MANY_NODES>,
                            <Q:DOMCore:nodeType>
                                 => $newNode->{<Q:DOMCore:nodeType>},
                            <Q:MDOM_EXCEPTION:param-name> => 'newChild',
                        }__;
                      } elsif (not {
                                 <Q:infoset:Comment> => 1,
                                 <Q:infoset:ProcessingInstruction> => 1,
                               }->{$newNode->{<Q:DOMCore:nodeType>}}) {
                        last CHILDTYPE;
                      }
                    } # EACHNEWNODE
                    last CHKTYPE; # No problem
                  } # CHILDTYPE
                } elsif ($node->{<Q:DOMCore:nodeType>} eq
                         <Q:infoset:Attribute>) {
                  CHILDTYPE: {
                    for my $newNode (@newNode) {
                      unless ({
                            <Q:DOMCore:Text> => 1,
                            <Q:DOMCore:EntityReference> => 1,
                          }->{$newNode->{<Q:DOMCore:nodeType>}}) {
                        last CHILDTYPE;
                      }
                    }
                    last CHKTYPE; # No problem
                  }
                } # $node->{<Q:DOMCore:nodeType>}
                __EXCEPTION{
                  DOMException.HIERARCHY_REQUEST_ERR:
                    <Q:MDOM_EXCEPTION:subtype>
                         => <Q:MDOM_EXCEPTION:HIERARCHY_BAD_TYPE>,
                    <Q:infoset:nodeType> => $newNode->{<Q:infoset:nodeType>},
                    <Q:MDOM_EXCEPTION:param-name> => 'newChild',
                }__;
              } # CHKTYPE
              
              ## Check $newNode (not $newNode[0]) = ancestor-or-self::node()
              if ($node->{<Q:TreeCore:treeID>} eq
                  $newNode->{<Q:TreeCore:treeID>}) {
                my $n = $node;
                {
                  if ($newNode->{<Q:TreeCore:nodeID>} eq
                      $n->{<Q:TreeCore:nodeID>}) {
                    __EXCEPTION{
                      DOMException.HIERARCHY_REQUEST_ERR:
                        <Q:MDOM_EXCEPTION:subtype>
                             => <Q:MDOM_EXCEPTION:HIERARCHY_ANCESTOR_OR_SELF>,
                        <Q:MDOM_EXCEPTION:param-name> => 'newChild',
                    }__;
                  }
                  if ($n->{<Q:infoset:parent>}) {
                    $n = $n->{<Q:infoset:parent>};
                    redo;
                  }
                }
              }
              
              for my $newNode (@newNode) {
                delete $newNode->{<Q:infoset:parent>};
                $node->__SUPER{ManakaiDOMNodeObject::}__::__INT{importTree}__
                                                                 ($newNode);
                $newNode->{<Q:infoset:parent>} = $node;
              }
              push @{$node->{<Q:infoset:children>}}, @newNode;

              if ($newNode->{<Q:DOMCore:nodeType>} eq
                  <Q:DOMCore:DocumentFragment>) {
                $newNode->{<Q:infoset:children>} = [];
              } elsif ($parentNode) {
                for my $i (0..$#{$parentNode->{<Q:infoset:children>}}) {
                  if ($parentNode->{<Q:infoset:children>}->[$i]
                                 ->{<Q:TreeCore:nodeID>} eq
                      $node->{<Q:TreeCore:nodeID>}) {
                    delete $parentNode->{<Q:infoset:children>}->[$i];
                    last;
                  }
                }
              }
            } # @newNode
            $r = $newChild;
     @@Level[list]:
        1
        3
     @@SpecLevel[list]:
        1
        3
     @@ImplNote:
       @@@lang:en
       @@@@: See also the implementation note of the "insertBefore" method.
  @Method:
     @@Name:  hasChildNodes
     @@Description:
       @@@lang:en
       @@@@: Return whether this node has any children.
     @@Return:
        @@@Type:  boolean
        @@@InCase:
          @@@@Value: true
          @@@@Description:
            @@@@@lang:en
            @@@@@@: This node has any child nodes.
        @@@InCase:
          @@@@Value: false
          @@@@Description:
            @@@@@lang:en
            @@@@@@: This node does not have any child node.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            $r = @{$self->{<Q:TreeCore:node>}->{<Q:infoset:children>}}
                   ? true : false;
  @Method:
     @@Name:  cloneNode
     @@Return:
        @@@Type:  Node
     @@Param:
        @@@Name:  deep
        @@@Type:  boolean
  @Method:
     @@Name:  normalize
     @@Level[list]:
       2
       3
     @@SpecLevel[list]:
       2
       3
     @@ImplNote:
       @@@lang:en
       @@@@:
         This method was defined in the "Element" interface in the DOM 
         Level 1, but has beem moved to the "Node" interface in the 
         DOM Level 2.
     @@RedefinedBy: Element
  @Method:
     @@Name:  isSupported
     @@Return:
        @@@Type:  boolean
     @@Param:
        @@@Name:  feature
        @@@Type:  DOMString
     @@Param:
        @@@Name:  version
        @@@Type:  DOMString
     @@Level[list]:  2
     @@SpecLevel:2
  @Attr:
     @@Name:  namespaceURI
     @@Description:
       @@@lang:en
       @@@@:
         The namespace URI of this node.
       \
         Note that this is not a computed value that is the result 
         of a namespace lookup based on an examination of the 
         namespace declarations in scope, but is merely the 
         namespace URI given at creation time.
     @@Get:
        @@@Type:
          ManakaiDOM:ManakaiDOMNamespaceURI
        @@@Description:
          @@@@lang:en
          @@@@@: The namespace URI.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The namespace URI is unspecified (the "null" namespace or 
              the attribute in a per-element-type partition),
              the type of the node is other than "ELEMENT_NODE" or 
              "ATTRIBUTE_NODE", or 
              the node is created with a DOM Level 1 methods.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@: $r = null;
     @@Level[list]:  2
     @@SpecLevel:2
     @@RedefinedBy: Element
     @@RedefinedBy: Attr
  @Attr:
     @@Name:  prefix
     @@Description:
       @@@lang:en
       @@@@: The namespace prefix of this node.
     @@Get:
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The namespace prefix.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Either the namespace prefix is unspecified, the node 
              is created with a DOM Level 1 method, or the type 
              of the node is other than "ELEMENT_NODE" and 
              "ATTRIBUTE_NODE".
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@: $r = null;
     @@Set:
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            The namespace prefix.
            Note that setting this attribute has no effect if 
            the namespace prefix is defined to be "null".
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The namespace prefix is unspecified.
        @@@InCase:
          @@@@Value: \
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The result is implementation dependent.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: INVALID_CHARACTER_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The specified prefix contains an illegal character 
              accoding to the XML version in use in the document.
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              The DOM Level 2 Errata clarifies that the "illegal"ness 
              is accoding to the XML 1.0 Specification.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: This node is read-only.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NAMESPACE_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Either the specified prefix is malformed per the 
              XML Namespace specification, non-"null" prefix is 
              specified but the "namespaceURI" of this node is "null", 
              the specified prefix is "xml" and the "namespaceURI" 
              of this node is different from 
              "http://www.w3.org/XML/1998/namespace", if this 
              node is an attribute and the specified prefix is "xmlns" 
              and the "namespaceURI" of this node is different from 
              "http://www.w3.org/2000/xmlns/", or if this node is 
              an attribute and the "qualifiedName" of this node is 
              "xmlns".
        @@@Warning:
          @@@@Type:
            ManakaiDOM:ManakaiDOMImplementationWarning
          @@@@Name: ATTR_SET_NO_EFFECT
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Setting this attribute has no effect.
        @@@Def: \
     @@Level[list]:  2
     @@SpecLevel:2
     @@RedefinedBy: Attr
     @@RedefinedBy: Element
  @Attr:
     @@Name:  localName
     @@Description:
       @@@lang:en
       @@@@: The local part of the qualified name of this node.
     @@Get:
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            The local name.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The type of the node is other than "ELEMENT_NODE" or 
              "ATTRIBUTE_NODE", or the node is created with a DOM Level 1 
              methods.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@: $r = null;
     @@Level[list]:  2
     @@SpecLevel:2
     @@RedefinedBy: Element
     @@RedefinedBy: Attr
  @Method:
     @@Name:  hasAttributes
     @@Return:
        @@@Type:  boolean
     @@Level[list]:  2
     @@SpecLevel:2
  @Attr:
     @@Name:  baseURI
     @@Get:
        @@@Type:  DOMString
     @@Level[list]:  3
     @@SpecLevel:3
     @@Spec:
       @@@DOM3:
         http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#baseURIs-Considerations
  @ConstGroup:
     @@Name:  DocumentPosition
     @@Description:
       @@@lang:en
       @@@@:
         A bitmask indicating the relative document position of a node 
         with respect to another node.
     @@Level: 3
     @@SpecLevel:3
     @@Const:
        @@@Name:  DOCUMENT_POSITION_DISCONNECTED
        @@@Type:  unsigned-short
        @@@Value:  0x01
        @@@Description:
          @@@@lang:en
          @@@@@:
            The two nodes are disconnected.  Order between disconnected nodes 
            is always implementation-specific.
     @@Const:
        @@@Name:  DOCUMENT_POSITION_PRECEDING
        @@@Type:  unsigned-short
        @@@Value:  0x02
        @@@Description:
          @@@@lang:en
          @@@@@:
            The node precedes the reference node.
     @@Const:
        @@@Name:  DOCUMENT_POSITION_FOLLOWING
        @@@Type:  unsigned-short
        @@@Value:  0x04
        @@@Description:
          @@@@lang:en
          @@@@@: The node fllows the reference node.
     @@Const:
        @@@Name:  DOCUMENT_POSITION_CONTAINS
        @@@Type:  unsigned-short
        @@@Value:  0x08
        @@@Description: 
          @@@@lang:en
          @@@@@:
            The node contains the reference node.  A node that 
            contains is always preceding, too.
     @@Const:
        @@@Name:  DOCUMENT_POSITION_CONTAINED_BY
        @@@Type:  unsigned-short
        @@@Value:  0x10
        @@@Description:
          @@@@lang:en
          @@@@@:
            The node is contained by the reference node. 
            A node that is contained is always following, too.
     @@Const:
        @@@Name:  DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC
        @@@Type:  unsigned-short
        @@@Value:  0x20
        @@@Description:
          @@@@lang:en
          @@@@@:
            The determination of preceding versus following is 
            implementation-specific.
  @Method:
     @@Name:  compareDocumentPosition
     @@Return:
        @@@Type:  unsigned-short
        @@@Exception[list]:  DOMException
     @@Param:
        @@@Name:  other
        @@@Type:  Node
     @@Level[list]:  3
     @@SpecLevel:3
  @Attr:
     @@Name:  textContent
     @@Description:
       @@@lang:en
       @@@@:
         The text content of this node and its descendants. 
         Note that element content whitespaces are not considered 
         as the text content of an "Element".
     @@Get:
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            The text content of this node.
        @@@InCase:
          @@@@Label: Concatenation of the text content of child nodes
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
            For the node of type "Element", "Attr", "Entity", 
            "EntityReference" or "DocumentFragment",  
            concatenation of the "textContent" value of every 
            child node, excluding of type "Comment" or 
            "ProcessingInstruction", is the text content.
        @@@InCase:
          @@@@Label: "nodeValue"
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              For the node of type "Text", "CDATASection", 
              "Comment" or "ProcessingInstruction", the text content 
              is same as the value of the attribute "nodeValue".
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              For the node of type "Document", "DocumentType" or 
              "Notation", the text content is defined to be "null".
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: DOMSTRING_SIZE_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The attribute would return more characters than 
              fit in a "DOMString" variable on the implementation 
              platform.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            $r = $self->{<Q:TreeCore:node>}
                  ->__SUPER{ManakaiDOMNodeObjectNode::}__::__INT{textContent}__;
     @@Set:
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            Any child nodes of this node are removed and 
            replaced by a single "Text" node containing the string 
            specified.
          \
            Note that when the "textContent" is defined to be "null", 
            setting the value has no effect.
        @@@InCase:
          @@@@Value:\
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Any child nodes are removed if the value is not defined to 
              be "null".
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: 
              Any child nodes are removed if the value is not defined 
              to be "null".
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Descriptin:
            @@@@@lang:en
            @@@@@@: This node is read-only.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            my $node = $self->{<Q:TreeCore:node>};
            if ($node->{<Q:DOMCore:read-only>}) {
              __EXCEPTION{
                DOMException.NO_MODIFICATION_ALLOWED_ERR:
                  <Q:MDOM_EXCEPTION:subtype> => <Q:MDOM_EXCEPTION:THIS>,
              }__;
            }
            my @oldChild = @{$node->{<Q:infoset:children>}};
            for (@oldChild) {
              delete $_->{<Q:infoset:parent>};
            }
                           ## Condition sensitive
            my $textNode = __CLASS{Text}__->__INT{newObject}__;
            $textNode->{<Q:infoset:content>} = $given;
            $node->{<Q:infoset:children>} = [$textNode];
            for (@oldChild) {
              $_->__SUPER{ManakaiDOMNodeObject}__::__INT{orphanate}__;
            }
     @@Level[list]:
        3
     @@SpecLevel:3
     @@RedefinedBy: Document
     @@RedefinedBy: DocumentType
     @@RedefinedBy: Notation
     @@RedefinedBy: CharacterData
     @@RedefinedBy: ProcessingInstrction
  @Method:
     @@Name:  isSameNode
     @@Description:
        @@@lang:en
        @@@@:
          Return whether this node is the same node as the given one.
        \
          When two "Node" references are references to the same object, 
          even if through a proxy, the references may be used completely 
          interchangably, such that all attributes have the same values 
          and calling the same method on either reference always has 
          exactly same effect.
     @@Operator:
        @@@@: eq
        @@@Type:
          lang:Perl
     @@Param:
        @@@Name:  other
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@: The node to test against.
     @@Return:
        @@@Type:  boolean
        @@@InCase:
          @@@@Value: true
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The two nodes are the same.
        @@@InCase:
          @@@@Value: false
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The two nodes are not same.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            if (ref $other and
                $other->isa ('__IIF{ManakaiDOMNodeReference::}__') and
                $other->{<Q:TreeCore:node>}->{<Q:TreeCore:nodeID>}
                  eq $self->{<Q:TreeCore:node>}->{<Q:TreeCore:nodeID>}) {
              $r = true;
            }
     @@Level[list]:  3
     @@SpecLevel:3
  @Method:
     @@Name:  lookupPrefix
     @@Return:
        @@@Type:  DOMString
     @@Param:
        @@@Name:  namespaceURI
        @@@Type:
          ManakaiDOM:ManakaiDOMNamespaceURI
     @@Level[list]:  3
     @@SpecLevel:3
  @Method:
     @@Name:  isDefaultNamespace
     @@Return:
        @@@Type:  boolean
     @@Param:
        @@@Name:  namespaceURI
        @@@Type:
          ManakaiDOM:ManakaiDOMNamespaceURI
     @@Level[list]:  3
     @@SpecLevel:3
  @Method:
     @@Name:  lookupNamespaceURI
     @@Return:
        @@@Type:
          ManakaiDOM:ManakaiDOMNamespaceURI
     @@Param:
        @@@Name:  prefix
        @@@Type:  DOMString
     @@Level[list]:  3
     @@SpecLevel:3
  @Method:
     @@Name:  isEqualNode
     @@Operator:
       @@@@: ==
       @@@Type:
          lang:Perl
     @@Return:
        @@@Type:  boolean
     @@Param:
        @@@Name:  arg
        @@@Type:  Node
     @@Level[list]:  3
     @@SpecLevel:3
  @Method:
     @@Name:  getFeature
     @@Return:
        @@@Type:  DOMObject
     @@Param:
        @@@Name:  feature
        @@@Type:  DOMString
     @@Param:
        @@@Name:  version
        @@@Type:  DOMString
     @@Level[list]:  3
     @@SpecLevel:3
  @Method:
     @@Name:  setUserData
     @@Return:
        @@@Type:  DOMUserData
     @@Param:
        @@@Name:  key
        @@@Type:  DOMString
     @@Param:
        @@@Name:  data
        @@@Type:  DOMUserData
     @@Param:
        @@@Name:  handler
        @@@Type:  UserDataHandler
     @@Level[list]:  3
     @@SpecLevel:3
  @Method:
     @@Name:  getUserData
     @@Return:
        @@@Type:  DOMUserData
     @@Param:
        @@@Name:  key
        @@@Type:  DOMString
     @@Level[list]:  3
     @@SpecLevel:3

  @IntMethod:
    @@Name: newObject
    @@Description:
      @@@lang:en
      @@@@: Construct an object for a new instance of the "Node".
    @@Return:
      @@@Type:
        ManakaiDOM:ManakaiDOMNodeObject
      @@@Description:
        @@@@lang:en
        @@@@@: The object for the "Node" to be created.
      @@@Def:
        @@@@Type:
          lang:Perl
        @@@@@:
          my $node = $r = __CLASS{ManakaiDOMNodeObject::}__->__INT{new}__;
          push @{$node->{<Q:TreeCore:origin>}}, <Q:infoset:parent>;
          push @{$node->{<Q:TreeCore:subnode>}}, <Q:infoset:children>;
          push @{$node->{<Q:TreeCore:irefnode>}}, <Q:DOMCore:ownerDocument>;
          $node->{<Q:infoset:children>} = [];
          $node->{<Q:DOMCore:hasFeature>}->{XML} = true;
              ## More consideration required for the feature
       @@@ImplNote:
         @@@@lang:en
         @@@@@:
           Other properties required to be a legal "Node" object:
           DOMCore:nodeType.
         \
           Optional properties: infoset:localName, infoset:prefix,
           DOMCore:ownerDocument, infoset:namespaceName, DOMCore:name,
           DOMCore:read-only.

  @IntMethod:
    @@Name: getNodeReference
    @@Description:
      @@@lang:en
      @@@@:
        Create a new "Node" object blessed with the appropriate class.
      \
        To create a new "Document", use the internal method 
        "newByDocumentType" of the "Document" interface.
    @@Param:
      @@@Name: object
      @@@Type:
        ManakaiDOM:ManakaiDOMNodeObject
      @@@Description:
        @@@@lang:en
        @@@@@: The node object referred to.
    @@Return:
      @@@Type: Node
      @@@Description:
        @@@@lang:en
        @@@@@: The node reference.
      @@@Def:
        @@@@Type:
          lang:Perl
        @@@@@:
          my $nt = $object->{<Q:DOMCore:nodeType>};
                        ## Condition sensitive
          my $class = q<__CLASS{Node}__>;
          if ($nt eq <Q:infoset:Element>) {
            ## TODO: Find class by namespace URI and local name
                       ## Condition sensitive
            $class = q<__CLASS{Element}__>;
          } elsif ($nt eq <Q:infoset:Attribute>) {
            ## TODO: Find class by namespace URI and local name
                       ## Condition sensitive
            $class = q<__CLASS{Attr}__>;
          } elsif ($nt eq <Q:DOMCore:Text>) {
                       ## Condition sensitive
            $class = q<__CLASS{Text}__>;
          } elsif ($nt eq <Q:infoset:Comment>) {
                       ## Condition sensitive
            $class = q<__CLASS{Comment}__>;
          } elsif ($nt eq <Q:infoset:Document>) {
            ## TODO: Find class by doctype
                       ## Condition sensitive
            $class = q<__CLASS{Document}__>;
          } elsif ($nt eq <Q:DOMCore:DocumentFragment>) {
                       ## Condition sensitive
            $class = q<__CLASS{DocumentFragment}__>;
          } elsif ($nt eq <Q:DOMCore:EntityReference>) {
                       ## Condition sensitive
            $class = q<__CLASS{EntityReference}__>;
          } elsif ($nt eq <Q:infoset:ProcessingInstruction>) {
            ## TODO: Find class by namespace URI and local name
                       ## Condition sensitive
            $class = q<__CLASS{ProcessingInstruction}__>;
          } elsif ($nt eq <Q:DOMCore:Entity>) {
                       ## Condition sensitive
            $class = q<__CLASS{Entity}__>;
          } elsif ($nt eq <Q:DOMCore:CDATASection>) {
                       ## Condition sensitive
            $class = q<__CLASS{CDATASection}__>;
          } elsif ($nt eq <Q:infoset:Notation>) {
                       ## Condition sensitive
            $class = q<__CLASS{Notation}__>;
          } else {
            __EXCEPTION{
              ManakaiDOMImplementationException.MDOM_DEBUG_BUG: 
                <Q:MDOM_EXCEPTION:values> => {
                  <Q:DOMCore:nodeType> => $nt,
                },
            }__;
          }
          $r = $object->__SUPER{ManakaiDOMNodeObject::}__::__INT{newReference}__
                                                                      ($class);
    @@Level[list]:
       1
       2
       3

## IF: Node

IF:
  @Name:  NodeList
  @Description:
    @@lang:en
    @@@:
      An ordered collection of nodes.  Objects contained in 
      a "NodeList" may be accessed by an ordinal index, starting from zero.
    \
      "NodeList" objects are live.
  @ImplNote:
    @@lang:en
    @@@:
      How this collection is implemented is not defined or constrained.
  @ImplNote:
    @@lang:en
    @@@:
      The actual process of the method and the attribute in this 
      interface is not defined here, since each use of this interface 
      requires different treatment of it to be live object. 
    \
      See also "ManakaiDOMCore" module.
  @Method:
     @@Name:  item
     @@Description:
       @@@lang:en
       @@@@:
         Return an item in the collection.
     @@Param:
        @@@Name:  index
        @@@Type:  unsigned-long
        @@@Description:
          @@@@lang:en
          @@@@@: The index of the item into the collection.
     @@Return:
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@: 
            The node at the "index"th position in the collection.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The "index" is invalid, i.e. it is greater than or 
              equal to the number of nodes in the list.
        @@@Def:
          @@@@Type:
            lang:dis
          @@@@Overridden:1
    @@RedefinedBy:
      ManakaiDOMCore:ManakaiDOMChildNodeList
    @@RedefinedBy:
      ManakaiDOMCore:ManakaiDOMGetElementsNodeList
  @Attr:
     @@Name:  length
     @@Description:
       @@@lang:en
       @@@@:
         The number of nodes in the list.
     @@Get:
        @@@Type:  unsigned-long
        @@@Def:
          @@@@Type:
             lang:dis
          @@@@Overridden:1
    @@RedefinedBy:
      ManakaiDOMCore:ManakaiDOMChildNodeList
    @@RedefinedBy:
      ManakaiDOMCore:ManakaiDOMGetElementsNodeList

IF:
  @Name:  NamedNodeMap
  @Description:
    @@lang:en
    @@@:
      A collection of nodes that can be accessed by name.  The 
      "NamedNodeMap" is not maintained in any particular order.  
      Objects contained in a "NamedNodeMap" may also be accessed 
      by an ordinal index, starting from zero, but this is simply 
      to allow convenient enumeration of the contents of a "NamedNodeMap" 
      and does not imply that the DOM specifies an order to these objects.
   \
      "NamedNodeMap" objects are live.
  @ImplNote:
    @@lang:en
    @@@:
      The actual process of methods and the attribute in this 
      interface is not defined here, since each use of this interface 
      requires different treatment of it to be live object. 
    \
      See also "ManakaiDOMCore" and "ManakaiDOMXML" modules.
  @Method:
     @@Name:  getNamedItem
     @@Description:
       @@@lang:en
       @@@@: Retrive a node specified by name.
     @@Param:
        @@@Name:  name
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The "nodeName" of a node to retrive.
     @@Return:
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@:
            A "Node" (of any type) with the specified "nodeName".
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The "name" does not identify any node in this map.
        @@@Def:
          @@@@Type:
            lang:dis
          @@@@Overridden:1
    @@RedefinedBy:
      ManakaiDOMCore:ManakaiDOMAttributes 
    @@RedefinedBy:
      ManakaiDOMXML:ManakaiDOMEntities
    @@RedefinedBy:
      ManakaiDOMXML:ManakaiDOMNotations
  @Method:
     @@Name:  setNamedItem
     @@Description:
       @@@lang:en
       @@@@:
         Add a node using its "nodeName" attribute.  If a node with 
         that name is already present in this map, it is replaced 
         by the new one.  Replacing a node by itself has no effect.
     @@ImplNote:
       @@@lang:en
       @@@@: "Replacing ... no effect" is clarified by the DOM Level 2 Errata. 
     @@Param:
        @@@Name:  arg
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@: A node to store in this map.
     @@Return:
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@:
            If the "arg" node replaces an existing node, the replaced node.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The "arg" node does not replace any node in the map.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: WRONG_DOCUMENT_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The "arg" node was created from a different document.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: This map is read-only.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: INUSE_ATTRIBUTE_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The "arg" node is an "Attr" that is already an 
              attribute of another "Element" object.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: HIERARCHY_REQUEST_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              An attempt is made to add a node that is unable to 
              belong to this map.
          @@@@SpecLevel:2
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@: This exception has added by the DOM Level 2 Errata.
        @@@Def:
          @@@@Type:
            lang:dis
          @@@@Overridden:1
     @@ImplNote:
       @@@lang:en
       @@@@:
         Is it possible to add the node that has namespace URI and local 
         name?  If it is, can that node be retrived via the "NS" methods? 
         Is it possible to add the node that has "nodeName" crushing 
         with existing "NS" node?
    @@RedefinedBy:
      ManakaiDOMCore:ManakaiDOMAttributes 
    @@RedefinedBy:
      ManakaiDOMXML:ManakaiDOMEntities
    @@RedefinedBy:
      ManakaiDOMXML:ManakaiDOMNotations
  @Method:
     @@Name:  removeNamedItem
     @@Description:
        @@@lang:en
        @@@@:
          Remove a node specified by name.
     @@Param:
        @@@Name:  name
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The "nodeName" of the node to remove.
     @@Return:
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@: The node removed from this map.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NOT_FOUND_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: There is no node named "name" in this map.
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              The DOM Level 1 First Edition also said that if there 
              is no node named "name", "null" is returned.  It has 
              removed by the DOM Level 1 First Edition Errata.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: This map is read-only.
          @@@@SpecLevel:1
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              This exception is added by the DOM Level 1 First Edition Errata.
        @@@Def:
          @@@@Type:
            lang:dis
          @@@@Overridden:1
    @@RedefinedBy:
      ManakaiDOMCore:ManakaiDOMAttributes 
    @@RedefinedBy:
      ManakaiDOMXML:ManakaiDOMEntities
    @@RedefinedBy:
      ManakaiDOMXML:ManakaiDOMNotations
  @Method:
     @@Name:  item
     @@Description:
       @@@lang:en
       @@@@: Return an item in the map.
     @@Param:
        @@@Name:  index
        @@@Type:  unsigned-long
        @@@Description:
          @@@@lang:en
          @@@@@: The index of the item into this map.
     @@Return:
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@: The node at the "index"th position in the map.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: 
              The "index" is invalid, i.e. it is greater than or 
              equal to the number of nodes in this map.
        @@@Def:
          @@@@Type:
            lang:dis
          @@@@Overridden:1
    @@RedefinedBy:
      ManakaiDOMCore:ManakaiDOMAttributes 
    @@RedefinedBy:
      ManakaiDOMXML:ManakaiDOMEntities
    @@RedefinedBy:
      ManakaiDOMXML:ManakaiDOMNotations
  @Attr:
     @@Name:  length
     @@Description:
       @@@lang:en
       @@@@: The number of nodes in this map.
     @@Get:
        @@@Type:  unsigned-long
        @@@Def:
          @@@@Type:
            lang:dis
          @@@@Overridden:1
    @@RedefinedBy:
      ManakaiDOMCore:ManakaiDOMAttributes 
    @@RedefinedBy:
      ManakaiDOMXML:ManakaiDOMEntities
    @@RedefinedBy:
      ManakaiDOMXML:ManakaiDOMNotations
  @Method:
     @@Name:  getNamedItemNS
     @@Description:
       @@@lang:en
       @@@@:
         Retrive a node specified by local name and namespace URI.
     @@Param:
        @@@Name:  namespaceURI
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            The namespace URI of the node to retrive.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The node to retrive has no namespace.
     @@Param:
        @@@Name:  localName
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The local name of the node to retrive.
     @@Return:
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@:
            A "Node" (of any type) with the specified local name and 
            namespace URI.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The "namespaceURI" and "localName" does not identify 
              any node in this map.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NOT_SUPPORTED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The DOM implementation does not support the feature "XML" and 
              the language exposed through the "Document" does not 
              support XML Namespaces.
         @@@Def:
           @@@@Type:
             lang:dis
           @@@@Overridden:1
     @@Level[list]:  2
     @@SpecLevel:2
     @@ImplNote:
       @@@lang:en
       @@@@:
         The DOM Level 2 Specification said that the HTML-only DOM 
         implenentations do not need to implement this method. 
         The DOM Level 2 Errata and the DOM Level 3 Specification 
         says that the NOT_SUPPORTED_ERR should be raised.
    @@RedefinedBy:
      ManakaiDOMCore:ManakaiDOMAttributes 
    @@RedefinedBy:
      ManakaiDOMXML:ManakaiDOMEntities
    @@RedefinedBy:
      ManakaiDOMXML:ManakaiDOMNotations
  @Method:
     @@Name:  setNamedItemNS
     @@Description:
       @@@lang:en
       @@@@:
         Add a node using its "namespaceURI" and "localName". 
         If a node with that namespace URI and that local name 
         is already present in this map, it is replaced by the new one. 
         Replacing a node by itself has no effect.
     @@ImplNote:
       @@@lang:en
       @@@@: "Replacing ... no effect" is clarified by the DOM Level 2 Errata. 
     @@Param:
        @@@Name:  arg
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@: A node to store in this map.
     @@Return:
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@:
            If the "arg" node replaces an existing node, the replaced node.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The "arg" node replaces no existing node in this map.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: WRONG_DOCUMENT_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The "arg" node was created from a different document.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: This map is read-only.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: INUSE_ATTRIBUTE_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The "arg" node is an "Attr" that is already an 
              attribute of another "Element" object.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: HIERARCHY_REQUEST_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              An attempt is made to add a node that is unable to 
              belong to this map.
          @@@@SpecLevel:2
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@: This exception has added by the DOM Level 2 Errata.
         @@@Exception:
           @@@@Type: DOMException
           @@@@Name: NOT_SUPPORTED_ERR
           @@@@Description:
             @@@@@lang:en
             @@@@@@:
             The DOM implementation does not support the feature "XML" and 
             the language exposed through the "Document" does not 
             support XML Namespaces
           @@@@SpecLevel:2
         @@@Def:
           @@@@Type:
             lang:dis
           @@@@Overridden:1
     @@ImplNote:
       @@@lang:en
       @@@@:
         The DOM Level 2 Specification said that the HTML-only DOM 
         implenentations do not need to implement this method. 
         The DOM Level 2 Errata and the DOM Level 3 Specification 
         says that the NOT_SUPPORTED_ERR should be raised.
     @@Level[list]:  2
     @@SpecLevel:2
    @@RedefinedBy:
      ManakaiDOMCore:ManakaiDOMAttributes 
    @@RedefinedBy:
      ManakaiDOMXML:ManakaiDOMEntities
    @@RedefinedBy:
      ManakaiDOMXML:ManakaiDOMNotations
  @Method:
     @@Name:  removeNamedItemNS
     @@Description:
        @@@lang:en
        @@@@:
          Remove a node specified by local name and namespace URI.
     @@Param:
        @@@Name:  namespaceURI
        @@@Type:
          ManakaiDOM:ManakaiDOMNamespaceURI
        @@@Description:
          @@@@lang:en
          @@@@@: The namespace URI of the node to remove.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The node to remove has no namespace.
     @@Param:
        @@@Name:  localName
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The local name of the node to remove.
     @@Return:
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@: The node removed from this map.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NOT_FOUND_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              There is no node with the specified "namespaceURI" and 
              "localName" in the map.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: This map is read-only.
         @@@Exception:
           @@@@Type: DOMException
           @@@@Name: NOT_SUPPORTED_ERR
           @@@@Description:
             @@@@@lang:en
             @@@@@@:
             The DOM implementation does not support the feature "XML" and 
             the language exposed through the "Document" does not 
             support XML Namespaces
         @@@Def:
           @@@@Type:
             lang:dis
           @@@@Overridden:1
     @@ImplNote:
       @@@lang:en
       @@@@:
         The DOM Level 2 Specification said that the HTML-only DOM 
         implenentations do not need to implement this method. 
         The DOM Level 2 Errata and the DOM Level 3 Specification 
         says that the NOT_SUPPORTED_ERR should be raised.
     @@Level[list]:  2
     @@SpecLevel:2
    @@RedefinedBy:
      ManakaiDOMCore:ManakaiDOMAttributes 
    @@RedefinedBy:
      ManakaiDOMXML:ManakaiDOMEntities
    @@RedefinedBy:
      ManakaiDOMXML:ManakaiDOMNotations
## IF:NamedNodeMap

IF:
  @Name:  CharacterData
  @ISA: Node
  @ImplNote:
    @@lang:en
    @@@:
      The DOM implementation may not put arbitary limits on the 
      amount of the data that may be stored in a "CharacterData" node. 
      However, the implementation limits may mean that the entirety of 
      a node's data may not fit into a single "DOMString".
  @ImplNote:
    @@lang:en
    @@@:
      "Comment" and "Text" are "CharacterData".  "CDATASection" is a "Text".
  @Attr:
     @@Name:  data
     @@Description:
       @@@lang:en
       @@@@: The character data of the node.
     @@Get:
        @@@Type:  DOMString
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: DOMSTRING_SIZE_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The attribute would return more characters than 
              fit in a "DOMString" variable on the implementation 
              platform.
        @@@Def:
          @@@@Type:
            lang:dis
          @@@@GetProp:
            infoset:content
     @@Set:
        @@@Type:  DOMString
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The node is read-only.
        @@@Def:
          @@@@Type:
            lang:dis
          @@@@SetProp:
            @@@@@@:
              infoset:content
            @@@@@CheckReadOnly:1
  @IntMethod:
    @@Name: getDOMStringValue
    @@Description:
      @@@lang:en
      @@@@: Get the value as DOMString.
    @@Return:
      @@@Type: DOMString
      @@@Def:
        @@@@Type:
          lang:Perl
        @@@@@:
          if (ref $self->{<Q:TreeCore:node>}->{<Q:infoset:content>} and
              $self->{<Q:TreeCore:node>}->{<Q:infoset:content>}
                   ->isa ('__IIF{DOMString::}__')) {
            $r = $self->{<Q:TreeCore:node>}->{<Q:infoset:content>};
          } else {
            $r = \$self->{<Q:TreeCore:node>}->{<Q:infoset:content>};
            if (defined $$r) {
              __CODE{DOMString: s => r, r => r}__;
            } else {
              $r = null;
            }
          }
  @Attr:
     @@Name:  length
     @@Description:
       @@@lang:en
       @@@@: 
         The number of 16-bit units of the "data".
     @@Get:
        @@@Type:  unsigned-long
        @@@Description:
          @@@@lang:en
          @@@@@: The number of 16-bit units of the "data".
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            __INT{{getDOMStringValue}}__;
            if (defined $r) {
              __DEEP{
                $r = $r->length;
              }__;
            } else {
              $r = 0;
            }
  @Method:
     @@Name:  substringData
     @@Description:
       @@@lang:en
       @@@@:
         Extract a range of data from the node.
     @@Param:
        @@@Name:  offset
        @@@Type:  unsigned-long
        @@@Description:
          @@@@lang:en
          @@@@@: Start offset of substring to extract.
     @@Param:
        @@@Name:  count
        @@@Type:  unsigned-long
        @@@Description:
          @@@@lang:en
          @@@@@:
          The number of 16-bit units to extract.  If the sum of the
          parameters offset and count exceeds the length of the
          DOMString then all 16-bit units from offset to the end
          of the DOMString are returned.
    @@Return:
      @@@Type: DOMString
      @@@Description:
        @@@@lang:en
        @@@@@: The specified substring.
      @@@Exception:
        @@@@Type: DOMException
        @@@@Name: INDEX_SIZE_ERR
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The specified "offset" is negative or greater than
            the number of 16-bit units in the "DOMString", or the specified
            "count" is negative.
      @@@Exception:
        @@@@Type: DOMException
        @@@@Name: DOMSTRING_SIZE_ERR
        @@@@Description:
          @@@@@lang:en
          @@@@@@: The specified range does not fit into a "DOMString".
      @@@Exception:
        @@@@Type: 
          ManakaiDOM:ManakaiDOMImplementationException
        @@@@Name: MDOM_INDEX_IN_SURROGATE_PAIR
        @@@@Description:
          @@@@@lang:en
          @@@@@@: An attempt is made to break surrogate pair.
      @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            __INT{{getDOMStringValue}}__;
            __DEEP{
              $r = $r->__INT{substring}__ ($offset, $count);
            }__;
  @Method:
     @@Name:  appendData
     @@Description:
       @@@lang:en
       @@@@:
         Append the string to the end of the character data of the node.
     @@Param:
        @@@Name:  arg
        @@@Type:  DOMString
        @@@Descroption:
          @@@@lang:en
          @@@@@: The string to append.
     @@Return:
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: This node is read-only.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            my $node = $self->{<Q:TreeCore:node>};
            if ($node->{<Q:DOMCore:read-only>}) {
              __EXCEPTION{
                DOMException.NO_MODIFICATION_ALLOWED_ERR:
                  <Q:MDOM_EXCEPTION:subtype> => <Q:MDOM_EXCEPTION:NOMOD_THIS>,
              }__;
            }
            $node->{<Q:infoset:content>} .= $arg;
  @Method:
     @@Name:  insertData
     @@Description:
       @@@lang:en
       @@@@: Insert a string at the specified 16-bit unit offset. 
    @@Param:
      @@@Name: offset
      @@@Type: unsigned-long
      @@@Description:
        @@@@lang:en
        @@@@@: The offset from which to insert.
    @@Param:
      @@@Name: arg
      @@@Type: DOMString
      @@@Description:
        @@@@lang:en
        @@@@@: The DOMString to insert.
    @@Return:
      @@@Exception:
        @@@@Type: DOMException
        @@@@Name: INDEX_SIZE_ERR
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The specified "offset" is negative or greater than
            the number of 16-bit units in the DOMString.
      @@@Exception:
        @@@@Type: DOMException
        @@@@Name: NO_MODIFICATION_ALLOWED_ERR
        @@@@Description:
          @@@@@lang:en
          @@@@@@: This node is read-only.
      @@@Exception:
        @@@@Type: 
          ManakaiDOM:ManakaiDOMImplementationException
        @@@@Name: MDOM_INDEX_IN_SURROGATE_PAIR
        @@@@Description:
          @@@@@lang:en
          @@@@@@: An attempt is made to break surrogate pair.
      @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
          if ($self->{<Q:TreeCore:node>}->{<Q:DOMCore:read-only>}) {
            __EXCEPTION{
              DOMException.NO_MODIFICATION_ALLOWED_ERR:
                <Q:MDOM_EXCEPTION:subtype> => <Q:MDOM_EXCEPTION:NOMOD_THIS>,
            }__;
          }
          my $r;
            __INT{{getDOMStringValue}}__;
            __DEEP{
              $r = $r->__INT{insert}__ ($offset, $arg);
            }__;
  @Method:
     @@Name:  deleteData
     @@Description:
        @@@lang:en
        @@@@: 
          Remove a range of 16-bit units from the node.
    @@Param:
      @@@Name: offset
      @@@Type: unsigned-long
      @@@Description:
        @@@@lang:en
        @@@@@: The offset from which to start removing.
    @@Param:
      @@@Name: count
      @@@Type: unsigned-long
      @@@Description:
        @@@@lang:en
        @@@@@:
          The number of 16-bit units to delete.  If the sum of the
          parameters offset and count exceeds the length of the
          DOMString then all 16-bit units from offset to the end
          of the DOMString are deleted.
    @@Return:
      @@@Exception:
        @@@@Type: DOMException
        @@@@Name: INDEX_SIZE_ERR
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The specified "offset" is negative or greater than
            the number of 16-bit units in the DOMString, or the specified
            "count" is negative.
      @@@Exception:
        @@@@Type: DOMException
        @@@@Name: NO_MODIFICATION_ALLOWED_ERR
        @@@@Description:
          @@@@@lang:en
          @@@@@@: This node is read-only.
      @@@Exception:
        @@@@Type: 
          ManakaiDOM:ManakaiDOMImplementationException
        @@@@Name: MDOM_INDEX_IN_SURROGATE_PAIR
        @@@@Description:
          @@@@@lang:en
          @@@@@@: 
            An attempt is made to break surrogate pair.
      @@@Def:
        @@@@Type:
          lang:Perl
        @@@@@:
          if ($self->{<Q:TreeCore:node>}->{<Q:DOMCore:read-only>}) {
            __EXCEPTION{
              DOMException.NO_MODIFICATION_ALLOWED_ERR:
                <Q:MDOM_EXCEPTION:subtype> => <Q:MDOM_EXCEPTION:NOMOD_THIS>,
            }__;
          }
          my $r;
            __INT{{getDOMStringValue}}__;
            __DEEP{
              $r->__INT{delete}__ ($offset, $count);
            }__;
  @Method:
    @@Name:  replaceData
    @@Description:
      @@@lang:en
      @@@@:
        Replace the characters starting at the specified 16-bit unit 
        offset with the specified string.
    @@Param:
      @@@Name: offset
      @@@Type: unsigned-long
      @@@Description:
        @@@@lang:en
        @@@@@: The offset from which to start replacing.
    @@Param:
      @@@Name: count
      @@@Type: unsigned-long
      @@@Description:
        @@@@lang:en
        @@@@@:
          The number of 16-bit units to replace.  If the sum of the
          parameters offset and count exceeds the length of the
          DOMString then all 16-bit units from offset to the end
          of the DOMString are replaced.
    @@Param:
      @@@Name: arg
      @@@Type: DOMString
      @@@Description:
        @@@@lang:en
        @@@@@: The DOMString with which the range is replaced.
    @@Return:
      @@@Exception:
        @@@@Type: DOMException
        @@@@Name: INDEX_SIZE_ERR
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The specified "offset" is negative or greater than
            the number of 16-bit units in the DOMString, or the specified
            "count" is negative.
      @@@Exception:
        @@@@Type: DOMException
        @@@@Name: NO_MODIFICATION_ALLOWED_ERR
        @@@@Description:
          @@@@@lang:en
          @@@@@@: This node is read-only.
      @@@Exception:
        @@@@Type: 
          ManakaiDOM:ManakaiDOMImplementationException
        @@@@Name: MDOM_INDEX_IN_SURROGATE_PAIR
        @@@@Description:
          @@@@@lang:en
          @@@@@@: An attempt is made to break surrogate pair.
      @@@Def:
        @@@@Type:
          lang:Perl
        @@@@@:
          if ($self->{<Q:TreeCore:node>}->{<Q:DOMCore:read-only>}) {
            __EXCEPTION{
              DOMException.NO_MODIFICATION_ALLOWED_ERR:
                <Q:MDOM_EXCEPTION:subtype> => <Q:MDOM_EXCEPTION:NOMOD_THIS>,
            }__;
          }
          my $r;
            __INT{{getDOMStringValue}}__;
            __DEEP{
              $r = $r->__INT{replace}__ ($offset, $count, $arg);
            }__;
  @ReAttr:
     @@Name:  nodeValue
     @@Description:
       @@@lang:en
       @@@@: The value of this node.
     @@Get:
        @@@Type:  DOMString
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: DOMSTRING_SIZE_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: 
              The node value, i.e. same as "data".
        @@@Def:
          @@@@Type: 
            lang:Perl
          @@@@@: __INT{{data}}__;
     @@Set:
        @@@Type:  DOMString
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: 
              The node is read-only.
        @@@Description:
          @@@@lang:en
          @@@@@:
            New node value.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
                           ## Condition sensitive
            __DEEP{ $self->__SUPER{CharacterData}__::data ($given) }__;
    @@Redefine: Node
    @@Level[list]:
      1
      2
      3
    @@SpecLevel:1
  @ReAttr:
     @@Name:  textContent
     @@Description:
       @@@lang:en
       @@@@: The text content of this node and its descendants.
     @@ImplNote:
        @@@lang:en
        @@@@:
          CharacterData->data == CharacterData->nodeValue == 
          CharacterData->textContent.
     @@Get:
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            The text content of this node, i.e. the "nodeValue".
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: DOMSTRING_SIZE_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The attribute would return more characters than 
              fit in a "DOMString" variable on the implementation 
              platform.
        @@@Def:
          @@@@Type: 
            lang:Perl
          @@@@@: __INT{{data}}__;
     @@Set:
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            The new text content of the node.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: 
              The text content is set to the empty.  Note that the 
              DOM specification does not specify how to treat the "null".
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Descriptin:
            @@@@@lang:en
            @@@@@@: This node is read-only.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
                           ## Condition sensitive
            __DEEP{ $self->__SUPER{CharacterData}__::data ($given) }__;
     @@Level[list]:
        3
     @@SpecLevel:3
     @@Redefine: Node
## IF: CharacterData

IF:
  @Name:  Attr
  @Description:
    @@lang:en
    @@@:
      An attribute in an "Element" object.
    \
      The DOM Core treats the attribute values as a plain string, even if 
      the schema language defines them as having tokenized types.
  @ISA:  Node
  @Require:
    @@Module:
      @@@Def:
        @@@@Type:
          lang:Perl
        @@@@use: 
          @@@@@@:
            Char::Class::XML
          @@@@@Import[list]:
            InXML_NameStartChar10
            InXMLNameChar10
            InXMLNameStartChar11
            InXMLNameChar11
      @@@Condition[list]:
        DOM2
        DOM3
  @ImplNote:
    @@lang:en
    @@@:
      If the implementation knows about the schema in use when 
      the attribute value is changed, and it is of a different type 
      than "CDATA", it may normalize it at that time. [SVG DOM, DOM 3]
  @Attr:
     @@Name:  name
     @@Description:
       @@@lang:en
       @@@@: The name of this attribute.
     @@Get:
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The attribute name. 
        @@@InCase:
          @@@@Label: Qualified name
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              If the "localName" is different from "null".
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            my $node = $self->{<Q:TreeCore:node>};
            if (defined $node->{<Q:infoset:localName>}) {
              $r = (defined $node->{<Q:infoset:prefix>} ?
                   $node->{<Q:infoset:prefix>} . ':' : '') . 
                   $node->{<Q:infoset:localName>};
            } else {
              $r = $node->{<Q:DOMCore:name>};
            }
        @@@ImplNote:
          @@@@lang:en
          @@@@@:
            "Element.tagName" is defined to return the uppercase name 
            if the document is an HTML document.  "Attr.name" is not 
            defined so.
  @Attr:
     @@Name:  specified
     @@Description:
       @@@lang:en
       @@@@: Whether this attribute is specified explicitly in the document.
     @@Get:
        @@@Type:  boolean
        @@@InCase:
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              This attribute is explicitly given a value in the 
              instance document.
        @@@InCase:
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              This attribute is not explicitly given a value in the 
              instance document.
        @@@Def:
          @@@@Type:
             lang:dis
          @@@@GetProp:
             infoset:specified
    @@ImplNote:
       @@@lang:en
       @@@@:
         This attribute is set to "true" if the DOM application 
         changed the value of this attribute node (even if it ends up 
         having the same value as the default value).
    @@ImplNote:
       @@@lang:en
       @@@@:
         The implementation may handle attributes with default 
         values from other schemas than DTD and XML Schema but 
         the DOM application should use "normalizeDocument" to 
         guarantee this information is up-to-date.
    @@ImplNote:
      @@@lang:en
      @@@@:
        Removing an attribute node may generate a new attribute 
        node with the default value and "specified" set to "false".
      \
        When "normalizeDocument" is invoked, non-"specified" 
        attribute nodes are recomputed according to the defaulu 
        attribute value.
    @@ImplNote:
      @@@lang:en
      @@@@: 
        The DOM Level 1 Specification (Second Edition) and the 
        DOM Level 2 Specification says that if the "ownerElement" 
        is "null", "specified" is always "true".  The DOM Level 3 
        Specification does not address this case.
## TODO: Some mechanism required to turn the "specified" attribute "true" 
## when some node operation is done.
  @Attr:
     @@Name:  value
     @@Description:
       @@@lang:en
       @@@@: The value of this attribute.
     @@Get:
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            The attribute value as a string.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            __DEEP{
              $r = $self->{<Q:TreeCore:node>}
                  ->__SUPER{ManakaiDOMNodeObjectNode::}__::__INT{textContent}__;
            }__;
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              This definition might be updated when the new level 
              of the DOM is introduced.
        @@@ImplNote:
          @@@@lang:en
          @@@@@:
            Although the specification says nothing, the Attr->value and 
            Attr->textContent should have the same value by nature.
     @@Set:
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            Setting of this attribute creates a "Text" node with 
            the value specified and replaces child nodes of this 
            node with it.
        @@@ImplNote:
          @@@@lang:en
          @@@@@:
            The DOM implementation may normalize the value [DOM 3, SVG DOM].
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: This node is read-only.
          @@@@SpecLevel:1
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              This exception is added in the DOM Level 1 Errata and 
              incorporated into the DOM Level 1 Second Edition.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            __DEEP{
              $self->__SUPER{Attr::DOM3}__::textContent ($given);
            }__;
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              This definition might be updated when the new level 
              of the DOM is introduced.
      @@SpecLevel[list]:
         1
      @@Level[list]: 1
            
  @Attr:
     @@Name:  ownerElement
     @@Description:
       @@@lang:en
       @@@@:
         The element to which this attribute is attached.
     @@Get:
        @@@Type:  Element
        @@@Description:
          @@@@lang:en
          @@@@@: The "Element" node.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: This attribute is not in use.
        @@@Def:
          @@@@Type:
            lang:dis
          @@@@GetPropNode:
            infoset:ownerElement
     @@Level[list]:  2
     @@SpecLevel:2
  @Attr:
     @@Name:  schemaTypeInfo
     @@Description:
       @@@lang:en
       @@@@:
         The type information associated with this node.
        \
         Note that while this type information is guarantee 
         to be correct after loading the validation, 
         it may not be reliable if the node was moved.
     @@Get:
        @@@Type:  TypeInfo
        @@@Description:
          @@@@lang:en
          @@@@@: The type information.
     @@Level[list]:  3
     @@SpecLevel:3
  @Attr:
     @@Name:  isId
     @@Description:
       @@@lang:en
       @@@@:
         Return whether this attribute is known to be of type ID or not.
     @@ImplNote:
       @@@lang:en
       @@@@:
         The ways to determine whether an attribute node is known 
         to contain an identifier:
        \
         PSVI - If validation occurred using an XML Schema, the PSVI 
         contributions values are used to determine whether this 
         attribute is a schema-determined ID attribute as the 
         XPointer specification defines, i.e. iif one of the following 
         is true:
        \
         1. The attribute information item has a [memeber type definition] or 
         [type definition] property whose value in turn has [name] eq "ID" 
         and [target namespace] eq "http://www.w3.org/2001/XMLSchema".
        \
         2. The attribute information item has a [base type definition] 
         property whose value in turn has [name] eq "ID"
         and [target namespace] eq "http://www.w3.org/2001/XMLSchema".
        \
         3. The attribute information item has a [base type definition] 
         property whose value has a [base type definition] property 
         whose value has ... whose value in turn has [name] eq "ID"
         and [target namespace] eq "http://www.w3.org/2001/XMLSchema".
        \
         4. The attribute information item has a [type definition name] 
         eq "ID" and a [type definition namespace] eq 
         "http://www.w3.org/2001/XMLSchema".
        \
         5. The attribute information item has a 
         [member type definition name] eq "ID" and a 
         [member type definition namespace] eq 
         "http://www.w3.org/2001/XMLSchema".
        \
         DTD - If validation occured using a DTD, the infoset 
         [type definition] value is used to determine whether 
         this attribute is a DTD-determined ID attribute as the 
         XPointer framework specification defines.  Iif the 
         attribute information item has a [type definition] property 
         eq "ID", it is a DTD-determined ID attribute.
        \
         User-determined - If the methods "setIdAttribute", 
         "setIdAttributeNS", "setIdAttributeNode" was used, 
         it is an user-determined ID attribute.
        \
         Externally-determined - Other mechanisms, including other 
         schema languages than DTD and XML Schema may provide 
         ways to determine whether it is a ID attribute.
     @@Get:
        @@@Type:  boolean
     @@Level[list]:  3
     @@SpecLevel:3
  
  @ReAttr:
    @@Name: attributes
    @@Spec:
      @@@DOM3[list]:
        http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-84CF096
        http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-1841493061
    @@Get:
      @@@Type: NamedNodeMap
      @@@Def:
        @@@@Type:
          lang:Perl
        @@@@@:
          $r = null;
  @ReAttr:
     @@Name:  localName
     @@Description:
       @@@lang:en
       @@@@: The local part of the qualified name of this "Attr" node.
     @@Get:
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            The local name of the attribute.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The node is created with a DOM Level 1 methods.
        @@@Def:
          @@@@Type:
            lang:dis
          @@@@GetProp:
            infoset:localName
     @@Level[list]:  2
     @@SpecLevel:2
     @@Redefine: Node
  @Attr:
     @@Name:  namespaceURI
     @@Description:
       @@@lang:en
       @@@@:
         The namespace URI of this node.
     @@Get:
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The namespace URI.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The namespace URI is unspecified (the attribute in a 
              per-element-type partition) or 
              the node is created with a DOM Level 1 methods.
        @@@Def:
          @@@@Type:
            lang:dis
          @@@@GetProp:
            infoset:namespaceName
     @@Level[list]:  2
     @@SpecLevel:2
     @@Redefined: Node
  @ReAttr:
    @@Name: nodeName
    @@Description:
      @@@lang:en
      @@@@: The node name.
    @@Get:
      @@@Type: DOMString
      @@@Description:
        @@@@lang:en
        @@@@@:
          The attribute name.  It is same as the value of the "name" 
          attribute.
      @@@Def:
        @@@@Type:
          lang:Perl
        @@@@@: __INT{{name}}__;
    @@Redefine: Node
  @ReAttr:
    @@Name: nodeType
    @@Description:
      @@@lang:en
      @@@@: The type of this node.
    @@Get:
      @@@Type: unsigned-short
      @@@InCase:
        @@@@Label: ATTRIBUTE_NODE
        @@@@Description:
          @@@@@lang:en
          @@@@@@: The node is an "Attr".
      @@@Def:
        @@@@Type:
          lang:Perl
        @@@@@: $r = __SUPER{Node}__->ATTRIBUTE_NODE;
    @@Redefine: Node
  @ReAttr:
     @@Name:  nodeValue
     @@Description:
       @@@lang:en
       @@@@: The value of this node.
     @@Get:
        @@@Type:  DOMString
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: DOMSTRING_SIZE_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: 
              The attribute value, i.e. same as "value".
        @@@Def:
          @@@@Type: 
            lang:Perl
          @@@@@: __INT{{value}}__;
     @@Set:
        @@@Type:  DOMString
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: 
              The node is read-only.
        @@@Description:
          @@@@lang:en
          @@@@@:
            New node value.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
                           ## Condition sensitive
            __DEEP{ $self->__SUPER{Attr}__::name ($given) }__;
    @@Redefine: Node
    @@Level[list]:
        1
        2
        3
    @@SpecLevel:1
  @ReAttr:
     @@Name:  prefix
     @@Description:
       @@@lang:en
       @@@@: The namespace prefix of this node.
     @@Get:
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The namespace prefix.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Either the namespace prefix is unspecified or the node 
              is created with a DOM Level 1 method.
        @@@Def:
          @@@@Type:
            lang:dis
          @@@@GetProp:
            infoset:prefix
     @@Set:
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            The namespace prefix.
            Note that setting this attribute has no effect if 
            the namespace prefix is defined to be "null".
          \
            Note also that changing the prefix of an attribute that 
            is known to have a default value does not make a 
            new attribute with the default value and the original 
            prefix appear, since the "namespaceURI" and "localName" 
            do not change.  This is different from the defaulting 
            mechanism of the DTD, which is namespace-unaware.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The namespace prefix is unspecified.
        @@@InCase:
          @@@@Value: \
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The result is implementation dependent in DOM Level 3.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: INVALID_CHARACTER_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The specified prefix contains an illegal character 
              accoding to the XML version in use in the document.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: This node is read-only.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NAMESPACE_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Either the specified prefix is malformed per the 
              XML Namespace specification, non-"null" prefix is 
              specified but the "namespaceURI" of this node is "null", 
              the specified prefix is "xml" and the "namespaceURI" 
              of this node is different from 
              "http://www.w3.org/XML/1998/namespace", the specified 
              prefix is "xmlns" and the "namespaceURI" of this node 
              is different from "http://www.w3.org/2000/xmlns/", or 
              the "qualifiedName" of this node is "xmlns".
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            my $node = $self->{<Q:TreeCore:node>};
            my $version = $node->{<Q:DOMCore:ownerDocument>}
                      ->__SUPER{Document::}__::__INT{getDocumentXMLVersion}__;
            if (not defined $version) {
              __WARNING{
                ManakaiDOMImplementationWarning.ATTR_SET_NO_EFFECT:
                  <Q:MDOM_EXCEPTION:subtype>
                              => <Q:MDOM_EXCEPTION:XML_NOT_SUPPORTED>,
              }__;
            } elsif (not defined $node->{<Q:infoset:localName>}) {
              __WARNING{
                ManakaiDOMImplementationWarning.ATTR_SET_NO_EFFECT:
                  <Q:MDOM_EXCEPTION:subtype>
                              => <Q:MDOM_EXCEPTION:NS_NOT_SUPPORTED>,
              }__;
            } elsif ($node->{<Q:DOMCore:read-only>}) {
              __WARNING{
                DOMException.NO_MODIFICATION_ALLOWED_ERR:
                  <Q:MDOM_EXCEPTION:subtype>
                              => <Q:MDOM_EXCEPTION:NOMOD_THIS>,
              }__;
            } elsif (not defined $node->{<Q:infoset:prefix>} and
                     $node->{<Q:infoset:localName>} and
                     $node->{<Q:infoset:localName>} eq 'xmlns') {
              __EXCEPTION{
                DOMException.NAMESPACE_ERR:
                  <Q:MDOM_EXCEPTION:subtype>
                       => <Q:MDOM_EXCEPTION:NS_QNAME_IS_XMLNS>,
              }__;
            } else {
              __CODE{CheckNCName: ncname => given, version => version,
                                  empty => warn3}__;
              if (not defined $given) {
                #
              } else {
                if (not defined $node->{<Q:infoset:namespaceName>}) {
                  __EXCEPTION{
                    DOMException.NAMESPACE_ERR:
                      <Q:MDOM_EXCEPTION:subtype>
                           => <Q:MDOM_EXCEPTION:NS_PREFIX_WITH_NULL_URI>,
                      <Q:MDOM_EXCEPTION:prefix> => $given,
                  }__;
                } elsif ($given eq 'xml' and
                         (not $node->{<Q:infoset:namespaceName>} or
                          $node->{<Q:infoset:namespaceName>} ne <Q:xml:>)) {
                  __EXCEPTION{
                    DOMException.NAMESPACE_ERR:
                      <Q:MDOM_EXCEPTION:subtype>
                           => <Q:MDOM_EXCEPTION:NS_XML_WITH_OTHER_URI>,
                      <Q:infoset:namespaceName>
                           => $node->{<Q:infoset:namespaceName>},
                  }__;
                } elsif ($given eq 'xmlns' and
                         (not $node->{<Q:infoset:namespaceName>} or
                          $node->{<Q:infoset:nanespaceName>} eq <Q:xmlns:>)) {
                  __EXCEPTION{
                    DOMException.NAMESPACE_ERR:
                      <Q:MDOM_EXCEPTION:subtype>
                           => <Q:MDOM_EXCEPTION:NS_XMLNS_WITH_OTHER_URI>,
                      <Q:infoset:namespaceName>
                           => $node->{<Q:infoset:namespaceName>},
                  }__;
                }
              }
              $node->{<Q:infoset:prefix>} = $given;
            }
     @@Level[list]:
       2
       3
     @@SpecLevel:2
     @@Redefine: Node

IF:
  @Name:  Element
  @Description:
    @@lang:en
    @@@:
      An element in a document.
  @ISA:  Node
  @Require:
    @@Module:
      @@@Def:
        @@@@Type:
          lang:Perl
        @@@@use: 
          @@@@@@:
            Char::Class::XML
          @@@@@Import[list]:
            InXML_NameStartChar10
            InXMLNameChar10
            InXMLNameStartChar11
            InXMLNameChar11
      @@@Condition[list]:
        DOM1
        DOM2
        DOM3
  @Attr:
     @@Name:  tagName
     @@Description:
       @@@lang:en
       @@@@: The element type name of this node.
     @@Get:
        @@@Type:  DOMString
        @@@InCase:
          @@@@Label: Qualified name
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              If the "localName" is different from "null".
        @@@InCase:
          @@@@Label: Canonical uppercase form of name
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              If this is an HTML element node.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            my $node = $self->{<Q:TreeCore:node>};
            if (defined $node->{<Q:infoset:localName>}) {
              $r = (defined $node->{<Q:infoset:prefix>} ?
                   $node->{<Q:infoset:prefix>} . ':' : '') . 
                   $node->{<Q:infoset:localName>};
            } else {
              $r = $node->{<Q:DOMCore:tagName>};
            }
 ## TODO: toUpper if HTML
 ## ISSUE: What to do if XHTML?       
  @Method:
     @@Name:  getAttribute
     @@Return:
        @@@Type:  DOMString
     @@Param:
        @@@Name:  name
        @@@Type:  DOMString
  @Method:
     @@Name:  setAttribute
     @@Param:
        @@@Name:  name
        @@@Type:  DOMString
     @@Param:
        @@@Name:  value
        @@@Type:  DOMString
     @@Return:
        @@@Exception[list]:  DOMException
  @Method:
     @@Name:  removeAttribute
     @@Param:
        @@@Name:  name
        @@@Type:  DOMString
     @@Return:
        @@@Exception[list]:  DOMException
  @Method:
     @@Name:  getAttributeNode
     @@Return:
        @@@Type:  Attr
     @@Param:
        @@@Name:  name
        @@@Type:  DOMString
  @Method:
     @@Name:  setAttributeNode
     @@Return:
        @@@Type:  Attr
        @@@Exception[list]:  DOMException
     @@Param:
        @@@Name:  newAttr
        @@@Type:  Attr
  @Method:
     @@Name:  removeAttributeNode
     @@Return:
        @@@Type:  Attr
        @@@Exception[list]:  DOMException
     @@Param:
        @@@Name:  oldAttr
        @@@Type:  Attr
  @Method:
     @@Name:  getElementsByTagName
     @@Return:
        @@@Type:  NodeList
     @@Param:
        @@@Name:  name
        @@@Type:  DOMString
  @Method:
     @@Name:  getAttributeNS
     @@Return:
        @@@Type:  DOMString
        @@@Exception[list]:  DOMException
     @@Param:
        @@@Name:  namespaceURI
        @@@Type:  DOMString
     @@Param:
        @@@Name:  localName
        @@@Type:  DOMString
     @@Level[list]:  2
     @@SpecLevel:2
  @Method:
     @@Name:  setAttributeNS
     @@Param:
        @@@Name:  namespaceURI
        @@@Type:  DOMString
     @@Param:
        @@@Name:  qualifiedName
        @@@Type:  DOMString
     @@Param:
        @@@Name:  value
        @@@Type:  DOMString
     @@Return:
        @@@Exception[list]:  DOMException
     @@Level[list]:  2
     @@SpecLevel:2
  @Method:
     @@Name:  removeAttributeNS
     @@Param:
        @@@Name:  namespaceURI
        @@@Type:  DOMString
     @@Param:
        @@@Name:  localName
        @@@Type:  DOMString
     @@Return:
        @@@Exception[list]:  DOMException
     @@Level[list]:  2
     @@SpecLevel:2
  @Method:
     @@Name:  getAttributeNodeNS
     @@Return:
        @@@Type:  Attr
        @@@Exception[list]:  DOMException
     @@Param:
        @@@Name:  namespaceURI
        @@@Type:  DOMString
     @@Param:
        @@@Name:  localName
        @@@Type:  DOMString
     @@Level[list]:  2
     @@SpecLevel:2
  @Method:
     @@Name:  setAttributeNodeNS
     @@Return:
        @@@Type:  Attr
        @@@Exception[list]:  DOMException
     @@Param:
        @@@Name:  newAttr
        @@@Type:  Attr
     @@Level[list]:  2
     @@SpecLevel:2
  @Method:
     @@Name:  getElementsByTagNameNS
     @@Return:
        @@@Type:  NodeList
        @@@Exception[list]:  DOMException
     @@Param:
        @@@Name:  namespaceURI
        @@@Type:  DOMString
     @@Param:
        @@@Name:  localName
        @@@Type:  DOMString
     @@Level[list]:  2
     @@SpecLevel:2
  @Method:
     @@Name:  hasAttribute
     @@Return:
        @@@Type:  boolean
     @@Param:
        @@@Name:  name
        @@@Type:  DOMString
     @@Level[list]:  2
     @@SpecLevel:2
  @Method:
     @@Name:  hasAttributeNS
     @@Return:
        @@@Type:  boolean
        @@@Exception[list]:  DOMException
     @@Param:
        @@@Name:  namespaceURI
        @@@Type:  DOMString
     @@Param:
        @@@Name:  localName
        @@@Type:  DOMString
     @@Level[list]:  2
     @@SpecLevel:2
  @Attr:
     @@Name:  schemaTypeInfo
     @@Description:
        @@@lang:en
        @@@@: The type information associated with this element.
     @@Get:
        @@@Type:  TypeInfo
        @@@Description:
          @@@@lang:en
          @@@@@: The type information.
     @@Level[list]:  3
     @@SpecLevel:3
  @Method:
     @@Name:  setIdAttribute
     @@Param:
        @@@Name:  name
        @@@Type:  DOMString
     @@Param:
        @@@Name:  isId
        @@@Type:  boolean
     @@Return:
        @@@Exception[list]:  DOMException
     @@Level[list]:  3
     @@SpecLevel:3
  @Method:
     @@Name:  setIdAttributeNS
     @@Param:
        @@@Name:  namespaceURI
        @@@Type:  DOMString
     @@Param:
        @@@Name:  localName
        @@@Type:  DOMString
     @@Param:
        @@@Name:  isId
        @@@Type:  boolean
     @@Return:
        @@@Exception[list]:  DOMException
     @@Level[list]:  3
     @@SpecLevel:3
  @Method:
     @@Name:  setIdAttributeNode
     @@Param:
        @@@Name:  idAttr
        @@@Type:  Attr
     @@Param:
        @@@Name:  isId
        @@@Type:  boolean
     @@Return:
        @@@Exception[list]:  DOMException
     @@Level[list]:  3
     @@SpecLevel:3
  @ReMethod:
    @@Name: normalize
    @@Return:
      @@@
    @@ImplNote:
      @@@lang:en
      @@@@:
        The method "normalize" was defined in the "Element" interface in 
        the DOM Level 1 but has been moved to 
        the "Node" interface in the DOM Level 2 and higher.
    @@Redefine: Node
  
  @ReAttr:
     @@Name:  localName
     @@Description:
       @@@lang:en
       @@@@: The local part of the qualified name of this "Element" node.
     @@Get:
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            The local name of the element type.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The node is created with a DOM Level 1 methods.
        @@@Def:
          @@@@Type:
            lang:dis
          @@@@GetProp:
            infoset:localName
     @@Level[list]:  2
     @@SpecLevel:2
     @@Redefine: Node
  @Attr:
     @@Name:  namespaceURI
     @@Description:
       @@@lang:en
       @@@@:
         The namespace URI of this node.
     @@Get:
        @@@Type:
          ManakaiDOM:ManakaiDOMNamespaceURI
        @@@Description:
          @@@@lang:en
          @@@@@: The namespace URI.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The namespace URI is unspecified (the "null" namespace) or 
              the node is created with a DOM Level 1 methods.
        @@@Def:
          @@@@Type:
            lang:dis
          @@@@GetProp:
            infoset:namespaceName
     @@Level[list]:  2
     @@SpecLevel:2
     @@Redefined: Node
  @ReAttr:
    @@Name: nodeName
    @@Description:
      @@@lang:en
      @@@@: The node name.
    @@Get:
      @@@Type: DOMString
      @@@Description:
        @@@@lang:en
        @@@@@: The element type name, i.e. same as "tagName" attribute.
      @@@Def:
        @@@@Type:
          lang:Perl
        @@@@@: __INT{{tagName}}__;
    @@Redefine: Node
  @ReAttr:
    @@Name: nodeType
    @@Description:
      @@@lang:en
      @@@@: The type of this node.
    @@Get:
      @@@Type: unsigned-short
      @@@InCase:
        @@@@Label: ELEMENT_NODE
        @@@@Description:
          @@@@@lang:en
          @@@@@@: The node is an "Element".
      @@@Def:
        @@@@Type:
          lang:Perl
        @@@@@: $r = __SUPER{Node}__->ELEMENT_NODE;
    @@Redefine: Node
  @ReAttr:
     @@Name:  prefix
     @@Description:
       @@@lang:en
       @@@@: The namespace prefix of this node.
     @@Get:
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The namespace prefix.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Either the namespace prefix is unspecified or the node 
              is created with a DOM Level 1 method.
        @@@Def:
          @@@@Type:
            lang:dis
          @@@@GetProp:
            infoset:prefix
     @@Set:
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            The namespace prefix.
            Note that setting this attribute has no effect if 
            the namespace prefix is defined to be "null".
        @@@ImplNote:
          @@@@lang:en
          @@@@@:
            It is unclear whether the default attribute should be 
            added or deleted as the DTD declares.  The DOM Level 2 
            and 3 specifications mentions that changing of the 
            attribute name prefix does not make the default 
            attribute supplied, since the namespace URI does not change.
            This logic might be applied to the element node.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The namespace prefix is unspecified.
        @@@InCase:
          @@@@Value: \
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The result is implementation dependent in DOM Level 3.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: INVALID_CHARACTER_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The specified prefix contains an illegal character 
              accoding to the XML version in use in the document.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: This node is read-only.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NAMESPACE_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Either the specified prefix is malformed per the 
              XML Namespace specification, non-"null" prefix is 
              specified but the "namespaceURI" of this node is "null" or 
              the specified prefix is "xml" and the "namespaceURI" 
              of this node is different from 
              "http://www.w3.org/XML/1998/namespace".
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            my $node = $self->{<Q:TreeCore:node>};
            my $version = $node->{<Q:DOMCore:ownerDocument>}
                      ->__SUPER{Document::}__::__INT{getDocumentXMLVersion}__;
            if (not defined $version) {
              __WARNING{
                ManakaiDOMImplementationWarning.ATTR_SET_NO_EFFECT:
                  <Q:MDOM_EXCEPTION:subtype>
                              => <Q:MDOM_EXCEPTION:XML_NOT_SUPPORTED>,
              }__;
            } elsif (not defined $node->{<Q:infoset:localName>}) {
              __WARNING{
                ManakaiDOMImplementationWarning.ATTR_SET_NO_EFFECT:
                  <Q:MDOM_EXCEPTION:subtype>
                              => <Q:MDOM_EXCEPTION:NS_NOT_SUPPORTED>,
              }__;
            } elsif ($node->{<Q:DOMCore:read-only>}) {
              __WARNING{
                DOMException.NO_MODIFICATION_ALLOWED_ERR:
                  <Q:MDOM_EXCEPTION:subtype>
                              => <Q:MDOM_EXCEPTION:NOMOD_THIS>,
              }__;
            } else {
              __CODE{CheckNCName: ncname => given, version => version,
                                  empty => warn3}__;
              if (not defined $given) {
                #
              } else {
                if (not defined $node->{<Q:infoset:namespaceName>}) {
                  __EXCEPTION{
                    DOMException.NAMESPACE_ERR:
                      <Q:MDOM_EXCEPTION:subtype>
                           => <Q:MDOM_EXCEPTION:NS_PREFIX_WITH_NULL_URI>,
                      <Q:MDOM_EXCEPTION:prefix> => $given,
                  }__;
                } elsif ($given eq 'xml' and
                         (not $node->{<Q:infoset:namespaceName>} or
                          $node->{<Q:infoset:namespaceName>} ne <Q:xml:>)) {
                  __EXCEPTION{
                    DOMException.NAMESPACE_ERR:
                      <Q:MDOM_EXCEPTION:subtype>
                           => <Q:MDOM_EXCEPTION:NS_XML_WITH_OTHER_URI>,
                      <Q:infoset:namespaceName>
                           => $node->{<Q:infoset:namespaceName>},
                  }__;
                }
              }
              $node->{<Q:infoset:prefix>} = $given;
            }
     @@Level[list]:
       2
       3
     @@SpecLevel:2
     @@Redefine: Node

IF:
  @Name:  Text
  @ISA:  CharacterData
  @Description:
    @@lang:en
    @@@:
      The textual content of an "Element" or "Attr".
    \
      When a document is first made available via the DOM, 
      there is only one "Text" node for each block of text. 
      DOM applications may create adjust "Text" nodes that 
      represent the contents of a given node (but there is no 
      way to represent the separation between these nodes in 
      XML or HTML so they will not persist between DOM editing sessions 
      in general).
  @ImplNote:
    @@lang:en
    @@@:
     "Text" is a "CharacterData" is a "Node".  "CDATASection" is a "Text".
  @Method:
     @@Name:  splitText
     @@Description:
       @@@lang:en
       @@@@:
         Break this node into two nodes.  After being split, 
         this node will contain all the content up to the break point 
         and a new node of the same type will contain all the content 
         at and after the break point.
      \
         If the original node had a parent node, the new node is 
         inserted as the next sibling of this node.
     @@Param:
        @@@Name:  offset
        @@@Type:  unsigned-long
        @@@Description:
          @@@@lang:en
          @@@@@:
            The 16-bit unit offset at which to split.
     @@Return:
        @@@Type:  Text
        @@@Description:
          @@@@lang:en
          @@@@@: The new node, of the same type as this node.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: INDEX_SIZE_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The "offset" is negative or greater than the number 
              of 16-bit units.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Either this node is read-only [DOM 1, 2, 3] or 
              the parent node of this node is read-only.
      @@@Exception:
        @@@@Type: 
          ManakaiDOM:ManakaiDOMImplementationException
        @@@@Name: MDOM_INDEX_IN_SURROGATE_PAIR
        @@@@Description:
          @@@@@lang:en
          @@@@@@: An attempt is made to break surrogate pair.
      @@@Def:
        @@@@Type:
          lang:Perl
        @@@@@:
          my $node = $self->{<Q:TreeCore:node>};
          my $parentNode = $node->{<Q:infoset:parent>};
          if ($node->{<Q:DOMCore:read-only>}) {
            __EXCEPTION{
              DOMException.NO_MODIFICATION_ALLOWED_ERR:
                <Q:MDOM_EXCEPTION:subtype> => <Q:MDOM_EXCEPTION:NOMOD_THIS>,
            }__;
          } elsif ($parentNode and $parentNode->{<Q:DOMCore:read-only>}) {
            __EXCEPTION{
              DOMException.NO_MODIFICATION_ALLOWED_ERR:
                <Q:MDOM_EXCEPTION:subtype> => <Q:MDOM_EXCEPTION:NOMOD_PARENT>,
            }__;
          }
                          ## Condition sensitive
          my $ds = $self->__SUPER{CharacterData}__::__INT{getDOMStringValue}__;
          my $len = length ($node->{<Q:infoset:content>}) * 2;
          my $after;
          __DEEP{
            $after = $ds->__INT{substring}__ ($offset, $len);
            $ds->__INT{delete}__ ($offset, $len);
          }__;
          my $newNode;
          if ($node->{<Q:DOMCore:nodeType>} eq <Q:DOMCore:Text>) {
                        ## Condition sensitive
            $newNode = __CLASS{Text}__->__INT{newObject}__;
          } elsif ($node->{<Q:DOMCore:nodeType>} eq <Q:DOMCore:CDATASection>) {
                        ## Condition sensitive
            $newNode = __CLASS{CDATASection}__->__INT{newObject}__;
          } else {
            __EXCEPTION{
              ManakaiDOMImplementationException.MDOM_DEBUG_BUG:
                <Q:MDOM_EXCEPTION:values> => {
                  <Q:DOMCore:nodeType> => $node->{<Q:DOMCore:nodeType>},
                },
            }__;
          }
          $newNode->{<Q:infoset:content>} = $after;
          if ($parentNode) {
            $parentNode->__SUPER{ManakaiDOMNodeObject::}__::__INT{importTree}__
                                                                   ($newNode);
            for my $i (0..$#{$parentNode->{<Q:infoset:children>}}) {
              if ($parentNode->{<Q:infoset:children>}->[$i]
                             ->{<Q:TreeCore:nodeID>} eq
                  $node->{<Q:TreeCore:nodeID>}) {
                splice @{$parentNode->{<Q:infoset:children>}},
                       $i + 1, 0, $newNode;
                last;
              }
            }
            $newNode->{<Q:infoset:parent>} = $parentNode;
          }
          $newNode->{<Q:DOMCore:ownerDocument>}
                                           = $node->{<Q:DOMCore:ownerDocument>};
    @@SpecLevel:1
    @@Level[list]:
      1
      2
      3
  @Attr:
     @@Name:  isElementContentWhitespace
     @@Description:
       @@@lang:en
       @@@@:
         Whether this text node contains element content whitespaces.
     @@Get:
        @@@Type:  boolean
        @@@InCase:
          @@@@Value:true
          @@@@Description:
            @@@@@lang:en
            @@@@@@: This text node contains element content whitespaces.
        @@@InCase:
          @@@@Value:false
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              This text node contains element content whitespaces or 
              no validation occurs so that it is unknown.
        @@@Def:
          @@@@Type:
            lang:dis
          @@@@GetProp:
            infoset:elementContentWhitespace
     @@Level[list]:  3
     @@SpecLevel:3
  @Attr:
     @@Name:  wholeText
     @@Get:
        @@@Type:  DOMString
     @@Level[list]:  3
     @@SpecLevel:3
  @Method:
     @@Name:  replaceWholeText
     @@Return:
        @@@Type:  Text
        @@@Exception[list]:  DOMException
     @@Param:
        @@@Name:  content
        @@@Type:  DOMString
     @@Level[list]:  3
     @@SpecLevel:3
  
  @ReAttr:
    @@Name: attributes
    @@Spec:
      @@@DOM3[list]:
        http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-84CF096
        http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-1841493061
    @@Get:
      @@@Type: NamedNodeMap
      @@@Def:
        @@@@Type:
          lang:Perl
        @@@@@:
          $r = null;
  @ReAttr:
    @@Name: nodeName
    @@Description:
      @@@lang:en
      @@@@: The node name.
    @@Spec:
      @@@DOM3[list]:
        http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-F68D095
        http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-1841493061
    @@Get:
      @@@Type: DOMString
      @@@InCase:
        @@@@Value:\#text
        @@@@Description:
          @@@@@lang:en
          @@@@@@: Always this value for the "Text" node.
      @@@DefaultValue: \#text
      @@@Def: \
  @ReAttr:
    @@Name: nodeType
    @@Description:
      @@@lang:en
      @@@@: The type of this node.
    @@Get:
      @@@Type: unsigned-short
      @@@InCase:
        @@@@Label: TEXT_NODE
        @@@@Description:
          @@@@@lang:en
          @@@@@@: The node is a "Text".
      @@@Def:
        @@@@Type:
          lang:Perl
        @@@@@: $r = __SUPER{Node}__->TEXT_NODE;
    @@Redefine: Node
    @@RedefinedBy: CDATASection
## IF:Text

IF:
  @Name:  Comment
  @ISA:  CharacterData
  @Description:
    @@lang:en
    @@@:
      A comment, corresponding to a comment declaration in the HTML or 
      XML or a comment information item in the XML Infoset.
  @ImplNote:
    @@lang:en
    @@@:
      "Comment" is a "CharacterData" is a "Node".
  @ImplNote:
    @@lang:en
    @@@:
      HTML comment declaration might have multiple "comment". 
  
  @ReAttr:
    @@Name: nodeName
    @@Spec:
      @@@DOM3[list]:
        http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-F68D095
        http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-1841493061
    @@Description:
      @@@lang:en
      @@@@: The node name.
    @@Get:
      @@@Type: DOMString
      @@@InCase:
        @@@@Value: \#comment
        @@@@Description:
          @@@@@lang:en
          @@@@@@: Always this value for the "Comment" node.
      @@@DefaultValue: \#comment
      @@@Def: \
  @ReAttr:
    @@Name: nodeType
    @@Description:
      @@@lang:en
      @@@@: The type of this node.
    @@Get:
      @@@Type: unsigned-short
      @@@InCase:
        @@@@Label: COMMENT_NODE
        @@@@Description:
          @@@@@lang:en
          @@@@@@: The node is a "Comment".
      @@@Def:
        @@@@Type:
          lang:Perl
        @@@@@: $r = __SUPER{Node}__->COMMENT_NODE;
    @@Redefine: Node
## IF:Comment

IF:
  @Name:  TypeInfo
  @Description:
    @@lang:en
    @@@:
      A type referenced from "Element" or "Attr" nodes, 
      specified in the schemas associated with the document.
    \
      The type is a pair of namespace URI and name.  It depsnds 
      on the schema language in use.
  @ImplNote:
    @@lang:en
    @@@:
      If the schema language is the XML Schema:
     \
      - If [validity] property exists and its value is 
      "invalid" or "notKnown": ("typeNamespace", "typeName") = 
      ({target namespace}, {name}) or ("null", "null").
     \
      NOTE: The XML Schema specification does not require 
      exposing the declared type.  DOM implementation might choose 
      not to provide type information if validity is not valid.
     \
      - If [validity] exists and its value is "valid":
     \
      -- If [member type definition] exists:
     \
      --- If {name} is not absent: ("typeNamespace", "typeName") = 
      [member type definition].({target namespace}, {name}).
     \
      --- Otherwise: ("typeNamespace", "typeName") = 
      (namespace, local name) of the corresponding anonymous type name.
     \
      -- If [type definition] exists:
     \
      --- If {name} is not absent: ("typeNamespace", "typeName") =
      [type definition].({target namespace}, {name}).
     \
      --- Otherwise: ("typeNamespace", "typeName") =
      (namespace, local name) of the corresponding anonymous type name.
     \
      -- If [member type definition anonymous] exists:
     \
      --- If false: ("typeNamespace", "typeName") =
      ([member type definition namespace], [member type definition name]).
     \
      --- Otherwise: ("typeNamespace", "typeName") =
      (namespace, local name) of the corresponding anonymous type name.
     \
      -- If [type definition anonymous] exists:
     \
      --- If false: ("typeNamespace", "typeName") =
      ([type definition namespace], [type definition name]).
     \
      --- Otherwise: ("typeNamespace", "typeName") =
      (namespace, local name) of the corresponding anonymous type name.
     \
      Other schema languages are outside of the scope of the W3C and 
      should define how to represent their type systems using "TypeInfo".
  @Level[list]:  3
  @SpecLevel:3
  @Attr:
     @@Name:  typeName
     @@Description:
       @@@lang:en
       @@@@: The name of the type.
     @@Get:
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The name of the type.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The name is unknown.
       
  @Attr:
     @@Name:  typeNamespace
     @@Description:
       @@@lang:en
       @@@@: The namespace of the type.
     @@Get:
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The namespace of the type.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Either the associated element or attribute does not have 
              declaration or no namespace information is available.
        @@@InCase:
          @@@@Value:
            http://www.w3.org/TR/REC-xml
          @@@@Description:
            @@@@@lang:en
            @@@@@@: 
              The schema language is the XML DTD and the node 
              associated is an "Attr".
            \
              In this case, the "typeName" is the value of 
              the [attribute type] property of the XML Infoset.
     @@ImplNote:
       @@@lang:en
       @@@@: Is this namespace *URI*?
  @ConstGroup:
     @@Name:  DerivationMethods
     @@Description:
       @@@lang:en
       @@@@:
         A set of possible types of derivation.
     @@Type: unsigned-long
     @@IsBitMask:1
     @@ImplNote:
       @@@lang:en
       @@@@:
         Any type derives from "xsd:anyType".
     @@Const:
        @@@Name:  DERIVATION_RESTRICTION
        @@@Type:  unsigned-long
        @@@Value:  0x00000001
        @@@Description:
          @@@@lang:en
          @@@@@:
            The derivation by restriction.
        @@@ImplNote:
          @@@@lang:en
          @@@@@:
            Other type definition = reference type definition or 
            reference type definition.{base type definition}. ... 
            .{base type definition} = other type definition and 
            all the derivation methods involved are restriction.
          \
            Any simple type derives from "xsd:anySimpleType" by restriction.
     @@Const:
        @@@Name:  DERIVATION_EXTENSION
        @@@Type:  unsigned-long
        @@@Value:  0x00000002
        @@@Description:
          @@@@lang:en
          @@@@@:
            The derivation by extension.
        @@@ImplNote:
          @@@@lang:en
          @@@@@:
            Reference type definition.{base type definition}.
            ... .{base type definition} = other type definition 
            and at least one of the derivation methods 
            involeved is an extension. 
          \
            Both types are complex types or both are simple types.
     @@Const:
        @@@Name:  DERIVATION_UNION
        @@@Type:  unsigned-long
        @@@Value:  0x00000004
        @@@Description:
          @@@@lang:en
          @@@@@: The union.
        @@@ImplNote:
          @@@@lang:en
          @@@@@:
            Other type definition --derive<DERIVATION_RESTRICTION>--> T2 
            or other type definition = T2,
            T1 --derive<DERIVATION_RESTRICTION or DERIVATION_EXTENSION>--> 
            reference type definition or T1 = reference type definition, 
            T1.{variety} = union and T1.{member type definition} = T2.
     @@Const:
        @@@Name:  DERIVATION_LIST
        @@@Type:  unsigned-long
        @@@Value:  0x00000008
        @@@Description:
          @@@@lang:en
          @@@@@: The list.
        @@@ImplNote:
          @@@@lang:en
          @@@@@: 
            Other type definition --derive<DERIVATION_RESTRICTION>--> T2 
            or other type definition = T2,
            T1 --derive<DERIVATION_RESTRICTION or DERIVATION_EXTENSION>--> 
            reference type definition or T1 = reference type definition, 
            T1.{variety} = list and T1.{item type definition} = T2.
  @Method:
     @@Name:  isDerivedFrom
     @@Description:
       @@@lang:en
       @@@@:
         Return whether there is a derivation between the definition 
         of this type and the other type definition.
     @@Param:
        @@@Name:  typeNamespaceArg
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The namespace of the other type definition.
     @@Param:
        @@@Name:  typeNameArg
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The name of the other type definition.
     @@Param:
        @@@Name:  derivationMethod
        @@@Type:  DerivationMethods
        @@@Description:
          @@@@lang:en
          @@@@@:
            The type of derivation and conditions applied between 
            two types.
     @@Return:
        @@@Type:  boolean
        @@@InCase:
          @@@@Value:true
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The schema language is the XML Schema and 
              the definition of this type is derived from the 
              other type definition according to the derivation 
              parameter.
            \
              If the "derivationMethod" is "0", the other 
              type definition can be reached by recursing any 
              combination of {base type definition}, 
              {item type definition} or {member type definition} 
              from the definition of this type.
        @@@InCase:
          @@@@Value:false
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Either the schema language is the XML Schema and 
              the other type definition is not derived from 
              the definition of this type, the schema language 
              is the XML DTD or no schama language is associated.

IF:
  @Name:  UserDataHandler
  @Description:
    @@lang:en
    @@@:
      A handler to implement various behaviors regarding the 
      data associated to the DOM nodes.
  @Level[list]:  3
  @SpecLevel:3
  @ConstGroup:
     @@Name:  OperationType
     @@Type: unsigned-short
     @@Description:
       @@@lang:en
       @@@@: The type of operation being performed on a node.
     @@Const:
        @@@Name:  NODE_CLONED
        @@@Type:  unsigned-short
        @@@Value:  1
        @@@Description:
          @@@@lang:en
          @@@@@: The node is cloned.
        @@@ImplNote:
          @@@@lang:en
          @@@@@: The node is cloned.
        @@@ImplNote:
          @@@@lang:en
          @@@@@: "Node.cloneNode".
     @@Const:
        @@@Name:  NODE_IMPORTED
        @@@Type:  unsigned-short
        @@@Value:  2
        @@@Description:
          @@@@lang:en
          @@@@@: The node is imported.
        @@@ImplNote:
          @@@@lang:en
          @@@@@: "Document.importNode".
     @@Const:
        @@@Name:  NODE_DELETED
        @@@Type:  unsigned-short
        @@@Value:  3
        @@@Description:
          @@@@lang:en
          @@@@@:
            The node is deleted.
        @@@ImplNote:
          @@@@lang:en
          @@@@@:
            This may not be supported or may not be reliable in certain 
            environment, such as Java, where the DOM implementation 
            has no real control over when objects are actually deleted.
     @@Const:
        @@@Name:  NODE_RENAMED
        @@@Type:  unsigned-short
        @@@Value:  4
        @@@Description:
          @@@@lang:en
          @@@@@: The node is renamed.
        @@@ImplNote:
          @@@@lang:en
          @@@@@: "Document.renameNode".
     @@Const:
        @@@Name:  NODE_ADOPTED
        @@@Type:  unsigned-short
        @@@Value:  5
        @@@Description:
          @@@@lang:en
          @@@@@: The node is adopted.
        @@@ImplNote:
          @@@@lang:en
          @@@@@: "Document.adoptNode".
  @Method:
     @@Name:  handle
     @@Description:
       @@@lang:en
       @@@@:
         Called whenever the node for which the handler is registered 
         is imported or cloned.
       \
         DOM applications MUST NOT raise exceptions in a 
         "UserDataHandler".  The effect of throwing exceptions 
         from the handler is implementation dependent.
     @@ImplNote:
       @@@lang:en
       @@@@:
         The manakai DOM implementation does NOT warn when 
         an exception is thrown.
     @@Param:
        @@@Name:  operation
        @@@Type:  OperationType
        @@@Description:
          @@@@lang:en
          @@@@@: The type of operation that is being performed on the node.
     @@Param:
        @@@Name:  key
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The key for which this handler is being called.
     @@Param:
        @@@Name:  data
        @@@Type:  DOMUserData
        @@@Description:
          @@@@lang:en
          @@@@@: The data for which this handler is being called.
     @@Param:
        @@@Name:  src
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@: 
            The node being cloned, adopted, imported or renamed.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The node is being deleted.
     @@Param:
        @@@Name:  dst
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@: The node newly created.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: No node is newly created.

IF:
  @Name:  DOMError
  @Description:
    @@lang:en
    @@@: Describes an error.
  @Level[list]:  3
  @SpecLevel:3
  @ConstGroup:
     @@Name:  ErrorSeverity
     @@Type: unsigned-short
     @@Description:
       @@@lang:en
       @@@@: The severity of the error.
     @@Const:
        @@@Name:  SEVERITY_WARNING
        @@@Type:  unsigned-short
        @@@Value:  1
        @@@Description:
          @@@@lang:en
          @@@@@:
            Warning.  It will not cause the processing stop unless 
            "DOMErrorHandler.handleError" returns "false".
     @@Const:
        @@@Name:  SEVERITY_ERROR
        @@@Type:  unsigned-short
        @@@Value:  2
        @@@Description:
          @@@@lang:en
          @@@@@:
            Error.  It may not cause the processing to stop 
            if the error can be recovered, unless 
            "DOMErrorHandler.handleError" returns "false".
     @@Const:
        @@@Name:  SEVERITY_FATAL_ERROR
        @@@Type:  unsigned-short
        @@@Value:  3
        @@@Description:
          @@@@lang:en
          @@@@@:
            Fatal error.  It will cause the normal processing to stop.  
            The return value of "DOMErrorHandler.handleError" is 
            ignored unless the implementation chooses to continue, 
            in which case the behavior becomes undefined.
  @Attr:
     @@Name:  severity
     @@Description:
       @@@lang:en
       @@@@:
         The severity of the error.
     @@Get:
        @@@Type:  ErrorSeverity     
  @Attr:
     @@Name:  message
     @@Description:
       @@@lang:en
       @@@@:
         An implementation specific string describing the error that occurred.
     @@Get:
        @@@Type:  DOMString
  @Attr:
     @@Name:  type
     @@Description:
       @@@lang:en
       @@@@:
         A string indicating which related data is expected in 
         "relatedData".
       \
         Implementators of DOM applications should refer to the 
         specification of the error in order to find "type" and 
         "relatedData" defiition if any.
     @@ImplNote:
       @@@lang:en
       @@@@: "Document.normalizeDocument".
     @@Get:
        @@@Type:  DOMString
  @Attr:
     @@Name:  relatedException
     @@Description:
       @@@lang:en
       @@@@: The related platform dependent exception if any.
     @@Get:
        @@@Type:  DOMObject
  @Attr:
     @@Name:  relatedData
     @@Description:
       @@@lang:en
       @@@@:
         The related "DOMError.type" dependent data if any.
     @@Get:
        @@@Type:  DOMObject
  @Attr:
     @@Name:  location
     @@Description:
       @@@lang:en
       @@@@: The location of the error.
     @@Get:
        @@@Type:  DOMLocator

IF:
  @Name:  DOMErrorHandler
  @Description:
    @@lang:en
    @@@:
      A callback interface that the DOM implementation can call when 
      reporting errors that happens while processing XML data or 
      when doing some other processing.
    \
      A "DOMErrorHandler" object can be attached to a "Document" using 
      the "error-handler" on the "DOMConfiguration" interface.
    \
      If more than one error needs to be reported during an operation, 
      the sequence and numbers of the errors passed to the error handler 
      are implementation dependent.
  @Level[list]:  3
  @SpecLevel:3
  @Method:
     @@Name:  handleError
     @@Description:
       @@@lang:en
       @@@@:
         Called when an error occurs.
     @@Param:
        @@@Name:  error
        @@@Type:  DOMError
        @@@Description:
          @@@@lang:en
          @@@@@:
            The error object that describes the error.
          \
            This object may be reused by the DOM implementation 
            across multiple calls to the method "handleError".
     @@Return:
        @@@Type:  boolean
        @@@Description:
          @@@@lang:en
          @@@@@:
            Whether the processing should be continued.
          \
            Throwing an exception from this method is considered 
            to be equivalent of returning "true".
        @@@InCase:
          @@@@Value: true
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The processing may continue depending on "DOMError.severity".
        @@@InCase:
          @@@@Value:false
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The processing should be stopped when possible.
        @@@Exception:
          @@@@Type: 
            ManakaiDOM:ManakaiDOMImplementationException
          @@@@Name: MDOM_IMPL_BY_APP
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The method MUST be implemented by the DOM application.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            __EXCEPTION{
              ManakaiDOMImplementationException.MDOM_IMPL_BY_APP:
            }__;

IF:
  @Name:  DOMLocator
  @Level[list]:  3
  @SpecLevel:3
  @Description:
    @@lang:en
    @@@: Describes a location.
  @Attr:
     @@Name:  lineNumber
     @@Description:
        @@@lang:en
        @@@@: The line number to which this locator is pointing.
     @@Get:
        @@@Type:  long
        @@@Description:
          @@@@lang:en
          @@@@@: The line number.
        @@@InCase:
          @@@@Value:-1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: There is no column number available.
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              "Column" in the DOM 3 Specification should be "line"? 
              Or this is correct?
  @Attr:
     @@Name:  columnNumber
     @@Description:
       @@@lang:en
       @@@@: The column number to which this locator is pointing.
     @@Get:
        @@@Type:  long
        @@@Description:
          @@@@lang:en
          @@@@@: The column number.
        @@@InCase:
          @@@@Value:-1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              There is no column number available.
  @Attr:
     @@Name:  byteOffset
     @@Description:
       @@@lang:en
       @@@@:
         The byte offset into the input source to which this locator 
         is pointing.
     @@Get:
        @@@Type:  long
        @@@Description:
          @@@@lang:en
          @@@@@: The byte offset.
        @@@InCase:
          @@@@Value: -1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: There is no byte offset available.
  @Attr:
     @@Name:  utf16Offset
     @@Description:
       @@@lang:en
       @@@@:
         The UTF-16 offset into the input source to which 
         this locator is pointing.
     @@Get:
        @@@Type:  long
        @@@Description:
          @@@@lang:en
          @@@@@: The UTF-16 offset.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: There is no UTF-16 offset available.
  @Attr:
     @@Name:  relatedNode
     @@Description:
       @@@lang:en
       @@@@: The node to which this locator is pointing.
     @@Get:
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@: The node pointed.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: There is no node available.
  @Attr:
     @@Name:  uri
     @@Description:
       @@@lang:en
       @@@@: The URI to which this locator is pointing.
     @@Get:
        @@@Type:
          ManakaiDOM:ManakaiDOMURI
        @@@Description:
          @@@@lang:en
          @@@@@: The URI.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: There is no URI is available.

IF:
  @Name:  DOMConfiguration
  @Description:
    @@lang:en
    @@@:
      The configuration of a document.  It maintains a table 
      of recognized parameters.
  @ImplNote:
    @@lang:en
    @@@:
      Parameters affect: "Document.normalizeDocument", 
      validation, "DOMParser" and "DOMSerializer", etc.
  @Level[list]:  3
  @SpecLevel:3
  @Method:
     @@Name:  setParameter
     @@Param:
        @@@Name:  name
        @@@Type:  DOMString
     @@Param:
        @@@Name:  value
        @@@Type:  DOMUserData
     @@Return:
        @@@Exception[list]:  DOMException
  @Method:
     @@Name:  getParameter
     @@Return:
        @@@Type:  DOMUserData
        @@@Exception[list]:  DOMException
     @@Param:
        @@@Name:  name
        @@@Type:  DOMString
  @Method:
     @@Name:  canSetParameter
     @@Return:
        @@@Type:  boolean
     @@Param:
        @@@Name:  name
        @@@Type:  DOMString
     @@Param:
        @@@Name:  value
        @@@Type:  DOMUserData
  @Attr:
     @@Name:  parameterNames
     @@Get:
        @@@Type:  DOMStringList

IF:
  @Name:  DocumentFragment
  @Description:
    @@lang:en
    @@@: A "lightweight" or "minimal" "Document" object.
  @ISA:  Node

  @IntMethod:
    @@Name: newObject
    @@Description:
      @@@lang:en
      @@@@:
        Construct an object for a new instance of the "DocumentFragment".
      \
        Note that this method is for the internal use.  DOM 
        applications must use the "createDocumentFragment" method 
        of the "Document" interface to create a new "DocumentFragment".
    @@Return:
      @@@Type:
        ManakaiDOM:ManakaiDOMNodeObject
      @@@Description:
        @@@@lang:en
        @@@@@: The new object for the "DocumentFragment".
      @@@Def:
        @@@@Type:
          lang:Perl
        @@@@@:
                            ## Condition sensitive
          $r = __CLASS{Node}__->__INT{newObject}__;
          $r->{<Q:DOMCore:nodeType>} = <Q:DOMCore:DocumentFragment>;          
     @@Level[list]:
       1
       2
       3
  
  @ReAttr:
    @@Name: attributes
    @@Spec:
      @@@DOM3[list]:
        http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-84CF096
        http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-1841493061
    @@Get:
      @@@Type: NamedNodeMap
      @@@DefaultValue:
        @@@@is-null: 1
      @@@Def: \
  @ReAttr:
    @@Name: nodeName
    @@Description:
      @@@lang:en
      @@@@: The node name.
    @@Spec:
      @@@DOM3[list]:
        http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-F68D095
        http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-1841493061
    @@Get:
      @@@Type: DOMString
      @@@InCase:
        @@@@Value:\#document-fragment
        @@@@Description:
          @@@@@lang:en
          @@@@@@: Always this value for the "DocumentFragment" node.
      @@@DefaultValue: \#document-fragment
      @@@Def: \
  @ReAttr:
    @@Name: nodeType
    @@Description:
      @@@lang:en
      @@@@: The type of this node.
    @@Get:
      @@@Type: unsigned-short
      @@@InCase:
        @@@@Label: DOCUMENT_FRAGMENT_NODE
        @@@@Description:
          @@@@@lang:en
          @@@@@@: The node is a "DocumentFragment".
      @@@Def:
        @@@@Type:
          lang:Perl
        @@@@@: $r = __SUPER{Node}__->DOCUMENT_FRAGMENT_NODE;
    @@Redefine: Node

## IF: DocumentFragment

IF:
  @Name:  Document
  @Description:
    @@lang:en
    @@@: 
      The entire document.  It is conceptually the root of the 
      document tree and it provides the primary access to the 
      document's data.

  @ISA:  Node
  @Attr:
     @@Name:  doctype
     @@Description:
       @@@lang:en
       @@@@:
         The "DocumentType" object associated with the "Document".
       \
         Note that even this attribute is defined as read-only, 
         the direct manipulations of child nodes (by the method "insertBefore" 
         for example) can change the document type.
     @@Level[list]:
       1
       2
       3
     @@SpecLevel[list]:
       1
       3
     @@Get:
        @@@Type:  DocumentType
        @@@Description:
          @@@@lang:en
          @@@@@:
            The "DocumentType" object for the "Document".
        @@@InCase:
          @@@@Value: 
            @@@@@is-null: 1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The document type declaration is omitted or it is an HTML 
              document.
            \
              Note: If it is an HTML document, the "doctype" attribute is 
              always "null" in DOM Level 1 and Level 2.  In DOM Level 3, 
              a "DocumentType" object may be returned even if the document 
              does not have explicit document type declaration.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            for (@{$self->{<Q:TreeCore:node>}->{<Q:infoset:children>}}) {
              if ($_->{<Q:DOMCore:nodeType>} eq <Q:DOMCore:DocumentType>) {
                     ## Condition sensitive
                $r = __CLASS{Node}__->__INT{getNodeReference}__ ($_);
                last;
              } elsif ($_->{<Q:DOMCore:nodeType>} eq <Q:infoset:Element>) {
                last;
              }
            }
  @Attr:
     @@Name:  implementation
     @@Description:
       @@@lang:en
       @@@@:
         The "DOMImplementation" object that handles the "Document".
     @@Get:
        @@@Type:  DOMImplementation
        @@@Def:
          @@@@Type:
            lang:dis
          @@@@GetPropNode:
            DOMCore:implementation
  @Attr:
     @@Name:  documentElement
     @@Description:
       @@@lang:en
       @@@@: The child node that is the document element of the document.
     @@Get:
        @@@Type:  Element
        @@@Description:
          @@@@lang:en
          @@@@@: The document element.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The document element not found.
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              The DOM specifications don't mention this case but for example 
              the DOMImplementation.createDocument (null, null, null) can 
              create a Document that does not have the document element.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            for (@{$self->{<Q:TreeCore:node>}->{<Q:infoset:children>}}) {
              if ($_->{<Q:DOMCore:nodeType>} eq <Q:infoset:Element>) {
                     ## Condition sensitive
                $r = __CLASS{Node}__->__INT{getNodeReference}__ ($_);
                last;
              }
            }
    @@Level[list]:
      1
      2
      3
    @@SpecLevel:1
  @Method:
     @@Name:  createElement
     @@Return:
        @@@Type:  Element
        @@@Exception[list]:  DOMException
     @@Param:
        @@@Name:  tagName
        @@@Type:  DOMString
  @Method:
     @@Name:  createDocumentFragment
     @@Return:
        @@@Type:  DocumentFragment
  @Method:
     @@Name:  createTextNode
     @@Return:
        @@@Type:  Text
     @@Param:
        @@@Name:  data
        @@@Type:  DOMString
  @Method:
     @@Name:  createComment
     @@Return:
        @@@Type:  Comment
     @@Param:
        @@@Name:  data
        @@@Type:  DOMString
  @Method:
     @@Name:  createCDATASection
     @@Return:
        @@@Type:  CDATASection
        @@@Exception[list]:  DOMException
     @@Param:
        @@@Name:  data
        @@@Type:  DOMString
  @Method:
     @@Name:  createProcessingInstruction
     @@Return:
        @@@Type:  ProcessingInstruction
        @@@Exception[list]:  DOMException
     @@Param:
        @@@Name:  target
        @@@Type:  DOMString
     @@Param:
        @@@Name:  data
        @@@Type:  DOMString
  @Method:
     @@Name:  createAttribute
     @@Return:
        @@@Type:  Attr
        @@@Exception[list]:  DOMException
     @@Param:
        @@@Name:  name
        @@@Type:  DOMString
  @Method:
     @@Name:  createEntityReference
     @@Return:
        @@@Type:  EntityReference
        @@@Exception[list]:  DOMException
     @@Param:
        @@@Name:  name
        @@@Type:  DOMString
  @Method:
     @@Name:  getElementsByTagName
     @@Return:
        @@@Type:  NodeList
     @@Param:
        @@@Name:  tagname
        @@@Type:  DOMString
  @Method:
     @@Name:  importNode
     @@Return:
        @@@Type:  Node
        @@@Exception[list]:  DOMException
     @@Param:
        @@@Name:  importedNode
        @@@Type:  Node
     @@Param:
        @@@Name:  deep
        @@@Type:  boolean
     @@Level[list]:  2
     @@SpecLevel:2
  @Method:
     @@Name:  createElementNS
     @@Return:
        @@@Type:  Element
        @@@Exception[list]:  DOMException
     @@Param:
        @@@Name:  namespaceURI
        @@@Type:  DOMString
     @@Param:
        @@@Name:  qualifiedName
        @@@Type:  DOMString
     @@Level[list]:  2
     @@SpecLevel:2
  @Method:
     @@Name:  createAttributeNS
     @@Return:
        @@@Type:  Attr
        @@@Exception[list]:  DOMException
     @@Param:
        @@@Name:  namespaceURI
        @@@Type:  DOMString
     @@Param:
        @@@Name:  qualifiedName
        @@@Type:  DOMString
     @@Level[list]:  2
     @@SpecLevel:2
  @Method:
     @@Name:  getElementsByTagNameNS
     @@Return:
        @@@Type:  NodeList
     @@Param:
        @@@Name:  namespaceURI
        @@@Type:  DOMString
     @@Param:
        @@@Name:  localName
        @@@Type:  DOMString
     @@Level[list]:  2
     @@SpecLevel:2
  @Method:
     @@Name:  getElementById
     @@Return:
        @@@Type:  Element
     @@Param:
        @@@Name:  elementId
        @@@Type:  DOMString
     @@Level[list]:  2
     @@SpecLevel:2
  @Attr:
     @@Name:  inputEncoding
     @@Description:
       @@@lang:en
       @@@@:
         The encoding used for this document at the time of 
         the parsing.
       \
         This attribute is corresponding to the [character encoding scheme] 
         property of the document infomation item.
     @@ImplNote:
        @@@lang:en
        @@@@:
          It is unclear what type of values are permitted. 
          IANA-registered charset names? XML encoding declaration 
          names?  Or, any names passed from the upper-level protocols?
     @@Get:
        @@@Type:  DOMString
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The input encoding is not known.
        @@@Def:
          @@@@Type:
            lang:dis
          @@@@GetProp:
            infoset:characterEncodingScheme
     @@Level[list]:  3
     @@SpecLevel:3
  @Attr:
     @@Name:  xmlEncoding
     @@Description:
       @@@lang:en
       @@@@:
         The value of the encoding declaration in the XML declaration 
         of the document.
     @@ImplNote:
       @@@lang:en
       @@@@:
         This attribute is NOT equal to the [character encoding scheme] 
         property of the document information item of the Infoset.
     @@Get:
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The encoding.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The encoding is not specified or not known.
        @@@Def:
          @@@@Type:
            lang:dis
          @@@@GetProp:
            DOMCore:xmlEncoding
     @@Level[list]:  3
     @@SpecLevel:3
  @Attr:
     @@Name:  xmlStandalone
     @@Description:
       @@@lang:en
       @@@@: 
         Whether the document is standalone or not.
       \
         This attribute is corresponding to the standalone declaration 
         in the XML declaration and the [standalone] property of the 
         document information item of the XML Infoset.
     @@ImplNote:
       @@@lang:en
       @@@@: Default false.
     @@Get:
        @@@Type:  boolean
        @@@Def:
          @@@@Type:
            lang:dis
          @@@@GetProp:
            infoset:standalone
     @@Set:
        @@@Type:  boolean
        @@@Description:
          @@@@lang:en
          @@@@@: Whether standalone or not.
        @@@InCase:
          @@@@Value: true
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Standalone "yes".  Note that no verification is done when 
              setting the value.  DOM applications should use 
              the method "normalizeDocument" with the "validate" parameter 
              to verify whether the value match the Validity Constraint.
        @@@InCase:
          @@@@Value: false
          @@@@Description:
            @@@@@lang:en
            @@@@@@: Standalone "no".
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NOT_SUPPORTED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The document does not support the "XML" feature.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            my $node = $self->{<Q:TreeCore:node>};
            if ($node->{<Q:DOMCore:hasFeature>}->{XML}) {
              __EXCEPTION{
                DOMException.NOT_SUPPORTED_ERR:
                  <Q:MDOM_EXCEPTION:subtype>
                     => <Q:MDOM_EXCEPTION:MDOM_NOT_SUPPORTED_DOC_XML>,
              }__;
            }
            $node->{<Q:infoset:standalone>} = $given;
     @@Level[list]:  3
     @@SpecLevel:3
  @Attr:
     @@Name:  xmlVersion
     @@Description:
       @@@lang:en
       @@@@:
         The version number of the document.
      \
         This attribute is corresponding to the version declaration in the 
         XML declaration and [version] property of the document information 
         item of the XML Infoset.
     @@Get:
        @@@Type:  DOMString
        @@@InCase:
          @@@@Value: 1.0
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The XML version is specified as XML 1.0 or the XML document 
              has no version declaration.
        @@@InCase:
          @@@@Value: 1.1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The XML version is specified as XML 1.1.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The document does not support the "XML" feature.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            __INT{{getDocumentXMLVersion}}__;
     @@Set:
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            The XML version number of the document.  Note that 
            changing this attribute will affect methods that 
            check for invalid characters in XML "Name"s.  DOM 
            application should invoke the method "normalizeDocument" in 
            order to check for invalid characters in the "Node"s that 
            are already part of the document.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NOT_SUPPORTED_ERR
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            my $node = $self->{<Q:TreeCore:node>};
            if (defined $node->{<Q:DOMCore:hasFeature>}->{XML}) {
              if ($given and
                  ($given eq '1.0' or $given eq '1.1')) {
                $node->{<Q:infoset:version>} = $given;
              } else {
                __EXCEPTION{
                  DOMException.NOT_SUPPORTED_ERR:
                    <Q:MDOM_EXCEPTION:subtype>
                       => <Q:MDOM_EXCEPTION:MDOM_NOT_SUPPORTED_XMLVER>,
                    <Q:infoset:version> => $given,
                }__;
              }
            } else {
              __EXCEPTION{
                DOMException.NOT_SUPPORTED_ERR:
                  <Q:MDOM_EXCEPTION:subtype>
                     => <Q:MDOM_EXCEPTION:MDOM_NOT_SUPPORTED_DOC_XML>,
              }__;
            }
     @@Level[list]:  3
     @@SpecLevel:3
  @IntMethod:
    @@Name: getDocumentXMLVersion
    @@Description:
      @@@lang:en
      @@@@:
        Return the XML version of the document.  This method is 
        same as the getting of the attribute "xmlVersion" but 
        introduced for the internal use.
    @@Return:
      @@@Type: DOMString
      @@@Def:
        @@@@Type:
          lang:Perl
        @@@@@:
          my $node = $self->{<Q:TreeCore:node>};
          $r = defined $node->{<Q:DOMCore:hasFeature>}->{XML} ?
                 defined $node->{<Q:infoset:version>} ?
                   $node->{<Q:infoset:version>} : '1.0' : null;
  @Attr:
     @@Name:  strictErrorChecking
     @@Description:
       @@@lang:en
       @@@@:
         Whether error checking is enforced or not.
     @@Get:
        @@@Type:  boolean
        @@@Def:
          @@@@Type:
            lang:dis
          @@@@GetProp:
            DOMCore:strictErrorChecking
     @@Set:
        @@@Type:  boolean
        @@@Description:
          @@@@lang:en
          @@@@@: Whether error checking is enforced or not.
        @@@InCase:
          @@@@Value: false
          @@@@@: 
            The implementation is free to not every possible error 
            case normally defined on DOM operations, and not raise any 
            "DOMException" on DOM operations or report error 
            while using method "normalizeDocument".  In case of error, 
            the behavior is undefined.
        @@@Def:
          @@@@Type:
            lang:dis
          @@@@SetProp:
            DOMCore:strictErrorChecking
     @@Level[list]:  3
     @@SpecLevel:3
     @@ImplNote:
       @@@lang:en
       @@@@: This attribute is "true" by default.
  @Attr:
     @@Name:  documentURI
     @@Description:
       @@@lang:en
       @@@@: The location of the document.
     @@Level[list]:  3
     @@SpecLevel:3
     @@Get:
        @@@Type:
          ManakaiDOM:ManakaiDOMURI
        @@@Description:
          @@@@lang:en
          @@@@@: The location of the document.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The location is undefined or the "Document" was created using 
              the method "createDocument".
        @@@Def:
          @@@@Type:
            lang:dis
          @@@@GetProp:
            DOMCore:documentURI
     @@Set:
        @@@Type:
          ManakaiDOM:ManakaiDOMURI
        @@@Description:
          @@@@lang:en
          @@@@@: 
            The location of the document.  Note that no lexical checking is 
            performed.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The location is undefined.
        @@@Def:
          @@@@Type:
            lang:dis
          @@@@SetProp:
            DOMCore:documentURI
  @Method:
     @@Name:  adoptNode
     @@Return:
        @@@Type:  Node
        @@@Exception[list]:  DOMException
     @@Param:
        @@@Name:  source
        @@@Type:  Node
     @@Level[list]:  3
     @@SpecLevel:3
  @Attr:
     @@Name:  domConfig
     @@Description:
       @@@lang:en
       @@@@: The configuration used when "normalizeDocument" is invoked.
     @@Get:
        @@@Type:  DOMConfiguration
        @@@Description:
          @@@@lang:en
          @@@@@: The DOM configuration object.
        @@@Def:
          @@@@Type:
            lang:dis
          @@@@GetProp:
            DOMCore:domConfig
     @@Level[list]:  3
     @@SpecLevel:3
  @Method:
     @@Name:  normalizeDocument
     @@Level[list]:  3
     @@SpecLevel:3
  @Method:
     @@Name:  renameNode
     @@Return:
        @@@Type:  Node
        @@@Exception[list]:  DOMException
     @@Param:
        @@@Name:  n
        @@@Type:  Node
     @@Param:
        @@@Name:  namespaceURI
        @@@Type:  DOMString
     @@Param:
        @@@Name:  qualifiedName
        @@@Type:  DOMString
     @@Level[list]:  3
     @@SpecLevel:3
  
  @ReAttr:
    @@Name: attributes
    @@Spec:
      @@@DOM3[list]:
        http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-84CF096
        http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-1841493061
    @@Get:
      @@@Type: NamedNodeMap
      @@@Def:
        @@@@Type:
          lang:Perl
        @@@@@:
          $r = null;
  @ReAttr:
    @@Name: nodeName
    @@Description:
      @@@lang:en
      @@@@: The node name.
    @@Spec:
      @@@DOM3[list]:
        http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-F68D095
        http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/core.html#ID-1841493061
    @@Get:
      @@@Type: DOMString
      @@@InCase:
        @@@@Value:\#document
        @@@@Description:
          @@@@@lang:en
          @@@@@@: Always this value for the "Document" node.
      @@@DefaultValue: \#document
      @@@Def: \
  @ReAttr:
    @@Name: nodeType
    @@Description:
      @@@lang:en
      @@@@: The type of this node.
    @@Get:
      @@@Type: unsigned-short
      @@@InCase:
        @@@@Label: DOCUMENT_NODE
        @@@@Description:
          @@@@@lang:en
          @@@@@@: The node is a "Document".
      @@@Def:
        @@@@Type:
          lang:Perl
        @@@@@: $r = __SUPER{Node}__->DOCUMENT_NODE;
    @@Redefine: Node
  @ReAttr:
     @@Name:  textContent
     @@Description:
       @@@lang:en
       @@@@:
         The text content of this node and its descendants.
     @@Get:
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The text content of this node.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The text content is defined to be "null".
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@: $r = null;
     @@Set:
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: Setting this attribute has no effect.
        @@@Warning:
          @@@@Type:
            ManakaiDOM:ManakaiDOMImplementationWarning
          @@@@Name: ATTR_SET_NO_EFFECT
          @@@@Descriptin:
            @@@@@lang:en
            @@@@@@: Setting this attribute has no effect.
        @@@Def: \
     @@Level[list]: 3
     @@SpecLevel:3
     @@Redefine: Node
  @IntMethod:
    @@Name: newObject
    @@Description:
      @@@lang:en
      @@@@:
        Construct an object for the new instance of the "Document".
      \
        Note that this method is for the internal use.  DOM 
        applications must use the "createDocument" method 
        of the "DOMImplementation" interface to create a new "Document".
    @@ImplNote:
      @@@lang:en
      @@@@:
        The caller of this internal method MUST ensure to set 
        the attributes: <Q:TreeCore:implementation>.
    @@Return:
      @@@Type:
        ManakaiDOM:ManakaiDOMNodeObject
      @@@Description:
        @@@@lang:en
        @@@@@: The new object for the "Document".
      @@@Def:
        @@@@Type:
          lang:Perl
        @@@@@:
          $r = __CLASS{Node}__->__INT{newObject}__;
          $r->{<Q:DOMCore:nodeType>} = <Q:infoset:Document>;
          $r->{<Q:infoset:version>} = '1.0';
          $r->{<Q:DOMCore:strictErrorChecking>} = true;
       @@@ImplNote:
         @@@@lang:en
         @@@@@:
           Other properties required to be a legal "Document" object:
           DOMCore:implementation.
         \
           Default-null (or false) properties: DOMCore:read-only,
           infoset:characterEncodingScheme, DOMCore:xmlEncoding,
           infoset:standalone,
           DOMCore:documentURI, DOMCore:domConfig.
    @@Level[list]:
      1
      2
      3

## IF: Document

## DOMCore.dis ends here
