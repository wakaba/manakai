Module:
  @QName: MDOM|XMLParser
  @Namespace:
    http://suika.fam.cx/~wakaba/archive/2004/dom/xml-parser#

  @FullName:
    @@lang:en
    @@@: XML Parser

  @DISCore:author: DISCore|Wakaba
  @License: license|Perl+MPL
  @Date:
    $Date: 2006/02/12 06:42:15 $

  @DefaultFor: ManakaiDOM|ManakaiDOMLatest

  @Require:
    @@Module:
      @@@QName: MDOM|DOMLS
      @@@WithFor: ManakaiDOM|ManakaiDOMLatest
    @@Module:
      @@@QName: MDOM|XDoctype
      @@@WithFor: ManakaiDOM|ManakaiDOMLatest

Namespace:
  @c:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#
  @cfg:
    http://suika.fam.cx/www/2006/dom-config/
  @d:
    http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#
  @dis:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#dis--
  @dtest:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS#Test/
  @dx:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#
  @ecore:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/Core/
  @f:
    http://suika.fam.cx/~wakaba/archive/2004/dom/feature#
  @fe:
    http://suika.fam.cx/www/2006/feature/
  @gls:
    http://suika.fam.cx/~wakaba/archive/2004/dom/gls#
  @idl:
    http://suika.fam.cx/~wakaba/archive/2004/dis/IDL#
  @infoset:
     http://www.w3.org/2001/04/infoset#
  @lang:
     http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#
  @license:
     http://suika.fam.cx/~wakaba/archive/2004/8/18/license#
  @LSEV:
    http://www.w3.org/2002/DOMLS
  @ManakaiDOM:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#
  @ManakaiDOMLS:
    http://suika.fam.cx/~wakaba/archive/2004/mdom-ls#
  @MDOM:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#ManakaiDOM.
  @MDOMX:
    http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#
  @mn:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/ManakaiNode#
  @rdf:
    http://www.w3.org/1999/02/22-rdf-syntax-ns#
  @rdfs:
    http://www.w3.org/2000/01/rdf-schema#
  @t:
    http://suika.fam.cx/~wakaba/archive/2004/dom/tree#
  @test:
    http://suika.fam.cx/~wakaba/archive/2004/dis/Test#
  @x:
    http://suika.fam.cx/~wakaba/archive/2004/dom/xml#
  @xml:
    http://www.w3.org/XML/1998/namespace
  @xml-dtd:
    http://www.w3.org/TR/REC-xml
  @xmlns:
    http://www.w3.org/2000/xmlns/
  @xp:
    http://suika.fam.cx/~wakaba/archive/2004/dom/xml-parser#

## -- Features

ElementTypeBinding:
  @Name: FeatureDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: f|Feature
    @@For: =ManakaiDOM|all

ElementTypeBinding:
  @Name: FeatureVerDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: f|Feature

ElementTypeBinding:
  @Name: featureQName
  @ElementType:
    f:name
  @ShadowContent:
    @@ContentType: DISCore|QName

ResourceDef:
  @QName: DOMString
  @AliasFor: DOMMain|DOMString
  @For: ManakaiDOM|DOM

ResourceDef:
  @QName: Node
  @AliasFor: t|Node
  @For: ManakaiDOM|DOM

ResourceDef:
  @QName: Element
  @AliasFor: t|Element
  @For: ManakaiDOM|DOM

ResourceDef:
  @QName: Document
  @AliasFor: t|Document
  @For: ManakaiDOM|DOM

ResourceDef:
  @QName: DocumentXDoctype
  @AliasFor: d|DocumentXDoctype
  @For: ManakaiDOM|DOM

ResourceDef:
  @QName: DTDef
  @AliasFor: d|DocumentTypeDefinition
  @For: ManakaiDOM|DOM

ResourceDef:
  @QName: ETDef
  @AliasFor: d|ElementTypeDefinition
  @For: ManakaiDOM|DOM

ResourceDef:
  @QName: ATDef
  @AliasFor: d|AttributeDefinition
  @For: ManakaiDOM|DOM

ElementTypeBinding:
  @Name: ClsDef
  @ElementType: 
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      @@@@: dis|MultipleResource
      @@@ForCheck: !ManakaiDOM|ForIF !ManakaiDOM|ForClass
    @@resourceFor:
      @@@@: ManakaiDOM|ForClass
      @@@ForCheck: ManakaiDOM|ManakaiDOM !=ManakaiDOM|ManakaiDOM
    @@For: ManakaiDOM|DOM3
    @@For: =ManakaiDOM|ManakaiDOM

    @@rdf:type:
      @@@@: DISLang|Class
      @@@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: ClsQName
  @ElementType:
    dis:QName
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: ClsISA
  @ElementType:
    dis:ISA
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: nullCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: ManakaiDOM|InCase
    @@Value:
      @@@is-null:1

ResourceDef:
  @QName: LSParser
  @AliasFor: DOMLS|LSParser
  @For: ManakaiDOM|DOM3

ClsDef:
  @ClsQName: ManakaiXMLParser
  
  @Implement: DOMLS|LSParser

  @f:implements:
    @@@: DOMLS|LSFeature30
    @@For: ManakaiDOM|DOM3

  @DISLang:role: gls|ParserRole

  @enDesc:
    Note that the <Class::ManakaiXMLParser> reports any XML errors
    (syntax errors and / or well-formedness constraint errors)
    via the <IF::DOMCore:error-handler> registered to
    the <A::DOMLS:LSParser.domConfig> object.  Each error has
    its <A::DOMCore:DOMError.severity>, either <C::DOMCore:SEVERITY_ERROR>
    or <C::DOMCore:SEVERITY_FATAL_ERROR>.  However, their semantics
    are slight different from the ones of <QUOTE::error> and
    <QUOTE::fatal error> in XML; in this implemenetation, 
    <C::DOMCore:SEVERITY_ERROR> implies that the parsing process
    can effectively be continued to detect more errors while
    <C::DOMCore:SEVERITY_FATAL_ERROR> implies that the error
    is serious so that the result document tree and any errors
    might be far from the ones obtained when the error would not
    be found.

  @Attr:
    @@Name: domConfig
    @@enDesc:
      The configuration of the parser.

    @@Get:
      @@@Type: DOMCore|DOMConfiguration
      @@@enDesc: The DOM configuration object.
      @@@PerlDef:
        __CODE{DOMCore|getConfigObject::
          $target => $self,
          $targetHash => $self,
          $targetType => {<IFName::LSParser>},
          $result => $r,
        }__;

  @Method:
    @@ManakaiDOM:isForInternal:1
    @@ForCheck: ManakaiDOM|ForClass
    @@Operator: DISPerl|NewMethod
    @@enDesc:
      Creates a new instance of the object.
    @@Param:
      @@@Name: impl
      @@@Type: gls|GLSImplementation
      @@@enDesc:
        The implementation from which the parser is created.
    @@Param:
      @@@Name: features
      @@@Type: DOMString
      @@@dis:actualType: f|FeaturesString
      @@@enDesc:
        The set of features requested for the parser.
    @@Return:
      @@@Type: DOMMain|DOMObject
      @@@dis:actualType: LSParser
      @@@enDesc:
        The newly created parser.
      @@@PerlDef:
        $r = bless {
          <H::DOMCore:implementation> => $impl,
        }, $self;

  @Method:
    @@Name: parseString
    @@enImplNote:
      Non-standard - to be removed

    @@Param:
      @@@Name: sourceText
      @@@Type: DOMString
    @@Return:
      @@@Type: Document
      @@@PerlDef:

        $self->{char} = [];
        $self->{token} = [];
        $self->{entity} = [{
          reptxt => \$sourceText,
          line => 1,
          column => 1,
          pos => 0,
        }];
        $self->{location} = $self->{entity}->[-1];
        $self->{entity_char} = [];
        $self->{entity_token} = [];
        $self->{xml_version} = '1.0';
        $self->{standalone} = false;
        $self->{has_xref} = false;
        $self->{general_entity} = {
          lt => {is_predefined => true},
          gt => {is_predefined => true},
          amp => {is_predefined => true},
          quot => {is_predefined => true},
          apos => {is_predefined => true},
        };
        $self->{param_entity} = {};
        $self->{attr} = {};
          # $self->{attr}->{$element_type_name}->{$attr_name} = $attr_def

          ## Well-formedness constraint Entity Declared takes effect?

        __DEEP{
          $r = $self->{<H::c|implementation>}-><M::DOMImpl.createDocument>;
          $r-><AS::Document.strictErrorChecking> (false);
          $self->{doc} = $r;
          CORE::delete $self->{docx};
          CORE::delete $self->{dtdef};
          CORE::delete $self->{dtdecl};
          $self->{cfg} = $r-><AG::Document.domConfig>;
          local $r->{<H::mn:node>}
                  ->{<H::cfg|entity-reference-read-only>} = false;

          ## Document entity -> |Document| node
          $self->_parse_DocumentEntity;

          ## Replacement tree for general |Entity| nodes
          my @ent = values %{$self->{general_entity}};
          for my $ent (@ent) {
            if (exists $ent->{has_replacement_text}) {
                my $ent_name = $ent->{name};
                $self->{entity} = [<Code::getCopyOfEntityState::
                                              $entity_type = 'general_entity',
                                              $entity_name = $ent_name>];
                $self->{location} = $self->{entity}->[-1];
                $self->{token} = [];
                $self->{char} = [];
                ## TODO: External entity support
                $self->_parse_InternalGeneralParsedEntity ($ent->{node});
                $ent->{node}-><AS::x|Entity.hasReplacementTree> (true);
            }
              ## TODO: Read-only if configuration (for all entities)
          }

          $r-><AS::Document.strictErrorChecking> (true);
        }__;

  @Method:
    @@Name: shiftChar
    @@ManakaiDOM:isForInternal:1
    @@ForCheck: ManakaiDOM|ForClass
    @@enDesc:
      Returns the next character.
    @@Return:
      @@@Type: idl|long||ManakaiDOM|all
      @@@enDesc:
        The code position number of the next character, if any,
        or <CODE::-1>.
      @@@PerlDef:
        if (@{$self->{char}}) {
          $r = shift @{$self->{char}};
        } else {
          no warnings 'substr';
            ## substr outside length warnings at the end of the string
          GETCHAR: {
            my $char = substr (${$self->{entity}->[-1]->{reptxt}},
                               $self->{entity}->[-1]->{pos}, 1);

            if (defined $char and length $char) {
              $self->{entity}->[-1]->{pos}++;
              $r = ord $char;
              if ($r == 0x000A) {
                $self->{entity}->[-1]->{line}++;
                $self->{entity}->[-1]->{column} = 1;
              } elsif ($r == 0x000D) {
                my $next_char = substr (${$self->{entity}->[-1]->{reptxt}},
                                        $self->{entity}->[-1]->{pos}, 1);
                if ($next_char eq "\x0A") {
                  $self->{entity}->[-1]->{pos}++;
                  $self->{entity}->[-1]->{line}++;
                  $self->{entity}->[-1]->{column} = 1;
                } elsif ($next_char eq "\x85") {
                  if ($self->{xml_version} eq '1.1') {
                    if ($self->{entity}->[-1]->{no_xml11_eol}) {
                      my $location = {
                        utf32_offset => $self->{entity}->[-1]->{pos} - 1,
                        line_number => $self->{entity}->[-1]->{line},
                        column_number => $self->{entity}->[-1]->{column},
                      };
                      my $continue = __DOMCore:ERROR{
                      xp|fatal-xml11-end-of-line-in-xml-declaration::
                        DOMCore|location => {$location},
                        xp|character-number => {$r},
                      }__;
                      unless ($continue) {
                        __EXCEPTION{DOMLS|PARSE_ERR}__;
                      }
                    } # no_xml11_eol
                    $self->{entity}->[-1]->{pos}++; 
                    $self->{entity}->[-1]->{line}++;
                    $self->{entity}->[-1]->{column} = 1;
                  } else {
                    ## |no_xml11_eol| will be tested later.
                    $self->{entity}->[-1]->{column}++;
                    ## Line number will be increased by next |shiftChar| call.
                  }
                } else {
                  $self->{entity}->[-1]->{line}++;
                  $self->{entity}->[-1]->{column} = 1;
                }
                $r = 0x000A;
              } elsif (
                not ((0x0020 <= $r and $r <= 0x007E) or
                     (0x00A0 <= $r and $r <= 0xD7FF) or
                     (0xE000 <= $r and $r <= 0xFFFD) or
                     (0x10000 <= $r and $r <= 0x10FFFF)) and
                $r != 0x0009 and $r != 0x0085 and
                not ($self->{xml_version} eq '1.0' and
                     (0x007F <= $r and $r <= 0x009F))
              ) {
                my $location = {
                  utf32_offset => $self->{entity}->[-1]->{pos} - 1,
                  line_number => $self->{entity}->[-1]->{line},
                  column_number => $self->{entity}->[-1]->{column},
                };
                my $continue = __DOMCore:ERROR{xp|wf-legal-literal-character::
                  DOMCore|location => {$location},
                  xp|character-number => {$r},
                }__;
                unless ($continue) {
                  __EXCEPTION{DOMLS|PARSE_ERR}__;
                }
                $self->{entity}->[-1]->{column}++;
              } elsif ($r == 0x0085 or $r == 0x2028) {
                if ($self->{entity}->[-1]->{no_xml11_eol}) {
                  my $location = {
                    utf32_offset => $self->{entity}->[-1]->{pos} - 1,
                    line_number => $self->{entity}->[-1]->{line},
                    column_number => $self->{entity}->[-1]->{column},
                  };
                  my $continue = __DOMCore:ERROR{
                  xp|fatal-xml11-end-of-line-in-xml-declaration::
                    DOMCore|location => {$location},
                    xp|character-number => {$r},
                  }__;
                  unless ($continue) {
                    __EXCEPTION{DOMLS|PARSE_ERR}__;
                  }
                } # no_xml11_eol
                $r = 0x000A if $self->{xml_version} eq '1.1';
                ## Even in XML 1.0 it increases the line number.
                $self->{entity}->[-1]->{line}++;
                $self->{entity}->[-1]->{column} = 1;
              } else {
                $self->{entity}->[-1]->{column}++;
              }
            } else {
              $r = -1;
            }
          } # GETCHAR
        }

  @Method:
    @@ManakaiDOM:isForInternal: 1
    @@Operator: ManakaiDOM|MUErrorHandler
    @@enDesc:
      When a <IF::ecore|ErrorInterface||ManakaiDOM|Perl> is <Perl::report>ed,
      then this method is invoked.
      
      The method calls the <cfg::DOMCore|error-handler> if the error is of 
      <IF::DOMCore|DOMError>.  Otherwise, the error is re-thrown so that
      corresponding <Perl::catch> clause, if any, can catch the error.
    @@Param:
      @@@Name: err
      @@@Type: ecore|ErrorInterface||ManakaiDOM|Perl
      @@@enDesc:
        The reported error object.
    @@Return:
      @@@Type: DISPerl|Any
      @@@enDesc:
        If the <P::err> is a <IF::DOMCore|DOMError>, then the return value
        of the error handler.

           {NOTE:: If the error is thrown, the method never returns.
           }
      @@@nullCase:
        @@@@enDesc:
          No error handler.
      @@@PerlDef:
        if ($err->isa (<IFName::DOMCore|DOMError||ManakaiDOM|ManakaiDOM>)) {
          __DEEP{
            A: {
              my $cfg = $self-><AG::LSParser.domConfig>;
              my $h = $cfg-><M::DOMCore|DOMConfiguration.getParameter>
                               ('error-handler');
              $r = $h-><M::DOMCore|DOMErrorHandler.handleError> ($err);
            } # A
          }__;
        } else {
          $err-><M::ecore|ErrorInterface||ManakaiDOM|Perl.throw>;
        }

  @DISPerl:dpgDef:

    /*
      XML Document Entity
      
        document := prolog element *Misc
                  - *Char RestrictedChar *Char  ;; [1]
    */
    rule DocumentEntity : standalone {
      /*
        prolog := XMLDecl? *Misc [doctypedecl *Misc]  ;; [22]
      */
      ?lexmode DocumentStart;

      my $doc;
      lang:Perl {
        $doc = $self->{doc};
      }
      
      ~? (XDO) {
        ?lexmode XMLDeclarationOrPI;
        lang:Perl {
          $self->{entity}->[-1]->{no_xml11_eol} = true;
        }
        ~ (S) {        // XML declaration
          &_XMLDeclaration_ ($doc => $doc);
          ~ (PIC2) {
            ?lexmode DocumentProlog;
          } else {
            ?lexmode DocumentProlog;
          }
        } (NameChar) {  // Processing instruction whose target begins with |xml|
          my $target_token;
          lang:Perl ($v => $token.value) {
            $target_token = $token;
            $target_token->{value} = 'xml'.$target_token->{value};
            $self->{entity}->[-1]->{no_xml11_eol} = false;
          }
          ?lexmode PINmtoken;
          ~? (Nmtoken) {
            lang:Perl ($v => $token.value) {
              $target_token->{value} .= $v;
            }
            ?lexmode PIName;
          }
          lang:Perl {
            $target_token->{type} = 'Name';
            $target_token->{location_d} += 3; # 'xml'
            unshift @{$self->{token}}, $token;
            $token = $target_token;
          }
          &_ProcessingInstruction_ ($doc => $doc, $parent => $doc);
          ~ (PIC) {
            ?lexmode DocumentProlog;
          } else {
            ?lexmode DocumentProlog;
          }
        } else {
          lang:Perl {
            $self->{entity}->[-1]->{no_xml11_eol} = false;
          }
        }
      } else {
        ?lexmode 'DocumentProlog';
      }
      
      // *Misc
      ~* (CDO) {
        &_CommentDeclaration_ ($doc => $doc, $parent => $doc);

        ~ (MDC) {
          ?lexmode DocumentProlog;
        } else {
          ?lexmode DocumentProlog;
        }
      } (PIO) {
        &_ProcessingInstruction_ ($doc => $doc, $parent => $doc);

        ~ (PIC) {
          ?lexmode 'DocumentProlog';
        } else {
          ?lexmode DocumentProlog;
        }
      } (S) {
        //
      }
      
      // doctypedecl
      ~? (MDO) {
        &_DocumentTypeDeclaration_ ($doc => $doc);

        ~ (MDC) {
          ?lexmode DocumentMisc;
        } else {
          ?lexmode DocumentMisc;
        }
      } else {
        ?lexmode DocumentMisc;
      }
      
      // *Misc
      ~* (CDO) {
        &_CommentDeclaration_ ($doc => $doc, $parent => $doc);

        ~ (MDC) {
          ?lexmode DocumentMisc;
        } else {
          ?lexmode DocumentMisc;
        }
      } (PIO) {
        &_ProcessingInstruction_ ($doc => $doc, $parent => $doc);

        ~ (PIC) {
          ?lexmode 'DocumentMisc';
        } else {
          ?lexmode DocumentMisc;
        }
      } (S) {
        //
      }
      
      // Document element
      ~ (STAGO) {
        &Element_ ($doc => $doc, $parent => $doc)
          : unshift-current-token;
        ~ (TAGC) {
          ?lexmode DocumentEnd;
        } else {
          ?lexmode DocumentEnd;
        }
      } else {
        ?lexmode 'DocumentEnd';
      }
      
      // *Misc
      ~* (CDO) {
        &_CommentDeclaration_ ($doc => $doc, $parent => $doc);

        ~ (MDC) {
          ?lexmode DocumentEnd;
        } else {
          ?lexmode DocumentEnd;
        }
      } (PIO) {
        &_ProcessingInstruction_ ($doc => $doc, $parent => $doc);
        ~ (PIC) {
          ?lexmode 'DocumentEnd';
        } else {
          ?lexmode DocumentEnd;
        }
      } (S) {
        //
      }
      
      ~ (#EOF) { }
    } // DocumentEntity
 
    /*
      Internal General Parsed Entity
 
        An internal general parsed entity is well-formed if its
        replacement text matches the production labeled |content|.
    */
    rule InternalGeneralParsedEntity ($ent) : standalone {
      ?lexmode ElementContent;

      my $ns;
      lang:Perl {
        $ns = {
          xml => <Q::xml:>,
          xmlns => <Q::xmlns:>,
        };
      }

      &content ($parent => $ent, $ns => $ns);

      ~ (#EOF) { }
    } // InternalGeneralParsedEntity
 
    /*
      XML Declaration
      
        XMLDecl := '<?xml' VersionInfo
                           [EncodingDecl]
                           [SDDecl]
                           [S] '?>'  ;; [23]
      
      NOTE: XML declaration is optional in XML 1.0
            while it is required in XML 1.1.
    */
    rule _XMLDeclaration_ {
      // ~ (XDO) { }
      ?lexmode XMLDeclaration;
      //lang:Perl {
      //  $self->{entity}->[-1]->{no_xml11_eol} = true;
      //}
      //~ (S) { }

      ~ (Name == 'version') {
        ~? (S) { }
        ~ (VI) { }
        ~? (S) { }

        my $ver;
        my $bad_token;

        ~ (LIT) {
          ?lexmode AttributeValueLiteral;
          
          ~ (STRING) {
            lang:Perl ($version => $token.value) {
              $ver = $version;
              $bad_token = $token;
            }
          }
    
          ~ (LIT) {
            ?lexmode XMLDeclaration;
          }
        } (LITA) {
          ?lexmode AttributeValueLiteralA;
          
          ~ (STRING) {
            lang:Perl ($version => $token.value) {
              $ver = $version;
              $bad_token = $token;
            }
          }
    
          ~ (LITA) {
            ?lexmode XMLDeclaration;
          }
        }

        lang:Perl : has-error {
          unless ($ver eq '1.0' or $ver eq '1.1') {
            my $location;
            __CODE{xp|get-location-from-token::
              $token => {$bad_token},
              $result => {$location},
            }__;
            my $continue = __DOMCore:ERROR{xp|wf-unsupported-xml-version::
              DOMCore|location => {$location},
              xp|parent => {$self->{doc}},
              infoset|version => {$ver},
              xp|error-token => {$bad_token},
            }__;
            unless ($continue) {
              __EXCEPTION{DOMLS|PARSE_ERR}__;
            }
          }
          $self->{doc}-><AS::Document.xmlVersion> ($ver);
          $self->{xml_version} = $ver;
        }

        ~? (S) { }
      }

      ~? (Name == 'encoding') {
        ~? (S) { }
        ~ (VI) { }
        ~? (S) { }

        my $ver;
        my $bad_token;

        ~ (LIT) {
          ?lexmode AttributeValueLiteral;
          
          ~ (STRING) {
            lang:Perl ($version => $token.value) {
              $ver = $version;
              $bad_token = $token;
            }
          }
    
          ~ (LIT) {
            ?lexmode XMLDeclaration;
          }
        } (LITA) {
          ?lexmode AttributeValueLiteralA;
          
          ~ (STRING) {
            lang:Perl ($version => $token.value) {
              $ver = $version;
              $bad_token = $token;
            }
          }
    
          ~ (LITA) {
            ?lexmode XMLDeclaration;
          }
        }

        lang:Perl : has-error {
          unless ($ver =~ /\A[A-Za-z][A-Za-z0-9._-]*\z/) {
            my $location;
            __CODE{xp|get-location-from-token::
              $token => {$bad_token},
              $result => {$location},
            }__;
            my $continue = __DOMCore:ERROR{xp|wf-malformed-enc-name::
              DOMCore|location => {$location},
              xp|parent => {$self->{doc}},
              xp|name => {$ver},
              xp|error-token => {$bad_token},
            }__;
            unless ($continue) {
              __EXCEPTION{DOMLS|PARSE_ERR}__;
            }
          }
          $self->{doc}-><AS::Document.xmlEncoding> ($ver);
        }

        ~? (S) { }
      }

      ~? (Name == 'standalone') {
        ~? (S) { }
        ~ (VI) { }
        ~? (S) { }

        my $ver;
        my $bad_token;

        ~ (LIT) {
          ?lexmode AttributeValueLiteral;
          
          ~ (STRING) {
            lang:Perl ($version => $token.value) {
              $ver = $version;
              $bad_token = $token;
            }
          }
    
          ~ (LIT) {
            ?lexmode XMLDeclaration;
          }
        } (LITA) {
          ?lexmode AttributeValueLiteralA;
          
          ~ (STRING) {
            lang:Perl ($version => $token.value) {
              $ver = $version;
              $bad_token = $token;
            }
          }
    
          ~ (LITA) {
            ?lexmode XMLDeclaration;
          }
        }

        lang:Perl : has-error {
          unless ($ver eq 'yes' or $ver eq 'no') {
            my $location;
            __CODE{xp|get-location-from-token::
              $token => {$bad_token},
              $result => {$location},
            }__;
            my $continue = __DOMCore:ERROR{xp|wf-malformed-xml-standalone::
              DOMCore|location => {$location},
              xp|parent => {$self->{doc}},
              xp|name => {$ver},
              xp|error-token => {$bad_token},
            }__;
            unless ($continue) {
              __EXCEPTION{DOMLS|PARSE_ERR}__;
            }
          }
          if ($ver eq 'yes') {
            $self->{doc}-><AS::Document.xmlStandalone> (true);
            $self->{standalone} = true;
          }
        }

        ~? (S) { }
      }

      ~ (PIC1) {
        lang:Perl {
          $self->{entity}->[-1]->{no_xml11_eol} = false;
        }
      } else {
        lang:Perl {
          $self->{entity}->[-1]->{no_xml11_eol} = false;
        }
      }

      // ~ (PIC2) { }
    } // _XMLDeclaration_
    
    /*
      Comment Declaration
      
        Comment := '<!--' *(Char - '-' / '-' (Char - '-'))
                   '-->'  ;; [15]
    */ 
    rule _CommentDeclaration_ ($doc, $parent) {
      ?lexmode 'CommentDeclaration';
      
      ~? (STRING) {
        lang:Perl ($data => $token.value) {
          my $com = $doc-><M::Document.createComment> ($data);
          $parent-><M::Node.appendChild> ($com);
        }
      } else {
        lang:Perl {
          my $com = $doc-><M::Document.createComment> ('');
          $parent-><M::Node.appendChild> ($com);
        }
      }
      
      ~ (COM) {
        ?lexmode MarkupDeclaration;
      } else {
        ?lexmode MarkupDeclaration;
      }
      
      // ~ (MDC) { }
    } // _CommentDeclaration

    rule _CommentDeclarationDTD {
      ?lexmode CommentDeclaration;
      
      ~? (STRING) {
        //
      }
      
      ~ (COM) {
        ?lexmode MarkupDeclaration;
      } else {
        ?lexmode MarkupDeclaration;
      }
      
      ~ (MDC) {
        ?lexmode DTD;
      } else {
        ?lexmode DTD;
      }
    } // _CommentDeclarationDTD
   
    /*
      Processing Instruction
      
        PI := '<?' PITarget [S *Char - *Char '?>' *Char]
              '?>'  ;; [16]
    */
    rule _ProcessingInstruction_ ($doc, $parent) {
      ?lexmode 'PIName';
      
      my $pi;
      
      ~ (Name) {
        lang:Perl ($name => $token.value) : has-error {
          if (lc $name eq 'xml') {
            my $location;
            __CODE{xp|get-location-from-token::
              $token => {$token},
              $result => {$location},
            }__;
            my $continue = __DOMCore:ERROR{xp|wf-pi-target-is-xml::
              xp|name => {$name},
              DOMCore|location => {$location},
              xp|parent => {$parent},
            }__;
            unless ($continue) {
              __EXCEPTION{DOMLS|PARSE_ERR::
              }__;
            }
          }
          ## TODO: Namespace well-formedness
          $pi = $doc-><M::Document.createProcessingInstruction>
                        ($name);
        }
      } else {
        lang:Perl {
          $pi = $doc-><M::Document.createProcessingInstruction> ('#INVALID');
        }
      }
      
      ~? (S) {
        ?lexmode 'PIData';
        
        my $tdata;
        
        ~? (DATA) {
          lang:Perl ($data => $token.value) {
            $tdata = $data;
          }
        } else {
          lang:Perl {
            $tdata = '';
          }
        }
        
        lang:Perl {
          $pi-><AS::Node.nodeValue> ($tdata);
        }
      }
      
      lang:Perl {
        $parent-><M::Node.appendChild> ($pi);
      }
      
      // ~ (PIC) { }
    } // _ProcessingInstruction_

    /*
      Processing instruction in DTD
    */
    rule _ProcessingInstructionDTD ($doc, $doctype) {
      ?lexmode 'PIName';

      my $pi;
      
      ~ (Name) {
        lang:Perl ($name => $token.value) : has-error {
          if (lc $name eq 'xml') {
            my $location;
            __CODE{xp|get-location-from-token::
              $token => {$token},
              $result => {$location},
            }__;
            my $continue = __DOMCore:ERROR{xp|wf-pi-target-is-xml::
              xp|name => {$name},
              DOMCore|location => {$location},
              xp|parent => {$doctype},
            }__;
            unless ($continue) {
              __EXCEPTION{DOMLS|PARSE_ERR::
              }__;
            }
          }
          ## TODO: Namespace well-formedness
          $pi = $doc-><M::Document.createProcessingInstruction>
                        ($name);
        }      
      } else {
        lang:Perl {
          $pi = $doc-><M::Document.createProcessingInstruction> ('#INVALID');
        }
      }
      
      ~? (S) {
        ?lexmode 'PIData';
        
        my $tdata;
        
        ~? (DATA) {
          lang:Perl ($data => $token.value) {
            $tdata = $data;
          }
        } else {
          lang:Perl {
            $tdata = '';
          }
        }
        
        lang:Perl {
          $pi-><AS::Node.nodeValue> ($tdata);
        }
      }
      
      lang:Perl {
        $doctype-><M::Node.appendChild> ($pi);
      }
      
      ~ (PIC) {
        ?lexmode DTD;
      } else {
        ?lexmode DTD;
      }
    } // _ProcessingInstructionDTD
    
    /*
      Element content parsing mode
      
        element := EmptyElemTag /
                   STag content ETag  ;; [39]
        content := (CharData / element / Reference / CDSect /
                    PI / Comment)     ;; [43]
    */
    rule Element_ ($doc, $parent, $ns) : standalone {
      ?lexmode 'ElementContent';
      
      my $node;  // Current "parent" node
      my $nodes; // Node stack (w/o $current_node)
      my $type;  // Current "parent" element type QName
      my $types; // Element type stack (w/o $current_type)
    //my $ns;    // Current in-scope namespace bindings
      my $nses;  // Namespace binding stack (w/o $current_ns)
      
      lang:Perl {
        $node = $parent;
        $nodes = [];
        $type = '';
        $types = [];
        $ns ||= {
          xml => <Q::xml:>,
          xmlns => <Q::xmlns:>,
        };
        $nses = [];
      }
      
      ~* : name => CONTENT
      (CharData) {
        // Character data
        lang:Perl ($data => $token.value) {
          $node-><M::Node.appendChild>
            ($doc-><M::Document.createTextNode> ($data));
        }
      } (STAGO) {
        // Start tag or empty element tag
        
        ?lexmode 'StartTag';
        
        ~ (Name) {
          my $attrs;
          lang:Perl ($name => $token.value) {
            push @{$types}, $type;
            $type = $name;
            $attrs = {};
          }
          
          ~? (S) {
            &AttributeSpecificationList
              ($doc => $doc, $attrs => $attrs);
          }

          my $el;

          /*
            Note that this implementation does not perform
            attribute value tokenization (but does white space
            normalization common to attribute types) and
            construct the tree as is.  DOM Level 3 Core spec
            is unclear on this point.  With tokenization,
            entity references cannot be preserved.

            The manakai Node.nodeValue and Attr.value attributes
            do tokenization according to attribute types.
          */

          /*
            ISSUE: Should |xml:id| attribute be typed?
          */
          
          lang:Perl {
            push @{$nses}, $ns;
            $ns = {%$ns};
            
            my %gattr;
            my %lattr;
            for my $atqname (keys %$attrs) {
              my ($pfx, $lname) = split /:/, $atqname;
              $attrs->{$atqname}->{def} = $self->{attr}->{$type}->{$atqname};
              if (defined $lname) {  ## Global attribute
                ## TODO: Namespace well-formedness (lname is NCName)
                if ($pfx eq 'xmlns') {
                  my $nsuri = $attrs->{$atqname}->{value};
                  if ($lname eq 'xml' and
                      $nsuri ne <Q::xml:>) {
                    ## TODO: error
                  } elsif ($lname eq 'xmlns') {
                    ## TODO: error
                  }
                  if ($nsuri eq '') {
                    ## TODO: error in XML 1.0
                  } elsif ($nsuri eq <Q::xml:> and
                           $lname ne 'xml') {
                    ## TODO: error
                  } elsif ($nsuri eq <Q::xmlns:>) {
                    ## TODO: error
                  }
                  $ns->{$lname} = $attrs->{$atqname}->{value};
                  if ($attrs->{$atqname}->{def}) {
                    my $dt = $attrs->{$atqname}->{def}-><AG::ATDef.declaredType>;
                    if ({
                      <C::ATDef.ID_ATTR> => true,
                      <C::ATDef.IDREF_ATTR> => true,
                      <C::ATDef.IDREFS_ATTR> => true,
                      <C::ATDef.ENTITY_ATTR> => true,
                      <C::ATDef.ENTITIES_ATTR> => true,
                      <C::ATDef.NMTOKEN_ATTR> => true,
                      <C::ATDef.NMTOKENS_ATTR> => true,
                      <C::ATDef.NOTATION_ATTR> => true,
                      <C::ATDef.ENUMERATION_ATTR> => true,
                    }->{$dt}) {
                      ## Tokenization (XML 1 3.3.3)
                      for ($ns->{$lname}) {
                        s/^\x20+//;
                        s/\x20+\z//;
                        s/\x20+/ /g;
                      }
                    }
                  }
                  delete $ns->{$lname} unless length $ns->{$lname};
                } elsif ($pfx eq '') {
                  ## TODO: pfx is not NCName error
                } else {
                  if ($gattr{$pfx}->{$lname}) {
                    ## TODO: Namespace well-formedness error
                  }
                }
                $gattr{$pfx}->{$lname} = $attrs->{$atqname};
              } else {               ## Local attribute
                if ($pfx eq 'xmlns') {
                  $ns->{''} = $attrs->{xmlns}->{value};
                  if ($attrs->{$atqname}->{def}) {
                    my $dt = $attrs->{$atqname}->{def}-><AG::ATDef.declaredType>;
                    if ({
                      <C::ATDef.ID_ATTR> => true,
                      <C::ATDef.IDREF_ATTR> => true,
                      <C::ATDef.IDREFS_ATTR> => true,
                      <C::ATDef.ENTITY_ATTR> => true,
                      <C::ATDef.ENTITIES_ATTR> => true,
                      <C::ATDef.NMTOKEN_ATTR> => true,
                      <C::ATDef.NMTOKENS_ATTR> => true,
                      <C::ATDef.NOTATION_ATTR> => true,
                      <C::ATDef.ENUMERATION_ATTR> => true,
                    }->{$dt}) {
                      ## Tokenization (XML 1 3.3.3)
                      for ($ns->{''}) {
                        s/^\x20+//;
                        s/\x20+\z//;
                        s/\x20+/ /g;
                      }
                    }
                  }
                  delete $ns->{''} unless length $ns->{''};
                } else {
                  $lattr{$pfx} = $attrs->{$atqname};
                }
              }
            }
            
            my ($pfx, $lname) = split /:/, $type;
            my $nsuri;
            ## TODO: lname is NCName?
            if (defined $lname) {  ## Prefixed namespace
              if ($pfx eq '') {
                ## TODO: pfx is not NCName error
              }
              if (defined $ns->{$pfx}) {
                $nsuri = $ns->{$pfx};
              } else {
                ## TODO: namespace ill-formed
              }
            } else {               ## Default namespace
              $nsuri = $ns->{''};
            }
            
            $el = $doc-><M::Document.createElementNS>
                             ($nsuri, $type);
            
            if ($attrs->{xmlns}) {
              my $attr = $doc-><M::Document.createAttributeNS>
                                 (<Q::xmlns:>, 'xmlns');
              for (@{$attrs->{xmlns}->{nodes}}) {
                $attr-><M::Node.appendChild> ($_);
              }
              if ($attrs->{xmlns}->{def}) {
                __CODE{t|setAttrType::
                  $attr => $attr,
                  $type => {$attrs->{xmlns}->{def}-><AG::ATDef.declaredType>},
                }__;
              }
              $el-><M::Element.setAttributeNodeNS> ($attr);
            }
            
            for my $lname (keys %lattr) {
              my $attr = $doc-><M::Document.createAttributeNS>
                                 (null, $lname);
              for (@{$lattr{$lname}->{nodes}}) {
                $attr-><M::Node.appendChild> ($_);
              }
              if ($attrs->{$lname}->{def}) {
                __CODE{t|setAttrType::
                  $attr => $attr,
                  $type => {$attrs->{$lname}->{def}-><AG::ATDef.declaredType>},
                }__;
              }
              $el-><M::Element.setAttributeNodeNS> ($attr);
            }
            
            for my $pfx (keys %gattr) {
              for my $lname (keys %{$gattr{$pfx}}) {
                my $attr = $doc-><M::Document.createAttributeNS>
                                   ($ns->{$pfx}, $pfx.':'.$lname);
                for (@{$gattr{$pfx}->{$lname}->{nodes}}) {
                  $attr-><M::Node.appendChild> ($_);
                }
                if ($attrs->{$pfx}->{$lname}->{def}) {
                  __CODE{t|setAttrType::
                    $attr => $attr,
                    $type => {$attrs->{$pfx}->{$lname}
                                    ->{def}-><AG::ATDef.declaredType>},
                  }__;
                }
                $el-><M::Element.setAttributeNodeNS> ($attr);
              }
            }

            $node-><M::Node.appendChild> ($el);            
          }
        
          ~ (TAGC) {
            lang:Perl {
              push @{$nodes}, $node;
              $node = $el;
            }
            ?lexmode ElementContent;
          } (NESTC) {
            my $is_docel;
            lang:Perl {
              $ns = pop @{$nses};
              $type = pop @{$types};
              $is_docel = (@{$types} == 0);
            }

            if-true ($is_docel) {
              return;
            }

            ~ (TAGC) {
              ?lexmode ElementContent;
            } else {
              ?lexmode ElementContent;
            }
          } else {
            ?lexmode ElementContent;
          }
        } else {
          ?lexmode ElementContent;
        }

      } (ETAGO) {
        // End tag
        
        ?lexmode 'EndTag';

        my $is_docel;
        
        ~ (Name) {
          lang:Perl ($name => $token.value) : has-error {
            if ($name eq $type) {
              $type = pop @{$types};
              if ($type eq '') {
                $is_docel = true;
              }
              $node = pop @{$nodes};
              $ns = pop @{$nses};
            } else {
              my $location;
              __CODE{xp|get-location-from-token::
                $token => $token,
                $result => $location,
              }__;
              my $continue = __DOMCore:ERROR{xp|wf-element-type-match::
                DOMCore:location => {$location},
                xp|token => {$token},
                xp|expected-element-type => {$type},
                xp|actual-element-type => {$name},
                xp|node => {$node},
              }__;
              unless ($continue) {
                __EXCEPTION{DOMLS|PARSE_ERR}__;
              }
            }
          }
        }
        
        ~? (S) { }

        if-true ($is_docel) {
          lang:Perl : has-error {
            if (@{$types}) {
              my $location;
              __CODE{xp|get-location-from-token::
                $token => $token,
                $result => $location,
              }__;
              for my $type (reverse @{$types}) {
                my $continue = __DOMCore:ERROR{xp|wf-no-end-tag::
                  DOMCore:location => {$location},
                  xp|token => {$token},
                  xp|expected-element-type => {$type},
                  xp|node => {$node},
                }__;
                unless ($continue) {
                  __EXCEPTION{DOMLS|PARSE_ERR}__;
                }
                $node = shift @{$nodes};
              }
            }
          }
          return;
        }
        
        ~ (TAGC) {
          ?lexmode ElementContent;
        } else {
          ?lexmode 'ElementContent';
        }

      } (HCRO) {
        &_HexadecimalCharacterReference_
          ($doc => $doc, $parent => $node);

        ~ (REFC) {
          ?lexmode 'ElementContent';
        } else {
          ?lexmode ElementContent;
        }
      } (CRO) {
        &_NumericCharacterReference_
          ($doc => $doc, $parent => $node);

        ~ (REFC) {
          ?lexmode 'ElementContent';
        } else {
          ?lexmode ElementContent;
        }
      } (ERO) {
        &_GeneralEntityReferenceEC
          ($doc => $doc, $parent => $node, $ns => $ns);
      } (CDO) {
        &_CommentDeclaration_ ($doc => $doc, $parent => $node);

        ~ (MDC) {
          ?lexmode ElementContent;
        } else {
          ?lexmode ElementContent;
        }
      } (CDSO) {
        &_CDATASection_ ($doc => $doc, $parent => $node);

        ~ (MSE) {
          ?lexmode 'ElementContent';
        } else {
          ?lexmode ElementContent;
        }
      } (PIO) {
        &_ProcessingInstruction_ ($doc => $doc, $parent => $node);

        ~ (PIC) {
          ?lexmode 'ElementContent';
        } else {
          ?lexmode ElementContent;
        }
      }

      ~ (#NONE) { }
    } // Element_

    /*
      content := [CharData]
                 *((element / Reference / CDSect / PI / Comment) [CharData])
    */
    rule content ($parent, $ns) {
      // ?lexmode ElementContent;
 
      my $doc;
      lang:Perl {
        $doc = $self->{doc};
      }

      ~* (CharData) {
        lang:Perl ($data => $token.value) {
          $parent-><M::Node.appendChild>
            ($self->{doc}-><M::Document.createTextNode> ($data));
        }
      } (STAGO) {
          &Element_ ($doc => $doc, $parent => $parent, $ns => $ns)
            : unshift-current-token;
          ~ (TAGC) {
            ?lexmode ElementContent;
          } else {
            ?lexmode ElementContent;
          }
        } (HCRO) {
          &_HexadecimalCharacterReference_
            ($doc => $doc, $parent => $parent);

          ~ (REFC) {
            ?lexmode 'ElementContent';
          } else {
            ?lexmode ElementContent;
          }
        } (CRO) {
          &_NumericCharacterReference_
            ($doc => $doc, $parent => $parent);

          ~ (REFC) {
            ?lexmode 'ElementContent';
          } else {
            ?lexmode ElementContent;
          }
        } (ERO) {
          &_GeneralEntityReferenceEC
            ($doc => $doc, $parent => $parent, $ns => $ns);
        } (CDO) {
          &_CommentDeclaration_ ($doc => $doc, $parent => $parent);

          ~ (MDC) {
            ?lexmode ElementContent;
          } else {
            ?lexmode ElementContent;
          }
        } (CDSO) {
          &_CDATASection_ ($doc => $doc, $parent => $parent);

          ~ (MSE) {
            ?lexmode 'ElementContent';
          } else {
            ?lexmode ElementContent;
          }
        } (PIO) {
          &_ProcessingInstruction_ ($doc => $doc, $parent => $parent);

          ~ (PIC) {
            ?lexmode 'ElementContent';
          } else {
            ?lexmode ElementContent;
          }
        }
    } // content
    
    rule AttributeSpecificationList ($doc, $attrs)
      : standalone
    {
      ?lexmode 'StartTag';
      
      my $i;
      lang:Perl {
        $i = 0;
      }
      
      ~* (Name) {
        my $atqname;
        lang:Perl ($name => $token.value) {
          $atqname = $name;
        }
        
        my $vals;
        lang:Perl : has-error {
          if ($attrs->{$atqname}) {
            my $location;
            __CODE{xp|get-location-from-token::
              $token => $token,
              $result => $location,
            }__;
            my $continue = __DOMCore:ERROR{xp|wf-unique-att-spec::
              DOMCore:location => {$location},
              xp|token => {$token},
              xp|name => {$atqname},
            }__;
            unless ($continue) {
              __EXCEPTION{DOMLS|PARSE_ERR}__;
            }
          }
          
          $vals = $attrs->{$atqname} = {
            nodes => [],
            value => '',
            index => $i++,
          };
        }

        ~? (S) { }
        ~ (VI) { }
        ~? (S) { }
        
        ~ (LIT) {
          &_AttributeValueSpecification_
            ($doc => $doc, $vals => $vals);

          ~ (LIT) {
            ?lexmode StartTag;
          } else {
            ?lexmode StartTag;
          }
        } (LITA) {
          &_AttributeValueSpecificationA_
            ($doc => $doc, $vals => $vals);

          ~ (LITA) {
            ?lexmode StartTag;
          } else {
            ?lexmode StartTag;
          }
        }
      } (S) : separator : terminator? { }
    } // AttributeSpecificationList
    
    rule _AttributeValueSpecification_ ($doc, $vals) {
      // ~ (LIT) { }
      ?lexmode 'AttributeValueLiteral';
      
      ~* (STRING) {
        lang:Perl ($value => $token.value) {
          $value =~ s/[\x09\x0A\x0D]/ /g;
          my $text = $doc-><M::Document.createTextNode> ($value);
          push @{$vals->{nodes}}, $text;
          $vals->{value} .= $value;
        }
      } (HCRO) {
        &_HexadecimalCharacterReferenceV_
          ($doc => $doc, $vals => $vals);

        ~ (REFC) {
          ?lexmode AttributeValueLiteral;
        } else {
          ?lexmode AttributeValueLiteral;
        }
      } (CRO) {
        &_NumericCharacterReferenceV_
          ($doc => $doc, $vals => $vals);

        ~ (REFC) {
          ?lexmode AttributeValueLiteral;
        } else {
          ?lexmode AttributeValueLiteral;
        }
      } (ERO) {
        // TODO: Attribute value normalization
        &_GeneralEntityReferenceV_
          ($doc => $doc, $vals => $vals);

        ~ (REFC) {
          ?lexmode AttributeValueLiteral;
        } else {
          ?lexmode AttributeValueLiteral;
        }
      }
      
      // ~ (LIT) { } (LITA) { }
    } // _AttributeValueSpecification_
    
    rule _AttributeValueSpecificationA_ ($doc, $vals) {
      // ~ (LITA) { }
      ?lexmode 'AttributeValueLiteralA';
      
      ~* (STRING) {
        lang:Perl ($value => $token.value) {
          $value =~ s/[\x09\x0A\x0D]/ /g;
          my $text = $doc-><M::Document.createTextNode> ($value);
          push @{$vals->{nodes}}, $text;
          $vals->{value} .= $value;
        }
      } (HCRO) {
        &_HexadecimalCharacterReferenceV_
          ($doc => $doc, $vals => $vals);

        ~ (REFC) {
          ?lexmode AttributeValueLiteralA;
        } else {
          ?lexmode AttributeValueLiteralA;
        }
      } (CRO) {
        &_NumericCharacterReferenceV_
          ($doc => $doc, $vals => $vals);

        ~ (REFC) {
          ?lexmode AttributeValueLiteralA;
        } else {
          ?lexmode AttributeValueLiteralA;
        }
      } (ERO) {
        // TODO: Attribute value normalization
        &_GeneralEntityReferenceV_
          ($doc => $doc, $vals => $vals);

        ~ (REFC) {
          ?lexmode AttributeValueLiteralA;
        } else {
          ?lexmode AttributeValueLiteralA;
        }
      }
      
      // ~ (LITA) { }
    } // _AttributeValueSpecificationA_
    
    /*
      Parsing replacement text of an entity referenced in
      an attribute value specification.
    */
    rule AttributeValueLiteralE_ ($parent, $vals)
      : recursive
    {
      // ?lexmode AttributeValueLiteralE;
      
      ~* (STRING) {
        lang:Perl ($value => $token.value) {
          $value =~ s/[\x09\x0A\x0D]/ /g;
          my $text = $self->{doc}-><M::Document.createTextNode> ($value);
          $parent-><M::Node.appendChild> ($text);
          $vals->{value} .= $value;
        }
      } (HCRO) {
        &_HexadecimalCharacterReferenceAE_
          ($parent => $parent, $vals => $vals);

        ~ (REFC) {
          ?lexmode AttributeValueLiteralE;
        } else {
          ?lexmode AttributeValueLiteralE;
        }
      } (CRO) {
        &_NumericCharacterReferenceAE_
          ($parent => $parent, $vals => $vals);

        ~ (REFC) {
          ?lexmode AttributeValueLiteralE;
        } else {
          ?lexmode AttributeValueLiteralE;
        }
      } (ERO) {
        &_GeneralEntityReferenceAE_ ($parent => $parent, $vals => $vals);

        ~ (REFC) {
          ?lexmode AttributeValueLiteralE;
        } else {
          ?lexmode AttributeValueLiteralE;
        }
      } (#INVALID == '<') {
        lang:Perl : has-error {
          my $location;
          __CODE{xp|get-location-from-token::
            $token => $token,
            $result => $location,
          }__;
          my $continue = __DOMCore:ERROR{xp|wf-no-lt-in-attribute-values::
            c|location => {$location},
            xp|token => {$token},
          }__;
          unless ($continue) {
            __EXCEPTION{DOMLS|PARSE_ERR}__;
          }

          my $text = $self->{doc}-><M::Document.createTextNode> ('<');
          $parent-><M::Node.appendChild> ($text);
          $vals->{value} .= '<';
        }
      }
      
      // ~ (#EOF) { }
    } // AttributeValueLiteralE_
    
    /*
      CDATA Section Content Parsing Mode
    */
    rule _CDATASection_ ($doc, $parent) {
      ?lexmode 'CDATASectionContent';
        
      my $cdata;
        
      ~? (CData) {
        lang:Perl ($data => $token.value) {
          $cdata = $data;
        }
      } else {
        lang:Perl {
          $cdata = '';
        }
      }
      
      lang:Perl {
        my $cdsect = $doc-><M::Document.createCDATASection>
                             ($cdata);
        $parent-><M::Node.appendChild> ($cdsect);
      }
      
      // ~ (MSE) { }
    } // _CDATASection_
    
    rule _NumericCharacterReference_ ($doc, $parent) {
      ?lexmode 'NumericCharacterReference';
      
      ~ (NUMBER) {
        lang:Perl ($num => $token.value) : has-error {
          $num += 0;
          unless (
            ($self->{xml_version} eq '1.0' and
              ((0x0020 <= $num and $num <= 0xD7FF) or
               (0xE000 <= $num and $num <= 0xFFFD) or
               (0x10000 <= $num and $num <= 0x10FFFF) or
               $num == 0x9 or $num == 0xA or $num == 0xD)) or
            ($self->{xml_version} eq '1.1' and
              ((0x0001 <= $num and $num <= 0xD7FF) or
               (0xE000 <= $num and $num <= 0xFFFD) or
               (0x10000 <= $num and $num <= 0x10FFFF)))
          ) {
            my $location;
            __CODE{xp|get-location-from-token::
              $token => $token,
              $result => $location,
            }__;
            my $continue = __DOMCore:ERROR{xp|wf-legal-character::
              DOMCore:location => {$location},
              xp|token => {$token},
              xp|character-number => {$num},
              xp|parent => {$parent},
            }__;
            unless ($continue) {
              __EXCEPTION{DOMLS|PARSE_ERR}__;
            }
          }
          my $ncr = $doc-><M::Document.createTextNode> (chr $num);
          $parent-><M::Node.appendChild> ($ncr);
        }
      }
      
      // ~ (REFC) { }
    } // _NumericCharacterReference_
    
    rule _NumericCharacterReferenceV_ ($doc, $vals) {
      ?lexmode 'NumericCharacterReference';
      
      ~ (NUMBER) {
        lang:Perl ($num => $token.value) : has-error {
          $num += 0;
          unless (
            ($self->{xml_version} eq '1.0' and
              ((0x0020 <= $num and $num <= 0xD7FF) or
               (0xE000 <= $num and $num <= 0xFFFD) or
               (0x10000 <= $num and $num <= 0x10FFFF) or
               $num == 0x9 or $num == 0xA or $num == 0xD)) or
            ($self->{xml_version} eq '1.1' and
              ((0x0001 <= $num and $num <= 0xD7FF) or
               (0xE000 <= $num and $num <= 0xFFFD) or
               (0x10000 <= $num and $num <= 0x10FFFF)))
          ) {
            my $location;
            __CODE{xp|get-location-from-token::
              $token => $token,
              $result => $location,
            }__;
            my $continue = __DOMCore:ERROR{xp|wf-legal-character::
              DOMCore:location => {$location},
              xp|token => {$token},
              xp|character-number => {$num},
            }__;
            unless ($continue) {
              __EXCEPTION{DOMLS|PARSE_ERR}__;
            }
          }
          my $ncr = $doc-><M::Document.createTextNode>
                            (my $char = chr $num);
          push @{$vals->{nodes}}, $ncr;
          $vals->{value} .= $char;
        }
      }
      
      // ~ (REFC) { }
    } // _NumericCharacterReferenceV_
    
    /*
      Numeric character reference in the replacement text
      of the entity referenced in an attribute value specification
    */
    rule _NumericCharacterReferenceAE_ ($parent, $vals)
    {
      ?lexmode NumericCharacterReference;
      
      ~ (NUMBER) {
        lang:Perl ($num => $token.value) : has-error {
          $num += 0;
          unless (
            ($self->{xml_version} eq '1.0' and
              ((0x0020 <= $num and $num <= 0xD7FF) or
               (0xE000 <= $num and $num <= 0xFFFD) or
               (0x10000 <= $num and $num <= 0x10FFFF) or
               $num == 0x9 or $num == 0xA or $num == 0xD)) or
            ($self->{xml_version} eq '1.1' and
              ((0x0001 <= $num and $num <= 0xD7FF) or
               (0xE000 <= $num and $num <= 0xFFFD) or
               (0x10000 <= $num and $num <= 0x10FFFF)))
          ) {
            my $location;
            __CODE{xp|get-location-from-token::
              $token => $token,
              $result => $location,
            }__;
            my $continue = __DOMCore:ERROR{xp|wf-legal-character::
              DOMCore:location => {$location},
              xp|token => {$token},
              xp|character-number => {$num},
            }__;
            unless ($continue) {
              __EXCEPTION{DOMLS|PARSE_ERR}__;
            }
          }
          my $ncr = $self->{doc}-><M::Document.createTextNode>
                            (my $char = chr $num);
          $parent-><M::Node.appendChild> ($ncr);
          $vals->{value} .= $char;
        }
      }
      
      // ~ (REFC) { }
    } // _NumericCharacterReferenceAE_
    
    rule _NumericCharacterReferenceEV_ ($vals)
    {
      ?lexmode 'NumericCharacterReference';
      
      ~ (NUMBER) {
        lang:Perl ($num => $token.value) : has-error {
          $num += 0;
          unless (
            ($self->{xml_version} eq '1.0' and
              ((0x0020 <= $num and $num <= 0xD7FF) or
               (0xE000 <= $num and $num <= 0xFFFD) or
               (0x10000 <= $num and $num <= 0x10FFFF) or
               $num == 0x9 or $num == 0xA or $num == 0xD)) or
            ($self->{xml_version} eq '1.1' and
              ((0x0001 <= $num and $num <= 0xD7FF) or
               (0xE000 <= $num and $num <= 0xFFFD) or
               (0x10000 <= $num and $num <= 0x10FFFF)))
          ) {
            my $location;
            __CODE{xp|get-location-from-token::
              $token => $token,
              $result => $location,
            }__;
            my $continue = __DOMCore:ERROR{xp|wf-legal-character::
              DOMCore:location => {$location},
              xp|token => {$token},
              xp|character-number => {$num},
            }__;
            unless ($continue) {
              __EXCEPTION{DOMLS|PARSE_ERR}__;
            }
          }
          push @{$vals}, chr $num;
        }
      }
      
      // ~ (REFC) { }
    } // _NumericCharacterReferenceEV_
    
    rule _HexadecimalCharacterReference_ ($doc, $parent) {
      ?lexmode 'HexadecimalCharacterReference';
      
      ~ (Hex) {
        lang:Perl ($v => $token.value) : has-error {
          my $num = hex $v;
          unless (
            ($self->{xml_version} eq '1.0' and
              ((0x0020 <= $num and $num <= 0xD7FF) or
               (0xE000 <= $num and $num <= 0xFFFD) or
               (0x10000 <= $num and $num <= 0x10FFFF) or
               $num == 0x9 or $num == 0xA or $num == 0xD)) or
            ($self->{xml_version} eq '1.1' and
              ((0x0001 <= $num and $num <= 0xD7FF) or
               (0xE000 <= $num and $num <= 0xFFFD) or
               (0x10000 <= $num and $num <= 0x10FFFF)))
          ) {
            my $location;
            __CODE{xp|get-location-from-token::
              $token => $token,
              $result => $location,
            }__;
            my $continue = __DOMCore:ERROR{xp|wf-legal-character::
              DOMCore:location => {$location},
              xp|token => {$token},
              xp|character-number => {$num},
              xp|parent => {$parent},
            }__;
            unless ($continue) {
              __EXCEPTION{DOMLS|PARSE_ERR}__;
            }
          }
          my $ncr = $doc-><M::Document.createTextNode>
                      (chr $num);
          $parent-><M::Node.appendChild> ($ncr);
        }
      }
      
      // ~ (REFC) { }
    } // _HexadecimalCharacterReference_
    
    rule _HexadecimalCharacterReferenceV_ ($doc, $vals) {
      ?lexmode 'HexadecimalCharacterReference';
      
      ~ (Hex) {
        lang:Perl ($v => $token.value) : has-error {
          my $num = hex $v;
          unless (
            ($self->{xml_version} eq '1.0' and
              ((0x0020 <= $num and $num <= 0xD7FF) or
               (0xE000 <= $num and $num <= 0xFFFD) or
               (0x10000 <= $num and $num <= 0x10FFFF) or
               $num == 0x9 or $num == 0xA or $num == 0xD)) or
            ($self->{xml_version} eq '1.1' and
              ((0x0001 <= $num and $num <= 0xD7FF) or
               (0xE000 <= $num and $num <= 0xFFFD) or
               (0x10000 <= $num and $num <= 0x10FFFF)))
          ) {
            my $location;
            __CODE{xp|get-location-from-token::
              $token => $token,
              $result => $location,
            }__;
            my $continue = __DOMCore:ERROR{xp|wf-legal-character::
              DOMCore:location => {$location},
              xp|token => {$token},
              xp|character-number => {$num},
            }__;
            unless ($continue) {
              __EXCEPTION{DOMLS|PARSE_ERR}__;
            }
          }
          my $ncr = $doc-><M::Document.createTextNode>
                      (my $char = chr $num);
          push @{$vals->{nodes}}, $ncr;
          $vals->{value} .= $char;
        }
      }
      
      // ~ (REFC) { }
    } // _HexadecimalCharacterReferenceV_
    
    /*
      Hexadecimal character reference in the replacement text
      of the entity referenced in an attribute value literal
    */
    rule _HexadecimalCharacterReferenceAE_ ($parent, $vals)
    {
      ?lexmode HexadecimalCharacterReference;
      
      ~ (Hex) {
        lang:Perl ($v => $token.value) : has-error {
          my $num = hex $v;
          unless (
            ($self->{xml_version} eq '1.0' and
              ((0x0020 <= $num and $num <= 0xD7FF) or
               (0xE000 <= $num and $num <= 0xFFFD) or
               (0x10000 <= $num and $num <= 0x10FFFF) or
               $num == 0x9 or $num == 0xA or $num == 0xD)) or
            ($self->{xml_version} eq '1.1' and
              ((0x0001 <= $num and $num <= 0xD7FF) or
               (0xE000 <= $num and $num <= 0xFFFD) or
               (0x10000 <= $num and $num <= 0x10FFFF)))
          ) {
            my $location;
            __CODE{xp|get-location-from-token::
              $token => $token,
              $result => $location,
            }__;
            my $continue = __DOMCore:ERROR{xp|wf-legal-character::
              DOMCore:location => {$location},
              xp|token => {$token},
              xp|character-number => {$num},
            }__;
            unless ($continue) {
              __EXCEPTION{DOMLS|PARSE_ERR}__;
            }
          }
          my $ncr = $self->{doc}-><M::Document.createTextNode>
                      (my $char = chr $num);
          $parent-><M::Node.appendChild> ($ncr);
          $vals->{value} .= $char;
        }
      }
      
      // ~ (REFC) { }
    } // _HexadecimalCharacterReferenceAE_
    
    rule _HexadecimalCharacterReferenceEV_ ($vals) {
      ?lexmode HexadecimalCharacterReference;
      
      ~ (Hex) {
        lang:Perl ($v => $token.value) : has-error {
          my $num = hex $v;
          unless (
            ($self->{xml_version} eq '1.0' and
              ((0x0020 <= $num and $num <= 0xD7FF) or
               (0xE000 <= $num and $num <= 0xFFFD) or
               (0x10000 <= $num and $num <= 0x10FFFF) or
               $num == 0x9 or $num == 0xA or $num == 0xD)) or
            ($self->{xml_version} eq '1.1' and
              ((0x0001 <= $num and $num <= 0xD7FF) or
               (0xE000 <= $num and $num <= 0xFFFD) or
               (0x10000 <= $num and $num <= 0x10FFFF)))
          ) {
            my $location;
            __CODE{xp|get-location-from-token::
              $token => $token,
              $result => $location,
            }__;
            my $continue = __DOMCore:ERROR{xp|wf-legal-character::
              DOMCore:location => {$location},
              xp|token => {$token},
              xp|character-number => {$num},
            }__;
            unless ($continue) {
              __EXCEPTION{DOMLS|PARSE_ERR}__;
            }
          }
          push @{$vals}, chr $num;
        }
      }
      
      // ~ (REFC) { }
    } // _HexadecimalCharacterReferenceEV_
    
    /*
      General entity reference in element's content
    */
    rule _GeneralEntityReferenceEC ($doc, $parent, $ns)
      : recursive
    {
      ?lexmode 'EntityReference';
      
      ~ (Name == 'lt') {
        lang:Perl {
          $parent-><M::Node.appendChild>
                     ($self->{doc}-><M::Document.createTextNode> ('<'));
        }
      } (Name == 'gt') {
        lang:Perl {
          $parent-><M::Node.appendChild>
                     ($self->{doc}-><M::Document.createTextNode> ('>'));
        }
      } (Name == 'amp') {
        lang:Perl {
          $parent-><M::Node.appendChild>
                     ($self->{doc}-><M::Document.createTextNode> ('&'));
        }
      } (Name == 'quot') {
        lang:Perl {
          $parent-><M::Node.appendChild>
                     ($self->{doc}-><M::Document.createTextNode> ('"'));
        }
      } (Name == 'apos') {
        lang:Perl {
          $parent-><M::Node.appendChild>
                     ($self->{doc}-><M::Document.createTextNode> ("'"));
        }
      } (Name) {
        my $er;
        lang:Perl ($name => $token.value) : has-error {
          ## TODO: Namespace well-formedness
          $er = $doc-><M::Document.createEntityReference>
                           ($name);
          $er-><AS::Node.textContent> ('');
            ## NOTE: When document entity (and entities referenced directly
            ##       or indirectly from it) is parsed, no general entity
            ##       node have its replacement tree.  During general
            ##       entity node collection construction, however,
            ##       some entity node has replacement tree.
          $parent-><M::Node.appendChild> ($er);

          my $ent = $self->{general_entity}->{$name};
          if (not $ent) {  # no entity declaration
            if ($self->{standalone} or not $self->{has_xref}) { # WFC error
              my $location;
              __CODE{xp|get-location-from-token::
                $token => {$token},
                $result => {$location},
              }__;
              my $continue = __DOMCore:ERROR{xp|wf-entity-declared::
                xp|error-token => {$token},
                c|location => {$location},
                xp|name => {$name},
              }__;
              unless ($continue) {
                __EXCEPTION{DOMLS|PARSE_ERR}__;
              }
            }                 # Otherwise VC error
            push @{$self->{entity}}, <Code::getEmptyEntityState>;
            $er-><AS::x|EntityReference.isExpanded> (false);

          } else {         # there IS entity declaration
            if (($self->{standalone} or not $self->{has_xref}) and
                $ent->{is_externally_declared} and
                not $self->{entity}->[-1]->{is_externally_declared}) {
              my $location;
              __CODE{xp|get-location-from-token::
                $token => {$token},
                $result => {$location},
              }__;
              my $continue = __DOMCore:ERROR{xp|wf-entity-declared::
                xp|error-token => {$token},
                c|location => {$location},
                xp|name => {$name},
              }__;
              unless ($continue) {
                __EXCEPTION{DOMLS|PARSE_ERR}__;
              }
            }          
            $er-><AS::x|EntityReference.isExpanded>
                   ($ent->{has_replacement_text});
            push @{$self->{entity}}, <Code::getCopyOfEntityState::
                                            $entity_type = 'general_entity',
                                            $entity_name = $name>;
          }
          $self->{location} = $self->{entity}->[-1];
          push @{$self->{entity_token}}, $self->{token};
          $self->{token} = [];
          push @{$self->{entity_char}}, $self->{char};
          $self->{char} = [];
        }

        ?lexmode ElementContent;
        &content ($doc => $doc, $parent => $er, $ns => $ns);
        ~ (#EOF) { }
        lang:Perl {
          $self->{token} = pop @{$self->{entity_token}};
          $self->{char} = pop @{$self->{entity_char}};
          pop @{$self->{entity}};
          $self->{location} = $self->{entity}->[-1];
        }

        // TODO: Set read-only flag

        ?lexmode EntityReference;
        ?requires-next-token;
      }
      
      ~ (REFC) {
        ?lexmode ElementContent;
      } else {
        ?lexmode ElementContent;
      }
    } // _GeneralEntityReferenceEC
    
    /*
      General entity reference in an attribute value literal
    */
    rule _GeneralEntityReferenceV_ ($vals) {
      ?lexmode EntityReference;
      
      ~ (Name == 'lt') {
        lang:Perl {
          push @{$vals->{nodes}}, $self->{doc}-><M::Document.createTextNode>
                                                  ('<');
          $vals->{value} .= '<';
        }
      } (Name == 'gt') {
        lang:Perl {
          push @{$vals->{nodes}}, $self->{doc}-><M::Document.createTextNode>
                                                  ('>');
          $vals->{value} .= '>';
        }
      } (Name == 'amp') {
        lang:Perl {
          push @{$vals->{nodes}}, $self->{doc}-><M::Document.createTextNode>
                                                  ('&');
          $vals->{value} .= '&';
        }
      } (Name == 'quot') {
        lang:Perl {
          push @{$vals->{nodes}}, $self->{doc}-><M::Document.createTextNode>
                                                  ('"');
          $vals->{value} .= '"';
        }
      } (Name == 'apos') {
        lang:Perl {
          push @{$vals->{nodes}}, $self->{doc}-><M::Document.createTextNode>
                                                  ("'");
          $vals->{value} .= "'";
        }
      } (Name) {
        my $er;
        lang:Perl ($name => $token.value) : has-error {
          ## TODO: Namespace well-formedness
          ## TODO: Entity declared constraints
          
          $er = $self->{doc}-><M::Document.createEntityReference> ($name);
          $er-><AS::Node.textContent> ('');
            ## NOTE: When document entity (and entities referenced directly
            ##       or indirectly from it) is parsed, no general entity
            ##       node have its replacement tree.  During general
            ##       entity node collection construction, however,
            ##       some entity node has replacement tree.
          my $ent = $self->{general_entity}->{$name};
          if (not $ent) {  # no entity declaration
            if ($self->{standalone} or not $self->{has_xref}) { # WFC error
              my $location;
              __CODE{xp|get-location-from-token::
                $token => {$token},
                $result => {$location},
              }__;
              my $continue = __DOMCore:ERROR{xp|wf-entity-declared::
                xp|error-token => {$token},
                c|location => {$location},
                xp|name => {$name},
              }__;
              unless ($continue) {
                __EXCEPTION{DOMLS|PARSE_ERR}__;
              }
            }                 # Otherwise VC error
            push @{$self->{entity}}, <Code::getEmptyEntityState>;
            $er-><AS::x|EntityReference.isExpanded> (false);

          } else {         # there IS entity declaration
            if (($self->{standalone} or not $self->{has_xref}) and
                $ent->{is_externally_declared} and
                not $self->{entity}->[-1]->{is_externally_declared}) {
              my $location;
              __CODE{xp|get-location-from-token::
                $token => {$token},
                $result => {$location},
              }__;
              my $continue = __DOMCore:ERROR{xp|wf-entity-declared::
                xp|error-token => {$token},
                c|location => {$location},
                xp|name => {$name},
              }__;
              unless ($continue) {
                __EXCEPTION{DOMLS|PARSE_ERR}__;
              }
            }          

            if ($ent->{is_external_entity}) {
              my $location;
              __CODE{xp|get-location-from-token::
                $token => {$token},
                $result => {$location},
              }__;
              my $continue = __c|ERROR{xp|wf-no-external-entity-references::
                xp|error-token => {$token},
                c|location => {$location},
                xp|name => {$name},
              }__;
              unless ($continue) {  
                __EXCEPTION{DOMLS|PARSE_ERR::
                }__;
              }
            } # if external entity

            $er-><AS::x|EntityReference.isExpanded>
                   ($ent->{has_replacement_text});
            push @{$self->{entity}}, <Code::getCopyOfEntityState::
                                            $entity_type = 'general_entity',
                                            $entity_name = $name>;
          }
          push @{$vals->{nodes}}, $er;
          $self->{location} = $self->{entity}->[-1];
          push @{$self->{entity_token}}, $self->{token};
          $self->{token} = [];
          push @{$self->{entity_char}}, $self->{char};
          $self->{char} = [];
        }

        ?lexmode AttributeValueLiteralE;
        &AttributeValueLiteralE_ ($parent => $er, $vals => $vals);       
        ~ (#EOF) { }
        lang:Perl {
          $self->{token} = pop @{$self->{entity_token}};
          $self->{char} = pop @{$self->{entity_char}};
          pop @{$self->{entity}};
          $self->{location} = $self->{entity}->[-1];
        }

        // TODO: Set read-only flag

        ?lexmode EntityReference;
        ?requires-next-token;
      }
      
      // ~ (REFC) { }
    } // _GeneralEntityReferenceV_
    
    /*
      General entity reference in the replacement text
      of the entity referenced in an attribute value literal
    */
    rule _GeneralEntityReferenceAE_ ($parent, $vals)
    {
      ?lexmode EntityReference;
      
      ~ (Name == 'lt') {
        lang:Perl {
          $parent-><M::Node.appendChild>
                     ($self->{doc}-><M::Document.createTextNode> ('<'));
          $vals->{value} .= '<';
        }
      } (Name == 'gt') {
        lang:Perl {
          $parent-><M::Node.appendChild>
                     ($self->{doc}-><M::Document.createTextNode> ('>'));
          $vals->{value} .= '>';
        }
      } (Name == 'amp') {
        lang:Perl {
          $parent-><M::Node.appendChild>
                     ($self->{doc}-><M::Document.createTextNode> ('&'));
          $vals->{value} .= '&';
        }
      } (Name == 'quot') {
        lang:Perl {
          $parent-><M::Node.appendChild>
                     ($self->{doc}-><M::Document.createTextNode> ('"'));
          $vals->{value} .= '"';
        }
      } (Name == 'apos') {
        lang:Perl {
          $parent-><M::Node.appendChild>
                     ($self->{doc}-><M::Document.createTextNode> ("'"));
          $vals->{value} .= "'";
        }
      } (Name) {
        my $er;
        lang:Perl ($name => $token.value) {
          ## TODO: Namespace well-formedness
          ## TODO: Entity declared constraints

          $er = $self->{doc}-><M::Document.createEntityReference> ($name);
          $er-><AS::Node.textContent> ('');
            ## NOTE: When document entity (and entities referenced directly
            ##       or indirectly from it) is parsed, no general entity
            ##       node have its replacement tree.  During general
            ##       entity node collection construction, however,
            ##       some entity node has replacement tree.
          my $ent = $self->{general_entity}->{$name};
          $parent-><M::Node.appendChild> ($er);
          $er-><AS::x|EntityReference.isExpanded>
                   ($ent->{has_replacement_text});
          push @{$self->{entity}}, <Code::getCopyOfEntityState::
                                            $entity_type = 'general_entity',
                                            $entity_name = $name>;
          $self->{location} = $self->{entity}->[-1];
          push @{$self->{entity_token}}, $self->{token};
          $self->{token} = [];
          push @{$self->{entity_char}}, $self->{char};
          $self->{char} = [];

          if ($self->{entity}->[-1]->{is_external_entity}) {
            my $location;
            __CODE{xp|get-location-from-token::
              $token => {$token},
              $result => {$location},
            }__;
            my $continue = __DOMCore:ERROR{xp|wf-no-external-entity-references::
              xp|error-token => {$token},
              c|location => {$location},
              xp|name => {$name},
            }__;
            unless ($continue) {
              __EXCEPTION{DOMLS|PARSE_ERR::
              }__;
            }
          } # if external entity
        }

        ?lexmode AttributeValueLiteralE;
        &AttributeValueLiteralE_ ($parent => $er, $vals => $vals);       
        ~ (#EOF) { }
        lang:Perl {
          $self->{token} = pop @{$self->{entity_token}};
          $self->{char} = pop @{$self->{entity_char}};
          pop @{$self->{entity}};
          $self->{location} = $self->{entity}->[-1];
        }

        // TODO: Set read-only flag

        ?lexmode EntityReference;
        ?requires-next-token;
      }
      
      // ~ (REFC) { }
    } // _GeneralEntityReferenceAE_
    
    /*
      General entity reference in literal entity value
    */
    rule _GeneralEntityReferenceEV_ ($vals) {
      ?lexmode 'EntityReference';
      
      ~ (Name) {
        lang:Perl ($name => $token.value) {
          ## TODO: Namespace well-formedness
          ## TODO: Entity declared constraints
          push @$vals, $name;
        }
      }

      // No expansion
      
      // ~ (REFC) { }
    } // _GeneralEntityReferenceEV_

    /*
      Document Type Declaration
    */
    rule _DocumentTypeDeclaration_ ($doc) {
      ?lexmode MarkupDeclaration;
      
      ~ (Name == 'DOCTYPE') { }
      
      ~ (S) { }
      
      // Document type name
      my $name;
      ~ (Name) {
        lang:Perl ($v => $token.value) {
          $name = $v;
        }
      }

      my $node;
      my $decl;
      lang:Perl {
        $self->{docx} = $self->{doc}
                             -><M::Node.getFeature> (<Q::fe:XDoctype>, '3.0');
        $node = $self->{docx}-><M::DocumentXDoctype.createDocumentTypeDefinition>
                                 ($name);
        $decl = $self->{dtdecl} = $node-><M::Node.getFeature>
                                           (<Q::fe:XDoctypeDeclaration>, '3.0');
      }

      ~? (S) {
        ~? (Name == 'PUBLIC') {
          ~ (S) { }
  
          &PubidLiteral ($decl => $decl);
  
          ~ (S) { }
  
          &SystemLiteral ($decl => $decl);
  
          ~? (S) { }

          lang:Perl {
            $self->{has_xref} = true;
          }
        } (Name == 'SYSTEM') {
          ~ (S) { }
  
          &SystemLiteral ($decl => $decl);
  
          ~? (S) { }

          lang:Perl {
            $self->{has_xref} = true;
          }
        }
      }

      lang:Perl {
        $self->{dtdef} = $node;
        $doc-><M::Node.appendChild> ($node);
        $doc-><AG::Document.domConfig>
            -><M::c|DOMConfiguration.setParameter>
                ('schema-type' => <Q::xml-dtd:>);
      }
      
      ~? (DSO) {
        &InternalSubset ($doc => $doc, $doctype => $node);

        ~ (DSC) {
          ?lexmode MarkupDeclaration;
        } else {
          ?lexmode MarkupDeclaration;
        }

        ~? (S) { }
      }

      // ~ (MDC) { }
    } // _DocumentTypeDeclaration_

    /*
      Public Identifier Literal
    */
    rule PubidLiteral ($decl) {
      my $pubid;
      my $pubid_token;
      ~ (LIT) {
        ?lexmode SystemLiteral;

        ~? (STRING) {
          lang:Perl ($v => $token.value) {
            $pubid = $v;
            $pubid_token = $token;
          }
        }

        ~ (LIT) {
          ?lexmode MarkupDeclaration;
        } else {
          ?lexmode MarkupDeclaration;
        }
      } (LITA) {
        ?lexmode SystemLiteralA;

        ~? (STRING) {
          lang:Perl ($v => $token.value) {
            $pubid = $v;
            $pubid_token = $token;
          }
        }

        ~ (LITA) {
          ?lexmode MarkupDeclaration;
        } else {
          ?lexmode MarkupDeclaration;
        }
      }

      if-true ($pubid_token) {
        lang:Perl : has-error {
          if ($pubid =~ m{[^\x20\x0D\x0Aa-zA-Z0-9'()+,./:=?;!*#\@\$_%-]}s) {
            my $location;
            __CODE{xp|get-location-from-token::
              $token => {$pubid_token},
              $result => {$location},
            }__;
                                  ## Should this be other (new) error type?
            my $continue = __DOMCore:ERROR{xp|wf-syntax-error::
              xp|error-token => {$token},
              c|location => {$location},
            }__;
            unless ($continue) {
              __EXCEPTION{DOMLS|PARSE_ERR::
             }__;
            }
          }

          ## NOTE: U+0009 is syntactically illegal.
          $pubid =~ s/[\x09\x0A\x0D\x20]+//gs;
          $pubid =~ s/\A\x20//s;
          $pubid =~ s/\x20\z//s;
                 ## NOTE: Bare attribute name is written.
          $decl->public_id ($pubid);
        }
      }
    } // PubidLiteral

    /*
      System Identifier Literal
    */
    rule SystemLiteral ($decl) {
      ~ (LIT) {
        ?lexmode SystemLiteral;
        &_SystemLiteral ($decl => $decl);
      } (LITA) {
        ?lexmode SystemLiteralA;
        &_SystemLiteral ($decl => $decl);
      }
    } // SystemLiteral

    /*
      System Identifier Literal Content
    */
    rule _SystemLiteral ($decl) {
      // LIT or LITA

      ~? (STRING) {
        lang:Perl ($v => $token.value) {
                 ## NOTE: Bare attribute name is written.
          $decl->system_id ($v);
        }
      }

      ~ (LIT) {
        ?lexmode MarkupDeclaration;
      } (LITA) {
        ?lexmode MarkupDeclaration;
      } else {
        ?lexmode MarkupDeclaration;
      }
    } // _SystemLiteral

    /*
      DTD Internal Subset
      
        intSubset := *(markupdecl / DeclSep)  ;; [28b]
    */
    rule InternalSubset ($doc, $doctype) {
      ?lexmode DTD;

      ~* (MDO) {
        ?lexmode MarkupDeclaration;

        ~ (Name == 'ELEMENT') {
          &_ElementDeclaration ($doc => $doc);
        } (Name == 'ATTLIST') {
          &_AttlistDeclaration ($doc => $doc, $doctype => $doctype);
        } (Name == 'ENTITY') {
          &_EntityDeclaration ($doc => $doc);
        } (Name == 'NOTATION') {
          &_NotationDeclaration ($doc => $doc);
        }
      } (S) {
        //
      } (CDO) {
        &_CommentDeclarationDTD ($doc => $doc);
      } (PIO) {
        &_ProcessingInstructionDTD ($doc => $doc, $doctype => $doctype);
      } (PERO) {
        ?lexmode EntityReference;

        lang:Perl {
          $self->{has_xref} = true;
        }

        ~ (Name) {

        }

        ~ (REFC) {
          ?lexmode DTD;
        } else {
          ?lexmode DTD;
        }
      }
    } // InternalSubset

    rule _ElementDeclaration ($doc) {
      // ~ (MDO) { }
      // ?lexmode MarkupDeclaration
      // ~ (Name == 'Element') { }

      ~ (S) { }

      ~ (Name) {

      }

      ?lexmode ElementDeclaration;

      ~ (S) { }

      // contentspec
      ~ (MGO) {
        &_ContentModel ($doc => $doc);
      } (Name == 'EMPTY') {

      } (Name == 'ANY') {

      }

      ~? (S) { }

      ~ (MDC) {
        ?lexmode DTD;
      } else {
        ?lexmode DTD;
      }
    } // _ElementDeclaration

    rule _ContentModel ($doc) {
      // ~ (MGO) { }
      
      ~? (S) { }

      ~ (Name) {
        // Element content model
        &_ModelGroup ($doc => $doc)
          : unshift-current-token;

        ~? (OPT) {

        } (REP) {

        } (PLUS) {

        }

      } (MDO) {
        &_ModelGroup ($doc => $doc)
          : unshift-current-token;

        ~? (OPT) {

        } (REP) {

        } (PLUS) {

        }

      } (PCDATA) {
        // Mixed content declaration
        ~? (S) { }

        ~* (OR) {
          ~? (S) { }

          ~ (Name) {

          }

          ~? (S) { }
        }

        ~ (MGC) { }

        ~? (REP) {
      
        } else {
          // TODO: error if |Name|
        }


      }
    } // _ContentModel

    rule _ModelGroup ($doc)
      : standalone
      : recursive
    {
      // ~ (MGO) { }
      // ~? (S) { }

      &ContentParticle ($doc => $doc);

      ~? (S) { }

      ~? (OR) {
        ~? (S) { }
  
        &ContentParticle ($doc => $doc);

        ~? (S) { }

        ~* (OR) {
          ~? (S) { }

          &ContentParticle ($doc => $doc);

          ~? (S) { }
        }

      } (SEQ) {
        ~? (S) { }
  
        &ContentParticle ($doc => $doc);

        ~? (S) { }

        ~* (SEQ) {
          ~? (S) { }

          &ContentParticle ($doc => $doc);

          ~? (S) { }
        }

      }

      ~ (MGC) { }
    } // _ModelGroup
    
    rule ContentParticle ($doc) {
      ~ (Name) {

      } (MGO) {
        ~? (S) { }
   
        &_ModelGroup ($doc => $doc);
      }

      ~? (OPT) {

      } (REP) {

      } (PLUS) {

      }
    } // ContentParticle

    /*
      Attribute list declaration
    */
    rule _AttlistDeclaration ($doc, $doctype) {
      // ~ (MDO) { }
      // ~ (Name == 'ATTLIST') { }

      ?lexmode AttlistDeclaration;

      ~ (S) { }

      my $name;
      ~ (Name) {
        lang:Perl ($v => $token.value) {
          $name = $v;
        }
      } else {
        lang:Perl { $name = '#ILLEGAL' }
      }

      my $docxd;
      my $et;
      lang:Perl {
        $et = $doctype-><M::DTDef.getElementTypeDefinitionNode> ($name);
        unless ($et) {
          $docxd = $doc-><M::Node.getFeature> (<Q::fe:XDoctype>, '3.0');
          $et = $docxd-><M::DocumentXDoctype.createElementTypeDefinition>
                          ($name);
          $doctype-><M::DTDef.setElementTypeDefinitionNode> ($et)
            unless $name eq '#ILLEGAL';
        }
      }
  
      ~? (S) { }

      ~* (Name) {
        my $at;
        lang:Perl ($v => $token.value) {
          $docxd ||= $doc-><M::Node.getFeature>
                             (<Q::fe:XDoctype>, '3.0');
          $at = $docxd-><M::DocumentXDoctype.createAttributeDefinition> ($v);
          unless (exists $et-><AG::ETDef.attributeDefinitions>->{$v}) {
            $et-><M::ETDef.setAttributeDefinitionNode> ($at);
            $self->{attr}->{$name}->{$v} = $at;
          }
        }

        ~ (S) { }
        
        // AttType
        ~ (Name == 'NOTATION') {
          ~ (S) { }

          my $kwd;
          lang:Perl {
            $at-><AS::ATDef.declaredType> (<C::ATDef.NOTATION_ATTR>);
            $kwd = $at-><AG::ATDef.allowedTokens>;
          }

          ~ (EGO) {
            ~? (S) { }

            ~+ (Name) {
              lang:Perl ($v => $token.value) {
                push @$kwd, $v;
              }

              ~? (S) { }
            } (OR) : separator {
              ~? (S) { }
            }

            ~ (EGC) { }
          }

        } (Name) {
          my $type;
          lang:Perl ($v => $token.value) : has-error {
            my $map = {
              CDATA => <C::ATDef.CDATA_ATTR>,
              ID => <C::ATDef.ID_ATTR>,
              IDREF => <C::ATDef.IDREF_ATTR>,
              IDREFS => <C::ATDef.IDREFS_ATTR>,
              ENTITY => <C::ATDef.ENTITY_ATTR>,
              ENTITIES => <C::ATDef.ENTITIES_ATTR>,
              NMTOKEN => <C::ATDef.NMTOKEN_ATTR>,
              NMTOKENS => <C::ATDef.NMTOKENS_ATTR>,
            };
            if ($map->{$v}) {
              $at-><AS::ATDef.declaredType> ($map->{$v});
            } else {
              ## TODO: Exception
            }
          }
        
        } (EGO) {
          ?lexmode Enumeration;

          ~? (S) { }

          my $kwd;
          lang:Perl {
            $at-><AS::ATDef.declaredType> (<C::ATDef.ENUMERATION_ATTR>);
            $kwd = $at-><AG::ATDef.allowedTokens>;
          }

          ~+ (Nmtoken) {
            lang:Perl ($v => $token.value) {
              push @$kwd, $v;
            }

            ~? (S) { }
          } (OR) : separator {
            ~? (S) { }
          }

          ~ (EGC) {
            ?lexmode AttlistDeclaration;
          } else {
            ?lexmode AttlistDeclaration;
          }

        }

        ~ (S) { }

        // DefaultDecl
        ~ (RNI) {
          ~ (Name == 'REQUIRED') {
            lang:Perl {
              $at-><AS::ATDef.defaultType> (<C::ATDef.REQUIRED_DEFAULT>);
            }
          } (Name == 'IMPLIED') {
            lang:Perl {
              $at-><AS::ATDef.defaultType> (<C::ATDef.IMPLIED_DEFAULT>);
            }
          } (Name == 'FIXED') {
            ~ (S) { }

            lang:Perl {
              $at-><AS::ATDef.defaultType> (<C::ATDef.FIXED_DEFAULT>);
            }
            
            ~ (LIT) {
              my $vals;
              lang:Perl {
                $vals = {nodes => [], value => ''};
              }

              &_AttributeValueSpecification_ ($doc => $doc, $vals => $vals);

              lang:Perl {
                for (@{$vals->{nodes}}) {
                  $at-><M::Node.appendChild> ($_);
                }
              }

              ~ (LIT) {
                ?lexmode AttlistDeclaration;
              } else {
                ?lexmode AttlistDeclaration;
              }
            } (LITA) {
              my $vals;
              lang:Perl {
                $vals = {nodes => [], value => ''};
              }

              &_AttributeValueSpecificationA_ ($doc => $doc, $vals => $vals);

              lang:Perl {
                for (@{$vals->{nodes}}) {
                  $at-><M::Node.appendChild> ($_);
                }
              }

              ~ (LITA) {
                ?lexmode AttlistDeclaration;
              } else {
                ?lexmode AttlistDeclaration;
              }
            }
          }

        } (LIT) {
          my $vals;
          lang:Perl {
            $at-><AS::ATDef.defaultType> (<C::ATDef.EXPLICIT_DEFAULT>);
            $vals = {nodes => [], value => ''};
          }

          &_AttributeValueSpecification_ ($doc => $doc, $vals => $vals);

          lang:Perl {
            for (@{$vals->{nodes}}) {
              $at-><M::Node.appendChild> ($_);
            }
          }

          ~ (LIT) {
            ?lexmode AttlistDeclaration;
          } else {
            ?lexmode AttlistDeclaration;
          }
        } (LITA) {
          my $vals;
          lang:Perl {
            $at-><AS::ATDef.defaultType> (<C::ATDef.EXPLICIT_DEFAULT>);
            $vals = {nodes => [], value => ''};
          }

          &_AttributeValueSpecificationA_ ($doc => $doc, $vals => $vals);

          lang:Perl {
            for (@{$vals->{nodes}}) {
              $at-><M::Node.appendChild> ($_);
            }
          }

          ~ (LITA) {
            ?lexmode AttlistDeclaration;
          } else {
            ?lexmode AttlistDeclaration;
          }
        }

      } (S) : separator : terminator? {
        //
      }

      ~ (MDC) {
        ?lexmode DTD;
      } else {
        ?lexmode DTD;
      }
    } // _AttlistDeclaration

    /*
      Entity declaration
    */
    rule _EntityDeclaration ($doc) {
      // ~ (MDO) { }
      // ~ (Name == ENTITY) { }

      ~ (S) { }

      my $decl;
      lang:Perl { $decl = { name => '#ILLEGAL', reptxt => \'' }; }

      ~? (PERO) {
        ~ (S) { }
        lang:Perl {
          $decl->{is_param_entity} = true;
        }
      }

      /*
        TODO: Set |$decl->{is_externally_declared}| flag
              and |Entity.isExternallyDeclared| attribute
              for entity declarations in external subset or
              in parameter entity.
      */

      ~ (Name) {
        lang:Perl ($v => $token.value) {
          $decl->{name} = $v;
        }
      } 

      my $node;
      lang:Perl {
        $node =
        $decl->{node} = $self->{docx}-><M::DocumentXDoctype.createGeneralEntity>
                                         ($decl->{name});
        ## TODO: Parameter entity...
      }

      ~ (S) { }

      ~ (LIT) {
        &_EntityValue ($doc => $doc, $decl => $decl);
      } (LITA) {
        &_EntityValueA ($doc => $doc, $decl => $decl);
      } (Name == 'PUBLIC') {
        ~ (S) { }

        &PubidLiteral ($decl => $node);

        ~ (S) { }

        &SystemLiteral ($decl => $node);

        lang:Perl {
          $decl->{is_external_entity} = true;
        }
      } (Name == 'SYSTEM') {
        ~ (S) { }

        &SystemLiteral ($decl => $node);

        lang:Perl {
          $decl->{is_external_entity} = true;
        }
      }

      ~? (S) {
        ~? (Name == 'NDATA') {
          // TODO: error if parameter entity

          ~ (S) { }
  
          ~ (Name) {
            lang:Perl ($v => $token.value) {
              $decl->{notation} = $v;
              $decl->{node}-><AG::x|Entity.notationName> ($v);
            }
          }

          ~? (S) { }
        }
      }

      lang:Perl {
        if ($self->{$decl->{is_param_entity} ? 'param_entity' : 'general_entity'}
                 ->{$decl->{name}}) {
          ## TODO: warning
          ## TODO: predefined entity error check
        } else {
          $self->{$decl->{is_param_entity} ? 'param_entity' : 'general_entity'}
               ->{$decl->{name}} = $decl;
          $self->{dtdef}-><M::DTDef.setGeneralEntityNode> ($decl->{node})
            unless $decl->{is_param_entity};
        }
      }

      ~ (MDC) {
        ?lexmode DTD;
      } else {
        ?lexmode DTD;
      }
    } // _EntityDeclaration

    rule _NotationDeclaration ($doc) {
      // ~ (MDO) { }
      // ~ (Name == NOTATION) { }

      ~ (S) { }

      ~ (Name) {

      } 

      ~ (S) { }

      my $decl;
      lang:Perl {
        $decl = $self->{docx}-><M::DocumentXDoctype.createGeneralEntity>
                                               ($decl->{name});
           ## Temporary: to avoid error.
      }

      ~ (Name == 'PUBLIC') {
        ~ (S) { }

        &PubidLiteral ($decl => $decl);

        ~? (S) {
          ~? (LIT) {
            ?lexmode SystemLiteral;
            &_SystemLiteral ($decl => $decl);

            ~? (S) { }
          } (LITA) {
            ?lexmode SystemLiteralA;
            &_SystemLiteral ($decl => $decl);

            ~? (S) { }
          }
        }
      } (Name == 'SYSTEM') {
        ~ (S) { }

        &SystemLiteral ($decl => $decl);

        ~? (S) { }
      }

      ~ (MDC) {
        ?lexmode DTD;
      } else {
        ?lexmode DTD;
      }
    } // _NotationDeclaration
 
    rule _EntityValue ($decl) {
      ?lexmode EntityValue;

      my $vals;
      my $reptxt;
      lang:Perl {
        $vals = [];
        $reptxt = '';
      }

      ~* (STRING) {
        lang:Perl ($v => $token.value) {
          $reptxt .= $v;
        }
      } (PERO) {
        ?lexmode EntityDeclaration;

        lang:Perl {
          $self->{has_xref} = true;
        }
     
        // TODO: Expand or wferror if internal subset

        ~ (Name) {

        }

        ~ (REFC) {
          ?lexmode EntityValue;
        } else {
          ?lexmode EntityValue;
        }
      } (HCRO) {
        &_HexadecimalCharacterReferenceEV_ ($vals => $vals);

        lang:Perl {
          $reptxt .= $vals->[-1];
        }

        ~ (REFC) {
          ?lexmode EntityValue;
        } else {
          ?lexmode EntityValue;
        }
      } (CRO) {
        &_NumericCharacterReferenceEV_ ($vals => $vals);
 
        lang:Perl {
          $reptxt .= $vals->[-1];
        }

        ~ (REFC) {
          ?lexmode EntityValue;
        } else {
          ?lexmode EntityValue;
        }
      } (ERO) {
        &_GeneralEntityReferenceEV_ ($vals => $vals);

        lang:Perl {
          $reptxt .= '&' . $vals->[-1] . ';';
        }

        ~ (REFC) {
          ?lexmode EntityValue;
        } else {
          ?lexmode EntityValue;
        }
      }

      ~ (LIT) {
        ?lexmode MarkupDeclaration;
      } (LITA) {
        ?lexmode MarkupDeclaration;
      } else {
        ?lexmode MarkupDeclaration;
      }

      lang:Perl {
        $decl->{reptxt} = \$reptxt;
        $decl->{has_replacement_text} = true;
      }
    } // _EntityValue

    rule _EntityValueA ($decl) {
      ?lexmode EntityValueA;

      my $vals;
      my $reptxt;
      lang:Perl {
        $vals = [];
        $reptxt = '';
      }

      ~* (STRING) {
        lang:Perl ($v => $token.value) {
          $reptxt .= $v;
        }
      } (PERO) {
        ?lexmode EntityDeclaration;

        lang:Perl {
          $self->{has_xref} = true;
        }

        // TODO: implement this
        ~ (Name) {

        }

        ~ (REFC) {
          ?lexmode EntityValueA;
        } else {
          ?lexmode EntityValueA;
        }
      } (HCRO) {
        &_HexadecimalCharacterReferenceEV_ ($vals => $vals);

        lang:Perl {
          $reptxt .= $vals->[-1];
        }


        ~ (REFC) {
          ?lexmode EntityValueA;
        } else {
          ?lexmode EntityValueA;
        }
      } (CRO) {
        &_NumericCharacterReferenceEV_ ($vals => $vals);

        lang:Perl {
          $reptxt .= $vals->[-1];
        }

        ~ (REFC) {
          ?lexmode EntityValueA;
        } else {
          ?lexmode EntityValueA;
        }
      } (ERO) {
        &_GeneralEntityReferenceEV_ ($vals => $vals);

        lang:Perl {
          $reptxt .= '&' . $vals->[-1] . ';';
        }

        ~ (REFC) {
          ?lexmode EntityValueA;
        } else {
          ?lexmode EntityValueA;
        }
      }

      ~ (LITA) {
        ?lexmode MarkupDeclaration;
      } else {
        ?lexmode MarkupDeclaration;
      }

      lang:Perl {
        $decl->{reptxt} = \$reptxt;
        $decl->{has_replacement_text} = true;
      }
    } // _EntityValueA

    
    /*
      XML Name
    */
    lexmode NameChar {
      $NameStartChar10 := [
        '_' ':'
        // Letter
          // BaseChar
          U+0041..U+005A U+0061..U+007A U+00C0..U+00D6
          U+00D8..U+00F6 U+00F8..U+00FF U+0100..U+0131
          U+0134..U+013E U+0141..U+0148 U+014A..U+017E
          U+0180..U+01C3 U+01CD..U+01F0 U+01F4..U+01F5
          U+01FA..U+0217 U+0250..U+02A8 U+02BB..U+02C1
          U+0386 U+0388..U+038A U+038C U+038E..U+03A1
          U+03A3..U+03CE U+03D0..U+03D6 U+03DA U+03DC
          U+03DE U+03E0 U+03E2..U+03F3 U+0401..U+040C
          U+040E..U+044F U+0451..U+045C U+045E..U+0481
          U+0490..U+04C4 U+04C7..U+04C8 U+04CB..U+04CC
          U+04D0..U+04EB U+04EE..U+04F5 U+04F8..U+04F9
          U+0531..U+0556 U+0559 U+0561..U+0586
          U+05D0..U+05EA U+05F0..U+05F2 U+0621..U+063A
          U+0641..U+064A U+0671..U+06B7 U+06BA..U+06BE
          U+06C0..U+06CE U+06D0..U+06D3 U+06D5
          U+06E5..U+06E6 U+0905..U+0939 U+093D
          U+0958..U+0961 U+0985..U+098C U+098F..U+0990
          U+0993..U+09A8 U+09AA..U+09B0 U+09B2
          U+09B6..U+09B9 U+09DC..U+09DD U+09DF..U+09E1
          U+09F0..U+09F1 U+0A05..U+0A0A U+0A0F..U+0A10
          U+0A13..U+0A28 U+0A2A..U+0A30 U+0A32..U+0A33
          U+0A35..U+0A36 U+0A38..U+0A39 U+0A59..U+0A5C
          U+0A5E U+0A72..U+0A74 U+0A85..U+0A8B U+0A8D
          U+0A8F..U+0A91 U+0A93..U+0AA8 U+0AAA..U+0AB0
          U+0AB2..U+0AB3 U+0AB5..U+0AB9 U+0ABD U+0AE0
          U+0B05..U+0B0C U+0B0F..U+0B10 U+0B13..U+0B28
          U+0B2A..U+0B30 U+0B32..U+0B33 U+0B36..U+0B39
          U+0B3D U+0B5C..U+0B5D U+0B5F..U+0B61
          U+0B85..U+0B8A U+0B8E..U+0B90 U+0B92..U+0B95
          U+0B99..U+0B9A U+0B9C U+0B9E..U+0B9F
          U+0BA3..U+0BA4 U+0BA8..U+0BAA U+0BAE..U+0BB5
          U+0BB7..U+0BB9 U+0C05..U+0C0C U+0C0E..U+0C10
          U+0C12..U+0C28 U+0C2A..U+0C33 U+0C35..U+0C39
          U+0C60..U+0C61 U+0C85..U+0C8C U+0C8E..U+0C90
          U+0C92..U+0CA8 U+0CAA..U+0CB3 U+0CB5..U+0CB9
          U+0CDE U+0CE0..U+0CE1 U+0D05..U+0D0C
          U+0D0E..U+0D10 U+0D12..U+0D28 U+0D2A..U+0D39
          U+0D60..U+0D61 U+0E01..U+0E2E U+0E30
          U+0E32..U+0E33 U+0E40..U+0E45 U+0E81..U+0E82
          U+0E84 U+0E87..U+0E88 U+0E8A U+0E8D
          U+0E94..U+0E97 U+0E99..U+0E9F U+0EA1..U+0EA3
          U+0EA5 U+0EA7 U+0EAA..U+0EAB U+0EAD..U+0EAE
          U+0EB0 U+0EB2..U+0EB3 U+0EBD U+0EC0..U+0EC4
          U+0F40..U+0F47 U+0F49..U+0F69 U+10A0..U+10C5
          U+10D0..U+10F6 U+1100 U+1102..U+1103
          U+1105..U+1107 U+1109 U+110B..U+110C
          U+110E..U+1112 U+113C U+113E U+1140 U+114C
          U+114E U+1150 U+1154..U+1155 U+1159
          U+115F..U+1161 U+1163 U+1165 U+1167 U+1169
          U+116D..U+116E U+1172..U+1173 U+1175 U+119E
          U+11A8 U+11AB U+11AE..U+11AF U+11B7..U+11B8
          U+11BA U+11BC..U+11C2 U+11EB U+11F0 U+11F9
          U+1E00..U+1E9B U+1EA0..U+1EF9 U+1F00..U+1F15
          U+1F18..U+1F1D U+1F20..U+1F45 U+1F48..U+1F4D
          U+1F50..U+1F57 U+1F59 U+1F5B U+1F5D
          U+1F5F..U+1F7D U+1F80..U+1FB4 U+1FB6..U+1FBC
          U+1FBE U+1FC2..U+1FC4 U+1FC6..U+1FCC
          U+1FD0..U+1FD3 U+1FD6..U+1FDB U+1FE0..U+1FEC
          U+1FF2..U+1FF4 U+1FF6..U+1FFC U+2126
          U+212A..U+212B U+212E U+2180..U+2182
          U+3041..U+3094 U+30A1..U+30FA U+3105..U+312C
          U+AC00..U+D7A3
          // Ideographic
          U+4E00..U+9FA5 U+3007 U+3021..U+3029
      ];
      $NameChar10 := [
        '.' '-' '_' ':'
        // Letter
          // BaseChar
          U+0041..U+005A U+0061..U+007A U+00C0..U+00D6
          U+00D8..U+00F6 U+00F8..U+00FF U+0100..U+0131
          U+0134..U+013E U+0141..U+0148 U+014A..U+017E
          U+0180..U+01C3 U+01CD..U+01F0 U+01F4..U+01F5
          U+01FA..U+0217 U+0250..U+02A8 U+02BB..U+02C1
          U+0386 U+0388..U+038A U+038C U+038E..U+03A1
          U+03A3..U+03CE U+03D0..U+03D6 U+03DA U+03DC
          U+03DE U+03E0 U+03E2..U+03F3 U+0401..U+040C
          U+040E..U+044F U+0451..U+045C U+045E..U+0481
          U+0490..U+04C4 U+04C7..U+04C8 U+04CB..U+04CC
          U+04D0..U+04EB U+04EE..U+04F5 U+04F8..U+04F9
          U+0531..U+0556 U+0559 U+0561..U+0586
          U+05D0..U+05EA U+05F0..U+05F2 U+0621..U+063A
          U+0641..U+064A U+0671..U+06B7 U+06BA..U+06BE
          U+06C0..U+06CE U+06D0..U+06D3 U+06D5
          U+06E5..U+06E6 U+0905..U+0939 U+093D
          U+0958..U+0961 U+0985..U+098C U+098F..U+0990
          U+0993..U+09A8 U+09AA..U+09B0 U+09B2
          U+09B6..U+09B9 U+09DC..U+09DD U+09DF..U+09E1
          U+09F0..U+09F1 U+0A05..U+0A0A U+0A0F..U+0A10
          U+0A13..U+0A28 U+0A2A..U+0A30 U+0A32..U+0A33
          U+0A35..U+0A36 U+0A38..U+0A39 U+0A59..U+0A5C
          U+0A5E U+0A72..U+0A74 U+0A85..U+0A8B U+0A8D
          U+0A8F..U+0A91 U+0A93..U+0AA8 U+0AAA..U+0AB0
          U+0AB2..U+0AB3 U+0AB5..U+0AB9 U+0ABD U+0AE0
          U+0B05..U+0B0C U+0B0F..U+0B10 U+0B13..U+0B28
          U+0B2A..U+0B30 U+0B32..U+0B33 U+0B36..U+0B39
          U+0B3D U+0B5C..U+0B5D U+0B5F..U+0B61
          U+0B85..U+0B8A U+0B8E..U+0B90 U+0B92..U+0B95
          U+0B99..U+0B9A U+0B9C U+0B9E..U+0B9F
          U+0BA3..U+0BA4 U+0BA8..U+0BAA U+0BAE..U+0BB5
          U+0BB7..U+0BB9 U+0C05..U+0C0C U+0C0E..U+0C10
          U+0C12..U+0C28 U+0C2A..U+0C33 U+0C35..U+0C39
          U+0C60..U+0C61 U+0C85..U+0C8C U+0C8E..U+0C90
          U+0C92..U+0CA8 U+0CAA..U+0CB3 U+0CB5..U+0CB9
          U+0CDE U+0CE0..U+0CE1 U+0D05..U+0D0C
          U+0D0E..U+0D10 U+0D12..U+0D28 U+0D2A..U+0D39
          U+0D60..U+0D61 U+0E01..U+0E2E U+0E30
          U+0E32..U+0E33 U+0E40..U+0E45 U+0E81..U+0E82
          U+0E84 U+0E87..U+0E88 U+0E8A U+0E8D
          U+0E94..U+0E97 U+0E99..U+0E9F U+0EA1..U+0EA3
          U+0EA5 U+0EA7 U+0EAA..U+0EAB U+0EAD..U+0EAE
          U+0EB0 U+0EB2..U+0EB3 U+0EBD U+0EC0..U+0EC4
          U+0F40..U+0F47 U+0F49..U+0F69 U+10A0..U+10C5
          U+10D0..U+10F6 U+1100 U+1102..U+1103
          U+1105..U+1107 U+1109 U+110B..U+110C
          U+110E..U+1112 U+113C U+113E U+1140 U+114C
          U+114E U+1150 U+1154..U+1155 U+1159
          U+115F..U+1161 U+1163 U+1165 U+1167 U+1169
          U+116D..U+116E U+1172..U+1173 U+1175 U+119E
          U+11A8 U+11AB U+11AE..U+11AF U+11B7..U+11B8
          U+11BA U+11BC..U+11C2 U+11EB U+11F0 U+11F9
          U+1E00..U+1E9B U+1EA0..U+1EF9 U+1F00..U+1F15
          U+1F18..U+1F1D U+1F20..U+1F45 U+1F48..U+1F4D
          U+1F50..U+1F57 U+1F59 U+1F5B U+1F5D
          U+1F5F..U+1F7D U+1F80..U+1FB4 U+1FB6..U+1FBC
          U+1FBE U+1FC2..U+1FC4 U+1FC6..U+1FCC
          U+1FD0..U+1FD3 U+1FD6..U+1FDB U+1FE0..U+1FEC
          U+1FF2..U+1FF4 U+1FF6..U+1FFC U+2126
          U+212A..U+212B U+212E U+2180..U+2182
          U+3041..U+3094 U+30A1..U+30FA U+3105..U+312C
          U+AC00..U+D7A3
          // Ideographic
          U+4E00..U+9FA5 U+3007 U+3021..U+3029
        // Digit
        U+0030..U+0039 U+0660..U+0669 U+06F0..U+06F9
        U+0966..U+096F U+09E6..U+09EF U+0A66..U+0A6F
        U+0AE6..U+0AEF U+0B66..U+0B6F U+0BE7..U+0BEF
        U+0C66..U+0C6F U+0CE6..U+0CEF U+0D66..U+0D6F
        U+0E50..U+0E59 U+0ED0..U+0ED9 U+0F20..U+0F29
        // CombiningChar
        U+0300..U+0345 U+0360..U+0361 U+0483..U+0486
        U+0591..U+05A1 U+05A3..U+05B9 U+05BB..U+05BD
        U+05BF U+05C1..U+05C2 U+05C4 U+064B..U+0652
        U+0670 U+06D6..U+06DC U+06DD..U+06DF
        U+06E0..U+06E4 U+06E7..U+06E8 U+06EA..U+06ED
        U+0901..U+0903 U+093C U+093E..U+094C U+094D
        U+0951..U+0954 U+0962..U+0963 U+0981..U+0983
        U+09BC U+09BE U+09BF U+09C0..U+09C4
        U+09C7..U+09C8 U+09CB..U+09CD U+09D7
        U+09E2..U+09E3 U+0A02 U+0A3C U+0A3E U+0A3F
        U+0A40..U+0A42 U+0A47..U+0A48 U+0A4B..U+0A4D
        U+0A70..U+0A71 U+0A81..U+0A83 U+0ABC
        U+0ABE..U+0AC5 U+0AC7..U+0AC9 U+0ACB..U+0ACD
        U+0B01..U+0B03 U+0B3C U+0B3E..U+0B43
        U+0B47..U+0B48 U+0B4B..U+0B4D U+0B56..U+0B57
        U+0B82..U+0B83 U+0BBE..U+0BC2 U+0BC6..U+0BC8
        U+0BCA..U+0BCD U+0BD7 U+0C01..U+0C03
        U+0C3E..U+0C44 U+0C46..U+0C48 U+0C4A..U+0C4D
        U+0C55..U+0C56 U+0C82..U+0C83 U+0CBE..U+0CC4
        U+0CC6..U+0CC8 U+0CCA..U+0CCD U+0CD5..U+0CD6
        U+0D02..U+0D03 U+0D3E..U+0D43 U+0D46..U+0D48
        U+0D4A..U+0D4D U+0D57 U+0E31 U+0E34..U+0E3A
        U+0E47..U+0E4E U+0EB1 U+0EB4..U+0EB9
        U+0EBB..U+0EBC U+0EC8..U+0ECD U+0F18..U+0F19
        U+0F35 U+0F37 U+0F39 U+0F3E U+0F3F
        U+0F71..U+0F84 U+0F86..U+0F8B U+0F90..U+0F95
        U+0F97 U+0F99..U+0FAD U+0FB1..U+0FB7 U+0FB9
        U+20D0..U+20DC U+20E1 U+302A..U+302F U+3099
        U+309A
        // Extender
        U+00B7 U+02D0 U+02D1 U+0387 U+0640 U+0E46
        U+0EC6 U+3005 U+3031..U+3035 U+309D..U+309E
        U+30FC..U+30FE
      ];
      
      $NameStartChar11 := [
        ':' '_'
        'A' 'B' 'C' 'D' 'E' 'F' 'G' 'H' 'I' 'J' 'K' 'L' 'M'
        'N' 'O' 'P' 'Q' 'R' 'S' 'T' 'U' 'V' 'W' 'X' 'Y' 'Z'
        'a' 'b' 'c' 'd' 'e' 'f' 'g' 'h' 'i' 'j' 'k' 'l' 'm'
        'n' 'o' 'p' 'q' 'r' 's' 't' 'u' 'v' 'w' 'x' 'y' 'z'
        U+00C0..U+00D6 U+00D8..U+00F6 U+00F8..U+02FF
        U+0370..U+037D U+037F..U+1FFF U+200C..U+200D
        U+2070..U+218F U+2C00..U+2FEF U+3001..U+D7FF
        U+F900..U+FDCF U+FDF0..U+FFFD U+10000..U+EFFFF
      ];
      $NameChar11 := [
        '-' '.' '0' '1' '2' '3' '4' '5' '6' '7' '8' '9'
        U+00B7 U+0300..U+036F U+203F..U+2040
        // NameStartChar
        ':' '_'
        'A' 'B' 'C' 'D' 'E' 'F' 'G' 'H' 'I' 'J' 'K' 'L' 'M'
        'N' 'O' 'P' 'Q' 'R' 'S' 'T' 'U' 'V' 'W' 'X' 'Y' 'Z'
        'a' 'b' 'c' 'd' 'e' 'f' 'g' 'h' 'i' 'j' 'k' 'l' 'm'
        'n' 'o' 'p' 'q' 'r' 's' 't' 'u' 'v' 'w' 'x' 'y' 'z'
        U+00C0..U+00D6 U+00D8..U+00F6 U+00F8..U+02FF
        U+0370..U+037D U+037F..U+1FFF U+200C..U+200D
        U+2070..U+218F U+2C00..U+2FEF U+3001..U+D7FF
        U+F900..U+FDCF U+FDF0..U+FFFD U+10000..U+EFFFF
      ];
    } // NameChar

    lexmode Name
      : extends => 'NameChar'
    {
      Name : value := $NameStartChar11 $NameChar11*;
    } // Name

    lexmode Nmtoken
      : extends => 'NameChar'
    {
      Nmtoken : value := $NameChar11*;
    } // Nmtoken
    
    /*
      S
    */
    lexmode S {
      $s := [U+0009 U+000A U+000D U+0020];
      S := $s+;
    } // S
    
    /*
      Document end scanning mode
    */
    lexmode DocumentEnd
      : standalone
      : extends => 'S'
    {
      /*
        Processing instruction
      */
      PIO := ['<'] ['?'];
      
      /*
        Comment declaration
      */
      CDO := ['<'] ['!'] ['-'] ['-'];
    } // DocumentEnd

    /*
      Document misc scanning mode
      
      This mode scans |Misc| constructions as well
      as document element's start tag.
    */
    lexmode DocumentMisc
      : standalone
      : extends => 'DocumentEnd'
    {
      /*
        Document element start tag
      */
      STAGO := ['<'];
    } // DocumentMisc
    
    /*
      Document prolog scanning mode
    */
    lexmode DocumentProlog
      : standalone
      : extends => 'DocumentMisc'
    {
      /*
        |DOCTYPE| declaration
      */
      MDO := ['<'] ['!'];
    } // DocumentProlog

    /*
      Document Start Scanning Mode
    */
    lexmode DocumentStart
      : standalone
      : extends => 'DocumentProlog'
    {
      /*
        XML declaration
      */
      XDO := ['<'] ['?'] ['x'] ['m'] ['l'];
    } // DocumentStart
    
    /*
      Comment declaration scanning mode
    */
    lexmode CommentDeclaration
      : standalone
    {
      /*
        Comment close
      */
      COM := ['-'] ['-'];
      
      /*
        Comment data
      */
      ?default-token STRING : value;
    } // CommentDeclaration
    
    /*
      Processing instruction name and |S| scanning mode
    */
    lexmode PIName
      : standalone
      : extends => 'Name'
      : extends => 'S'
    {
      /*
        Processing instruction close
      */
      PIC := ['?'] ['>'];
    } // PIName
    
    /*
      Processing instruction name and |S| scanning mode
    */
    lexmode PINmtoken
      : standalone
      : extends => 'Nmtoken'
      : extends => 'S'
    {
      /*
        Processing instruction close
      */
      PIC := ['?'] ['>'];
    } // PINmtoken
    
    /*
      Processing instruction data scanning mode
    */
    lexmode PIData
      : standalone
    {
      /*
        Processing instruction close
      */
      PIC := ['?'] ['>'];
      
      /*
        Processing instruction target data
      */
      ?default-token DATA : value;
    } // PIData
    
    /*
      Content of element scanning mode
    */
    lexmode ElementContent
      : standalone
    {
      /*
        Start tag open
      */
      STAGO := ['<'];
      
      /* 
        End tag open
      */
      ETAGO := ['<'] ['/'];
      
      /*
        Hexadecimal character reference open
      */
      HCRO := ['&'] ['#'] ['x'];
      
      /*
        Numeric character reference open
      */
      CRO := ['&'] ['#'];
      
      /*
        General entity reference open
      */
      ERO := ['&'];
      
      /*
        Comment declaration open
      */
      CDO := ['<'] ['!'] ['-'] ['-'];
      
      /*
        CDATA section open
      */
      CDSO := ['<'] ['!'] ['[']
              ['C'] ['D'] ['A'] ['T'] ['A'] ['['];
      
      /*
        Processing instruction open
      */
      PIO := ['<'] ['?'];

      /*
        Markup section end
      */
      MSE := [']'] [']'] ['>'];

      /*
        Character data
      */
      /*
        Character data and/or |MSE|
      */
      ?default-token CharData : value;
    } // ElementContent
    
    /*
      CDATA section content scanning mode
    */
    lexmode CDATASectionContent
      : standalone
    {
      /*
        Markup section end
      */
      MSE := [']'] [']'] ['>'];
      
      /*
        Character data
      */
      ?default-token CData : value;
    } // CDATASectionContent
    
    lexmode EntityReference
      : standalone
      : extends => 'Name'
    {
      /*
        Reference close
      */
      REFC := [';'];
    } // EntityReference
    
    lexmode NumericCharacterReference
      : standalone
    {
      /*
        Decimal number
      */
      $digit := ['0' '1' '2' '3' '4' '5' '6' '7' '8' '9'];
      NUMBER : value := $digit+;
      
      /*
        Reference close
      */
      REFC := [';'];
    } // NumericCharacterReference
    
    lexmode HexadecimalCharacterReference
      : standalone
    {
      /*
        Hexadecimal number
      */
      $hexdigit := ['0' '1' '2' '3' '4' '5' '6' '7' '8' '9'
                    'A' 'B' 'C' 'D' 'E' 'F'
                    'a' 'b' 'c' 'd' 'e' 'f'];
      Hex : value := $hexdigit+;
      
      /*
        Reference close
      */
      REFC := [';'];
    } // HexadecimalCharacterReference
    
    /*
      The XML Declaration and Text Declaration Scanning Mode
    */
    lexmode XMLDeclaration
      : standalone
      : extends => 'Name'
      : extends => 'S'
    {
      
      /*
        Value indicator
      */
      VI := ['='];
      
      /*
        Literal open
      */
      LIT := ['"'];
      LITA := [U+0027];
      
      /*
        Processing instruction close

          The |PIC|, i.e. |?>|, is split into two tokens |PIC1| and |PIC2|
          in this scanning mode to set |no_xml11_eol| flag in the
          |_XMLDeclaration_| |rule|.
      */
      PIC1 := ['?'];
      PIC2 := ['>'];
    } // XMLDeclaration

    /*
      The XML Declaration or Processing Instruction Scanning Mode

           '<?xml'               S                 ...
        (DocumentStart) (XMLDeclarationOrPI) (XMLDeclaration)
           '<?xml'              '1'                S                ...
        (DocumentStart) (XMLDeclarationOrPI) (PINmtoken)(PIName) (PITarget)
           '<?xml'              '-'         'stylesheet'    S       ...
        (DocumentStart) (XMLDeclarationOrPI) (PINmtoken) (PIName) (PITarget)
    */
    lexmode XMLDeclarationOrPI
      : standalone
      : extends => 'NameChar'
      : extends => 'S'
    {
      NameChar : value := $NameChar11;
    } // XMLDeclarationOrPI
    
    lexmode StartTag
      : standalone
      : extends => 'Name'
      : extends => 'S'
    {
      
      /*
        Value indicator
      */
      VI := ['='];
      
      /*
        Literal open
      */
      LIT := ['"'];
      LITA := [U+0027];
      
      /*
        Tag close
      */
      TAGC := ['>'];
      
      /*
        Null end-tag enabled start-tag close
      */
      NESTC := ['/'];
    } // StartTag
    
    lexmode EndTag
      : standalone
      : extends => 'Name'
      : extends => 'S'
    {
      /*
        Tag close
      */
      TAGC := ['>'];
    } // EndTag
    
    lexmode AttributeValueLiteral_ {
      ERO := ['&'];
      CRO := ['&'] ['#'];
      HCRO := ['&'] ['#'] ['x'];
    } // AttributeValueLiteral_
    
    lexmode AttributeValueLiteral
      : standalone
      : extends => 'AttributeValueLiteral_'
    {
      LIT := ['"'];
      STRING : value := [^'"' '&' '<']+;
    } // AttributeValueLiteral
    
    lexmode AttributeValueLiteralA
      : standalone
      : extends => 'AttributeValueLiteral_'
    {
      LITA := [U+0027];
      STRING : value := [^U+0027 '&' '<']+;
    } // AttributeValueLiteralA
    
    lexmode AttributeValueLiteralE
      : standalone
      : extends => 'AttributeValueLiteral_'
    {
      STRING : value := [^'&' '<']+;
    } // AttributeValueLiteralE

    lexmode EntityValue_ {
      PERO := ['%'];
      ERO := ['&'];
      CRO := ['&'] ['#'];
      HCRO := ['&'] ['#'] ['x'];
    } // EntityValue_
    
    lexmode EntityValue
      : standalone
      : extends => 'EntityValue_'
    {
      LIT := ['"'];
      STRING : value := [^'"' '&' '%']+;
    } // EntityValue
    
    lexmode EntityValueA
      : standalone
      : extends => 'EntityValue_'
    {
      LITA := [U+0027];
      STRING : value := [^U+0027 '&' '%']+;
    } // EntityValueA

    lexmode SystemLiteral
      : standalone
    {
      LIT := ['"'];
      ?default-token STRING : value;
    } // SystemLiteral

    lexmode SystemLiteralA
      : standalone
    {
      LITA := [U+0027];
      ?default-token STRING : value;
    } // SystemLiteralA

    lexmode DTD
      : standalone
      : extends => 'S'
    {
      /*
        Markup declaration open
      */
      MDO := ['<'] ['!'];

      /*
        Comment declaration open
      */
      CDO := ['<'] ['!'] ['-'] ['-'];

      /*
        Processing instruction open
      */
      PIO := ['<'] ['?'];

      /*
        Parameter entity reference open
      */
      PERO := ['%'];

      /*
        Declaration subset close
      */
      DSC := [']'];

      /*
        Contition section open
      */
      CSO := ['<'] ['!'] ['['];
    } // DTD
    
    /*
      Markup declaration scanning mode
      
      This mode is used to recognize |MDC| that terminates
      a comment declaration as well as the base |lexmode|
      for e.g. document type declaration scanning mode.
    */
    lexmode MarkupDeclaration
      : standalone
      : extends => 'Name'
      : extends => 'S'
    {
      /*
        Markup declaration close
      */
      MDC := ['>'];
      
      /*
        Literal open
      */
      LIT := ['"'];
      
      /*
        Alternative literal open
      */
      LITA := [U+0027];

      /*
        Parameter entity reference open
      */
      PERO := ['%'];
    
      /*
        Declaration subset open
      */
      DSO := ['['];
    } // MarkupDeclaration

    lexmode ElementDeclaration
      : standalone
      : extends => 'MarkupDeclaration'
    {
      /*
        Model group open
      */
      MGO := ['('];

      /*
        Model group close
      */
      MGC := [')'];

      /*
        Reserved name indicator
      */
      RNI := ['#'];

      /*
        Occurence indicators
      */
      OPT := ['?'];
      REP := ['*'];
      PLUS := ['+'];

      /*
        Connectors
      */
      OR := ['|'];
      SEQ := [','];
    } // ElementDeclaration

    lexmode AttlistDeclaration
      : standalone
      : extends => 'MarkupDeclaration'
    {
      /*
        Enumeration group open
      */
      EGO := ['('];

      /*
        Enumeration group close
      */
      EGC := [')'];

      /*
        Enumeration choice delimiter
      */
      OR := ['|'];

      /*
        Reserved name indicator
      */
      RNI := ['#'];
    } // AttlistDeclaration

    lexmode Enumeration
      : standalone
      : extends => 'Nmtoken'
      : extends => 'S'
    {
      /*
        Enumeration group close
      */
      EGC := [')'];

      /*
        Enumeration choice delimiter
      */
      OR := ['|'];
    } // Enumeration

    
    token-error default : default {
      lang:Perl {
        my $location;
        __CODE{xp|get-location-from-token::
          $token => {$token},
          $result => {$location},
        }__;
        my $continue = __DOMCore:ERROR{xp|wf-syntax-error::
          xp|error-token => {$token},
          DOMCore|location => {$location},
        }__;
        unless ($continue) {
          __EXCEPTION{DOMLS|PARSE_ERR::
          }__;
        }
      }
    } // default

  @XMLTests:
    @@XMLTest:
      @@@QName: xp.char.xml10.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0"?>
          <p>$u0009$u000A$u000D$u0020$uD7FF$uE000$uFFFD$U00010000$U0010FFFF</p>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          element {
            text-content: U+0009 U+000A U+000A U+0020 U+D7FF
                          U+E000 U+FFFD U+10000 U+10FFFF;
          }
        }
    @@XMLTest:
      @@@QName: xp.char.xml11.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.1"?>
          <p>$u0009$u000A$u000D$u0020$uD7FF$uE000$uFFFD$U00010000$U0010FFFF</p>
      @@@test:domTree:
        document {
          xml-version: '1.1';
          element {
            text-content: U+0009 U+000A U+000A U+0020 U+D7FF
                          U+E000 U+FFFD U+10000 U+10FFFF;
          }
        }
    @@XMLTest:
      @@@QName: xp.char.xml10.c0.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0"?>
          <p>$u0000$u0001$u0002$u0003$u0004$u0005$u0006$u0007$u0008$u000B$
          $u000C$u000E$u000F$u0010$u0011$u0012$u0013$u0014$u0015$u0016$
          $u0017$u0018$u0019$u001A$u001B$u001C$u001D$u001E$u001F</p>
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 4); } /* U+0000 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 5); } /* U+0001 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 6); } /* U+0002 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 7); } /* U+0003 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 8); } /* U+0004 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 9); } /* U+0005 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 10); } /* U+0006 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 11); } /* U+0007 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 12); } /* U+0008 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 13); } /* U+000B */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 14); } /* U+000C */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 15); } /* U+000E */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 16); } /* U+000F */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 17); } /* U+0010 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 18); } /* U+0011 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 19); } /* U+0012 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 20); } /* U+0013 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 21); } /* U+0014 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 22); } /* U+0015 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 23); } /* U+0016 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 24); } /* U+0017 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 25); } /* U+0018 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 26); } /* U+0019 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 27); } /* U+001A */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 28); } /* U+001B */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 29); } /* U+001C */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 30); } /* U+001D */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 31); } /* U+001E */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 32); } /* U+001F */
    @@XMLTest:
      @@@QName: xp.char.xml11.c0.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.1"?>
          <p>$u0000$u0001$u0002$u0003$u0004$u0005$u0006$u0007$u0008$u000B$
          $u000C$u000E$u000F$u0010$u0011$u0012$u0013$u0014$u0015$u0016$
          $u0017$u0018$u0019$u001A$u001B$u001C$u001D$u001E$u001F</p>
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 4); } /* U+0000 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 5); } /* U+0001 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 6); } /* U+0002 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 7); } /* U+0003 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 8); } /* U+0004 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 9); } /* U+0005 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 10); } /* U+0006 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 11); } /* U+0007 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 12); } /* U+0008 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 13); } /* U+000B */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 14); } /* U+000C */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 15); } /* U+000E */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 16); } /* U+000F */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 17); } /* U+0010 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 18); } /* U+0011 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 19); } /* U+0012 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 20); } /* U+0013 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 21); } /* U+0014 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 22); } /* U+0015 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 23); } /* U+0016 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 24); } /* U+0017 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 25); } /* U+0018 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 26); } /* U+0019 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 27); } /* U+001A */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 28); } /* U+001B */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 29); } /* U+001C */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 30); } /* U+001D */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 31); } /* U+001E */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 32); } /* U+001F */
    @@XMLTest:
      @@@QName: xp.char.xml10.c1.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0"?>
          <p>$u007F$u0080$u0081$u0082$u0083$u0084$u0086$u0087$u0088$
          $u0089$u008A$u008B$u008C$
          $u008D$u008E$u008F$u0090$u0091$u0092$u0093$u0094$u0095$u0096$
          $u0097$u0098$u0099$u009A$u009B$u009C$u009D$u009E$u009F$u0085</p>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          element {
            text-content: U+007F U+0080 U+0081 U+0082 U+0083 U+0084 U+0086
                          U+0087 U+0088 U+0089 U+008A U+008B U+008C U+008D
                          U+008E U+008F U+0090 U+0091 U+0092 U+0093 U+0094
                          U+0095 U+0096 U+0097 U+0098 U+0099 U+009A U+009B
                          U+009C U+009D U+009E U+009F U+0085;
          }
        }
    @@XMLTest:
      @@@QName: xp.char.xml11.c1.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.1"?>
          <p>$u007F$u0080$u0081$u0082$u0083$u0084$u0086$u0087$u0088$
          $u0089$u008A$u008B$u008C$
          $u008D$u008E$u008F$u0090$u0091$u0092$u0093$u0094$u0095$u0096$
          $u0097$u0098$u0099$u009A$u009B$u009C$u009D$u009E$u009F$u0085</p>
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 4); } /* U+007F */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 5); } /* U+0080 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 6); } /* U+0081 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 7); } /* U+0082 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 8); } /* U+0083 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 9); } /* U+0084 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 10); } /* U+0086 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 11); } /* U+0087 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 12); } /* U+0088 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 13); } /* U+0089 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 14); } /* U+008A */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 15); } /* U+008B */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 16); } /* U+008C */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 17); } /* U+008D */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 18); } /* U+008E */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 19); } /* U+008F */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 20); } /* U+0090 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 21); } /* U+0091 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 22); } /* U+0092 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 23); } /* U+0093 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 24); } /* U+0094 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 25); } /* U+0095 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 26); } /* U+0096 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 27); } /* U+0097 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 28); } /* U+0098 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 29); } /* U+0099 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 30); } /* U+009A */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 31); } /* U+009B */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 32); } /* U+009C */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 33); } /* U+009D */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 34); } /* U+009E */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 35); } /* U+009F */

    @@XMLTest:
      @@@QName: xp.syntax.empty.test
      @@@DEnt:
        @@@@test:value: \
      @@@c:erred:
        <[[xp:wf-syntax-error]]> { (1, 1); }
    @@XMLTest:
      @@@QName: xp.syntax.space.test
      @@@DEnt:
        @@@@test:value: \   
      @@@c:erred:
        <[[xp:wf-syntax-error]]> { (1, 4); }
    @@XMLTest:
      @@@QName: xp.syntax.newlines.test
      @@@DEnt:
        @@@@test:value:
          \
          \
          \
      @@@c:erred:
        <[[xp:wf-syntax-error]]> { (3, 1); }

    @@XMLTest:
      @@@QName: xp.only.docel.test
      @@@DEnt:
        @@@@test:value:
          <p></p>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          xml-encoding: null;
          xml-standalone: false;
          element {
            namespace-uri: null;
            prefix: null;
            local-name: 'p';
            text-content: '';
          }
        }
    @@XMLTest:
      @@@QName: xp.only.docel.emptyelemtag.test
      @@@DEnt:
        @@@@test:value:
          <p/>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          xml-encoding: null;
          xml-standalone: false;
          element {
            namespace-uri: null;
            prefix: null;
            local-name: 'p';
            text-content: '';
          }
        }
    @@XMLTest:
      @@@QName: xp.root.s.1.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0"?>$u0020$u000D$u000A$u0009
          <p></p>
      @@@test:domTree:
        document {
          element { }
        }

    @@XMLTest:
      @@@QName: xp.Name.1.test
      @@@DEnt:
        @@@@test:value: <name/>
      @@@test:domTree:
        document {
          element {
            node-name: 'name';
          }
        }
    @@XMLTest:
      @@@QName: xp.Name.2.test
      @@@DEnt:
        @@@@test:value: <name0/>
      @@@test:domTree:
        document {
          element {
            node-name: 'name0';
          }
        }
    @@enImplNote:
      @@@ddid: xml11name
      @@@@:
        {TODO:: XML 1.1 Name tests required
        }

    @@XMLTest:
      @@@QName: xp.content.mse.1.test
      @@@DEnt:
        @@@@test:value:
          <p>]]></p>
      @@@c:erred:
        <[[xp|wf-syntax-error]]> { (1, 4)..(1, 6); }
    @@XMLTest:
      @@@QName: xp.content.mse.2.test
      @@@DEnt:
        @@@@test:value:
          <p>aaa]]>bbb</p>
      @@@c:erred:
        <[[xp|wf-syntax-error]]> { (1, 7)..(1, 9); }

    @@XMLTest:
      @@@QName: xp.root.comment.1.test
      @@@DEnt:
        @@@@test:value:
          <!--comment data-->
          <p/>
      @@@test:domTree:
        document {
          comment {
            data: 'comment data';
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.root.comment.2.test
      @@@DEnt:
        @@@@test:value:
          <!---->
          <p/>
      @@@test:domTree:
        document {
          comment {
            data: '';
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.root.after.pi.comment.1.test
      @@@DEnt:
        @@@@test:value:
          <?pi?>
          <!--comment data-->
          <p/>
      @@@test:domTree:
        document {
          pi { }
          comment {
            data: 'comment data';
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.root.after.pi.comment.2.test
      @@@DEnt:
        @@@@test:value:
          <?pi?>
          <!---->
          <p/>
      @@@test:domTree:
        document {
          pi { }
          comment {
            data: '';
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.root.after.element.comment.1.test
      @@@DEnt:
        @@@@test:value:
          <p/>
          <!--comment data-->
      @@@test:domTree:
        document {
          element { }
          comment {
            data: 'comment data';
          }
        }
    @@XMLTest:
      @@@QName: xp.root.after.element.comment.2.test
      @@@DEnt:
        @@@@test:value:
          <p/>
          <!---->
      @@@test:domTree:
        document {
          element { }
          comment {
            data: '';
          }
        }
    @@XMLTest:
      @@@QName: xp.doctype.intsubset.comment.1.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
          <!--comment data-->
          ]>
          <p/>
      @@@test:domTree:
        document {
          document-type { }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.doctype.intsubset.comment.2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
          <!---->
          ]>
          <p/>
      @@@test:domTree:
        document {
          document-type { }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.doctype.intsubset.comment.3.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
          <?pi?>
          <!---->
          ]>
          <p/>
      @@@test:domTree:
        document {
          document-type {
            pi { }
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.content.comment.1.test
      @@@DEnt:
        @@@@test:value:
          <p><!--comment data--></p>
      @@@test:domTree:
        document {
          element {
            comment {
              data: 'comment data';
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.content.comment.2.test
      @@@DEnt:
        @@@@test:value:
          <p><!----></p>
      @@@test:domTree:
        document {
          element {
            comment {
              data: '';
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.content.comment.3.test
      @@@DEnt:
        @@@@test:value:
          <p>aaaaa<!---->bbbbb</p>
      @@@test:domTree:
        document {
          element {
            text {
              data: 'aaaaa';
            }
            comment {
              data: '';
            }
            text {
              data: 'bbbbb';
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.content.comment.--.1.test
      @@@DEnt:
        @@@@test:value:
          <p><!--data--data--></p>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 12)..(1, 17); }
    @@XMLTest:
      @@@QName: xp.content.comment.---gt.test
      @@@DEnt:
        @@@@test:value:
          <p><!--data---></p>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 12)..(1, 15); }

    @@XMLTest:
      @@@QName: xp.xmldecl.version.1.0.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0"?>
          <p></p>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          xml-encoding: null;
          xml-standalone: false;
          element { }
        }
    @@XMLTest:
      @@@QName: xp.xmldecl.version.1.0.lita.test
      @@@DEnt:
        @@@@test:value:
          <?xml version='1.0'?>
          <p></p>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          xml-encoding: null;
          xml-standalone: false;
          element { }
        }
    @@XMLTest:
      @@@QName: xp.xmldecl.version.1.0.s.test
      @@@DEnt:
        @@@@test:value:
          <?xml  version  =  "1.0"  ?>
          <p></p>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          xml-encoding: null;
          xml-standalone: false;
          element { }
        }
    @@XMLTest:
      @@@QName: xp.xmldecl.version.1.1.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.1"?>
          <p></p>
      @@@test:domTree:
        document {
          xml-version: '1.1';
          xml-encoding: null;
          xml-standalone: false;
          element { }
        }

    @@XMLTest:
      @@@QName: xp.xmldecl.version.1.0.encoding.usascii.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" encoding="US-ascii"?>
          <p></p>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          xml-encoding: 'US-ascii';
          xml-standalone: false;
          element { }
        }
    @@XMLTest:
      @@@QName: xp.xmldecl.version.1.0.encoding.usascii.lita.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" encoding='US-ascii'?>
          <p></p>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          xml-encoding: 'US-ascii';
          xml-standalone: false;
          element { }
        }
    @@XMLTest:
      @@@QName: xp.xmldecl.version.1.0.encoding.usascii.s.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" encoding  = "US-ascii" ?>
          <p></p>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          xml-encoding: 'US-ascii';
          xml-standalone: false;
          element { }
        }

    @@XMLTest:
      @@@QName: xp.xmldecl.version.1.0.encoding.usascii.standalone.yes.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" encoding="us-ascii" standalone="yes"?>
          <p></p>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          xml-encoding: 'us-ascii';
          xml-standalone: true;
          element { }
        }
    @@XMLTest:
      @@@QName: xp.xmldecl.version.1.0.encoding.usascii.standalone.no.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" encoding="us-ascii" standalone="no"?>
          <p></p>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          xml-encoding: 'us-ascii';
          xml-standalone: false;
          element { }
        }
    @@XMLTest:
      @@@QName: xp.xmldecl.version.1.0.encoding.usascii.standalone.yes.lita.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" encoding="us-ascii" standalone='yes'?>
          <p></p>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          xml-encoding: 'us-ascii';
          xml-standalone: true;
          element { }
        }
    @@XMLTest:
      @@@QName: xp.xmldecl.version.1.0.encoding.usascii.standalone.yes.s.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" encoding="us-ascii"  standalone  = "yes"  ?>
          <p></p>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          xml-encoding: 'us-ascii';
          xml-standalone: true;
          element { }
        }
    @@XMLTest:
      @@@QName: xp.xmldecl.no.encoding.but.standalone.attr.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="yes"?>
          <p></p>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          xml-encoding: null;
          xml-standalone: true;
          element { }
        }
    @@XMLTest:
      @@@QName: xp.xmldecl.encoding.encname.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" encoding="a-._01-"?>
          <p></p>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          xml-encoding: 'a-._01-';
          xml-standalone: false;
          element { }
        }

    @@XMLTest:
      @@@QName: xp.xmldecl.no.s.no.attr.test
      @@@DEnt:
        @@@@test:value:
          <?xml?>
          <p></p>
      @@@c:erred:
        <[[xp:wf-syntax-error]]> { (1, 1)..(1, 7); }
    @@XMLTest:
      @@@QName: xp.xmldecl.s.no.attr.test
      @@@DEnt:
        @@@@test:value:
          <?xml  ?>
          <p></p>
      @@@c:erred:
        <[[xp:wf-syntax-error]]> { (1, 8)..(1, 9); }
    @@XMLTest:
      @@@QName: xp.xmldecl.unknown.attr.test
      @@@DEnt:
        @@@@test:value:
          <?xml  unknown="value"?>
          <p></p>
      @@@c:erred:
        <[[xp:wf-syntax-error]]> { (1, 8)..(1, 22); }
    @@XMLTest:
      @@@QName: xp.xmldecl.version.unknown.attr.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" unknown="value"?>
          <p></p>
      @@@c:erred:
        <[[xp:wf-syntax-error]]> { (1, 21)..(1, 35); }
    @@XMLTest:
      @@@QName: xp.xmldecl.version.encoding.unknown.attr.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" encoding="us-ascii" unknown="value"?>
          <p></p>
      @@@c:erred:
        <[[xp:wf-syntax-error]]> { (1, 41)..(1, 55); }
    @@XMLTest:
      @@@QName: xp.xmldecl.version.encoding.standalone.unknown.attr.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" encoding="us-ascii" standalone="yes"
          unknown="value"?>
          <p></p>
      @@@c:erred:
        <[[xp:wf-syntax-error]]> { (2, 1)..(2, 15); }
    @@XMLTest:
      @@@QName: xp.xmldecl.no.version.but.encoding.attr.test
      @@@DEnt:
        @@@@test:value:
          <?xml encoding="us-ascii"?>
          <p></p>
      @@@c:erred:
        <[[xp:wf-syntax-error]]> { (1, 7)..(1, 25); }
    @@XMLTest:
      @@@QName: xp.xmldecl.no.version.but.standalone.attr.test
      @@@DEnt:
        @@@@test:value:
          <?xml standalone="yes"?>
          <p></p>
      @@@c:erred:
        <[[xp:wf-syntax-error]]> { (1, 7)..(1, 24); }
    @@XMLTest:
      @@@QName: xp.xmldecl.version.unsupported.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.2"?>
          <p></p>
      @@@c:erred:
        <[[xp:wf-unsupported-xml-version]]> { (1, 7)..(1, 19); }
    @@XMLTest:
      @@@QName: xp.xmldecl.version.unsupported.2.test
      @@@DEnt:
        @@@@test:value:
          <?xml version=" 1.0 "?>
          <p></p>
      @@@c:erred:
        <[[xp:wf-unsupported-xml-version]]> { (1, 7)..(1, 21); }
    @@XMLTest:
      @@@QName: xp.xmldecl.version.unsupported.3.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="01.00"?>
          <p></p>
      @@@c:erred:
        <[[xp:wf-unsupported-xml-version]]> { (1, 7)..(1, 21); }
    @@XMLTest:
      @@@QName: xp.xmldecl.encoding.malformed.1.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" encoding="0088"?>
          <p></p>
      @@@c:erred:
        <[[xp:wf-malformed-enc-name]]> { (1, 21)..(1, 35); }
    @@XMLTest:
      @@@QName: xp.xmldecl.encoding.malformed.2.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" encoding="D.V.D!"?>
          <p></p>
      @@@c:erred:
        <[[xp:wf-malformed-enc-name]]> { (1, 21)..(1, 38); }
    @@XMLTest:
      @@@QName: xp.xmldecl.standalone.malformed.1.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="true"?>
          <p></p>
      @@@c:erred:
        <[[xp:wf-malformed-xml-standalone]]> { (1, 21)..(1, 38); }
    @@XMLTest:
      @@@QName: xp.xmldecl.standalone.malformed.2.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="YES"?>
          <p></p>
      @@@c:erred:
        <[[xp:wf-malformed-xml-standalone]]> { (1, 21)..(1, 37); }
    @@XMLTest:
      @@@QName: xp.xmldecl.standalone.malformed.3.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="no  "?>
          <p></p>
      @@@c:erred:
        <[[xp:wf-malformed-xml-standalone]]> { (1, 21)..(1, 38); }
    
    @@XMLTest:
      @@@QName: xp.no-xmldecl.xml...-pi.test
      @@@DEnt:
        @@@@test:value:
          <?xmldeclaration?>
          <a></a>
      @@@test:domTree:
        document {
          pi {
            node-name: 'xmldeclaration';
            node-value: '';
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.no-xmldecl.xml...-pi.after.document.element.test
      @@@DEnt:
        @@@@test:value:
          <a></a>
          <?xmldeclaration?>
      @@@test:domTree:
        document {
          element { }
          pi {
            node-name: 'xmldeclaration';
            node-value: '';
          }
        }
    @@XMLTest:
      @@@QName: xp.no-xmldecl.xml...-pi.in.document.element.test
      @@@DEnt:
        @@@@test:value:
          <a>
          <?xmldeclaration?>
          </a>
      @@@test:domTree:
        document {
          element {
            text { }
            pi {
              node-name: 'xmldeclaration';
              node-value: '';
            }
            text { }
          }
        }
    @@XMLTest:
      @@@QName: xp.no-xmldecl.xml...-pi.in.doctype.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
          <?xmldeclaration?>
          ]>
          <a></a>
      @@@test:domTree:
        document {
          document-type {
            pi {
              node-name: 'xmldeclaration';
              node-value: '';
            }
          }
          element { }
        }

    @@XMLTest:
      @@@QName: xp.XMLdecl.test
      @@@DEnt:
        @@@@test:value:
          <?XML version="1.0"?>
          <p></p>
      @@@c:erred:
        <[[xp:wf-pi-target-is-xml]]> { (1, 1)..(1, 5); }
    @@XMLTest:
      @@@QName: xp.Xmldecl.test
      @@@DEnt:
        @@@@test:value:
          <?Xml version="1.0"?>
          <p></p>
      @@@c:erred:
        <[[xp:wf-pi-target-is-xml]]> { (1, 1)..(1, 5); }
    @@XMLTest:
      @@@QName: xp.xmldecl.after.document.element.empty.test
      @@@DEnt:
        @@@@test:value:
          <p></p>
          <?xml?>
      @@@c:erred:
        <[[xp:wf-pi-target-is-xml]]> { (2, 1)..(2, 5); }
    @@XMLTest:
      @@@QName: xp.xmldecl.after.document.element.test
      @@@DEnt:
        @@@@test:value:
          <p></p>
          <?xml version="1.0"?>
      @@@c:erred:
        <[[xp:wf-pi-target-is-xml]]> { (2, 1)..(2, 5); }
    @@XMLTest:
      @@@QName: xp.xmldecl.in.element.empty.test
      @@@DEnt:
        @@@@test:value:
          <p>
          <?xml?>
          </p>
      @@@c:erred:
        <[[xp:wf-pi-target-is-xml]]> { (2, 1)..(2, 5); }
    @@XMLTest:
      @@@QName: xp.xmldecl.in.element.test
      @@@DEnt:
        @@@@test:value:
          <p>
          <?xml version="1.0"?>
          </p>
      @@@c:erred:
        <[[xp:wf-pi-target-is-xml]]> { (2, 1)..(2, 5); }
    @@XMLTest:
      @@@QName: xp.xmldecl.after.comment.test
      @@@DEnt:
        @@@@test:value:
          <!---->
          <?xml version="1.0"?>
          <p></p>
      @@@c:erred:
        <[[xp:wf-pi-target-is-xml]]> { (2, 1)..(2, 5); }
    @@XMLTest:
      @@@QName: xp.xmldecl.after.comment.empty.test
      @@@DEnt:
        @@@@test:value:
          <!---->
          <?xml?>
          <p></p>
      @@@c:erred:
        <[[xp:wf-pi-target-is-xml]]> { (2, 1)..(2, 5); }
    @@XMLTest:
      @@@QName: xp.xmldecl.after.pi.test
      @@@DEnt:
        @@@@test:value:
          <?xml-declaration?>
          <?xml version="1.0"?>
          <p></p>
      @@@c:erred:
        <[[xp:wf-pi-target-is-xml]]> { (2, 1)..(2, 5); }
    @@XMLTest:
      @@@QName: xp.xmldecl.after.pi.empty.test
      @@@DEnt:
        @@@@test:value:
          <?xml-declaration?>
          <?xml?>
          <p></p>
      @@@c:erred:
        <[[xp:wf-pi-target-is-xml]]> { (2, 1)..(2, 5); }
    @@XMLTest:
      @@@QName: xp.xmldecl.after.pi.2.test
      @@@DEnt:
        @@@@test:value:
          <?declaration?>
          <?xml version="1.0"?>
          <p></p>
      @@@c:erred:
        <[[xp:wf-pi-target-is-xml]]> { (2, 1)..(2, 5); }
    @@XMLTest:
      @@@QName: xp.xmldecl.after.pi.empty.2.test
      @@@DEnt:
        @@@@test:value:
          <?declaration?>
          <?xml?>
          <p></p>
      @@@c:erred:
        <[[xp:wf-pi-target-is-xml]]> { (2, 1)..(2, 5); }
    @@XMLTest:
      @@@QName: xp.xmldecl.after.doctype.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a>
          <?xml version="1.0"?>
          <p></p>
      @@@c:erred:
        <[[xp:wf-pi-target-is-xml]]> { (2, 1)..(2, 5); }
    @@XMLTest:
      @@@QName: xp.xmldecl.after.doctype.empty.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a>
          <?xml?>
          <p></p>
      @@@c:erred:
        <[[xp:wf-pi-target-is-xml]]> { (2, 1)..(2, 5); }
    @@XMLTest:
      @@@QName: xp.xmldecl.in.doctype.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
          <?xml version="1.0"?>
          ]>
          <p></p>
      @@@c:erred:
        <[[xp:wf-pi-target-is-xml]]> { (2, 1)..(2, 5); }
    @@XMLTest:
      @@@QName: xp.xmldecl.in.doctype.empty.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
          <?xml?>
          ]>
          <p></p>
      @@@c:erred:
        <[[xp:wf-pi-target-is-xml]]> { (2, 1)..(2, 5); }

    @@XMLTest:
      @@@QName: xp.pi.before.element.empty.test
      @@@DEnt:
        @@@@test:value:
          <?target?>
          <a></a>
      @@@test:domTree:
        document {
          pi {
            node-name: 'target';
            node-value: '';
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.pi.before.element.s.test
      @@@DEnt:
        @@@@test:value:
          <?target  ?>
          <a></a>
      @@@test:domTree:
        document {
          pi {
            node-name: 'target';
            node-value: '';
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.pi.before.element.string.test
      @@@DEnt:
        @@@@test:value:
          <?target string?>
          <a></a>
      @@@test:domTree:
        document {
          pi {
            node-name: 'target';
            node-value: 'string';
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.pi.before.element.string.s.test
      @@@DEnt:
        @@@@test:value:
          <?target string  ?>
          <a></a>
      @@@test:domTree:
        document {
          pi {
            node-name: 'target';
            node-value: 'string  ';
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.pi.before.element.gt.test
      @@@DEnt:
        @@@@test:value:
          <?target string>string?>
          <a></a>
      @@@test:domTree:
        document {
          pi {
            node-name: 'target';
            node-value: 'string>string';
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.pi.doctype.empty.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
          <?target?>
          ]>
          <a></a>
      @@@test:domTree:
        document {
          document-type {
            pi {
              node-name: 'target';
              node-value: '';
            }
          }
          element { }
        }

    @@XMLTest:
      @@@QName: xp.pi.no.target.test
      @@@DEnt:
        @@@@test:value:
          <??>
          <p></p>
      @@@c:erred:
        <[[xp:wf-syntax-error]]> { (1, 3)..(1, 4); }
    @@XMLTest:
      @@@QName: xp.pi.no.target.2.test
      @@@DEnt:
        @@@@test:value:
          <?  ?>
          <p></p>
      @@@c:erred:
        <[[xp:wf-syntax-error]]> { (1, 3)..(1, 4); }
    @@XMLTest:
      @@@QName: xp.pi.bad.target.1.test
      @@@DEnt:
        @@@@test:value:
          <?target!  ?>
          <p></p>
      @@@c:erred:
        <[[xp:wf-syntax-error]]> { (1, 9)..(1, 9); }
    @@XMLTest:
      @@@QName: xp.pi.bad.target.2.test
      @@@DEnt:
        @@@@test:value:
          <?0target  ?>
          <p></p>
      @@@c:erred:
        <[[xp:wf-syntax-error]]> { (1, 3)..(1, 3); }

    @@XMLTest:
      @@@QName: xp.cdatasection.empty.1.test
      @@@DEnt:
        @@@@test:value:
          <p><![CDATA[]]></p>
      @@@test:domTree:
        document {
          element {
            cdata-section {
              data: '';
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.cdatasection.empty.2.test
      @@@DEnt:
        @@@@test:value:
          <p>aa<![CDATA[]]>bb</p>
      @@@test:domTree:
        document {
          element {
            text { data: 'aa'; }
            cdata-section {
              data: '';
            }
            text { data: 'bb'; }
          }
        }
    @@XMLTest:
      @@@QName: xp.cdatasection.1.test
      @@@DEnt:
        @@@@test:value:
          <p><![CDATA[abcdefg]]></p>
      @@@test:domTree:
        document {
          element {
            cdata-section {
              data: 'abcdefg';
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.cdatasection.2.test
      @@@DEnt:
        @@@@test:value:
          <p>aa<![CDATA[abcdefg]]>bb</p>
      @@@test:domTree:
        document {
          element {
            text { data: 'aa'; }
            cdata-section {
              data: 'abcdefg';
            }
            text { data: 'bb'; }
          }
        }
    @@XMLTest:
      @@@QName: xp.cdatasection.ref.1.test
      @@@DEnt:
        @@@@test:value:
          <p><![CDATA[a&amp;&#x32;&#32;%abc;&def;]]&gt;b]]></p>
      @@@test:domTree:
        document {
          element {
            cdata-section {
              data: 'a&amp;&#x32;&#32;%abc;&def;]]&gt;b';
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.cdatasection.in.general.entity.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p [
            <!ENTITY cdata "<![CDATA[text]]>">
          ]>
          <p>&cdata;</p>
      @@@test:domTree:
        document {
          document-type {
            general-entity {
              node-name: 'cdata';
              cdata-section {
                data: 'text';
              }
            }
          }
          element {
            general-entity-reference {
              is-expanded: true;
              cdata-section {
                data: 'text';
              }
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.cdatasection.no.mse.test
      @@@DEnt:
        @@@@test:value:
          <p><![CDATA[text</p>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 21); }
    @@XMLTest:
      @@@QName: xp.cdatasection.nest.test
      @@@DEnt:
        @@@@test:value:
          <p><![CDATA[text01<![CDATA[txt2]]>text3]]></p>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 40)..(1, 42); }

    @@XMLTest:
      @@@QName: xp.doctype.empty.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a>
          <a></a>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          xml-encoding: null;
          xml-standalone: false;
          document-type {
            node-name: 'a';
            public-id: null;
            system-id: null;
          }
          element {
            namespace-uri: null;
            prefix: null;
            local-name: 'a';
            text-content: '';
          }
        }
    @@XMLTest:
      @@@QName: xp.doctype.empty.after.document.element.test
      @@@DEnt:
        @@@@test:value:
          <a></a>
          <!DOCTYPE a>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (2, 1)..(2, 12); }
    @@XMLTest:
      @@@QName: xp.doctype.empty.in.element.test
      @@@DEnt:
        @@@@test:value:
          <a>
          <!DOCTYPE a>
          </a>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (2, 1)..(2, 12); }
    @@XMLTest:
      @@@QName: xp.doctype.empty.dup.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a>
          <!DOCTYPE a>
          <a></a>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (2, 1)..(2, 12); }
    @@XMLTest:
      @@@QName: xp.doctype.empty.in.intsubset.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
          <!DOCTYPE a>
          ]>
          <a></a>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (2, 1)..(2, 12); }
    @@XMLTest:
      @@@QName: xp.doctype.no.s.no.name.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE>
          <a></a>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 10); }
    @@XMLTest:
      @@@QName: xp.doctype.no.name.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE >
          <a></a>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 11); }
    @@XMLTest:
      @@@QName: xp.doctype.name.s.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE aa   >
          <aa></aa>
      @@@test:domTree:
        document {
          document-type {
            node-name: 'aa';
            public-id: null;
            system-id: null;
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.doctype.no.mdc.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE aa
          <aa></aa>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (2, 1); }

    @@XMLTest:
      @@@QName: xp.doctype.intsubset.empty.1.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a []>
          <a></a>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          xml-encoding: null;
          xml-standalone: false;
          document-type {
            node-name: 'a';
            public-id: null;
            system-id: null;
          }
          element {
            namespace-uri: null;
            prefix: null;
            local-name: 'a';
            text-content: '';
          }
        }
    @@XMLTest:
      @@@QName: xp.doctype.intsubset.empty.2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [

          ]>
          <a></a>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          xml-encoding: null;
          xml-standalone: false;
          document-type {
            node-name: 'a';
            public-id: null;
            system-id: null;
          }
          element {
            namespace-uri: null;
            prefix: null;
            local-name: 'a';
            text-content: '';
          }
        }
    @@XMLTest:
      @@@QName: xp.doctype.intsubset.empty.3.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a[]>
          <a></a>
      @@@test:domTree:
        document {
          document-type {
            node-name: 'a';
            public-id: null;
            system-id: null;
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.doctype.intsubset.empty.4.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a[]  >
          <a></a>
      @@@test:domTree:
        document {
          document-type {
            node-name: 'a';
            public-id: null;
            system-id: null;
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.doctype.intsubset.no.dsc.1.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [>
          <a></a>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 14); }
    @@XMLTest:
      @@@QName: xp.doctype.intsubset.no.dsc.2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
          <a></a>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (2, 1); }
    @@XMLTest:
      @@@QName: xp.doctype.intsubset.no.dsc.3.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 14); }
    @@XMLTest:
      @@@QName: xp.doctype.intsubset.no.mdc.1.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a []
          <a/>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (2, 1); }
    @@XMLTest:
      @@@QName: xp.doctype.intsubset.no.mdc.2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a []]>
          <a/>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 15); }
    @@XMLTest:
      @@@QName: xp.doctype.pubid.sysid.1.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a PUBLIC "pubid" "sysid">
          <a/>
      @@@test:domTree:
        document {
          document-type {
            node-name: 'a';
            public-id: 'pubid';
            system-id: 'sysid';
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.doctype.pubid.sysid.2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a PUBLIC 'pubid' "sysid">
          <a/>
      @@@test:domTree:
        document {
          document-type {
            node-name: 'a';
            public-id: 'pubid';
            system-id: 'sysid';
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.doctype.pubid.sysid.3.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a PUBLIC "pubid" 'sysid'>
          <a/>
      @@@test:domTree:
        document {
          document-type {
            node-name: 'a';
            public-id: 'pubid';
            system-id: 'sysid';
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.doctype.pubid.sysid.4.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a PUBLIC 'pubid' 'sysid'>
          <a/>
      @@@test:domTree:
        document {
          document-type {
            node-name: 'a';
            public-id: 'pubid';
            system-id: 'sysid';
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.doctype.pubid.sysid.5.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a PUBLIC "pubid" "sysid"  >
          <a/>
      @@@test:domTree:
        document {
          document-type {
            node-name: 'a';
            public-id: 'pubid';
            system-id: 'sysid';
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.doctype.pubid.sysid.6.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a PUBLIC 'pubid' 'sysid'  >
          <a/>
      @@@test:domTree:
        document {
          document-type {
            node-name: 'a';
            public-id: 'pubid';
            system-id: 'sysid';
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.doctype.pubid.sysid.intsubset.1.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a PUBLIC "pubid" "sysid"[]>
          <a/>
      @@@test:domTree:
        document {
          document-type {
            node-name: 'a';
            public-id: 'pubid';
            system-id: 'sysid';
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.doctype.pubid.sysid.intsubset.2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a PUBLIC "pubid" "sysid"  []>
          <a/>
      @@@test:domTree:
        document {
          document-type {
            node-name: 'a';
            public-id: 'pubid';
            system-id: 'sysid';
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.doctype.pubid.sysid.intsubset.3.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a PUBLIC 'pubid' 'sysid'[]>
          <a/>
      @@@test:domTree:
        document {
          document-type {
            node-name: 'a';
            public-id: 'pubid';
            system-id: 'sysid';
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.doctype.pubid.sysid.intsubset.4.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a PUBLIC 'pubid' 'sysid'  []>
          <a/>
      @@@test:domTree:
        document {
          document-type {
            node-name: 'a';
            public-id: 'pubid';
            system-id: 'sysid';
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.doctype.sysid.1.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a SYSTEM "sysid">
          <a/>
      @@@test:domTree:
        document {
          document-type {
            node-name: 'a';
            public-id: null;
            system-id: 'sysid';
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.doctype.sysid.2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a SYSTEM 'sysid'>
          <a/>
      @@@test:domTree:
        document {
          document-type {
            node-name: 'a';
            public-id: null;
            system-id: 'sysid';
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.doctype.sysid.3.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a SYSTEM "sysid"  >
          <a/>
      @@@test:domTree:
        document {
          document-type {
            node-name: 'a';
            public-id: null;
            system-id: 'sysid';
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.doctype.sysid.4.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a SYSTEM 'sysid'  >
          <a/>
      @@@test:domTree:
        document {
          document-type {
            node-name: 'a';
            public-id: null;
            system-id: 'sysid';
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.doctype.sysid.intsubset.1.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a SYSTEM "sysid"[]>
          <a/>
      @@@test:domTree:
        document {
          document-type {
            node-name: 'a';
            public-id: null;
            system-id: 'sysid';
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.doctype.sysid.intsubset.2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a SYSTEM "sysid"  []>
          <a/>
      @@@test:domTree:
        document {
          document-type {
            node-name: 'a';
            public-id: null;
            system-id: 'sysid';
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.doctype.sysid.intsubset.3.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a SYSTEM 'sysid'[]>
          <a/>
      @@@test:domTree:
        document {
          document-type {
            node-name: 'a';
            public-id: null;
            system-id: 'sysid';
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.doctype.sysid.intsubset.4.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a SYSTEM 'sysid'   []>
          <a/>
      @@@test:domTree:
        document {
          document-type {
            node-name: 'a';
            public-id: null;
            system-id: 'sysid';
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.doctype.public.stago.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a PUBLIC<a/>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 19); }
    @@XMLTest:
      @@@QName: xp.doctype.public.mdc.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a PUBLIC>
          <a/>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 19); }
    @@XMLTest:
      @@@QName: xp.doctype.public.s.stago.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a PUBLIC <a/>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 20); }
    @@XMLTest:
      @@@QName: xp.doctype.public.s.mdc.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a PUBLIC >
          <a/>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 20); }
    @@XMLTest:
      @@@QName: xp.doctype.public.lit.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a PUBLIC"p" "s">
          <a/>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 19); }
    @@XMLTest:
      @@@QName: xp.doctype.public.lita.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a PUBLIC'p' "s">
          <a/>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 19); }
    @@XMLTest:
      @@@QName: xp.doctype.pubid.lit.lita.unmatched.1.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a PUBLIC "p' "s">
          <a/>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 25); }
    @@XMLTest:
      @@@QName: xp.doctype.pubid.lit.lita.unmatched.2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a PUBLIC "p' 's'><a/>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 32); }
    @@XMLTest:
      @@@QName: xp.doctype.pubid.lita.lit.unmatched.1.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a PUBLIC 'p" "s"><a/>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 32); }
    @@XMLTest:
      @@@QName: xp.doctype.pubid.lita.lit.unmatched.2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a PUBLIC 'p" 's'>
          <a/>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 21)..(1, 25); }
    @@XMLTest:
      @@@QName: xp.doctype.public.s.lit.mdc.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a PUBLIC "><a/>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 26); }
    @@XMLTest:
      @@@QName: xp.doctype.public.s.lita.mdc.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a PUBLIC '><a/>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 26); }
    @@XMLTest:
      @@@QName: xp.doctype.public.lit.pubid.lit.mdc.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a PUBLIC "p">
          <a/>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 23); }
    @@XMLTest:
      @@@QName: xp.doctype.public.lita.pubid.lita.mdc.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a PUBLIC 'p'>
          <a/>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 23); }
    @@XMLTest:
      @@@QName: xp.doctype.public.lit.pubid.lit.s.mdc.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a PUBLIC "p" >
          <a/>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 24); }
    @@XMLTest:
      @@@QName: xp.doctype.public.lita.pubid.lita.s.mdc.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a PUBLIC 'p' >
          <a/>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 24); }
    @@XMLTest:
      @@@QName: xp.doctype.public.lit.pubid.lit.s.lit.mdc.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a PUBLIC "p" "><a/>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 30); }
    @@XMLTest:
      @@@QName: xp.doctype.public.lit.pubid.lit.s.lita.mdc.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a PUBLIC "p" '><a/>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 30); }
    @@XMLTest:
      @@@QName: xp.doctype.public.lita.pubid.lita.s.lit.mdc.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a PUBLIC 'p' "><a/>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 30); }
    @@XMLTest:
      @@@QName: xp.doctype.public.lita.pubid.lita.s.lita.mdc.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a PUBLIC 'p' '><a/>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 30); }
    @@XMLTest:
      @@@QName: xp.doctype.public.lit.pubid.lit.lit.lita.unmatched.mdc.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a PUBLIC "p" "s'><a/>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 32); }
    @@XMLTest:
      @@@QName: xp.doctype.public.lita.pubid.lita.lita.lit.unmatched.mdc.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a PUBLIC 'p' 's"><a/>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 32); }
    @@XMLTest:
      @@@QName: xp.doctype.pubid.sysid.stago.1.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a PUBLIC "p" "s"<a/>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 27); }
    @@XMLTest:
      @@@QName: xp.doctype.pubid.sysid.stago.2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a PUBLIC "p" 's'<a/>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 27); }
    @@XMLTest:
      @@@QName: xp.doctype.pubid.sysid.stago.s.1.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a PUBLIC "p" "s" <a/>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 28); }
    @@XMLTest:
      @@@QName: xp.doctype.pubid.sysid.stago.s.2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a PUBLIC "p" 's' <a/>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 28); }

    @@XMLTest:
      @@@QName: xp.endofline.1.0.crlf.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0"?>
          <p>aaa$u000D$u000Abbb</p>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          element {
            text-content: 'aaa' U+000A 'bbb';
          }
        }
    @@XMLTest:
      @@@QName: xp.endofline.1.1.crlf.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.1"?>
          <p>aaa$u000D$u000Abbb</p>
      @@@test:domTree:
        document {
          xml-version: '1.1';
          element {
            text-content: 'aaa' U+000A 'bbb';
          }
        }
    @@XMLTest:
      @@@QName: xp.endofline.1.0.crnl.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0"?>
          <p>aaa$u000D$u0085bbb</p>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          element {
            text-content: 'aaa' U+000A U+0085 'bbb';
          }
        }
    @@XMLTest:
      @@@QName: xp.endofline.1.1.crnl.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.1"?>
          <p>aaa$u000D$u0085bbb</p>
      @@@test:domTree:
        document {
          xml-version: '1.1';
          element {
            text-content: 'aaa' U+000A 'bbb';
          }
        }
    @@XMLTest:
      @@@QName: xp.endofline.1.0.nl.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0"?>
          <p>aaa$u0085bbb</p>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          element {
            text-content: 'aaa' U+0085 'bbb';
          }
        }
    @@XMLTest:
      @@@QName: xp.endofline.1.1.nl.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.1"?>
          <p>aaa$u0085bbb</p>
      @@@test:domTree:
        document {
          xml-version: '1.1';
          element {
            text-content: 'aaa' U+000A 'bbb';
          }
        }
    @@XMLTest:
      @@@QName: xp.endofline.1.0.ls.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0"?>
          <p>aaa$u2028bbb</p>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          element {
            text-content: 'aaa' U+2028 'bbb';
          }
        }
    @@XMLTest:
      @@@QName: xp.endofline.1.1.ls.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.1"?>
          <p>aaa$u2028bbb</p>
      @@@test:domTree:
        document {
          xml-version: '1.1';
          element {
            text-content: 'aaa' U+000A 'bbb';
          }
        }
    @@XMLTest:
      @@@QName: xp.endofline.1.0.cr.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0"?>
          <p>aaa$u000Dbbb</p>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          element {
            text-content: 'aaa' U+000A 'bbb';
          }
        }
    @@XMLTest:
      @@@QName: xp.endofline.1.1.cr.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.1"?>
          <p>aaa$u000Dbbb</p>
      @@@test:domTree:
        document {
          xml-version: '1.1';
          element {
            text-content: 'aaa' U+000A 'bbb';
          }
        }
    @@XMLTest:
      @@@QName: xp.endofline.1.0.lf.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0"?>
          <p>aaa$u000Abbb</p>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          element {
            text-content: 'aaa' U+000A 'bbb';
          }
        }
    @@XMLTest:
      @@@QName: xp.endofline.1.1.lf.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.1"?>
          <p>aaa$u000Abbb</p>
      @@@test:domTree:
        document {
          xml-version: '1.1';
          element {
            text-content: 'aaa' U+000A 'bbb';
          }
        }
    @@XMLTest:
      @@@QName: xp.xml10.endofline.nl.in.xmldecl.1.test
      @@@DEnt:
        @@@@test:value:
          <?xml$u0085version="1.0"?>
          <p/>
      @@@c:erred:
        <[[xp|fatal-xml11-end-of-line-in-xml-declaration]]> { (1, 6)..(2, 0); }
      @@@c:erred: <[[xp|wf-syntax-error]]> { }
    @@XMLTest:
      @@@QName: xp.xml11.endofline.nl.in.xmldecl.1.test
      @@@DEnt:
        @@@@test:value:
          <?xml$u0085version="1.1"?>
          (err)<p/>
      @@@c:erred:
        <[[xp|fatal-xml11-end-of-line-in-xml-declaration]]> { (1, 6)..(2, 0); }
      @@@c:erred: <[[xp|wf-syntax-error]]> { }
    @@XMLTest:
      @@@QName: xp.xml10.endofline.crnl.in.xmldecl.1.test
      @@@DEnt:
        @@@@test:value:
          <?xml$u000D$u0085version="1.0"?>
          <p/>
      @@@c:erred:
        <[[xp|fatal-xml11-end-of-line-in-xml-declaration]]> { (1, 6)..(2, 0); }
      @@@c:erred: <[[xp|wf-syntax-error]]> { }
    @@XMLTest:
      @@@QName: xp.xml11.endofline.crnl.in.xmldecl.1.test
      @@@DEnt:
        @@@@test:value:
          <?xml$u000D$u0085version="1.1"?>
          (err)<p/>
      @@@c:erred:
        <[[xp|fatal-xml11-end-of-line-in-xml-declaration]]> { (1, 6)..(2, 0); }
      @@@c:erred: <[[xp|wf-syntax-error]]> { }
    @@XMLTest:
      @@@QName: xp.xml10.endofline.ls.in.xmldecl.1.test
      @@@DEnt:
        @@@@test:value:
          <?xml$u2028version="1.0"?>
          <p/>
      @@@c:erred:
        <[[xp|fatal-xml11-end-of-line-in-xml-declaration]]> { (1, 6)..(2, 0); }
      @@@c:erred: <[[xp|wf-syntax-error]]> { }
    @@XMLTest:
      @@@QName: xp.xml11.endofline.ls.in.xmldecl.1.test
      @@@DEnt:
        @@@@test:value:
          <?xml$u2028version="1.1"?>
          (err)<p/>
      @@@c:erred:
        <[[xp|fatal-xml11-end-of-line-in-xml-declaration]]> { (1, 6)..(2, 0); }
      @@@c:erred: <[[xp|wf-syntax-error]]> { }
    @@XMLTest:
      @@@QName: xp.xml10.endofline.nl.in.xmldecl.2.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0"$u0085?>
          <p/>
      @@@c:erred:
        <[[xp|fatal-xml11-end-of-line-in-xml-declaration]]> { (1, 20)..(2, 0); }
      @@@c:erred: <[[xp|wf-syntax-error]]> { }
    @@XMLTest:
      @@@QName: xp.xml11.endofline.nl.in.xmldecl.2.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.1"$u0085?>
          (err)<p/>
      @@@c:erred:
        <[[xp|fatal-xml11-end-of-line-in-xml-declaration]]> { (1, 20)..(2, 0); }
      @@@c:erred: <[[xp|wf-syntax-error]]> { }
    @@XMLTest:
      @@@QName: xp.xml10.endofline.crnl.in.xmldecl.2.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0"$u000D$u0085?>
          <p/>
      @@@c:erred:
        <[[xp|fatal-xml11-end-of-line-in-xml-declaration]]> { (1, 20)..(2, 0); }
      @@@c:erred: <[[xp|wf-syntax-error]]> { }
    @@XMLTest:
      @@@QName: xp.xml11.endofline.crnl.in.xmldecl.2.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.1"$u000D$u0085?>
          (err)<p/>
      @@@c:erred:
        <[[xp|fatal-xml11-end-of-line-in-xml-declaration]]> { (1, 20)..(2, 0); }
      @@@c:erred: <[[xp|wf-syntax-error]]> { }
    @@XMLTest:
      @@@QName: xp.xml10.endofline.ls.in.xmldecl.2.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0"$u2028?>
          <p/>
      @@@c:erred:
        <[[xp|fatal-xml11-end-of-line-in-xml-declaration]]> { (1, 20)..(2, 0); }
      @@@c:erred: <[[xp|wf-syntax-error]]> { }
    @@XMLTest:
      @@@QName: xp.xml11.endofline.ls.in.xmldecl.2.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.1"$u2028?>
          (err)<p/>
      @@@c:erred:
        <[[xp|fatal-xml11-end-of-line-in-xml-declaration]]> { (1, 20)..(2, 0); }
      @@@c:erred: <[[xp|wf-syntax-error]]> { }
    @@XMLTest:
      @@@QName: xp.xml10.endofline.nl.in.xmldecl.3.test
      @@@DEnt:
        @@@@test:value:
          <?xml $u0085version="1.0"?>
          <p/>
      @@@c:erred:
        <[[xp|fatal-xml11-end-of-line-in-xml-declaration]]> { (1, 7)..(2, 0); }
      @@@c:erred: <[[xp|wf-syntax-error]]> { }
    @@XMLTest:
      @@@QName: xp.xml11.endofline.nl.in.xmldecl.3.test
      @@@DEnt:
        @@@@test:value:
          <?xml $u0085version="1.1"?>
          (err)<p/>
      @@@c:erred:
        <[[xp|fatal-xml11-end-of-line-in-xml-declaration]]> { (1, 7)..(2, 0); }
      @@@c:erred: <[[xp|wf-syntax-error]]> { }
    @@XMLTest:
      @@@QName: xp.xml10.endofline.crnl.in.xmldecl.3.test
      @@@DEnt:
        @@@@test:value:
          <?xml $u000D$u0085version="1.0"?>
          <p/>
      @@@c:erred:
        <[[xp|fatal-xml11-end-of-line-in-xml-declaration]]> { (1, 7)..(2, 0); }
      @@@c:erred: <[[xp|wf-syntax-error]]> { }
    @@XMLTest:
      @@@QName: xp.xml11.endofline.crnl.in.xmldecl.3.test
      @@@DEnt:
        @@@@test:value:
          <?xml $u000D$u0085version="1.1"?>
          (err)<p/>
      @@@c:erred:
        <[[xp|fatal-xml11-end-of-line-in-xml-declaration]]> { (1, 7)..(2, 0); }
      @@@c:erred: <[[xp|wf-syntax-error]]> { }
    @@XMLTest:
      @@@QName: xp.xml10.endofline.ls.in.xmldecl.3.test
      @@@DEnt:
        @@@@test:value:
          <?xml $u2028version="1.0"?>
          <p/>
      @@@c:erred:
        <[[xp|fatal-xml11-end-of-line-in-xml-declaration]]> { (1, 7)..(2, 0); }
      @@@c:erred: <[[xp|wf-syntax-error]]> { }
    @@XMLTest:
      @@@QName: xp.xml11.endofline.ls.in.xmldecl.3.test
      @@@DEnt:
        @@@@test:value:
          <?xml $u2028version="1.1"?>
          (err)<p/>
      @@@c:erred:
        <[[xp|fatal-xml11-end-of-line-in-xml-declaration]]> { (1, 7)..(2, 0); }
      @@@c:erred: <[[xp|wf-syntax-error]]> { }
    @@XMLTest:
      @@@QName: xp.xml10implied.endofline.nl.in.pi.1.test
      @@@DEnt:
        @@@@test:value:
          <?xml-$u0085?>
          <p/>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 7)..(2, 0); }
    @@XMLTest:
      @@@QName: xp.xml10.endofline.nl.in.pi.1.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0"?>
          <?xml-$u0085?>
          <p/>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (2, 7)..(3, 0); }
    @@XMLTest:
      @@@QName: xp.xml11.endofline.nl.in.pi.1.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.1"?>
          <?xml-$u0085?>
          <p/>
      @@@test:domTree:
        document {
          xml-version: '1.1';
          pi {
            node-name: 'xml-';
            node-value: '';
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.xml10implied.endofline.crnl.in.pi.1.test
      @@@DEnt:
        @@@@test:value:
          <?xml-$u000D$u0085?>
          <p/>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          pi {
            node-name: 'xml-';
            node-value: U+0085;
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.xml10.endofline.crnl.in.pi.1.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0"?>
          <?xml-$u000D$u0085?>
          <p/>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          pi {
            node-name: 'xml-';
            node-value: U+0085;
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.xml11.endofline.crnl.in.pi.1.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.1"?>
          <?xml-$u000D$u0085?>
          <p/>
      @@@test:domTree:
        document {
          xml-version: '1.1';
          pi {
            node-name: 'xml-';
            node-value: '';
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.xml10implied.endofline.ls.in.pi.1.test
      @@@DEnt:
        @@@@test:value:
          <?xml-$u2028?>
          <p/>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 7)..(2, 0); }
    @@XMLTest:
      @@@QName: xp.xml10.endofline.ls.in.pi.1.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0"?>
          <?xml-$u2028?>
          <p/>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (2, 7)..(3, 0); }
    @@XMLTest:
      @@@QName: xp.xml11.endofline.ls.in.pi.1.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.1"?>
          <?xml-$u2028?>
          <p/>
      @@@test:domTree:
        document {
          xml-version: '1.1';
          pi {
            node-name: 'xml-';
            node-value: '';
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.noxmldecl.pi.pi.test
      @@@DEnt:
        @@@@test:value:
          <?noxml 1?><?noxml 2?><p/>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          pi {
            node-name: 'noxml';
            node-value: '1';
          }
          pi {
            node-name: 'noxml';
            node-value: '2';
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.noxmldecl.pi.pi.2.test
      @@@DEnt:
        @@@@test:value:
          <?xmlno 1?><?xmlno 2?><p/>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          pi {
            node-name: 'xmlno';
            node-value: '1';
          }
          pi {
            node-name: 'xmlno';
            node-value: '2';
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.noxmldecl.pi.pi.3.test
      @@@DEnt:
        @@@@test:value:
          <?xmln 1?><?xmln 2?><p/>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          pi {
            node-name: 'xmln';
            node-value: '1';
          }
          pi {
            node-name: 'xmln';
            node-value: '2';
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.noxml.s.nl.test
      @@@DEnt:
        @@@@test:value:
          $u0085<p/>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 1)..(2, 0); }
    @@XMLTest:
      @@@QName: xp.noxml.s.crnl.test
      @@@DEnt:
        @@@@test:value:
          $u000D$u0085<p/>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 1)..(2, 0); }
    @@XMLTest:
      @@@QName: xp.noxml.s.ls.test
      @@@DEnt:
        @@@@test:value:
          $u2028<p/>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 1)..(2, 0); }
    @@XMLTest:
      @@@QName: xp.xml10.decl.s.nl.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0"?>$u0085<p/>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 22)..(2, 0); }
    @@XMLTest:
      @@@QName: xp.xml10.decl.s.crnl.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0"?>$u000D$u0085<p/>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (2, 0)..(3, 0); }
    @@XMLTest:
      @@@QName: xp.xml10.decl.s.ls.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0"?>$u2028<p/>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 22)..(2, 0); }
    @@XMLTest:
      @@@QName: xp.xml11.decl.s.nl.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.1"?>$u0085<p/>
      @@@test:domTree:
        document {
          xml-version: '1.1';
          element { }
        }
    @@XMLTest:
      @@@QName: xp.xml11.decl.s.crnl.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.1"?>$u000D$u0085<p/>
      @@@test:domTree:
        document {
          xml-version: '1.1';
          element { }
        }
    @@XMLTest:
      @@@QName: xp.xml11.decl.s.ls.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.1"?>$u2028<p/>
      @@@test:domTree:
        document {
          xml-version: '1.1';
          element { }
        }

    @@XMLTest:
      @@@QName: xp.element.type.match.1.test
      @@@DEnt:
        @@@@test:value:
          <p></pa>(err)
      @@@c:erred: <[[xp|wf-element-type-match]]> { (1, 4)..(1, 8); }
      @@@c:erred: <[[xp|wf-syntax-error]]> { }
    @@XMLTest:
      @@@QName: xp.element.type.match.2.test
      @@@DEnt:
        @@@@test:value:
          <p><pa></pa></pa>(err)
      @@@c:erred: <[[xp|wf-element-type-match]]> { (1, 13)..(1, 17); }
      @@@c:erred: <[[xp|wf-syntax-error]]> { }
    @@XMLTest:
      @@@QName: xp.element.type.match.3.test
      @@@DEnt:
        @@@@test:value:
          <p><pa></p></p>(err)
      @@@c:erred: <[[xp|wf-element-type-match]]> { (1, 8)..(1, 11); }
      @@@c:erred: <[[xp|wf-syntax-error]]> { }
    @@XMLTest:
      @@@QName: xp.element.type.match.4.test
      @@@DEnt:
        @@@@test:value:
          <a:p xmlns:a="about:1"></p>(err)
      @@@c:erred: <[[xp|wf-element-type-match]]> { (1, 24)..(1, 27); }
      @@@c:erred: <[[xp|wf-syntax-error]]> { }
    @@XMLTest:
      @@@QName: xp.element.type.match.5.test
      @@@DEnt:
        @@@@test:value:
          <a:p xmlns:a="about:1" xmlns:b="about:1"></b:p>(err)
      @@@c:erred: <[[xp|wf-element-type-match]]> { (1, 42)..(1, 47); }
      @@@c:erred: <[[xp|wf-syntax-error]]> { }

    @@XMLTest:
      @@@QName: xp.stag.stago.name.etago.test
      @@@DEnt:
        @@@@test:value:
          <a</a>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 3); }
    @@XMLTest:
      @@@QName: xp.stag.stago.name.s.etago.test
      @@@DEnt:
        @@@@test:value:
          <a </a>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 4); }
    @@XMLTest:
      @@@QName: xp.stag.stago.name.s.attr.etago.test
      @@@DEnt:
        @@@@test:value:
          <a a="b"</a>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 9); }
    @@XMLTest:
      @@@QName: xp.stag.stago.name.s.attr.s.attr.etago.test
      @@@DEnt:
        @@@@test:value:
          <a a="b" c="d"</a>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 15); }
    @@XMLTest:
      @@@QName: xp.stag.stago.name.s.attr.s.etago.test
      @@@DEnt:
        @@@@test:value:
          <a a="b" </a>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 10); }
    @@XMLTest:
      @@@QName: xp.stag.etag.1.test
      @@@DEnt:
        @@@@test:value:
          <root><a></a></root>
      @@@test:domTree:
        document {
          element {
            element {
              node-name: 'a';
            }
          }
        }	
    @@XMLTest:
      @@@QName: xp.stag.etag.2.test
      @@@DEnt:
        @@@@test:value:
          <root><ab></ab></root>
      @@@test:domTree:
        document {
          element {
            element {
              node-name: 'ab';
            }
          }
        }	
    @@XMLTest:
      @@@QName: xp.stag.etag.s.1.test
      @@@DEnt:
        @@@@test:value:
          <root><a  ></a  ></root>
      @@@test:domTree:
        document {
          element {
            element {
              node-name: 'a';
            }
          }
        }	
    @@XMLTest:
      @@@QName: xp.etag.1.test
      @@@DEnt:
        @@@@test:value:
          <root><a/></root>
      @@@test:domTree:
        document {
          element {
            element {
              node-name: 'a';
            }
          }
        }	
    @@XMLTest:
      @@@QName: xp.etag.2.test
      @@@DEnt:
        @@@@test:value:
          <root><a    /></root>
      @@@test:domTree:
        document {
          element {
            element {
              node-name: 'a';
            }
          }
        }	
    @@XMLTest:
      @@@QName: xp.stag.etag.attr.1.test
      @@@DEnt:
        @@@@test:value:
          <root><a at="v"></a></root>
      @@@test:domTree:
        document {
          element {
            element {
              node-name: 'a';
              attribute {
                node-name: 'at';
                value: 'v';
              }
            }
          }
        }	
    @@XMLTest:
      @@@QName: xp.stag.etag.attr.2.test
      @@@DEnt:
        @@@@test:value:
          <root><a at="v"  ></a></root>
      @@@test:domTree:
        document {
          element {
            element {
              node-name: 'a';
              attribute {
                node-name: 'at';
                value: 'v';
              }
            }
          }
        }	
    @@XMLTest:
      @@@QName: xp.stag.etag.attr.3.test
      @@@DEnt:
        @@@@test:value:
          <root><a at     ="v"></a></root>
      @@@test:domTree:
        document {
          element {
            element {
              node-name: 'a';
              attribute {
                node-name: 'at';
                value: 'v';
              }
            }
          }
        }	
    @@XMLTest:
      @@@QName: xp.stag.etag.attr.4.test
      @@@DEnt:
        @@@@test:value:
          <root><a at=   "v"></a></root>
      @@@test:domTree:
        document {
          element {
            element {
              node-name: 'a';
              attribute {
                node-name: 'at';
                value: 'v';
              }
            }
          }
        }	
    @@XMLTest:
      @@@QName: xp.stag.etag.attr.5.test
      @@@DEnt:
        @@@@test:value:
          <root><a at='v'></a></root>
      @@@test:domTree:
        document {
          element {
            element {
              node-name: 'a';
              attribute {
                node-name: 'at';
                value: 'v';
              }
            }
          }
        }	
    @@XMLTest:
      @@@QName: xp.stag.etag.attr.6.test
      @@@DEnt:
        @@@@test:value:
          <root><a at=   'v'  ></a></root>
      @@@test:domTree:
        document {
          element {
            element {
              node-name: 'a';
              attribute {
                node-name: 'at';
                value: 'v';
              }
            }
          }
        }	
    @@XMLTest:
      @@@QName: xp.stag.etag.attr.attr.1.test
      @@@DEnt:
        @@@@test:value:
          <root><a at="v"  tr="w"></a></root>
      @@@test:domTree:
        document {
          element {
            element {
              node-name: 'a';
              attribute {
                node-name: 'at';
                value: 'v';
              }
              attribute {
                node-name: 'tr';
                value: 'w';
              }
            }
          }
        }	
    @@XMLTest:
      @@@QName: xp.stag.etag.attr.attr.2.test
      @@@DEnt:
        @@@@test:value:
          <root><a tr="w" at="v"></a></root>
      @@@test:domTree:
        document {
          element {
            element {
              node-name: 'a';
              attribute {
                node-name: 'at';
                value: 'v';
              }
              attribute {
                node-name: 'tr';
                value: 'w';
              }
            }
          }
        }	
    @@XMLTest:
      @@@QName: xp.stag.etag.attr.no.s.attr.test
      @@@DEnt:
        @@@@test:value:
          <root><a at="v"tr="w"></a></root>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 16)..(1, 17); }
    @@XMLTest:
      @@@QName: xp.etag.attr.1.test
      @@@DEnt:
        @@@@test:value:
          <root><a at="v" tr="w"></a b="c"></root>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 28); }
    @@XMLTest:
      @@@QName: xp.etag.no.etagc.1.test
      @@@DEnt:
        @@@@test:value:
          <root><a at="v" tr="w"></a</root>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 27)..(1, 28); }
    @@XMLTest:
      @@@QName: xp.etag.no.etagc.2.test
      @@@DEnt:
        @@@@test:value:
          <root><a at="v" tr="w"></a  </root>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 29)..(1, 30); }
    @@XMLTest:
      @@@QName: xp.mtag.attr.1.test
      @@@DEnt:
        @@@@test:value:
          <root><a  b="c"/></root>
      @@@test:domTree:
        document {
          element {
            element {
              node-name: 'a';
              attribute {
                node-name: 'b';
                value: 'c';
              }
            }
          }
        }	
    @@XMLTest:
      @@@QName: xp.mtag.attr.2.test
      @@@DEnt:
        @@@@test:value:
          <root><a  b="c"  /></root>
      @@@test:domTree:
        document {
          element {
            element {
              node-name: 'a';
              attribute {
                node-name: 'b';
                value: 'c';
              }
            }
          }
        }	
    @@XMLTest:
      @@@QName: xp.mtag.attr.3.test
      @@@DEnt:
        @@@@test:value:
          <root><a  b='c'/></root>
      @@@test:domTree:
        document {
          element {
            element {
              node-name: 'a';
              attribute {
                node-name: 'b';
                value: 'c';
              }
            }
          }
        }	
    @@XMLTest:
      @@@QName: xp.mtag.attr.4.test
      @@@DEnt:
        @@@@test:value:
          <root><a  b="c" d="e"/></root>
      @@@test:domTree:
        document {
          element {
            element {
              node-name: 'a';
              attribute {
                node-name: 'b';
                value: 'c';
              }
              attribute {
                node-name: 'd';
                value: 'e';
              }
            }
          }
        }	

    @@XMLTest:
      @@@QName: xp.attvalue.lt.1.test
      @@@DEnt:
        @@@@test:value:
          <a b="aa<dd"/>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 9); }
    @@XMLTest:
      @@@QName: xp.attvalue.lt.2.test
      @@@DEnt:
        @@@@test:value:
          <a b='aa<dd'/>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 9); }
    @@XMLTest:
      @@@QName: xp.attvalue.amp.1.test
      @@@DEnt:
        @@@@test:value:
          <a b="aa& dd"/>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 9)..(1, 12); }
    @@XMLTest:
      @@@QName: xp.attvalue.amp.2.test
      @@@DEnt:
        @@@@test:value:
          <a b='aa& dd'/>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 9)..(1, 12); }
    @@XMLTest:
      @@@QName: xp.attvalue.amp.3.test
      @@@DEnt:
        @@@@test:value:
          <a b="aa&# dd"/>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 9)..(1, 13); }
    @@XMLTest:
      @@@QName: xp.attvalue.amp.4.test
      @@@DEnt:
        @@@@test:value:
          <a b="aa&#x dd"/>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 9)..(1, 14); }

    @@XMLTest:
      @@@QName: xp.unique.att.spec.1.test
      @@@DEnt:
        @@@@test:value:
          <a b="c" b="d"/>
      @@@c:erred: <[[xp|wf-unique-att-spec]]> { (1, 4)..(1, 14); }
    @@XMLTest:
      @@@QName: xp.unique.att.spec.2.test
      @@@DEnt:
        @@@@test:value:
          <a d:b="c" d:b="d" xmlns:d="about:2"/>
      @@@c:erred: <[[xp|wf-unique-att-spec]]> { (1, 4)..(1, 18); }

    @@XMLTest:
      @@@QName: xp.no.external.entity.references.1.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
            <!ENTITY ent SYSTEM "something">
          ]>
          <a b="c&ent;"/>
      @@@c:erred: <[[xp|wf-no-external-entity-references]]> { (4, 8)..(4, 12); }
    @@XMLTest:
      @@@QName: xp.no.external.entity.references.2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
            <!NOTATION n SYSTEM "notation">
            <!ENTITY ent SYSTEM "something" NDATA n>
          ]>
          <a b="c&ent;"/>
      @@@c:erred: <[[xp|wf-no-external-entity-references]]> { (5, 8)..(5, 12); }
    @@XMLTest:
      @@@QName: xp.no.external.entity.references.3.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
            <!ENTITY ent SYSTEM "something">
            <!ENTITY ent2 "ddd&ent;">
          ]>
          <a b="c&ent2;"/>
      @@@c:erred: <[[xp|wf-no-external-entity-references]]> { (1, 4)..(1, 8); }
    @@XMLTest:
      @@@QName: xp.no.external.entity.references.4.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
            <!NOTATION n SYSTEM "notation">
            <!ENTITY ent SYSTEM "something" NDATA n>
            <!ENTITY ent2 "ddd&ent;">
          ]>
          <a b="c&ent2;"/>
      @@@c:erred: <[[xp|wf-no-external-entity-references]]> { (1, 4)..(1, 8); }
    @@XMLTest:
      @@@QName: xp.no.lt.in.attr.value.1.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
          <!ENTITY ent "aa<bb">
          ]>
          <a b="c&ent;"/>
      @@@c:erred: <[[xp|wf-no-lt-in-attribute-values]]> { (1, 3); }
      @@@c:erred:
        @@@@@: <[[xp|wf-syntax-error]]> { (1, 3)..(1, 6); }
        @@@@enImplNote: When entity node is created.
    @@XMLTest:
      @@@QName: xp.no.lt.in.attr.value.2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
          <!ENTITY ent "aa<bb">
          <!ENTITY ent2 "ccc&ent;">
          ]>
          <a b="c&ent2;"/>
      @@@c:erred: <[[xp|wf-no-lt-in-attribute-values]]> { (1, 3); }
      @@@c:erred:
        @@@@@: <[[xp|wf-syntax-error]]> { (1, 3)..(1, 6); }
        @@@@enImplNote: When entity node is created.
    @@XMLTest:
      @@@QName: xp.no.lt.in.attr.value.3.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
          <!ENTITY ent "aa&#x3C;bb">
          ]>
          <a b="c&ent;"/>
      @@@c:erred: <[[xp|wf-no-lt-in-attribute-values]]> { (1, 3); }
      @@@c:erred:
        @@@@@: <[[xp|wf-syntax-error]]> { (1, 3)..(1, 6); }
        @@@@enImplNote: When entity node is created.
    @@XMLTest:
      @@@QName: xp.no.lt.in.attr.value.4.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
          <!ENTITY ent "aa&#x3C;bb">
          <!ENTITY ent2 "ccc&ent;">
          ]>
          <a b="c&ent2;"/>
      @@@c:erred: <[[xp|wf-no-lt-in-attribute-values]]> { (1, 3); }
      @@@c:erred:
        @@@@@: <[[xp|wf-syntax-error]]> { (1, 3)..(1, 6); }
        @@@@enImplNote: When entity node is created.
    @@XMLTest:
      @@@QName: xp.ger.lt.in.attr.value.1.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
          <!ENTITY ent "aa&lt;bb">
          ]>
          <a b="c&ent;"/>
      @@@test:domTree:
        document {
          document-type {
            general-entity {
              node-name: 'ent';
              text-content: 'aa<bb';
            }
          }
          element {
            attribute {
              node-name: 'b';
              text { data: 'c'; }
              general-entity-reference {
                is-expanded: true;
                node-name: 'ent';
                text-content: 'aa<bb';
              }
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.ger.lt.in.attr.value.2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
          <!ENTITY ent "aa&lt;bb">
          <!ENTITY ent2 "ccc&ent;">
          ]>
          <a b="c&ent2;"/>
      @@@test:domTree:
        document {
          document-type {
            general-entity {
              node-name: 'ent';
              text-content: 'aa<bb';
            }
            general-entity {
              node-name: 'ent2';
              text { data: 'ccc'; }
              general-entity-reference {
                node-name: 'ent';
                text-content: 'aa<bb';
                is-expanded: true;
              }
            }
          }
          element {
            attribute {
              node-name: 'b';
              text { data: 'c'; }
              general-entity-reference {
                node-name: 'ent2';
                text { data: 'ccc'; }
                general-entity-reference {
                  node-name: 'ent';
                  text-content: 'aa<bb';
                  is-expanded: true;
                }
                is-expanded: true;
              }
            }
          }
        }

    @@XMLTest:
      @@@QName: xp.doctype.intsubset.pi.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
            <?pi  data ?>
          ]>
          <a></a>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          xml-encoding: null;
          xml-standalone: false;
          document-type {
            node-name: 'a';
            pi {
              target: 'pi';
              data: 'data ';
            }
          }
          element {
            namespace-uri: null;
            prefix: null;
            local-name: 'a';
            text-content: '';
          }
        }
      @@@enImplNote:
        A DOM PI node in doctype node is a manakai extension.


    @@XMLTest:
      @@@QName: xp.doctype.intsubset.entity.general.internal.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
            <!ENTITY entity "entity value">
          ]>
          <a></a>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          xml-encoding: null;
          xml-standalone: false;
          document-type {
            node-name: 'a';
            general-entity {
              node-name: 'entity';
              text-content: 'entity value';
              has-replacement-tree: true;
            }
          }
          element {
            namespace-uri: null;
            prefix: null;
            local-name: 'a';
            text-content: '';
          }
        }
    @@XMLTest:
      @@@QName: xp.doctype.intsubset.entity.parameter.internal.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
            <!ENTITY % entity "entity value">
          ]>
          <a></a>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          xml-encoding: null;
          xml-standalone: false;
          document-type {
            node-name: 'a';
          }
          element {
            namespace-uri: null;
            prefix: null;
            local-name: 'a';
            text-content: '';
          }
        }

    @@XMLTest:
      @@@QName: xp.doctype.internal.entity.root.element.text.only.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
            <!ENTITY entity "entity value">
          ]>
          <a>&entity;</a>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          xml-encoding: null;
          xml-standalone: false;
          document-type {
            node-name: 'a';
            general-entity {
              node-name: 'entity';
              text-content: 'entity value';
              has-replacement-tree: true;
            }
          }
          element {
            namespace-uri: null;
            prefix: null;
            local-name: 'a';
            general-entity-reference {
              node-name: 'entity';
              text {
                data: 'entity value';
              }
              is-expanded: true;
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.doctype.internal.entity.root.element.text.mult.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
            <!ENTITY entity "entity value">
          ]>
          <a>&entity; and &entity;</a>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          xml-encoding: null;
          xml-standalone: false;
          document-type {
            node-name: 'a';
            general-entity {
              node-name: 'entity';
              text-content: 'entity value';
              has-replacement-tree: true;
            }
          }
          element {
            namespace-uri: null;
            prefix: null;
            local-name: 'a';
            general-entity-reference {
              node-name: 'entity';
              text {
                data: 'entity value';
              }
              is-expanded: true;
            }
            text { data: ' and '; }
            general-entity-reference {
              node-name: 'entity';
              text {
                data: 'entity value';
              }
              is-expanded: true;
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.doctype.internal.entity.root.element.text.element.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
            <!ENTITY entity "entity <p>value</p> with <e>element</e> ">
          ]>
          <a>&entity;</a>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          xml-encoding: null;
          xml-standalone: false;
          document-type {
            node-name: 'a';
            general-entity {
              node-name: 'entity';
              has-replacement-tree: true;
              text { data: 'entity '; }
              element {
                node-name: 'p';
                text-content: 'value';
              }
              text { data: ' with '; }
              element {
                node-name: 'e';
                text-content: 'element';
              }
              text { data: ' '; }
            }
          }
          element {
            namespace-uri: null;
            prefix: null;
            local-name: 'a';
            general-entity-reference {
              node-name: 'entity';
              is-expanded: true;
              text {
                data: 'entity ';
              }
              element {
                namespace-uri: null;
                prefix: null;
                local-name: 'p';
                text {
                  data: 'value';
                }
              }
              text {
                data: ' with ';
              }
              element {
                namespace-uri: null;
                prefix: null;
                local-name: 'e';
                text {
                  data: 'element';
                }
              }
              text {
                data: ' ';
              }
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.doctype.internal.entity.root.element.text.in.ent.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
            <!ENTITY entity1 "entity value">
            <!ENTITY entity2 "e&entity1;n">
          ]>
          <a>&entity2;</a>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          xml-encoding: null;
          xml-standalone: false;
          document-type {
            node-name: 'a';
            general-entity {
              node-name: 'entity1';
              text-content: 'entity value';
            }
            general-entity {
              node-name: 'entity2';
              text { data: 'e'; }
              general-entity-reference {
                node-name: 'entity1';
                text-content: 'entity value';
                is-expanded: true;
              }
              text { data: 'n'; }
            }
          }
          element {
            namespace-uri: null;
            prefix: null;
            local-name: 'a';
            general-entity-reference {
              node-name: 'entity2';
              text { data: 'e'; }
              is-expanded: true;
              general-entity-reference {
                node-name: 'entity1';
                text {
                  data: 'entity value';
                }
                is-expanded: true;
              }
              text { data: 'n'; }
            }
          }
        }

    @@XMLTest:
      @@@QName: xp.doctype.entity.value.charref.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
            <!ENTITY entity1 "entity &#x21;value&#35;">
            <!ENTITY entity2 '&#x21;value&#35;'>
          ]>
          <a></a>
      @@@test:domTree:
        document {
          document-type {
            general-entity {
              node-name: 'entity1';
              text-content: 'entity !value#';
              has-replacement-tree: true;
            }
            general-entity {
              node-name: 'entity2';
              text-content: '!value#';
              has-replacement-tree: true;
            }
          }
          element { }
        }

    @@XMLTest:
      @@@QName: xp.predefined.in.content.test
      @@@DEnt:
        @@@@test:value:
          <a>_&lt;_&gt;_&quot;_&apos;_&amp;_</a>
      @@@test:domTree:
        document {
          element {
            text-content: '_<_>_"_' U+0027 '_&_';
          }
        }
    @@XMLTest:
      @@@QName: xp.predefined.in.attr.test
      @@@DEnt:
        @@@@test:value:
          <a at="_&lt;_&gt;_&quot;_&apos;_&amp;_"></a>
      @@@test:domTree:
        document {
          element {
            attribute {
              node-name: 'at';
              text-content: '_<_>_"_' U+0027 '_&_';
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.predefined.in.content.in.entity.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
            <!ENTITY ent "_&lt;_&gt;_&quot;_&apos;_&amp;_">
          ]>
          <a>&ent;</a>
      @@@test:domTree:
        document {
          document-type {
            general-entity {
              node-name: 'ent';
              text-content: '_<_>_"_' U+0027 '_&_';
            }
          }
          element {
            text-content: '_<_>_"_' U+0027 '_&_';
          }
        }
    @@XMLTest:
      @@@QName: xp.predefined.decl.ignore.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
            <!ENTITY lt "&#x26;#x3C;">
            <!ENTITY gt "&#x3E;">
            <!ENTITY amp "&#x26;#x26;">
            <!ENTITY quot "&#x22;">
            <!ENTITY apos "&#x27;">
            <!ENTITY other "other">
          ]>
          <a>_&lt;_&gt;_&quot;_&apos;_&amp;_&other;_</a>
      @@@test:domTree:
        document {
          document-type {
            general-entity {
              node-name: 'other';
              text-content: 'other';
            }
          }
          element {
            text-content: '_<_>_"_' U+0027 '_&_other_';
          }
        }

    @@XMLTest:
      @@@QName: xp.doctype.internal.attr.empty.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
            <!ATTLIST a>
          ]>
          <a></a>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          xml-encoding: null;
          xml-standalone: false;
          document-type {
            node-name: 'a';
            element-type-definition {
              node-name: 'a';
            }
          }
          element {
            namespace-uri: null;
            local-name: 'a';
          }
        }
    @@XMLTest:
      @@@QName: xp.doctype.internal.attr.cdata.implied.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
            <!ATTLIST a
              at   CDATA    #IMPLIED
            >
          ]>
          <a></a>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          xml-encoding: null;
          xml-standalone: false;
          document-type {
            node-name: 'a';
            element-type-definition {
              node-name: 'a';
              attribute-definition {
                node-name: 'at';
                declared-type: const (CDATA_ATTR);
                allowed-tokens: DOMStringList ();
                default-type: const (IMPLIED_DEFAULT);
                text-content: '';
              }
            }
          }
          element {
            namespace-uri: null;
            local-name: 'a';
          }
        }
    @@XMLTest:
      @@@QName: xp.doctype.internal.attr.types.implied.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
            <!ATTLIST a
              at1   ID        #IMPLIED
              at2   IDREF     #IMPLIED
              at3   IDREFS    #IMPLIED
              at4   ENTITY    #IMPLIED
              at5   ENTITIES  #IMPLIED
              at6   NMTOKEN   #IMPLIED
              at7   NMTOKENS  #IMPLIED
              at8   NOTATION  (n1 | n2|n3)  #IMPLIED
              at9   (e1| e2| e3 ) #IMPLIED
            >
          ]>
          <a></a>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          xml-encoding: null;
          xml-standalone: false;
          document-type {
            node-name: 'a';
            element-type-definition {
              node-name: 'a';
              attribute-definition {
                node-name: 'at1';
                declared-type: const (ID_ATTR);
                allowed-tokens: DOMStringList ();
                default-type: const (IMPLIED_DEFAULT);
                text-content: '';
              }
              attribute-definition {
                node-name: 'at2';
                declared-type: const (IDREF_ATTR);
                allowed-tokens: DOMStringList ();
                default-type: const (IMPLIED_DEFAULT);
                text-content: '';
              }
              attribute-definition {
                node-name: 'at3';
                declared-type: const (IDREFS_ATTR);
                allowed-tokens: DOMStringList ();
                default-type: const (IMPLIED_DEFAULT);
                text-content: '';
              }
              attribute-definition {
                node-name: 'at4';
                declared-type: const (ENTITY_ATTR);
                allowed-tokens: DOMStringList ();
                default-type: const (IMPLIED_DEFAULT);
                text-content: '';
              }
              attribute-definition {
                node-name: 'at5';
                declared-type: const (ENTITIES_ATTR);
                allowed-tokens: DOMStringList ();
                default-type: const (IMPLIED_DEFAULT);
                text-content: '';
              }
              attribute-definition {
                node-name: 'at6';
                declared-type: const (NMTOKEN_ATTR);
                allowed-tokens: DOMStringList ();
                default-type: const (IMPLIED_DEFAULT);
                text-content: '';
              }
              attribute-definition {
                node-name: 'at7';
                declared-type: const (NMTOKENS_ATTR);
                allowed-tokens: DOMStringList ();
                default-type: const (IMPLIED_DEFAULT);
                text-content: '';
              }
              attribute-definition {
                node-name: 'at8';
                declared-type: const (NOTATION_ATTR);
                allowed-tokens: DOMStringList ('n1', 'n2', 'n3');
                default-type: const (IMPLIED_DEFAULT);
                text-content: '';
              }
              attribute-definition {
                node-name: 'at9';
                declared-type: const (ENUMERATION_ATTR);
                allowed-tokens: DOMStringList ('e1', 'e2', 'e3');
                default-type: const (IMPLIED_DEFAULT);
                text-content: '';
              }
            }
          }
          element {
            namespace-uri: null;
            local-name: 'a';
          }
        }
    @@XMLTest:
      @@@QName: xp.doctype.internal.attr.cdata.defaults.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
            <!ATTLIST a
              at1   CDATA    #IMPLIED
              at2   CDATA    #REQUIRED
              at3   CDATA    #FIXED     "value3"
              at4   CDATA    "value4"
              at5   CDATA    #FIXED     'value5'
              at6   CDATA    'value6'
            >
          ]>
          <a></a>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          xml-encoding: null;
          xml-standalone: false;
          document-type {
            node-name: 'a';
            element-type-definition {
              node-name: 'a';
              attribute-definition {
                node-name: 'at1';
                declared-type: const (CDATA_ATTR);
                allowed-tokens: DOMStringList ();
                default-type: const (IMPLIED_DEFAULT);
                text-content: '';
              }
              attribute-definition {
                node-name: 'at2';
                declared-type: const (CDATA_ATTR);
                allowed-tokens: DOMStringList ();
                default-type: const (REQUIRED_DEFAULT);
                text-content: '';
              }
              attribute-definition {
                node-name: 'at3';
                declared-type: const (CDATA_ATTR);
                allowed-tokens: DOMStringList ();
                default-type: const (FIXED_DEFAULT);
                text-content: 'value3';
              }
              attribute-definition {
                node-name: 'at4';
                declared-type: const (CDATA_ATTR);
                allowed-tokens: DOMStringList ();
                default-type: const (EXPLICIT_DEFAULT);
                text-content: 'value4';
              }
              attribute-definition {
                node-name: 'at5';
                declared-type: const (CDATA_ATTR);
                allowed-tokens: DOMStringList ();
                default-type: const (FIXED_DEFAULT);
                text-content: 'value5';
              }
              attribute-definition {
                node-name: 'at6';
                declared-type: const (CDATA_ATTR);
                allowed-tokens: DOMStringList ();
                default-type: const (EXPLICIT_DEFAULT);
                text-content: 'value6';
              }
            }
          }
          element {
            namespace-uri: null;
            local-name: 'a';
            attribute {
              node-name: 'at3';
              text-content: 'value3';
              specified: false;
            }
            attribute {
              node-name: 'at4';
              text-content: 'value4';
              specified: false;
            }
            attribute {
              node-name: 'at5';
              text-content: 'value5';
              specified: false;
            }
            attribute {
              node-name: 'at6';
              text-content: 'value6';
              specified: false;
            }
          }
        }

    @@XMLTest:
      @@@QName: xp.doctype.internal.attr.cdata.default.normalize.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
            <!ATTLIST a
              at   CDATA    "  default &#x0A;value  "
            >
          ]>
          <a></a>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          xml-encoding: null;
          xml-standalone: false;
          document-type {
            node-name: 'a';
            element-type-definition {
              node-name: 'a';
              attribute-definition {
                node-name: 'at';
                declared-type: const (CDATA_ATTR);
                allowed-tokens: DOMStringList ();
                default-type: const (EXPLICIT_DEFAULT);
                text-content: '  default ' U+000A 'value  ';
              }
            }
          }
          element {
            namespace-uri: null;
            local-name: 'a';
            attribute {
              node-name: 'at';
              text-content: '  default ' U+000A 'value  ';
              specified: false;
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.doctype.internal.attr.nmtoken.default.normalize.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
            <!ATTLIST a
              at   NMTOKEN    "  default &#x0A;value  "
            >
          ]>
          <a></a>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          xml-encoding: null;
          xml-standalone: false;
          document-type {
            node-name: 'a';
            element-type-definition {
              node-name: 'a';
              attribute-definition {
                node-name: 'at';
                declared-type: const (NMTOKEN_ATTR);
                allowed-tokens: DOMStringList ();
                default-type: const (EXPLICIT_DEFAULT);
                text-content: '  default ' U+000A 'value  ';
              }
            }
          }
          element {
            namespace-uri: null;
            local-name: 'a';
            attribute {
              node-name: 'at';
              text-content: '  default ' U+000A 'value  ';
              specified: false;
            }
          }
        }

    @@XMLTest:
      @@@QName: xp.doctype.attrtype.no-value.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a>
          <a at="  at  value  "></a>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          xml-encoding: null;
          xml-standalone: false;
          document-type { }
          element {
            namespace-uri: null;
            local-name: 'a';
            attribute {
              namespace-uri: null;
              local-name: 'at';
              value: '  at  value  ';
              text {
                data: '  at  value  ';
              }
              schema-type-info: TypeInfo (null, null);
              specified: true;
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.doctype.attrtype.cdata.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
            <!ATTLIST a
              at   CDATA    #IMPLIED
            >
          ]>
          <a at="  at  value  "></a>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          xml-encoding: null;
          xml-standalone: false;
          document-type { }
          element {
            namespace-uri: null;
            local-name: 'a';
            attribute {
              namespace-uri: null;
              local-name: 'at';
              value: '  at  value  ';
              text {
                data: '  at  value  ';
              }
              schema-type-info:
                TypeInfo ('http://www.w3.org/TR/REC-xml', 'CDATA');
              specified: true;
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.doctype.attrtype.nmtoken.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
            <!ATTLIST a
              at   NMTOKEN    #IMPLIED
            >
          ]>
          <a at="  at  value  "></a>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          xml-encoding: null;
          xml-standalone: false;
          document-type { }
          element {
            namespace-uri: null;
            local-name: 'a';
            attribute {
              namespace-uri: null;
              local-name: 'at';
              value: 'at value';
              text {
                data: '  at  value  ';
              }
              schema-type-info:
                TypeInfo ('http://www.w3.org/TR/REC-xml', 'NMTOKEN');
              specified: true;
            }
          }
        }

    @@XMLTest:
      @@@QName: xp.doctype.attr.normalization.1.test
      @@@DEnt:
        @@@@test:value:
          <a at="  at &#xA;value  "></a>
      @@@test:domTree:
        document {
          element {
            attribute {
              node-name: 'at';
              value: '  at ' U+000A 'value  ';
              schema-type-info: TypeInfo (null, null);
              specified: true;
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.doctype.attr.normalization.2.test
      @@@DEnt:
        @@@@test:value:
          <a at="  at &#xD;value  "></a>
      @@@test:domTree:
        document {
          element {
            attribute {
              value: '  at ' U+000D 'value  ';
              schema-type-info: TypeInfo (null, null);
              specified: true;
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.doctype.attr.normalization.3.test
      @@@DEnt:
        @@@@test:value:
          <a at="  at &#x9;value  "></a>
      @@@test:domTree:
        document {
          element {
            attribute {
              node-name: 'at';
              value: '  at ' U+0009 'value  ';
              schema-type-info: TypeInfo (null, null);
              specified: true;
            }
          }
        }

    @@XMLTest:
      @@@QName: xp.doctype.attr.specified.1.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
            <!ATTLIST a
              at  CDATA  "default"
            >
          ]>
          <a></a>
      @@@test:domTree:
        document {
          document-type { }
          element {
            attribute {
              node-name: 'at';
              value: 'default';
              specified: false;
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.doctype.attr.specified.2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
            <!ATTLIST a
              at  CDATA  "default"
            >
          ]>
          <a at2="specified"></a>
      @@@test:domTree:
        document {
          document-type { }
          element {
            attribute {
              node-name: 'at';
              value: 'default';
              specified: false;
            }
            attribute {
              node-name: 'at2';
              value: 'specified';
              specified: true;
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.doctype.attr.specified.3.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
            <!ATTLIST a
              at  CDATA  "default"
            >
          ]>
          <a at="specified"></a>
      @@@test:domTree:
        document {
          document-type { }
          element {
            attribute {
              node-name: 'at';
              value: 'specified';
              specified: true;
            }
          }
        }

    @@XMLTest:
      @@@QName: xp.attr.literal.charref.test
      @@@DEnt:
        @@@@test:value:
          <a at1 = "value&#33;_&#x25;value"
             at2 = 'value&#x25;_&#33;value'></a>
      @@@test:domTree:
        document {
          element {
            attribute {
              node-name: 'at1';
              text-content: 'value!_%value';
            }
            attribute {
              node-name: 'at2';
              text-content: 'value%_!value';
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.attr.literal.entref.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
            <!ENTITY ent "entity&#x26;#33;_&#x26;#x29;value">
          ]>
          <a at1 = "value&ent;value"
             at2 = 'value&ent;value'></a>
      @@@test:domTree:
        document {
          document-type {
            general-entity {
              node-name: 'ent';
              text-content: 'entity!_)value';
            }
          }
          element {
            attribute {
              node-name: 'at1';
              text-content: 'valueentity!_)valuevalue';
            }
            attribute {
              node-name: 'at2';
              text-content: 'valueentity!_)valuevalue';
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.attr.literal.entref.nest.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
            <!ENTITY ent1 "entity&#x26;#33;_&#x26;#x29;value">
            <!ENTITY ent2 "@&ent1;@">
          ]>
          <a at1 = "value&ent2;value"
             at2 = 'value&ent2;value'></a>
      @@@test:domTree:
        document {
          document-type {
            general-entity {
              node-name: 'ent1';
              text-content: 'entity!_)value';
            }
            general-entity {
              node-name: 'ent2';
              text-content: '@entity!_)value@';
            }
          }
          element {
            attribute {
              node-name: 'at1';
              text-content: 'value@entity!_)value@value';
            }
            attribute {
              node-name: 'at2';
              text-content: 'value@entity!_)value@value';
            }
          }
        }

    @@XMLTest:
      @@@QName: xp.element.content.ncr.1.test
      @@@DEnt:
        @@@@test:value:
          <e>&#33;</e>
      @@@test:domTree:
        document {
          element {
            text-content: '!';
          }
        }
    @@XMLTest:
      @@@QName: xp.element.content.ncr.2.test
      @@@DEnt:
        @@@@test:value:
          <e>aaaa&#33;bbbb</e>
      @@@test:domTree:
        document {
          element {
            text-content: 'aaaa!bbbb';
          }
        }
    @@XMLTest:
      @@@QName: xp.attrval.ncr.1.test
      @@@DEnt:
        @@@@test:value:
          <e a="&#33;"/>
      @@@test:domTree:
        document {
          element {
            attribute {
              node-name: 'a';
              text-content: '!';
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.attrval.ncr.2.test
      @@@DEnt:
        @@@@test:value:
          <e a="aaaaa&#33;bbbbb"/>
      @@@test:domTree:
        document {
          element {
            attribute {
              node-name: 'a';
              text-content: 'aaaaa!bbbbb';
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.attrval.ncr.3.test
      @@@DEnt:
        @@@@test:value:
          <e a='&#33;'/>
      @@@test:domTree:
        document {
          element {
            attribute {
              node-name: 'a';
              text-content: '!';
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.attrval.ncr.4.test
      @@@DEnt:
        @@@@test:value:
          <e a='aaaaa&#33;bbbbb'/>
      @@@test:domTree:
        document {
          element {
            attribute {
              node-name: 'a';
              text-content: 'aaaaa!bbbbb';
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.entval.ncr.1.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE e [
            <!ENTITY ent "&#33;">
          ]>
          <e/>
      @@@test:domTree:
        document {
          document-type {
            general-entity {
              node-name: 'ent';
              text-content: '!';
            }
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.entval.ncr.2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE e [
            <!ENTITY ent "aaaaa&#33;bbbbb">
          ]>
          <e/>
      @@@test:domTree:
        document {
          document-type {
            general-entity {
              node-name: 'ent';
              text-content: 'aaaaa!bbbbb';
            }
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.element.content.reptxt.ncr.1.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE e [
            <!ENTITY ent "&#38;#33;">
          ]>
          <e>&ent;</e>
      @@@test:domTree:
        document {
          document-type { }
          element {
            general-entity-reference {
              node-name: 'ent';
              text-content: '!';
              is-expanded: true;
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.element.content.reptxt.ncr.2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE e [
            <!ENTITY ent "aaaaa&#38;#33;bbbbb">
          ]>
          <e>&ent;</e>
      @@@test:domTree:
        document {
          document-type { }
          element {
            general-entity-reference {
              node-name: 'ent';
              text-content: 'aaaaa!bbbbb';
              is-expanded: true;
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.element.content.reptxt.reptxt.ncr.1.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE e [
            <!ENTITY ent "&#38;#33;">
            <!ENTITY ent2 "&ent;">
          ]>
          <e>&ent2;</e>
      @@@test:domTree:
        document {
          document-type { }
          element {
            general-entity-reference {
              node-name: 'ent2';
              general-entity-reference {
                node-name: 'ent';
                text-content: '!';
                is-expanded: true;
              }
              is-expanded: true;
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.element.content.reptxt.reptxt.ncr.2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE e [
            <!ENTITY ent "aa&#38;#33;bb">
            <!ENTITY ent2 "&ent;">
          ]>
          <e>&ent2;</e>
      @@@test:domTree:
        document {
          document-type { }
          element {
            general-entity-reference {
              node-name: 'ent2';
              general-entity-reference {
                node-name: 'ent';
                text-content: 'aa!bb';
                is-expanded: true;
              }
              is-expanded: true;
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.attval.reptxt.ncr.1.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE e [
            <!ENTITY ent "&#38;#33;">
          ]>
          <e a="&ent;"/>
      @@@test:domTree:
        document {
          document-type { }
          element {
            attribute {
              node-name: 'a';
              general-entity-reference {
                node-name: 'ent';
                text-content: '!';
                is-expanded: true;
              }
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.attval.reptxt.ncr.2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE e [
            <!ENTITY ent "aaaaa&#38;#33;bbbbb">
          ]>
          <e a="&ent;"/>
      @@@test:domTree:
        document {
          document-type { }
          element {
            attribute {
              node-name: 'a';
              general-entity-reference {
                node-name: 'ent';
                text-content: 'aaaaa!bbbbb';
                is-expanded: true;
              }
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.attval.reptxt.reptxt.ncr.1.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE e [
            <!ENTITY ent "&#38;#33;">
            <!ENTITY ent2 "&ent;">
          ]>
          <e a="&ent2;"/>
      @@@test:domTree:
        document {
          document-type { }
          element {
            attribute {
              node-name: 'a';
              general-entity-reference {
                node-name: 'ent2';
                is-expanded: true;
                general-entity-reference {
                  node-name: 'ent';
                  text-content: '!';
                  is-expanded: true;
                }
              }
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.attval.reptxt.reptxt.ncr.2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE e [
            <!ENTITY ent "aa&#38;#33;bb">
            <!ENTITY ent2 "&ent;">
          ]>
          <e a="&ent2;"/>
      @@@test:domTree:
        document {
          document-type { }
          element {
            attribute {
              node-name: 'a';
              general-entity-reference {
                node-name: 'ent2';
                is-expanded: true;
                general-entity-reference {
                  node-name: 'ent';
                  text-content: 'aa!bb';
                  is-expanded: true;
                }
              }
            }
          }
        }

    @@XMLTest:
      @@@QName: xp.element.content.hcr.1.test
      @@@DEnt:
        @@@@test:value:
          <e>&#x21;</e>
      @@@test:domTree:
        document {
          element {
            text-content: '!';
          }
        }
    @@XMLTest:
      @@@QName: xp.element.content.hcr.2.test
      @@@DEnt:
        @@@@test:value:
          <e>aaaa&#x21;bbbb</e>
      @@@test:domTree:
        document {
          element {
            text-content: 'aaaa!bbbb';
          }
        }
    @@XMLTest:
      @@@QName: xp.attrval.hcr.1.test
      @@@DEnt:
        @@@@test:value:
          <e a="&#x21;"/>
      @@@test:domTree:
        document {
          element {
            attribute {
              node-name: 'a';
              text-content: '!';
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.attrval.hcr.2.test
      @@@DEnt:
        @@@@test:value:
          <e a="aaaaa&#x21;bbbbb"/>
      @@@test:domTree:
        document {
          element {
            attribute {
              node-name: 'a';
              text-content: 'aaaaa!bbbbb';
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.attrval.hcr.3.test
      @@@DEnt:
        @@@@test:value:
          <e a='&#x21;'/>
      @@@test:domTree:
        document {
          element {
            attribute {
              node-name: 'a';
              text-content: '!';
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.attrval.hcr.4.test
      @@@DEnt:
        @@@@test:value:
          <e a='aaaaa&#x21;bbbbb'/>
      @@@test:domTree:
        document {
          element {
            attribute {
              node-name: 'a';
              text-content: 'aaaaa!bbbbb';
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.entval.hcr.1.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE e [
            <!ENTITY ent "&#x21;">
          ]>
          <e/>
      @@@test:domTree:
        document {
          document-type {
            general-entity {
              node-name: 'ent';
              text-content: '!';
            }
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.entval.hcr.2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE e [
            <!ENTITY ent "aaaaa&#x21;bbbbb">
          ]>
          <e/>
      @@@test:domTree:
        document {
          document-type {
            general-entity {
              node-name: 'ent';
              text-content: 'aaaaa!bbbbb';
            }
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.element.content.reptxt.hcr.1.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE e [
            <!ENTITY ent "&#38;#x21;">
          ]>
          <e>&ent;</e>
      @@@test:domTree:
        document {
          document-type { }
          element {
            general-entity-reference {
              node-name: 'ent';
              text-content: '!';
              is-expanded: true;
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.element.content.reptxt.hcr.2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE e [
            <!ENTITY ent "aaaaa&#38;#x21;bbbbb">
          ]>
          <e>&ent;</e>
      @@@test:domTree:
        document {
          document-type { }
          element {
            general-entity-reference {
              node-name: 'ent';
              text-content: 'aaaaa!bbbbb';
              is-expanded: true;
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.element.content.reptxt.reptxt.hcr.1.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE e [
            <!ENTITY ent "&#38;#x21;">
            <!ENTITY ent2 "&ent;">
          ]>
          <e>&ent2;</e>
      @@@test:domTree:
        document {
          document-type { }
          element {
            general-entity-reference {
              node-name: 'ent2';
              is-expanded: true;
              general-entity-reference {
                node-name: 'ent';
                text-content: '!';
                is-expanded: true;
              }
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.element.content.reptxt.reptxt.hcr.2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE e [
            <!ENTITY ent "aa&#38;#x21;bb">
            <!ENTITY ent2 "&ent;">
          ]>
          <e>&ent2;</e>
      @@@test:domTree:
        document {
          document-type { }
          element {
            general-entity-reference {
              node-name: 'ent2';
              is-expanded: true;
              general-entity-reference {
                node-name: 'ent';
                is-expanded: true;
                text-content: 'aa!bb';
              }
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.attval.reptxt.hcr.1.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE e [
            <!ENTITY ent "&#38;#x21;">
          ]>
          <e a="&ent;"/>
      @@@test:domTree:
        document {
          document-type { }
          element {
            attribute {
              node-name: 'a';
              general-entity-reference {
                node-name: 'ent';
                is-expanded: true;
                text-content: '!';
              }
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.attval.reptxt.hcr.2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE e [
            <!ENTITY ent "aaaaa&#38;#x21;bbbbb">
          ]>
          <e a="&ent;"/>
      @@@test:domTree:
        document {
          document-type { }
          element {
            attribute {
              node-name: 'a';
              general-entity-reference {
                node-name: 'ent';
                is-expanded: true;
                text-content: 'aaaaa!bbbbb';
              }
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.attval.reptxt.reptxt.hcr.1.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE e [
            <!ENTITY ent "&#38;#x21;">
            <!ENTITY ent2 "&ent;">
          ]>
          <e a="&ent2;"/>
      @@@test:domTree:
        document {
          document-type { }
          element {
            attribute {
              node-name: 'a';
              general-entity-reference {
                node-name: 'ent2';
                is-expanded: true;
                general-entity-reference {
                  node-name: 'ent';
                  is-expanded: true;
                  text-content: '!';
                }
              }
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.attval.reptxt.reptxt.hcr.2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE e [
            <!ENTITY ent "aa&#38;#x21;bb">
            <!ENTITY ent2 "&ent;">
          ]>
          <e a="&ent2;"/>
      @@@test:domTree:
        document {
          document-type { }
          element {
            attribute {
              node-name: 'a';
              general-entity-reference {
                node-name: 'ent2';
                is-expanded: true;
                general-entity-reference {
                  node-name: 'ent';
                  is-expanded: true;
                  text-content: 'aa!bb';
                }
              }
            }
          }
        }

    @@XMLTest:
      @@@QName: xp.element.content.ncr.legal.char.1.0.1.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0"?>
          <e>&#0;</e>
      @@@c:erred: <[[xp|wf-legal-character]]> { (2, 4)..(2, 7); }
    @@XMLTest:
      @@@QName: xp.element.content.ncr.legal.char.1.1.1.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.1"?>
          <e>&#0;</e>
      @@@c:erred: <[[xp|wf-legal-character]]> { (2, 4)..(2, 7); }
    @@XMLTest:
      @@@QName: xp.element.content.ncr.legal.char.1.0.2.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0"?>
          <e>&#1;</e>
      @@@c:erred: <[[xp|wf-legal-character]]> { (2, 4)..(2, 7); }
    @@XMLTest:
      @@@QName: xp.element.content.ncr.legal.char.1.1.2.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.1"?>
          <e>&#1;</e>
      @@@test:domTree:
        document {
          xml-version: '1.1';
          element {
            text-content: U+0001;
          }
        }
    @@XMLTest:
      @@@QName: xp.element.content.hcr.legal.char.1.0.1.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0"?>
          <e>&#x0;</e>
      @@@c:erred: <[[xp|wf-legal-character]]> { (2, 4)..(2, 8); }
    @@XMLTest:
      @@@QName: xp.element.content.hcr.legal.char.1.1.1.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.1"?>
          <e>&#x0;</e>
      @@@c:erred: <[[xp|wf-legal-character]]> { (2, 4)..(2, 8); }
    @@XMLTest:
      @@@QName: xp.element.content.hcr.legal.char.1.0.2.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0"?>
          <e>&#x1;</e>
      @@@c:erred: <[[xp|wf-legal-character]]> { (2, 4)..(2, 8); }
    @@XMLTest:
      @@@QName: xp.element.content.hcr.legal.char.1.1.2.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.1"?>
          <e>&#x1;</e>
      @@@test:domTree:
        document {
          xml-version: '1.1';
          element {
            text-content: U+0001;
          }
        }

    @@XMLTest:
      @@@QName: xp.element.content.ger.entity.declared.nodtd.1.test
      @@@DEnt:
        @@@@test:value:
          <p>&entity;</p>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (1, 4)..(1, 11); }
    @@XMLTest:
      @@@QName: xp.element.content.ger.entity.declared.nodtd.2.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="yes"?>
          <p>&entity;</p>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (2, 4)..(2, 11); }
    @@XMLTest:
      @@@QName: xp.element.content.ger.entity.declared.nodtd.3.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="no"?>
          <p>&entity;</p>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (2, 4)..(2, 11); }
    @@XMLTest:
      @@@QName: xp.element.content.ger.entity.declared.nodtd.-1.test
      @@@DEnt:
        @@@@test:value:
          <p>&lt;&gt;&amp;&quot;&apos;</p>
      @@@test:domTree:
        document {
          element {
            text-content: '<>&"' U+0027;
          }
        }
    @@XMLTest:
      @@@QName: xp.element.content.ger.entity.declared.nopref.1.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p []>
          <p>&entity;</p>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (2, 4)..(2, 11); }
    @@XMLTest:
      @@@QName: xp.element.content.ger.entity.declared.nopref.2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p [
            <!ENTITY other "aa">
            <!ENTITY % another "aa">
          ]>
          <p>&entity;</p>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (5, 4)..(5, 11); }
    @@XMLTest:
      @@@QName: xp.element.content.ger.entity.declared.nopref.3.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="yes"?>
          <!DOCTYPE p []>
          <p>&entity;</p>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (3, 4)..(3, 11); }
    @@XMLTest:
      @@@QName: xp.element.content.ger.entity.declared.nopref.4.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="no"?>
          <!DOCTYPE p []>
          <p>&entity;</p>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (3, 4)..(3, 11); }
    @@XMLTest:
      @@@QName: xp.element.content.ger.entity.declared.nopref.5.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="yes"?>
          <!DOCTYPE p [
            <!ENTITY other "aa">
            <!ENTITY % another "aa">
          ]>
          <p>&entity;</p>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (6, 4)..(6, 11); }
    @@XMLTest:
      @@@QName: xp.element.content.ger.entity.declared.nopref.6.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="no"?>
          <!DOCTYPE p [
            <!ENTITY other "aa">
            <!ENTITY % another "aa">
          ]>
          <p>&entity;</p>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (6, 4)..(6, 11); }
    @@XMLTest:
      @@@QName: xp.element.content.ger.entity.declared.nopref.-1.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p [
            <!ENTITY entity "value">
          ]>
          <p>&entity;</p>
      @@@test:domTree:
        document {
          document-type {
            general-entity {
              node-name: 'entity';
              text-content: 'value';
            }
          }
          element {
            general-entity-reference {
              node-name: 'entity';
              is-expanded: true;
              text-content: 'value';
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.element.content.ger.entity.declared.nopref.-2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p [
            <!ENTITY entity "value">
            <!ENTITY another SYSTEM "another">
          ]>
          <p>&entity;</p>
      @@@test:domTree:
        document {
          document-type {
            general-entity {
              node-name: 'entity';
              text-content: 'value';
            }
            general-entity {
              node-name: 'another';
              public-id: null;
              system-id: 'another';
            }
          }
          element {
            general-entity-reference {
              node-name: 'entity';
              is-expanded: true;
              text-content: 'value';
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.element.content.ger.entity.declared.standalone.1.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="yes"?>
          <p>&entity;</p>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (2, 4)..(2, 11); }
    @@XMLTest:
      @@@QName: xp.element.content.ger.entity.declared.standalone.2.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="yes"?>
          <!DOCTYPE p []>
          <p>&entity;</p>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (3, 4)..(3, 11); }
    @@XMLTest:
      @@@QName: xp.element.content.ger.entity.declared.standalone.3.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="yes"?>
          <!DOCTYPE p [
            <!ENTITY % para "<!-- -->">
            %para;
          ]>
          <p>&entity;</p>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (6, 4)..(6, 11); }
    @@XMLTest:
      @@@QName: xp.element.content.ger.entity.declared.standalone.-1.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="no"?>
          <!DOCTYPE p [
            <!ENTITY % para "<!-- -->">
            %para;
          ]>
          <p>&entity;</p>
      @@@test:domTree:
        document {
          document-type { }
          element {
            general-entity-reference {
              is-expanded: false;
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.element.content.ger.entity.declared.standalone.-2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p [
            <!ENTITY % para "<!-- -->">
            %para;
          ]>
          <p>&entity;</p>
      @@@test:domTree:
        document {
          document-type { }
          element {
            general-entity-reference {
              is-expanded: false;
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.element.content.ger.entity.declared.standalone.4.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="yes"?>
          <!DOCTYPE p [
            <!ENTITY % para SYSTEM "para">
            %para;
          ]>
          <p>&entity;</p>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (6, 4)..(6, 11); }
    @@XMLTest:
      @@@QName: xp.element.content.ger.entity.declared.standalone.-3.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="no"?>
          <!DOCTYPE p [
            <!ENTITY % para SYSTEM "para">
            %para;
          ]>
          <p>&entity;</p>
      @@@test:domTree:
        document {
          document-type { }
          element {
            general-entity-reference {
              is-expanded: false;
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.element.content.ger.entity.declared.standalone.-4.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p [
            <!ENTITY % para SYSTEM "para">
            %para;
          ]>
          <p>&entity;</p>
      @@@test:domTree:
        document {
          document-type { }
          element {
            general-entity-reference {
              is-expanded: false;
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.element.content.ger.entity.declared.standalone.5.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="yes"?>
          <!DOCTYPE p SYSTEM "dtd">
          <p>&entity;</p>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (3, 4)..(3, 11); }
    @@XMLTest:
      @@@QName: xp.element.content.ger.entity.declared.standalone.-5.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="no"?>
          <!DOCTYPE p SYSTEM "dtd">
          <p>&entity;</p>
      @@@test:domTree:
        document {
          document-type { }
          element {
            general-entity-reference {
              is-expanded: false;
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.element.content.ger.entity.declared.standalone.-6.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p SYSTEM "dtd">
          <p>&entity;</p>
      @@@test:domTree:
        document {
          document-type { }
          element {
            general-entity-reference {
              is-expanded: false;
            }
          }
        }

    @@XMLTest:
      @@@QName: xp.reptxt.element.content.ger.entity.declared.nopref.1.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p [
          <!ENTITY c "&entity;">
          ]>
          <p>&c;</p>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (1, 1)..(1, 8); }
    @@XMLTest:
      @@@QName: xp.reptxt.element.content.ger.entity.declared.nopref.2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p [
            <!ENTITY other "aa">
            <!ENTITY % another "aa">
          <!ENTITY c "&entity;">
          ]>
          <p>&c;</p>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (1, 1)..(1, 8); }
    @@XMLTest:
      @@@QName: xp.reptxt.element.content.ger.entity.declared.nopref.3.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="yes"?>
          <!DOCTYPE p [
          <!ENTITY c "&entity;">
          ]>
          <p>&c;</p>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (1, 1)..(1, 8); }
    @@XMLTest:
      @@@QName: xp.reptxt.element.content.ger.entity.declared.nopref.4.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="no"?>
          <!DOCTYPE p [
          <!ENTITY c "&entity;">
          ]>
          <p>&c;</p>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (1, 1)..(1, 8); }
    @@XMLTest:
      @@@QName: xp.reptxt.element.content.ger.entity.declared.nopref.5.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="yes"?>
          <!DOCTYPE p [
            <!ENTITY other "aa">
            <!ENTITY % another "aa">
          <!ENTITY c "&entity;">
          ]>
          <p>&c;</p>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (1, 1)..(1, 8); }
    @@XMLTest:
      @@@QName: xp.reptxt.element.content.ger.entity.declared.nopref.6.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="no"?>
          <!DOCTYPE p [
            <!ENTITY other "aa">
            <!ENTITY % another "aa">
          <!ENTITY c "&entity;">
          ]>
          <p>&c;</p>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (1, 1)..(1, 8); }
    @@XMLTest:
      @@@QName: xp.reptxt.element.content.ger.entity.declared.nopref.-1.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p [
            <!ENTITY entity "value">
          <!ENTITY c "&entity;">
          ]>
          <p>&c;</p>
      @@@test:domTree:
        document {
          document-type {
            general-entity {
              node-name: 'entity';
              text-content: 'value';
            }
            general-entity {
              node-name: 'c';
              general-entity-reference {
                node-name: 'entity';
                text-content: 'value';
              }
            }
          }
          element {
            general-entity-reference {
              node-name: 'c';
              general-entity-reference {
                node-name: 'entity';
                text-content: 'value';
              }
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.reptxt.element.content.ger.entity.declared.nopref.-2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p [
            <!ENTITY entity "value">
            <!ENTITY another SYSTEM "another">
          <!ENTITY c "&entity;">
          ]>
          <p>&c;</p>
      @@@test:domTree:
        document {
          document-type {
            general-entity {
              node-name: 'entity';
              text-content: 'value';
            }
            general-entity {
              node-name: 'c';
              general-entity-reference {
                node-name: 'entity';
                text-content: 'value';
              }
            }
            general-entity {
              node-name: 'another';
              public-id: null;
              system-id: 'another';
              has-replacement-tree: false;
            }
          }
          element {
            general-entity-reference {
              node-name: 'c';
              general-entity-reference {
                node-name: 'entity';
                text-content: 'value';
              }
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.reptxt.element.content.ger.entity.declared.standalone.2.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="yes"?>
          <!DOCTYPE p [
          <!ENTITY c "&entity;">
          ]>
          <p>&c;</p>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (1, 1)..(1, 8); }
    @@XMLTest:
      @@@QName: xp.reptxt.element.content.ger.entity.declared.standalone.3.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="yes"?>
          <!DOCTYPE p [
            <!ENTITY % para "<!-- -->">
            %para;
          <!ENTITY c "&entity;">
          ]>
          <p>&c;</p>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (1, 1)..(1, 8); }
    @@XMLTest:
      @@@QName: xp.reptxt.element.content.ger.entity.declared.standalone.-1.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="no"?>
          <!DOCTYPE p [
          <!ENTITY c "&entity;">
            <!ENTITY % para "<!-- -->">
            %para;
          ]>
          <p>&c;</p>
      @@@test:domTree:
        document {
          document-type {
            general-entity {
              node-name: 'c';
              general-entity-reference {
                node-name: 'entity';
                is-expanded: false;
              }
            }
          }
          element {
            general-entity-reference {
              node-name: 'c';
              general-entity-reference {
                node-name: 'entity';
                is-expanded: false;
              }
            }
          }
        }
    @@XMLTest:
      @@@QName:
        xp.reptxt.element.content.ger.entity.declared.standalone.-1.2.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="no"?>
          <!DOCTYPE p [
            <!ENTITY % para "<!-- -->">
            %para;
          <!ENTITY c "&entity;">
          ]>
          <p>&c;</p>
      @@@test:domTree:
        document {
          document-type { }
          element {
            general-entity-reference {
              node-name: 'c';
              is-expanded: false;
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.reptxt.element.content.ger.entity.declared.standalone.-2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p [
          <!ENTITY c "&entity;">
            <!ENTITY % para "<!-- -->">
            %para;
          ]>
          <p>&c;</p>
      @@@test:domTree:
        document {
          document-type { }
          element {
            general-entity-reference {
              node-name: 'c';
              is-expanded: true;
              general-entity-reference {
                node-name: 'entity';
                is-expanded: false;
              }
            }
          }
        }
    @@XMLTest:
      @@@QName:
        xp.reptxt.element.content.ger.entity.declared.standalone.-2.2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p [
            <!ENTITY % para "<!-- -->">
            %para;
          <!ENTITY c "&entity;">
          ]>
          <p>&c;</p>
      @@@test:domTree:
        document {
          document-type { }
          element {
            general-entity-reference {
              node-name: 'c';
              is-expanded: false;
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.reptxt.element.content.ger.entity.declared.standalone.4.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="yes"?>
          <!DOCTYPE p [
            <!ENTITY % para SYSTEM "para">
            %para;
          <!ENTITY c "&entity;">
          ]>
          <p>&c;</p>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (1, 1)..(1, 8); }
    @@XMLTest:
      @@@QName: xp.reptxt.element.content.ger.entity.declared.standalone.-3.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="no"?>
          <!DOCTYPE p [
          <!ENTITY c "&entity;">
            <!ENTITY % para SYSTEM "para">
            %para;
          ]>
          <p>&c;</p>
      @@@test:domTree:
        document {
          document-type { }
          element {
            general-entity-reference {
              node-name: 'c';
              is-expanded: true;
              general-entity-reference {
                node-name: 'entity';
                is-expanded: false;
              }
            }
          }
        }
    @@XMLTest:
      @@@QName:
        xp.reptxt.element.content.ger.entity.declared.standalone.-3.2.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="no"?>
          <!DOCTYPE p [
            <!ENTITY % para SYSTEM "para">
            %para;
          <!ENTITY c "&entity;">
          ]>
          <p>&c;</p>
      @@@test:domTree:
        document {
          document-type { }
          element {
            general-entity-reference {
              node-name: 'c';
              is-expanded: false;
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.reptxt.element.content.ger.entity.declared.standalone.-4.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p [
          <!ENTITY c "&entity;">
            <!ENTITY % para SYSTEM "para">
            %para;
          ]>
          <p>&c;</p>
      @@@test:domTree:
        document {
          document-type { }
          element {
            general-entity-reference {
              node-name: 'c';
              is-expanded: true;
              general-entity-reference {
                node-name: 'entity';
                is-expanded: false;
              }
            }
          }
        }
    @@XMLTest:
      @@@QName:
        xp.reptxt.element.content.ger.entity.declared.standalone.-4.2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p [
            <!ENTITY % para SYSTEM "para">
            %para;
          <!ENTITY c "&entity;">
          ]>
          <p>&c;</p>
      @@@test:domTree:
        document {
          document-type { }
          element {
            general-entity-reference {
              node-name: 'c';
              is-expanded: false;
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.reptxt.element.content.ger.entity.declared.standalone.5.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="yes"?>
          <!DOCTYPE p SYSTEM "dtd" [
          <!ENTITY c "&entity;">
          ]>
          <p>&c;</p>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (1, 1)..(1, 8); }
    @@XMLTest:
      @@@QName: xp.reptxt.element.content.ger.entity.declared.standalone.-5.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="no"?>
          <!DOCTYPE p SYSTEM "dtd" [
          <!ENTITY c "&entity;">
          ]>
          <p>&c;</p>
      @@@test:domTree:
        document {
          document-type { }
          element {
            general-entity-reference {
              node-name: 'c';
              is-expanded: true;
              general-entity-reference {
                node-name: 'entity';
                is-expanded: false;
              }
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.reptxt.element.content.ger.entity.declared.standalone.-6.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p SYSTEM "dtd" [<!ENTITY c "&entity;">]>
          <p>&c;</p>
      @@@test:domTree:
        document {
          document-type { }
          element {
            general-entity-reference {
              node-name: 'c';
              is-expanded: true;
              general-entity-reference {
                node-name: 'entity';
                is-expanded: false;
              }
            }
          }
        }

    @@XMLTest:
      @@@QName: xp.attval.ger.entity.declared.nodtd.1.test
      @@@DEnt:
        @@@@test:value:
          <p a="&entity;"/>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (1, 7)..(1, 14); }
    @@XMLTest:
      @@@QName: xp.attval.ger.entity.declared.nodtd.2.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="yes"?>
          <p a="&entity;"/>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (2, 7)..(2, 14); }
    @@XMLTest:
      @@@QName: xp.attval.ger.entity.declared.nodtd.3.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="no"?>
          <p a="&entity;"/>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (2, 7)..(2, 14); }
    @@XMLTest:
      @@@QName: xp.attval.ger.entity.declared.nodtd.-1.test
      @@@DEnt:
        @@@@test:value:
          <p a="&lt;&gt;&amp;&quot;&apos;"/>
      @@@test:domTree:
        document {
          element {
            attribute {
              node-name: 'a';
              text-content: '<>&"' U+0027;
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.attval.ger.entity.declared.nopref.1.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p []>
          <p a="&entity;"/>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (2, 7)..(2, 14); }
    @@XMLTest:
      @@@QName: xp.attval.ger.entity.declared.nopref.2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p [
            <!ENTITY other "aa">
            <!ENTITY % another "aa">
          ]>
          <p a="&entity;"/>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (5, 7)..(5, 14); }
    @@XMLTest:
      @@@QName: xp.attval.ger.entity.declared.nopref.3.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="yes"?>
          <!DOCTYPE p []>
          <p a="&entity;"/>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (3, 7)..(3, 14); }
    @@XMLTest:
      @@@QName: xp.attval.ger.entity.declared.nopref.4.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="no"?>
          <!DOCTYPE p []>
          <p a="&entity;"/>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (3, 7)..(3, 14); }
    @@XMLTest:
      @@@QName: xp.attval.ger.entity.declared.nopref.5.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="yes"?>
          <!DOCTYPE p [
            <!ENTITY other "aa">
            <!ENTITY % another "aa">
          ]>
          <p a="&entity;"/>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (6, 7)..(6, 14); }
    @@XMLTest:
      @@@QName: xp.attval.ger.entity.declared.nopref.6.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="no"?>
          <!DOCTYPE p [
            <!ENTITY other "aa">
            <!ENTITY % another "aa">
          ]>
          <p a="&entity;"/>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (6, 7)..(6, 14); }
    @@XMLTest:
      @@@QName: xp.attval.ger.entity.declared.nopref.-1.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p [
            <!ENTITY entity "value">
          ]>
          <p a="&entity;"/>
      @@@test:domTree:
        document {
          document-type {
            general-entity {
              node-name: 'entity';
              text-content: 'value';
            }
          }
          element {
            attribute {
              node-name: 'a';
              general-entity-reference {
                node-name: 'entity';
                is-expanded: true;
                text-content: 'value';
              }
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.attval.ger.entity.declared.nopref.-2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p [
            <!ENTITY entity "value">
            <!ENTITY another SYSTEM "another">
          ]>
          <p a="&entity;"/>
      @@@test:domTree:
        document {
          document-type {
            general-entity {
              node-name: 'entity';
              text-content: 'value';
              has-replacement-tree: true;
            }
            general-entity {
              node-name: 'another';
              public-id: null;
              system-id: 'another';
              has-replacement-tree: false;
            }
          }
          element {
            attribute {
              node-name: 'a';
              general-entity-reference {
                node-name: 'entity';
                is-expanded: true;
                text-content: 'value';
              }
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.attval.ger.entity.declared.standalone.1.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="yes"?>
          <p a="&entity;"/>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (2, 7)..(2, 14); }
    @@XMLTest:
      @@@QName: xp.attval.ger.entity.declared.standalone.2.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="yes"?>
          <!DOCTYPE p []>
          <p a="&entity;"/>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (3, 7)..(3, 14); }
    @@XMLTest:
      @@@QName: xp.attval.ger.entity.declared.standalone.3.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="yes"?>
          <!DOCTYPE p [
            <!ENTITY % para "<!-- -->">
            %para;
          ]>
          <p a="&entity;"/>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (6, 7)..(6, 14); }
    @@XMLTest:
      @@@QName: xp.attval.ger.entity.declared.standalone.-1.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="no"?>
          <!DOCTYPE p [
            <!ENTITY % para "<!-- -->">
            %para;
          ]>
          <p a="&entity;"/>
      @@@test:domTree:
        document {
          document-type { }
          element {
            attribute {
              node-name: 'a';
              general-entity-reference {
                is-expanded: false;
              }
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.attval.ger.entity.declared.standalone.-2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p [
            <!ENTITY % para "<!-- -->">
            %para;
          ]>
          <p a="&entity;"/>
      @@@test:domTree:
        document {
          document-type { }
          element {
            attribute {
              node-name: 'a';
              general-entity-reference {
                is-expanded: false;
              }
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.attval.ger.entity.declared.standalone.4.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="yes"?>
          <!DOCTYPE p [
            <!ENTITY % para SYSTEM "para">
            %para;
          ]>
          <p a="&entity;"/>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (6, 7)..(6, 14); }
    @@XMLTest:
      @@@QName: xp.attval.ger.entity.declared.standalone.-3.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="no"?>
          <!DOCTYPE p [
            <!ENTITY % para SYSTEM "para">
            %para;
          ]>
          <p a="&entity;"/>
      @@@test:domTree:
        document {
          document-type { }
          element {
            attribute {
              node-name: 'a';
              general-entity-reference {
                is-expanded: false;
              }
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.attval.ger.entity.declared.standalone.-4.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p [
            <!ENTITY % para SYSTEM "para">
            %para;
          ]>
          <p a="&entity;"/>
      @@@test:domTree:
        document {
          document-type { }
          element {
            attribute {
              node-name: 'a';
              general-entity-reference {
                is-expanded: false;
              }
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.attval.ger.entity.declared.standalone.5.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="yes"?>
          <!DOCTYPE p SYSTEM "dtd">
          <p a="&entity;"/>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (3, 7)..(3, 14); }
    @@XMLTest:
      @@@QName: xp.attval.ger.entity.declared.standalone.-5.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="no"?>
          <!DOCTYPE p SYSTEM "dtd">
          <p a="&entity;"/>
      @@@test:domTree:
        document {
          document-type { }
          element {
            attribute {
              node-name: 'a';
              general-entity-reference {
                is-expanded: false;
              }
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.attval.ger.entity.declared.standalone.-6.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p SYSTEM "dtd">
          <p a="&entity;"/>
      @@@test:domTree:
        document {
          document-type { }
          element {
            attribute {
              node-name: 'a';
              general-entity-reference {
                is-expanded: false;
              }
            }
          }
        }

    @@enImplNote:
      {TODO:: Entity declared WFC for

         - General entity references in attribute value literals in
           attlist declarations

         - General entity references in replacement texts referenced
           in attribute value literals in tags

         - General entity references in replacement texts referenced
           in attribute value literals in attlist declarations

         - General entity references in entity value??

      }

    @@PerlDef:
      my $impl = $Message::DOM::ImplementationRegistry->get_implementation ({
        'Core' => '3.0',
        'XML' => '3.0',
        'XMLVersion' => ['1.0', '1.1'],
      });
      my $parser = <Class::ManakaiXMLParser>->new ($impl);

      for my $test_data (@$TestData) {
        $test->start_new_test ($test_data->{uri});
        my $doc_ent = $test_data->{entity}->{$test_data->{root_uri}};
        my $not_ok;

        $parser->dom_config->set_parameter ('error-handler' => sub ($$) {
          my (undef, $err) = @_;
	  my $err_type = $err->type;
	  if ($test_data->{dom_error}->{$err_type}) {
            $test->assert_error_equals
                     (actual_value => $err,
                      expected_hash => shift @{$test_data->{dom_error}
                                                         ->{$err_type}});
          } else { # Uncatched error
            warn $err;
            unless ($err->severity == <C::c|DOMError.SEVERITY_WARNING>) {
              $test->failure_comment ('Unexpected error |'.$err->type.'|');
              $not_ok = true;
            }
          }
          return true; # continue as far as possible
        });

        if ($test_data->{dom_tree}) { # Successful test
          try {
            my $doc = $parser->parse_string ($doc_ent->{<H::test:value>});
            $test->assert_dom_tree_equals
                     (actual_value => $doc,
                      expected_hash => $test_data->{dom_tree});
            for (values %{$test_data->{dom_error}||{}}) {
              if (@$_) {
                $test->failure_comment
                         (@$_.' |DOMError|s of type |'.
                          $_->[0]->{type}->{value}.'| are not reported');
                $not_ok = true;
              }
            }
            $not_ok ? $test->not_ok : $test->ok;
          } catch Message::Util::IF::DTException with {
            # 
          } catch Message::DOM::IF::LSException with {
            # not_ok
          } otherwise {
            my $err = shift;
            warn $err;
            $test->not_ok;
          };
        } else {
          try {
            my $doc = $parser->parse_string ($doc_ent->{<H::test:value>});
          } catch Message::Util::IF::DTException with {
            #
          } catch Message::DOM::IF::LSException with {
            #
          } otherwise {
            my $err = shift;
            warn $err;
            $test->not_ok;
          };
          for (values %{$test_data->{dom_error}||{}}) {
            if (@$_) {
              $test->failure_comment
                       (@$_.' |DOMError|s of type |'.
                        $_->[0]->{type}->{value}.'| are not reported');
              $not_ok = true;
            }
          }
          $not_ok ? $test->not_ok : $test->ok;
        }
      }

  @ResourceDef:
    @@QName: getEmptyEntityState
    @@rdf:type: DISPerl|InlineCode
    @@ForCheck: ManakaiDOM|ForClass
    @@PerlDef:
      {reptxt => \'', line => 1, column => 1, pos => 0,
       is_externally_declared => true}

  @ResourceDef:
    @@QName: getCopyOfEntityState
    @@rdf:type: DISPerl|InlineCode
    @@ForCheck: ManakaiDOM|ForClass
    @@PerlDef:
      {%{$self->{$entity_type}->{$entity_name}},
       line => 1, column => 1, pos => 0}
##ManakaiXMLParser

ElementTypeBinding:
  @Name: XMLTests
  @ElementType: 
    dis:ResourceDef
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass
    @@rdf:type: test|ParserTestSet

ElementTypeBinding:
  @Name: XMLTest
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass
    @@rdf:type: test|ParserTest

ElementTypeBinding:
  @Name: DEnt
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: test|RootEntity

ElementTypeBinding:
  @Name: Ent
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: test|Entity

ResourceDef:
  @QName: xp|get-location-from-token
  @rdf:type: DISPerl|BlockCode
  @enDesc:
    Creates a <IF::DOMCore:DOMLocator> object from a token.
  @PerlDef:
    my $__d = $token->{type} ne '#EOF'
                ? $token->{location}->{char_d}
                : 0;
    $__d -= $token->{location_d} if $token->{location_d};
    $result = {
      utf32_offset => $token->{location}->{pos} - $__d,
      line_number => $token->{location}->{line},
      column_number => $token->{location}->{column} - $__d,
    };
    $result->{utf32_offset} = 0 if $result->{utf32_offset} < 0;
    $result->{column_number} = 0 if $result->{column_number} < 0;
                            ## 0 or 1, which should be?
  @For: ManakaiDOM|ManakaiDOM3

ElementTypeBinding:
  @Name: RuleDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass
    @@rdf:type: Muf2003|RuleDefClass

ElementTypeBinding:
  @Name: RuleParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: Muf2003|RuleParameter

ElementTypeBinding:
  @Name: enImplNote
  @ElementType:
    dis:ImplNote
  @ShadowContent:
    @@lang:en

ElementTypeBinding:
  @Name: ErrDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DOMCore|DOMErrorType
    @@For: ManakaiDOM|DOM3
    @@ecore:textFormatter: ManakaiXMLParserExceptionFormatter

ElementTypeBinding:
  @Name: WFErrDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DOMCore|DOMErrorType
    @@For: ManakaiDOM|DOM3
    @@ecore:textFormatter: ManakaiXMLParserExceptionFormatter

ElementTypeBinding:
  @Name: FatalErrDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DOMCore|DOMErrorType
    @@For: ManakaiDOM|DOM3
    @@ecore:textFormatter: ManakaiXMLParserExceptionFormatter

WFErrDef:
  @QName: xp|wf-syntax-error
  @enDesc:
    The entity does not match to the production rule; it is not
    well-formed.
  @DOMCore:severity: DOMCore|SEVERITY_FATAL_ERROR
  @enMufDef:
    |%xp-error-token-type;|%xp-error-token-value
    (prefix => { (|}, suffix => {|)}); is not 
    allowed%xp-error-lines (prefix => { (|}, suffix => {|)});
  @ecore:hasParameter:
    @@@: xp|error-token
    @@enDesc:
      The token that is not allowed.

WFErrDef:
  @QName: xp|wf-pi-target-is-xml
  @enDesc:
    A processing instruction has its <CODE::PITarget> of
    <XML::xml> (in any case) which is not allowed.
  @DOMCore:severity: DOMCore|SEVERITY_ERROR
  @enMufDef:
    Processing instruction target name cannot be |%p
    (name => {<Q::xp|name>});|
  @ecore:hasParameter:
    @@@: xp|error-token
    @@enDesc:
      The token that contains the name.
  @ecore:hasParameter:
    @@@: xp|name
    @@enDesc:
      A string that is specified as target name of the
      processing instruction.
  @ecore:hasParameter: xp|parent

WFErrDef:
  @QName: xp|wf-no-end-tag
  @DOMCore:severity: DOMCore|SEVERITY_ERROR
  @enDesc:
    An end-tag is not found.
  @enMufDef:
    End-tag |</%p (name => {<Q::xp|expected-element-type>});>| is required
  @ecore:hasParameter: xp|error-token
  @ecore:hasParameter:
    @@@: xp|node
    @@enDesc:
      The element node that is not closed.
  @ecore:hasParameter:
    @@@: xp|expected-element-type
    @@enDesc:
      The element type name of the element that is not closed.

WFErrDef:
  @QName: xp|wf-unsupported-xml-version
  @DOMCore:severity: DOMCore|SEVERITY_ERROR
  @enDesc:
    The XML version specified in the version declaration is not supported.
  @enMufDef:
    XML version |%p (name => {<Q::infoset|version>});| is not supported
  @ecore:hasParameter: xp|bad-token
  @ecore:hasParameter:
    @@@: xp|parent
    @@enDesc:
      The document node.
  @ecore:hasParameter:
    @@@: infoset|version
    @@enDesc:
      The specified XML version.

WFErrDef:
  @QName: xp|wf-malformed-enc-name
  @DOMCore:severity: DOMCore|SEVERITY_ERROR
  @enDesc:
    An <XA::encoding> pseudo-attribute value does not match
    to the procduction rule <CODE::EncName>.
  @enMufDef:
    Encoding name |%p (name => {<Q::xp|name>});| is not allowed
  @ecore:hasParameter: xp|error-token
  @ecore:hasParameter:
    @@@: xp|parent
    @@enDesc: The document node.
  @ecore:hasParameter:
    @@@: xp|name
    @@enDesc:
      The <XA::encoding> value.

WFErrDef:
  @QName: xp|wf-malformed-xml-standalone
  @DOMCore:severity: DOMCore|SEVERITY_ERROR
  @enDesc:
    An <XA::standalone> pseudo-attribute value is neither <XML::yes>
    or <XML::no>.
  @enMufDef:
    |standalone| pseudo-attribute value |%p (name => {<Q::xp|name>});|
    is not allowed
  @ecore:hasParameter: xp|error-token
  @ecore:hasParameter:
    @@@: xp|parent
    @@enDesc: The document node.
  @ecore:hasParameter:
    @@@: xp|name
    @@enDesc:
      The <XA::standalone> value.

WFErrDef:
  @QName: xp|wf-legal-literal-character
  @DOMCore:severity: DOMCore|SEVERITY_ERROR
  @enDesc:
    Each character in XML entity must match to the production
    rule <CODE::Char - RestrictedChar>.
  @enMufDef:
    Character %character-code-point 
    (v => {<Q::xp|character-number>}); is not allowed
  @ecore:hasParameter:
    @@@: xp|character-number
    @@enDesc:
      The code position of the character being referred.

WFErrDef:
  @QName: xp|wf-element-type-match
  @DOMCore:severity: DOMCore|SEVERITY_FATAL_ERROR
  @enDesc:
    The <CODE::Name> in an element's end-tag must match the element type
    in the start-tag.
  @enMufDef:
    End-tag |</%p (name => {<Q::xp|actual-element-type>});>| does
    not match to start-tag |<%p (name => {<Q::xp|expected-element-type>});>|
  @ecore:hasParameter: xp|error-token
  @ecore:hasParameter:
    @@@: xp|node
    @@enDesc:
      The current opening element node.
  @ecore:hasParameter:
    @@@: xp|expected-element-type
    @@enDesc:
      The element type name of the current element.
  @ecore:hasParameter:
    @@@: xp|actual-element-type
    @@enDesc:
      The <CODE::Name> occurs in the end-tag.

WFErrDef:
  @QName: xp|wf-unique-att-spec
  @DOMCore:severity: DOMCore|SEVERITY_ERROR
  @enDesc:
    An attribute name <kwd:MUST-NOT> appear more than once in
    the same start-tag or empty-element tag.
  @enMufDef:
    Attribute |%p (name => {<Q::xp|name>});| is specified more
    than once in the same tag
  @ecore:hasParameter: xp|error-token
  @ecore:hasParameter:
    @@@: xp|name
    @@enDesc:
      The name of the attribute.

WFErrDef:
  @QName: xp|wf-no-external-entity-references
  @c:severity: c|SEVERITY_ERROR
  @enDesc:
    Attribute values <kwd:MUST-NOT> contain direct or indirect
    entity references to external entities.
  @enMufDef:
    External entity |%p (name => {<Q::xp|name>});| is referenced
    in an attribute value literal
  @ecore:hasParameter: xp|error-token
  @ecore:hasParameter:
    @@@: xp|name
    @@enDesc:
      The name of the entity.

WFErrDef:
  @QName: xp|wf-no-lt-in-attribute-values
  @c:severity: c|SEVERITY_ERROR
  @enDesc:
    The replacement text of any entity referred to directly or indirectly
    in an attribute value literal <kwd:MUST-NOT> contain a
    <CHAR::LESS-THAN SIGN>.
  @enMufDef:
    Entity replacement text cannot contain a
    |LESS-THAN SIGN| since it is referenced from an attribute
    value literal
  @ecore:hasParameter: xp|error-token

WFErrDef:
  @QName: xp|wf-legal-character
  @DOMCore:severity: DOMCore|SEVERITY_ERROR
  @enDesc:
    Characters referred to using character references <kwd:MUST>
    match the production for <CODE::Char>.
  @enMufDef:
    Reference to character %character-code-point 
    (v => {<Q::xp|character-number>}); is not allowed
  @ecore:hasParameter: xp|error-token
  @ecore:hasParameter:
    @@@: xp|character-number
    @@enDesc:
      The code position of the character being referred.
  @ecore:hasParameter:
    @@@: xp|parent
    @@enDesc:
      The parent node in which the character reference has
      occurred, if available.

WFErrDef:
  @QName: xp|wf-entity-declared
  @c:severity: c|SEVERITY_ERROR
  @enDesc:
    {P:: In a document

       - without any DTD,

       - with only an internal DTD subset that contains no parameter
         entity references, or

       - with <XML::standalone="yes">,

    for an entity reference that does not occur within the external 
    subset or a parameter entity, the <CODE::Name> given in the
    entity reference <kwd:MUST> match the <CODE::Name> does not
    occur within the external subset or a parameter entity,
    except that five predefined character entities need not 
    be declared.  The declaration of a general entity <kwd:MUST>
    precede any reference to it which appears in a default value
    in an attribute list declaration.
  @enMufDef:
    Entity |%p (name => {<Q::xp|name>});| must be declared
    in the internal subset
  @ecore:hasParameter: xp|error-token
  @ecore:hasParameter:
    @@@: xp|name
    @@enDesc:
      The name of the entity.

FatalErrDef:
  @QName: xp|fatal-xml11-end-of-line-in-xml-declaration
  @DOMCore:severity: DOMCore|SEVERITY_ERROR
  @enDesc:
    An end-of-line character <CODE::U+0085> or <CODE::U+2028> is appeared
    within an XML declaration or text declaration.
  @enMufDef:
    End-of-line character %character-code-point
    (v => {<Q::xp|character-number>}); cannot be used within the
    XML or text declaration
  @ecore:hasParameter:
    @@@: xp|character-number
    @@enDesc:
      The code position of the end-of-line character.

XWParam:
  @QName: xp|error-token
  @enDesc:
    The token where the parser found an error.

XWParam:
  @QName: xp|name
  @enDesc:
    A name.

XWParam:
  @QName: xp|parent
  @enDesc:
    The parent node in which the error occurs.

XWParam:
  @QName: xp|node
  @enDesc:
    The current node.

XWParam:
  @QName: xp|actual-element-type
  @enDesc:
    The actual element type name occured in the source.

XWParam:
  @QName: xp|expected-element-type
  @enDesc:
    The element type name expected.

XWParam:
  @QName: xp|character-number
  @enDesc:
    The character code position.

ElementTypeBinding:
  @Name: XWParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@For: =ManakaiDOM|all
    @@rdf:type: ecore|Parameter

ElementTypeBinding:
  @Name:enMufDef
  @ElementType:
    ecore:defaultMessage
  @ShadowContent:
    @@lang:en
    @@ContentType:
      lang:muf

ResourceDef:
  @QName: DOMImpl
  @AliasFor: DOMCore|DOMImplementation
  @For: ManakaiDOM|DOM

ElementTypeBinding:
  @Name: Attr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Attribute
    @@ForCheck: !=ManakaiDOM|ManakaiDOM

ElementTypeBinding:
  @Name: Get
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|AttributeGet

ElementTypeBinding:
  @Name: Set
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|AttributeSet

ElementTypeBinding:
  @Name: enDesc
  @ElementType: 
    dis:Description
  @ShadowContent: 
    @@lang:en

ElementTypeBinding:
  @Name: Method
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Method
    @@For: !=ManakaiDOM|ManakaiDOM

ElementTypeBinding:
  @Name: Return
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|MethodReturn

ElementTypeBinding:
  @Name: Param
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|MethodParameter

ElementTypeBinding:
  @Name: PerlDef
  @ElementType:
    dis:Def
  @ShadowContent:
    @@ContentType: lang|Perl

ElementTypeBinding:
  @Name: PropDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: rdf|Property

ClsDef:
  @ClsQName: ManakaiXMLParserExceptionFormatter

  @ClsISA: ecore|MUErrorFormatter||ManakaiDOM|Perl

  @RuleDef:
    @@Name: xp-error-token-type
    @@enDesc:
      The type of the token the parser is encountered.

    @@Method:
      @@@Name: after
      @@@Param:
        @@@@Name: name
        @@@@Type: DOMString
        @@@@enDesc: The name of the method.
      @@@Param:
        @@@@Name: p
        @@@@Type: DISPerl|HASH
        @@@@enDesc: The set of the parameters to the method.
      @@@Param:
        @@@@Name: o
        @@@@Type: DISPerl|HASH
        @@@@enDesc: The option value.
      @@@Return:
        @@@@PerlDef:
          $p->{-result} = $o->{<H::xp|error-token>}->{type}
            if defined $o->{<H::xp|error-token>}->{type};

  @RuleDef:
    @@Name: xp-error-token-value
    @@enDesc:
      The value of the token the parser is encountered, if any.

    @@Method:
      @@@Name: after
      @@@Param:
        @@@@Name: name
        @@@@Type: DOMString
        @@@@enDesc: The name of the method.
      @@@Param:
        @@@@Name: p
        @@@@Type: DISPerl|HASH
        @@@@enDesc: The set of the parameters to the method.
      @@@Param:
        @@@@Name: o
        @@@@Type: DISPerl|HASH
        @@@@enDesc: The option value.
      @@@Return:
        @@@@PerlDef:
          $p->{-result} = $o->{<H::xp|error-token>}->{value}
            if defined $o->{<H::xp|error-token>}->{value};

  @RuleDef:
    @@Name: xp-error-lines
    @@enDesc:
      A copy of fragment of the source text that contains the line
      where the error occurred, if available.
    
    @@Method:
      @@@Name: after
      @@@Param:
        @@@@Name: name
        @@@@Type: DOMString
        @@@@enDesc: The name of the method.
      @@@Param:
        @@@@Name: p
        @@@@Type: DISPerl|HASH
        @@@@enDesc: The set of the parameters to the method.
      @@@Param:
        @@@@Name: o
        @@@@Type: DISPerl|HASH
        @@@@enDesc: The option value.
      @@@Return:
        @@@@PerlDef:
          my $pos = $o-><AG::DOMCore|DOMError.location>
                      -><AG::DOMCore|DOMLocator.utf32Offset>;
          if ($pos > -1) {
            my $src = $o->{<H::ecore|object>}->{entity}->[-1]->{reptxt};
            my $start = $pos;
            $start = rindex ($$src, "\x0A", $start - 1) for 0..2;
            $start++;
            my $end = $pos;
            $end = index ($$src, "\x0A", $end + 1) for 0..2;
            $end = length $$src if $end < 0;
            $p->{-result} = substr $$src, $start, $end - $start;
          }

  @RuleDef:
    @@Name: character-code-point
    @@enDesc:
      The character code position, in <CODE::U+<VAR::HHHH>> notation.
    
    @@Method:
      @@@Name: after
      @@@Param:
        @@@@Name: name
        @@@@Type: DOMString
        @@@@enDesc: The name of the method.
      @@@Param:
        @@@@Name: p
        @@@@Type: DISPerl|HASH
        @@@@enDesc: The set of the parameters to the method.
      @@@Param:
        @@@@Name: o
        @@@@Type: DISPerl|HASH
        @@@@enDesc: The option value.
      @@@RuleParam:
        @@@@Name: v
        @@@@Type: DISPerl|Number
        @@@@enDesc:
          The name of the error parameter that contains the character code.
      @@@Return:
        @@@@PerlDef:
          $p->{-result} = sprintf 'U+%04X', $o->{$p->{v}};
##XMLParserExceptionFormatter
