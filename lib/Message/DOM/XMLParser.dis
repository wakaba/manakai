Module:
  @QName: MDOM|XMLParser
  @Namespace:
    http://suika.fam.cx/~wakaba/archive/2004/dom/xml-parser#

  @FullName:
    @@lang:en
    @@@: XML Parser

  @DISCore:author: DISCore|Wakaba
  @License: license|Perl+MPL
  @Date:
    $Date: 2006/03/06 07:32:52 $

  @DefaultFor: ManakaiDOM|ManakaiDOMLatest

  @Require:
    @@Module:
      @@@QName: MDOM|DOMLS
      @@@WithFor: ManakaiDOM|ManakaiDOMLatest
    @@Module:
      @@@QName: MDOM|XDoctype
      @@@WithFor: ManakaiDOM|ManakaiDOMLatest

Namespace:
  @c:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#
  @cfg:
    http://suika.fam.cx/www/2006/dom-config/
  @d:
    http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#
  @dis:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#dis--
  @dtest:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/DIS#Test/
  @dx:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#
  @ecore:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/Core/
  @f:
    http://suika.fam.cx/~wakaba/archive/2004/dom/feature#
  @fe:
    http://suika.fam.cx/www/2006/feature/
  @gls:
    http://suika.fam.cx/~wakaba/archive/2004/dom/gls#
  @idl:
    http://suika.fam.cx/~wakaba/archive/2004/dis/IDL#
  @infoset:
     http://www.w3.org/2001/04/infoset#
  @lang:
     http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#
  @license:
     http://suika.fam.cx/~wakaba/archive/2004/8/18/license#
  @LSEV:
    http://www.w3.org/2002/DOMLS
  @ManakaiDOM:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#
  @ManakaiDOMLS:
    http://suika.fam.cx/~wakaba/archive/2004/mdom-ls#
  @MDOM:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#ManakaiDOM.
  @MDOMX:
    http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#
  @mn:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/ManakaiNode#
  @rdf:
    http://www.w3.org/1999/02/22-rdf-syntax-ns#
  @rdfs:
    http://www.w3.org/2000/01/rdf-schema#
  @t:
    http://suika.fam.cx/~wakaba/archive/2004/dom/tree#
  @test:
    http://suika.fam.cx/~wakaba/archive/2004/dis/Test#
  @urigen:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/URI/Generic/
  @x:
    http://suika.fam.cx/~wakaba/archive/2004/dom/xml#
  @xml:
    http://www.w3.org/XML/1998/namespace
  @xml-dtd:
    http://www.w3.org/TR/REC-xml
  @xmlns:
    http://www.w3.org/2000/xmlns/
  @xp:
    http://suika.fam.cx/~wakaba/archive/2004/dom/xml-parser#

## -- Features

ElementTypeBinding:
  @Name: FeatureDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: f|Feature
    @@For: =ManakaiDOM|all

ElementTypeBinding:
  @Name: FeatureVerDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: f|Feature

ElementTypeBinding:
  @Name: featureQName
  @ElementType:
    f:name
  @ShadowContent:
    @@ContentType: DISCore|QName

ResourceDef:
  @QName: DOMString
  @AliasFor: DOMMain|DOMString
  @For: ManakaiDOM|DOM

ResourceDef:
  @QName: Node
  @AliasFor: t|Node
  @For: ManakaiDOM|DOM

ResourceDef:
  @QName: Element
  @AliasFor: t|Element
  @For: ManakaiDOM|DOM

ResourceDef:
  @QName: Document
  @AliasFor: t|Document
  @For: ManakaiDOM|DOM

ResourceDef:
  @QName: DocumentXDoctype
  @AliasFor: d|DocumentXDoctype
  @For: ManakaiDOM|DOM

ResourceDef:
  @QName: DTDef
  @AliasFor: d|DocumentTypeDefinition
  @For: ManakaiDOM|DOM

ResourceDef:
  @QName: ETDef
  @AliasFor: d|ElementTypeDefinition
  @For: ManakaiDOM|DOM

ResourceDef:
  @QName: ATDef
  @AliasFor: d|AttributeDefinition
  @For: ManakaiDOM|DOM

ElementTypeBinding:
  @Name: ClsDef
  @ElementType: 
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      @@@@: dis|MultipleResource
      @@@ForCheck: !ManakaiDOM|ForIF !ManakaiDOM|ForClass
    @@resourceFor:
      @@@@: ManakaiDOM|ForClass
      @@@ForCheck: ManakaiDOM|ManakaiDOM !=ManakaiDOM|ManakaiDOM
    @@For: ManakaiDOM|DOM3
    @@For: =ManakaiDOM|ManakaiDOM

    @@rdf:type:
      @@@@: DISLang|Class
      @@@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: ClsQName
  @ElementType:
    dis:QName
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: ClsISA
  @ElementType:
    dis:ISA
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: nullCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: ManakaiDOM|InCase
    @@Value:
      @@@is-null:1

ElementTypeBinding:
  @Name: TrueCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:InCase
    @@Value:
      @@@@: 1
      @@@ContentType: DISCore|Boolean
    @@Type: idl|boolean||ManakaiDOM|all

ElementTypeBinding:
  @Name: FalseCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:InCase
    @@Value:
      @@@@: 0
      @@@ContentType: DISCore|Boolean
    @@Type: idl|boolean||ManakaiDOM|all

ResourceDef:
  @QName: LSParser
  @AliasFor: DOMLS|LSParser
  @For: ManakaiDOM|DOM3

ClsDef:
  @ClsQName: ManakaiXMLParser
  
  @Implement: DOMLS|LSParser

  @f:implements: DOMLS|LSFeature30
  @f:implements: DOMLS|ParseString10
  @enImplNote:
    @@ddid: dtdfeature
    @@@:
      {TODO::
        Once DTD validation is implemented, add <Q::f:implements>
        for XML-DTD-feature.
      }

  @DISLang:role: gls|ParserRole

  @enDesc:
    Note that the <Class::ManakaiXMLParser> reports any XML errors
    (syntax errors and / or well-formedness constraint errors)
    via the <IF::DOMCore:error-handler> registered to
    the <A::DOMLS:LSParser.domConfig> object.  Each error has
    its <A::DOMCore:DOMError.severity>, either <C::DOMCore:SEVERITY_ERROR>
    or <C::DOMCore:SEVERITY_FATAL_ERROR>.  However, their semantics
    are slight different from the ones of <QUOTE::error> and
    <QUOTE::fatal error> in XML; in this implemenetation, 
    <C::DOMCore:SEVERITY_ERROR> implies that the parsing process
    can effectively be continued to detect more errors while
    <C::DOMCore:SEVERITY_FATAL_ERROR> implies that the error
    is serious so that the result document tree and any errors
    might be far from the ones obtained when the error would not
    be found.

  @Test:
    @@QName: GLSImpl.createGLSParser.LS.test
    @@enDesc:
      Since there is at least one implementation of the feature (i.e.
      this class), the <M::gls|GLSImplementation.createGLSParser>
      must not throw an exception.
    @@PerlDef:
      my $impl;
      __CODE{DOMLS|createImplForTest:: $impl => $impl}__;
      
      my $p = $impl-><M::gls|GLSImplementation.createGLSParser>
                       ({LS => '3.0'});

      $test->assert_isa ($p, <IFName::LSParser>);
  @Test:
    @@QName: GLSImpl.createGLSParser.ParseXMLString.test
    @@enDesc:
      Since there is at least one implementation of the feature (i.e.
      this class), the <M::gls|GLSImplementation.createGLSParser>
      must not throw an exception.
    @@PerlDef:
      my $impl;
      __CODE{DOMLS|createImplForTest:: $impl => $impl}__;
      
      my $p = $impl-><M::gls|GLSImplementation.createGLSParser>
                       ({<Q::fe|ParseXMLString> => '1.0'});

      $test->assert_not_null ($p);
  @Test:
    @@QName: GLSImpl.createGLSParser.LS.ParseXMLString.test
    @@enDesc:
      Since there is at least one implementation of the feature (i.e.
      this class), the <M::gls|GLSImplementation.createGLSParser>
      must not throw an exception.
    @@PerlDef:
      my $impl;
      __CODE{DOMLS|createImplForTest:: $impl => $impl}__;
      
      my $p = $impl-><M::gls|GLSImplementation.createGLSParser>
                       ({LS => '3.0', <Q::fe|ParseXMLString> => '1.0'});

      $test->assert_isa ($p, <IFName::LSParser>);

  @Test:
    @@QName: DOMImplLS.createLSParser.1.test
    @@enDesc:
      Since there is at least one implementation of the feature (i.e.
      this class), the <M::gls|GLSImplementation.createGLSParser>
      must not throw an exception.
    @@PerlDef:
      my $impl;
      __CODE{DOMLS|createImplForTest:: $impl => $impl}__;
      
      my $p = $impl-><M::DOMLS|DOMImplementationLS.createLSParser>
                       (<C::DOMLS|DOMImplementationLS.MODE_SYNCHRONOUS>);
      $test->assert_isa ($p, <IFName::LSParser>);
  @enImplNote:
    @@ddid: lsparsertext
    @@@:
      Future version should add test:
    @@QName: DOMImplLS.createLSParser.2.test
    @@enDesc:
      Since there is at least one implementation of the feature (i.e.
      this class), the <M::gls|GLSImplementation.createGLSParser>
      must not throw an exception.
    @@PerlDef:
      my $impl;
      __CODE{DOMLS|createImplForTest:: $impl => $impl}__;
      
      my $p = $impl-><M::DOMLS|DOMImplementationLS.createLSParser>
                       (<C::DOMLS|DOMImplementationLS.MODE_SYNCHRONOUS>,
                        <Q::xml-dtd:>);
      $test->assert_isa ($p, <IFName::LSParser>);

  @Test:
    @@QName: Perl.open.utf8.strref.1.test
    @@enDesc:
      Does PerlIO works as intended?
    @@PerlDef:
      my $s = qq<\x{3001}\x0A\x{10001}>;
      #open my $a, '<'.':utf8', \$s;
      require IO::String;
      my $a = IO::String->new ($s);
      $test->assert_num_equals
               (actual_value => ord getc $a,
                expected_value => 0x3001);
      $test->assert_num_equals
               (actual_value => ord getc $a,
                expected_value => 0x000A);
      $test->assert_num_equals
               (actual_value => ord getc $a,
                expected_value => 0x10001);
      $a->ungetc (0x10001);
      $test->assert_num_equals
               (actual_value => ord getc $a,
                expected_value => 0x10001);
      $test->assert_null (getc $a);
      close $a;
  @Test:
    @@QName: Perl.open.8859.strref.2.test
    @@enDesc:
      Does PerlIO works as intended?
    @@PerlDef:
      my $s = qq<\x{0080}\x0A\x{00A9}>;
      #open my $a, '<', \$s;
      require IO::String;
      my $a = IO::String->new ($s);
      $test->assert_num_equals
               (actual_value => ord getc $a,
                expected_value => 0x0080);
      $test->assert_num_equals
               (actual_value => ord getc $a,
                expected_value => 0x000A);
      $test->assert_num_equals
               (actual_value => ord getc $a,
                expected_value => 0x00A9);
      $a->ungetc (0x00A9);
      $test->assert_num_equals
               (actual_value => ord getc $a,
                expected_value => 0x00A9);
      $test->assert_null (getc $a);
      close $a;

  @Attr:
    @@Name: domConfig
    @@enDesc:
      The configuration of the parser.

    @@Get:
      @@@Type: DOMCore|DOMConfiguration
      @@@enDesc: The DOM configuration object.
      @@@PerlDef:
        __CODE{DOMCore|getConfigObject::
          $target => $self,
          $targetHash => $self,
          $targetType => {<ClassName::xp|ManakaiXMLParser>},
          $result => $r,
        }__;

  @Attr:
    @@ForCheck: ManakaiDOM|ForClass
    @@Name: async
    @@enDesc:
      Whether the parser is asynchronous or not.
    @@Type: idl|boolean||ManakaiDOM|all
    @@Get:
      @@@FalseCase:
        @@@@enDesc:
          The parser does not in asynchronous mode.
      @@@PerlDef: \
    @@Test:
      @@@QName: XMLParser.async.test
      @@@PerlDef:
        my $xp;
        __CODE{createParserForTest:: $xp => $xp}__;

        $test->assert_false ($xp-><AG::DOMLS|LSParser.async>);

  @Attr:
    @@ForCheck: ManakaiDOM|ForClass
    @@Name: busy
    @@enDesc:
      Whether the parser is currently busy loading a document or not.
    @@Type: idl|boolean||ManakaiDOM|all
    @@Get:
      @@@TrueCase:
        @@@@enDesc:
           The parser is currently busy.
      @@@FalseCase:
        @@@@enDesc:
           The parser is not busy.
      @@@PerlDef:
        $r = $self->{<H::DOMLS|busy>};

  @enImplNote:
    @@ddid: abort
    @@@:
      {ISSUE::
        LSParser.abort:

          Is it required to support even in synchronous mode?
      }

      {TODO::
          LSParser.filter
      }

  @ResourceDef:
    @@QName: createParserForTest
    @@ForCheck: ManakaiDOM|ForClass
    @@rdf:type: DISPerl|BlockCode
    @@PerlDef:
      require Message::DOM::GenericLS;
      $xp = <Class::ManakaiXMLParser>
              ->new (<Class::gls|ManakaiGLSImplementation>->_new, '');

  @Method:
    @@ManakaiDOM:isForInternal:1
    @@ForCheck: ManakaiDOM|ForClass
    @@Operator: DISPerl|NewMethod
    @@enDesc:
      Creates a new instance of the object.
    @@Param:
      @@@Name: impl
      @@@Type: gls|GLSImplementation
      @@@enDesc:
        The implementation from which the parser is created.
    @@Param:
      @@@Name: features
      @@@Type: DOMString
      @@@dis:actualType: f|FeaturesString
      @@@enDesc:
        The set of features requested for the parser.
    @@Return:
      @@@Type: DOMMain|DOMObject
      @@@dis:actualType: LSParser
      @@@enDesc:
        The newly created parser.
      @@@PerlDef:
        $r = bless {
          <H::DOMCore:implementation> => $impl,
        }, $self;

  @Method:
    @@Name: parseURI
    @@enDesc:
      Parses an XML document identified by a DOM URI.

      It is equivalent to <M::.parse> method with its <P::input>
      parameter set to a <IF::LSInput> object whose
      <A::LSInput.systemId> set to <P::uri>.
    @@Param:
      @@@Name: uri
      @@@Type: DOMString
      @@@enDesc:
        The DOM URI of the XML document to be read.
    @@Return:
      @@@Type: Document
      @@@enDesc:
        The newly created and populated <IF::Document> node.
      @@@dx:raises:
        @@@@@: ManakaiDOMLS|MDOMLS_BUSY
        @@@@enDesc:
          If <A::LSParser.busy> is <DOM::true>.
      @@@dx:raises:
        @@@@@: DOMLS|PARSE_ERR
        @@@@enDesc:
          If the <IF::LSParser> was unable to load the document.
      @@@PerlDef:
        __DEEP{
          $r = $self-><M::LSParser.parse> ({system_id => $uri});
        }__;          

  @Method:
    @@Name: parse
    @@enDesc:
      Parses an XML document from a resource identified
      by a <IF::LSInput>.
    @@Param:
      @@@Name: input
      @@@Type: LSInput
      @@@enDesc:
        The <IF::LSInput> from which the source of the document
        is to be read.
    @@Return:
      @@@Type: Document
      @@@enDesc:
        The newly created and populated <IF::Document> node.
      @@@dx:raises:
        @@@@@: ManakaiDOMLS|MDOMLS_BUSY
        @@@@enDesc:
          If the <A::LSParser.busy> is <DOM::true>.
      @@@dx:raises:
        @@@@@: DOMLS|PARSE_ERR
        @@@@enDesc:
          If the <IF::LSParser> was unable to load the document.
      @@@PerlDef:
        if ($self->{<H::DOMLS|busy>}) {
          __EXCEPTION{ManakaiDOMLS|MDOMLS_BUSY}__;
        }
        local $self->{<H::DOMLS|busy>} = true;

        my $in;
        __DEEP{
          $self->{parser_cfg} = $self-><AG::LSParser.domConfig>;
            ## Parser's |domConfig| object.
          $self->{in_in} = $self->{parser_cfg}
                                -><M::c|DOMConfiguration.getParameter>
                                    (<Q::xp|ls-input-to-input-file>);
          $in = $self->{in_in}-><M::ManakaiDOMLSInputToInputFile.resolveLSInput>
                                  ($input,
                                   $self->{parser_cfg}
                                        -><M::c|DOMConfiguration.getParameter>
                                            ('error-handler'));
        }__;
        unless (defined $in) {
          __c|ERROR{DOMLS|no-input-specified::
            MDOMX:param-name => 'input',
          }__;
          __CODE{ParseError}__;
        }

        require IO::Handle;

        $self->{char} = [];
        $self->{token} = [];
        $self->{entity} = [{
          fh => $in-><AG::ManakaiDOMInputFile.filehandle>,
          base_uri => $in-><AG::ManakaiDOMInputFile.baseURI>,
          doc_uri => $in-><AG::ManakaiDOMInputFile.documentURI>,
          line => 1,
          column => 1,
          pos => 0,
          close_file => sub { $in-><M::ManakaiDOMInputFile.close> },
          reptxt => \'',
          is_external_entity => true,
        }];
          ## Entity stack.
        $self->{location} = $self->{entity}->[-1];
          ## Parsing location object as required by DPG.
          ## It must always be equal to |{entity}->[-1]|.
        $self->{entity_char} = [];
          ## Stack for |{char}| stacks analog to |{entity}| stack.
        $self->{entity_token} = [];
          ## Stack for |{token}| stacks analog to |{entity}| stack.
        $self->{xml_version} = '1.0';
          ## Document XML version: either |1.0| or |1.1|.
        $self->{standalone} = false;
          ## True iff |standalone=yes| is explicitly specified.
        $self->{has_xref} = false;
          ## There is an unread external entity.
        $self->{dont_process} = false;
          ## So, don't process |ENTITY| and |ATTLIST| declarations.
        $self->{general_entity} = {
          lt => {is_predefined => true},
          gt => {is_predefined => true},
          amp => {is_predefined => true},
          quot => {is_predefined => true},
          apos => {is_predefined => true},
        };
          ## Declared general entities.
        $self->{param_entity} = {};
          ## Declared parameter entities.
        $self->{attr} = {};
          # $self->{attr}->{$element_type_name}->{$attr_name} = $attr_def
          ## Declared attributes.

        __DEEP{
          $r = $self->{<H::c|implementation>}-><M::DOMImpl.createDocument>;
          $self->{doc} = $r;
            ## |Document| object.
          CORE::delete $self->{docx};
            ## |DocumentXDoctype| object (if necessary).
          $self->{doc_cfg} = $r-><AG::Document.domConfig>;
            ## |Document|'s configuration.
          CORE::delete $self->{dtdef};
            ## |DocumentTypeDefinition| object (if created).
          CORE::delete $self->{dtdecl};
            ## |DocumentTypeDeclaration| object (if created).
 
          $r-><AS::Document.strictErrorChecking> (false);
            ## NOTE: Any checks such as |Name| validity done by
            ##       methods on DOM nodes are disabled.  It might result
            ##       in creating an ill-formed DOM tree when parser
            ##       errors are traped by |error-handler|.
          $self->{doc_cfg}-><M::c|DOMConfiguration.setParameter>
                              (<Q::cfg|entity-reference-read-only> => false);
            ## NOTE: Turn this configuration parameter off is required
            ##       because entity reference subtree is created by
            ##       the parser rather than |createEntityReference|'s
            ##       cloning.  Parser's |cfg:entity-reference-read-only|
            ##       configuration parameter controls whether generated
            ##       subtree is then marked as read-only or not.
          $self->{doc_cfg}-><M::c|DOMConfiguration.setParameter>
                              (<Q::cfg|clone-entity-reference-subtree> => true);
            ## NOTE: Turn this configuration parameter on makes 
            ##       entity reference subtrees in attribute default values
            ##       cloned as is into default attribute node subtrees.
          $self->{doc_cfg}-><M::c|DOMConfiguration.setParameter>
                              (<Q::cfg|dtd-default-attributes> => false);
            ## NOTE: Don't create DTD default attributes by
            ##       |createElementNS| method.
          $self->{doc_cfg}-><M::c|DOMConfiguration.setParameter>
                              (<Q::cfg|xml-id> => $self->{parser_cfg}
                                  -><M::c|DOMConfiguration.getParameter>
                                      (<Q::cfg|xml-id>));
          $self->{doc_cfg}-><M::c|DOMConfiguration.setParameter>
                              ('error-handler' => sub {
                                 my (undef, $err) = @_;
                                 return ($err-><AG::c|DOMError.severity> !=
                                         <C::c|DOMError.SEVERITY_FATAL_ERROR>);
                               })
            unless $Message::DOM::XMLParser::DEBUG;
            ## NOTE: The default error handler in manakai |warn|s error
            ##       description.

          ## Document entity's URI and base URI
          $r-><AS::Document.documentURI> ($self->{entity}->[0]->{doc_uri});
          $r-><AS::Document.manakaiEntityBaseURI>
                ($self->{entity}->[0]->{base_uri});

          ## Document entity -> |Document| node
          $self->_parse_DocumentEntity;

          for (@{$self->{entity}}) {
            $_->{close_file}->();
            ## NOTE: There should be only the document entity.
          }

          ## Replacement tree for general |Entity| nodes
          my @ent = values %{$self->{general_entity}};
          for my $ent (@ent) {
            if (exists $ent->{has_replacement_text}) {
                my $ent_name = $ent->{name};
                $self->{entity} = [<Code::getCopyOfEntityState::
                                              $entity_type = 'general_entity',
                                              $entity_name = $ent_name>];
                $self->{location} = $self->{entity}->[-1];
                $self->{token} = [];
                $self->{char} = [];
                local $ent->{is_opened} = true;
                ## TODO: External entity support
                $self->_parse_InternalGeneralParsedEntity ($ent->{node});
                $ent->{node}-><AS::x|Entity.hasReplacementTree> (true);
                $self->{entity}->[-1]->{close_file}->();
              ## ISSUE: Should errors detected by this phase result
              ##        in |DOMLS:PARSE_ERR| exception thrown?
            }
              ## TODO: Read-only if configuration (for all entities)
          }

          ## Turns flags to their default value
          $self->{doc_cfg}-><M::c|DOMConfiguration.setParameter>
                              (<Q::cfg|entity-reference-read-only> => null);
          $self->{doc_cfg}-><M::c|DOMConfiguration.setParameter>
                              (<Q::cfg|clone-entity-reference-subtree> => null);
          $self->{doc_cfg}-><M::c|DOMConfiguration.setParameter>
                              (<Q::cfg|dtd-default-attributes> => null);
          $self->{doc_cfg}-><M::c|DOMConfiguration.setParameter>
                              (<Q::cfg|xml-id> => null);
          $self->{doc_cfg}-><M::c|DOMConfiguration.setParameter>
                              ('error-handler' => null);
          $r-><AS::Document.strictErrorChecking> (true);
        }__;

  @Method:
    @@Name: shiftChar
    @@ManakaiDOM:isForInternal:1
    @@ForCheck: ManakaiDOM|ForClass
    @@enDesc:
      Returns the next character.
    @@Return:
      @@@Type: idl|long||ManakaiDOM|all
      @@@enDesc:
        The code position number of the next character, if any,
        or <CODE::-1>.
      @@@PerlDef:
        if (@{$self->{char}}) {
          $r = shift @{$self->{char}};
        } else {
          GETCHAR: {
            no warnings 'closed'; # getc() on closed filehandle warning
            my $ent = $self->{entity}->[-1];
            my $char = getc $ent->{fh};

            if (defined $char and length $char) {
              $ent->{pos}++;
              $r = ord $char;
              if ($r == 0x000A) {
                $ent->{line}++;
                $ent->{column} = 1;
              } elsif ($r == 0x000D) {
                my $next_char = getc $ent->{fh};
                if ($next_char eq "\x0A") {
                  if ($ent->{is_external_entity}) {
                    $ent->{pos}++;
                    $ent->{line}++;
                    $ent->{column} = 1;
                    $r = 0x000A; # ^ U+000D U+000A -> U+000A ^
                  } else { # Internal entity
                    $ent->{column}++;
                    ## Line number will be increased by next |shiftChar|.
                    $ent->{fh}->ungetc (0x000A);
                    #$r = 0x000D; # ^ U+000D U+000A -> U+000D ^ U+000A
                    # no change
                  }
                } elsif ($next_char eq "\x85") {
                  if ($self->{xml_version} eq '1.1') {
                    if ($ent->{is_external_entity}) {
                      if ($ent->{no_xml11_eol}) {
                        my $location = {
                          utf32_offset => $ent->{pos} - 1,
                          line_number => $ent->{line},
                          column_number => $ent->{column},
                        };
                        my $continue = __c|ERROR{
                        xp|fatal-xml11-end-of-line-in-xml-declaration::
                          c|location => {$location},
                          xp|character-number => {$r},
                        }__;
                        unless ($continue) {
                          __CODE{ParseError}__;
                        }
                      } # no_xml11_eol
                      $ent->{pos}++; 
                      $ent->{line}++;
                      $ent->{column} = 1;
                      $r = 0x000A; # ^ U+000D U+0085 -> U+000A ^
                    } else { # internal entity
                      $ent->{column}++;
                      ## Line number will be increased by next |shiftChar|.
                      $ent->{fh}->ungetc (0x0085);
                      #$r = 0x000D; # ^ U+000D U+0085 -> U+000D ^ U+0085
                      # no change
                    }
                  } else { # XML 1.0
                    ## |no_xml11_eol| will be tested later.
                    $ent->{column}++;
                    ## Line number will be increased by next |shiftChar|.
                    $ent->{fh}->ungetc (0x0085);
                    $r = 0x000A if $ent->{is_external_entity};
                      # external: ^ U+000D U+0085 -> U+000A ^ U+0085
                      # internal: ^ U+000D U+0085 -> U+000D ^ U+0085 (as is)
                  }
                } else { # neither U+000A nor U+0085
                  $ent->{line}++;
                  $ent->{column} = 1;
                  $ent->{fh}->ungetc (ord $next_char);
                  $r = 0x000A if $ent->{is_external_entity};
                    # external: ^ U+000D _ -> U+000A ^ _
                    # internal: ^ U+000D _ -> U+000D ^ _ (as is)
                }
              } elsif ($r == 0x0085 or $r == 0x2028) {
                if ($ent->{no_xml11_eol}) {
                  my $location = {
                    utf32_offset => $ent->{pos} - 1,
                    line_number => $ent->{line},
                    column_number => $ent->{column},
                  };
                  my $continue = __c|ERROR{
                  xp|fatal-xml11-end-of-line-in-xml-declaration::
                    c|location => {$location},
                    xp|character-number => {$r},
                  }__;
                  unless ($continue) {
                    __CODE{ParseError}__;
                  }
                } # no_xml11_eol
                $r = 0x000A if $self->{xml_version} eq '1.1' and
                               $ent->{is_external_entity};
                ## Even in XML 1.0 it increases the line number.
                $ent->{line}++;
                $ent->{column} = 1;
              } elsif (
                not ((0x0020 <= $r and $r <= 0x007E) or
                     (0x00A0 <= $r and $r <= 0xD7FF) or
                     (0xE000 <= $r and $r <= 0xFFFD) or
                     (0x10000 <= $r and $r <= 0x10FFFF)) and
                $r != 0x0009 and
                not (($self->{xml_version} eq '1.0' or
                      not $ent->{is_external_entity}) and
                     (0x007F <= $r and $r <= 0x009F)) and
                not ($self->{xml_version} eq '1.1' and
                     not $ent->{is_external_entity} and
                     0x0001 <= $r and $r <= 0x001F)
              ) {
                my $location = {
                  utf32_offset => $ent->{pos} - 1,
                  line_number => $ent->{line},
                  column_number => $ent->{column},
                };
                my $continue = __c|ERROR{xp|wf-legal-literal-character::
                  c|location => {$location},
                  xp|character-number => {$r},
                }__;
                unless ($continue) {
                  __CODE{ParseError}__;
                }
                $ent->{column}++;
              } else { # XML |Char|
                $ent->{column}++;
              }
            } else {
              $r = -1;
            }
          } # GETCHAR
        }

  @Method:
    @@ManakaiDOM:isForInternal: 1
    @@Operator: ManakaiDOM|MUErrorHandler
    @@enDesc:
      When a <IF::ecore|ErrorInterface||ManakaiDOM|Perl> is <Perl::report>ed,
      then this method is invoked.
      
      The method calls the <cfg::DOMCore|error-handler> if the error is of 
      <IF::DOMCore|DOMError>.  Otherwise, the error is re-thrown so that
      corresponding <Perl::catch> clause, if any, can catch the error.
    @@Param:
      @@@Name: err
      @@@Type: ecore|ErrorInterface||ManakaiDOM|Perl
      @@@enDesc:
        The reported error object.
    @@Return:
      @@@Type: DISPerl|Any
      @@@enDesc:
        If the <P::err> is a <IF::DOMCore|DOMError>, then the return value
        of the error handler.

           {NOTE:: If the error is thrown, the method never returns.
           }
      @@@nullCase:
        @@@@enDesc:
          No error handler.
      @@@PerlDef:
        if ($err->isa (<IFName::DOMCore|DOMError||ManakaiDOM|ManakaiDOM>)) {
          __DEEP{
            A: {
              my $cfg = $self-><AG::LSParser.domConfig>;
              my $h = $cfg-><M::DOMCore|DOMConfiguration.getParameter>
                               ('error-handler');
              $r = $h-><M::DOMCore|DOMErrorHandler.handleError> ($err);
            } # A
          }__;
        } else {
          $err-><M::ecore|ErrorInterface||ManakaiDOM|Perl.throw>;
        }

  @DISPerl:dpgDef:

    /*
      XML Document Entity
      
        document := prolog element *Misc
                  - *Char RestrictedChar *Char  ;; [1]
    */
    rule DocumentEntity : standalone {
      /*
        prolog := XMLDecl? *Misc [doctypedecl *Misc]  ;; [22]
      */
      ?lexmode DocumentStart;

      my $doc;
      lang:Perl {
        $doc = $self->{doc};
      }
      
      ~? (XDO) {
        ?lexmode XMLDeclarationOrPI;
        lang:Perl {
          $self->{entity}->[-1]->{no_xml11_eol} = true;
        }
        ~ (S) {        // XML declaration
          &_XMLDeclaration_ ($doc => $doc);
          ~ (PIC2) {
            ?lexmode DocumentProlog;
          } else {
            ?lexmode DocumentProlog;
          }
        } (NameChar) {  // Processing instruction whose target begins with |xml|
          my $target_token;
          lang:Perl ($v => $token.value) {
            $target_token = $token;
            $target_token->{value} = 'xml'.$target_token->{value};
            $self->{entity}->[-1]->{no_xml11_eol} = false;
          }
          ?lexmode PINmtoken;
          ~? (Nmtoken) {
            lang:Perl ($v => $token.value) {
              $target_token->{value} .= $v;
            }
            ?lexmode PIName;
          }
          lang:Perl {
            $target_token->{type} = 'Name';
            $target_token->{location_d} += 3; # 'xml'
            unshift @{$self->{token}}, $token;
            $token = $target_token;
          }
          &_ProcessingInstruction_ ($doc => $doc, $parent => $doc);
          ~ (PIC) {
            ?lexmode DocumentProlog;
          } else {
            ?lexmode DocumentProlog;
          }
        } else {
          lang:Perl {
            $self->{entity}->[-1]->{no_xml11_eol} = false;
          }
        }
      } else {
        ?lexmode 'DocumentProlog';
      }
      
      // *Misc
      ~* (CDO) {
        &_CommentDeclaration_ ($doc => $doc, $parent => $doc);

        ~ (MDC) {
          ?lexmode DocumentProlog;
        } else {
          ?lexmode DocumentProlog;
        }
      } (PIO) {
        &_ProcessingInstruction_ ($doc => $doc, $parent => $doc);

        ~ (PIC) {
          ?lexmode 'DocumentProlog';
        } else {
          ?lexmode DocumentProlog;
        }
      } (S) {
        //
      }
      
      // doctypedecl
      ~? (MDO) {
        &_DocumentTypeDeclaration_ ($doc => $doc);

        ~ (MDC) {
          ?lexmode DocumentMisc;
        } else {
          ?lexmode DocumentMisc;
        }
      } else {
        ?lexmode DocumentMisc;
      }

      lang:Perl {
        $self->{doc}-><AS::Document.allDeclarationsProcessed> (true)
          unless $self->{dont_process};
      }
      
      // *Misc
      ~* (CDO) {
        &_CommentDeclaration_ ($doc => $doc, $parent => $doc);

        ~ (MDC) {
          ?lexmode DocumentMisc;
        } else {
          ?lexmode DocumentMisc;
        }
      } (PIO) {
        &_ProcessingInstruction_ ($doc => $doc, $parent => $doc);

        ~ (PIC) {
          ?lexmode 'DocumentMisc';
        } else {
          ?lexmode DocumentMisc;
        }
      } (S) {
        //
      }
      
      // Document element
      ~ (STAGO) {
        &Element_ ($doc => $doc, $parent => $doc)
          : unshift-current-token;
        ~ (TAGC) {
          ?lexmode DocumentEnd;
        } else {
          ?lexmode DocumentEnd;
        }
      } else {
        ?lexmode 'DocumentEnd';
      }
      
      // *Misc
      ~* (CDO) {
        &_CommentDeclaration_ ($doc => $doc, $parent => $doc);

        ~ (MDC) {
          ?lexmode DocumentEnd;
        } else {
          ?lexmode DocumentEnd;
        }
      } (PIO) {
        &_ProcessingInstruction_ ($doc => $doc, $parent => $doc);
        ~ (PIC) {
          ?lexmode 'DocumentEnd';
        } else {
          ?lexmode DocumentEnd;
        }
      } (S) {
        //
      }
      
      ~ (#EOF) { }
    } // DocumentEntity
 
    /*
      Internal General Parsed Entity
 
        An internal general parsed entity is well-formed if its
        replacement text matches the production labeled |content|.
    */
    rule InternalGeneralParsedEntity ($ent) : standalone {
      ?lexmode ElementContent;

      my $ns;
      lang:Perl {
        $ns = {
          xml => <Q::xml:>,
          xmlns => <Q::xmlns:>,
        };
      }

      &content ($parent => $ent, $ns => $ns);

      ~ (#EOF) { }
    } // InternalGeneralParsedEntity
 
    /*
      XML Declaration
      
        XMLDecl := '<?xml' VersionInfo
                           [EncodingDecl]
                           [SDDecl]
                           [S] '?>'  ;; [23]
      
      NOTE: XML declaration is optional in XML 1.0
            while it is required in XML 1.1.
    */
    rule _XMLDeclaration_ {
      // ~ (XDO) { }
      ?lexmode XMLDeclaration;
      //lang:Perl {
      //  $self->{entity}->[-1]->{no_xml11_eol} = true;
      //}
      //~ (S) { }

      ~ (Name == 'version') {
        ~? (S) { }
        ~ (VI) { }
        ~? (S) { }

        my $ver;
        my $bad_token;

        ~ (LIT) {
          ?lexmode AttributeValueLiteral;
          
          ~ (STRING) {
            lang:Perl ($version => $token.value) {
              $ver = $version;
              $bad_token = $token;
            }
          }
    
          ~ (LIT) {
            ?lexmode XMLDeclaration;
          }
        } (LITA) {
          ?lexmode AttributeValueLiteralA;
          
          ~ (STRING) {
            lang:Perl ($version => $token.value) {
              $ver = $version;
              $bad_token = $token;
            }
          }
    
          ~ (LITA) {
            ?lexmode XMLDeclaration;
          }
        }

        lang:Perl : has-error {
          unless ($ver eq '1.0' or $ver eq '1.1') {
            my $location;
            __CODE{xp|get-location-from-token::
              $token => {$bad_token},
              $result => {$location},
            }__;
            my $continue = __DOMCore:ERROR{xp|wf-unsupported-xml-version::
              DOMCore|location => {$location},
              xp|parent => {$self->{doc}},
              infoset|version => {$ver},
              xp|error-token => {$bad_token},
            }__;
            unless ($continue) {
              __CODE{ParseError}__;
            }
          }
          $self->{doc}-><AS::Document.xmlVersion> ($ver);
          $self->{xml_version} = $ver;
        }

        ~? (S) { }
      }

      ~? (Name == 'encoding') {
        ~? (S) { }
        ~ (VI) { }
        ~? (S) { }

        my $ver;
        my $bad_token;

        ~ (LIT) {
          ?lexmode AttributeValueLiteral;
          
          ~ (STRING) {
            lang:Perl ($version => $token.value) {
              $ver = $version;
              $bad_token = $token;
            }
          }
    
          ~ (LIT) {
            ?lexmode XMLDeclaration;
          }
        } (LITA) {
          ?lexmode AttributeValueLiteralA;
          
          ~ (STRING) {
            lang:Perl ($version => $token.value) {
              $ver = $version;
              $bad_token = $token;
            }
          }
    
          ~ (LITA) {
            ?lexmode XMLDeclaration;
          }
        }

        lang:Perl : has-error {
          unless ($ver =~ /\A[A-Za-z][A-Za-z0-9._-]*\z/) {
            my $location;
            __CODE{xp|get-location-from-token::
              $token => {$bad_token},
              $result => {$location},
            }__;
            my $continue = __DOMCore:ERROR{xp|wf-malformed-enc-name::
              DOMCore|location => {$location},
              xp|parent => {$self->{doc}},
              xp|name => {$ver},
              xp|error-token => {$bad_token},
            }__;
            unless ($continue) {
              __CODE{ParseError}__;
            }
          }
          $self->{doc}-><AS::Document.xmlEncoding> ($ver);
        }

        ~? (S) { }
      }

      ~? (Name == 'standalone') {
        ~? (S) { }
        ~ (VI) { }
        ~? (S) { }

        my $ver;
        my $bad_token;

        ~ (LIT) {
          ?lexmode AttributeValueLiteral;
          
          ~ (STRING) {
            lang:Perl ($version => $token.value) {
              $ver = $version;
              $bad_token = $token;
            }
          }
    
          ~ (LIT) {
            ?lexmode XMLDeclaration;
          }
        } (LITA) {
          ?lexmode AttributeValueLiteralA;
          
          ~ (STRING) {
            lang:Perl ($version => $token.value) {
              $ver = $version;
              $bad_token = $token;
            }
          }
    
          ~ (LITA) {
            ?lexmode XMLDeclaration;
          }
        }

        lang:Perl : has-error {
          unless ($ver eq 'yes' or $ver eq 'no') {
            my $location;
            __CODE{xp|get-location-from-token::
              $token => {$bad_token},
              $result => {$location},
            }__;
            my $continue = __DOMCore:ERROR{xp|wf-malformed-xml-standalone::
              DOMCore|location => {$location},
              xp|parent => {$self->{doc}},
              xp|name => {$ver},
              xp|error-token => {$bad_token},
            }__;
            unless ($continue) {
              __CODE{ParseError}__;
            }
          }
          if ($ver eq 'yes') {
            $self->{doc}-><AS::Document.xmlStandalone> (true);
            $self->{standalone} = true;
          }
        }

        ~? (S) { }
      }

      ~ (PIC1) {
        lang:Perl {
          $self->{entity}->[-1]->{no_xml11_eol} = false;
        }
      } else {
        lang:Perl {
          $self->{entity}->[-1]->{no_xml11_eol} = false;
        }
      }

      // ~ (PIC2) { }
    } // _XMLDeclaration_
    
    /*
      Comment Declaration
      
        Comment := '<!--' *(Char - '-' / '-' (Char - '-'))
                   '-->'  ;; [15]
    */ 
    rule _CommentDeclaration_ ($doc, $parent) {
      ?lexmode 'CommentDeclaration';
      
      ~? (STRING) {
        lang:Perl ($data => $token.value) {
          my $com = $doc-><M::Document.createComment> ($data);
          $parent-><M::Node.appendChild> ($com);
        }
      } else {
        lang:Perl {
          my $com = $doc-><M::Document.createComment> ('');
          $parent-><M::Node.appendChild> ($com);
        }
      }
      
      ~ (COM) {
        ?lexmode MarkupDeclaration;
      } else {
        ?lexmode MarkupDeclaration;
      }
      
      // ~ (MDC) { }
    } // _CommentDeclaration

    rule _CommentDeclarationDTD {
      ?lexmode CommentDeclaration;
      
      ~? (STRING) {
        //
      }
      
      ~ (COM) {
        ?lexmode MarkupDeclaration;
      } else {
        ?lexmode MarkupDeclaration;
      }
      
      ~ (MDC) {
        ?lexmode DTD;
      } else {
        ?lexmode DTD;
      }
    } // _CommentDeclarationDTD
   
    /*
      Processing Instruction
      
        PI := '<?' PITarget [S *Char - *Char '?>' *Char]
              '?>'  ;; [16]
    */
    rule _ProcessingInstruction_ ($doc, $parent) {
      ?lexmode 'PIName';
      
      my $pi;
      
      ~ (Name) {
        lang:Perl ($name => $token.value) : has-error {
          if (lc $name eq 'xml') {
            my $location;
            __CODE{xp|get-location-from-token::
              $token => {$token},
              $result => {$location},
            }__;
            my $continue = __DOMCore:ERROR{xp|wf-pi-target-is-xml::
              xp|name => {$name},
              DOMCore|location => {$location},
              xp|parent => {$parent},
            }__;
            unless ($continue) {
              __CODE{ParseError}__;
            }
          }
          __CODE{checkNCName:: $name => $name}__;
          
          $pi = $doc-><M::Document.createProcessingInstruction>
                        ($name);
        }
      } else {
        lang:Perl {
          $pi = $doc-><M::Document.createProcessingInstruction> ('#INVALID');
        }
      }
      
      ~? (S) {
        ?lexmode 'PIData';
        
        my $tdata;
        
        ~? (DATA) {
          lang:Perl ($data => $token.value) {
            $tdata = $data;
          }
        } else {
          lang:Perl {
            $tdata = '';
          }
        }
        
        lang:Perl {
          $pi-><AS::Node.nodeValue> ($tdata);
        }
      }
      
      lang:Perl {
        $parent-><M::Node.appendChild> ($pi);
      }
      
      // ~ (PIC) { }
    } // _ProcessingInstruction_

    /*
      Processing instruction in DTD
    */
    rule _ProcessingInstructionDTD ($doc, $doctype) {
      ?lexmode 'PIName';

      my $pi;
      
      ~ (Name) {
        lang:Perl ($name => $token.value) : has-error {
          if (lc $name eq 'xml') {
            my $location;
            __CODE{xp|get-location-from-token::
              $token => {$token},
              $result => {$location},
            }__;
            my $continue = __DOMCore:ERROR{xp|wf-pi-target-is-xml::
              xp|name => {$name},
              DOMCore|location => {$location},
              xp|parent => {$doctype},
            }__;
            unless ($continue) {
              __CODE{ParseError}__;
            }
          }
          __CODE{checkNCName:: $name => $name}__;
          
          $pi = $doc-><M::Document.createProcessingInstruction>
                        ($name);
          $pi-><AS::x|ProcessingInstruction.manakaiBaseURI>
                 ($self->{location}->{base_uri});
        }      
      } else {
        lang:Perl {
          $pi = $doc-><M::Document.createProcessingInstruction> ('#INVALID');
        }
      }
      
      ~? (S) {
        ?lexmode 'PIData';
        
        my $tdata;
        
        ~? (DATA) {
          lang:Perl ($data => $token.value) {
            $tdata = $data;
          }
        } else {
          lang:Perl {
            $tdata = '';
          }
        }
        
        lang:Perl {
          $pi-><AS::Node.nodeValue> ($tdata);
        }
      }
      
      lang:Perl {
        $doctype-><M::Node.appendChild> ($pi);
      }
      
      ~ (PIC) {
        ?lexmode DTD;
      } else {
        ?lexmode DTD;
      }
    } // _ProcessingInstructionDTD
    
    /*
      Element content parsing mode
      
        element := EmptyElemTag /
                   STag content ETag  ;; [39]
        content := (CharData / element / Reference / CDSect /
                    PI / Comment)     ;; [43]
    */
    rule Element_ ($doc, $parent, $ns) : standalone {
      ?lexmode 'ElementContent';
      
      my $node;  // Current "parent" node
      my $nodes; // Node stack (w/o $current_node)
      my $type;  // Current "parent" element type QName
      my $types; // Element type stack (w/o $current_type)
    //my $ns;    // Current in-scope namespace bindings
      my $nses;  // Namespace binding stack (w/o $current_ns)
      
      lang:Perl {
        $node = $parent;
        $nodes = [];
        $type = '';
        $types = [];
        $ns ||= {
          xml => <Q::xml:>,
          xmlns => <Q::xmlns:>,
        };
        $nses = [];
      }
      
      ~* : name => CONTENT
      (CharData) {
        // Character data
        lang:Perl ($data => $token.value) {
          $node-><M::Node.appendChild>
            ($doc-><M::Document.createTextNode> ($data));
        }
      } (STAGO) {
        // Start tag or empty element tag
        
        ?lexmode 'StartTag';
        
        ~ (Name) {
          my $attrs;
          lang:Perl ($name => $token.value) : has-error {
            __CODE{checkQName:: $name => $name}__;
            push @{$types}, $type;
            $type = $name;
            $attrs = {};
          }
          
          ~? (S) {
            &AttributeSpecificationList
              ($doc => $doc, $attrs => $attrs);
          }

          my $el;

          /*
            Note that this implementation does not perform
            attribute value tokenization (but does white space
            normalization common to attribute types) and
            construct the tree as is.  DOM Level 3 Core spec
            is unclear on this point.  With tokenization,
            entity references cannot be preserved.

            The manakai Node.nodeValue and Attr.value attributes
            do tokenization according to attribute types.
          */

          /*
            ISSUE: Should |xml:id| attribute be typed?
          */
          
          lang:Perl {
            push @{$nses}, $ns;
            $ns = {%$ns};

            ## Default attributes
            DA: for my $atqname (%{$self->{attr}->{$type}}) {
              next DA unless $self->{attr}->{$type}->{$atqname};
              next DA if exists $attrs->{$atqname}; # specified
              my $dtype = $self->{attr}->{$type}->{$atqname}
                               -><AG::ATDef.defaultType>;
              next DA unless $dtype == <C::ATDef.EXPLICIT_DEFAULT> or
                             $dtype == <C::ATDef.FIXED_DEFAULT>;
              $attrs->{$atqname} = {is_default => true, nodes => []};
              for (@{$self->{attr}->{$type}->{$atqname}
                          -><AG::Node.childNodes>}) {
                push @{$attrs->{$atqname}->{nodes}},
                     $_-><M::Node.cloneNode> (true);
              }
            }
            
            my %gattr;
            my %lattr;
            for my $atqname (keys %$attrs) {
              my ($pfx, $lname) = split /:/, $atqname;
              $attrs->{$atqname}->{def} = $self->{attr}->{$type}->{$atqname};
              if (defined $lname) {  ## Global attribute
                if ($pfx eq 'xmlns') {
                  my $nsuri = $attrs->{$atqname}->{is_default}
                                ? $attrs->{$atqname}->{def}-><AG::Node.nodeValue>
                                : $attrs->{$atqname}->{value};
                  if (not $attrs->{$atqname}->{is_default} and
                      $attrs->{$atqname}->{def}) {
                    my $dt = $attrs->{$atqname}->{def}-><AG::ATDef.declaredType>;
                    if ({
                      <C::ATDef.ID_ATTR> => true,
                      <C::ATDef.IDREF_ATTR> => true,
                      <C::ATDef.IDREFS_ATTR> => true,
                      <C::ATDef.ENTITY_ATTR> => true,
                      <C::ATDef.ENTITIES_ATTR> => true,
                      <C::ATDef.NMTOKEN_ATTR> => true,
                      <C::ATDef.NMTOKENS_ATTR> => true,
                      <C::ATDef.NOTATION_ATTR> => true,
                      <C::ATDef.ENUMERATION_ATTR> => true,
                    }->{$dt}) {
                      ## Tokenization (XML 1 3.3.3)
                      for ($nsuri) {
                        s/^\x20+//;
                        s/\x20+\z//;
                        s/\x20+/ /g;
                      }
                    }
                  }
                  if ($lname eq 'xml' and
                      $nsuri ne <Q::xml:>) {
                    my $location;
                    __CODE{xp|get-location-from-token::
                      $token => $token,
                      $result => $location,
                    }__;
                    my $continue = __c|ERROR{xp|nsc-reserved-prefix-xml::
                      c|location => {$location},
                      xp|token => {$token},
                      infoset|prefix => {$lname},
                      infoset|namespaceName => {$nsuri},
                    }__;
                    unless ($continue) {
                      __CODE{ParseError}__;
                    }
                  } elsif ($lname eq 'xmlns') {
                    my $location;
                    __CODE{xp|get-location-from-token::
                      $token => $token,
                      $result => $location,
                    }__;
                    my $continue = __c|ERROR{xp|nsc-reserved-prefix-xmlns::
                      c|location => {$location},
                      xp|token => {$token},
                      infoset|prefix => {$lname},
                      infoset|namespaceName => {$nsuri},
                    }__;
                    unless ($continue) {
                      __CODE{ParseError}__;
                    }
                  }
                  if ($nsuri eq '') {
                    if ($self->{xml_version} eq '1.0') {
                      my $location;
                      __CODE{xp|get-location-from-token::
                        $token => $token,
                        $result => $location,
                      }__;
                      my $continue = __c|ERROR{xp|nswf-empty-namespace-name::
                        c|location => {$location},
                        xp|token => {$token},
                        infoset|namespaceName => {$nsuri},
                        infoset|prefix => {$lname},
                      }__;
                      unless ($continue) {
                        __CODE{ParseError}__;
                      }
                    }
                  } elsif ($nsuri eq <Q::xml:> and
                           $lname ne 'xml') {
                    my $location;
                    __CODE{xp|get-location-from-token::
                      $token => $token,
                      $result => $location,
                    }__;
                    my $continue = __c|ERROR{
                    xp|nsc-reserved-namespace-name-xml::
                      c|location => {$location},
                      xp|token => {$token},
                      infoset|prefix => {$lname},
                      infoset|namespaceName => {$nsuri},
                    }__;
                    unless ($continue) {
                      __CODE{ParseError}__;
                    }
                  } elsif ($nsuri eq <Q::xmlns:>) {
                    my $location;
                    __CODE{xp|get-location-from-token::
                      $token => $token,
                      $result => $location,
                    }__;
                    my $continue = __c|ERROR{
                    xp|nsc-reserved-namespace-name-xmlns::
                      c|location => {$location},
                      xp|token => {$token},
                      infoset|prefix => {$lname},
                      infoset|namespaceName => {$nsuri},
                    }__;
                    unless ($continue) {
                      __CODE{ParseError}__;
                    }
                  }
                  $ns->{$lname} = $nsuri;
                  delete $ns->{$lname} unless length $ns->{$lname};
                }
                $gattr{$pfx}->{$lname} = $attrs->{$atqname};
              } else {               ## Local attribute
                if ($pfx eq 'xmlns') {
                  $ns->{''} = $attrs->{xmlns}->{is_default}
                                ? $attrs->{xmlns}->{def}-><AG::Node.nodeValue>
                                : $attrs->{xmlns}->{value};
                  if (not $attrs->{$atqname}->{is_default} and
                      $attrs->{$atqname}->{def}) {
                    my $dt = $attrs->{$atqname}->{def}-><AG::ATDef.declaredType>;
                    if ({
                      <C::ATDef.ID_ATTR> => true,
                      <C::ATDef.IDREF_ATTR> => true,
                      <C::ATDef.IDREFS_ATTR> => true,
                      <C::ATDef.ENTITY_ATTR> => true,
                      <C::ATDef.ENTITIES_ATTR> => true,
                      <C::ATDef.NMTOKEN_ATTR> => true,
                      <C::ATDef.NMTOKENS_ATTR> => true,
                      <C::ATDef.NOTATION_ATTR> => true,
                      <C::ATDef.ENUMERATION_ATTR> => true,
                    }->{$dt}) {
                      ## Tokenization (XML 1 3.3.3)
                      for ($ns->{''}) {
                        s/^\x20+//;
                        s/\x20+\z//;
                        s/\x20+/ /g;
                      }
                    }
                  }
                  unless ($ns->{''}) {
                    delete $ns->{''};
                  } elsif ($ns->{''} eq <Q::xml:>) {
                    my $location;
                    __CODE{xp|get-location-from-token::
                      $token => $token,
                      $result => $location,
                    }__;
                    my $continue = __c|ERROR{
                    xp|nsc-reserved-namespace-name-xml::
                      c|location => {$location},
                      xp|token => {$token},
                      infoset|prefix => {null},
                      infoset|namespaceName => {<Q::xml:>},
                    }__;
                    unless ($continue) {
                      __CODE{ParseError}__;
                    }
                  } elsif ($ns->{''} eq <Q::xmlns:>) {
                    my $location;
                    __CODE{xp|get-location-from-token::
                      $token => $token,
                      $result => $location,
                    }__;
                    my $continue = __c|ERROR{
                    xp|nsc-reserved-namespace-name-xmlns::
                      c|location => {$location},
                      xp|token => {$token},
                      infoset|prefix => {null},
                      infoset|namespaceName => {<Q::xmlns:>},
                    }__;
                    unless ($continue) {
                      __CODE{ParseError}__;
                    }
                  }
                } else {
                  $lattr{$pfx} = $attrs->{$atqname};
                }
              }
            }
            
            my ($pfx, $lname) = split /:/, $type;
            my $nsuri;
            if (defined $lname) {  ## Prefixed namespace
              if (defined $ns->{$pfx}) {
                $nsuri = $ns->{$pfx};
              } else {
                my $location;
                __CODE{xp|get-location-from-token::
                  $token => $token,
                  $result => $location,
                }__;
                my $continue = __c|ERROR{xp|nsc-prefix-declared::
                  c|location => {$location},
                  xp|token => {$token},
                  infoset|prefix => {$pfx},
                  xp|name => {$type},
                }__;
                unless ($continue) {
                  __CODE{ParseError}__;
                }
              }
            } else {               ## Default namespace
              $nsuri = $ns->{''};
            }
            
            $el = $doc-><M::Document.createElementNS>
                             ($nsuri, $type);
            
            if ($attrs->{xmlns}) {
              my $attr = $doc-><M::Document.createAttributeNS>
                                 (<Q::xmlns:>, 'xmlns');
              for (@{$attrs->{xmlns}->{nodes}}) {
                $attr-><M::Node.appendChild> ($_);
              }
              if ($attrs->{xmlns}->{def}) {
                __CODE{t|setAttrType::
                  $attr => $attr,
                  $type => {$attrs->{xmlns}->{def}-><AG::ATDef.declaredType>},
                }__;
              }
              $el-><M::Element.setAttributeNodeNS> ($attr);
              $attr-><AS::t|Attr.specified> (false)
                if $attrs->{xmlns}->{is_default};
            }
            
            for my $lname (keys %lattr) {
              my $attr = $doc-><M::Document.createAttributeNS>
                                 (null, $lname);
              for (@{$lattr{$lname}->{nodes}}) {
                $attr-><M::Node.appendChild> ($_);
              }
              if ($attrs->{$lname}->{def}) {
                __CODE{t|setAttrType::
                  $attr => $attr,
                  $type => {$attrs->{$lname}->{def}-><AG::ATDef.declaredType>},
                }__;
              }
              $el-><M::Element.setAttributeNodeNS> ($attr);
              $attr-><AS::t|Attr.specified> (false)
                if $attrs->{$lname}->{is_default};
            }
            
            for my $pfx (keys %gattr) {
              LN: for my $lname (keys %{$gattr{$pfx}}) {
                my $name = $pfx.':'.$lname;
                unless (defined $ns->{$pfx}) {
                  my $location;
                  __CODE{xp|get-location-from-token::
                    $token => $token,
                    $result => $location,
                  }__;
                  my $continue = __c|ERROR{xp|nsc-prefix-declared::
                    c|location => {$location},
                    xp|token => {$token},
                    xp|name => {$name},
                    infoset|prefix => {$pfx},
                  }__;
                  unless ($continue) {
                    __CODE{ParseError}__;
                  }
                }
                my $attr = $el-><M::Element.getAttributeNodeNS>
                                  ($ns->{$pfx}, $lname);
                if ($attr) {
                  my $another_name = $attr-><AG::Node.nodeName>;
                  if ($name ne $another_name) {
                    my $location;
                    __CODE{xp|get-location-from-token::
                      $token => $token,
                      $result => $location,
                    }__;
                    my $continue = __c|ERROR{
                    xp|nswf-unique-att-spec-expanded-name::
                      c|location => {$location},
                      xp|token => {$token},
                      xp|another-attribute-name => {$another_name},
                      xp|name => {$name},
                      infoset|namespaceName => {$ns->{$pfx}},
                      infoset|localName => {$lname},
                    }__;
                    unless ($continue) {
                      __CODE{ParseError}__;
                    }
                    unless ($attr-><AG::t|Attr.specified>) {
                      ## It is a default attribute
                      $attr = $doc-><M::Document.createAttributeNS>
                                      ($ns->{$pfx}, $name);
                    } else {
                      ## It is a specified attribute
                      next LN;
                    }
                  } else { ## There is default attribute
                    $attr = $doc-><M::Document.createAttributeNS>
                                    ($ns->{$pfx}, $name);                    
                  }
                } else {
                  $attr = $doc-><M::Document.createAttributeNS>
                                   ($ns->{$pfx}, $name);
                }
                for (@{$gattr{$pfx}->{$lname}->{nodes}}) {
                  $attr-><M::Node.appendChild> ($_);
                }
                if ($gattr{$pfx}->{$lname}->{def}) {
                  __CODE{t|setAttrType::
                    $attr => $attr,
                    $type => {$gattr{$pfx}->{$lname}
                                    ->{def}-><AG::ATDef.declaredType>},
                  }__;
                }
                $el-><M::Element.setAttributeNodeNS> ($attr);
                $attr-><AS::t|Attr.specified> (false)
                  if $gattr{$pfx}->{$lname}->{is_default};
              } # PFX
            }

            $node-><M::Node.appendChild> ($el);            
          }
        
          ~ (TAGC) {
            lang:Perl {
              push @{$nodes}, $node;
              $node = $el;
            }
            ?lexmode ElementContent;
          } (NESTC) {
            my $is_docel;
            lang:Perl {
              $ns = pop @{$nses};
              $type = pop @{$types};
              $is_docel = (@{$types} == 0);
            }

            if-true ($is_docel) {
              return;
            }

            ~ (TAGC) {
              ?lexmode ElementContent;
            } else {
              ?lexmode ElementContent;
            }
          } else {
            ?lexmode ElementContent;
          }
        } else {
          ?lexmode ElementContent;
        }

      } (ETAGO) {
        // End tag
        
        ?lexmode 'EndTag';

        my $is_docel;
        
        ~ (Name) {
          // No NCName & QName check (it must match to start-tag)
          lang:Perl ($name => $token.value) : has-error {
            if ($name eq $type) {
              $type = pop @{$types};
              if ($type eq '') {
                $is_docel = true;
              }
              $node = pop @{$nodes};
              $ns = pop @{$nses};
            } else {
              my $location;
              __CODE{xp|get-location-from-token::
                $token => $token,
                $result => $location,
              }__;
              my $continue = __DOMCore:ERROR{xp|wf-element-type-match::
                DOMCore:location => {$location},
                xp|token => {$token},
                xp|expected-element-type => {$type},
                xp|actual-element-type => {$name},
                xp|node => {$node},
              }__;
              unless ($continue) {
                __CODE{ParseError}__;
              }
            }
          }
        }
        
        ~? (S) { }

        if-true ($is_docel) {
          lang:Perl : has-error {
            if (@{$types}) {
              my $location;
              __CODE{xp|get-location-from-token::
                $token => $token,
                $result => $location,
              }__;
              for my $type (reverse @{$types}) {
                my $continue = __DOMCore:ERROR{xp|wf-no-end-tag::
                  DOMCore:location => {$location},
                  xp|token => {$token},
                  xp|expected-element-type => {$type},
                  xp|node => {$node},
                }__;
                unless ($continue) {
                  __CODE{ParseError}__;
                }
                $node = shift @{$nodes};
              }
            }
          }
          return;
        }
        
        ~ (TAGC) {
          ?lexmode ElementContent;
        } else {
          ?lexmode 'ElementContent';
        }

      } (HCRO) {
        &_HexadecimalCharacterReference_
          ($doc => $doc, $parent => $node);

        ~ (REFC) {
          ?lexmode 'ElementContent';
        } else {
          ?lexmode ElementContent;
        }
      } (CRO) {
        &_NumericCharacterReference_
          ($doc => $doc, $parent => $node);

        ~ (REFC) {
          ?lexmode 'ElementContent';
        } else {
          ?lexmode ElementContent;
        }
      } (ERO) {
        &_GeneralEntityReferenceEC
          ($doc => $doc, $parent => $node, $ns => $ns);
      } (CDO) {
        &_CommentDeclaration_ ($doc => $doc, $parent => $node);

        ~ (MDC) {
          ?lexmode ElementContent;
        } else {
          ?lexmode ElementContent;
        }
      } (CDSO) {
        &_CDATASection_ ($doc => $doc, $parent => $node);

        ~ (MSE) {
          ?lexmode 'ElementContent';
        } else {
          ?lexmode ElementContent;
        }
      } (PIO) {
        &_ProcessingInstruction_ ($doc => $doc, $parent => $node);

        ~ (PIC) {
          ?lexmode 'ElementContent';
        } else {
          ?lexmode ElementContent;
        }
      }

      ~ (#NONE) { }
    } // Element_

    /*
      content := [CharData]
                 *((element / Reference / CDSect / PI / Comment) [CharData])
    */
    rule content ($parent, $ns) {
      // ?lexmode ElementContent;
 
      my $doc;
      lang:Perl {
        $doc = $self->{doc};
      }

      ~* (CharData) {
        lang:Perl ($data => $token.value) {
          $parent-><M::Node.appendChild>
            ($self->{doc}-><M::Document.createTextNode> ($data));
        }
      } (STAGO) {
          &Element_ ($doc => $doc, $parent => $parent, $ns => $ns)
            : unshift-current-token;
          ~ (TAGC) {
            ?lexmode ElementContent;
          } else {
            ?lexmode ElementContent;
          }
        } (HCRO) {
          &_HexadecimalCharacterReference_
            ($doc => $doc, $parent => $parent);

          ~ (REFC) {
            ?lexmode 'ElementContent';
          } else {
            ?lexmode ElementContent;
          }
        } (CRO) {
          &_NumericCharacterReference_
            ($doc => $doc, $parent => $parent);

          ~ (REFC) {
            ?lexmode 'ElementContent';
          } else {
            ?lexmode ElementContent;
          }
        } (ERO) {
          &_GeneralEntityReferenceEC
            ($doc => $doc, $parent => $parent, $ns => $ns);
        } (CDO) {
          &_CommentDeclaration_ ($doc => $doc, $parent => $parent);

          ~ (MDC) {
            ?lexmode ElementContent;
          } else {
            ?lexmode ElementContent;
          }
        } (CDSO) {
          &_CDATASection_ ($doc => $doc, $parent => $parent);

          ~ (MSE) {
            ?lexmode 'ElementContent';
          } else {
            ?lexmode ElementContent;
          }
        } (PIO) {
          &_ProcessingInstruction_ ($doc => $doc, $parent => $parent);

          ~ (PIC) {
            ?lexmode 'ElementContent';
          } else {
            ?lexmode ElementContent;
          }
        }
    } // content
    
    rule AttributeSpecificationList ($doc, $attrs)
      : standalone
    {
      ?lexmode 'StartTag';
      
      my $i;
      lang:Perl {
        $i = 0;
      }
      
      ~* (Name) {
        my $atqname;
        lang:Perl ($name => $token.value) : has-error {
          __CODE{checkQName:: $name => $name}__;
          $atqname = $name;
        }
        
        my $vals;
        lang:Perl : has-error {
          if ($attrs->{$atqname}) {
            my $location;
            __CODE{xp|get-location-from-token::
              $token => $token,
              $result => $location,
            }__;
            my $continue = __DOMCore:ERROR{xp|wf-unique-att-spec::
              DOMCore:location => {$location},
              xp|token => {$token},
              xp|name => {$atqname},
            }__;
            unless ($continue) {
              __CODE{ParseError}__;
            }
          }
          
          $vals = $attrs->{$atqname} = {
            nodes => [],
            value => '',
            index => $i++,
          };
        }

        ~? (S) { }
        ~ (VI) { }
        ~? (S) { }
        
        ~ (LIT) {
          &_AttributeValueSpecification_
            ($doc => $doc, $vals => $vals);

          ~ (LIT) {
            ?lexmode StartTag;
          } else {
            ?lexmode StartTag;
          }
        } (LITA) {
          &_AttributeValueSpecificationA_
            ($doc => $doc, $vals => $vals);

          ~ (LITA) {
            ?lexmode StartTag;
          } else {
            ?lexmode StartTag;
          }
        }
      } (S) : separator : terminator? { }
    } // AttributeSpecificationList
    
    rule _AttributeValueSpecification_ ($doc, $vals) {
      // ~ (LIT) { }
      ?lexmode 'AttributeValueLiteral';
      
      ~* (STRING) {
        lang:Perl ($value => $token.value) {
          $value =~ s/[\x09\x0A\x0D]/ /g;
          my $text = $doc-><M::Document.createTextNode> ($value);
          push @{$vals->{nodes}}, $text;
          $vals->{value} .= $value;
        }
      } (HCRO) {
        &_HexadecimalCharacterReferenceV_
          ($doc => $doc, $vals => $vals);

        ~ (REFC) {
          ?lexmode AttributeValueLiteral;
        } else {
          ?lexmode AttributeValueLiteral;
        }
      } (CRO) {
        &_NumericCharacterReferenceV_
          ($doc => $doc, $vals => $vals);

        ~ (REFC) {
          ?lexmode AttributeValueLiteral;
        } else {
          ?lexmode AttributeValueLiteral;
        }
      } (ERO) {
        // TODO: Attribute value normalization
        &_GeneralEntityReferenceV_
          ($doc => $doc, $vals => $vals);

        ~ (REFC) {
          ?lexmode AttributeValueLiteral;
        } else {
          ?lexmode AttributeValueLiteral;
        }
      }
      
      // ~ (LIT) { } (LITA) { }
    } // _AttributeValueSpecification_
    
    rule _AttributeValueSpecificationA_ ($doc, $vals) {
      // ~ (LITA) { }
      ?lexmode 'AttributeValueLiteralA';
      
      ~* (STRING) {
        lang:Perl ($value => $token.value) {
          $value =~ s/[\x09\x0A\x0D]/ /g;
          my $text = $doc-><M::Document.createTextNode> ($value);
          push @{$vals->{nodes}}, $text;
          $vals->{value} .= $value;
        }
      } (HCRO) {
        &_HexadecimalCharacterReferenceV_
          ($doc => $doc, $vals => $vals);

        ~ (REFC) {
          ?lexmode AttributeValueLiteralA;
        } else {
          ?lexmode AttributeValueLiteralA;
        }
      } (CRO) {
        &_NumericCharacterReferenceV_
          ($doc => $doc, $vals => $vals);

        ~ (REFC) {
          ?lexmode AttributeValueLiteralA;
        } else {
          ?lexmode AttributeValueLiteralA;
        }
      } (ERO) {
        // TODO: Attribute value normalization
        &_GeneralEntityReferenceV_
          ($doc => $doc, $vals => $vals);

        ~ (REFC) {
          ?lexmode AttributeValueLiteralA;
        } else {
          ?lexmode AttributeValueLiteralA;
        }
      }
      
      // ~ (LITA) { }
    } // _AttributeValueSpecificationA_
    
    /*
      Parsing replacement text of an entity referenced in
      an attribute value specification.
    */
    rule AttributeValueLiteralE_ ($parent, $vals)
      : recursive
    {
      // ?lexmode AttributeValueLiteralE;
      
      ~* (STRING) {
        lang:Perl ($value => $token.value) {
          $value =~ s/[\x09\x0A\x0D]/ /g;
          my $text = $self->{doc}-><M::Document.createTextNode> ($value);
          $parent-><M::Node.appendChild> ($text);
          $vals->{value} .= $value;
        }
      } (HCRO) {
        &_HexadecimalCharacterReferenceAE_
          ($parent => $parent, $vals => $vals);

        ~ (REFC) {
          ?lexmode AttributeValueLiteralE;
        } else {
          ?lexmode AttributeValueLiteralE;
        }
      } (CRO) {
        &_NumericCharacterReferenceAE_
          ($parent => $parent, $vals => $vals);

        ~ (REFC) {
          ?lexmode AttributeValueLiteralE;
        } else {
          ?lexmode AttributeValueLiteralE;
        }
      } (ERO) {
        &_GeneralEntityReferenceAE_ ($parent => $parent, $vals => $vals);

        ~ (REFC) {
          ?lexmode AttributeValueLiteralE;
        } else {
          ?lexmode AttributeValueLiteralE;
        }
      } (#INVALID == '<') {
        lang:Perl : has-error {
          my $location;
          __CODE{xp|get-location-from-token::
            $token => $token,
            $result => $location,
          }__;
          my $continue = __DOMCore:ERROR{xp|wf-no-lt-in-attribute-values::
            c|location => {$location},
            xp|token => {$token},
          }__;
          unless ($continue) {
            __CODE{ParseError}__;
          }

          my $text = $self->{doc}-><M::Document.createTextNode> ('<');
          $parent-><M::Node.appendChild> ($text);
          $vals->{value} .= '<';
        }
      }
      
      // ~ (#EOF) { }
    } // AttributeValueLiteralE_
    
    /*
      CDATA Section Content Parsing Mode
    */
    rule _CDATASection_ ($doc, $parent) {
      ?lexmode 'CDATASectionContent';
        
      my $cdata;
        
      ~? (CData) {
        lang:Perl ($data => $token.value) {
          $cdata = $data;
        }
      } else {
        lang:Perl {
          $cdata = '';
        }
      }
      
      lang:Perl {
        my $cdsect = $doc-><M::Document.createCDATASection>
                             ($cdata);
        $parent-><M::Node.appendChild> ($cdsect);
      }
      
      // ~ (MSE) { }
    } // _CDATASection_
    
    rule _NumericCharacterReference_ ($doc, $parent) {
      ?lexmode 'NumericCharacterReference';
      
      ~ (NUMBER) {
        lang:Perl ($num => $token.value) : has-error {
          $num += 0;
          unless (
            ($self->{xml_version} eq '1.0' and
              ((0x0020 <= $num and $num <= 0xD7FF) or
               (0xE000 <= $num and $num <= 0xFFFD) or
               (0x10000 <= $num and $num <= 0x10FFFF) or
               $num == 0x9 or $num == 0xA or $num == 0xD)) or
            ($self->{xml_version} eq '1.1' and
              ((0x0001 <= $num and $num <= 0xD7FF) or
               (0xE000 <= $num and $num <= 0xFFFD) or
               (0x10000 <= $num and $num <= 0x10FFFF)))
          ) {
            my $location;
            __CODE{xp|get-location-from-token::
              $token => $token,
              $result => $location,
            }__;
            my $continue = __DOMCore:ERROR{xp|wf-legal-character::
              DOMCore:location => {$location},
              xp|token => {$token},
              xp|character-number => {$num},
              xp|parent => {$parent},
            }__;
            unless ($continue) {
              __CODE{ParseError}__;
            }
          }
          my $ncr = $doc-><M::Document.createTextNode> (chr $num);
          $parent-><M::Node.appendChild> ($ncr);
        }
      }
      
      // ~ (REFC) { }
    } // _NumericCharacterReference_
    
    rule _NumericCharacterReferenceV_ ($doc, $vals) {
      ?lexmode 'NumericCharacterReference';
      
      ~ (NUMBER) {
        lang:Perl ($num => $token.value) : has-error {
          $num += 0;
          unless (
            ($self->{xml_version} eq '1.0' and
              ((0x0020 <= $num and $num <= 0xD7FF) or
               (0xE000 <= $num and $num <= 0xFFFD) or
               (0x10000 <= $num and $num <= 0x10FFFF) or
               $num == 0x9 or $num == 0xA or $num == 0xD)) or
            ($self->{xml_version} eq '1.1' and
              ((0x0001 <= $num and $num <= 0xD7FF) or
               (0xE000 <= $num and $num <= 0xFFFD) or
               (0x10000 <= $num and $num <= 0x10FFFF)))
          ) {
            my $location;
            __CODE{xp|get-location-from-token::
              $token => $token,
              $result => $location,
            }__;
            my $continue = __DOMCore:ERROR{xp|wf-legal-character::
              DOMCore:location => {$location},
              xp|token => {$token},
              xp|character-number => {$num},
            }__;
            unless ($continue) {
              __CODE{ParseError}__;
            }
          }
          my $ncr = $doc-><M::Document.createTextNode>
                            (my $char = chr $num);
          push @{$vals->{nodes}}, $ncr;
          $vals->{value} .= $char;
        }
      }
      
      // ~ (REFC) { }
    } // _NumericCharacterReferenceV_
    
    /*
      Numeric character reference in the replacement text
      of the entity referenced in an attribute value specification
    */
    rule _NumericCharacterReferenceAE_ ($parent, $vals)
    {
      ?lexmode NumericCharacterReference;
      
      ~ (NUMBER) {
        lang:Perl ($num => $token.value) : has-error {
          $num += 0;
          unless (
            ($self->{xml_version} eq '1.0' and
              ((0x0020 <= $num and $num <= 0xD7FF) or
               (0xE000 <= $num and $num <= 0xFFFD) or
               (0x10000 <= $num and $num <= 0x10FFFF) or
               $num == 0x9 or $num == 0xA or $num == 0xD)) or
            ($self->{xml_version} eq '1.1' and
              ((0x0001 <= $num and $num <= 0xD7FF) or
               (0xE000 <= $num and $num <= 0xFFFD) or
               (0x10000 <= $num and $num <= 0x10FFFF)))
          ) {
            my $location;
            __CODE{xp|get-location-from-token::
              $token => $token,
              $result => $location,
            }__;
            my $continue = __DOMCore:ERROR{xp|wf-legal-character::
              DOMCore:location => {$location},
              xp|token => {$token},
              xp|character-number => {$num},
            }__;
            unless ($continue) {
              __CODE{ParseError}__;
            }
          }
          my $ncr = $self->{doc}-><M::Document.createTextNode>
                            (my $char = chr $num);
          $parent-><M::Node.appendChild> ($ncr);
          $vals->{value} .= $char;
        }
      }
      
      // ~ (REFC) { }
    } // _NumericCharacterReferenceAE_
    
    rule _NumericCharacterReferenceEV_ ($vals)
    {
      ?lexmode 'NumericCharacterReference';
      
      ~ (NUMBER) {
        lang:Perl ($num => $token.value) : has-error {
          $num += 0;
          unless (
            ($self->{xml_version} eq '1.0' and
              ((0x0020 <= $num and $num <= 0xD7FF) or
               (0xE000 <= $num and $num <= 0xFFFD) or
               (0x10000 <= $num and $num <= 0x10FFFF) or
               $num == 0x9 or $num == 0xA or $num == 0xD)) or
            ($self->{xml_version} eq '1.1' and
              ((0x0001 <= $num and $num <= 0xD7FF) or
               (0xE000 <= $num and $num <= 0xFFFD) or
               (0x10000 <= $num and $num <= 0x10FFFF)))
          ) {
            my $location;
            __CODE{xp|get-location-from-token::
              $token => $token,
              $result => $location,
            }__;
            my $continue = __DOMCore:ERROR{xp|wf-legal-character::
              DOMCore:location => {$location},
              xp|token => {$token},
              xp|character-number => {$num},
            }__;
            unless ($continue) {
              __CODE{ParseError}__;
            }
          }
          push @{$vals}, chr $num;
        }
      }
      
      // ~ (REFC) { }
    } // _NumericCharacterReferenceEV_
    
    rule _HexadecimalCharacterReference_ ($doc, $parent) {
      ?lexmode 'HexadecimalCharacterReference';
      
      ~ (Hex) {
        lang:Perl ($v => $token.value) : has-error {
          my $num = hex $v;
          unless (
            ($self->{xml_version} eq '1.0' and
              ((0x0020 <= $num and $num <= 0xD7FF) or
               (0xE000 <= $num and $num <= 0xFFFD) or
               (0x10000 <= $num and $num <= 0x10FFFF) or
               $num == 0x9 or $num == 0xA or $num == 0xD)) or
            ($self->{xml_version} eq '1.1' and
              ((0x0001 <= $num and $num <= 0xD7FF) or
               (0xE000 <= $num and $num <= 0xFFFD) or
               (0x10000 <= $num and $num <= 0x10FFFF)))
          ) {
            my $location;
            __CODE{xp|get-location-from-token::
              $token => $token,
              $result => $location,
            }__;
            my $continue = __DOMCore:ERROR{xp|wf-legal-character::
              DOMCore:location => {$location},
              xp|token => {$token},
              xp|character-number => {$num},
              xp|parent => {$parent},
            }__;
            unless ($continue) {
              __CODE{ParseError}__;
            }
          }
          my $ncr = $doc-><M::Document.createTextNode>
                      (chr $num);
          $parent-><M::Node.appendChild> ($ncr);
        }
      }
      
      // ~ (REFC) { }
    } // _HexadecimalCharacterReference_
    
    rule _HexadecimalCharacterReferenceV_ ($doc, $vals) {
      ?lexmode 'HexadecimalCharacterReference';
      
      ~ (Hex) {
        lang:Perl ($v => $token.value) : has-error {
          my $num = hex $v;
          unless (
            ($self->{xml_version} eq '1.0' and
              ((0x0020 <= $num and $num <= 0xD7FF) or
               (0xE000 <= $num and $num <= 0xFFFD) or
               (0x10000 <= $num and $num <= 0x10FFFF) or
               $num == 0x9 or $num == 0xA or $num == 0xD)) or
            ($self->{xml_version} eq '1.1' and
              ((0x0001 <= $num and $num <= 0xD7FF) or
               (0xE000 <= $num and $num <= 0xFFFD) or
               (0x10000 <= $num and $num <= 0x10FFFF)))
          ) {
            my $location;
            __CODE{xp|get-location-from-token::
              $token => $token,
              $result => $location,
            }__;
            my $continue = __DOMCore:ERROR{xp|wf-legal-character::
              DOMCore:location => {$location},
              xp|token => {$token},
              xp|character-number => {$num},
            }__;
            unless ($continue) {
              __CODE{ParseError}__;
            }
          }
          my $ncr = $doc-><M::Document.createTextNode>
                      (my $char = chr $num);
          push @{$vals->{nodes}}, $ncr;
          $vals->{value} .= $char;
        }
      }
      
      // ~ (REFC) { }
    } // _HexadecimalCharacterReferenceV_
    
    /*
      Hexadecimal character reference in the replacement text
      of the entity referenced in an attribute value literal
    */
    rule _HexadecimalCharacterReferenceAE_ ($parent, $vals)
    {
      ?lexmode HexadecimalCharacterReference;
      
      ~ (Hex) {
        lang:Perl ($v => $token.value) : has-error {
          my $num = hex $v;
          unless (
            ($self->{xml_version} eq '1.0' and
              ((0x0020 <= $num and $num <= 0xD7FF) or
               (0xE000 <= $num and $num <= 0xFFFD) or
               (0x10000 <= $num and $num <= 0x10FFFF) or
               $num == 0x9 or $num == 0xA or $num == 0xD)) or
            ($self->{xml_version} eq '1.1' and
              ((0x0001 <= $num and $num <= 0xD7FF) or
               (0xE000 <= $num and $num <= 0xFFFD) or
               (0x10000 <= $num and $num <= 0x10FFFF)))
          ) {
            my $location;
            __CODE{xp|get-location-from-token::
              $token => $token,
              $result => $location,
            }__;
            my $continue = __DOMCore:ERROR{xp|wf-legal-character::
              DOMCore:location => {$location},
              xp|token => {$token},
              xp|character-number => {$num},
            }__;
            unless ($continue) {
              __CODE{ParseError}__;
            }
          }
          my $ncr = $self->{doc}-><M::Document.createTextNode>
                      (my $char = chr $num);
          $parent-><M::Node.appendChild> ($ncr);
          $vals->{value} .= $char;
        }
      }
      
      // ~ (REFC) { }
    } // _HexadecimalCharacterReferenceAE_
    
    rule _HexadecimalCharacterReferenceEV_ ($vals) {
      ?lexmode HexadecimalCharacterReference;
      
      ~ (Hex) {
        lang:Perl ($v => $token.value) : has-error {
          my $num = hex $v;
          unless (
            ($self->{xml_version} eq '1.0' and
              ((0x0020 <= $num and $num <= 0xD7FF) or
               (0xE000 <= $num and $num <= 0xFFFD) or
               (0x10000 <= $num and $num <= 0x10FFFF) or
               $num == 0x9 or $num == 0xA or $num == 0xD)) or
            ($self->{xml_version} eq '1.1' and
              ((0x0001 <= $num and $num <= 0xD7FF) or
               (0xE000 <= $num and $num <= 0xFFFD) or
               (0x10000 <= $num and $num <= 0x10FFFF)))
          ) {
            my $location;
            __CODE{xp|get-location-from-token::
              $token => $token,
              $result => $location,
            }__;
            my $continue = __DOMCore:ERROR{xp|wf-legal-character::
              DOMCore:location => {$location},
              xp|token => {$token},
              xp|character-number => {$num},
            }__;
            unless ($continue) {
              __CODE{ParseError}__;
            }
          }
          push @{$vals}, chr $num;
        }
      }
      
      // ~ (REFC) { }
    } // _HexadecimalCharacterReferenceEV_
    
    /*
      General entity reference in element's content
    */
    rule _GeneralEntityReferenceEC ($doc, $parent, $ns)
      : recursive
    {
      ?lexmode 'EntityReference';
      
      ~ (Name == 'lt') {
        lang:Perl {
          $parent-><M::Node.appendChild>
                     ($self->{doc}-><M::Document.createTextNode> ('<'));
        }
      } (Name == 'gt') {
        lang:Perl {
          $parent-><M::Node.appendChild>
                     ($self->{doc}-><M::Document.createTextNode> ('>'));
        }
      } (Name == 'amp') {
        lang:Perl {
          $parent-><M::Node.appendChild>
                     ($self->{doc}-><M::Document.createTextNode> ('&'));
        }
      } (Name == 'quot') {
        lang:Perl {
          $parent-><M::Node.appendChild>
                     ($self->{doc}-><M::Document.createTextNode> ('"'));
        }
      } (Name == 'apos') {
        lang:Perl {
          $parent-><M::Node.appendChild>
                     ($self->{doc}-><M::Document.createTextNode> ("'"));
        }
      } (Name) {
        my $er;
        lang:Perl ($name => $token.value) : has-error {
          __CODE{checkNCName:: $name => $name}__;
          
          $er = $doc-><M::Document.createEntityReference>
                           ($name);
          $er-><AS::Node.textContent> ('');
            ## NOTE: When document entity (and entities referenced directly
            ##       or indirectly from it) is parsed, no general entity
            ##       node have its replacement tree.  During general
            ##       entity node collection construction, however,
            ##       some entity node has replacement tree.
          $parent-><M::Node.appendChild> ($er);

          my $ent = $self->{general_entity}->{$name};
          if (not $ent) {  # no entity declaration
            if ($self->{standalone} or not $self->{has_xref}) { # WFC error
              my $location;
              __CODE{xp|get-location-from-token::
                $token => {$token},
                $result => {$location},
              }__;
              my $continue = __DOMCore:ERROR{xp|wf-entity-declared::
                xp|error-token => {$token},
                c|location => {$location},
                xp|name => {$name},
              }__;
              unless ($continue) {
                __CODE{ParseError}__;
              }
            }                 # Otherwise VC error
            push @{$self->{entity}}, <Code::getEmptyEntityState::
                                              $name = $name>;
            $er-><AS::x|EntityReference.isExpanded> (false);

          } else {         # there IS entity declaration
            if (($self->{standalone} or not $self->{has_xref}) and
                $ent->{is_externally_declared} and
                not $self->{entity}->[-1]->{is_externally_declared}) {
              my $location;
              __CODE{xp|get-location-from-token::
                $token => {$token},
                $result => {$location},
              }__;
              my $continue = __DOMCore:ERROR{xp|wf-entity-declared::
                xp|error-token => {$token},
                c|location => {$location},
                xp|name => {$name},
              }__;
              unless ($continue) {
                __CODE{ParseError}__;
              }
            }          
            $er-><AS::x|EntityReference.isExpanded>
                   ($ent->{has_replacement_text});
            push @{$self->{entity}}, <Code::getCopyOfEntityState::
                                            $entity_type = 'general_entity',
                                            $entity_name = $name>;

            if (defined $ent->{notation}) {
              my $location;
              __CODE{xp|get-location-from-token::
                $token => {$token},
                $result => {$location},
              }__;
              my $continue = __c|ERROR{xp|wf-parsed-entity::
                xp|error-token => {$token},
                c|location => {$location},
                xp|name => {$name},
              }__;
              unless ($continue) {  
                __CODE{ParseError}__;
              }
            } # if unparsed entity
            
            if ($ent->{is_opened}) {
              my $location;
              __CODE{xp|get-location-from-token::
                $token => {$token},
                $result => {$location},
              }__;
              my $continue = __c|ERROR{xp|wf-no-recursion::
                xp|error-token => {$token},
                c|location => {$location},
                xp|name => {$name},
              }__;
              unless ($continue) {  
                __CODE{ParseError}__;
              }
              open my $empty, '<', \'';
              $self->{entity}->[-1]->{fh} = $empty;
              $er-><AS::x|EntityReference.isExpanded> (false);
            } # recursive
            $ent->{is_opened} = true;
          } # entity declared
          $self->{location} = $self->{entity}->[-1];
          push @{$self->{entity_token}}, $self->{token};
          $self->{token} = [];
          push @{$self->{entity_char}}, $self->{char};
          $self->{char} = [];
        }

        ?lexmode ElementContent;
        &content ($doc => $doc, $parent => $er, $ns => $ns);
        ~ (#EOF) { }
        lang:Perl {
          $self->{general_entity}->{$self->{entity}->[-1]->{name}}
               ->{is_opened} = false
            if $self->{general_entity}->{$self->{entity}->[-1]->{name}};
          $self->{token} = pop @{$self->{entity_token}};
          $self->{char} = pop @{$self->{entity_char}};
          pop (@{$self->{entity}})->{close_file}->();
          $self->{location} = $self->{entity}->[-1];
        }

        // TODO: Set read-only flag

        ?lexmode EntityReference;
        ?requires-next-token;
      }
      
      ~ (REFC) {
        ?lexmode ElementContent;
      } else {
        ?lexmode ElementContent;
      }
    } // _GeneralEntityReferenceEC
    
    /*
      General entity reference in an attribute value literal
    */
    rule _GeneralEntityReferenceV_ ($vals) {
      ?lexmode EntityReference;
      
      ~ (Name == 'lt') {
        lang:Perl {
          push @{$vals->{nodes}}, $self->{doc}-><M::Document.createTextNode>
                                                  ('<');
          $vals->{value} .= '<';
        }
      } (Name == 'gt') {
        lang:Perl {
          push @{$vals->{nodes}}, $self->{doc}-><M::Document.createTextNode>
                                                  ('>');
          $vals->{value} .= '>';
        }
      } (Name == 'amp') {
        lang:Perl {
          push @{$vals->{nodes}}, $self->{doc}-><M::Document.createTextNode>
                                                  ('&');
          $vals->{value} .= '&';
        }
      } (Name == 'quot') {
        lang:Perl {
          push @{$vals->{nodes}}, $self->{doc}-><M::Document.createTextNode>
                                                  ('"');
          $vals->{value} .= '"';
        }
      } (Name == 'apos') {
        lang:Perl {
          push @{$vals->{nodes}}, $self->{doc}-><M::Document.createTextNode>
                                                  ("'");
          $vals->{value} .= "'";
        }
      } (Name) {
        my $er;
        lang:Perl ($name => $token.value) : has-error {
          __CODE{checkNCName:: $name => $name}__;
          
          $er = $self->{doc}-><M::Document.createEntityReference> ($name);
          $er-><AS::Node.textContent> ('');
            ## NOTE: When document entity (and entities referenced directly
            ##       or indirectly from it) is parsed, no general entity
            ##       node have its replacement tree.  During general
            ##       entity node collection construction, however,
            ##       some entity node has replacement tree.
          my $ent = $self->{general_entity}->{$name};
          if (not $ent) {  # no entity declaration
            if ($self->{standalone} or not $self->{has_xref}) { # WFC error
              my $location;
              __CODE{xp|get-location-from-token::
                $token => {$token},
                $result => {$location},
              }__;
              my $continue = __DOMCore:ERROR{xp|wf-entity-declared::
                xp|error-token => {$token},
                c|location => {$location},
                xp|name => {$name},
              }__;
              unless ($continue) {
                __CODE{ParseError}__;
              }
            }                 # Otherwise VC error
            push @{$self->{entity}}, <Code::getEmptyEntityState::
                                              $name = $name>;
            $er-><AS::x|EntityReference.isExpanded> (false);

          } else {         # there IS entity declaration
            if (($self->{standalone} or not $self->{has_xref}) and
                $ent->{is_externally_declared} and
                not $self->{entity}->[-1]->{is_externally_declared}) {
              my $location;
              __CODE{xp|get-location-from-token::
                $token => {$token},
                $result => {$location},
              }__;
              my $continue = __DOMCore:ERROR{xp|wf-entity-declared::
                xp|error-token => {$token},
                c|location => {$location},
                xp|name => {$name},
              }__;
              unless ($continue) {
                __CODE{ParseError}__;
              }
            }          

            if ($ent->{is_external_entity}) {
              my $location;
              __CODE{xp|get-location-from-token::
                $token => {$token},
                $result => {$location},
              }__;
              my $continue = __c|ERROR{xp|wf-no-external-entity-references::
                xp|error-token => {$token},
                c|location => {$location},
                xp|name => {$name},
              }__;
              unless ($continue) {  
                __CODE{ParseError}__;
              }
              ## NOTE: |xp:wf-parsed-entity| is not checked
            } # if external entity

            $er-><AS::x|EntityReference.isExpanded>
                   ($ent->{has_replacement_text});
            push @{$self->{entity}}, <Code::getCopyOfEntityState::
                                            $entity_type = 'general_entity',
                                            $entity_name = $name>;
            
            if ($ent->{is_opened}) {
              my $location;
              __CODE{xp|get-location-from-token::
                $token => {$token},
                $result => {$location},
              }__;
              my $continue = __c|ERROR{xp|wf-no-recursion::
                xp|error-token => {$token},
                c|location => {$location},
                xp|name => {$name},
              }__;
              unless ($continue) {  
                __CODE{ParseError}__;
              }
              open my $empty, '<', \'';
              $self->{entity}->[-1]->{fh} = $empty;
              $er-><AS::x|EntityReference.isExpanded> (false);
            } # recursive
            $ent->{is_opened} = true;
          }
          push @{$vals->{nodes}}, $er;
          $self->{location} = $self->{entity}->[-1];
          push @{$self->{entity_token}}, $self->{token};
          $self->{token} = [];
          push @{$self->{entity_char}}, $self->{char};
          $self->{char} = [];
        }

        ?lexmode AttributeValueLiteralE;
        &AttributeValueLiteralE_ ($parent => $er, $vals => $vals);       
        ~ (#EOF) { }
        lang:Perl {
          $self->{general_entity}->{$self->{entity}->[-1]->{name}}
               ->{is_opened} = false
            if $self->{general_entity}->{$self->{entity}->[-1]->{name}};
          $self->{token} = pop @{$self->{entity_token}};
          $self->{char} = pop @{$self->{entity_char}};
          pop (@{$self->{entity}})->{close_file}->();
          $self->{location} = $self->{entity}->[-1];
        }

        // TODO: Set read-only flag

        ?lexmode EntityReference;
        ?requires-next-token;
      }
      
      // ~ (REFC) { }
    } // _GeneralEntityReferenceV_
    
    /*
      General entity reference in the replacement text
      of the entity referenced in an attribute value literal
    */
    rule _GeneralEntityReferenceAE_ ($parent, $vals)
    {
      ?lexmode EntityReference;
      
      ~ (Name == 'lt') {
        lang:Perl {
          $parent-><M::Node.appendChild>
                     ($self->{doc}-><M::Document.createTextNode> ('<'));
          $vals->{value} .= '<';
        }
      } (Name == 'gt') {
        lang:Perl {
          $parent-><M::Node.appendChild>
                     ($self->{doc}-><M::Document.createTextNode> ('>'));
          $vals->{value} .= '>';
        }
      } (Name == 'amp') {
        lang:Perl {
          $parent-><M::Node.appendChild>
                     ($self->{doc}-><M::Document.createTextNode> ('&'));
          $vals->{value} .= '&';
        }
      } (Name == 'quot') {
        lang:Perl {
          $parent-><M::Node.appendChild>
                     ($self->{doc}-><M::Document.createTextNode> ('"'));
          $vals->{value} .= '"';
        }
      } (Name == 'apos') {
        lang:Perl {
          $parent-><M::Node.appendChild>
                     ($self->{doc}-><M::Document.createTextNode> ("'"));
          $vals->{value} .= "'";
        }
      } (Name) {
        my $er;
        lang:Perl ($name => $token.value) : has-error {
          __CODE{checkNCName:: $name => $name}__;

          $er = $self->{doc}-><M::Document.createEntityReference> ($name);
          $er-><AS::Node.textContent> ('');
            ## NOTE: When document entity (and entities referenced directly
            ##       or indirectly from it) is parsed, no general entity
            ##       node have its replacement tree.  During general
            ##       entity node collection construction, however,
            ##       some entity node has replacement tree.
          my $ent = $self->{general_entity}->{$name};
          if (not $ent) {  # no entity declaration
            if ($self->{standalone} or not $self->{has_xref}) { # WFC error
              my $location;
              __CODE{xp|get-location-from-token::
                $token => {$token},
                $result => {$location},
              }__;
              my $continue = __DOMCore:ERROR{xp|wf-entity-declared::
                xp|error-token => {$token},
                c|location => {$location},
                xp|name => {$name},
              }__;
              unless ($continue) {
                __CODE{ParseError}__;
              }
            }                 # Otherwise VC error
            push @{$self->{entity}}, <Code::getEmptyEntityState::
                                              $name = $name>;
            $er-><AS::x|EntityReference.isExpanded> (false);

          } else {         # there IS entity declaration
            if (($self->{standalone} or not $self->{has_xref}) and
                $ent->{is_externally_declared} and
                not $self->{entity}->[-1]->{is_externally_declared}) {
              my $location;
              __CODE{xp|get-location-from-token::
                $token => {$token},
                $result => {$location},
              }__;
              my $continue = __DOMCore:ERROR{xp|wf-entity-declared::
                xp|error-token => {$token},
                c|location => {$location},
                xp|name => {$name},
              }__;
              unless ($continue) {
                __CODE{ParseError}__;
              }
            }          

            if ($ent->{is_external_entity}) {
              my $location;
              __CODE{xp|get-location-from-token::
                $token => {$token},
                $result => {$location},
              }__;
              my $continue = __c|ERROR{xp|wf-no-external-entity-references::
                xp|error-token => {$token},
                c|location => {$location},
                xp|name => {$name},
              }__;
              unless ($continue) {  
                __CODE{ParseError}__;
              }
              ## NOTE: |xp:wf-parsed-entity| is not checked
            } # if external entity

            $er-><AS::x|EntityReference.isExpanded>
                   ($ent->{has_replacement_text});
            push @{$self->{entity}}, <Code::getCopyOfEntityState::
                                            $entity_type = 'general_entity',
                                            $entity_name = $name>;
            
            if ($ent->{is_opened}) {
              my $location;
              __CODE{xp|get-location-from-token::
                $token => {$token},
                $result => {$location},
              }__;
              my $continue = __c|ERROR{xp|wf-no-recursion::
                xp|error-token => {$token},
                c|location => {$location},
                xp|name => {$name},
              }__;
              unless ($continue) {  
                __CODE{ParseError}__;
              }
              open my $empty, '<', \'';
              $self->{entity}->[-1]->{fh} = $empty;
              $er-><AS::x|EntityReference.isExpanded> (false);
            } # recursive
            $ent->{is_opened} = true;
          }
          $parent-><M::Node.appendChild> ($er);
          $self->{location} = $self->{entity}->[-1];
          push @{$self->{entity_token}}, $self->{token};
          $self->{token} = [];
          push @{$self->{entity_char}}, $self->{char};
          $self->{char} = [];
        }

        ?lexmode AttributeValueLiteralE;
        &AttributeValueLiteralE_ ($parent => $er, $vals => $vals);       
        ~ (#EOF) { }
        lang:Perl {
          $self->{general_entity}->{$self->{entity}->[-1]->{name}}
               ->{is_opened} = false
            if $self->{general_entity}->{$self->{entity}->[-1]->{name}};
          $self->{token} = pop @{$self->{entity_token}};
          $self->{char} = pop @{$self->{entity_char}};
          pop (@{$self->{entity}})->{close_file}->();
          $self->{location} = $self->{entity}->[-1];
        }

        // TODO: Set read-only flag

        ?lexmode EntityReference;
        ?requires-next-token;
      }
      
      // ~ (REFC) { }
    } // _GeneralEntityReferenceAE_
    
    /*
      General Entity Reference in Literal Entity Value in Entity Declaration
    */
    rule _GeneralEntityReferenceEV_ ($vals) {
      ?lexmode 'EntityReference';
      
      ~ (Name) {
        lang:Perl ($name => $token.value) {
          __CODE{checkNCName:: $name => $name}__;
          push @$vals, $name;
        }
        /*
          WFCs such as Entity Declared are not checked
          <http://www.w3.org/TR/xml11/#bypass>

          Note that violation to the Parsed Entity WFC is an error
          rather than fatal error here.
        */
      }

      // No expansion
      
      // ~ (REFC) { }
    } // _GeneralEntityReferenceEV_

    /*
      Document Type Declaration
    */
    rule _DocumentTypeDeclaration_ ($doc) {
      ?lexmode MarkupDeclaration;
      
      ~ (Name == 'DOCTYPE') { }
      
      ~ (S) { }
      
      // Document type name
      my $name;
      ~ (Name) {
        lang:Perl ($v => $token.value) {
          __CODE{checkQName:: $name => $v}__;
          $name = $v;
        }
      }

      my $node;
      my $decl;
      lang:Perl {
        $self->{docx} = $self->{doc}
                             -><M::Node.getFeature> (<Q::fe:XDoctype>, '3.0');
        $node = $self->{docx}-><M::DocumentXDoctype.createDocumentTypeDefinition>
                                 ($name);
        $decl = $self->{dtdecl} = $node-><M::Node.getFeature>
                                           (<Q::fe:XDoctypeDeclaration>, '3.0');
      }

      my $has_extid;
      ~? (S) {
        ~? (Name == 'PUBLIC') {
          ~ (S) { }
  
          &PubidLiteral ($decl => $decl);
  
          ~ (S) { }
  
          &SystemLiteral ($decl => $decl);
  
          ~? (S) { }

          lang:Perl {
            $self->{has_xref} = true;
            $has_extid = true;
          }
        } (Name == 'SYSTEM') {
          ~ (S) { }
  
          &SystemLiteral ($decl => $decl);
  
          ~? (S) { }

          lang:Perl {
            $self->{has_xref} = true;
            $has_extid = true;
          }
        }
      }

      lang:Perl {
        $self->{dtdef} = $node;
        $self->{doc}-><M::Node.appendChild> ($node);
        $self->{doc_cfg}-><M::c|DOMConfiguration.setParameter>
                            ('schema-type' => <Q::xml-dtd:>);
        ## ISSUE: Should default schema language information be
        ##        preserved by some other flag?
      }
      
      ~? (DSO) {
        &InternalSubset ($doc => $doc, $doctype => $node);

        ~ (DSC) {
          ?lexmode MarkupDeclaration;
        } else {
          ?lexmode MarkupDeclaration;
        }

        ~? (S) { }
      }

      // TODO: Read and process external subset if any.
      lang:Perl {
        $self->{dont_process} = true if $has_extid;
      }

      // ~ (MDC) { }
    } // _DocumentTypeDeclaration_

    /*
      Public Identifier Literal
    */
    rule PubidLiteral ($decl) {
      my $pubid;
      my $pubid_token;
      ~ (LIT) {
        ?lexmode SystemLiteral;

        ~? (STRING) {
          lang:Perl ($v => $token.value) {
            $pubid = $v;
            $pubid_token = $token;
          }
        }

        ~ (LIT) {
          ?lexmode MarkupDeclaration;
        } else {
          ?lexmode MarkupDeclaration;
        }
      } (LITA) {
        ?lexmode SystemLiteralA;

        ~? (STRING) {
          lang:Perl ($v => $token.value) {
            $pubid = $v;
            $pubid_token = $token;
          }
        }

        ~ (LITA) {
          ?lexmode MarkupDeclaration;
        } else {
          ?lexmode MarkupDeclaration;
        }
      }

      if-true ($pubid_token) {
        lang:Perl : has-error {
          if ($pubid =~ m{[^\x20\x0D\x0Aa-zA-Z0-9'()+,./:=?;!*#\@\$_%-]}s) {
            my $location;
            __CODE{xp|get-location-from-token::
              $token => {$pubid_token},
              $result => {$location},
            }__;
                                  ## Should this be other (new) error type?
            my $continue = __DOMCore:ERROR{xp|wf-syntax-error::
              xp|error-token => {$token},
              c|location => {$location},
            }__;
            unless ($continue) {
              __CODE{ParseError}__;
            }
          }

          ## NOTE: U+0009 is syntactically illegal.
          $pubid =~ s/[\x09\x0A\x0D\x20]+/\x20/gs;
          $pubid =~ s/\A\x20//s;
          $pubid =~ s/\x20\z//s;
                 ## NOTE: Bare attribute name is written.
          $decl->public_id ($pubid);
        }
      }
    } // PubidLiteral

    /*
      System Identifier Literal
    */
    rule SystemLiteral ($decl) {
      ~ (LIT) {
        ?lexmode SystemLiteral;
        &_SystemLiteral ($decl => $decl);
      } (LITA) {
        ?lexmode SystemLiteralA;
        &_SystemLiteral ($decl => $decl);
      }
    } // SystemLiteral

    /*
      System Identifier Literal Content

        Used in document type declaration, entity declaration,
        and notation declaration.
    */
    rule _SystemLiteral ($decl) {
      // LIT or LITA

      ~? (STRING) {
        lang:Perl ($v => $token.value) {
          $decl-><AS::x|Entity.systemId> ($v);
          $decl-><AS::x|Entity.manakaiDeclarationBaseURI>
                   ($self->{location}->{base_uri});
        }
      }

      ~ (LIT) {
        ?lexmode MarkupDeclaration;
      } (LITA) {
        ?lexmode MarkupDeclaration;
      } else {
        ?lexmode MarkupDeclaration;
      }
    } // _SystemLiteral

    /*
      DTD Internal Subset
      
        intSubset := *(markupdecl / DeclSep)  ;; [28b]
    */
    rule InternalSubset ($doc, $doctype) {
      ?lexmode DTD;

      ~* (MDO) {
        ?lexmode MarkupDeclaration;

        ~ (Name == 'ELEMENT') {
          &_ElementDeclaration ($doc => $doc);
        } (Name == 'ATTLIST') {
          &_AttlistDeclaration ($doc => $doc, $doctype => $doctype);
        } (Name == 'ENTITY') {
          &_EntityDeclaration ($doc => $doc);
        } (Name == 'NOTATION') {
          &_NotationDeclaration ($doc => $doc);
        }
      } (S) {
        //
      } (CDO) {
        &_CommentDeclarationDTD ($doc => $doc);
      } (PIO) {
        &_ProcessingInstructionDTD ($doc => $doc, $doctype => $doctype);
      } (PERO) {
        ?lexmode EntityReference;

        lang:Perl {
          $self->{has_xref} = true;
          $self->{dont_process} = true;
        }

        ~ (Name) {
          // TODO:             __CODE{checkNCName:: $name => $name}__;

        }

        ~ (REFC) {
          ?lexmode DTD;
        } else {
          ?lexmode DTD;
        }
      }
    } // InternalSubset

    rule _ElementDeclaration ($doc) {
      // ~ (MDO) { }
      // ?lexmode MarkupDeclaration
      // ~ (Name == 'Element') { }

      ~ (S) { }

      ~ (Name) {
        // TODO:             __CODE{checkQName:: $name => $name}__;

      }

      ?lexmode ElementDeclaration;

      ~ (S) { }

      // contentspec
      ~ (MGO) {
        &_ContentModel ($doc => $doc);
      } (Name == 'EMPTY') {

      } (Name == 'ANY') {

      }

      ~? (S) { }

      ~ (MDC) {
        ?lexmode DTD;
      } else {
        ?lexmode DTD;
      }
    } // _ElementDeclaration

    rule _ContentModel ($doc) {
      // ~ (MGO) { }
      
      ~? (S) { }

      ~ (Name) {
        // Element content model
        &_ModelGroup ($doc => $doc)
          : unshift-current-token;

        ~? (OPT) {

        } (REP) {

        } (PLUS) {

        }

      } (MDO) {
        &_ModelGroup ($doc => $doc)
          : unshift-current-token;

        ~? (OPT) {

        } (REP) {

        } (PLUS) {

        }

      } (PCDATA) {
        // Mixed content declaration
        ~? (S) { }

        ~* (OR) {
          ~? (S) { }

          ~ (Name) {
            // TODO: Name & QName check

          }

          ~? (S) { }
        }

        ~ (MGC) { }

        ~? (REP) {
      
        } else {
          // TODO: error if |Name|
        }


      }
    } // _ContentModel

    rule _ModelGroup ($doc)
      : standalone
      : recursive
    {
      // ~ (MGO) { }
      // ~? (S) { }

      &ContentParticle ($doc => $doc);

      ~? (S) { }

      ~? (OR) {
        ~? (S) { }
  
        &ContentParticle ($doc => $doc);

        ~? (S) { }

        ~* (OR) {
          ~? (S) { }

          &ContentParticle ($doc => $doc);

          ~? (S) { }
        }

      } (SEQ) {
        ~? (S) { }
  
        &ContentParticle ($doc => $doc);

        ~? (S) { }

        ~* (SEQ) {
          ~? (S) { }

          &ContentParticle ($doc => $doc);

          ~? (S) { }
        }

      }

      ~ (MGC) { }
    } // _ModelGroup
    
    rule ContentParticle ($doc) {
      ~ (Name) {
        // TODO: Name & QName check

      } (MGO) {
        ~? (S) { }
   
        &_ModelGroup ($doc => $doc);
      }

      ~? (OPT) {

      } (REP) {

      } (PLUS) {

      }
    } // ContentParticle

    /*
      Attribute list declaration
    */
    rule _AttlistDeclaration ($doc, $doctype) {
      // ~ (MDO) { }
      // ~ (Name == 'ATTLIST') { }

      ?lexmode AttlistDeclaration;

      ~ (S) { }

      my $name;
      ~ (Name) {
        lang:Perl ($v => $token.value) {
          __CODE{checkQName:: $name => $v}__;
          $name = $v;
        }
      } else {
        lang:Perl { $name = '#ILLEGAL' }
      }

      my $docxd;
      my $et;
      lang:Perl {
        $et = $doctype-><M::DTDef.getElementTypeDefinitionNode> ($name);
        unless ($et) {
          $docxd = $doc-><M::Node.getFeature> (<Q::fe:XDoctype>, '3.0');
          $et = $docxd-><M::DocumentXDoctype.createElementTypeDefinition>
                          ($name);
          $doctype-><M::DTDef.setElementTypeDefinitionNode> ($et)
            unless $name eq '#ILLEGAL';
        }
      }
  
      ~? (S) { }

      ~* (Name) {
        my $at;
        lang:Perl ($v => $token.value) : has-error {
          __CODE{checkQName:: $name => $v}__;
          $docxd ||= $doc-><M::Node.getFeature>
                             (<Q::fe:XDoctype>, '3.0');
          $at = $docxd-><M::DocumentXDoctype.createAttributeDefinition> ($v);
          if (exists $et-><AG::ETDef.attributeDefinitions>->{$v}) {
            my $location;
            __CODE{xp|get-location-from-token::
              $token => {$token},
              $result => {$location},
            }__;
            my $continue = __c|ERROR{xp|warning-attribute-definition-ignored::
              xp|error-token => {$token},
              c|location => {$location},
              xp|name => {$v},
            }__;
            unless ($continue) {
              __CODE{ParseError}__;
            }            
          } elsif ($self->{dont_process} and not $self->{standalone}) {
            my $location;
            __CODE{xp|get-location-from-token::
              $token => {$token},
              $result => {$location},
            }__;
            my $continue = __c|ERROR{
            xp|warning-attribute-definition-not-processed::
              xp|error-token => {$token},
              c|location => {$location},
              xp|name => {$v},
            }__;
            unless ($continue) {
              __CODE{ParseError}__;
            }            
          } else {
            $et-><M::ETDef.setAttributeDefinitionNode> ($at);
            $self->{attr}->{$name}->{$v} = $at;
          }
        }

        ~ (S) { }
        
        // AttType
        ~ (Name == 'NOTATION') {
          ~ (S) { }

          my $kwd;
          lang:Perl {
            $at-><AS::ATDef.declaredType> (<C::ATDef.NOTATION_ATTR>);
            $kwd = $at-><AG::ATDef.allowedTokens>;
          }

          ~ (EGO) {
            ~? (S) { }

            ~+ (Name) {
              lang:Perl ($v => $token.value) : has-error {
                __CODE{checkNCName:: $name => $v}__;
                push @$kwd, $v;
              }

              ~? (S) { }
            } (OR) : separator {
              ~? (S) { }
            }

            ~ (EGC) { }
          }

        } (Name) {
          my $type;
          lang:Perl ($v => $token.value) : has-error {
            my $map = {
              CDATA => <C::ATDef.CDATA_ATTR>,
              ID => <C::ATDef.ID_ATTR>,
              IDREF => <C::ATDef.IDREF_ATTR>,
              IDREFS => <C::ATDef.IDREFS_ATTR>,
              ENTITY => <C::ATDef.ENTITY_ATTR>,
              ENTITIES => <C::ATDef.ENTITIES_ATTR>,
              NMTOKEN => <C::ATDef.NMTOKEN_ATTR>,
              NMTOKENS => <C::ATDef.NMTOKENS_ATTR>,
            };
            if ($map->{$v}) {
              $at-><AS::ATDef.declaredType> ($map->{$v});
            } else {
              ## TODO: Exception
            }
          }
        
        } (EGO) {
          ?lexmode Enumeration;

          ~? (S) { }

          my $kwd;
          lang:Perl {
            $at-><AS::ATDef.declaredType> (<C::ATDef.ENUMERATION_ATTR>);
            $kwd = $at-><AG::ATDef.allowedTokens>;
          }

          ~+ (Nmtoken) {
            lang:Perl ($v => $token.value) {
              push @$kwd, $v;
            }

            ~? (S) { }
          } (OR) : separator {
            ~? (S) { }
          }

          ~ (EGC) {
            ?lexmode AttlistDeclaration;
          } else {
            ?lexmode AttlistDeclaration;
          }

        }

        ~ (S) { }

        // DefaultDecl
        ~ (RNI) {
          ~ (Name == 'REQUIRED') {
            lang:Perl {
              $at-><AS::ATDef.defaultType> (<C::ATDef.REQUIRED_DEFAULT>);
            }
          } (Name == 'IMPLIED') {
            lang:Perl {
              $at-><AS::ATDef.defaultType> (<C::ATDef.IMPLIED_DEFAULT>);
            }
          } (Name == 'FIXED') {
            ~ (S) { }

            lang:Perl {
              $at-><AS::ATDef.defaultType> (<C::ATDef.FIXED_DEFAULT>);
            }
            
            ~ (LIT) {
              my $vals;
              lang:Perl {
                $vals = {nodes => [], value => ''};
              }

              &_AttributeValueSpecification_ ($doc => $doc, $vals => $vals);

              lang:Perl {
                for (@{$vals->{nodes}}) {
                  $at-><M::Node.appendChild> ($_);
                }
              }

              ~ (LIT) {
                ?lexmode AttlistDeclaration;
              } else {
                ?lexmode AttlistDeclaration;
              }
            } (LITA) {
              my $vals;
              lang:Perl {
                $vals = {nodes => [], value => ''};
              }

              &_AttributeValueSpecificationA_ ($doc => $doc, $vals => $vals);

              lang:Perl {
                for (@{$vals->{nodes}}) {
                  $at-><M::Node.appendChild> ($_);
                }
              }

              ~ (LITA) {
                ?lexmode AttlistDeclaration;
              } else {
                ?lexmode AttlistDeclaration;
              }
            }
          }

        } (LIT) {
          my $vals;
          lang:Perl {
            $at-><AS::ATDef.defaultType> (<C::ATDef.EXPLICIT_DEFAULT>);
            $vals = {nodes => [], value => ''};
          }

          &_AttributeValueSpecification_ ($doc => $doc, $vals => $vals);

          lang:Perl {
            for (@{$vals->{nodes}}) {
              $at-><M::Node.appendChild> ($_);
            }
          }

          ~ (LIT) {
            ?lexmode AttlistDeclaration;
          } else {
            ?lexmode AttlistDeclaration;
          }
        } (LITA) {
          my $vals;
          lang:Perl {
            $at-><AS::ATDef.defaultType> (<C::ATDef.EXPLICIT_DEFAULT>);
            $vals = {nodes => [], value => ''};
          }

          &_AttributeValueSpecificationA_ ($doc => $doc, $vals => $vals);

          lang:Perl {
            for (@{$vals->{nodes}}) {
              $at-><M::Node.appendChild> ($_);
            }
          }

          ~ (LITA) {
            ?lexmode AttlistDeclaration;
          } else {
            ?lexmode AttlistDeclaration;
          }
        }

      } (S) : separator : terminator? {
        //
      }

      ~ (MDC) {
        ?lexmode DTD;
      } else {
        ?lexmode DTD;
      }
    } // _AttlistDeclaration

    /*
      Entity Declaration
    */
    rule _EntityDeclaration ($doc) {
      // ~ (MDO) { }
      // ~ (Name == ENTITY) { }

      ~ (S) { }

      my $is_param_entity;
      my $decl;
      lang:Perl {
        $decl = {
          name => '#ILLEGAL',
          reptxt => \'',
          is_external_entity => false,
          document_uri => $self->{location}->{document_uri},
          base_uri => $self->{location}->{base_uri},
        };
      }

      ~? (PERO) {
        ~ (S) { }
        lang:Perl {
          $is_param_entity = $decl->{is_param_entity} = true;
        }
      }

      /*
        TODO: Set |$decl->{is_externally_declared}| flag
              and |Entity.isExternallyDeclared| attribute
              for entity declarations in external subset or
              in parameter entity.
      */

      ~ (Name) {
        lang:Perl ($v => $token.value) {
          __CODE{checkNCName:: $name => $v}__;
          $decl->{name} = $v;
        }
      } 

      my $node;
      lang:Perl {
        $node =
        $decl->{node} = $self->{docx}-><M::DocumentXDoctype.createGeneralEntity>
                                         ($decl->{name});
        ## TODO: Parameter entity...
      }

      ~ (S) { }

      ~ (LIT) {
        &_EntityValue ($doc => $doc, $decl => $decl);
      } (LITA) {
        &_EntityValueA ($doc => $doc, $decl => $decl);
      } (Name == 'PUBLIC') {
        ~ (S) { }

        &PubidLiteral ($decl => $node);

        ~ (S) { }

        &SystemLiteral ($decl => $node);

        lang:Perl {
          $decl->{is_external_entity} = true;
        }
      } (Name == 'SYSTEM') {
        ~ (S) { }

        &SystemLiteral ($decl => $node);

        lang:Perl {
          $decl->{is_external_entity} = true;
        }
      }

      ~? (S) {
        ~? (Name == 'NDATA') {
          if-true ($is_param_entity) {
            lang:Perl : has-error {
              my $location;
              __CODE{xp|get-location-from-token::
                $token => {$token},
                $result => {$location},
              }__;
              my $continue = __DOMCore:ERROR{xp|wf-syntax-error::
                xp|error-token => {$token},
                c|location => {$location},
              }__;
              unless ($continue) {
                __CODE{ParseError}__;
              }
            }
          }

          ~ (S) { }
  
          ~ (Name) {
            lang:Perl ($v => $token.value) : has-error {
              __CODE{checkNCName:: $name => $v}__;
              $decl->{notation} = $v;
              $decl->{node}-><AG::x|Entity.notationName> ($v);
            }
          }

          ~? (S) { }
        }
      }

      lang:Perl : has-error {
        if ($self->{$decl->{is_param_entity} ? 'param_entity' : 'general_entity'}
                 ->{$decl->{name}}) {
          ## Predefined entity
          if (not $decl->{is_param_entity} and
              {lt => true, gt => true, amp => true,
               quot => true, apos => true}->{$decl->{name}}) {
            if ($decl->{is_external_entity}) {
              my $location;
              __CODE{xp|get-location-from-token::
                $token => {$token},
                $result => {$location},
              }__;
              my $continue = __c|ERROR{xp|error-internal-predefined-entity::
                xp|error-token => {$token},
                c|location => {$location},
                xp|name => {$decl->{name}},
              }__;
              unless ($continue) {
                __CODE{ParseError}__;
              }              
            } elsif (
              not ({gt => true, apos => true, quot => true}->{$decl->{name}} and
                   ${$decl->{reptxt}} eq {
                     gt => '>', apos => "'", quot => '"',
                   }->{$decl->{name}}) and
              not (${$decl->{reptxt}} =~ /\A&#0*@{[{
                     lt => '60', gt => '62', amp => '38',
                     apos => '39', quot => '34',
                   }->{$decl->{name}}]};\z/) and
              not (${$decl->{reptxt}} =~ /\A&#x0*(?:(?i)@{[{
                     lt => '3C', gt => '3E', amp => '26',
                     apos => '27', quot => '22',
                   }->{$decl->{name}}]});\z/)
            ) {
              ## NOTE: See "SuikaWiki - Predefined Entities"
              ##       "http://suika.fam.cx/gate/2005/sw/%E5%AE%9A%E7%BE%A9%E6%B8%88%E5%AE%9F%E4%BD%93".
              my $location;
              __CODE{xp|get-location-from-token::
                $token => {$token},
                $result => {$location},
              }__;
              my $continue = __c|ERROR{xp|error-malformed-predefined-entity::
                xp|error-token => {$token},
                c|location => {$location},
                xp|name => {$decl->{name}},
                xp|replacement-text => {${$decl->{reptxt}}},
              }__;
              unless ($continue) {
                __CODE{ParseError}__;
              }
            }
            $self->{dtdecl}->{<H::mn:node>}->{{
              lt => <H::d|hasLtDeclaration>,
              gt => <H::d|hasGtDeclaration>,
              amp => <H::d|hasAmpDeclaration>,
              apos => <H::d|hasAposDeclaration>,
              quot => <H::d|hasQuotDeclaration>,
            }->{$decl->{name}}} = true;
          } else {  ## Dupulicating declaration
            my $location;
            __CODE{xp|get-location-from-token::
              $token => {$token},
              $result => {$location},
            }__;
            my $continue = __c|ERROR{xp|warning-entity-declaration-ignored::
              xp|error-token => {$token},
              c|location => {$location},
              xp|name => {$decl->{name}},
            }__;
            unless ($continue) {
              __CODE{ParseError}__;
            }
          }
        } elsif ($self->{dont_process} and not $self->{standalone}) {
          ## TODO: |standalone| and parameter entities??
          my $location;
          __CODE{xp|get-location-from-token::
            $token => {$token},
            $result => {$location},
          }__;
          my $continue = __c|ERROR{xp|warning-entity-declaration-not-processed::
            xp|error-token => {$token},
            c|location => {$location},
            xp|name => {$decl->{name}},
          }__;
          unless ($continue) {
            __CODE{ParseError}__;
          }            
        } else {
          $self->{$decl->{is_param_entity} ? 'param_entity' : 'general_entity'}
               ->{$decl->{name}} = $decl;
          $self->{dtdef}-><M::DTDef.setGeneralEntityNode> ($decl->{node})
            unless $decl->{is_param_entity};
        }
      }

      ~ (MDC) {
        ?lexmode DTD;
      } else {
        ?lexmode DTD;
      }
    } // _EntityDeclaration

    /*
      Notation Declaration
    */
    rule _NotationDeclaration {
      // ~ (MDO) { }
      // ~ (Name == NOTATION) { }

      ~ (S) { }

      my $name;
      ~ (Name) {
        lang:Perl ($v => $token.value) : has-error {
          __CODE{checkNCName:: $name => $v}__;
          $name = $v;
        }
      } else {
        lang:Perl {
          $name = '#INVALID';
        }
      }

      ~ (S) { }

      lang:Perl {
        $decl = $self->{docx}-><M::DocumentXDoctype.createNotation> ($name);
      }

      ~ (Name == 'PUBLIC') {
        ~ (S) { }

        &PubidLiteral ($decl => $decl);

        ~? (S) {
          ~? (LIT) {
            ?lexmode SystemLiteral;
            &_SystemLiteral ($decl => $decl);

            ~? (S) { }
          } (LITA) {
            ?lexmode SystemLiteralA;
            &_SystemLiteral ($decl => $decl);

            ~? (S) { }
          }
        }
      } (Name == 'SYSTEM') {
        ~ (S) { }

        &SystemLiteral ($decl => $decl);

        ~? (S) { }
      }

      lang:Perl : has-error {
        if ($self->{dtdef}-><M::DTDef.getNotationNode> ($name)) {
          ## Dupulication
          my $location;
          __CODE{xp|get-location-from-token::
            $token => {$token},
            $result => {$location},
          }__;
          my $continue = __c|ERROR{xp|vc-unique-notation-name::
            xp|error-token => {$token},
            c|location => {$location},
            xp|name => {$name},
          }__;
          unless ($continue) {
            __CODE{ParseError}__;
          }
        } else {
          $self->{dtdef}-><M::DTDef.setNotationNode> ($decl);
        }
      }

      ~ (MDC) {
        ?lexmode DTD;
      } else {
        ?lexmode DTD;
      }
    } // _NotationDeclaration
 
    rule _EntityValue ($decl) {
      ?lexmode EntityValue;

      my $vals;
      my $reptxt;
      lang:Perl {
        $vals = [];
        $reptxt = '';
      }

      ~* (STRING) {
        lang:Perl ($v => $token.value) {
          $reptxt .= $v;
        }
      } (PERO) {
        ?lexmode EntityReference;

        lang:Perl {
          $self->{has_xref} = true;
          $self->{dont_process} = true;
        }
     
        // TODO: Expand or wferror if internal subset

        ~ (Name) {

          // Note that external subset and parameter entities are not supported
          lang:Perl ($name => $token.value) : has-error {
            __CODE{checkNCName:: $name => $name}__;
            my $location;
            __CODE{xp|get-location-from-token::
              $token => {$token},
              $result => {$location},
            }__;
            my $continue = __c|ERROR{xp|wf-pes-in-internal-subset::
              xp|error-token => {$token},
              c|location => {$location},
              xp|name => {$name},
            }__;
            unless ($continue) {
              __CODE{ParseError}__;
            }
          }
        }

        ~ (REFC) {
          ?lexmode EntityValue;
        } else {
          ?lexmode EntityValue;
        }
      } (HCRO) {
        &_HexadecimalCharacterReferenceEV_ ($vals => $vals);

        lang:Perl {
          $reptxt .= $vals->[-1];
        }

        ~ (REFC) {
          ?lexmode EntityValue;
        } else {
          ?lexmode EntityValue;
        }
      } (CRO) {
        &_NumericCharacterReferenceEV_ ($vals => $vals);
 
        lang:Perl {
          $reptxt .= $vals->[-1];
        }

        ~ (REFC) {
          ?lexmode EntityValue;
        } else {
          ?lexmode EntityValue;
        }
      } (ERO) {
        &_GeneralEntityReferenceEV_ ($vals => $vals);

        lang:Perl {
          $reptxt .= '&' . $vals->[-1] . ';';
        }

        ~ (REFC) {
          ?lexmode EntityValue;
        } else {
          ?lexmode EntityValue;
        }
      }

      ~ (LIT) {
        ?lexmode MarkupDeclaration;
      } (LITA) {
        ?lexmode MarkupDeclaration;
      } else {
        ?lexmode MarkupDeclaration;
      }

      lang:Perl {
        $decl->{reptxt} = \$reptxt;
        $decl->{has_replacement_text} = true;
      }
    } // _EntityValue

    rule _EntityValueA ($decl) {
      ?lexmode EntityValueA;

      my $vals;
      my $reptxt;
      lang:Perl {
        $vals = [];
        $reptxt = '';
      }

      ~* (STRING) {
        lang:Perl ($v => $token.value) {
          $reptxt .= $v;
        }
      } (PERO) {
        ?lexmode EntityReference;

        lang:Perl {
          $self->{has_xref} = true;
          $self->{dont_process} = true;
        }

        // TODO: implement this
        ~ (Name) {

          // Note that external subset and parameter entities are not supported
          lang:Perl ($name => $token.value) : has-error {
            __CODE{checkNCName:: $name => $name}__;
            my $location;
            __CODE{xp|get-location-from-token::
              $token => {$token},
              $result => {$location},
            }__;
            my $continue = __c|ERROR{xp|wf-pes-in-internal-subset::
              xp|error-token => {$token},
              c|location => {$location},
              xp|name => {$name},
            }__;
            unless ($continue) {
              __CODE{ParseError}__;
            }
          }
        }

        ~ (REFC) {
          ?lexmode EntityValueA;
        } else {
          ?lexmode EntityValueA;
        }
      } (HCRO) {
        &_HexadecimalCharacterReferenceEV_ ($vals => $vals);

        lang:Perl {
          $reptxt .= $vals->[-1];
        }


        ~ (REFC) {
          ?lexmode EntityValueA;
        } else {
          ?lexmode EntityValueA;
        }
      } (CRO) {
        &_NumericCharacterReferenceEV_ ($vals => $vals);

        lang:Perl {
          $reptxt .= $vals->[-1];
        }

        ~ (REFC) {
          ?lexmode EntityValueA;
        } else {
          ?lexmode EntityValueA;
        }
      } (ERO) {
        &_GeneralEntityReferenceEV_ ($vals => $vals);

        lang:Perl {
          $reptxt .= '&' . $vals->[-1] . ';';
        }

        ~ (REFC) {
          ?lexmode EntityValueA;
        } else {
          ?lexmode EntityValueA;
        }
      }

      ~ (LITA) {
        ?lexmode MarkupDeclaration;
      } else {
        ?lexmode MarkupDeclaration;
      }

      lang:Perl {
        $decl->{reptxt} = \$reptxt;
        $decl->{has_replacement_text} = true;
      }
    } // _EntityValueA

    
    /*
      XML Name
    */
    lexmode NameChar {
      $NameStartChar10 := [
        '_' ':'
        // Letter
          // BaseChar
          U+0041..U+005A U+0061..U+007A U+00C0..U+00D6
          U+00D8..U+00F6 U+00F8..U+00FF U+0100..U+0131
          U+0134..U+013E U+0141..U+0148 U+014A..U+017E
          U+0180..U+01C3 U+01CD..U+01F0 U+01F4..U+01F5
          U+01FA..U+0217 U+0250..U+02A8 U+02BB..U+02C1
          U+0386 U+0388..U+038A U+038C U+038E..U+03A1
          U+03A3..U+03CE U+03D0..U+03D6 U+03DA U+03DC
          U+03DE U+03E0 U+03E2..U+03F3 U+0401..U+040C
          U+040E..U+044F U+0451..U+045C U+045E..U+0481
          U+0490..U+04C4 U+04C7..U+04C8 U+04CB..U+04CC
          U+04D0..U+04EB U+04EE..U+04F5 U+04F8..U+04F9
          U+0531..U+0556 U+0559 U+0561..U+0586
          U+05D0..U+05EA U+05F0..U+05F2 U+0621..U+063A
          U+0641..U+064A U+0671..U+06B7 U+06BA..U+06BE
          U+06C0..U+06CE U+06D0..U+06D3 U+06D5
          U+06E5..U+06E6 U+0905..U+0939 U+093D
          U+0958..U+0961 U+0985..U+098C U+098F..U+0990
          U+0993..U+09A8 U+09AA..U+09B0 U+09B2
          U+09B6..U+09B9 U+09DC..U+09DD U+09DF..U+09E1
          U+09F0..U+09F1 U+0A05..U+0A0A U+0A0F..U+0A10
          U+0A13..U+0A28 U+0A2A..U+0A30 U+0A32..U+0A33
          U+0A35..U+0A36 U+0A38..U+0A39 U+0A59..U+0A5C
          U+0A5E U+0A72..U+0A74 U+0A85..U+0A8B U+0A8D
          U+0A8F..U+0A91 U+0A93..U+0AA8 U+0AAA..U+0AB0
          U+0AB2..U+0AB3 U+0AB5..U+0AB9 U+0ABD U+0AE0
          U+0B05..U+0B0C U+0B0F..U+0B10 U+0B13..U+0B28
          U+0B2A..U+0B30 U+0B32..U+0B33 U+0B36..U+0B39
          U+0B3D U+0B5C..U+0B5D U+0B5F..U+0B61
          U+0B85..U+0B8A U+0B8E..U+0B90 U+0B92..U+0B95
          U+0B99..U+0B9A U+0B9C U+0B9E..U+0B9F
          U+0BA3..U+0BA4 U+0BA8..U+0BAA U+0BAE..U+0BB5
          U+0BB7..U+0BB9 U+0C05..U+0C0C U+0C0E..U+0C10
          U+0C12..U+0C28 U+0C2A..U+0C33 U+0C35..U+0C39
          U+0C60..U+0C61 U+0C85..U+0C8C U+0C8E..U+0C90
          U+0C92..U+0CA8 U+0CAA..U+0CB3 U+0CB5..U+0CB9
          U+0CDE U+0CE0..U+0CE1 U+0D05..U+0D0C
          U+0D0E..U+0D10 U+0D12..U+0D28 U+0D2A..U+0D39
          U+0D60..U+0D61 U+0E01..U+0E2E U+0E30
          U+0E32..U+0E33 U+0E40..U+0E45 U+0E81..U+0E82
          U+0E84 U+0E87..U+0E88 U+0E8A U+0E8D
          U+0E94..U+0E97 U+0E99..U+0E9F U+0EA1..U+0EA3
          U+0EA5 U+0EA7 U+0EAA..U+0EAB U+0EAD..U+0EAE
          U+0EB0 U+0EB2..U+0EB3 U+0EBD U+0EC0..U+0EC4
          U+0F40..U+0F47 U+0F49..U+0F69 U+10A0..U+10C5
          U+10D0..U+10F6 U+1100 U+1102..U+1103
          U+1105..U+1107 U+1109 U+110B..U+110C
          U+110E..U+1112 U+113C U+113E U+1140 U+114C
          U+114E U+1150 U+1154..U+1155 U+1159
          U+115F..U+1161 U+1163 U+1165 U+1167 U+1169
          U+116D..U+116E U+1172..U+1173 U+1175 U+119E
          U+11A8 U+11AB U+11AE..U+11AF U+11B7..U+11B8
          U+11BA U+11BC..U+11C2 U+11EB U+11F0 U+11F9
          U+1E00..U+1E9B U+1EA0..U+1EF9 U+1F00..U+1F15
          U+1F18..U+1F1D U+1F20..U+1F45 U+1F48..U+1F4D
          U+1F50..U+1F57 U+1F59 U+1F5B U+1F5D
          U+1F5F..U+1F7D U+1F80..U+1FB4 U+1FB6..U+1FBC
          U+1FBE U+1FC2..U+1FC4 U+1FC6..U+1FCC
          U+1FD0..U+1FD3 U+1FD6..U+1FDB U+1FE0..U+1FEC
          U+1FF2..U+1FF4 U+1FF6..U+1FFC U+2126
          U+212A..U+212B U+212E U+2180..U+2182
          U+3041..U+3094 U+30A1..U+30FA U+3105..U+312C
          U+AC00..U+D7A3
          // Ideographic
          U+4E00..U+9FA5 U+3007 U+3021..U+3029
      ];
      $NameChar10 := [
        '.' '-' '_' ':'
        // Letter
          // BaseChar
          U+0041..U+005A U+0061..U+007A U+00C0..U+00D6
          U+00D8..U+00F6 U+00F8..U+00FF U+0100..U+0131
          U+0134..U+013E U+0141..U+0148 U+014A..U+017E
          U+0180..U+01C3 U+01CD..U+01F0 U+01F4..U+01F5
          U+01FA..U+0217 U+0250..U+02A8 U+02BB..U+02C1
          U+0386 U+0388..U+038A U+038C U+038E..U+03A1
          U+03A3..U+03CE U+03D0..U+03D6 U+03DA U+03DC
          U+03DE U+03E0 U+03E2..U+03F3 U+0401..U+040C
          U+040E..U+044F U+0451..U+045C U+045E..U+0481
          U+0490..U+04C4 U+04C7..U+04C8 U+04CB..U+04CC
          U+04D0..U+04EB U+04EE..U+04F5 U+04F8..U+04F9
          U+0531..U+0556 U+0559 U+0561..U+0586
          U+05D0..U+05EA U+05F0..U+05F2 U+0621..U+063A
          U+0641..U+064A U+0671..U+06B7 U+06BA..U+06BE
          U+06C0..U+06CE U+06D0..U+06D3 U+06D5
          U+06E5..U+06E6 U+0905..U+0939 U+093D
          U+0958..U+0961 U+0985..U+098C U+098F..U+0990
          U+0993..U+09A8 U+09AA..U+09B0 U+09B2
          U+09B6..U+09B9 U+09DC..U+09DD U+09DF..U+09E1
          U+09F0..U+09F1 U+0A05..U+0A0A U+0A0F..U+0A10
          U+0A13..U+0A28 U+0A2A..U+0A30 U+0A32..U+0A33
          U+0A35..U+0A36 U+0A38..U+0A39 U+0A59..U+0A5C
          U+0A5E U+0A72..U+0A74 U+0A85..U+0A8B U+0A8D
          U+0A8F..U+0A91 U+0A93..U+0AA8 U+0AAA..U+0AB0
          U+0AB2..U+0AB3 U+0AB5..U+0AB9 U+0ABD U+0AE0
          U+0B05..U+0B0C U+0B0F..U+0B10 U+0B13..U+0B28
          U+0B2A..U+0B30 U+0B32..U+0B33 U+0B36..U+0B39
          U+0B3D U+0B5C..U+0B5D U+0B5F..U+0B61
          U+0B85..U+0B8A U+0B8E..U+0B90 U+0B92..U+0B95
          U+0B99..U+0B9A U+0B9C U+0B9E..U+0B9F
          U+0BA3..U+0BA4 U+0BA8..U+0BAA U+0BAE..U+0BB5
          U+0BB7..U+0BB9 U+0C05..U+0C0C U+0C0E..U+0C10
          U+0C12..U+0C28 U+0C2A..U+0C33 U+0C35..U+0C39
          U+0C60..U+0C61 U+0C85..U+0C8C U+0C8E..U+0C90
          U+0C92..U+0CA8 U+0CAA..U+0CB3 U+0CB5..U+0CB9
          U+0CDE U+0CE0..U+0CE1 U+0D05..U+0D0C
          U+0D0E..U+0D10 U+0D12..U+0D28 U+0D2A..U+0D39
          U+0D60..U+0D61 U+0E01..U+0E2E U+0E30
          U+0E32..U+0E33 U+0E40..U+0E45 U+0E81..U+0E82
          U+0E84 U+0E87..U+0E88 U+0E8A U+0E8D
          U+0E94..U+0E97 U+0E99..U+0E9F U+0EA1..U+0EA3
          U+0EA5 U+0EA7 U+0EAA..U+0EAB U+0EAD..U+0EAE
          U+0EB0 U+0EB2..U+0EB3 U+0EBD U+0EC0..U+0EC4
          U+0F40..U+0F47 U+0F49..U+0F69 U+10A0..U+10C5
          U+10D0..U+10F6 U+1100 U+1102..U+1103
          U+1105..U+1107 U+1109 U+110B..U+110C
          U+110E..U+1112 U+113C U+113E U+1140 U+114C
          U+114E U+1150 U+1154..U+1155 U+1159
          U+115F..U+1161 U+1163 U+1165 U+1167 U+1169
          U+116D..U+116E U+1172..U+1173 U+1175 U+119E
          U+11A8 U+11AB U+11AE..U+11AF U+11B7..U+11B8
          U+11BA U+11BC..U+11C2 U+11EB U+11F0 U+11F9
          U+1E00..U+1E9B U+1EA0..U+1EF9 U+1F00..U+1F15
          U+1F18..U+1F1D U+1F20..U+1F45 U+1F48..U+1F4D
          U+1F50..U+1F57 U+1F59 U+1F5B U+1F5D
          U+1F5F..U+1F7D U+1F80..U+1FB4 U+1FB6..U+1FBC
          U+1FBE U+1FC2..U+1FC4 U+1FC6..U+1FCC
          U+1FD0..U+1FD3 U+1FD6..U+1FDB U+1FE0..U+1FEC
          U+1FF2..U+1FF4 U+1FF6..U+1FFC U+2126
          U+212A..U+212B U+212E U+2180..U+2182
          U+3041..U+3094 U+30A1..U+30FA U+3105..U+312C
          U+AC00..U+D7A3
          // Ideographic
          U+4E00..U+9FA5 U+3007 U+3021..U+3029
        // Digit
        U+0030..U+0039 U+0660..U+0669 U+06F0..U+06F9
        U+0966..U+096F U+09E6..U+09EF U+0A66..U+0A6F
        U+0AE6..U+0AEF U+0B66..U+0B6F U+0BE7..U+0BEF
        U+0C66..U+0C6F U+0CE6..U+0CEF U+0D66..U+0D6F
        U+0E50..U+0E59 U+0ED0..U+0ED9 U+0F20..U+0F29
        // CombiningChar
        U+0300..U+0345 U+0360..U+0361 U+0483..U+0486
        U+0591..U+05A1 U+05A3..U+05B9 U+05BB..U+05BD
        U+05BF U+05C1..U+05C2 U+05C4 U+064B..U+0652
        U+0670 U+06D6..U+06DC U+06DD..U+06DF
        U+06E0..U+06E4 U+06E7..U+06E8 U+06EA..U+06ED
        U+0901..U+0903 U+093C U+093E..U+094C U+094D
        U+0951..U+0954 U+0962..U+0963 U+0981..U+0983
        U+09BC U+09BE U+09BF U+09C0..U+09C4
        U+09C7..U+09C8 U+09CB..U+09CD U+09D7
        U+09E2..U+09E3 U+0A02 U+0A3C U+0A3E U+0A3F
        U+0A40..U+0A42 U+0A47..U+0A48 U+0A4B..U+0A4D
        U+0A70..U+0A71 U+0A81..U+0A83 U+0ABC
        U+0ABE..U+0AC5 U+0AC7..U+0AC9 U+0ACB..U+0ACD
        U+0B01..U+0B03 U+0B3C U+0B3E..U+0B43
        U+0B47..U+0B48 U+0B4B..U+0B4D U+0B56..U+0B57
        U+0B82..U+0B83 U+0BBE..U+0BC2 U+0BC6..U+0BC8
        U+0BCA..U+0BCD U+0BD7 U+0C01..U+0C03
        U+0C3E..U+0C44 U+0C46..U+0C48 U+0C4A..U+0C4D
        U+0C55..U+0C56 U+0C82..U+0C83 U+0CBE..U+0CC4
        U+0CC6..U+0CC8 U+0CCA..U+0CCD U+0CD5..U+0CD6
        U+0D02..U+0D03 U+0D3E..U+0D43 U+0D46..U+0D48
        U+0D4A..U+0D4D U+0D57 U+0E31 U+0E34..U+0E3A
        U+0E47..U+0E4E U+0EB1 U+0EB4..U+0EB9
        U+0EBB..U+0EBC U+0EC8..U+0ECD U+0F18..U+0F19
        U+0F35 U+0F37 U+0F39 U+0F3E U+0F3F
        U+0F71..U+0F84 U+0F86..U+0F8B U+0F90..U+0F95
        U+0F97 U+0F99..U+0FAD U+0FB1..U+0FB7 U+0FB9
        U+20D0..U+20DC U+20E1 U+302A..U+302F U+3099
        U+309A
        // Extender
        U+00B7 U+02D0 U+02D1 U+0387 U+0640 U+0E46
        U+0EC6 U+3005 U+3031..U+3035 U+309D..U+309E
        U+30FC..U+30FE
      ];
      
      $NameStartChar11 := [
        ':' '_'
        'A' 'B' 'C' 'D' 'E' 'F' 'G' 'H' 'I' 'J' 'K' 'L' 'M'
        'N' 'O' 'P' 'Q' 'R' 'S' 'T' 'U' 'V' 'W' 'X' 'Y' 'Z'
        'a' 'b' 'c' 'd' 'e' 'f' 'g' 'h' 'i' 'j' 'k' 'l' 'm'
        'n' 'o' 'p' 'q' 'r' 's' 't' 'u' 'v' 'w' 'x' 'y' 'z'
        U+00C0..U+00D6 U+00D8..U+00F6 U+00F8..U+02FF
        U+0370..U+037D U+037F..U+1FFF U+200C..U+200D
        U+2070..U+218F U+2C00..U+2FEF U+3001..U+D7FF
        U+F900..U+FDCF U+FDF0..U+FFFD U+10000..U+EFFFF
      ];
      $NameChar11 := [
        '-' '.' '0' '1' '2' '3' '4' '5' '6' '7' '8' '9'
        U+00B7 U+0300..U+036F U+203F..U+2040
        // NameStartChar
        ':' '_'
        'A' 'B' 'C' 'D' 'E' 'F' 'G' 'H' 'I' 'J' 'K' 'L' 'M'
        'N' 'O' 'P' 'Q' 'R' 'S' 'T' 'U' 'V' 'W' 'X' 'Y' 'Z'
        'a' 'b' 'c' 'd' 'e' 'f' 'g' 'h' 'i' 'j' 'k' 'l' 'm'
        'n' 'o' 'p' 'q' 'r' 's' 't' 'u' 'v' 'w' 'x' 'y' 'z'
        U+00C0..U+00D6 U+00D8..U+00F6 U+00F8..U+02FF
        U+0370..U+037D U+037F..U+1FFF U+200C..U+200D
        U+2070..U+218F U+2C00..U+2FEF U+3001..U+D7FF
        U+F900..U+FDCF U+FDF0..U+FFFD U+10000..U+EFFFF
      ];
    } // NameChar

    lexmode Name
      : extends => 'NameChar'
    {
      Name : value := $NameStartChar11 $NameChar11*;
    } // Name

    lexmode Nmtoken
      : extends => 'NameChar'
    {
      Nmtoken : value := $NameChar11*;
    } // Nmtoken
    
    /*
      S
    */
    lexmode S {
      $s := [U+0009 U+000A U+000D U+0020];
      S := $s+;
    } // S
    
    /*
      Document end scanning mode
    */
    lexmode DocumentEnd
      : standalone
      : extends => 'S'
    {
      /*
        Processing instruction
      */
      PIO := ['<'] ['?'];
      
      /*
        Comment declaration
      */
      CDO := ['<'] ['!'] ['-'] ['-'];
    } // DocumentEnd

    /*
      Document misc scanning mode
      
      This mode scans |Misc| constructions as well
      as document element's start tag.
    */
    lexmode DocumentMisc
      : standalone
      : extends => 'DocumentEnd'
    {
      /*
        Document element start tag
      */
      STAGO := ['<'];
    } // DocumentMisc
    
    /*
      Document prolog scanning mode
    */
    lexmode DocumentProlog
      : standalone
      : extends => 'DocumentMisc'
    {
      /*
        |DOCTYPE| declaration
      */
      MDO := ['<'] ['!'];
    } // DocumentProlog

    /*
      Document Start Scanning Mode
    */
    lexmode DocumentStart
      : standalone
      : extends => 'DocumentProlog'
    {
      /*
        XML declaration
      */
      XDO := ['<'] ['?'] ['x'] ['m'] ['l'];
    } // DocumentStart
    
    /*
      Comment declaration scanning mode
    */
    lexmode CommentDeclaration
      : standalone
    {
      /*
        Comment close
      */
      COM := ['-'] ['-'];
      
      /*
        Comment data
      */
      ?default-token STRING : value;
    } // CommentDeclaration
    
    /*
      Processing instruction name and |S| scanning mode
    */
    lexmode PIName
      : standalone
      : extends => 'Name'
      : extends => 'S'
    {
      /*
        Processing instruction close
      */
      PIC := ['?'] ['>'];
    } // PIName
    
    /*
      Processing instruction name and |S| scanning mode
    */
    lexmode PINmtoken
      : standalone
      : extends => 'Nmtoken'
      : extends => 'S'
    {
      /*
        Processing instruction close
      */
      PIC := ['?'] ['>'];
    } // PINmtoken
    
    /*
      Processing instruction data scanning mode
    */
    lexmode PIData
      : standalone
    {
      /*
        Processing instruction close
      */
      PIC := ['?'] ['>'];
      
      /*
        Processing instruction target data
      */
      ?default-token DATA : value;
    } // PIData
    
    /*
      Content of element scanning mode
    */
    lexmode ElementContent
      : standalone
    {
      /*
        Start tag open
      */
      STAGO := ['<'];
      
      /* 
        End tag open
      */
      ETAGO := ['<'] ['/'];
      
      /*
        Hexadecimal character reference open
      */
      HCRO := ['&'] ['#'] ['x'];
      
      /*
        Numeric character reference open
      */
      CRO := ['&'] ['#'];
      
      /*
        General entity reference open
      */
      ERO := ['&'];
      
      /*
        Comment declaration open
      */
      CDO := ['<'] ['!'] ['-'] ['-'];
      
      /*
        CDATA section open
      */
      CDSO := ['<'] ['!'] ['[']
              ['C'] ['D'] ['A'] ['T'] ['A'] ['['];
      
      /*
        Processing instruction open
      */
      PIO := ['<'] ['?'];

      /*
        Markup section end
      */
      MSE := [']'] [']'] ['>'];

      /*
        Character data
      */
      /*
        Character data and/or |MSE|
      */
      ?default-token CharData : value;
    } // ElementContent
    
    /*
      CDATA section content scanning mode
    */
    lexmode CDATASectionContent
      : standalone
    {
      /*
        Markup section end
      */
      MSE := [']'] [']'] ['>'];
      
      /*
        Character data
      */
      ?default-token CData : value;
    } // CDATASectionContent
    
    lexmode EntityReference
      : standalone
      : extends => 'Name'
    {
      /*
        Reference close
      */
      REFC := [';'];
    } // EntityReference
    
    lexmode NumericCharacterReference
      : standalone
    {
      /*
        Decimal number
      */
      $digit := ['0' '1' '2' '3' '4' '5' '6' '7' '8' '9'];
      NUMBER : value := $digit+;
      
      /*
        Reference close
      */
      REFC := [';'];
    } // NumericCharacterReference
    
    lexmode HexadecimalCharacterReference
      : standalone
    {
      /*
        Hexadecimal number
      */
      $hexdigit := ['0' '1' '2' '3' '4' '5' '6' '7' '8' '9'
                    'A' 'B' 'C' 'D' 'E' 'F'
                    'a' 'b' 'c' 'd' 'e' 'f'];
      Hex : value := $hexdigit+;
      
      /*
        Reference close
      */
      REFC := [';'];
    } // HexadecimalCharacterReference
    
    /*
      The XML Declaration and Text Declaration Scanning Mode
    */
    lexmode XMLDeclaration
      : standalone
      : extends => 'Name'
      : extends => 'S'
    {
      
      /*
        Value indicator
      */
      VI := ['='];
      
      /*
        Literal open
      */
      LIT := ['"'];
      LITA := [U+0027];
      
      /*
        Processing instruction close

          The |PIC|, i.e. |?>|, is split into two tokens |PIC1| and |PIC2|
          in this scanning mode to set |no_xml11_eol| flag in the
          |_XMLDeclaration_| |rule|.
      */
      PIC1 := ['?'];
      PIC2 := ['>'];
    } // XMLDeclaration

    /*
      The XML Declaration or Processing Instruction Scanning Mode

           '<?xml'               S                 ...
        (DocumentStart) (XMLDeclarationOrPI) (XMLDeclaration)
           '<?xml'              '1'                S                ...
        (DocumentStart) (XMLDeclarationOrPI) (PINmtoken)(PIName) (PITarget)
           '<?xml'              '-'         'stylesheet'    S       ...
        (DocumentStart) (XMLDeclarationOrPI) (PINmtoken) (PIName) (PITarget)
    */
    lexmode XMLDeclarationOrPI
      : standalone
      : extends => 'NameChar'
      : extends => 'S'
    {
      NameChar : value := $NameChar11;
    } // XMLDeclarationOrPI
    
    lexmode StartTag
      : standalone
      : extends => 'Name'
      : extends => 'S'
    {
      
      /*
        Value indicator
      */
      VI := ['='];
      
      /*
        Literal open
      */
      LIT := ['"'];
      LITA := [U+0027];
      
      /*
        Tag close
      */
      TAGC := ['>'];
      
      /*
        Null end-tag enabled start-tag close
      */
      NESTC := ['/'];
    } // StartTag
    
    lexmode EndTag
      : standalone
      : extends => 'Name'
      : extends => 'S'
    {
      /*
        Tag close
      */
      TAGC := ['>'];
    } // EndTag
    
    lexmode AttributeValueLiteral_ {
      ERO := ['&'];
      CRO := ['&'] ['#'];
      HCRO := ['&'] ['#'] ['x'];
    } // AttributeValueLiteral_
    
    lexmode AttributeValueLiteral
      : standalone
      : extends => 'AttributeValueLiteral_'
    {
      LIT := ['"'];
      STRING : value := [^'"' '&' '<']+;
    } // AttributeValueLiteral
    
    lexmode AttributeValueLiteralA
      : standalone
      : extends => 'AttributeValueLiteral_'
    {
      LITA := [U+0027];
      STRING : value := [^U+0027 '&' '<']+;
    } // AttributeValueLiteralA
    
    lexmode AttributeValueLiteralE
      : standalone
      : extends => 'AttributeValueLiteral_'
    {
      STRING : value := [^'&' '<']+;
    } // AttributeValueLiteralE

    lexmode EntityValue_ {
      PERO := ['%'];
      ERO := ['&'];
      CRO := ['&'] ['#'];
      HCRO := ['&'] ['#'] ['x'];
    } // EntityValue_
    
    lexmode EntityValue
      : standalone
      : extends => 'EntityValue_'
    {
      LIT := ['"'];
      STRING : value := [^'"' '&' '%']+;
    } // EntityValue
    
    lexmode EntityValueA
      : standalone
      : extends => 'EntityValue_'
    {
      LITA := [U+0027];
      STRING : value := [^U+0027 '&' '%']+;
    } // EntityValueA

    lexmode SystemLiteral
      : standalone
    {
      LIT := ['"'];
      ?default-token STRING : value;
    } // SystemLiteral

    lexmode SystemLiteralA
      : standalone
    {
      LITA := [U+0027];
      ?default-token STRING : value;
    } // SystemLiteralA

    lexmode DTD
      : standalone
      : extends => 'S'
    {
      /*
        Markup declaration open
      */
      MDO := ['<'] ['!'];

      /*
        Comment declaration open
      */
      CDO := ['<'] ['!'] ['-'] ['-'];

      /*
        Processing instruction open
      */
      PIO := ['<'] ['?'];

      /*
        Parameter entity reference open
      */
      PERO := ['%'];

      /*
        Declaration subset close
      */
      DSC := [']'];

      /*
        Contition section open
      */
      CSO := ['<'] ['!'] ['['];
    } // DTD
    
    /*
      Markup declaration scanning mode
      
      This mode is used to recognize |MDC| that terminates
      a comment declaration as well as the base |lexmode|
      for e.g. document type declaration scanning mode.
    */
    lexmode MarkupDeclaration
      : standalone
      : extends => 'Name'
      : extends => 'S'
    {
      /*
        Markup declaration close
      */
      MDC := ['>'];
      
      /*
        Literal open
      */
      LIT := ['"'];
      
      /*
        Alternative literal open
      */
      LITA := [U+0027];

      /*
        Parameter entity reference open
      */
      PERO := ['%'];
    
      /*
        Declaration subset open
      */
      DSO := ['['];
    } // MarkupDeclaration

    lexmode ElementDeclaration
      : standalone
      : extends => 'MarkupDeclaration'
    {
      /*
        Model group open
      */
      MGO := ['('];

      /*
        Model group close
      */
      MGC := [')'];

      /*
        Reserved name indicator
      */
      RNI := ['#'];

      /*
        Occurence indicators
      */
      OPT := ['?'];
      REP := ['*'];
      PLUS := ['+'];

      /*
        Connectors
      */
      OR := ['|'];
      SEQ := [','];
    } // ElementDeclaration

    lexmode AttlistDeclaration
      : standalone
      : extends => 'MarkupDeclaration'
    {
      /*
        Enumeration group open
      */
      EGO := ['('];

      /*
        Enumeration group close
      */
      EGC := [')'];

      /*
        Enumeration choice delimiter
      */
      OR := ['|'];

      /*
        Reserved name indicator
      */
      RNI := ['#'];
    } // AttlistDeclaration

    lexmode Enumeration
      : standalone
      : extends => 'Nmtoken'
      : extends => 'S'
    {
      /*
        Enumeration group close
      */
      EGC := [')'];

      /*
        Enumeration choice delimiter
      */
      OR := ['|'];
    } // Enumeration

    
    token-error default : default {
      lang:Perl {
        my $location;
        __CODE{xp|get-location-from-token::
          $token => {$token},
          $result => {$location},
        }__;
        my $continue = __DOMCore:ERROR{xp|wf-syntax-error::
          xp|error-token => {$token},
          DOMCore|location => {$location},
        }__;
        unless ($continue) {
          __CODE{ParseError}__;
        }
      }
    } // default

  @ResourceDef:
    @@ForCheck: ManakaiDOM|ForClass
    @@QName: ParseError
    @@rdf:type: DISPerl|BlockCode
    @@PerlDef:
      __DEEP{
        for (@{$self->{entity}}) {
          $_->{close_file}->();
        }
      }__;
      __EXCEPTION{DOMLS|PARSE_ERR}__;

  @ResourceDef:
    @@ForCheck: ManakaiDOM|ForClass
    @@QName: checkNCName
    @@rdf:type: DISPerl|BlockCode
    @@PerlDef:
      if (($self->{xml_version} eq '1.0' and
           not <Code::DOMMain|testXML10Name:: $INPUT = $name>) or
          ($self->{xml_version} eq '1.1' and
           not <Code::DOMMain|testXML11Name:: $INPUT = $name>)) {
        my $__location;
        __CODE{xp|get-location-from-token::
          $token => {$token},
          $result => {$__location},
        }__;
        my $__continue = __c|ERROR{xp|wf-invalid-character-in-node-name::
          xp|error-token => {$token},
          c|location => {$__location},
          xp|name => {$name},
          infoset|version => {$self->{xml_version}},
        }__;
        unless ($__continue) {
          __CODE{ParseError}__;
        }
      } elsif (index ($name, ':') > -1) {
        my $__location;
        __CODE{xp|get-location-from-token::
          $token => {$token},
          $result => {$__location},
        }__;
        my $__continue = __c|ERROR{xp|nswf-legal-ncname::
          xp|error-token => {$token},
          c|location => {$__location},
          xp|name => {$name},
          infoset|version => {$self->{xml_version}},
        }__;
        unless ($__continue) {
          __CODE{ParseError}__;
        }            
      }

  @ResourceDef:
    @@ForCheck: ManakaiDOM|ForClass
    @@QName: checkQName
    @@rdf:type: DISPerl|BlockCode
    @@PerlDef:
      if (($self->{xml_version} eq '1.0' and
           not <Code::DOMMain|testXML10Name:: $INPUT = $name>) or
          ($self->{xml_version} eq '1.1' and
           not <Code::DOMMain|testXML11Name:: $INPUT = $name>)) {
        my $__location;
        __CODE{xp|get-location-from-token::
          $token => {$token},
          $result => {$__location},
        }__;
        my $__continue = __c|ERROR{xp|wf-invalid-character-in-node-name::
          xp|error-token => {$token},
          c|location => {$__location},
          xp|name => {$name},
          infoset|version => {$self->{xml_version}},
        }__;
        unless ($__continue) {
          __CODE{ParseError}__;
        }
      } elsif (($self->{xml_version} eq '1.0' and
                not <Code::DOMMain|testXML10QName:: $INPUT = $name>) or
               ($self->{xml_version} eq '1.1' and
                not <Code::DOMMain|testXML11QName:: $INPUT = $name>)) {
        my $__location;
        __CODE{xp|get-location-from-token::
          $token => {$token},
          $result => {$__location},
        }__;
        my $__continue = __c|ERROR{xp|nswf-legal-qname::
          xp|error-token => {$token},
          c|location => {$__location},
          xp|name => {$name},
          infoset|version => {$self->{xml_version}},
        }__;
        unless ($__continue) {
          __CODE{ParseError}__;
        }            
      }


  @XMLTests:
    @@XMLTest:
      @@@QName: xp.char.xml10.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0"?>
          <p>$u0009$u000A$u000D$u0020$uD7FF$uE000$uFFFD$U00010000$U0010FFFF</p>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          element {
            text-content: U+0009 U+000A U+000A U+0020 U+D7FF
                          U+E000 U+FFFD U+10000 U+10FFFF;
          }
        }
    @@XMLTest:
      @@@QName: xp.char.xml11.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.1"?>
          <p>$u0009$u000A$u000D$u0020$uD7FF$uE000$uFFFD$U00010000$U0010FFFF</p>
      @@@test:domTree:
        document {
          xml-version: '1.1';
          element {
            text-content: U+0009 U+000A U+000A U+0020 U+D7FF
                          U+E000 U+FFFD U+10000 U+10FFFF;
          }
        }
    @@XMLTest:
      @@@QName: xp.char.xml10.c0.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0"?>
          <p>$u0000$u0001$u0002$u0003$u0004$u0005$u0006$u0007$u0008$u000B$
          $u000C$u000E$u000F$u0010$u0011$u0012$u0013$u0014$u0015$u0016$
          $u0017$u0018$u0019$u001A$u001B$u001C$u001D$u001E$u001F</p>
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 4); } /* U+0000 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 5); } /* U+0001 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 6); } /* U+0002 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 7); } /* U+0003 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 8); } /* U+0004 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 9); } /* U+0005 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 10); } /* U+0006 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 11); } /* U+0007 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 12); } /* U+0008 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 13); } /* U+000B */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 14); } /* U+000C */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 15); } /* U+000E */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 16); } /* U+000F */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 17); } /* U+0010 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 18); } /* U+0011 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 19); } /* U+0012 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 20); } /* U+0013 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 21); } /* U+0014 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 22); } /* U+0015 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 23); } /* U+0016 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 24); } /* U+0017 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 25); } /* U+0018 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 26); } /* U+0019 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 27); } /* U+001A */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 28); } /* U+001B */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 29); } /* U+001C */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 30); } /* U+001D */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 31); } /* U+001E */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 32); } /* U+001F */
    @@XMLTest:
      @@@QName: xp.char.xml11.c0.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.1"?>
          <p>$u0000$u0001$u0002$u0003$u0004$u0005$u0006$u0007$u0008$u000B$
          $u000C$u000E$u000F$u0010$u0011$u0012$u0013$u0014$u0015$u0016$
          $u0017$u0018$u0019$u001A$u001B$u001C$u001D$u001E$u001F</p>
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 4); } /* U+0000 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 5); } /* U+0001 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 6); } /* U+0002 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 7); } /* U+0003 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 8); } /* U+0004 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 9); } /* U+0005 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 10); } /* U+0006 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 11); } /* U+0007 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 12); } /* U+0008 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 13); } /* U+000B */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 14); } /* U+000C */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 15); } /* U+000E */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 16); } /* U+000F */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 17); } /* U+0010 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 18); } /* U+0011 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 19); } /* U+0012 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 20); } /* U+0013 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 21); } /* U+0014 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 22); } /* U+0015 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 23); } /* U+0016 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 24); } /* U+0017 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 25); } /* U+0018 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 26); } /* U+0019 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 27); } /* U+001A */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 28); } /* U+001B */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 29); } /* U+001C */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 30); } /* U+001D */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 31); } /* U+001E */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 32); } /* U+001F */
    @@XMLTest:
      @@@QName: xp.char.xml10.c1.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0"?>
          <p>$u007F$u0080$u0081$u0082$u0083$u0084$u0086$u0087$u0088$
          $u0089$u008A$u008B$u008C$
          $u008D$u008E$u008F$u0090$u0091$u0092$u0093$u0094$u0095$u0096$
          $u0097$u0098$u0099$u009A$u009B$u009C$u009D$u009E$u009F$u0085</p>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          element {
            text-content: U+007F U+0080 U+0081 U+0082 U+0083 U+0084 U+0086
                          U+0087 U+0088 U+0089 U+008A U+008B U+008C U+008D
                          U+008E U+008F U+0090 U+0091 U+0092 U+0093 U+0094
                          U+0095 U+0096 U+0097 U+0098 U+0099 U+009A U+009B
                          U+009C U+009D U+009E U+009F U+0085;
          }
        }
    @@XMLTest:
      @@@QName: xp.char.xml11.c1.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.1"?>
          <p>$u007F$u0080$u0081$u0082$u0083$u0084$u0086$u0087$u0088$
          $u0089$u008A$u008B$u008C$
          $u008D$u008E$u008F$u0090$u0091$u0092$u0093$u0094$u0095$u0096$
          $u0097$u0098$u0099$u009A$u009B$u009C$u009D$u009E$u009F$u0085</p>
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 4); } /* U+007F */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 5); } /* U+0080 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 6); } /* U+0081 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 7); } /* U+0082 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 8); } /* U+0083 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 9); } /* U+0084 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 10); } /* U+0086 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 11); } /* U+0087 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 12); } /* U+0088 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 13); } /* U+0089 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 14); } /* U+008A */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 15); } /* U+008B */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 16); } /* U+008C */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 17); } /* U+008D */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 18); } /* U+008E */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 19); } /* U+008F */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 20); } /* U+0090 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 21); } /* U+0091 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 22); } /* U+0092 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 23); } /* U+0093 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 24); } /* U+0094 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 25); } /* U+0095 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 26); } /* U+0096 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 27); } /* U+0097 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 28); } /* U+0098 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 29); } /* U+0099 */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 30); } /* U+009A */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 31); } /* U+009B */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 32); } /* U+009C */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 33); } /* U+009D */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 34); } /* U+009E */
      @@@c:erred: <[[xp|wf-legal-literal-character]]> { (2, 35); } /* U+009F */

    @@XMLTest:
      @@@QName: xp.c0.internal.entity.xml11.1.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.1"?>
          <!DOCTYPE a [
          <!ENTITY e "&#x01;&#x02;&#x03;&#x04;&#x05;&#x06;&#x07;$
          &#x08;&#x09;&#x0A;&#x0B;&#x0C;&#x0D;&#x0E;&#x0F;$
          &#x10;&#x11;&#x12;&#x13;&#x14;&#x15;&#x16;&#x17;$
          &#x18;&#x19;&#x1A;&#x1B;&#x1C;&#x1D;&#x1E;&#x1F;">
          ]><a/>
      @@@test:domTree:
        document {
          document-type {
            general-entity {
              node-name: 'e';
              text-content: U+0001 U+0002 U+0003 U+0004 U+0005
                            U+0006 U+0007 U+0008 U+0009 U+000A U+000B
                            U+000C U+000D U+000E U+000F
                            U+0010 U+0011 U+0012 U+0013 U+0014 U+0015
                            U+0016 U+0017 U+0018 U+0019 U+001A U+001B
                            U+001C U+001D U+001E U+001F;
            }
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.c1.internal.entity.xml11.1.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.1"?>
          <!DOCTYPE a [
          <!ENTITY e "&#x80;&#x81;&#x82;&#x83;&#x84;&#x85;&#x86;&#x87;$
          &#x88;&#x89;&#x8A;&#x8B;&#x8C;&#x8D;&#x8E;&#x8F;$
          &#x90;&#x91;&#x92;&#x93;&#x94;&#x95;&#x96;&#x97;$
          &#x98;&#x99;&#x9A;&#x9B;&#x9C;&#x9D;&#x9E;&#x9F;&#x7F;">
          ]><a/>
      @@@test:domTree:
        document {
          document-type {
            general-entity {
              node-name: 'e';
              text-content: U+0080 U+0081 U+0082 U+0083 U+0084 U+0085
                            U+0086 U+0087 U+0088 U+0089 U+008A U+008B
                            U+008C U+008D U+008E U+008F
                            U+0090 U+0091 U+0092 U+0093 U+0094 U+0095
                            U+0096 U+0097 U+0098 U+0099 U+009A U+009B
                            U+009C U+009D U+009E U+009F U+007F;
            }
          }
          element { }
        }

    @@XMLTest:
      @@@QName: xp.syntax.empty.test
      @@@DEnt:
        @@@@test:value: \
      @@@c:erred:
        <[[xp:wf-syntax-error]]> { (1, 1); }
    @@XMLTest:
      @@@QName: xp.syntax.space.test
      @@@DEnt:
        @@@@test:value: \   
      @@@c:erred:
        <[[xp:wf-syntax-error]]> { (1, 4); }
    @@XMLTest:
      @@@QName: xp.syntax.newlines.test
      @@@DEnt:
        @@@@test:value:
          \
          \
          \
      @@@c:erred:
        <[[xp:wf-syntax-error]]> { (3, 1); }

    @@XMLTest:
      @@@QName: xp.only.docel.test
      @@@DEnt:
        @@@@test:value:
          <p></p>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          xml-encoding: null;
          xml-standalone: false;
          element {
            namespace-uri: null;
            prefix: null;
            local-name: 'p';
            text-content: '';
          }
        }
    @@XMLTest:
      @@@QName: xp.only.docel.emptyelemtag.test
      @@@DEnt:
        @@@@test:value:
          <p/>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          xml-encoding: null;
          xml-standalone: false;
          element {
            namespace-uri: null;
            prefix: null;
            local-name: 'p';
            text-content: '';
          }
        }
    @@XMLTest:
      @@@QName: xp.root.s.1.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0"?>$u0020$u000D$u000A$u0009
          <p></p>
      @@@test:domTree:
        document {
          element { }
        }

    @@XMLTest:
      @@@QName: xp.Name.1.test
      @@@DEnt:
        @@@@test:value: <name/>
      @@@test:domTree:
        document {
          element {
            node-name: 'name';
          }
        }
    @@XMLTest:
      @@@QName: xp.Name.2.test
      @@@DEnt:
        @@@@test:value: <name0/>
      @@@test:domTree:
        document {
          element {
            node-name: 'name0';
          }
        }
    @@enImplNote:
      @@@ddid: xml11name
      @@@@:
        {TODO:: XML 1.1 Name tests required
        }

    @@XMLTest:
      @@@QName: xp.content.mse.1.test
      @@@DEnt:
        @@@@test:value:
          <p>]]></p>
      @@@c:erred:
        <[[xp|wf-syntax-error]]> { (1, 4)..(1, 6); }
    @@XMLTest:
      @@@QName: xp.content.mse.2.test
      @@@DEnt:
        @@@@test:value:
          <p>aaa]]>bbb</p>
      @@@c:erred:
        <[[xp|wf-syntax-error]]> { (1, 7)..(1, 9); }

    @@XMLTest:
      @@@QName: xp.root.comment.1.test
      @@@DEnt:
        @@@@test:value:
          <!--comment data-->
          <p/>
      @@@test:domTree:
        document {
          comment {
            data: 'comment data';
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.root.comment.2.test
      @@@DEnt:
        @@@@test:value:
          <!---->
          <p/>
      @@@test:domTree:
        document {
          comment {
            data: '';
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.root.after.pi.comment.1.test
      @@@DEnt:
        @@@@test:value:
          <?pi?>
          <!--comment data-->
          <p/>
      @@@test:domTree:
        document {
          pi { }
          comment {
            data: 'comment data';
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.root.after.pi.comment.2.test
      @@@DEnt:
        @@@@test:value:
          <?pi?>
          <!---->
          <p/>
      @@@test:domTree:
        document {
          pi { }
          comment {
            data: '';
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.root.after.element.comment.1.test
      @@@DEnt:
        @@@@test:value:
          <p/>
          <!--comment data-->
      @@@test:domTree:
        document {
          element { }
          comment {
            data: 'comment data';
          }
        }
    @@XMLTest:
      @@@QName: xp.root.after.element.comment.2.test
      @@@DEnt:
        @@@@test:value:
          <p/>
          <!---->
      @@@test:domTree:
        document {
          element { }
          comment {
            data: '';
          }
        }
    @@XMLTest:
      @@@QName: xp.doctype.intsubset.comment.1.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
          <!--comment data-->
          ]>
          <p/>
      @@@test:domTree:
        document {
          document-type { }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.doctype.intsubset.comment.2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
          <!---->
          ]>
          <p/>
      @@@test:domTree:
        document {
          document-type { }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.doctype.intsubset.comment.3.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
          <?pi?>
          <!---->
          ]>
          <p/>
      @@@test:domTree:
        document {
          document-type {
            pi { }
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.content.comment.1.test
      @@@DEnt:
        @@@@test:value:
          <p><!--comment data--></p>
      @@@test:domTree:
        document {
          element {
            comment {
              data: 'comment data';
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.content.comment.2.test
      @@@DEnt:
        @@@@test:value:
          <p><!----></p>
      @@@test:domTree:
        document {
          element {
            comment {
              data: '';
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.content.comment.3.test
      @@@DEnt:
        @@@@test:value:
          <p>aaaaa<!---->bbbbb</p>
      @@@test:domTree:
        document {
          element {
            text {
              data: 'aaaaa';
            }
            comment {
              data: '';
            }
            text {
              data: 'bbbbb';
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.content.comment.--.1.test
      @@@DEnt:
        @@@@test:value:
          <p><!--data--data--></p>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 12)..(1, 17); }
    @@XMLTest:
      @@@QName: xp.content.comment.---gt.test
      @@@DEnt:
        @@@@test:value:
          <p><!--data---></p>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 12)..(1, 15); }

    @@XMLTest:
      @@@QName: xp.xmldecl.version.1.0.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0"?>
          <p></p>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          xml-encoding: null;
          xml-standalone: false;
          element { }
        }
    @@XMLTest:
      @@@QName: xp.xmldecl.version.1.0.lita.test
      @@@DEnt:
        @@@@test:value:
          <?xml version='1.0'?>
          <p></p>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          xml-encoding: null;
          xml-standalone: false;
          element { }
        }
    @@XMLTest:
      @@@QName: xp.xmldecl.version.1.0.s.test
      @@@DEnt:
        @@@@test:value:
          <?xml  version  =  "1.0"  ?>
          <p></p>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          xml-encoding: null;
          xml-standalone: false;
          element { }
        }
    @@XMLTest:
      @@@QName: xp.xmldecl.version.1.1.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.1"?>
          <p></p>
      @@@test:domTree:
        document {
          xml-version: '1.1';
          xml-encoding: null;
          xml-standalone: false;
          element { }
        }

    @@XMLTest:
      @@@QName: xp.xmldecl.version.1.0.encoding.usascii.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" encoding="US-ascii"?>
          <p></p>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          xml-encoding: 'US-ascii';
          xml-standalone: false;
          element { }
        }
    @@XMLTest:
      @@@QName: xp.xmldecl.version.1.0.encoding.usascii.lita.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" encoding='US-ascii'?>
          <p></p>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          xml-encoding: 'US-ascii';
          xml-standalone: false;
          element { }
        }
    @@XMLTest:
      @@@QName: xp.xmldecl.version.1.0.encoding.usascii.s.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" encoding  = "US-ascii" ?>
          <p></p>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          xml-encoding: 'US-ascii';
          xml-standalone: false;
          element { }
        }

    @@XMLTest:
      @@@QName: xp.xmldecl.version.1.0.encoding.usascii.standalone.yes.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" encoding="us-ascii" standalone="yes"?>
          <p></p>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          xml-encoding: 'us-ascii';
          xml-standalone: true;
          element { }
        }
    @@XMLTest:
      @@@QName: xp.xmldecl.version.1.0.encoding.usascii.standalone.no.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" encoding="us-ascii" standalone="no"?>
          <p></p>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          xml-encoding: 'us-ascii';
          xml-standalone: false;
          element { }
        }
    @@XMLTest:
      @@@QName: xp.xmldecl.version.1.0.encoding.usascii.standalone.yes.lita.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" encoding="us-ascii" standalone='yes'?>
          <p></p>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          xml-encoding: 'us-ascii';
          xml-standalone: true;
          element { }
        }
    @@XMLTest:
      @@@QName: xp.xmldecl.version.1.0.encoding.usascii.standalone.yes.s.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" encoding="us-ascii"  standalone  = "yes"  ?>
          <p></p>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          xml-encoding: 'us-ascii';
          xml-standalone: true;
          element { }
        }
    @@XMLTest:
      @@@QName: xp.xmldecl.no.encoding.but.standalone.attr.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="yes"?>
          <p></p>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          xml-encoding: null;
          xml-standalone: true;
          element { }
        }
    @@XMLTest:
      @@@QName: xp.xmldecl.encoding.encname.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" encoding="a-._01-"?>
          <p></p>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          xml-encoding: 'a-._01-';
          xml-standalone: false;
          element { }
        }

    @@XMLTest:
      @@@QName: xp.xmldecl.no.s.no.attr.test
      @@@DEnt:
        @@@@test:value:
          <?xml?>
          <p></p>
      @@@c:erred:
        <[[xp:wf-syntax-error]]> { (1, 1)..(1, 7); }
    @@XMLTest:
      @@@QName: xp.xmldecl.s.no.attr.test
      @@@DEnt:
        @@@@test:value:
          <?xml  ?>
          <p></p>
      @@@c:erred:
        <[[xp:wf-syntax-error]]> { (1, 8)..(1, 9); }
    @@XMLTest:
      @@@QName: xp.xmldecl.unknown.attr.test
      @@@DEnt:
        @@@@test:value:
          <?xml  unknown="value"?>
          <p></p>
      @@@c:erred:
        <[[xp:wf-syntax-error]]> { (1, 8)..(1, 22); }
    @@XMLTest:
      @@@QName: xp.xmldecl.version.unknown.attr.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" unknown="value"?>
          <p></p>
      @@@c:erred:
        <[[xp:wf-syntax-error]]> { (1, 21)..(1, 35); }
    @@XMLTest:
      @@@QName: xp.xmldecl.version.encoding.unknown.attr.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" encoding="us-ascii" unknown="value"?>
          <p></p>
      @@@c:erred:
        <[[xp:wf-syntax-error]]> { (1, 41)..(1, 55); }
    @@XMLTest:
      @@@QName: xp.xmldecl.version.encoding.standalone.unknown.attr.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" encoding="us-ascii" standalone="yes"
          unknown="value"?>
          <p></p>
      @@@c:erred:
        <[[xp:wf-syntax-error]]> { (2, 1)..(2, 15); }
    @@XMLTest:
      @@@QName: xp.xmldecl.no.version.but.encoding.attr.test
      @@@DEnt:
        @@@@test:value:
          <?xml encoding="us-ascii"?>
          <p></p>
      @@@c:erred:
        <[[xp:wf-syntax-error]]> { (1, 7)..(1, 25); }
    @@XMLTest:
      @@@QName: xp.xmldecl.no.version.but.standalone.attr.test
      @@@DEnt:
        @@@@test:value:
          <?xml standalone="yes"?>
          <p></p>
      @@@c:erred:
        <[[xp:wf-syntax-error]]> { (1, 7)..(1, 24); }
    @@XMLTest:
      @@@QName: xp.xmldecl.version.unsupported.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.2"?>
          <p></p>
      @@@c:erred:
        <[[xp:wf-unsupported-xml-version]]> { (1, 7)..(1, 19); }
    @@XMLTest:
      @@@QName: xp.xmldecl.version.unsupported.2.test
      @@@DEnt:
        @@@@test:value:
          <?xml version=" 1.0 "?>
          <p></p>
      @@@c:erred:
        <[[xp:wf-unsupported-xml-version]]> { (1, 7)..(1, 21); }
    @@XMLTest:
      @@@QName: xp.xmldecl.version.unsupported.3.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="01.00"?>
          <p></p>
      @@@c:erred:
        <[[xp:wf-unsupported-xml-version]]> { (1, 7)..(1, 21); }
    @@XMLTest:
      @@@QName: xp.xmldecl.encoding.malformed.1.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" encoding="0088"?>
          <p></p>
      @@@c:erred:
        <[[xp:wf-malformed-enc-name]]> { (1, 21)..(1, 35); }
    @@XMLTest:
      @@@QName: xp.xmldecl.encoding.malformed.2.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" encoding="D.V.D!"?>
          <p></p>
      @@@c:erred:
        <[[xp:wf-malformed-enc-name]]> { (1, 21)..(1, 38); }
    @@XMLTest:
      @@@QName: xp.xmldecl.standalone.malformed.1.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="true"?>
          <p></p>
      @@@c:erred:
        <[[xp:wf-malformed-xml-standalone]]> { (1, 21)..(1, 38); }
    @@XMLTest:
      @@@QName: xp.xmldecl.standalone.malformed.2.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="YES"?>
          <p></p>
      @@@c:erred:
        <[[xp:wf-malformed-xml-standalone]]> { (1, 21)..(1, 37); }
    @@XMLTest:
      @@@QName: xp.xmldecl.standalone.malformed.3.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="no  "?>
          <p></p>
      @@@c:erred:
        <[[xp:wf-malformed-xml-standalone]]> { (1, 21)..(1, 38); }
    
    @@XMLTest:
      @@@QName: xp.no-xmldecl.xml...-pi.test
      @@@DEnt:
        @@@@test:value:
          <?xmldeclaration?>
          <a></a>
      @@@test:domTree:
        document {
          pi {
            node-name: 'xmldeclaration';
            node-value: '';
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.no-xmldecl.xml...-pi.after.document.element.test
      @@@DEnt:
        @@@@test:value:
          <a></a>
          <?xmldeclaration?>
      @@@test:domTree:
        document {
          element { }
          pi {
            node-name: 'xmldeclaration';
            node-value: '';
          }
        }
    @@XMLTest:
      @@@QName: xp.no-xmldecl.xml...-pi.in.document.element.test
      @@@DEnt:
        @@@@test:value:
          <a>
          <?xmldeclaration?>
          </a>
      @@@test:domTree:
        document {
          element {
            text { }
            pi {
              node-name: 'xmldeclaration';
              node-value: '';
            }
            text { }
          }
        }
    @@XMLTest:
      @@@QName: xp.no-xmldecl.xml...-pi.in.doctype.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
          <?xmldeclaration?>
          ]>
          <a></a>
      @@@test:domTree:
        document {
          document-type {
            pi {
              node-name: 'xmldeclaration';
              node-value: '';
            }
          }
          element { }
        }

    @@XMLTest:
      @@@QName: xp.XMLdecl.test
      @@@DEnt:
        @@@@test:value:
          <?XML version="1.0"?>
          <p></p>
      @@@c:erred:
        <[[xp:wf-pi-target-is-xml]]> { (1, 1)..(1, 5); }
    @@XMLTest:
      @@@QName: xp.Xmldecl.test
      @@@DEnt:
        @@@@test:value:
          <?Xml version="1.0"?>
          <p></p>
      @@@c:erred:
        <[[xp:wf-pi-target-is-xml]]> { (1, 1)..(1, 5); }
    @@XMLTest:
      @@@QName: xp.xmldecl.after.document.element.empty.test
      @@@DEnt:
        @@@@test:value:
          <p></p>
          <?xml?>
      @@@c:erred:
        <[[xp:wf-pi-target-is-xml]]> { (2, 1)..(2, 5); }
    @@XMLTest:
      @@@QName: xp.xmldecl.after.document.element.test
      @@@DEnt:
        @@@@test:value:
          <p></p>
          <?xml version="1.0"?>
      @@@c:erred:
        <[[xp:wf-pi-target-is-xml]]> { (2, 1)..(2, 5); }
    @@XMLTest:
      @@@QName: xp.xmldecl.in.element.empty.test
      @@@DEnt:
        @@@@test:value:
          <p>
          <?xml?>
          </p>
      @@@c:erred:
        <[[xp:wf-pi-target-is-xml]]> { (2, 1)..(2, 5); }
    @@XMLTest:
      @@@QName: xp.xmldecl.in.element.test
      @@@DEnt:
        @@@@test:value:
          <p>
          <?xml version="1.0"?>
          </p>
      @@@c:erred:
        <[[xp:wf-pi-target-is-xml]]> { (2, 1)..(2, 5); }
    @@XMLTest:
      @@@QName: xp.xmldecl.after.comment.test
      @@@DEnt:
        @@@@test:value:
          <!---->
          <?xml version="1.0"?>
          <p></p>
      @@@c:erred:
        <[[xp:wf-pi-target-is-xml]]> { (2, 1)..(2, 5); }
    @@XMLTest:
      @@@QName: xp.xmldecl.after.comment.empty.test
      @@@DEnt:
        @@@@test:value:
          <!---->
          <?xml?>
          <p></p>
      @@@c:erred:
        <[[xp:wf-pi-target-is-xml]]> { (2, 1)..(2, 5); }
    @@XMLTest:
      @@@QName: xp.xmldecl.after.pi.test
      @@@DEnt:
        @@@@test:value:
          <?xml-declaration?>
          <?xml version="1.0"?>
          <p></p>
      @@@c:erred:
        <[[xp:wf-pi-target-is-xml]]> { (2, 1)..(2, 5); }
    @@XMLTest:
      @@@QName: xp.xmldecl.after.pi.empty.test
      @@@DEnt:
        @@@@test:value:
          <?xml-declaration?>
          <?xml?>
          <p></p>
      @@@c:erred:
        <[[xp:wf-pi-target-is-xml]]> { (2, 1)..(2, 5); }
    @@XMLTest:
      @@@QName: xp.xmldecl.after.pi.2.test
      @@@DEnt:
        @@@@test:value:
          <?declaration?>
          <?xml version="1.0"?>
          <p></p>
      @@@c:erred:
        <[[xp:wf-pi-target-is-xml]]> { (2, 1)..(2, 5); }
    @@XMLTest:
      @@@QName: xp.xmldecl.after.pi.empty.2.test
      @@@DEnt:
        @@@@test:value:
          <?declaration?>
          <?xml?>
          <p></p>
      @@@c:erred:
        <[[xp:wf-pi-target-is-xml]]> { (2, 1)..(2, 5); }
    @@XMLTest:
      @@@QName: xp.xmldecl.after.doctype.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a>
          <?xml version="1.0"?>
          <p></p>
      @@@c:erred:
        <[[xp:wf-pi-target-is-xml]]> { (2, 1)..(2, 5); }
    @@XMLTest:
      @@@QName: xp.xmldecl.after.doctype.empty.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a>
          <?xml?>
          <p></p>
      @@@c:erred:
        <[[xp:wf-pi-target-is-xml]]> { (2, 1)..(2, 5); }
    @@XMLTest:
      @@@QName: xp.xmldecl.in.doctype.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
          <?xml version="1.0"?>
          ]>
          <p></p>
      @@@c:erred:
        <[[xp:wf-pi-target-is-xml]]> { (2, 1)..(2, 5); }
    @@XMLTest:
      @@@QName: xp.xmldecl.in.doctype.empty.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
          <?xml?>
          ]>
          <p></p>
      @@@c:erred:
        <[[xp:wf-pi-target-is-xml]]> { (2, 1)..(2, 5); }

    @@XMLTest:
      @@@QName: xp.pi.before.element.empty.test
      @@@DEnt:
        @@@@test:value:
          <?target?>
          <a></a>
      @@@test:domTree:
        document {
          pi {
            node-name: 'target';
            node-value: '';
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.pi.before.element.s.test
      @@@DEnt:
        @@@@test:value:
          <?target  ?>
          <a></a>
      @@@test:domTree:
        document {
          pi {
            node-name: 'target';
            node-value: '';
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.pi.before.element.string.test
      @@@DEnt:
        @@@@test:value:
          <?target string?>
          <a></a>
      @@@test:domTree:
        document {
          pi {
            node-name: 'target';
            node-value: 'string';
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.pi.before.element.string.s.test
      @@@DEnt:
        @@@@test:value:
          <?target string  ?>
          <a></a>
      @@@test:domTree:
        document {
          pi {
            node-name: 'target';
            node-value: 'string  ';
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.pi.before.element.gt.test
      @@@DEnt:
        @@@@test:value:
          <?target string>string?>
          <a></a>
      @@@test:domTree:
        document {
          pi {
            node-name: 'target';
            node-value: 'string>string';
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.pi.doctype.empty.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
          <?target?>
          ]>
          <a></a>
      @@@test:domTree:
        document {
          document-type {
            pi {
              node-name: 'target';
              node-value: '';
            }
          }
          element { }
        }

    @@XMLTest:
      @@@QName: xp.pi.no.target.test
      @@@DEnt:
        @@@@test:value:
          <??>
          <p></p>
      @@@c:erred:
        <[[xp:wf-syntax-error]]> { (1, 3)..(1, 4); }
    @@XMLTest:
      @@@QName: xp.pi.no.target.2.test
      @@@DEnt:
        @@@@test:value:
          <?  ?>
          <p></p>
      @@@c:erred:
        <[[xp:wf-syntax-error]]> { (1, 3)..(1, 4); }
    @@XMLTest:
      @@@QName: xp.pi.bad.target.1.test
      @@@DEnt:
        @@@@test:value:
          <?target!  ?>
          <p></p>
      @@@c:erred:
        <[[xp:wf-syntax-error]]> { (1, 9)..(1, 9); }
    @@XMLTest:
      @@@QName: xp.pi.bad.target.2.test
      @@@DEnt:
        @@@@test:value:
          <?0target  ?>
          <p></p>
      @@@c:erred:
        <[[xp:wf-syntax-error]]> { (1, 3)..(1, 3); }

    @@XMLTest:
      @@@QName: xp.cdatasection.empty.1.test
      @@@DEnt:
        @@@@test:value:
          <p><![CDATA[]]></p>
      @@@test:domTree:
        document {
          element {
            cdata-section {
              data: '';
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.cdatasection.empty.2.test
      @@@DEnt:
        @@@@test:value:
          <p>aa<![CDATA[]]>bb</p>
      @@@test:domTree:
        document {
          element {
            text { data: 'aa'; }
            cdata-section {
              data: '';
            }
            text { data: 'bb'; }
          }
        }
    @@XMLTest:
      @@@QName: xp.cdatasection.1.test
      @@@DEnt:
        @@@@test:value:
          <p><![CDATA[abcdefg]]></p>
      @@@test:domTree:
        document {
          element {
            cdata-section {
              data: 'abcdefg';
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.cdatasection.2.test
      @@@DEnt:
        @@@@test:value:
          <p>aa<![CDATA[abcdefg]]>bb</p>
      @@@test:domTree:
        document {
          element {
            text { data: 'aa'; }
            cdata-section {
              data: 'abcdefg';
            }
            text { data: 'bb'; }
          }
        }
    @@XMLTest:
      @@@QName: xp.cdatasection.ref.1.test
      @@@DEnt:
        @@@@test:value:
          <p><![CDATA[a&amp;&#x32;&#32;%abc;&def;]]&gt;b]]></p>
      @@@test:domTree:
        document {
          element {
            cdata-section {
              data: 'a&amp;&#x32;&#32;%abc;&def;]]&gt;b';
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.cdatasection.in.general.entity.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p [
            <!ENTITY cdata "<![CDATA[text]]>">
          ]>
          <p>&cdata;</p>
      @@@test:domTree:
        document {
          document-type {
            general-entity {
              node-name: 'cdata';
              cdata-section {
                data: 'text';
              }
            }
          }
          element {
            general-entity-reference {
              node-name: 'cdata';
              is-expanded: true;
              cdata-section {
                data: 'text';
              }
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.cdatasection.no.mse.test
      @@@DEnt:
        @@@@test:value:
          <p><![CDATA[text</p>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 21); }
    @@XMLTest:
      @@@QName: xp.cdatasection.nest.test
      @@@DEnt:
        @@@@test:value:
          <p><![CDATA[text01<![CDATA[txt2]]>text3]]></p>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 40)..(1, 42); }

    @@XMLTest:
      @@@QName: xp.doctype.empty.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a>
          <a></a>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          xml-encoding: null;
          xml-standalone: false;
          document-type {
            node-name: 'a';
            public-id: null;
            system-id: null;
          }
          element {
            namespace-uri: null;
            prefix: null;
            local-name: 'a';
            text-content: '';
          }
        }
    @@XMLTest:
      @@@QName: xp.doctype.empty.after.document.element.test
      @@@DEnt:
        @@@@test:value:
          <a></a>
          <!DOCTYPE a>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (2, 1)..(2, 12); }
    @@XMLTest:
      @@@QName: xp.doctype.empty.in.element.test
      @@@DEnt:
        @@@@test:value:
          <a>
          <!DOCTYPE a>
          </a>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (2, 1)..(2, 12); }
    @@XMLTest:
      @@@QName: xp.doctype.empty.dup.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a>
          <!DOCTYPE a>
          <a></a>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (2, 1)..(2, 12); }
    @@XMLTest:
      @@@QName: xp.doctype.empty.in.intsubset.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
          <!DOCTYPE a>
          ]>
          <a></a>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (2, 1)..(2, 12); }
    @@XMLTest:
      @@@QName: xp.doctype.no.s.no.name.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE>
          <a></a>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 10); }
    @@XMLTest:
      @@@QName: xp.doctype.no.name.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE >
          <a></a>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 11); }
    @@XMLTest:
      @@@QName: xp.doctype.name.s.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE aa   >
          <aa></aa>
      @@@test:domTree:
        document {
          document-type {
            node-name: 'aa';
            public-id: null;
            system-id: null;
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.doctype.no.mdc.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE aa
          <aa></aa>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (2, 1); }

    @@XMLTest:
      @@@QName: xp.doctype.intsubset.empty.1.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a []>
          <a></a>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          xml-encoding: null;
          xml-standalone: false;
          document-type {
            node-name: 'a';
            public-id: null;
            system-id: null;
          }
          element {
            namespace-uri: null;
            prefix: null;
            local-name: 'a';
            text-content: '';
          }
        }
    @@XMLTest:
      @@@QName: xp.doctype.intsubset.empty.2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [

          ]>
          <a></a>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          xml-encoding: null;
          xml-standalone: false;
          document-type {
            node-name: 'a';
            public-id: null;
            system-id: null;
          }
          element {
            namespace-uri: null;
            prefix: null;
            local-name: 'a';
            text-content: '';
          }
        }
    @@XMLTest:
      @@@QName: xp.doctype.intsubset.empty.3.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a[]>
          <a></a>
      @@@test:domTree:
        document {
          document-type {
            node-name: 'a';
            public-id: null;
            system-id: null;
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.doctype.intsubset.empty.4.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a[]  >
          <a></a>
      @@@test:domTree:
        document {
          document-type {
            node-name: 'a';
            public-id: null;
            system-id: null;
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.doctype.intsubset.no.dsc.1.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [>
          <a></a>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 14); }
    @@XMLTest:
      @@@QName: xp.doctype.intsubset.no.dsc.2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
          <a></a>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (2, 1); }
    @@XMLTest:
      @@@QName: xp.doctype.intsubset.no.dsc.3.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 14); }
    @@XMLTest:
      @@@QName: xp.doctype.intsubset.no.mdc.1.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a []
          <a/>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (2, 1); }
    @@XMLTest:
      @@@QName: xp.doctype.intsubset.no.mdc.2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a []]>
          <a/>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 15); }
    @@XMLTest:
      @@@QName: xp.doctype.pubid.sysid.1.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a PUBLIC "pubid" "sysid">
          <a/>
      @@@test:domTree:
        document {
          document-type {
            node-name: 'a';
            public-id: 'pubid';
            system-id: 'sysid';
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.doctype.pubid.sysid.2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a PUBLIC 'pubid' "sysid">
          <a/>
      @@@test:domTree:
        document {
          document-type {
            node-name: 'a';
            public-id: 'pubid';
            system-id: 'sysid';
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.doctype.pubid.sysid.3.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a PUBLIC "pubid" 'sysid'>
          <a/>
      @@@test:domTree:
        document {
          document-type {
            node-name: 'a';
            public-id: 'pubid';
            system-id: 'sysid';
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.doctype.pubid.sysid.4.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a PUBLIC 'pubid' 'sysid'>
          <a/>
      @@@test:domTree:
        document {
          document-type {
            node-name: 'a';
            public-id: 'pubid';
            system-id: 'sysid';
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.doctype.pubid.sysid.5.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a PUBLIC "pubid" "sysid"  >
          <a/>
      @@@test:domTree:
        document {
          document-type {
            node-name: 'a';
            public-id: 'pubid';
            system-id: 'sysid';
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.doctype.pubid.sysid.6.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a PUBLIC 'pubid' 'sysid'  >
          <a/>
      @@@test:domTree:
        document {
          document-type {
            node-name: 'a';
            public-id: 'pubid';
            system-id: 'sysid';
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.doctype.pubid.sysid.intsubset.1.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a PUBLIC "pubid" "sysid"[]>
          <a/>
      @@@test:domTree:
        document {
          document-type {
            node-name: 'a';
            public-id: 'pubid';
            system-id: 'sysid';
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.doctype.pubid.sysid.intsubset.2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a PUBLIC "pubid" "sysid"  []>
          <a/>
      @@@test:domTree:
        document {
          document-type {
            node-name: 'a';
            public-id: 'pubid';
            system-id: 'sysid';
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.doctype.pubid.sysid.intsubset.3.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a PUBLIC 'pubid' 'sysid'[]>
          <a/>
      @@@test:domTree:
        document {
          document-type {
            node-name: 'a';
            public-id: 'pubid';
            system-id: 'sysid';
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.doctype.pubid.sysid.intsubset.4.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a PUBLIC 'pubid' 'sysid'  []>
          <a/>
      @@@test:domTree:
        document {
          document-type {
            node-name: 'a';
            public-id: 'pubid';
            system-id: 'sysid';
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.doctype.sysid.1.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a SYSTEM "sysid">
          <a/>
      @@@test:domTree:
        document {
          document-type {
            node-name: 'a';
            public-id: null;
            system-id: 'sysid';
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.doctype.sysid.2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a SYSTEM 'sysid'>
          <a/>
      @@@test:domTree:
        document {
          document-type {
            node-name: 'a';
            public-id: null;
            system-id: 'sysid';
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.doctype.sysid.3.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a SYSTEM "sysid"  >
          <a/>
      @@@test:domTree:
        document {
          document-type {
            node-name: 'a';
            public-id: null;
            system-id: 'sysid';
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.doctype.sysid.4.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a SYSTEM 'sysid'  >
          <a/>
      @@@test:domTree:
        document {
          document-type {
            node-name: 'a';
            public-id: null;
            system-id: 'sysid';
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.doctype.sysid.intsubset.1.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a SYSTEM "sysid"[]>
          <a/>
      @@@test:domTree:
        document {
          document-type {
            node-name: 'a';
            public-id: null;
            system-id: 'sysid';
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.doctype.sysid.intsubset.2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a SYSTEM "sysid"  []>
          <a/>
      @@@test:domTree:
        document {
          document-type {
            node-name: 'a';
            public-id: null;
            system-id: 'sysid';
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.doctype.sysid.intsubset.3.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a SYSTEM 'sysid'[]>
          <a/>
      @@@test:domTree:
        document {
          document-type {
            node-name: 'a';
            public-id: null;
            system-id: 'sysid';
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.doctype.sysid.intsubset.4.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a SYSTEM 'sysid'   []>
          <a/>
      @@@test:domTree:
        document {
          document-type {
            node-name: 'a';
            public-id: null;
            system-id: 'sysid';
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.doctype.public.stago.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a PUBLIC<a/>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 19); }
    @@XMLTest:
      @@@QName: xp.doctype.public.mdc.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a PUBLIC>
          <a/>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 19); }
    @@XMLTest:
      @@@QName: xp.doctype.public.s.stago.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a PUBLIC <a/>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 20); }
    @@XMLTest:
      @@@QName: xp.doctype.public.s.mdc.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a PUBLIC >
          <a/>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 20); }
    @@XMLTest:
      @@@QName: xp.doctype.public.lit.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a PUBLIC"p" "s">
          <a/>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 19); }
    @@XMLTest:
      @@@QName: xp.doctype.public.lita.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a PUBLIC'p' "s">
          <a/>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 19); }
    @@XMLTest:
      @@@QName: xp.doctype.pubid.lit.lita.unmatched.1.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a PUBLIC "p' "s">
          <a/>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 25); }
    @@XMLTest:
      @@@QName: xp.doctype.pubid.lit.lita.unmatched.2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a PUBLIC "p' 's'><a/>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 32); }
    @@XMLTest:
      @@@QName: xp.doctype.pubid.lita.lit.unmatched.1.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a PUBLIC 'p" "s"><a/>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 32); }
    @@XMLTest:
      @@@QName: xp.doctype.pubid.lita.lit.unmatched.2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a PUBLIC 'p" 's'>
          <a/>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 21)..(1, 25); }
    @@XMLTest:
      @@@QName: xp.doctype.public.s.lit.mdc.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a PUBLIC "><a/>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 26); }
    @@XMLTest:
      @@@QName: xp.doctype.public.s.lita.mdc.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a PUBLIC '><a/>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 26); }
    @@XMLTest:
      @@@QName: xp.doctype.public.lit.pubid.lit.mdc.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a PUBLIC "p">
          <a/>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 23); }
    @@XMLTest:
      @@@QName: xp.doctype.public.lita.pubid.lita.mdc.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a PUBLIC 'p'>
          <a/>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 23); }
    @@XMLTest:
      @@@QName: xp.doctype.public.lit.pubid.lit.s.mdc.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a PUBLIC "p" >
          <a/>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 24); }
    @@XMLTest:
      @@@QName: xp.doctype.public.lita.pubid.lita.s.mdc.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a PUBLIC 'p' >
          <a/>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 24); }
    @@XMLTest:
      @@@QName: xp.doctype.public.lit.pubid.lit.s.lit.mdc.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a PUBLIC "p" "><a/>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 30); }
    @@XMLTest:
      @@@QName: xp.doctype.public.lit.pubid.lit.s.lita.mdc.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a PUBLIC "p" '><a/>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 30); }
    @@XMLTest:
      @@@QName: xp.doctype.public.lita.pubid.lita.s.lit.mdc.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a PUBLIC 'p' "><a/>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 30); }
    @@XMLTest:
      @@@QName: xp.doctype.public.lita.pubid.lita.s.lita.mdc.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a PUBLIC 'p' '><a/>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 30); }
    @@XMLTest:
      @@@QName: xp.doctype.public.lit.pubid.lit.lit.lita.unmatched.mdc.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a PUBLIC "p" "s'><a/>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 32); }
    @@XMLTest:
      @@@QName: xp.doctype.public.lita.pubid.lita.lita.lit.unmatched.mdc.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a PUBLIC 'p' 's"><a/>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 32); }
    @@XMLTest:
      @@@QName: xp.doctype.pubid.sysid.stago.1.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a PUBLIC "p" "s"<a/>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 27); }
    @@XMLTest:
      @@@QName: xp.doctype.pubid.sysid.stago.2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a PUBLIC "p" 's'<a/>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 27); }
    @@XMLTest:
      @@@QName: xp.doctype.pubid.sysid.stago.s.1.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a PUBLIC "p" "s" <a/>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 28); }
    @@XMLTest:
      @@@QName: xp.doctype.pubid.sysid.stago.s.2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a PUBLIC "p" 's' <a/>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 28); }

    @@XMLTest:
      @@@QName: xp.endofline.1.0.crlf.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0"?>
          <p>aaa$u000D$u000Abbb</p>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          element {
            text-content: 'aaa' U+000A 'bbb';
          }
        }
    @@XMLTest:
      @@@QName: xp.endofline.1.1.crlf.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.1"?>
          <p>aaa$u000D$u000Abbb</p>
      @@@test:domTree:
        document {
          xml-version: '1.1';
          element {
            text-content: 'aaa' U+000A 'bbb';
          }
        }
    @@XMLTest:
      @@@QName: xp.endofline.1.0.crnl.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0"?>
          <p>aaa$u000D$u0085bbb</p>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          element {
            text-content: 'aaa' U+000A U+0085 'bbb';
          }
        }
    @@XMLTest:
      @@@QName: xp.endofline.1.1.crnl.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.1"?>
          <p>aaa$u000D$u0085bbb</p>
      @@@test:domTree:
        document {
          xml-version: '1.1';
          element {
            text-content: 'aaa' U+000A 'bbb';
          }
        }
    @@XMLTest:
      @@@QName: xp.endofline.1.0.nl.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0"?>
          <p>aaa$u0085bbb</p>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          element {
            text-content: 'aaa' U+0085 'bbb';
          }
        }
    @@XMLTest:
      @@@QName: xp.endofline.1.1.nl.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.1"?>
          <p>aaa$u0085bbb</p>
      @@@test:domTree:
        document {
          xml-version: '1.1';
          element {
            text-content: 'aaa' U+000A 'bbb';
          }
        }
    @@XMLTest:
      @@@QName: xp.endofline.1.0.ls.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0"?>
          <p>aaa$u2028bbb</p>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          element {
            text-content: 'aaa' U+2028 'bbb';
          }
        }
    @@XMLTest:
      @@@QName: xp.endofline.1.1.ls.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.1"?>
          <p>aaa$u2028bbb</p>
      @@@test:domTree:
        document {
          xml-version: '1.1';
          element {
            text-content: 'aaa' U+000A 'bbb';
          }
        }
    @@XMLTest:
      @@@QName: xp.endofline.1.0.cr.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0"?>
          <p>aaa$u000Dbbb</p>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          element {
            text-content: 'aaa' U+000A 'bbb';
          }
        }
    @@XMLTest:
      @@@QName: xp.endofline.1.1.cr.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.1"?>
          <p>aaa$u000Dbbb</p>
      @@@test:domTree:
        document {
          xml-version: '1.1';
          element {
            text-content: 'aaa' U+000A 'bbb';
          }
        }
    @@XMLTest:
      @@@QName: xp.endofline.1.0.lf.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0"?>
          <p>aaa$u000Abbb</p>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          element {
            text-content: 'aaa' U+000A 'bbb';
          }
        }
    @@XMLTest:
      @@@QName: xp.endofline.1.1.lf.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.1"?>
          <p>aaa$u000Abbb</p>
      @@@test:domTree:
        document {
          xml-version: '1.1';
          element {
            text-content: 'aaa' U+000A 'bbb';
          }
        }
    @@XMLTest:
      @@@QName: xp.xml10.endofline.nl.in.xmldecl.1.test
      @@@DEnt:
        @@@@test:value:
          <?xml$u0085version="1.0"?>
          <p/>
      @@@c:erred:
        <[[xp|fatal-xml11-end-of-line-in-xml-declaration]]> { (1, 6)..(2, 0); }
      @@@c:erred: <[[xp|wf-syntax-error]]> { }
    @@XMLTest:
      @@@QName: xp.xml11.endofline.nl.in.xmldecl.1.test
      @@@DEnt:
        @@@@test:value:
          <?xml$u0085version="1.1"?>
          (err)<p/>
      @@@c:erred:
        <[[xp|fatal-xml11-end-of-line-in-xml-declaration]]> { (1, 6)..(2, 0); }
      @@@c:erred: <[[xp|wf-syntax-error]]> { }
    @@XMLTest:
      @@@QName: xp.xml10.endofline.crnl.in.xmldecl.1.test
      @@@DEnt:
        @@@@test:value:
          <?xml$u000D$u0085version="1.0"?>
          <p/>
      @@@c:erred:
        <[[xp|fatal-xml11-end-of-line-in-xml-declaration]]> { (1, 6)..(2, 0); }
      @@@c:erred: <[[xp|wf-syntax-error]]> { }
    @@XMLTest:
      @@@QName: xp.xml11.endofline.crnl.in.xmldecl.1.test
      @@@DEnt:
        @@@@test:value:
          <?xml$u000D$u0085version="1.1"?>
          (err)<p/>
      @@@c:erred:
        <[[xp|fatal-xml11-end-of-line-in-xml-declaration]]> { (1, 6)..(2, 0); }
      @@@c:erred: <[[xp|wf-syntax-error]]> { }
    @@XMLTest:
      @@@QName: xp.xml10.endofline.ls.in.xmldecl.1.test
      @@@DEnt:
        @@@@test:value:
          <?xml$u2028version="1.0"?>
          <p/>
      @@@c:erred:
        <[[xp|fatal-xml11-end-of-line-in-xml-declaration]]> { (1, 6)..(2, 0); }
      @@@c:erred: <[[xp|wf-syntax-error]]> { }
    @@XMLTest:
      @@@QName: xp.xml11.endofline.ls.in.xmldecl.1.test
      @@@DEnt:
        @@@@test:value:
          <?xml$u2028version="1.1"?>
          (err)<p/>
      @@@c:erred:
        <[[xp|fatal-xml11-end-of-line-in-xml-declaration]]> { (1, 6)..(2, 0); }
      @@@c:erred: <[[xp|wf-syntax-error]]> { }
    @@XMLTest:
      @@@QName: xp.xml10.endofline.nl.in.xmldecl.2.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0"$u0085?>
          <p/>
      @@@c:erred:
        <[[xp|fatal-xml11-end-of-line-in-xml-declaration]]> { (1, 20)..(2, 0); }
      @@@c:erred: <[[xp|wf-syntax-error]]> { }
    @@XMLTest:
      @@@QName: xp.xml11.endofline.nl.in.xmldecl.2.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.1"$u0085?>
          (err)<p/>
      @@@c:erred:
        <[[xp|fatal-xml11-end-of-line-in-xml-declaration]]> { (1, 20)..(2, 0); }
      @@@c:erred: <[[xp|wf-syntax-error]]> { }
    @@XMLTest:
      @@@QName: xp.xml10.endofline.crnl.in.xmldecl.2.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0"$u000D$u0085?>
          <p/>
      @@@c:erred:
        <[[xp|fatal-xml11-end-of-line-in-xml-declaration]]> { (1, 20)..(2, 0); }
      @@@c:erred: <[[xp|wf-syntax-error]]> { }
    @@XMLTest:
      @@@QName: xp.xml11.endofline.crnl.in.xmldecl.2.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.1"$u000D$u0085?>
          (err)<p/>
      @@@c:erred:
        <[[xp|fatal-xml11-end-of-line-in-xml-declaration]]> { (1, 20)..(2, 0); }
      @@@c:erred: <[[xp|wf-syntax-error]]> { }
    @@XMLTest:
      @@@QName: xp.xml10.endofline.ls.in.xmldecl.2.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0"$u2028?>
          <p/>
      @@@c:erred:
        <[[xp|fatal-xml11-end-of-line-in-xml-declaration]]> { (1, 20)..(2, 0); }
      @@@c:erred: <[[xp|wf-syntax-error]]> { }
    @@XMLTest:
      @@@QName: xp.xml11.endofline.ls.in.xmldecl.2.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.1"$u2028?>
          (err)<p/>
      @@@c:erred:
        <[[xp|fatal-xml11-end-of-line-in-xml-declaration]]> { (1, 20)..(2, 0); }
      @@@c:erred: <[[xp|wf-syntax-error]]> { }
    @@XMLTest:
      @@@QName: xp.xml10.endofline.nl.in.xmldecl.3.test
      @@@DEnt:
        @@@@test:value:
          <?xml $u0085version="1.0"?>
          <p/>
      @@@c:erred:
        <[[xp|fatal-xml11-end-of-line-in-xml-declaration]]> { (1, 7)..(2, 0); }
      @@@c:erred: <[[xp|wf-syntax-error]]> { }
    @@XMLTest:
      @@@QName: xp.xml11.endofline.nl.in.xmldecl.3.test
      @@@DEnt:
        @@@@test:value:
          <?xml $u0085version="1.1"?>
          (err)<p/>
      @@@c:erred:
        <[[xp|fatal-xml11-end-of-line-in-xml-declaration]]> { (1, 7)..(2, 0); }
      @@@c:erred: <[[xp|wf-syntax-error]]> { }
    @@XMLTest:
      @@@QName: xp.xml10.endofline.crnl.in.xmldecl.3.test
      @@@DEnt:
        @@@@test:value:
          <?xml $u000D$u0085version="1.0"?>
          <p/>
      @@@c:erred:
        <[[xp|fatal-xml11-end-of-line-in-xml-declaration]]> { (1, 7)..(2, 0); }
      @@@c:erred: <[[xp|wf-syntax-error]]> { }
    @@XMLTest:
      @@@QName: xp.xml11.endofline.crnl.in.xmldecl.3.test
      @@@DEnt:
        @@@@test:value:
          <?xml $u000D$u0085version="1.1"?>
          (err)<p/>
      @@@c:erred:
        <[[xp|fatal-xml11-end-of-line-in-xml-declaration]]> { (1, 7)..(2, 0); }
      @@@c:erred: <[[xp|wf-syntax-error]]> { }
    @@XMLTest:
      @@@QName: xp.xml10.endofline.ls.in.xmldecl.3.test
      @@@DEnt:
        @@@@test:value:
          <?xml $u2028version="1.0"?>
          <p/>
      @@@c:erred:
        <[[xp|fatal-xml11-end-of-line-in-xml-declaration]]> { (1, 7)..(2, 0); }
      @@@c:erred: <[[xp|wf-syntax-error]]> { }
    @@XMLTest:
      @@@QName: xp.xml11.endofline.ls.in.xmldecl.3.test
      @@@DEnt:
        @@@@test:value:
          <?xml $u2028version="1.1"?>
          (err)<p/>
      @@@c:erred:
        <[[xp|fatal-xml11-end-of-line-in-xml-declaration]]> { (1, 7)..(2, 0); }
      @@@c:erred: <[[xp|wf-syntax-error]]> { }
    @@XMLTest:
      @@@QName: xp.xml10implied.endofline.nl.in.pi.1.test
      @@@DEnt:
        @@@@test:value:
          <?xml-$u0085?>
          <p/>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 7)..(2, 0); }
    @@XMLTest:
      @@@QName: xp.xml10.endofline.nl.in.pi.1.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0"?>
          <?xml-$u0085?>
          <p/>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (2, 7)..(3, 0); }
    @@XMLTest:
      @@@QName: xp.xml11.endofline.nl.in.pi.1.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.1"?>
          <?xml-$u0085?>
          <p/>
      @@@test:domTree:
        document {
          xml-version: '1.1';
          pi {
            node-name: 'xml-';
            node-value: '';
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.xml10implied.endofline.crnl.in.pi.1.test
      @@@DEnt:
        @@@@test:value:
          <?xml-$u000D$u0085?>
          <p/>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          pi {
            node-name: 'xml-';
            node-value: U+0085;
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.xml10.endofline.crnl.in.pi.1.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0"?>
          <?xml-$u000D$u0085?>
          <p/>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          pi {
            node-name: 'xml-';
            node-value: U+0085;
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.xml11.endofline.crnl.in.pi.1.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.1"?>
          <?xml-$u000D$u0085?>
          <p/>
      @@@test:domTree:
        document {
          xml-version: '1.1';
          pi {
            node-name: 'xml-';
            node-value: '';
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.xml10implied.endofline.ls.in.pi.1.test
      @@@DEnt:
        @@@@test:value:
          <?xml-$u2028?>
          <p/>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 7)..(2, 0); }
    @@XMLTest:
      @@@QName: xp.xml10.endofline.ls.in.pi.1.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0"?>
          <?xml-$u2028?>
          <p/>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (2, 7)..(3, 0); }
    @@XMLTest:
      @@@QName: xp.xml11.endofline.ls.in.pi.1.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.1"?>
          <?xml-$u2028?>
          <p/>
      @@@test:domTree:
        document {
          xml-version: '1.1';
          pi {
            node-name: 'xml-';
            node-value: '';
          }
          element { }
        }
    
    @@XMLTest:
      @@@QName: xp.xml10.endofline.internal.1.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0"?>
          <!DOCTYPE a [
          <!ENTITY e "&#x000D; &#x000A; &#x0085; &#x000D;&#x000A; $
          &#x000D;&#x0085; &#x2028;">
          ]><a>&e;</a>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          document-type {
            general-entity {
              node-name: 'e';
              text-content: U+000D ' ' U+000A ' ' U+0085 ' '
                            U+000D U+000A ' ' U+000D U+0085 ' ' U+2028;
            }
          }
          element {
            text-content: U+000D ' ' U+000A ' ' U+0085 ' '
                          U+000D U+000A ' ' U+000D U+0085 ' ' U+2028;
          }
        }
    @@XMLTest:
      @@@QName: xp.xml11.endofline.internal.1.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.1"?>
          <!DOCTYPE a [
          <!ENTITY e "&#x000D; &#x000A; &#x0085; &#x000D;&#x000A; $
          &#x000D;&#x0085; &#x2028;">
          ]><a>&e;</a>
      @@@test:domTree:
        document {
          xml-version: '1.1';
          document-type {
            general-entity {
              node-name: 'e';
              text-content: U+000D ' ' U+000A ' ' U+0085 ' '
                            U+000D U+000A ' ' U+000D U+0085 ' ' U+2028;
            }
          }
          element {
            text-content: U+000D ' ' U+000A ' ' U+0085 ' '
                          U+000D U+000A ' ' U+000D U+0085 ' ' U+2028;
          }
        }

    @@XMLTest:
      @@@QName: xp.noxmldecl.pi.pi.test
      @@@DEnt:
        @@@@test:value:
          <?noxml 1?><?noxml 2?><p/>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          pi {
            node-name: 'noxml';
            node-value: '1';
          }
          pi {
            node-name: 'noxml';
            node-value: '2';
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.noxmldecl.pi.pi.2.test
      @@@DEnt:
        @@@@test:value:
          <?xmlno 1?><?xmlno 2?><p/>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          pi {
            node-name: 'xmlno';
            node-value: '1';
          }
          pi {
            node-name: 'xmlno';
            node-value: '2';
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.noxmldecl.pi.pi.3.test
      @@@DEnt:
        @@@@test:value:
          <?xmln 1?><?xmln 2?><p/>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          pi {
            node-name: 'xmln';
            node-value: '1';
          }
          pi {
            node-name: 'xmln';
            node-value: '2';
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.noxml.s.nl.test
      @@@DEnt:
        @@@@test:value:
          $u0085<p/>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 1)..(2, 0); }
    @@XMLTest:
      @@@QName: xp.noxml.s.crnl.test
      @@@DEnt:
        @@@@test:value:
          $u000D$u0085<p/>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 1)..(2, 0); }
    @@XMLTest:
      @@@QName: xp.noxml.s.ls.test
      @@@DEnt:
        @@@@test:value:
          $u2028<p/>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 1)..(2, 0); }
    @@XMLTest:
      @@@QName: xp.xml10.decl.s.nl.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0"?>$u0085<p/>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 22)..(2, 0); }
    @@XMLTest:
      @@@QName: xp.xml10.decl.s.crnl.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0"?>$u000D$u0085<p/>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (2, 0)..(3, 0); }
    @@XMLTest:
      @@@QName: xp.xml10.decl.s.ls.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0"?>$u2028<p/>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 22)..(2, 0); }
    @@XMLTest:
      @@@QName: xp.xml11.decl.s.nl.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.1"?>$u0085<p/>
      @@@test:domTree:
        document {
          xml-version: '1.1';
          element { }
        }
    @@XMLTest:
      @@@QName: xp.xml11.decl.s.crnl.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.1"?>$u000D$u0085<p/>
      @@@test:domTree:
        document {
          xml-version: '1.1';
          element { }
        }
    @@XMLTest:
      @@@QName: xp.xml11.decl.s.ls.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.1"?>$u2028<p/>
      @@@test:domTree:
        document {
          xml-version: '1.1';
          element { }
        }

    @@XMLTest:
      @@@QName: xp.element.type.match.1.test
      @@@DEnt:
        @@@@test:value:
          <p></pa>(err)
      @@@c:erred: <[[xp|wf-element-type-match]]> { (1, 4)..(1, 8); }
      @@@c:erred: <[[xp|wf-syntax-error]]> { }
    @@XMLTest:
      @@@QName: xp.element.type.match.2.test
      @@@DEnt:
        @@@@test:value:
          <p><pa></pa></pa>(err)
      @@@c:erred: <[[xp|wf-element-type-match]]> { (1, 13)..(1, 17); }
      @@@c:erred: <[[xp|wf-syntax-error]]> { }
    @@XMLTest:
      @@@QName: xp.element.type.match.3.test
      @@@DEnt:
        @@@@test:value:
          <p><pa></p></p>(err)
      @@@c:erred: <[[xp|wf-element-type-match]]> { (1, 8)..(1, 11); }
      @@@c:erred: <[[xp|wf-syntax-error]]> { }
    @@XMLTest:
      @@@QName: xp.element.type.match.4.test
      @@@DEnt:
        @@@@test:value:
          <a:p xmlns:a="about:1"></p>(err)
      @@@c:erred: <[[xp|wf-element-type-match]]> { (1, 24)..(1, 27); }
      @@@c:erred: <[[xp|wf-syntax-error]]> { }
    @@XMLTest:
      @@@QName: xp.element.type.match.5.test
      @@@DEnt:
        @@@@test:value:
          <a:p xmlns:a="about:1" xmlns:b="about:1"></b:p>(err)
      @@@c:erred: <[[xp|wf-element-type-match]]> { (1, 42)..(1, 47); }
      @@@c:erred: <[[xp|wf-syntax-error]]> { }

    @@XMLTest:
      @@@QName: xp.stag.stago.name.etago.test
      @@@DEnt:
        @@@@test:value:
          <a</a>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 3); }
    @@XMLTest:
      @@@QName: xp.stag.stago.name.s.etago.test
      @@@DEnt:
        @@@@test:value:
          <a </a>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 4); }
    @@XMLTest:
      @@@QName: xp.stag.stago.name.s.attr.etago.test
      @@@DEnt:
        @@@@test:value:
          <a a="b"</a>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 9); }
    @@XMLTest:
      @@@QName: xp.stag.stago.name.s.attr.s.attr.etago.test
      @@@DEnt:
        @@@@test:value:
          <a a="b" c="d"</a>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 15); }
    @@XMLTest:
      @@@QName: xp.stag.stago.name.s.attr.s.etago.test
      @@@DEnt:
        @@@@test:value:
          <a a="b" </a>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 10); }
    @@XMLTest:
      @@@QName: xp.stag.etag.1.test
      @@@DEnt:
        @@@@test:value:
          <root><a></a></root>
      @@@test:domTree:
        document {
          element {
            element {
              node-name: 'a';
            }
          }
        }	
    @@XMLTest:
      @@@QName: xp.stag.etag.2.test
      @@@DEnt:
        @@@@test:value:
          <root><ab></ab></root>
      @@@test:domTree:
        document {
          element {
            element {
              node-name: 'ab';
            }
          }
        }	
    @@XMLTest:
      @@@QName: xp.stag.etag.s.1.test
      @@@DEnt:
        @@@@test:value:
          <root><a  ></a  ></root>
      @@@test:domTree:
        document {
          element {
            element {
              node-name: 'a';
            }
          }
        }	
    @@XMLTest:
      @@@QName: xp.etag.1.test
      @@@DEnt:
        @@@@test:value:
          <root><a/></root>
      @@@test:domTree:
        document {
          element {
            element {
              node-name: 'a';
            }
          }
        }	
    @@XMLTest:
      @@@QName: xp.etag.2.test
      @@@DEnt:
        @@@@test:value:
          <root><a    /></root>
      @@@test:domTree:
        document {
          element {
            element {
              node-name: 'a';
            }
          }
        }	
    @@XMLTest:
      @@@QName: xp.stag.etag.attr.1.test
      @@@DEnt:
        @@@@test:value:
          <root><a at="v"></a></root>
      @@@test:domTree:
        document {
          element {
            element {
              node-name: 'a';
              attribute {
                node-name: 'at';
                value: 'v';
              }
            }
          }
        }	
    @@XMLTest:
      @@@QName: xp.stag.etag.attr.2.test
      @@@DEnt:
        @@@@test:value:
          <root><a at="v"  ></a></root>
      @@@test:domTree:
        document {
          element {
            element {
              node-name: 'a';
              attribute {
                node-name: 'at';
                value: 'v';
              }
            }
          }
        }	
    @@XMLTest:
      @@@QName: xp.stag.etag.attr.3.test
      @@@DEnt:
        @@@@test:value:
          <root><a at     ="v"></a></root>
      @@@test:domTree:
        document {
          element {
            element {
              node-name: 'a';
              attribute {
                node-name: 'at';
                value: 'v';
              }
            }
          }
        }	
    @@XMLTest:
      @@@QName: xp.stag.etag.attr.4.test
      @@@DEnt:
        @@@@test:value:
          <root><a at=   "v"></a></root>
      @@@test:domTree:
        document {
          element {
            element {
              node-name: 'a';
              attribute {
                node-name: 'at';
                value: 'v';
              }
            }
          }
        }	
    @@XMLTest:
      @@@QName: xp.stag.etag.attr.5.test
      @@@DEnt:
        @@@@test:value:
          <root><a at='v'></a></root>
      @@@test:domTree:
        document {
          element {
            element {
              node-name: 'a';
              attribute {
                node-name: 'at';
                value: 'v';
              }
            }
          }
        }	
    @@XMLTest:
      @@@QName: xp.stag.etag.attr.6.test
      @@@DEnt:
        @@@@test:value:
          <root><a at=   'v'  ></a></root>
      @@@test:domTree:
        document {
          element {
            element {
              node-name: 'a';
              attribute {
                node-name: 'at';
                value: 'v';
              }
            }
          }
        }	
    @@XMLTest:
      @@@QName: xp.stag.etag.attr.attr.1.test
      @@@DEnt:
        @@@@test:value:
          <root><a at="v"  tr="w"></a></root>
      @@@test:domTree:
        document {
          element {
            element {
              node-name: 'a';
              attribute {
                node-name: 'at';
                value: 'v';
              }
              attribute {
                node-name: 'tr';
                value: 'w';
              }
            }
          }
        }	
    @@XMLTest:
      @@@QName: xp.stag.etag.attr.attr.2.test
      @@@DEnt:
        @@@@test:value:
          <root><a tr="w" at="v"></a></root>
      @@@test:domTree:
        document {
          element {
            element {
              node-name: 'a';
              attribute {
                node-name: 'at';
                value: 'v';
              }
              attribute {
                node-name: 'tr';
                value: 'w';
              }
            }
          }
        }	
    @@XMLTest:
      @@@QName: xp.stag.etag.attr.no.s.attr.test
      @@@DEnt:
        @@@@test:value:
          <root><a at="v"tr="w"></a></root>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 16)..(1, 17); }
    @@XMLTest:
      @@@QName: xp.etag.attr.1.test
      @@@DEnt:
        @@@@test:value:
          <root><a at="v" tr="w"></a b="c"></root>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 28); }
    @@XMLTest:
      @@@QName: xp.etag.no.etagc.1.test
      @@@DEnt:
        @@@@test:value:
          <root><a at="v" tr="w"></a</root>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 27)..(1, 28); }
    @@XMLTest:
      @@@QName: xp.etag.no.etagc.2.test
      @@@DEnt:
        @@@@test:value:
          <root><a at="v" tr="w"></a  </root>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 29)..(1, 30); }
    @@XMLTest:
      @@@QName: xp.mtag.attr.1.test
      @@@DEnt:
        @@@@test:value:
          <root><a  b="c"/></root>
      @@@test:domTree:
        document {
          element {
            element {
              node-name: 'a';
              attribute {
                node-name: 'b';
                value: 'c';
              }
            }
          }
        }	
    @@XMLTest:
      @@@QName: xp.mtag.attr.2.test
      @@@DEnt:
        @@@@test:value:
          <root><a  b="c"  /></root>
      @@@test:domTree:
        document {
          element {
            element {
              node-name: 'a';
              attribute {
                node-name: 'b';
                value: 'c';
              }
            }
          }
        }	
    @@XMLTest:
      @@@QName: xp.mtag.attr.3.test
      @@@DEnt:
        @@@@test:value:
          <root><a  b='c'/></root>
      @@@test:domTree:
        document {
          element {
            element {
              node-name: 'a';
              attribute {
                node-name: 'b';
                value: 'c';
              }
            }
          }
        }	
    @@XMLTest:
      @@@QName: xp.mtag.attr.4.test
      @@@DEnt:
        @@@@test:value:
          <root><a  b="c" d="e"/></root>
      @@@test:domTree:
        document {
          element {
            element {
              node-name: 'a';
              attribute {
                node-name: 'b';
                value: 'c';
              }
              attribute {
                node-name: 'd';
                value: 'e';
              }
            }
          }
        }	

    @@XMLTest:
      @@@QName: xp.attvalue.lt.1.test
      @@@DEnt:
        @@@@test:value:
          <a b="aa<dd"/>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 9); }
    @@XMLTest:
      @@@QName: xp.attvalue.lt.2.test
      @@@DEnt:
        @@@@test:value:
          <a b='aa<dd'/>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 9); }
    @@XMLTest:
      @@@QName: xp.attvalue.amp.1.test
      @@@DEnt:
        @@@@test:value:
          <a b="aa& dd"/>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 9)..(1, 12); }
    @@XMLTest:
      @@@QName: xp.attvalue.amp.2.test
      @@@DEnt:
        @@@@test:value:
          <a b='aa& dd'/>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 9)..(1, 12); }
    @@XMLTest:
      @@@QName: xp.attvalue.amp.3.test
      @@@DEnt:
        @@@@test:value:
          <a b="aa&# dd"/>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 9)..(1, 13); }
    @@XMLTest:
      @@@QName: xp.attvalue.amp.4.test
      @@@DEnt:
        @@@@test:value:
          <a b="aa&#x dd"/>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (1, 9)..(1, 14); }

    @@XMLTest:
      @@@QName: xp.unique.att.spec.1.test
      @@@DEnt:
        @@@@test:value:
          <a b="c" b="d"/>
      @@@c:erred: <[[xp|wf-unique-att-spec]]> { (1, 4)..(1, 14); }
    @@XMLTest:
      @@@QName: xp.unique.att.spec.2.test
      @@@DEnt:
        @@@@test:value:
          <a d:b="c" d:b="d" xmlns:d="about:2"/>
      @@@c:erred: <[[xp|wf-unique-att-spec]]> { (1, 4)..(1, 18); }

    @@XMLTest:
      @@@QName: xp.no.external.entity.references.1.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
            <!ENTITY ent SYSTEM "something">
          ]>
          <a b="c&ent;"/>
      @@@c:erred: <[[xp|wf-no-external-entity-references]]> { (4, 8)..(4, 12); }
    @@XMLTest:
      @@@QName: xp.no.external.entity.references.2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
            <!NOTATION n SYSTEM "notation">
            <!ENTITY ent SYSTEM "something" NDATA n>
          ]>
          <a b="c&ent;"/>
      @@@c:erred: <[[xp|wf-no-external-entity-references]]> { (5, 8)..(5, 12); }
    @@XMLTest:
      @@@QName: xp.no.external.entity.references.3.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
            <!ENTITY ent SYSTEM "something">
            <!ENTITY ent2 "ddd&ent;">
          ]>
          <a b="c&ent2;"/>
      @@@c:erred: <[[xp|wf-no-external-entity-references]]> { (1, 4)..(1, 8); }
    @@XMLTest:
      @@@QName: xp.no.external.entity.references.4.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
            <!NOTATION n SYSTEM "notation">
            <!ENTITY ent SYSTEM "something" NDATA n>
            <!ENTITY ent2 "ddd&ent;">
          ]>
          <a b="c&ent2;"/>
      @@@c:erred: <[[xp|wf-no-external-entity-references]]> { (1, 4)..(1, 8); }
      @@@c:erred: <[[xp|wf-parsed-entity]]> { }
    @@XMLTest:
      @@@QName: xp.no.lt.in.attr.value.1.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
          <!ENTITY ent "aa<bb">
          ]>
          <a b="c&ent;"/>
      @@@c:erred: <[[xp|wf-no-lt-in-attribute-values]]> { (1, 3); }
      @@@c:erred:
        @@@@@: <[[xp|wf-syntax-error]]> { (1, 3)..(1, 6); }
        @@@@enImplNote: When entity node is created.
    @@XMLTest:
      @@@QName: xp.no.lt.in.attr.value.2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
          <!ENTITY ent "aa<bb">
          <!ENTITY ent2 "ccc&ent;">
          ]>
          <a b="c&ent2;"/>
      @@@c:erred: <[[xp|wf-no-lt-in-attribute-values]]> { (1, 3); }
      @@@c:erred:
        @@@@@: <[[xp|wf-syntax-error]]> { (1, 3)..(1, 6); }
        @@@@enImplNote: When entity node is created.
    @@XMLTest:
      @@@QName: xp.no.lt.in.attr.value.3.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
          <!ENTITY ent "aa&#x3C;bb">
          ]>
          <a b="c&ent;"/>
      @@@c:erred: <[[xp|wf-no-lt-in-attribute-values]]> { (1, 3); }
      @@@c:erred:
        @@@@@: <[[xp|wf-syntax-error]]> { (1, 3)..(1, 6); }
        @@@@enImplNote: When entity node is created.
    @@XMLTest:
      @@@QName: xp.no.lt.in.attr.value.4.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
          <!ENTITY ent "aa&#x3C;bb">
          <!ENTITY ent2 "ccc&ent;">
          ]>
          <a b="c&ent2;"/>
      @@@c:erred: <[[xp|wf-no-lt-in-attribute-values]]> { (1, 3); }
      @@@c:erred:
        @@@@@: <[[xp|wf-syntax-error]]> { (1, 3)..(1, 6); }
        @@@@enImplNote: When entity node is created.
    @@XMLTest:
      @@@QName: xp.ger.lt.in.attr.value.1.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
          <!ENTITY ent "aa&lt;bb">
          ]>
          <a b="c&ent;"/>
      @@@test:domTree:
        document {
          document-type {
            general-entity {
              node-name: 'ent';
              text-content: 'aa<bb';
            }
          }
          element {
            attribute {
              node-name: 'b';
              text { data: 'c'; }
              general-entity-reference {
                is-expanded: true;
                node-name: 'ent';
                text-content: 'aa<bb';
              }
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.ger.lt.in.attr.value.2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
          <!ENTITY ent "aa&lt;bb">
          <!ENTITY ent2 "ccc&ent;">
          ]>
          <a b="c&ent2;"/>
      @@@test:domTree:
        document {
          document-type {
            general-entity {
              node-name: 'ent';
              text-content: 'aa<bb';
            }
            general-entity {
              node-name: 'ent2';
              text { data: 'ccc'; }
              general-entity-reference {
                node-name: 'ent';
                text-content: 'aa<bb';
                is-expanded: true;
              }
            }
          }
          element {
            attribute {
              node-name: 'b';
              text { data: 'c'; }
              general-entity-reference {
                node-name: 'ent2';
                text { data: 'ccc'; }
                general-entity-reference {
                  node-name: 'ent';
                  text-content: 'aa<bb';
                  is-expanded: true;
                }
                is-expanded: true;
              }
            }
          }
        }

    @@XMLTest:
      @@@QName: xp.doctype.intsubset.pi.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
            <?pi  data ?>
          ]>
          <a></a>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          xml-encoding: null;
          xml-standalone: false;
          document-type {
            node-name: 'a';
            pi {
              target: 'pi';
              data: 'data ';
            }
          }
          element {
            namespace-uri: null;
            prefix: null;
            local-name: 'a';
            text-content: '';
          }
        }
      @@@enImplNote:
        A DOM PI node in doctype node is a manakai extension.


    @@XMLTest:
      @@@QName: xp.doctype.intsubset.entity.general.internal.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
            <!ENTITY entity "entity value">
          ]>
          <a></a>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          xml-encoding: null;
          xml-standalone: false;
          document-type {
            node-name: 'a';
            general-entity {
              node-name: 'entity';
              text-content: 'entity value';
              has-replacement-tree: true;
            }
          }
          element {
            namespace-uri: null;
            prefix: null;
            local-name: 'a';
            text-content: '';
          }
        }
    @@XMLTest:
      @@@QName: xp.doctype.intsubset.entity.parameter.internal.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
            <!ENTITY % entity "entity value">
          ]>
          <a></a>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          xml-encoding: null;
          xml-standalone: false;
          document-type {
            node-name: 'a';
          }
          element {
            namespace-uri: null;
            prefix: null;
            local-name: 'a';
            text-content: '';
          }
        }

    @@XMLTest:
      @@@QName: xp.doctype.internal.entity.root.element.text.only.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
            <!ENTITY entity "entity value">
          ]>
          <a>&entity;</a>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          xml-encoding: null;
          xml-standalone: false;
          document-type {
            node-name: 'a';
            general-entity {
              node-name: 'entity';
              text-content: 'entity value';
              has-replacement-tree: true;
            }
          }
          element {
            namespace-uri: null;
            prefix: null;
            local-name: 'a';
            general-entity-reference {
              node-name: 'entity';
              text {
                data: 'entity value';
              }
              is-expanded: true;
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.doctype.internal.entity.root.element.text.mult.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
            <!ENTITY entity "entity value">
          ]>
          <a>&entity; and &entity;</a>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          xml-encoding: null;
          xml-standalone: false;
          document-type {
            node-name: 'a';
            general-entity {
              node-name: 'entity';
              text-content: 'entity value';
              has-replacement-tree: true;
            }
          }
          element {
            namespace-uri: null;
            prefix: null;
            local-name: 'a';
            general-entity-reference {
              node-name: 'entity';
              text {
                data: 'entity value';
              }
              is-expanded: true;
            }
            text { data: ' and '; }
            general-entity-reference {
              node-name: 'entity';
              text {
                data: 'entity value';
              }
              is-expanded: true;
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.doctype.internal.entity.root.element.text.element.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
            <!ENTITY entity "entity <p>value</p> with <e>element</e> ">
          ]>
          <a>&entity;</a>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          xml-encoding: null;
          xml-standalone: false;
          document-type {
            node-name: 'a';
            general-entity {
              node-name: 'entity';
              has-replacement-tree: true;
              text { data: 'entity '; }
              element {
                node-name: 'p';
                text-content: 'value';
              }
              text { data: ' with '; }
              element {
                node-name: 'e';
                text-content: 'element';
              }
              text { data: ' '; }
            }
          }
          element {
            namespace-uri: null;
            prefix: null;
            local-name: 'a';
            general-entity-reference {
              node-name: 'entity';
              is-expanded: true;
              text {
                data: 'entity ';
              }
              element {
                namespace-uri: null;
                prefix: null;
                local-name: 'p';
                text {
                  data: 'value';
                }
              }
              text {
                data: ' with ';
              }
              element {
                namespace-uri: null;
                prefix: null;
                local-name: 'e';
                text {
                  data: 'element';
                }
              }
              text {
                data: ' ';
              }
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.doctype.internal.entity.root.element.text.in.ent.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
            <!ENTITY entity1 "entity value">
            <!ENTITY entity2 "e&entity1;n">
          ]>
          <a>&entity2;</a>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          xml-encoding: null;
          xml-standalone: false;
          document-type {
            node-name: 'a';
            general-entity {
              node-name: 'entity1';
              text-content: 'entity value';
            }
            general-entity {
              node-name: 'entity2';
              text { data: 'e'; }
              general-entity-reference {
                node-name: 'entity1';
                text-content: 'entity value';
                is-expanded: true;
              }
              text { data: 'n'; }
            }
          }
          element {
            namespace-uri: null;
            prefix: null;
            local-name: 'a';
            general-entity-reference {
              node-name: 'entity2';
              text { data: 'e'; }
              is-expanded: true;
              general-entity-reference {
                node-name: 'entity1';
                text {
                  data: 'entity value';
                }
                is-expanded: true;
              }
              text { data: 'n'; }
            }
          }
        }

    @@XMLTest:
      @@@QName: xp.doctype.entity.value.charref.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
            <!ENTITY entity1 "entity &#x21;value&#35;">
            <!ENTITY entity2 '&#x21;value&#35;'>
          ]>
          <a></a>
      @@@test:domTree:
        document {
          document-type {
            general-entity {
              node-name: 'entity1';
              text-content: 'entity !value#';
              has-replacement-tree: true;
            }
            general-entity {
              node-name: 'entity2';
              text-content: '!value#';
              has-replacement-tree: true;
            }
          }
          element { }
        }

    @@XMLTest:
      @@@QName: xp.predefined.in.content.test
      @@@DEnt:
        @@@@test:value:
          <a>_&lt;_&gt;_&quot;_&apos;_&amp;_</a>
      @@@test:domTree:
        document {
          element {
            text-content: '_<_>_"_' U+0027 '_&_';
          }
        }
    @@XMLTest:
      @@@QName: xp.predefined.in.attr.test
      @@@DEnt:
        @@@@test:value:
          <a at="_&lt;_&gt;_&quot;_&apos;_&amp;_"></a>
      @@@test:domTree:
        document {
          element {
            attribute {
              node-name: 'at';
              text-content: '_<_>_"_' U+0027 '_&_';
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.predefined.in.content.in.entity.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
            <!ENTITY ent "_&lt;_&gt;_&quot;_&apos;_&amp;_">
          ]>
          <a>&ent;</a>
      @@@test:domTree:
        document {
          document-type {
            general-entity {
              node-name: 'ent';
              text-content: '_<_>_"_' U+0027 '_&_';
            }
          }
          element {
            text-content: '_<_>_"_' U+0027 '_&_';
          }
        }
    @@XMLTest:
      @@@QName: xp.predefined.decl.ignore.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
            <!ENTITY lt "&#x26;#x3C;">
            <!ENTITY gt "&#x3E;">
            <!ENTITY amp "&#x26;#x26;">
            <!ENTITY quot "&#x22;">
            <!ENTITY apos "&#x27;">
            <!ENTITY other "other">
          ]>
          <a>_&lt;_&gt;_&quot;_&apos;_&amp;_&other;_</a>
      @@@test:domTree:
        document {
          document-type {
            general-entity {
              node-name: 'other';
              text-content: 'other';
            }
          }
          element {
            text-content: '_<_>_"_' U+0027 '_&_other_';
          }
        }

    @@XMLTest:
      @@@QName: xp.doctype.internal.attr.empty.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
            <!ATTLIST a>
          ]>
          <a></a>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          xml-encoding: null;
          xml-standalone: false;
          document-type {
            node-name: 'a';
            element-type-definition {
              node-name: 'a';
            }
          }
          element {
            namespace-uri: null;
            local-name: 'a';
          }
        }
    @@XMLTest:
      @@@QName: xp.doctype.internal.attr.cdata.implied.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
            <!ATTLIST a
              at   CDATA    #IMPLIED
            >
          ]>
          <a></a>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          xml-encoding: null;
          xml-standalone: false;
          document-type {
            node-name: 'a';
            element-type-definition {
              node-name: 'a';
              attribute-definition {
                node-name: 'at';
                declared-type: const (CDATA_ATTR);
                allowed-tokens: DOMStringList ();
                default-type: const (IMPLIED_DEFAULT);
                text-content: '';
              }
            }
          }
          element {
            namespace-uri: null;
            local-name: 'a';
          }
        }
    @@XMLTest:
      @@@QName: xp.doctype.internal.attr.types.implied.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
            <!ATTLIST a
              at1   ID        #IMPLIED
              at2   IDREF     #IMPLIED
              at3   IDREFS    #IMPLIED
              at4   ENTITY    #IMPLIED
              at5   ENTITIES  #IMPLIED
              at6   NMTOKEN   #IMPLIED
              at7   NMTOKENS  #IMPLIED
              at8   NOTATION  (n1 | n2|n3)  #IMPLIED
              at9   (e1| e2| e3 ) #IMPLIED
            >
          ]>
          <a></a>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          xml-encoding: null;
          xml-standalone: false;
          document-type {
            node-name: 'a';
            element-type-definition {
              node-name: 'a';
              attribute-definition {
                node-name: 'at1';
                declared-type: const (ID_ATTR);
                allowed-tokens: DOMStringList ();
                default-type: const (IMPLIED_DEFAULT);
                text-content: '';
              }
              attribute-definition {
                node-name: 'at2';
                declared-type: const (IDREF_ATTR);
                allowed-tokens: DOMStringList ();
                default-type: const (IMPLIED_DEFAULT);
                text-content: '';
              }
              attribute-definition {
                node-name: 'at3';
                declared-type: const (IDREFS_ATTR);
                allowed-tokens: DOMStringList ();
                default-type: const (IMPLIED_DEFAULT);
                text-content: '';
              }
              attribute-definition {
                node-name: 'at4';
                declared-type: const (ENTITY_ATTR);
                allowed-tokens: DOMStringList ();
                default-type: const (IMPLIED_DEFAULT);
                text-content: '';
              }
              attribute-definition {
                node-name: 'at5';
                declared-type: const (ENTITIES_ATTR);
                allowed-tokens: DOMStringList ();
                default-type: const (IMPLIED_DEFAULT);
                text-content: '';
              }
              attribute-definition {
                node-name: 'at6';
                declared-type: const (NMTOKEN_ATTR);
                allowed-tokens: DOMStringList ();
                default-type: const (IMPLIED_DEFAULT);
                text-content: '';
              }
              attribute-definition {
                node-name: 'at7';
                declared-type: const (NMTOKENS_ATTR);
                allowed-tokens: DOMStringList ();
                default-type: const (IMPLIED_DEFAULT);
                text-content: '';
              }
              attribute-definition {
                node-name: 'at8';
                declared-type: const (NOTATION_ATTR);
                allowed-tokens: DOMStringList ('n1', 'n2', 'n3');
                default-type: const (IMPLIED_DEFAULT);
                text-content: '';
              }
              attribute-definition {
                node-name: 'at9';
                declared-type: const (ENUMERATION_ATTR);
                allowed-tokens: DOMStringList ('e1', 'e2', 'e3');
                default-type: const (IMPLIED_DEFAULT);
                text-content: '';
              }
            }
          }
          element {
            namespace-uri: null;
            local-name: 'a';
          }
        }
    @@XMLTest:
      @@@QName: xp.doctype.internal.attr.cdata.defaults.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
            <!ATTLIST a
              at1   CDATA    #IMPLIED
              at2   CDATA    #REQUIRED
              at3   CDATA    #FIXED     "value3"
              at4   CDATA    "value4"
              at5   CDATA    #FIXED     'value5'
              at6   CDATA    'value6'
            >
          ]>
          <a></a>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          xml-encoding: null;
          xml-standalone: false;
          document-type {
            node-name: 'a';
            element-type-definition {
              node-name: 'a';
              attribute-definition {
                node-name: 'at1';
                declared-type: const (CDATA_ATTR);
                allowed-tokens: DOMStringList ();
                default-type: const (IMPLIED_DEFAULT);
                text-content: '';
              }
              attribute-definition {
                node-name: 'at2';
                declared-type: const (CDATA_ATTR);
                allowed-tokens: DOMStringList ();
                default-type: const (REQUIRED_DEFAULT);
                text-content: '';
              }
              attribute-definition {
                node-name: 'at3';
                declared-type: const (CDATA_ATTR);
                allowed-tokens: DOMStringList ();
                default-type: const (FIXED_DEFAULT);
                text-content: 'value3';
              }
              attribute-definition {
                node-name: 'at4';
                declared-type: const (CDATA_ATTR);
                allowed-tokens: DOMStringList ();
                default-type: const (EXPLICIT_DEFAULT);
                text-content: 'value4';
              }
              attribute-definition {
                node-name: 'at5';
                declared-type: const (CDATA_ATTR);
                allowed-tokens: DOMStringList ();
                default-type: const (FIXED_DEFAULT);
                text-content: 'value5';
              }
              attribute-definition {
                node-name: 'at6';
                declared-type: const (CDATA_ATTR);
                allowed-tokens: DOMStringList ();
                default-type: const (EXPLICIT_DEFAULT);
                text-content: 'value6';
              }
            }
          }
          element {
            namespace-uri: null;
            local-name: 'a';
            attribute {
              node-name: 'at3';
              text-content: 'value3';
              specified: false;
            }
            attribute {
              node-name: 'at4';
              text-content: 'value4';
              specified: false;
            }
            attribute {
              node-name: 'at5';
              text-content: 'value5';
              specified: false;
            }
            attribute {
              node-name: 'at6';
              text-content: 'value6';
              specified: false;
            }
          }
        }

    @@XMLTest:
      @@@QName: xp.doctype.internal.attr.cdata.default.normalize.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
            <!ATTLIST a
              at   CDATA    "  default &#x0A;value  "
            >
          ]>
          <a></a>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          xml-encoding: null;
          xml-standalone: false;
          document-type {
            node-name: 'a';
            element-type-definition {
              node-name: 'a';
              attribute-definition {
                node-name: 'at';
                declared-type: const (CDATA_ATTR);
                allowed-tokens: DOMStringList ();
                default-type: const (EXPLICIT_DEFAULT);
                text-content: '  default ' U+000A 'value  ';
              }
            }
          }
          element {
            namespace-uri: null;
            local-name: 'a';
            attribute {
              node-name: 'at';
              text-content: '  default ' U+000A 'value  ';
              specified: false;
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.doctype.internal.attr.nmtoken.default.normalize.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
            <!ATTLIST a
              at   NMTOKEN    "  default &#x0A;value  "
            >
          ]>
          <a></a>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          xml-encoding: null;
          xml-standalone: false;
          document-type {
            node-name: 'a';
            element-type-definition {
              node-name: 'a';
              attribute-definition {
                node-name: 'at';
                declared-type: const (NMTOKEN_ATTR);
                allowed-tokens: DOMStringList ();
                default-type: const (EXPLICIT_DEFAULT);
                text-content: '  default ' U+000A 'value  ';
              }
            }
          }
          element {
            namespace-uri: null;
            local-name: 'a';
            attribute {
              node-name: 'at';
              text-content: '  default ' U+000A 'value  ';
              specified: false;
            }
          }
        }

    @@XMLTest:
      @@@QName: xp.doctype.attrtype.no-value.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a>
          <a at="  at  value  "></a>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          xml-encoding: null;
          xml-standalone: false;
          document-type { }
          element {
            namespace-uri: null;
            local-name: 'a';
            attribute {
              namespace-uri: null;
              local-name: 'at';
              value: '  at  value  ';
              text {
                data: '  at  value  ';
              }
              schema-type-info: TypeInfo (null, null);
              specified: true;
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.doctype.attrtype.cdata.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
            <!ATTLIST a
              at   CDATA    #IMPLIED
            >
          ]>
          <a at="  at  value  "></a>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          xml-encoding: null;
          xml-standalone: false;
          document-type { }
          element {
            namespace-uri: null;
            local-name: 'a';
            attribute {
              namespace-uri: null;
              local-name: 'at';
              value: '  at  value  ';
              text {
                data: '  at  value  ';
              }
              schema-type-info:
                TypeInfo ('http://www.w3.org/TR/REC-xml', 'CDATA');
              specified: true;
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.doctype.attrtype.nmtoken.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
            <!ATTLIST a
              at   NMTOKEN    #IMPLIED
            >
          ]>
          <a at="  at  value  "></a>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          xml-encoding: null;
          xml-standalone: false;
          document-type { }
          element {
            namespace-uri: null;
            local-name: 'a';
            attribute {
              namespace-uri: null;
              local-name: 'at';
              value: 'at value';
              text {
                data: '  at  value  ';
              }
              schema-type-info:
                TypeInfo ('http://www.w3.org/TR/REC-xml', 'NMTOKEN');
              specified: true;
            }
          }
        }

    @@XMLTest:
      @@@QName: xp.doctype.attr.normalization.1.test
      @@@DEnt:
        @@@@test:value:
          <a at="  at &#xA;value  "></a>
      @@@test:domTree:
        document {
          element {
            attribute {
              node-name: 'at';
              value: '  at ' U+000A 'value  ';
              schema-type-info: TypeInfo (null, null);
              specified: true;
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.doctype.attr.normalization.2.test
      @@@DEnt:
        @@@@test:value:
          <a at="  at &#xD;value  "></a>
      @@@test:domTree:
        document {
          element {
            attribute {
              value: '  at ' U+000D 'value  ';
              schema-type-info: TypeInfo (null, null);
              specified: true;
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.doctype.attr.normalization.3.test
      @@@DEnt:
        @@@@test:value:
          <a at="  at &#x9;value  "></a>
      @@@test:domTree:
        document {
          element {
            attribute {
              node-name: 'at';
              value: '  at ' U+0009 'value  ';
              schema-type-info: TypeInfo (null, null);
              specified: true;
            }
          }
        }

    @@XMLTest:
      @@@QName: xp.doctype.attr.specified.1.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
            <!ATTLIST a
              at  CDATA  "default"
            >
          ]>
          <a></a>
      @@@test:domTree:
        document {
          document-type { }
          element {
            attribute {
              node-name: 'at';
              value: 'default';
              specified: false;
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.doctype.attr.specified.2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
            <!ATTLIST a
              at  CDATA  "default"
            >
          ]>
          <a at2="specified"></a>
      @@@test:domTree:
        document {
          document-type { }
          element {
            attribute {
              node-name: 'at';
              value: 'default';
              specified: false;
            }
            attribute {
              node-name: 'at2';
              value: 'specified';
              specified: true;
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.doctype.attr.specified.3.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
            <!ATTLIST a
              at  CDATA  "default"
            >
          ]>
          <a at="specified"></a>
      @@@test:domTree:
        document {
          document-type { }
          element {
            attribute {
              node-name: 'at';
              value: 'specified';
              specified: true;
            }
          }
        }

    @@XMLTest:
      @@@QName: xp.attr.literal.charref.test
      @@@DEnt:
        @@@@test:value:
          <a at1 = "value&#33;_&#x25;value"
             at2 = 'value&#x25;_&#33;value'></a>
      @@@test:domTree:
        document {
          element {
            attribute {
              node-name: 'at1';
              text-content: 'value!_%value';
            }
            attribute {
              node-name: 'at2';
              text-content: 'value%_!value';
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.attr.literal.entref.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
            <!ENTITY ent "entity&#x26;#33;_&#x26;#x29;value">
          ]>
          <a at1 = "value&ent;value"
             at2 = 'value&ent;value'></a>
      @@@test:domTree:
        document {
          document-type {
            general-entity {
              node-name: 'ent';
              text-content: 'entity!_)value';
            }
          }
          element {
            attribute {
              node-name: 'at1';
              text-content: 'valueentity!_)valuevalue';
            }
            attribute {
              node-name: 'at2';
              text-content: 'valueentity!_)valuevalue';
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.attr.literal.entref.nest.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
            <!ENTITY ent1 "entity&#x26;#33;_&#x26;#x29;value">
            <!ENTITY ent2 "@&ent1;@">
          ]>
          <a at1 = "value&ent2;value"
             at2 = 'value&ent2;value'></a>
      @@@test:domTree:
        document {
          document-type {
            general-entity {
              node-name: 'ent1';
              text-content: 'entity!_)value';
            }
            general-entity {
              node-name: 'ent2';
              text-content: '@entity!_)value@';
            }
          }
          element {
            attribute {
              node-name: 'at1';
              text-content: 'value@entity!_)value@value';
            }
            attribute {
              node-name: 'at2';
              text-content: 'value@entity!_)value@value';
            }
          }
        }

    @@XMLTest:
      @@@QName: xp.element.content.ncr.1.test
      @@@DEnt:
        @@@@test:value:
          <e>&#33;</e>
      @@@test:domTree:
        document {
          element {
            text-content: '!';
          }
        }
    @@XMLTest:
      @@@QName: xp.element.content.ncr.2.test
      @@@DEnt:
        @@@@test:value:
          <e>aaaa&#33;bbbb</e>
      @@@test:domTree:
        document {
          element {
            text-content: 'aaaa!bbbb';
          }
        }
    @@XMLTest:
      @@@QName: xp.attrval.ncr.1.test
      @@@DEnt:
        @@@@test:value:
          <e a="&#33;"/>
      @@@test:domTree:
        document {
          element {
            attribute {
              node-name: 'a';
              text-content: '!';
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.attrval.ncr.2.test
      @@@DEnt:
        @@@@test:value:
          <e a="aaaaa&#33;bbbbb"/>
      @@@test:domTree:
        document {
          element {
            attribute {
              node-name: 'a';
              text-content: 'aaaaa!bbbbb';
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.attrval.ncr.3.test
      @@@DEnt:
        @@@@test:value:
          <e a='&#33;'/>
      @@@test:domTree:
        document {
          element {
            attribute {
              node-name: 'a';
              text-content: '!';
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.attrval.ncr.4.test
      @@@DEnt:
        @@@@test:value:
          <e a='aaaaa&#33;bbbbb'/>
      @@@test:domTree:
        document {
          element {
            attribute {
              node-name: 'a';
              text-content: 'aaaaa!bbbbb';
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.entval.ncr.1.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE e [
            <!ENTITY ent "&#33;">
          ]>
          <e/>
      @@@test:domTree:
        document {
          document-type {
            general-entity {
              node-name: 'ent';
              text-content: '!';
            }
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.entval.ncr.2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE e [
            <!ENTITY ent "aaaaa&#33;bbbbb">
          ]>
          <e/>
      @@@test:domTree:
        document {
          document-type {
            general-entity {
              node-name: 'ent';
              text-content: 'aaaaa!bbbbb';
            }
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.element.content.reptxt.ncr.1.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE e [
            <!ENTITY ent "&#38;#33;">
          ]>
          <e>&ent;</e>
      @@@test:domTree:
        document {
          document-type { }
          element {
            general-entity-reference {
              node-name: 'ent';
              text-content: '!';
              is-expanded: true;
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.element.content.reptxt.ncr.2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE e [
            <!ENTITY ent "aaaaa&#38;#33;bbbbb">
          ]>
          <e>&ent;</e>
      @@@test:domTree:
        document {
          document-type { }
          element {
            general-entity-reference {
              node-name: 'ent';
              text-content: 'aaaaa!bbbbb';
              is-expanded: true;
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.element.content.reptxt.reptxt.ncr.1.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE e [
            <!ENTITY ent "&#38;#33;">
            <!ENTITY ent2 "&ent;">
          ]>
          <e>&ent2;</e>
      @@@test:domTree:
        document {
          document-type { }
          element {
            general-entity-reference {
              node-name: 'ent2';
              general-entity-reference {
                node-name: 'ent';
                text-content: '!';
                is-expanded: true;
              }
              is-expanded: true;
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.element.content.reptxt.reptxt.ncr.2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE e [
            <!ENTITY ent "aa&#38;#33;bb">
            <!ENTITY ent2 "&ent;">
          ]>
          <e>&ent2;</e>
      @@@test:domTree:
        document {
          document-type { }
          element {
            general-entity-reference {
              node-name: 'ent2';
              general-entity-reference {
                node-name: 'ent';
                text-content: 'aa!bb';
                is-expanded: true;
              }
              is-expanded: true;
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.attval.reptxt.ncr.1.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE e [
            <!ENTITY ent "&#38;#33;">
          ]>
          <e a="&ent;"/>
      @@@test:domTree:
        document {
          document-type { }
          element {
            attribute {
              node-name: 'a';
              general-entity-reference {
                node-name: 'ent';
                text-content: '!';
                is-expanded: true;
              }
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.attval.reptxt.ncr.2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE e [
            <!ENTITY ent "aaaaa&#38;#33;bbbbb">
          ]>
          <e a="&ent;"/>
      @@@test:domTree:
        document {
          document-type { }
          element {
            attribute {
              node-name: 'a';
              general-entity-reference {
                node-name: 'ent';
                text-content: 'aaaaa!bbbbb';
                is-expanded: true;
              }
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.attval.reptxt.reptxt.ncr.1.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE e [
            <!ENTITY ent "&#38;#33;">
            <!ENTITY ent2 "&ent;">
          ]>
          <e a="&ent2;"/>
      @@@test:domTree:
        document {
          document-type { }
          element {
            attribute {
              node-name: 'a';
              general-entity-reference {
                node-name: 'ent2';
                is-expanded: true;
                general-entity-reference {
                  node-name: 'ent';
                  text-content: '!';
                  is-expanded: true;
                }
              }
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.attval.reptxt.reptxt.ncr.2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE e [
            <!ENTITY ent "aa&#38;#33;bb">
            <!ENTITY ent2 "&ent;">
          ]>
          <e a="&ent2;"/>
      @@@test:domTree:
        document {
          document-type { }
          element {
            attribute {
              node-name: 'a';
              general-entity-reference {
                node-name: 'ent2';
                is-expanded: true;
                general-entity-reference {
                  node-name: 'ent';
                  text-content: 'aa!bb';
                  is-expanded: true;
                }
              }
            }
          }
        }

    @@XMLTest:
      @@@QName: xp.element.content.hcr.1.test
      @@@DEnt:
        @@@@test:value:
          <e>&#x21;</e>
      @@@test:domTree:
        document {
          element {
            text-content: '!';
          }
        }
    @@XMLTest:
      @@@QName: xp.element.content.hcr.2.test
      @@@DEnt:
        @@@@test:value:
          <e>aaaa&#x21;bbbb</e>
      @@@test:domTree:
        document {
          element {
            text-content: 'aaaa!bbbb';
          }
        }
    @@XMLTest:
      @@@QName: xp.attrval.hcr.1.test
      @@@DEnt:
        @@@@test:value:
          <e a="&#x21;"/>
      @@@test:domTree:
        document {
          element {
            attribute {
              node-name: 'a';
              text-content: '!';
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.attrval.hcr.2.test
      @@@DEnt:
        @@@@test:value:
          <e a="aaaaa&#x21;bbbbb"/>
      @@@test:domTree:
        document {
          element {
            attribute {
              node-name: 'a';
              text-content: 'aaaaa!bbbbb';
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.attrval.hcr.3.test
      @@@DEnt:
        @@@@test:value:
          <e a='&#x21;'/>
      @@@test:domTree:
        document {
          element {
            attribute {
              node-name: 'a';
              text-content: '!';
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.attrval.hcr.4.test
      @@@DEnt:
        @@@@test:value:
          <e a='aaaaa&#x21;bbbbb'/>
      @@@test:domTree:
        document {
          element {
            attribute {
              node-name: 'a';
              text-content: 'aaaaa!bbbbb';
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.entval.hcr.1.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE e [
            <!ENTITY ent "&#x21;">
          ]>
          <e/>
      @@@test:domTree:
        document {
          document-type {
            general-entity {
              node-name: 'ent';
              text-content: '!';
            }
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.entval.hcr.2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE e [
            <!ENTITY ent "aaaaa&#x21;bbbbb">
          ]>
          <e/>
      @@@test:domTree:
        document {
          document-type {
            general-entity {
              node-name: 'ent';
              text-content: 'aaaaa!bbbbb';
            }
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.element.content.reptxt.hcr.1.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE e [
            <!ENTITY ent "&#38;#x21;">
          ]>
          <e>&ent;</e>
      @@@test:domTree:
        document {
          document-type { }
          element {
            general-entity-reference {
              node-name: 'ent';
              text-content: '!';
              is-expanded: true;
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.element.content.reptxt.hcr.2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE e [
            <!ENTITY ent "aaaaa&#38;#x21;bbbbb">
          ]>
          <e>&ent;</e>
      @@@test:domTree:
        document {
          document-type { }
          element {
            general-entity-reference {
              node-name: 'ent';
              text-content: 'aaaaa!bbbbb';
              is-expanded: true;
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.element.content.reptxt.reptxt.hcr.1.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE e [
            <!ENTITY ent "&#38;#x21;">
            <!ENTITY ent2 "&ent;">
          ]>
          <e>&ent2;</e>
      @@@test:domTree:
        document {
          document-type { }
          element {
            general-entity-reference {
              node-name: 'ent2';
              is-expanded: true;
              general-entity-reference {
                node-name: 'ent';
                text-content: '!';
                is-expanded: true;
              }
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.element.content.reptxt.reptxt.hcr.2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE e [
            <!ENTITY ent "aa&#38;#x21;bb">
            <!ENTITY ent2 "&ent;">
          ]>
          <e>&ent2;</e>
      @@@test:domTree:
        document {
          document-type { }
          element {
            general-entity-reference {
              node-name: 'ent2';
              is-expanded: true;
              general-entity-reference {
                node-name: 'ent';
                is-expanded: true;
                text-content: 'aa!bb';
              }
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.attval.reptxt.hcr.1.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE e [
            <!ENTITY ent "&#38;#x21;">
          ]>
          <e a="&ent;"/>
      @@@test:domTree:
        document {
          document-type { }
          element {
            attribute {
              node-name: 'a';
              general-entity-reference {
                node-name: 'ent';
                is-expanded: true;
                text-content: '!';
              }
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.attval.reptxt.hcr.2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE e [
            <!ENTITY ent "aaaaa&#38;#x21;bbbbb">
          ]>
          <e a="&ent;"/>
      @@@test:domTree:
        document {
          document-type { }
          element {
            attribute {
              node-name: 'a';
              general-entity-reference {
                node-name: 'ent';
                is-expanded: true;
                text-content: 'aaaaa!bbbbb';
              }
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.attval.reptxt.reptxt.hcr.1.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE e [
            <!ENTITY ent "&#38;#x21;">
            <!ENTITY ent2 "&ent;">
          ]>
          <e a="&ent2;"/>
      @@@test:domTree:
        document {
          document-type { }
          element {
            attribute {
              node-name: 'a';
              general-entity-reference {
                node-name: 'ent2';
                is-expanded: true;
                general-entity-reference {
                  node-name: 'ent';
                  is-expanded: true;
                  text-content: '!';
                }
              }
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.attval.reptxt.reptxt.hcr.2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE e [
            <!ENTITY ent "aa&#38;#x21;bb">
            <!ENTITY ent2 "&ent;">
          ]>
          <e a="&ent2;"/>
      @@@test:domTree:
        document {
          document-type { }
          element {
            attribute {
              node-name: 'a';
              general-entity-reference {
                node-name: 'ent2';
                is-expanded: true;
                general-entity-reference {
                  node-name: 'ent';
                  is-expanded: true;
                  text-content: 'aa!bb';
                }
              }
            }
          }
        }

    @@XMLTest:
      @@@QName: xp.element.content.ncr.legal.char.1.0.1.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0"?>
          <e>&#0;</e>
      @@@c:erred: <[[xp|wf-legal-character]]> { (2, 4)..(2, 7); }
    @@XMLTest:
      @@@QName: xp.element.content.ncr.legal.char.1.1.1.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.1"?>
          <e>&#0;</e>
      @@@c:erred: <[[xp|wf-legal-character]]> { (2, 4)..(2, 7); }
    @@XMLTest:
      @@@QName: xp.element.content.ncr.legal.char.1.0.2.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0"?>
          <e>&#1;</e>
      @@@c:erred: <[[xp|wf-legal-character]]> { (2, 4)..(2, 7); }
    @@XMLTest:
      @@@QName: xp.element.content.ncr.legal.char.1.1.2.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.1"?>
          <e>&#1;</e>
      @@@test:domTree:
        document {
          xml-version: '1.1';
          element {
            text-content: U+0001;
          }
        }
    @@XMLTest:
      @@@QName: xp.element.content.hcr.legal.char.1.0.1.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0"?>
          <e>&#x0;</e>
      @@@c:erred: <[[xp|wf-legal-character]]> { (2, 4)..(2, 8); }
    @@XMLTest:
      @@@QName: xp.element.content.hcr.legal.char.1.1.1.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.1"?>
          <e>&#x0;</e>
      @@@c:erred: <[[xp|wf-legal-character]]> { (2, 4)..(2, 8); }
    @@XMLTest:
      @@@QName: xp.element.content.hcr.legal.char.1.0.2.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0"?>
          <e>&#x1;</e>
      @@@c:erred: <[[xp|wf-legal-character]]> { (2, 4)..(2, 8); }
    @@XMLTest:
      @@@QName: xp.element.content.hcr.legal.char.1.1.2.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.1"?>
          <e>&#x1;</e>
      @@@test:domTree:
        document {
          xml-version: '1.1';
          element {
            text-content: U+0001;
          }
        }

    @@XMLTest:
      @@@QName: xp.element.content.ger.entity.declared.nodtd.1.test
      @@@DEnt:
        @@@@test:value:
          <p>&entity;</p>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (1, 4)..(1, 11); }
    @@XMLTest:
      @@@QName: xp.element.content.ger.entity.declared.nodtd.2.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="yes"?>
          <p>&entity;</p>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (2, 4)..(2, 11); }
    @@XMLTest:
      @@@QName: xp.element.content.ger.entity.declared.nodtd.3.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="no"?>
          <p>&entity;</p>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (2, 4)..(2, 11); }
    @@XMLTest:
      @@@QName: xp.element.content.ger.entity.declared.nodtd.-1.test
      @@@DEnt:
        @@@@test:value:
          <p>&lt;&gt;&amp;&quot;&apos;</p>
      @@@test:domTree:
        document {
          element {
            text-content: '<>&"' U+0027;
          }
        }
    @@XMLTest:
      @@@QName: xp.element.content.ger.entity.declared.nopref.1.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p []>
          <p>&entity;</p>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (2, 4)..(2, 11); }
    @@XMLTest:
      @@@QName: xp.element.content.ger.entity.declared.nopref.2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p [
            <!ENTITY other "aa">
            <!ENTITY % another "aa">
          ]>
          <p>&entity;</p>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (5, 4)..(5, 11); }
    @@XMLTest:
      @@@QName: xp.element.content.ger.entity.declared.nopref.3.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="yes"?>
          <!DOCTYPE p []>
          <p>&entity;</p>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (3, 4)..(3, 11); }
    @@XMLTest:
      @@@QName: xp.element.content.ger.entity.declared.nopref.4.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="no"?>
          <!DOCTYPE p []>
          <p>&entity;</p>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (3, 4)..(3, 11); }
    @@XMLTest:
      @@@QName: xp.element.content.ger.entity.declared.nopref.5.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="yes"?>
          <!DOCTYPE p [
            <!ENTITY other "aa">
            <!ENTITY % another "aa">
          ]>
          <p>&entity;</p>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (6, 4)..(6, 11); }
    @@XMLTest:
      @@@QName: xp.element.content.ger.entity.declared.nopref.6.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="no"?>
          <!DOCTYPE p [
            <!ENTITY other "aa">
            <!ENTITY % another "aa">
          ]>
          <p>&entity;</p>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (6, 4)..(6, 11); }
    @@XMLTest:
      @@@QName: xp.element.content.ger.entity.declared.nopref.-1.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p [
            <!ENTITY entity "value">
          ]>
          <p>&entity;</p>
      @@@test:domTree:
        document {
          document-type {
            general-entity {
              node-name: 'entity';
              text-content: 'value';
            }
          }
          element {
            general-entity-reference {
              node-name: 'entity';
              is-expanded: true;
              text-content: 'value';
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.element.content.ger.entity.declared.nopref.-2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p [
            <!ENTITY entity "value">
            <!ENTITY another SYSTEM "another">
          ]>
          <p>&entity;</p>
      @@@test:domTree:
        document {
          document-type {
            general-entity {
              node-name: 'entity';
              text-content: 'value';
            }
            general-entity {
              node-name: 'another';
              public-id: null;
              system-id: 'another';
            }
          }
          element {
            general-entity-reference {
              node-name: 'entity';
              is-expanded: true;
              text-content: 'value';
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.element.content.ger.entity.declared.standalone.1.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="yes"?>
          <p>&entity;</p>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (2, 4)..(2, 11); }
    @@XMLTest:
      @@@QName: xp.element.content.ger.entity.declared.standalone.2.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="yes"?>
          <!DOCTYPE p []>
          <p>&entity;</p>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (3, 4)..(3, 11); }
    @@XMLTest:
      @@@QName: xp.element.content.ger.entity.declared.standalone.3.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="yes"?>
          <!DOCTYPE p [
            <!ENTITY % para "<!-- -->">
            %para;
          ]>
          <p>&entity;</p>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (6, 4)..(6, 11); }
    @@XMLTest:
      @@@QName: xp.element.content.ger.entity.declared.standalone.-1.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="no"?>
          <!DOCTYPE p [
            <!ENTITY % para "<!-- -->">
            %para;
          ]>
          <p>&entity;</p>
      @@@test:domTree:
        document {
          document-type { }
          element {
            general-entity-reference {
              is-expanded: false;
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.element.content.ger.entity.declared.standalone.-2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p [
            <!ENTITY % para "<!-- -->">
            %para;
          ]>
          <p>&entity;</p>
      @@@test:domTree:
        document {
          document-type { }
          element {
            general-entity-reference {
              is-expanded: false;
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.element.content.ger.entity.declared.standalone.4.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="yes"?>
          <!DOCTYPE p [
            <!ENTITY % para SYSTEM "para">
            %para;
          ]>
          <p>&entity;</p>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (6, 4)..(6, 11); }
    @@XMLTest:
      @@@QName: xp.element.content.ger.entity.declared.standalone.-3.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="no"?>
          <!DOCTYPE p [
            <!ENTITY % para SYSTEM "para">
            %para;
          ]>
          <p>&entity;</p>
      @@@test:domTree:
        document {
          document-type { }
          element {
            general-entity-reference {
              is-expanded: false;
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.element.content.ger.entity.declared.standalone.-4.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p [
            <!ENTITY % para SYSTEM "para">
            %para;
          ]>
          <p>&entity;</p>
      @@@test:domTree:
        document {
          document-type { }
          element {
            general-entity-reference {
              is-expanded: false;
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.element.content.ger.entity.declared.standalone.5.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="yes"?>
          <!DOCTYPE p SYSTEM "dtd">
          <p>&entity;</p>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (3, 4)..(3, 11); }
    @@XMLTest:
      @@@QName: xp.element.content.ger.entity.declared.standalone.-5.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="no"?>
          <!DOCTYPE p SYSTEM "dtd">
          <p>&entity;</p>
      @@@test:domTree:
        document {
          document-type { }
          element {
            general-entity-reference {
              is-expanded: false;
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.element.content.ger.entity.declared.standalone.-6.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p SYSTEM "dtd">
          <p>&entity;</p>
      @@@test:domTree:
        document {
          document-type { }
          element {
            general-entity-reference {
              is-expanded: false;
            }
          }
        }

    @@XMLTest:
      @@@QName: xp.reptxt.element.content.ger.entity.declared.nopref.1.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p [
          <!ENTITY c "&entity;">
          ]>
          <p>&c;</p>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (1, 1)..(1, 8); }
    @@XMLTest:
      @@@QName: xp.reptxt.element.content.ger.entity.declared.nopref.2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p [
            <!ENTITY other "aa">
            <!ENTITY % another "aa">
          <!ENTITY c "&entity;">
          ]>
          <p>&c;</p>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (1, 1)..(1, 8); }
    @@XMLTest:
      @@@QName: xp.reptxt.element.content.ger.entity.declared.nopref.3.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="yes"?>
          <!DOCTYPE p [
          <!ENTITY c "&entity;">
          ]>
          <p>&c;</p>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (1, 1)..(1, 8); }
    @@XMLTest:
      @@@QName: xp.reptxt.element.content.ger.entity.declared.nopref.4.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="no"?>
          <!DOCTYPE p [
          <!ENTITY c "&entity;">
          ]>
          <p>&c;</p>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (1, 1)..(1, 8); }
    @@XMLTest:
      @@@QName: xp.reptxt.element.content.ger.entity.declared.nopref.5.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="yes"?>
          <!DOCTYPE p [
            <!ENTITY other "aa">
            <!ENTITY % another "aa">
          <!ENTITY c "&entity;">
          ]>
          <p>&c;</p>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (1, 1)..(1, 8); }
    @@XMLTest:
      @@@QName: xp.reptxt.element.content.ger.entity.declared.nopref.6.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="no"?>
          <!DOCTYPE p [
            <!ENTITY other "aa">
            <!ENTITY % another "aa">
          <!ENTITY c "&entity;">
          ]>
          <p>&c;</p>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (1, 1)..(1, 8); }
    @@XMLTest:
      @@@QName: xp.reptxt.element.content.ger.entity.declared.nopref.-1.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p [
            <!ENTITY entity "value">
          <!ENTITY c "&entity;">
          ]>
          <p>&c;</p>
      @@@test:domTree:
        document {
          document-type {
            general-entity {
              node-name: 'entity';
              text-content: 'value';
            }
            general-entity {
              node-name: 'c';
              general-entity-reference {
                node-name: 'entity';
                text-content: 'value';
              }
            }
          }
          element {
            general-entity-reference {
              node-name: 'c';
              general-entity-reference {
                node-name: 'entity';
                text-content: 'value';
              }
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.reptxt.element.content.ger.entity.declared.nopref.-2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p [
            <!ENTITY entity "value">
            <!ENTITY another SYSTEM "another">
          <!ENTITY c "&entity;">
          ]>
          <p>&c;</p>
      @@@test:domTree:
        document {
          document-type {
            general-entity {
              node-name: 'entity';
              text-content: 'value';
            }
            general-entity {
              node-name: 'c';
              general-entity-reference {
                node-name: 'entity';
                is-expanded: true;
                text-content: 'value';
              }
            }
            general-entity {
              node-name: 'another';
              public-id: null;
              system-id: 'another';
              has-replacement-tree: false;
            }
          }
          element {
            general-entity-reference {
              node-name: 'c';
              is-expanded: true;
              general-entity-reference {
                node-name: 'entity';
                is-expanded: true;
                text-content: 'value';
              }
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.reptxt.element.content.ger.entity.declared.standalone.2.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="yes"?>
          <!DOCTYPE p [
          <!ENTITY c "&entity;">
          ]>
          <p>&c;</p>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (1, 1)..(1, 8); }
    @@XMLTest:
      @@@QName: xp.reptxt.element.content.ger.entity.declared.standalone.3.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="yes"?>
          <!DOCTYPE p [
            <!ENTITY % para "<!-- -->">
            %para;
          <!ENTITY c "&entity;">
          ]>
          <p>&c;</p>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (1, 1)..(1, 8); }
    @@XMLTest:
      @@@QName: xp.reptxt.element.content.ger.entity.declared.standalone.-1.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="no"?>
          <!DOCTYPE p [
          <!ENTITY c "&entity;">
            <!ENTITY % para "<!-- -->">
            %para;
          ]>
          <p>&c;</p>
      @@@test:domTree:
        document {
          document-type {
            general-entity {
              node-name: 'c';
              general-entity-reference {
                node-name: 'entity';
                is-expanded: false;
              }
            }
          }
          element {
            general-entity-reference {
              node-name: 'c';
              general-entity-reference {
                node-name: 'entity';
                is-expanded: false;
              }
            }
          }
        }
    @@XMLTest:
      @@@QName:
        xp.reptxt.element.content.ger.entity.declared.standalone.-1.2.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="no"?>
          <!DOCTYPE p [
            <!ENTITY % para "<!-- -->">
            %para;
          <!ENTITY c "&entity;">
          ]>
          <p>&c;</p>
      @@@test:domTree:
        document {
          document-type { }
          element {
            general-entity-reference {
              node-name: 'c';
              is-expanded: false;
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.reptxt.element.content.ger.entity.declared.standalone.-2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p [
          <!ENTITY c "&entity;">
            <!ENTITY % para "<!-- -->">
            %para;
          ]>
          <p>&c;</p>
      @@@test:domTree:
        document {
          document-type { }
          element {
            general-entity-reference {
              node-name: 'c';
              is-expanded: true;
              general-entity-reference {
                node-name: 'entity';
                is-expanded: false;
              }
            }
          }
        }
    @@XMLTest:
      @@@QName:
        xp.reptxt.element.content.ger.entity.declared.standalone.-2.2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p [
            <!ENTITY % para "<!-- -->">
            %para;
          <!ENTITY c "&entity;">
          ]>
          <p>&c;</p>
      @@@test:domTree:
        document {
          document-type { }
          element {
            general-entity-reference {
              node-name: 'c';
              is-expanded: false;
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.reptxt.element.content.ger.entity.declared.standalone.4.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="yes"?>
          <!DOCTYPE p [
            <!ENTITY % para SYSTEM "para">
            %para;
          <!ENTITY c "&entity;">
          ]>
          <p>&c;</p>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (1, 1)..(1, 8); }
    @@XMLTest:
      @@@QName: xp.reptxt.element.content.ger.entity.declared.standalone.-3.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="no"?>
          <!DOCTYPE p [
          <!ENTITY c "&entity;">
            <!ENTITY % para SYSTEM "para">
            %para;
          ]>
          <p>&c;</p>
      @@@test:domTree:
        document {
          document-type { }
          element {
            general-entity-reference {
              node-name: 'c';
              is-expanded: true;
              general-entity-reference {
                node-name: 'entity';
                is-expanded: false;
              }
            }
          }
        }
    @@XMLTest:
      @@@QName:
        xp.reptxt.element.content.ger.entity.declared.standalone.-3.2.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="no"?>
          <!DOCTYPE p [
            <!ENTITY % para SYSTEM "para">
            %para;
          <!ENTITY c "&entity;">
          ]>
          <p>&c;</p>
      @@@test:domTree:
        document {
          document-type { }
          element {
            general-entity-reference {
              node-name: 'c';
              is-expanded: false;
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.reptxt.element.content.ger.entity.declared.standalone.-4.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p [
          <!ENTITY c "&entity;">
            <!ENTITY % para SYSTEM "para">
            %para;
          ]>
          <p>&c;</p>
      @@@test:domTree:
        document {
          document-type { }
          element {
            general-entity-reference {
              node-name: 'c';
              is-expanded: true;
              general-entity-reference {
                node-name: 'entity';
                is-expanded: false;
              }
            }
          }
        }
    @@XMLTest:
      @@@QName:
        xp.reptxt.element.content.ger.entity.declared.standalone.-4.2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p [
            <!ENTITY % para SYSTEM "para">
            %para;
          <!ENTITY c "&entity;">
          ]>
          <p>&c;</p>
      @@@test:domTree:
        document {
          document-type { }
          element {
            general-entity-reference {
              node-name: 'c';
              is-expanded: false;
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.reptxt.element.content.ger.entity.declared.standalone.5.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="yes"?>
          <!DOCTYPE p SYSTEM "dtd" [
          <!ENTITY c "&entity;">
          ]>
          <p>&c;</p>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (1, 1)..(1, 8); }
    @@XMLTest:
      @@@QName: xp.reptxt.element.content.ger.entity.declared.standalone.-5.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="no"?>
          <!DOCTYPE p SYSTEM "dtd" [
          <!ENTITY c "&entity;">
          ]>
          <p>&c;</p>
      @@@test:domTree:
        document {
          document-type { }
          element {
            general-entity-reference {
              node-name: 'c';
              is-expanded: true;
              general-entity-reference {
                node-name: 'entity';
                is-expanded: false;
              }
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.reptxt.element.content.ger.entity.declared.standalone.-6.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p SYSTEM "dtd" [<!ENTITY c "&entity;">]>
          <p>&c;</p>
      @@@test:domTree:
        document {
          document-type { }
          element {
            general-entity-reference {
              node-name: 'c';
              is-expanded: true;
              general-entity-reference {
                node-name: 'entity';
                is-expanded: false;
              }
            }
          }
        }

    @@XMLTest:
      @@@QName: xp.attval.ger.entity.declared.nodtd.1.test
      @@@DEnt:
        @@@@test:value:
          <p a="&entity;"/>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (1, 7)..(1, 14); }
    @@XMLTest:
      @@@QName: xp.attval.ger.entity.declared.nodtd.2.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="yes"?>
          <p a="&entity;"/>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (2, 7)..(2, 14); }
    @@XMLTest:
      @@@QName: xp.attval.ger.entity.declared.nodtd.3.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="no"?>
          <p a="&entity;"/>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (2, 7)..(2, 14); }
    @@XMLTest:
      @@@QName: xp.attval.ger.entity.declared.nodtd.-1.test
      @@@DEnt:
        @@@@test:value:
          <p a="&lt;&gt;&amp;&quot;&apos;"/>
      @@@test:domTree:
        document {
          element {
            attribute {
              node-name: 'a';
              text-content: '<>&"' U+0027;
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.attval.ger.entity.declared.nopref.1.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p []>
          <p a="&entity;"/>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (2, 7)..(2, 14); }
    @@XMLTest:
      @@@QName: xp.attval.ger.entity.declared.nopref.2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p [
            <!ENTITY other "aa">
            <!ENTITY % another "aa">
          ]>
          <p a="&entity;"/>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (5, 7)..(5, 14); }
    @@XMLTest:
      @@@QName: xp.attval.ger.entity.declared.nopref.3.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="yes"?>
          <!DOCTYPE p []>
          <p a="&entity;"/>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (3, 7)..(3, 14); }
    @@XMLTest:
      @@@QName: xp.attval.ger.entity.declared.nopref.4.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="no"?>
          <!DOCTYPE p []>
          <p a="&entity;"/>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (3, 7)..(3, 14); }
    @@XMLTest:
      @@@QName: xp.attval.ger.entity.declared.nopref.5.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="yes"?>
          <!DOCTYPE p [
            <!ENTITY other "aa">
            <!ENTITY % another "aa">
          ]>
          <p a="&entity;"/>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (6, 7)..(6, 14); }
    @@XMLTest:
      @@@QName: xp.attval.ger.entity.declared.nopref.6.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="no"?>
          <!DOCTYPE p [
            <!ENTITY other "aa">
            <!ENTITY % another "aa">
          ]>
          <p a="&entity;"/>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (6, 7)..(6, 14); }
    @@XMLTest:
      @@@QName: xp.attval.ger.entity.declared.nopref.-1.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p [
            <!ENTITY entity "value">
          ]>
          <p a="&entity;"/>
      @@@test:domTree:
        document {
          document-type {
            general-entity {
              node-name: 'entity';
              text-content: 'value';
            }
          }
          element {
            attribute {
              node-name: 'a';
              general-entity-reference {
                node-name: 'entity';
                is-expanded: true;
                text-content: 'value';
              }
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.attval.ger.entity.declared.nopref.-2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p [
            <!ENTITY entity "value">
            <!ENTITY another SYSTEM "another">
          ]>
          <p a="&entity;"/>
      @@@test:domTree:
        document {
          document-type {
            general-entity {
              node-name: 'entity';
              text-content: 'value';
              has-replacement-tree: true;
            }
            general-entity {
              node-name: 'another';
              public-id: null;
              system-id: 'another';
              has-replacement-tree: false;
            }
          }
          element {
            attribute {
              node-name: 'a';
              general-entity-reference {
                node-name: 'entity';
                is-expanded: true;
                text-content: 'value';
              }
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.attval.ger.entity.declared.standalone.1.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="yes"?>
          <p a="&entity;"/>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (2, 7)..(2, 14); }
    @@XMLTest:
      @@@QName: xp.attval.ger.entity.declared.standalone.2.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="yes"?>
          <!DOCTYPE p []>
          <p a="&entity;"/>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (3, 7)..(3, 14); }
    @@XMLTest:
      @@@QName: xp.attval.ger.entity.declared.standalone.3.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="yes"?>
          <!DOCTYPE p [
            <!ENTITY % para "<!-- -->">
            %para;
          ]>
          <p a="&entity;"/>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (6, 7)..(6, 14); }
    @@XMLTest:
      @@@QName: xp.attval.ger.entity.declared.standalone.-1.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="no"?>
          <!DOCTYPE p [
            <!ENTITY % para "<!-- -->">
            %para;
          ]>
          <p a="&entity;"/>
      @@@test:domTree:
        document {
          document-type { }
          element {
            attribute {
              node-name: 'a';
              general-entity-reference {
                is-expanded: false;
              }
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.attval.ger.entity.declared.standalone.-2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p [
            <!ENTITY % para "<!-- -->">
            %para;
          ]>
          <p a="&entity;"/>
      @@@test:domTree:
        document {
          document-type { }
          element {
            attribute {
              node-name: 'a';
              general-entity-reference {
                is-expanded: false;
              }
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.attval.ger.entity.declared.standalone.4.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="yes"?>
          <!DOCTYPE p [
            <!ENTITY % para SYSTEM "para">
            %para;
          ]>
          <p a="&entity;"/>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (6, 7)..(6, 14); }
    @@XMLTest:
      @@@QName: xp.attval.ger.entity.declared.standalone.-3.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="no"?>
          <!DOCTYPE p [
            <!ENTITY % para SYSTEM "para">
            %para;
          ]>
          <p a="&entity;"/>
      @@@test:domTree:
        document {
          document-type { }
          element {
            attribute {
              node-name: 'a';
              general-entity-reference {
                is-expanded: false;
              }
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.attval.ger.entity.declared.standalone.-4.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p [
            <!ENTITY % para SYSTEM "para">
            %para;
          ]>
          <p a="&entity;"/>
      @@@test:domTree:
        document {
          document-type { }
          element {
            attribute {
              node-name: 'a';
              general-entity-reference {
                is-expanded: false;
              }
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.attval.ger.entity.declared.standalone.5.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="yes"?>
          <!DOCTYPE p SYSTEM "dtd">
          <p a="&entity;"/>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (3, 7)..(3, 14); }
    @@XMLTest:
      @@@QName: xp.attval.ger.entity.declared.standalone.-5.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="no"?>
          <!DOCTYPE p SYSTEM "dtd">
          <p a="&entity;"/>
      @@@test:domTree:
        document {
          document-type { }
          element {
            attribute {
              node-name: 'a';
              general-entity-reference {
                is-expanded: false;
              }
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.attval.ger.entity.declared.standalone.-6.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p SYSTEM "dtd">
          <p a="&entity;"/>
      @@@test:domTree:
        document {
          document-type { }
          element {
            attribute {
              node-name: 'a';
              general-entity-reference {
                is-expanded: false;
              }
            }
          }
        }

    @@XMLTest:
      @@@QName: xp.reptxt.attval.ger.entity.declared.nopref.1.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p [
          <!ENTITY c "&entity;">
          ]>
          <p a="&c;"/>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (1, 1)..(1, 8); }
    @@XMLTest:
      @@@QName: xp.reptxt.attval.ger.entity.declared.nopref.2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p [
            <!ENTITY other "aa">
            <!ENTITY % another "aa">
          <!ENTITY c "&entity;">
          ]>
          <p a="&c;"/>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (1, 1)..(1, 8); }
    @@XMLTest:
      @@@QName: xp.reptxt.attval.ger.entity.declared.nopref.3.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="yes"?>
          <!DOCTYPE p [
          <!ENTITY c "&entity;">
          ]>
          <p a="&c;"/>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (1, 1)..(1, 8); }
    @@XMLTest:
      @@@QName: xp.reptxt.attval.ger.entity.declared.nopref.4.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="no"?>
          <!DOCTYPE p [
          <!ENTITY c "&entity;">
          ]>
          <p a="&c;"/>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (1, 1)..(1, 8); }
    @@XMLTest:
      @@@QName: xp.reptxt.attval.ger.entity.declared.nopref.5.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="yes"?>
          <!DOCTYPE p [
            <!ENTITY other "aa">
            <!ENTITY % another "aa">
          <!ENTITY c "&entity;">
          ]>
          <p a="&c;"/>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (1, 1)..(1, 8); }
    @@XMLTest:
      @@@QName: xp.reptxt.attval.ger.entity.declared.nopref.6.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="no"?>
          <!DOCTYPE p [
            <!ENTITY other "aa">
            <!ENTITY % another "aa">
          <!ENTITY c "&entity;">
          ]>
          <p a="&c;"/>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (1, 1)..(1, 8); }
    @@XMLTest:
      @@@QName: xp.reptxt.attval.ger.entity.declared.nopref.-1.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p [
            <!ENTITY entity "value">
          <!ENTITY c "&entity;">
          ]>
          <p a="&c;"/>
      @@@test:domTree:
        document {
          document-type {
            general-entity {
              node-name: 'entity';
              text-content: 'value';
            }
            general-entity {
              node-name: 'c';
              general-entity-reference {
                node-name: 'entity';
                text-content: 'value';
              }
            }
          }
          element {
            attribute {
              node-name: 'a';
              general-entity-reference {
                node-name: 'c';
                general-entity-reference {
                  node-name: 'entity';
                  text-content: 'value';
                }
              }
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.reptxt.attval.ger.entity.declared.nopref.-2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p [
            <!ENTITY entity "value">
            <!ENTITY another SYSTEM "another">
          <!ENTITY c "&entity;">
          ]>
          <p a="&c;"/>
      @@@test:domTree:
        document {
          document-type {
            general-entity {
              node-name: 'entity';
              text-content: 'value';
            }
            general-entity {
              node-name: 'c';
              general-entity-reference {
                node-name: 'entity';
                text-content: 'value';
              }
            }
            general-entity {
              node-name: 'another';
              public-id: null;
              system-id: 'another';
              has-replacement-tree: false;
            }
          }
          element {
            attribute {
              node-name: 'a';
              general-entity-reference {
                node-name: 'c';
                general-entity-reference {
                  node-name: 'entity';
                  text-content: 'value';
                }
              }
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.reptxt.attval.ger.entity.declared.standalone.2.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="yes"?>
          <!DOCTYPE p [
          <!ENTITY c "&entity;">
          ]>
          <p a="&c;"/>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (1, 1)..(1, 8); }
    @@XMLTest:
      @@@QName: xp.reptxt.attval.ger.entity.declared.standalone.3.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="yes"?>
          <!DOCTYPE p [
            <!ENTITY % para "<!-- -->">
            %para;
          <!ENTITY c "&entity;">
          ]>
          <p a="&c;"/>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (1, 1)..(1, 8); }
    @@XMLTest:
      @@@QName: xp.reptxt.attval.ger.entity.declared.standalone.-1.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="no"?>
          <!DOCTYPE p [
          <!ENTITY c "&entity;">
            <!ENTITY % para "<!-- -->">
            %para;
          ]>
          <p a="&c;"/>
      @@@test:domTree:
        document {
          document-type {
            general-entity {
              node-name: 'c';
              general-entity-reference {
                node-name: 'entity';
                is-expanded: false;
              }
            }
          }
          element {
            attribute {
              node-name: 'a';
              general-entity-reference {
                node-name: 'c';
                general-entity-reference {
                  node-name: 'entity';
                  is-expanded: false;
                }
              }
            }
          }
        }
    @@XMLTest:
      @@@QName:
        xp.reptxt.attval.ger.entity.declared.standalone.-1.2.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="no"?>
          <!DOCTYPE p [
            <!ENTITY % para "<!-- -->">
            %para;
          <!ENTITY c "&entity;">
          ]>
          <p a="&c;"/>
      @@@test:domTree:
        document {
          document-type { }
          element {
            attribute {
              node-name: 'a';
              general-entity-reference {
                node-name: 'c';
                is-expanded: false;
              }
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.reptxt.attval.ger.entity.declared.standalone.-2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p [
          <!ENTITY c "&entity;">
            <!ENTITY % para "<!-- -->">
            %para;
          ]>
          <p a="&c;"/>
      @@@test:domTree:
        document {
          document-type { }
          element {
            attribute {
              node-name: 'a';
              general-entity-reference {
                node-name: 'c';
                is-expanded: true;
                general-entity-reference {
                  node-name: 'entity';
                  is-expanded: false;
                }
              }
            }
          }
        }
    @@XMLTest:
      @@@QName:
        xp.reptxt.attval.ger.entity.declared.standalone.-2.2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p [
            <!ENTITY % para "<!-- -->">
            %para;
          <!ENTITY c "&entity;">
          ]>
          <p a="&c;"/>
      @@@test:domTree:
        document {
          document-type { }
          element {
            attribute {
              node-name: 'a';
              general-entity-reference {
                node-name: 'c';
                is-expanded: false;
              }
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.reptxt.attval.ger.entity.declared.standalone.4.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="yes"?>
          <!DOCTYPE p [
            <!ENTITY % para SYSTEM "para">
            %para;
          <!ENTITY c "&entity;">
          ]>
          <p a="&c;"/>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (1, 1)..(1, 8); }
    @@XMLTest:
      @@@QName: xp.reptxt.attval.ger.entity.declared.standalone.-3.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="no"?>
          <!DOCTYPE p [
          <!ENTITY c "&entity;">
            <!ENTITY % para SYSTEM "para">
            %para;
          ]>
          <p a="&c;"/>
      @@@test:domTree:
        document {
          document-type { }
          element {
            attribute {
              node-name: 'a';
              general-entity-reference {
                node-name: 'c';
                is-expanded: true;
                general-entity-reference {
                  node-name: 'entity';
                  is-expanded: false;
                }
              }
            }
          }
        }
    @@XMLTest:
      @@@QName:
        xp.reptxt.attval.ger.entity.declared.standalone.-3.2.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="no"?>
          <!DOCTYPE p [
            <!ENTITY % para SYSTEM "para">
            %para;
          <!ENTITY c "&entity;">
          ]>
          <p a="&c;"/>
      @@@test:domTree:
        document {
          document-type { }
          element {
            attribute {
              node-name: 'a';
              general-entity-reference {
                node-name: 'c';
                is-expanded: false;
              }
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.reptxt.attval.ger.entity.declared.standalone.-4.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p [
          <!ENTITY c "&entity;">
            <!ENTITY % para SYSTEM "para">
            %para;
          ]>
          <p a="&c;"/>
      @@@test:domTree:
        document {
          document-type { }
          element {
            attribute {
              node-name: 'a';
              general-entity-reference {
                node-name: 'c';
                is-expanded: true;
                general-entity-reference {
                  node-name: 'entity';
                  is-expanded: false;
                }
              }
            }
          }
        }
    @@XMLTest:
      @@@QName:
        xp.reptxt.attval.ger.entity.declared.standalone.-4.2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p [
            <!ENTITY % para SYSTEM "para">
            %para;
          <!ENTITY c "&entity;">
          ]>
          <p a="&c;"/>
      @@@test:domTree:
        document {
          document-type { }
          element {
            attribute {
              node-name: 'a';
              general-entity-reference {
                node-name: 'c';
                is-expanded: false;
              }
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.reptxt.attval.ger.entity.declared.standalone.5.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="yes"?>
          <!DOCTYPE p SYSTEM "dtd" [
          <!ENTITY c "&entity;">
          ]>
          <p a="&c;"/>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (1, 1)..(1, 8); }
    @@XMLTest:
      @@@QName: xp.reptxt.attval.ger.entity.declared.standalone.-5.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="no"?>
          <!DOCTYPE p SYSTEM "dtd" [
          <!ENTITY c "&entity;">
          ]>
          <p a="&c;"/>
      @@@test:domTree:
        document {
          document-type { }
          element {
            attribute {
              node-name: 'a';
              general-entity-reference {
                node-name: 'c';
                is-expanded: true;
                general-entity-reference {
                  node-name: 'entity';
                  is-expanded: false;
                }
              }
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.reptxt.attval.ger.entity.declared.standalone.-6.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p SYSTEM "dtd" [<!ENTITY c "&entity;">]>
          <p a="&c;"/>
      @@@test:domTree:
        document {
          document-type { }
          element {
            attribute {
              node-name: 'a';
              general-entity-reference {
                node-name: 'c';
                is-expanded: true;
                general-entity-reference {
                  node-name: 'entity';
                  is-expanded: false;
                }
              }
            }
          }
        }

    @@XMLTest:
      @@@QName: xp.attlist.dup.entity.declared.1.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p [
          <!ATTLIST p a CDATA "no-entity">
          <!ATTLIST p a CDATA "&entity;">
          ]>
          <p/>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (3, 21)..(3, 29); }
    @@XMLTest:
      @@@QName: xp.attlist.dup.entity.declared.2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p [
          <!ATTLIST p a CDATA "no-entity"
                      a CDATA "&entity;">
          ]>
          <p/>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (3, 21)..(3, 29); }
    @@XMLTest:
      @@@QName: xp.attlist.unused.entity.declared.1.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p [
          <!ATTLIST q a CDATA "&entity;">
          ]>
          <p/>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (2, 21)..(2, 29); }
    @@XMLTest:
      @@@QName: xp.attlist.unused.entity.declared.2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p [
          <!ATTLIST p a CDATA "&entity;">
          ]>
          <p a="bb"/>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (2, 21)..(2, 29); }

    @@XMLTest:
      @@@QName: xp.reptxt.attlist.attval.ger.entity.declared.nopref.1.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p [
          <!ENTITY c "&entity;">
          <!ATTLIST p a CDATA "&c;">
          ]>
          <p/>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (1, 1)..(1, 8); }
    @@XMLTest:
      @@@QName: xp.reptxt.attlist.attval.ger.entity.declared.nopref.2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p [
            <!ENTITY other "aa">
            <!ENTITY % another "aa">
          <!ENTITY c "&entity;">
          <!ATTLIST p a CDATA "&c;">
          ]>
          <p/>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (1, 1)..(1, 8); }
    @@XMLTest:
      @@@QName: xp.reptxt.attlist.attval.ger.entity.declared.nopref.3.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="yes"?>
          <!DOCTYPE p [
          <!ENTITY c "&entity;">
          <!ATTLIST p a CDATA "&c;">
          ]>
          <p/>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (1, 1)..(1, 8); }
    @@XMLTest:
      @@@QName: xp.reptxt.attlist.attval.ger.entity.declared.nopref.4.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="no"?>
          <!DOCTYPE p [
          <!ENTITY c "&entity;">
          <!ATTLIST p a CDATA "&c;">
          ]>
          <p/>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (1, 1)..(1, 8); }
    @@XMLTest:
      @@@QName: xp.reptxt.attlist.attval.ger.entity.declared.nopref.5.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="yes"?>
          <!DOCTYPE p [
            <!ENTITY other "aa">
            <!ENTITY % another "aa">
          <!ENTITY c "&entity;">
          <!ATTLIST p a CDATA "&c;">
          ]>
          <p/>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (1, 1)..(1, 8); }
    @@XMLTest:
      @@@QName: xp.reptxt.attlist.attval.ger.entity.declared.nopref.6.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="no"?>
          <!DOCTYPE p [
            <!ENTITY other "aa">
            <!ENTITY % another "aa">
          <!ENTITY c "&entity;">
          <!ATTLIST p a CDATA "&c;">
          ]>
          <p/>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (1, 1)..(1, 8); }
    @@XMLTest:
      @@@QName: xp.reptxt.attlist.attval.ger.entity.declared.nopref.-1.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p [
            <!ENTITY entity "value">
          <!ENTITY c "&entity;">
          <!ATTLIST p a CDATA "&c;">
          ]>
          <p/>
      @@@test:domTree:
        document {
          document-type {
            general-entity {
              node-name: 'entity';
              text-content: 'value';
            }
            general-entity {
              node-name: 'c';
              general-entity-reference {
                node-name: 'entity';
                is-expanded: true;
                text-content: 'value';
              }
            }
            element-type-definition {
              node-name: 'p';
              attribute-definition {
                node-name: 'a';
                general-entity-reference {
                  node-name: 'c';
                  is-expanded: true;
                  general-entity-reference {
                    node-name: 'entity';
                    is-expanded: true;
                    text-content: 'value';
                  }
                }
              }
            }
          }
          element {
            attribute {
              node-name: 'a';
              specified: false;
              general-entity-reference {
                node-name: 'c';
                general-entity-reference {
                  node-name: 'entity';
                  text-content: 'value';
                }
              }
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.reptxt.attlist.attval.ger.entity.declared.nopref.-2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p [
            <!ENTITY entity "value">
            <!ENTITY another SYSTEM "another">
          <!ENTITY c "&entity;">
          <!ATTLIST p a CDATA "&c;">
          ]>
          <p/>
      @@@test:domTree:
        document {
          document-type {
            general-entity {
              node-name: 'entity';
              text-content: 'value';
            }
            general-entity {
              node-name: 'c';
              general-entity-reference {
                node-name: 'entity';
                text-content: 'value';
              }
            }
            general-entity {
              node-name: 'another';
              public-id: null;
              system-id: 'another';
              has-replacement-tree: false;
            }
            element-type-definition {
              node-name: 'p';
              attribute-definition {
                node-name: 'a';
                general-entity-reference {
                  node-name: 'c';
                  is-expanded: true;
                  general-entity-reference {
                    node-name: 'entity';
                    is-expanded: true;
                    text-content: 'value';
                  }
                }
              }
            }
          }
          element {
            attribute {
              node-name: 'a';
              specified: false;
              general-entity-reference {
                node-name: 'c';
                general-entity-reference {
                  node-name: 'entity';
                  text-content: 'value';
                }
              }
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.reptxt.attlist.attval.ger.entity.declared.standalone.2.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="yes"?>
          <!DOCTYPE p [
          <!ENTITY c "&entity;">
          <!ATTLIST p a CDATA "&c;">
          ]>
          <p/>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (1, 1)..(1, 8); }
    @@XMLTest:
      @@@QName: xp.reptxt.attlist.attval.ger.entity.declared.standalone.3.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="yes"?>
          <!DOCTYPE p [
            <!ENTITY % para "<!-- -->">
            %para;
          <!ENTITY c "&entity;">
          <!ATTLIST p a CDATA "&c;">
          ]>
          <p/>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (1, 1)..(1, 8); }
    @@XMLTest:
      @@@QName: xp.reptxt.attlist.attval.ger.entity.declared.standalone.-1.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="no"?>
          <!DOCTYPE p [
          <!ENTITY c "&entity;">
          <!ATTLIST p a CDATA "&c;">
            <!ENTITY % para "<!-- -->">
            %para;
          ]>
          <p/>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (1, 1)..(1, 8); }
    @@XMLTest:
      @@@QName:
        xp.reptxt.attlist.attval.ger.entity.declared.standalone.-1.2.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="no"?>
          <!DOCTYPE p [
            <!ENTITY % para "<!-- -->">
            %para;
          <!ENTITY c "&entity;">
          <!ATTLIST p a CDATA "&c;">
          ]>
          <p g="h"/>
      @@@test:domTree:
        document {
          document-type { }
          element {
            attribute {
              node-name: 'g';
              text-content: 'h';
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.reptxt.attlist.attval.ger.entity.declared.standalone.-2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p [
          <!ENTITY c "&entity;">
          <!ATTLIST p a CDATA "&c;">
            <!ENTITY % para "<!-- -->">
            %para;
          ]>
          <p/>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (1, 1)..(1, 8); }
    @@XMLTest:
      @@@QName:
        xp.reptxt.attlist.attval.ger.entity.declared.standalone.-2.2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p [
            <!ENTITY % para "<!-- -->">
            %para;
          <!ENTITY c "&entity;">
          <!ATTLIST p a CDATA "&c;">
          ]>
          <p g="h"/>
      @@@test:domTree:
        document {
          document-type { }
          element {
            attribute {
              node-name: 'g';
              text-content: 'h';
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.reptxt.attlist.attval.ger.entity.declared.standalone.4.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="yes"?>
          <!DOCTYPE p [
            <!ENTITY % para SYSTEM "para">
            %para;
          <!ENTITY c "&entity;">
          <!ATTLIST p a CDATA "&c;">
          ]>
          <p/>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (1, 1)..(1, 8); }
    @@XMLTest:
      @@@QName: xp.reptxt.attlist.attval.ger.entity.declared.standalone.-3.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="no"?>
          <!DOCTYPE p [
          <!ENTITY c "&entity;">
          <!ATTLIST p a CDATA "&c;">
            <!ENTITY % para SYSTEM "para">
            %para;
          ]>
          <p/>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (1, 1)..(1, 8); }
    @@XMLTest:
      @@@QName:
        xp.reptxt.attlist.attval.ger.entity.declared.standalone.-3.2.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="no"?>
          <!DOCTYPE p [
            <!ENTITY % para SYSTEM "para">
            %para;
          <!ENTITY c "&entity;">
          <!ATTLIST p a CDATA "&c;">
          ]>
          <p g="h"/>
      @@@test:domTree:
        document {
          document-type { }
          element {
            attribute {
              node-name: 'g';
              text-content: 'h';
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.reptxt.attlist.attval.ger.entity.declared.standalone.-4.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p [
          <!ENTITY c "&entity;">
          <!ATTLIST p a CDATA "&c;">
            <!ENTITY % para SYSTEM "para">
            %para;
          ]>
          <p/>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (1, 1)..(1, 8); }
    @@XMLTest:
      @@@QName:
        xp.reptxt.attlist.attval.ger.entity.declared.standalone.-4.2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p [
            <!ENTITY % para SYSTEM "para">
            %para;
          <!ENTITY c "&entity;">
          <!ATTLIST p a CDATA "&c;">
          ]>
          <p g="h"/>
      @@@test:domTree:
        document {
          document-type { }
          element {
            attribute {
              node-name: 'g';
              text-content: 'h';
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.reptxt.attlist.attval.ger.entity.declared.standalone.5.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="yes"?>
          <!DOCTYPE p SYSTEM "dtd" [
          <!ENTITY c "&entity;">
          <!ATTLIST p a CDATA "&c;">
          ]>
          <p/>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (1, 1)..(1, 8); }
    @@XMLTest:
      @@@QName: xp.reptxt.attlist.attval.ger.entity.declared.standalone.-5.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="no"?>
          <!DOCTYPE p SYSTEM "dtd" [
          <!ENTITY c "&entity;">
          <!ATTLIST p a CDATA "&c;">
          ]>
          <p/>
      @@@test:domTree:
        document {
          document-type { }
          element {
            attribute {
              node-name: 'a';
              specified: false;
              general-entity-reference {
                node-name: 'c';
                is-expanded: true;
                general-entity-reference {
                  node-name: 'entity';
                  is-expanded: false;
                }
              }
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.reptxt.attlist.attval.ger.entity.declared.standalone.-6.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p SYSTEM "dtd" [<!ENTITY c "&entity;">
          <!ATTLIST p a CDATA "&c;">
          ]>
          <p/>
      @@@test:domTree:
        document {
          document-type { }
          element {
            attribute {
              node-name: 'a';
              specified: false;
              general-entity-reference {
                node-name: 'c';
                is-expanded: true;
                general-entity-reference {
                  node-name: 'entity';
                  is-expanded: false;
                }
              }
            }
          }
        }

    @@XMLTest:
      @@@QName: xp.attlist.attval.ger.entity.declared.nopref.1.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p [
          <!ATTLIST p a CDATA "&entity;">
          ]>
          <p/>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (2, 22)..(2, 29); }
    @@XMLTest:
      @@@QName: xp.attlist.attval.ger.entity.declared.nopref.2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p [
            <!ENTITY other "aa">
            <!ENTITY % another "aa">
          <!ATTLIST p a CDATA "&entity;">
          ]>
          <p/>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (4, 22)..(4, 29); }
    @@XMLTest:
      @@@QName: xp.attlist.attval.ger.entity.declared.nopref.3.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="yes"?>
          <!DOCTYPE p [
          <!ATTLIST p a CDATA "&entity;">
          ]>
          <p/>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (3, 22)..(3, 29); }
    @@XMLTest:
      @@@QName: xp.attlist.attval.ger.entity.declared.nopref.4.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="no"?>
          <!DOCTYPE p [
          <!ATTLIST p a CDATA "&entity;">
          ]>
          <p/>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (3, 22)..(3, 29); }
    @@XMLTest:
      @@@QName: xp.attlist.attval.ger.entity.declared.nopref.5.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="yes"?>
          <!DOCTYPE p [
            <!ENTITY other "aa">
            <!ENTITY % another "aa">
          <!ATTLIST p a CDATA "&entity;">
          ]>
          <p/>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (5, 22)..(5, 29); }
    @@XMLTest:
      @@@QName: xp.attlist.attval.ger.entity.declared.nopref.6.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="no"?>
          <!DOCTYPE p [
            <!ENTITY other "aa">
            <!ENTITY % another "aa">
          <!ATTLIST p a CDATA "&entity;">
          ]>
          <p/>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (5, 22)..(5, 29); }
    @@XMLTest:
      @@@QName: xp.attlist.attval.ger.entity.declared.nopref.-1.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p [
            <!ENTITY entity "value">
          <!ATTLIST p a CDATA "&entity;">
          ]>
          <p/>
      @@@test:domTree:
        document {
          document-type {
            general-entity {
              node-name: 'entity';
              text-content: 'value';
            }
            element-type-definition {
              node-name: 'p';
              attribute-definition {
                node-name: 'a';
                general-entity-reference {
                  node-name: 'entity';
                  is-expanded: true;
                  text-content: 'value';
                }
              }
            }
          }
          element {
            attribute {
              node-name: 'a';
              specified: false;
              general-entity-reference {
                node-name: 'entity';
                is-expanded: true;
                text-content: 'value';
              }
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.attlist.attval.ger.entity.declared.nopref.-1.2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p [
          <!ATTLIST p a CDATA "&entity;">
            <!ENTITY entity "value">
          ]>
          <p/>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (2, 22)..(2, 29); }
    @@XMLTest:
      @@@QName: xp.attlist.attval.ger.entity.declared.nopref.-2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p [
            <!ENTITY entity "value">
            <!ENTITY another SYSTEM "another">
          <!ATTLIST p a CDATA "&entity;">
          ]>
          <p/>
      @@@test:domTree:
        document {
          document-type {
            element-type-definition {
              node-name: 'p';
              attribute-definition {
                node-name: 'a';
                general-entity-reference {
                  node-name: 'entity';
                  is-expanded: true;
                  text-content: 'value';
                }
              }
            }
            general-entity {
              node-name: 'entity';
              text-content: 'value';
              has-replacement-tree: true;
            }
            general-entity {
              node-name: 'another';
              public-id: null;
              system-id: 'another';
              has-replacement-tree: false;
            }
          }
          element {
            attribute {
              node-name: 'a';
              specified: false;
              general-entity-reference {
                node-name: 'entity';
                is-expanded: true;
                text-content: 'value';
              }
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.attlist.attval.ger.entity.declared.nopref.-2.2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p [
          <!ATTLIST p a CDATA "&entity;">
            <!ENTITY entity "value">
            <!ENTITY another SYSTEM "another">
          ]>
          <p/>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (2, 22)..(2, 29); }
    @@XMLTest:
      @@@QName: xp.attlist.attval.ger.entity.declared.standalone.2.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="yes"?>
          <!DOCTYPE p [
          <!ATTLIST p a CDATA "&entity;">
          ]>
          <p/>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (3, 22)..(3, 29); }
    @@XMLTest:
      @@@QName: xp.attlist.attval.ger.entity.declared.standalone.3.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="yes"?>
          <!DOCTYPE p [
          <!ATTLIST p a CDATA "&entity;">
            <!ENTITY % para "<!-- -->">
            %para;
          ]>
          <p/>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (3, 22)..(3, 29); }
    @@XMLTest:
      @@@QName: xp.attlist.attval.ger.entity.declared.standalone.3.2.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="yes"?>
          <!DOCTYPE p [
            <!ENTITY % para "<!-- -->">
            %para;
          <!ATTLIST p a CDATA "&entity;">
          ]>
          <p/>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (5, 22)..(5, 29); }
      @@@enImplNote:
        The <XML::ATTLIST> declaration is processed since
        it is a <XA::standalone> document.
    @@XMLTest:
      @@@QName: xp.attlist.attval.ger.entity.declared.standalone.-1.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="no"?>
          <!DOCTYPE p [
          <!ATTLIST p a CDATA "&entity;">
            <!ENTITY % para "<!-- -->">
            %para;
          ]>
          <p/>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (3, 22)..(3, 29); }
    @@XMLTest:
      @@@QName: xp.attlist.attval.ger.entity.declared.standalone.-1.2.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="no"?>
          <!DOCTYPE p [
            <!ATTLIST p b CDATA #IMPLIED>
            <!ENTITY % para "<!-- -->">
            %para;
          <!ATTLIST p a CDATA "&entity;">
          ]>
          <p c="d"/>
      @@@c:erred:
        <[[xp|warning-attribute-definition-not-processed]]> { (6, 13)..(6, 30); }
      @@@test:domTree:
        document {
          document-type {
            element-type-definition {
              node-name: 'p';
              attribute-definition {
                node-name: 'b';
              }
            }
          }
          element {
            attribute {
              node-name: 'c';
              text-content: 'd';
            }
          }
        }
      @@@enImplNote:
        The second <XML::ATTLIST> declaration is read but not processed
        and its <XML::&entity;> general entity reference violates 
        entity declared validty constraint rather than well-formedness
        constraint.
    @@XMLTest:
      @@@QName: xp.attlist.attval.ger.entity.declared.standalone.-2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p [
          <!ATTLIST p a CDATA "&entity;">
            <!ENTITY % para "<!-- -->">
            %para;
          ]>
          <p/>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (2, 22)..(2, 29); }
    @@XMLTest:
      @@@QName: xp.attlist.attval.ger.entity.declared.standalone.-2.2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p [
            <!ATTLIST p b CDATA #IMPLIED>
            <!ENTITY % para "<!-- -->">
            %para;
          <!ATTLIST p a CDATA "&entity;">
          ]>
          <p c="d"/>
      @@@c:erred:
        <[[xp|warning-attribute-definition-not-processed]]> { (5, 13)..(5, 30); }
      @@@test:domTree:
        document {
          document-type {
            element-type-definition {
              node-name: 'p';
              attribute-definition {
                node-name: 'b';
              }
            }
          }
          element {
            attribute {
              node-name: 'c';
              text-content: 'd';
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.attlist.attval.ger.entity.declared.standalone.4.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="yes"?>
          <!DOCTYPE p [
          <!ATTLIST p a CDATA "&entity;">
            <!ENTITY % para SYSTEM "p">
            %para;
          ]>
          <p/>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (3, 22)..(3, 29); }
    @@XMLTest:
      @@@QName: xp.attlist.attval.ger.entity.declared.standalone.4.2.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="yes"?>
          <!DOCTYPE p [
            <!ENTITY % para SYSTEM "p">
            %para;
          <!ATTLIST p a CDATA "&entity;">
          ]>
          <p/>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (5, 22)..(5, 29); }
      @@@enImplNote:
        The <XML::ATTLIST> declaration is processed since
        it is a <XA::standalone> document.
    @@XMLTest:
      @@@QName: xp.attlist.attval.ger.entity.declared.standalone.-3.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="no"?>
          <!DOCTYPE p [
          <!ATTLIST p a CDATA "&entity;">
            <!ENTITY % para SYSTEM "p">
            %para;
          ]>
          <p/>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (3, 22)..(3, 29); }
      @@@enImplNote:
        Is this well-formed?  It has a parameter entity reference,
        therefore, it does not violates Entity Declared WFC, isn't it?

        Note that Firefox 1.5 and Opera 9 TP1 reports that this document has a
        fatal error (also note that they does not support unexpanded).

        See also:
        <URI::http://suika.fam.cx/gate/2005/sw/%E5%B1%9E%E6%80%A7%E5%80%A4%E8%A1%A8%E8%A8%98#anchor-8>
    @@XMLTest:
      @@@QName: xp.attlist.attval.ger.entity.declared.standalone.-3.2.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="no"?>
          <!DOCTYPE p [
            <!ATTLIST p b CDATA #IMPLIED>
            <!ENTITY % para SYSTEM "p">
            %para;
          <!ATTLIST p a CDATA "&entity;">
          ]>
          <p c="d"/>
      @@@c:erred:
        <[[xp|warning-attribute-definition-not-processed]]> { (6, 13)..(6, 30); }
      @@@test:domTree:
        document {
          document-type {
            element-type-definition {
              node-name: 'p';
              attribute-definition {
                node-name: 'b';
              }
            }
          }
          element {
            attribute {
              node-name: 'c';
              text-content: 'd';
            }
          }
        }
      @@@enImplNote:
        The second <XML::ATTLIST> declaration is read but not processed
        and its <XML::&entity;> general entity reference violates 
        entity declared validty constraint rather than well-formedness
        constraint.
    @@XMLTest:
      @@@QName: xp.attlist.attval.ger.entity.declared.standalone.-4.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p [
          <!ATTLIST p a CDATA "&entity;">
            <!ENTITY % para SYSTEM "p">
            %para;
          ]>
          <p/>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (2, 22)..(2, 29); }
    @@XMLTest:
      @@@QName: xp.attlist.attval.ger.entity.declared.standalone.-4.2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p [
            <!ATTLIST p b CDATA #IMPLIED>
            <!ENTITY % para SYSTEM "p">
            %para;
          <!ATTLIST p a CDATA "&entity;">
          ]>
          <p c="d"/>
      @@@c:erred:
        <[[xp|warning-attribute-definition-not-processed]]> { (5, 13)..(5, 30); }
      @@@test:domTree:
        document {
          document-type {
            element-type-definition {
              node-name: 'p';
              attribute-definition {
                node-name: 'b';
              }
            }
          }
          element {
            attribute {
              node-name: 'c';
              text-content: 'd';
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.attlist.attval.ger.entity.declared.standalone.5.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="yes"?>
          <!DOCTYPE p SYSTEM "dtd" [
          <!ATTLIST p a CDATA "&entity;">
          ]>
          <p/>
      @@@c:erred: <[[xp|wf-entity-declared]]> { (3, 22)..(3, 29); }
      @@@enImplNote:
        This document has an error - result is implementation dependent.
    @@XMLTest:
      @@@QName: xp.attlist.attval.ger.entity.declared.standalone.-5.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0" standalone="no"?>
          <!DOCTYPE p SYSTEM "dtd" [
          <!ATTLIST p a CDATA "&entity;">
          ]>
          <p/>
      @@@test:domTree:
        document {
          document-type {
            element-type-definition {
              node-name: 'p';
              attribute-definition {
                node-name: 'a';
                general-entity-reference {
                  node-name: 'entity';
                  is-expanded: false;
                }
              }
            }
          }
          element {
            attribute {
              node-name: 'a';
              specified: false;
              general-entity-reference {
                node-name: 'entity';
                is-expanded: false;
              }
            }
          }
        }
      @@@enImplNote:
        This document has an error - result is implementation dependent.
    @@XMLTest:
      @@@QName: xp.attlist.attval.ger.entity.declared.standalone.-6.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p SYSTEM "dtd" [
          <!ATTLIST p a CDATA "&entity;">
          ]>
          <p/>
      @@@test:domTree:
        document {
          document-type {
            element-type-definition {
              node-name: 'p';
              attribute-definition {
                node-name: 'a';
                general-entity-reference {
                  node-name: 'entity';
                  is-expanded: false;
                }
              }
            }
          }
          element {
            attribute {
              node-name: 'a';
              specified: false;
              general-entity-reference {
                node-name: 'entity';
                is-expanded: false;
              }
            }
          }
        }
      @@@enImplNote:
        This document has an error - result is implementation dependent.

    @@enImplNote:
      {TODO:: Entity declared WFC for

         - General entity references in entity value??

      }

    @@XMLTest:
      @@@QName: xp.element.content.parsed.entity.reference.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p [
          <!NOTATION n SYSTEM "notation">
          <!ENTITY ext SYSTEM "system" NDATA n>
          ]>
          <p>&ext;</p>
      @@@c:erred: <[[xp|wf-parsed-entity]]> { (5, 4)..(5, 8); }
    @@XMLTest:
      @@@QName: xp.attval.parsed.entity.reference.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p [
          <!NOTATION n SYSTEM "notation">
          <!ENTITY ext SYSTEM "system" NDATA n>
          ]>
          <p a="&ext;"/>
#      @@@c:erred: <[[xp|wf-parsed-entity]]> { (5, 7)..(5, 11); }
      @@@c:erred: <[[xp|wf-no-external-entity-references]]> { (5, 7)..(5, 11); }
    @@XMLTest:
      @@@QName: xp.element.content.reptxt.parsed.entity.reference.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p [
          <!NOTATION n SYSTEM "notation">
          <!ENTITY ext SYSTEM "system" NDATA n>
          <!ENTITY c "&#x26;ext;">
          ]>
          <p>&c;</p>
      @@@c:erred: <[[xp|wf-parsed-entity]]> { (1, 1)..(1, 5); }
    @@XMLTest:
      @@@QName: xp.attval.reptxt.parsed.entity.reference.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p [
          <!NOTATION n SYSTEM "notation">
          <!ENTITY ext SYSTEM "system" NDATA n>
          <!ENTITY c "&#x26;ext;">
          ]>
          <p a="&c;"/>
      @@@c:erred: <[[xp|wf-no-external-entity-references]]> { (1, 1)..(1, 5); }
      @@@c:erred:
        @@@@@: <[[xp|wf-parsed-entity]]> { }
        @@@@enImplNote: During entity node construction.
    @@XMLTest:
      @@@QName: xp.element.content.entval.parsed.entity.reference.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p [
          <!NOTATION n SYSTEM "notation">
          <!ENTITY ext SYSTEM "system" NDATA n>
          <!ENTITY c "&ext;">
          ]>
          <p>&c;</p>
      @@@c:erred: <[[xp|wf-parsed-entity]]> { }
    @@XMLTest:
      @@@QName: xp.attval.entval.parsed.entity.reference.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p [
          <!NOTATION n SYSTEM "notation">
          <!ENTITY ext SYSTEM "system" NDATA n>
          <!ENTITY c "&ext;">
          ]>
          <p a="&c;"/>
      @@@c:erred: <[[xp|wf-no-external-entity-references]]> { }
      @@@c:erred: <[[xp|wf-parsed-entity]]> { }

    @@XMLTest:
      @@@QName: xp.element.content.no.recursion.direct.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p [
          <!ENTITY c "&c;">
          ]>
          <p>&c;</p>
      @@@c:erred: <[[xp|wf-no-recursion]]> { (1, 1)..(1, 3); }
    @@XMLTest:
      @@@QName: xp.element.content.no.recursion.indirect.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p [
          <!ENTITY d "&c;">
          <!ENTITY c "&d;">
          ]>
          <p>&c;</p>
      @@@c:erred: <[[xp|wf-no-recursion]]> { /* |d| */ (1, 1)..(1, 3); }
    @@XMLTest:
      @@@QName: xp.attval.no.recursion.direct.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p [
          <!ENTITY c "&c;">
          ]>
          <p a="&c;"/>
      @@@c:erred: <[[xp|wf-no-recursion]]> { (1, 1)..(1, 3); }
    @@XMLTest:
      @@@QName: xp.attval.no.recursion.indirect.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p [
          <!ENTITY d "&c;">
          <!ENTITY c "&d;">
          ]>
          <p a="&c;"/>
      @@@c:erred: <[[xp|wf-no-recursion]]> { /* |d| */ (1, 1)..(1, 3); }
    @@XMLTest:
      @@@QName: xp.reptxt.element.content.no.recursion.direct.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p [
          <!ENTITY c "&c;">
          <!ENTITY e "&#x26;c;">
          ]>
          <p>&e;</p>
      @@@c:erred: <[[xp|wf-no-recursion]]> { /* |e| */ (1, 1)..(1, 3); }
    @@XMLTest:
      @@@QName: xp.reptxt.element.content.no.recursion.indirect.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p [
          <!ENTITY d "&c;">
          <!ENTITY c "&d;">
          <!ENTITY e "&#x26;c;">
          ]>
          <p>&e;</p>
      @@@c:erred: <[[xp|wf-no-recursion]]> { /* |d| */ (1, 1)..(1, 3); }
    @@XMLTest:
      @@@QName: xp.reptxt.attval.no.recursion.direct.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p [
          <!ENTITY c "&c;">
          <!ENTITY e "&#x26;c;">
          ]>
          <p a="&e;"/>
      @@@c:erred: <[[xp|wf-no-recursion]]> { /* |e| */ (1, 1)..(1, 3); }
    @@XMLTest:
      @@@QName: xp.reptxt.attval.no.recursion.indirect.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p [
          <!ENTITY d "&c;">
          <!ENTITY c "&d;">
          <!ENTITY e "&#x26;c;">
          ]>
          <p a="&e;"/>
      @@@c:erred: <[[xp|wf-no-recursion]]> { /* |d| */ (1, 1)..(1, 3); }

    @@XMLTest:
      @@@QName: xp.ENTITY.system.ndata.name.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
          <!NOTATION n SYSTEM "n">
          <!ENTITY % e SYSTEM "sys" NDATA n>
          ]><a/>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (3, 26)..(3, 30); }
    @@XMLTest:
      @@@QName: xp.ENTITY.public.ndata.name.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
          <!NOTATION n SYSTEM "n">
          <!ENTITY % e PUBLIC "pub" "sys" NDATA n>
          ]><a/>
      @@@c:erred: <[[xp|wf-syntax-error]]> { (3, 33)..(3, 37); }
    @@XMLTest:
      @@@QName: xp.ENTITY.public.ndata.name.-1.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
          <!NOTATION n SYSTEM "n">
          <!ENTITY % e PUBLIC "pub" "sys" >
          ]><a/>
      @@@test:domTree:
        document { }

    @@XMLTest:
      @@@QName: xp.ENTITY.pubid.1.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
          <!ENTITY e PUBLIC "p" "s">
          ]><a/>
      @@@test:domTree:
        document {
          document-type {
            general-entity {
              node-name: 'e';
              public-id: 'p';
              system-id: 's';
            }
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.ENTITY.pubid.2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
          <!ENTITY e PUBLIC "  p  " "s">
          ]><a/>
      @@@test:domTree:
        document {
          document-type {
            general-entity {
              node-name: 'e';
              public-id: 'p';
              system-id: 's';
            }
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.ENTITY.pubid.3.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
          <!ENTITY e PUBLIC "  p  $u000Aq$u000A " "s">
          ]><a/>
      @@@test:domTree:
        document {
          document-type {
            general-entity {
              node-name: 'e';
              public-id: 'p q';
              system-id: 's';
            }
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.ENTITY.pubid.4.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
          <!ENTITY e PUBLIC "  p  $u000D$u000Aq" "s">
          ]><a/>
      @@@test:domTree:
        document {
          document-type {
            general-entity {
              node-name: 'e';
              public-id: 'p q';
              system-id: 's';
            }
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.ENTITY.pubid.5.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.1"?>
          <!DOCTYPE a [
          <!ENTITY e PUBLIC "  p  $u000D$u0085q" "s">
          ]><a/>
      @@@test:domTree:
        document {
          document-type {
            general-entity {
              node-name: 'e';
              public-id: 'p q';
              system-id: 's';
            }
          }
          element { }
        }

    @@XMLTest:
      @@@QName: xp.ENTITY.ignored.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
          <!ENTITY e "a">
          <!ENTITY e "b">
          ]><a/>
      @@@test:domTree:
        document {
          document-type {
            general-entity {
              node-name: 'e';
              text-content: 'a';
            }
          }
          element { }
        }
      @@@c:erred:
        <[[xp|warning-entity-declaration-ignored]]> { (3, 1)..(3, 15); }
    @@XMLTest:
      @@@QName: xp.ENTITY.ignored.2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
          <!ENTITY % e "a">
          <!ENTITY % e "b">
          ]><a/>
      @@@test:domTree:
        document { }
      @@@c:erred:
        <[[xp|warning-entity-declaration-ignored]]> { (3, 1)..(3, 17); }

    @@XMLTest:
      @@@QName: xp.ENTITY.predefined.1.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
          <!ENTITY lt     "&#38;#60;">
          <!ENTITY gt     "&#62;">
          <!ENTITY amp    "&#38;#38;">
          <!ENTITY apos   "&#39;">
          <!ENTITY quot   "&#34;">
          <!ENTITY e      "f">
          ]><a>&lt;&gt;&amp;&apos;&quot;</a>
      @@@test:domTree:
        document {
          document-type {
            general-entity {
              node-name: 'e';
              text-content: 'f';
            }
          }
          element {
            text-content: '<>&' U+0027 '"';
          }
        }
    @@XMLTest:
      @@@QName: xp.ENTITY.predefined.2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
          <!ENTITY lt     "&#38;#60;">
          <!ENTITY gt     "&#x26;#62;">
          <!ENTITY amp    "&#38;#38;">
          <!ENTITY apos   "&#x26;#39;">
          <!ENTITY quot   "&#x26;#34;">
          <!ENTITY e      "f">
          ]><a>&lt;&gt;&amp;&apos;&quot;</a>
      @@@test:domTree:
        document {
          document-type {
            general-entity {
              node-name: 'e';
              text-content: 'f';
            }
          }
          element {
            text-content: '<>&' U+0027 '"';
          }
        }
    @@XMLTest:
      @@@QName: xp.ENTITY.predefined.3.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
          <!ENTITY lt     "&#60;">
          <!ENTITY gt     "&#62;">
          <!ENTITY amp    "&#38;">
          <!ENTITY apos   "&#39;">
          <!ENTITY quot   "&#34;">
          <!ENTITY e      "f">
          ]><a>&lt;&gt;&amp;&apos;&quot;</a>
      @@@c:erred: <[[xp|error-malformed-predefined-entity]]> { (2, 1)..(2, 24); }
      @@@c:erred: <[[xp|error-malformed-predefined-entity]]> { (4, 1)..(4, 24); }
      @@@test:domTree:
        document {
          document-type {
            general-entity {
              node-name: 'e';
              text-content: 'f';
            }
          }
          element {
            text-content: '<>&' U+0027 '"';
          }
        }
    @@XMLTest:
      @@@QName: xp.ENTITY.predefined.4.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
          <!ENTITY lt     "1">
          <!ENTITY gt     "2">
          <!ENTITY amp    "3">
          <!ENTITY apos   "4">
          <!ENTITY quot   "5">
          <!ENTITY e      "f">
          ]><a>&lt;&gt;&amp;&apos;&quot;</a>
      @@@c:erred: <[[xp|error-malformed-predefined-entity]]> { (2, 1)..(2, 24); }
      @@@c:erred: <[[xp|error-malformed-predefined-entity]]> { (3, 1)..(3, 24); }
      @@@c:erred: <[[xp|error-malformed-predefined-entity]]> { (4, 1)..(4, 24); }
      @@@c:erred: <[[xp|error-malformed-predefined-entity]]> { (5, 1)..(5, 24); }
      @@@c:erred: <[[xp|error-malformed-predefined-entity]]> { (6, 1)..(6, 24); }
      @@@test:domTree:
        document {
          document-type {
            general-entity {
              node-name: 'e';
              text-content: 'f';
            }
          }
          element {
            text-content: '<>&' U+0027 '"';
          }
        }
    @@XMLTest:
      @@@QName: xp.ENTITY.predefined.5.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
          <!ENTITY lt     SYSTEM "1">
          <!ENTITY gt     SYSTEM "2">
          <!ENTITY amp    SYSTEM "3">
          <!ENTITY apos   SYSTEM "4">
          <!ENTITY quot   SYSTEM "5">
          <!ENTITY e      "f">
          ]><a>&lt;&gt;&amp;&apos;&quot;</a>
      @@@c:erred: <[[xp|error-internal-predefined-entity]]> { (2, 1)..(2, 27); }
      @@@c:erred: <[[xp|error-internal-predefined-entity]]> { (3, 1)..(3, 27); }
      @@@c:erred: <[[xp|error-internal-predefined-entity]]> { (4, 1)..(4, 27); }
      @@@c:erred: <[[xp|error-internal-predefined-entity]]> { (5, 1)..(5, 27); }
      @@@c:erred: <[[xp|error-internal-predefined-entity]]> { (6, 1)..(6, 27); }
      @@@test:domTree:
        document {
          document-type {
            general-entity {
              node-name: 'e';
              text-content: 'f';
            }
          }
          element {
            text-content: '<>&' U+0027 '"';
          }
        }
    @@XMLTest:
      @@@QName: xp.ENTITY.predefined.6.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
          <!ENTITY % lt     SYSTEM "1">
          <!ENTITY % gt     SYSTEM "2">
          <!ENTITY % amp    SYSTEM "3">
          <!ENTITY % apos   SYSTEM "4">
          <!ENTITY % quot   SYSTEM "5">
          <!ENTITY e      "f">
          ]><a>&lt;&gt;&amp;&apos;&quot;</a>
      @@@test:domTree:
        document {
          document-type {
            general-entity {
              node-name: 'e';
              text-content: 'f';
            }
          }
          element {
            text-content: '<>&' U+0027 '"';
          }
        }
    @@XMLTest:
      @@@QName: xp.ENTITY.predefined.7.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
          <!ENTITY lt     "&#38;#x3C;">
          <!ENTITY gt     "&#x3E;">
          <!ENTITY amp    "&#38;#x26;">
          <!ENTITY apos   "&#x27;">
          <!ENTITY quot   "&#x22;">
          <!ENTITY e      "f">
          ]><a>&lt;&gt;&amp;&apos;&quot;</a>
      @@@test:domTree:
        document {
          document-type {
            general-entity {
              node-name: 'e';
              text-content: 'f';
            }
          }
          element {
            text-content: '<>&' U+0027 '"';
          }
        }
    @@XMLTest:
      @@@QName: xp.ENTITY.predefined.8.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
          <!ENTITY lt     "&#38;#x3c;">
          <!ENTITY gt     "&#x3e;">
          <!ENTITY amp    "&#38;#x26;">
          <!ENTITY apos   "&#x27;">
          <!ENTITY quot   "&#x22;">
          <!ENTITY e      "f">
          ]><a>&lt;&gt;&amp;&apos;&quot;</a>
      @@@test:domTree:
        document {
          document-type {
            general-entity {
              node-name: 'e';
              text-content: 'f';
            }
          }
          element {
            text-content: '<>&' U+0027 '"';
          }
        }
    @@XMLTest:
      @@@QName: xp.ENTITY.predefined.9.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
          <!ENTITY lt     "&#38;#x00003C;">
          <!ENTITY gt     "&#x0003E;">
          <!ENTITY amp    "&#38;#x026;">
          <!ENTITY apos   "&#x000027;">
          <!ENTITY quot   "&#x0022;">
          <!ENTITY e      "f">
          ]><a>&lt;&gt;&amp;&apos;&quot;</a>
      @@@test:domTree:
        document {
          document-type {
            general-entity {
              node-name: 'e';
              text-content: 'f';
            }
          }
          element {
            text-content: '<>&' U+0027 '"';
          }
        }
    @@XMLTest:
      @@@QName: xp.ENTITY.predefined.10.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
          <!ENTITY lt     "&#38;#00060;">
          <!ENTITY gt     "&#062;">
          <!ENTITY amp    "&#38;#000038;">
          <!ENTITY apos   "&#0000039;">
          <!ENTITY quot   "&#0034;">
          <!ENTITY e      "f">
          ]><a>&lt;&gt;&amp;&apos;&quot;</a>
      @@@test:domTree:
        document {
          document-type {
            general-entity {
              node-name: 'e';
              text-content: 'f';
            }
          }
          element {
            text-content: '<>&' U+0027 '"';
          }
        }

    @@XMLTest:
      @@@QName: xp.processed.1.test
      @@@DEnt:
        @@@@test:value:
          <a/>
      @@@test:domTree:
        document {
          all-declarations-processed: true;
          element { }
        }
    @@XMLTest:
      @@@QName: xp.processed.2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
          <!ENTITY e      "f">
          <!ATTLIST a b NMTOKEN "  c  ">
          ]><a>&e;</a>
      @@@test:domTree:
        document {
          document-type {
            general-entity {
              node-name: 'e';
            }
            element-type-definition {
              node-name: 'a';
              attribute-definition {
                node-name: 'b';
              }
            }
          }
          all-declarations-processed: true;
          element {
            attribute {
              node-name: 'b';
              node-value: 'c';
            }
            text-content: 'f';
          }
        }
    @@XMLTest:
      @@@QName: xp.processed.3.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
          <!ENTITY % p    SYSTEM "p">
          %p;
          <!ENTITY e      "f">
          <!ATTLIST a b NMTOKEN "  c  ">
          ]><a d="e">&e;</a>
      @@@test:domTree:
        document {
          document-type { }
          all-declarations-processed: false;
          element {
            attribute {
              node-name: 'd';
              node-value: 'e';
            }
            general-entity-reference {
              node-name: 'e';
              is-expanded: false;
            }
          }
        }
      @@@c:erred:
        <[[xp|warning-entity-declaration-not-processed]]> { (4, 1)..(4, 20); }
      @@@c:erred:
        <[[xp|warning-attribute-definition-not-processed]]> { (5, 13)..(5, 31); }
    @@XMLTest:
      @@@QName: xp.processed.4.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.1" standalone="yes"?>
          <!DOCTYPE a [
          <!ENTITY % p    SYSTEM "p">
          %p;
          <!ENTITY e      "f">
          <!ATTLIST a b NMTOKEN "  c  ">
          ]><a>&e;</a>
      @@@test:domTree:
        document {
          document-type {
            general-entity {
              node-name: 'e';
            }
            element-type-definition {
              node-name: 'a';
              attribute-definition {
                node-name: 'b';
              }
            }
          }
          all-declarations-processed: false;
          element {
            attribute {
              node-name: 'b';
              node-value: 'c';
            }
            text-content: 'f';
          }
        }
    @@XMLTest:
      @@@QName: xp.processed.5.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a SYSTEM "p" [
          <!ENTITY e      "f">
          <!ATTLIST a b NMTOKEN "  c  ">
          ]><a>&e;</a>
      @@@test:domTree:
        document {
          document-type {
            general-entity {
              node-name: 'e';
            }
            element-type-definition {
              node-name: 'a';
              attribute-definition {
                node-name: 'b';
              }
            }
          }
          all-declarations-processed: false;
          element {
            attribute {
              node-name: 'b';
              node-value: 'c';
            }
            text-content: 'f';
          }
        }

    @@XMLTest:
      @@@QName: xp.PEs.in.internal.subset.1.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
          <!ENTITY % p " ">
          <!ENTITY % q "%p;">
          ]><a/>
      @@@c:erred: <[[xp|wf-pes-in-internal-subset]]> { (3, 15)..(3, 17); }
    @@XMLTest:
      @@@QName: xp.PEs.in.internal.subset.2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
          <!ENTITY % p " ">
          <!ENTITY % q '%p;'>
          ]><a/>
      @@@c:erred: <[[xp|wf-pes-in-internal-subset]]> { (3, 15)..(3, 17); }

    @@XMLTest:
      @@@QName: xp.name.pitarget.content.1.0.2.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0"?>
          <p>
          <?$u3001$u3002?>
          </p>
      @@@c:erred: <[[xp|wf-invalid-character-in-node-name]]> { (3, 3)..(3, 4); }
    @@XMLTest:
      @@@QName: xp.name.pitarget.content.1.1.2.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.1"?>
          <p>$
          <?$u3001$u3002?>$
          </p>
      @@@test:domTree:
        document {
          xml-version: '1.1';
          element {
            pi {
              node-name: U+3001 U+3002;
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.name.pitarget.content.1.0.3.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0"?>
          <p>
          <?$u3005b?>
          </p>
      @@@c:erred: <[[xp|wf-invalid-character-in-node-name]]> { (3, 3)..(3, 4); }
    @@XMLTest:
      @@@QName: xp.name.pitarget.content.1.1.3.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.1"?>
          <p>$
          <?$u3005b?>$
          </p>
      @@@test:domTree:
        document {
          xml-version: '1.1';
          element {
            pi {
              node-name: U+3005 'b';
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.name.pitarget.content.names.1.0.1.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0"?>
          <p>
          <?a:b?>
          </p>
      @@@c:erred: <[[xp|nswf-legal-ncname]]> { (3, 3)..(3, 5); }
    @@XMLTest:
      @@@QName: xp.name.pitarget.content.names.1.1.1.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.1"?>
          <p>
          <?a:b?>
          </p>
      @@@c:erred: <[[xp|nswf-legal-ncname]]> { (3, 3)..(3, 5); }
    @@XMLTest:
      @@@QName: xp.name.pitarget.intsubset.1.0.2.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0"?>
          <!DOCTYPE p [
          <?$u3001$u3002?>
          ]><p/>
      @@@c:erred: <[[xp|wf-invalid-character-in-node-name]]> { (3, 3)..(3, 4); }
    @@XMLTest:
      @@@QName: xp.name.pitarget.intsubset.1.1.2.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.1"?>
          <!DOCTYPE p [
          <?$u3001$u3002?>
          ]><p/>
      @@@test:domTree:
        document {
          xml-version: '1.1';
          document-type {
            pi {
              node-name: U+3001 U+3002;
            }
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.name.pitarget.intsubset.1.0.3.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0"?>
          <!DOCTYPE p [
          <?$u3005b?>
          ]><p/>
      @@@c:erred: <[[xp|wf-invalid-character-in-node-name]]> { (3, 3)..(3, 4); }
    @@XMLTest:
      @@@QName: xp.name.pitarget.intsubset.1.1.3.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.1"?>
          <!DOCTYPE p [
          <?$u3005b?>
          ]><p/>
      @@@test:domTree:
        document {
          xml-version: '1.1';
          document-type {
            pi {
              node-name: U+3005 'b';
            }
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.name.pitarget.intsubset.names.1.0.1.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0"?>
          <!DOCTYPE p [
          <?a:b?>
          ]><p/>
      @@@c:erred: <[[xp|nswf-legal-ncname]]> { (3, 3)..(3, 5); }
    @@XMLTest:
      @@@QName: xp.name.pitarget.intsubset.names.1.1.1.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.1"?>
          <!DOCTYPE p [
          <?a:b?>
          ]><p/>
      @@@c:erred: <[[xp|nswf-legal-ncname]]> { (3, 3)..(3, 5); }
    @@XMLTest:
      @@@QName: xp.name.doctypedecl.stag.etag.1.0.2.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0"?>
          <!DOCTYPE $u3001$u3002>
          <$u3001$u3002>
          </$u3001$u3002>
      @@@c:erred: <[[xp|wf-invalid-character-in-node-name]]>{ (2, 11)..(2, 12); }
      @@@c:erred: <[[xp|wf-invalid-character-in-node-name]]>{ (3, 2)..(3, 3); }
#      @@@c:erred: <[[xp|wf-invalid-character-in-node-name]]>{ (4, 3)..(4, 4); }
    @@XMLTest:
      @@@QName: xp.name.doctypedecl.stag.etag.1.1.2.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.1"?>
          <!DOCTYPE $u3001$u3002>
          <$u3001$u3002>
          </$u3001$u3002>
      @@@test:domTree:
        document {
          xml-version: '1.1';
          document-type {
            node-name: U+3001 U+3002;
          }
          element {
            node-name: U+3001 U+3002;
          }
        }
    @@XMLTest:
      @@@QName: xp.name.doctypedecl.stag.etag.1.0.3.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0"?>
          <!DOCTYPE $u3005b>
          <$u3005b>
          </$u3005b>
      @@@c:erred: <[[xp|wf-invalid-character-in-node-name]]>{ (2, 11)..(2, 12); }
      @@@c:erred: <[[xp|wf-invalid-character-in-node-name]]>{ (3, 2)..(3, 3); }
#      @@@c:erred: <[[xp|wf-invalid-character-in-node-name]]>{ (4, 3)..(4, 4); }
    @@XMLTest:
      @@@QName: xp.name.doctype.decl.stag.etag.1.1.3.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.1"?>
          <!DOCTYPE $u3005b>
          <$u3005b>
          </$u3005b>
      @@@test:domTree:
        document {
          xml-version: '1.1';
          document-type {
            node-name: U+3005 'b';
          }
          element {
            node-name: U+3005 'b';
          }
        }
    @@XMLTest:
      @@@QName: xp.name.doctypedecl.stag.etag.names.1.0.1.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0"?>
          <!DOCTYPE a:b>
          <a:b xmlns:a="http://a.example/">
          </a:b>
      @@@test:domTree:
        document {
          xml-version: '1.0';
          document-type {
            node-name: 'a:b';
          }
          element {
            prefix: 'a';
            local-name: 'b';
            namespace-uri: 'http://a.example/';
            attribute {
              namespace-uri: 'http://www.w3.org/2000/xmlns/';
              prefix: 'xmlns';
              local-name: 'a';
              value: 'http://a.example/';
              specified: true;
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.name.doctypedecl.stag.etag.names.1.1.1.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.1"?>
          <!DOCTYPE a:b>
          <a:b xmlns:a="http://a.example/">
          </a:b>
      @@@test:domTree:
        document {
          xml-version: '1.1';
          document-type {
            node-name: 'a:b';
          }
          element {
            prefix: 'a';
            local-name: 'b';
            namespace-uri: 'http://a.example/';
            attribute {
              namespace-uri: 'http://www.w3.org/2000/xmlns/';
              prefix: 'xmlns';
              local-name: 'a';
              specified: true;
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.name.doctypedecl.stag.etag.names.1.0.2.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0"?>
          <!DOCTYPE :ab>
          <:ab>
          </:ab>
      @@@c:erred: <[[xp|nswf-legal-qname]]> { (2, 11)..(2, 13); }
      @@@c:erred: <[[xp|nswf-legal-qname]]> { (3, 2)..(3, 4); }
      @@@c:erred: <[[xp|nsc-prefix-declared]]> { /* prefix || */ }
    @@XMLTest:
      @@@QName: xp.name.doctypedecl.stag.etag.names.1.1.2.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.1"?>
          <!DOCTYPE :ab>
          <:ab>
          </:ab>
      @@@c:erred: <[[xp|nswf-legal-qname]]> { (2, 11)..(2, 13); }
      @@@c:erred: <[[xp|nswf-legal-qname]]> { (3, 2)..(3, 4); }
      @@@c:erred: <[[xp|nsc-prefix-declared]]> { /* prefix || */ }
    @@XMLTest:
      @@@QName: xp.name.doctypedecl.stag.etag.names.1.0.3.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0"?>
          <!DOCTYPE a:$u3005>
          <a:$u3005 xmlns:a="http://a.example/">
          </a:$u3005>
      @@@c:erred: <[[xp|nswf-legal-qname]]> { (2, 11)..(2, 13); }
      @@@c:erred: <[[xp|nswf-legal-qname]]> { (3, 2)..(3, 4); }
    @@XMLTest:
      @@@QName: xp.name.doctypedecl.stag.etag.names.1.1.3.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.1"?>
          <!DOCTYPE a:$u3005>
          <a:$u3005 xmlns:a="http://a.example/">
          </a:$u3005>
      @@@test:domTree:
        document {
          xml-version: '1.1';
          document-type {
            node-name: 'a:' U+3005;
          }
          element {
            prefix: 'a';
            local-name: U+3005;
            namespace-uri: 'http://a.example/';
            attribute {
              namespace-uri: 'http://www.w3.org/2000/xmlns/';
              prefix: 'xmlns';
              local-name: 'a';
              value: 'http://a.example/';
              specified: true;
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.name.doctypedecl.stag.etag.names.1.0.4.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0"?>
          <!DOCTYPE a:b>
          <a:b>
          </a:b>
      @@@c:erred: <[[xp|nsc-prefix-declared]]> { (3, 1)..(3, 5); }
    @@XMLTest:
      @@@QName: xp.name.doctypedecl.stag.etag.names.1.1.4.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.1"?>
          <!DOCTYPE a:b>
          <a:b>
          </a:b>
      @@@c:erred: <[[xp|nsc-prefix-declared]]> { (3, 1)..(3, 5); }
    @@XMLTest:
      @@@QName: xp.name.emptyelemtag.1.0.2.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0"?>
          <$u3001$u3002/>
      @@@c:erred: <[[xp|wf-invalid-character-in-node-name]]>{ (2, 2)..(2, 3); }
    @@XMLTest:
      @@@QName: xp.name.emptyelemtag.1.1.2.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.1"?>
          <$u3001$u3002/>
      @@@test:domTree:
        document {
          xml-version: '1.1';
          element {
            node-name: U+3001 U+3002;
          }
        }
    @@XMLTest:
      @@@QName: xp.name.emptyelemtag.1.0.3.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0"?>
          <$u3005b/>
      @@@c:erred: <[[xp|wf-invalid-character-in-node-name]]>{ (2, 2)..(2, 3); }
    @@XMLTest:
      @@@QName: xp.name.emptyelemtag.1.1.3.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.1"?>
          <$u3005b/>
      @@@test:domTree:
        document {
          xml-version: '1.1';
          element {
            node-name: U+3005 'b';
          }
        }
    @@XMLTest:
      @@@QName: xp.name.emptyelemtag.names.1.0.1.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0"?>
          <a:b/>
      @@@c:erred: <[[xp|nsc-prefix-declared]]>{ (2, 1)..(2, 6); }
    @@XMLTest:
      @@@QName: xp.name.emptyelemtag.names.1.1.1.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.1"?>
          <a:b/>
      @@@c:erred: <[[xp|nsc-prefix-declared]]>{ (2, 1)..(2, 6); }
    @@XMLTest:
      @@@QName: xp.name.attr.1.0.2.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0"?>
          <a $u3001$u3002=""/>
      @@@c:erred: <[[xp|wf-invalid-character-in-node-name]]>{ (2, 4)..(2, 5); }
    @@XMLTest:
      @@@QName: xp.name.attr.1.1.2.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.1"?>
          <a $u3001$u3002=""/>
      @@@test:domTree:
        document {
          xml-version: '1.1';
          element {
            attribute {
              node-name: U+3001 U+3002;
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.name.attr.1.0.3.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0"?>
          <a $u3005b=""/>
      @@@c:erred: <[[xp|wf-invalid-character-in-node-name]]>{ (2, 4)..(2, 5); }
    @@XMLTest:
      @@@QName: xp.name.attr.1.1.3.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.1"?>
          <a $u3005b=""/>
      @@@test:domTree:
        document {
          xml-version: '1.1';
          element {
            attribute {
              node-name: U+3005 'b';
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.name.attr.names.1.0.1.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0"?>
          <a a:b=""/>
      @@@c:erred: <[[xp|nsc-prefix-declared]]>{ (2, 1)..(2, 11); }
    @@XMLTest:
      @@@QName: xp.name.attr.names.1.1.1.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.1"?>
          <a a:b=""/>
      @@@c:erred: <[[xp|nsc-prefix-declared]]>{ (2, 1)..(2, 11); }
    @@XMLTest:
      @@@QName: xp.name.attr.names.1.0.2.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0"?>
          <a :ab=""/>
      @@@c:erred: <[[xp|nswf-legal-qname]]>{ (2, 4)..(2, 6); }
      @@@c:erred: <[[xp|nsc-prefix-declared]]> { }
    @@XMLTest:
      @@@QName: xp.name.attr.names.1.1.2.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.1"?>
          <a :ab=""/>
      @@@c:erred: <[[xp|nswf-legal-qname]]>{ (2, 4)..(2, 6); }
      @@@c:erred: <[[xp|nsc-prefix-declared]]> { }
    @@XMLTest:
      @@@QName: xp.name.attlist.1.0.2.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0"?>
          <!DOCTYPE p [
          <!NOTATION $u3001$u3002 SYSTEM "n">
          <!ATTLIST $u3001$u3002
          $u3001$u3002
          NOTATION
          ($u3001$u3002)
          #IMPLIED>
          ]><p/>
      @@@c:erred: <[[xp|wf-invalid-character-in-node-name]]>{ (3, 12)..(3, 13); }
      @@@c:erred: <[[xp|wf-invalid-character-in-node-name]]>{ (4, 11)..(4, 12); }
      @@@c:erred: <[[xp|wf-invalid-character-in-node-name]]>{ (5, 1)..(5, 2); }
      @@@c:erred: <[[xp|wf-invalid-character-in-node-name]]>{ (7, 2)..(7, 3); }
    @@XMLTest:
      @@@QName: xp.name.attlist.1.1.2.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.1"?>
          <!DOCTYPE p [
          <!NOTATION $u3001$u3002 SYSTEM "n">
          <!ATTLIST $u3001$u3002
          $u3001$u3002
          NOTATION
          ($u3001$u3002)
          #IMPLIED>
          ]><p/>
      @@@test:domTree:
        document {
          xml-version: '1.1';
          document-type {
            notation {
              node-name: U+3001 U+3002;
            }
            element-type-definition {
              node-name: U+3001 U+3002;
              attribute-definition {
                node-name: U+3001 U+3002;
                allowed-tokens: DOMStringList (U+3001 U+3002);
              }
            }
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.name.attlist.1.0.3.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0"?>
          <!DOCTYPE p [
          <!NOTATION $u3005b SYSTEM "n">
          <!ATTLIST $u3005b
          $u3005b
          NOTATION
          ($u3005b)
          #IMPLIED>
          ]><p/>
      @@@c:erred: <[[xp|wf-invalid-character-in-node-name]]>{ (3, 12)..(3, 13); }
      @@@c:erred: <[[xp|wf-invalid-character-in-node-name]]>{ (4, 11)..(4, 12); }
      @@@c:erred: <[[xp|wf-invalid-character-in-node-name]]>{ (5, 1)..(5, 2); }
      @@@c:erred: <[[xp|wf-invalid-character-in-node-name]]>{ (7, 2)..(7, 3); }
    @@XMLTest:
      @@@QName: xp.name.attlist.1.1.3.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.1"?>
          <!DOCTYPE p [
          <!NOTATION $u3005b SYSTEM "n">
          <!ATTLIST $u3005b
          $u3005b
          NOTATION
          ($u3005b)
          #IMPLIED>
          ]><p/>
      @@@test:domTree:
        document {
          xml-version: '1.1';
          document-type {
            notation {
              node-name: U+3005 'b';
            }
            element-type-definition {
              node-name: U+3005 'b';
              attribute-definition {
                node-name: U+3005 'b';
                allowed-tokens: DOMStringList (U+3005 'b');
              }
            }
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.name.attlist.names.1.0.1.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0"?>
          <!DOCTYPE p [
          <!NOTATION a:b SYSTEM "n">
          <!ATTLIST a:b
          a:b
          NOTATION
          (a:b)
          #IMPLIED>
          ]><p/>
      @@@c:erred: <[[xp|nswf-legal-ncname]]>{ (3, 12)..(3, 14); }
      @@@c:erred: <[[xp|nswf-legal-ncname]]>{ (7, 2)..(7, 4); }
    @@XMLTest:
      @@@QName: xp.name.attlist.names.1.1.1.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.1"?>
          <!DOCTYPE p [
          <!NOTATION a:b SYSTEM "n">
          <!ATTLIST a:b
          a:b
          NOTATION
          (a:b)
          #IMPLIED>
          ]><p/>
      @@@c:erred: <[[xp|nswf-legal-ncname]]>{ (3, 12)..(3, 14); }
      @@@c:erred: <[[xp|nswf-legal-ncname]]>{ (7, 2)..(7, 4); }
    @@XMLTest:
      @@@QName: xp.name.attlist.names.1.0.2.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0"?>
          <!DOCTYPE p [
          <!NOTATION :ab SYSTEM "n">
          <!ATTLIST :ab
          :ab
          NOTATION
          (:ab)
          #IMPLIED>
          ]><p/>
      @@@c:erred: <[[xp|nswf-legal-ncname]]>{ (3, 12)..(3, 14); }
      @@@c:erred: <[[xp|nswf-legal-qname]]>{ (4, 11)..(4, 13); }
      @@@c:erred: <[[xp|nswf-legal-qname]]>{ (5, 1)..(5, 3); }
      @@@c:erred: <[[xp|nswf-legal-ncname]]>{ (7, 2)..(7, 4); }
    @@XMLTest:
      @@@QName: xp.name.attlist.names.1.1.2.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.1"?>
          <!DOCTYPE p [
          <!NOTATION :ab SYSTEM "n">
          <!ATTLIST :ab
          :ab
          NOTATION
          (:ab)
          #IMPLIED>
          ]><p/>
      @@@c:erred: <[[xp|nswf-legal-ncname]]>{ (3, 12)..(3, 14); }
      @@@c:erred: <[[xp|nswf-legal-qname]]>{ (4, 11)..(4, 13); }
      @@@c:erred: <[[xp|nswf-legal-qname]]>{ (5, 1)..(5, 3); }
      @@@c:erred: <[[xp|nswf-legal-ncname]]>{ (7, 2)..(7, 4); }
    @@XMLTest:
      @@@QName: xp.name.gent.1.0.2.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0"?>
          <!DOCTYPE p [
          <!ENTITY $u3001$u3002 "n">
          ]>
          <p a="&$u3001$u3002;">
          &$u3001$u3002;
          </p>
      @@@c:erred: <[[xp|wf-invalid-character-in-node-name]]>{ (3, 10)..(3, 11); }
      @@@c:erred: <[[xp|wf-invalid-character-in-node-name]]>{ (5, 8)..(5, 9); }
      @@@c:erred: <[[xp|wf-invalid-character-in-node-name]]>{ (6, 2)..(6, 3); }
    @@XMLTest:
      @@@QName: xp.name.ger.1.1.2.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.1"?>
          <!DOCTYPE p [
          <!ENTITY $u3001$u3002 "n">
          ]>
          <p a="&$u3001$u3002;">$
          &$u3001$u3002;$
          </p>
      @@@test:domTree:
        document {
          xml-version: '1.1';
          document-type {
            general-entity {
              node-name: U+3001 U+3002;
            }
          }
          element {
            attribute {
              node-name: 'a';
              general-entity-reference {
                node-name: U+3001 U+3002;
              }
            }
            general-entity-reference {
              node-name: U+3001 U+3002;
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.name.ger.1.0.3.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0"?>
          <!DOCTYPE p [
          <!ENTITY $u3005b "n">
          ]>
          <p a="&$u3005b;">
          &$u3005b;
          </p>
      @@@c:erred: <[[xp|wf-invalid-character-in-node-name]]>{ (3, 10)..(3, 11); }
      @@@c:erred: <[[xp|wf-invalid-character-in-node-name]]>{ (5, 8)..(5, 9); }
      @@@c:erred: <[[xp|wf-invalid-character-in-node-name]]>{ (6, 2)..(6, 3); }
    @@XMLTest:
      @@@QName: xp.name.ger.1.1.3.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.1"?>
          <!DOCTYPE p [
          <!ENTITY $u3005b "n">
          ]>
          <p a="&$u3005b;">$
          &$u3005b;$
          </p>
      @@@test:domTree:
        document {
          xml-version: '1.1';
          document-type {
            general-entity {
              node-name: U+3005 'b';
            }
          }
          element {
            attribute {
              node-name: 'a';
              general-entity-reference {
                node-name: U+3005 'b';
              }
            }
            general-entity-reference {
              node-name: U+3005 'b';
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.name.ger.names.1.0.1.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0"?>
          <!DOCTYPE p [
          <!ENTITY a:b "n">
          ]>
          <p a="&a:b;">
          &a:b;
          </p>
      @@@c:erred: <[[xp|nswf-legal-ncname]]>{ (3, 10)..(3, 12); }
      @@@c:erred: <[[xp|nswf-legal-ncname]]>{ (5, 8)..(5, 10); }
      @@@c:erred: <[[xp|nswf-legal-ncname]]>{ (6, 2)..(6, 4); }
    @@XMLTest:
      @@@QName: xp.name.ger.names.1.1.1.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.1"?>
          <!DOCTYPE p [
          <!ENTITY a:b "n">
          ]>
          <p a="&a:b;">
          &a:b;
          </p>
      @@@c:erred: <[[xp|nswf-legal-ncname]]>{ (3, 10)..(3, 12); }
      @@@c:erred: <[[xp|nswf-legal-ncname]]>{ (5, 8)..(5, 10); }
      @@@c:erred: <[[xp|nswf-legal-ncname]]>{ (6, 2)..(6, 4); }
    @@XMLTest:
      @@@QName: xp.name.ndata.1.0.2.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0"?>
          <!DOCTYPE p [
          <!NOTATION $u3001$u3002 SYSTEM "n">
          <!ENTITY e SYSTEM "s" NDATA $u3001$u3002>
          ]><p/>
      @@@c:erred: <[[xp|wf-invalid-character-in-node-name]]>{ (3, 12)..(3, 13); }
      @@@c:erred: <[[xp|wf-invalid-character-in-node-name]]>{ (4, 29)..(4, 30); }
    @@XMLTest:
      @@@QName: xp.name.ndata.1.1.2.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.1"?>
          <!DOCTYPE p [
          <!NOTATION $u3001$u3002 SYSTEM "n">
          <!ENTITY e SYSTEM "s" NDATA $u3001$u3002>
          ]><p/>
      @@@test:domTree:
        document {
          xml-version: '1.1';
          document-type {
            notation {
              node-name: U+3001 U+3002;
            }
            general-entity {
              node-name: 'e';
              notation-name: U+3001 U+3002;
            }
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.name.ndata.1.0.3.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0"?>
          <!DOCTYPE p [
          <!NOTATION $u3005b SYSTEM "n">
          <!ENTITY e SYSTEM "s" NDATA $u3005b>
          ]><p/>
      @@@c:erred: <[[xp|wf-invalid-character-in-node-name]]>{ (3, 12)..(3, 13); }
      @@@c:erred: <[[xp|wf-invalid-character-in-node-name]]>{ (4, 29)..(4, 30); }
    @@XMLTest:
      @@@QName: xp.name.ndata.1.1.3.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.1"?>
          <!DOCTYPE p [
          <!NOTATION $u3005b SYSTEM "n">
          <!ENTITY e SYSTEM "s" NDATA $u3005b>
          ]><p/>
      @@@test:domTree:
        document {
          xml-version: '1.1';
          document-type {
            notation {
              node-name: U+3005 'b';
            }
            general-entity {
              node-name: 'e';
              notation-name: U+3005 'b';
            }
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.name.ndata.names.1.0.1.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0"?>
          <!DOCTYPE p [
          <!NOTATION a:b SYSTEM "n">
          <!ENTITY e SYSTEM "s" NDATA a:b>
          ]><p/>
      @@@c:erred: <[[xp|nswf-legal-ncname]]>{ (3, 12)..(3, 14); }
      @@@c:erred: <[[xp|nswf-legal-ncname]]>{ (4, 29)..(4, 31); }
    @@XMLTest:
      @@@QName: xp.name.ndata.names.1.1.1.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.1"?>
          <!DOCTYPE p [
          <!NOTATION a:b SYSTEM "n">
          <!ENTITY e SYSTEM "s" NDATA a:b>
          ]><p/>
      @@@c:erred: <[[xp|nswf-legal-ncname]]>{ (3, 12)..(3, 14); }
      @@@c:erred: <[[xp|nswf-legal-ncname]]>{ (4, 29)..(4, 31); }

    @@enImplNote:
      @@@ddid: wf-invalid-character-in-node-name
      @@@@:
        {ISSUE::
          {P:: Tests required for:

            - <CODE::Name> in element type declaration

            - <CODE::Name> in model group

            - <CODE::Name> in parameter entity declaration

            - <CODE::Name> in parameter entity reference

          }
        }

    @@XMLTest:
      @@@QName: xp.NOTATION.1.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p [
          <!NOTATION n SYSTEM "m">
          ]><p/>
      @@@test:domTree:
        document {
          document-type {
            notation {
              node-name: 'n';
              public-id: null;
              system-id: 'm';
            }
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.NOTATION.2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p [
          <!NOTATION n PUBLIC "m">
          ]><p/>
      @@@test:domTree:
        document {
          document-type {
            notation {
              node-name: 'n';
              system-id: null;
              public-id: 'm';
            }
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.NOTATION.3.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p [
          <!NOTATION n PUBLIC "m" "l">
          ]><p/>
      @@@test:domTree:
        document {
          document-type {
            notation {
              node-name: 'n';
              public-id: 'm';
              system-id: 'l';
            }
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.NOTATION.4.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p [
          <!NOTATION n SYSTEM "m">
          <!NOTATION n SYSTEM "l">
          ]><p/>
      @@@c:erred: <[[xp|vc-unique-notation-name]]> { (3, 1)..(3, 24); }
      @@@test:domTree:
        document {
          document-type {
            notation {
              node-name: 'n';
              system-id: 'm';
            }
          }
          element { }
        }

    @@XMLTest:
      @@@QName: xp.names.1.test
      @@@DEnt:
        @@@@test:value:
          <p xmlns="http://1.example/" a="b"/>
      @@@test:domTree:
        document {
          element {
            prefix: null;
            local-name: 'p';
            namespace-uri: 'http://1.example/';
            attribute {
              prefix: null;
              local-name: 'xmlns';
              namespace-uri: 'http://www.w3.org/2000/xmlns/';
              specified: true;
            }
            attribute {
              prefix: null;
              local-name: 'a';
              specified: true;
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.names.2.test
      @@@DEnt:
        @@@@test:value:
          <p xmlns:a="http://1.example/" a="b" a:a="c"/>
      @@@test:domTree:
        document {
          element {
            prefix: null;
            local-name: 'p';
            namespace-uri: null;
            attribute {
              prefix: 'xmlns';
              local-name: 'a';
              namespace-uri: 'http://www.w3.org/2000/xmlns/';
              specified: true;
            }
            attribute {
              prefix: null;
              local-name: 'a';
              specified: true;
            }
            attribute {
              prefix: 'a';
              local-name: 'a';
              namespace-uri: 'http://1.example/';
              specified: true;
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.names.3.test
      @@@DEnt:
        @@@@test:value:
          <a:p xmlns:a="http://1.example/" a="b" a:a="c"/>
      @@@test:domTree:
        document {
          element {
            prefix: 'a';
            local-name: 'p';
            namespace-uri: 'http://1.example/';
            attribute {
              prefix: 'xmlns';
              local-name: 'a';
              namespace-uri: 'http://www.w3.org/2000/xmlns/';
              specified: true;
            }
            attribute {
              prefix: null;
              local-name: 'a';
              specified: true;
            }
            attribute {
              prefix: 'a';
              local-name: 'a';
              namespace-uri: 'http://1.example/';
              specified: true;
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.names.5.test
      @@@DEnt:
        @@@@test:value:
          <p xmlns:a="http://1.example/">$
          <a:q/>$
          </p>
      @@@test:domTree:
        document {
          element {
            prefix: null;
            local-name: 'p';
            namespace-uri: null;
            attribute {
              prefix: 'xmlns';
              local-name: 'a';
              namespace-uri: 'http://www.w3.org/2000/xmlns/';
              specified: true;
            }
            element {
              prefix: 'a';
              local-name: 'q';
              namespace-uri: 'http://1.example/';
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.names.6.test
      @@@DEnt:
        @@@@test:value:
          <p xmlns:a="http://1.example/">$
          <q a:b="c"/>$
          </p>
      @@@test:domTree:
        document {
          element {
            prefix: null;
            local-name: 'p';
            namespace-uri: null;
            attribute {
              prefix: 'xmlns';
              local-name: 'a';
              namespace-uri: 'http://www.w3.org/2000/xmlns/';
              specified: true;
            }
            element {
              prefix: null;
              local-name: 'q';
              namespace-uri: null;
              attribute {
                prefix: 'a';
                local-name: 'b';
                namespace-uri: 'http://1.example/';
                specified: true;
              }
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.names.7.test
      @@@DEnt:
        @@@@test:value:
          <p xmlns:a="http://1.example/">$
          <q a:b="c" xmlns:a="http://2.example/"/>$
          </p>
      @@@test:domTree:
        document {
          element {
            prefix: null;
            local-name: 'p';
            namespace-uri: null;
            attribute {
              prefix: 'xmlns';
              local-name: 'a';
              namespace-uri: 'http://www.w3.org/2000/xmlns/';
              specified: true;
            }
            element {
              prefix: null;
              local-name: 'q';
              namespace-uri: null;
              attribute {
                prefix: 'a';
                local-name: 'b';
                namespace-uri: 'http://2.example/';
                specified: true;
              }
              attribute {
                prefix: 'xmlns';
                local-name: 'a';
                namespace-uri: 'http://www.w3.org/2000/xmlns/';
                specified: true;
              }
            }
          }
        }

    @@XMLTest:
      @@@QName: xp.names.undeclare.1.test
      @@@DEnt:
        @@@@test:value:
          <p xmlns="http://1.example/">$
          <q xmlns="">$
          <r xmlns="http://2.example/"/>$
          </q>$
          </p>
      @@@test:domTree:
        document {
          element {
            prefix: null;
            local-name: 'p';
            namespace-uri: 'http://1.example/';
            attribute {
              prefix: null;
              local-name: 'xmlns';
              namespace-uri: 'http://www.w3.org/2000/xmlns/';
              specified: true;
            }
            element {
              prefix: null;
              local-name: 'q';
              namespace-uri: null;
              attribute {
                prefix: null;
                local-name: 'xmlns';
                namespace-uri: 'http://www.w3.org/2000/xmlns/';
                specified: true;
              }
              element {
                prefix: null;
                local-name: 'r';
                namespace-uri: 'http://2.example/';
                attribute {
                  prefix: null;
                  local-name: 'xmlns';
                  namespace-uri: 'http://www.w3.org/2000/xmlns/';
                  specified: true;
                }
              }
            }
          }
        }

    @@XMLTest:
      @@@QName: xp.names.undeclare.1.0.1.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.0"?>
          <a:p xmlns:a="http://1.example/">$
          <q xmlns:a="">$
          <a:r xmlns:a="http://2.example/"/>$
          </q>$
          </a:p>
      @@@c:erred: <[[xp|nswf-empty-namespace-name]]> { (2, 34)..(2, 47); }
    @@XMLTest:
      @@@QName: xp.names.undeclare.1.1.1.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.1"?>
          <a:p xmlns:a="http://1.example/">$
          <q xmlns:a="">$
          <a:r xmlns:a="http://2.example/"/>$
          </q>$
          </a:p>
      @@@test:domTree:
        document {
          element {
            prefix: 'a';
            local-name: 'p';
            namespace-uri: 'http://1.example/';
            attribute {
              prefix: 'xmlns';
              local-name: 'a';
              namespace-uri: 'http://www.w3.org/2000/xmlns/';
              specified: true;
            }
            element {
              prefix: null;
              local-name: 'q';
              namespace-uri: null;
              attribute {
                prefix: 'xmlns';
                local-name: 'a';
                namespace-uri: 'http://www.w3.org/2000/xmlns/';
                specified: true;
              }
              element {
                prefix: 'a';
                local-name: 'r';
                namespace-uri: 'http://2.example/';
                attribute {
                  prefix: 'xmlns';
                  local-name: 'a';
                  namespace-uri: 'http://www.w3.org/2000/xmlns/';
                  specified: true;
                }
              }
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.names.undeclare.1.1.2.test
      @@@DEnt:
        @@@@test:value:
          <?xml version="1.1"?>
          <a:p xmlns:a="http://1.example/">$
          <q xmlns:a="">$
          <a:r/>$
          </q>$
          </a:p>
      @@@c:erred: <[[xp|nsc-prefix-declared]]> { (2, 48)..(2, 53); }

    @@XMLTest:
      @@@QName: xp.names.xml.prefix.1.test
      @@@DEnt:
        @@@@test:value:
          <a xmlns:xml="http://www.w3.org/XML/1998/namespace"/>
      @@@test:domTree:
        document {
          element {
            attribute {
              prefix: 'xmlns';
              local-name: 'xml';
              namespace-uri: 'http://www.w3.org/2000/xmlns/';
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.names.xml.prefix.2.test
      @@@DEnt:
        @@@@test:value:
          <a xmlns:xml="a"/>
      @@@c:erred: <[[xp|nsc-reserved-prefix-xml]]> { (1, 1)..(1, 18); }
    @@XMLTest:
      @@@QName: xp.names.xml.prefix.3.test
      @@@DEnt:
        @@@@test:value:
          <a xmlns:a="http://www.w3.org/XML/1998/namespace"
          />
      @@@c:erred: <[[xp|nsc-reserved-namespace-name-xml]]> { (1, 1)..(2, 2); }
    @@XMLTest:
      @@@QName: xp.names.xml.prefix.4.test
      @@@DEnt:
        @@@@test:value:
          <a xml:lang="ja"/>
      @@@test:domTree:
        document {
          element {
            attribute {
              prefix: 'xml';
              local-name: 'lang';
              namespace-uri: 'http://www.w3.org/XML/1998/namespace';
            }
          }
        }

    @@XMLTest:
      @@@QName: xp.names.prefix.declared.1.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
          <!ATTLIST a
          b:c CDATA "d"
          >
          ]>
          <a/>
      @@@c:erred: <[[xp|nsc-prefix-declared]]> { (6, 1)..(6, 4); }

    @@XMLTest:
      @@@QName: xp.names.xmlns.reserved.1.test
      @@@DEnt:
        @@@@test:value:
          <a xmlns:xmlns="http://www.w3.org/2000/xmlns/"
          />
      @@@c:erred: <[[xp|nsc-reserved-prefix-xmlns]]> { (1, 1)..(2, 2); }
      @@@c:erred: <[[xp|nsc-reserved-namespace-name-xmlns]]> { (1, 1)..(2, 2); }
    @@XMLTest:
      @@@QName: xp.names.xmlns.reserved.2.test
      @@@DEnt:
        @@@@test:value:
          <a xmlns:xmlns="a"
          />
      @@@c:erred: <[[xp|nsc-reserved-prefix-xmlns]]> { (1, 1)..(2, 2); }
    @@XMLTest:
      @@@QName: xp.names.xmlns.reserved.3.test
      @@@DEnt:
        @@@@test:value:
          <a xmlns:a="http://www.w3.org/2000/xmlns/"
          />
      @@@c:erred: <[[xp|nsc-reserved-namespace-name-xmlns]]> { (1, 1)..(2, 2); }

    @@XMLTest:
      @@@QName: xp.names.default.1.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
          <!ATTLIST a
          xmlns CDATA "http://1.example/">
          ]>
          <a/>
      @@@test:domTree:
        document {
          document-type {
            element-type-definition {
              node-name: 'a';
              attribute-definition {
                node-name: 'xmlns';
                node-value: 'http://1.example/';
              }
            }
          }
          element {
            prefix: null;
            local-name: 'a';
            namespace-uri: 'http://1.example/';
            attribute {
              prefix: null;
              local-name: 'xmlns';
              namespace-uri: 'http://www.w3.org/2000/xmlns/';
              value: 'http://1.example/';
              specified: false;
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.names.default.2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
          <!ATTLIST a
          xmlns CDATA "http://1.example/">
          ]>
          <a xmlns="http://2.example/"/>
      @@@test:domTree:
        document {
          document-type {
            element-type-definition {
              node-name: 'a';
              attribute-definition {
                node-name: 'xmlns';
                node-value: 'http://1.example/';
              }
            }
          }
          element {
            prefix: null;
            local-name: 'a';
            namespace-uri: 'http://2.example/';
            attribute {
              prefix: null;
              local-name: 'xmlns';
              namespace-uri: 'http://www.w3.org/2000/xmlns/';
              value: 'http://2.example/';
              specified: true;
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.names.default.3.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE b:a [
          <!ATTLIST b:a
          xmlns:b CDATA "http://1.example/">
          ]>
          <b:a/>
      @@@test:domTree:
        document {
          document-type {
            element-type-definition {
              node-name: 'b:a';
              attribute-definition {
                node-name: 'xmlns:b';
                node-value: 'http://1.example/';
              }
            }
          }
          element {
            prefix: 'b';
            local-name: 'a';
            namespace-uri: 'http://1.example/';
            attribute {
              prefix: 'xmlns';
              local-name: 'b';
              namespace-uri: 'http://www.w3.org/2000/xmlns/';
              value: 'http://1.example/';
              specified: false;
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.names.default.4.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE b:a [
          <!ATTLIST b:a
          xmlns:b CDATA "http://1.example/">
          ]>
          <b:a xmlns:b="http://2.example/"/>
      @@@test:domTree:
        document {
          document-type {
            element-type-definition {
              node-name: 'b:a';
              attribute-definition {
                node-name: 'xmlns:b';
                node-value: 'http://1.example/';
              }
            }
          }
          element {
            prefix: 'b';
            local-name: 'a';
            namespace-uri: 'http://2.example/';
            attribute {
              prefix: 'xmlns';
              local-name: 'b';
              namespace-uri: 'http://www.w3.org/2000/xmlns/';
              value: 'http://2.example/';
              specified: true;
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.names.default.5.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
          <!ATTLIST a
          xmlns:b CDATA "http://1.example/"
          b:c CDATA "http://1.example/">
          ]>
          <a xmlns:b="http://2.example/"/>
      @@@test:domTree:
        document {
          document-type {
            element-type-definition {
              node-name: 'a';
              attribute-definition {
                node-name: 'xmlns:b';
                text-content: 'http://1.example/';
              }
              attribute-definition {
                node-name: 'b:c';
                text-content: 'http://1.example/';
              }
            }
          }
          element {
            prefix: null;
            local-name: 'a';
            namespace-uri: null;
            attribute {
              prefix: 'xmlns';
              local-name: 'b';
              namespace-uri: 'http://www.w3.org/2000/xmlns/';
              value: 'http://2.example/';
              specified: true;
            }
            attribute {
              prefix: 'b';
              local-name: 'c';
              namespace-uri: 'http://2.example/';
              specified: false;
            }
          }
        }

    @@XMLTest:
      @@@QName: xp.names.unique.1.test
      @@@DEnt:
        @@@@test:value:
          <a
          xmlns:b="http://2.example/"
          xmlns:c="http://2.example/"
          b:d=""
          c:d=""
          />
      @@@c:erred: <[[xp|nswf-unique-att-spec-expanded-name]]> { (1, 1)..(6, 2); }
    @@XMLTest:
      @@@QName: xp.names.unique.2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
          <!ATTLIST a
          c:d CDATA ""
          >
          ]>
          <a
          xmlns:b="http://2.example/"
          xmlns:c="http://2.example/"
          b:d=""
          />
      @@@c:erred: <[[xp|nswf-unique-att-spec-expanded-name]]> { (6, 1)..(10, 2);}
    @@XMLTest:
      @@@QName: xp.names.unique.3.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
          <!ATTLIST a
          c:d CDATA "value1"
          >
          ]>
          <a
          xmlns:c="http://2.example/"
          c:d="value2"
          />
      @@@test:domTree:
        document {
          document-type { }
          element {
            attribute {
              prefix: 'xmlns';
              local-name: 'c';
              namespace-uri: 'http://www.w3.org/2000/xmlns/';
              specified: true;
            }
            attribute {
              prefix: 'c';
              local-name: 'd';
              namespace-uri: 'http://2.example/';
              value: 'value2';
              specified: true;
            }
          }
        }

    @@XMLTest:
      @@@QName: xp.names.normalize.1.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
          <!ATTLIST a
          xmlns NMTOKEN #IMPLIED
          >
          ]>
          <a xmlns="  "/>
      @@@test:domTree:
        document {
          document-type { }
          element {
            namespace-uri: null;
            prefix: null;
            local-name: 'a';
          }
        }
    @@XMLTest:
      @@@QName: xp.names.normalize.2.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a [
          <!ATTLIST a
          xmlns NMTOKEN #IMPLIED
          >
          ]>
          <a xmlns="  about:blank  "/>
      @@@test:domTree:
        document {
          document-type { }
          element {
            namespace-uri: 'about:blank';
            prefix: null;
            local-name: 'a';
          }
        }
    @@XMLTest:
      @@@QName: xp.names.normalize.3.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE a:a [
          <!ATTLIST a:a
          xmlns:a NMTOKEN #IMPLIED
          >
          ]>
          <a:a xmlns:a=" about:blank  "/>
      @@@test:domTree:
        document {
          document-type { }
          element {
            namespace-uri: 'about:blank';
            prefix: 'a';
            local-name: 'a';
          }
        }

    @@XMLTest:
      @@@QName: xp.no.baseuri.test
      @@@DEnt:
        @@@@test:value:
          <p/>
      @@@test:domTree:
        document {
          document-uri: null;
          base-uri: null;
          element {
            node-name: 'p';
            base-uri: null;
          }
        }
    @@XMLTest:
      @@@QName: xp.docuri.no.baseuri.test
      @@@DEnt:
        @@@@test:uri: 
          http://www.example.com/
        @@@@test:value:
          <p/>
      @@@test:domTree:
        document {
          document-uri: 'http://www.example.com/';
          base-uri: 'http://www.example.com/';
          element {
            node-name: 'p';
            base-uri: 'http://www.example.com/';
          }
        }
    @@XMLTest:
      @@@QName: xp.docuri.baseuri.test
      @@@DEnt:
        @@@@test:uri: 
          http://www.example.com/
        @@@@test:baseURI:
          ftp://ftp.example.com/
        @@@@test:value:
          <p/>
      @@@test:domTree:
        document {
          document-uri: 'http://www.example.com/';
          base-uri: 'ftp://ftp.example.com/';
          element {
            node-name: 'p';
            base-uri: 'ftp://ftp.example.com/';
          }
        }
    @@XMLTest:
      @@@QName: xp.doctype.baseuri.test
      @@@DEnt:
        @@@@test:uri: 
          http://www.example.com/
        @@@@test:baseURI:
          ftp://ftp.example.com/
        @@@@test:value:
          <!DOCTYPE p SYSTEM "sys">
          <p/>
      @@@test:domTree:
        document {
          document-uri: 'http://www.example.com/';
          base-uri: 'ftp://ftp.example.com/';
          document-type {
            system-id: 'sys';
            manakai-declaration-base-uri: 'ftp://ftp.example.com/';
          }
          element {
            node-name: 'p';
            base-uri: 'ftp://ftp.example.com/';
          }
        }
    @@XMLTest:
      @@@QName: xp.entdecl.baseuri.test
      @@@DEnt:
        @@@@test:uri: 
          http://www.example.com/
        @@@@test:baseURI:
          ftp://ftp.example.com/
        @@@@test:value:
          <!DOCTYPE p [
            <!ENTITY ent SYSTEM "ent">
          ]>
          <p/>
      @@@test:domTree:
        document {
          document-uri: 'http://www.example.com/';
          base-uri: 'ftp://ftp.example.com/';
          document-type {
            general-entity {
              node-name: 'ent';
              manakai-declaration-base-uri: 'ftp://ftp.example.com/';
            }
          }
          element {
            node-name: 'p';
            base-uri: 'ftp://ftp.example.com/';
          }
        }
    @@XMLTest:
      @@@QName: xp.notdecl.baseuri.test
      @@@DEnt:
        @@@@test:uri: 
          http://www.example.com/
        @@@@test:baseURI:
          ftp://ftp.example.com/
        @@@@test:value:
          <!DOCTYPE p [
            <!NOTATION not SYSTEM "not">
          ]>
          <p/>
      @@@test:domTree:
        document {
          document-uri: 'http://www.example.com/';
          base-uri: 'ftp://ftp.example.com/';
          document-type {
            notation {
              node-name: 'not';
              manakai-declaration-base-uri: 'ftp://ftp.example.com/';
            }
          }
          element {
            node-name: 'p';
            base-uri: 'ftp://ftp.example.com/';
          }
        }
    @@XMLTest:
      @@@QName: xp.doctype.intsubset.pi.baseuri.test
      @@@DEnt:
        @@@@test:uri: 
          http://www.example.com/
        @@@@test:baseURI:
          ftp://ftp.example.com/
        @@@@test:value:
          <!DOCTYPE p [
            <?pi?>
          ]>
          <p/>
      @@@test:domTree:
        document {
          document-uri: 'http://www.example.com/';
          base-uri: 'ftp://ftp.example.com/';
          document-type {
            pi {
              node-name: 'pi';
              base-uri: 'ftp://ftp.example.com/';
            }
          }
          element {
            node-name: 'p';
            base-uri: 'ftp://ftp.example.com/';
          }
        }

    @@XMLTest:
      @@@QName: xp.xmlid.attr.test
      @@@DEnt:
        @@@@test:value:
          <p xml:id="idv"/>
      @@@test:domTree:
        document {
          element {
            attribute {
              node-name: 'xml:id';
              value: 'idv';
              schema-type-info: TypeInfo ('http://www.w3.org/TR/REC-xml',
                                          'ID');
              specified: true;
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.xmlid.attr.norm.test
      @@@DEnt:
        @@@@test:value:
          <p xml:id=" $u000Aidv  "/>
      @@@test:domTree:
        document {
          element {
            attribute {
              node-name: 'xml:id';
              value: 'idv';
              schema-type-info: TypeInfo ('http://www.w3.org/TR/REC-xml',
                                          'ID');
              specified: true;
            }
          }
        }
    @@XMLTest:
      @@@QName: xp.xmlid.attrdef.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p [
            <!ATTLIST p xml:id ID #IMPLIED>
          ]>
          <p/>
      @@@test:domTree:
        document {
          document-type {
            element-type-definition {
              node-name: 'p';
              attribute-definition {
                node-name: 'xml:id';
                declared-type: const (ID_ATTR);
                default-type: const (IMPLIED_DEFAULT);
              }
            }
          }
          element { }
        }
    @@XMLTest:
      @@@QName: xp.xmlid.attrdef.defaultattr.test
      @@@DEnt:
        @@@@test:value:
          <!DOCTYPE p [
            <!ATTLIST p xml:id ID "idv"><!-- invalid -->
          ]>
          <p/>
      @@@test:domTree:
        document {
          document-type {
            element-type-definition {
              node-name: 'p';
              attribute-definition {
                node-name: 'xml:id';
                declared-type: const (ID_ATTR);
                default-type: const (EXPLICIT_DEFAULT);
                node-value: 'idv';
              }
            }
          }
          element {
            attribute {
              node-name: 'xml:id';
              schema-type-info: TypeInfo ('http://www.w3.org/TR/REC-xml',
                                          'ID');
              value: 'idv';
              specified: false;
            }
          }
        }

    @@PerlDef:
      my $impl = $Message::DOM::ImplementationRegistry->get_implementation ({
        'Core' => '3.0',
        'XML' => '3.0',
        'XMLVersion' => ['1.0', '1.1'],
      });
      my $parser = <Class::ManakaiXMLParser>->new ($impl);

      for my $test_data (@$TestData) {
        $test->start_new_test ($test_data->{uri});
        my $doc_ent = $test_data->{entity}->{$test_data->{root_uri}};
        my $not_ok;

        $parser->dom_config->set_parameter ('error-handler' => sub ($$) {
          my (undef, $err) = @_;
	  my $err_type = $err->type;
	  if ($test_data->{dom_error}->{$err_type}) {
            $test->assert_error_equals
                     (actual_value => $err,
                      expected_hash => shift @{$test_data->{dom_error}
                                                         ->{$err_type}});
          } else { # Uncatched error
            warn $err;
            unless ($err->severity == <C::c|DOMError.SEVERITY_WARNING>) {
              $test->failure_comment ('Unexpected error |'.$err->type.'|');
              $not_ok = true;
            }
          }
          return true; # continue as far as possible
        });

        my $input = {string_data => \$doc_ent->{<Q::test:value>},
                     system_id => $doc_ent->{<Q::test:uri>},
                     base_uri => $doc_ent->{<Q::test:baseURI>}};
        if ($test_data->{dom_tree}) { # Successful test
          try {
            my $doc = $parser->parse ($input);
            $test->assert_dom_tree_equals
                     (actual_value => $doc,
                      expected_hash => $test_data->{dom_tree});
            for (values %{$test_data->{dom_error}||{}}) {
              if (@$_) {
                $test->failure_comment
                         (@$_.' |DOMError|s of type |'.
                          $_->[0]->{type}->{value}.'| are not reported');
                $not_ok = true;
              }
            }
            $not_ok ? $test->not_ok : $test->ok;
          } catch Message::Util::IF::DTException with {
            # 
          } catch Message::DOM::IF::LSException with {
            # not_ok
          } otherwise {
            my $err = shift;
            warn $err;
            $test->not_ok;
          };
        } else {
          try {
            my $doc = $parser->parse ($input);
          } catch Message::Util::IF::DTException with {
            #
          } catch Message::DOM::IF::LSException with {
            #
          } otherwise {
            my $err = shift;
            warn $err;
            $test->not_ok;
          };
          for (values %{$test_data->{dom_error}||{}}) {
            if (@$_) {
              $test->failure_comment
                       (@$_.' |DOMError|s of type |'.
                        $_->[0]->{type}->{value}.'| are not reported');
              $not_ok = true;
            }
          }
          $not_ok ? $test->not_ok : $test->ok;
        }
      }

  @ResourceDef:
    @@QName: getEmptyEntityState
    @@rdf:type: DISPerl|InlineCode
    @@ForCheck: ManakaiDOM|ForClass
    @@PerlDef:
      {reptxt => \'', line => 1, column => 1, pos => 0,
       is_externally_declared => true, name => $name,
       fh => do { 
               open my $empty, '<', \'';
               $empty;
             },
       close_file => sub { }}

  @ResourceDef:
    @@QName: getCopyOfEntityState
    @@rdf:type: DISPerl|InlineCode
    @@ForCheck: ManakaiDOM|ForClass
    @@PerlDef:
      {%{$self->{$entity_type}->{$entity_name}},
       line => 1, column => 1, pos => 0,
       fh => do {
               require IO::String;
               IO::String->new
                            (${$self->{$entity_type}->{$entity_name}->{reptxt}});
               ## TODO: External entities.
             },
       close_file => sub { }}
##ManakaiXMLParser

ElementTypeBinding:
  @Name: Test
  @ElementType: 
    dis:ResourceDef
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass
    @@rdf:type: test|StandaloneTest

ElementTypeBinding:
  @Name: XMLTests
  @ElementType: 
    dis:ResourceDef
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass
    @@rdf:type: test|ParserTestSet

ElementTypeBinding:
  @Name: XMLTest
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass
    @@rdf:type: test|ParserTest

ElementTypeBinding:
  @Name: DEnt
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: test|RootEntity

ElementTypeBinding:
  @Name: Ent
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: test|Entity

ResourceDef:
  @QName: xp|get-location-from-token
  @rdf:type: DISPerl|BlockCode
  @enDesc:
    Creates a <IF::DOMCore:DOMLocator> object from a token.
  @PerlDef:
    my $__d = $token->{type} ne '#EOF'
                ? $token->{location}->{char_d}
                : 0;
    $__d -= $token->{location_d} if $token->{location_d};
    $result = {
      utf32_offset => $token->{location}->{pos} - $__d,
      line_number => $token->{location}->{line},
      column_number => $token->{location}->{column} - $__d,
    };
    $result->{utf32_offset} = 0 if $result->{utf32_offset} < 0;
    $result->{column_number} = 0 if $result->{column_number} < 0;
                            ## 0 or 1, which should be?
  @For: ManakaiDOM|ManakaiDOM3

ElementTypeBinding:
  @Name: RuleDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass
    @@rdf:type: Muf2003|RuleDefClass

ElementTypeBinding:
  @Name: RuleParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: Muf2003|RuleParameter

ElementTypeBinding:
  @Name: enImplNote
  @ElementType:
    dis:ImplNote
  @ShadowContent:
    @@lang:en

ElementTypeBinding:
  @Name: WFErrDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DOMCore|DOMErrorType
    @@For: ManakaiDOM|DOM3
    @@ecore:textFormatter: ManakaiXMLParserExceptionFormatter
    @@c:severity: c|SEVERITY_FATAL_ERROR

ElementTypeBinding:
  @Name: FatalErrDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DOMCore|DOMErrorType
    @@For: ManakaiDOM|DOM3
    @@ecore:textFormatter: ManakaiXMLParserExceptionFormatter
    @@c:severity: c|SEVERITY_FATAL_ERROR

ElementTypeBinding:
  @Name: NSFatalErrDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: c|DOMErrorType
    @@For: ManakaiDOM|DOM3
    @@ecore:textFormatter: ManakaiXMLParserExceptionFormatter
    @@c:severity: c|SEVERITY_FATAL_ERROR

ElementTypeBinding:
  @Name: NSCErrDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: c|DOMErrorType
    @@For: ManakaiDOM|DOM3
    @@ecore:textFormatter: ManakaiXMLParserExceptionFormatter
    @@c:severity: c|SEVERITY_FATAL_ERROR

ElementTypeBinding:
  @Name: VCErrDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: c|DOMErrorType
    @@For: ManakaiDOM|DOM3
    @@ecore:textFormatter: ManakaiXMLParserExceptionFormatter
    @@c:severity: c|SEVERITY_ERROR

ElementTypeBinding:
  @Name: ErrDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: c|DOMErrorType
    @@For: ManakaiDOM|DOM3
    @@ecore:textFormatter: ManakaiXMLParserExceptionFormatter
    @@c:severity: c|SEVERITY_ERROR

ElementTypeBinding:
  @Name: WarnDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: c|DOMErrorType
    @@For: ManakaiDOM|DOM3
    @@ecore:textFormatter: ManakaiXMLParserExceptionFormatter
    @@c:severity: c|SEVERITY_WARNING

WFErrDef:
  @QName: xp|wf-syntax-error
  @enDesc:
    The entity does not match to the production rule; it is not
    well-formed.
  @enMufDef:
    |%xp-error-token-type;|%xp-error-token-value
    (prefix => { (|}, suffix => {|)}); is not 
    allowed%xp-error-lines (prefix => { (|}, suffix => {|)});
  @ecore:hasParameter:
    @@@: xp|error-token
    @@enDesc:
      The token that is not allowed.

WFErrDef:
  @QName: xp|wf-pi-target-is-xml
  @enDesc:
    A processing instruction has its <CODE::PITarget> of
    <XML::xml> (in any case) which is not allowed.
  @enMufDef:
    Processing instruction target name cannot be |%p
    (name => {<Q::xp|name>});|
  @ecore:hasParameter:
    @@@: xp|error-token
    @@enDesc:
      The token that contains the name.
  @ecore:hasParameter:
    @@@: xp|name
    @@enDesc:
      A string that is specified as target name of the
      processing instruction.
  @ecore:hasParameter: xp|parent

WFErrDef:
  @QName: xp|wf-no-end-tag
  @enDesc:
    An end-tag is not found.
  @enMufDef:
    End-tag |</%p (name => {<Q::xp|expected-element-type>});>| is required
  @ecore:hasParameter: xp|error-token
  @ecore:hasParameter:
    @@@: xp|node
    @@enDesc:
      The element node that is not closed.
  @ecore:hasParameter:
    @@@: xp|expected-element-type
    @@enDesc:
      The element type name of the element that is not closed.

WFErrDef:
  @QName: xp|wf-unsupported-xml-version
  @enDesc:
    The XML version specified in the version declaration is not supported.
  @enMufDef:
    XML version |%p (name => {<Q::infoset|version>});| is not supported
  @ecore:hasParameter: xp|bad-token
  @ecore:hasParameter:
    @@@: xp|parent
    @@enDesc:
      The document node.
  @ecore:hasParameter:
    @@@: infoset|version
    @@enDesc:
      The specified XML version.

WFErrDef:
  @QName: xp|wf-malformed-enc-name
  @enDesc:
    An <XA::encoding> pseudo-attribute value does not match
    to the procduction rule <CODE::EncName>.
  @enMufDef:
    Encoding name |%p (name => {<Q::xp|name>});| is not allowed
  @ecore:hasParameter: xp|error-token
  @ecore:hasParameter:
    @@@: xp|parent
    @@enDesc: The document node.
  @ecore:hasParameter:
    @@@: xp|name
    @@enDesc:
      The <XA::encoding> value.

WFErrDef:
  @QName: xp|wf-malformed-xml-standalone
  @enDesc:
    An <XA::standalone> pseudo-attribute value is neither <XML::yes>
    or <XML::no>.
  @enMufDef:
    |standalone| pseudo-attribute value |%p (name => {<Q::xp|name>});|
    is not allowed
  @ecore:hasParameter: xp|error-token
  @ecore:hasParameter:
    @@@: xp|parent
    @@enDesc: The document node.
  @ecore:hasParameter:
    @@@: xp|name
    @@enDesc:
      The <XA::standalone> value.

WFErrDef:
  @QName: xp|wf-legal-literal-character
  @enDesc:
    Each character in XML entity must match to the production
    rule <CODE::Char - RestrictedChar>.
  @enMufDef:
    Character %character-code-point 
    (v => {<Q::xp|character-number>}); is not allowed
  @ecore:hasParameter:
    @@@: xp|character-number
    @@enDesc:
      The code position of the character being referred.

WFErrDef:
  @QName: xp|wf-invalid-character-in-node-name
  @c:errorType:
    @@@: wf-invalid-character-in-node-name
    @@ContentType: DISCore|String
  @enDesc:
    If a name contains a character that is not a name character
    in the XML version in use, or if the first character of a name
    is not a name start character in the XML version in use.

      {NOTE::
        When an invalid character is encountered in an entity
        where a <CODE::Name> is expected, what type of error
        is issued is implementation dependent: <Q::xp|wf-syntax-error>,
        <Q::xp|wf-pi-target-is-xml> or other error might be reported.
      }

      {NOTE::
        This error type is defined in DOM Level 3 Core and Load and Save
        modules and redefined herein for the purpose of XML parser.
      }
  @enMufDef:
    Character %character-code-point
    (v => {<Q::xp|character-number>}); is not allowed in name
  @ecore:hasParameter: xp|error-token
  @ecore:hasParameter:
    @@@: xp|character-number
    @@enDesc:
      The code position of the character being referred.
  @ecore:hasParameter:
    @@@: infoset|version
    @@enDesc:
      The version of XML in use.

WFErrDef:
  @QName: xp|wf-pes-in-internal-subset
  @enDesc:
    In the internal subset of the DTD, parameter entity references
    <kwd:MUST-NOT> occur within markup declarations.
  @enMufDef:
    Parameter entity reference |%percent;%param (name => {<Q::xp|name>});;|
    cannot occur within a markup declaration
  @ecore:hasParameter: xp|error-token
  @ecore:hasParameter:
    @@@: xp|name
    @@enDesc:
      The name of the parameter entity.

WFErrDef:
  @QName: xp|wf-element-type-match
  @enDesc:
    The <CODE::Name> in an element's end-tag must match the element type
    in the start-tag.
  @enMufDef:
    End-tag |</%p (name => {<Q::xp|actual-element-type>});>| does
    not match to start-tag |<%p (name => {<Q::xp|expected-element-type>});>|
  @ecore:hasParameter: xp|error-token
  @ecore:hasParameter:
    @@@: xp|node
    @@enDesc:
      The current opening element node.
  @ecore:hasParameter:
    @@@: xp|expected-element-type
    @@enDesc:
      The element type name of the current element.
  @ecore:hasParameter:
    @@@: xp|actual-element-type
    @@enDesc:
      The <CODE::Name> occurs in the end-tag.

WFErrDef:
  @QName: xp|wf-unique-att-spec
  @enDesc:
    An attribute name <kwd:MUST-NOT> appear more than once in
    the same start-tag or empty-element tag.
  @enMufDef:
    Attribute |%p (name => {<Q::xp|name>});| is specified more
    than once in the same tag
  @ecore:hasParameter: xp|error-token
  @ecore:hasParameter:
    @@@: xp|name
    @@enDesc:
      The name of the attribute.

WFErrDef:
  @QName: xp|wf-no-external-entity-references
  @enDesc:
    Attribute values <kwd:MUST-NOT> contain direct or indirect
    entity references to external entities.
  @enMufDef:
    External entity |%p (name => {<Q::xp|name>});| is referenced
    in an attribute value literal
  @ecore:hasParameter: xp|error-token
  @ecore:hasParameter:
    @@@: xp|name
    @@enDesc:
      The name of the entity.

WFErrDef:
  @QName: xp|wf-no-lt-in-attribute-values
  @enDesc:
    The replacement text of any entity referred to directly or indirectly
    in an attribute value literal <kwd:MUST-NOT> contain a
    <CHAR::LESS-THAN SIGN>.
  @enMufDef:
    Entity replacement text cannot contain a
    |LESS-THAN SIGN| since it is referenced from an attribute
    value literal
  @ecore:hasParameter: xp|error-token

WarnDef:
  @QName: xp|warning-attribute-definition-ignored
  @enDesc:
    An attribute definition is ignored because the same attribute
    is declared before.
  @enMufDef:
    Attribute definition for |%p (name => {<Q::xp|name>});| is ignored
  @ecore:hasParameter: xp|error-token
  @ecore:hasParameter:
    @@@: xp|name
    @@enDesc:
      The name of the attribute.

WFErrDef:
  @QName: xp|wf-legal-character
  @enDesc:
    Characters referred to using character references <kwd:MUST>
    match the production for <CODE::Char>.
  @enMufDef:
    Reference to character %character-code-point 
    (v => {<Q::xp|character-number>}); is not allowed
  @ecore:hasParameter: xp|error-token
  @ecore:hasParameter:
    @@@: xp|character-number
    @@enDesc:
      The code position of the character being referred.
  @ecore:hasParameter:
    @@@: xp|parent
    @@enDesc:
      The parent node in which the character reference has
      occurred, if available.

WFErrDef:
  @QName: xp|wf-entity-declared
  @enDesc:
    {P:: In a document

       - without any DTD,

       - with only an internal DTD subset that contains no parameter
         entity references, or

       - with <XML::standalone="yes">,

    for an entity reference that does not occur within the external 
    subset or a parameter entity, the <CODE::Name> given in the
    entity reference <kwd:MUST> match the <CODE::Name> does not
    occur within the external subset or a parameter entity,
    except that five predefined character entities need not 
    be declared.  The declaration of a general entity <kwd:MUST>
    precede any reference to it which appears in a default value
    in an attribute list declaration.
  @enMufDef:
    Entity |%p (name => {<Q::xp|name>});| must be declared
    in the internal subset
  @ecore:hasParameter: xp|error-token
  @ecore:hasParameter:
    @@@: xp|name
    @@enDesc:
      The name of the entity.

WFErrDef:
  @QName: xp|wf-parsed-entity
  @enDesc:
    An entity reference <kwd:MUST-NOT> contain the name of an
    unparsed entity.
  @enMufDef:
    Entity |%p (name => {<Q::xp|name>});| is an unparsed entity
  @ecore:hasParameter: xp|error-token
  @ecore:hasParameter:
    @@@: xp|name
    @@enDesc:
      The name of the entity.

WFErrDef:
  @QName: xp|wf-no-recursion
  @enDesc:
    A parsed entity <kwd:MUST-NOT> contain a recursive reference
    to itself, either directly or indirectly.
  @enMufDef:
    Entity |%p (name => {<Q::xp|name>});| is recursively referenced
  @ecore:hasParameter: xp|error-token
  @ecore:hasParameter:
    @@@: xp|name
    @@enDesc:
      The name of the entity.

FatalErrDef:
  @QName: xp|fatal-xml11-end-of-line-in-xml-declaration
  @enDesc:
    An end-of-line character <CODE::U+0085> or <CODE::U+2028> is appeared
    within an XML declaration or text declaration.
  @enMufDef:
    End-of-line character %character-code-point
    (v => {<Q::xp|character-number>}); cannot be used within the
    XML or text declaration
  @ecore:hasParameter:
    @@@: xp|character-number
    @@enDesc:
      The code position of the end-of-line character.

ErrDef:
  @QName: xp|error-internal-predefined-entity
  @enDesc:
    A general entity declaration whose <CODE::Name> equals to one
    of predefined entities <kwd:MUST> declare it as an internal entity.
  @enMufDef:
    Entity |%p (name => {<Q::xp|name>});| must be declared as an 
    internal entity
  @ecore:hasParameter: xp|error-token
  @ecore:hasParameter:
    @@@: xp|name
    @@enDesc:
      The name of the entity.

ErrDef:
  @QName: xp|error-malformed-predefined-entity
  @enDesc:
    A general entity declaration whose <CODE::Name> equals to one
    of predefined entities <kwd:MUST> declare it as a data
    character for the entity.
  @enMufDef:
    Entity declaration for |%p (name => {<Q::xp|name>});|
    (replacement text |%p (name => {<Q::xp|replacement-text>});|) is malformed
  @ecore:hasParameter: xp|error-token
  @ecore:hasParameter:
    @@@: xp|name
    @@enDesc:
      The name of the entity.
  @ecore:hasParameter:
    @@@: xp|replacement-text
    @@enDesc:
      The replacement text of the entity declaration.

WarnDef:
  @QName: xp|warning-entity-declaration-ignored
  @enDesc:
    An entity declaration is ignored because the same entity
    is declared before.
  @enMufDef:
    Entity declaration for |%p (name => {<Q::xp|name>});| is ignored
  @ecore:hasParameter: xp|error-token
  @ecore:hasParameter:
    @@@: xp|name
    @@enDesc:
      The name of the entity.

VCErrDef:
  @QName: xp|vc-unique-notation-name
  @enDesc:
    A <CODE::Name> <kwd:MUST-NOT> be declared in more than
    one notation declaration.
  @enMufDef:
    Notation |%p (name => {<Q::xp|name>});| is already declared
  @ecore:hasParameter: xp|error-token
  @ecore:hasParameter:
    @@@: xp|name
    @@enDesc:
      The name of the notation.

WarnDef:
  @QName: xp|warning-entity-declaration-not-processed
  @enDesc:
    An entity declaration is not processed because there
    is a reference to parameter entity before the declaration
    and the entity is not read.
  @enMufDef:
    Entity declaration for |%p (name => {<Q::xp|name>});| is not processed
  @ecore:hasParameter: xp|error-token
  @ecore:hasParameter:
    @@@: xp|name
    @@enDesc:
      The name of the entity.

WarnDef:
  @QName: xp|warning-attribute-definition-not-processed
  @enDesc:
    An attribute definition is not processed because there
    is a reference to parameter entity before the declaration
    and the entity is not read.
  @enMufDef:
    Attribute definition for |%p (name => {<Q::xp|name>});| is not processed
  @ecore:hasParameter: xp|error-token
  @ecore:hasParameter:
    @@@: xp|name
    @@enDesc:
      The name of the attribute.

NSFatalErrDef:
  @QName: xp|nswf-legal-ncname
  @enDesc:
    <CODE::Name>s other than element type names and attribute names
    <kwd:MUST> be <CODE::NCName>s.
  @enMufDef:
    <CODE::Name> |%p (name => {<Q::xp|name>});| is not an <CODE::NCName>
  @ecore:hasParameter: xp|error-token
  @ecore:hasParameter:
    @@@: xp|name
    @@enDesc:
      The name.
  @ecore:hasParameter:
    @@@: infoset|version
    @@enDesc:
      The version of XML in use.

NSFatalErrDef:
  @QName: xp|nswf-legal-qname
  @enDesc:
    An element type name or an attribute name <kwd:MUST> be a
    <CODE::QName>.
  @enMufDef:
    <CODE::Name> |%p (name => {<Q::xp|name>});| is not a <CODE::QName>
  @ecore:hasParameter: xp|error-token
  @ecore:hasParameter:
    @@@: xp|name
    @@enDesc:
      The name.
  @ecore:hasParameter:
    @@@: infoset|version
    @@enDesc:
      The version of XML in use.

NSCErrDef:
  @QName: xp|nsc-reserved-prefix-xml
  @enDesc:
    The prefix <XML::xml> <kwd:MUST-NOT> be undeclared or bound
    to any namespace name other than <URI::http://www.w3.org/XML/1998/namespace>.
  @enMufDef:
    Namespace prefix |xml| cannot be bound to namespace
    name |%p (name => {<Q::infoset|namespaceName>});|
  @ecore:hasParameter: xp|error-token
  @ecore:hasParameter:
    @@@: infoset|prefix
    @@enDesc:
      The namespace prefix.
  @ecore:hasParameter:
    @@@: infoset|namespaceName
    @@enDesc:
      The namespace name bound to or an empty string for undeclaring.

NSCErrDef:
  @QName: xp|nsc-reserved-namespace-name-xml
  @enDesc:
    Namespace prefixes other than <XML::xml> <kwd:MUST-NOT> be bound
    to the namespace name <URI::http://www.w3.org/XML/1998/namespace>.
  @enMufDef:
    Namespace prefix |%p (name => {<Q::infoset|prefix>});| cannot be
    bound to namespace name |http://www.w3.org/XML/1998/namespace|
  @enImplNote:
    The XMLNames spec does not prohibit the URI bound to
    the default namespace (!)
  @ecore:hasParameter: xp|error-token
  @ecore:hasParameter:
    @@@: infoset|prefix
    @@enDesc:
      The namespace prefix or <DOM::null> for default namespace.
  @ecore:hasParameter:
    @@@: infoset|namespaceName
    @@enDesc:
      The namespace name bound to.

NSCErrDef:
  @QName: xp|nsc-reserved-prefix-xmlns
  @enDesc:
    The prefix <XML::xmlns> <kwd:MUST-NOT> be declared or undeclared.
  @enMufDef:
    Namespace prefix |xmlns| cannot be declared or undeclared
  @ecore:hasParameter: xp|error-token
  @ecore:hasParameter:
    @@@: infoset|prefix
    @@enDesc:
      The namespace prefix.
  @ecore:hasParameter:
    @@@: infoset|namespaceName
    @@enDesc:
      The namespace name bound to or an empty string for undeclaring.

NSCErrDef:
  @QName: xp|nsc-reserved-namespace-name-xmlns
  @enDesc:
    Namespace prefixes <kwd:MUST-NOT> be bound
    to the namespace name <URI::http://www.w3.org/2000/xmlns/>.
  @enMufDef:
    Namespace prefix |%p (name => {<Q::infoset|prefix>});| cannot be
    bound to namespace name |http://www.w3.org/2000/xmlns/|
  @enImplNote:
    The XMLNames spec does not prohibit the URI bound to
    the default namespace (!)
  @ecore:hasParameter: xp|error-token
  @ecore:hasParameter:
    @@@: infoset|prefix
    @@enDesc:
      The namespace prefix or <DOM::null> for default namespace.
  @ecore:hasParameter:
    @@@: infoset|namespaceName
    @@enDesc:
      The namespace name bound to.

NSCErrDef:
  @QName: xp|nsc-prefix-declared
  @enDesc:
    A namespace prefix other than <XML::xml> or <XML::xmlns>
    <kwd:MUST> have been declared in a namespace declaration
    attribute in either the start or empty element tag of the
    element where the prefix is used or in an ancestor
    element.  Furthermore, the attribute value in the innermost
    such declaration <kwd:MUST-NOT> be an empty string.
  @enMufDef:
    Namespace prefix |%p (name => {<Q::infoset|prefix>});| in
    qualified name |%p (name => {<Q::xp|name>});| is not declared
  @ecore:hasParameter: xp|error-token
  @ecore:hasParameter:
    @@@: infoset|prefix
    @@enDesc:
      The namespace prefix.
  @ecore:hasParameter:
    @@@: xp|name
    @@enDesc:
      The qualified name.

NSFatalErrDef:
  @QName: xp|nswf-empty-namespace-name
  @enDesc:
    If the XML version of the document is 1.0 and the
    normalized value of the prefixed namespace declaration attribute is empty.
  @enMufDef:
    Namespace |%p (name => {<Q::infoset|prefix>});| cannot be
    undeclared in XML 1.0
  @ecore:hasParameter: xp|error-token
  @ecore:hasParameter:
    @@@: infoset|prefix
    @@enDesc:
      The namespace prefix.
  @ecore:hasParameter:
    @@@: infoset|namespaceName
    @@enDesc:
      An empty string.

NSFatalErrDef:
  @QName: xp|nswf-unique-att-spec-expanded-name
  @enDesc:
    No element may have two attributes that have qualified name
    with the same local part and with namespace prefixes
    that have been bound to namespace names that are identical.
  @enMufDef:
    Attribute |%p (name => {<Q::infoset|localName>});| in
    namespace |%p (name => {<Q::infoset|namespaceName>});| is
    attached to the same element more than once (as
    |%p (name => {<Q::xp|name>});| and
    |%p (name => {<Q::xp|another-attribute-name>});|)
  @enImplNote:
    The XMLNames spec doesn't mention default attributes
    for this constraint...
  @ecore:hasParameter: xp|error-token
  @ecore:hasParameter:
    @@@: infoset|localName
    @@enDesc:
      The local part of the attribute.
  @ecore:hasParameter:
    @@@: infoset|namespaceName
    @@enDesc:
      The namespace URI of the attribute.
  @ecore:hasParameter:
    @@@: xp|name
    @@enDesc:
      The name, i.e. a qualified name consist of <Q::infoset:localName>
      and <Q::infoset:namespaceName> parameter values.
  @ecore:hasParameter:
    @@@: xp|another-attribute-name
    @@enDesc:
      Another attribute qualified name expanded to the same expanded name
      as <Q::xp|name>.

XWParam:
  @QName: xp|another-attribute-name

XWParam:
  @QName: xp|replacement-text
  @enDesc:
    The replacement text.

XWParam:
  @QName: xp|error-token
  @enDesc:
    The token where the parser found an error.

XWParam:
  @QName: xp|name
  @enDesc:
    A name.

XWParam:
  @QName: xp|parent
  @enDesc:
    The parent node in which the error occurs.

XWParam:
  @QName: xp|node
  @enDesc:
    The current node.

XWParam:
  @QName: xp|actual-element-type
  @enDesc:
    The actual element type name occured in the source.

XWParam:
  @QName: xp|expected-element-type
  @enDesc:
    The element type name expected.

XWParam:
  @QName: xp|character-number
  @enDesc:
    The character code position.

ElementTypeBinding:
  @Name: XWParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@For: =ManakaiDOM|all
    @@rdf:type: ecore|Parameter

ElementTypeBinding:
  @Name:enMufDef
  @ElementType:
    ecore:defaultMessage
  @ShadowContent:
    @@lang:en
    @@ContentType:
      lang:muf

ResourceDef:
  @QName: DOMImpl
  @AliasFor: DOMCore|DOMImplementation
  @For: ManakaiDOM|DOM

ResourceDef:
  @QName: LSInput
  @AliasFor: DOMLS|LSInput
  @For: ManakaiDOM|DOM

ResourceDef:
  @QName: LSParser
  @AliasFor: DOMLS|LSParser
  @For: ManakaiDOM|DOM

ElementTypeBinding:
  @Name: Attr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Attribute
    @@ForCheck: !=ManakaiDOM|ManakaiDOM

ElementTypeBinding:
  @Name: Get
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|AttributeGet

ElementTypeBinding:
  @Name: Set
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|AttributeSet

ElementTypeBinding:
  @Name: enDesc
  @ElementType: 
    dis:Description
  @ShadowContent: 
    @@lang:en

ElementTypeBinding:
  @Name: Method
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Method
    @@For: !=ManakaiDOM|ManakaiDOM

ElementTypeBinding:
  @Name: Return
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|MethodReturn

ElementTypeBinding:
  @Name: Param
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|MethodParameter

ElementTypeBinding:
  @Name: PerlDef
  @ElementType:
    dis:Def
  @ShadowContent:
    @@ContentType: lang|Perl

ElementTypeBinding:
  @Name: PerlDefC
  @ElementType:
    dis:Def
  @ShadowContent:
    @@ContentType: lang|Perl

ElementTypeBinding:
  @Name: PropDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: rdf|Property

ClsDef:
  @ClsQName: ManakaiXMLParserExceptionFormatter

  @ClsISA: ecore|MUErrorFormatter||ManakaiDOM|Perl

  @RuleDef:
    @@Name: xp-error-token-type
    @@enDesc:
      The type of the token the parser is encountered.

    @@Method:
      @@@Name: after
      @@@Param:
        @@@@Name: name
        @@@@Type: DOMString
        @@@@enDesc: The name of the method.
      @@@Param:
        @@@@Name: p
        @@@@Type: DISPerl|HASH
        @@@@enDesc: The set of the parameters to the method.
      @@@Param:
        @@@@Name: o
        @@@@Type: DISPerl|HASH
        @@@@enDesc: The option value.
      @@@Return:
        @@@@PerlDef:
          $p->{-result} = $o->{<H::xp|error-token>}->{type}
            if defined $o->{<H::xp|error-token>}->{type};

  @RuleDef:
    @@Name: xp-error-token-value
    @@enDesc:
      The value of the token the parser is encountered, if any.

    @@Method:
      @@@Name: after
      @@@Param:
        @@@@Name: name
        @@@@Type: DOMString
        @@@@enDesc: The name of the method.
      @@@Param:
        @@@@Name: p
        @@@@Type: DISPerl|HASH
        @@@@enDesc: The set of the parameters to the method.
      @@@Param:
        @@@@Name: o
        @@@@Type: DISPerl|HASH
        @@@@enDesc: The option value.
      @@@Return:
        @@@@PerlDef:
          $p->{-result} = $o->{<H::xp|error-token>}->{value}
            if defined $o->{<H::xp|error-token>}->{value};

  @RuleDef:
    @@Name: xp-error-lines
    @@enDesc:
      A copy of fragment of the source text that contains the line
      where the error occurred, if available.
    
    @@Method:
      @@@Name: after
      @@@Param:
        @@@@Name: name
        @@@@Type: DOMString
        @@@@enDesc: The name of the method.
      @@@Param:
        @@@@Name: p
        @@@@Type: DISPerl|HASH
        @@@@enDesc: The set of the parameters to the method.
      @@@Param:
        @@@@Name: o
        @@@@Type: DISPerl|HASH
        @@@@enDesc: The option value.
      @@@Return:
        @@@@PerlDef:
          my $pos = $o-><AG::DOMCore|DOMError.location>
                      -><AG::DOMCore|DOMLocator.utf32Offset>;
          my $src = $o->{<H::ecore|object>}->{entity}->[-1]->{reptxt};
          if (defined $src and $pos > -1) {
            my $start = $pos;
            $start = rindex ($$src, "\x0A", $start - 1) for 0..2;
            $start++;
            my $end = $pos;
            $end = index ($$src, "\x0A", $end + 1) for 0..2;
            $end = length $$src if $end < 0;
            $p->{-result} = substr $$src, $start, $end - $start;
          }

  @RuleDef:
    @@Name: character-code-point
    @@enDesc:
      The character code position, in <CODE::U+<VAR::HHHH>> notation.
    
    @@Method:
      @@@Name: after
      @@@Param:
        @@@@Name: name
        @@@@Type: DOMString
        @@@@enDesc: The name of the method.
      @@@Param:
        @@@@Name: p
        @@@@Type: DISPerl|HASH
        @@@@enDesc: The set of the parameters to the method.
      @@@Param:
        @@@@Name: o
        @@@@Type: DISPerl|HASH
        @@@@enDesc: The option value.
      @@@RuleParam:
        @@@@Name: v
        @@@@Type: DISPerl|Number
        @@@@enDesc:
          The name of the error parameter that contains the character code.
      @@@Return:
        @@@@PerlDef:
          $p->{-result} = sprintf 'U+%04X', $o->{$p->{v}};
##XMLParserExceptionFormatter

ElementTypeBinding:
  @Name: CParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      @@@@: c|DOMConfigurationParameter
      @@@For: ManakaiDOM|DOM
    @@rdf:type:
      @@@@: DISCore|Property
      @@@For: =ManakaiDOM|all
    @@For: ManakaiDOM|DOM3
    @@For: =ManakaiDOM|all

ElementTypeBinding:
  @Name: CParamApp
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      @@@@: c|DOMConfigurationParameterApplication
      @@@For: ManakaiDOM|DOM
    @@For: ManakaiDOM|DOM3

CParamApp:
  @QName: xml-id
  @c:domConfigurationParameter: cfg|xml-id
  @c:targetType: xp|ManakaiXMLParser

CParamApp:
  @QName: error-handler
  @c:domConfigurationParameter: c|error-handler
  @c:targetType: xp|ManakaiXMLParser

CParam:
  @QName: xp|ls-input-to-input-file
  @DOMLS:lsKey:
    @@@: i2i
    @@For: =ManakaiDOM|all
  @Type: ManakaiDOMLSInputToInputFile
  @c:targetType: xp|ManakaiXMLParser
  @IsSupportRequired: 1
  @c:isSupported: 1
  @enDesc:
    An <IF::LSInput> to Perl filehandle converter.

  @Method:
    @@rdf:type: c|DOMConfigurationParameterDefaultGetter
    @@Param:
      @@@Name: name
      @@@Type: DOMString
      @@@dis:actualType: c|DOMConfigurationParameterName
      @@@enDesc: The parameter name.
    @@Return:
      @@@Type: ManakaiDOMLSInputToInputFile
      @@@enDesc:
        The default resolver.
      @@@PerlDefC:
        $r = sub {
          my ($self, $input, $errorHandler) = @_;
          ## As defined in DOM Level 3 LS |LSInput| interface

          my $r = {};

          __DEEP{

            FH: {
              ## 1. |characterStream|
              my $v = $input-><AG::LSInput.characterStream>;
              if (defined $v) {
                $r->{filehandle} = $v;
                last FH;
              }

              ## 2. |byteStream|
              $v = $input-><AG::LSInput.byteStream>;
              if (defined $v) {
                ## TODO: Support byte filehandle
                  ## |encoding|
                  ## TODO: How to guess?
                return null;
              }

              ## 3. |stringData|
              $v = $input-><AG::LSInput.stringData>;
              if (defined $v) {
                require IO::String;
                $r->{filehandle} = IO::String->new ($v);
                last FH;
              }

              ## 4. |systemId|
                ## TODO:
                  ## resolve relative URI
                  ## open
                  ## set document_uri
              
              ## 5. |publicId|
              ##   The default resolver does not support only-|publicId| input.

              return null;
            } # FH

            DURI: {
              last DURI if defined $r->{document_uri};
              
              my $v = $input-><AG::LSInput.systemId>;
              if (defined $v) {
                $r->{base_uri} = $input-><AG::LSInput.baseURI>
                  unless defined $r->{base_uri};
                if (defined $r->{base_uri}) {
                  $r->{document_uri}
                    = <ClassM::urigen|ManakaiURIReference.new> (\$v)
                        -><M::urigen|URIReference.getAbsoluteReference>
                            ($r->{base_uri})
                        -><AG::urigen|URIReference.uriReference>;
                } else {
                  $r->{document_uri} = $v;
                }
                last DURI;
              }

              ## TODO: pubid -> pubid URN -> document_uri
            } # DURI

            BURI: {
              last BURI if defined $r->{base_uri};

              my $v = $input-><AG::LSInput.baseURI>;
              if (defined $v) {
                $r->{base_uri} = $v;
                last BURI;
              }

              if (defined $r->{document_uri}) {
                $r->{base_uri} = $r->{document_uri};
              }
            } # BURI

          }__;

          ## ISSUE: Is |certifiedText| required by parsers?

          return $r;
        };
  @Method:
    @@rdf:type: c|DOMConfigurationParameterSetter
    @@Param:
      @@@Name: name
      @@@Type: DOMString
      @@@dis:actualType: c|DOMConfigurationParameterName
      @@@enDesc: The parameter name.
    @@Param:
      @@@Name: value
      @@@Type: DOMMain|DOMUserData
      @@@dis:actualType: ManakaiDOMLSInputToInputFile
      @@@enDesc: The new value.
    @@Return:
      @@@Type: idl|void||ManakaiDOM|all
      @@@PerlDefC:
        $self->[1]->{<H::xp|ls-input-to-input-file>} = $value;
    @@enImplNote:
      Implied input processor converts non-blessed code references
      into a <Class::ManakaiDOMLSInputToInputFile> object.
  @Method:
    @@rdf:type: c|DOMConfigurationParameterChecker
    @@Param:
      @@@Name: name
      @@@Type: DOMString
      @@@dis:actualType: c|DOMConfigurationParameterName
      @@@enDesc: The parameter name.
    @@Param:
      @@@Name: value
      @@@Type: DOMMain|DOMUserData
      #@@@dis:actualType: ManakaiDOMLSInputToInputFile
      @@@enDesc: The new value.
    @@Return:
      @@@Type: idl|boolean||ManakaiDOM|all
      @@@PerlDefC:
        $r = UNIVERSAL::isa ($value, 'CODE') or
             UNIVERSAL::isa ($value, <ClassName::ManakaiDOMLSInputToInputFile>);

    @@Test:
      @@@QName: cp.ls-input-to-input-file.test
      @@@PerlDefC:
        my $xp;
        __CODE{createParserForTest:: $xp => $xp}__;
        my $cfg = $xp-><AG::LSInput.domConfig>;

        my $cp = <Q::xp|ls-input-to-input-file>;
        
        $test->id ('default');
        my $default = $cfg-><M::c|DOMConfiguration.getParameter> ($cp);
        $test->assert_isa ($default,
                           <ClassName::ManakaiDOMLSInputToInputFile>);

        $test->id ('set');
        my $sub1 = sub { };
        $cfg-><M::c|DOMConfiguration.setParameter> ($cp => $sub1);
        my $sub2 = $cfg-><M::c|DOMConfiguration.getParameter> ($cp);
        $test->assert_isa ($sub2, <ClassName::ManakaiDOMLSInputToInputFile>);
        $test->assert_equals ($sub2, $sub1);

        $test->id ('reset');
        $cfg-><M::c|DOMConfiguration.setParameter> ($cp => null);
        my $sub3 = $cfg-><M::c|DOMConfiguration.getParameter> ($cp);
        $test->assert_isa ($sub3, <ClassName::ManakaiDOMLSInputToInputFile>);
        $test->assert_equals ($sub3, $default);

    @@Test:
      @@@QName: cp.ls-input-to-input-file.default.test
      @@@PerlDefC:
        my $xp;
        __CODE{createParserForTest:: $xp => $xp}__;
        my $cfg = $xp-><AG::LSInput.domConfig>;
        my $cp = <Q::xp|ls-input-to-input-file>;
        my $default = $cfg-><M::c|DOMConfiguration.getParameter> ($cp);

        my $err = sub {}; # dummy error handler

        my $cs = \*STDOUT; # dummy input
 
        $test->id ('cs.sysid');
        my $r1 = $default->resolve_ls_input ({
                   character_stream => $cs,
                   system_id => q<http://example.com/sysid>,
                 }, $err);
        $test->assert_equals
                 ($r1->document_uri, q<http://example.com/sysid>);
        $test->assert_equals
                 ($r1->base_uri, q<http://example.com/sysid>);
 
        $test->id ('cs.baseuri.sysid');
        my $r1 = $default->resolve_ls_input ({
                   character_stream => $cs,
                   system_id => q<sysid>,
                   base_uri => q<http://example.com/>,
                 }, $err);
        $test->assert_equals
                 ($r1->document_uri, q<http://example.com/sysid>);
        $test->assert_equals
                 ($r1->base_uri, q<http://example.com/>);
##ls-input-to-input-file

ClsDef:
  @ClsQName: ManakaiDOMLSInputToInputFile
  @enDesc:
    An <Class::ManakaiDOMLSInputToInputFile> object is used to covert 
    a <IF::LSInput> object into a Perl filehandle.

    {ISSUE::
      In which module this class should be placed?

      Better interface name?
    }

  @enDesc:
    @@ddid: perl
    @@ForCheck: ManakaiDOM|ManakaiDOM
    @@@:
      For Perl binding, any parameter that accepts
      a <Class::ManakaiDOMLSInputToInputFile> would also accept a Perl code
      reference (subroutine reference).  The code reference
      will be blessed as a <Class::ManakaiDOMLSInputToInputFile> whose
      <M::ManakaiDOMLSInputToInputFile.resolveLSInput> method invokes the code.

  @ResourceDef:
    @@rdf:type: DISLang|InputProcessor
    @@rdf:type: DISLang|OutputProcessor
    @@PerlDef:
      $INPUT = bless $INPUT, <ClassName::ManakaiDOMLSInputToInputFile>
        if ref $INPUT eq 'CODE';

  @Method:
    @@Name: resolveLSInput
    @@enDesc:
      Converts a <IF::LSInput> into a Perl filehandle.
    @@Param:
      @@@Name: input
      @@@Type: LSInput
      @@@enDesc:
        The input.
    @@Param:
      @@@Name: errorHandler
      @@@Type: c|DOMErrorHandler
      @@@enDesc:
        An error handler.  If the method encounters an error
        or warning, it <kwd:MAY> notify it to application
        via this handler.
    @@Return:
      @@@Type: ManakaiDOMInputFile
      @@@enDesc:
        A <Class::ManakaiDOMInputFile> object created from <P::input>.
      @@@nullCase:
        @@@@enDesc:
          If the method was unable to resolve the <P::input>.

          {ISSUE::
            Should we allow the method to throw exceptions?
          }
      @@@PerlDef:
        __DEEP{
          $r = $self->($self, $input, $errorHandler);
        }__;
      @@@enImplNote:
        Notet that the input / output processor for <CODE::$input>
        and return value might or might not be inserted in
        the <Perl::$self> code.
##LSInputToInputFile

ClsDef:
  @ClsQName: ManakaiDOMInputFile
  @enDesc:
    A set of information on the input, including filehandle.

  @enDesc:
    @@ddid: perl
    @@ForCheck: ManakaiDOM|ManakaiDOM
    @@@:
      For Perl binding, any parameter that accepts
      a <Class::ManakaiDOMInputFile> would also accept a Perl hash reference.
      If a hash reference is given to parameter that expects 
      a <Class::ManakaiDOMInputFile> object, then it 
      bless the hash with the class.

      Each attributes defined
      in the class is associated to the hash value with the
      key equals to the attribut name.  Each method defined in
      the class will invoke the code reference retrieved 
      from the hash by the key equals to the method name.

      If there is no value in the hash for an attribute,
      then its value is <DOM::null>.

  @ResourceDef:
    @@rdf:type: DISLang|InputProcessor
    @@rdf:type: DISLang|OutputProcessor
    @@PerlDef:
      $INPUT = bless $INPUT, <ClassName::ManakaiDOMInputFile>
        if ref $INPUT eq 'HASH';

  @Attr:
    @@Name: filehandle
    @@Type: DISPerl|filehandle||ManakaiDOM|all
    @@enDesc:
      The input filehandle.

      It <kwd:MUST> be an <Perl::open>ed (and not <Perl::close>d)
      filehandle.  Note that
      it does not have to be associated with an actual file
      in the local file system.

      It <kwd:MUST> return a character (rather than byte) 
      by <Perl::getc>.
    @@Get:
      @@@PerlDef: $r = $self->{filehandle};
    @@Set:
      @@@PerlDef: $self->{filehandle} = $given;

  @Attr:
    @@Name: baseURI
    @@enDesc:
      The base URI of the input.

      It <kwd:MUST> be an absolute DOM URI or <DOM::null>.
      Otherwise, the result is undefined.
    @@Type: DOMString
    @@nullCase:
      @@@enDesc:
        If the base URI is not available.
    @@Get:
      @@@PerlDef: $r = $self->{base_uri};
    @@Set:
      @@@PerlDef: $self->{base_uri} = $given;

  @Attr:
    @@Name: documentURI
    @@enDesc:
      The URI of the document.

      It <kwd:MUST> be an absolute DOM URI or <DOM::null>.
      Otherwise, the result is undefined.
    @@Type: DOMString
    @@nullCase:
      @@@enDesc:
        If the document URI is not available.
    @@Get:
      @@@PerlDef: $r = $self->{document_uri};
    @@Set:
      @@@PerlDef: $self->{document_uri} = $given;

  @Method:
    @@Name: close
    @@enDesc:
      Closes the file.

      Since when the Perl's destructor is invoked is unreliable,
      this method is explicitly called when the file is no longer
      in use.

      If the <Class::ManakaiDOMInputFile> is given as a hash
      reference and whose value for <CODE::close> is not defined,
      then the statement <Perl::close $filehandle> is done
      (where <Perl::$filehandle> is the <A::ManakaiDOMInputFile.filehandle>
      value).
    @@Return:
      @@@PerlDef:
        __DEEP{
          if ($self->{close}) {
            $self->{close}->($self);
          } else {
            close $self->{filehandle};
          }
        }__;
##ManakaiDOMInputFile



