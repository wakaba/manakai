Module:
  @QName: MDOM|TreeCore
  @enFN:
    DOM Tree Core Module
  @enDesc:
    The manakai DOM Tree Core Module implements a part of the W3C DOM
    Core module related to tree structural model for HTML or XML documents.

  @Namespace:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/DOM/TreeCore/

  @DISCore:author: DISCore|Wakaba
  @License: license|Perl+MPL
  @Date:
    $Date: 2006/03/25 12:24:49 $

  @Require:
    @@Module:
      @@@QName: Util|Grove
      @@@WithFor: ManakaiDOM|all
    @@Module:
      @@@QName: MDOM|DOMCore
      @@@WithFor: ManakaiDOM|ManakaiDOMLatest
    @@Module:
      @@@QName: MDOM|XML
      @@@WithFor: ManakaiDOM|ManakaiDOMLatest
    @@Module:
      @@@QName: MDOM|XDoctype
      @@@WithFor: ManakaiDOM|ManakaiDOMLatest
    @@Module:
      @@@QName: MURI|Generic
      @@@WithFor: ManakaiDOM|ManakaiDOMLatest
    @@Module:
      @@@WithFor: ManakaiDOM|ManakaiDOM
    @@Module:
      @@@WithFor: ManakaiDOM|ManakaiDOM1
    @@Module:
      @@@WithFor: ManakaiDOM|ManakaiDOM2
    @@Module:
      @@@WithFor: ManakaiDOM|ManakaiDOM3
  @DefaultFor: ManakaiDOM|ManakaiDOMLatest

Namespace:
  @c:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#
  @cfg:
    http://suika.fam.cx/www/2006/dom-config/
  @dis:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#dis--
  @doc:
    http://suika.fam.cx/~wakaba/archive/2005/7/tutorial#
  @d:
    http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#
  @DOMMain:
    http://suika.fam.cx/~wakaba/archive/2004/dom/main#
  @dx:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#
  @dxm:
    http://suika.fam.cx/~wakaba/archive/2004/dis/XML#
  @ecore:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/Core/
  @ev:
    http://www.w3.org/2001/xml-events
  @f:
    http://suika.fam.cx/~wakaba/archive/2004/dom/feature#
  @fe:
    http://suika.fam.cx/www/2006/feature/
  @html5:
    http://www.w3.org/1999/xhtml
  @idl:
    http://suika.fam.cx/~wakaba/archive/2004/dis/IDL#
  @infoset:
    http://www.w3.org/2001/04/infoset#
  @kwd:
    http://suika.fam.cx/~wakaba/archive/2005/rfc2119/
  @lang:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#
  @license:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/license#
  @ManakaiDOM:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#
  @ManakaiDOMCore:
    http://suika.fam.cx/~wakaba/archive/2004/mdom-core#
  @MDOM:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#ManakaiDOM.
  @MDOMX:
    http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#
  @mg:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Grove/
  @mn:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/ManakaiNode#
  @MURI:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/URI/
  @null:
    http://suika.fam.cx/~wakaba/-temp/2003/09/27/null
  @rdf:
    http://www.w3.org/1999/02/22-rdf-syntax-ns#
  @rdfs:
    http://www.w3.org/2000/01/rdf-schema#
  @sw010:
    urn:x-suika-fam-cx:markup:suikawiki:0:10:
  @t:
    http://suika.fam.cx/~wakaba/archive/2004/dom/tree#
  @tc:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/DOM/TreeCore/
  @test:
    http://suika.fam.cx/~wakaba/archive/2004/dis/Test#
  @tx:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/DOM/XML/
  @urigen:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/URI/Generic/
  @Util:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/
  @x:
    http://suika.fam.cx/~wakaba/archive/2004/dom/xml#
  @xhtml1:
    http://www.w3.org/1999/xhtml
  @xml:
    http://www.w3.org/XML/1998/namespace
  @xml-dtd:
    http://www.w3.org/TR/REC-xml
  @xmlns:
    http://www.w3.org/2000/xmlns/

ElementTypeBinding:
  @Name: ClsDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType:
      @@@@: dis|MultipleResource
      @@@ForCheck: !ManakaiDOM|ForIF !ManakaiDOM|ForClass
    @@resourceFor:
      @@@@: ManakaiDOM|ForClass
    @@For: ManakaiDOM|ManakaiDOMLatest

    @@DISCore:resourceType:
      @@@@: DISLang|Class
      @@@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: CODE
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISPerl|BlockCode
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: Method
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Method
    @@ForCheck: !=ManakaiDOM|ManakaiDOM

ElementTypeBinding:
  @Name: L13Method
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Method
    @@ForCheck: !=ManakaiDOM|ManakaiDOM
  ## Modified in DOM Level 3

ElementTypeBinding:
  @Name: CMethod
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Method
    @@ForCheck: !=ManakaiDOM|ManakaiDOM ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: L2Method
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Method
    @@ForCheck: !=ManakaiDOM|ManakaiDOM ManakaiDOM|DOM2

ElementTypeBinding:
  @Name: L3Method
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Method
    @@ForCheck: !=ManakaiDOM|ManakaiDOM ManakaiDOM|DOM3

ElementTypeBinding:
  @Name: CL3Method
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Method
    @@ForCheck: !=ManakaiDOM|ManakaiDOM ManakaiDOM|DOM3 ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: LXMethod
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Method
    @@ForCheck: !=ManakaiDOM|ManakaiDOM ManakaiDOM|ManakaiDOMLatest

ElementTypeBinding:
  @Name: IntMethod
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Method
    @@ForCheck:
      ManakaiDOM:ManakaiDOM !=ManakaiDOM:ManakaiDOM ManakaiDOM|ForClass
    @@ManakaiDOM:isForInternal: 1

ElementTypeBinding:
  @Name: Param
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|MethodParameter

ElementTypeBinding:
  @Name: Return
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|MethodReturn

ElementTypeBinding:
  @Name: Attr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Attribute
    @@ForCheck: !=ManakaiDOM|ManakaiDOM

ElementTypeBinding:
  @Name: CAttr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|Attribute
    @@ForCheck: !=ManakaiDOM|ManakaiDOM ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: IntAttr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Attribute
    @@ForCheck: ManakaiDOM|ForClass
    @@ManakaiDOM:isForInternal: 1

ElementTypeBinding:
  @Name: L2Attr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Attribute
    @@ForCheck: !=ManakaiDOM|ManakaiDOM ManakaiDOM|DOM2

ElementTypeBinding:
  @Name: L12Attr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Attribute
    @@ForCheck: !=ManakaiDOM|ManakaiDOM ManakaiDOM|DOM1
  # Modified in DOM Level 2

ElementTypeBinding:
  @Name: L13Attr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Attribute
    @@ForCheck: !=ManakaiDOM|ManakaiDOM ManakaiDOM|DOM1
  # Modified in DOM Level 3

ElementTypeBinding:
  @Name: CL2Attr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Attribute
    @@ForCheck: !=ManakaiDOM|ManakaiDOM ManakaiDOM|DOM2 ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: L3Attr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Attribute
    @@ForCheck: !=ManakaiDOM|ManakaiDOM ManakaiDOM|DOM3
  ## Note that there are attributes introduced in DOM Level 3
  ## but also defined for lower levels as internal attributes
  ## for the purpose of internal use.

ElementTypeBinding:
  @Name: CL3Attr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Attribute
    @@ForCheck: !=ManakaiDOM|ManakaiDOM ManakaiDOM|DOM3 ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: LXAttr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Attribute
    @@ForCheck: !=ManakaiDOM|ManakaiDOM ManakaiDOM|ManakaiDOMLatest

ElementTypeBinding:
  @Name: Get
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|AttributeGet

ElementTypeBinding:
  @Name: Set
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|AttributeSet

ElementTypeBinding:
  @Name: LXSet
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|AttributeSet
    @@ForCheck: ManakaiDOM|ManakaiDOMLatest

ElementTypeBinding:
  @Name: InCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:InCase

ElementTypeBinding:
  @Name: nullCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:InCase
    @@Value:
      @@@is-null:1

ElementTypeBinding:
  @Name: ConstGroup
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|ConstGroup
    @@ForCheck: ManakaiDOM|ForIF !=ManakaiDOM|ManakaiDOM

ElementTypeBinding:
  @Name: Constants
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|ConstGroup
    @@ForCheck: ManakaiDOM|ForIF !=ManakaiDOM|ManakaiDOM
    @@Type: unsignedShort
    @@subsetOf: unsignedShort

ElementTypeBinding:
  @Name: L3Bitmasks
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|ConstGroup
    @@ForCheck: ManakaiDOM|ForIF !=ManakaiDOM|ManakaiDOM
    @@Type: unsignedShort
    @@subsetOf: unsignedShort

ElementTypeBinding:
  @Name: Const
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|Const

ElementTypeBinding:
  @Name: mConst
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|Const
    @@Description:
      @@@lang:en
      @@@ddid:manakai
      @@@@:
        {NOTE::
          This is a manakai extension.
        }

ElementTypeBinding:
  @Name: PerlDef
  @ElementType:
    dis:Def
  @ShadowContent:
    @@ContentType:
      lang:Perl
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: PerlDefC
  @ElementType:
    dis:Def
  @ShadowContent:
    @@ContentType:
      lang:Perl

ElementTypeBinding:
  @Name: XML2Feature
  @ElementType:
    dis:ImplNote
  @ShadowContent:
    @@ImplNote:
      @@@lang:en
      @@@@:
        The <CITE::DOM Level 2 Core> specification said that HTML-only 
        DOM Level 2 implementations does not need to implement this member. 
        The DOM Level 2 Errata withdraws it and it requires HTML-only 
        DOM implementations throw a <X::DOMException.NOT_SUPPORTED_ERR>. 

ElementTypeBinding:
  @Name: enImplNote
  @ElementType:
    dis:ImplNote
  @ShadowContent:
    @@lang:en

ElementTypeBinding:
  @Name: enFN
  @ElementType:
    dis:FullName
  @ShadowContent:
    @@lang:en

ElementTypeBinding:
  @Name: NodeTypeDef
  @ElementType: 
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      @@@@: dis|MultipleResource
      @@@ForCheck: !ManakaiDOM|ForIF !ManakaiDOM|ForClass
    @@resourceFor: ManakaiDOM|ForIF
    @@resourceFor:
      @@@@: ManakaiDOM|ForClass
      @@@ForCheck: ManakaiDOM|ManakaiDOMLatest
    @@For: ManakaiDOM|DOM1
    @@For: =ManakaiDOM|ManakaiDOM

    @@rdf:type:
      @@@@: DISLang|Interface
      @@@ForCheck: ManakaiDOM|ForIF

    @@rdf:type:
      @@@@: DISLang|Class
      @@@ForCheck: ManakaiDOM|ForClass

    @@ISA:
      @@@@: Node
      @@@ForCheck: ManakaiDOM|ForIF
    @@ISA:
      @@@@: ManakaiDOMNode
      @@@ForCheck: ManakaiDOM|ForClass

    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOM||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOM1||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM1
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOM2||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM2
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOM3||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM3
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOMLatest||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOMLatest

    @@f:implements:
      @@@@: DOMCore|CoreFeature10
      @@@For: ManakaiDOM|DOM1
    @@DOMMain:implementFeature:
      @@@@: DOMCore|CoreFeature20
      @@@For: ManakaiDOM|DOM2
    @@DOMMain:implementFeature:
      @@@@: DOMCore|CoreFeature30
      @@@For: ManakaiDOM|DOM3
    @@DOMMain:implementFeature:
      @@@@: DOMXML|XMLFeature10
      @@@For: ManakaiDOM|DOM1 ManakaiDOM|DOMXMLFeature
    @@DOMMain:implementFeature:
      @@@@: DOMXML|XMLFeature20
      @@@For: ManakaiDOM|DOM2 ManakaiDOM|DOMXMLFeature
    @@DOMMain:implementFeature:
      @@@@: DOMXML|XMLFeature30
      @@@For: ManakaiDOM|DOM3 ManakaiDOM|DOMXMLFeature
    @@DOMMain:implementFeature:
      @@@@: DOMXML|XMLVersionFeature10
      @@@For: ManakaiDOM|DOM3 ManakaiDOM|DOMXMLFeature
    @@DOMMain:implementFeature:
      @@@@: DOMXML|XMLVersionFeature11
      @@@For: ManakaiDOM|DOM3 ManakaiDOM|DOMXMLFeatureXML11

ElementTypeBinding:
  @Name: IFCls1Def
  @ElementType: 
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      @@@@: dis|MultipleResource
      @@@ForCheck: !ManakaiDOM|ForIF !ManakaiDOM|ForClass
    @@resourceFor: ManakaiDOM|ForIF
    @@resourceFor:
      @@@@: ManakaiDOM|ForClass
      @@@ForCheck: ManakaiDOM|ManakaiDOMLatest
    @@For: ManakaiDOM|DOM1
    @@For: =ManakaiDOM|ManakaiDOM

    @@rdf:type:
      @@@@: DISLang|Interface
      @@@ForCheck: ManakaiDOM|ForIF

    @@rdf:type:
      @@@@: DISLang|Class
      @@@ForCheck: ManakaiDOM|ForClass
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOM||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOM1||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM1
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOM2||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM2
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOM3||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM3
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOMLatest||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOMLatest

    @@f:implements:
      @@@@: c|CoreFeature10
      @@@For: ManakaiDOM|DOM1
    @@f:implements:
      @@@@: c|CoreFeature20
      @@@For: ManakaiDOM|DOM2
    @@f:implements:
      @@@@: c|CoreFeature30
      @@@For: ManakaiDOM|DOM3
    @@f:implements:
      @@@@: DOMXML|XMLFeature10
      @@@For: ManakaiDOM|DOM1 ManakaiDOM|DOMXMLFeature
    @@f:implements:
      @@@@: DOMXML|XMLFeature20
      @@@For: ManakaiDOM|DOM2 ManakaiDOM|DOMXMLFeature
    @@f:implements:
      @@@@: DOMXML|XMLFeature30
      @@@For: ManakaiDOM|DOM3 ManakaiDOM|DOMXMLFeature
    @@f:implements:
      @@@@: DOMXML|XMLVersionFeature10
      @@@For: ManakaiDOM|DOM3 ManakaiDOM|DOMXMLFeature
    @@f:implements:
      @@@@: DOMXML|XMLVersionFeature11
      @@@For: ManakaiDOM|DOM3 ManakaiDOM|DOMXMLFeatureXML11

ElementTypeBinding:
  @Name: IFQName
  @ElementType:
    dis:QName
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForIF

ElementTypeBinding:
  @Name: ClsQName
  @ElementType:
    dis:QName
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: IFISA
  @ElementType:
    dis:ISA
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForIF

ElementTypeBinding:
  @Name: ClsISA
  @ElementType:
    dis:ISA
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: disDef
  @ElementType:
    dis:Def
  @ShadowContent:
    @@ContentType:
      lang:dis
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: Code
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISPerl|InlineCode
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: IntPropDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISCore|Property
    @@For: =ManakaiDOM|all

ElementTypeBinding:
  @Name: RPropDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISSource|ResourceProperty
    @@For: =ManakaiDOM|all

ElementTypeBinding:
  @Name: Test
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: test|StandaloneTest
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: L2Test
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: test|StandaloneTest
    @@ForCheck: ManakaiDOM|ForClass ManakaiDOM|DOM2

ElementTypeBinding:
  @Name: L3Test
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: test|StandaloneTest
    @@ForCheck: ManakaiDOM|ForClass ManakaiDOM|DOM3

ElementTypeBinding:
  @Name: LXTest
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: test|StandaloneTest
    @@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOMLatest

ElementTypeBinding:
  @Name: XDTest
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: test|StandaloneTest
    @@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOMLatest

ClsDef:
  @ClsQName: ManakaiDOMImplementationTC

  @Implement: c|DOMImplementation
  @DISLang:role: mg|NodeRefRole

  @enDesc:
    The <Class::ManakaiDOMImplementationDocument> class implements
    two factory methods to create DOM <IF::Document> or
    <IF::DOMXML|DocumentType> defined in DOM Level 2 or higher.

  @IntMethod:
    @@Name: new
    @@enDesc:
      Creates a new instance of the implementation.
    @@Return:
      @@@Type: c|DOMImplementation
      @@@enDesc:
        The newly created implementation object.
      @@@PerlDef:
        my $bag;
        __CODE{mg|createNodeBag||ManakaiDOM|all:: $bag => $bag}__;
        my $stem;
        __CODE{mg|createNodeStem||ManakaiDOM|all::
          $bag => $bag,
          $stem => $stem,
          $class => {<ClassName::ManakaiDOMImplementationTC>},
          $opt => {{}},
        }__;
        __CODE{mg|createNodeRef||ManakaiDOM|all::
          $bag => $bag,
          $stem => $stem,
          $ref => $r,
          $opt => {{}},
        }__;

    @@Test:
      @@@QName: Impl.new.test
      @@@PerlDef:
        local $Message::DOM::TreeCore::GCLatency = 0;

        my $impl = <ClassM::ManakaiDOMImplementationTC.new>;

        my $bag = $impl->{<H::mg|nodeBag>};
        my $id = $impl->{<H::mg|nodeIDReference>};
        
        $test->id ('interface');
        $test->assert_isa ($impl, <IFName::c|DOMImplementation>);
        
        $test->id ('class');
        $test->assert_isa ($impl, <ClassName::ManakaiDOMImplementationTC>);

        undef $impl;

        $test->id ('gc');
        $test->assert_null ($bag->{$$id});

  @IntMethod:
    @@Operator:
      @@@@: DESTROY
      @@@ContentType: DISPerl|Perl
    @@Return:
      @@@disDef:
        @@@@DISPerl:cloneCode: mg|NodeRef||ManakaiDOM|all.destroy

  @CODE:
    @@QName: tc|createImplForTest
    @@PerlDef:
      $impl = <ClassM::ManakaiDOMImplementationTC.new>;

  @IntMethod:
    @@Operator: mg|CreateNodeRefMethod
    @@Param:
      @@@Name: obj
      @@@Type: HASH
    @@Return:
      @@@Type: c|DOMImplementation
      @@@PerlDef:
        $r = bless $obj, $self;

  @IntMethod:
    @@Operator: mg|CreateNodeStemMethod
    @@Param:
      @@@Name: bag
      @@@Type: HASH
    @@Param:
      @@@Name: obj
      @@@Type: HASH
    @@Return:
      @@@Type: HASH
      @@@PerlDef:
        $obj->{<H::tc|revImplementation>} = {};
        $r = $obj;
  @mg:ownee1h: tc|revImplementation

  @Method:
    @@Name: createDocument
    @@Return:
      @@@Type: Document
      @@@PerlDef:
        my $bag = <Code::mg|getNodeBag||ManakaiDOM|all:: $ref = $self>;
        my $stem;
        __CODE{mg|createNodeStem||ManakaiDOM|all::
          $bag => $bag,
          $stem => $stem,
          $class => {<ClassName::ManakaiDOMDocument>},
          $opt => {{
            <H::tc|implementation> => $self,
          }},
        }__;
        __CODE{mg|createNodeRef||ManakaiDOM|all::
          $bag => $bag,
          $stem => $stem,
          $ref => $r,
          $opt => {{
          }},
        }__;

    @@Test:
      @@@QName: Impl.createDoc.1.test
      @@@PerlDef:
        local $Message::DOM::TreeCore::GCLatency = 0;

        my $impl = <ClassM::ManakaiDOMImplementationTC.new>;

        my $bag = $impl->{<H::mg|nodeBag>};
        my $id = $impl->{<H::mg|nodeIDReference>};

        my $doc = $impl-><M::c|DOMImplementation.createDocument>;
        
        $test->id ('interface');
        $test->assert_isa ($doc, <IFName::Document>);
        
        $test->id ('class');
        $test->assert_isa ($doc, <ClassName::ManakaiDOMDocument>);

        my $doc_id = $doc->{<H::mg|nodeIDReference>};

        undef $impl;

        $test->id ('gc.impl.1');
        $test->assert_not_null ($bag->{$$id});

        $test->id ('gc.doc.1');
        $test->assert_not_null ($bag->{$$doc_id});

        undef $doc;

        $test->id ('gc.impl.2');
        $test->assert_null ($bag->{$$id});

        $test->id ('gc.doc.2');
        $test->assert_null ($bag->{$$doc_id});
    @@Test:
      @@@QName: Impl.createDoc.2.test
      @@@PerlDef:
        local $Message::DOM::TreeCore::GCLatency = 0;

        my $impl = <ClassM::ManakaiDOMImplementationTC.new>;

        my $bag = $impl->{<H::mg|nodeBag>};
        my $id = $impl->{<H::mg|nodeIDReference>};

        my $doc = $impl-><M::c|DOMImplementation.createDocument>;
        
        $test->id ('interface');
        $test->assert_isa ($doc, <IFName::Document>);
        
        $test->id ('class');
        $test->assert_isa ($doc, <ClassName::ManakaiDOMDocument>);

        my $doc_id = $doc->{<H::mg|nodeIDReference>};

        undef $doc;

        $test->id ('gc.impl.1');
        $test->assert_not_null ($bag->{$$id});

        $test->id ('gc.doc.1');
        $test->assert_null ($bag->{$$doc_id});

        undef $impl;

        $test->id ('gc.impl.2');
        $test->assert_null ($bag->{$$id});

        $test->id ('gc.doc.2');
        $test->assert_null ($bag->{$$doc_id});
    @@Test:
      @@@QName: Impl.createDoc.3.test
      @@@PerlDef:
        local $Message::DOM::TreeCore::GCLatency = 1;

        my $impl = <ClassM::ManakaiDOMImplementationTC.new>;

        my $bag = $impl->{<H::mg|nodeBag>};
        my $id = $impl->{<H::mg|nodeIDReference>};

        my $doc = $impl-><M::c|DOMImplementation.createDocument>;
        
        $test->id ('interface');
        $test->assert_isa ($doc, <IFName::Document>);
        
        $test->id ('class');
        $test->assert_isa ($doc, <ClassName::ManakaiDOMDocument>);

        my $doc_id = $doc->{<H::mg|nodeIDReference>};

        undef $doc;
        undef $impl;

        $test->id ('gc.impl.1');
        $test->assert_null ($bag->{$$id});

        $test->id ('gc.doc.1');
        $test->assert_null ($bag->{$$doc_id});
##DOMImplementationTC

ResourceDef:
  @QName: DOMString
  @AliasFor: DOMMain|DOMString
  @For: ManakaiDOM|DOM

ResourceDef:
  @QName: DOMImpl
  @AliasFor: c|DOMImplementation
  @For: ManakaiDOM|DOM

ResourceDef:
  @QName: boolean
  @AliasFor: idl|boolean||ManakaiDOM|all

ResourceDef:
  @QName: unsignedLong
  @AliasFor: idl|unsignedLong||ManakaiDOM|all

ResourceDef:
  @QName: unsignedShort
  @AliasFor: idl|unsignedShort||ManakaiDOM|all

ResourceDef:
  @QName: ARRAY
  @AliasFor: DISPerl|ARRAY||ManakaiDOM|all

ResourceDef:
  @QName: HASH
  @AliasFor: DISPerl|HASH||ManakaiDOM|all

ResourceDef:
  @QName: DTDef
  @AliasFor: d|DocumentTypeDefinition
  @For: ManakaiDOM|ManakaiDOMLatest

ResourceDef:
  @QName: ETDef
  @AliasFor: d|ElementTypeDefinition
  @For: ManakaiDOM|ManakaiDOMLatest

ResourceDef:
  @QName: ATDef
  @AliasFor: d|AttributeDefinition
  @For: ManakaiDOM|ManakaiDOMLatest

IFCls1Def:
  @IFQName: Node
  @ClsQName: ManakaiDOMNode

  @DISLang:role: mg|NodeRefRole

  @IntMethod:
    @@Operator: mg|CreateNodeRefMethod
    @@Param:
      @@@Name: obj
      @@@Type: HASH
    @@Param:
      @@@Name: opt
      @@@Type: HASH
    @@Return:
      @@@Type: Node
      @@@PerlDef:
        $r = bless $obj, ($opt->{<H::tc|nodeRefClass>} or $self);

  @IntMethod:
    @@Operator: mg|CreateNodeStemMethod
    @@Param:
      @@@Name: bag
      @@@Type: HASH
    @@Param:
      @@@Name: obj
      @@@Type: HASH
    @@Param:
      @@@Name: opt
      @@@Type: HASH
    @@Return:
      @@@Type: HASH
      @@@PerlDef:
        __CODE{mg|setOwnerProp||ManakaiDOM|all::
          $bag => $bag,
          $ownerref => {$opt->{<H::tc|ownerDocument>}},
          $ownee1hprop => {<H::tc|revOwnerDocument>},
          $ownee => {$obj},
          $owner0prop => {<H::tc|ownerDocument>},
        }__;
        $r = $obj;

  @Code:
    @@QName: tc|createNodesForTest
    @@PerlDef:
          $doc-><M::Document.createAttribute> ('a'),
          $docx-><M::d|DocumentXDoctype.createAttributeDefinition> ('at'),
          $doc-><M::Document.createCDATASection> ('cs'),
          $doc-><M::Document.createComment> ('c'),
          $doc,
          $doc-><M::Document.createDocumentFragment>,
          $docx-><M::d|DocumentXDoctype.createDocumentTypeDefinition> ('d'),
          $docx-><M::d|DocumentXDoctype.createGeneralEntity> ('ge'),
          $doc-><M::Document.createElement> ('e'),
          $docx-><M::d|DocumentXDoctype.createElementTypeDefinition> ('et'),
          $doc-><M::Document.createEntityReference> ('er'),
          $docx-><M::d|DocumentXDoctype.createNotation> ('not'),
          $doc-><M::Document.createProcessingInstruction> ('pi'),
          $doc-><M::Document.createTextNode> ('text'),
          #test:nodeTypes

  @Code:
    @@QName: tc|createNodesForTest+dt
    @@PerlDef:
          $doc-><M::Document.createAttribute> ('a'),
          $docx-><M::d|DocumentXDoctype.createAttributeDefinition> ('at'),
          $doc-><M::Document.createCDATASection> ('cs'),
          $doc-><M::Document.createComment> ('c'),
          $doc,
          $doc-><M::Document.createDocumentFragment>,
          $docx-><M::d|DocumentXDoctype.createDocumentTypeDefinition> ('d'),
          $doc-><AG::Document.implementation>
              -><M::c|DOMImplementation.createDocumentType> ('dt'),
          $docx-><M::d|DocumentXDoctype.createGeneralEntity> ('ge'),
          $doc-><M::Document.createElement> ('e'),
          $docx-><M::d|DocumentXDoctype.createElementTypeDefinition> ('et'),
          $doc-><M::Document.createEntityReference> ('er'),
          $docx-><M::d|DocumentXDoctype.createNotation> ('not'),
          $doc-><M::Document.createProcessingInstruction> ('pi'),
          $doc-><M::Document.createTextNode> ('text'),
          #test:nodeTypes

  @Code:
    @@QName: tc|createNodesForTest-doc-dtdef
    @@PerlDef:
          $doc-><M::Document.createAttribute> ('a'),
          $docx-><M::d|DocumentXDoctype.createAttributeDefinition> ('at'),
          $doc-><M::Document.createCDATASection> ('cs'),
          $doc-><M::Document.createComment> ('c'),
          # |Document|
          $doc-><M::Document.createDocumentFragment>,
          # |DocumentType| / |DocumentTypeDefinition|
          $docx-><M::d|DocumentXDoctype.createGeneralEntity> ('ge'),
          $doc-><M::Document.createElement> ('e'),
          $docx-><M::d|DocumentXDoctype.createElementTypeDefinition> ('et'),
          $doc-><M::Document.createEntityReference> ('er'),
          $docx-><M::d|DocumentXDoctype.createNotation> ('not'),
          $doc-><M::Document.createProcessingInstruction> ('pi'),
          $doc-><M::Document.createTextNode> ('text'),
          #test:nodeTypes

  @Code:
    @@QName: tc|createNodesForTest-el-attr
    @@PerlDef:
          # |Attribute|
          $docx-><M::d|DocumentXDoctype.createAttributeDefinition> ('at'),
          $doc-><M::Document.createCDATASection> ('cs'),
          $doc-><M::Document.createComment> ('c'),
          $doc,
          $doc-><M::Document.createDocumentFragment>,
          $docx-><M::d|DocumentXDoctype.createDocumentTypeDefinition> ('d'),
          $docx-><M::d|DocumentXDoctype.createGeneralEntity> ('ge'),
          # |Element|
          $docx-><M::d|DocumentXDoctype.createElementTypeDefinition> ('et'),
          $doc-><M::Document.createEntityReference> ('er'),
          $docx-><M::d|DocumentXDoctype.createNotation> ('not'),
          $doc-><M::Document.createProcessingInstruction> ('pi'),
          $doc-><M::Document.createTextNode> ('text'),
          #test:nodeTypes

  @IntMethod:
    @@Operator:
      @@@@: DESTROY
      @@@ContentType: DISPerl|Perl
    @@Return:
      @@@disDef:
        @@@@DISPerl:cloneCode: mg|NodeRef||ManakaiDOM|all.destroy

  @Constants:
    @@QName: NodeType
    @@enDesc:
      A <Q::NodeType> value is an integer indicating which type
      the node is.

      {NOTE::
        Numeric codes up to 200 are reserved to W3C for
        possible future use. <SRC::DOM1SE, DOM2, DOM3>
      }

    @@Const:
      @@@Name: ELEMENT_NODE
      @@@intValue: 1
      @@@enDesc:
        The node is an <IF::Element>.
    @@Const:
      @@@Name: ATTRIBUTE_NODE
      @@@intValue: 2
      @@@enDesc:
        The node is an <IF::Attr>.
    @@Const:
      @@@Name: TEXT_NODE
      @@@intValue: 3
      @@@enDesc:
        The node is a <IF::Text>.
    @@Const:
      @@@Name: CDATA_SECTION_NODE
      @@@intValue: 4
      @@@enDesc:
        The node is a <IF::tx|CDATASection>.
    @@Const:
      @@@Name: ENTITY_REFERENCE_NODE
      @@@intValue: 5
      @@@enDesc:
        The node is an <IF::tx|EntityReference>.
    @@Const:
      @@@Name: ENTITY_NODE
      @@@intValue: 6
      @@@enDesc:
        The node is an <IF::tx|Entity>.
    @@Const:
      @@@Name: PROCESSING_INSTRUCTION_NODE
      @@@intValue: 7
      @@@enDesc:
        The node is a <IF::tx|ProcessingInstruction>.
    @@Const:
      @@@Name: COMMENT_NODE
      @@@intValue: 8
      @@@enDesc:
        The node is a <IF::Comment>.
    @@Const:
      @@@Name: DOCUMENT_NODE
      @@@intValue: 9
      @@@enDesc:
        The node is a <IF::Document>.
    @@Const:
      @@@Name: DOCUMENT_TYPE_NODE
      @@@intValue: 10
      @@@enDesc:
        The node is a <IF::tx|DocumentType>.
    @@Const:
      @@@Name: DOCUMENT_FRAGMENT_NODE
      @@@intValue: 11
      @@@enDesc:
        The node is a <IF::DocumentFragment>.
    @@Const:
      @@@Name: NOTATION_NODE
      @@@intValue: 12
      @@@enDesc:
        The node is a <IF::tx|Notation>.

    @@mConst:
      @@@Name: ELEMENT_TYPE_DEFINITION_NODE
      @@@intValue: 81001
      @@@enDesc:
        The node is an <IF::d|ElementTypeDefinition>.
    @@mConst:
      @@@Name: ATTRIBUTE_DEFINITION_NODE
      @@@intValue: 81002
      @@@enDesc:
        The node is an <IF::d|AttributeDefinition>.

  @Attr:
    @@Name: nodeType
    @@enDesc:
      A code representing the type of the underlying object.
    @@Type: unsignedShort
    @@dis:actualType: NodeType
    @@Get:
      @@@PerlDef:
        ## TODO: Assertion

  @L2Attr:
    @@Name: localName
    @@enDesc:
      The local part of the qualified name of the node.
    @@DOMMain:isNamespaceAware:1
    @@Type: DOMString
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          If the type of the node is different from <C::Node.ELEMENT_NODE>
          and <C::Node.ATTRIBUTE_NODE>.
      @@@nullCase:
        @@@@enDesc:
          If it is a DOM Level 1 node.
      @@@PerlDef:
        my $v;
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $v,
          $prop => {<H::infoset|localName>},
          $ref => $self,
        }__;
        $r = defined $v ? $$v : null;
      @@@enImplNote:
        @@@@ddid: dom1
        @@@@@:
          {NOTE::
            Manakai no longer supports DOM Level 1 nodes.
          }

    @@L2Test:
      @@@QName: Node.localName.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        for my $node (<Code::tc|createNodesForTest-el-attr>) {
          $test->id ($node-><AG::Node.nodeType>);
          $test->assert_null ($node-><AG::Node.localName>);
        }

  @L2Attr:
    @@Name: namespaceURI
    @@enDesc:
      The namespace URI of the node.

        {NOTE::
           This is <EM::not> a computed value that is the result
           of a namespace lookup based on an examination of the
           namespace declarations in scope.  It is merely the
           namespace URI given at creation time.
        }
    @@DOMMain:isNamespaceAware:1
    @@Type: DOMString
    @@dis:actualType: ManakaiDOM|ManakaiDOMNamespaceURI
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          If the namespace is unspecified.
      @@@nullCase:
        @@@@enDesc:
          If the type of the node is different from <C::Node.ELEMENT_NODE>
          or <C::Node.ATTRIBUTE_NODE>.
      @@@nullCase:
        @@@@enDesc:
          If it is a DOM Level 1 node.
      @@@PerlDef:
        my $v;
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $v,
          $prop => {<H::infoset|namespaceName>},
          $ref => $self,
        }__;
        $r = defined $v ? $$v : null;
      @@@enImplNote:
        @@@@ddid:dom1
        @@@@@:
          {NOTE::
            Manakai no longer supports DOM Level 1 nodes.
          }

    @@L2Test:
      @@@QName: Node.namespaceURI.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        for my $node (<Code::tc|createNodesForTest-el-attr>) {
          $test->id ($node-><AG::Node.nodeType>);
          $test->assert_null ($node-><AG::Node.namespaceURI>);
        }

  @L2Attr:
    @@Name: prefix
    @@enDesc:
      The namespace prefix of the node.
    @@DOMMain:isNamespaceAware:1
    @@Type: DOMString
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          If the namespace prefix is unspecified.
      @@@nullCase:
        @@@@enDesc:
          If the type of the node is different from <C::Node.ELEMENT_NODE>
          or <C::Node.ATTRIBUTE_NODE>.
      @@@nullCase:
        @@@@enDesc:
          If it is a DOM Level 1 node.
      @@@PerlDef:
        $r = null;
    @@Set:
      @@@enDesc:
        Setting this attribute, when permitted, changes the 
        <A::Node.nodeName>, as well as <A::Element.tagName>
        or <A::Attr.name> attributes when applicable.

        Changining the namespace prefix of an attribute that
        is known to have a default value does not make a
        new attribute with the default value and the original
        prefix appear, since the <A::Node.namespaceURI> and
        <A::Node.localName> do no change.

        If the attribute value is defined to be <DOM::null>,
        setting it has no effect, including if the node is read-only.
        <SRC::DOM3>
      @@@nullCase:
        @@@@enDesc:
          Makes the namespace prefix unspecified.  <SRC::DOM3>
      @@@InCase:
        @@@@Value:
          @@@@@@: \
          @@@@@ContentType: DISCore|String
        @@@@enDesc:
          Implementation dependent.  <SRC::DOM3>
        @@@@enImplNote:
          In Firefox 1.5 it is same as <DOM::null>.  In Opera 8.5 and
          9 TP1 it has no effect.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_BAD_NAME
        @@@@enDesc:
          If the specified value contains an illegal character 
          <SRC::DOM2, DOM3>, according to XML 1.0 <SRC::DOM2 Errata> or
          according to the XML version in use specified in the
          <A::Document.xmlVersion> attribute <SRC::DOM3>.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the node is read-only.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_NS_BAD_NCNAME
        @@@@enDesc:
          If the specified prefix is malformed <SRC::DOM2, DOM3>
          per the XML Namespaces specification <SRC::DOM3>.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_NS_PREFIX_WITH_NULL_URI
        @@@@enDesc:
          If the <A::Node.namespaceURI> of the node is <DOM::null>.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_NS_XML_WITH_OTHER_URI
        @@@@enDesc:
          If the specified prefix is <XML::xml> and
          the <A::Node.namespaceURI> of the node is different
          from <URI::http://www.w3.org/XML/1998/namespace>.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_NS_XMLNS_WITH_OTHER_URI
        @@@@enDesc:
          If the node is an attribute and the specified prefix
          is <XML::xmlns> and the <A::Node.namespaceURI> of the node
          is different from <URI::http://www.w3.org/2000/xmlns/>.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_NS_QNAME_IS_XMLNS
        @@@@enDesc:
          If the node is an attribute and the qualified name
          of the node is <XML::xmlns>.
      @@@c:reports:
        @@@@@: t|setting-prefix-no-effect-because-of-document
        @@@@enDesc:
          If the the document does not support XML namespace
          so that setting the attribute value has no effect.
      @@@c:reports:
        @@@@@: t|setting-prefix-no-effect-because-of-node
        @@@@enDesc:
          If the the node does not support XML namespace
          so that setting the attribute value has no effect.
      @@@PerlDef:
        __c|ERROR{t|setting-prefix-no-effect-because-of-node::
          c|relatedData => {$self},
        }__;

    @@L2Test:
      @@@QName: Node.prefix.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestNoErr:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        for my $node (<Code::tc|createNodesForTest-el-attr>) {
          $test->id ($node-><AG::Node.nodeType>.'.get');
          $test->assert_null ($node-><AG::Node.prefix>);

          $test->id ($node-><AG::Node.nodeType>.'.set');
          $node-><AS::Node.prefix> ('node-value');
          $test->assert_null ($node-><AG::Node.prefix>);
        }

  @Attr:
    @@Name: parentNode
    @@enDesc:
      The parent of the node.
    @@Type: Node
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          If the node has no parent.
      @@@PerlDef:
        __CODE{mg|getNodeStemProp0Node||ManakaiDOM|all::
          $r => $r,
          $prop => {<H::infoset|parent>},
          $ref => $self,
        }__;

    @@XDTest:
      @@@QName: Node.parentNode.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        for my $node (<Code::tc|createNodesForTest>) {
          $test->id ('initial.'.$test-><AG::Node.nodeType>);
          $test->assert_null ($test-><AG::Node.parentNode>);
        }

  @L12Attr:
    @@Name: ownerDocument
    @@enDesc:
      The <IF::Document> object associated with the node.
    @@Type: Document
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          If the node is a <IF::Document>.
      @@@nullCase:
        @@@@enDesc:
          If the node is a <IF::tx|DocumentType> that is not
          used with any <IF::Document> yet.
      @@@PerlDef:
        __CODE{mg|getNodeStemProp0Node||ManakaiDOM|all::
          $r => $r,
          $prop => {<H::tc|ownerDocument>},
          $ref => $self,
        }__;

    @@Test:
      @@@QName: Node.ownerDocument.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        for my $node (<Code::tc|createNodesForTest-doc-dtdef>) {
          $test->id ($node-><AG::Node.nodeType>);
          $test->assert_equals ($node-><AG::Node.ownerDocument>, $doc);
        }

    @@Test:
      @@@QName: Node.ownerDocument.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        $test->assert_null ($doc-><AG::Node.ownerDocument>);

    @@Test:
      @@@QName: Node.ownerDocument.3.test
      @@@PerlDef:
        my $dt;
        __CODE{d|createDTForTest:: $dt => $dt}__;
        $test->assert_null ($dt-><AG::Node.ownerDocument>);

    @@XDTest:
      @@@QName: Node.ownerDocument.4.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtdef = $doc-><M::DocumentX.createDocumentTypeDefinition> ('dt1');

        $test->assert_null ($dtdef-><AG::Node.ownerDocument>, $doc);

  @L3Method:
    @@Name: isSameNode
    @@Perlop: eq
    @@enDesc:
      Returns whether the node is the same node as the given one.

      This method provides a way to determine whether two
      <IF::Node> references returned by the implementation
      reference the same object.  When two <IF::Node> references
      are references to the same object, even if through a proxy,
      the references may be used completely interchangeably,
      such that all attributes have the same values and calling
      the same DOM methods on either reference always has exactly
      the same effect.
    @@Param:
      @@@Name: other
      @@@Type: Node
      @@@enDesc:
        The node to test against.
    @@Return:
      @@@Type: boolean
      @@@TrueCase:
        @@@@enDesc:
          If the nodes are same.
      @@@FalseCase:
        @@@@enDesc:
          Otherwise.
      @@@PerlDef:
        if (UNIVERSAL::isa ($other, <IFName::Node||ManakaiDOM|ManakaiDOM>) and
            $other->isa ('HASH') and
            exists $other->{<H::mg|nodeIDReference>}) {
          $r = ($other->{<H::mg|nodeIDReference>}
                    eq $self->{<H::mg|nodeIDReference>});
        }

  @LXAttr:
    @@Name: manakaiReadOnly
    @@enDesc:
      Whether the node is read-only or not.
    @@Type: boolean
    @@TrueCase:
      @@@enDesc:
        If the node is read-only.
    @@FalseCase:
      @@@enDesc:
        If the node is <EM::not> read-only.
    @@Get:
      @@@PerlDef:
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $r,
          $prop => {<H::c|read-only>},
          $ref => $self,
        }__;

    @@CODE:
      @@@QName: tc|NodeReadOnlyError
      @@@PerlDef:
        if ($node-><AG::Node.manakaiReadOnly>) {
          __EXCEPTION{MDOMX|NOMOD_THIS::
          }__;
        }

  @LXMethod:
    @@Name: manakaiSetReadOnly
    @@Return:

  @enImplNote:
    @@ddid: setReadOnly
    @@@:
      {TODO::
        Add <M::Node.manakaiSetReadOnly> (<P::deep>).
      }

  @Attr:
    @@Name: childNodes
    @@enDesc:
      A node list containing the children of the node.  If there are
      no children, this is a list containing no nodes.
    @@Type: NodeList
    @@Get:
      @@@PerlDef:
        __CODE{tc|createChildNodeList::
          $node => $self,
          $r => $r,
        }__;

    @@Test:
      @@@QName: Node.childNodes.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        for my $node (<Code::tc|createNodesForTest>) {
          my $cn = $node-><AG::Node.childNodes>;

          $test->id ('interface.'.$node-><AG::Node.nodeType>);
          $test->assert_isa ($cn, <IFName::NodeList>);

          $test->id ('length.'.$node-><AG::Node.nodeType>);
          $test->assert_num_equals
                   (actual_value => $cn-><AG::NodeList.length>, 
                    expected_value => 0);
        }

  @Attr:
    @@Name: firstChild
    @@enDesc:
      The first child of the node.
    @@Type: Node
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          If there is no child node.
      @@@PerlDef:
        my $v;
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $v,
          $prop => {<H::infoset|children>},
          $ref => $self,
        }__;
        if (defined $v and defined $v->[0]) {
          __CODE{mg|createNodeRefFromID||ManakaiDOM|all::
            $bag => {<Code::mg|getNodeBag||ManakaiDOM|all:: $ref = $self>},
            $stemid => {$v->[0]},
            $ref => $r,
            $opt => {{}},
          }__;
        }

    @@Test:
      @@@QName: Node.firstChild.lastChild.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        for my $node (<Code::tc|createNodesForTest>) {
          $test->id ('default.firstChild.'.$node-><AG::Node.nodeType>);
          $test->assert_null ($node-><AG::Node.firstChild>);

          $test->id ('default.lastChild.'.$node-><AG::Node.nodeType>);
          $test->assert_null ($node-><AG::Node.lastChild>);
        }

  @Attr:
    @@Name: lastChild
    @@enDesc:
      The last child of the node.
    @@Type: Node
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          If there is no child node.
      @@@PerlDef:
        my $v;
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $v,
          $prop => {<H::infoset|children>},
          $ref => $self,
        }__;
        if (defined $v and defined $v->[0]) { # If 0, then there is -1
          __CODE{mg|createNodeRefFromID||ManakaiDOM|all::
            $bag => {<Code::mg|getNodeBag||ManakaiDOM|all:: $ref = $self>},
            $stemid => {$v->[-1]},
            $ref => $r,
            $opt => {{}},
          }__;
        }

  @Attr:
    @@Name: previousSibling
    @@enDesc:
      The node immediately preceding the node.
    @@Type: Node
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          If there is no such node.
      @@@PerlDef:
        __DEEP{
          my $parent = $self-><AG::Node.parentNode>;
          if ($parent) {
            S: for my $sib (@{$parent-><AG::Node.childNodes>}) {
              if ($sib eq $self) {
                last S;
              } else {
                $r = $sib;
              }
            }
          }
        }__;

  @Attr:
    @@Name: nextSibling
    @@enDesc:
      The node immediately following the node.
    @@Type: Node
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          If there is no such node.
      @@@PerlDef:
        __DEEP{
          my $parent = $self-><AG::Node.parentNode>;
          if ($parent) {
            my $next = false;
            S: for my $sib (@{$self-><AG::Node.childNodes>}) {
              if ($next) {
                $r = $sib;
                last S;
              } elsif ($sib eq $self) {
                $next = true;
              }
            }
          }
        }__;

    @@Test:
      @@@QName: Node.previousSibling.nextSibling.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $container = $doc-><M::Document.createElementNS> (null, 'c');

        my $e1 = $doc-><M::Document.createElementNS> (null, 'e1');
        $container-><M::Node.appendChild> ($e1);

        my $e2 = $doc-><M::Document.createElementNS> (null, 'e2');
        $container-><M::Node.appendChild> ($e2);

        my $e3 = $doc-><M::Document.createElementNS> (null, 'e3');
        $container-><M::Node.appendChild> ($e3);

        $test->id ('e1.prev');
        $test->assert_null ($e1-><AG::Node.previousSibling>);

        $test->id ('e1.next');
        $test->assert_equals ($e1-><AG::Node.nextSibling>, $e2);

        $test->id ('e2.prev');
        $test->assert_equals ($e2-><AG::Node.previousSibling>, $e1);

        $test->id ('e2.next');
        $test->assert_equals ($e2-><AG::Node.nextSibling>, $e3);

        $test->id ('e3.prev');
        $test->assert_equals ($e3-><AG::Node.previousSibling>, $e2);

        $test->id ('e3.next');
        $test->assert_null ($e3-><AG::Node.nextSibling>);

  @L13Method:
    @@Name: appendChild
    @@enDesc:
      Adds a node to the end of the list of children of the node.
      If that node is already in the tree, it is first removed.
    @@Param:
      @@@Name: newChild
      @@@Type: Node
      @@@enDesc:
        The node to add.
      @@@InCase:
        @@@@Type: DocumentFragment
        @@@@enDesc:
          The entire contents of the document fragment are
          moved into the child list of the node.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node added.
      @@@enImplNote:
        The specification is unclear on what node should or should
        not be returned if the <P::newChild> is a <IF::DocumentFragment>.

        In Firefix 1.5, Opera 9 TP1, and WinIE 6 (Windows XP SP2),
        the <IF::DocumentFragment> node is returned.
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_BAD_TYPE
        @@@@enDesc:
          If the node is of a type that does not allow children of
          the type of the <P::newChild> node.
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_ANCESTOR_OR_SELF
        @@@@enDesc:
          If the <P::newChild> node is one of the node's ancestor
          <SRC::DOM1, DOM2, DOM3> or the node itself <SRC::DOM2 Errata, DOM3>.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_SECOND_DOC_ELEMENT
        @@@@enDesc:
          If the node is of type <IF::Document> and an attempt
          is made to append a second <IF::DocumentType> node
          <SRC::DOM3> where the <cfg::cfg|strict-document-children>
          configuration parameter is set to <DOM::true> <SRC::manakai>.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_SECOND_DOCTYPE
        @@@@enDesc:
          If the node is of type <IF::Document> and an attempt
          is made to append a second <IF::x|DocumentType> node
          <SRC::DOM3> where the <cfg::cfg|strict-document-children>
          configuration parameter is set to <DOM::true> <SRC::manakai>.
      @@@dx:raises:
        @@@@@: c|HIERARCHY_WRONG_DOCTYPE_ERR
        @@@@enDesc:
          If the node is of type <IF::Document> and an attempt
          is made to append a <IF::x|DocumentType> node after
          an <IF::Element> node where the <cfg::cfg|strict-document-children>
          configuration parameter is set to <DOM::true>.  <SRC::manakai>
        @@@@enImplNote:
          Although such document type node is not prohibited
          by DOM specification, Firefox 1.5 and Opera 9 TP1
          throws an <X::c|DOMException.HIERARCHY_REQUEST_ERR>.
      @@@dx:raises:
        @@@@@: c|DIFFERENT_DOCUMENT_ERR
        @@@@enDesc:
          If the <P::newChild> node was created from a different
          document than the one that created the node.
        @@@@enImplNote:
          The DOM specification ignores the fact that <IF::Document>s
          and <IF::x|DocumentType>s are created from 
          <IF::c|DOMImplementation> :-)
      @@@dx:raises: 
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the node is read-only.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_SRC_PARENT
        @@@@enDesc:
          If the previous parent of the <P::newChild> node is read-only.
          <SRC::DOM2 Errata, DOM3>
      @@@iRaises:
        @@@@@: t|REMOVE_DOCUMENT_TYPE_ERR
        @@@@enDesc:
          If the <P::newChild> node is a child of the <IF::Document> node
          and the DOM implementation does not support the removal
          of the <IF::x|DocumentType> child. <SRC::DOM3>
      @@@iRaises:
        @@@@@: t|REMOVE_DOCUMENT_ELEMENT_ERR
        @@@@enDesc:
          If the <P::newChild> node is a child of the <IF::Document> node
          and the DOM implementation does not support the removal
          of the <IF::Element> child. <SRC::DOM3>
      @@@dx:raises:
        @@@@@: t|HIERARCHY_DOCUMENT_FRAGMENT_ITSELF_ERR
        @@@@enDesc:
          If <P::newChild> is the node itself.  <SRC::manakai>
      @@@PerlDef:
        ## TODO: Assertion
    
  @L13Method:
    @@Name: insertBefore
    @@enDesc:
      Inserts a node before the existing child node of the node.

      Inserting a node before itself is implementation dependent.
      <SRC::DOM3>
    @@Param:
      @@@Name: newChild
      @@@Type: Node
      @@@enDesc:
        The node to insert.  If the <P::newChild> is already in 
        the tree, it is first removed.
      @@@InCase:
        @@@@Type: DocumentFragment
        @@@@enDesc:
          All of children of the <P::newChild> node are inserted,
          in the same order, before <P::refChild>.
    @@Param:
      @@@Name: refChild
      @@@Type: Node
      @@@enDesc:
        The reference node, i.e. the node before which the new node
        must be inserted.
      @@@nullCase:
        @@@@enDesc:
          The <P::newChild> node is inserted at the end of the list
          of children.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node being inserted.
      @@@enImplNote:
        What is returned if <P::newChild> is a <IF::DocumentFragment>?
        See also <M::Node.appendChild>'s return value.
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_BAD_TYPE
        @@@@enDesc:
          If the node is of a type that does not allow children of
          the type of the <P::newChild> node.
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_ANCESTOR_OR_SELF
        @@@@enDesc:
          If the <P::newChild> node is one of the node's ancestor
          <SRC::DOM1, DOM2, DOM3> or the node itself <SRC::DOM2 Errata, DOM3>.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_SECOND_DOC_ELEMENT
        @@@@enDesc:
          If the node is of type <IF::Document> and an attempt
          is made to append a second <IF::tx|DocumentType> node
          <SRC::DOM3> where the <cfg::cfg|strict-document-children>
          configuration parameter is set to <DOM::true> <SRC::manakai>.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_SECOND_DOCTYPE
        @@@@enDesc:
          If the node is of type <IF::Document> and an attempt
          is made to append a second <IF::tx|DocumentType> node
          <SRC::DOM3> where the <cfg::cfg|strict-document-children>
          configuration parameter is set to <DOM::true> <SRC::manakai>.
      @@@dx:raises:
        @@@@@: c|HIERARCHY_WRONG_DOCTYPE_ERR
        @@@@enDesc:
          If the node is of type <IF::Document> and an attempt
          is made to append a <IF::tx|DocumentType> node after
          an <IF::Element> node where the <cfg::cfg|strict-document-children>
          configuration parameter is set to <DOM::true>.  <SRC::manakai>
        @@@@enImplNote:
          Although such document type node is not prohibited
          by DOM specification, Firefox 1.5 and Opera 9 TP1
          throws an <X::c|DOMException.HIERARCHY_REQUEST_ERR>.
      @@@dx:raises:
        @@@@@: c|DIFFERENT_DOCUMENT_ERR
        @@@@enDesc:
          If the <P::newChild> node was created from a different
          document than the one that created the node.
        @@@@enImplNote:
          The DOM specification ignores the fact that <IF::Document>s
          and <IF::tx|DocumentType>s are created from 
          <IF::c|DOMImplementation> :-)
      @@@dx:raises: 
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the node is read-only.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_SRC_PARENT
        @@@@enDesc:
          If the previous parent of the <P::newChild> node is read-only
          <SRC::DOM1SE, DOM2, DOM3>.
      @@@dx:raises:
        @@@@@: c|NOT_CHILD_ERR
        @@@@enDesc:
          If the <P::refChild> node is not a child of the node.
      @@@iRaises:
        @@@@@: t|REMOVE_DOCUMENT_TYPE_ERR
        @@@@enDesc:
          If the node is of type <IF::Document> and the DOM implementation
          does not support the insertion of a <IF::x|DocumentType> child.
          <SRC::DOM3>
      @@@iRaises:
        @@@@@: t|REMOVE_DOCUMENT_ELEMENT_ERR
        @@@@enDesc:
          If the node is of type <IF::Document> and the DOM implementation
          does not support the insertion of a <IF::x|Element> child.
          <SRC::DOM3>
      @@@iRaises:
        @@@@@: t|REMOVE_DOCUMENT_TYPE_ERR
        @@@@enDesc:
          If the <P::newChild> node is a child of the <IF::Document> node
          and the DOM implementation does not support the removal
          of the <IF::x|DocumentType> child.  <SRC::manakai>
      @@@iRaises:
        @@@@@: t|REMOVE_DOCUMENT_ELEMENT_ERR
        @@@@enDesc:
          If the <P::newChild> node is a child of the <IF::Document> node
          and the DOM implementation does not support the removal
          of the <IF::Element> child.  <SRC::manakai>
      @@@dx:raises:
        @@@@@: t|HIERARCHY_DOCUMENT_FRAGMENT_ITSELF_ERR
        @@@@enDesc:
          If <P::newChild> is the node itself.  <SRC::manakai>
      @@@c:reports:
        @@@@@: t|insert-before-itself
        @@@@enDesc:
          If the <P::newChild> node is same as the <P::refChild> node.
          Then, the result is implementation dependent.
      @@@PerlDef:
        ## TODO: Assertion

       @@@L3Test:
         @@@@QName: Node.insertBefore.insert-before-itself.Test
         @@@@PerlDef:
           my $impl = <Class::c|ManakaiDOMImplementation>->_new;
           my $doc = $impl-><M::c|DOMImplementation.createDocument>
                              ('http://www.example/', 'ex');

           my $eh_called = false;

           my $del = $doc-><AG::Document.documentElement>;
           my $el = $doc-><M::Document.createElementNS>
                       ('http://www.example/', 'element');
           $del-><M::Node.appendChild> ($el);

           my $cfg = $doc-><AG::Document.domConfig>;
           $cfg-><M::c|DOMConfiguration.setParameter> ('error-handler' => sub {
             my (undef, $err) = @_;
             $eh_called = true;
             $test->assert_equals ($err-><AG::c|DOMError.severity>,
                                   <C::c|DOMError.SEVERITY_WARNING>);
             $test->assert_equals ($err-><AG::c|DOMError.type>,
                                   <Q::t|insert-before-itself>);
             $test->assert_equals ($err-><AG::c|DOMError.relatedData>, $el);
             $test->assert_null ($err-><AG::c|DOMError.relatedException>);
             $test->assert_isa ($err-><AG::c|DOMError.location>,
                                <IFName::c|DOMLocator>);
             $test->assert_not_null ($err-><AG::c|DOMError.message>);
           });

           $test->assert_false ($eh_called);
           $del-><M::Node.insertBefore> ($el, $el);
           $test->assert_true ($eh_called);

           $test->assert_equals ($del-><AG::Node.firstChild>, $el);

           $el = null;

    @@enImplNote:
      @@@ddid: mod
      @@@@:
        Modified in DOM Level 3.

  @L13Method:
    @@Name: replaceChild
    @@enDesc:
      Replaces a child node with another node.

      Replacing a node with itself is implementation dependent <SRC::DOM3>.
    @@Param:
      @@@Name: newChild
      @@@Type: Node
      @@@enDesc:
        The new node to put in the child list.

        If the <P::newChild> node is already in the tree,
        it is first removed.
      @@@InCase:
        @@@@Type: DocumentFragment
        @@@@enDesc:
          The <P::oldChild> node is replaced by all of the 
          <IF::DocumentFragment> children, which are inserted
          in the same order <SRC::DOM1SE, DOM2, DOM3>.
    @@Param:
      @@@Name: oldChild
      @@@Type: Node
      @@@enDesc:
        The node being replaced in the list.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node replaced.
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_BAD_TYPE
        @@@@enDesc:
          If the node is of a type that does not allow children of
          the type of the <P::newChild> node.
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_ANCESTOR_OR_SELF
        @@@@enDesc:
          If the <P::newChild> node is one of the node's ancestor
          <SRC::DOM1, DOM2, DOM3> or the node itself <SRC::DOM2 Errata, DOM3>.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_SECOND_DOC_ELEMENT
        @@@@enDesc:
          If the node is of type <IF::Document> and an attempt
          is made to append a second <IF::tx|DocumentType> node
          <SRC::DOM3> where the <cfg::cfg|strict-document-children>
          configuration parameter is set to <DOM::true> <SRC::manakai>.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_SECOND_DOCTYPE
        @@@@enDesc:
          If the node is of type <IF::Document> and an attempt
          is made to append a second <IF::tx|DocumentType> node
          <SRC::DOM3> where the <cfg::cfg|strict-document-children>
          configuration parameter is set to <DOM::true> <SRC::manakai>.
      @@@dx:raises:
        @@@@@: c|HIERARCHY_WRONG_DOCTYPE_ERR
        @@@@enDesc:
          If the node is of type <IF::Document> and an attempt
          is made to append a <IF::tx|DocumentType> node after
          an <IF::Element> node where the <cfg::cfg|strict-document-children>
          configuration parameter is set to <DOM::true>. <SRC::manakai>
        @@@@enImplNote:
          Although such document type node is not prohibited
          by DOM specification, Firefox 1.5 and Opera 9 TP1
          throws an <X::c|DOMException.HIERARCHY_REQUEST_ERR>.
      @@@dx:raises:
        @@@@@: c|DIFFERENT_DOCUMENT_ERR
        @@@@enDesc:
          If the <P::newChild> node was created from a different
          document than the one that created the node.
        @@@@enImplNote:
          The DOM specification ignores the fact that <IF::Document>s
          and <IF::x|DocumentType>s are created from 
          <IF::c|DOMImplementation> :-)
      @@@dx:raises: 
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the node is read-only.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_SRC_PARENT
        @@@@enDesc:
          If the previous parent of the <P::newChild> node is read-only
          <SRC::DOM1SE, DOM2, DOM3>.
      @@@dx:raises:
        @@@@@: c|NOT_CHILD_ERR
        @@@@enDesc:
          If the <P::oldChild> node is not a child of the node.
      @@@iRaises:
        @@@@@: t|REMOVE_DOCUMENT_TYPE_ERR
        @@@@enDesc:
          If the node is of type <IF::Document> and the DOM implementation
          does not support the replacement of a <IF::x|DocumentType> child
          <SRC::DOM3>.
      @@@iRaises:
        @@@@@: t|REMOVE_DOCUMENT_ELEMENT_ERR
        @@@@enDesc:
          If the node is of type <IF::Document> and the DOM implementation
          does not support the replacement of a <IF::x|Element> child
          <SRC::DOM3>.
      @@@iRaises:
        @@@@@: t|REMOVE_DOCUMENT_TYPE_ERR
        @@@@enDesc:
          If the <P::newChild> node is a child of the <IF::Document> node
          and the DOM implementation does not support the removal
          of the <IF::tx|DocumentType> child.  <SRC::manakai>
      @@@iRaises:
        @@@@@: t|REMOVE_DOCUMENT_ELEMENT_ERR
        @@@@enDesc:
          If the <P::newChild> node is a child of the <IF::Document> node
          and the DOM implementation does not support the removal
          of the <IF::Element> child.  <SRC::manakai>
      @@@dx:raises:
        @@@@@: t|HIERARCHY_DOCUMENT_FRAGMENT_ITSELF_ERR
        @@@@enDesc:
          If <P::newChild> is the node itself.  <SRC::manakai>
      @@@c:reports:
        @@@@@: t|replaced-by-itself
        @@@@enDesc:
          If the <P::newChild> node is same as the <P::oldChild> node.
          Then, the result is implementation dependent.
      @@@PerlDef:
        ## TODO: Assertion

      @@@L3Test:
        @@@@QName: Node.replaceChild.replace-by-itself.Test
        @@@@PerlDef:
          my $impl;
          __CODE{tc|createImplForTest:: $impl => $impl}__;
          my $doc = $impl-><M::c|DOMImplementation.createDocument>
                              ('http://www.example/', 'ex');

           my $eh_called = false;

           my $del = $doc-><AG::Document.documentElement>;
           my $el = $doc-><M::Document.createElementNS>
                       ('http://www.example/', 'element');
           $del-><M::Node.appendChild> ($el);

           my $cfg = $doc-><AG::Document.domConfig>;
           $cfg-><M::c|DOMConfiguration.setParameter> ('error-handler' => sub {
             my (undef, $err) = @_;
             $eh_called = true;
             $test->assert_equals ($err-><AG::c|DOMError.severity>,
                                   <C::c|DOMError.SEVERITY_WARNING>);
             $test->assert_equals ($err-><AG::c|DOMError.type>,
                                   <Q::t|replace-by-itself>);
             $test->assert_equals ($err-><AG::c|DOMError.relatedData>, $el);
             $test->assert_null ($err-><AG::c|DOMError.relatedException>);
             $test->assert_isa ($err-><AG::c|DOMError.location>,
                                <IFName::c|DOMLocator>);
             $test->assert_not_null ($err-><AG::c|DOMError.message>);
           });

           $test->assert_false ($eh_called);
           $del-><M::Node.replaceChild> ($el, $el);
           $test->assert_true ($eh_called);

           $test->assert_equals ($del-><AG::Node.firstChild>, $el);

           $el = null;

      @@@enImplNote:
        Test for doctype/child::pi and attrdef/(text | entref)
        is included in <Module::MDOM|XDoctype> module.

    @@ResourceDef:
      @@@DISCore:resourceType:
        @@@@@: dis|MultipleResource
        @@@@ForCheck:
          ManakaiDOM|ForClass
          !tc|ForAppendChild !tc|ForInsertBefore !tc|ForReplaceChild
      @@@resourceFor: tc|ForAppendChild
      @@@resourceFor: tc|ForInsertBefore
      @@@resourceFor: tc|ForReplaceChild

      @@@QName:
        @@@@@: tc|appendChildImpl1
        @@@@ForCheck: tc|ForAppendChild
      @@@QName:
        @@@@@: tc|insertBeforeImpl1
        @@@@ForCheck: tc|ForInsertBefore
      @@@QName:
        @@@@@: tc|replaceChildImpl1
        @@@@ForCheck: tc|ForReplaceChild

      @@@DISCore:resourceType: DISPerl|BlockCode

      @@@enDesc:
        <Perl::$self>, <Perl::$newChild>, <Perl::$refChild> (insertBefore
        or replaceChild : <CODE::oldChild>),
        <Perl::$child_od>, <Perl::$child_nt>,
        <Perl::$r>, <Perl::$allowedNodeTypes>, <Perl::$self_od>.
  
      @@@PerlDef:
        __DEEP{
          my $strict = $self_od-><AG::Document.strictErrorChecking>;

          ## -- Node Type check
          my @new_child;
          if ($allowedNodeTypes->{$child_nt}) {
            push @new_child, $newChild;
          } elsif ($child_nt == <C::Node.DOCUMENT_FRAGMENT_NODE>) {
            for my $cn (@{$newChild-><AG::Node.childNodes>}) {
              unless ($allowedNodeTypes->{$cn-><AG::Node.nodeType>}) {
                __UNDEEP{__EXCEPTION{MDOMX|HIERARCHY_BAD_TYPE::
                  MDOMX|param-name => 'newChild',
                  c|node => {$newChild},
                }__}__;
              }
              push @new_child, $cn;
            }
          } else {
            __UNDEEP{__EXCEPTION{MDOMX|HIERARCHY_BAD_TYPE::
              MDOMX|param-name => 'newChild',
              c|node => {$newChild},
            }__}__;
          }

          my $nc_parent = @new_child ? $new_child[0]-><AG::Node.parentNode>
                                     : null;
          if ($strict) {
            ## -- Wrong-document check
            unless ($self_od eq $child_od) {
              __UNDEEP{__EXCEPTION{c|DIFFERENT_DOCUMENT_ERR::
                MDOMX|param-name => 'newChild',
                c|node => {$newChild},
              }__}__;
            }

            ## -- Read-onlyness check
            if ($self-><AG::Node.manakaiReadOnly>) {
              __UNDEEP{__EXCEPTION{MDOMX|NOMOD_THIS::
              }__}__;
            }
            if (@new_child) {
              if ($nc_parent and
                  $nc_parent-><AG::Node.manakaiReadOnly>) {
                __UNDEEP{__EXCEPTION{MDOMX|NOMOD_SRC_PARENT::
                }__}__;
              }
            }
          }

          ## -- Insert at...
          my $index = -1; # last
          __FOR{!tc:ForAppendChild:: # tc:ForAppendChild & tc:ForReplaceChild
            if (defined $refChild) {
              if ($refChild eq $newChild) {
                __FOR{tc:ForInsertBefore::
                  __UNDEEP{__c|ERROR{t|insert-before-itself::
                    c|relatedData => {$refChild},
                  }__}__;
                }__;
                __FOR{tc:ForReplaceChild::
                  __UNDEEP{__c|ERROR{t|replace-by-itself::
                    c|relatedData => {$refChild},
                  }__}__;
                }__;
              }

              my $cns = $self-><AG::Node.childNodes>;
              my $cnsl = @$cns;
              C: {
                $index = 0;
                for my $i (0..($cnsl-1)) {
                  my $cn = $cns->[$i];
                  if ($cn eq $refChild) {
                    $index += $i;
                    last C;
                  } elsif ($cn eq $newChild) {
                    $index = -1; # offset
                  }
                }
                __FOR{tc:ForInsertBefore::
                  __UNDEEP{__EXCEPTION{c|NOT_CHILD_ERR::
                    MDOMX|param-name => 'refChild',
                    c|node => {$refChild},
                  }__}__;
                }__;
                __FOR{tc:ForReplaceChild::
                  __UNDEEP{__EXCEPTION{c|NOT_CHILD_ERR::
                    MDOMX|param-name => 'oldChild',
                    c|node => {$refChild},
                  }__}__;
                }__;
              } # C
            } else { # |oldChild| is not defined
              __FOR{tc:ForReplaceChild::
                __UNDEEP{__EXCEPTION{c|NOT_CHILD_ERR::
                  MDOMX|param-name => 'oldChild',
                  c|node => {$refChild},
                }__}__;
              }__;
            }
          }__; # FOR !tc:ForAppendChild

          ## -- Removes from parent
          if ($nc_parent) {
            if ($child_nt == <C::Node.DOCUMENT_FRAGMENT_NODE>) {
              __CODE{mg|setNodeStemPropValue||ManakaiDOM|all::
                $given => {[]},
                $prop => {<H::infoset|children>},
                $ref => $newChild,
              }__;
            } else {
              my $v;
              __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
                $r => $v,
                $prop => {<H::infoset|children>},
                $ref => $nc_parent,
              }__;
              RP: for my $i (0..$#$v) {
                my $nodeid = $v->[$i];
                if (<Code::mg|nodeIDMatch||ManakaiDOM|all::
                        $noderef = {$new_child[0]},
                        $nodeid = $nodeid>) {
                  splice @$v, $i, 1, ();
                  last RP;
                }
              } # RP
            }
          }

          ## -- Rewrite the |parentNode| properties
          for my $nc (@new_child) {
            __CODE{mg|setNodeStemProp0Node||ManakaiDOM|all::
              $prop => {<H::infoset|parent>},
              $ref => $nc,
              $given => $self,
            }__;
          }

          my $children;
          __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
            $r => $children,
            $prop => {<H::infoset|children>},
            $ref => $self,
          }__;

          __FOR{tc:ForAppendChild::
            ## -- Adds to children list
            push @$children, map {
              <Code::mg|getNodeID||ManakaiDOM|all:: $ref = $_>
            } @new_child;
            $r = $newChild;
          }__;

          __FOR{tc:ForInsertBefore::
            ## -- Adds to children list
            if ($index == -1) {
              push @$children, map {
                <Code::mg|getNodeID||ManakaiDOM|all:: $ref = $_>
              } @new_child;
            } else {
              splice @$children, $index, 0, map {
                <Code::mg|getNodeID||ManakaiDOM|all:: $ref = $_>
              } @new_child;
            }
            $r = $newChild;
          }__;

          __FOR{tc:ForReplaceChild::
            ## -- Replaces the node
            splice @$children, $index, 1, map {
              <Code::mg|getNodeID||ManakaiDOM|all:: $ref = $_>
            } @new_child;
            __CODE{mg|deleteNodeStemPropValue||ManakaiDOM|all::
              $prop => {<H::infoset|parent>},
              $ref => $self,
            }__;
            $r = $refChild;
          }__;
        }__;

  @LXMethod:
    @@Name: manakaiAppendText
    @@enDesc:
      For manakai's Perl binding, the <Perl::.=> operator on
      a <IF::Node> object appends a string to the text content
      of the node.

      If the node is a <IF::DocumentFragment>, <IF::x|EntityReference>, 
      <IF::Element>, <IF::Attr>, <IF::x|Entity>, or
      <IF::d|AttributeDefinition> node, then the string
      is appended to the end of the text content of the node.  That is,
      if the last child node, if any, is a <IF::Text>, then its 
      <A::CharacterData.data> is extended by inserting the string
      at the end of it.  Otherwise, a new <IF::Text> node whose
      <A::CharacterData.data> is set to the string is inserted
      at the end of the child list of the node.

      If the node is a <IF::Document> and the <cfg::cfg|strict-document-children>
      configuration parameter is set to <DOM::false>, then the string
      is appended as if it were a <IF::DocumentFragment> node.  Otherwise,
      the operation has no effect.

      If the node is a <IF::x|ProcessingInstruction>, <IF::Comment>,
      <IF::Text>, or <IF::CDATASection> node, then the string
      is appended to its <A::Node.textContent> value.

      For other types of nodes, the operation has no effect.
    @@enImplNote:
      {ISSUE::
        It would be nice if the <Perl::.=> operator is overloaded
        by this method.  However, it makes perl unstable and causes
        segmentation fault at least in Perl 5.8.1 and 5.8.7 on Linux.
      }
    @@Param:
      @@@Name: string
      @@@Type: DOMString
      @@@enDesc:
        The string to append.
      @@@InCase:
        @@@@Type: DISPerl|SCALAR||ManakaiDOM|all
        @@@@enDesc:
          A copy of the string value referenced from the value
          is appended.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node itself.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the node to insert the string or a <IF::Text> node
          is read-only.
      @@@PerlDef:
        $r = $self;

  @L13Method:
    @@Name: removeChild
    @@enDesc:
      Removes a child node from the list of children of the node
      and returns it.
    @@Param:
      @@@Name: oldChild
      @@@Type: Node
      @@@enDesc:
        The node to remove.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node removed.
      @@@NodeReadOnlyError:
      @@@dx:raises:
        @@@@@: c|NOT_CHILD_ERR
        @@@@enDesc:
          If the <P::oldChild> is not a child of the node.
      @@@iRaises:
        @@@@@: t|REMOVE_DOCUMENT_TYPE_ERR
        @@@@enDesc:
          If the node is a <IF::Document> and the implementation
          does not support the removal of the <IF::tx|DocumentType>
          child.  <SRC::DOM3>
      @@@iRaises:
        @@@@@: t|REMOVE_DOCUMENT_ELEMENT_ERR
        @@@@enDesc:
          If the node is a <IF::Document> and the implementation
          does not support the removal of the <IF::Element>
          child.  <SRC::DOM3>
      @@@PerlDef:
        if ($self-><AG::Node.ownerDocument>
                 -><AG::Document.strictErrorChecking> and
            $self-><AG::Node.manakaiReadOnly>) {
          __EXCEPTION{MDOMX|NOMOD_THIS::
          }__;
        }
        __CODE{tc|removeChildImpl}__;

    @@CODE:
      @@@QName: tc|removeChildImpl
      @@@PerlDef:
          F: {
            my $i = -1;
            for my $cld (@{$self-><AG::Node.childNodes>}) {
              $i++;
              if ($cld eq $oldChild) {
                my $v;
                __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
                  $r => $v,
                  $prop => {<H::infoset|children>},
                  $ref => $self,
                }__;
                splice @$v, $i, 1, ();
                __CODE{mg|deleteNodeStemPropValue||ManakaiDOM|all::
                  $prop => {<H::infoset|parent>},
                  $ref => $oldChild,
                }__;
                $r = $oldChild;
                last F;
              }
            }
            __EXCEPTION{c|NOT_CHILD_ERR::
              MDOMX|param-name => 'oldChild',
              c|node => {$oldChild},
            }__;
          } # F

    @@Test:
      @@@QName: Node.removeChild.1.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        my $doc = $el-><AG::Node.ownerDocument>;

        my $c1 = $doc-><M::Document.createElementNS> (null, 'e');
        $el-><M::Node.appendChild> ($c1);

        my $c2 = $doc-><M::Document.createElementNS> (null, 'f');
        $el-><M::Node.appendChild> ($c2);

        my $c3 = $doc-><M::Document.createElementNS> (null, 'g');
        $el-><M::Node.appendChild> ($c3);

        my $return = $el-><M::Node.removeChild> ($c1);

        $test->id ('return');
        $test->assert_equals ($return, $c1);

        $test->id ('parentNode');
        $test->assert_null ($c1-><AG::Node.parentNode>);

        $test->id ('firstChild');
        $test->assert_equals ($el-><AG::Node.firstChild>, $c2);

        $test->id ('lastChild');
        $test->assert_equals ($el-><AG::Node.lastChild>, $c3);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$el-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: Node.removeChild.2.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        my $doc = $el-><AG::Node.ownerDocument>;

        my $c1 = $doc-><M::Document.createElementNS> (null, 'e');
        $el-><M::Node.appendChild> ($c1);

        my $c2 = $doc-><M::Document.createElementNS> (null, 'f');
        $el-><M::Node.appendChild> ($c2);

        my $c3 = $doc-><M::Document.createElementNS> (null, 'g');
        $el-><M::Node.appendChild> ($c3);

        my $return = $el-><M::Node.removeChild> ($c2);

        $test->id ('return');
        $test->assert_equals ($return, $c2);

        $test->id ('parentNode');
        $test->assert_null ($c2-><AG::Node.parentNode>);

        $test->id ('firstChild');
        $test->assert_equals ($el-><AG::Node.firstChild>, $c1);

        $test->id ('lastChild');
        $test->assert_equals ($el-><AG::Node.lastChild>, $c3);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$el-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: Node.removeChild.3.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        my $doc = $el-><AG::Node.ownerDocument>;

        my $c1 = $doc-><M::Document.createElementNS> (null, 'e');
        $el-><M::Node.appendChild> ($c1);

        my $c2 = $doc-><M::Document.createElementNS> (null, 'f');
        $el-><M::Node.appendChild> ($c2);

        my $c3 = $doc-><M::Document.createElementNS> (null, 'g');
        $el-><M::Node.appendChild> ($c3);

        my $return = $el-><M::Node.removeChild> ($c3);

        $test->id ('return');
        $test->assert_equals ($return, $c3);

        $test->id ('parentNode');
        $test->assert_null ($c3-><AG::Node.parentNode>);

        $test->id ('firstChild');
        $test->assert_equals ($el-><AG::Node.firstChild>, $c1);

        $test->id ('lastChild');
        $test->assert_equals ($el-><AG::Node.lastChild>, $c2);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$el-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: Node.removeChild.4.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        my $doc = $el-><AG::Node.ownerDocument>;

        my $c1 = $doc-><M::Document.createElementNS> (null, 'e');
        $el-><M::Node.appendChild> ($c1);

        my $return = $el-><M::Node.removeChild> ($c1);

        $test->id ('return');
        $test->assert_equals ($return, $c1);

        $test->id ('parentNode');
        $test->assert_null ($c1-><AG::Node.parentNode>);

        $test->id ('firstChild');
        $test->assert_null ($el-><AG::Node.firstChild>);

        $test->id ('lastChild');
        $test->assert_null ($el-><AG::Node.lastChild>);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$el-><AG::Node.childNodes>},
                  expected_value => 0);

  @Attr:
    @@Name: attributes
    @@enDesc:
      A named node map containing the attributes of the node.
    @@Type: NamedNodeMap
    @@Get:
      @@@enDesc:
        A <IF::NamedNodeMap> containing the attribute nodes,
        if the node is an <IF::Element>.
      @@@nullCase:
        @@@@enDesc:
          If the node is not an <IF::Element>.
    @@PerlDef: \

    @@Test:
      @@@QName: Node.attributes.test
      @@@enDesc:
        Other than <IF::Element>.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        for my $node (
          $doc-><M::Document.createAttribute> ('a'),
          $docx-><M::d|DocumentXDoctype.createAttributeDefinition> ('at'),
          $doc-><M::Document.createCDATASection> ('cs'),
          $doc-><M::Document.createComment> ('c'),
          $doc,
          $doc-><M::Document.createDocumentFragment>,
          $docx-><M::d|DocumentXDoctype.createDocumentTypeDefinition> ('d'),
          $docx-><M::d|DocumentXDoctype.createGeneralEntity> ('ge'),
          # |Element|
          $docx-><M::d|DocumentXDoctype.createElementTypeDefinition> ('et'),
          $doc-><M::Document.createEntityReference> ('er'),
          $docx-><M::d|DocumentXDoctype.createNotation> ('not'),
          $doc-><M::Document.createProcessingInstruction> ('pi'),
          $doc-><M::Document.createTextNode> ('text'),
          #test:nodeTypes
        ) {
          $test->id ($node-><AG::Node.nodeType>);
          $test->assert_null ($node-><AG::Node.attributes>);
        }

  @Attr:
    @@Name: nodeName
    @@enDesc:
      The name of the node.

      - <IF::Attr>::: The name of the attribute.  <SRC::DOM1, DOM2>
                      Same as <A::Attr.name>. <SRC::DOM3>

      - <IF::d|AttributeDefinition>::: The attribute name. <SRC::manakai>
 
      - <IF::tx|CDATASection>::: <DOM::#cdata-section>.

      - <IF::Comment>::: <DOM::#comment>.

      - <IF::Document>::: <DOM::#document>.

      - <IF::DocumentFragment>::: <DOM::#document-fragment>.

      - <IF::tx|DocumentType>::: The document type name.  <SRC::DOM1, DOM2>
            Same as <A::tx|DocumentType.name>.  <SRC::DOM3>

      - <IF::Element>::: The tag name of the element.  <SRC::DOM1, DOM2>
                         Same as <A::Element.tagName>.  <SRC::DOM3>

      - <IF::d|ElementTypeDefinition>::: The element type name. <SRC::manakai>

      - <IF::tx|Entity>::: The entity name.

      - <IF::tx|EntityReference>::: The entity name.

      - <IF::tx|Notation>::: The notation name.

      - <IF::tx|ProcessingInstruction>::: The target of the 
            processing instruction.  <SRC::DOM1, DOM2>  Same as 
            <A::tx|ProcessingInstruction.target>.  <SRC::DOM3>

      - <IF::tx|Text>::: <DOM::#text>.
    @@DOMMain:isNamespaceUnaware:1
    @@Type: DOMString
    @@Get:
      @@@PerlDef:
        ## TODO: Assertion

  @Attr:
    @@Name: nodeValue
    @@enDesc:
      The value of the node.

      - <IF::Attr>::: The value of the attribute.  <SRC::DOM1, DOM2>
            Same as <IF::Attr.value>.  <SRC::DOM3>

      - <IF::ATDef>::: The normalized default value. <SRC::manakai>

      - <IF::tx|CDATASection>::: The content of the <XML::CDATA> section.
            <SRC::DOM1, DOM2, DOM3>  Same as <A::CharacterData.data>.
            <SRC::DOM3>

      - <IF::Comment>::: The content of the comment.  <SRC::DOM1, DOM2, DOM3>
            Same as <A::CharacterData.data>.  <SRC::DOM3>

      - <IF::Document>, <IF::DocumentFragment>, <IF::tx|DocumentType>,
        <IF::Element>, <IF::ETDef>, <IF::tx|Entity>, <IF::tx|EntityReference>,
        <IF::tx|Notation>::: <DOM::null>.
   
      - <IF::tx|ProcessingInstruction>::: The entire content excluding
            the target.  <SRC::DOM1, DOM2>  Same as
            <IF::tx|ProcessingInstruction.data>.  <SRC::DOM3>

      - <IF::Text>:::The content of the text node.  <SRC::DOM1, DOM2, DOM3>
            Same as <A::CharacterData.data>.  <SRC::DOM3>
    @@Type: DOMString
    @@Get:
      @@@enDesc:
        {LI:: <IF::ATDef>:::
          The concatenation of the text content of every
          child node.  For <IF::Text> children, the
          text content of a node is the <A::Node.textContent>
          attribute value.  For <IF::tx|EntityReference>
          children, the text content of a node is the
          <A::Node.textContent> attribute value with
          any <CODE::U+0009>, <CODE::U+000A>, and
          <CODE::U+000D> replaced by <CODE::U+0020>.
        
          If the <A::ATDef.declaredType>
          of the node is different from 
          <C::ATDef.NO_TYPE_ATTR>,
          <C::ATDef.UNKNOWN_ATTR>, or
          <C::ATDef,CDATA_ATTR>, the value
          is further modified by discarding any leading
          and trailing <CODE::U+0020> characters and
          by replacing sequences of <CODE::U+0020> characters
          by a single <CODE::U+0020> character.  <SRC::manakai>
        }
      @@@nullCase:
        @@@@enDesc:
          If the node is a <C::Node.ATTRIBUTE_TYPE_DEFINITION_NODE> and
          the <A::ATDef.defaultType> is different from
          <C::ATDef.FIXED_DEFAULT> or <C::ATDef.EXPLICIT_DEFAULT>.
          <SRC::manakai>
      @@@iRaises:
        @@@@@: c|DOMSTRING_SIZE_ERR
        @@@@enDesc:
          When it would return more characters than fit in a
          <IF::DOMString> variable on the implementation platform.
      @@@PerlDef:
        $r = null;
    @@Set:
      @@@enDesc:
        If the attribute value is defined to be <DOM::null>,
        setting it has no effect, including if the node is read-only.
        <SRC::DOM2 Errata, DOM3>

        {LI:: <IF::ATDef>:::
          Any children are removed and if the new value
          is not empty or <DOM::null>, replaced by a single
          <IF::Text> node containgin the value the
          attribute is set to.
        
          If the <A::ATDef.defaultType>
          is different from <C::ATDef.FIXED_DEFAULT>
          or <C::ATDef.EXPLICIT_DEFAULT>, however,
          setting the attribute has no effect.  <SRC::manakai>
        }
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          When the node is read-only and if the attribute value is not defined
          to be <DOM::null>.
       @@@c:reports:
         @@@@@: c|setting-node-value-no-effect
         @@@@enDesc:
           Setting the attribute value has no effect, since the
           node value is defined as <DOM::null>.
       @@@PerlDef:
         __c|ERROR{t|setting-node-value-no-effect::
           c|relatedData => {$self},
         }__;

    @@XDTest:
      @@@QName: Node.nodeValue.null.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestNoErr:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        for (
          # |Attr|
          # |AttributeDefinition|
          # |CDATASection|
          # |Comment|
          $doc,
          $doc-><M::Document.createDocumentFragment>,
          $docx-><M::d|DocumentXDoctype.createDocumentTypeDefinition> ('d'),
          $docx-><M::d|DocumentXDoctype.createGeneralEntity> ('gent'),
          $doc-><M::Document.createElement> ('e'),
          $docx-><M::d|DocumentXDoctype.createElementTypeDefinition> ('et'),
          $doc-><M::Document.createEntityReference> ('er'),
          $docx-><M::d|DocumentXDoctype.createNotation> ('not'),
          # |ProcessingInstruction|
          # |Text|
          #test:nodeTypes
        ) {
          $test->id ('get.'.$node-><AG::Node.nodeType>);
          $test->assert_null ($node-><AG::Node.nodeValue>);

          $node-><M::Node.manakaiSetReadOnly> (false);

          $test->id ('set.'.$node-><AG::Node.nodeType>);
          $node-><AS::Node.nodeValue> ('node-value');
          $test->assert_null ($node-><AG::Node.nodeValue>);

          $node-><M::Node.manakaiSetReadOnly> (true);

          $test->id ('roset.'.$node-><AG::Node.nodeType>);
          $node-><AS::Node.nodeValue> ('node-value');
          $test->assert_null ($node-><AG::Node.nodeValue>);
        }

     @@L3Test:
       @@@QName: Node.nodeValue.Set.null.noEffect.Test
       @@@enDesc:
           This test ensures that attempts to set <A::Node.nodeValue>
           of <IF::Element> or <IF::Document> node never change its value
           and warnings are reported.

             {NOTE:: This test is restricted to DOM Level 3 or higher,
                     since the <IF::c|DOMError> interface is introduced
                     in that level of DOM.
             }
       @@@PerlDef:
           my $impl = <Class::c|ManakaiDOMImplementation>->_new;
           my $doc = $impl-><M::c|DOMImplementation.createDocument>
                              ('http://www.example/', 'ex');

           my $eh_called = 0;
           my $current_node;

           my $cfg = $doc-><AG::Document.domConfig>;
           $cfg-><M::c|DOMConfiguration.setParameter> ('error-handler' => sub {
             my (undef, $err) = @_;
             $eh_called++;
             $test->assert_equals ($err-><AG::c|DOMError.severity>,
                                   <C::c|DOMError.SEVERITY_WARNING>);
             $test->assert_equals ($err-><AG::c|DOMError.type>,
                                   <Q::t|setting-node-value-no-effect>);
             $test->assert_equals ($err-><AG::c|DOMError.relatedData>,
                                   $current_node);
             $test->assert_null ($err-><AG::c|DOMError.relatedException>);
             $test->assert_isa ($err-><AG::c|DOMError.location>,
                                <IFName::c|DOMLocator>);
             $test->assert_not_null ($err-><AG::c|DOMError.message>);
           });

           my $del = $doc-><AG::Document.documentElement>;
           $current_node = $del;
           $del-><AS::Node.nodeValue> ('non-null value');

           $test->assert_null ($del-><AG::Node.nodeValue>);
           $test->assert_equals ($eh_called, 1);

           $current_node = $doc;
           $doc-><AS::Node.nodeValue> ('non-null value');
            
           $test->assert_equals ($doc-><AG::Node.nodeValue>);
           $test->assert_equals ($eh_called, 2);

           $current_node = null;

  @L3Attr:
    @@Name: textContent
    @@enDesc:
      The text content of the node and its descendants.
    @@Type: DOMString
    @@Get:
      @@@enDesc:
        The text content of the node.  No serialization is performed
        and the returned string does not contain any markup.  No
        white space normalization is performed.

        - <IF::Attr>, <IF::ATDef>, <IF::Element>, <IF::tx|Entity>,
          <IF::tx|EntityReference>, <IF::DocumentFragment>:::
              Concatenetion of the <A::Node.textContent> value
              of every child node, excluding <IF::Comment> and
              <IF::tx|ProcessingInstruction> nodes.  This is the
              empty string if the node has no children.  Returned
              string does not contain the white spaces in element
              content (<A::Node.isElementContentWhitespace>).

        - <IF::tx|CDATASection>, <IF::Comment>, <IF::tx|ProcessingInstruction>,
              <IF::Text>::: <A::Node.nodeValue>.

        - <IF::tx|DocumentType>, <IF::ETDef>,
              <IF::tx|Notation>::: <DOM::null>.

        - <IF::Document>::: <DOM::null>. <SRC::DOM3>  However,
              if the <cfg::cfg|strict-document-children> configuration
              parameter is set to <DOM::false>, then the attribute
              value is the concatenation of the <A::Node.textContent>
              value of every child node, excluding <IF::tx|DocumentType>,
              <IF::Comment>, and <IF::tx|ProcessingInstruction> nodes and
              <IF::Text> nodes whose <A::Node.isElementContentWhitespace>
              attribute value is <DOM::true>.  <SRC::manakai>
      @@@nullCase:
        @@@@enDesc:
          If the type of the node is <IF::Document>, IF::tx|DocumentType>,
          <IF::ETDef>, or <IF::tx|Notation>.
      @@@iRaises:
        @@@@@: c|DOMSTRING_SIZE_ERR
        @@@@enDesc:
          When it would return more characters than fit in a <IF::DOMString>
          variable on the implementation platform.
      @@@PerlDef:
        __DEEP{
          $r = '';
          my @target = @{$self-><AG::Node.childNodes>};
          C: for my $node (@target) {
            my $nt = $node-><AG::Node.nodeType>;
            if ($nt == <C::Node.TEXT_NODE> or
                $nt == <C::Node.CDATA_SECTION_NODE>) {
              $r .= $node-><AG::CharacterData.data>
                unless $node-><AG::Text.isElementContentWhitespace>;
            } elsif ($nt == <C::Node.ELEMENT_NODE> or
                     $nt == <C::Node.ENTITY_REFERENCE_NODE>) {
              unshift @target, @{$node-><AG::Node.childNodes>};
            }
          }
        }__;
    @@Set:
      @@@enDesc:
        Any possible children the node may have are removed and
        if the new string is not empty or <DOM::null>, it is replaced
        by a single <IF::Text> node containing the string the
        attribute is set to.  No parsing is performed and the
        input string is taken as pure textual content.

        If the attribute value is defined to be <DOM::null>,
        setting it has no effect.

        If it is a <IF::Document> node and the 
        <cfg::cfg|strict-document-children> configuration parameter
        is set to <DOM::false>, then any possible children the
        node may have are removed and if the new string is not
        empty or <DOM::null>, it is replaced by a single
        <IF::Text> node containing the string the attribute is 
        set to.  No parsing is performed and the input string is
        taken as pure textual content.  <SRC::manakai>

        If it is an <IF::d|ElementTypeDefinition> node, then
        setting the attribute has no effect, including if
        the node is read-only.  <SRC::manakai>

        If it is an <IF::d|AttributeDefinition> node, then
        any possible children the node may have are removed and
        if the new string is not empty or <DOM::null>, it is
        replaced by a single <IF::Text> node containing
        the string the attribute is set to.  No parsing or
        white space normalization is performed and the input
        string is taken as pure textual content.  However,
        the implementation <kwd:MAY> normalize the attribute
        value according to the schemas in use or their builtin
        knowledge as in <IF::Attr> (see <sw010:csection::Interface
        <CODE::Attr>> in DOM Level 3 Core specification).  <SRC::manakai>
      @@@nullCase:
        @@@@enDesc:
          All children are removed.
      @@@NodeReadOnlyError:
      @@@PerlDef:
        __CODE{tc|setNodeTextContent::
          $node => $self,
          $given => $given,
          $ownerDocument => {$self-><AG::Node.ownerDocument>},
        }__;

    @@Test:
      @@@QName: Node.textContent.1.test
      @@@enDesc:
        Defined as <DOM::null>.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestNoErr:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        $doc-><AG::Document.domConfig>
            -><M::c|DOMConfiguration.setParameter>
                (<Q::cfg|strict-document-children> => true);

        for my $node (
          $docx-><M::DocumentX.createDocumentTypeDefinition> ('dt1'),
          $docx-><M::DocumentX.createElementTypeDefinition> ('et1'),
          $docx-><M::DocumentX.createNotation> ('nt1'),
          $doc-><AG::Document.implementation>
              -><M::c|DOMImplementation.createDocumentType> ('dt2'),
          $doc,
        ) {
          $test->id ($node-><AG::Node.nodeName>.'.get');
          $test->assert_null ($node-><AG::Node.textContent>);

          $test->id ($node-><AG::Node.nodeName>.'.set');
          $node-><AS::Node.textContent> ('new-text-content');
          $test->assert_null ($node-><AG::Node.textContent>);

          $test->id ($node-><AG::Node.nodeName>.'.set.ro');
          $node-><M::Node.manakaiSetReadOnly> (true);
          $node-><AS::Node.textContent> ('new-text-content');
          $test->assert_null ($node-><AG::Node.textContent>);
        }

    @@Test:
      @@@QName: Node.textContent.2.test
      @@@enDesc:
        Defined as concateneation.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestNoErr:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        $doc-><AG::Document.domConfig>
            -><M::c|DOMConfiguration.setParameter>
                (<Q::cfg|strict-document-children> => false);

        for my $node (
          $doc,
          $doc-><M::Document.createElement> ('e'),
          $doc-><M::Document.createAttribute> ('a'),
          $docx-><M::DocumentX.createGeneralEntity> ('ge'),
          $doc-><M::Document.createEntityReference> ('er'),
          $doc-><M::Document.createDocumentFragment>,
          $docx-><M::DocumentX.createAttributeDefinition> ('at'),
          #test:nodeTypes
        ) {
          $test->id ('empty');
          $test->assert_equals ($node-><AG::Node.textContent>, '');

          $node-><M::Node.manakaiSetReadOnly> (false);
          $node-><AS::Node.textContent> ('text1');

          $test->id ('set.textContent');
          $test->assert_equals ($node-><AG::Node.textContent>, 'text1');
          
          $test->id ('set.childNodes.length');
          $test->assert_num_equals
                   (actual_value => 0+@{$node-><AG::Node.childNodes>},
                    expected_value => 1);

          $node-><AS::Node.textContent> ('');

          $test->id ('empty.textContent');
          $test->assert_equals ($node-><AG::Node.textContent>, '');
          
          $test->id ('empty.childNodes.length');
          $test->assert_num_equals
                   (actual_value => 0+@{$node-><AG::Node.childNodes>},
                    expected_value => 0);

          $node-><AS::Node.textContent> ('text2');
          $node-><AS::Node.textContent> (null);

          $test->id ('null.textContent');
          $test->assert_equals ($node-><AG::Node.textContent>, '');
          
          $test->id ('null.childNodes.length');
          $test->assert_num_equals
                   (actual_value => 0+@{$node-><AG::Node.childNodes>},
                    expected_value => 0);

          $test->id ('ro.set');
          $node-><AS::Node.textContent> ('text4');
          $node-><AS::Node.manakaiSetReadOnly> (true);
          $test->assert_exception (code => sub {
            $node-><AS::Node.textContent> ('text3');
          }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);
          $test->assert_equals ($node-><AG::Node.textContent>, 'text4');
        }

  @ResourceDef:
    @@QName: tc|setNodeTextContent
    @@rdf:type: DISPerl|BlockCode
    @@Description:
      @@@lang:en
      @@@@:
        Sets a string as the text content of a node.
    @@ForCheck:
      ManakaiDOM:ForClass
    @@PerlDef:
      __CODE{tc|NodeReadOnlyError:: $node => $node}__;
 
      my @__old_children = @{$node-><AG::Node.childNodes>};
      for my $__old_child (@__old_children) {
        __CODE{mg|deleteNodeStemPropValue||ManakaiDOM|all::
          $prop => {<H::infoset|parent>},
          $ref => $__old_child,
        }__;
      }

      my @__new_children;
      if (defined $given and length $given) {
        my $__text = $ownerDocument-><M::Document.createTextNode> ($given);
        push @__new_children, $__text;
        __CODE{mg|setNodeStemProp0Node||ManakaiDOM|all::
          $prop => {<H::infoset|parent>},
          $ref => $__text,
          $given => $node,
        }__;
      }

      __CODE{mg|setNodeStemPropValue||ManakaiDOM|all::
        $given => {\@__new_children},
        $prop => {<H::infoset|children>},
        $ref => $node,
      }__;

  @L3Bitmasks:
    @@QName: DocumentPosition

     @@Description:
       @@@lang:en
       @@@@:
         A bitmask indicating the relative document position of a node 
         with respect to another node.

     @@Const:
        @@@Name:  DOCUMENT_POSITION_DISCONNECTED
        @@@intValue:  0x01
        @@@Description:
          @@@@lang:en
          @@@@@:
            The two nodes are disconnected.  Order between disconnected nodes 
            is always implementation-specific.
     @@Const:
        @@@Name:  DOCUMENT_POSITION_PRECEDING
        @@@intValue:  0x02
        @@@Description:
          @@@@lang:en
          @@@@@:
            The node precedes the reference node.
     @@Const:
        @@@Name:  DOCUMENT_POSITION_FOLLOWING
        @@@intValue:  0x04
        @@@Description:
          @@@@lang:en
          @@@@@: The node fllows the reference node.
     @@Const:
        @@@Name:  DOCUMENT_POSITION_CONTAINS
        @@@intValue:  0x08
        @@@Description: 
          @@@@lang:en
          @@@@@:
            The node contains the reference node.  A node that 
            contains is always preceding, too.
     @@Const:
        @@@Name:  DOCUMENT_POSITION_CONTAINED_BY
        @@@intValue:  0x10
        @@@Description:
          @@@@lang:en
          @@@@@:
            The node is contained by the reference node. 
            A node that is contained is always following, too.
     @@Const:
        @@@Name:  DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC
        @@@intValue:  0x20
        @@@Description:
          @@@@lang:en
          @@@@@:
            The determination of preceding versus following is 
            implementation-specific.

  @Method:
    @@Name: cloneNode
    @@DISCore:resourceType: DISLang|Constructor
    @@Operator: DISPerl|CloneMethod
    @@enDesc:
      Returns a duplicate of the node, i.e. serves as a generic
      copy constructor for nodes.

      - The duplicate node has no parent, i.e. <A::Node.parentNode>
        is <DOM::null>.  <SRC::DOM1, DOM2, DOM3>

      - The duplicate node has no user data, i.e. user data 
        associated to the node is not carried over.  However,
        if any <IF::c|UserDataHandlers> has been specified along with
        the associated data, those handlers will be called with
        the appropriate parameters before the method returns.  <SRC::DOM3>

      - If the node is an <IF::Element>, all attributes and their values,
        including those representing defaulted attributes (i.e.
        attributes whose <A::Attr.specified> are <DOM::false>),
        but the method does not copy any children it contains
        unless it is a deep clone (i.e. <P::deep> is <DOM::true>).
        <SRC::DOM1, DOM2, DOM3>

      - Cloning an <IF::Attr> directly, as oppsed to be cloned
        as part of an <IF::Element> cloning operation, returns
        a specified attribute (i.e. its <A::Attr.specified> is
        set to <DOM::true>).  <SRC::DOM1, DOM2, DOM3>

      - Cloning an <IF::Attr> always clones its children, since 
        they represent its value, no matter whether this is a 
        deep clone or not.  <SRC::DOM3>

      - Cloning an <IF::tx|EntityReference> automatically constructs
        its subtree if a corresponding <IF::tx|Entity> is available,  
        no matter whether this is a deep clone or not.  <SRC::DOM3>

      - Cloning any other type of node simply returns a copy of the node.
        <SRC::DOM1, DOM2, DOM3>

      - Cloning <IF::Document>, <IF::tx|DocumentType>, <IF::tx|Entity>,
        <IF::tx|Notation> nodes is implementation dependent.
        <SRC::DOM1SE, DOM2, DOM3>

      - Cloning an immutable subtree results in a mutable copy, but
        the children of an <IF::tx|EntityReference> clone are
        read-only.  <SRC::DOM2, DOM3>

      - Cloning a node does not copy the event listeners attached to it.
        <SRC::DOM2 Events, DOM3 Events>

      {NOTE:: <IF::c|UserDataHandler>s are prohibitted to throw exceptions;
              if a <IF::c|UserDataHandler> that is registered to the node
              being cloned throws an exception, then the result of
              the method is undefined.
      }

      {ISSUE::
        Relationship to style sheets??
      }
    @@Param:
      @@@Name: deep
      @@@Type: boolean
      @@@enDesc:
        Whether the subtree under the node should be recursively cloned
        or not.
      @@@TrueCase:
        @@@@enDesc:
          Recusively clones the subtree under the node.
      @@@FalseCase:
        @@@@enDesc:
          Doesn't clone the subtree under the node.
    @@Return:
      @@@Type:  Node
      @@@enDesc: The duplicate node.
      @@@dx:raises:
        @@@@@: c|CLONE_NODE_TYPE_NOT_SUPPORTED_ERR
        @@@@enDesc:
          The node is of type <IF::Document>, <IF::tx|DocumentType>,
          <IF::tx|Entity>, or <IF::tx|Notation> and the implementation
          does not support cloning that type of node.  <SRC::DOM1SE>
        @@@@enImplNote:
          Only in DOM1SE; they are implementation dependent
          in DOM1SE, DOM2, and DOM3.
      @@@PerlDef:
        __DEEP{
          my $od = $self-><AG::Node.ownerDocument>;
          my $strict_check = $od-><AG::Document.strictErrorChecking>;
          $od-><AS::Document.strictErrorChecking> (false);
          my $cfg = $od-><AG::Document.domConfig>;
          my $er_copy_asis = $cfg-><M::c|DOMConfiguration.getParameter>
                                     (<Q::cfg|clone-entity-reference-subtree>);
          my @udh;
          my @node = ([$self]);
          while (@node) {
            my ($node, $parent) = @{shift @node};
            my $nt = $node-><AG::Node.nodeType>;
            my $clone;
            if ($nt == <C::Node.ELEMENT_NODE>) {
              $clone = $od-><M::Document.createElementNS>
                              ($node-><AG::Node.namespaceURI>,
                               [$node-><AG::Node.prefix>,
                                $node-><AG::Node.localName>]);
              if ($parent) {
                $parent-><M::Node.appendChild> ($clone);
              } else {
                $r = $clone;
              }
              my $attrs = $node-><AG::Node.attributes>;
              my $attrsMax = $attrs-><AG::NamedNodeMap.length> - 1;
              for my $i (0..$attrsMax) {
                my $attr = $attrs-><M::NamedNodeMap.item> ($i);
                push @node, [$attr, $clone] if $attr-><AG::Attr.specified>;
              }
              if ($deep) {
                push @node, map {[$_, $clone]} @{$node-><AG::Node.childNodes>};
              }
            } elsif ($nt == <C::Node.TEXT_NODE>) {
              $clone = $od-><M::Document.createTextNode>
                              ($node-><AG::CharacterData.data>);
              if ($parent) {
                $parent-><M::Node.appendChild> ($clone);
              } else {
                $r = $clone;
              }
              $clone-><AS::Text.isElementContentWhitespace> (true)
                if $node-><AG::Text.isElementContentWhitespace>;
            } elsif ($nt == <C::Node.ATTRIBUTE_NODE>) {
              $clone = $od-><M::Document.createAttributeNS>
                              ($node-><AG::Node.namespaceURI>,
                               [$node-><AG::Node.prefix>,
                                $node-><AG::Node.localName>]);
              if ($parent) {
                $parent-><M::Element.setAttributeNodeNS> ($clone);
              } else {
                $r = $clone;
              }
              $clone-><AS::Attr.specified> (true);
              push @node, map {[$_, $clone]} @{$node-><AG::Node.childNodes>};
            } elsif ($nt == <C::Node.COMMENT_NODE>) {
              $clone = $od-><M::Document.createComment>
                              ($node-><AG::CharacterData.data>);
              if ($parent) {
                $parent-><M::Node.appendChild> ($clone);
              } else {
                $r = $clone;
              }
            } elsif ($nt == <C::Node.CDATA_SECTION_NODE>) {
              $clone = $od-><M::Document.createCDATASection>
                              ($node-><AG::CharacterData.data>);
              if ($parent) {
                $parent-><M::Node.appendChild> ($clone);
              } else {
                $r = $clone;
              }
            } elsif ($nt == <C::Node.PROCESSING_INSTRUCTION_NODE>) {
              $clone = $od-><M::Document.createProcessingInstruction>
                              ($node-><AG::tx|ProcessingInstruction.target>,
                               $node-><AG::tx|ProcessingInstruction.data>);
              if ($parent) {
                $parent-><M::Node.appendChild> ($clone);
              } else {
                $r = $clone;
              }
            } elsif ($nt == <C::Node.ENTITY_REFERENCE_NODE>) {
              $clone = $od-><M::Document.createEntityReference>
                              ($node-><AG::Node.nodeName>);
              if ($er_copy_asis) {
                $clone-><M::Node.manakaiSetReadOnly> (false);
                $clone-><AS::Node.textContent> ('');
                for (@{$node-><AG::Node.childNodes>}) {
                  $clone-><M::Node.appendChild>
                            ($_-><M::Node.cloneNode> (true));
                }
                $clone-><AS::tx|EntityReference.manakaiExpanded>
                          ($node-><AG::tx|EntityReference.manakaiExpanded>);
                if ($cfg-><M::c|DOMConfiguration.getParameter>
                            (<Q::cfg|entity-reference-read-only>)) {
                  $clone-><M::Node.manakaiSetReadOnly> (true, true);
                }
              } # copy asis
              if ($parent) {
                $parent-><M::Node.appendChild> ($clone);
              } else {
                $r = $clone;
              }
            } elsif ($nt == <C::Node.DOCUMENT_FRAGMENT_NODE>) {
              $clone = $od-><M::Document.createDocumentFragment>;
              $r = $clone;
              push @node, map {[$_, $clone]} @{$node-><AG::Node.childNodes>};
            } elsif ($nt == <C::Node.DOCUMENT_NODE>) {
              $od-><AS::Document.strictErrorChecking> ($strict_check);
              __UNDEEP{__EXCEPTION{c|CLONE_NODE_TYPE_NOT_SUPPORTED_ERR::
                c|node => $node,
              }__}__;
            } elsif ($nt == <C::Node.DOCUMENT_TYPE_NODE>) {
              $od-><AS::Document.strictErrorChecking> ($strict_check);
              __UNDEEP{__EXCEPTION{c|CLONE_NODE_TYPE_NOT_SUPPORTED_ERR::
                c|node => $node,
              }__}__;
            } elsif ($nt == <C::Node.ENTITY_NODE>) {
              $od-><AS::Document.strictErrorChecking> ($strict_check);
              __UNDEEP{__EXCEPTION{c|CLONE_NODE_TYPE_NOT_SUPPORTED_ERR::
                c|node => $node,
              }__}__;
            } elsif ($nt == <C::Node.NOTATION_NODE>) {
              $od-><AS::Document.strictErrorChecking> ($strict_check);
              __UNDEEP{__EXCEPTION{c|CLONE_NODE_TYPE_NOT_SUPPORTED_ERR::
                c|node => $node,
              }__}__;
            } else {
              ## TODO: Assertion
            }

            my $udhs;
            __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
              $r => $udhs,
              $prop => {<H::t|userData>},
              $ref => $self,
            }__;
            push @udh, [$node => $clone, $udhs] if $udhs and %$udhs;
          } # @node
          $od-><AS::Document.strictErrorChecking> (true) if $strict_check;

          ## Calling user data handlers if any
          for my $sd (@udh) {
            my $src = $sd->[0];
            my $src_ud = $sd->[2];
            for my $key (keys %{$src_ud}) {
              my $dh = $src_ud->{$key}->[1];
              if ($dh) {
                $dh-><M::c|UserDataHandler.handle>
                        (<C::c|UserDataHandler.NODE_CLONED>,
                         $key, $src_ud->{$key}->[0], $src, $sd->[1]);
              }
            }
          }
        }__;

    @@enImplNote:
      @@@ddid:udh
      @@@@:
        When are <IF::UserDataHandler>s invoked?  After a node
        is cloned?  Or, all nodes are cloned?  In any order?

        {TODO::
         
           - Clarification for default attributes

           - Define cloning for DTDef, ETDef, and ATDef.
        }

    @@L3Test:
      @@@QName: Node.CloneNode.UserDataHandler.Test
      @@@PerlDef:
        my $impl;
        __CODE{tc|createImplForTest:: $impl => $impl}__;
        my $doc = $impl-><M::c|DOMImplementation.createDocument>
                              ('http://www.example/', 'ex');
        my $node = $doc-><AG::Document.documentElement>;

        my $udh_called = false;

        $node-><M::Node.setUserData> ('key' => {}, sub {
          my ($self, $op, $key, $data, $src, $dest) = @_;
          $udh_called = true;

          $test->assert_equals ($op, <C::c|UserDataHandler.NODE_CLONED>);
          $test->assert_equals ($key, 'key');
          $test->assert_equals (ref $data, 'HASH');
          $test->assert_not_null ($src);
          $test->assert_equals ($src-><AG::Node.localName>, 'ex');
          $test->assert_not_null ($dest);
          $test->assert_equals ($dest-><AG::Node.localName>, 'ex');
        });

        my $clone = $node-><M::Node.cloneNode>;

        $test->assert_true ($udh_called);

        $node-><M::Node.setUserData> ('key', null, null);

    @@XDTest:
      @@@QName: EntityReference.cloneNode.clone-entity-reference-subtree.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docd = $doc-><M::Node.getFeature> (<Q::ManakaiDOM:XDoctype>, '3.0');
        my $dtd = $docd-><M::d|DocumentXDoctype.createDocumentTypeDefinition>
                           ('doctype');
          my $et = $docd-><M::d|DocumentXDoctype.createGeneralEntity>
                             ('ent1');
          $et-><AS::Node.textContent> ('replacement text content');
          $et-><AS::tx|Entity.manakaiHasReplacementTree> (true);
        $dtd-><M::DTDef.setGeneralEntityNode> ($et);
        $doc-><M::Node.appendChild> ($dtd);
        $doc-><AG::Document.domConfig>
            -><M::c|DOMConfiguration.setParameter>
                (<Q::cfg|entity-reference-read-only> => false);

        $doc-><AG::Document.domConfig>
            -><M::c|DOMConfiguration.setParameter>
                (<Q::cfg|clone-entity-reference-subtree> => false);
                # DOM 3 definition

        $test->id ('original');
        my $ent = $doc-><M::Document.createEntityReference> ('ent1');
        $test->assert_isa ($ent, <IFName::tx|EntityReference>);
        $test->assert_equals ($ent-><AG::Node.textContent>,
                              'replacement text content');
        $test->assert_true ($ent-><AG::tx|EntityReference.manakaiExpanded>);

        $test->id ('change');
        $ent-><AS::Node.textContent> ('another text');
        $test->assert_equals ($ent-><AG::Node.textContent>,
                              'another text');

        $test->id ('clone');
        my $clone = $ent-><M::Node.cloneNode>;
        $test->assert_isa ($clone, <IFName::tx|EntityReference>);
        $test->assert_equals ($clone-><AG::Node.textContent>,
                              'replacement text content');
        $test->assert_true ($clone-><AG::tx|EntityReference.manakaiExpanded>);
    @@XDTest:
      @@@QName: EntityReference.cloneNode.clone-entity-reference-subtree.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docd = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>, '3.0');
        my $dtd = $docd-><M::d|DocumentXDoctype.createDocumentTypeDefinition>
                           ('doctype');
          my $et = $docd-><M::d|DocumentXDoctype.createGeneralEntity>
                             ('ent1');
          $et-><AS::Node.textContent> ('replacement text content');
          $et-><AS::tx|Entity.manakaiHasReplacementTree> (true);
        $dtd-><M::DTDef.setGeneralEntityNode> ($et);
        $doc-><M::Node.appendChild> ($dtd);
        $doc-><AG::Document.domConfig>
            -><M::c|DOMConfiguration.setParameter>
                (<Q::cfg|entity-reference-read-only> => false);

        $doc-><AG::Document.domConfig>
            -><M::c|DOMConfiguration.setParameter>
                (<Q::cfg|clone-entity-reference-subtree> => true);

        $test->id ('original');
        my $ent = $doc-><M::Document.createEntityReference> ('ent1');
        $test->assert_isa ($ent, <IFName::tx|EntityReference>);
        $test->assert_equals ($ent-><AG::Node.textContent>,
                              'replacement text content');
        $test->assert_true ($ent-><AG::tx|EntityReference.manakaiExpanded>);

        $test->id ('change');
        $ent-><AS::Node.textContent> ('another text');
        $test->assert_equals ($ent-><AG::Node.textContent>,
                              'another text');

        $test->id ('clone');
        my $clone = $ent-><M::Node.cloneNode>;
        $test->assert_isa ($clone, <IFName::tx|EntityReference>);
        $test->assert_equals ($clone-><AG::Node.textContent>,
                              'another text');
        $test->assert_true ($clone-><AG::tx|EntityReference.manakaiExpanded>);
    @@XDTest:
      @@@QName: EntityReference.cloneNode.clone-entity-reference-subtree.3.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docd = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>, '3.0');
        my $dtd = $docd-><M::d|DocumentXDoctype.createDocumentTypeDefinition>
                           ('doctype');
          my $et = $docd-><M::d|DocumentXDoctype.createGeneralEntity>
                             ('ent1');
          $et-><AS::Node.textContent> ('replacement text content');
          $et-><AS::tx|Entity.manakaiHasReplacementTree> (true);
        $dtd-><M::DTDef.setGeneralEntityNode> ($et);
        $doc-><M::Node.appendChild> ($dtd);
        $doc-><AG::Document.domConfig>
            -><M::c|DOMConfiguration.setParameter>
                (<Q::cfg|entity-reference-read-only> => false);

        $doc-><AG::Document.domConfig>
            -><M::c|DOMConfiguration.setParameter>
                (<Q::cfg|clone-entity-reference-subtree> => true);

        $test->id ('original');
        my $ent = $doc-><M::Document.createEntityReference> ('ent1');
        $test->assert_isa ($ent, <IFName::tx|EntityReference>);
        $test->assert_equals ($ent-><AG::Node.textContent>,
                              'replacement text content');
        $test->assert_true ($ent-><AG::tx|EntityReference.manakaiExpanded>);

        $test->id ('change');
        $ent-><AS::Node.textContent> ('');
        $test->assert_equals ($ent-><AG::Node.textContent>, '');
        $ent-><AS::tx|EntityReference.manakaiExpanded> (false);
        $test->assert_false ($ent-><AG::tx|EntityReference.manakaiExpanded>);

        $test->id ('clone');
        my $clone = $ent-><M::Node.cloneNode>;
        $test->assert_isa ($clone, <IFName::tx|EntityReference>);
        $test->assert_equals ($clone-><AG::Node.textContent>, '');
        $test->assert_false ($clone-><AG::tx|EntityReference.manakaiExpanded>);

  @enImplNote:
    @@ddid: pending
    @@@:
      baseURI, compareDocumentPosition, isDefaultNamespace,
      isEqualNode, isSupported, lookupNamespaceURI,
      lookupPrefix, normalize

  @L3Method:
    @@Name: getFeature
    @@enDesc:
      Returns a specialized object that implements the specialized
      APIs of the specified feature and version.  This method also
      allow the implementation to provide specialized objects
      that do not support the <IF::Node> interface.

        {NOTE:: The specialized object may also obtained by
                using binding-specific casting methods but
                it is not necessarily expected to.
        }
    @@Param:
      @@@Name: feature
      @@@Type: DOMString
      @@@dis:actualType: f|FeatureNameString
      @@@enDesc:
        The name of the feature to request.
      @@@InCase:
        @@@@Label:
          @@@@@lang:en
          @@@@@@:
            Feature name prepended by a <CHAR::PLUS SIGN>
        @@@@enDesc:
          Any <CHAR::PLUS SIGN> will be ignored since it is
          not significant in the context of this method.
    @@Param:
      @@@Name: version
      @@@Type: DOMString
      @@@dis:actualType: f|FeatureVersionString
      @@@enDesc:
        The version number of the feature to request.
      @@@enImplNote:
        {ISSUE:: null? empty?
        }
    @@Return:
      @@@Type: DOMMain|DOMObject
      @@@enDesc:
        An object that implements the specialized APIs of
        the specified feature and version.

        If it implements the <IF::Node> interface, it must
        delegate to the primary core <IF::Node> and not return
        results icosistent with the primary core <IF::Node>.
      @@@nullCase:
        @@@@enDesc:
          If there is no object that implements interfaces
          associated with the specified feature and version.
      @@@PerlDef:
        $feature =~ s/^\+//;
        __CODE{f|getFeatureImpl::
          $self => $self,
          $feature => $feature, $version => $version, $r => $r,
          $base_class => {<ClassName::ManakaiDOMNode>},
        }__;

    @@Test:
      @@@QName: Node.getFeature.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        for my $node (<Code::tc|createNodesForTest+dt>) {
          $test->id ($node-><AG::Node.nodeType>.'.core.1.0');
          my $core1 = $node-><M::Node.getFeature> (Core => '1.0');
          $test->assert_isa ($core1, <IFName::Node||ManakaiDOM|ManakaiDOM1>);

          $test->id ($node-><AG::Node.nodeType>.'.core.2.0');
          my $core2 = $node-><M::Node.getFeature> (Core => '2.0');
          $test->assert_isa ($core2, <IFName::Node||ManakaiDOM|ManakaiDOM2>);

          $test->id ($node-><AG::Node.nodeType>.'.core.3.0');
          my $core3 = $node-><M::Node.getFeature> (Core => '3.0');
          $test->assert_isa ($core3, <IFName::Node||ManakaiDOM|ManakaiDOM3>);

          $test->id ($node-><AG::Node.nodeType>.'.xml.1.0');
          my $xml1 = $node-><M::Node.getFeature> (XML => '1.0');
          $test->assert_isa ($xml1, <IFName::Node||ManakaiDOM|ManakaiDOM1>);

          $test->id ($node-><AG::Node.nodeType>.'.xml.2.0');
          my $xml2 = $node-><M::Node.getFeature> (XML => '2.0');
          $test->assert_isa ($xml2, <IFName::Node||ManakaiDOM|ManakaiDOM2>);

          $test->id ($node-><AG::Node.nodeType>.'.xml.3.0');
          my $xml3 = $node-><M::Node.getFeature> (XML => '3.0');
          $test->assert_isa ($xml3, <IFName::Node||ManakaiDOM|ManakaiDOM3>);

          $test->id ($node-><AG::Node.nodeType>.'.unknown');
          my $unk = $node-><M::Node.getFeature> ('-unknown-feature' => '3.0');
          $test->assert_null ($unk);
        }

  @CODE:
    @@QName: f|getFeatureImpl
    @@enDesc:
      - <Perl::$self>::: The object.

      - <Perl::$feature>::: Normalized feature name with 
                            no <CHAR::PLUS SIGN> prefix.

      - <Perl::$version>::: Normalized feature version.

      - <Perl::$base_class>::: The Perl package name of the class the
                               specialized class <kwd:MUST> be 
                               compatible with.

      - <Perl::$r>::: The return value.
    @@PerlDef:
      if ($Message::DOM::DOMFeature::ClassInfo->{ref $self}
            ->{has_feature}->{$feature}->{$version}) {
        $r = $self;
      } else {
        CLASS: for my $__class (grep {
          $Message::DOM::DOMFeature::ClassInfo->{$base_class}
              ->{compat_class}->{$_}
        } keys %{$Message::DOM::DOMFeature::ClassInfo->{$base_class}
                     ->{compat_class}}) {
          if ($Message::DOM::DOMFeature::ClassInfo->{$__class}
                  ->{has_feature}->{$feature}->{$version}) {
            __CODE{mg|createNodeRefFromID||ManakaiDOM|all::
              $bag => {<Code::mg|getNodeBag||ManakaiDOM|all:: $ref = $self>},
              $stemid => {<Code::mg|getNodeID||ManakaiDOM|all:: $ref = $self>},
              $ref => $r,
              $opt => {{
                <H::tc|nodeRefClass> => $__class,
              }},
            }__;
            last Class;
          }
        } # CLASS
      }
    @@enImplNote:
      {TODO::
        Move on <Module::MDOMX|DOMFeature> module.
      }

  @L3Method:
    @@Name: getUserData
    @@enDesc:
      Retrieves the object associated to a key on the node.
    @@Param:
      @@@Name: key
      @@@Type: DOMMain|DOMString
      @@@enDesc:
        The key the object is associated to.
    @@Return:
      @@@Type: DOMMain|DOMUserData
      @@@enDesc:
        The object associated to the given <P::key> on the node.
      @@@nullCase:
        @@@@enDesc:
          No object is associated.
      @@@PerlDef:
        my $v;
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $v,
          $prop => {<H::t|userData>},
          $ref => $self,
        }__;
        $r = $v->{$key}->[0];


  @L3Method:
    @@Name: setUserData
    @@enDesc:
      Associates an object to a key on the node.  The object can later
      be retrieved from the node by calling <M::Node.getUserData>
      method with the same key.
    @@enDesc:
      @@@ForCheck: ManakaiDOM|Perl ManakaiDOM|ForClass
      @@@ddid: pleak
      @@@@:
        {NOTE:: Application developers are advised to be careful
                to include direct or indirect references to the node
                itself as user data or in user data handlers.
                They would result in memory leak problems unless
                the circular references are removed later.
                
                It would be a good practive to eusure that every user data
                registered to a node is later unregistered by setting
                <DOM::null> as a data for the same key.
        }
    @@Param:
      @@@Name: key
      @@@Type: DOMMain|DOMString
      @@@enDesc:
        The key to associate the <P::data> to.
    @@Param:
      @@@Name: data
      @@@Type: DOMMain|DOMUserData
      @@@enDesc:
        The object to associate to the given key.
      @@@nullCase:
        @@@@enDesc:
          Removes any existing association to the <P::key>.
    @@Param:
      @@@Name: handler
      @@@Type: c|UserDataHandler
      @@@enDesc:
        The handler to associate to the <P::key>.
      @@@nullCase:
        @@@@enDesc:
          No handler is associated.
    @@Return:
      @@@Type: DOMMain|DOMUserData
      @@@enDesc:
        The object previously associated to the <P::key> on the node.
      @@@nullCase:
        @@@@enDesc:
          No object was associated.
      @@@PerlDef:
        __CODE{mg|orSetNodeStemPropValue||ManakaiDOM|all::
          $given => {{}},
          $prop => {<H::t|userData>},
          $ref => $self,
        }__;
        my $v;
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $v,
          $prop => {<H::t|userData>},
          $ref => $self,
        }__;
        $r = $v->{$key}->[0];

        if (defined $data) {
          $v->{$key} = [$data, $handler];
        } else {
          CORE::delete $v->{$key};
        }

  @L3Test:
    @@QName: GetSetUserDataTest
    @@PerlDef:
      my $impl;
      __CODE{tc|createImplForTest:: $impl => $impl}__;

      my $node = $impl-><M::c|DOMImplementation.createDocument>;

      my $data = ['2'];
      my $handler = sub { 1 };

      $test->assert_null
               ($node-><M::Node.setUserData> ('key1', $data, $handler),
                uri => <Q::GetSetUserDataTest.InitialReturnNull>);

      my $key1_data = $node-><M::Node.getUserData> ('key1');
      $test->assert_not_null ($key1_data);
      $test->assert_equals ($data->[0], $key1_data->[0]);

      my $data2 = ['4'];
      
      $test->assert_equals ($node-><M::Node.setUserData> ('key1', $data2, null),
                            $data);
      
      $test->assert_equals ($node-><M::Node.getUserData> ('key1'), $data2);

      $node-><M::Node.setUserData> ('key1', null, $handler);
      $test->assert_null ($node-><M::Node.getUserData> ('key1'));

      $node-><M::Node.setUserData> ('key1', null, null);
      $test->assert_null ($node-><M::Node.getUserData> ('key1'));

  @L2Method:
    @@Name: hasAttributes
    @@enDesc:
      Returns whether the node has any attribute nodes.
    @@Return:
      @@@Type: boolean
      @@@TrueCase:
        @@@@enDesc:
          If the node has any attributes.
      @@@FalseCase:
        @@@@enDesc:
          Otherwise.
      @@@PerlDef:
        my $attrs;
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $attrs,
          $prop => {<H::infoset|attributes>},
          $ref => $self,
        }__;
        A: for (values %{$attrs or {}}) {
          if (keys %$_) {
            $r = true;
            last A;
          }
        }

    @@Test:
      @@@QName: Node.hasAttributes.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        for my $node (
          <Code::tc|createNodesForTest-el-attr>,
          $doc-><M::Document.createAttribute> ('at1'),
        ) {
          $test->id ($node-><AG::Node.nodeName>);
          $test->assert_false ($node-><M::Node.hasAttributes>);
        }
    @@Test:
      @@@QName: Element.hasAttributes.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        $test->id ('initial');
        $test->assert_false ($el-><M::Node.hasAttributes>);

        $test->id ('1');
        $node-><M::Element.setAttribute> (a => 'b');
        $test->assert_true ($el-><M::Node.hasAttributes>);

        $test->id ('2');
        $node-><M::Element.setAttribute> (c => 'd');
        $test->assert_true ($el-><M::Node.hasAttributes>);

        $test->id ('2-1');
        $node-><M::Element.removeAttribute> ('c');
        $test->assert_true ($el-><M::Node.hasAttributes>);

        $test->id ('not.specified');
        $node-><M::Element.getAttributeNode> ('a')
             -><AS::Attr.specified> (false);
        $test->assert_true ($el-><M::Node.hasAttributes>);

        $test->id ('1-1');
        $node-><M::Element.removeAttribute> ('a');
        $test->assert_false ($el-><M::Node.hasAttributes>);

  @Method:
    @@Name: hasChildNodes
    @@enDesc:
      Returns whether the node has any children.
    @@Return:
      @@@Type: boolean
      @@@TrueCase:
        @@@@enDesc:
          If the node has any children.
      @@@FalseCase:
        @@@@enDesc:
          Otherwise.
      @@@PerlDef:
        my $v;
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $v,
          $prop => {<H::infoset|children>},
          $ref => $self,
        }__;
        $r = (@{$v or []} > 0);

    @@Test:
      @@@QName: Node.hasChildNodes.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        for my $node (<Code::tc|createNodesForTest+dt>) {
          $test->id ($node-><AG::Node.nodeName>);
          $test->assert_false ($node-><M::Node.hasChildNodes>);
        }
    @@Test:
      @@@QName: Doc.hasChildNodes.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        $test->id ('initial');
        $test->assert_false ($doc-><M::Node.hasChildNodes>);

        $test->id ('1');
        $doc-><M::Node.appendChild> ($doc-><M::Document.createComment> (''));
        $test->assert_true ($doc-><M::Node.hasChildNodes>);

        $test->id ('2');
        $doc-><M::Node.appendChild> ($doc-><M::Document.createComment> (''));
        $test->assert_true ($doc-><M::Node.hasChildNodes>);

        $test->id ('2-1');
        $doc-><M::Node.removeChild> ($doc-><AG::Node.firstChild>);
        $test->assert_true ($doc-><M::Node.hasChildNodes>);

        $test->id ('1-1');
        $doc-><M::Node.removeChild> ($doc-><AG::Node.firstChild>);
        $test->assert_false ($doc-><M::Node.hasChildNodes>);

  @Method:
    @@Name: lookupNamespaceURI
    @@Return:
##Node

IntPropDef:
  @QName: tc|nodeRefClass
  @mg:nodeStemKey: nrcls
  @enDesc:
    The Perl package name of the class of the node reference.

ForDef:
  @QName: tc|ForAppendChild
  @ISA: ManakaiDOM|ForClass

ForDef:
  @QName: tc|ForInsertBefore
  @ISA: ManakaiDOM|ForClass

ForDef:
  @QName: tc|ForReplaceChild
  @ISA: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: iRaises
  @ElementType:
    dx:raises
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForIF

ElementTypeBinding:
  @Name: Exception
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@ForCheck: !ManakaiDOM|all

NodeTypeDef:
  @IFQName: Document
  @ClsQName: ManakaiDOMDocument

  @enDesc:
    A <IF::Document> object represents the entire HTML or XML document.
    It is conceptually the root of the document tree and
    provides the primary access to the docuement's data.

    Since elements, text nodes, comments, processing instructions,
    and so on cannot exist outside the context of a <IF::Document>,
    the <IF::Document> interface also contains the factory methods
    needed to create these objects.  The <IF::Node> objects
    created have a <A::Node.ownerDocument> attribute which
    associates them with the <IF::Document> within whose context
    they were created.

    {NOTE:: A <IF::DocumentType> node can be created by
            <M::c|DOMImplementation.createDocumentType> method.
            A <IF::Document> node can be created by 
            <M::c|DOMImplementation.createDocument> method.
    }

  @IntMethod:
    @@Operator: mg|CreateNodeStemMethod
    @@Param:
      @@@Name: bag
      @@@Type: HASH
    @@Param:
      @@@Name: obj
      @@@Type: HASH
    @@Param:
      @@@Name: opt
      @@@Type: HASH
    @@Return:
      @@@Type: HASH
      @@@PerlDef:
        $obj->{<H::infoset|children>} = [];
        $obj->{<H::tc|revOwnerDocument>} = {};
        $obj->{<H::infoset|version>} = '1.0';
        __CODE{mg|setOwnerProp||ManakaiDOM|all::
          $bag => $bag,
          $ownerref => {$opt->{<H::tc|implementation>}},
          $ownee1hprop => {<H::tc|revImplementation>},
          $ownee => {$obj},
          $owner0prop => {<H::tc|implementation>},
        }__;
        $r = $obj;
  @mg:subnode1a: infoset|children
  @mg:ownee1h: tc|revOwnerDocument
  @mg:owner0: tc|implementation

  @CODE:
    @@QName: tc|createEmptyDocumentForTest
    @@PerlDef:
      my $impl;
      __CODE{tc|createImplForTest:: $impl => $impl}__;
      $doc = $impl-><M::c|DOMImplementation.createDocument>;

  @CODE:
    @@QName: tc|createEmptyDocumentForTestNoErr
    @@PerlDef:
      my $impl;
      __CODE{tc|createImplForTest:: $impl => $impl}__;
      $doc = $impl-><M::c|DOMImplementation.createDocument>;
      $doc-><AG::Document.domConfig>
          -><M::c|DOMConfiguration.setParameter>
              ('error-handler' => sub { });

  @CODE:
    @@QName: tc|createDocumentForTestDA
    @@PerlDef:
      my $impl;
      __CODE{tc|createImplForTest:: $impl => $impl}__;
      $doc = $impl-><M::c|DOMImplementation.createDocument>;
      $doc-><AG::Document.domConfig>
          -><M::c|DOMConfiguration.setParameter>
              (<Q::cfg|entity-reference-read-only> => false);
      $doc-><AG::Document.domConfig>
          -><M::c|DOMConfiguration.setParameter>
              (<Q::cfg|strict-document-children> => false);

  @CODE:
    @@QName: tc|createEmptyDocumentForTestER
    @@enDesc:
      Creates an empty document, entity references created
      from which are not read-only.
    @@PerlDef:
      my $impl;
      __CODE{tc|createImplForTest:: $impl => $impl}__;
      $doc = $impl-><M::c|DOMImplementation.createDocument>;
      $doc-><AG::Document.domConfig>
          -><M::c|DOMConfiguration.setParameter>
              (<Q::cfg|entity-reference-read-only> => false);

  @CAttr:
    @@Name: nodeType
    @@Type: unsignedShort
    @@dis:actualType: NodeType
    @@Get:
      @@@disDef:
        @@@@DISLang:constValue: Node.DOCUMENT_NODE

    @@Test:
      @@@QName: Document.nodeType.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        $test->id ('nodeType');
        $test->assert_num_equals
                 (actual_value => $doc-><AG::Node.nodeType>,
                  expected_value => <C::Node.DOCUMENT_NODE>);

  @Test:
    @@QName: Doc.prefix.test
    @@PerlDef:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
      $test->id ('get');
      $test->assert_null ($doc-><AG::Node.prefix>);
      $test->id ('set');
      $doc-><AS::Node.prefix> ('pre');
      $test->assert_null ($doc-><AG::Node.prefix>);

  @Test:
    @@QName: Document.parentNode.test
    @@PerlDef:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
      $test->assert_null ($doc-><AG::Node.parentNode>);

  @Test:
    @@QName: Document.isSameNode.1.test
    @@PerlDef:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

      $test->id ('same');
      $test->assert_equals ($doc, $doc);

      $test->id ('non-object.1');
      $test->assert_not_equals ($doc, 1);

      $test->id ('non-object.2');
      $test->assert_not_equals ($doc, {a => 2});

      my $doc2;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc2}__;

      $test->id ('diff');
      $test->assert_not_equals ($doc, $doc2);
  @L3Test:
    @@QName: Document.isSameNode.2.test
    @@PerlDef:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

      $test->id ('same');
      $test->assert_true ($doc-><M::Node.isSameNode> ($doc));

      my $doc2;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc2}__;

      $test->id ('diff');
      $test->assert_false ($doc-><M::Node.isSameNode> ($doc2));

  @LXTest:
    @@QName: Document.readOnly.test
    @@PerlDef:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

      $test->id ('default');
      $test->assert_false ($doc-><AG::Node.manakaiReadOnly>);

  @CMethod:
    @@Name: appendChild
    @@enDesc:
      Adds a node to the end of the list of children of the node.
      If that node is already in the tree, it is first removed.
    @@Param:
      @@@Name: newChild
      @@@Type: Node
      @@@enDesc:
        The node to add.
      @@@InCase:
        @@@@Type: DocumentFragment
        @@@@enDesc:
          The entire contents of the document fragment are
          moved into the child list of the node.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node added.  If the <P::newChild> node is a <IF::DocumentFragment>
        node, then the <P::newChild> node <kwd:MUST> be returned.
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_BAD_TYPE
        @@@@enDesc:
          If the node is of a type that does not allow children of
          the type of the <P::newChild> node.
 
          If the <A::Document.strictErrorChecking> is set to <DOM::false>,
          this exception <kwd:MAY-NOT> be thrown.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_SECOND_DOC_ELEMENT
        @@@@enDesc:
          If the node is of type <IF::Document> and an attempt
          is made to append a second <IF::DocumentType> node
          <SRC::DOM 3>.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_SECOND_DOCTYPE
        @@@@enDesc:
          If the node is of type <IF::Document> and an attempt
          is made to append a second <IF::x|DocumentType> node
          <SRC::DOM 3>.
      @@@dx:raises:
        @@@@@: c|HIERARCHY_WRONG_DOCTYPE_ERR
        @@@@enDesc:
          If the node is of type <IF::Document> and an attempt
          is made to append a <IF::x|DocumentType> node after
          an <IF::Element> node or an <IF::Element> node after
          a <IF::x|DocumentType>.
        @@@@enImplNote:
          Although such document type node is not prohibited
          by DOM specification, Firefox 1.5 and Opera 9 TP1
          throws an <X::c|DOMException.HIERARCHY_REQUEST_ERR>.
      @@@dx:raises:
        @@@@@: c|DIFFERENT_DOCUMENT_ERR
        @@@@enDesc:
          If the <P::newChild> node was created from a different
          document than the one to which the node was created or
          the node does not belong to any document.

          If the <A::Document.strictErrorChecking> is set to <DOM::false>,
          this exception <kwd:MAY-NOT> be thrown.
      @@@dx:raises: 
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the node is read-only.

          If the <A::Document.strictErrorChecking> is set to <DOM::false>,
          this exception <kwd:MAY-NOT> be thrown.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_SRC_PARENT
        @@@@enDesc:
          If the previous parent of the <P::newChild> node is read-only
          <SRC::DOM 2 Errata, DOM 3>.

          If the <A::Document.strictErrorChecking> is set to <DOM::false>,
          this exception <kwd:MAY-NOT> be thrown.
      @@@PerlDef:
        my $strictc = $self-><AG::Document.domConfig>
                           -><M::c|DOMConfiguration.getParameter>
                               (<Q::cfg|strict-document-children>);
        my $child_od = $newChild-><AG::Node.ownerDocument> || $self;
        my $child_nt = $newChild-><AG::Node.nodeType>;
        if ($strictc and $self-><AG::Document.strictErrorChecking>) {
          __DEEP{
            my $has_el;
            my $has_dt;
            if ($child_nt == <C::Node.ELEMENT_NODE>) {
              $has_el = true;
            } elsif ($child_nt == <C::Node.DOCUMENT_TYPE_NODE>) {
              $has_dt = true;
            } elsif ($child_nt == <C::Node.DOCUMENT_FRAGMENT_NODE>) {
              for my $cn (@{$newChild-><AG::Node.childNodes>}) {
                my $cnt = $cn-><AG::Node.nodeType>;
                if ($cnt == <C::Node.ELEMENT_NODE>) {
                  if ($has_el) {
                    __UNDEEP{__EXCEPTION{MDOMX|MDOM_SECOND_DOC_ELEMENT::
                      MDOMX|param-name => 'newChild',
                      c|node => {$newChild},
                    }__}__;
                  }
                  $has_el = true;
                }
                # DocumentType node cannot be contained in DocumentFragments
              }
            }
  
            if ($has_el) {
              my $anode = $self-><AG::Node.lastChild>;
              while (defined $anode) {
                if ($anode-><AG::Node.nodeType> == <C::Node.ELEMENT_NODE>) {
                  __UNDEEP{__EXCEPTION{MDOMX|MDOM_SECOND_DOC_ELEMENT::
                    MDOMX|param-name => 'newChild',
                    c|node => {$newChild},
                  }__}__;
                }
                $anode = $anode-><AG::Node.previousSibling>;
              }
            } # has_el
            if ($has_dt) {
              my $anode = $self-><AG::Node.lastChild>;
              while (defined $anode) {
                my $ant = $anode-><AG::Node.nodeType>;
                if ($ant == <C::Node.ELEMENT_NODE>) {
                  __UNDEEP{__EXCEPTION{c|HIERARCHY_WRONG_DOCTYPE_ERR::
                    MDOMX|param-name => 'newChild',
                    c|node => {$newChild},
                  }__}__;
                } elsif ($ant == <C::Node.DOCUMENT_TYPE_NODE>) {
                  __UNDEEP{__EXCEPTION{MDOMX|MDOM_SECOND_DOCTYPE::
                    MDOMX|param-name => 'newChild',
                    c|node => {$newChild},
                  }__}__;
                }
                $anode = $anode-><AG::Node.previousSibling>;
              }
            } # has_dt
          }__;
        }
        __CODE{tc|appendChildImpl1::
          $self => $self, $self_od => $self,
          $newChild => $newChild, $child_od => $child_od, $child_nt => $child_nt,
          $r => $r,
          $allowedNodeTypes => {{
            <C::Node.TEXT_NODE> => (not $strictc),
            <C::Node.ENTITY_REFERENCE_NODE> => (not $strictc),
            <C::Node.ELEMENT_NODE> => true,
            <C::Node.CDATA_SECTION_NODE> => (not $strictc),
            <C::Node.PROCESSING_INSTRUCTION_NODE> => true,
            <C::Node.COMMENT_NODE> => true,
            <C::Node.DOCUMENT_TYPE_NODE> => true,
          }},
        }__;
        if ($child_nt == <C::Node.DOCUMENT_TYPE_NODE> and
            not defined $newChild-><AG::Node.ownerDocument>) {
          __CODE{mg|deleteNodeStemPropValue||ManakaiDOM|all::
            $prop => {<H::tc|implementation>},
            $ref => $newChild,
          }__;
        }

  @CMethod:
    @@Name: insertBefore
    @@enDesc:
      Inserts a node before the existing child node of the node.

      Inserting a node before itself is implementation dependent.
    @@Param:
      @@@Name: newChild
      @@@Type: Node
      @@@enDesc:
        The node to insert.  If the <P::newChild> is already in 
        the tree, it is first removed.
      @@@InCase:
        @@@@Type: DocumentFragment
        @@@@enDesc:
          All of children of the <P::newChild> node are inserted,
          in the same order, before <P::refChild>.
    @@Param:
      @@@Name: refChild
      @@@Type: Node
      @@@enDesc:
        The reference node, i.e. the node before which the new node
        must be inserted.
      @@@nullCase:
        @@@@enDesc:
          The <P::newChild> node is inserted at the end of the list
          of children.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node being inserted.
      @@@enImplNote:
        What is returned if <P::newChild> is a <IF::DocumentFragment>?
        See also <M::Node.appendChild>'s return value.
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_BAD_TYPE
        @@@@enDesc:
          If the node is of a type that does not allow children of
          the type of the <P::newChild> node.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_SECOND_DOC_ELEMENT
        @@@@enDesc:
          If the node is of type <IF::Document> and an attempt
          is made to append a second <IF::DocumentType> node
          <SRC::DOM 3>.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_SECOND_DOCTYPE
        @@@@enDesc:
          If the node is of type <IF::Document> and an attempt
          is made to append a second <IF::x|DocumentType> node
          <SRC::DOM 3>.
      @@@dx:raises:
        @@@@@: c|HIERARCHY_WRONG_DOCTYPE_ERR
        @@@@enDesc:
          If the node is of type <IF::Document> and an attempt
          is made to append a <IF::x|DocumentType> node after
          an <IF::Element> node or an <IF::Element> node after
          a <IF::x|DocumentType>.
        @@@@enImplNote:
          Although such document type node is not prohibited
          by DOM specification, Firefox 1.5 and Opera 9 TP1
          throws an <X::c|DOMException.HIERARCHY_REQUEST_ERR>.
      @@@dx:raises:
        @@@@@: c|DIFFERENT_DOCUMENT_ERR
        @@@@enDesc:
          If the <P::newChild> node was created from a different
          document than the one that created the node.
        @@@@enImplNote:
          The DOM specification ignores the fact that <IF::Document>s
          and <IF::x|DocumentType>s are created from 
          <IF::c|DOMImplementation> :-)
      @@@dx:raises: 
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the node is read-only.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_SRC_PARENT
        @@@@enDesc:
          If the previous parent of the <P::newChild> node is read-only
          <SRC::DOM 1 SE, DOM 2, 3>.
      @@@dx:raises:
        @@@@@: c|NOT_CHILD_ERR
        @@@@enDesc:
          If the <P::refChild> node is not a child of the node.
      @@@c:reports:
        @@@@@: t|insert-before-itself
        @@@@enDesc:
          If the <P::newChild> node is same as the <P::refChild> node.
          Then, the result is implementation dependent.
        @@@@For: ManakaiDOM|ManakaiDOM
      @@@PerlDef:
        my $strictc = $self-><AG::Document.domConfig>
                           -><M::c|DOMConfiguration.getParameter>
                               (<Q::cfg|strict-document-children>);
        my $child_od = $newChild-><AG::Node.ownerDocument> || $self;
        my $child_nt = $newChild-><AG::Node.nodeType>;
        if ($strictc and $self-><AG::Document.strictErrorChecking>) {
          __DEEP{
            my $has_el;
            my $has_dt;
            if ($child_nt == <C::Node.ELEMENT_NODE>) {
              $has_el = true;
            } elsif ($child_nt == <C::Node.DOCUMENT_TYPE_NODE>) {
              $has_dt = true;
            } elsif ($child_nt == <C::Node.DOCUMENT_FRAGMENT_NODE>) {
              for my $cn (@{$newChild-><AG::Node.childNodes>}) {
                my $cnt = $cn-><AG::Node.nodeType>;
                if ($cnt == <C::Node.ELEMENT_NODE>) {
                  if ($has_el) {
                    __UNDEEP{__EXCEPTION{MDOMX|MDOM_SECOND_DOC_ELEMENT::
                      MDOMX|param-name => 'newChild',
                      c|node => {$newChild},
                    }__}__;
                  }
                  $has_el = true;
                }
                # DocumentType node cannot be contained in DocumentFragments
              }
            }
  
            if ($has_el) {
              my $anode = $refChild ? $refChild-><AG::Node.previousSibling>
                                    : $self-><AG::Node.lastChild>;
              while (defined $anode) {
                if ($anode-><AG::Node.nodeType> == <C::Node.ELEMENT_NODE>) {
                  __UNDEEP{__EXCEPTION{MDOMX|MDOM_SECOND_DOC_ELEMENT::
                    MDOMX|param-name => 'newChild',
                    c|node => {$newChild},
                  }__}__;
                }
                $anode = $anode-><AG::Node.previousSibling>;
              }
              $anode = $refChild;
              while (defined $anode) {
                my $ant = $anode-><AG::Node.nodeType>;
                if ($ant == <C::Node.ELEMENT_NODE>) {
                  __UNDEEP{__EXCEPTION{MDOMX|MDOM_SECOND_DOC_ELEMENT::
                    MDOMX|param-name => 'newChild',
                    c|node => {$newChild},
                  }__}__;
                } elsif ($ant == <C::Node.DOCUMENT_TYPE_NODE>) {
                  __UNDEEP{__EXCEPTION{c|HIERARCHY_WRONG_DOCTYPE_ERR::
                    MDOMX|param-name => 'newChild',
                    c|node => {$newChild},
                  }__}__;
                }
                $anode = $anode-><AG::Node.nextSibling>;
              }
            } # has_el
            if ($has_dt) {
              my $anode = $refChild ? $refChild-><AG::Node.previousSibling>
                                    : $self-><AG::Node.lastChild>;
              while (defined $anode) {
                my $ant = $anode-><AG::Node.nodeType>;
                if ($ant == <C::Node.ELEMENT_NODE>) {
                  __UNDEEP{__EXCEPTION{c|HIERARCHY_WRONG_DOCTYPE_ERR::
                    MDOMX|param-name => 'newChild',
                    c|node => {$newChild},
                  }__}__;
                } elsif ($ant == <C::Node.DOCUMENT_TYPE_NODE>) {
                  __UNDEEP{__EXCEPTION{MDOMX|MDOM_SECOND_DOCTYPE::
                    MDOMX|param-name => 'newChild',
                    c|node => {$newChild},
                  }__}__;
                }
                $anode = $anode-><AG::Node.previousSibling>;
              }
              $anode = $refChild;
              while (defined $anode) {
                if ($anode-><AG::Node.nodeType>
                        == <C::Node.DOCUMENT_TYPE_NODE>) {
                  __UNDEEP{__EXCEPTION{MDOMX|MDOM_SECOND_DOCTYPE::
                    MDOMX|param-name => 'newChild',
                    c|node => {$newChild},
                  }__}__;
                }
                $anode = $anode-><AG::Node.nextSibling>;
              }
            } # has_dt
          }__;
        }
        __CODE{tc|insertBeforeImpl1::
          $self => $self, $self_od => $self,
          $newChild => $newChild, $refChild => $refChild,
          $child_od => $child_od, $child_nt => $child_nt,
          $r => $r,
          $allowedNodeTypes => {{
            <C::Node.TEXT_NODE> => (not $strictc),
            <C::Node.ENTITY_REFERENCE_NODE> => (not $strictc),
            <C::Node.ELEMENT_NODE> => true,
            <C::Node.CDATA_SECTION_NODE> => (not $strictc),
            <C::Node.PROCESSING_INSTRUCTION_NODE> => true,
            <C::Node.COMMENT_NODE> => true,
            <C::Node.DOCUMENT_TYPE_NODE> => true,
          }},
        }__;
        if ($child_nt == <C::Node.DOCUMENT_TYPE_NODE> and
            not defined $newChild-><AG::Node.ownerDocument>) {
          __CODE{mg|deleteNodeStemPropValue||ManakaiDOM|all::
            $prop => {<H::tc|implementation>},
            $ref => $newChild,
          }__;
        }

  @CMethod:
    @@Name: replaceChild
    @@enDesc:
      Replaces a child node with another node.

      Replacing a node with itself is implementation dependent <SRC::DOM3>.
    @@Param:
      @@@Name: newChild
      @@@Type: Node
      @@@enDesc:
        The new node to put in the child list.

        If the <P::newChild> node is already in the tree,
        it is first removed.
      @@@InCase:
        @@@@Type: DocumentFragment
        @@@@enDesc:
          The <P::oldChild> node is replaced by all of the 
          <IF::DocumentFragment> children, which are inserted
          in the same order <SRC::DOM1 SE, DOM2, DOM3>.
    @@Param:
      @@@Name: oldChild
      @@@Type: Node
      @@@enDesc:
        The node being replaced in the list.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node replaced.
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_BAD_TYPE
        @@@@enDesc:
          If the node is of a type that does not allow children of
          the type of the <P::newChild> node.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_SECOND_DOC_ELEMENT
        @@@@enDesc:
          If the node is of type <IF::Document> and an attempt
          is made to append a second <IF::DocumentType> node
          <SRC::DOM 3>.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_SECOND_DOCTYPE
        @@@@enDesc:
          If the node is of type <IF::Document> and an attempt
          is made to append a second <IF::x|DocumentType> node
          <SRC::DOM 3>.
      @@@dx:raises:
        @@@@@: c|HIERARCHY_WRONG_DOCTYPE_ERR
        @@@@enDesc:
          If the node is of type <IF::Document> and an attempt
          is made to append a <IF::x|DocumentType> node after
          an <IF::Element> node or an <IF::Element> node after
          a <IF::x|DocumentType>.
        @@@@enImplNote:
          Although such document type node is not prohibited
          by DOM specification, Firefox 1.5 and Opera 9 TP1
          throws an <X::c|DOMException.HIERARCHY_REQUEST_ERR>.
      @@@dx:raises:
        @@@@@: c|DIFFERENT_DOCUMENT_ERR
        @@@@enDesc:
          If the <P::newChild> node was created from a different
          document than the one that created the node.
        @@@@enImplNote:
          The DOM specification ignores the fact that <IF::Document>s
          and <IF::x|DocumentType>s are created from 
          <IF::c|DOMImplementation> :-)
      @@@dx:raises: 
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the node is read-only.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_SRC_PARENT
        @@@@enDesc:
          If the previous parent of the <P::newChild> node is read-only
          <SRC::DOM1 SE, DOM2, DOM3>.
      @@@dx:raises:
        @@@@@: c|NOT_CHILD_ERR
        @@@@enDesc:
          If the <P::oldChild> node is not a child of the node.
      @@@c:reports:
        @@@@@: t|replaced-by-itself
        @@@@enDesc:
          If the <P::newChild> node is same as the <P::oldChild> node.
          Then, the result is implementation dependent.
        @@@@For: ManakaiDOM|ManakaiDOM
      @@@PerlDef:
        my $strictc = $self-><AG::Document.domConfig>
                           -><M::c|DOMConfiguration.getParameter>
                               (<Q::cfg|strict-document-children>);
        my $child_od = $newChild-><AG::Node.ownerDocument> || $self;
        my $child_nt = $newChild-><AG::Node.nodeType>;
        if ($strictc and $self-><AG::Document.strictErrorChecking>) {
          __DEEP{
            my $has_el;
            my $has_dt;
            if ($child_nt == <C::Node.ELEMENT_NODE>) {
              $has_el = true;
            } elsif ($child_nt == <C::Node.DOCUMENT_TYPE_NODE>) {
              $has_dt = true;
            } elsif ($child_nt == <C::Node.DOCUMENT_FRAGMENT_NODE>) {
              for my $cn (@{$newChild-><AG::Node.childNodes>}) {
                my $cnt = $cn-><AG::Node.nodeType>;
                if ($cnt == <C::Node.ELEMENT_NODE>) {
                  if ($has_el) {
                    __UNDEEP{__EXCEPTION{MDOMX|MDOM_SECOND_DOC_ELEMENT::
                      MDOMX|param-name => 'newChild',
                      c|node => {$newChild},
                    }__}__;
                  }
                  $has_el = true;
                }
                # DocumentType node cannot be contained in DocumentFragments
              }
            }
  
            if ($has_el) {
              my $anode = $oldChild-><AG::Node.previousSibling>;
              while (defined $anode) {
                if ($anode-><AG::Node.nodeType> == <C::Node.ELEMENT_NODE>) {
                  __UNDEEP{__EXCEPTION{MDOMX|MDOM_SECOND_DOC_ELEMENT::
                    MDOMX|param-name => 'newChild',
                    c|node => {$newChild},
                  }__}__;
                }
                $anode = $anode-><AG::Node.previousSibling>;
              }
              $anode = $oldChild-><AG::Node.nextSibling>;
              while (defined $anode) {
                my $ant = $anode-><AG::Node.nodeType>;
                if ($ant == <C::Node.ELEMENT_NODE>) {
                  __UNDEEP{__EXCEPTION{MDOMX|MDOM_SECOND_DOC_ELEMENT::
                    MDOMX|param-name => 'newChild',
                    c|node => {$newChild},
                  }__}__;
                } elsif ($ant == <C::Node.DOCUMENT_TYPE_NODE>) {
                  __UNDEEP{__EXCEPTION{c|HIERARCHY_WRONG_DOCTYPE_ERR::
                    MDOMX|param-name => 'newChild',
                    c|node => {$newChild},
                  }__}__;
                }
                $anode = $anode-><AG::Node.nextSibling>;
              }
            } # has_el
            if ($has_dt) {
              my $anode = $oldChild-><AG::Node.previousSibling>;
              while (defined $anode) {
                my $ant = $anode-><AG::Node.nodeType>;
                if ($ant == <C::Node.ELEMENT_NODE>) {
                  __UNDEEP{__EXCEPTION{c|HIERARCHY_WRONG_DOCTYPE_ERR::
                    MDOMX|param-name => 'newChild',
                    c|node => {$newChild},
                  }__}__;
                } elsif ($ant == <C::Node.DOCUMENT_TYPE_NODE>) {
                  __UNDEEP{__EXCEPTION{MDOMX|MDOM_SECOND_DOCTYPE::
                    MDOMX|param-name => 'newChild',
                    c|node => {$newChild},
                  }__}__;
                }
                $anode = $anode-><AG::Node.previousSibling>;
              }
              $anode = $oldChild-><AG::Node.nextSibling>;
              while (defined $anode) {
                if ($anode-><AG::Node.nodeType>
                        == <C::Node.DOCUMENT_TYPE_NODE>) {
                  __UNDEEP{__EXCEPTION{MDOMX|MDOM_SECOND_DOCTYPE::
                    MDOMX|param-name => 'newChild',
                    c|node => {$newChild},
                  }__}__;
                }
                $anode = $anode-><AG::Node.nextSibling>;
              }
            } # has_dt
          }__;
        }
        __CODE{tc|replaceChildImpl1::
          $self => $self, $self_od => $self,
          $newChild => $newChild, $refChild => $oldChild,
          $child_od => $child_od, $child_nt => $child_nt,
          $r => $r,
          $allowedNodeTypes => {{
            <C::Node.TEXT_NODE> => (not $strictc),
            <C::Node.ENTITY_REFERENCE_NODE> => (not $strictc),
            <C::Node.ELEMENT_NODE> => true,
            <C::Node.CDATA_SECTION_NODE> => (not $strictc),
            <C::Node.PROCESSING_INSTRUCTION_NODE> => true,
            <C::Node.COMMENT_NODE> => true,
            <C::Node.DOCUMENT_TYPE_NODE> => true,
          }},
        }__;
        if ($child_nt == <C::Node.DOCUMENT_TYPE_NODE> and
            not defined $newChild-><AG::Node.ownerDocument>) {
          __CODE{mg|deleteNodeStemPropValue||ManakaiDOM|all::
            $prop => {<H::tc|implementation>},
            $ref => $newChild,
          }__;
        }

    @@Test:
      @@@QName: Document.appendChild.1.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;

        my $dtd = $doc;
        my $pi = $doc-><M::Document.createTextNode> ('pi');

        my $return = $dtd-><M::Node.appendChild> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);

    @@Test:
      @@@QName: Document.appendChild.1.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;
        my $pi = $doc-><M::Document.createEntityReference> ('pi');

        my $return = $dtd-><M::Node.appendChild> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|EntityReference>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: Document.appendChild.1.3.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;
        my $pi = $doc-><M::Document.createElement> ('pi');

        my $return = $dtd-><M::Node.appendChild> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Element>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: Document.appendChild.1.4.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;
        my $pi = $doc-><M::Document.createProcessingInstruction> ('pi');

        my $return = $dtd-><M::Node.appendChild> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|ProcessingInstruction>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: Document.appendChild.1.5.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;
        my $pi = $doc-><M::Document.createCDATASection> ('pi');

        my $return = $dtd-><M::Node.appendChild> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|CDATASection>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: Document.appendChild.1.6.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;
        my $pi = $doc-><M::Document.createComment> ('pi');

        my $return = $dtd-><M::Node.appendChild> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Comment>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: Document.appendChild.1.7.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;
        my $pi = $docx-><M::d|DocumentXDoctype.createDocumentTypeDefinition>
                          ('pi');

        my $return = $dtd-><M::Node.appendChild> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|DocumentType>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: Document.insertBefore.1.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;
        my $pi = $doc-><M::Document.createTextNode> ('pi');

        my $return = $dtd-><M::Node.insertBefore> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: Document.insertBefore.1.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;
        my $pi = $doc-><M::Document.createEntityReference> ('pi');

        my $return = $dtd-><M::Node.insertBefore> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|EntityReference>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: Document.insertBefore.1.3.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;
        my $pi = $doc-><M::Document.createElement> ('pi');

        my $return = $dtd-><M::Node.insertBefore> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Element>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: Document.insertBefore.1.4.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;
        my $pi = $doc-><M::Document.createProcessingInstruction> ('pi');

        my $return = $dtd-><M::Node.insertBefore> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|ProcessingInstruction>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: Document.insertBefore.1.5.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;
        my $pi = $doc-><M::Document.createCDATASection> ('pi');

        my $return = $dtd-><M::Node.insertBefore> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|CDATASection>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: Document.insertBefore.1.6.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;
        my $pi = $doc-><M::Document.createComment> ('pi');

        my $return = $dtd-><M::Node.insertBefore> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Comment>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: Document.insertBefore.1.7.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;
        my $pi = $docx-><M::d|DocumentXDoctype.createDocumentTypeDefinition>
                          ('pi');

        my $return = $dtd-><M::Node.insertBefore> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|DocumentType>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);

    @@Test:
      @@@QName: Document.appendChild.has.parent.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;

        my $piparent = $doc-><M::Document.createElementNS> (null, 'e');
        my $pi = $doc-><M::Document.createTextNode> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.appendChild> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: Document.appendChild.has.parent.1.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;

        my $piparent = $doc-><M::Document.createElementNS> (null, 'e');
        my $pi = $doc-><M::Document.createEntityReference> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.appendChild> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|EntityReference>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: Document.insertBefore.has.parent.1.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;

        my $piparent = $doc-><M::Document.createElementNS> (null, 'e');
        my $pi = $doc-><M::Document.createTextNode> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.insertBefore> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: Document.insertBefore.has.parent.1.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;

        my $piparent = $doc-><M::Document.createElementNS> (null, 'e');
        my $pi = $doc-><M::Document.createEntityReference> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.insertBefore> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|EntityReference>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi);

    @@Test:
      @@@QName: Document.appendChild.documentfragment.1.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createTextNode> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.appendChild> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: Document.appendChild.documentfragment.1.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createEntityReference> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.appendChild> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|EntityReference>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: Document.insertBefore.documentfragment.1.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createTextNode> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.insertBefore> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: Document.insertBefore.documentfragment.1.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createEntityReference> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.insertBefore> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|EntityReference>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: Document.replaceChild.documentfragment.1.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;
        my $pi0 = $doc-><M::Document.createTextNode> ('pi0');
        $dtd-><M::Node.appendChild> ($pi0);

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createTextNode> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.replaceChild> ($piparent, $pi0);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi0);
    @@Test:
      @@@QName: Document.replaceChild.documentfragment.1.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;
        my $pi0 = $doc-><M::Document.createTextNode> ('pi0');
        $dtd-><M::Node.appendChild> ($pi0);

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createEntityReference> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.replaceChild> ($piparent, $pi0);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|EntityReference>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi0);

    @@Test:
      @@@QName: Document.appendChild.documentfragment.2.1.test
      @@@enDesc:
        Empty document fragment.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;

        my $piparent = $doc-><M::Document.createDocumentFragment>;

        my $return = $dtd-><M::Node.appendChild> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 0);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: Document.insertBefore.documentfragment.2.test
      @@@enDesc:
        Empty document fragment.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;

        my $piparent = $doc-><M::Document.createDocumentFragment>;

        my $return = $dtd-><M::Node.insertBefore> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 0);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: Document.replaceChild.documentfragment.2.test
      @@@enDesc:
        Empty document fragment.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;
        my $pi0 = $doc-><M::Document.createTextNode> ('pi0');
        $dtd-><M::Node.appendChild> ($pi0);

        my $piparent = $doc-><M::Document.createDocumentFragment>;

        my $return = $dtd-><M::Node.replaceChild> ($piparent, $pi0);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 0);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi0);

    @@Test:
      @@@QName: Document.appendChild.documentfragment.3.test
      @@@enDesc:
        Three PIs in document fragment.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createTextNode> ('pi');
        my $pi2 = $doc-><M::Document.createEntityReference> ('pi2');
        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $piparent-><M::Node.appendChild> ($pi);
        $piparent-><M::Node.appendChild> ($pi2);
        $piparent-><M::Node.appendChild> ($pi3);

        my $return = $dtd-><M::Node.appendChild> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 3);

        my $item = $child-><M::NodeList.item> (0);
        my $item2 = $child-><M::NodeList.item> (1);
        my $item3 = $child-><M::NodeList.item> (2);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);
        $test->id ('child.item.node2');
        $test->assert_isa ($item2, <IFName::Node>);
        $test->id ('child.item.node3');
        $test->assert_isa ($item3, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);
        $test->id ('child.item.pi2');
        $test->assert_isa ($item2, <IFName::tx|EntityReference>);
        $test->id ('child.item.pi3');
        $test->assert_isa ($item3, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);
        $test->id ('child.item.equals2');
        $test->assert_equals ($item2, $pi2);
        $test->id ('child.item.equals3');
        $test->assert_equals ($item3, $pi3);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi3);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);
        $test->id ('parent2');
        my $parent2 = $item2-><AG::Node.parentNode>;
        $test->assert_equals ($parent2, $dtd);
        $test->id ('parent3');
        my $parent3 = $item3-><AG::Node.parentNode>;
        $test->assert_equals ($parent3, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: Document.insertBefore.documentfragment.3.test
      @@@enDesc:
        Three PIs in document fragment.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createTextNode> ('pi');
        my $pi2 = $doc-><M::Document.createEntityReference> ('pi2');
        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $piparent-><M::Node.appendChild> ($pi);
        $piparent-><M::Node.appendChild> ($pi2);
        $piparent-><M::Node.appendChild> ($pi3);

        my $return = $dtd-><M::Node.insertBefore> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 3);

        my $item = $child-><M::NodeList.item> (0);
        my $item2 = $child-><M::NodeList.item> (1);
        my $item3 = $child-><M::NodeList.item> (2);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);
        $test->id ('child.item.node2');
        $test->assert_isa ($item2, <IFName::Node>);
        $test->id ('child.item.node3');
        $test->assert_isa ($item3, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);
        $test->id ('child.item.pi2');
        $test->assert_isa ($item2, <IFName::tx|EntityReference>);
        $test->id ('child.item.pi3');
        $test->assert_isa ($item3, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);
        $test->id ('child.item.equals2');
        $test->assert_equals ($item2, $pi2);
        $test->id ('child.item.equals3');
        $test->assert_equals ($item3, $pi3);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi3);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);
        $test->id ('parent2');
        my $parent2 = $item2-><AG::Node.parentNode>;
        $test->assert_equals ($parent2, $dtd);
        $test->id ('parent3');
        my $parent3 = $item3-><AG::Node.parentNode>;
        $test->assert_equals ($parent3, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: Document.replaceChild.documentfragment.3.test
      @@@enDesc:
        Three PIs in document fragment.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;
        my $pi0 = $doc-><M::Document.createTextNode> ('pi0');
        $dtd-><M::Node.appendChild> ($pi0);

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createTextNode> ('pi');
        my $pi2 = $doc-><M::Document.createEntityReference> ('pi2');
        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $piparent-><M::Node.appendChild> ($pi);
        $piparent-><M::Node.appendChild> ($pi2);
        $piparent-><M::Node.appendChild> ($pi3);

        my $return = $dtd-><M::Node.replaceChild> ($piparent, $pi0);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 3);

        my $item = $child-><M::NodeList.item> (0);
        my $item2 = $child-><M::NodeList.item> (1);
        my $item3 = $child-><M::NodeList.item> (2);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);
        $test->id ('child.item.node2');
        $test->assert_isa ($item2, <IFName::Node>);
        $test->id ('child.item.node3');
        $test->assert_isa ($item3, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);
        $test->id ('child.item.pi2');
        $test->assert_isa ($item2, <IFName::tx|EntityReference>);
        $test->id ('child.item.pi3');
        $test->assert_isa ($item3, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);
        $test->id ('child.item.equals2');
        $test->assert_equals ($item2, $pi2);
        $test->id ('child.item.equals3');
        $test->assert_equals ($item3, $pi3);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi3);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);
        $test->id ('parent2');
        my $parent2 = $item2-><AG::Node.parentNode>;
        $test->assert_equals ($parent2, $dtd);
        $test->id ('parent3');
        my $parent3 = $item3-><AG::Node.parentNode>;
        $test->assert_equals ($parent3, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi0);

    @@Test:
      @@@QName: Document.appendChild.badtype.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $comment = $doc;
        my $pi0 = $doc-><M::Document.createTextNode> ('pi0');
        $comment-><M::Node.appendChild> ($pi0);

        for my $node (
          $doc-><M::Document.createAttribute> ('a'),
          $docx-><M::d|DocumentXDoctype.createGeneralEntity> ('ge'),
          $docx-><M::d|DocumentXDoctype.createNotation> ('not'),
          $docx-><M::d|DocumentXDoctype.createElementTypeDefinition> ('et'),
          $docx-><M::d|DocumentXDoctype.createAttributeDefinition> ('at'),
          #test:nodeTypes
        ) {
          $test->id ('appendChild.'.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.appendChild> ($node);
          }, exception_subtype => <Q::MDOMX|HIERARCHY_BAD_TYPE>);

          $test->id ('insertBefore.'.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.insertBefore> ($node);
          }, exception_subtype => <Q::MDOMX|HIERARCHY_BAD_TYPE>);

          $test->id ('replaceChild.'.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.replaceChild> ($node, $pi0);
          }, exception_subtype => <Q::MDOMX|HIERARCHY_BAD_TYPE>);
        }

    @@Test:
      @@@QName: Document.appendChild.wrongdoc.test
      @@@PerlDef:
        my $doc0;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc0}__;
        my $docx0 = $doc0-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $comment = $doc0;

        for my $node (
          $doc-><M::Document.createTextNode> ('pi'),
          $doc-><M::Document.createEntityReference> ('e'),
          $doc-><M::Document.createComment> ('c'),
          $doc-><M::Document.createCDATASection> ('cs'),
          $doc-><M::Document.createProcessingInstruction> ('pi'),
          $doc-><M::Document.createElement> ('el'),
          $docx-><M::d|DocumentXDoctype.createDocumentTypeDefinition> ('del'),
        ) {
          $test->id ('type='.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.appendChild> ($node);
          }, exception_subtype => <Q::c|DIFFERENT_DOCUMENT_ERR>);
        }
    @@Test:
      @@@QName: Document.insertBefore.wrongdoc.test
      @@@PerlDef:
        my $doc0;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc0}__;
        my $docx0 = $doc0-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $comment = $doc0;
        my $pi0 = $doc0-><M::Document.createTextNode> ('pi0');
        $comment-><M::Node.appendChild> ($pi0);

        for my $node (
          $doc-><M::Document.createTextNode> ('pi'),
          $doc-><M::Document.createEntityReference> ('ent'),
          $doc-><M::Document.createComment> ('c'),
          $doc-><M::Document.createCDATASection> ('cs'),
          $doc-><M::Document.createProcessingInstruction> ('pi'),
          $doc-><M::Document.createElement> ('el'),
          $docx-><M::d|DocumentXDoctype.createDocumentTypeDefinition> ('del'),
        ) {
          $test->id ('appendChild.'.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.appendChild> ($node);
          }, exception_subtype => <Q::c|DIFFERENT_DOCUMENT_ERR>);

          $test->id ('insertBefore.'.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.insertBefore> ($node);
          }, exception_subtype => <Q::c|DIFFERENT_DOCUMENT_ERR>);

          $test->id ('replaceChild.'.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.replaceChild> ($node, $pi0);
          }, exception_subtype => <Q::c|DIFFERENT_DOCUMENT_ERR>);
        }

    @@Test:
      @@@QName: Document.appendChild.readonly.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;
        my $pi0 = $doc-><M::Document.createTextNode> ('pi0');
        $dtd-><M::Node.appendChild> ($pi0);
        $dtd-><M::Node.manakaiSetReadOnly> (true);

        $test->id ('pi');
        my $node = $doc-><M::Document.createTextNode> ('pi');

        $test->assert_exception (code => sub {
          $dtd-><M::Node.appendChild> ($node);
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);

        $test->id ('pi.insertBefore');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.insertBefore> ($node);
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);

        $test->id ('pi.replaceChild');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.replaceChild> ($node, $pi0);
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);

        $test->id ('fragment');
        my $node2 = $doc-><M::Document.createDocumentFragment>;
        $node2-><M::Node.appendChild> ($node);

        $test->assert_exception (code => sub {
          $dtd-><M::Node.appendChild> ($node2);
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);

        $test->id ('fragment.insertBefore');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.insertBefore> ($node2);
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);

        $test->id ('fragment.replaceChild');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.replaceChild> ($node2, $pi0);
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);

    @@Test:
      @@@QName: Document.appendChild.readonly.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;
        my $pi0 = $doc-><M::Document.createTextNode> ('pi0');
        $dtd-><M::Node.appendChild> ($pi0);

        $test->id ('pi');
        my $el = $doc-><M::Document.createElementNS> (null, 'e');
        my $node = $doc-><M::Document.createTextNode> ('pi');
        $el-><M::Node.appendChild> ($node);
        $el-><M::Node.manakaiSetReadOnly> (true);

        $test->assert_exception (code => sub {
          $dtd-><M::Node.appendChild> ($node);
        }, exception_subtype => <Q::MDOMX|NOMOD_SRC_PARENT>);

        $test->id ('pi.insertBefore');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.insertBefore> ($node);
        }, exception_subtype => <Q::MDOMX|NOMOD_SRC_PARENT>);

        $test->id ('pi.replaceChild');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.replaceChild> ($node, $pi0);
        }, exception_subtype => <Q::MDOMX|NOMOD_SRC_PARENT>);

        $test->id ('fragment');
        my $node2 = $doc-><M::Document.createDocumentFragment>;
        my $node3 = $doc-><M::Document.createTextNode> ('pi');
        $node2-><M::Node.appendChild> ($node3);
        $node2-><M::Node.manakaiSetReadOnly> (true);

        $test->assert_exception (code => sub {
          $dtd-><M::Node.appendChild> ($node2);
        }, exception_subtype => <Q::MDOMX|NOMOD_SRC_PARENT>);

        $test->id ('fragment.insertBefore');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.insertBefore> ($node2);
        }, exception_subtype => <Q::MDOMX|NOMOD_SRC_PARENT>);

        $test->id ('fragment.replaceChild');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.replaceChild> ($node2, $pi0);
        }, exception_subtype => <Q::MDOMX|NOMOD_SRC_PARENT>);

    @@Test:
      @@@QName: Document.insertBefore.refChild.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.insertBefore> ($pi2, $pi1);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi2);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi1);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: Document.insertBefore.refChild.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $dtd-><M::Node.insertBefore> ($pi3, $pi2);

        # pi1, pi3, pi2

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi1);

        $test->id ('firstChild.nextSibling');
        $test->assert_equals ($dtd-><AG::Node.firstChild>
                                  -><AG::Node.nextSibling>, $pi3);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi2);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 3);

    @@Test:
      @@@QName: Document.insertBefore.refChild.3.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $dtd-><M::Node.appendChild> ($pi3);

        # pi1, pi2, pi3

        $dtd-><M::Node.insertBefore> ($pi2, $pi1);
 
        # pi2, pi1, pi3

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi2);

        $test->id ('firstChild.nextSibling');
        $test->assert_equals ($dtd-><AG::Node.firstChild>
                                  -><AG::Node.nextSibling>, $pi1);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi3);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 3);

    @@Test:
      @@@QName: Document.insertBefore.refChild.4.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $dtd-><M::Node.appendChild> ($pi3);

        # pi1, pi2, pi3

        $dtd-><M::Node.insertBefore> ($pi3, $pi1);
 
        # pi3, pi1, pi2

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi3);

        $test->id ('firstChild.nextSibling');
        $test->assert_equals ($dtd-><AG::Node.firstChild>
                                  -><AG::Node.nextSibling>, $pi1);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi2);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 3);

    @@Test:
      @@@QName: Document.insertBefore.refChild.not_found_err.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');

        my $pi4 = $doc-><M::Document.createTextNode> ('pi4');

        # pi1, pi2

        $test->assert_exception (code => sub {
          $dtd-><M::Node.insertBefore> ($pi4, $pi3);
        }, exception_subtype => <Q::c|NOT_CHILD_ERR>);

    @@Test:
      @@@QName: Document.insertBefore.refChild=newChild.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        # pi1, pi2

        my $eh_called = false;
        my $cfg = $doc-><AG::Document.domConfig>;
        $cfg-><M::c|DOMConfiguration.setParameter> ('error-handler' => sub {
          my (undef, $err) = @_;
          $eh_called = true;
          $test->assert_equals ($err-><AG::c|DOMError.severity>,
                                <C::c|DOMError.SEVERITY_WARNING>);
          $test->assert_equals ($err-><AG::c|DOMError.type>,
                                <Q::t|insert-before-itself>);
          $test->assert_equals ($err-><AG::c|DOMError.relatedData>, $pi2);
          $test->assert_null ($err-><AG::c|DOMError.relatedException>);
          $test->assert_isa ($err-><AG::c|DOMError.location>,
                             <IFName::c|DOMLocator>);
          $test->assert_not_null ($err-><AG::c|DOMError.message>);
        });

        $test->assert_false ($eh_called);
        $dtd-><M::Node.insertBefore> ($pi2, $pi2);
        $test->assert_true ($eh_called);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi1);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi2);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: Document.replaceChild.oldChild=newChild.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        # pi1, pi2

        my $eh_called = false;
        my $cfg = $doc-><AG::Document.domConfig>;
        $cfg-><M::c|DOMConfiguration.setParameter> ('error-handler' => sub {
          my (undef, $err) = @_;
          $eh_called = true;
          $test->assert_equals ($err-><AG::c|DOMError.severity>,
                                <C::c|DOMError.SEVERITY_WARNING>);
          $test->assert_equals ($err-><AG::c|DOMError.type>,
                                <Q::t|replace-by-itself>);
          $test->assert_equals ($err-><AG::c|DOMError.relatedData>, $pi2);
          $test->assert_null ($err-><AG::c|DOMError.relatedException>);
          $test->assert_isa ($err-><AG::c|DOMError.location>,
                             <IFName::c|DOMLocator>);
          $test->assert_not_null ($err-><AG::c|DOMError.message>);
        });

        $test->assert_false ($eh_called);
        $dtd-><M::Node.replaceChild> ($pi2, $pi2);
        $test->assert_true ($eh_called);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi1);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi2);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: Document.appendChild.sameparent.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        # pi1, pi2

        my $return = $dtd-><M::Node.appendChild> ($pi1);

        # pi2, pi1

        $test->id ('return');
        $test->assert_equals ($return, $pi1);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi2);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi1);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: Document.insertBefore.sameparent.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        # pi1, pi2

        my $return = $dtd-><M::Node.insertBefore> ($pi1);

        # pi2, pi1

        $test->id ('return');
        $test->assert_equals ($return, $pi1);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi2);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi1);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: Document.appendChild.sameparent.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        # pi1, pi2

        my $return = $dtd-><M::Node.appendChild> ($pi2);

        # pi1, pi2

        $test->id ('return');
        $test->assert_equals ($return, $pi2);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi1);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi2);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: Document.insertBefore.sameparent.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        # pi1, pi2

        my $return = $dtd-><M::Node.insertBefore> ($pi2);

        # pi1, pi2

        $test->id ('return');
        $test->assert_equals ($return, $pi2);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi1);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi2);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: Document.replaceChild.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $dtd-><M::Node.appendChild> ($pi3);

        # pi1, pi2, pi3

        my $pi9 = $doc-><M::Document.createTextNode> ('pi9');
        my $return = $dtd-><M::Node.replaceChild> ($pi9, $pi1);

        # pi9, pi2, pi3

        $test->id ('return.node');
        $test->assert_isa ($return, <IFName::Node>);
        $test->id ('return.pi');
        $test->assert_isa ($return, <IFName::Text>);
        $test->id ('return');
        $test->assert_equals ($return, $pi1);

        my $c = $dtd-><AG::Node.childNodes>;

        $test->id ('length');
        $test->assert_num_equals (actual_value => 0+@$c, expected_value => 3);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi9);

        $test->id ('firstChild.nextSibling');
        $test->assert_equals ($dtd-><AG::Node.firstChild>
                                  -><AG::Node.nextSibling>, $pi2);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi3);
 
        $test->id ('parent');
        $test->assert_equals ($pi9-><AG::Node.parentNode>, $dtd);

        $test->id ('return.parent');
        $test->assert_null ($pi1-><AG::Node.parentNode>);

    @@Test:
      @@@QName: Document.replaceChild.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $dtd-><M::Node.appendChild> ($pi3);

        # pi1, pi2, pi3

        my $pi9 = $doc-><M::Document.createTextNode> ('pi9');
        my $return = $dtd-><M::Node.replaceChild> ($pi9, $pi2);

        # pi1, pi9, pi3

        $test->id ('return.node');
        $test->assert_isa ($return, <IFName::Node>);
        $test->id ('return.pi');
        $test->assert_isa ($return, <IFName::Text>);
        $test->id ('return');
        $test->assert_equals ($return, $pi2);

        my $c = $dtd-><AG::Node.childNodes>;

        $test->id ('length');
        $test->assert_num_equals (actual_value => 0+@$c, expected_value => 3);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi1);

        $test->id ('firstChild.nextSibling');
        $test->assert_equals ($dtd-><AG::Node.firstChild>
                                  -><AG::Node.nextSibling>, $pi9);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi3);
 
        $test->id ('parent');
        $test->assert_equals ($pi9-><AG::Node.parentNode>, $dtd);

        $test->id ('return.parent');
        $test->assert_null ($pi2-><AG::Node.parentNode>);

    @@Test:
      @@@QName: Document.replaceChild.3.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $dtd-><M::Node.appendChild> ($pi3);

        # pi1, pi2, pi3

        my $pi9 = $doc-><M::Document.createTextNode> ('pi9');
        my $return = $dtd-><M::Node.replaceChild> ($pi9, $pi3);

        # pi1, pi2, pi9

        $test->id ('return.node');
        $test->assert_isa ($return, <IFName::Node>);
        $test->id ('return.pi');
        $test->assert_isa ($return, <IFName::Text>);
        $test->id ('return');
        $test->assert_equals ($return, $pi3);

        my $c = $dtd-><AG::Node.childNodes>;

        $test->id ('length');
        $test->assert_num_equals (actual_value => 0+@$c, expected_value => 3);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi1);

        $test->id ('firstChild.nextSibling');
        $test->assert_equals ($dtd-><AG::Node.firstChild>
                                  -><AG::Node.nextSibling>, $pi2);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi9);
 
        $test->id ('parent');
        $test->assert_equals ($pi9-><AG::Node.parentNode>, $dtd);

        $test->id ('return.parent');
        $test->assert_null ($pi3-><AG::Node.parentNode>);

    @@Test:
      @@@QName: Document.replaceChild.sameparent.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $dtd-><M::Node.appendChild> ($pi3);

        # pi1, pi2, pi3

        my $return = $dtd-><M::Node.replaceChild> ($pi3, $pi1);

        # pi3, pi2

        $test->id ('return.node');
        $test->assert_isa ($return, <IFName::Node>);
        $test->id ('return.pi');
        $test->assert_isa ($return, <IFName::Text>);
        $test->id ('return');
        $test->assert_equals ($return, $pi1);

        my $c = $dtd-><AG::Node.childNodes>;

        $test->id ('length');
        $test->assert_num_equals (actual_value => 0+@$c, expected_value => 2);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi3);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi2);
 
        $test->id ('parent');
        $test->assert_equals ($pi3-><AG::Node.parentNode>, $dtd);

        $test->id ('return.parent');
        $test->assert_null ($pi1-><AG::Node.parentNode>);

    @@Test:
      @@@QName: Document.replaceChild.sameparent.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc;

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $dtd-><M::Node.appendChild> ($pi3);

        # pi1, pi2, pi3

        my $return = $dtd-><M::Node.replaceChild> ($pi1, $pi3);

        # pi2, pi1

        $test->id ('return.node');
        $test->assert_isa ($return, <IFName::Node>);
        $test->id ('return.pi');
        $test->assert_isa ($return, <IFName::Text>);
        $test->id ('return');
        $test->assert_equals ($return, $pi3);

        my $c = $dtd-><AG::Node.childNodes>;

        $test->id ('length');
        $test->assert_num_equals (actual_value => 0+@$c, expected_value => 2);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi2);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi1);
 
        $test->id ('parent');
        $test->assert_equals ($pi1-><AG::Node.parentNode>, $dtd);

        $test->id ('return.parent');
        $test->assert_null ($pi3-><AG::Node.parentNode>);

    @@Test:
      @@@QName: Document.appendChild.twodtd.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        $doc-><AG::Document.domConfig>
            -><M::c|DOMConfiguration.setParameter>
                (<Q::cfg|strict-document-children> => true);

        $doc-><M::Node.appendChild>
                ($docx-><M::d|DocumentXDoctype.createDocumentTypeDefinition>
                          ('dt1'));
        $doc-><M::Node.appendChild>
                ($doc-><M::Document.createComment> ('c'));

        my $dt2 = $docx-><M::d|DocumentXDoctype.createDocumentTypeDefinition>
                           ('dt2');

        $test->id ('appendChild');
        $test->assert_exception (code => sub {
          $doc-><M::Node.appendChild> ($dt2);
        }, exception_subtype => <Q::MDOMX|MDOM_SECOND_DOCTYPE>);

        $test->id ('insertBefore');
        $test->assert_exception (code => sub {
          $doc-><M::Node.insertBefore> ($dt2);
        }, exception_subtype => <Q::MDOMX|MDOM_SECOND_DOCTYPE>);

        $test->id ('replaceChild');
        $test->assert_exception (code => sub {
          $doc-><M::Node.replaceChild> ($dt2, $doc-><AG::Node.lastChild>);
        }, exception_subtype => <Q::MDOMX|MDOM_SECOND_DOCTYPE>);

    @@Test:
      @@@QName: Document.insertBefore.twodtd.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        $doc-><AG::Document.domConfig>
            -><M::c|DOMConfiguration.setParameter>
                (<Q::cfg|strict-document-children> => true);

        $doc-><M::Node.appendChild>
                ($docx-><M::d|DocumentXDoctype.createDocumentTypeDefinition>
                          ('dt1'));
        $doc-><M::Node.appendChild>
                ($doc-><M::Document.createComment> ('c'));

        my $dt2 = $docx-><M::d|DocumentXDoctype.createDocumentTypeDefinition>
                           ('dt2');

        $test->id ('insertBefore');
        $test->assert_exception (code => sub {
          $doc-><M::Node.insertBefore> ($dt2, $doc-><AG::Node.firstChild>);
        }, exception_subtype => <Q::MDOMX|MDOM_SECOND_DOCTYPE>);

    @@Test:
      @@@QName: Document.replaceChild.twodtd.3.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        $doc-><AG::Document.domConfig>
            -><M::c|DOMConfiguration.setParameter>
                (<Q::cfg|strict-document-children> => true);

        $doc-><M::Node.appendChild>
                ($docx-><M::d|DocumentXDoctype.createDocumentTypeDefinition>
                          ('dt1'));
        my $c = $doc-><M::Node.appendChild>
                        ($doc-><M::Document.createComment> ('c'));

        my $dt2 = $docx-><M::d|DocumentXDoctype.createDocumentTypeDefinition>
                           ('dt2');

        $doc-><M::Node.replaceChild> ($dt2, $doc-><AG::Node.firstChild>);

        $test->id ('first');
        $test->assert_equals ($doc-><AG::Node.firstChild>, $dt2);

        $test->id ('last');
        $test->assert_equals ($doc-><AG::Node.lastChild>, $c);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$doc-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: Document.appendChild.twoel.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        $doc-><AG::Document.domConfig>
            -><M::c|DOMConfiguration.setParameter>
                (<Q::cfg|strict-document-children> => true);

        $doc-><M::Node.appendChild>
                ($doc-><M::Document.createElement>
                          ('dt1'));
        $doc-><M::Node.appendChild>
                ($doc-><M::Document.createComment> ('c'));

        my $dt2 = $doc-><M::Document.createElement>
                           ('dt2');

        $test->id ('appendChild');
        $test->assert_exception (code => sub {
          $doc-><M::Node.appendChild> ($dt2);
        }, exception_subtype => <Q::MDOMX|MDOM_SECOND_DOC_ELEMENT>);

        $test->id ('insertBefore');
        $test->assert_exception (code => sub {
          $doc-><M::Node.insertBefore> ($dt2);
        }, exception_subtype => <Q::MDOMX|MDOM_SECOND_DOC_ELEMENT>);

        $test->id ('replaceChild');
        $test->assert_exception (code => sub {
          $doc-><M::Node.replaceChild> ($dt2, $doc-><AG::Node.lastChild>);
        }, exception_subtype => <Q::MDOMX|MDOM_SECOND_DOC_ELEMENT>);

    @@Test:
      @@@QName: Document.insertBefore.twoel.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        $doc-><AG::Document.domConfig>
            -><M::c|DOMConfiguration.setParameter>
                (<Q::cfg|strict-document-children> => true);

        $doc-><M::Node.appendChild>
                ($doc-><M::Document.createElement>
                          ('dt1'));
        $doc-><M::Node.appendChild>
                ($doc-><M::Document.createComment> ('c'));

        my $dt2 = $doc-><M::Document.createElement>
                           ('dt2');

        $test->id ('insertBefore');
        $test->assert_exception (code => sub {
          $doc-><M::Node.insertBefore> ($dt2, $doc-><AG::Node.firstChild>);
        }, exception_subtype => <Q::MDOMX|MDOM_SECOND_DOC_ELEMENT>);

    @@Test:
      @@@QName: Document.replaceChild.twoel.3.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        $doc-><AG::Document.domConfig>
            -><M::c|DOMConfiguration.setParameter>
                (<Q::cfg|strict-document-children> => true);

        $doc-><M::Node.appendChild>
                ($doc-><M::Document.createElement>
                          ('dt1'));
        my $c = $doc-><M::Node.appendChild>
                        ($doc-><M::Document.createComment> ('c'));

        my $dt2 = $doc-><M::Document.createElement>
                           ('dt2');

        $doc-><M::Node.replaceChild> ($dt2, $doc-><AG::Node.firstChild>);

        $test->id ('first');
        $test->assert_equals ($doc-><AG::Node.firstChild>, $dt2);

        $test->id ('last');
        $test->assert_equals ($doc-><AG::Node.lastChild>, $c);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$doc-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: Document.appendChild.twoel.4.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        $doc-><AG::Document.domConfig>
            -><M::c|DOMConfiguration.setParameter>
                (<Q::cfg|strict-document-children> => true);

        $doc-><M::Node.appendChild>
                ($doc-><M::Document.createElement>
                          ('dt1'));
        $doc-><M::Node.appendChild>
                ($doc-><M::Document.createComment> ('c'));

        my $dt2 = $doc-><M::Document.createElement>
                           ('dt2');
        my $df = $doc-><M::Document.createDocumentFragment>;
        $df-><M::Node.appendChild> ($dt2);

        $test->id ('appendChild');
        $test->assert_exception (code => sub {
          $doc-><M::Node.appendChild> ($df);
        }, exception_subtype => <Q::MDOMX|MDOM_SECOND_DOC_ELEMENT>);

        $test->id ('insertBefore');
        $test->assert_exception (code => sub {
          $doc-><M::Node.insertBefore> ($df);
        }, exception_subtype => <Q::MDOMX|MDOM_SECOND_DOC_ELEMENT>);

        $test->id ('replaceChild');
        $test->assert_exception (code => sub {
          $doc-><M::Node.replaceChild> ($df, $doc-><AG::Node.lastChild>);
        }, exception_subtype => <Q::MDOMX|MDOM_SECOND_DOC_ELEMENT>);

    @@Test:
      @@@QName: Document.appendChild.el.dtd.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        $doc-><AG::Document.domConfig>
            -><M::c|DOMConfiguration.setParameter>
                (<Q::cfg|strict-document-children> => true);

        $doc-><M::Node.appendChild>
                ($doc-><M::Document.createElement>
                          ('dt1'));
        $doc-><M::Node.appendChild>
                ($doc-><M::Document.createComment> ('c'));

        my $dt2 = $docx-><M::d|DocumentXDoctype.createDocumentTypeDefinition>
                           ('dt2');

        $test->id ('appendChild');
        $test->assert_exception (code => sub {
          $doc-><M::Node.appendChild> ($dt2);
        }, exception_subtype => <Q::c|HIERARCHY_WRONG_DOCTYPE_ERR>);

        $test->id ('insertBefore');
        $test->assert_exception (code => sub {
          $doc-><M::Node.insertBefore> ($dt2);
        }, exception_subtype => <Q::c|HIERARCHY_WRONG_DOCTYPE_ERR>);

        $test->id ('replaceChild');
        $test->assert_exception (code => sub {
          $doc-><M::Node.replaceChild> ($dt2, $doc-><AG::Node.lastChild>);
        }, exception_subtype => <Q::c|HIERARCHY_WRONG_DOCTYPE_ERR>);

    @@Test:
      @@@QName: Document.appendChild.el.dtd.3.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        $doc-><AG::Document.domConfig>
            -><M::c|DOMConfiguration.setParameter>
                (<Q::cfg|strict-document-children> => true);

        $doc-><M::Node.appendChild>
                ($doc-><M::Document.createComment> ('c'));
        $doc-><M::Node.appendChild>
                ($docx-><M::d|DocumentXDoctype.createDocumentTypeDefinition>
                          ('dt1'));

        my $dt2 = $doc-><M::Document.createElement> ('dt2');
        my $df = $doc-><M::Document.createDocumentFragment>;
        $df-><M::Node.appendChild> ($dt2);

        $test->id ('insertBefore');
        $test->assert_exception (code => sub {
          $doc-><M::Node.insertBefore> ($df, $doc-><AG::Node.firstChild>);
        }, exception_subtype => <Q::c|HIERARCHY_WRONG_DOCTYPE_ERR>);

        $test->id ('replaceChild');
        $test->assert_exception (code => sub {
          $doc-><M::Node.replaceChild> ($df, $doc-><AG::Node.firstChild>);
        }, exception_subtype => <Q::c|HIERARCHY_WRONG_DOCTYPE_ERR>);

    @@Test:
      @@@QName: Document.appendChild.el.dtd.4.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        $doc-><AG::Document.domConfig>
            -><M::c|DOMConfiguration.setParameter>
                (<Q::cfg|strict-document-children> => true);

        $doc-><M::Node.appendChild>
                ($doc-><M::Document.createComment> ('c'));
        $doc-><M::Node.appendChild>
                ($docx-><M::d|DocumentXDoctype.createDocumentTypeDefinition>
                          ('dt1'));

        my $dt2 = $doc-><M::Document.createElement> ('dt2');

        $test->id ('insertBefore');
        $test->assert_exception (code => sub {
          $doc-><M::Node.insertBefore> ($dt2, $doc-><AG::Node.firstChild>);
        }, exception_subtype => <Q::c|HIERARCHY_WRONG_DOCTYPE_ERR>);

        $test->id ('replaceChild');
        $test->assert_exception (code => sub {
          $doc-><M::Node.replaceChild> ($dt2, $doc-><AG::Node.firstChild>);
        }, exception_subtype => <Q::c|HIERARCHY_WRONG_DOCTYPE_ERR>);

    @@Test:
      @@@QName: Document.appendChild.newDocumentType.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;

        my $dtd = $doc-><AG::Document.implementation>
                      -><M::c|DOMImplementation.createDocumentType> ('d');

        $doc-><M::Node.appendChild> ($dtd);

        $test->id ('doctype');
        $test->assert_isa ($doc-><AG::Document.doctype>,
                           <IFName::tx|DocumentType>);

        $test->id ('length');
        $test->assert_num_equals
                 (expected_value => 1,
                  actual_value => 0+@{$doc-><AG::Node.childNodes>});

        $test->id ('firstChild');
        $test->assert_equals ($doc-><AG::Node.firstChild>, $dtd);

        $test->id ('parent');
        $test->assert_equals ($dtd-><AG::Node.parentNode>, $doc);

        $test->id ('od');
        $test->assert_equals ($dtd-><AG::Node.ownerDocument>, $doc);

        $test->id ('impl');
        $test->assert_equals ($dtd-><AG::tx|DocumentType.implementation>,
                              $doc-><AG::Document.implementation>);
    @@Test:
      @@@QName: Document.insertBefore.newDocumentType.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;

        my $dtd = $doc-><AG::Document.implementation>
                      -><M::c|DOMImplementation.createDocumentType> ('d');

        $doc-><M::Node.insertBefore> ($dtd);

        $test->id ('doctype');
        $test->assert_isa ($doc-><AG::Document.doctype>,
                           <IFName::tx|DocumentType>);

        $test->id ('length');
        $test->assert_num_equals
                 (expected_value => 1,
                  actual_value => 0+@{$doc-><AG::Node.childNodes>});

        $test->id ('firstChild');
        $test->assert_equals ($doc-><AG::Node.firstChild>, $dtd);

        $test->id ('parent');
        $test->assert_equals ($dtd-><AG::Node.parentNode>, $doc);

        $test->id ('od');
        $test->assert_equals ($dtd-><AG::Node.ownerDocument>, $doc);

        $test->id ('impl');
        $test->assert_equals ($dtd-><AG::tx|DocumentType.implementation>,
                              $doc-><AG::Document.implementation>);

    @@Test:
      @@@QName: Document.replaceChild.newDocumentType.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;

        my $dtd = $doc-><AG::Document.implementation>
                      -><M::c|DOMImplementation.createDocumentType> ('d');
        my $c = $doc-><M::Document.createComment> ('c');
        $doc-><M::Node.appendChild> ($c);

        $doc-><M::Node.replaceChild> ($dtd, $c);

        $test->id ('doctype');
        $test->assert_isa ($doc-><AG::Document.doctype>,
                           <IFName::tx|DocumentType>);

        $test->id ('length');
        $test->assert_num_equals
                 (expected_value => 1,
                  actual_value => 0+@{$doc-><AG::Node.childNodes>});

        $test->id ('firstChild');
        $test->assert_equals ($doc-><AG::Node.firstChild>, $dtd);

        $test->id ('parent');
        $test->assert_equals ($dtd-><AG::Node.parentNode>, $doc);

        $test->id ('od');
        $test->assert_equals ($dtd-><AG::Node.ownerDocument>, $doc);

        $test->id ('impl');
        $test->assert_equals ($dtd-><AG::tx|DocumentType.implementation>,
                              $doc-><AG::Document.implementation>);

  @CMethod:
    @@Name: manakaiAppendText
    @@Param:
      @@@Name: string
      @@@Type: DOMString
      @@@enDesc:
        The string to append.
      @@@InCase:
        @@@@Type: DISPerl|SCALAR||ManakaiDOM|all
        @@@@enDesc:
          A copy of the string value referenced from the value
          is appended.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node itself.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the node to insert the string or a <IF::Text> node
          is read-only.
      @@@PerlDef:
        __DEEP{
          unless ($self-><AG::Document.domConfig>
                       -><M::c|DOMConfiguration.getParameter>
                           (<Q::cfg|strict-document-children>)) {
            my $lc = $self-><AG::Node.lastChild>;
            if (defined $lc and
                $lc-><AG::Node.nodeType> == <C::Node.TEXT_NODE>) {
              $lc-><M::Node.manakaiAppendText>
                     (ref $string eq 'SCALAR' ? $string : \$string);
            } else {
              my $text = $self-><M::Document.createTextNode> 
                                  (ref $string eq 'SCALAR' ? $$string : $string);
              $self-><M::Node.appendChild> ($text);
            }
          }
          $r = $self;
        }__;

    @@Test:
      @@@QName: Document..=.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;

        my $node = $doc;

        $node-><M::Node.manakaiAppendText> ('string');
        $test->id ('1.class');
        $test->assert_isa ($node, <IFName::Document>);
        $test->id ('1.length');
        $test->assert_num_equals
                 (expected_value => 1,
                  actual_value => 0+@{$node-><AG::Node.childNodes>});
        $test->id ('1.value');
        $test->assert_equals ($node-><AG::Node.lastChild>
                                   -><AG::Node.textContent>, 'string');

        $test->id (2);
        $node-><M::Node.manakaiAppendText> ('STRING');
        $test->assert_num_equals
                 (expected_value => 1,
                  actual_value => 0+@{$node-><AG::Node.childNodes>});
        $test->assert_equals ($node-><AG::Node.lastChild>
                                   -><AG::Node.textContent>, 'stringSTRING');

        $node-><M::Node.appendChild>
                 ($doc-><M::Document.createEntityReference> ('er'));

        $test->id (3);
        $node-><M::Node.manakaiAppendText> ('text');
        $test->assert_num_equals
                 (expected_value => 3,
                  actual_value => 0+@{$node-><AG::Node.childNodes>});
        $test->assert_equals ($node-><AG::Node.lastChild>
                                   -><AG::Node.textContent>, 'text');

    @@Test:
      @@@QName: Document..=.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;

        my $node = $doc;

        $node-><M::Node.manakaiAppendText> ('aaaa');
        $test->id ('1.class');
        $test->assert_isa ($node, <IFName::Document>);
        $test->id ('1.value');
        $test->assert_null ($node-><AG::Node.textContent>);

  @CMethod:
    @@Name: removeChild
    @@enDesc:
      Removes a child node.
    @@Param:
      @@@Name: oldChild
      @@@Type: Node
    @@Return:
      @@@Type: Node
      @@@NodeReadOnlyError:
      @@@dx:raises:
        @@@@@: c|NOT_CHILD_ERR
        @@@@enDesc:
          If the <P::oldChild> is not a child of the node.
      @@@PerlDef:
        if ($self-><AG::Document.strictErrorChecking> and
            $self-><AG::Node.manakaiReadOnly>) {
          __EXCEPTION{MDOMX|NOMOD_THIS::
          }__;
        }
        __CODE{tc|removeChildImpl}__;

    @@Test:
      @@@QName: Doc.removeChild.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $c1 = $doc-><M::Document.createComment> ('e');
        $doc-><M::Node.appendChild> ($c1);

        my $c2 = $doc-><M::Document.createComment> ('f');
        $doc-><M::Node.appendChild> ($c2);

        my $c3 = $doc-><M::Document.createComment> ('g');
        $doc-><M::Node.appendChild> ($c3);

        my $return = $doc-><M::Node.removeChild> ($c1);

        $test->id ('return');
        $test->assert_equals ($return, $c1);

        $test->id ('parentNode');
        $test->assert_null ($c1-><AG::Node.parentNode>);

        $test->id ('firstChild');
        $test->assert_equals ($doc-><AG::Node.firstChild>, $c2);

        $test->id ('lastChild');
        $test->assert_equals ($doc-><AG::Node.lastChild>, $c3);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$doc-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: Doc.removeChild.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $c1 = $doc-><M::Document.createComment> ('e');
        $doc-><M::Node.appendChild> ($c1);

        my $c2 = $doc-><M::Document.createComment> ('f');
        $doc-><M::Node.appendChild> ($c2);

        my $c3 = $doc-><M::Document.createComment> ('g');
        $doc-><M::Node.appendChild> ($c3);

        my $return = $doc-><M::Node.removeChild> ($c2);

        $test->id ('return');
        $test->assert_equals ($return, $c2);

        $test->id ('parentNode');
        $test->assert_null ($c2-><AG::Node.parentNode>);

        $test->id ('firstChild');
        $test->assert_equals ($doc-><AG::Node.firstChild>, $c1);

        $test->id ('lastChild');
        $test->assert_equals ($doc-><AG::Node.lastChild>, $c3);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$doc-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: Doc.removeChild.3.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $c1 = $doc-><M::Document.createComment> ('e');
        $doc-><M::Node.appendChild> ($c1);

        my $c2 = $doc-><M::Document.createComment> ('f');
        $doc-><M::Node.appendChild> ($c2);

        my $c3 = $doc-><M::Document.createComment> ('g');
        $doc-><M::Node.appendChild> ($c3);

        my $return = $doc-><M::Node.removeChild> ($c3);

        $test->id ('return');
        $test->assert_equals ($return, $c3);

        $test->id ('parentNode');
        $test->assert_null ($c3-><AG::Node.parentNode>);

        $test->id ('firstChild');
        $test->assert_equals ($doc-><AG::Node.firstChild>, $c1);

        $test->id ('lastChild');
        $test->assert_equals ($doc-><AG::Node.lastChild>, $c2);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$doc-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: Doc.removeChild.4.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $c1 = $doc-><M::Document.createComment> ('e');
        $doc-><M::Node.appendChild> ($c1);

        my $return = $doc-><M::Node.removeChild> ($c1);

        $test->id ('return');
        $test->assert_equals ($return, $c1);

        $test->id ('parentNode');
        $test->assert_null ($c1-><AG::Node.parentNode>);

        $test->id ('firstChild');
        $test->assert_null ($doc-><AG::Node.firstChild>);

        $test->id ('lastChild');
        $test->assert_null ($doc-><AG::Node.lastChild>);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$doc-><AG::Node.childNodes>},
                  expected_value => 0);

  @Test:
    @@QName: Doc.attributes.test
    @@PerlDef:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

      $test->assert_null ($doc-><AG::Node.attributes>);

  @CAttr:
    @@Name: nodeName
    @@enDesc:
      The node name.
    @@DOMMain:isNamespaceUnaware:1
    @@Type: DOMString
    @@Get:
      @@@disDef:
        @@@@DISLang:value:
          @@@@@@: \#document
          @@@@@ContentType:
            DISCore:String

    @@Test:
      @@@QName: Doc.nodeName.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        $test->assert_equals ($doc-><AG::Node.nodeName>, '#document');

  @CL3Attr:
    @@Name: textContent
    @@enDesc:
      The text content of the node and its descendants.
    @@Type: DOMString
    @@Get:
      @@@nullCase:
      @@@PerlDef:
        __DEEP{
          if ($self-><AG::Document.domConfig>
                   -><M::c|DOMConfiguration.getParameter>
                       (<Q::cfg|strict-document-children>)) {
            $r = null;
          } else {
            $r = '';
            my @target = @{$self-><AG::Node.childNodes>};
            C: for my $node (@target) {
              my $nt = $node-><AG::Node.nodeType>;
              if ($nt == <C::Node.TEXT_NODE> or
                  $nt == <C::Node.CDATA_SECTION_NODE>) {
                $r .= $node-><AG::CharacterData.data>
                  unless $node-><AG::Text.isElementContentWhitespace>;
              } elsif ($nt == <C::Node.ELEMENT_NODE> or
                       $nt == <C::Node.ENTITY_REFERENCE_NODE>) {
                unshift @target, @{$node-><AG::Node.childNodes>};
              }
            }
          }
        }__;
    @@Set:
      @@@nullCase:
      @@@NodeReadOnlyError:
       @@@c:reports:
         @@@@@: c|setting-node-value-no-effect
         @@@@enDesc:
           Setting the attribute value has no effect, since the
           node value is defined as <DOM::null>.
      @@@PerlDef:
        if ($self-><AG::Document.domConfig>
                 -><M::c|DOMConfiguration.getParameter>
                     (<Q::cfg|strict-document-children>)) {
          __c|ERROR{t|setting-node-value-no-effect::
            c|relatedData => {$self},
          }__;
        } else {
          __CODE{tc|setNodeTextContent::
            $node => $self,
            $given => $given,
            $ownerDocument => $self,
          }__;
        }

  @CL3Method:
    @@Name: getFeature
    @@enDesc:
      Returns a specialized object that implements the specialized APIs.
    @@Param:
      @@@Name: feature
      @@@Type: DOMString
      @@@dis:actualType: f|FeatureNameString
    @@Param:
      @@@Name: version
      @@@Type: DOMString
      @@@dis:actualType: f|FeatureVersionString
    @@Return:
      @@@Type: DOMMain|DOMObject
      @@@nullCase:
      @@@PerlDef:
        $feature =~ s/^\+//;
        __CODE{f|getFeatureImpl::
          $self => $self,
          $feature => $feature, $version => $version, $r => $r,
          $base_class => {<ClassName::ManakaiDOMDocument>},
        }__;
        unless (defined $r) {
          __DEEP{
            $r = $self->SUPER::get_feature ($feature, $version);
          }__;
        }

    @@Test:
      @@@QName: Document.getFeature.test
      @@@PerlDef:
        my $node;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $node}__;

        for (
          [Core => '1.0', <IFName::Document||ManakaiDOM|ManakaiDOM1>],
          [Core => '2.0', <IFName::Document||ManakaiDOM|ManakaiDOM2>],
          [Core => '3.0', <IFName::Document||ManakaiDOM|ManakaiDOM3>],
          [XML => '1.0', <IFName::Document||ManakaiDOM|ManakaiDOM1>],
          [XML => '2.0', <IFName::Document||ManakaiDOM|ManakaiDOM2>],
          [XML => '3.0', <IFName::Document||ManakaiDOM|ManakaiDOM3>],
        ) {
          $test->id ($_->[0].'.'.$_->[1]);
          my $sp = $node-><M::Node.getFeature> ($_->[0], $_->[1]);
          $test->assert_isa ($sp, $_->[2]);
        }

  @CL3Attr:
    @@Name: baseURI
    @@enDesc:
      The base URI of the node.
    @@Type: DOMString
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          If it is not available.
      @@@PerlDef:
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $r,
          $prop => {<H::infoset|baseURI>},
          $ref => $self,
        }__;
        unless (defined $r) {
          __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
            $r => $r,
            $prop => {<H::c|documentURI>},
            $ref => $self,
          }__;
        }
      @@@enImplNote:
        {TODO::
          HTML <HE::base> element support (awaiting until HTML5 clarification)
        }

    @@L3Test:
      @@@QName: Document.baseURI.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        $test->id ('initial');
        $test->assert_null ($doc-><AG::Node.baseURI>);

        $test->id ('docuri.set');
        $doc-><AS::Document.documentURI> ('ftp://suika.fam.cx/');
        $test->assert_equals ($doc-><AG::Node.baseURI>,
                              q<ftp://suika.fam.cx/>);

        $test->id ('docuri.reset');
        $doc-><AS::Document.documentURI> (null);
        $test->assert_null ($doc-><AG::Node.baseURI>);
        $test->assert_null ($doc-><AG::Document.manakaiEntityBaseURI>);

        $test->id ('mburi.set');
        $doc-><AS::Document.manakaiEntityBaseURI> (q<https://suika.fam.cx/>);
        $test->assert_equals ($doc-><AG::Node.baseURI>,
                              q<https://suika.fam.cx/>);
        $test->assert_equals ($doc-><AG::Document.manakaiEntityBaseURI>,
                              q<https://suika.fam.cx/>);

        $test->id ('mburi.reset');
        $doc-><AS::Document.manakaiEntityBaseURI> (null);
        $test->assert_null ($doc-><AG::Node.baseURI>);
        $test->assert_null ($doc-><AG::Document.manakaiEntityBaseURI>);

        $test->id ('docuri.mburi.set');
        $doc-><AS::Document.documentURI> ('ftp://suika.fam.cx/');
        $doc-><AS::Document.manakaiEntityBaseURI> (q<https://suika.fam.cx/>);
        $test->assert_equals ($doc-><AG::Node.baseURI>,
                              q<https://suika.fam.cx/>);
        $test->assert_equals ($doc-><AG::Document.manakaiEntityBaseURI>,
                              q<https://suika.fam.cx/>);

  @Method:
    @@Name: createElement
    @@enDesc:
      Creates an element of the specified type.

      If there are known attributes with default values, 
      <IF::Attr> nodes representing them are automatically created
      and attached to the element.
    @@NSVersion:.createElementNS
    @@Param:
      @@@Name: tagName
      @@@Type: DOMString
      @@@enDesc:
        The name of the element type to instantiate.

        For XML this is case-sensitive.  <SRC::DOM1, DOM2, DOM3>

        For HTML the <P::tagName> parameter may be provided
        in any case, but it must be mapped to the canonical uppercase
        form by the implementation.  <SRC::DOM1, DOM2>

        If the markup language is different from XML, it
        depends on the case-sensitibity of the markup
        language in use.  In that case, the name is
        mapped to the canonical form of that markup by
        the implementation.  <SRC::DOM3>
    @@Return:
      @@@Type: Element
      @@@enDesc:
        {P:: A new <IF::Element> node with:

          - <A::Node.nodeName>::: <P::tagName>.

          - <A::Node.localName>::: <DOM::null>.  <SRC::DOM2, DOM3>
                However, in manakai, as well as in Web browsers,
                it is set to <P::tagName>, even if it is not
                an <CODE::NCName>.

          - <A::Node.prefix>::: <DOM::null>.

          - <A::Node.namespaceURI>::: <DOM::null>.

        }
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_BAD_NAME
        @@@@enDesc:
          If the specified name is not an XML <CODE::Name>
          according to the XML version in use specified in the
          <A::Document.xmlVersion> attribute.
      @@@PerlDef:
        my $version = $self-><AG::Document.xmlVersion>;
        __CODE{DOMMain|ensureXMLName::
          $INPUT => $tagName, $INPUT_PARAM_NAME => 'tagName',
          $XMLVERSION => $version,
        }__;
        __DEEP{
          my $strict = $self-><AG::Document.strictErrorChecking>;
          $r = $self-><M::Document.createElementNS> (null, [null, $tagName]);
          $self-><AS::Document.strictErrorChecking> ($strict);
        }__;
    @@enImplNote:
      {ISSUE::
        <P::tagName> normalization (HTML5)
      }

    @@Test:
      @@@QName: Document.createElement.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createElement> ('elName');

        $test->id ('interface');
        $test->assert_isa ($el, <IFName::Element>);

        $test->id ('nodeName');
        $test->assert_equals ($el-><AG::Node.nodeName>, 'elName');

        $test->id ('localName');
        $test->assert_equals ($el-><AG::Node.localName>, 'elName');

        $test->id ('namespaceURI');
        $test->assert_null ($el-><AG::Node.namespaceURI>);

        $test->id ('prefix');
        $test->assert_null ($el-><AG::Node.prefix>);
    @@Test:
      @@@QName: Document.createElement.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createElement> ('el:name');

        $test->id ('interface');
        $test->assert_isa ($el, <IFName::Element>);

        $test->id ('nodeName');
        $test->assert_equals ($el-><AG::Node.nodeName>, 'el:name');

        $test->id ('localName');
        $test->assert_equals ($el-><AG::Node.localName>, 'el:name');

        $test->id ('namespaceURI');
        $test->assert_null ($el-><AG::Node.namespaceURI>);

        $test->id ('prefix');
        $test->assert_null ($el-><AG::Node.prefix>);
    @@Test:
      @@@QName: Document.createElement.nodefaultattr.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createElement> ('et1');

        $test->assert_num_equals
                 (actual_value => $el-><AG::Node.attributes>
                                     -><AG::NamedNodeMap.length>,
                  expected_value => 0);
    @@Test:
      @@@QName: Document.createElement.defaultattr.1.test
      @@@PerlDef:
        my $doc;
        __CODE{createEmptyDocumentForTest:: $doc => $doc}__;
        my $docd = $doc-><M::Node.getFeature> (<Q::ManakaiDOM:XDoctype>, '3.0');
        my $dtd = $docd-><M::d|DocumentXDoctype.createDocumentTypeDefinition>
                           ('doctype');
          my $et = $docd-><M::d|DocumentXDoctype.createElementTypeDefinition>
                             ('et1');
            my $at = $docd-><M::d|DocumentXDoctype.createAttributeDefinition>
                               ('dattr1');
            $at-><AS::ATDef.defaultType> (<C::ATDef.EXPLICIT_DEFAULT>);
            $at-><AS::Node.textContent> ('dattr1 default ');
          $et-><M::ETDef.setAttributeDefinitionNode> ($at);
        $dtd-><M::DTDef.setElementTypeDefinitionNode> ($et);
        $doc-><M::Node.appendChild> ($dtd);

        my $el = $doc-><M::Document.createElement> ('et1');

        $test->id ('attributes.length');
        $test->assert_num_equals
                 (actual_value => $el-><AG::Node.attributes>
                                     -><AG::NamedNodeMap.length>,
                  expected_value => 1);
        
        $test->id ('has.attribute');
        $test->assert_true ($el-><M::Element.hasAttribute> ('dattr1'));

        $test->id ('get.attr.node');
        my $an = $el-><M::Element.getAttributeNode> ('dattr1');
        $test->assert_isa ($an, <IFName::Attr>);

        $test->id ('attr.text.content');
        $test->assert_equals ($an-><AG::Node.textContent>, 'dattr1 default ');
        
        $test->id ('attr.specified');
        $test->assert_false ($an-><AG::Attr.specified>);
    @@Test:
      @@@QName: Document.createElement.defaultattr.typed.test
      @@@PerlDef:
        my $doc;
        __CODE{createEmptyDocumentForTest:: $doc => $doc}__;
        my $docd = $doc-><M::Node.getFeature> (<Q::ManakaiDOM:XDoctype>, '3.0');
        my $dtd = $docd-><M::d|DocumentXDoctype.createDocumentTypeDefinition>
                           ('doctype');
          my $et = $docd-><M::d|DocumentXDoctype.createElementTypeDefinition>
                             ('et1');
            my $at = $docd-><M::d|DocumentXDoctype.createAttributeDefinition>
                               ('dattr1');
            $at-><AS::ATDef.defaultType> (<C::ATDef.EXPLICIT_DEFAULT>);
            $at-><AS::Node.textContent> ('dattr1 default ');
            $at-><AS::ATDef.declaredType> (<C::ATDef.NMTOKENS_ATTR>);
          $et-><M::ETDef.setAttributeDefinitionNode> ($at);
        $dtd-><M::DTDef.setElementTypeDefinitionNode> ($et);
        $doc-><M::Node.appendChild> ($dtd);

        my $el = $doc-><M::Document.createElement> ('et1');

        $test->id ('attributes.length');
        $test->assert_num_equals
                 (actual_value => $el-><AG::Node.attributes>
                                     -><AG::NamedNodeMap.length>,
                  expected_value => 1);
        
        $test->id ('has.attribute');
        $test->assert_true ($el-><M::Element.hasAttribute> ('dattr1'));

        $test->id ('get.attr.node');
        my $an = $el-><M::Element.getAttributeNode> ('dattr1');
        $test->assert_isa ($an, <IFName::Attr>);

        $test->id ('attr.text.content');
        $test->assert_equals ($an-><AG::Node.textContent>, 'dattr1 default ');
        
        $test->id ('attr.specified');
        $test->assert_false ($an-><AG::Attr.specified>);

        $test->id ('attr.type');
        my $ti = $an-><AG::Attr.schemaTypeInfo>;
        $test->assert_equals
                 ($ti-><AG::c|TypeInfo.typeNamespace>, <Q::xml-dtd:>);
        $test->assert_equals ($ti-><AG::c|TypeInfo.typeName>, 'NMTOKENS');
    @@L3Test:
      @@@QName: Document.createElement.defaultattr.3.test
      @@@PerlDef:
        my $doc;
        __CODE{createEmptyDocumentForTest:: $doc => $doc}__;
        my $docd = $doc-><M::Node.getFeature> (<Q::ManakaiDOM:XDoctype>, '3.0');
        my $dtd = $docd-><M::d|DocumentXDoctype.createDocumentTypeDefinition>
                           ('doctype');
          my $et = $docd-><M::d|DocumentXDoctype.createElementTypeDefinition>
                             ('et1');
            my $at = $docd-><M::d|DocumentXDoctype.createAttributeDefinition>
                               ('dattr1');
            $at-><AS::ATDef.defaultType> (<C::ATDef.EXPLICIT_DEFAULT>);
            $at-><AS::Node.textContent> ('dattr1 default ');
          $et-><M::ETDef.setAttributeDefinitionNode> ($at);
        $dtd-><M::DTDef.setElementTypeDefinitionNode> ($et);
        $doc-><M::Node.appendChild> ($dtd);

        $doc-><AG::Document.domConfig>
            -><M::c|DOMConfiguration.setParameter>
                 (<Q::cfg|dtd-default-attributes> => false);

        my $el = $doc-><M::Document.createElement> ('et1');

        $test->id ('attributes.length');
        $test->assert_num_equals
                 (actual_value => $el-><AG::Node.attributes>
                                     -><AG::NamedNodeMap.length>,
                  expected_value => 0);

  @L2Method:
    @@Name: createElementNS
    @@enDesc:
      Creates an element of the given qualified name and namespace URI.
    @@NoNSVersion:.createElement
    @@XML2Feature:
    @@Param:
      @@@Name: namespaceURI
      @@@Type: DOMString
      @@@dis:actualType: ManakaiDOM|ManakaiDOMNamespaceURI
      @@@enDesc:
        The namespace URI of the element to create.
      @@@nullCase:
        @@@@enDesc:
          If the element has no namespace.
    @@Param:
      @@@Name: qualifiedName
      @@@Type: DOMString
      @@@dis:actualType:
        @@@@@: DOMMain|ManakaiDOMXMLQName
        @@@@ManakaiDOM:noInputNormalize: 1
      @@@enDesc:
        The qualified name of the element type to instantiate.
      @@@InCase:
        @@@@Type: ARRAY
        @@@@enDesc:
          A reference to the array that contains the namespace
          prefix (zeroth item) and the local name (first item)
          of the attribute.  The namespace prefix <kwd:MAY>
          be <DOM::null> to indicate that the qualified name
          contains no <CHAR::COLON> character.
    @@Return:
      @@@Type: Element
      @@@enDesc:
        {P:: A new <IF::Element> node with:

          - <A::Node.nodeName>::: <P::qualifiedName>.

          - <A::Node.namespaceURI>::: <P::namespaceURI>.

          - <A::Node.prefix>::: The namespace prefix extracted
                from <P::qualifiedName>, or <DOM::null> if there
                is no prefix.

          - <A::Node.localName>::: The local name extracted
                from <P::qualifiedName>.

          - <A::Element.tagName>::: <P::qualifiedName>.

        }
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_BAD_NAME
        @@@@enDesc:
          If the specified <P::qualifiedName> is not an XML
          <CODE::Name> according to the XML version in use 
          specified in the <A::Document.xmlVersion> attribute.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_NS_MALFORMED_QNAME
        @@@@enDesc:
          If the <P::qualifiedName> is malformed qualified
          name.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_NS_PREFIX_WITH_NULL_URI
        @@@@enDesc:
          If the <P::qualifiedName> has a prefix and the
          <P::namespaceURI> is <DOM::null>.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_NS_XML_WITH_OTHER_URI
        @@@@enDesc:
          If the <P::qualifiedName> has a prefix that is <XML::xml>
          and the <P::namespaceURI> is different from
          <URI::http://www.w3.org/XML/1998/namespace>.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_NS_XMLNS_WITH_OTHER_URI
        @@@@enDesc:
          If the <P::qualifiedName> has a prefix that is <XML::xmlns>
          and the <P::namespaceURI> is different from
          <URI::http://www.w3.org/2000/xmlns/>.  <SRC::DOM3>
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_NS_XMLNSQ_WITH_OTHER_URI
        @@@@enDesc:
          If the <P::qualifiedName> is <XE::xmlns> and
          the <P::namespaceURI> is different from 
          <URI::http://www.w3.org/2000/xmlns/>.  <SRC::DOM3>
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_NS_OTHER_WITH_XMLNS_URI
        @@@@enDesc:
          If the <P::namespaceURI> is <URI::http://www.w3.org/2000/xmlns/>
          and neither the <P::qualifiedName> nor its prefix is
          <XML::xmlns>.  <SRC::DOM3>
      @@@iRaises:
        @@@@@: MDOMX|MDOM_DOC_NOSUPPORT_XML
        @@@@enDesc:
          If the current document does not support the <Feature::XML>
          feature.
      @@@PerlDef:
        my ($prefix, $lname) = ref $qualifiedName eq 'ARRAY'
                                 ? @$qualifiedName
                                 : split /:/, $qualifiedName, 2;
        ($prefix, $lname) = (null, $prefix) unless defined $lname;

        if ($self-><AG::Document.strictErrorChecking>) {
          my $version = $od-><AG::Document.xmlVersion>;
          $qualifiedName = defined $prefix ? $prefix.':'.$lname
                                           : $lname;
          __CODE{DOMMain|ensureXMLQName::
            $INPUT = $qualifiedName, 
            $INPUT_PARAM_NAME = 'qualifiedName',
            $XMLVERSION = $version,
          }__;
          __CODE{DOMMain|checkXMLNamesQName::
            $PREFIX => $prefix, $NSURI => $namespaceURI,
            $LNAME => $lname,
          }__;
          if (defined $namespaceURI and $namespaceURI eq <Q::xmlns:> and
              ($qualifiedName eq 'xmlns' or
               (defined $prefix and $prefix eq 'xmlns')) {
            __EXCEPTION{MDOMX|MDOM_NS_OTHER_WITH_XMLNS_URI::
              MDOMX|param-name => 'qualifiedName',
              infoset|prefix => {$prefix},
              infoset|localName => {$localName},
              infoset|namespaceName => {$namespaceName},
            }__;
          }
        }

        my $bag = <Code::mg|getNodeBag||ManakaiDOM|all:: $ref = $self>;
        my $stem;
        __CODE{mg|createNodeStem||ManakaiDOM|all::
          $bag => $bag,
          $stem => $stem,
          $class => {<ClassName::ManakaiDOMElement>},
          $opt => {{
            <H::tc|ownerDocument> => $self,
            <H::infoset|namespaceName> => \$namespaceURI,
            <H::infoset|prefix> => \$prefix,
            <H::infoset|localName> => \$lname,
          }},
        }__;
        __CODE{mg|createNodeRef||ManakaiDOM|all::
          $bag => $bag,
          $stem => $stem,
          $ref => $r,
          $opt => {{
          }},
        }__;

        ## Default attributes
        __CODE{tc|exposeDefaultAttributes::
          $document => $self,
          $element => $r,
          $element_type => $qualifiedName,
        }__;

    @@Test:
      @@@QName: Doc.createElNS.mg.1.test
      @@@PerlDef:
        local $Message::DOM::TreeCore::GCLatency = 0;

        my $impl = <ClassM::ManakaiDOMImplementationTC.new>;

        my $bag = $impl->{<H::mg|nodeBag>};
        my $id = $impl->{<H::mg|nodeIDReference>};

        my $doc = $impl-><M::c|DOMImplementation.createDocument>;

        my $el = $doc-><M::Document.createElementNS> (null, 'e');
        
        $test->id ('interface');
        $test->assert_isa ($el, <IFName::Element>);
        
        $test->id ('class');
        $test->assert_isa ($el, <ClassName::ManakaiDOMElement>);

        my $doc_id = $doc->{<H::mg|nodeIDReference>};
        my $el_id = $el->{<H::mg|nodeIDReference>};

        undef $impl;

        $test->id ('gc.impl.1');
        $test->assert_not_null ($bag->{$$id});

        $test->id ('gc.doc.1');
        $test->assert_not_null ($bag->{$$doc_id});

        $test->id ('gc.el.1');
        $test->assert_not_null ($bag->{$$el_id});

        undef $doc;

        $test->id ('gc.impl.2');
        $test->assert_not_null ($bag->{$$id});

        $test->id ('gc.doc.2');
        $test->assert_not_null ($bag->{$$doc_id});

        $test->id ('gc.el.2');
        $test->assert_not_null ($bag->{$$el_id});

        undef $el;

        $test->id ('gc.impl.3');
        $test->assert_null ($bag->{$$id});

        $test->id ('gc.doc.3');
        $test->assert_null ($bag->{$$doc_id});

        $test->id ('gc.el.3');
        $test->assert_null ($bag->{$$el_id});
    @@Test:
      @@@QName: Doc.createElNS.mg.2.test
      @@@PerlDef:
        local $Message::DOM::TreeCore::GCLatency = 0;

        my $impl = <ClassM::ManakaiDOMImplementationTC.new>;

        my $bag = $impl->{<H::mg|nodeBag>};
        my $id = $impl->{<H::mg|nodeIDReference>};

        my $doc = $impl-><M::c|DOMImplementation.createDocument>;

        my $el = $doc-><M::Document.createElementNS> (null, 'e');
        
        $test->id ('interface');
        $test->assert_isa ($el, <IFName::Element>);
        
        $test->id ('class');
        $test->assert_isa ($el, <ClassName::ManakaiDOMElement>);

        my $doc_id = $doc->{<H::mg|nodeIDReference>};
        my $el_id = $el->{<H::mg|nodeIDReference>};

        undef $impl;

        $test->id ('gc.impl.1');
        $test->assert_not_null ($bag->{$$id});

        $test->id ('gc.doc.1');
        $test->assert_not_null ($bag->{$$doc_id});

        $test->id ('gc.el.1');
        $test->assert_not_null ($bag->{$$el_id});

        undef $el;

        $test->id ('gc.impl.2');
        $test->assert_not_null ($bag->{$$id});

        $test->id ('gc.doc.2');
        $test->assert_not_null ($bag->{$$doc_id});

        $test->id ('gc.el.2');
        $test->assert_null ($bag->{$$el_id});

        undef $doc;

        $test->id ('gc.impl.3');
        $test->assert_null ($bag->{$$id});

        $test->id ('gc.doc.3');
        $test->assert_null ($bag->{$$doc_id});

        $test->id ('gc.el.3');
        $test->assert_null ($bag->{$$el_id});
    @@Test:
      @@@QName: Doc.createElNS.mg.3.test
      @@@PerlDef:
        local $Message::DOM::TreeCore::GCLatency = 0;

        my $impl = <ClassM::ManakaiDOMImplementationTC.new>;

        my $bag = $impl->{<H::mg|nodeBag>};
        my $id = $impl->{<H::mg|nodeIDReference>};

        my $doc = $impl-><M::c|DOMImplementation.createDocument>;

        my $el = $doc-><M::Document.createElementNS> (null, 'e');
        
        $test->id ('interface');
        $test->assert_isa ($el, <IFName::Element>);
        
        $test->id ('class');
        $test->assert_isa ($el, <ClassName::ManakaiDOMElement>);

        my $doc_id = $doc->{<H::mg|nodeIDReference>};
        my $el_id = $el->{<H::mg|nodeIDReference>};

        undef $doc;

        $test->id ('gc.impl.1');
        $test->assert_not_null ($bag->{$$id});

        $test->id ('gc.doc.1');
        $test->assert_not_null ($bag->{$$doc_id});

        $test->id ('gc.el.1');
        $test->assert_not_null ($bag->{$$el_id});

        undef $impl;

        $test->id ('gc.impl.2');
        $test->assert_not_null ($bag->{$$id});

        $test->id ('gc.doc.2');
        $test->assert_not_null ($bag->{$$doc_id});

        $test->id ('gc.el.2');
        $test->assert_not_null ($bag->{$$el_id});

        undef $el;

        $test->id ('gc.impl.3');
        $test->assert_null ($bag->{$$id});

        $test->id ('gc.doc.3');
        $test->assert_null ($bag->{$$doc_id});

        $test->id ('gc.el.3');
        $test->assert_null ($bag->{$$el_id});
    @@Test:
      @@@QName: Doc.createElNS.mg.4.test
      @@@PerlDef:
        local $Message::DOM::TreeCore::GCLatency = 0;

        my $impl = <ClassM::ManakaiDOMImplementationTC.new>;

        my $bag = $impl->{<H::mg|nodeBag>};
        my $id = $impl->{<H::mg|nodeIDReference>};

        my $doc = $impl-><M::c|DOMImplementation.createDocument>;

        my $el = $doc-><M::Document.createElementNS> (null, 'e');
        
        $test->id ('interface');
        $test->assert_isa ($el, <IFName::Element>);
        
        $test->id ('class');
        $test->assert_isa ($el, <ClassName::ManakaiDOMElement>);

        my $doc_id = $doc->{<H::mg|nodeIDReference>};
        my $el_id = $el->{<H::mg|nodeIDReference>};

        undef $doc;

        $test->id ('gc.impl.1');
        $test->assert_not_null ($bag->{$$id});

        $test->id ('gc.doc.1');
        $test->assert_not_null ($bag->{$$doc_id});

        $test->id ('gc.el.1');
        $test->assert_not_null ($bag->{$$el_id});

        undef $el;

        $test->id ('gc.impl.2');
        $test->assert_not_null ($bag->{$$id});

        $test->id ('gc.doc.2');
        $test->assert_null ($bag->{$$doc_id});

        $test->id ('gc.el.2');
        $test->assert_null ($bag->{$$el_id});

        undef $impl;

        $test->id ('gc.impl.3');
        $test->assert_null ($bag->{$$id});

        $test->id ('gc.doc.3');
        $test->assert_null ($bag->{$$doc_id});

        $test->id ('gc.el.3');
        $test->assert_null ($bag->{$$el_id});
    @@Test:
      @@@QName: Doc.createElNS.mg.5.test
      @@@PerlDef:
        local $Message::DOM::TreeCore::GCLatency = 0;

        my $impl = <ClassM::ManakaiDOMImplementationTC.new>;

        my $bag = $impl->{<H::mg|nodeBag>};
        my $id = $impl->{<H::mg|nodeIDReference>};

        my $doc = $impl-><M::c|DOMImplementation.createDocument>;

        my $el = $doc-><M::Document.createElementNS> (null, 'e');
        
        $test->id ('interface');
        $test->assert_isa ($el, <IFName::Element>);
        
        $test->id ('class');
        $test->assert_isa ($el, <ClassName::ManakaiDOMElement>);

        my $doc_id = $doc->{<H::mg|nodeIDReference>};
        my $el_id = $el->{<H::mg|nodeIDReference>};

        undef $el;

        $test->id ('gc.impl.1');
        $test->assert_not_null ($bag->{$$id});

        $test->id ('gc.doc.1');
        $test->assert_not_null ($bag->{$$doc_id});

        $test->id ('gc.el.1');
        $test->assert_null ($bag->{$$el_id});

        undef $impl;

        $test->id ('gc.impl.2');
        $test->assert_not_null ($bag->{$$id});

        $test->id ('gc.doc.2');
        $test->assert_not_null ($bag->{$$doc_id});

        $test->id ('gc.el.2');
        $test->assert_null ($bag->{$$el_id});

        undef $doc;

        $test->id ('gc.impl.3');
        $test->assert_null ($bag->{$$id});

        $test->id ('gc.doc.3');
        $test->assert_null ($bag->{$$doc_id});

        $test->id ('gc.el.3');
        $test->assert_null ($bag->{$$el_id});
    @@Test:
      @@@QName: Doc.createElNS.mg.6.test
      @@@PerlDef:
        local $Message::DOM::TreeCore::GCLatency = 0;

        my $impl = <ClassM::ManakaiDOMImplementationTC.new>;

        my $bag = $impl->{<H::mg|nodeBag>};
        my $id = $impl->{<H::mg|nodeIDReference>};

        my $doc = $impl-><M::c|DOMImplementation.createDocument>;

        my $el = $doc-><M::Document.createElementNS> (null, 'e');
        
        $test->id ('interface');
        $test->assert_isa ($el, <IFName::Element>);
        
        $test->id ('class');
        $test->assert_isa ($el, <ClassName::ManakaiDOMElement>);

        my $doc_id = $doc->{<H::mg|nodeIDReference>};
        my $el_id = $el->{<H::mg|nodeIDReference>};

        undef $el;

        $test->id ('gc.impl.1');
        $test->assert_not_null ($bag->{$$id});

        $test->id ('gc.doc.1');
        $test->assert_not_null ($bag->{$$doc_id});

        $test->id ('gc.el.1');
        $test->assert_null ($bag->{$$el_id});

        undef $doc;

        $test->id ('gc.impl.2');
        $test->assert_not_null ($bag->{$$id});

        $test->id ('gc.doc.2');
        $test->assert_null ($bag->{$$doc_id});

        $test->id ('gc.el.2');
        $test->assert_null ($bag->{$$el_id});

        undef $impl;

        $test->id ('gc.impl.3');
        $test->assert_null ($bag->{$$id});

        $test->id ('gc.doc.3');
        $test->assert_null ($bag->{$$doc_id});

        $test->id ('gc.el.3');
        $test->assert_null ($bag->{$$el_id});
    @@Test:
      @@@QName: Document.createElementNS.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createElementNS> (null, 'el');

        $test->id ('interface');
        $test->assert_isa ($el, <IFName::Element>);

        $test->id ('nodeName');
        $test->assert_equals ($el-><AG::Node.nodeName>, 'el');

        $test->id ('localName');
        $test->assert_equals ($el-><AG::Node.localName>, 'el');

        $test->id ('namespaceURI');
        $test->assert_null ($el-><AG::Node.namespaceURI>);

        $test->id ('prefix');
        $test->assert_null ($el-><AG::Node.prefix>);
    @@Test:
      @@@QName: Document.createElementNS.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createElementNS> ('about:', 'a:el');

        $test->id ('interface');
        $test->assert_isa ($el, <IFName::Element>);

        $test->id ('nodeName');
        $test->assert_equals ($el-><AG::Node.nodeName>, 'a:el');

        $test->id ('localName');
        $test->assert_equals ($el-><AG::Node.localName>, 'el');

        $test->id ('namespaceURI');
        $test->assert_equals ($el-><AG::Node.namespaceURI>, 'about:');

        $test->id ('prefix');
        $test->assert_equals ($el-><AG::Node.prefix>, 'a');
    @@Test:
      @@@QName: Document.createElementNS.3.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createElementNS> ('about:', ['a', 'el']);

        $test->id ('interface');
        $test->assert_isa ($el, <IFName::Element>);

        $test->id ('nodeName');
        $test->assert_equals ($el-><AG::Node.nodeName>, 'a:el');

        $test->id ('localName');
        $test->assert_equals ($el-><AG::Node.localName>, 'el');

        $test->id ('namespaceURI');
        $test->assert_equals ($el-><AG::Node.namespaceURI>, 'about:');

        $test->id ('prefix');
        $test->assert_equals ($el-><AG::Node.prefix>, 'a');
    @@Test:
      @@@QName: Document.createElementNS.nodefaultattr.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createElementNS> (null, 'et1');

        $test->assert_num_equals
                 (actual_value => $el-><AG::Node.attributes>
                                     -><AG::NamedNodeMap.length>,
                  expected_value => 0);
    @@Test:
      @@@QName: Document.createElementNS.defaultattr.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docd = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>, '3.0');
        my $dtd = $docd-><M::d|DocumentXDoctype.createDocumentTypeDefinition>
                           ('doctype');
          my $et = $docd-><M::d|DocumentXDoctype.createElementTypeDefinition>
                             ('et1');
            my $at = $docd-><M::d|DocumentXDoctype.createAttributeDefinition>
                               ('dattr1');
            $at-><AS::ATDef.defaultType> (<C::ATDef.EXPLICIT_DEFAULT>);
            $at-><AS::Node.textContent> ('dattr1 default ');
          $et-><M::ETDef.setAttributeDefinitionNode> ($at);
        $dtd-><M::DTDef.setElementTypeDefinitionNode> ($et);
        $doc-><M::Node.appendChild> ($dtd);

        my $el = $doc-><M::Document.createElementNS> (null, 'et1');

        $test->id ('attributes.length');
        $test->assert_num_equals
                 (actual_value => $el-><AG::Node.attributes>
                                     -><AG::NamedNodeMap.length>,
                  expected_value => 1);
        
        $test->id ('has.attribute');
        $test->assert_true ($el-><M::Element.hasAttribute> ('dattr1'));

        $test->id ('get.attr.node');
        my $an = $el-><M::Element.getAttributeNode> ('dattr1');
        $test->assert_isa ($an, <IFName::Attr>);

        $test->id ('attr.text.content');
        $test->assert_equals ($an-><AG::Node.textContent>, 'dattr1 default ');
        
        $test->id ('attr.specified');
        $test->assert_false ($an-><AG::Attr.specified>);
    @@Test:
      @@@QName: Document.createElementNS.defaultattr.typed.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docd = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>, '3.0');
        my $dtd = $docd-><M::d|DocumentXDoctype.createDocumentTypeDefinition>
                           ('doctype');
          my $et = $docd-><M::d|DocumentXDoctype.createElementTypeDefinition>
                             ('et1');
            my $at = $docd-><M::d|DocumentXDoctype.createAttributeDefinition>
                               ('dattr1');
            $at-><AS::ATDef.defaultType> (<C::ATDef.EXPLICIT_DEFAULT>);
            $at-><AS::Node.textContent> ('dattr1 default ');
            $at-><AS::ATDef.declaredType> (<C::ATDef.NMTOKENS_ATTR>);
          $et-><M::ETDef.setAttributeDefinitionNode> ($at);
        $dtd-><M::DTDef.setElementTypeDefinitionNode> ($et);
        $doc-><M::Node.appendChild> ($dtd);

        my $el = $doc-><M::Document.createElementNS> (null, 'et1');

        $test->id ('attributes.length');
        $test->assert_num_equals
                 (actual_value => $el-><AG::Node.attributes>
                                     -><AG::NamedNodeMap.length>,
                  expected_value => 1);
        
        $test->id ('has.attribute');
        $test->assert_true ($el-><M::Element.hasAttribute> ('dattr1'));

        $test->id ('get.attr.node');
        my $an = $el-><M::Element.getAttributeNode> ('dattr1');
        $test->assert_isa ($an, <IFName::Attr>);

        $test->id ('attr.text.content');
        $test->assert_equals ($an-><AG::Node.textContent>, 'dattr1 default ');
        
        $test->id ('attr.specified');
        $test->assert_false ($an-><AG::Attr.specified>);

        $test->id ('attr.type');
        my $ti = $an-><AG::Attr.schemaTypeInfo>;
        $test->assert_equals
                 ($ti-><AG::c|TypeInfo.typeNamespace>, <Q::xml-dtd:>);
        $test->assert_equals ($ti-><AG::c|TypeInfo.typeName>, 'NMTOKENS');
    @@Test:
      @@@QName: Document.createElementNS.defaultattr.3.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docd = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>, '3.0');
        my $dtd = $docd-><M::d|DocumentXDoctype.createDocumentTypeDefinition>
                           ('doctype');
          my $et = $docd-><M::d|DocumentXDoctype.createElementTypeDefinition>
                             ('et1');
            my $at = $docd-><M::d|DocumentXDoctype.createAttributeDefinition>
                               ('dattr1');
            $at-><AS::ATDef.defaultType> (<C::ATDef.EXPLICIT_DEFAULT>);
            $at-><AS::Node.textContent> ('dattr1 default ');
          $et-><M::ETDef.setAttributeDefinitionNode> ($at);
        $dtd-><M::DTDef.setElementTypeDefinitionNode> ($et);
        $doc-><M::Node.appendChild> ($dtd);

        $doc-><AG::Document.domConfig>
            -><M::c|DOMConfiguration.setParameter>
                 (<Q::cfg|dtd-default-attributes> => false);

        my $el = $doc-><M::Document.createElementNS> (null, 'et1');

        $test->id ('attributes.length');
        $test->assert_num_equals
                 (actual_value => $el-><AG::Node.attributes>
                                     -><AG::NamedNodeMap.length>,
                  expected_value => 0);

  @CODE:
    @@QName: tc|exposeDefaultAttributes
    @@PerlDef:
      __DEEP{
        my $__doctype = $document-><AG::Document.doctype>;
        my $__cfg = $document-><AG::Document.domConfig>;
        undef $__doctype unless $__cfg-><M::c|DOMConfiguration.getParameter>
                                          (<Q::cfg|dtd-default-attributes>);
        $__doctype = $__doctype-><M::Node.getFeature>
                                   (<Q::fe|XDoctype> => '3.0')
          if $__doctype;
        if ($__doctype) {
          my $__et = $__doctype-><M::DTDef.getElementTypeDefinitionNode>
                                   ($element_type);
          if ($__et) {
            my $__orig_strict = $document-><AG::Document.strictErrorChecking>;
            $document-><AS::Document.strictErrorChecking> (false);
            my %__gattr;
            my %__has_attr;
            my %__pfx_to_uri;
            my $__copy_asis = $__cfg-><M::c|DOMConfiguration.getParameter>
                                     (<Q::cfg|clone-entity-reference-subtree>);
            $__cfg-><M::c|DOMConfiguration.setParameter>
                          (<Q::cfg|clone-entity-reference-subtree> => true);
            for my $__at (@{$__et-><AG::ETDef.attributeDefinitions>}) {
              my $__at_default = $__at-><AG::ATDef.defaultType>;
              if ($__at_default == <C::ATDef.EXPLICIT_DEFAULT> or
                  $__at_default == <C::ATDef.FIXED_DEFAULT>) {
                my ($__nn1, $__nn2) = split /:/, $__at-><AG::Node.nodeName>;
                if (defined $__nn2) { # prefixed
                  if ($__nn1 eq 'xmlns') {
                    ## TODO: NCName check, prefix check and NSURI check
                    my $__attr = $document-><M::Document.createAttributeNS>
                                              (<Q::xmlns:>, [$__nn1, $__nn2]);
                    for my $__at_child (@{$__at-><AG::Node.childNodes>}) {
                      $__attr-><M::Node.appendChild>
                                 ($__at_child-><M::Node.cloneNode> (true));
                    }
                    __CODE{tc|setAttrType::
                      $ref => $__attr,
                      $type => {$__at-><AG::ATDef.declaredType>},
                    }__;
                    my $__nsuri = $__attr-><AG::Attr.value>;
                    ## TODO: Namespace well-formedness check (NSURI), v1.1 chk
                    $__pfx_to_uri{$__nn2} = $__nsuri;
                    $element-><M::Element.setAttributeNodeNS> ($__attr);
                             ## This method changes |specified| flag
                    $__attr-><AS::Attr.specified> (false);
                    $__has_attr{<Q::xmlns:>}->{$__nn2} = true;
                  } else {
                    ## TODO: NCName check
                    $__gattr{$__nn1}->{$__nn2} = $__at;
                  }
                } else {            # no prefixed
                  my $__attr;
                  if ($__nn1 eq 'xmlns') {
                    $__attr = $document-><M::Document.createAttributeNS>
                                              (<Q::xmlns:>, 'xmlns');
                    $__has_attr{<Q::xmlns:>}->{xmlns} = true;
                  } else {
                    $__attr = $document-><M::Document.createAttributeNS>
                                              (null, $__nn1);
                    ## TODO: NCName check
                  }
                  for my $__at_child (@{$__at-><AG::Node.childNodes>}) {
                    $__attr-><M::Node.appendChild>
                               ($__at_child-><M::Node.cloneNode> (true));
                  }
                  __CODE{tc|setAttrType::
                    $ref => $__attr,
                    $type => {$__at-><AG::ATDef.declaredType>},
                  }__;
                  ## TODO: Namespace well-formedness check (NSURI)
                  $element-><M::Element.setAttributeNodeNS> ($__attr);
                             ## This method changes |specified| flag
                  $__attr-><AS::Attr.specified> (false);
                }
              }
            } # attrdefs
            for my $__pfx (keys %__gattr) {
              my $__nsuri = $__pfx_to_uri{$__pfx};
              unless (defined $__nsuri) {
                ## TODO: Namespace well-formedness error
              }
              LN: for my $__ln (keys %{$__gattr{$__pfx}}) {
                if ($__has_attr{defined $__nsuri ? $__nsuri : ''}->{$__ln}) {
                  ## TODO: Namespace well-formedness error
                  next LN;
                }
                ## TODO: NCName check, prefix check and NSURI check
                my $__at = $__gattr{$__pfx}->{$__ln};
                my $__attr = $document-><M::Document.createAttributeNS>
                                          ($__nsuri, [$__pfx, $__ln]);
                for my $__at_child (@{$__at-><AG::Node.childNodes>}) {
                  $__attr-><M::Node.appendChild>
                             ($__at_child-><M::Node.cloneNode> (true));
                }
                __CODE{tc|setAttrType::
                  $ref => $__attr,
                  $type => {$__at-><AG::ATDef.declaredType>},
                }__;
                $element-><M::Element.setAttributeNodeNS> ($__attr);
                             ## This method changes |specified| flag
                $__attr-><AS::Attr.specified> (false);
                $__has_attr{defined $__nsuri ? $__nsuri : ''}->{$__ln} = true;
              } # LN
            } # pfx
            $__cfg-><M::c|DOMConfiguration.setParameter>
                    (<Q::cfg|clone-entity-reference-subtree> => $__copy_asis);
            $document-><AS::Document.strictErrorChecking> ($__orig_strict);
          }
        }
      }__;
    @@enImplNote:
      @@@ddid: webbrowsers
      @@@@:
        Firefox 1.5 and Opera 9 Preview 1 do not add default attributes
        by <M::Document.createElement> and <M::Document.createElementNS>.
        Opera does not support default attribute addition at 
        parsing time in internal subset neither.
        Firefox <EM::does> support it but <A::Attr.specified> of the default
        attributes are set to <DOM::true>.

  @Method:
    @@Name: createAttribute
    @@enDesc:
      Creates an <IF::Attr> of the given name.
    @@NSVersion: .createAttributeNS
    @@Param:
      @@@Name: name
      @@@Type: DOMString
      @@@enDesc:
        The name of the attribute.
      @@@enImplNote:
        {ISSUE::
           Case in HTML documents??
        }
    @@Return:
      @@@Type: Attr
      @@@enDesc:
        {P:: A new <IF::Attr> object with:

          - <A::Node.nodeName>::: <P::name>.

          - <A::Node.localName>::: <DOM::null>.  <SRC::DOM2, DOM3>
              However, in manakai, as well as Web browsers, 
              it is set to <P::name> even if it is not an <CODE::NCName>.

          - <A::Node.prefix>::: <DOM::null>.

          - <A::Node.namespaceURI>::: <DOM::null>.

          - <A::Attr.value>::: The empty string.

          - <A::Attr.specified>::: <DOM::true>.  <SRC::DOM1, DOM2>
                Note that it is set to <DOM::false> in Gecko.

        }
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_BAD_NAME
        @@@@enDesc:
          If the specified name is not an <CODE::XML> name
          according to the XML version in use specified in
          the <A::Document.xmlVersion> attribute.
      @@@PerlDef:
        my $version = $self-><AG::Document.xmlVersion>;
        __CODE{DOMMain|ensureXMLName::
          $INPUT => $name, $INPUT_PARAM_NAME => 'name',
          $XMLVERSION => $version,
        }__;
        __DEEP{
          my $strict = $self-><AG::Document.strictErrorChecking>;
          $r = $self-><M::Document.createAttributeNS> (null, [null, $name]);
          $self-><AS::Document.strictErrorChecking> ($strict);
        }__;
      @@@enImplNote:
        @@@@ddid: schema
        @@@@For: ManakaiDOM|ManakaiDOM
        @@@@@:
          The created node does not have DTD type information,
          since its element type is not known.

    @@Test:
      @@@QName: Document.createAttribute.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $attr = $doc-><M::Document.createAttribute> ('attrName');

        $test->id ('interface');
        $test->assert_isa ($attr, <IFName::Attr>);

        $test->id ('nodeName');
        $test->assert_equals ($attr-><AG::Node.nodeName>, 'attrName');

        $test->id ('localName');
        $test->assert_equals ($attr-><AG::Node.localName>, 'attrName');

        $test->id ('prefix');
        $test->assert_null ($attr-><AG::Node.prefix>);

        $test->id ('namespaceURI');
        $test->assert_null ($attr-><AG::Node.namespaceURI>);

        $test->id ('specified');
        $test->assert_true ($attr-><AG::Node.specified>);

        $test->id ('value');
        $test->assert_equals ($attr-><AG::Node.value>, '');

        $test->id ('childNodes.length');
        $test->assert_num_equals
                 (expected_value => 0+@{$attr-><AG::Node.childNodes>},
                  actual_value => 0);
    @@Test:
      @@@QName: Document.createAttribute.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $attr = $doc-><M::Document.createAttribute> ('attr:name');

        $test->id ('interface');
        $test->assert_isa ($attr, <IFName::Attr>);

        $test->id ('nodeName');
        $test->assert_equals ($attr-><AG::Node.nodeName>, 'attr:name');

        $test->id ('localName');
        $test->assert_equals ($attr-><AG::Node.localName>, 'attr:name');

        $test->id ('prefix');
        $test->assert_null ($attr-><AG::Node.prefix>);

        $test->id ('namespaceURI');
        $test->assert_null ($attr-><AG::Node.namespaceURI>);
    @@Test:
      @@@QName: Document.createAttribute.3.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $attr = $doc-><M::Document.createAttribute> ('xml:lang');

        $test->id ('interface');
        $test->assert_isa ($attr, <IFName::Attr>);

        $test->id ('nodeName');
        $test->assert_equals ($attr-><AG::Node.nodeName>, 'xml:lang');

        $test->id ('localName');
        $test->assert_equals ($attr-><AG::Node.localName>, 'xml:lang');

        $test->id ('prefix');
        $test->assert_null ($attr-><AG::Node.prefix>);

        $test->id ('namespaceURI');
        $test->assert_null ($attr-><AG::Node.namespaceURI>);
    @@Test:
      @@@QName: Document.createAttribute.4.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $attr = $doc-><M::Document.createAttribute> ('xmlns');

        $test->id ('interface');
        $test->assert_isa ($attr, <IFName::Attr>);

        $test->id ('nodeName');
        $test->assert_equals ($attr-><AG::Node.nodeName>, 'xmlns');

        $test->id ('localName');
        $test->assert_equals ($attr-><AG::Node.localName>, 'xmlns');

        $test->id ('prefix');
        $test->assert_null ($attr-><AG::Node.prefix>);

        $test->id ('namespaceURI');
        $test->assert_null ($attr-><AG::Node.namespaceURI>);
    @@L3Test:
      @@@QName: Doc.createAttr.xmlid.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $cfg = $doc-><AG::Document.domConfig>;
        $doc-><AS::Document.strictErrorChecking> (false);

        $test->id ('id.xmlid');
        $cfg-><M::c|DOMConfiguration.setParameter> (<Q::cfg|xml-id> => true);
        my $at1 = $doc-><M::Document.createAttribute> ('xml:id');
        $test->assert_equals
                 ($at1-><AG::Attr.schemaTypeInfo>-><AG::c|TypeInfo.typeName>,
                  'ID');
        $test->assert_equals
                 ($at1-><AG::Attr.schemaTypeInfo>
                      -><AG::c|TypeInfo.typeNamespace>,
                  <Q::xml-dtd:>);

        $test->id ('id.other');
        my $at2 = $doc-><M::Document.createAttribute> ('id');
        $test->assert_null
                 ($at2-><AG::Attr.schemaTypeInfo>-><AG::c|TypeInfo.typeName>);
        $test->assert_null
                 ($at2-><AG::Attr.schemaTypeInfo>
                      -><AG::c|TypeInfo.typeNamespace>);

        $test->id ('noid.xmlid');
        $cfg-><M::c|DOMConfiguration.setParameter> (<Q::cfg|xml-id> => false);
        my $at3 = $doc-><M::Document.createAttribute> ('xml:id');
        $test->assert_null
                 ($at3-><AG::Attr.schemaTypeInfo>-><AG::c|TypeInfo.typeName>);
        $test->assert_null
                 ($at3-><AG::Attr.schemaTypeInfo>
                      -><AG::c|TypeInfo.typeNamespace>);

        $test->id ('noid.other');
        my $at4 = $doc-><M::Document.createAttribute> ('id');
        $test->assert_null
                 ($at4-><AG::Attr.schemaTypeInfo>-><AG::c|TypeInfo.typeName>);
        $test->assert_null
                 ($at4-><AG::Attr.schemaTypeInfo>
                      -><AG::c|TypeInfo.typeNamespace>);

  @L2Method:
    @@Name: createAttributeNS
    @@enDesc:
      Creates an attribute of the given qualified name and namespace URI.
    @@NoNSVersion: .createAttribute
    @@XML2Feature:
    @@Param:
      @@@Name: namespaceURI
      @@@Type: DOMString
      @@@dis:actualType: ManakaiDOM|ManakaiDOMNamespaceURI
      @@@enDesc:
        The namespace URI of the attribute to create.

        If the attribute has no namespace.
    @@Param:
      @@@Name: qualifiedName
      @@@Type: DOMString
      @@@dis:actualType:
        @@@@@: DOMMain|ManakaiDOMXMLQName
        @@@@ManakaiDOM:noInputNormalize: 1
      @@@enDesc:
        The qualified name of the attribute to create.
      @@@InCase:
        @@@@Type: ARRAY
        @@@@enDesc:
          A reference to the array that contains the namespace
          prefix (zeroth item) and the local name (first item)
          of the attribute.  The namespace prefix <kwd:MAY>
          be <DOM::null> to indicate that the qualified name
          contains no <CHAR::COLON> character.
    @@Return:
      @@@Type: Attr
      @@@enDesc:
        {P:: A new <IF::Attr> object with:

          - <A::Node.nodeName>::: <P::qualifiedName>.

          - <A::Node.namespaceURI>::: <P::namespaceURI>.

          - <A::Node.prefix>::: The prefix extracted from <P::qualifiedName>,
                                if any, or <DOM::null> otherwise.

          - <A::Node.localName>::: The local name extracted from
                                   <P::qualifiedName>.

          - <A::Attr.name>::: <P::qualifiedName>.

          - <A::Node.nodeValue>::: The empty string.

          - <A::Attr.specified>::: <DOM::true>.  <SRC::DOM2>
      
        }
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_BAD_NAME
        @@@@enDesc:
          If the <P::qualifiedName> is not an XML <CODE::Name>
          according to the XML version in use specified in
          the <A::Document.xmlVersion> attribute.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_NS_MALFORMED_QNAME
        @@@@enDesc:
          If the <P::qualifiedName> is a malformed qualified name.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_NS_PREFIX_WITH_NULL_URI
        @@@@enDesc:
          If the <P::qualifiedName> has a prefix and the 
          <P::namespaceURI> is <DOM::null>.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_NS_XML_WITH_OTHER_URI
        @@@@enDesc:
          If the <P::qualifiedName> has a prefix that is <XML::xml>
          and the <P::namespaceURI> is different from
          <URI::http://www.w3.org/XML/1998/namespace>.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_NS_XMLNS_WITH_OTHER_URI
        @@@@enDesc:
          If the <P::qualifiedName> has a prefix that is <P::xmlns>
          and the <P::namespaceURI> is different from
          <URI::http://www.w3.org/20900/xmlns/>.  <SRC::DOM3>
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_NS_XMLNSQ_WITH_OTHER_URI
        @@@@enDesc:
          If the <P::qualifiedName> is <XA::xmlns> and the
          <P::namespaceURI> is different from 
          <URI::http://www.w3.org/2000/xmlns/>.
      @@@iRaises:
        @@@@@: MDOMX|MDOM_DOC_NOSUPPORT_XML
        @@@@enDesc:
          If the current document does not support the <Feature::XML>
          feature.
      @@@PerlDef:
        my ($prefix, $lname) = ref $qualifiedName eq 'ARRAY'
                                 ? @$qualifiedName
                                 : split /:/, $qualifiedName, 2;
        ($prefix, $lname) = (null, $prefix) unless defined $lname;

        if ($self-><AG::Document.strictErrorChecking>) {
          my $version = $od-><AG::Document.xmlVersion>;
          $qualifiedName = defined $prefix ? $prefix.':'.$lname
                                           : $lname;
          __CODE{DOMMain|ensureXMLQName::
            $INPUT = $qualifiedName, 
            $INPUT_PARAM_NAME = 'qualifiedName',
            $XMLVERSION = $version,
          }__;
          __CODE{DOMMain|checkXMLNamesQName::
            $PREFIX => $prefix, $NSURI => $namespaceURI,
            $LNAME => $lname,
          }__;
        }

        my $bag = <Code::mg|getNodeBag||ManakaiDOM|all:: $ref = $self>;
        my $stem;
        __CODE{mg|createNodeStem||ManakaiDOM|all::
          $bag => $bag,
          $stem => $stem,
          $class => {<ClassName::ManakaiDOMAttr>},
          $opt => {{
            <H::tc|ownerDocument> => $self,
            <H::infoset|namespaceName> => \$namespaceURI,
            <H::infoset|prefix> => \$prefix,
            <H::infoset|localName> => \$lname,
            <H::infoset|specified> => true,
          }},
        }__;
        __CODE{mg|createNodeRef||ManakaiDOM|all::
          $bag => $bag,
          $stem => $stem,
          $ref => $r,
          $opt => {{
          }},
        }__;

        ## Attribute type information
        if ((defined $namespaceURI and $namespaceURI eq <Q::xml:> and
             $lname eq 'id') or
            (not defined $namespaceURI and $lname eq 'xml:id')) {
          __DEEP{
            if ($self-><AG::Document.domConfig>
                     -><M::c|DOMConfiguration.getParameter>
                         (<Q::cfg|xml-id>)) {
              __CODE{tc|setAttrType::
                $ref => $r,
                $type => {<C::ATDef.ID_ATTR>},
              }__;
            }
          }__;
        }

    @@Test:
      @@@QName: Doc.createAttrNS.mg.1.test
      @@@PerlDef:
        local $Message::DOM::TreeCore::GCLatency = 0;

        my $impl = <ClassM::ManakaiDOMImplementationTC.new>;

        my $bag = $impl->{<H::mg|nodeBag>};
        my $id = $impl->{<H::mg|nodeIDReference>};

        my $doc = $impl-><M::c|DOMImplementation.createDocument>;

        my $el = $doc-><M::Document.createAttributeNS> (null, 'e');
        
        $test->id ('interface');
        $test->assert_isa ($el, <IFName::Attr>);
        
        $test->id ('class');
        $test->assert_isa ($el, <ClassName::ManakaiDOMAttr>);

        my $doc_id = $doc->{<H::mg|nodeIDReference>};
        my $el_id = $el->{<H::mg|nodeIDReference>};

        undef $impl;

        $test->id ('gc.impl.1');
        $test->assert_not_null ($bag->{$$id});

        $test->id ('gc.doc.1');
        $test->assert_not_null ($bag->{$$doc_id});

        $test->id ('gc.el.1');
        $test->assert_not_null ($bag->{$$el_id});

        undef $doc;

        $test->id ('gc.impl.2');
        $test->assert_not_null ($bag->{$$id});

        $test->id ('gc.doc.2');
        $test->assert_not_null ($bag->{$$doc_id});

        $test->id ('gc.el.2');
        $test->assert_not_null ($bag->{$$el_id});

        undef $el;

        $test->id ('gc.impl.3');
        $test->assert_null ($bag->{$$id});

        $test->id ('gc.doc.3');
        $test->assert_null ($bag->{$$doc_id});

        $test->id ('gc.el.3');
        $test->assert_null ($bag->{$$el_id});
    @@Test:
      @@@QName: Document.createAttributeNS.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $attr = $doc-><M::Document.createAttributeNS> (null, 'a1');

        $test->id ('interface');
        $test->assert_isa ($attr, <IFName::Attr>);

        $test->id ('nodeName');
        $test->assert_equals ($attr-><AG::Node.nodeName>, 'a1');

        $test->id ('localName');
        $test->assert_equals ($attr-><AG::Node.localName>, 'a1');

        $test->id ('namespaceURI');
        $test->assert_null ($attr-><AG::Node.namespaceURI>);

        $test->id ('prefix');
        $test->assert_null ($attr-><AG::Node.prefix>);

        $test->id ('value');
        $test->assert_equals ($attr-><AG::Node.value>, '');

        $test->id ('specified');
        $test->assert_true ($attr-><AG::Node.specified>);

        $test->id ('ownerElement');
        $test->assert_null ($attr-><AG::Node.ownerElement>);
    @@Test:
      @@@QName: Document.createAttributeNS.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $attr = $doc-><M::Document.createAttributeNS> ('about:', 'a:a1');

        $test->id ('interface');
        $test->assert_isa ($attr, <IFName::Attr>);

        $test->id ('nodeName');
        $test->assert_equals ($attr-><AG::Node.nodeName>, 'a:a1');

        $test->id ('localName');
        $test->assert_equals ($attr-><AG::Node.localName>, 'a1');

        $test->id ('namespaceURI');
        $test->assert_equals ($attr-><AG::Node.namespaceURI>, 'about:');

        $test->id ('prefix');
        $test->assert_equals ($attr-><AG::Node.prefix>, 'a');
    @@Test:
      @@@QName: Document.createAttributeNS.3.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $attr = $doc-><M::Document.createAttributeNS>
                           (<Q::xml:>, 'xml:lang');

        $test->id ('interface');
        $test->assert_isa ($attr, <IFName::Attr>);

        $test->id ('nodeName');
        $test->assert_equals ($attr-><AG::Node.nodeName>, 'xml:lang');

        $test->id ('localName');
        $test->assert_equals ($attr-><AG::Node.localName>, 'lang');

        $test->id ('namespaceURI');
        $test->assert_equals ($attr-><AG::Node.namespaceURI>, <Q::xml:>);

        $test->id ('prefix');
        $test->assert_equals ($attr-><AG::Node.prefix>, 'xml');
    @@Test:
      @@@QName: Document.createAttributeNS.4.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $attr = $doc-><M::Document.createAttributeNS>
                           (<Q::xmlns:>, 'xmlns');

        $test->id ('interface');
        $test->assert_isa ($attr, <IFName::Attr>);

        $test->id ('nodeName');
        $test->assert_equals ($attr-><AG::Node.nodeName>, 'xmlns');

        $test->id ('localName');
        $test->assert_equals ($attr-><AG::Node.localName>, 'xmlns');

        $test->id ('namespaceURI');
        $test->assert_equals ($attr-><AG::Node.namespaceURI>, <Q::xmlns:>);

        $test->id ('prefix');
        $test->assert_null ($attr-><AG::Node.prefix>);
    @@Test:
      @@@QName: Document.createAttributeNS.5.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $attr = $doc-><M::Document.createAttributeNS>
                           (<Q::xml:>, ['xml', 'lang']);

        $test->id ('interface');
        $test->assert_isa ($attr, <IFName::Attr>);

        $test->id ('nodeName');
        $test->assert_equals ($attr-><AG::Node.nodeName>, 'xml:lang');

        $test->id ('localName');
        $test->assert_equals ($attr-><AG::Node.localName>, 'lang');

        $test->id ('namespaceURI');
        $test->assert_equals ($attr-><AG::Node.namespaceURI>, <Q::xml:>);

        $test->id ('prefix');
        $test->assert_equals ($attr-><AG::Node.prefix>, 'xml');
    @@L3Test:
      @@@QName: Doc.createAttrNS.xmlid.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $cfg = $doc-><AG::Document.domConfig>;
        $doc-><AS::Document.strictErrorChecking> (false);

        $test->id ('id.xmlid');
        $cfg-><M::c|DOMConfiguration.setParameter> (<Q::cfg|xml-id> => true);
        my $at1 = $doc-><M::Document.createAttributeNS> (<Q::xml:>, 'xml:id');
        $test->assert_equals
                 ($at1-><AG::Attr.schemaTypeInfo>-><AG::c|TypeInfo.typeName>,
                  'ID');
        $test->assert_equals
                 ($at1-><AG::Attr.schemaTypeInfo>
                      -><AG::c|TypeInfo.typeNamespace>,
                  <Q::xml-dtd:>);

        $test->id ('id.other');
        my $at2 = $doc-><M::Document.createAttributeNS> (null, 'id');
        $test->assert_null
                 ($at2-><AG::Attr.schemaTypeInfo>-><AG::c|TypeInfo.typeName>);
        $test->assert_null
                 ($at2-><AG::Attr.schemaTypeInfo>
                      -><AG::c|TypeInfo.typeNamespace>);

        $test->id ('noid.xmlid');
        $cfg-><M::c|DOMConfiguration.setParameter> (<Q::cfg|xml-id> => false);
        my $at3 = $doc-><M::Document.createAttributeNS> (<Q::xml:>, 'xml:id');
        $test->assert_null
                 ($at3-><AG::Attr.schemaTypeInfo>-><AG::c|TypeInfo.typeName>);
        $test->assert_null
                 ($at3-><AG::Attr.schemaTypeInfo>
                      -><AG::c|TypeInfo.typeNamespace>);

        $test->id ('noid.other');
        my $at4 = $doc-><M::Document.createAttributeNS> (null, 'id');
        $test->assert_null
                 ($at4-><AG::Attr.schemaTypeInfo>-><AG::c|TypeInfo.typeName>);
        $test->assert_null
                 ($at4-><AG::Attr.schemaTypeInfo>
                      -><AG::c|TypeInfo.typeNamespace>);

  @Method:
    @@Name: createTextNode
    @@enDesc:
      Creates a <IF::Text> node given the specified string.
    @@Param:
      @@@Name: data
      @@@Type: DOMString
      @@@enDesc:
        The data for the node.
    @@Return:
      @@@Type: Text
      @@@enDesc:
        The newly created <IF::Text> node.
      @@@PerlDef:
        my $bag = <Code::mg|getNodeBag||ManakaiDOM|all:: $ref = $self>;
        my $stem;
        __CODE{mg|createNodeStem||ManakaiDOM|all::
          $bag => $bag,
          $stem => $stem,
          $class => {<ClassName::ManakaiDOMText>},
          $opt => {{
            <H::tc|ownerDocument> => $self,
            <H::infoset|content> => \$data,
          }},
        }__;
        __CODE{mg|createNodeRef||ManakaiDOM|all::
          $bag => $bag,
          $stem => $stem,
          $ref => $r,
          $opt => {{
          }},
        }__;

    @@Test:
      @@@QName: Doc.createTextNode.mg.1.test
      @@@PerlDef:
        local $Message::DOM::TreeCore::GCLatency = 0;

        my $impl = <ClassM::ManakaiDOMImplementationTC.new>;

        my $bag = $impl->{<H::mg|nodeBag>};
        my $id = $impl->{<H::mg|nodeIDReference>};

        my $doc = $impl-><M::c|DOMImplementation.createDocument>;

        my $el = $doc-><M::Document.createTextNode> ('textdata');
        
        $test->id ('interface');
        $test->assert_isa ($el, <IFName::Text>);
        
        $test->id ('class');
        $test->assert_isa ($el, <ClassName::ManakaiDOMText>);

        my $doc_id = $doc->{<H::mg|nodeIDReference>};
        my $el_id = $el->{<H::mg|nodeIDReference>};

        undef $impl;

        $test->id ('gc.impl.1');
        $test->assert_not_null ($bag->{$$id});

        $test->id ('gc.doc.1');
        $test->assert_not_null ($bag->{$$doc_id});

        $test->id ('gc.el.1');
        $test->assert_not_null ($bag->{$$el_id});

        undef $doc;

        $test->id ('gc.impl.2');
        $test->assert_not_null ($bag->{$$id});

        $test->id ('gc.doc.2');
        $test->assert_not_null ($bag->{$$doc_id});

        $test->id ('gc.el.2');
        $test->assert_not_null ($bag->{$$el_id});

        undef $el;

        $test->id ('gc.impl.3');
        $test->assert_null ($bag->{$$id});

        $test->id ('gc.doc.3');
        $test->assert_null ($bag->{$$doc_id});

        $test->id ('gc.el.3');
        $test->assert_null ($bag->{$$el_id});
    @@Test:
      @@@QName: Document.createTextNode.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $text = $doc-><M::Document.createTextNode> ('text data');
       
        $test->id ('interface');
        $test->assert_isa ($text, <IFName::Text>);

        $test->id ('nodeValue');
        $test->assert_equals ($text-><AG::Node.nodeValue>, 'text data');
 
        $test->id ('isElementContentWhitespace');
        $test->assert_false ($text-><AG::Text.isElementContentWhitespace>);
    @@Test:
      @@@QName: Document.createTextNode.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $text = $doc-><M::Document.createTextNode> ('');
       
        $test->id ('interface');
        $test->assert_isa ($text, <IFName::Text>);

        $test->id ('nodeValue');
        $test->assert_equals ($text-><AG::Node.nodeValue>, '');
 
        $test->id ('isElementContentWhitespace');
        $test->assert_false ($text-><AG::Text.isElementContentWhitespace>);

  @Method:
    @@Name: createCDATASection
    @@enDesc:
      Creates a <IF::tx|CDATASection> node.
    @@Param:
      @@@Name: data
      @@@Type: DOMString
      @@@enDesc:
        The data for the <IF::tx|CDATASection> content.
    @@Return:
      @@@Type: tx|CDATASection
      @@@enDesc:
        The newly created <IF::tx|CDATASection> node.
      @@@iRaises:
        @@@@@: MDOMX|MDOM_DOC_NOSUPPORT_XML
        @@@@enDesc:
          If the document is an HTML document.
      @@@PerlDef:
        require Message::DOM::XML;
        my $bag = <Code::mg|getNodeBag||ManakaiDOM|all:: $ref = $self>;
        my $stem;
        __CODE{mg|createNodeStem||ManakaiDOM|all::
          $bag => $bag,
          $stem => $stem,
          $class => {<ClassName::tx|ManakaiDOMCDATASection>},
          $opt => {{
            <H::tc|ownerDocument> => $self,
            <H::infoset|content> => \$data,
          }},
        }__;
        __CODE{mg|createNodeRef||ManakaiDOM|all::
          $bag => $bag,
          $stem => $stem,
          $ref => $r,
          $opt => {{
          }},
        }__;

    @@Test:
      @@@QName: Doc.createCDATASection.mg.1.test
      @@@PerlDef:
        local $Message::DOM::TreeCore::GCLatency = 0;

        my $impl = <ClassM::ManakaiDOMImplementationTC.new>;

        my $bag = $impl->{<H::mg|nodeBag>};
        my $id = $impl->{<H::mg|nodeIDReference>};

        my $doc = $impl-><M::c|DOMImplementation.createDocument>;

        my $el = $doc-><M::Document.createCDATASection> ('textdata');
        
        $test->id ('interface');
        $test->assert_isa ($el, <IFName::tx|CDATASection>);
        
        $test->id ('class');
        $test->assert_isa ($el, <ClassName::tx|ManakaiDOMCDATASection>);

        my $doc_id = $doc->{<H::mg|nodeIDReference>};
        my $el_id = $el->{<H::mg|nodeIDReference>};

        undef $impl;

        $test->id ('gc.impl.1');
        $test->assert_not_null ($bag->{$$id});

        $test->id ('gc.doc.1');
        $test->assert_not_null ($bag->{$$doc_id});

        $test->id ('gc.el.1');
        $test->assert_not_null ($bag->{$$el_id});

        undef $doc;

        $test->id ('gc.impl.2');
        $test->assert_not_null ($bag->{$$id});

        $test->id ('gc.doc.2');
        $test->assert_not_null ($bag->{$$doc_id});

        $test->id ('gc.el.2');
        $test->assert_not_null ($bag->{$$el_id});

        undef $el;

        $test->id ('gc.impl.3');
        $test->assert_null ($bag->{$$id});

        $test->id ('gc.doc.3');
        $test->assert_null ($bag->{$$doc_id});

        $test->id ('gc.el.3');
        $test->assert_null ($bag->{$$el_id});

  @Method:
    @@Name: createComment
    @@enDesc:
      Creates a <IF::Comment> node.
    @@Param:
      @@@Name: data
      @@@Type: DOMString
      @@@enDesc:
        The data for the node.
    @@Return:
      @@@Type: Comment
      @@@enDesc:
        The newly created <IF::Comment> node.
      @@@PerlDef:
        my $bag = <Code::mg|getNodeBag||ManakaiDOM|all:: $ref = $self>;
        my $stem;
        __CODE{mg|createNodeStem||ManakaiDOM|all::
          $bag => $bag,
          $stem => $stem,
          $class => {<ClassName::ManakaiDOMComment>},
          $opt => {{
            <H::tc|ownerDocument> => $self,
            <H::infoset|content> => \$data,
          }},
        }__;
        __CODE{mg|createNodeRef||ManakaiDOM|all::
          $bag => $bag,
          $stem => $stem,
          $ref => $r,
          $opt => {{
          }},
        }__;

    @@Test:
      @@@QName: Document.createComment.mg.1.test
      @@@PerlDef:
        local $Message::DOM::TreeCore::GCLatency = 0;

        my $impl = <ClassM::ManakaiDOMImplementationTC.new>;

        my $bag = $impl->{<H::mg|nodeBag>};
        my $id = $impl->{<H::mg|nodeIDReference>};

        my $doc = $impl-><M::c|DOMImplementation.createDocument>;

        my $el = $doc-><M::Document.createComment> ('textdata');
        
        $test->id ('interface');
        $test->assert_isa ($el, <IFName::Comment>);
        
        $test->id ('class');
        $test->assert_isa ($el, <ClassName::ManakaiDOMComment>);

        my $doc_id = $doc->{<H::mg|nodeIDReference>};
        my $el_id = $el->{<H::mg|nodeIDReference>};

        undef $impl;

        $test->id ('gc.impl.1');
        $test->assert_not_null ($bag->{$$id});

        $test->id ('gc.doc.1');
        $test->assert_not_null ($bag->{$$doc_id});

        $test->id ('gc.el.1');
        $test->assert_not_null ($bag->{$$el_id});

        undef $doc;

        $test->id ('gc.impl.2');
        $test->assert_not_null ($bag->{$$id});

        $test->id ('gc.doc.2');
        $test->assert_not_null ($bag->{$$doc_id});

        $test->id ('gc.el.2');
        $test->assert_not_null ($bag->{$$el_id});

        undef $el;

        $test->id ('gc.impl.3');
        $test->assert_null ($bag->{$$id});

        $test->id ('gc.doc.3');
        $test->assert_null ($bag->{$$doc_id});

        $test->id ('gc.el.3');
        $test->assert_null ($bag->{$$el_id});

  @Method:
    @@Name: createDocumentFragment
    @@enDesc:
      Creates an empty <IF::DocumentFragment> node.
    @@Return:
      @@@Type: DocumentFragment
      @@@enDesc:
        A newly created <IF::DocumentFragment> node.
      @@@PerlDef:
        my $bag = <Code::mg|getNodeBag||ManakaiDOM|all:: $ref = $self>;
        my $stem;
        __CODE{mg|createNodeStem||ManakaiDOM|all::
          $bag => $bag,
          $stem => $stem,
          $class => {<ClassName::ManakaiDOMDocumentFragment>},
          $opt => {{
            <H::tc|ownerDocument> => $self,
          }},
        }__;
        __CODE{mg|createNodeRef||ManakaiDOM|all::
          $bag => $bag,
          $stem => $stem,
          $ref => $r,
          $opt => {{
          }},
        }__;

    @@Test:
      @@@QName: Document.createDF.mg.1.test
      @@@PerlDef:
        local $Message::DOM::TreeCore::GCLatency = 0;

        my $impl = <ClassM::ManakaiDOMImplementationTC.new>;

        my $bag = $impl->{<H::mg|nodeBag>};
        my $id = $impl->{<H::mg|nodeIDReference>};

        my $doc = $impl-><M::c|DOMImplementation.createDocument>;

        my $el = $doc-><M::Document.createDocumentFragment>;
        
        $test->id ('interface');
        $test->assert_isa ($el, <IFName::DocumentFragment>);
        
        $test->id ('class');
        $test->assert_isa ($el, <ClassName::ManakaiDOMDocumentFragment>);

        my $doc_id = $doc->{<H::mg|nodeIDReference>};
        my $el_id = $el->{<H::mg|nodeIDReference>};

        undef $impl;

        $test->id ('gc.impl.1');
        $test->assert_not_null ($bag->{$$id});

        $test->id ('gc.doc.1');
        $test->assert_not_null ($bag->{$$doc_id});

        $test->id ('gc.el.1');
        $test->assert_not_null ($bag->{$$el_id});

        undef $doc;

        $test->id ('gc.impl.2');
        $test->assert_not_null ($bag->{$$id});

        $test->id ('gc.doc.2');
        $test->assert_not_null ($bag->{$$doc_id});

        $test->id ('gc.el.2');
        $test->assert_not_null ($bag->{$$el_id});

        undef $el;

        $test->id ('gc.impl.3');
        $test->assert_null ($bag->{$$id});

        $test->id ('gc.doc.3');
        $test->assert_null ($bag->{$$doc_id});

        $test->id ('gc.el.3');
        $test->assert_null ($bag->{$$el_id});

  @Method:
    @@Name: createEntityReference
    @@enDesc:
      Creates an <IF::tx|EntityReference> node.

      In addition, if the referenced entity is known, the child
      list of the <IF::tx|EntityReference> node is made the same
      as that of the corresponding <IF::tx|Entity> node.

      Note that if any descendant of the <IF::tx|Entity> node has
      an unbound namespace prefix, the corresponding descendant of 
      the created <IF::tx|EntityReference> node is also unbound,
      i.e. its <A::Node.namespaceURI> is <DOM::null>.  DOM levels
      2 and 3 do not support any mechanism to resolve namespace
      prefixes in this case.  <SRC::DOM2, DOM3>
    @@DOMMain:isNamespaceUnaware: 1
    @@Param:
      @@@Name: name
      @@@Type: DOMString
      @@@enDesc:
        The name of the entity to reference.

          {NOTE:: Namespace well-formedness check is not performed.
          }
      @@@enImplNote:
        {ISSUE::
           What would be made if the <P::name> is the name of one of
           predefined entities?
        }
    @@Return:
      @@@Type: tx|EntityReference
      @@@enDesc:
        The newly created <IF::tx|EntityReference> node.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_BAD_NAME
        @@@@enDesc:
          If the <P::name> is not an XML <CODE::Name> according
          to the XML version in use specified in the
          <A::Document.xmlVersion> attribute.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_DOC_NOSUPPORT_XML
        @@@@enDesc:
          If it is an HTML document.
      @@@PerlDef:
        require Message::DOM::XML;
        our $CreateEntityReference_OpenEntity;
          ## NOTE: Multithread unsafe

        my $orig_strict = $self-><AG::Document.strictErrorChecking>;
        if ($orig_strict) {
          my $version = $self-><AG::Document.xmlVersion>;
          __CODE{DOMMain|ensureXMLName::
            $INPUT => $name, $INPUT_PARAM_NAME => 'name',
            $XMLVERSION => $version,
          }__;
        }

        my $bag = <Code::mg|getNodeBag||ManakaiDOM|all:: $ref = $self>;
        my $stem;
        __CODE{mg|createNodeStem||ManakaiDOM|all::
          $bag => $bag,
          $stem => $stem,
          $class => {<ClassName::tx|ManakaiDOMEntityReference>},
          $opt => {{
            <H::infoset|name> => \$name,
            <H::tc|ownerDocument> => $self,
          }},
        }__;
        __CODE{mg|createNodeRef||ManakaiDOM|all::
          $bag => $bag,
          $stem => $stem,
          $ref => $r,
          $opt => {{
          }},
        }__;

        ## Expansion
        __DEEP{
          unless ($CreateEntityReference_OpenEntity->{$name}) {
            local $CreateEntityReference_OpenEntity->{$name} = true;
            my $__doctype = $self-><AG::Document.doctype>;
            $__doctype = $__doctype-><M::Node.getFeature>
                                     (<Q::fe|XDoctype> => '3.0')
              if $__doctype;
          if ($__doctype) {
            my $__et = $__doctype-><M::DTDef.getGeneralEntityNode> ($name);
            if ($__et) {
              $self-><AS::Document.strictErrorChecking> (false);
              my @node;
              for my $c (@{$__et-><AG::Node.childNodes>}) {
                my $clone = $c-><M::Node.cloneNode> (true);
                $r-><M::Node.appendChild> ($clone);
                push @node, $clone;
              }
              $r-><AS::tx|EntityReference.manakaiExpanded>
                    ($__et-><AG::tx|Entity.manakaiHasReplacementTree>);
              if ($self-><AG::Document.domConfig>
                       -><M::c|DOMConfiguration.setParameter>
                           (<Q::cfg|entity-reference-read-only>)) {
                $r-><M::Node.manakaiSetReadOnly> (true, true);
              }
              $self-><AS::Document.strictErrorChecking> ($orig_strict);
            } # entity
          } # doctype
        }__;

    @@Test:
      @@@QName: Document.createER.mg.1.test
      @@@PerlDef:
        local $Message::DOM::TreeCore::GCLatency = 0;

        my $impl = <ClassM::ManakaiDOMImplementationTC.new>;

        my $bag = $impl->{<H::mg|nodeBag>};
        my $id = $impl->{<H::mg|nodeIDReference>};

        my $doc = $impl-><M::c|DOMImplementation.createDocument>;

        my $el = $doc-><M::Document.createEntityReference> ('entity');
        
        $test->id ('interface');
        $test->assert_isa ($el, <IFName::tx|EntityReference>);
        
        $test->id ('class');
        $test->assert_isa ($el, <ClassName::tx|ManakaiDOMEntityReference>);

        my $doc_id = $doc->{<H::mg|nodeIDReference>};
        my $el_id = $el->{<H::mg|nodeIDReference>};

        undef $impl;

        $test->id ('gc.impl.1');
        $test->assert_not_null ($bag->{$$id});

        $test->id ('gc.doc.1');
        $test->assert_not_null ($bag->{$$doc_id});

        $test->id ('gc.el.1');
        $test->assert_not_null ($bag->{$$el_id});

        undef $doc;

        $test->id ('gc.impl.2');
        $test->assert_not_null ($bag->{$$id});

        $test->id ('gc.doc.2');
        $test->assert_not_null ($bag->{$$doc_id});

        $test->id ('gc.el.2');
        $test->assert_not_null ($bag->{$$el_id});

        undef $el;

        $test->id ('gc.impl.3');
        $test->assert_null ($bag->{$$id});

        $test->id ('gc.doc.3');
        $test->assert_null ($bag->{$$doc_id});

        $test->id ('gc.el.3');
        $test->assert_null ($bag->{$$el_id});
    @@XDTest:
      @@@QName: Document.createER.nodef.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $ent = $doc-><M::Document.createEntityReference> ('ent1');
        $test->assert_isa ($ent, <IFName::tx|EntityReference>);
        
        $test->id ('node.name');
        $test->assert_equals ($ent-><AG::Node.nodeName>, 'ent1');

        $test->id ('not.expanded');
        $test->assert_false ($ent-><AG::tx|EntityReference.manakaiExpanded>);

        $test->id ('empty');
        $test->assert_false ($ent-><M::Node.hasChildNodes>);
    @@XDTest:
      @@@QName: Document.createER.hasdef.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docd = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>, '3.0');
        my $dtd = $docd-><M::d|DocumentXDoctype.createDocumentTypeDefinition>
                           ('doctype');
          my $et = $docd-><M::d|DocumentXDoctype.createGeneralEntity>
                             ('ent1');
          $et-><AS::Node.textContent> ('replacement text content');
          $et-><AS::x|Entity.manakaiHasReplacementTree> (true);
        $dtd-><M::DTDef.setGeneralEntityNode> ($et);
        $doc-><M::Node.appendChild> ($dtd);

        my $ent = $doc-><M::Document.createEntityReference> ('ent1');
        $test->assert_isa ($ent, <IFName::tx|EntityReference>);
        
        $test->id ('node.name');
        $test->assert_equals ($ent-><AG::Node.nodeName>, 'ent1');

        $test->id ('expanded');
        $test->assert_true ($ent-><AG::tx|EntityReference.manakaiExpanded>);

        $test->id ('not.empty');
        $test->assert_true ($ent-><M::Node.hasChildNodes>);

        $test->id ('text.content');
        $test->assert_equals ($ent-><AG::Node.textContent>,
                              'replacement text content');

        $test->id ('is.read.only');
        $test->assert_exception (code => sub {
          $ent-><AS::Node.textContent> ('new value');
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);
    @@XDTest:
      @@@QName: Document.createER.hasdef.no-read-only.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docd = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>, '3.0');
        my $dtd = $docd-><M::d|DocumentXDoctype.createDocumentTypeDefinition>
                           ('doctype');
          my $et = $docd-><M::d|DocumentXDoctype.createGeneralEntity>
                             ('ent1');
          $et-><AS::Node.textContent> ('replacement text content');
          $et-><AS::tx|Entity.manakaiHasReplacementTree> (true);
        $dtd-><M::DTDef.setGeneralEntityNode> ($et);
        $doc-><M::Node.appendChild> ($dtd);
        $doc-><AG::Document.domConfig>
            -><M::c|DOMConfiguration.setParameter>
                (<Q::cfg|entity-reference-read-only> => false);

        my $ent = $doc-><M::Document.createEntityReference> ('ent1');
        $test->assert_isa ($ent, <IFName::tx|EntityReference>);
        
        $test->id ('node.name');
        $test->assert_equals ($ent-><AG::Node.nodeName>, 'ent1');

        $test->id ('expanded');
        $test->assert_true ($ent-><AG::tx|EntityReference.manakaiExpanded>);

        $test->id ('not.empty');
        $test->assert_true ($ent-><M::Node.hasChildNodes>);

        $test->id ('text.content');
        $test->assert_equals ($ent-><AG::Node.textContent>,
                              'replacement text content');

        $test->id ('is.not.read.only');
        $ent-><AS::Node.textContent> ('new value');
        $test->assert_equals ($ent-><AG::Node.textContent>,
                              'new value');
    @@XDTest:
      @@@QName: Document.createER.hasdef.recursive.direct.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docd = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>, '3.0');
        my $dtd = $docd-><M::d|DocumentXDoctype.createDocumentTypeDefinition>
                           ('doctype');
          my $ent0 = $doc-><M::Document.createEntityReference> ('ent1');
          $test->assert_false ($ent0-><AG::tx|EntityReference.manakaiExpanded>);
          my $et = $docd-><M::d|DocumentXDoctype.createGeneralEntity>
                             ('ent1');
          $et-><M::Node.appendChild> ($ent0);
          $et-><AS::tx|Entity.manakaiHasReplacementTree> (true);
        $dtd-><M::DTDef.setGeneralEntityNode> ($et);
        $doc-><M::Node.appendChild> ($dtd);

        $test->id ('create');
        my $ent = $doc-><M::Document.createEntityReference> ('ent1');
        $test->assert_isa ($ent, <IFName::tx|EntityReference>);
        $test->assert_true ($ent-><AG::tx|EntityReference.manakaiExpanded>);

        $test->assert_not_null ($ent-><AG::Node.firstChild>);
        $test->assert_false ($ent-><AG::Node.firstChild>
                                 -><AG::tx|EntityReference.manakaiExpanded>);
    @@XDTest:
      @@@QName: Document.createER.hasdef.recursive.indirect.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docd = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>, '3.0');
        my $dtd = $docd-><M::d|DocumentXDoctype.createDocumentTypeDefinition>
                           ('doctype');
          my $ent0 = $doc-><M::Document.createEntityReference> ('ent2');
          $test->assert_false ($ent0-><AG::tx|EntityReference.manakaiExpanded>);
          my $et = $docd-><M::d|DocumentXDoctype.createGeneralEntity>
                             ('ent1');
          $et-><M::Node.appendChild> ($ent0);
          $et-><AS::tx|Entity.manakaiHasReplacementTree> (true);

          my $ent0_2 = $doc-><M::Document.createEntityReference> ('ent1');
          my $et_2 = $docd-><M::d|DocumentXDoctype.createGeneralEntity>
                             ('ent2');
          $et_2-><M::Node.appendChild> ($ent0_2);
          $et_2-><AS::tx|Entity.manakaiHasReplacementTree> (true);
        $dtd-><M::DTDef.setGeneralEntityNode> ($et);
        $doc-><M::Node.appendChild> ($dtd);

        $test->id ('create');
        my $ent = $doc-><M::Document.createEntityReference> ('ent1');
        $test->assert_isa ($ent, <IFName::tx|EntityReference>);
        $test->assert_true ($ent-><AG::tx|EntityReference.manakaiExpanded>);

        $test->assert_not_null ($ent-><AG::Node.firstChild>);
        $test->assert_false ($ent-><AG::Node.firstChild>
                                 -><AG::tx|EntityReference.manakaiExpanded>);

  @Method:
    @@Name: createProcessingInstruction
    @@enDesc:
      Creates a <IF::tx|ProcessingInstruction> node given the
      specified name and data strings.
    @@Param:
      @@@Name: target
      @@@Type: DOMString
      @@@enDesc:
        The target part of the processing instruction.
    @@Param:
      @@@Name: data
      @@@Type: DOMString
      @@@enDesc:
        The data for the node.
    @@Return:
      @@@Type: tx|ProcessingInstruction
      @@@enDesc:
        The newly created <IF::tx|ProcessingInstruction> node.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_BAD_NAME
        @@@@enDesc:
          If the <P::name> is not an XML <CODE::Name> according
          to the XML version in use specified in the
          <A::Document.xmlVersion> attribute.
        @@@@UnlessStrictErrorChecking:
        @@@@enImplNote:
          <ABNF::"XML"> is not allowed as a target in XML
          but it is not forbidden in DOM.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_DOC_NOSUPPORT_XML
        @@@@enDesc:
          If the document is an HTML document.
      @@@PerlDef:
        require Message::DOM::XML;

        if ($self-><AG::Document.strictErrorChecking>) {
          my $version = $self-><AG::Document.xmlVersion>;
          __CODE{DOMMain|ensureXMLName::
            $INPUT => $target, $INPUT_PARAM_NAME => 'target',
            $XMLVERSION => $version,
          }__;
        }

        my $bag = <Code::mg|getNodeBag||ManakaiDOM|all:: $ref = $self>;
        my $stem;
        __CODE{mg|createNodeStem||ManakaiDOM|all::
          $bag => $bag,
          $stem => $stem,
          $class => {<ClassName::tx|ManakaiDOMProcessingInstruction>},
          $opt => {{
            <H::infoset|target> => \$target,
            <H::infoset|content> => \(defined $data ? $data : ''),
            <H::tc|ownerDocument> => $self,
          }},
        }__;
        __CODE{mg|createNodeRef||ManakaiDOM|all::
          $bag => $bag,
          $stem => $stem,
          $ref => $r,
          $opt => {{
          }},
        }__;

    @@Test:
      @@@QName: Document.createPI.mg.1.test
      @@@PerlDef:
        local $Message::DOM::TreeCore::GCLatency = 0;

        my $impl = <ClassM::ManakaiDOMImplementationTC.new>;

        my $bag = $impl->{<H::mg|nodeBag>};
        my $id = $impl->{<H::mg|nodeIDReference>};

        my $doc = $impl-><M::c|DOMImplementation.createDocument>;

        my $el = $doc-><M::Document.createProcessingInstruction> ('pi', 'data');
        
        $test->id ('interface');
        $test->assert_isa ($el, <IFName::tx|ProcessingInstruction>);
        
        $test->id ('class');
        $test->assert_isa ($el, <ClassName::tx|ManakaiDOMProcessingInstruction>);

        my $doc_id = $doc->{<H::mg|nodeIDReference>};
        my $el_id = $el->{<H::mg|nodeIDReference>};

        undef $impl;

        $test->id ('gc.impl.1');
        $test->assert_not_null ($bag->{$$id});

        $test->id ('gc.doc.1');
        $test->assert_not_null ($bag->{$$doc_id});

        $test->id ('gc.el.1');
        $test->assert_not_null ($bag->{$$el_id});

        undef $doc;

        $test->id ('gc.impl.2');
        $test->assert_not_null ($bag->{$$id});

        $test->id ('gc.doc.2');
        $test->assert_not_null ($bag->{$$doc_id});

        $test->id ('gc.el.2');
        $test->assert_not_null ($bag->{$$el_id});

        undef $el;

        $test->id ('gc.impl.3');
        $test->assert_null ($bag->{$$id});

        $test->id ('gc.doc.3');
        $test->assert_null ($bag->{$$doc_id});

        $test->id ('gc.el.3');
        $test->assert_null ($bag->{$$el_id});
    @@Test:
      @@@QName: Document.createProcessingInstruction.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $pi = $self-><M::Document.createProcessingInstruction>
                          ('target', 'data');

        $test->id ('interface');
        $test->assert_isa ($pi, <IFName::tx|ProcessingInstruction>);

        $test->id ('nodeName');
        $test->assert_equals ($pi-><AG::Node.nodeName>, 'target');

        $test->id ('nodeValue');
        $test->assert_equals ($pi-><AG::Node.nodeValue>, 'data');
    @@Test:
      @@@QName: Document.createProcessingInstruction.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $pi = $self-><M::Document.createProcessingInstruction>
                          ('target:name', '');

        $test->id ('interface');
        $test->assert_isa ($pi, <IFName::tx|ProcessingInstruction>);

        $test->id ('nodeName');
        $test->assert_equals ($pi-><AG::Node.nodeName>, 'target:name');

        $test->id ('nodeValue');
        $test->assert_equals ($pi-><AG::Node.nodeValue>, '');

  @L3Attr:
    @@Name: strictErrorChecking
    @@enDesc:
      Whether error checking is enforced or not.

      This attribute is <DOM::true> by default.
    @@Type: boolean
    @@FalseCase:
      @@@enDesc:
        The implementation is free not to test every possible error
        case normally defined on DOM operations and not raise any
        <IF::c|DOMException> on DOM operations or report errors
        while using <M::Document.normalizeDocument>.  In case of error,
        the behavior is undefined.
    @@Get:
      @@@PerlDef:
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $r,
          $prop => {<H::c|strictErrorChecking>},
          $ref => $self,
        }__;
        $r = true unless defined $r;
    @@Set:
      @@@PerlDef:
        __CODE{mg|setNodeStemPropValue||ManakaiDOM|all::
          $given => {$given ? true : false},
          $prop => {<H::c|strictErrorChecking>},
          $ref => $self,
        }__;

    @@L3Test:
      @@@QName: Document.strictErrorChecking.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        $test->id ('default');
        $test->assert_true ($doc-><AG::Document.strictErrorChecking>);

        $test->id ('disabled');
        $doc-><AS::Document.strictErrorChecking> (false);
        $test->assert_false ($doc-><AG::Document.strictErrorChecking>);

        $test->id ('enabled');
        $doc-><AS::Document.strictErrorChecking> (true);
        $test->assert_true ($doc-><AG::Document.strictErrorChecking>);

        $test->id ('disabled.by.null');
        $doc-><AS::Document.strictErrorChecking> (null);
        $test->assert_false ($doc-><AG::Document.strictErrorChecking>);

  @L3Attr:
    @@Name: domConfig
    @@enDesc:
      The configuration of the document.

      {NOTE:: This configuration is used when e.g. the method
              <M::Document.normalizeDocument> is invoked.
      }

    @@Get:
      @@@Type: c|DOMConfiguration
      @@@enDesc: The DOM configuration object.
      @@@PerlDef:
        __CODE{c|getConfigObject::
          $target => $self,
          $targetHash => {<Code::mg|getNodeStem||ManakaiDOM|all::
                                     $ref = $self>},
          $targetType => {<IFName::Document>},
          $result => $r,
        }__;

    @@L3Test:
      @@@QName: Doc.domConfig.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $cfg = $doc-><AG::Document.domConfig>;

        $test->id ('interface');
        $test->assert_isa ($cfg, <IFName::c|DOMConfiguration>);

  @Attr:
    @@Name: documentElement
    @@enDesc:
      The document element of the document.
    @@Get:
      @@@Type: Element
      @@@nullCase:
        @@@@enDesc:
          If the document has no element.
        @@@@For: ManakaiDOM|ManakaiDOM
      @@@PerlDef:
        __DEEP{
          F: for my $child (@{$self-><AG::Node.childNodes>}) {
            if ($child-><AG::Node.nodeType> == <C::Node.ELEMENT_NODE>) {
              $r = $child;
              last F;
            }
          } # F
        }__;
    @@Test:
      @@@QName: Document.documentElement.one-element-document.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createElementNS> (null, 'e');
        $doc-><M::Node.appendChild> ($el);

        $test->assert_equals ($doc-><AG::Document.documentElement>, $el);
    @@Test:
      @@@QName: Document.documentElement.empty-document.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        $test->assert_null ($doc-><AG::Document.documentElement>);
    @@Test:
      @@@QName: Document.documentElement.doctype-element-document.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $doctype = $doc-><AG::Document.implementation>
                          -><M::c|DOMImplementation.createDocumentType> ('dt');
        $doc-><M::Node.appendChild> ($doctype);
        my $el = $doc-><M::Document.createElementNS> (null, 'el');
        $doc-><M::Node.appendChild> ($el);

        $test->assert_equals ($doc-><AG::Document.documentElement>, $el);

  @Attr:
    @@Name: implementation
    @@enDesc:
      The <IF::c|DOMImplmentation> object that handles the document.
    @@Type: c|DOMImplementation
    @@Get:
      @@@PerlDef:
        __CODE{mg|getNodeStemProp0Node||ManakaiDOM|all::
          $r => $r,
          $prop => {<H::tc|implementation>},
          $ref => $self,
        }__;

    @@Test:
      @@@QName: Document.implementation.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $impl = $doc-><AG::Document.implementation>;
        $test->assert_isa ($impl, <IFName::c|DOMImplementation>);

  @L3Attr:
    @@Name: xmlVersion
    @@enDesc:
      The XML version number of the document, as part of the XML
      declaration.
    @@Type: DOMString
    @@InCase:
      @@@Value: 
        @@@@@: 1.0
        @@@@ContentType: DISCore|String
      @@@enDesc:
        If the <XA::version> declaration is set to <XML::1.0> or
        if there is no declaration and the document supports the
        <Feature::XML> feature.
    @@InCase:
      @@@Value:
        @@@@@: 1.1
        @@@@ContentType: DISCore|String
      @@@enDesc:
        If the <XA::version> declaration is set to <XML::1.1>.  <SRC::manakai>
    @@nullCase:
      @@@enDesc:
        If the document does not support the <Feature::XML> feature.
    @@Get:
      @@@PerlDef:
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $r,
          $prop => {<H::infoset|version>},
          $ref => $self,
        }__;
        $r = '1.0' unless defined $r;
    @@Set:
      @@@enDesc:
        Changing this attribute will affect methods that checks
        for invalid characters in XML <CODE::Name>s. 
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_IMPL_NOSUPPORT_XMLVER
        @@@@enDesc:
          If the version is set to a value that is not supported by
          the <IF::Document>.

          A <IF::Document> that supports a version of the <Feature::XMLVersion>
          feature must not raise a <C::c|DOMException.NOT_SUPPORTED_ERR>
          exception for the same version number when setting this
          attribute.
      @@@iRaises:
        @@@@@: MDOMX|MDOM_DOC_NOSUPPORT_XML
        @@@@enDesc:
          If the <IF::Document> does not support the <Feature::XML> feature.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the node is read-only.  <SRC::manakai>
      @@@PerlDef:
        __CODE{tc|NodeReadOnlyError:: $node => $node}__;
        if (defined $given and
            ($given eq '1.0' or $given eq '1.1' or
             not $self-><AG::Document.strictErrorChecking>)) {
          __CODE{mg|setNodeStemPropValue||ManakaiDOM|all::
            $given => $given,
            $prop => {<H::infoset|version>},
            $ref => $self,
          }__;
        } else {
          __EXCEPTION{MDOMX|MDOM_IMPL_NOSUPPORT_XMLVER::
            infoset|version => {$given},
          }__;
        }

    @@Test:
      @@@QName: Document.xmlVersion.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        $test->id ('initial');
        $test->assert_equals ($doc-><AG::Document.xmlVersion>, '1.0');

        $test->id ('set.1.1');
        $doc-><AS::Document.xmlVersion> ('1.1');
        $test->assert_equals ($doc-><AG::Document.xmlVersion>, '1.1');

        $test->id ('set.1.0');
        $doc-><AS::Document.xmlVersion> ('1.0');
        $test->assert_equals ($doc-><AG::Document.xmlVersion>, '1.0');

        $test->id ('set.1.2');
        $test->assert_exception (code => sub {
          $doc-><AS::Document.xmlVersion> ('1.1');
        }, exception_subtype => <Q::MDOMX|MDOM_IMPL_NOSUPPORT_XMLVER>);

  @L13Attr:
    @@Name: doctype
    @@enDesc:
      The document type declaration associated with the document.
      It is the <IF::tx|DocumentType> child of the node, if any.

      For an XML document with a document type declaration,
      this attribute contains the <IF::tx|DocumentType> node.
    @@enDesc:
      @@@For: ManakaiDOM|DOM3
      @@@ddid: html
      @@@@:
        For an HTML document, this attribute may contain
        a <IF::tx|DocumentType> node independently of the presence or
        absence of document type declaration. 
    @@enDesc:
      @@@For: !ManakaiDOM|DOM3
      @@@ddid: html
      @@@@:
        For an HTML document, the attribute value is always <DOM::null>.

    @@enDesc:
      @@@ddid: note
      @@@@:
        {NOTE:: Although this attribute itself is read-only, 
                usual node modification methods on the <IF::Document>
                node can alter the <IF::tx|DocumentType> node.
                However, while the implementation might instantiate different
                types of <IF::Document> object supporting additional
                feature than <Feature::Core>, based on the
                <IF::tx|DocumentType> specified at creation time,
                changing it afterward is unlikely to result in a
                change of the feature supported by the <IF::Document>.
        }
    @@enImplNote:
      {TODO:: HTML5 consideration.
      }
    @@Type: tx|DocumentType
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          @@@@@For: ManakaiDOM|DOM3
          @@@@@@:
            If the document does not have a document type declaration,
            or if it is an HTML document and the implementation does not
            expose the document type declaration to the DOM.
        @@@@enDesc:
          @@@@@For: !ManakaiDOM|DOM3
          @@@@@@:
            If the document does not have a document type declaration,
            or if it is an HTML document.
      @@@PerlDef:
        @@@@@:
          __DEEP{
            F: for my $child (@{$self-><AG::Node.childNodes>}) {
              my $nt = $child-><AG::Node.nodeType>;
              if ($nt == <C::Node.DOCUMENT_TYPE_NODE>) {
                $r = $child;
                last F;
              } elsif ($nt == <C::Node.ELEMENT_NODE>) { # document element
                last F;
              }
            } # F
          }__;
        @@@@enImplNote:
          Although the intention of the DOM specification is unclear,
          the current manakai implementation <EM::does> return
          a <IF::tx|DocumentType> node, if any, even if DOM level
          is less than (not equal to) 3.
    @@Test:
      @@@QName: Document.doctype.one-element-document.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        $test->assert_null ($doc-><AG::Document.doctype>);
    @@Test:
      @@@QName: Document.doctype.empty-document.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        $test->assert_null ($doc-><AG::Document.doctype>);
    @@Test:
      @@@QName: Document.doctype.doctype-element-document.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $doctype = $doc-><AG::Document.implementation>
                          -><M::c|DOMImplementation.createDocumentType> ('dt');
        my $el = $doc-><M::Document.createElementNS> (null, 'e');
        $doc-><M::Node.appendChild> ($doctype);
        $doc-><M::Node.appendChild> ($el);

        $test->assert_equals ($doc-><AG::Document.doctype>, $doctype);
    @@Test:
      @@@QName: Document.doctype.comment-doctype-element-document.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $doctype = $doc-><AG::Document.implementation>
                          -><M::c|DOMImplementation.createDocumentType> ('dt');
        my $el = $doc-><M::Document.createElementNS> (null, 'el');
        my $comment = $doc-><M::Document.createComment> ('');
        $doc-><M::Node.appendChild> ($comment);
        $doc-><M::Node.appendChild> ($doctype);
        $doc-><M::Node.appendChild> ($el);

        $test->assert_equals ($doc-><AG::Document.doctype>, $doctype);

  @L3Attr:
    @@Name: documentURI
    @@enDesc:
      The location of the document.
    @@nullCase:
      @@@enDesc:
        If undefined or if the <IF::Document> was created using
        <M::c|DOMImplementation.createDocument>.
    @@Type: DOMString
    @@dis:actualType: ManakaiDOM|ManakaiDOMURI
    @@Get:
      @@@PerlDef:
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $r,
          $prop => {<H::c|documentURI>},
          $ref => $self,
        }__;
    @@Set:
      @@@enDesc:
        No lexical checking is performed when setting this attribute;
        this could result in a <DOM::null> value return when using
        <A::Node.baseURI>.
      @@@NodeReadOnlyError:
      @@@PerlDef:
        __CODE{tc|NodeReadOnlyError:: $node => $self}__;
        __CODE{mg|setNodeStemPropValue||ManakaiDOM|all::
          $given => $given,
          $prop => {<H::c|documentURI>},
          $ref => $self,
        }__;

    @@Test:
      @@@QName: Document.documentURI.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        $test->id ('initial');
        $test->assert_null ($doc-><AG::Document.documentURI>);

        $test->id ('set');
        $doc-><AS::Document.documentURI> ('about:');
        $test->assert_equals ($doc-><AG::Document.documentURI>, 'about:');

        $test->id ('relative.set');
        $doc-><AS::Document.documentURI> ('path');
        $test->assert_equals ($doc-><AG::Document.documentURI>, 'path');

        $test->id ('reset');
        $doc-><AS::Document.documentURI> (null);
        $test->assert_null ($doc-><AG::Document.documentURI>);

  @L3Attr:
    @@Name: inputEncoding
    @@enDesc:
      The encoding used for the document at the time of the parsing.
    @@Type: DOMString
    @@enImplNote:
      It is unclear what type of values are permitted. 
      IANA-registered charset names? XML encoding declaration 
      names?  Or, any names passed from the upper-level protocols?
    @@nullCase:
      @@@enDesc:
        If it is not known, such as when the <IF::Document> was
        created in memory.
    @@Get:
      @@@PerlDef:
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $r,
          $prop => {<H::infoset|characterEncodingScheme>},
          $ref => $self,
        }__;
    @@LXSet:
      @@@enDesc:
        Sets the attribute value.  No lexical checking is performed
        on setting.
      @@@NodeReadOnlyError:
      @@@PerlDef:
        __CODE{tc|NodeReadOnlyError:: $node => $self}__;
        __CODE{mg|setNodeStemPropValue||ManakaiDOM|all::
          $given => $given,
          $prop => {<H::infoset|characterEncodingScheme>},
          $ref => $self,
        }__;

    @@Test:
      @@@QName: Document.inputEncoding.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        $test->id ('initial');
        $test->assert_null ($doc-><AG::Document.inputEncoding>);

        $test->id ('set');
        $doc-><AS::Document.inputEncoding> ('utf-8');
        $test->assert_equals ($doc-><AG::Document.inputEncoding>, 'utf-8');

        $test->id ('reset');
        $doc-><AS::Document.inputEncoding> (null);
        $test->assert_null ($doc-><AG::Document.inputEncoding>);

  @L3Attr:
    @@Name: xmlEncoding
    @@enDesc:
      The encoding of the document, as part of the XML declaration.
    @@Type: DOMString
    @@nullCase:
      @@@enDesc:
        If unspecified or if it is not known, such as when
        the <IF::Document> was created in memory.
    @@Get:
      @@@PerlDef:
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $r,
          $prop => {<H::c|xmlEncoding>},
          $ref => $self,
        }__;
    @@LXSet:
      @@@enDesc:
        The value of the <XA::encoding> declaration.  No lexical
        checking is performed on setting.
      @@@nullCase:
        @@@@enDesc:
          The <XA::encoding> declaration is <EM::not> specified.
      @@@NodeReadOnlyError:
      @@@PerlDef:
        __CODE{tc|NodeReadOnlyError:: $node => $self}__;
        __CODE{mg|setNodeStemPropValue||ManakaiDOM|all::
          $given => $given,
          $prop => {<H::c|xmlEncoding>},
          $ref => $self,
        }__;

    @@Test:
      @@@QName: Document.xmlEncoding.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        $test->id ('initial');
        $test->assert_null ($doc-><AG::Document.xmlEncoding>);

        $test->id ('set');
        $doc-><AS::Document.xmlEncoding> ('utf-8');
        $test->assert_equals ($doc-><AG::Document.xmlEncoding>, 'utf-8');

        $test->id ('reset');
        $doc-><AS::Document.xmlEncoding> (null);
        $test->assert_null ($doc-><AG::Document.xmlEncoding>);

  @L3Attr:
    @@Name: xmlStandalone
    @@enDesc:
      Whether the document is standalone or not, as part of the
      XML declaration.
    @@Type: boolean
    @@TrueCase:
      @@@enDesc:
        If the <XA::standalone> declaration is set to <XML::yes>.
    @@FalseCase:
      @@@enDesc:
        If the <XA::standalone> declaration is set to <XML::no>
        or is unspecified.
    @@Get:
      @@@PerlDef:
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $r,
          $prop => {<H::infoset|standalone>},
          $ref => $self,
        }__;
    @@Set:
      @@@enDesc:
        No verification is performed on the value when setting
        this attribute.
      @@@iRaises:
        @@@@@: MDOMX|MDOM_DOC_NOSUPPORT_XML
        @@@@enDesc:
          If the document does not support the <Feature::XML> feature.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the node is read-only.  <SRC::manakai>
      @@@NodeReadOnlyError:
      @@@PerlDef:
        __CODE{tc|NodeReadOnlyError:: $node => $self}__;
        __CODE{mg|setNodeStemPropValue||ManakaiDOM|all::
          $given => $given,
          $prop => {<H::infoset|standalone>},
          $ref => $self,
        }__;

    @@Test:
      @@@QName: Document.xmlStandalone.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
 
        $test->id ('initial');
        $test->assert_false ($doc-><AG::Document.xmlStandalone>);

        $test->id ('set.yes');
        $doc-><AS::Document.xmlStandalone> (true);
        $test->assert_true ($doc-><AG::Document.xmlStandalone>);

        $test->id ('set.no');
        $doc-><AS::Document.xmlStandalone> (false);
        $test->assert_false ($doc-><AG::Document.xmlStandalone>);

  @L3Method:
    @@Name: adoptNode
    @@enDesc:
      Attempts to adopt a node from another document to this document.
      
      If supported, it changes the <A::Node.ownerDocument> of
      the source node, its children, as well as the attached attribute
      nodes if any.  If the source node has a <A::Node.parentNode>
      it is first removed from the children list of the parent.
      
      This method effectively allowes moving a subtree from one
      document to another, unlike <M::Document.importNode> which
      creates a copy of the source node instead of moving it.
      When it fails, applications should use <M::Document.importNode> instead.

      Note that if the adopted node is already part of this document,
      i.e. the source and target document are the same, this method
      still has the effect of removing the source node from the
      children list of its parent, if any.

        {ISSUE::
          This clause is somewhat unclear.
        }

      - <IF::Attr>::: The <A::Node.ownerElement> attribute is set to
                      <DOM::null> and the <A::Attr.specified> attribute
                      is set to <DOM::true>.  The descendant nodes
                      are recursively adopted.
      
      - <IF::DocumentFragment>::: The descendant nodes
                      are recursively adopted.

      - <IF::Element>::: All <A::Attr.specified> attributes are adopted.
                      Default attributes are discarded, though if the 
                      target document defines default attributes 
                      for the element type, then those are assigned.
                      The descendant nodes are recursively adopted.

      - <IF::tx|EntityReference>::: Only the node itself is adopted
                      and the descendants are discarded, since the source
                      and target documents might have defined the entity
                      differently.  If the target document provides a
                      definition for the entity name, then its value is
                      assigned.

         {TODO::
           copy-asis
         }

      - <IF::Text>, <IF::Comment>, <IF::tx|CDATASection>,
        <IF::tx|ProcessingInstruction>:::
                      These nodes can be adopted.

      - <IF::Document>, <IF::tx|DocumentType>,
        <IF::tx|Entity>, <IF::tx|Notation>:::
                      These kinds of nodes cannot be adopted.
      
      {NOTE:: Since this method does not create new nodes unlike
              the <M::Document.importNode> method, this method does
              not raise an <X::DOMException.INVALID_CHARACTER_ERR>
              exception and applications should use the 
              <M::Document.normalizeDocument> method to check if
              an imported name is not an XML <CODE::Name> according
              to the XML version in use.
      }    

    @@enDesc:
      @@@ddid: adopt
      @@@enImplNote: Not in spec.
      @@@:
        If an adopted node has user data with handlers being registered,
        those handlers are invoked after the adoption occurred,
        with the <CODE::operation>
        parameter set to <C::c|UserDataHandler.NODE_ADOPTED>,
        <CODE::src> parameter set to the adopted node, and
        the <CODE::dest> parameter set to <DOM::null>.

          {NOTE:: User data handlers are disallowed to throw any
                  exception; if they do, then the result of 
                  the method is implementation dependent.
          }

    @@Param:
      @@@Name: source
      @@@Type: Node
      @@@enDesc:
        The node to move into this document.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The adopted node.
      @@@nullCase:
        @@@@enDesc:
          If the adopting operation fails, such as when the <P::source>
          node comes from a different implementation.
      @@@dx:raises:
        @@@@@: c|ADOPT_NODE_TYPE_NOT_SUPPORTED_ERR
        @@@@enDesc:
          The <P::source> node is of type <IF::Document>,
          <IF::tx|DocumentType> <SRC::DOM3>, <IF::tx|Entity>, or
          <IF::tx|Notation> <SRC::manakai>.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          The <P::source> node is read-only.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_PARENT
        @@@@enDesc:
          The parent or owner element node of the <P::source>
          node is read-only.  <SRC::manakai>
      @@@dx:raises:
        @@@@@: c|NOMOD_DESCENDANT_ERR
        @@@@enDesc:
          One or more descendant or attribute node of the
          <P::source> node is read-only.  <SRC::manakai>
      @@@PerlDef:
        if ($source->isa (<ClassName::ManakaiDOMNode>) and
            <Code::mg|getNodeBag||ManakaiDOM|all:: $ref = $self>
                eq <Code::mg|getNodeBag||ManakaiDOM|all:: $ref = $source>) {
          if ($self-><AG::Node.manakaiReadOnly>) {
            __EXCEPTION{MDOMX|NOMOD_THIS::
              MDOMX|param-name => 'source',
              c|node => $source,
            }__;
          }
          my $parent = $source-><AG::Node.parentNode>;
          if ($parent and $parent-><AG::Node.manakaiReadOnly>) {
            __EXCEPTION{MDOMX|NOMOD_PARENT::
              MDOMX|param-name => 'source',
              c|node => $parent,
            }__;
          }
          my $nt = $source-><AG::Node.nodeType>;
          my $oe;
          if ($nt == <C::Node.ATTRIBUTE_NODE>) {
            $oe = $source-><AG::Attr.ownerElement>;
            if ($oe and $oe-><AG::Node.manakaiReadOnly>) {
              __EXCEPTION{MDOMX|NOMOD_PARENT::
                MDOMX|param-name => 'source', 
                c|node => $oe,
              }__;
            }
          } elsif ($nt == <C::Node.DOCUMENT_NODE> or 
                   $nt == <C::Node.DOCUMENT_TYPE_NODE> or
                   $nt == <C::Node.ENTITY_NODE> or
                   $nt == <C::Node.NOTATION_NODE>) {
            __EXCEPTION{c|ADOPT_NODE_TYPE_NOT_SUPPORTED_ERR::
              MDOMX|param-name => 'source',
              c|node => $source,
            }__;
          }

          my @change_od;
          my @nodes = ($source);
          while (@nodes) {
            my $node = shift @nodes;
            my $nt = $node-><AG::Node.nodeType>;
            if ($node-><AG::Node.manakaiReadOnly>) {
              __EXCEPTION{c|NOMOD_DESCENDANT_ERR::
                MDOMX|param-name => 'source',
                c|node => {$node},
              }__;
            }
            if ($nt == <C::Node.ELEMENT_NODE>) {
              push @change_od, $node;
              push @nodes, @{$node-><AG::Node.childNodes>};
              my $attrs = $node-><AG::Node.attributes>;
              my $attrsLength = $attrs-><AG::NamedNodeMap.length>;
              for my $i (0..($attrsLength - 1)) {
                push @nodes, $attrs-><M::NamedNodeMap.item> ($i);
              }
            } elsif ($nt == <C::Node.ATTRIBUTE_NODE> or
                     $nt == <C::Node.ENTITY_REFERENCE_NODE> or
                     $nt == <C::Node.DOCUMENT_FRAGMENT_NODE>) {
              push @change_od, $node;
              push @nodes, @{$node-><AG::Node.childNodes>};
            } elsif ($nt == <C::Node.TEXT_NODE> or
                     $nt == <C::Node.COMMENT_NODE> or
                     $nt == <C::Node.PROCESSING_INSTRUCTION_NODE> or
                     $nt == <C::Node.CDATA_SECTION_NODE>) {
              push @change_od, $node;
            } else {
              ## TODO: assertion
            }
          } # nodes
          
          if ($parent) {
            __DEEP{
              $parent-><M::Node.removeChild> ($source);
            }__;
          } elsif ($oe) {
            __DEEP{
              $oe-><M::Element.removeAttributeNode> ($source);
            }__;
          }

          my $old_od = $change_od[0]-><AG::Node.ownerDocument>;
                         ## NOTE: The array must have more than zero
                         ##       nodes by definition.  In addition,
                         ##       it cannot contain document or document
                         ##       type nodes in current implementation.
          my $old_od_list;
          __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
            $r => $old_od_list,
            $prop => {<H::tc|revOwnerDocument>},
            $ref => $old_od,
          }__;
          my $new_od_list;
          __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
            $r => $new_od_list,
            $prop => {<H::tc|revOwnerDocument>},
            $ref => $self,
          }__;
          for my $n (@change_od) {
            __CODE{mg|setNodeStemProp0Node||ManakaiDOM|all::
              $prop => {<H::infoset|ownerDocument>},
              $ref => $n,
              $given => $self,
            }__;
            my $nid = <Code::mg|getNodeID||ManakaiDOM|all:: $ref = $n>;
            CORE::delete $old_od_list->{$$nid};
            $new_od_list->{$$nid} = $nid;
          }

          for my $src (@change_od) {
            my $src_ud;
            __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
              $r => $src_ud,
              $prop => {<H::t|userData>},
              $ref => $self,
            }__;
            for my $key (keys %{$src_ud or {}}) {
              my $dh = $src_ud->{$key}->[1];
              if ($dh) {
                $dh-><M::c|UserDataHandler.handle>
                         (<C::c|UserDataHandler.NODE_ADOPTED>,
                          $key, $src_ud->{$key}->[0], $src, null);
              }
            }
          }
          $r = $source;
        } # compatible class

      @@@enImplNote:
        The order in which handlers are invoked when multiple
        nodes are adopted is undefined.  Called just after the adoption
        or after all nodes are adopted is also unspecified.

        Is is invoked even if <A::Node.ownerDocument> is unchanged?

    @@Test:
      @@@QName: Node.adoptNode.1.test
      @@@PerlDef:
        my $impl;
        __CODE{tc|createImplForTest:: $impl => $impl}__;

        my $doc1 = $impl-><M::c|DOMImplementation.createDocument>;

        my $doc2 = $impl-><M::c|DOMImplementation.createDocument>;

        my $el1 = $doc1-><M::Document.createElementNS> (null, 'e');
     
        my $el2 = $doc2-><M::Document.adoptNode> ($el1);

        $test->id ('same');
        $test->assert_equals ($el2, $el1);
 
        $test->id ('ownerDocument');
        $test->assert_equals ($el2-><AG::Node.ownerDocument>, $doc2);

    @@L3Test:
      @@@QName: Node.adoptNode.UserDataHandler.Test
      @@@PerlDef:
        my $impl;
        __CODE{tc|createImplForTest:: $impl => $impl}__;

        my $doc = $impl-><M::c|DOMImplementation.createDocument>
                              ('http://www.example/', 'ex');
        my $node = $doc-><AG::Document.documentElement>;

        $test->set_test_data (node => $node);
          ## This registration prevents the user data handler
          ## being called when a test fails so that the |$node|
          ## is being destructed (|NODE_DELETED|).

        my $doc2 = $impl-><M::c|DOMImplementation.createDocument>;

        my $udh_called = false;

        $node-><M::Node.setUserData> ('key' => {}, sub {
          my ($self, $op, $key, $data, $src, $dest) = @_;
          $udh_called = true;

          $test->assert_equals ($op, <C::c|UserDataHandler.NODE_ADOPTED>);
          $test->assert_equals ($key, 'key');
          $test->assert_equals (ref $data, 'HASH');
          $test->assert_not_null ($src);
          $test->assert_equals ($src-><AG::Node.localName>, 'ex');
          $test->assert_null ($dest);
        });

        $node = $doc2-><M::Document.adoptNode> ($node);

        $test->assert_true ($udh_called);

        $node-><M::Node.setUserData> ('key', null, null);
        $test->set_test_data (node => null);

  @L2Method:
    @@Name: getElementById
    @@enDesc:
      Returns the <IF::Element> that has an <XML::ID> attribute
      with the given value.

      The implementation is expected to use the attribute <A::Attr.isId>
      to determine if an attribute is of type <XML::ID>.  <SRC::DOM3>
    @@Param:
      @@@Name: elementId
      @@@Type: DOMString
      @@@enDesc:
        The unique identifier value for an element.
    @@Return:
      @@@enDesc:
        The matching element.

        If more than one element has an <XML::ID> attribute
        with that value, what is returned is undefined.
      @@@nullCase:
        @@@@enDesc:
          If no such element exists.
      @@@enImplNote:
        Can an <IF::Element> that is not a descendant of the <IF::Document> 
        be returned?

        This method was first defined in the interface <IF::HTMLDocument> 
        in the DOM Level 1.

        {TODO::
          Use hash table as in Web browsers.
        }
      @@@PerlDef:
        __DEEP{
          my @nodes = @{$self-><AG::Node.childNodes>};
          N: while (@nodes) {
            my $node = shift @nodes;
            next N unless $node-><AG::Node.nodeType> == <C::Node.ELEMENT_NODE>;
            for my $attr (@{$node-><AG::Node.attributes>}) {
              if ($attr-><AG::Attr.isId> and
                  $attr-><AG::Attr.value> eq $elementId) {
                $r = $attr;
                last N;
              }
            }
            unshift @nodes, @{$node-><AG::Node.childNodes>};
          } # N
        }__;

  @Method:
    @@Name: getElementsByTagName
    @@enDesc:
      Returns a <IF::NodeList> of all the <IF::Element>s in
      document order with a given tag name and are contained
      in the document.
    @@enImplNote:
         Does <QUOTE::contained> mean that an <IF::Element> node 
         which is not a descendant of the <IF::Document> does not match?
       \
         The DOM Level 2 Specification specifies as <QUOTE::pre-order 
         traversal>.  The DOM Level 3 Specifies it by 
         <QUOTE::in document order> and this makes the ambigiousness.
       \
         Should <IF::Element> nodes in <IF::tx|Entity> nodes be matched?
    @@NSVersion: .getElementsByTagNameNS
    @@Param:
      @@@Name: tagname
      @@@DISPerl:paramName: name
      @@@Type: DOMString
      @@@enDesc:
        The name of the tag to match on.

        For XML the <P::tagname> parameter is case-sensitive.

        In other markup languages it depends on the case-sensitivity
        of the markup language in use.
      @@@InCase:
        @@@@Value:
          @@@@@@: *
          @@@@@ContentType: DISCore|String
        @@@@enDesc:
          Matches all tags.
    @@Return:
      @@@Type: NodeList
      @@@enDesc:
        A <IF::NodeList> object containing all the matched
        <IF::Element>s.
      @@@disDef:
        @@@@DISPerl:cloneCode: ManakaiDOMElement.getElementsByTagName

  @L2Method:
    @@Name: getElementsByTagNameNS
    @@enDesc:
      Returns a <IF::NodeList> of all the <IF::Element>s with
      a given namespace URI and local name in document order.
    @@enImplNote:
      Pre-order traversal <SRC::DOM2> or document order <SRC::DOM3>.
    @@NoNSVersion: .getElementsByTagName
    @@Param:
      @@@Name: namespaceURI
      @@@Type: DOMString
      @@@dis:actualType: ManakaiDOM|ManakaiDOMNamespaceURI
      @@@enDesc:
        The namespace URI of the element to match on.
      @@@InCase:
        @@@@Value:
          @@@@@@: *
          @@@@@ContentType: DISCore|String
        @@@@enDesc:
          Matches all namespaces.
    @@Param:
      @@@Name: localName
      @@@Type: DOMString
      @@@enDesc:
        The local name of the elements to match on.
      @@@InCase:
        @@@@Value:
          @@@@@@: *
          @@@@@ContentType: DISCore|String
        @@@@enDesc:
          Matches all local names.
    @@Return:
      @@@Type: NodeList
      @@@enDesc:
        A new <IF::NodeList> object containing all the matched
        <IF::Element>s.
      @@@iRaises:
        @@@@@: MDOMX|MDOM_DOC_NOSUPPORT_XML
        @@@@enDesc:
          If the document does not support the <Feature::XML> feature.
          <SRC::manakai>
      @@@disDef:
        @@@@DISPerl:cloneCode: ManakaiDOMElement.getElementsByTagNameNS

  @L2Method:
    @@Name: importNode

     @@Description:
       @@@lang:en
       @@@@:
         Import a node from another document to this document, 
         without altering or removing the source node from 
         the original document (i.e. create a new copy of 
         the source node in this document).
     @@ImplNote:
       @@@lang:en
       @@@@:
         Copied: <A::Node.nodeName>, <A::Node.nodeType>, <A::Node.prefix>, 
         <A::Node.localName>, <A::Node.namespaceURI>, <A::x|Entity.publicId>, 
         <A::x|Entity.systemId>, <A::x|Entity.notationName>, 
         <A::Notation.publicId>, <A::Notation.systemId>, 
         <A::ProcessingInstruction.target>, <A::ProcessingInstruction.data>, 
         <A::CharacterData.data>, <A::CharacterData.length>.
       \
         User data is not carried over.  However, if any 
         <IF::UserDataHandler>s has specified, these handlers will 
         be called with the appropriate parameters before this method 
         returns.
       \
         <A::Node.parentNode> := <DOM::null>.
         <A::Attr.ownerElement> := <DOM::null>. 
         <A::Attr.specified> := <DOM::true>.
         Specified attribute nodes attached to the <IF::Element> node 
         are imported.  Default attributes are created if exists.
     @@Param:
        @@@Name:  importedNode
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@:
            The node to import.
            \
            Note that <IF::Document> or <IF::DOMXML:DocumentType> nodes cannot 
            be imported.
     @@Param:
        @@@Name:  deep
        @@@Type:  DOMMain|boolean||ManakaiDOM|all
        @@@Description:
          @@@@lang:en
          @@@@@:
            Whether the subtree under the <P::importedNode> 
            is recursively imported or not.
            \
            This parameter has no effect on <IF::Attr>,
            <IF::DOMXML:EntityReference>, 
            <IF::DOMXML:Notation>, <IF::DOMXML:ProcessingInstruction>,
            <IF::Text>, 
            <IF::DOMXML:CDATASection> and <IF::Comment> nodes.
            The descendants of 
            the <IF::Attr> node are 
            always imported.  The descendants of the
            <IF::DOMXML:EntityReference> 
            node are always not imported.
        @@@InCase:
          @@@@Value:true
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The descendants are recursively imported if the 
              <P::importedNode> is of <IF::DocumentFragment>, <IF::Element> or 
              <IF::DOMXML:Entity>.
        @@@InCase:
          @@@@Value:false
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Import only the node itself.
     @@Return:
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@:
            The imported node.
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:NOT_SUPPORTED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The type of node being imported is not supported.
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              Maybe, if this document is not <Feature::XML> and 
              the node type is either <IF::DOMXML:ProcessingInstruction>, 
              <IF::DOMXML:Notation>, <IF::DOMXML:EntityReference>,
              <IF::DOMXML:Entity> or 
              <IF::DOMXML:CDATASection>.  And if namespaced nodes are imported?
        @@@Exception:
          @@@@Type:DOMException
          @@@@Name:INVALID_CHARACTER_ERR
          @@@@SubType:
            @@@@@QName:
              MDOMX:MDOM_BAD_NAME
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                One of the imported names is not a SGML or XML <CODE::Name>.

  @L3Method:
    @@Name: normalizeDocument
     @@Description:
       @@@lang:en
       @@@@:
         Act as if the document was going through a save and 
         load cycle, putting the document in a "normal" form.
       \
         - Update the replacement tree of <IF::DOMXML:EntityReference> nodes.
       \
         - Normalize <IF::Text> nodes, as the method <M::Node.normalize> does.
       \
         - Other normalization specified by the <A::Document.domConfig>.
       \
         Mutation events, when supported, are generated to reflect  
         the changes occuring on the document.
       \
         If errors occur, such as an attempt to update a read-only 
         node or a <A::Node.nodeName> contains an invalid character, 
         (fatal and non-fatal) errors and warnings will be reported using 
         the <IF::DOMErrorHandler> object associated with the 
         <DOM::error-handler> parameter.
     @@Return:
      @@@c:reports:
        @@@@@: c|check-character-normalization-failure
        @@@@enDesc:
          If the <cfg::c|check-character-normalization> configuration
          parameter is set to <DOM::true> and a sequence of characters
          is encountered that fails normalization checking.
      @@@c:reports:
        @@@@@: c|cdata-sections-splitted
        @@@@enDesc:
          If the <cfg::c|split-cdata-sections> configuration parameter
          is set to <DOM::true> and a <XML::CDATA> section
          is split.
      @@@c:reports:
        @@@@@: c|wf-invalid-character-in-node-name
        @@@@enDesc:
          If the <cfg::c|well-formed> configuration parameter is set to 
          <DOM::true> and a <A::Node.nodeName> contains invalid character
          according to its node type.
      @@@c:reports:
        @@@@@: c|wf-invalid-character
        @@@@enDesc:
          If the <cfg::c|well-formed> configuration parameter is set to
          <DOM::true> and the text content inside <IF::Attr>, <IF::Element>,
          <IF::Comment>, <IF::Text>, or <IF::DOMXML:CDATASection> node
          or the data inside <IF::DOMXML:ProcessingInstruction> node
          contains invalid characters.

  @L3Method:
    @@Name: renameNode
    @@enDesc:
      Renames an <IF::Element> or <IF::Attr> node.

      When possible, this simple changes the name of the
      given node.  Otherwise, this creates a new node with the
      specified name and replaces the existing node with the new node.

      If the renamed node is an <IF::Element>, only the <A::Attr.specified>
      attributes are moved; default attributes originated from the DTD
      are updated according to the new element type name.  In addition,
      the implementation may update default attributes from other schemas.

        {NOTE:: Applications should use <M::Document.normalizeDocument>
                to guarantee those attributes are up-to-date after
                renaming.
        }

      If the renamed node is an <IF::Attr> attached to <IF::Element>, 
      the node is first removed from the owner <IF::Element>'s attribute
      map.  Then, once renamed, it is put back.

      In addition, a user data event <C::c|UserDataHandler.NODE_RENAMED>
      is fired if there are user data handlers registered to the node.
      When the implementation supports the feature <Feature::MutationNameEvents>,
      each mutation operation involved in the method fires the appropriate
      event, and in the end the event <EV::ev|DOMElementNameChanged>
      or <EV::ev|DOMAttributeNameChanged> is fired.

    @@DOMMain:isNamespaceAware:1
    @@enImplNote:
      {P:: If simple changing is impossible:
 
           = Creates a new node.
 
           = Registers any registered event listener on the new node.

           = Removes any user data attached to the old node.

           = Removes the old node from its parent, if any.

           = Moves the children of the old node to the new node.

           = Inserts the new node at the position the old node used to have
             in its parent's child node list if it has one.

           = Attaches the user data that was attached to the old node.

      }

    @@Param:
      @@@Name: n
      @@@Type: Node
      @@@enDesc:
        The node to rename.
    @@Param:
      @@@Name: namespaceURI
      @@@Type: DOMMain|DOMString
      @@@dis:actualType: ManakaiDOM|ManakaiDOMNamespaceURI
      @@@enDesc:
        The new namespace URI.
      @@@nullCase:
        @@@@enDesc:
          The new name does not belong to any namespace.
    @@Param:
      @@@Name: qualifiedName
      @@@Type: DOMMain|DOMString
      @@@enDesc:
        The new qualified name.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The rename node.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_IMPL_NOSUPPORT_XMLNS
        @@@@enDesc:
          If the DOM implementation does not support the <DOM::XML> feature
          and the language exposed through the <IF::Document>
          object does not support XML Namespaces.
        @@@@For: !ManakaiDOM|DOMXMLFeature ManakaiDOM|ManakaiDOM
      @@@dx:raises:
        @@@@@: c|RENAME_NODE_TYPE_NOT_SUPPORTED_ERR
        @@@@enDesc:
          If the type of the <P::n> is neither <C::Node.ELEMENT_NODE>
          nor <C::Node.ATTRIBUTE_NODE>.
        @@@@enDesc:
          @@@@@ddid: nonns
          @@@@@For: ManakaiDOM|ManakaiDOM
          @@@@@@:
            Or, if the <P::n> does not support namespace since
            it is created by DOM Level 1 method or does not support
            the <Feature::XML> feature.
      @@@dx:raises:
        @@@@@: c|RENAME_DOCUMENT_ELEMENT_NOT_SUPPORTED_ERR
        @@@@enDesc:
          If the <P::n> is the document element and the implementation
          does not support the renaming of the document element.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_BAD_NAME
        @@@@enDesc:
          If the <P::qualifiedName> is not an XML <CODE::Name> according
          to the XML version in use (<A::Document.xmlVersion>).
      @@@dx:raises:
        @@@@@: c|MDOMX_EXTERNAL_NODE
        @@@@enDesc:
          If the <P::n> was created from a different document than
          the document.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_NS_MALFORMED_QNAME
        @@@@enDesc:
          If the <P::qualifiedName> is a malformed qualified name.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_NS_PREFIX_WITH_NULL_URI
        @@@@enDesc:
          If the <P::qualifiedName> has a prefix and the 
          <P::namespaceURI> is <DOM::null>.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_NS_XML_WITH_OTHER_URI
        @@@@enDesc:
          If the <P::qualifiedName> has a prefix that is <XML::xml>
          and the <P::namespaceURI> is different from 
          <URI::http://www.w3.org/XML/1998/namespace>.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_NS_XMLNSQ_WITH_OTHER_URI
        @@@@enDesc:
          If the <P::n> is an attribute node and the <P::qualifiedName> 
          is <XA::xmlns> and the <P::namespaceURI> is different from
          <URI::http://www.w3.org/2000/xmlns/>.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_NS_XMLNS_WITH_OTHER_URI
        @@@@enDesc:
          If the <P::n> is an attribute node and the <P::qualifiedName>
          has a prefix that is <XML::xmlns> and the <P::namespaceURI>
          is different from <URI::http://www.w3.org/2000/xmlns/>.
      @@@enImplNote:
        These exception cases from DOM Level 3 spec do not cover all.
      @@@enImplNote:
        What would happen if a non-XML or non-namespace-aware node
        is being renamed?

  @LXAttr:
    @@Name: manakaiEntityBaseURI
    @@enDesc:
      The base URI of the document entity.

        {NOTE::
          This attribute is a manakai extension.
        }
    @@Type: DOMString
    @@Get:
      @@@enDesc:
        The base DOM URI of the document entity.  It is equal to
        the <A::Node.baseURI> value if there is no <HE::base> element.
      @@@nullCase:
        @@@@enDesc:
          If no base DOM URI is available.
      @@@PerlDef:
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $r,
          $prop => {<H::infoset|baseURI>},
          $ref => $self,
        }__;
        unless (defined $r) {
          __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
            $r => $r,
            $prop => {<H::c|documentURI>},
            $ref => $self,
          }__;
        }
    @@Set:
      @@@enDesc:
        Sets the base DOM URI of the document entity.  It <kwd:MUST>
        be an absolute DOM URI; however, no lexical checking is performed
        on setting.
      @@@nullCase:
        @@@@enDesc:
          The base DOM URI of the document entity, if available, is unset.
          Note that it does not affect to <A::Document.documentURI>.
      @@@NodeReadOnlyError:
      @@@PerlDef:
        __CODE{tc|NodeReadOnlyError:: $node => $self}__;
        __CODE{mg|setNodeStemPropValue||ManakaiDOM|all::
          $given => $given,
          $prop => {<H::infoset|baseURI>},
          $ref => $self,
        }__;

  @LXAttr:
    @@Name: allDeclarationsProcessed
    @@enDesc:
      Whether the XML processor has read the complete DTD when the
      XML document is parsed.  This attribute corresponding to
      the <InfoProp::all declarations processed> property of
      the <InfoItem::document information item> in the XML Information Set.

        {NOTE::
          This attribute only exposes the information set property.
          Its value does <EM::not> indicate whether the document
          is <QUOTE::complete> or not, or valid or not.  In particular,
          modifications to the DOM tree does not affect the
          value of this attribute.
        }
    @@enImplNote:
      {ISSUE::
        Interaction between <M::Document.normalizeDocument> and this attribute
      }
    @@Type: boolean
    @@TrueCase:
      @@@enDesc:
        The <InfoProp::all declarations processed> property is
        true.
    @@FalseCase:
      @@@enDesc:
        The <InfoProp::all declarations processed> property is <EM::not>
        true.
    @@Get:
      @@@PerlDef:
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $r,
          $prop => {<H::infoset|allDeclarationsProcessed>},
          $ref => $self,
        }__;
    @@Set:
      @@@NodeReadOnlyError:
      @@@PerlDef:
        __CODE{tc|NodeReadOnlyError:: $node => $self}__;
        __CODE{mg|setNodeStemPropValue||ManakaiDOM|all::
          $given => $given,
          $prop => {<H::infoset|allDeclarationsProcessed>},
          $ref => $self,
        }__;
    @@LXTest:
      @@@QName: Document.allDeclarationsProcessed.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        $test->id ('default');
        $test->assert_false ($doc-><AG::Document.allDeclarationsProcessed>);

        $test->id ('set.true');
        $doc-><AS::Document.allDeclarationsProcessed> (true);
        $test->assert_true ($doc-><AG::Document.allDeclarationsProcessed>);

        $test->id ('set.false');
        $doc-><AS::Document.allDeclarationsProcessed> (false);
        $test->assert_false ($doc-><AG::Document.allDeclarationsProcessed>);
##Document

ElementTypeBinding:
  @Name: UnlessStrictErrorChecking
  @ElementType:
    dis:Description
  @ShadowContent:
    @@ddid: unlessStrictErrorChecking
    @@For: ManakaiDOM|ManakaiDOM3
    @@@:
      In manakai implementation, this exception is not thrown
      when <A::Document.strictErrorChecking> attribute is set to
      <DOM::false>.

IntPropDef:
  @QName: tc|revImplementation
  @enDesc:
    Reversed <Q::tc|implementation>
  @Type: HASH
  @mg:nodeStemKey: ed

IntPropDef:
  @QName: tc|implementation
  @enDesc:
    Associated implementation
  @Type: HASH
  @mg:nodeStemKey: impl

IntPropDef:
  @QName: tc|ownerDocument
  @mg:nodeStemKey: od

IntPropDef:
  @QName: tc|revOwnerDocument
  @enDesc:
    Reversed relationship for <Q::tc|ownerDocument>.
  @Type: HASH
  @mg:nodeStemKey: do

ElementTypeBinding:
  @Name: enDesc
  @ElementType:
    dis:Description
  @ShadowContent:
    @@lang:en

NodeTypeDef:
  @IFQName: Element
  @ClsQName: ManakaiDOMElement

  @enDesc:
    An <IF::Element> object represents an element in a document.
    Elements may have attributes associated with them.
  
  @IntMethod:
    @@Operator: mg|CreateNodeStemMethod
    @@Param:
      @@@Name: bag
      @@@Type: HASH
    @@Param:
      @@@Name: obj
      @@@Type: HASH
    @@Param:
      @@@Name: opt
      @@@Type: HASH
    @@Return:
      @@@Type: HASH
      @@@PerlDef:
        $obj->{<H::infoset|children>} = [];
        $obj->{<H::infoset|attributes>} = {};
        __CODE{DISPerl|HashStringRef||ManakaiDOM|all::
          $result => {$obj->{<H::infoset|namespaceName>}},
          $given => {${$opt->{<H::infoset|namespaceName>}}},
        }__;
        __CODE{DISPerl|HashStringRef||ManakaiDOM|all::
          $result => {$obj->{<H::infoset|prefix>}},
          $given => {${$opt->{<H::infoset|prefix>}}},
        }__;
        __CODE{DISPerl|HashStringRef||ManakaiDOM|all::
          $result => {$obj->{<H::infoset|localName>}},
          $given => {${$opt->{<H::infoset|localName>}}},
        }__;
        __CODE{mg|setOwnerProp||ManakaiDOM|all::
          $bag => $bag,
          $ownerref => {$opt->{<H::tc|ownerDocument>}},
          $ownee1hprop => {<H::tc|revOwnerDocument>},
          $ownee => {$obj},
          $owner0prop => {<H::tc|ownerDocument>},
        }__;
        $r = $obj;
  @mg:subnode1a: infoset|children
  @mg:subnode2hh: infoset|attributes
  @mg:owner0: tc|ownerDocument
  @mg:origin0: infoset|parent

  @CODE:
    @@QName: tc|createElementForTest
    @@PerlDef:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
      $el = $doc-><M::Document.createElementNS>
                    ('http://www.example.net/', 'ex:element');

  @CAttr:
    @@Name: nodeType
    @@Type: unsignedShort
    @@dis:actualType: NodeType
    @@Get:
      @@@disDef:
        @@@@DISLang:constValue: Node.ELEMENT_NODE

    @@Test:
      @@@QName: Element.nodeType.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        $test->id ('nodeType');
        $test->assert_num_equals
                 (actual_value => $el-><AG::Node.nodeType>,
                  expected_value => <C::Node.ELEMENT_NODE>);

  @CL2Attr:
    @@Name: prefix
    @@enDesc:
      The namespace prefix of the node.
    @@DOMMain:isNamespaceAware:1
    @@Type: DOMString
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          If the namespace prefix is unspecified.
      @@@PerlDef:
        my $v;
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $v,
          $prop => {<H::infoset|prefix>},
          $ref => $self,
        }__;
        $r = defined $v ? $$v : null;
    @@Set:
      @@@nullCase:
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_BAD_NAME
        @@@@enDesc:
          If the specified value contains an illegal character according to
          the XML version in use specified in the <A::Document.xmlVersion>
          attribute.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the node is read-only.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_NS_BAD_NCNAME
        @@@@enDesc:
          If the specified prefix is malformed per the XML Namespaces
          specification.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_NS_PREFIX_WITH_NULL_URI
        @@@@enDesc:
          If the <A::Node.namespaceURI> of the node is <DOM::null>.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_NS_XML_WITH_OTHER_URI
        @@@@enDesc:
          If the specified prefix is <XML::xml> and
          the <A::Node.namespaceURI> of the node is different
          from <URI::http://www.w3.org/XML/1998/namespace>.
      @@@PerlDef:
        my $od = $self-><AG::Node.ownerDocument>;
        if ($od-><AG::Document.strictErrorChecking>) {
          __CODE{tc|NodeReadOnlyError:: $node => $self}__;
          my $nsuri;
          __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
            $r => $nsuri,
            $prop => {<H::infoset|namespaceName>},
            $ref => $self,
          }__;
          if (not defined $nsuri) {
            __EXCEPTION{MDOMX|MDOM_NS_PREFIX_WITH_NULL_URI::
              infoset|prefix => {$given},
              infoset|namespaceName => {null},
            }__;
          } elsif ($$nsuri ne <Q::xml:> and $given eq 'xml') {
            __EXCEPTION{MDOMX|MDOM_NS_XML_WITH_OTHER_URI::
              infoset|prefix => {$given},
              infoset|namespaceName => {$self-><AG::Node.namespaceURI>},
            }__;
          }
          my $version = $od-><AG::Document.xmlVersion>;
          __CODE{DOMMain:ensureNamespacePrefix::
            $INPUT => $given, $INPUT_PARAM_NAME => '',
            $XMLVERSION => $version,
          }__;
        } # strict
        my $v = defined $given ? \$given : null;
        __CODE{mg|setNodeStemPropValue||ManakaiDOM|all::
          $given => $v,
          $prop => {<H::infoset|prefix>},
          $ref => $self,
        }__;

    @@L2Test:
      @@@QName: Element.localName.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createElementNS>
                         (null, 'el');

        $test->id ('localName');
        $test->assert_equals ($el-><AG::Node.localName>, 'el');

        $test->id ('namespaceURI');
        $test->assert_equals ($el-><AG::Node.namespaceURI>, null);

        $test->id ('prefix');
        $test->assert_equals ($el-><AG::Node.prefix>, null);

        $test->id ('prefix.set');
        $el-><AS::Node.prefix> ('pre');
        $test->assert_equals ($el-><AG::Node.prefix>, 'pre');

    @@L2Test:
      @@@QName: Element.localName.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createElementNS>
                         ('http://www.ns.example/', 'p:el');

        $test->id ('localName');
        $test->assert_equals ($el-><AG::Node.localName>, 'el');

        $test->id ('namespaceURI');
        $test->assert_equals ($el-><AG::Node.namespaceURI>,
                              'http://www.ns.example/');

        $test->id ('prefix');
        $test->assert_equals ($el-><AG::Node.prefix>, 'p');

        $test->id ('prefix.set');
        $el-><AS::Node.prefix> ('pre');
        $test->assert_equals ($el-><AG::Node.prefix>, 'pre');

    @@L2Test:
      @@@QName: Element.prefix.1.test
      @@@enDesc:
        <M::Document.createElementNS> node with no namespace URI,
        no prefix.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createElementNS> (null, 'el');

        $test->id ('get');
        $test->assert_null ($el-><AG::Node.prefix>);

        $test->id ('set');
        $test->assert_exception (code => sub {
          $el-><AS::Node.prefix> ('prefix');
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);
        $test->assert_null ($el-><AG::Node.prefix>);

        $test->id ('reset');
        $test->assert_exception (code => sub {
          $el-><AS::Node.prefix> (null);
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);
        $test->assert_null ($el-><AG::Node.prefix>);

    @@L2Test:
      @@@QName: Element.prefix.2.test
      @@@enDesc:
        <M::Document.createElement> node.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createElement> ('el');

        $test->id ('get');
        $test->assert_null ($el-><AG::Node.prefix>);

        $test->id ('set');
        $test->assert_exception (code => sub {
          $el-><AS::Node.prefix> ('prefix');
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);
        $test->assert_null ($el-><AG::Node.prefix>);

        $test->id ('reset');
        $test->assert_exception (code => sub {
          $el-><AS::Node.prefix> (null);
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);
        $test->assert_null ($el-><AG::Node.prefix>);

    @@L2Test:
      @@@QName: Element.prefix.3.test
      @@@enDesc:
        <M::Document.createElementNS> node with namespace URI, no prefix.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createElementNS>
                         ('http://www.dom.test/', 'el');

        $test->id ('get');
        $test->assert_null ($el-><AG::Node.prefix>);

        $test->id ('set');
        $el-><AS::Node.prefix> ('prefix');
        $test->assert_equals ($el-><AG::Node.prefix>, 'prefix');

        $test->id ('reset');
        $el-><AS::Node.prefix> (null);
        $test->assert_equals ($el-><AG::Node.prefix>);

    @@L2Test:
      @@@QName: Element.prefix.4.test
      @@@enDesc:
        <M::Document.createElementNS> node with namespace URI and prefix.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createElementNS>
                         ('http://www.dom.test/', 'p:el');

        $test->id ('get');
        $test->assert_equals ($el-><AG::Node.prefix>, 'p');

        $test->id ('set');
        $el-><AS::Node.prefix> ('prefix');
        $test->assert_equals ($el-><AG::Node.prefix>, 'prefix');

        $test->id ('reset');
        $el-><AS::Node.prefix> (null);
        $test->assert_equals ($el-><AG::Node.prefix>);

    @@L2Test:
      @@@QName: Element.prefix.5.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createElementNS>
                         ('http://www.dom.test/', 'p:el');

        $el-><M::Node.manakaiSetReadOnly> (true);

        $test->id ('set');
        $test->assert_exception (code => sub {
          $el-><AS::Node.prefix> ('new-prefix');
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);

    @@L2Test:
      @@@QName: Element.prefix.6.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createElementNS>
                         ('http://www.dom.test/', 'p:el');

        $el-><M::Node.manakaiSetReadOnly> (true);

        $test->id ('set');
        $test->assert_exception (code => sub {
          $el-><AS::Node.prefix> ('0120');
        }, exception_subtype => <Q::MDOMX|MDOM_BAD_NAME>);

    @@L2Test:
      @@@QName: Element.prefix.7.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createElementNS>
                         ('http://www.dom.test/', 'p:el');

        $el-><M::Node.manakaiSetReadOnly> (true);

        $test->id ('set');
        $test->assert_exception (code => sub {
          $el-><AS::Node.prefix> ('a:b');
        }, exception_subtype => <Q::MDOMX|MDOM_NS_BAD_NCNAME>);

    @@enImplNote:
      @@@ddid: moretest
      @@@@:
        {TODO::
          More tests for namespace errors and XML 1.1 error are necessary.
        }

  @Test:
    @@QName: Element.parentNode.1.test
    @@PerlDef:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

      my $el = $doc-><M::Document.createElementNS>
                       ('http://www.ns.example/', 'p:el');

      $test->assert_null ($el-><AG::Node.parentNode>);

  @Test:
    @@QName: Element.isSameNode.1.test
    @@PerlDef:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

      my $el = $doc-><M::Document.createElementNS>
                       ('http://www.ns.example/', 'p:el');

      my $el2 = $doc-><M::Document.createElementNS>
                       ('http://www.ns.example/', 'p:el');
      
      $test->id ('same');
      $test->assert_equals ($el, $el);
      
      $test->id ('diff');
      $test->assert_not_equals ($el, $el2);
      
      $test->id ('doc');
      $test->assert_not_equals ($el, $doc);
  @Test:
    @@QName: Element.isSameNode.2.test
    @@PerlDef:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

      my $el = $doc-><M::Document.createElementNS>
                       ('http://www.ns.example/', 'p:el');

      my $el2 = $doc-><M::Document.createElementNS>
                       ('http://www.ns.example/', 'p:el');
      
      $test->id ('same');
      $test->assert_true ($el-><M::Node.isSameNode> ($el));
      
      $test->id ('diff');
      $test->assert_false ($el-><M::Node.isSameNode> ($el2));
      
      $test->id ('doc');
      $test->assert_false ($el-><M::Node.isSameNode> ($doc));

  @LXTest:
    @@QName: Element.readOnly.test
    @@PerlDef:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

      my $el = $doc-><M::Document.createElementNS> (null, 'el');

      $test->id ('default');
      $test->assert_false ($el-><AG::Node.manakaiReadOnly>);
  
  @CMethod:
    @@Name: appendChild
    @@enDesc:
      Adds a node to the end of the list of children of the node.
      If that node is already in the tree, it is first removed.
    @@Param:
      @@@Name: newChild
      @@@Type: Node
      @@@enDesc:
        The node to add.
      @@@InCase:
        @@@@Type: DocumentFragment
        @@@@enDesc:
          The entire contents of the document fragment are
          moved into the child list of the node.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node added.  If the <P::newChild> node is a <IF::DocumentFragment>
        node, then the <P::newChild> node <kwd:MUST> be returned.
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_BAD_TYPE
        @@@@enDesc:
          If the node is of a type that does not allow children of
          the type of the <P::newChild> node.
 
          If the <A::Document.strictErrorChecking> is set to <DOM::false>,
          this exception <kwd:MAY-NOT> be thrown.
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_ANCESTOR_OR_SELF
        @@@@enDesc:
          If the <P::newChild> node is one of the node's ancestor
          <SRC::DOM 1, 2, 3> or the node itself <SRC::DOM 2 Errata, DOM 3>.
      @@@dx:raises:
        @@@@@: c|DIFFERENT_DOCUMENT_ERR
        @@@@enDesc:
          If the <P::newChild> node was created from a different
          document than the one to which the node was created or
          the node does not belong to any document.

          If the <A::Document.strictErrorChecking> is set to <DOM::false>,
          this exception <kwd:MAY-NOT> be thrown.
      @@@dx:raises: 
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the node is read-only.

          If the <A::Document.strictErrorChecking> is set to <DOM::false>,
          this exception <kwd:MAY-NOT> be thrown.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_SRC_PARENT
        @@@@enDesc:
          If the previous parent of the <P::newChild> node is read-only
          <SRC::DOM 2 Errata, DOM 3>.

          If the <A::Document.strictErrorChecking> is set to <DOM::false>,
          this exception <kwd:MAY-NOT> be thrown.
      @@@PerlDef:
        my $self_od = $self-><AG::Node.ownerDocument>;
        if ($self_od-><AG::Document.strictErrorChecking>) {
          my $anode = $self;
          while (defined $anode) {
            if ($anode eq $newChild) {
              __EXCEPTION{MDOMX|HIERARCHY_ANCESTOR_OR_SELF::
                MDOMX|param-name => 'newChild',
                c|node => {$newChild},
              }__;
            }
            $anode = $anode-><AG::Node.parentNode>;
          }
        }
        my $child_od = $newChild-><AG::Node.ownerDocument>;
        my $child_nt = $newChild-><AG::Node.nodeType>;
        __CODE{tc|appendChildImpl1::
          $self => $self, $self_od => $self_od,
          $newChild => $newChild, $child_od => $child_od, $child_nt => $child_nt,
          $r => $r,
          $allowedNodeTypes => {{
            <C::Node.TEXT_NODE> => true,
            <C::Node.ENTITY_REFERENCE_NODE> => true,
            <C::Node.ELEMENT_NODE> => true,
            <C::Node.CDATA_SECTION_NODE> => true,
            <C::Node.PROCESSING_INSTRUCTION_NODE> => true,
            <C::Node.COMMENT_NODE> => true,
          }},
        }__;

  @CMethod:
    @@Name: insertBefore
    @@enDesc:
      Inserts a node before the existing child node of the node.

      Inserting a node before itself is implementation dependent.
    @@Param:
      @@@Name: newChild
      @@@Type: Node
      @@@enDesc:
        The node to insert.  If the <P::newChild> is already in 
        the tree, it is first removed.
      @@@InCase:
        @@@@Type: DocumentFragment
        @@@@enDesc:
          All of children of the <P::newChild> node are inserted,
          in the same order, before <P::refChild>.
    @@Param:
      @@@Name: refChild
      @@@Type: Node
      @@@enDesc:
        The reference node, i.e. the node before which the new node
        must be inserted.
      @@@nullCase:
        @@@@enDesc:
          The <P::newChild> node is inserted at the end of the list
          of children.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node being inserted.
      @@@enImplNote:
        What is returned if <P::newChild> is a <IF::DocumentFragment>?
        See also <M::Node.appendChild>'s return value.
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_BAD_TYPE
        @@@@enDesc:
          If the node is of a type that does not allow children of
          the type of the <P::newChild> node.
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_ANCESTOR_OR_SELF
        @@@@enDesc:
          If the <P::newChild> node is one of the node's ancestor
          <SRC::DOM 1, 2, 3> or the node itself <SRC::DOM 2 Errata, DOM 3>.
      @@@dx:raises:
        @@@@@: c|DIFFERENT_DOCUMENT_ERR
        @@@@enDesc:
          If the <P::newChild> node was created from a different
          document than the one that created the node.
        @@@@enImplNote:
          The DOM specification ignores the fact that <IF::Document>s
          and <IF::x|DocumentType>s are created from 
          <IF::c|DOMImplementation> :-)
      @@@dx:raises: 
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the node is read-only.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_SRC_PARENT
        @@@@enDesc:
          If the previous parent of the <P::newChild> node is read-only
          <SRC::DOM 1 SE, DOM 2, 3>.
      @@@dx:raises:
        @@@@@: c|NOT_CHILD_ERR
        @@@@enDesc:
          If the <P::refChild> node is not a child of the node.
      @@@c:reports:
        @@@@@: t|insert-before-itself
        @@@@enDesc:
          If the <P::newChild> node is same as the <P::refChild> node.
          Then, the result is implementation dependent.
        @@@@For: ManakaiDOM|ManakaiDOM
      @@@PerlDef:
        my $self_od = $self-><AG::Node.ownerDocument>;
        if ($self_od-><AG::Document.strictErrorChecking>) {
          my $anode = $self;
          while (defined $anode) {
            if ($anode eq $newChild) {
              __EXCEPTION{MDOMX|HIERARCHY_ANCESTOR_OR_SELF::
                MDOMX|param-name => 'newChild',
                c|node => {$newChild},
              }__;
            }
            $anode = $anode-><AG::Node.parentNode>;
          }
        }
        my $child_od = $newChild-><AG::Node.ownerDocument>;
        my $child_nt = $newChild-><AG::Node.nodeType>;
        __CODE{tc|insertBeforeImpl1::
          $self => $self, $self_od => $self_od,
          $newChild => $newChild, $refChild => $refChild,
          $child_od => $child_od, $child_nt => $child_nt,
          $r => $r,
          $allowedNodeTypes => {{
            <C::Node.TEXT_NODE> => true,
            <C::Node.ENTITY_REFERENCE_NODE> => true,
            <C::Node.ELEMENT_NODE> => true,
            <C::Node.CDATA_SECTION_NODE> => true,
            <C::Node.PROCESSING_INSTRUCTION_NODE> => true,
            <C::Node.COMMENT_NODE> => true,
          }},
        }__;

  @CMethod:
    @@Name: replaceChild
    @@enDesc:
      Replaces a child node with another node.

      Replacing a node with itself is implementation dependent <SRC::DOM3>.
    @@Param:
      @@@Name: newChild
      @@@Type: Node
      @@@enDesc:
        The new node to put in the child list.

        If the <P::newChild> node is already in the tree,
        it is first removed.
      @@@InCase:
        @@@@Type: DocumentFragment
        @@@@enDesc:
          The <P::oldChild> node is replaced by all of the 
          <IF::DocumentFragment> children, which are inserted
          in the same order <SRC::DOM1 SE, DOM2, DOM3>.
    @@Param:
      @@@Name: oldChild
      @@@Type: Node
      @@@enDesc:
        The node being replaced in the list.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node replaced.
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_BAD_TYPE
        @@@@enDesc:
          If the node is of a type that does not allow children of
          the type of the <P::newChild> node.
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_ANCESTOR_OR_SELF
        @@@@enDesc:
          If the <P::newChild> node is one of the node's ancestor
          <SRC::DOM 1, 2, 3> or the node itself <SRC::DOM 2 Errata, DOM 3>.
      @@@dx:raises:
        @@@@@: c|DIFFERENT_DOCUMENT_ERR
        @@@@enDesc:
          If the <P::newChild> node was created from a different
          document than the one that created the node.
        @@@@enImplNote:
          The DOM specification ignores the fact that <IF::Document>s
          and <IF::x|DocumentType>s are created from 
          <IF::c|DOMImplementation> :-)
      @@@dx:raises: 
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the node is read-only.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_SRC_PARENT
        @@@@enDesc:
          If the previous parent of the <P::newChild> node is read-only
          <SRC::DOM1 SE, DOM2, DOM3>.
      @@@dx:raises:
        @@@@@: c|NOT_CHILD_ERR
        @@@@enDesc:
          If the <P::oldChild> node is not a child of the node.
      @@@c:reports:
        @@@@@: t|replaced-by-itself
        @@@@enDesc:
          If the <P::newChild> node is same as the <P::oldChild> node.
          Then, the result is implementation dependent.
        @@@@For: ManakaiDOM|ManakaiDOM
      @@@PerlDef:
        my $self_od = $self-><AG::Node.ownerDocument>;
        if ($self_od-><AG::Document.strictErrorChecking>) {
          my $anode = $self;
          while (defined $anode) {
            if ($anode eq $newChild) {
              __EXCEPTION{MDOMX|HIERARCHY_ANCESTOR_OR_SELF::
                MDOMX|param-name => 'newChild',
                c|node => {$newChild},
              }__;
            }
            $anode = $anode-><AG::Node.parentNode>;
          }
        }
        my $child_od = $newChild-><AG::Node.ownerDocument>;
        my $child_nt = $newChild-><AG::Node.nodeType>;
        __CODE{tc|replaceChildImpl1::
          $self => $self, $self_od => $self_od,
          $newChild => $newChild, $refChild => $oldChild,
          $child_od => $child_od, $child_nt => $child_nt,
          $r => $r,
          $allowedNodeTypes => {{
            <C::Node.TEXT_NODE> => true,
            <C::Node.ENTITY_REFERENCE_NODE> => true,
            <C::Node.ELEMENT_NODE> => true,
            <C::Node.CDATA_SECTION_NODE> => true,
            <C::Node.PROCESSING_INSTRUCTION_NODE> => true,
            <C::Node.COMMENT_NODE> => true,
          }},
        }__;
  
  @CAttr:
    @@Name: attributes
    @@enDesc:
      A named node map containing the attributes of the node.
    @@Type: NamedNodeMap
    @@Get:
      @@@PerlDef:
        __CODE{t|getAttrMap::
          $node => $self,
          $map => $r,
        }__;

    @@Test:
      @@@QName: Element.attributes.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;
        
        my $as = $el-><AG::Node.attributes>;
        $test->assert_isa ($as, <IFName::NamedNodeMap>);

        $el-><M::Element.setAttribute> (at1 => 'value');
        $test->assert_equals 
                 ($as-><M::NamedNodeMap.getNamedItem> ('at1'),
                  $el-><M::Element.getAttributeNode> ('at1'));

  @CAttr:
    @@Name: nodeName
    @@enDesc:
      The node name.
    @@DOMMain:isNamespaceUnaware:1
    @@Type: DOMString
    @@Get:
      @@@enDesc:
        Same as <A::Element.tagName>.
      @@@disDef:
        @@@@DISPerl:cloneCode:.tagName.get

  @Attr:
    @@Name: tagName
    @@enDesc:
      The name of the element.
    @@enDesc:
      @@@ddid: ns
      @@@@:
        If the <A::Node.localName> is different from <DOM::null>,
        then the attribute value is the qualified name of the 
        element node.  <SRC::DOM3>
    @@enDesc:
      @@@ddid:html
      @@@@:
        In the HTML DOM it is the canonical uppercase form,
        regardless of the case in the source HTML document.
    @@Type: DOMString
    @@Get:
      @@@PerlDef: 
        my $prefix;
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $prefix,
          $prop => {<H::infoset|prefix>},
          $ref => $self,
        }__;
        my $lname;
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $lname,
          $prop => {<H::infoset|localName>},
          $ref => $self,
        }__;
        $r = defined $prefix ? $prefix.':'.$lname : $lname;
    @@enImplNote:
      {ISSUE::
        In HTML?
      }

      {NOTE::
        DOM Level 1 nodes are no longer supported.
      }

    @@Test:
      @@@QName: Element.nodeName.tagName.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createElement> ('element1');

        $test->id ('nodeName');
        $test->assert_equals ($el-><AG::Node.nodeName>, 'element1');

        $test->id ('tagName');
        $test->assert_equals ($el-><AG::Element.tagName>, 'element1');

    @@Test:
      @@@QName: Element.nodeName.tagName.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createElementNS> (null, 'element1');

        $test->id ('nodeName');
        $test->assert_equals ($el-><AG::Node.nodeName>, 'element1');

        $test->id ('tagName');
        $test->assert_equals ($el-><AG::Element.tagName>, 'element1');

    @@Test:
      @@@QName: Element.nodeName.tagName.3.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createElementNS>
                         ('http://el1.test/', 'element1');

        $test->id ('nodeName');
        $test->assert_equals ($el-><AG::Node.nodeName>, 'element1');

        $test->id ('tagName');
        $test->assert_equals ($el-><AG::Element.tagName>, 'element1');

    @@Test:
      @@@QName: Element.nodeName.tagName.4.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createElementNS>
                         ('http://el1.test/', 'pfx:element1');

        $test->id ('nodeName');
        $test->assert_equals ($el-><AG::Node.nodeName>, 'pfx:element1');

        $test->id ('tagName');
        $test->assert_equals ($el-><AG::Element.tagName>, 'pfx:element1');

    @@Test:
      @@@QName: Element.appendChild.1.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');
        my $pi = $doc-><M::Document.createTextNode> ('pi');

        my $return = $dtd-><M::Node.appendChild> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: Element.appendChild.1.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');
        my $pi = $doc-><M::Document.createEntityReference> ('pi');

        my $return = $dtd-><M::Node.appendChild> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|EntityReference>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: Element.appendChild.1.3.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');
        my $pi = $doc-><M::Document.createElement> ('pi');

        my $return = $dtd-><M::Node.appendChild> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Element>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: Element.appendChild.1.4.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');
        my $pi = $doc-><M::Document.createProcessingInstruction> ('pi');

        my $return = $dtd-><M::Node.appendChild> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|ProcessingInstruction>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: Element.appendChild.1.5.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');
        my $pi = $doc-><M::Document.createCDATASection> ('pi');

        my $return = $dtd-><M::Node.appendChild> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|CDATASection>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: Element.appendChild.1.6.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');
        my $pi = $doc-><M::Document.createComment> ('pi');

        my $return = $dtd-><M::Node.appendChild> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Comment>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: Element.insertBefore.1.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');
        my $pi = $doc-><M::Document.createTextNode> ('pi');

        my $return = $dtd-><M::Node.insertBefore> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: Element.insertBefore.1.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');
        my $pi = $doc-><M::Document.createEntityReference> ('pi');

        my $return = $dtd-><M::Node.insertBefore> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|EntityReference>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: Element.insertBefore.1.3.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');
        my $pi = $doc-><M::Document.createElement> ('pi');

        my $return = $dtd-><M::Node.insertBefore> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Element>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: Element.insertBefore.1.4.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');
        my $pi = $doc-><M::Document.createProcessingInstruction> ('pi');

        my $return = $dtd-><M::Node.insertBefore> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|ProcessingInstruction>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: Element.insertBefore.1.5.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');
        my $pi = $doc-><M::Document.createCDATASection> ('pi');

        my $return = $dtd-><M::Node.insertBefore> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|CDATASection>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: Element.insertBefore.1.6.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');
        my $pi = $doc-><M::Document.createComment> ('pi');

        my $return = $dtd-><M::Node.insertBefore> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Comment>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);

    @@Test:
      @@@QName: Element.appendChild.has.parent.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');

        my $piparent = $doc-><M::Document.createElementNS> (null, 'e');
        my $pi = $doc-><M::Document.createTextNode> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.appendChild> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: Element.appendChild.has.parent.1.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');

        my $piparent = $doc-><M::Document.createElementNS> (null, 'e');
        my $pi = $doc-><M::Document.createEntityReference> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.appendChild> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|EntityReference>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: Element.insertBefore.has.parent.1.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');

        my $piparent = $doc-><M::Document.createElementNS> (null, 'e');
        my $pi = $doc-><M::Document.createTextNode> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.insertBefore> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: Element.insertBefore.has.parent.1.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');

        my $piparent = $doc-><M::Document.createElementNS> (null, 'e');
        my $pi = $doc-><M::Document.createEntityReference> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.insertBefore> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|EntityReference>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi);

    @@Test:
      @@@QName: Element.appendChild.documentfragment.1.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createTextNode> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.appendChild> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: Element.appendChild.documentfragment.1.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createEntityReference> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.appendChild> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|EntityReference>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: Element.insertBefore.documentfragment.1.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createTextNode> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.insertBefore> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: Element.insertBefore.documentfragment.1.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createEntityReference> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.insertBefore> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|EntityReference>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: Element.replaceChild.documentfragment.1.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');
        my $pi0 = $doc-><M::Document.createTextNode> ('pi0');
        $dtd-><M::Node.appendChild> ($pi0);

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createTextNode> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.replaceChild> ($piparent, $pi0);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi0);
    @@Test:
      @@@QName: Element.replaceChild.documentfragment.1.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');
        my $pi0 = $doc-><M::Document.createTextNode> ('pi0');
        $dtd-><M::Node.appendChild> ($pi0);

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createEntityReference> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.replaceChild> ($piparent, $pi0);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|EntityReference>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi0);

    @@Test:
      @@@QName: Element.appendChild.documentfragment.2.1.test
      @@@enDesc:
        Empty document fragment.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');

        my $piparent = $doc-><M::Document.createDocumentFragment>;

        my $return = $dtd-><M::Node.appendChild> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 0);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: Element.insertBefore.documentfragment.2.test
      @@@enDesc:
        Empty document fragment.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');

        my $piparent = $doc-><M::Document.createDocumentFragment>;

        my $return = $dtd-><M::Node.insertBefore> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 0);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: Element.replaceChild.documentfragment.2.test
      @@@enDesc:
        Empty document fragment.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');
        my $pi0 = $doc-><M::Document.createTextNode> ('pi0');
        $dtd-><M::Node.appendChild> ($pi0);

        my $piparent = $doc-><M::Document.createDocumentFragment>;

        my $return = $dtd-><M::Node.replaceChild> ($piparent, $pi0);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 0);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi0);

    @@Test:
      @@@QName: Element.appendChild.documentfragment.3.test
      @@@enDesc:
        Three PIs in document fragment.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createTextNode> ('pi');
        my $pi2 = $doc-><M::Document.createEntityReference> ('pi2');
        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $piparent-><M::Node.appendChild> ($pi);
        $piparent-><M::Node.appendChild> ($pi2);
        $piparent-><M::Node.appendChild> ($pi3);

        my $return = $dtd-><M::Node.appendChild> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 3);

        my $item = $child-><M::tc|NodeList.item> (0);
        my $item2 = $child-><M::tc|NodeList.item> (1);
        my $item3 = $child-><M::tc|NodeList.item> (2);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);
        $test->id ('child.item.node2');
        $test->assert_isa ($item2, <IFName::Node>);
        $test->id ('child.item.node3');
        $test->assert_isa ($item3, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);
        $test->id ('child.item.pi2');
        $test->assert_isa ($item2, <IFName::tx|EntityReference>);
        $test->id ('child.item.pi3');
        $test->assert_isa ($item3, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);
        $test->id ('child.item.equals2');
        $test->assert_equals ($item2, $pi2);
        $test->id ('child.item.equals3');
        $test->assert_equals ($item3, $pi3);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi3);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);
        $test->id ('parent2');
        my $parent2 = $item2-><AG::Node.parentNode>;
        $test->assert_equals ($parent2, $dtd);
        $test->id ('parent3');
        my $parent3 = $item3-><AG::Node.parentNode>;
        $test->assert_equals ($parent3, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: Element.insertBefore.documentfragment.3.test
      @@@enDesc:
        Three PIs in document fragment.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createTextNode> ('pi');
        my $pi2 = $doc-><M::Document.createEntityReference> ('pi2');
        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $piparent-><M::Node.appendChild> ($pi);
        $piparent-><M::Node.appendChild> ($pi2);
        $piparent-><M::Node.appendChild> ($pi3);

        my $return = $dtd-><M::Node.insertBefore> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 3);

        my $item = $child-><M::tc|NodeList.item> (0);
        my $item2 = $child-><M::tc|NodeList.item> (1);
        my $item3 = $child-><M::tc|NodeList.item> (2);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);
        $test->id ('child.item.node2');
        $test->assert_isa ($item2, <IFName::Node>);
        $test->id ('child.item.node3');
        $test->assert_isa ($item3, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);
        $test->id ('child.item.pi2');
        $test->assert_isa ($item2, <IFName::tx|EntityReference>);
        $test->id ('child.item.pi3');
        $test->assert_isa ($item3, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);
        $test->id ('child.item.equals2');
        $test->assert_equals ($item2, $pi2);
        $test->id ('child.item.equals3');
        $test->assert_equals ($item3, $pi3);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi3);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);
        $test->id ('parent2');
        my $parent2 = $item2-><AG::Node.parentNode>;
        $test->assert_equals ($parent2, $dtd);
        $test->id ('parent3');
        my $parent3 = $item3-><AG::Node.parentNode>;
        $test->assert_equals ($parent3, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: Element.replaceChild.documentfragment.3.test
      @@@enDesc:
        Three PIs in document fragment.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');
        my $pi0 = $doc-><M::Document.createTextNode> ('pi0');
        $dtd-><M::Node.appendChild> ($pi0);

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createTextNode> ('pi');
        my $pi2 = $doc-><M::Document.createEntityReference> ('pi2');
        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $piparent-><M::Node.appendChild> ($pi);
        $piparent-><M::Node.appendChild> ($pi2);
        $piparent-><M::Node.appendChild> ($pi3);

        my $return = $dtd-><M::Node.replaceChild> ($piparent, $pi0);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 3);

        my $item = $child-><M::tc|NodeList.item> (0);
        my $item2 = $child-><M::tc|NodeList.item> (1);
        my $item3 = $child-><M::tc|NodeList.item> (2);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);
        $test->id ('child.item.node2');
        $test->assert_isa ($item2, <IFName::Node>);
        $test->id ('child.item.node3');
        $test->assert_isa ($item3, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);
        $test->id ('child.item.pi2');
        $test->assert_isa ($item2, <IFName::tx|EntityReference>);
        $test->id ('child.item.pi3');
        $test->assert_isa ($item3, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);
        $test->id ('child.item.equals2');
        $test->assert_equals ($item2, $pi2);
        $test->id ('child.item.equals3');
        $test->assert_equals ($item3, $pi3);


        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi3);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);
        $test->id ('parent2');
        my $parent2 = $item2-><AG::Node.parentNode>;
        $test->assert_equals ($parent2, $dtd);
        $test->id ('parent3');
        my $parent3 = $item3-><AG::Node.parentNode>;
        $test->assert_equals ($parent3, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi0);

    @@Test:
      @@@QName: Element.appendChild.badtype.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $comment = $doc-><M::Document.createElement> ('dt');
        my $pi0 = $doc-><M::Document.createTextNode> ('pi0');
        $comment-><M::Node.appendChild> ($pi0);

        for my $node (
          $docx-><M::d|DocumentXDoctype.createDocumentTypeDefinition> ('d'),
          $doc-><M::Document.createAttribute> ('a'),
          $docx-><M::d|DocumentXDoctype.createGeneralEntity> ('ge'),
          $docx-><M::d|DocumentXDoctype.createNotation> ('not'),
          $docx-><M::d|DocumentXDoctype.createElementTypeDefinition> ('et'),
          $docx-><M::d|DocumentXDoctype.createAttributeDefinition> ('at'),
          #test:nodeTypes
        ) {
          $test->id ('appendChild.'.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.appendChild> ($node);
          }, exception_subtype => <Q::MDOMX|HIERARCHY_BAD_TYPE>);

          $test->id ('insertBefore.'.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.insertBefore> ($node);
          }, exception_subtype => <Q::MDOMX|HIERARCHY_BAD_TYPE>);

          $test->id ('replaceChild.'.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.replaceChild> ($node, $pi0);
          }, exception_subtype => <Q::MDOMX|HIERARCHY_BAD_TYPE>);
        }

    @@Test:
      @@@QName: Element.appendChild.wrongdoc.test
      @@@PerlDef:
        my $doc0;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc0}__;
        my $docx0 = $doc0-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;

        my $comment = $doc0-><M::Document.createElement> ('dt');

        for my $node (
          $doc-><M::Document.createTextNode> ('pi'),
          $doc-><M::Document.createEntityReference> ('e'),
          $doc-><M::Document.createComment> ('c'),
          $doc-><M::Document.createCDATASection> ('cs'),
          $doc-><M::Document.createProcessingInstruction> ('pi'),
          $doc-><M::Document.createElement> ('el'),
        ) {
          $test->id ('type='.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.appendChild> ($node);
          }, exception_subtype => <Q::c|DIFFERENT_DOCUMENT_ERR>);
        }
    @@Test:
      @@@QName: Element.insertBefore.wrongdoc.test
      @@@PerlDef:
        my $doc0;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc0}__;
        my $docx0 = $doc0-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;

        my $comment = $doc0-><M::Document.createElement> ('dt');
        my $pi0 = $doc0-><M::Document.createTextNode> ('pi0');
        $comment-><M::Node.appendChild> ($pi0);

        for my $node (
          $doc-><M::Document.createTextNode> ('pi'),
          $doc-><M::Document.createEntityReference> ('ent'),
          $doc-><M::Document.createComment> ('c'),
          $doc-><M::Document.createCDATASection> ('cs'),
          $doc-><M::Document.createProcessingInstruction> ('pi'),
          $doc-><M::Document.createElement> ('el'),
        ) {
          $test->id ('appendChild.'.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.appendChild> ($node);
          }, exception_subtype => <Q::c|DIFFERENT_DOCUMENT_ERR>);

          $test->id ('insertBefore.'.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.insertBefore> ($node);
          }, exception_subtype => <Q::c|DIFFERENT_DOCUMENT_ERR>);

          $test->id ('replaceChild.'.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.replaceChild> ($node, $pi0);
          }, exception_subtype => <Q::c|DIFFERENT_DOCUMENT_ERR>);
        }

    @@Test:
      @@@QName: Element.appendChild.readonly.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');
        my $pi0 = $doc-><M::Document.createTextNode> ('pi0');
        $dtd-><M::Node.appendChild> ($pi0);
        $dtd-><M::Node.setReadOnly> (true);

        $test->id ('pi');
        my $node = $doc-><M::Document.createTextNode> ('pi');

        $test->assert_exception (code => sub {
          $dtd-><M::Node.appendChild> ($node);
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);

        $test->id ('pi.insertBefore');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.insertBefore> ($node);
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);

        $test->id ('pi.replaceChild');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.replaceChild> ($node, $pi0);
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);

        $test->id ('fragment');
        my $node2 = $doc-><M::Document.createDocumentFragment>;
        $node2-><M::Node.appendChild> ($node);

        $test->assert_exception (code => sub {
          $dtd-><M::Node.appendChild> ($node2);
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);

        $test->id ('fragment.insertBefore');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.insertBefore> ($node2);
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);

        $test->id ('fragment.replaceChild');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.replaceChild> ($node2, $pi0);
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);

    @@Test:
      @@@QName: Element.appendChild.readonly.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');
        my $pi0 = $doc-><M::Document.createTextNode> ('pi0');
        $dtd-><M::Node.appendChild> ($pi0);

        $test->id ('pi');
        my $el = $doc-><M::Document.createElementNS> (null, 'e');
        my $node = $doc-><M::Document.createTextNode> ('pi');
        $el-><M::Node.appendChild> ($node);
        $el-><M::Node.setReadOnly> (true);

        $test->assert_exception (code => sub {
          $dtd-><M::Node.appendChild> ($node);
        }, exception_subtype => <Q::MDOMX|NOMOD_SRC_PARENT>);

        $test->id ('pi.insertBefore');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.insertBefore> ($node);
        }, exception_subtype => <Q::MDOMX|NOMOD_SRC_PARENT>);

        $test->id ('pi.replaceChild');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.replaceChild> ($node, $pi0);
        }, exception_subtype => <Q::MDOMX|NOMOD_SRC_PARENT>);

        $test->id ('fragment');
        my $node2 = $doc-><M::Document.createDocumentFragment>;
        my $node3 = $doc-><M::Document.createTextNode> ('pi');
        $node2-><M::Node.appendChild> ($node3);
        $node2-><M::Node.manakaiSetReadOnly> (true);

        $test->assert_exception (code => sub {
          $dtd-><M::Node.appendChild> ($node2);
        }, exception_subtype => <Q::MDOMX|NOMOD_SRC_PARENT>);

        $test->id ('fragment.insertBefore');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.insertBefore> ($node2);
        }, exception_subtype => <Q::MDOMX|NOMOD_SRC_PARENT>);

        $test->id ('fragment.replaceChild');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.replaceChild> ($node2, $pi0);
        }, exception_subtype => <Q::MDOMX|NOMOD_SRC_PARENT>);

    @@Test:
      @@@QName: Element.insertBefore.refChild.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.insertBefore> ($pi2, $pi1);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi2);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi1);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: Element.insertBefore.refChild.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $dtd-><M::Node.insertBefore> ($pi3, $pi2);

        # pi1, pi3, pi2

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi1);

        $test->id ('firstChild.nextSibling');
        $test->assert_equals ($dtd-><AG::Node.firstChild>
                                  -><AG::Node.nextSibling>, $pi3);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi2);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 3);

    @@Test:
      @@@QName: Element.insertBefore.refChild.3.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $dtd-><M::Node.appendChild> ($pi3);

        # pi1, pi2, pi3

        $dtd-><M::Node.insertBefore> ($pi2, $pi1);
 
        # pi2, pi1, pi3

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi2);

        $test->id ('firstChild.nextSibling');
        $test->assert_equals ($dtd-><AG::Node.firstChild>
                                  -><AG::Node.nextSibling>, $pi1);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi3);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 3);

    @@Test:
      @@@QName: Element.insertBefore.refChild.4.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $dtd-><M::Node.appendChild> ($pi3);

        # pi1, pi2, pi3

        $dtd-><M::Node.insertBefore> ($pi3, $pi1);
 
        # pi3, pi1, pi2

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi3);

        $test->id ('firstChild.nextSibling');
        $test->assert_equals ($dtd-><AG::Node.firstChild>
                                  -><AG::Node.nextSibling>, $pi1);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi2);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 3);

    @@Test:
      @@@QName: Element.insertBefore.refChild.not_found_err.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');

        my $pi4 = $doc-><M::Document.createTextNode> ('pi4');

        # pi1, pi2

        $test->assert_exception (code => sub {
          $dtd-><M::Node.insertBefore> ($pi4, $pi3);
        }, exception_subtype => <Q::c|NOT_CHILD_ERR>);

    @@Test:
      @@@QName: Element.insertBefore.refChild=newChild.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        # pi1, pi2

        my $eh_called = false;
        my $cfg = $doc-><AG::Document.domConfig>;
        $cfg-><M::c|DOMConfiguration.setParameter> ('error-handler' => sub {
          my (undef, $err) = @_;
          $eh_called = true;
          $test->assert_equals ($err-><AG::c|DOMError.severity>,
                                <C::c|DOMError.SEVERITY_WARNING>);
          $test->assert_equals ($err-><AG::c|DOMError.type>,
                                <Q::t|insert-before-itself>);
          $test->assert_equals ($err-><AG::c|DOMError.relatedData>, $pi2);
          $test->assert_null ($err-><AG::c|DOMError.relatedException>);
          $test->assert_isa ($err-><AG::c|DOMError.location>,
                             <IFName::c|DOMLocator>);
          $test->assert_not_null ($err-><AG::c|DOMError.message>);
        });

        $test->assert_false ($eh_called);
        $dtd-><M::Node.insertBefore> ($pi2, $pi2);
        $test->assert_true ($eh_called);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi1);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi2);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: Element.replaceChild.oldChild=newChild.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        # pi1, pi2

        my $eh_called = false;
        my $cfg = $doc-><AG::Document.domConfig>;
        $cfg-><M::c|DOMConfiguration.setParameter> ('error-handler' => sub {
          my (undef, $err) = @_;
          $eh_called = true;
          $test->assert_equals ($err-><AG::c|DOMError.severity>,
                                <C::c|DOMError.SEVERITY_WARNING>);
          $test->assert_equals ($err-><AG::c|DOMError.type>,
                                <Q::t|replace-by-itself>);
          $test->assert_equals ($err-><AG::c|DOMError.relatedData>, $pi2);
          $test->assert_null ($err-><AG::c|DOMError.relatedException>);
          $test->assert_isa ($err-><AG::c|DOMError.location>,
                             <IFName::c|DOMLocator>);
          $test->assert_not_null ($err-><AG::c|DOMError.message>);
        });

        $test->assert_false ($eh_called);
        $dtd-><M::Node.replaceChild> ($pi2, $pi2);
        $test->assert_true ($eh_called);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi1);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi2);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: Element.appendChild.sameparent.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        # pi1, pi2

        my $return = $dtd-><M::Node.appendChild> ($pi1);

        # pi2, pi1

        $test->id ('return');
        $test->assert_equals ($return, $pi1);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi2);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi1);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: Element.insertBefore.sameparent.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        # pi1, pi2

        my $return = $dtd-><M::Node.insertBefore> ($pi1);

        # pi2, pi1

        $test->id ('return');
        $test->assert_equals ($return, $pi1);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi2);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi1);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: Element.appendChild.sameparent.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        # pi1, pi2

        my $return = $dtd-><M::Node.appendChild> ($pi2);

        # pi1, pi2

        $test->id ('return');
        $test->assert_equals ($return, $pi2);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi1);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi2);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: Element.insertBefore.sameparent.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        # pi1, pi2

        my $return = $dtd-><M::Node.insertBefore> ($pi2);

        # pi1, pi2

        $test->id ('return');
        $test->assert_equals ($return, $pi2);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi1);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi2);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: Element.replaceChild.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $dtd-><M::Node.appendChild> ($pi3);

        # pi1, pi2, pi3

        my $pi9 = $doc-><M::Document.createTextNode> ('pi9');
        my $return = $dtd-><M::Node.replaceChild> ($pi9, $pi1);

        # pi9, pi2, pi3

        $test->id ('return.node');
        $test->assert_isa ($return, <IFName::Node>);
        $test->id ('return.pi');
        $test->assert_isa ($return, <IFName::Text>);
        $test->id ('return');
        $test->assert_equals ($return, $pi1);

        my $c = $dtd-><AG::Node.childNodes>;

        $test->id ('length');
        $test->assert_num_equals (actual_value => 0+@$c, expected_value => 3);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi9);

        $test->id ('firstChild.nextSibling');
        $test->assert_equals ($dtd-><AG::Node.firstChild>
                                  -><AG::Node.nextSibling>, $pi2);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi3);
 
        $test->id ('parent');
        $test->assert_equals ($pi9-><AG::Node.parentNode>, $dtd);

        $test->id ('return.parent');
        $test->assert_null ($pi1-><AG::Node.parentNode>);

    @@Test:
      @@@QName: Element.replaceChild.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $dtd-><M::Node.appendChild> ($pi3);

        # pi1, pi2, pi3

        my $pi9 = $doc-><M::Document.createTextNode> ('pi9');
        my $return = $dtd-><M::Node.replaceChild> ($pi9, $pi2);

        # pi1, pi9, pi3

        $test->id ('return.node');
        $test->assert_isa ($return, <IFName::Node>);
        $test->id ('return.pi');
        $test->assert_isa ($return, <IFName::Text>);
        $test->id ('return');
        $test->assert_equals ($return, $pi2);

        my $c = $dtd-><AG::Node.childNodes>;

        $test->id ('length');
        $test->assert_num_equals (actual_value => 0+@$c, expected_value => 3);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi1);

        $test->id ('firstChild.nextSibling');
        $test->assert_equals ($dtd-><AG::Node.firstChild>
                                  -><AG::Node.nextSibling>, $pi9);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi3);
 
        $test->id ('parent');
        $test->assert_equals ($pi9-><AG::Node.parentNode>, $dtd);

        $test->id ('return.parent');
        $test->assert_null ($pi2-><AG::Node.parentNode>);

    @@Test:
      @@@QName: Element.replaceChild.3.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $dtd-><M::Node.appendChild> ($pi3);

        # pi1, pi2, pi3

        my $pi9 = $doc-><M::Document.createTextNode> ('pi9');
        my $return = $dtd-><M::Node.replaceChild> ($pi9, $pi3);

        # pi1, pi2, pi9

        $test->id ('return.node');
        $test->assert_isa ($return, <IFName::Node>);
        $test->id ('return.pi');
        $test->assert_isa ($return, <IFName::Text>);
        $test->id ('return');
        $test->assert_equals ($return, $pi3);

        my $c = $dtd-><AG::Node.childNodes>;

        $test->id ('length');
        $test->assert_num_equals (actual_value => 0+@$c, expected_value => 3);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi1);

        $test->id ('firstChild.nextSibling');
        $test->assert_equals ($dtd-><AG::Node.firstChild>
                                  -><AG::Node.nextSibling>, $pi2);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi9);
 
        $test->id ('parent');
        $test->assert_equals ($pi9-><AG::Node.parentNode>, $dtd);

        $test->id ('return.parent');
        $test->assert_null ($pi3-><AG::Node.parentNode>);

    @@Test:
      @@@QName: Element.replaceChild.sameparent.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $dtd-><M::Node.appendChild> ($pi3);

        # pi1, pi2, pi3

        my $return = $dtd-><M::Node.replaceChild> ($pi3, $pi1);

        # pi3, pi2

        $test->id ('return.node');
        $test->assert_isa ($return, <IFName::Node>);
        $test->id ('return.pi');
        $test->assert_isa ($return, <IFName::Text>);
        $test->id ('return');
        $test->assert_equals ($return, $pi1);

        my $c = $dtd-><AG::Node.childNodes>;

        $test->id ('length');
        $test->assert_num_equals (actual_value => 0+@$c, expected_value => 2);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi3);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi2);
 
        $test->id ('parent');
        $test->assert_equals ($pi3-><AG::Node.parentNode>, $dtd);

        $test->id ('return.parent');
        $test->assert_null ($pi1-><AG::Node.parentNode>);

    @@Test:
      @@@QName: Element.replaceChild.sameparent.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $dtd-><M::Node.appendChild> ($pi3);

        # pi1, pi2, pi3

        my $return = $dtd-><M::Node.replaceChild> ($pi1, $pi3);

        # pi2, pi1

        $test->id ('return.node');
        $test->assert_isa ($return, <IFName::Node>);
        $test->id ('return.pi');
        $test->assert_isa ($return, <IFName::Text>);
        $test->id ('return');
        $test->assert_equals ($return, $pi3);

        my $c = $dtd-><AG::Node.childNodes>;

        $test->id ('length');
        $test->assert_num_equals (actual_value => 0+@$c, expected_value => 2);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi2);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi1);
 
        $test->id ('parent');
        $test->assert_equals ($pi1-><AG::Node.parentNode>, $dtd);

        $test->id ('return.parent');
        $test->assert_null ($pi3-><AG::Node.parentNode>);

    @@Test:
      @@@QName: Element.appendChild.ancestor.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');
        $dtd-><M::Node.appendChild>
                ($doc-><M::Document.createTextNode> ('text1'));

        $test->id ('appendChild');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.appendChild> ($dtd);
        }, exception_subtype => <Q::MDOMX|HIERARCHY_ANCESTOR_OR_SELF>);

        $test->id ('insertBefore');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.insertBefore> ($dtd);
        }, exception_subtype => <Q::MDOMX|HIERARCHY_ANCESTOR_OR_SELF>);

        $test->id ('replaceChild');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.replaceChild> ($dtd, $dtd-><AG::Node.firstChild>);
        }, exception_subtype => <Q::MDOMX|HIERARCHY_ANCESTOR_OR_SELF>);

    @@Test:
      @@@QName: Element.appendChild.ancestor.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');
        $dtd-><M::Node.appendChild>
                ($doc-><M::Document.createTextNode> ('text1'));
        my $el = $doc-><M::Document.createElement> ('el');
        $el-><M::Node.appendChild> ($dtd);

        $test->id ('appendChild');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.appendChild> ($el);
        }, exception_subtype => <Q::MDOMX|HIERARCHY_ANCESTOR_OR_SELF>);

        $test->id ('insertBefore');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.insertBefore> ($el);
        }, exception_subtype => <Q::MDOMX|HIERARCHY_ANCESTOR_OR_SELF>);

        $test->id ('replaceChild');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.replaceChild> ($el, $dtd-><AG::Node.firstChild>);
        }, exception_subtype => <Q::MDOMX|HIERARCHY_ANCESTOR_OR_SELF>);

    @@Test:
      @@@QName: Element.appendChild.ancestor.3.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestER:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createElement> ('dt');
        $dtd-><M::Node.appendChild>
                ($doc-><M::Document.createTextNode> ('text1'));
        my $el = $doc-><M::Document.createElement> ('el');
        $el-><M::Node.appendChild> ($dtd);
        my $el2 = $doc-><M::Document.createElement> ('el');
        $el2-><M::Node.appendChild> ($el);

        $test->id ('appendChild');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.appendChild> ($el2);
        }, exception_subtype => <Q::MDOMX|HIERARCHY_ANCESTOR_OR_SELF>);

        $test->id ('insertBefore');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.insertBefore> ($el2);
        }, exception_subtype => <Q::MDOMX|HIERARCHY_ANCESTOR_OR_SELF>);

        $test->id ('replaceChild');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.replaceChild> ($el2, $dtd-><AG::Node.firstChild>);
        }, exception_subtype => <Q::MDOMX|HIERARCHY_ANCESTOR_OR_SELF>);

  @CMethod:
    @@Name: manakaiAppendText
    @@Param:
      @@@Name: string
      @@@Type: DOMString
      @@@enDesc:
        The string to append.
      @@@InCase:
        @@@@Type: DISPerl|SCALAR||ManakaiDOM|all
        @@@@enDesc:
          A copy of the string value referenced from the value
          is appended.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node itself.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the node to insert the string or a <IF::Text> node
          is read-only.
      @@@disDef:
        @@@@DISPerl:cloneCode: ManakaiDOMAttr.manakaiAppendText

    @@Test:
      @@@QName: Element..=.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $node = $doc-><M::Document.createElement> ('node');

        $node-><M::Node.manakaiAppendText> ('string');
        $test->id ('1.class');
        $test->assert_isa ($node, <IFName::Element>);
        $test->id ('1.value');
        $test->assert_equals ($node-><AG::Node.textContent>, 'string');
        $test->id ('1.length');
        $test->assert_num_equals
                 (expected_value => 1,
                  actual_value => 0+@{$node-><AG::Node.childNodes>});

        $test->id (2);
        $node-><M::Node.manakaiAppendText> ('STRING');
        $test->assert_equals ($node-><AG::Node.textContent>, 'stringSTRING');
        $test->assert_num_equals
                 (expected_value => 1,
                  actual_value => 0+@{$node-><AG::Node.childNodes>});

        $node-><M::Node.appendChild>
                 ($doc-><M::Document.createEntityReference> ('er'));

        $test->id (3);
        $node-><M::Node.manakaiAppendText> ('text');
        $test->assert_equals ($node-><AG::Node.textContent>, 'stringSTRINGtext');
        $test->assert_num_equals
                 (expected_value => 3,
                  actual_value => 0+@{$node-><AG::Node.childNodes>});

  @CL3Method:
    @@Name: getFeature
    @@enDesc:
      Returns a specialized object that implements the specialized APIs.
    @@Param:
      @@@Name: feature
      @@@Type: DOMString
      @@@dis:actualType: f|FeatureNameString
    @@Param:
      @@@Name: version
      @@@Type: DOMString
      @@@dis:actualType: f|FeatureVersionString
    @@Return:
      @@@Type: DOMMain|DOMObject
      @@@nullCase:
      @@@PerlDef:
        $feature =~ s/^\+//;
        __CODE{f|getFeatureImpl::
          $self => $self,
          $feature => $feature, $version => $version, $r => $r,
          $base_class => {<ClassName::ManakaiDOMElement>},
        }__;
        unless (defined $r) {
          __DEEP{
            $r = $self->SUPER::get_feature ($feature, $version);
          }__;
        }

    @@Test:
      @@@QName: Element.getFeature.test
      @@@PerlDef:
        my $node;
        __CODE{tc|createElementForTest:: $el => $node}__;

        for (
          [Core => '1.0', <IFName::Element||ManakaiDOM|ManakaiDOM1>],
          [Core => '2.0', <IFName::Element||ManakaiDOM|ManakaiDOM2>],
          [Core => '3.0', <IFName::Element||ManakaiDOM|ManakaiDOM3>],
          [XML => '1.0', <IFName::Element||ManakaiDOM|ManakaiDOM1>],
          [XML => '2.0', <IFName::Element||ManakaiDOM|ManakaiDOM2>],
          [XML => '3.0', <IFName::Element||ManakaiDOM|ManakaiDOM3>],
        ) {
          $test->id ($_->[0].'.'.$_->[1]);
          my $sp = $node-><M::Node.getFeature> ($_->[0], $_->[1]);
          $test->assert_isa ($sp, $_->[2]);
        }

  @ResourceDef:
    @@ForCheck:
      ManakaiDOM:ManakaiDOM ManakaiDOM:ForClass
    @@DISCore:resourceType:
      @@@@:
        dis:MultipleResource
      @@@ForCheck: !tc|ForSelect !tc|ForRemove
    @@resourceFor: tc|ForSelect
    @@resourceFor: tc|ForRemove

    @@QName:
      @@@@: selectAttrNodeObject
      @@@ForCheck: tc|ForSelect
    @@NSVersion:
      @@@@: selectAttrNodeObjectNS
      @@@ForCheck: tc|ForSelect
      @@@ContentType: DISCore|TFQNames

    @@QName:
      @@@@: selectAttrNodeObjectForRemove
      @@@ForCheck: tc|ForRemove
    @@NSVersion:
      @@@@: selectAttrNodeObjectForRemoveNS
      @@@ForCheck: tc|ForRemove
      @@@ContentType: DISCore|TFQNames

    @@DISCore:resourceType: DISPerl|BlockCode

    @@enDesc:
      Selects an attribute node stem.

    @@Param:
      @@@Name:name
      @@@Type:
        @@@@@:
          DOMMain:ManakaiDOMXMLName
        @@@@ManakaiDOM:noInputNormalize:1
      @@@Description:
        @@@@lang:en
        @@@@@:
          The name of the attribute to select.
    @@Param:
      @@@Name: r
      @@@Out: 1
      @@@Type: NodeStem
      @@@Description:
        @@@@lang:en
        @@@@@:
          The <IF::NodeStem> object.  If there is no attribute
          node, then its value is left unchanged.
    @@PerlDef:
      my $__attr;
      __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
        $r => $__attr,
        $prop => {<H::infoset|attributes>},
        $ref => $self,
      }__;

      ## Note that we no longer support DOM Level 1 nodes.

      ## If an attribute's qualified name is equal to
      ## the requested name, then the node is the answer.

      ## Note that if there is a namespace ill-formed attribute,
      ## the result is not the expected one.  For example,
      ## if an |xmlns| attribute in the |http://www.w3.org/2000/xmlns/|
      ## namespace has non-NULL |prefix|, a request to get |xmlns|
      ## attribute will not return that node.

      ## |sort|ing is required so that every |getAttribute|, |setAttribute|,
      ## |hasAttribute|, |removeAttribute|, or any other namespace unaware
      ## methods operates on the same node even if there is 
      ## multiple nodes with the same qualified name.

      NS: for my $__ns (sort {$a cmp $b} keys %$__attr) {
        for my $__ln (sort {$a cmp $b} keys %{$__attr->{$__ns}}) {
          my $__node;
          __CODE{mg|createNodeRefFromID||ManakaiDOM|all::
            $bag => {<Code::mg|getNodeBag||ManakaiDOM|all:: $ref = $self>},
            $stemid => {$__attr->{$__ns}->{$__ln}},
            $ref => $__node,
            $opt => {{}},
          }__;
          if ($__node-><AG::Node.nodeName> eq $name) {
            __FOR{!tc:ForRemove::
              $r = $__node;
            }__;
            __FOR{tc:ForRemove::
              $r = $__node;
              $list = $__attr->{$__ns};
              $key = $__ln;
            }__;
            last NS;
          }
        } # ln
      } # NS

  @ResourceDef:
    @@ForCheck:
      ManakaiDOM:ManakaiDOM ManakaiDOM:ForClass
    @@rdf:type:
      @@@@:
        dis:MultipleResource
      @@@ForCheck: !tc|ForRemove !tc|ForSelect
    @@resourceFor: tc|ForSelect
    @@resourceFor: tc|ForRemove

    @@QName:
      @@@@: selectAttrNodeObjectNS
      @@@ForCheck: tc|ForSelect
    @@NoNSVersion:
      @@@@: selectAttrNodeObject
      @@@ForCheck: tc|ForSelect
      @@@ContentType: DISCore|TFQNames
    @@rdf:type:
      @@@@: DISPerl|BlockCode
      @@@ForCheck: tc|ForSelect
    
    @@QName:
      @@@@: selectAttrNodeObjectForRemoveNS
      @@@ForCheck: tc|ForRemove
    @@NoNSVersion:
      @@@@: selectAttrNodeObjectForRemove
      @@@ForCheck: tc|ForRemove
      @@@ContentType: DISCore|TFQNames
    @@rdf:type:
      @@@@: DISPerl|BlockCode
      @@@ForCheck: tc|ForRemove
    
     @@Description:
       @@@lang:en
       @@@@:
         Select a <Class::ManakaiDOMNodeObject> object that represents 
         an <IF::Attr> node, by namespace URI and local name.
     @@Param:
        @@@Name:  namespaceURI
        @@@Type:
          DOMMain:DOMString
        @@@actualType:
          ManakaiDOM:ManakaiDOMNamespaceURI
        @@@Description:
          @@@@lang:en
          @@@@@:
            The namespace URI of the attribute to select.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The attribute to select has no namespace.
     @@Param:
        @@@Name:  localName
        @@@Type:  
          @@@@@:
            DOMMain:ManakaiDOMXMLLocalName
          @@@@ManakaiDOM:noInputNormalize:1
        @@@Description:
          @@@@lang:en
          @@@@@: The local name of the attribute to select.
     @@Return:
        @@@Type: NodeStem
        @@@Description:
          @@@@lang:en
          @@@@@:
            The <Class::ManakaiDOM:ManakaiDOMNodeObject> object being selected.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: There is no such attribute.
    @@PerlDef:
      @@@ForCheck: !tc|ForRemove
      @@@@:
        my $__attrs;
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $__attrs,
          $prop => {<H::infoset|attributes>},
          $ref => $self,
        }__;
        if (defined $__attrs->{defined $namespaceURI ? $namespaceURI : ''}
                            ->{$localName}) {
          __CODE{mg|createNodeRefFromID||ManakaiDOM|all::
            $bag => {<Code::mg|getNodeBag||ManakaiDOM|all:: $ref = $self>},
            $stemid => {$__attrs->{defined $namespaceURI ? $namespaceURI : ''}
                                ->{$localName}},
            $ref => $r,
            $opt => {{}},
          }__;
        }
    @@PerlDef:
      @@@ForCheck: tc|ForRemove
      @@@@:
        my $__attrs;
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $__attrs,
          $prop => {<H::infoset|attributes>},
          $ref => $self,
        }__;
        $list = $__attrs->{defined $namespaceURI ? $namespaceURI : ''};
        if (defined $list) {
          __CODE{mg|createNodeRefFromID||ManakaiDOM|all::
            $bag => {<Code::mg|getNodeBag||ManakaiDOM|all:: $ref = $self>},
            $stemid => {$__attrs->{defined $namespaceURI ? $namespaceURI : ''}
                                ->{$localName}},
            $ref => $r,
            $opt => {{}},
          }__;
        }

  @Method:
    @@Name: getAttribute
    @@enDesc:
      Retrueves an attribute value by name.
    @@NSVersion:.getAttribute
    @@Param:
      @@@Name: name
      @@@Type: DOMString
      @@@dis:actualType:
        @@@@@: DOMMain|ManakaiDOMXMLName
        @@@@ManakaiDOM:noInputNormalize: 1
      @@@enDesc:
        The name of the attribute to retrieve.
    @@Return:
      @@@Type: DOMString
      @@@enDesc:
        The value of the <IF::Attr> as a string.
      @@@InCase:
        @@@@Value:
          @@@@@@: \
          @@@@@ContentType: DISCore|String
        @@@@enDesc:
          If the attribute does not have a specified or default value.
          <SRC::DOM1, DOM2, DOM3>
      @@@nullCase:
        @@@@enDesc:
          If the attribute does not have a specified or default value.
          <SRC::manakai>
      @@@PerlDef:
        my $node;
        __CODE{selectAttrNodeObject::
          $name => $name,
          $self => $self,
          $r => $node,
        }__;
        if (defined $node) {
          $r = $node-><AG::Attr.value>;
        } else {
          $r = null;
        }

    @@Test:
      @@@QName: Element.getAttribute.1.test
      @@@enDesc:
        No NS attribute.
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        my $doc = $el-><AG::Node.ownerDocument>;

        $test->id ('initial');
        $test->assert_null ($el-><M::Element.getAttribute> ('a1'));

        $test->id ('specified'); 
        my $attr = $doc-><M::Document.createAttribute> ("a1");
        $attr-><AS::Attr.value> ('value1');

        $el-><M::Element.setAttributeNode> ($attr);

        my $return = $el-><M::Element.getAttribute> ("a1");
        $test->assert_equals ($return, "value1");

        $test->id ('not.specified');
        $attr-><AS::Attr.specified> (false);
        my $return2 = $el-><M::Element.getAttribute> ('a1');
        $test->assert_equals ($return2, 'value1');
    @@Test:
      @@@QName: Element.getAttribute.2.test
      @@@enDesc:
        NS = <DOM::null> attribute.
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        my $doc = $el-><AG::Node.ownerDocument>;

        $test->id ('initial');
        $test->assert_null ($el-><M::Element.getAttribute> ('a1'));

        $test->id ('specified'); 
        my $attr = $doc-><M::Document.createAttributeNS> (null, "a1");
        $attr-><AS::Attr.value> ('value1');

        $el-><M::Element.setAttributeNodeNS> ($attr);

        my $return = $el-><M::Element.getAttribute> ("a1");
        $test->assert_equals ($return, "value1");

        $test->id ('not.specified');
        $attr-><AS::Attr.specified> (false);
        my $return2 = $el-><M::Element.getAttribute> ('a1');
        $test->assert_equals ($return2, 'value1');
    @@Test:
      @@@QName: Element.getAttribute.3.test
      @@@enDesc:
        NS attribute.
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        my $doc = $el-><AG::Node.ownerDocument>;

        $test->id ('initial');
        $test->assert_null ($el-><M::Element.getAttribute> ('ns:a1'));

        $test->id ('specified'); 
        my $attr = $doc-><M::Document.createAttributeNS>
                           ('http://ns.test/', "ns:a1");
        $attr-><AS::Attr.value> ('value1');

        $el-><M::Element.setAttributeNode> ($attr);

        my $return = $el-><M::Element.getAttribute> ("ns:a1");
        $test->assert_equals ($return, "value1");

        $test->id ('not.specified');
        $attr-><AS::Attr.specified> (false);
        my $return2 = $el-><M::Element.getAttribute> ('ns:a1');
        $test->assert_equals ($return2, 'value1');
    @@Test:
      @@@QName: Element.getAttribute.4.test
      @@@enDesc:
        <XA::xmlns> attribute.
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        my $doc = $el-><AG::Node.ownerDocument>;

        $test->id ('initial');
        $test->assert_null ($el-><M::Element.getAttribute> ('xmlns'));

        $test->id ('specified'); 
        my $attr = $doc-><M::Document.createAttributeNS>
                           (<Q::xmlns:>, 'xmlns');
        $attr-><AS::Attr.value> ('value1');

        $el-><M::Element.setAttributeNode> ($attr);

        my $return = $el-><M::Element.getAttribute> ('xmlns');
        $test->assert_equals ($return, "value1");

        $test->id ('not.specified');
        $attr-><AS::Attr.specified> (false);
        my $return2 = $el-><M::Element.getAttribute> ('xmlns');
        $test->assert_equals ($return2, 'value1');

  @L2Method:
    @@Name: getAttributeNS
    @@enDesc:
      Retrieves an attribute value by local name and namespace URI.
    @@NoNSVersion:.getAttribute
    @@XML2Feature:
    @@Param:
      @@@Name: namespaceURI
      @@@Type: DOMString
      @@@dis:actualType: ManakaiDOM|ManakaiDOMNamespaceURI
      @@@enDesc:
        The namespace URI of the attribute to retrieve.
      @@@nullCase:
        @@@@enDesc:
          If the attribute has no namespace.
    @@Param:
      @@@Name: localName
      @@@Type: DOMString
      @@@dis:actualType:
        @@@@@: DOMMain|ManakaiDOMXMLLocalName
        @@@@ManakaiDOM:noInputNormalize: 1
      @@@enDesc:
        The local name of the attribute to retrieve.
    @@Return:
      @@@Type: DOMString
      @@@enDesc:
        The value of the <IF::Attr> as a string.
      @@@InCase:
        @@@@Value:
          @@@@@@: \
          @@@@@ContentType: DISCore|String
        @@@@enDesc:
          If the attribute does not have a specified or default value.
          <SRC::DOM2, DOM3>
      @@@nullCase:
        @@@@enDesc:
          If the attribute does not have a specified or default value.
          <SRC::manakai>
      @@@iRaises:
        @@@@@: MDOMX|MDOM_IMPL_NOSUPPORT_XML
        @@@@enDesc:
          If the implementation does not support the feature 
          <Feature::XML> and the language exposed through the <IF::Document>
          does not support XML namespaces.
      @@@PerlDef:
        my $node;
        __CODE{selectAttrNodeObjectNS::
          $self => $self,
          $namespaceURI => $namespaceURI, $localName => $localName,
          $r => $node,
        }__;
        if (defined $node) {
          $r = $node-><AG::Attr.value>;
        } else {
          $r = null;
        }

    @@Test:
      @@@QName: Element.getAttributeNS.1.test
      @@@enDesc:
        NS = <DOM::null> attribute.
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        my $doc = $el-><AG::Node.ownerDocument>;

        $test->id ('initial');
        $test->assert_null ($el-><M::Element.getAttributeNS> (null, 'a1'));

        $test->id ('specified');
        my $attr = $doc-><M::Document.createAttributeNS> (null, 'a1');
        $attr-><AS::Attr.value> ('value1');
        $el-><M::Element.setAttributeNodeNS> ($attr);
        my $return1 = $el-><M::Element.getAttributeNS> (null, 'a1');
        $test->assert_equals ($return1, 'value1');

        $test->id ('not.specified');
        $attr-><AS::Attr.specified> (false);
        my $return2 = $el-><M::Element.getAttributeNS> (null, 'a1');
        $test->assert_equals ($return2, 'value1');
    @@Test:
      @@@QName: Element.getAttributeNS.2.test
      @@@enDesc:
        Non NS attribute.
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        my $doc = $el-><AG::Node.ownerDocument>;

        $test->id ('initial');
        $test->assert_null ($el-><M::Element.getAttributeNS> (null, 'a1'));

        $test->id ('specified');
        my $attr = $doc-><M::Document.createAttribute> ('a1');
        $attr-><AS::Attr.value> ('value1');
        $el-><M::Element.setAttributeNode> ($attr);
        my $return1 = $el-><M::Element.getAttributeNS> (null, 'a1');
        $test->assert_equals ($return1, 'value1');

        $test->id ('not.specified');
        $attr-><AS::Attr.specified> (false);
        my $return2 = $el-><M::Element.getAttributeNS> (null, 'a1');
        $test->assert_equals ($return2, 'value1');
    @@Test:
      @@@QName: Element.getAttributeNS.3.test
      @@@enDesc:
        NS attribute.
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        my $doc = $el-><AG::Node.ownerDocument>;
        my $ns = 'http://ns.test/';

        $test->id ('initial');
        $test->assert_null ($el-><M::Element.getAttributeNS> ($ns, 'a1'));

        $test->id ('specified');
        my $attr = $doc-><M::Document.createAttributeNS> ($ns, 'p:a1');
        $attr-><AS::Attr.value> ('value1');
        $el-><M::Element.setAttributeNodeNS> ($attr);
        my $return1 = $el-><M::Element.getAttributeNS> ($ns, 'a1');
        $test->assert_equals ($return1, 'value1');

        $test->id ('not.specified');
        $attr-><AS::Attr.specified> (false);
        my $return2 = $el-><M::Element.getAttributeNS> ($ns, 'a1');
        $test->assert_equals ($return2, 'value1');

        $test->id ('prefixed');
        $test->assert_null ($el-><M::Element.getAttributeNS> ($ns, 'p:a1'));

  @Method:
    @@Name: getAttributeNode
    @@enDesc:
      Retrieves an attribute node by name.
    @@NSVersion:.getAttributeNodeNS
    @@Param:
      @@@Name: name
      @@@Type: DOMString
      @@@dis:actualType:
        @@@@@: DOMMain|ManakaiDOMXMLName
        @@@@ManakaiDOM:noInputNormalize: 1
      @@@enDesc:
        The name (<A::Node.nodeName>) of the attribute to retrieve.
    @@Return:
      @@@Type: Attr
      @@@enDesc:
        The <IF::Attr> node with the specified <P::name>.
      @@@nullCase:
        @@@@enDesc:
          If there is no such attribute.
      @@@PerlDef:
        __CODE{selectAttrNodeObject::
          $name => $name,
          $self => $self,
          $r => $r,
        }__;

    @@Test:
      @@@QName: Element.getAttributeNode.1.test
      @@@enDesc:
        No NS attribute.
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        my $doc = $el-><AG::Node.ownerDocument>;

        $test->id ('initial');
        my $return1 = $el-><M::Element.getAttributeNode> ('a1');
        $test->assert_null ($return1);

        $test->id ('value');
        my $attr = $doc-><M::Document.createAttribute> ('a1');
        $el-><M::Element.setAttributeNode> ($attr);
        my $return2 = $el-><M::Element.getAttributeNode> ('a1');
        $test->assert_equals ($return2, $attr);
    @@Test:
      @@@QName: Element.getAttributeNode.2.test
      @@@enDesc:
        NS = <DOM::null> attribute.
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        my $doc = $el-><AG::Node.ownerDocument>;

        $test->id ('initial');
        my $return1 = $el-><M::Element.getAttributeNode> ('a1');
        $test->assert_null ($return1);

        $test->id ('value');
        my $attr = $doc-><M::Document.createAttributeNS> (null, 'a1');
        $el-><M::Element.setAttributeNode> ($attr);
        my $return2 = $el-><M::Element.getAttributeNode> ('a1');
        $test->assert_equals ($return2, $attr);
    @@Test:
      @@@QName: Element.getAttributeNode.3.test
      @@@enDesc:
        NS attribute.
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        my $doc = $el-><AG::Node.ownerDocument>;
        my $ns = 'http://ns.test/';

        $test->id ('initial');
        my $return1 = $el-><M::Element.getAttributeNode> ('p:a1');
        $test->assert_null ($return1);

        $test->id ('value');
        my $attr = $doc-><M::Document.createAttributeNS> ($ns, 'p:a1');
        $el-><M::Element.setAttributeNodeNS> ($attr);
        my $return2 = $el-><M::Element.getAttributeNode> ('p:a1');
        $test->assert_equals ($return2, $attr);

        $test->id ('prefix.changed');
        $attr-><AS::Node.prefix> ('q');
        my $return3 = $el-><M::Element.getAttributeNode> ('p:a1');
        $test->assert_null ($return3);

  @L2Method:
    @@Name: getAttributeNodeNS
    @@enDesc:
      Retrieves an <IF::Attr> node by namespace URI and local name.
    @@NoNSVersion:.getAttributeNode
    @@Param:
      @@@Name: namespaceURI
      @@@Type: DOMString
      @@@dis:actualType: ManakaiDOM|ManakaiDOMNamespaceURI
      @@@enDesc:
        The namespace URI of the attribute to retrieve.
      @@@nullCase:
        @@@@enDesc:
          If the attribute has no namespace.
    @@Param:
      @@@Name: localName
      @@@Type: DOMString
      @@@enDesc:
        The local name of the attribute to retrieve.
    @@Return:
      @@@Type: Attr
      @@@enDesc: 
        The <IF::Attr> node with the specified namespace URI
        and local name.
      @@@nullCase:
        @@@@enDesc:
          If there is no such attribute.
      @@@iRaises:
        @@@@@: MDOMX|MDOM_IMPL_NOSUPPORT_XML
        @@@@enDesc:
          If the implementation does not support the feature
          <Feature::XML> and the language exposed through the <IF::Document>
          does not support XML namespaces.
      @@@PerlDef:
        __CODE{selectAttrNodeObjectNS::
          $self => $self,
          $namespaceURI => $namespaceURI, $localName => $localName,
          $r => $r,
        }__;

    @@Test:
      @@@QName: Element.getAttributeNodeNS.1.test
      @@@enDesc:
        No NS attribute.
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        my $doc = $el-><AG::Node.ownerDocument>;

        $test->id ('initial');
        my $return1 = $el-><M::Element.getAttributeNodeNS> (null, 'a1');
        $test->assert_null ($return1);

        $test->id ('value');
        my $attr = $doc-><M::Document.createAttribute> ('a1');
        $el-><M::Element.setAttributeNode> ($attr);
        my $return2 = $el-><M::Element.getAttributeNodeNS> (null, 'a1');
        $test->assert_equals ($return2, $attr);
    @@Test:
      @@@QName: Element.getAttributeNodeNS.2.test
      @@@enDesc:
        NS = <DOM::null> attribute.
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        my $doc = $el-><AG::Node.ownerDocument>;

        $test->id ('initial');
        my $return1 = $el-><M::Element.getAttributeNodeNS> (null, 'a1');
        $test->assert_null ($return1);

        $test->id ('value');
        my $attr = $doc-><M::Document.createAttributeNS> (null, 'a1');
        $el-><M::Element.setAttributeNodeNS> ($attr);
        my $return2 = $el-><M::Element.getAttributeNodeNS> (null, 'a1');
        $test->assert_equals ($return2, $attr);
    @@Test:
      @@@QName: Element.getAttributeNodeNS.3.test
      @@@enDesc:
        NS attribute.
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        my $doc = $el-><AG::Node.ownerDocument>;
        my $ns = 'http://ns.test/';

        $test->id ('initial');
        my $return1 = $el-><M::Element.getAttributeNodeNS> ($ns, 'a1');
        $test->assert_null ($return1);

        $test->id ('value');
        my $attr = $doc-><M::Document.createAttributeNS> ($ns, 'p:a1');
        $el-><M::Element.setAttributeNodeNS> ($attr);
        my $return2 = $el-><M::Element.getAttributeNodeNS> ($ns, 'a1');
        $test->assert_equals ($return2, $attr);

        $test->id ('prefix.changed');
        $attr-><AS::Node.prefix> ('q');
        my $return3 = $el-><M::Element.getAttributeNodeNS> ($ns, 'a1');
        $test->assert_equals ($return3, $attr);

        $test->id ('prefixed');
        my $return4 = $el-><M::Element.getAttributeNodeNS> ($ns, 'q:a1');
        $test->assert_null ($return4);
  
  @L2Method:
    @@Name: hasAttribute
    @@enDesc:
      Returns whether an attribute with a given name is specified
      on the element or has a default value or not.
    @@NSVersion:.hasAttributeNS
    @@Param:
      @@@Name: name
      @@@Type: DOMString
      @@@dis:actualType:
        @@@@@: DOMMain|ManakaiDOMXMLName
        @@@@ManakaiDOM:noInputNormalize: 1
      @@@enDesc:
        The name of the attribute to look for.
    @@Return:
      @@@Type: boolean
      @@@TrueCase:
        @@@@enDesc:
          If an attribute with the given name is specified
          on the element or has a default value.
      @@@FalseCase:
        @@@@enDesc:
          Otherwise.
      @@@PerlDef:
        my $node;
        __CODE{selectAttrNodeObject::
          $name => $name,
          $self => $self,
          $r => $node,
        }__;
        $r = defined $node;

    @@Test:
      @@@QName: Element.hasAttribute.1.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        my $doc = $el-><AG::Node.ownerDocument>;

        $test->id ('initial');
        $test->assert_false ($el-><M::Element.hasAttribute> ('a1'));

        $test->id ('specified');
        my $attr = $doc-><M::Document.createAttribute> ('a1');
        $el-><M::Element.setAttributeNode> ($attr);
        $test->assert_true ($el-><M::Element.hasAttribute> ('a1'));

        $test->id ('not.specified');
        $attr-><AS::Attr.specified> (false);
        $test->assert_true ($el-><M::Element.hasAttribute> ('a1'));
    @@Test:
      @@@QName: Element.hasAttribute.2.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        my $doc = $el-><AG::Node.ownerDocument>;

        $test->id ('initial');
        $test->assert_false ($el-><M::Element.hasAttribute> ('a1'));

        $test->id ('specified');
        my $attr = $doc-><M::Document.createAttributeNS> (null, 'a1');
        $el-><M::Element.setAttributeNode> ($attr);
        $test->assert_true ($el-><M::Element.hasAttribute> ('a1'));

        $test->id ('not.specified');
        $attr-><AS::Attr.specified> (false);
        $test->assert_true ($el-><M::Element.hasAttribute> ('a1'));

        $test->id ('prefixed');
        $el-><M::Element.removeAttributeNode> ($attr);
        $el-><M::Element.setAttributeNS> ('about:', 'p:a1', 'v2');
        $test->assert_false ($el-><M::Element.hasAttribute> ('a1'));
    @@Test:
      @@@QName: Element.hasAttribute.3.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        my $doc = $el-><AG::Node.ownerDocument>;

        $test->id ('initial');
        $test->assert_false ($el-><M::Element.hasAttribute> ('m:a1'));

        $test->id ('specified');
        my $attr = $doc-><M::Document.createAttributeNS> ('mocha:', 'm:a1');
        $el-><M::Element.setAttributeNode> ($attr);
        $test->assert_true ($el-><M::Element.hasAttribute> ('m:a1'));

        $test->id ('not.specified');
        $attr-><AS::Attr.specified> (false);
        $test->assert_true ($el-><M::Element.hasAttribute> ('m:a1'));

  @L2Method:
    @@Name: hasAttributeNS
    @@enDesc:
      Returns whether an attribute with a given namespace URI
      and local name is specified on the element or has a default
      value or not.
    @@NoNSVersion:.hasAttribute
    @@XML2Feature:
    @@Param:
      @@@Name: namespaceURI
      @@@Type: DOMString
      @@@dis:actualType: ManakaiDOM|ManakaiDOMNamespaceURI
      @@@enDesc:
        The namespace URI of the attribute to look for.
      @@@nullCase:
        @@@@enDesc:
          The attribute has no namespace.
    @@Param:
      @@@Name: localName
      @@@Type: DOMString
      @@@dis:actualType:
        @@@@@: DOMMain|ManakaiDOMXMLLocalName
        @@@@ManakaiDOM:noInputNormalize: 1
      @@@enDesc:
        The local name of the attribute to look for.
    @@Return:
      @@@Type: boolean
      @@@TrueCase:
        @@@@enDesc:
          If an attribute with the given namespace URI and
          local name is specified on the element or has a default value.
      @@@FalseCase:
        @@@@enDesc:
          Otherwise.
      @@@iRaises:
        @@@@@: MDOMX|MDOM_IMPL_NOSUPPORT_XML
        @@@@enDesc:
          If the implementation does not support the feature
          <Feature::XML> and the language exposed through the <IF::Document>
          does not support XML namespaces.
      @@@PerlDef:
        my $node;
        __CODE{selectAttrNodeObjectNS::
          $self => $self,
          $namespaceURI => $namespaceURI, $localName => $localName,
          $r => $node,
        }__;
        $r = defined $node;

    @@Test:
      @@@QName: Element.hasAttributeNS.1.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        my $doc = $el-><AG::Node.ownerDocument>;
        
        $test->id ('initial');
        $test->assert_false ($el-><M::Element.hasAttributeNS> (null, 'a1'));

        $test->id ('2');
        my $attr = $doc-><M::Document.createAttribute> ('a1');
        $el-><M::Element.setAttributeNode> ($attr);
        $test->assert_true ($el-><M::Element.hasAttributeNS> (null, 'a1'));
    @@Test:
      @@@QName: Element.hasAttributeNS.2.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        my $doc = $el-><AG::Node.ownerDocument>;
        
        $test->id ('initial');
        $test->assert_false ($el-><M::Element.hasAttributeNS> (null, 'a1'));

        $test->id ('1');
        my $attr2 = $doc-><M::Document.createAttributeNS> ('about:', 'a:a1');
        $el-><M::Element.setAttributeNodeNS> ($attr2);
        $test->assert_false ($el-><M::Element.hasAttributeNS> (null, 'a1'));

        $test->id ('2');
        my $attr = $doc-><M::Document.createAttributeNS> (null, 'a1');
        $el-><M::Element.setAttributeNode> ($attr);
        $test->assert_true ($el-><M::Element.hasAttributeNS> (null, 'a1'));
    @@Test:
      @@@QName: Element.hasAttributeNS.3.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        my $doc = $el-><AG::Node.ownerDocument>;
        my $ns = 'about:';
        
        $test->id ('initial');
        $test->assert_false ($el-><M::Element.hasAttributeNS> ($ns, 'a1'));

        $test->id ('1');
        my $attr = $doc-><M::Document.createAttributeNS> (null, 'a1');
        $el-><M::Element.setAttributeNode> ($attr);
        $test->assert_false ($el-><M::Element.hasAttributeNS> (null, 'a1'));

        $test->id ('2');
        my $attr2 = $doc-><M::Document.createAttributeNS> ($ns, 'a:a1');
        $el-><M::Element.setAttributeNodeNS> ($attr2);
        $test->assert_true ($el-><M::Element.hasAttributeNS> ($ns, 'a1'));

  @Method:
    @@Name: setAttribute
    @@enDesc:
      Adds a new attribute.  If an attribute with that name is
      already present in the element, its value is changed to be
      that of the <P::value> parameter.
    @@NSVersion:.setAttributeNS
    @@Param:
      @@@Name: name
      @@@Type: DOMString
      @@@dis:actualType:
        @@@@@: DOMMain|ManakaiDOMXMLName
        @@@@ManakaiDOM:noInputNormalize: 1
      @@@enDesc:
        The name of the attribute to create or alter.
    @@Param:
      @@@Name: value
      @@@enDesc:
        The value to set in string form.
  
        This value is a simple string; it is not parsed to scan
        e.g. entity references as it is being set.
    @@Return:
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_BAD_NAME
        @@@@enDesc:
          If the specified <P::name> is not an XML <CODE::Name>
          according to the XML version in use specified in
          the <A::Document.xmlVersion> attribute.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the element node is read-only.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_ATTR
        @@@@enDesc:
          If there is the attribute whose <A::Attr.name> is equal
          to the <P::name> and that attribute node is read-only.
          <SRC::manakai>
      @@@PerlDef:
        my $od = $self-><AG::Node.ownerDocument>;
        if ($od-><AG::Document.strictErrorChecking>) {
          if ($self-><AG::Node.manakaiReadOnly>) {
            __EXCEPTION{MDOMX|NOMOD_THIS::
            }__;
          }
          my $version = $od-><AG::Document.xmlVersion>;
          __CODE{DOMMain|ensureXMLName::
            $INPUT => $name,
            $INPUT_PARAM_NAME => 'name',
            $XMLVERSION => $version,
          }__;
        }

        my $__node;
        __CODE{selectAttrNodeObject::
          $name => $name,
          $self => $self,
          $r => $__node,
        }__;
        if (defined $__node) { ## There is already a node with such a |name|
          if ($__node-><AG::Node.manakaiReadOnly>) {
            __EXCEPTION{MDOMX|NOMOD_ATTR::
              MDOMX|param-name => 'name',
              c|node => {$__node},
            }__;
          }
        } else { ## There is no such attribute
          __DEEP{
            $__node = $od-><M::Document.createAttribute> ($name);
            my $__attrs;
            __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
              $r => $__attrs,
              $prop => {<H::infoset|attributes>},
              $ref => $self,
            }__;
            $__attrs->{''}->{$name}
                = <Code::mg|getNodeID||ManakaiDOM|all:: $ref = $__node>;
            __CODE{mg|setNodeStemProp0Node||ManakaiDOM|all::
              $prop => {<H::infoset|ownerElement>},
              $ref => $__node,
              $given => $self,
            }__;
          }__;
          ## TODO: Schema
        }
        __DEEP{
          $__node-><AS::Attr.value> ($value);
          $__node-><AS::Attr.specified> (true);
        }__;

    @@Test:
      @@@QName: Element.setAttribute.1.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        $el-><M::Element.setAttribute> ('a1', 'v1');

        my $a1 = $el-><M::Element.getAttributeNode> ('a1');
        $test->id ('new.node.isa');
        $test->assert_isa ($a1, <IFName::Attr>);
        $test->id ('new.node.namespaceURI');
        $test->assert_null ($a1-><AG::Node.namespaceURI>);
        $test->id ('new.node.localName');
        $test->assert_equals ($a1-><AG::Node.localName>, 'a1');
        $test->id ('new.node.value');
        $test->assert_equals ($a1-><AG::Attr.value>, 'v1');
        $test->id ('new.node.specified');
        $test->assert_true ($a1-><AG::Attr.specified>);
        $test->id ('new.node.ownerElement');
        $test->assert_equals ($a1-><AG::Attr.ownerElement>, $el);

        $el-><M::Element.setAttribute> ('a1', 'v2');
        $test->id ('changed.equals');
        my $a2 = $el-><M::Element.getAttributeNode> ('a2');
        $test->assert_equals ($a2, $a1);
        $test->id ('changed.value');
        $test->assert_equals ($a2-><AG::Attr.value>, 'v2');
        $test->id ('changed.node.specified');
        $test->assert_true ($a2-><AG::Attr.specified>);

        $a2-><AS::Attr.specified> (false);

        $test->id ('specified.changed');
        $el-><M::Element.setAttribute> ('a1', 'v2');
        $test->assert_true ($a2-><AG::Attr.specified>);
    @@Test:
      @@@QName: Element.setAttribute.2.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        $el-><M::Element.setAttributeNS> (<Q::xml:>, 'xml:lang', 'ja');

        $el-><M::Element.setAttribute> ('xml:lang', 'en');
        $test->assert_equals
                 ($el-><M::Element.getAttributeNS> (<Q::xml:>, 'lang'), 'en');

    @@L3Test:
      @@@QName: Element.setAttribute.xmlid.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        my $cfg = $el-><AG::Node.ownerDocument>-><AG::Document.domConfig>;

        $cfg-><M::c|DOMConfiguration.setParameter> (<Q::cfg|xml-id> => true);

        $test->id ('id.xmlid');
        $el-><M::Element.setAttribute> ('xml:id' => 'value');
        my $sti = $el-><M::Element.getAttributeNode> ('xml:id')
                     -><AG::Attr.schemaTypeInfo>;
        $test->assert_equals ($sti-><AG::c|TypeInfo.typeName>, 'ID');
        $test->assert_equals
                 ($sti-><AG::c|TypeInfo.typeNamespace>, <Q::xml-dtd:>);

        $test->id ('id.other');
        $el-><M::Element.setAttribute> ('id' => 'value');
        my $sti2 = $el-><M::Element.getAttributeNode> ('id')
                      -><AG::Attr.schemaTypeInfo>;
        $test->assert_null ($sti2-><AG::c|TypeInfo.typeName>);
        $test->assert_null ($sti2-><AG::c|TypeInfo.typeNamespace>);

        my $el2 = $el-><AG::Node.ownerDocument>
                     -><M::Document.createElement> ('e');
        $cfg-><M::c|DOMConfiguration.setParameter> (<Q::cfg|xml-id> => false);

        $test->id ('noid.xmlid');
        $el2-><M::Element.setAttribute> ('xml:id' => 'value');
        my $sti3 = $el2-><M::Element.getAttributeNode> ('xml:id')
                       -><AG::Attr.schemaTypeInfo>;
        $test->assert_null ($sti3-><AG::c|TypeInfo.typeName>);
        $test->assert_null ($sti3-><AG::c|TypeInfo.typeNamespace>);

        $test->id ('noid.other');
        $el2-><M::Element.setAttribute> ('id' => 'value');
        my $sti4 = $el2-><M::Element.getAttributeNode> ('id')
                       -><AG::Attr.schemaTypeInfo>;
        $test->assert_null ($sti4-><AG::c|TypeInfo.typeName>);
        $test->assert_null ($sti4-><AG::c|TypeInfo.typeNamespace>);

  @L2Method:
    @@Name: setAttributeNS
    @@enDesc:
      Adds a new attribute.  If an attribute with the same namespace
      URI and local name is already present on the element, its
      prefix is changed to be the prefix part of the <P::qualifiedName>
      parameter and its value is changed to be the <P::value>
      parameter.
    @@NoNSVersion:.setAttribute
    @@XML2Feature:
    @@Param:
      @@@Name: namespaceURI
      @@@Type: DOMString
      @@@dis:actualType: ManakaiDOM|ManakaiDOMNamespaceURI
      @@@enDesc:
        The namespace URI of the attribute to create or alter.
      @@@nullCase:
        @@@@enDesc:
          If the attribute has no namespace.
    @@Param:
      @@@Name: qualifiedName
      @@@Type: DOMString
      @@@enDesc:
        The qualified name of the attribute to create or alter.
      @@@InCase:
        @@@@Type: ARRAY
        @@@@enDesc:
          A reference to the array that contains the namespace
          prefix (zeroth item) and the local name (first item)
          of the attribute.  The namespace prefix <kwd:MAY>
          be <DOM::null> to indicate that the qualified name
          contains no <CHAR::COLON> character.
    @@Param:
      @@@Name: value
      @@@Type: DOMString
      @@@enDesc:
        The value to set in string form.

        This value is a simple string; it is not parsed to scan
        e.g. entity references as it is being set.
    @@Return:
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_BAD_NAME
        @@@@enDesc:
          If the specified qualified name is not an <CODE::XML>
          name according to the XML version in use specified
          in the <A::Document.xmlVersion> attribute.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the element node is read-only.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_ATTR
        @@@@enDesc:
          If there is the attribute specified by namespace URI and
          local name and that attribute node is read-only.
          <SRC::manakai>
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_NS_MALFORMED_QNAME
        @@@@enDesc:
           If the <P::qualifiedName> is malformed per the XML
           Namespaces specification.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_NS_PREFIX_WITH_NULL_URI
        @@@@enDesc:
          If the <P::qualifiedName> has a prefix and the 
          <P::namespaceURI> is <DOM::null>.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_NS_XML_WITH_OTHER_URI
        @@@@enDesc:
          If the <P::qualifiedName> has a prefix that is <XML::xml>
          and the <P::namespaceURI> is different from
          <URI::http://www.w3.org/XML/1998/namespace>.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_NS_XMLNS_WITH_OTHER_URI
        @@@@enDesc:
          If the <P::qualifiedName> has a prefix that is <XML::xmlns>
          and the <P::namespaceURI> is different from
          <URI::http://www.w3.org/2000/xmlns/>.  <SRC::DOM3>
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_NS_XMLNSQ_WITH_OTHER_URI
        @@@@enDesc:
          If the <P::qualifiedName> is <XA::xmlns> and the
          <P::namespaceURI> is different from
          <URI::http://www.w3.org/2000/xmlns/>.  <SRC::DOM2, DOM3>
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_NS_OTHER_WITH_XMLNS_URI
        @@@@enDesc:
          If the <P::namespaceURI> is <URI::http://www.w3.org/2000/xmlns/>
          and neither the <P::qualifiedName> nor its prefix
          is <XML::xmlns>.  <SRC::DOM3>
      @@@iRaises:
        @@@@@: MDOMX|MDOM_IMPL_NOSUPPORT_XML
        @@@@enDesc:
          If the implementation does not support the feature
          <Feature::XML> and the language exposed through the <IF::Document>
          does not support XML namespaces.
      @@@PerlDef:
        my ($prefix, $localName) = ref $qualifiedName eq 'ARRAY'
                                     ? @$qualifiedName
                                     : split /:/, $qualifiedName, 2;
        ($prefix, $localName) = (null, $prefix) unless defined $localName;

        my $od = $self-><AG::Node.ownerDocument>;
        if ($od-><AG::Document.strictErrorChecking>) {
          if ($self-><AG::Node.manakaiReadOnly>) {
            __EXCEPTION{MDOMX|NOMOD_THIS::
            }__;
          }
          my $version = $od-><AG::Document.xmlVersion>;
          $qualifiedName = defined $prefix ? $prefix.':'.$localName
                                           : $localName;
          __CODE{DOMMain|ensureXMLQName::
            $INPUT = $qualifiedName, 
            $INPUT_PARAM_NAME = 'qualifiedName',
            $XMLVERSION = $version,
          }__;
          __CODE{DOMMain|checkXMLNamesQName::
            $PREFIX => $prefix, $NSURI => $namespaceURI,
            $LNAME => $localName,
          }__;
        }
        __CODE{tc|setAttrValueNS::
          $namespaceURI => $namespaceURI,
          $prefix => $prefix,
          $localName => $localName,
          $qualifiedName => $qualifiedName,
          $element => $self,
          $value => $value,
          $ownerDocument => $od,
        }__;

    @@Test:
      @@@QName: Element.setAttributeNS.1.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        $el-><M::Element.setAttributeNS> (null, 'a1', 'v1');
        my $a1 = $el-><M::Element.getAttributeNodeNS> (null, 'a1');
        $test->id ('new.node');
        $test->assert_isa ($a1, <IFName::Attr>);
        $test->id ('new.namespaceURI');
        $test->assert_null ($a1-><AG::Node.namespaceURI>);
        $test->id ('new.localName');
        $test->assert_equals ($a1-><AG::Node.localName>, 'a1');
        $test->id ('new.prefix');
        $test->assert_null ($a1-><AG::Node.prefix>);
        $test->id ('new.value');
        $test->assert_equals ($a1-><AG::Attr.value>, 'v1');
        $test->id ('new.specified');
        $test->assert_true ($a1-><AG::Attr.specified>);
        $test->id ('new.ownerElement');
        $test->assert_equals ($a1-><AG::Attr.ownerElement>, $el);

        $el-><M::Element.setAttributeNS> (null, 'a1', 'v2');
        $test->id ('changed.node');
        my $a2 = $el-><M::Element.getAttributeNodeNS> (null, 'a1');
        $test->assert_equals ($a2, $a1);
        $test->id ('changed.value');
        $test->assert_equals ($a2-><AG::Attr.value>, 'v2');
    @@Test:
      @@@QName: Element.setAttributeNS.2.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        my $ns = 'about:';

        $el-><M::Element.setAttributeNS> ($ns, 'p:a1', 'v1');
        my $a1 = $el-><M::Element.getAttributeNodeNS> ($ns, 'a1');
        $test->id ('new.node');
        $test->assert_isa ($a1, <IFName::Attr>);
        $test->id ('new.namespaceURI');
        $test->assert_null ($a1-><AG::Node.namespaceURI>);
        $test->id ('new.localName');
        $test->assert_equals ($a1-><AG::Node.localName>, 'a1');
        $test->id ('new.prefix');
        $test->assert_equals ($a1-><AG::Node.prefix>, 'p');
        $test->id ('new.value');
        $test->assert_equals ($a1-><AG::Attr.value>, 'v1');
        $test->id ('new.specified');
        $test->assert_true ($a1-><AG::Attr.specified>);
        $test->id ('new.ownerElement');
        $test->assert_equals ($a1-><AG::Attr.ownerElement>, $el);

        $el-><M::Element.setAttributeNS> ($ns, 'p:a1', 'v2');
        $test->id ('changed.node');
        my $a2 = $el-><M::Element.getAttributeNodeNS> ($ns, 'a1');
        $test->assert_equals ($a2, $a1);
        $test->id ('changed.value');
        $test->assert_equals ($a2-><AG::Attr.value>, 'v2');

        $el-><M::Element.setAttributeNS> ($ns, 'q:a1', 'v3');
        $test->id ('changed2.node');
        my $a3 = $el-><M::Element.getAttributeNodeNS> ($ns, 'a1');
        $test->assert_equals ($a3, $a1);
        $test->id ('changed2.value');
        $test->assert_equals ($a3-><AG::Attr.value>, 'v3');
        $test->id ('changed2.prefix');
        $test->assert_equals ($a3-><AG::Attr.prefix>, 'q');
    @@Test:
      @@@QName: Element.setAttributeNS.3.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        my $ns = 'about:';

        $el-><M::Element.setAttributeNS> ($ns, ['p', 'a1'], 'v1');

        $test->assert_equals
                 ($el-><M::Element.getAttributeNS> ($ns, 'a1'), 'v1');
    @@L3Test:
      @@@QName: Element.setAttributeNS.xmlid.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        my $cfg = $el-><AG::Node.ownerDocument>-><AG::Document.domConfig>;

        $cfg-><M::c|DOMConfiguration.setParameter> (<Q::cfg|xml-id> => true);

        $test->id ('id.xmlid');
        $el-><M::Element.setAttributeNS> (<Q::xml:>, 'xml:id' => 'value');
        my $sti = $el-><M::Element.getAttributeNodeNS> (<Q::xml:>, 'id')
                     -><AG::Attr.schemaTypeInfo>;
        $test->assert_equals ($sti-><AG::c|TypeInfo.typeName>, 'ID');
        $test->assert_equals
                 ($sti-><AG::c|TypeInfo.typeNamespace>, <Q::xml-dtd:>);

        $test->id ('id.other');
        $el-><M::Element.setAttributeNS> (null, 'id' => 'value');
        my $sti2 = $el-><M::Element.getAttributeNodeNS> (null, 'id')
                      -><AG::Attr.schemaTypeInfo>;
        $test->assert_null ($sti2-><AG::c|TypeInfo.typeName>);
        $test->assert_null ($sti2-><AG::c|TypeInfo.typeNamespace>);

        my $el2 = $el-><AG::Node.ownerDocument>
                     -><M::Document.createElementNS> (null, 'e');
        $cfg-><M::c|DOMConfiguration.setParameter> (<Q::cfg|xml-id> => false);

        $test->id ('noid.xmlid');
        $el2-><M::Element.setAttributeNS> (<Q::xml:>, 'xml:id' => 'value');
        my $sti3 = $el2-><M::Element.getAttributeNodeNS> (<Q::xml:>, 'id')
                       -><AG::Attr.schemaTypeInfo>;
        $test->assert_null ($sti3-><AG::c|TypeInfo.typeName>);
        $test->assert_null ($sti3-><AG::c|TypeInfo.typeNamespace>);

        $test->id ('noid.other');
        $el2-><M::Element.setAttributeNS> (null, 'id' => 'value');
        my $sti4 = $el2-><M::Element.getAttributeNodeNS> (null, 'id')
                       -><AG::Attr.schemaTypeInfo>;
        $test->assert_null ($sti4-><AG::c|TypeInfo.typeName>);
        $test->assert_null ($sti4-><AG::c|TypeInfo.typeNamespace>);

  @ResourceDef:
    @@QName: tc|setAttrValueNS
    @@rdf:type: DISPerl|BlockCode
    @@ForCheck: ManakaiDOM|ForClass
    @@PerlDef:
      my $__node;
      __CODE{selectAttrNodeObjectNS::
        $namespaceURI => $namespaceURI,
        $localName => $localName,
        $self => $element,
        $r => $__node,
      }__;
      if (defined $__node) { ## There is already a node with such a |name|
        if ($__node-><AG::Node.manakaiReadOnly>) {
          __EXCEPTION{MDOMX|NOMOD_ATTR::
            c|node => {$__node},
          }__;
        }
        $__node-><AS::Attr.prefix> ($prefix);
      } else { ## There is no such attribute
        __DEEP{
          $__node = $ownerDocument-><M::Document.createAttributeNS>
                                      ($namespaceURI, [$prefix, $localName]);
          my $__attrs;
          __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
            $r => $__attrs,
            $prop => {<H::infoset|attributes>},
            $ref => $element,
          }__;
          $__attrs->{defined $namespaceURI ? $namespaceURI : ''}->{$localName}
              = <Code::mg|getNodeID||ManakaiDOM|all:: $ref = $__node>;
          __CODE{mg|setNodeStemProp0Node||ManakaiDOM|all::
            $prop => {<H::infoset|ownerElement>},
            $ref => $__node,
            $given => $element,
          }__;
        }__;
      }
      __DEEP{
        $__node-><AS::Attr.value> (defined $value ? $value : '');
        $__node-><AS::Attr.specified> (true);
      }__;
      ## TODO: Schema

  @Method:
    @@Name: setAttributeNode
    @@enDesc:
      Adds a new attribute node.  If an attribute with that 
      <A::Node.nodeName> is already present in the element,
      it is replaced by the new one.

      Replacing an attribute node by itself has no effect.  <SRC::DOM3>

      In manakai, it is an alias of <M::Node.setAttributeNodeNS>.
    @@NSVersion:.setAttributeNodeNS
    @@Param:
      @@@Name: newAttr
      @@@Type: Attr
      @@@enDesc:
        The <IF::Attr> node to add to the attribute list.
    @@Return:
      @@@Type: Attr
      @@@enDesc:
        The replaced <IF::Attr> node.
      @@@nullCase:
        @@@@enDesc:
          If no existing attribute was replaced.
        @@@@enImplNote:
          Although the spec is unclear, when a node is <QUOTE::replaced>
          by itself, it is defined as <QUOTE::no effect>, no node
          is actually replaced and the manakai implementation does
          return <DOM::null>.
      @@@dx:raises:
        @@@@@: c|DIFFERENT_DOCUMENT_ERR
        @@@@enDesc:
          If <P::newAttr> was created from a different document
          than the <A::Node.ownerDocument> of the element.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the element is read-only.
      @@@dx:raises:
        @@@@@: c|INUSE_ATTRIBUTE_ERR
        @@@@enDesc:
          If the <P::newAttr> node is already used as an attribute
          of another <IF::Element> node.
      @@@c:reports:
        @@@@@: t|replace-by-itself
        @@@@enDesc:
          If the <P::arg> node is same as the attribute node that
          is attached to the element node.  Then, the method call is 
          no effect.
      @@@PerlDef:
        my $self_od = $self-><AG::Node.ownerDocument>;
        my $strict = $self_od-><AG::Document.strictErrorChecking>;
        if ($strict and
            not $self_od eq $newAttr-><AG::Node.ownerDocument>) {
          __EXCEPTION{c|DIFFERENT_DOCUMENT_ERR::
            MDOMX|param-name => 'newAttr',
            c|node => {$newAttr},
          }__;
        }

        my $nsuri = $newAttr-><AG::Node.namespaceURI>;
        my $ln = $newAttr-><AG::Node.localName>;
        my $attrs;
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $attrs,
          $prop => {<H::infoset|attributes>},
          $ref => $self,
        }__;
        my $current;
        if (defined $attrs->{$nsuri}->{$ln}) {
          __CODE{mg|createNodeRefFromID||ManakaiDOM|all::
            $bag => {<Code::mg|getNodeBag||ManakaiDOM|all:: $ref = $self>},
            $stemid => {$attrs->{$nsuri}->{$ln}},
            $ref => $current,
            $opt => {{}},
          }__;
        }

        if (defined $newAttr-><AG::Attr.ownerElement>) {
          if (defined $current and $current eq $newAttr) {
            __c:ERROR{t|replace-by-itself::
              c:relatedData => {$newAttr},
            }__;
            ## No return value
          } else {
            __EXCEPTION{c|INUSE_ATTRIBUTE_ERR::
              MDOMX|param-name => 'newAttr',
              c|node => {$newAttr},
            }__;
          }
        } else { # not in use
          if ($strict and $self-><AG::Node.manakaiReadOnly>) {
            __EXCEPTION{MDOMX|NOMOD_THIS::
            }__;
          }

          $attrs->{$nsuri}->{$ln} = <Code::mg|getNodeID||ManakaiDOM|all::
                                               $ref = $newAttr>;
          __CODE{mg|setNodeStemProp0Node||ManakaiDOM|all::
            $prop => {<H::infoset|ownerElement>},
            $ref => $newAttr,
            $given => $self,
          }__;
          $newAttr-><AS::Attr.specified> (true);

          if (defined $current) {
            __CODE{mg|deleteNodeStemPropValue||ManakaiDOM|all::
              $prop => {<H::infoset|ownerElement>},
              $ref => $current,
            }__;
            $r = $current;
          }
        }

    @@Test:
      @@@QName: Element.setAttributeNode.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;
        my $doc = $el-><AG::Node.ownerDocument>;

        my $a1 = $doc-><M::Document.createAttribute> ('attr1');
        $a1-><AS::Attr.value> ('value1');

        $test->id ('set');
        my $r1 = $el-><M::Element.setAttributeNode> ($a1);

        $test->id ('no.replace.no.return');
        $test->assert_null ($r1);

        $test->id ('get.text');
        $test->assert_equals ($el-><M::Element.getAttribute> ('attr1'),
                              'value1');

        $test->id ('get.return.setten');
        my $r2 = $el-><M::Element.getAttributeNode> ('attr1');
        $test->assert_equals ($r2, $a1);

        $test->id ('owner');
        $test->assert_equals ($a1-><AG::Attr.ownerElement>, $el);

        $test->id ('specified');
        $test->assert_true ($a1-><AG::Attr.specified>);

        my $a2 = $doc-><M::Document.createAttribute> ('attr1');
        
        $test->id ('replace');
        my $r3 = $el-><M::Element.setAttributeNode> ($a2);
  
        $test->id ('replaced.node.returned');
        $test->assert_equals ($r3, $a1);

        $test->id ('replaced.no.owner');
        $test->assert_null ($a1-><AG::Attr.ownerElement>);

    @@L3Test:
      @@@QName: Element.setAttributeNode.replace-by-itself.Test
      @@@PerlDef:
        my $impl;
        __CODE{tc|createImplForTest:: $impl => $impl}__;

           my $doc = $impl-><M::c|DOMImplementation.createDocument>
                              ('http://www.example/', 'ex');

           my $eh_called = false;

           my $del = $doc-><AG::Document.documentElement>;
           $del-><M::Element.setAttributeNS> (null, 'attr' => 'value');

           my $attr = $del-><M::Element.getAttributeNodeNS> (null, 'attr');

           my $cfg = $doc-><AG::Document.domConfig>;
           $cfg-><M::c|DOMConfiguration.setParameter> ('error-handler' => sub {
             my (undef, $err) = @_;
             $eh_called = true;
             $test->assert_equals ($err-><AG::c|DOMError.severity>,
                                   <C::c|DOMError.SEVERITY_WARNING>);
             $test->assert_equals ($err-><AG::c|DOMError.type>,
                                   <Q::t|replace-by-itself>);
             $test->assert_equals ($err-><AG::c|DOMError.relatedData>, $attr);
             $test->assert_null ($err-><AG::c|DOMError.relatedException>);
             $test->assert_isa ($err-><AG::c|DOMError.location>,
                                <IFName::c|DOMLocator>);
             $test->assert_not_null ($err-><AG::c|DOMError.message>);
           });

           $test->assert_false ($eh_called);
           $del-><M::Element.setAttributeNode> ($attr);
           $test->assert_true ($eh_called);

           $test->assert_equals ($del-><M::Element.getAttributeNodeNS>
                                   (null, 'attr'), $attr);

           $attr = null;

  @L2Method:
    @@Name: setAttributeNodeNS
    @@enDesc:
      Adds a new attribute.  If an attribute with that namespace URI
      and local name is already present in the element, it is
      replaced by the new one.

      Replacing an attribute node by itself has no effect.  <SRC::DOM3>
    @@NoNSVersion:.setAttributeNS
    @@XML2Feature:
    @@Param:
      @@@Name: newAttr
      @@@Type: Attr
      @@@enDesc:
        The <IF::Attr> node to add to the attribute list.
    @@Return:
      @@@Type: Attr
      @@@enDesc:
        The replaced <IF::Attr> node.
      @@@nullCase:
        @@@@enDesc:
          If there is no existing attribute.
      @@@dx:raises:
        @@@@@: c|DIFFERENT_DOCUMENT_ERR
        @@@@enDesc:
          If the <P::newAttr> node was created from a different
          document than the one that created the element.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the node is read-only.
      @@@dx:raises:
        @@@@@: c|INUSE_ATTRIBUTE_ERR
        @@@@enDesc:
          If the <P::newAttr> node is already an attribute of 
          another <IF::Element>.
      @@@iRaises:
        @@@@@: MDOMX|MDOM_IMPL_NOSUPPORT_XML
        @@@@enDesc:
          If the implementation does not support the feature
          <Feature::XML> and the language exposed through the <IF::Document>
          does not support XML namespaces.
      @@@iRaises:
        @@@@@: MDOMX|MDOM_NODE_NOSUPPORT_XMLNS
        @@@@enDesc:
          If the <P::newAttr> node does not support XML namespaces.
          <SRC::manakai>.
      @@@c:reports:
        @@@@@: t|replace-by-itself
        @@@@enDesc:
          If the <P::newAttr> node is same as the node already attached
          to the element.  Then, the method is no effect.
      @@@disDef:
        @@@@DISPerl:cloneCode: .setAttributeNode

    @@Test:
      @@@QName: Element.setAttributeNodeNS.1.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;
        my $doc = $el-><AG::Node.ownerDocument>;

        my $a1 = $doc-><M::Document.createElementNS> (null, 'a1');
        $a1-><AS::Attr.value> ('v1');

        $el-><M::Element.setAttributeNodeNS> ($a1);

        $test->id ('value');
        $test->assert_equals ($el-><M::Element.getAttributeNS> (null, 'a1'),
                              'v1');
        $test->id ('specified');
        $test->assert_true ($a1-><AG::Attr.specified>);
        $test->id ('ownerElement');
        $test->assert_equals ($a1-><AG::Attr.ownerElement>, $el);

  @Method:
    @@Name: removeAttribute
    @@enDesc:
      Removes an attribute by name.

      If a default value for the removed attribute is defined
      in the DTD, a new attribute immediately appears with
      the default value as well as corresponding namespace URI,
      local name, and prefix when applicable.  The implementation
      may handle default values from other schemas similarly
      but applications should use the <M::Document.normalizeDocument>
      method to guarantee this information is up-to-date.

      If no attribute with the name is found, this method has no effect.
    @@NSVersion:.removeAttributeNS
    @@Param:
      @@@Name: name
      @@@Type: DOMString
      @@@dis:actualType:
        @@@@@: DOMMain|ManakaiDOMXMLName
        @@@@ManakaiDOM:noInputNormalize: 1
      @@@enDesc:
        The name of the attribute to remove.
    @@Return:
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the <IF::Element> node is read-only.
      @@@PerlDef:
        my $list;
        my $key;
        my $attr;
        __CODE{selectAttrNodeObjectForRemove::
          $self => $self,
          $name => $name,
          $list => $list,
          $key => $key,
          $r => $attr,
        }__;
        if (defined $attr) {
          if ($self-><AG::Node.manakaiReadOnly>) {
            __EXCEPTION{MDOMX|NOMOD_THIS::
            }__;
          }

          ## Remove the attribute node
          CORE::delete $list->{$key};
          __CODE{mg|deleteNodeStemPropValue||ManakaiDOM|all::
            $prop => {<H::infoset|ownerElement>},
            $ref => $attr,
          }__;

          ## Default attribute
          my $doc = $self-><AG::Node.ownerDocument>;
          my $prefix;
          __CODE{tc|generateDefaultAttribute::
            $document => $doc,
            $element_type => {$self-><AG::Node.nodeName>},
            $element => $self,
            $name => $name,
            $prefix => $prefix, $localName => $name,
          }__;
        } # exists

    @@Test:
      @@@QName: Element.removeAttribute.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        $test->id ('remove.no.attr');
        $el-><M::Element.removeAttribute> ('at1');

        $test->id ('set.attr');
        $el-><M::Element.setAttribute> (at1 => 'value1');
        my $v1 = $el-><M::Element.getAttribute> ('at1');
        $test->assert_equals ($v1, 'value1');

        $test->id ('remove.attr');
        $el-><M::Element.removeAttribute> ('at1');
        my $v2 = $el-><M::Element.getAttribute> ('at1');
        $test->assert_true (not defined $v2 or $v2 eq '');
    @@Test:
      @@@QName: Element.removeAttribute.nsattr.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        $test->id ('remove.no.attr');
        $el-><M::Element.removeAttribute> ('ns1:at1');

        $test->id ('set.attr.ns');
        $el-><M::Element.setAttributeNS>
               ('http://example./', 'ns1:at1' => 'value1');
        my $v1 = $el-><M::Element.getAttributeNS> ('http://example./', 'at1');
        $test->assert_equals ($v1, 'value1');

        $test->id ('remove.attr');
        $el-><M::Element.removeAttribute> ('ns1:at1');
        my $v2 = $el-><M::Element.getAttributeNS> ('http://example./', 'at1');
        undef $v2 if defined $v2 and $v2 eq '';
        $test->assert_null ($v2);
    @@L3Test:
      @@@QName: Element.removeAttribute.defaultattr.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docd = $doc-><M::Node.getFeature> (<Q::ManakaiDOM:XDoctype>, '3.0');
        my $dtd = $docd-><M::d|DocumentXDoctype.createDocumentTypeDefinition>
                           ('doctype');
          my $et = $docd-><M::d|DocumentXDoctype.createElementTypeDefinition>
                             ('et1');
            my $at = $docd-><M::d|DocumentXDoctype.createAttributeDefinition>
                               ('dattr1');
            $at-><AS::ATDef.defaultType> (<C::ATDef.EXPLICIT_DEFAULT>);
            $at-><AS::Node.textContent> ('dattr1 default ');
          $et-><M::ETDef.setAttributeDefinitionNode> ($at);
        $dtd-><M::DTDef.setElementTypeDefinitionNode> ($et);
        $doc-><M::Node.appendChild> ($dtd);

        $test->id ('created.default.value');
        my $el = $doc-><M::Document.createElement> ('et1');
        $test->assert_equals ($el-><M::Element.getAttribute> ('dattr1'),
                              'dattr1 default ');
        $test->assert_false ($el-><M::Element.getAttributeNode> ('dattr1')
                                -><AG::Attr.specified>);

        $test->id ('set.attr');
        $el-><M::Element.setAttribute> ('dattr1', 'non-default-value');
        $test->assert_equals ($el-><M::Element.getAttribute> ('dattr1'),
                              'non-default-value');
        $test->assert_true ($el-><M::Element.getAttributeNode> ('dattr1')
                               -><AG::Attr.specified>);

        $test->id ('remove.attr');
        $el-><M::Element.removeAttribute> ('dattr1');
        $test->assert_equals ($el-><M::Element.getAttribute> ('dattr1'),
                              'dattr1 default ');
        $test->assert_false ($el-><M::Element.getAttributeNode> ('dattr1')
                                -><AG::Attr.specified>);
    @@Test:
      @@@QName: Element.removeAttribute.ro.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        $el-><M::Element.setAttribute> (a => 'b');
        $el-><M::Node.manakaiSetReadOnly> (true);

        $test->id ('remove');
        $test->assert_exception (code => sub {
          $el-><M::Element.removeAttribute> ('a');
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);

        $test->id ('has');
        $test->assert_true ($el-><M::Element.hasAttribute> ('a'));

  @L2Method:
    @@Name: removeAttributeNS
    @@enDesc:
      Removes an attribute by namespace URI and local name.

      If a default value for the removed attribute is defined in
      the DTD, a new attribute immediately apperas with
      the default value as well as the corresponding namespace URI,
      local name, and prefix when applicable.  The implementation
      may handle default values from other schemas similarly but
      applications should use the <M::Document.normalizeDocument>
      method to guarantee this information is up-to-date.

      If no attribute with the namespace URI and local name is
      found, this method has no effect.
    @@NoNSVersion: .removeAttribute
    @@XML2Feature:
    @@Param:
      @@@Name: namespaceURI
      @@@Type: DOMString
      @@@dis:actualType: ManakaiDOM|ManakaiDOMNamespaceURI
      @@@enDesc:
        The namespace URI of the attribute to remove.
      @@@nullCase:
        @@@@enDesc:
          If the attribute has no namespace.
    @@Param:
      @@@Name: localName
      @@@Type: DOMString
      @@@dis:actualType:
        @@@@@: DOMMain|ManakaiDOMXMLLocalName
        @@@@ManakaiDOM:noInputNormalize: 1
      @@@enDesc:
        The local name of the attribute to remove.
    @@Return:
      @@@NodeReadOnlyError:
      @@@iRaises:
        @@@@@: MDOMX|MDOM_IMPL_NOSUPPORT_XML
        @@@@enDesc:
          If the implementation does not support the feature
          <Feature::XML> and the language exposed through the <IF::Document>
          does not support XML namespaces.
      @@@PerlDef:
        my $list;
        my $attr;
        __CODE{selectAttrNodeObjectForRemoveNS::
          $self => $self,
          $namespaceURI => $namespaceURI,
          $localName => $localName,
          $list => $list,
          $r => $attr,
        }__;
        if (defined $attr) {
          if ($self-><AG::Node.manakaiReadOnly>) {
            __EXCEPTION{MDOMX|NOMOD_THIS::
            }__;
          }
         
          ## Removes the attribute node
          CORE::delete $list->{$localName};
          __CODE{mg|deleteNodeStemPropValue||ManakaiDOM|all::
            $prop => {<H::infoset|ownerElement>},
            $ref => $attr,
          }__;

          ## Default attribute
          my $pfx = $attr-><AG::Node.prefix>;
          my $name = defined $pfx ? $pfx.':'.$localName : $localName;
          my $doc = $self-><AG::Node.ownerDocument>;
          __CODE{tc|generateDefaultAttribute::
            $document => $doc,
            $element_type => {$self-><AG::Node.nodeName>},
            $element => $self,
            $name => $name,
            $prefix => $pfx, $localName => $localName,
          }__;
        } # exists

    @@Test:
      @@@ForCheck: ManakaiDOM|DOMXMLFeature
      @@@QName: Element.removeAttributeNS.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        $test->id ('remove.no.attr');
        $el-><M::Element.removeAttributeNS> (null, 'at1');

        $test->id ('set.attr');
        $el-><M::Element.setAttributeNS> (null, at1 => 'value1');
        my $v1 = $el-><M::Element.getAttributeNS> (null, 'at1');
        $test->assert_equals ($v1, 'value1');

        $test->id ('remove.attr');
        $el-><M::Element.removeAttributeNS> (null, 'at1');
        my $v2 = $el-><M::Element.getAttributeNS> (null, 'at1');
        $test->assert_true (not defined $v2 or $v2 eq '');
    @@Test:
      @@@QName: Element.removeAttributeNS.global.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        my $uri = 'http://example.com/';
        $test->id ('remove.no.attr');
        $el-><M::Element.removeAttributeNS> ($uri, 'at1');

        $test->id ('set.attr');
        $el-><M::Element.setAttributeNS> ($uri, at1 => 'value1');
        my $v1 = $el-><M::Element.getAttributeNS> ($uri, 'at1');
        $test->assert_equals ($v1, 'value1');

        $test->id ('remove.attr');
        $el-><M::Element.removeAttributeNS> ($uri, 'at1');
        my $v2 = $el-><M::Element.getAttributeNS> ($uri, 'at1');
        $test->assert_true (not defined $v2 or $v2 eq '');
    @@L3Test:
      @@@QName: Element.removeAttributeNS.defaultattr.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $uri = 'http://www.example.com/';
        my $docd = $doc-><M::Node.getFeature> (<Q::ManakaiDOM:XDoctype>, '3.0');
        my $dtd = $docd-><M::d|DocumentXDoctype.createDocumentTypeDefinition>
                           ('doctype');
          my $et = $docd-><M::d|DocumentXDoctype.createElementTypeDefinition>
                             ('et1');
            my $at = $docd-><M::d|DocumentXDoctype.createAttributeDefinition>
                               ('ns1:dattr1');
            $at-><AS::ATDef.defaultType> (<C::ATDef.EXPLICIT_DEFAULT>);
            $at-><AS::Node.textContent> ('dattr1 default ');
          $et-><M::ETDef.setAttributeDefinitionNode> ($at);
            my $at2 = $docd-><M::d|DocumentXDoctype.createAttributeDefinition>
                               ('xmlns:ns1');
            $at2-><AS::ATDef.defaultType> (<C::ATDef.EXPLICIT_DEFAULT>);
            $at2-><AS::Node.textContent> ($uri);
          $et-><M::ETDef.setAttributeDefinitionNode> ($at2);
        $dtd-><M::DTDef.setElementTypeDefinitionNode> ($et);
        $doc-><M::Node.appendChild> ($dtd);

        $test->id ('created.default.value');
        my $el = $doc-><M::Document.createElementNS> ($uri, 'et1');
        $test->assert_equals ($el-><M::Element.getAttributeNS> ($uri, 'dattr1'),
                              'dattr1 default ');
        $test->assert_false ($el-><M::Element.getAttributeNodeNS>
                                    ($uri, 'dattr1')
                                -><AG::Attr.specified>);

        $test->id ('set.attr');
        $el-><M::Element.setAttributeNS>
               ($uri, 'ns1:dattr1', 'non-default-value');
        $test->assert_equals ($el-><M::Element.getAttributeNS> ($uri, 'dattr1'),
                              'non-default-value');
        $test->assert_true ($el-><M::Element.getAttributeNodeNS> ($uri, 'dattr1')
                               -><AG::Attr.specified>);

        $test->id ('remove.attr');
        $el-><M::Element.removeAttributeNS> ($uri, 'dattr1');
        $test->assert_equals ($el-><M::Element.getAttributeNS> ($uri, 'dattr1'),
                              'dattr1 default ');
        $test->assert_false ($el-><M::Element.getAttributeNodeNS>
                                    ($uri, 'dattr1')
                                -><AG::Attr.specified>);

  @Method:
    @@Name: removeAttributeNode
    @@enDesc:
      Removes the specified attribute node.

      If a default value for the removed attribute is defined
      in the DTD, a new node immediately appears with the 
      default value as well as the corresponding namespace URI,
      local name, and prefix when applicable.  The implementation
      may handle default values from other schemas similarly but
      applications should use the <M::Document.normalizeDocument>
      method to guarantee this information is up-to-date.
    @@Param:
      @@@Name: oldAttr
      @@@Type: Attr
      @@@enDesc:
        The <IF::Attr> node to remove from the attribute list.
    @@Return:
      @@@Type: Attr
      @@@enDesc:
        The <IF::Attr> node that was removed.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the element node is read-only.
      @@@dx:raises:
        @@@@@: c|NOT_ATTR_ERR
        @@@@enDesc:
          If the <P::oldAttr> node is not an attribute of the element.
      @@@PerlDef:
        my $od = $self-><AG::Node.ownerDocument>;
        if ($od-><AG::Document.strictErrorChecking> and
            $self-><AG::Node.manakaiReadOnly>) {
          __EXCEPTION{MDOMX|NOMOD_THIS::
          }__;
        }

        my $ln = $oldAttr-><AG::Node.localName>;
        FIND: {
          my $attrs;
          __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
            $r => $attrs,
            $prop => {<H::infoset|attributes>},
            $ref => $self,
          }__;
          my $nsuri = $oldAttr-><AG::Node.namespaceURI>;
          my $list = $attrs->{defined $nsuri ? $nsuri : ''};
          my $list_nid = $list->{$ln};
          if (defined $list_nid and
              <Code::mg|nodeIDMatch||ManakaiDOM|all::
                        $noderef = $oldAttr,
                        $nodeid = $list_nid>) {
            CORE::delete $list->{$ln};
            last FIND;
          }
          __EXCEPTION{c|NOT_ATTR_ERR::
            MDOMX|param-name => 'oldAttr',
            c|node => {$oldAttr},
          }__;
        } # FIND

        __CODE{mg|deleteNodeStemPropValue||ManakaiDOM|all::
          $prop => {<H::infoset|ownerElement>},
          $ref => $oldAttr,
        }__;
        $r = $oldAttr;
      
        ## Default attribute
        my $name = $oldAttr-><AG::Node.nodeName>;
        my $pfx = $oldAttr-><AG::Node.prefix>;
        __CODE{t|generateDefaultAttribute::
          $document => $od,
          $element_type => {$self-><AG::Node.nodeName>},
          $element => $self,
          $name => $name,
          $prefix => $pfx, $localName => $ln,
        }__;

    @@Test:
      @@@QName: Element.removeAttributeNode.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        $test->id ('remove.no.attr');
        $el-><M::Element.removeAttribute> ('at1');

        $test->id ('set.attr');
        $el-><M::Element.setAttribute> (at1 => 'value1');
        my $v1 = $el-><M::Element.getAttribute> ('at1');
        $test->assert_equals ($v1, 'value1');

        $test->id ('remove.attr');
        my $a1 = $el-><M::Element.getAttributeNode> ('at1');
        $el-><M::Element.removeAttributeNode> ($a1);
        my $v2 = $el-><M::Element.getAttribute> ('at1');
        $test->assert_true (not defined $v2 or $v2 eq '');
        $test->assert_null ($a1-><AG::Attr.ownerElement>);
    @@L2Test:
      @@@QName: Element.removeAttributeNode.nsattr.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        $test->id ('remove.no.attr');
        $el-><M::Element.removeAttribute> ('ns1:at1');

        $test->id ('set.attr.ns');
        $el-><M::Element.setAttributeNS>
               ('http://example./', 'ns1:at1' => 'value1');
        my $v1 = $el-><M::Element.getAttributeNS> ('http://example./', 'at1');
        $test->assert_equals ($v1, 'value1');

        $test->id ('remove.attr');
        my $a1 = $el-><M::Element.getAttributeNode> ('ns1:at1');
        $el-><M::Element.removeAttributeNode> ($a1);
        my $v2 = $el-><M::Element.getAttributeNS> ('http://example./', 'at1');
        $test->assert_true (not defined $v2 or $v2 eq '');
        $test->assert_null ($a1-><AG::Attr.ownerElement>);
    @@L3Test:
      @@@QName: Element.removeAttributeNode.defaultattr.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docd = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>, '3.0');
        my $dtd = $docd-><M::d|DocumentXDoctype.createDocumentTypeDefinition>
                           ('doctype');
          my $et = $docd-><M::d|DocumentXDoctype.createElementTypeDefinition>
                             ('et1');
            my $at = $docd-><M::d|DocumentXDoctype.createAttributeDefinition>
                               ('dattr1');
            $at-><AS::ATDef.defaultType> (<C::ATDef.EXPLICIT_DEFAULT>);
            $at-><AS::Node.textContent> ('dattr1 default ');
          $et-><M::ETDef.setAttributeDefinitionNode> ($at);
        $dtd-><M::DTDef.setElementTypeDefinitionNode> ($et);
        $doc-><M::Node.appendChild> ($dtd);

        $test->id ('created.default.value');
        my $el = $doc-><M::Document.createElement> ('et1');
        $test->assert_equals ($el-><M::Element.getAttribute> ('dattr1'),
                              'dattr1 default ');
        $test->assert_false ($el-><M::Element.getAttributeNode> ('dattr1')
                                -><AG::Attr.specified>);

        $test->id ('set.attr');
        $el-><M::Element.setAttribute> ('dattr1', 'non-default-value');
        $test->assert_equals ($el-><M::Element.getAttribute> ('dattr1'),
                              'non-default-value');
        $test->assert_true ($el-><M::Element.getAttributeNode> ('dattr1')
                               -><AG::Attr.specified>);

        $test->id ('remove.attr');
        my $a1 = $el-><M::Element.getAttributeNode> ('dattr1');
        $el-><M::Element.removeAttributeNode> ($a1);
        $test->assert_equals ($el-><M::Element.getAttribute> ('dattr1'),
                              'dattr1 default ');
        $test->assert_false ($el-><M::Element.getAttributeNode> ('dattr1')
                                -><AG::Attr.specified>);
        $test->assert_null ($a1-><AG::Attr.ownerElement>);

  @CODE:
    @@QName: tc|generateDefaultAttribute
    @@PerlDef:
      __DEEP{
        my $__doctype = $document-><AG::Document.doctype>;
        $__doctype = $__doctype-><M::Node.getFeature> (<Q::fe|XDoctype>)
          if $__doctype;
        if (defined $__doctype) {
          my $__et = $__doctype-><M::DTDef.getElementTypeDefinitionNode>
                                   ($element_type);
          if (defined $__et) {
            my $__orig_strict = $document-><AG::Document.strictErrorChecking>;
            $document-><AS::Document.strictErrorChecking> (false);

            my $__at = $__et-><M::ETDef.getAttributeDefinitionNode> ($name);
            if (defined $__at) {
              my $__cfg = $document-><AG::Document.domConfig>;
              my $__copy_asis = $__cfg-><M::c|DOMConfiguration.getParameter>
                                     (<Q::cfg|clone-entity-reference-subtree>);
              $__cfg-><M::c|DOMConfiguration.setParameter>
                        (<Q::cfg|clone-entity-reference-subtree> => true);
              ADD: {
                my $__attr;
                my $__attrs;
                __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
                  $r => $__attrs,
                  $prop => {<H::infoset|attributes>},
                  $ref => $element,
                }__;
                if (defined $prefix) {   ## prefixed attr
                  my $__nsuri = $element-><M::Node.lookupNamespaceURI>
                                            ($prefix);
                  unless (defined $__nsuri) {
                    ## TODO: Namespace well-formedness error
                  }
                  if (defined $__attrs->{defined $__nsuri ? $__nsuri : ''}
                                      ->{$localName}) {
                    ## TODO: Namespace well-formedness warning?
                    last ADD;
                  }
                  $__attr = $document-><M::Document.createAttributeNS>
                                         ($__nsuri, [$prefix, $localName]);
                } else {                ## local attr
                  if ($name eq 'xmlns') {
                    if (defined $__attrs->{<Q::xmlns:>}->{xmlns}) {
                      ## TODO: Namespace well-formedness warning?
                      last ADD;
                    }
                    $__attr = $document-><M::Document.createAttributeNS>
                                           (<Q::xmlns:>, 'xmlns');
                  } else {
                    if (defined $__attrs->{''}->{$name}) {
                      ## TODO: Namespace well-formedness warning?
                      last ADD;
                    }
                    $__attr = $document-><M::Document.createAttribute> ($name);
                  }
                }
                for my $__at_child (@{$__at-><AG::Node.childNodes>}) {
                  $__attr-><M::Node.appendChild>
                             ($__at_child-><M::Node.cloneNode> (true));
                }
                __CODE{tc|setAttrType::
                  $ref => $__attr,
                  $type => {$__at-><AG::ATDef.declaredType>},
                }__;
                $element-><M::Element.setAttributeNodeNS> ($__attr);
                              ## This method change the |specified| flag
                $__attr-><AS::Attr.specified> (false);
              } # ADD
              $__cfg-><M::c|DOMConfiguration.setParameter>
                     (<Q::cfg|clone-entity-reference-subtree> => $__copy_asis);
            }
            $document-><AS::Document.strictErrorChecking> ($__orig_strict);
          } # et
        } # doctype
      }__;
    @@enImplNote:
      {ISSUE::
        Given <XA::ns1:ln> attribute has a default value <CODE::value>
        and there is a <A::Attr.specified> attribute node <VAR::a1>
        whose <A::Node.prefix> is <XML::ns1> and <A::Node.localName>
        is <XML::ln>.  Then, <VAR::a1>'s <A::Node.prefix> is 
        so modified that its value is now <XML::ns2>.  At this
        time no default attribute is added <SRC::DOM Level 3 Core>.

        Now we remove the <VAR::a1> node from its owner element.
        Should the operation make a default attribute with
        its <A::Node.nodeName> <XA::ns1:ln> be created?
        
        To do it, because of DTD's namespace unawareness, 
        we must test any possible default attribute if
        its local name matches to the removed attribute's local name,
        i.e. <XML::ln>, and looking up its prefix by the
        former owner element of the removed attribute and
        it matches to the namespace URI of the removed attribute.
      }

  @L3Attr:
    @@Name: schemaTypeInfo
    @@enDesc:
      The type information associated with the element.
    @@enImplNote:
      Currently manakai does not support XML Schema, so it is 
      always a no-type <IF::c|TypeInfo>.  It is expected that
      a future version of the implementation will return an
      element type definition node that also implement the
      <IF::c|TypeInfo> interface when the schema language is XML DTD.
    @@Type: c|TypeInfo
    @@Get:
      @@@PerlDef:
        __CODE{c|createDTDTypeInfo::
          $result => $r,
          $type => {0},
        }__;
    @@L3Test:
      @@@QName: Element.schemaTypeInfo.no-schema.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;
        $el-><AG::Node.ownerDocument>
           -><AG::Document.domConfig>
           -><M::c|DOMConfiguration.setParameter>
               ('schema-type' => q[http://dummy.example/]);

        my $sti = $el-><AG::Element.schemaTypeInfo>;
        $test->assert_isa ($sti, <IFName::c|TypeInfo>);
        $test->assert_null ($sti-><AG::c|TypeInfo.typeName>);
        $test->assert_null ($sti-><AG::c|TypeInfo.typeNamespace>);
    @@L3Test:
      @@@QName: Element.schemaTypeInfo.dtd.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;
        $el-><AG::Node.ownerDocument>
           -><AG::Document.domConfig>
           -><M::c|DOMConfiguration.setParameter>
               ('schema-type' => <Q::xml-dtd:>);

        my $sti = $el-><AG::Element.schemaTypeInfo>;
        $test->assert_isa ($sti, <IFName::c|TypeInfo>);
        $test->assert_null ($sti-><AG::c|TypeInfo.typeName>);
        $test->assert_null ($sti-><AG::c|TypeInfo.typeNamespace>);

  @Method:
    @@Name: getElementsByTagName
    @@enDesc:
      Returns a <IF::NodeList> of all descendant <IF::Element>s
      with a given tag name, in the order in which they are
      encountered in a preorder traversal of the <IF::Element> tree.
    @@NSVersion: .getElementsByTagNameNS
    @@Param:
      @@@Name: name
      @@@Type: DOMString
      @@@enDesc:
        The name of the tag to match on.
      @@@InCase:
        @@@@Value:
          @@@@@@: *
          @@@@@ContentType: DISCore|String
        @@@@enDesc:
          Matches all tags.
    @@Return:
      @@@Type: NodeList
      @@@enDesc:
        A live list of matching <IF::Element> nodes.
      @@@PerlDef:
        $name = "$name";
        my $chk;
        if ($name eq '*') {
          $chk = sub { true };
        } else {
          $chk = sub {
            my $node = shift;
            my $nodeName = $node-><AG::Node.nodeName>;
            ($nodeName eq $name);
          };
        }
        __CODE{tc|createGetElementsNodeList::
          $node => $self, $chk => $chk, $r => $r,
        }__;

    @@Test:
      @@@QName: Node.getElementsByTagName.1.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        my $doc = $el-><AG::Node.ownerDocument>;

        $test->id ('nodelist');
        my $nl = $el-><M::Element.getElementsByTagName> ('target');
        $test->assert_isa ($nl, <IFName::NodeList>);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@$nl, expected_value => 0);

        $test->id ('item.0');
        $test->assert_null ($nl-><M::NodeList.item> (0));

        $test->id ('item.-1');
        $test->assert_null ($nl-><M::NodeList.item> (-1));

        my $t1 = $doc-><M::Document.createElement> ('target');
        my $t2 = $doc-><M::Document.createElement> ('target');
        my $t3 = $doc-><M::Document.createElementNS> (null, 'target');
        my $d1 = $doc-><M::Document.createElementNS> ('about:', 'a:target');
        my $d2 = $doc-><M::Document.createElement> ('not-target');
        $el-><M::Node.appendChild> ($t1);
        $el-><M::Node.appendChild> ($d1);
        $el-><M::Node.appendChild> ($d2);
        $d2-><M::Node.appendChild> ($t2);
        $el-><M::Node.appendChild> ($t3);

        $test->id ('length.3');
        $test->assert_num_equals
                 (actual_value => 0+@$nl, expected_value => 3);

        $test->id ('t1');
        $test->assert_equals ($nl-><M::NodeList.item> (0), $t1);

        $test->id ('t2');
        $test->assert_equals ($nl-><M::NodeList.item> (1), $t2);

        $test->id ('t3');
        $test->assert_equals ($nl-><M::NodeList.item> (2), $t3);

        $test->id ('item.3');
        $test->assert_null ($nl-><M::NodeList.item> (3));

        $test->id ('item.-1');
        $test->assert_null ($nl-><M::NodeList.item> (-1));
    @@Test:
      @@@QName: Node.getElementsByTagName.2.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        my $doc = $el-><AG::Node.ownerDocument>;

        $test->id ('nodelist');
        my $nl = $el-><M::Element.getElementsByTagName> ('a:target');
        $test->assert_isa ($nl, <IFName::NodeList>);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@$nl, expected_value => 0);

        $test->id ('item.0');
        $test->assert_null ($nl-><M::NodeList.item> (0));

        $test->id ('item.-1');
        $test->assert_null ($nl-><M::NodeList.item> (-1));

        my $t1 = $doc-><M::Document.createElement> ('a:target');
        my $t2 = $doc-><M::Document.createElementNS> ('mocha:', 'a:target');
        my $t3 = $doc-><M::Document.createElementNS> ('about:', 'a:target');
        my $d1 = $doc-><M::Document.createElementNS> ('about:', 'target');
        my $d2 = $doc-><M::Document.createElement> ('not-target');
        $el-><M::Node.appendChild> ($t1);
        $el-><M::Node.appendChild> ($d1);
        $el-><M::Node.appendChild> ($d2);
        $d2-><M::Node.appendChild> ($t2);
        $el-><M::Node.appendChild> ($t3);

        $test->id ('length.3');
        $test->assert_num_equals
                 (actual_value => 0+@$nl, expected_value => 3);

        $test->id ('t1');
        $test->assert_equals ($nl-><M::NodeList.item> (0), $t1);

        $test->id ('t2');
        $test->assert_equals ($nl-><M::NodeList.item> (1), $t2);

        $test->id ('t3');
        $test->assert_equals ($nl-><M::NodeList.item> (2), $t3);

        $test->id ('item.3');
        $test->assert_null ($nl-><M::NodeList.item> (3));

        $test->id ('item.-1');
        $test->assert_null ($nl-><M::NodeList.item> (-1));

  @L2Method:
    @@Name: getElementsByTagNameNS
    @@enDesc:
      Returns a <IF::NodeList> of all the descendant <IF::Element>s
      with a given namespace URI and local name in document order.
    @@NoNSVersion: .getElementsByTagName
    @@XML2Feature:
    @@Param:
      @@@Name: namespaceURI
      @@@Type: DOMString
      @@@dis:actualType: ManakaiDOM|ManakaiDOMNamespaceURI
      @@@enDesc:
        The namespace URI of the elements to match on.
      @@@InCase:
        @@@@Value:
          @@@@@@: *
          @@@@@ContentType: DISCore|String
        @@@@enDesc:
          Matches all namespaces.
    @@Param:
      @@@Name: localName
      @@@Type: DOMString
      @@@dis:actualType:
        @@@@@: DOMMain|ManakaiDOMXMLLocalName
        @@@@ManakaiDOM:noInputNormalize: 1
      @@@enDesc:
        The local name of the elements to match on.
      @@@InCase:
        @@@@Value:
          @@@@@@: *
          @@@@@ContentType: DISCore|String
        @@@@enDesc:
          Matches all local names.
    @@Return:
      @@@Type: NodeList
      @@@enDesc:
        A new <IF::NodeList> object containing all the matched 
        <IF::Element>s.
      @@@iRaises:
        @@@@@: MDOMX|MDOM_IMPL_NOSUPPORT_XML
        @@@@enDesc:
          If the implementation does not support the feature
          <Feature;;XML> and the language exposed through the 
          <IF::Document> does not support XML namespaces.
      @@@PerlDef:
        $namespaceURI = "$namespaceURI" if defined $namespaceURI;
        $localName = "$localName";
        my $chk;
        if (not defined $namespaceURI) {
          if ($localName eq '*') {
            $chk = sub {
              my $node = shift;
              (not defined $node-><AG::Node.namespaceURI>);
            };
          } else {
            $chk = sub {
              my $node = shift;
              (not defined $node-><AG::Node.namespaceURI> and
               $node-><AG::Node.localName> eq $localName);
            };
          }
        } elsif ($namespaceURI eq '*') {
          if ($localName eq '*') {
            $chk = sub { true };
          } else {
            $chk = sub {
              my $node = shift;
              ($node-><AG::Node.localName> eq $localName);
            };
          }
        } else {
          if ($localName eq '*') {
            $chk = sub {
              my $node = shift;
              my $nsuri = $node-><AG::Node.namespaceURI>;
              (defined $nsuri and $nsuri eq $namespaceURI);
            };
          } else {
            $chk = sub {
              my $node = shift;
              my $nsuri = $node-><AG::Node.namespaceURI>;
              (defined $nsuri and $nsuri eq $namespaceURI and
               $node-><AG::Node.localName> eq $localName);
            };
          }
        }
        __CODE{tc|createGetElementsNodeList::
          $node => $self, $chk => $chk, $r => $r,
        }__;

    @@Test:
      @@@QName: Element.getElementsByTagNameNS.1.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        my $doc = $el-><AG::Node.ownerDocument>;

        $test->id ('nodelist');
        my $nl = $el-><M::Element.getElementsByTagName>
                        (null, 'target');
        $test->assert_isa ($nl, <IFName::NodeList>);

        $test->id ('length.0');
        $test->assert_num_equals
                 (actual_value => 0+@$nl, expected_value => 0);

        $test->id ('item.-1.1');
        $test->assert_null ($nl-><M::NodeList.item> (-1));

        $test->id ('item.0.1');
        $test->assert_null ($nl-><M::NodeList.item> (0));

        my $t1 = $doc-><M::Document.createElement> ('target');
        my $t2 = $doc-><M::Document.createElementNS> (null, 'target');
        my $t3 = $doc-><M::Document.createElementNS> (null, 'target');
        my $d1 = $doc-><M::Document.createElementNS> ('about:', 'target');
        my $d2 = $doc-><M::Document.createElementNS> ('about:', 'a:target');
        $el-><M::Node.appendChild> ($t1);
        $el-><M::Node.appendChild> ($d1);
        $d1-><M::Node.appendChild> ($t2);
        $e1-><M::Node.appendChild> ($d2);
        $el-><M::Node.appendChild> ($t3);

        $test->id ('length.3');
        $test->assert_num_equals
                 (actual_value => 0+@$nl, expected_value => 3);

        $test->id ('item.0');
        $test->assert_equals ($nl-><M::NodeList.item> (0), $t1);

        $test->id ('item.1');
        $test->assert_equals ($nl-><M::NodeList.item> (1), $t2);

        $test->id ('item.2');
        $test->assert_equals ($nl-><M::NodeList.item> (2), $t3);

        $test->id ('item.-1');
        $test->assert_null ($nl-><M::NodeList.item> (-1));

        $test->id ('item.3');
        $test->assert_null ($nl-><M::NodeList.item> (3));
    @@Test:
      @@@QName: Element.getElementsByTagNameNS.2.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        my $doc = $el-><AG::Node.ownerDocument>;

        $test->id ('nodelist');
        my $nl = $el-><M::Element.getElementsByTagName>
                        ('about:', 'target');
        $test->assert_isa ($nl, <IFName::NodeList>);

        $test->id ('length.0');
        $test->assert_num_equals
                 (actual_value => 0+@$nl, expected_value => 0);

        $test->id ('item.-1.1');
        $test->assert_null ($nl-><M::NodeList.item> (-1));

        $test->id ('item.0.1');
        $test->assert_null ($nl-><M::NodeList.item> (0));

        my $t1 = $doc-><M::Document.createElementNS> ('about:', 'target');
        my $t2 = $doc-><M::Document.createElementNS> ('about:', 'target');
        my $t3 = $doc-><M::Document.createElementNS> ('about:', 'a:target');
        my $d1 = $doc-><M::Document.createElementNS> ('about:a', 'target');
        my $d2 = $doc-><M::Document.createElementNS> ('about:b', 'a:target');
        $el-><M::Node.appendChild> ($t1);
        $el-><M::Node.appendChild> ($d1);
        $d1-><M::Node.appendChild> ($t2);
        $e1-><M::Node.appendChild> ($d2);
        $el-><M::Node.appendChild> ($t3);

        $test->id ('length.3');
        $test->assert_num_equals
                 (actual_value => 0+@$nl, expected_value => 3);

        $test->id ('item.0');
        $test->assert_equals ($nl-><M::NodeList.item> (0), $t1);

        $test->id ('item.1');
        $test->assert_equals ($nl-><M::NodeList.item> (1), $t2);

        $test->id ('item.2');
        $test->assert_equals ($nl-><M::NodeList.item> (2), $t3);

        $test->id ('item.-1');
        $test->assert_null ($nl-><M::NodeList.item> (-1));

        $test->id ('item.3');
        $test->assert_null ($nl-><M::NodeList.item> (3));

  @enImplNote:
    @@ddid:todo
    @@@:
      {TODO::
        normalize in DOM1,
        setIdAttribute, setIdAttributeNS, setIdAttributeNode
      }
##Element

ForDef:
  @QName: tc|ForSelect
  @enDesc:
    For selecting an attribute node for the purpose other than
    removing the node.
  @ISA: ManakaiDOM|ForClass

ForDef:
  @QName: tc|ForRemove
  @enDesc:
    For selecting an attribute node for the purpose of removing.
  @ISA: ManakaiDOM|ForClass

NodeTypeDef:
  @IFQName: Attr
  @ClsQName: ManakaiDOMAttr
  
  @enDesc:
    An <IF::Attr> object represents an attribute that can be attached
    on an <IF::Element> object.

      {NOTE::
         Typically the allowable values for the attribute are
         defined in a schema associated with the document.
      }

    Since <IF::Attr> nodes are not actually child nodes of the
    element they describes, the DOM does not consisder them part
    of the document tree.  Thus, DOM attributes <A::Node.parentNode>,
    <A::Node.previousSibling>, and <A::Node.nextSibling> have a 
    <DOM::null> value for <IF::Attr> nodes.  The DOM takes the view
    that attributes are properties of elements rather than having
    a separate identity from the elements they are associated with.
    Developers of applications and implementations need to be aware
    that <IF::Attr> nodes have some things in common with other objects
    inheriting the <IF::Node> interface, but they are quite distinct.
  @enImplNote:
    @@ddid: eff
    @@@:
      {NOTE::
        Then why the DOM allows <IF::Attr> nodes that are not
        attached to any <IF::Element> node?  Why it allows 
        <IF::Attr> nodes having child nodes rather than
        they themselves containing value as in <IF::CharacterData>,
        <IF::tx|ProcessingInstruction>, or WinIE6's 
        <IF::Attr> implementation?
      }
  @enDesc:
    @@ddid: effval
    @@@:
      {ps:: <doc:caption::Specified and Default Values>

        {P:: The attribute's <DFN::effective value> is determined as follows:

           = If the attribute has been explicitly assigned any value,
             that value is the attribute's effective value.

           = Otherwise, if there is a declaration for the attribute,
             and that declaration includes a default value, then
             that default value is the attribute's effective value.

           = Otherwise, the attribute does not exist on the element
             in the structure model until it has been explicitly added.
      
        }

        The <A::Node.nodeValue> attribute on the <IF::Attr> node
        can be used to retrieve the string version of the attribute's
        value.

        If the attribute was not explicitly given a value in the 
        instance document but has a default value provided by
        the schema associated with the document, an attribute node
        will be created with <A::Attr.specified> set to <DOM::false>.

        Removing attribute nodes for which a default value is defined
        in the schema generates a new attribute node with the
        default value and <A::Attr.specified> set to <DOM::false>.

        If validation occurred while invoking <M::Document.normalizeDocument>,
        attribute node with <A::Node.specified> equals to <DOM::false>
        are recomputed according to the default attribute values 
        provided by the schema.

      }

      {ps:: <doc:caption::Attribute Type and Normalization>

        In XML, where the value of an attribute can contain entity
        references, the child nodes of the <IF::Attr> node may
        be either <IF::Text> or <IF::tx|EntityReference> nodes.

        The DOM Core represents all attribute values as simple
        strings, even if the DTD or schema associated with the
        document declares them of some specific type such as
        tokenized type.

        The way attribute value normalization is performed by the
        DOM implementation depends on how much the implementation
        knows about the schema in use.  <SRC::DOM3>

        Typically, the <A::Attr.value> and <A::Node.nodeValue> attributes of
        an <IF::Attr> node initially contains the normalized value given by
        the parser.  It is also the case after <M::Document.normalizeDocument>
        is called (assugming the right configuration parameters
        have been set).  <SRC::DOM3>

        However, this may not be the case after mutation,
        independently of whether the mutation is performed by
        setting the string value directly or by changing the
        <IF::Attr> child nodes.  In particular, this is true when
        character references, which are not represented in the DOM
        and impact attribute value normalization, are involved.  <SRC::DOM3>

        On the other hand, if the implementation knows about the schema
        in use when the attribute value is changed, and it is of a 
        different type than <XML::CDATA>, it may normalize it
        again at that time.  This is especially true of specialized
        DOM implementations, such as SVG DOM implementations, which
        store attribute values in an internal form different from
        a string.  <SRC::DOM3>

      }

  @IntMethod:
    @@Operator: mg|CreateNodeStemMethod
    @@Param:
      @@@Name: bag
      @@@Type: HASH
    @@Param:
      @@@Name: obj
      @@@Type: HASH
    @@Param:
      @@@Name: opt
      @@@Type: HASH
    @@Return:
      @@@Type: HASH
      @@@PerlDef:
        $obj->{<H::infoset|children>} = [];
        __CODE{DISPerl|HashStringRef||ManakaiDOM|all::
          $result => {$obj->{<H::infoset|namespaceName>}},
          $given => {${$opt->{<H::infoset|namespaceName>}}},
        }__;
        __CODE{DISPerl|HashStringRef||ManakaiDOM|all::
          $result => {$obj->{<H::infoset|prefix>}},
          $given => {${$opt->{<H::infoset|prefix>}}},
        }__;
        __CODE{DISPerl|HashStringRef||ManakaiDOM|all::
          $result => {$obj->{<H::infoset|localName>}},
          $given => {${$opt->{<H::infoset|localName>}}},
        }__;
        $obj->{<H::infoset|specified>} = $opt->{<H::infoset|specified>};
        __CODE{mg|setOwnerProp||ManakaiDOM|all::
          $bag => $bag,
          $ownerref => {$opt->{<H::tc|ownerDocument>}},
          $ownee1hprop => {<H::tc|revOwnerDocument>},
          $ownee => {$obj},
          $owner0prop => {<H::tc|ownerDocument>},
        }__;
        $r = $obj;
  @mg:subnode1a: infoset|children
  @mg:owner0: tc|ownerDocument
  @mg:origin0: infoset|ownerElement

  @CODE:
    @@QName: tc|createAttrForTest
    @@PerlDef:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
      $attr = $doc-><M::Document.createAttributeNS>
                      ('http://www.example.net/', 'ex:element');

  @CAttr:
    @@Name: nodeType
    @@Type: unsignedShort
    @@dis:actualType: NodeType
    @@Get:
      @@@disDef:
        @@@@DISLang:constValue: Node.ATTRIBUTE_NODE

    @@Test:
      @@@QName: Attr.nodeType.test
      @@@PerlDef:
        my $attr;
        __CODE{tc|createAttrForTest:: $attr => $attr}__;

        $test->id ('nodeType');
        $test->assert_num_equals
                 (actual_value => $attr-><AG::Node.nodeType>,
                  expected_value => <C::Node.ATTRIBUTE_NODE>);

  @CL2Attr:
    @@Name: prefix
    @@enDesc:
      The namespace prefix of the node.
    @@DOMMain:isNamespaceAware:1
    @@Type: DOMString
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          If the namespace prefix is unspecified.
      @@@PerlDef:
        my $v;
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $v,
          $prop => {<H::infoset|prefix>},
          $ref => $self,
        }__;
        $r = defined $v ? $$v : null;
    @@Set:
      @@@nullCase:
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_BAD_NAME
        @@@@enDesc:
          If the specified value contains an illegal character according to
          the XML version in use specified in the <A::Document.xmlVersion>
          attribute.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the node is read-only.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_NS_BAD_NCNAME
        @@@@enDesc:
          If the specified prefix is malformed per the XML Namespaces
          specification.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_NS_PREFIX_WITH_NULL_URI
        @@@@enDesc:
          If the <A::Node.namespaceURI> of the node is <DOM::null>.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_NS_XML_WITH_OTHER_URI
        @@@@enDesc:
          If the specified prefix is <XML::xml> and
          the <A::Node.namespaceURI> of the node is different
          from <URI::http://www.w3.org/XML/1998/namespace>.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_NS_XMLNS_WITH_OTHER_URI
        @@@@enDesc:
          If the node is an attribute and the specified prefix
          is <XML::xmlns> and the <A::Node.namespaceURI> of the node
          is different from <URI::http://www.w3.org/2000/xmlns/>.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_NS_QNAME_IS_XMLNS
        @@@@enDesc:
          If the node is an attribute and the qualified name
          of the node is <XML::xmlns>.
      @@@PerlDef:
        my $od = $self-><AG::Node.ownerDocument>;
        if ($od-><AG::Document.strictErrorChecking>) {
          __CODE{tc|NodeReadOnlyError:: $node => $self}__;
          my $nsuri;
          __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
            $r => $nsuri,
            $prop => {<H::infoset|namespaceName>},
            $ref => $self,
          }__;
          if (not defined $nsuri) {
            __EXCEPTION{MDOMX|MDOM_NS_PREFIX_WITH_NULL_URI::
              infoset|prefix => {$given},
              infoset|namespaceName => {null},
            }__;
          } elsif ($$nsuri ne <Q::xml:> and $given eq 'xml') {
            __EXCEPTION{MDOMX|MDOM_NS_XML_WITH_OTHER_URI::
              infoset|prefix => {$given},
              infoset|namespaceName => {$self-><AG::Node.namespaceURI>},
            }__;
          } elsif ($$nsuri ne <Q::xmlns:> and $given eq 'xmlns') {
            __EXCEPTION{MDOMX|MDOM_NS_XMLNS_WITH_OTHER_URI::
              infoset|prefix => {$given},
              infoset|namespaceName => {$self-><AG::Node.namespaceURI>},
            }__;
          } elsif ($self-><AG::Node.nodeName> eq 'xmlns') {
            __EXCEPTION{MDOMX|MDOM_NS_QNAME_IS_XMLNS::
              infoset|prefix => {$given},
              infoset|namespaceName => {$self-><AG::Node.namespaceURI>},
            }__;
          }
          my $version = $od-><AG::Document.xmlVersion>;
          __CODE{DOMMain:ensureNamespacePrefix::
            $INPUT => $given, $INPUT_PARAM_NAME => '',
            $XMLVERSION => $version,
          }__;
        } # strict
        my $v = defined $given ? \$given : null;
        __CODE{mg|setNodeStemPropValue||ManakaiDOM|all::
          $given => $v,
          $prop => {<H::infoset|prefix>},
          $ref => $self,
        }__;

    @@L2Test:
      @@@QName: Attr.localName.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createAttributeNS>
                         (null, 'el');

        $test->id ('localName');
        $test->assert_equals ($el-><AG::Node.localName>, 'el');

        $test->id ('namespaceURI');
        $test->assert_equals ($el-><AG::Node.namespaceURI>, null);

        $test->id ('prefix');
        $test->assert_equals ($el-><AG::Node.prefix>, null);

        $test->id ('prefix.set');
        $el-><AS::Node.prefix> ('pre');
        $test->assert_equals ($el-><AG::Node.prefix>, 'pre');

    @@L2Test:
      @@@QName: Attr.localName.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createAttributeNS>
                         ('http://www.ns.example/', 'p:el');

        $test->id ('localName');
        $test->assert_equals ($el-><AG::Node.localName>, 'el');

        $test->id ('namespaceURI');
        $test->assert_equals ($el-><AG::Node.namespaceURI>,
                              'http://www.ns.example/');

        $test->id ('prefix');
        $test->assert_equals ($el-><AG::Node.prefix>, 'p');

        $test->id ('prefix.set');
        $el-><AS::Node.prefix> ('pre');
        $test->assert_equals ($el-><AG::Node.prefix>, 'pre');

    @@L2Test:
      @@@QName: Attr.prefix.1.test
      @@@enDesc:
        <M::Document.createAttributeNS> node with no namespace URI,
        no prefix.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createAttributeNS> (null, 'el');

        $test->id ('get');
        $test->assert_null ($el-><AG::Node.prefix>);

        $test->id ('set');
        $test->assert_exception (code => sub {
          $el-><AS::Node.prefix> ('prefix');
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);
        $test->assert_null ($el-><AG::Node.prefix>);

        $test->id ('reset');
        $test->assert_exception (code => sub {
          $el-><AS::Node.prefix> (null);
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);
        $test->assert_null ($el-><AG::Node.prefix>);

    @@L2Test:
      @@@QName: Attr.prefix.2.test
      @@@enDesc:
        <M::Document.createAttribute> node.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createAttribute> ('el');

        $test->id ('get');
        $test->assert_null ($el-><AG::Node.prefix>);

        $test->id ('set');
        $test->assert_exception (code => sub {
          $el-><AS::Node.prefix> ('prefix');
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);
        $test->assert_null ($el-><AG::Node.prefix>);

        $test->id ('reset');
        $test->assert_exception (code => sub {
          $el-><AS::Node.prefix> (null);
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);
        $test->assert_null ($el-><AG::Node.prefix>);

    @@L2Test:
      @@@QName: Attr.prefix.4.test
      @@@enDesc:
        <M::Document.createAttributeNS> node with namespace URI and prefix.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createAttributeNS>
                         ('http://www.dom.test/', 'p:el');

        $test->id ('get');
        $test->assert_equals ($el-><AG::Node.prefix>, 'p');

        $test->id ('set');
        $el-><AS::Node.prefix> ('prefix');
        $test->assert_equals ($el-><AG::Node.prefix>, 'prefix');

        $test->id ('reset');
        $el-><AS::Node.prefix> (null);
        $test->assert_equals ($el-><AG::Node.prefix>);

    @@L2Test:
      @@@QName: Attribute.prefix.5.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createAttributeNS>
                         ('http://www.dom.test/', 'p:el');

        $el-><M::Node.manakaiSetReadOnly> (true);

        $test->id ('set');
        $test->assert_exception (code => sub {
          $el-><AS::Node.prefix> ('new-prefix');
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);

    @@L2Test:
      @@@QName: Attr.prefix.6.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createAttributeNS>
                         ('http://www.dom.test/', 'p:el');

        $el-><M::Node.manakaiSetReadOnly> (true);

        $test->id ('set');
        $test->assert_exception (code => sub {
          $el-><AS::Node.prefix> ('0120');
        }, exception_subtype => <Q::MDOMX|MDOM_BAD_NAME>);

    @@L2Test:
      @@@QName: Attr.prefix.7.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createAttributeNS>
                         ('http://www.dom.test/', 'p:el');

        $el-><M::Node.manakaiSetReadOnly> (true);

        $test->id ('set');
        $test->assert_exception (code => sub {
          $el-><AS::Node.prefix> ('a:b');
        }, exception_subtype => <Q::MDOMX|MDOM_NS_BAD_NCNAME>);

    @@enImplNote:
      @@@ddid: moretest
      @@@@:
        {TODO::
          More tests for namespace errors and XML 1.1 error are necessary.
        }

  @Test:
    @@QName: Attr.parentNode.1.test
    @@PerlDef:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

      my $el = $doc-><M::Document.createAttributeNS>
                       ('http://www.ns.example/', 'p:el');

      $test->assert_null ($el-><AG::Node.parentNode>);

  @Test:
    @@QName: Attr.isSameNode.1.test
    @@PerlDef:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

      my $el = $doc-><M::Document.createAttributeNS>
                       ('http://www.ns.example/', 'p:el');

      my $el2 = $doc-><M::Document.createAttributeNS>
                       ('http://www.ns.example/', 'p:el');
      
      $test->id ('same');
      $test->assert_equals ($el, $el);
      
      $test->id ('diff');
      $test->assert_not_equals ($el, $el2);
      
      $test->id ('doc');
      $test->assert_not_equals ($el, $doc);
  @Test:
    @@QName: Attr.isSameNode.2.test
    @@PerlDef:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

      my $el = $doc-><M::Document.createAttributeNS>
                       ('http://www.ns.example/', 'p:el');

      my $el2 = $doc-><M::Document.createAttributeNS>
                       ('http://www.ns.example/', 'p:el');
      
      $test->id ('same');
      $test->assert_true ($el-><M::Node.isSameNode> ($el));
      
      $test->id ('diff');
      $test->assert_false ($el-><M::Node.isSameNode> ($el2));
      
      $test->id ('doc');
      $test->assert_false ($el-><M::Node.isSameNode> ($doc));

  @LXTest:
    @@QName: Attr.readOnly.test
    @@PerlDef:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

      my $el = $doc-><M::Document.createAttributeNS> (null, 'el');

      $test->id ('default');
      $test->assert_false ($el-><AG::Node.manakaiReadOnly>);

  @CMethod:
    @@Name: appendChild
    @@enDesc:
      Adds a node to the end of the list of children of the node.
      If that node is already in the tree, it is first removed.
    @@Param:
      @@@Name: newChild
      @@@Type: Node
      @@@enDesc:
        The node to add.
      @@@InCase:
        @@@@Type: DocumentFragment
        @@@@enDesc:
          The entire contents of the document fragment are
          moved into the child list of the node.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node added.  If the <P::newChild> node is a <IF::DocumentFragment>
        node, then the <P::newChild> node <kwd:MUST> be returned.
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_BAD_TYPE
        @@@@enDesc:
          If the node is of a type that does not allow children of
          the type of the <P::newChild> node.
 
          If the <A::Document.strictErrorChecking> is set to <DOM::false>,
          this exception <kwd:MAY-NOT> be thrown.
      @@@dx:raises:
        @@@@@: c|DIFFERENT_DOCUMENT_ERR
        @@@@enDesc:
          If the <P::newChild> node was created from a different
          document than the one to which the node was created or
          the node does not belong to any document.

          If the <A::Document.strictErrorChecking> is set to <DOM::false>,
          this exception <kwd:MAY-NOT> be thrown.
      @@@dx:raises: 
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the node is read-only.

          If the <A::Document.strictErrorChecking> is set to <DOM::false>,
          this exception <kwd:MAY-NOT> be thrown.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_SRC_PARENT
        @@@@enDesc:
          If the previous parent of the <P::newChild> node is read-only
          <SRC::DOM 2 Errata, DOM 3>.

          If the <A::Document.strictErrorChecking> is set to <DOM::false>,
          this exception <kwd:MAY-NOT> be thrown.
      @@@PerlDef:
        my $self_od = $self-><AG::Node.ownerDocument>;
        my $child_od = $newChild-><AG::Node.ownerDocument>;
        my $child_nt = $newChild-><AG::Node.nodeType>;
        __CODE{tc|appendChildImpl1::
          $self => $self, $self_od => $self_od,
          $newChild => $newChild, $child_od => $child_od, $child_nt => $child_nt,
          $r => $r,
          $allowedNodeTypes => {{
            <C::Node.TEXT_NODE> => true,
            <C::Node.ENTITY_REFERENCE_NODE> => true,
          }},
        }__;

  @CMethod:
    @@Name: insertBefore
    @@enDesc:
      Inserts a node before the existing child node of the node.

      Inserting a node before itself is implementation dependent.
    @@Param:
      @@@Name: newChild
      @@@Type: Node
      @@@enDesc:
        The node to insert.  If the <P::newChild> is already in 
        the tree, it is first removed.
      @@@InCase:
        @@@@Type: DocumentFragment
        @@@@enDesc:
          All of children of the <P::newChild> node are inserted,
          in the same order, before <P::refChild>.
    @@Param:
      @@@Name: refChild
      @@@Type: Node
      @@@enDesc:
        The reference node, i.e. the node before which the new node
        must be inserted.
      @@@nullCase:
        @@@@enDesc:
          The <P::newChild> node is inserted at the end of the list
          of children.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node being inserted.
      @@@enImplNote:
        What is returned if <P::newChild> is a <IF::DocumentFragment>?
        See also <M::Node.appendChild>'s return value.
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_BAD_TYPE
        @@@@enDesc:
          If the node is of a type that does not allow children of
          the type of the <P::newChild> node.
      @@@dx:raises:
        @@@@@: c|DIFFERENT_DOCUMENT_ERR
        @@@@enDesc:
          If the <P::newChild> node was created from a different
          document than the one that created the node.
        @@@@enImplNote:
          The DOM specification ignores the fact that <IF::Document>s
          and <IF::x|DocumentType>s are created from 
          <IF::c|DOMImplementation> :-)
      @@@dx:raises: 
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the node is read-only.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_SRC_PARENT
        @@@@enDesc:
          If the previous parent of the <P::newChild> node is read-only
          <SRC::DOM 1 SE, DOM 2, 3>.
      @@@dx:raises:
        @@@@@: c|NOT_CHILD_ERR
        @@@@enDesc:
          If the <P::refChild> node is not a child of the node.
      @@@c:reports:
        @@@@@: t|insert-before-itself
        @@@@enDesc:
          If the <P::newChild> node is same as the <P::refChild> node.
          Then, the result is implementation dependent.
        @@@@For: ManakaiDOM|ManakaiDOM
      @@@PerlDef:
        my $self_od = $self-><AG::Node.ownerDocument>;
        my $child_od = $newChild-><AG::Node.ownerDocument>;
        my $child_nt = $newChild-><AG::Node.nodeType>;
        __CODE{tc|insertBeforeImpl1::
          $self => $self, $self_od => $self_od,
          $newChild => $newChild, $refChild => $refChild,
          $child_od => $child_od, $child_nt => $child_nt,
          $r => $r,
          $allowedNodeTypes => {{
            <C::Node.TEXT_NODE> => true,
            <C::Node.ENTITY_REFERENCE_NODE> => true,
          }},
        }__;

  @CMethod:
    @@Name: replaceChild
    @@enDesc:
      Replaces a child node with another node.

      Replacing a node with itself is implementation dependent <SRC::DOM3>.
    @@Param:
      @@@Name: newChild
      @@@Type: Node
      @@@enDesc:
        The new node to put in the child list.

        If the <P::newChild> node is already in the tree,
        it is first removed.
      @@@InCase:
        @@@@Type: DocumentFragment
        @@@@enDesc:
          The <P::oldChild> node is replaced by all of the 
          <IF::DocumentFragment> children, which are inserted
          in the same order <SRC::DOM1 SE, DOM2, DOM3>.
    @@Param:
      @@@Name: oldChild
      @@@Type: Node
      @@@enDesc:
        The node being replaced in the list.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node replaced.
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_BAD_TYPE
        @@@@enDesc:
          If the node is of a type that does not allow children of
          the type of the <P::newChild> node.
      @@@dx:raises:
        @@@@@: c|DIFFERENT_DOCUMENT_ERR
        @@@@enDesc:
          If the <P::newChild> node was created from a different
          document than the one that created the node.
        @@@@enImplNote:
          The DOM specification ignores the fact that <IF::Document>s
          and <IF::x|DocumentType>s are created from 
          <IF::c|DOMImplementation> :-)
      @@@dx:raises: 
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the node is read-only.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_SRC_PARENT
        @@@@enDesc:
          If the previous parent of the <P::newChild> node is read-only
          <SRC::DOM1 SE, DOM2, DOM3>.
      @@@dx:raises:
        @@@@@: c|NOT_CHILD_ERR
        @@@@enDesc:
          If the <P::oldChild> node is not a child of the node.
      @@@c:reports:
        @@@@@: t|replaced-by-itself
        @@@@enDesc:
          If the <P::newChild> node is same as the <P::oldChild> node.
          Then, the result is implementation dependent.
        @@@@For: ManakaiDOM|ManakaiDOM
      @@@PerlDef:
        my $self_od = $self-><AG::Node.ownerDocument>;
        my $child_od = $newChild-><AG::Node.ownerDocument>;
        my $child_nt = $newChild-><AG::Node.nodeType>;
        __CODE{tc|replaceChildImpl1::
          $self => $self, $self_od => $self_od,
          $newChild => $newChild, $refChild => $oldChild,
          $child_od => $child_od, $child_nt => $child_nt,
          $r => $r,
          $allowedNodeTypes => {{
            <C::Node.TEXT_NODE> => true,
            <C::Node.ENTITY_REFERENCE_NODE> => true,
          }},
        }__;

  @CAttr:
    @@Name: nodeName
    @@enDesc:
      The node name.
    @@DOMMain:isNamespaceUnaware:1
    @@Type: DOMString
    @@Get:
      @@@enDesc:
        Same as <A::Attr.name>.
      @@@disDef:
        @@@@DISPerl:cloneCode: .name.get

  @Attr:
    @@Name: name
    @@enDesc:
      The name of the attribute.
    @@enDesc:
      @@@ddid: ns
      @@@@:
        If the <A::Node.localName> of the node is different from
        <DOM::null>, then the attribute value is the qualified name
        of the attribute node.  <SRC::DOM3>
    @@Type: DOMString
    @@Get:
      @@@PerlDef:
        my $prefix;
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $prefix,
          $prop => {<H::infoset|prefix>},
          $ref => $self,
        }__;
        my $lname;
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $lname,
          $prop => {<H::infoset|localName>},
          $ref => $self,
        }__;
        $r = defined $prefix ? $prefix.':'.$lname : $lname;
    @@enImplNote:
      {ISSUE::
        In HTML?
      }

      {NOTE::
        DOM Level 1 nodes are no longer supported.
      }

    @@Test:
      @@@QName: Attr.nodeName.name.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createAttribute> ('element1');

        $test->id ('nodeName');
        $test->assert_equals ($el-><AG::Node.nodeName>, 'element1');

        $test->id ('name');
        $test->assert_equals ($el-><AG::Attr.name>, 'element1');

    @@Test:
      @@@QName: Attr.nodeName.name.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createAttributeNS> (null, 'element1');

        $test->id ('nodeName');
        $test->assert_equals ($el-><AG::Node.nodeName>, 'element1');

        $test->id ('name');
        $test->assert_equals ($el-><AG::Attr.name>, 'element1');

    @@Test:
      @@@QName: Attr.nodeName.name.3.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createAttributeNS>
                         ('http://el1.test/', 'element1');

        $test->id ('nodeName');
        $test->assert_equals ($el-><AG::Node.nodeName>, 'element1');

        $test->id ('name');
        $test->assert_equals ($el-><AG::Attr.name>, 'element1');

    @@Test:
      @@@QName: Attr.nodeName.name.4.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createAttributeNS>
                         ('http://el1.test/', 'pfx:element1');

        $test->id ('nodeName');
        $test->assert_equals ($el-><AG::Node.nodeName>, 'pfx:element1');

        $test->id ('name');
        $test->assert_equals ($el-><AG::Attr.name>, 'pfx:element1');

  @CAttr:
    @@Name: nodeValue
    @@enDesc:
      The value of the node.
    @@Type: DOMString
    @@Get:
      @@@PerlDef:
        __DEEP{
          $r = $self-><AG::Attr.value>;
        }__;
    @@Set:
      @@@NodeReadOnlyError:
      @@@PerlDef:
        __DEEP{
          $self-><AS::Attr.value> ($given);
        }__;

    @@Test:
      @@@QName: Attr.appendChild.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createAttribute> ('dt');
        my $pi = $doc-><M::Document.createTextNode> ('pi');

        my $return = $dtd-><M::Node.appendChild> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: Attr.appendChild.1.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createAttribute> ('dt');
        my $pi = $doc-><M::Document.createEntityReference> ('pi');

        my $return = $dtd-><M::Node.appendChild> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|EntityReference>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: Attr.insertBefore.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createAttribute> ('dt');
        my $pi = $doc-><M::Document.createTextNode> ('pi');

        my $return = $dtd-><M::Node.insertBefore> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: Attr.insertBefore.1.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createAttribute> ('dt');
        my $pi = $doc-><M::Document.createEntityReference> ('pi');

        my $return = $dtd-><M::Node.insertBefore> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|EntityReference>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);

    @@Test:
      @@@QName: Attr.appendChild.has.parent.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createAttribute> ('dt');

        my $piparent = $doc-><M::Document.createElementNS> (null, 'e');
        my $pi = $doc-><M::Document.createTextNode> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.appendChild> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: Attr.appendChild.has.parent.1.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createAttribute> ('dt');

        my $piparent = $doc-><M::Document.createElementNS> (null, 'e');
        my $pi = $doc-><M::Document.createEntityReference> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.appendChild> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|EntityReference>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: Attr.insertBefore.has.parent.1.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createAttribute> ('dt');

        my $piparent = $doc-><M::Document.createElementNS> (null, 'e');
        my $pi = $doc-><M::Document.createTextNode> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.insertBefore> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: Attr.insertBefore.has.parent.1.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createAttribute> ('dt');

        my $piparent = $doc-><M::Document.createElementNS> (null, 'e');
        my $pi = $doc-><M::Document.createEntityReference> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.insertBefore> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|EntityReference>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi);

    @@Test:
      @@@QName: Attr.appendChild.documentfragment.1.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createAttribute> ('dt');

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createTextNode> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.appendChild> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: Attr.appendChild.documentfragment.1.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createAttribute> ('dt');

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createEntityReference> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.appendChild> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|EntityReference>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: Attr.insertBefore.documentfragment.1.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createAttribute> ('dt');

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createTextNode> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.insertBefore> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: Attr.insertBefore.documentfragment.1.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createAttribute> ('dt');

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createEntityReference> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.insertBefore> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|EntityReference>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: Attr.replaceChild.documentfragment.1.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createAttribute> ('dt');
        my $pi0 = $doc-><M::Document.createTextNode> ('pi0');
        $dtd-><M::Node.appendChild> ($pi0);

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createTextNode> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.replaceChild> ($piparent, $pi0);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi0);
    @@Test:
      @@@QName: Attr.replaceChild.documentfragment.1.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createAttribute> ('dt');
        my $pi0 = $doc-><M::Document.createTextNode> ('pi0');
        $dtd-><M::Node.appendChild> ($pi0);

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createEntityReference> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.replaceChild> ($piparent, $pi0);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::tc|NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|EntityReference>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi0);

    @@Test:
      @@@QName: Attr.appendChild.documentfragment.2.1.test
      @@@enDesc:
        Empty document fragment.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createAttribute> ('dt');

        my $piparent = $doc-><M::Document.createDocumentFragment>;

        my $return = $dtd-><M::Node.appendChild> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 0);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: Attr.insertBefore.documentfragment.2.test
      @@@enDesc:
        Empty document fragment.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createAttribute> ('dt');

        my $piparent = $doc-><M::Document.createDocumentFragment>;

        my $return = $dtd-><M::Node.insertBefore> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 0);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: Attr.replaceChild.documentfragment.2.test
      @@@enDesc:
        Empty document fragment.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createAttribute> ('dt');
        my $pi0 = $doc-><M::Document.createTextNode> ('pi0');
        $dtd-><M::Node.appendChild> ($pi0);

        my $piparent = $doc-><M::Document.createDocumentFragment>;

        my $return = $dtd-><M::Node.replaceChild> ($piparent, $pi0);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 0);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi0);

    @@Test:
      @@@QName: Attr.appendChild.documentfragment.3.test
      @@@enDesc:
        Three PIs in document fragment.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createAttribute> ('dt');

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createTextNode> ('pi');
        my $pi2 = $doc-><M::Document.createEntityReference> ('pi2');
        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $piparent-><M::Node.appendChild> ($pi);
        $piparent-><M::Node.appendChild> ($pi2);
        $piparent-><M::Node.appendChild> ($pi3);

        my $return = $dtd-><M::Node.appendChild> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 3);

        my $item = $child-><M::tc|NodeList.item> (0);
        my $item2 = $child-><M::tc|NodeList.item> (1);
        my $item3 = $child-><M::tc|NodeList.item> (2);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);
        $test->id ('child.item.node2');
        $test->assert_isa ($item2, <IFName::Node>);
        $test->id ('child.item.node3');
        $test->assert_isa ($item3, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);
        $test->id ('child.item.pi2');
        $test->assert_isa ($item2, <IFName::tx|EntityReference>);
        $test->id ('child.item.pi3');
        $test->assert_isa ($item3, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);
        $test->id ('child.item.equals2');
        $test->assert_equals ($item2, $pi2);
        $test->id ('child.item.equals3');
        $test->assert_equals ($item3, $pi3);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi3);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);
        $test->id ('parent2');
        my $parent2 = $item2-><AG::Node.parentNode>;
        $test->assert_equals ($parent2, $dtd);
        $test->id ('parent3');
        my $parent3 = $item3-><AG::Node.parentNode>;
        $test->assert_equals ($parent3, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: Attr.insertBefore.documentfragment.3.test
      @@@enDesc:
        Three PIs in document fragment.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createAttribute> ('dt');

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createTextNode> ('pi');
        my $pi2 = $doc-><M::Document.createEntityReference> ('pi2');
        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $piparent-><M::Node.appendChild> ($pi);
        $piparent-><M::Node.appendChild> ($pi2);
        $piparent-><M::Node.appendChild> ($pi3);

        my $return = $dtd-><M::Node.insertBefore> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 3);

        my $item = $child-><M::tc|NodeList.item> (0);
        my $item2 = $child-><M::tc|NodeList.item> (1);
        my $item3 = $child-><M::tc|NodeList.item> (2);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);
        $test->id ('child.item.node2');
        $test->assert_isa ($item2, <IFName::Node>);
        $test->id ('child.item.node3');
        $test->assert_isa ($item3, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);
        $test->id ('child.item.pi2');
        $test->assert_isa ($item2, <IFName::tx|EntityReference>);
        $test->id ('child.item.pi3');
        $test->assert_isa ($item3, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);
        $test->id ('child.item.equals2');
        $test->assert_equals ($item2, $pi2);
        $test->id ('child.item.equals3');
        $test->assert_equals ($item3, $pi3);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi3);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);
        $test->id ('parent2');
        my $parent2 = $item2-><AG::Node.parentNode>;
        $test->assert_equals ($parent2, $dtd);
        $test->id ('parent3');
        my $parent3 = $item3-><AG::Node.parentNode>;
        $test->assert_equals ($parent3, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: Attr.replaceChild.documentfragment.3.test
      @@@enDesc:
        Three PIs in document fragment.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createAttribute> ('dt');
        my $pi0 = $doc-><M::Document.createTextNode> ('pi0');
        $dtd-><M::Node.appendChild> ($pi0);

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createTextNode> ('pi');
        my $pi2 = $doc-><M::Document.createEntityReference> ('pi2');
        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $piparent-><M::Node.appendChild> ($pi);
        $piparent-><M::Node.appendChild> ($pi2);
        $piparent-><M::Node.appendChild> ($pi3);

        my $return = $dtd-><M::Node.replaceChild> ($piparent, $pi0);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 3);

        my $item = $child-><M::tc|NodeList.item> (0);
        my $item2 = $child-><M::tc|NodeList.item> (1);
        my $item3 = $child-><M::tc|NodeList.item> (2);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);
        $test->id ('child.item.node2');
        $test->assert_isa ($item2, <IFName::Node>);
        $test->id ('child.item.node3');
        $test->assert_isa ($item3, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);
        $test->id ('child.item.pi2');
        $test->assert_isa ($item2, <IFName::tx|EntityReference>);
        $test->id ('child.item.pi3');
        $test->assert_isa ($item3, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);
        $test->id ('child.item.equals2');
        $test->assert_equals ($item2, $pi2);
        $test->id ('child.item.equals3');
        $test->assert_equals ($item3, $pi3);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi3);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);
        $test->id ('parent2');
        my $parent2 = $item2-><AG::Node.parentNode>;
        $test->assert_equals ($parent2, $dtd);
        $test->id ('parent3');
        my $parent3 = $item3-><AG::Node.parentNode>;
        $test->assert_equals ($parent3, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi0);

    @@Test:
      @@@QName: Attr.appendChild.badtype.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $comment = $doc-><M::Document.createAttribute> ('data');
        my $pi0 = $doc-><M::Document.createTextNode> ('pi0');
        $comment-><M::Node.appendChild> ($pi0);

        for my $node (
          $docx-><M::d|DocumentXDoctype.createDocumentTypeDefinition> ('d'),
          $doc-><M::Document.createProcessingInstruction> ('ent'),
          $doc-><M::Document.createElement> ('e'),
          $doc-><M::Document.createAttribute> ('a'),
          $doc-><M::Document.createComment> ('c'),
          $doc-><M::Document.createCDATASection> ('cs'),
          $docx-><M::d|DocumentXDoctype.createGeneralEntity> ('ge'),
          $docx-><M::d|DocumentXDoctype.createNotation> ('not'),
          $docx-><M::d|DocumentXDoctype.createElementTypeDefinition> ('et'),
          $docx-><M::d|DocumentXDoctype.createAttributeDefinition> ('at'),
          #test:nodeTypes
        ) {
          $test->id ('appendChild.'.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.appendChild> ($node);
          }, exception_subtype => <Q::MDOMX|HIERARCHY_BAD_TYPE>);

          $test->id ('insertBefore.'.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.insertBefore> ($node);
          }, exception_subtype => <Q::MDOMX|HIERARCHY_BAD_TYPE>);

          $test->id ('replaceChild.'.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.replaceChild> ($node, $pi0);
          }, exception_subtype => <Q::MDOMX|HIERARCHY_BAD_TYPE>);
        }

    @@Test:
      @@@QName: Attr.appendChild.wrongdoc.test
      @@@PerlDef:
        my $doc0;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc0}__;

        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $comment = $doc0-><M::Document.createAttribute> ('data');

        for my $node (
          $doc-><M::Document.createTextNode> ('pi'),
          $doc-><M::Document.createEntityReference> ('e'),
        ) {
          $test->id ('type='.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.appendChild> ($node);
          }, exception_subtype => <Q::c|DIFFERENT_DOCUMENT_ERR>);
        }
    @@Test:
      @@@QName: Attr.insertBefore.wrongdoc.test
      @@@PerlDef:
        my $doc0;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc0}__;
        my $docx0 = $doc0-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $comment = $doc0-><M::Document.createAttribute> ('data');
        my $pi0 = $doc0-><M::Document.createTextNode> ('pi0');
        $comment-><M::Node.appendChild> ($pi0);

        for my $node (
          $doc-><M::Document.createTextNode> ('pi'),
          $doc-><M::Document.createEntityReference> ('ent'),
        ) {
          $test->id ('appendChild.'.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.appendChild> ($node);
          }, exception_subtype => <Q::c|DIFFERENT_DOCUMENT_ERR>);

          $test->id ('insertBefore.'.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.insertBefore> ($node);
          }, exception_subtype => <Q::c|DIFFERENT_DOCUMENT_ERR>);

          $test->id ('replaceChild.'.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.replaceChild> ($node, $pi0);
          }, exception_subtype => <Q::c|DIFFERENT_DOCUMENT_ERR>);
        }

    @@Test:
      @@@QName: Attr.appendChild.readonly.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createAttribute> ('d');
        my $pi0 = $doc-><M::Document.createTextNode> ('pi0');
        $dtd-><M::Node.appendChild> ($pi0);
        $dtd-><M::Node.manakaiSetReadOnly> (true);

        $test->id ('pi');
        my $node = $doc-><M::Document.createTextNode> ('pi');

        $test->assert_exception (code => sub {
          $dtd-><M::Node.appendChild> ($node);
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);

        $test->id ('pi.insertBefore');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.insertBefore> ($node);
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);

        $test->id ('pi.replaceChild');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.replaceChild> ($node, $pi0);
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);

        $test->id ('fragment');
        my $node2 = $doc-><M::Document.createDocumentFragment>;
        $node2-><M::Node.appendChild> ($node);

        $test->assert_exception (code => sub {
          $dtd-><M::Node.appendChild> ($node2);
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);

        $test->id ('fragment.insertBefore');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.insertBefore> ($node2);
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);

        $test->id ('fragment.replaceChild');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.replaceChild> ($node2, $pi0);
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);

    @@Test:
      @@@QName: Attr.appendChild.readonly.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createAttribute> ('d');
        my $pi0 = $doc-><M::Document.createTextNode> ('pi0');
        $dtd-><M::Node.appendChild> ($pi0);

        $test->id ('pi');
        my $el = $doc-><M::Document.createElementNS> (null, 'e');
        my $node = $doc-><M::Document.createTextNode> ('pi');
        $el-><M::Node.appendChild> ($node);
        $el-><M::Node.manakaiSetReadOnly> (true);

        $test->assert_exception (code => sub {
          $dtd-><M::Node.appendChild> ($node);
        }, exception_subtype => <Q::MDOMX|NOMOD_SRC_PARENT>);

        $test->id ('pi.insertBefore');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.insertBefore> ($node);
        }, exception_subtype => <Q::MDOMX|NOMOD_SRC_PARENT>);

        $test->id ('pi.replaceChild');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.replaceChild> ($node, $pi0);
        }, exception_subtype => <Q::MDOMX|NOMOD_SRC_PARENT>);

        $test->id ('fragment');
        my $node2 = $doc-><M::Document.createDocumentFragment>;
        my $node3 = $doc-><M::Document.createTextNode> ('pi');
        $node2-><M::Node.appendChild> ($node3);
        $node2-><M::Node.manakaiSetReadOnly> (true);

        $test->assert_exception (code => sub {
          $dtd-><M::Node.appendChild> ($node2);
        }, exception_subtype => <Q::MDOMX|NOMOD_SRC_PARENT>);

        $test->id ('fragment.insertBefore');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.insertBefore> ($node2);
        }, exception_subtype => <Q::MDOMX|NOMOD_SRC_PARENT>);

        $test->id ('fragment.replaceChild');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.replaceChild> ($node2, $pi0);
        }, exception_subtype => <Q::MDOMX|NOMOD_SRC_PARENT>);

    @@Test:
      @@@QName: Attr.insertBefore.refChild.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createAttribute> ('d');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.insertBefore> ($pi2, $pi1);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi2);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi1);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: Attr.insertBefore.refChild.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createAttribute> ('d');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $dtd-><M::Node.insertBefore> ($pi3, $pi2);

        # pi1, pi3, pi2

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi1);

        $test->id ('firstChild.nextSibling');
        $test->assert_equals ($dtd-><AG::Node.firstChild>
                                  -><AG::Node.nextSibling>, $pi3);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi2);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 3);

    @@Test:
      @@@QName: Attr.insertBefore.refChild.3.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createAttribute> ('d');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $dtd-><M::Node.appendChild> ($pi3);

        # pi1, pi2, pi3

        $dtd-><M::Node.insertBefore> ($pi2, $pi1);
 
        # pi2, pi1, pi3

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi2);

        $test->id ('firstChild.nextSibling');
        $test->assert_equals ($dtd-><AG::Node.firstChild>
                                  -><AG::Node.nextSibling>, $pi1);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi3);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 3);

    @@Test:
      @@@QName: Attr.insertBefore.refChild.4.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createAttribute> ('d');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $dtd-><M::Node.appendChild> ($pi3);

        # pi1, pi2, pi3

        $dtd-><M::Node.insertBefore> ($pi3, $pi1);
 
        # pi3, pi1, pi2

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi3);

        $test->id ('firstChild.nextSibling');
        $test->assert_equals ($dtd-><AG::Node.firstChild>
                                  -><AG::Node.nextSibling>, $pi1);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi2);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 3);

    @@Test:
      @@@QName: Attr.insertBefore.refChild.not_found_err.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createAttribute> ('d');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');

        my $pi4 = $doc-><M::Document.createTextNode> ('pi4');

        # pi1, pi2

        $test->assert_exception (code => sub {
          $dtd-><M::Node.insertBefore> ($pi4, $pi3);
        }, exception_subtype => <Q::c|NOT_CHILD_ERR>);

    @@Test:
      @@@QName: Attr.insertBefore.refChild=newChild.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createAttribute> ('d');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        # pi1, pi2

        my $eh_called = false;
        my $cfg = $doc-><AG::Document.domConfig>;
        $cfg-><M::c|DOMConfiguration.setParameter> ('error-handler' => sub {
          my (undef, $err) = @_;
          $eh_called = true;
          $test->assert_equals ($err-><AG::c|DOMError.severity>,
                                <C::c|DOMError.SEVERITY_WARNING>);
          $test->assert_equals ($err-><AG::c|DOMError.type>,
                                <Q::t|insert-before-itself>);
          $test->assert_equals ($err-><AG::c|DOMError.relatedData>, $pi2);
          $test->assert_null ($err-><AG::c|DOMError.relatedException>);
          $test->assert_isa ($err-><AG::c|DOMError.location>,
                             <IFName::c|DOMLocator>);
          $test->assert_not_null ($err-><AG::c|DOMError.message>);
        });

        $test->assert_false ($eh_called);
        $dtd-><M::Node.insertBefore> ($pi2, $pi2);
        $test->assert_true ($eh_called);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi1);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi2);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: Attr.replaceChild.oldChild=newChild.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createAttribute> ('d');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        # pi1, pi2

        my $eh_called = false;
        my $cfg = $doc-><AG::Document.domConfig>;
        $cfg-><M::c|DOMConfiguration.setParameter> ('error-handler' => sub {
          my (undef, $err) = @_;
          $eh_called = true;
          $test->assert_equals ($err-><AG::c|DOMError.severity>,
                                <C::c|DOMError.SEVERITY_WARNING>);
          $test->assert_equals ($err-><AG::c|DOMError.type>,
                                <Q::t|replace-by-itself>);
          $test->assert_equals ($err-><AG::c|DOMError.relatedData>, $pi2);
          $test->assert_null ($err-><AG::c|DOMError.relatedException>);
          $test->assert_isa ($err-><AG::c|DOMError.location>,
                             <IFName::c|DOMLocator>);
          $test->assert_not_null ($err-><AG::c|DOMError.message>);
        });

        $test->assert_false ($eh_called);
        $dtd-><M::Node.replaceChild> ($pi2, $pi2);
        $test->assert_true ($eh_called);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi1);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi2);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: Attr.appendChild.sameparent.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createAttribute> ('d');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        # pi1, pi2

        my $return = $dtd-><M::Node.appendChild> ($pi1);

        # pi2, pi1

        $test->id ('return');
        $test->assert_equals ($return, $pi1);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi2);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi1);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: Attr.insertBefore.sameparent.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createAttribute> ('d');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        # pi1, pi2

        my $return = $dtd-><M::Node.insertBefore> ($pi1);

        # pi2, pi1

        $test->id ('return');
        $test->assert_equals ($return, $pi1);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi2);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi1);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: Attr.appendChild.sameparent.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createAttribute> ('d');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        # pi1, pi2

        my $return = $dtd-><M::Node.appendChild> ($pi2);

        # pi1, pi2

        $test->id ('return');
        $test->assert_equals ($return, $pi2);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi1);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi2);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: Attr.insertBefore.sameparent.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createAttribute> ('d');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        # pi1, pi2

        my $return = $dtd-><M::Node.insertBefore> ($pi2);

        # pi1, pi2

        $test->id ('return');
        $test->assert_equals ($return, $pi2);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi1);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi2);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: Attr.replaceChild.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createAttribute> ('d');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $dtd-><M::Node.appendChild> ($pi3);

        # pi1, pi2, pi3

        my $pi9 = $doc-><M::Document.createTextNode> ('pi9');
        my $return = $dtd-><M::Node.replaceChild> ($pi9, $pi1);

        # pi9, pi2, pi3

        $test->id ('return.node');
        $test->assert_isa ($return, <IFName::Node>);
        $test->id ('return.pi');
        $test->assert_isa ($return, <IFName::Text>);
        $test->id ('return');
        $test->assert_equals ($return, $pi1);

        my $c = $dtd-><AG::Node.childNodes>;

        $test->id ('length');
        $test->assert_num_equals (actual_value => 0+@$c, expected_value => 3);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi9);

        $test->id ('firstChild.nextSibling');
        $test->assert_equals ($dtd-><AG::Node.firstChild>
                                  -><AG::Node.nextSibling>, $pi2);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi3);
 
        $test->id ('parent');
        $test->assert_equals ($pi9-><AG::Node.parentNode>, $dtd);

        $test->id ('return.parent');
        $test->assert_null ($pi1-><AG::Node.parentNode>);

    @@Test:
      @@@QName: Attr.replaceChild.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createAttribute> ('d');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $dtd-><M::Node.appendChild> ($pi3);

        # pi1, pi2, pi3

        my $pi9 = $doc-><M::Document.createTextNode> ('pi9');
        my $return = $dtd-><M::Node.replaceChild> ($pi9, $pi2);

        # pi1, pi9, pi3

        $test->id ('return.node');
        $test->assert_isa ($return, <IFName::Node>);
        $test->id ('return.pi');
        $test->assert_isa ($return, <IFName::Text>);
        $test->id ('return');
        $test->assert_equals ($return, $pi2);

        my $c = $dtd-><AG::Node.childNodes>;

        $test->id ('length');
        $test->assert_num_equals (actual_value => 0+@$c, expected_value => 3);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi1);

        $test->id ('firstChild.nextSibling');
        $test->assert_equals ($dtd-><AG::Node.firstChild>
                                  -><AG::Node.nextSibling>, $pi9);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi3);
 
        $test->id ('parent');
        $test->assert_equals ($pi9-><AG::Node.parentNode>, $dtd);

        $test->id ('return.parent');
        $test->assert_null ($pi2-><AG::Node.parentNode>);

    @@Test:
      @@@QName: Attr.replaceChild.3.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createAttribute> ('d');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $dtd-><M::Node.appendChild> ($pi3);

        # pi1, pi2, pi3

        my $pi9 = $doc-><M::Document.createTextNode> ('pi9');
        my $return = $dtd-><M::Node.replaceChild> ($pi9, $pi3);

        # pi1, pi2, pi9

        $test->id ('return.node');
        $test->assert_isa ($return, <IFName::Node>);
        $test->id ('return.pi');
        $test->assert_isa ($return, <IFName::Text>);
        $test->id ('return');
        $test->assert_equals ($return, $pi3);

        my $c = $dtd-><AG::Node.childNodes>;

        $test->id ('length');
        $test->assert_num_equals (actual_value => 0+@$c, expected_value => 3);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi1);

        $test->id ('firstChild.nextSibling');
        $test->assert_equals ($dtd-><AG::Node.firstChild>
                                  -><AG::Node.nextSibling>, $pi2);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi9);
 
        $test->id ('parent');
        $test->assert_equals ($pi9-><AG::Node.parentNode>, $dtd);

        $test->id ('return.parent');
        $test->assert_null ($pi3-><AG::Node.parentNode>);

    @@Test:
      @@@QName: Attr.replaceChild.sameparent.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createAttribute> ('d');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $dtd-><M::Node.appendChild> ($pi3);

        # pi1, pi2, pi3

        my $return = $dtd-><M::Node.replaceChild> ($pi3, $pi1);

        # pi3, pi2

        $test->id ('return.node');
        $test->assert_isa ($return, <IFName::Node>);
        $test->id ('return.pi');
        $test->assert_isa ($return, <IFName::Text>);
        $test->id ('return');
        $test->assert_equals ($return, $pi1);

        my $c = $dtd-><AG::Node.childNodes>;

        $test->id ('length');
        $test->assert_num_equals (actual_value => 0+@$c, expected_value => 2);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi3);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi2);
 
        $test->id ('parent');
        $test->assert_equals ($pi3-><AG::Node.parentNode>, $dtd);

        $test->id ('return.parent');
        $test->assert_null ($pi1-><AG::Node.parentNode>);

    @@Test:
      @@@QName: Attr.replaceChild.sameparent.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createAttribute> ('d');

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $dtd-><M::Node.appendChild> ($pi3);

        # pi1, pi2, pi3

        my $return = $dtd-><M::Node.replaceChild> ($pi1, $pi3);

        # pi2, pi1

        $test->id ('return.node');
        $test->assert_isa ($return, <IFName::Node>);
        $test->id ('return.pi');
        $test->assert_isa ($return, <IFName::Text>);
        $test->id ('return');
        $test->assert_equals ($return, $pi3);

        my $c = $dtd-><AG::Node.childNodes>;

        $test->id ('length');
        $test->assert_num_equals (actual_value => 0+@$c, expected_value => 2);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi2);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi1);
 
        $test->id ('parent');
        $test->assert_equals ($pi1-><AG::Node.parentNode>, $dtd);

        $test->id ('return.parent');
        $test->assert_null ($pi3-><AG::Node.parentNode>);

  @CMethod:
    @@Name: manakaiAppendText
    @@Param:
      @@@Name: string
      @@@Type: DOMString
      @@@enDesc:
        The string to append.
      @@@InCase:
        @@@@Type: DISPerl|SCALAR||ManakaiDOM|all
        @@@@enDesc:
          A copy of the string value referenced from the value
          is appended.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node itself.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the node to insert the string or a <IF::Text> node
          is read-only.
      @@@PerlDef:
        __DEEP{
          my $lc = $self-><AG::Node.lastChild>;
          if (defined $lc and
              $lc-><AG::Node.nodeType> == <C::Node.TEXT_NODE>) {
            $lc-><M::Node.manakaiAppendText>
                   (ref $string eq 'SCALAR' ? $string : \$string);
          } else {
            my $text = $self-><AG::Node.ownerDocument>
                            -><M::Document.createTextNode> 
                                (ref $string eq 'SCALAR' ? $$string : $string);
            $self-><M::Node.appendChild> ($text);
          }
          $r = $self;
        }__;

    @@Test:
      @@@QName: Attr..=.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $node = $doc-><M::Document.createAttribute> ('node');

        $node-><M::Node.manakaiAppendText> ('string');
        $test->id ('1.class');
        $test->assert_isa ($node, <IFName::Attr>);
        $test->id ('1.value');
        $test->assert_equals ($node-><AG::Node.textContent>, 'string');
        $test->id ('1.length');
        $test->assert_num_equals
                 (expected_value => 1,
                  actual_value => 0+@{$node-><AG::Node.childNodes>});

        $test->id (2);
        $node-><M::Node.manakaiAppendText> ('STRING');
        $test->assert_equals ($node-><AG::Node.textContent>, 'stringSTRING');
        $test->assert_num_equals
                 (expected_value => 1,
                  actual_value => 0+@{$node-><AG::Node.childNodes>});

        $node-><M::Node.appendChild>
                 ($doc-><M::Document.createEntityReference> ('er'));

        $test->id (3);
        $node-><M::Node.manakaiAppendText> ('text');
        $test->assert_equals ($node-><AG::Node.textContent>, 'stringSTRINGtext');
        $test->assert_num_equals
                 (expected_value => 3,
                  actual_value => 0+@{$node-><AG::Node.childNodes>});

  @CL3Method:
    @@Name: getFeature
    @@enDesc:
      Returns a specialized object that implements the specialized APIs.
    @@Param:
      @@@Name: feature
      @@@Type: DOMString
      @@@dis:actualType: f|FeatureNameString
    @@Param:
      @@@Name: version
      @@@Type: DOMString
      @@@dis:actualType: f|FeatureVersionString
    @@Return:
      @@@Type: DOMMain|DOMObject
      @@@nullCase:
      @@@PerlDef:
        $feature =~ s/^\+//;
        __CODE{f|getFeatureImpl::
          $self => $self,
          $feature => $feature, $version => $version, $r => $r,
          $base_class => {<ClassName::ManakaiDOMAttr>},
        }__;
        unless (defined $r) {
          __DEEP{
            $r = $self->SUPER::get_feature ($feature, $version);
          }__;
        }

    @@Test:
      @@@QName: Attr.getFeature.test
      @@@PerlDef:
        my $node;
        __CODE{tc|createAttrForTest:: $attr => $node}__;

        for (
          [Core => '1.0', <IFName::Attr||ManakaiDOM|ManakaiDOM1>],
          [Core => '2.0', <IFName::Attr||ManakaiDOM|ManakaiDOM2>],
          [Core => '3.0', <IFName::Attr||ManakaiDOM|ManakaiDOM3>],
          [XML => '1.0', <IFName::Attr||ManakaiDOM|ManakaiDOM1>],
          [XML => '2.0', <IFName::Attr||ManakaiDOM|ManakaiDOM2>],
          [XML => '3.0', <IFName::Attr||ManakaiDOM|ManakaiDOM3>],
        ) {
          $test->id ($_->[0].'.'.$_->[1]);
          my $sp = $node-><M::Node.getFeature> ($_->[0], $_->[1]);
          $test->assert_isa ($sp, $_->[2]);
        }

  @L2Attr:
    @@Name: ownerElement
    @@enDesc:
      The <IF::Element> node to which the attribute is attached.
    @@Type: Element
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          If the attribute is not in use.
      @@@PerlDef:
        __CODE{mg|getNodeStemProp0Node||ManakaiDOM|all::
          $r => $r,
          $prop => {<H::infoset|ownerElement>},
          $ref => $self,
        }__;

    @@L2Test:
      @@@QName: Attr.ownerElement.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
 
        my $attr = $doc-><M::Document.createAttributeNS> (null, 'attr');

        $test->id ('default');
        $test->assert_null ($attr-><AG::Attr.ownerElement>);

        $test->id ('set');
        my $el = $doc-><M::Document.createElementNS> (null, 'el');
        $el-><M::Element.setAttributeNodeNS> ($attr);
        $test->assert_equals ($attr-><AG::Attr.ownerElement>, $el);

        $test->id ('remove');
        $el-><M::Element.removeAttributeNode> ($attr);
        $test->assert_null ($attr-><AG::Attr.ownerElement>);

  @Attr:
    @@Name: specified
    @@enDesc:
      Whether the attribute was explicitly given a value in
      the instance document.

      If the application changed the value of the attribute node
      (even if it ends up having the same value as the default value),
      then it is set to <DOM::true>.

      The implementation may handle attributes with default values
      from other schemas than DTD similarly but applications
      should use <M::Document.normalizeDocument> to guarantee this
      information is up-to-date.

      If the <A::Attr.ownerElement> attribute is <DOM::null>,
      <A::Attr.specified> is <DOM::true>.  <SRC::DOM1SE, DOM2>
    @@Type: boolean
    @@TrueCase:
      @@@enDesc:
        The attribute is explicitly given a value in the instance document.
    @@FalseCase:
      @@@enDesc:
        Otherwise.
    @@Get:
      @@@PerlDef:
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $r,
          $prop => {<H::infoset|specified>},
          $ref => $self,
        }__;
        unless ($r) {
          my $oe;
          __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
            $r => $oe,
            $prop => {<H::infoset|ownerElement>},
            $ref => $self,
          }__;
          unless (defined $oe) {
            $r = true;
          }
        }
    @@LXSet:
      @@@TrueCase:
        @@@@enDesc:
          Sets the <A::Attr.specified> flag <DOM::true>.  <SRC::manakai>
      @@@FalseCase:
        @@@@enDesc:
          Sets the <A::Attr.specified> flag <DOM::false>.
          This might result in inconsistency between
          the document tree and a serialized representation of it.
          <SRC::manakai>

          If the <A::Attr.ownerElement> is <DOM::null>, 
          the <A::Attr.specified> value <kwd:MUST> be 
          left unchanged as <DOM::true>.
      @@@NodeReadOnlyError:
      @@@PerlDef:
        __CODE{tc|NodeReadOnlyError:: $node => $self}__;
        unless ($given) {
          my $oe;
          __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
            $r => $oe,
            $prop => {<H::infoset|ownerElement>},
            $ref => $self,
          }__;
          $given = true unless defined $oe;
        }
        __CODE{mg|setNodeStemPropValue||ManakaiDOM|all::
          $given => $given,
          $prop => {<H::infoset|specified>},
          $ref => $self,
        }__;

    @@enImplNote:
      @@@ddid: mutation 
      @@@@:
        {TODO::
          If a node in subtree is modified, the <A::Attr.specified>
          flag must be turned <DOM::true>.  Manakai implements this
          behavior in some case, but not all, in particular
          node operation methods such as <M::Node.appendChild> does not.

          $another_node->append_child ($text_that_is_a_child_of_attr)
          must change $text_that_is_a_child_of_attr->parent_node->specified.

          Setting of any <QUOTE::reflected> attribute must change
          the specified value.
        }

    @@LXTest:
      @@@QName: Document.specified.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
 
        my $attr = $doc-><M::Document.createAttributeNS> (null, 'at1');

        $test->id ('default');
        $test->assert_true ($attr-><AG::Attr.specified>);

        $test->id ('set.false');
        $attr-><AS::Attr.specified> (false);
        $test->assert_true ($attr-><AG::Attr.specified>);

        $test->id ('set.true');
        $attr-><AS::Attr.specified> (true);
        $test->assert_true ($attr-><AG::Attr.specified>);
    @@Test:
      @@@QName: Attr.specified.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $attr = $doc-><M::Document.createAttributeNS> (null, 'at1');

        my $el = $doc-><M::Document.createElementNS> (null, 'el');
        $el-><M::Element.setAttributeNodeNS> ($attr);

        $test->id ('default');
        $test->assert_true ($attr-><AG::Attr.specified>);

        $test->id ('set.false');
        $attr-><AS::Attr.specified> (false);
        $test->assert_false ($attr-><AG::Attr.specified>);

        $test->id ('set.true');
        $attr-><AS::Attr.specified> (true);
        $test->assert_true ($attr-><AG::Attr.specified>);

        $attr-><AS::Attr.specified> (false);

        $test->id ('removed');
        $el-><M::Element.removeAttributeNode> ($attr);
        $test->assert_true ($attr-><AG::Attr.specified>);
    @@Test:
      @@@QName: Attr.specified.3.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $attr = $doc-><M::Document.createAttributeNS> (null, 'at1');

        my $el = $doc-><M::Document.createElementNS> (null, 'el');
        $el-><M::Element.setAttributeNodeNS> ($attr);

        $attr-><AS::Attr.specified> (false);

        my $attr2 = $doc-><M::Document.createAttributeNS> (null, 'at1');

        $test->id ('removed');
        $el-><M::Element.setAttributeNS> ($attr2);
        $test->assert_true ($attr-><AG::Attr.specified>);

  @Attr:
    @@Name: value
    @@enDesc:
      The value of the attribute as a string.  Character and general
      entity references, if any, are replaced with their values.
    @@Type: DOMString
    @@Get:
      @@@enDesc:
        @@@@ForCheck: ManakaiDOM|ManakaiDOM
        @@@@@:
          In the manakai implementation, it is the concatenation of
          the <DFN::text content> of every child node.  For <IF::t|Text>
          children, the text content of a node is the <A::t|Node.textContent>
          attribute value.  For <IF::x|EntityReference>
          children, the text content of a node is the
          <A::t|Node.textContent> attribute value with
          any <CODE::U+0009>, <CODE::U+000A>, and
          <CODE::U+000D> replaced by <CODE::U+0020>.

          If the <InfoProp::attribute type> of the node
          (which might be accessible via <A::Attr.schemaTypeInfo>
           if the schema language of the document is XML DTD) has
          a valid value different from <CODE::no value>, <CODE::unknown>,
          and <CODE::CDATA>, then the value
          is further modified by discarding any leading
          and trailing <CODE::U+0020> characters and
          by replacing sequences of <CODE::U+0020> characters
          by a single <CODE::U+0020> character.
      @@@PerlDef:
         __DEEP{
            for my $child (@{$self-><AG::t|Node.childNodes>}) {
              if ($child-><AG::t|Node.nodeType> ==
                  <C::t|Node.ENTITY_REFERENCE_NODE>) {
                my $v = $child-><AG::t|Node.textContent>;
                $v =~ s/[\x09\x0A\x0D]/ /;
                $r .= $v;
              } else {
                $r .= $child-><AG::t|Node.textContent>;
              }
            } # childNodes
            my $vt;
            __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
              $r => $vt,
              $prop => {<H::infoset|attributeType>},
              $ref => $self,
            }__;
            unless (not defined $vt or
                    $vt == <C::ATDef.NO_TYPE_ATTR> or
                    $vt == <C::ATDef.UNKNOWN_ATTR> or
                    $vt == <C::ATDef.CDATA_ATTR>) {
              $r =~ s/\A\x20+//;
              $r =~ s/\x20+\z//;
              $r =~ s/\x20+/ /g;
            }
        }__;
    @@Set:
      @@@enDesc:
        Removes any child nodes <SRC::manakai>, and
        creates a <IF::Text> node with the unparsed content
        of the string <SRC::DOM1, DOM2, DOM3>, unless the specified value
        is the empty string <SRC::manakai>.

          {NOTE::
            Some specialized implementations, such as some SVG 1.1
            implementations, may do normalization automatically,
            even after mutation; in such case, the value on retrieval
            may differ from the value on setting.  <SRC::DOM3>
          }
      @@@enImplNote:
        Currenly type information does not affect on setting.
        Should it do?
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the node is read-only. <SRC::DOM1FE Errata, DOM1SE, DOM2, DOM3>
      @@@PerlDef:
        __CODE{tc|setNodeTextContent::
          $node => $self,
          $given => $given,
          $ownerDocument => {$self-><AG::Node.ownerDocument>},
        }__;
    @@enImplNote:
      @@@ddid: value-attrs
      @@@@:
        <IF::Node.nodeValue> for <IF::Attr> and <IF::Attr.value> shares their
        definition.  <IF::Node.textContent> does <EM::not>.

        Manakai's <IF::Node.nodeValue> for <IF::ATDef> is also shares
        the definition with <IF::Attr.value>.

    @@Test:
      @@@QName: Attr.nodeValue.value.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
  
        for my $node (
          $doc-><M::Document.createAttribute> ('attr'),
          $doc-><M::Document.createAttributeNS> (null, 'attr'),
        ) {
          $test->id ('nodeValue.get');
          $test->assert_equals ($node-><AG::Node.nodeValue>, '');

          $test->id ('value.get');
          $test->assert_equals ($node-><AG::Attr.value>, '');

          $node-><M::Node.manakaiSetReadOnly> (false);

          $node-><AS::Node.nodeValue> ('value1');

          $test->id ('nodeValue.set.nodeValue');
          $test->assert_equals ($node-><AG::Node.nodeValue>, 'value1');

          $test->id ('nodeValue.set.value');
          $test->assert_equals ($node-><AG::Attr.value>, 'value1');

          $node-><AS::Node.nodeValue> ('');

          $test->id ('nodeValue.empty.nodeValue');
          $test->assert_equals ($node-><AG::Node.nodeValue>, '');

          $test->id ('nodeValue.empty.value');
          $test->assert_equals ($node-><AG::Attr.value>, '');

          $node-><AS::Attr.value> ('value2');

          $test->id ('value.set.nodeValue');
          $test->assert_equals ($node-><AG::Node.nodeValue>, 'value2');

          $test->id ('value.set.value');
          $test->assert_equals ($node-><AG::Attr.value>, 'value2');
     
          $node-><AS::Attr.value> ('');

          $test->id ('value.empty.nodeValue');
          $test->assert_equals ($node-><AG::Node.nodeValue>, '');

          $test->id ('value.empty.value');
          $test->assert_equals ($node-><AG::Attr.value>, '');

          $node-><M::Node.manakaiSetReadOnly> (true);

          $test->id ('nodeValue.set.ro');
          $test->assert_exception (code => sub {
            $node-><AS::Node.nodeValue> ('value1');
          }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);
          $test->assert_equals ($node-><AG::Node.nodeValue>, '');

          $test->id ('value.set.ro');
          $test->assert_exception (code => sub {
            $node-><AS::Attr.value> ('value1');
          }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);
          $test->assert_equals ($node-><AG::Node.nodeValue>, '');
        }

  @L3Attr:
    @@Name: schemaTypeInfo
    @@enDesc:
      The type information associated with the attribute.

      While the type information contained in the attribute is guarantee
      to be correct after loading the document or validation,
      it may not be reliable if the node was moved.
    @@Type: c|TypeInfo
    @@Get:
      @@@PerlDef:
        my $type;
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $type,
          $prop => {<H::infoset|attributeType>},
          $ref => $self,
        }__;
        __CODE{c|createDTDTypeInfo::
          $result => $r,
          $type => $type,
        }__;

    @@L3Test:
      @@@QName: Attr.schemaTypeInfo.no-schema.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;
        $el-><AG::Node.ownerDocument>
           -><AG::Document.domConfig>
           -><M::c|DOMConfiguration.setParameter>
               ('schema-type' => q[http://dummy.example/]);
        $el-><M::Element.setAttributeNS> (null, 'a', 'b');
        my $attr = $el-><M::Element.getAttributeNodeNS> (null, 'a');

        my $sti = $attr-><AG::Attr.schemaTypeInfo>;
        $test->assert_isa ($sti, <IFName::c|TypeInfo>);
        $test->assert_null ($sti-><AG::c|TypeInfo.typeName>);
        $test->assert_null ($sti-><AG::c|TypeInfo.typeNamespace>);
    @@L3Test:
      @@@QName: Attr.schemaTypeInfo.dtd.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;
        $el-><AG::Node.ownerDocument>
           -><AG::Document.domConfig>
           -><M::c|DOMConfiguration.setParameter>
               ('schema-type' => <Q::xml-dtd:>);
        $el-><M::Element.setAttributeNS> (null, 'a', 'b');
        my $attr = $el-><M::Element.getAttributeNodeNS> (null, 'a');

        my $sti = $attr-><AG::Attr.schemaTypeInfo>;
        $test->assert_isa ($sti, <IFName::c|TypeInfo>);
        $test->assert_null ($sti-><AG::c|TypeInfo.typeName>);
        $test->assert_null ($sti-><AG::c|TypeInfo.typeNamespace>);
    @@L3Test:
      @@@QName: Attr.schemaTypeInfo.dtd.cdata.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;
        $el-><AG::Node.ownerDocument>
           -><AG::Document.domConfig>
           -><M::c|DOMConfiguration.setParameter>
               ('schema-type' => <Q::xml-dtd:>);
        $el-><M::Element.setAttributeNS> (null, 'a', 'b');
        my $attr = $el-><M::Element.getAttributeNodeNS> (null, 'a');
        $attr->{<H::mn:node>}->{<H::infoset:attributeType>}
          = <C::ATDef.CDATA_ATTR>;

        my $sti = $attr-><AG::Attr.schemaTypeInfo>;
        $test->assert_isa ($sti, <IFName::c|TypeInfo>);
        $test->assert_equals ($sti-><AG::c|TypeInfo.typeName>, 'CDATA');
        $test->assert_equals
                 ($sti-><AG::c|TypeInfo.typeNamespace>, <Q::xml-dtd:>);

  @CODE:
    @@QName: tc|setAttrType
    @@enDesc:
      Sets <Q::infoset:attributeType> attribute.
    @@PerlDef:
      __CODE{mg|setNodeStemPropValue||ManakaiDOM|all::
        $given => $type,
        $prop => {<H::infoset|attributeType>},
        $ref => $attr,
      }__;

  @L3Attr:
    @@Name: isId
     @@Description:
       @@@lang:en
       @@@@:
         Whether this attribute is known to be of type ID or not.
     @@ImplNote:
       @@@lang:en
       @@@@:
         The ways to determine whether an attribute node is known 
         to contain an identifier:
        \
         PSVI - If validation occurred using an XML Schema, the PSVI 
         contributions values are used to determine whether this 
         attribute is a Schema-determined ID attribute as the 
         XPointer specification defines, i.e. iif one of the following 
         is true:
        \
         1. The attribute information item has a [memeber type definition] or 
         [type definition] property whose value in turn has [name] eq "ID" 
         and [target namespace] eq "http://www.w3.org/2001/XMLSchema".
        \
         2. The attribute information item has a [base type definition] 
         property whose value in turn has [name] eq "ID"
         and [target namespace] eq "http://www.w3.org/2001/XMLSchema".
        \
         3. The attribute information item has a [base type definition] 
         property whose value has a [base type definition] property 
         whose value has ... whose value in turn has [name] eq "ID"
         and [target namespace] eq "http://www.w3.org/2001/XMLSchema".
        \
         4. The attribute information item has a [type definition name] 
         eq "ID" and a [type definition namespace] eq 
         "http://www.w3.org/2001/XMLSchema".
        \
         5. The attribute information item has a 
         [member type definition name] eq "ID" and a 
         [member type definition namespace] eq 
         "http://www.w3.org/2001/XMLSchema".
        \
         DTD - If validation occured using a DTD, the infoset 
         [type definition] value is used to determine whether 
         this attribute is a DTD-determined ID attribute as the 
         XPointer framework specification defines.  Iif the 
         attribute information item has a [type definition] property 
         eq "ID", it is a DTD-determined ID attribute.
        \
         User-determined - If the methods "setIdAttribute", 
         "setIdAttributeNS", "setIdAttributeNode" was used, 
         it is an user-determined ID attribute.
        \
         Externally-determined - Other mechanisms, including other 
         schema languages than DTD and XML Schema may provide 
         ways to determine whether it is a ID attribute.
    @@Type: boolean
    @@Get:
        @@@InCase:
          @@@@Value:true
          @@@@Description:
            @@@@@lang:en
            @@@@@@: 
              This attribute is a ID attribute.
        @@@InCase:
          @@@@Value:false
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              This attribute is not a ID attribute.
      @@@PerlDef:
        @@@@@:
          T: {
            ## DTD Attribute Type
            my $type;
            __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
              $r => $type,
              $prop => {<H::infoset|attributeType>},
              $ref => $self,
            }__;
            if (defined $type and $type == <C::ATDef.ID_ATTR>) {
              $r = true;
              last T;
            }

            ## User-determined ID
            my $udid;
            __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
              $r => $udid,
              $prop => {<H::c|userDeterminedId>},
              $ref => $self,
            }__;
            if ($udid) {
              $r = true;
              last T;
            }

            ## Application-determined ID
            my $nsuri = $self-><AG::Node.namespaceURI>;
            my $ln = $self-><AG::Node.localName>;
            if (defined $nsuri and $nsuri eq <Q::xml:> and
                $ln eq 'id') {
              $r = true;
              last T;
            } elsif (not defined $nsuri and $ln eq 'xml:id') {
              $r = true;
              last T;
            }
          } # T

          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              TODO: Support non-user-determined ID attributes.
              Especially, application-determined ID such as html5:*/@id
              and xml:id should be supported.

  @enImplNote:
    @@ddid: todo
    @@@:
      {TODO::
         DTD [attribute type] setter is necessary.
      }
##Attr

ElementTypeBinding:
  @Name: NodeReadOnlyError
  @ElementType:
    dx:raises
  @ShadowContent:
    @@@: MDOMX|NOMOD_THIS
    @@Description:
      @@@lang:en
      @@@@:
        The node is read-only.

ElementTypeBinding:
  @Name: intValue
  @ElementType:
    dis:Value
  @ShadowContent:
    @@ContentType: DISCore|Integer

ElementTypeBinding:
  @Name: TrueCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType:
      ManakaiDOM:InCase
    @@Value:
      @@@@: 1
      @@@ContentType: DISCore|Boolean
    @@Type: idl|boolean||ManakaiDOM|all

ElementTypeBinding:
  @Name: FalseCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType:
      ManakaiDOM:InCase
    @@Value:
      @@@@: 0
      @@@ContentType: DISCore|Boolean
    @@Type: idl|boolean||ManakaiDOM|all

NodeTypeDef:
  @IFQName: CharacterData
  @ClsQName: ManakaiDOMCharacterData

  @enDesc:
    The <IF::CharacterData> interface extends the <IF::Node>
    interface with a set of attributes and methods for
    accessing character data in the DOM.  No DOM objects correspond 
    directly to the <IF::CharacterData> interface -- the
    <IF::Text> interface and the <IF::Comment> interface
    inherits this interface.

    {ps:: <doc:caption::Positions in character data>

    All <CODE::offset>s in this interface start from <CODE::0>.  Since strings in
    the DOM are represented in UTF-16, indexing
    on <IF::CharacterData> is done in 16-bit units, i.e. characters
    allocated in the range <CODE::U+10000> to <CODE::U+10FFFF>
    (inclusive) are counted as two units.
    }

    {NOTE:: DOM implementations may not put arbitary limits on 
            the amount of the data that may be stored in a 
            <IF::CharacterData> node.  This might make a node's
            data cannot fit into a single <TYPE::DOMString>.
            See also <X::DOMSTRING_SIZE_ERR>.
    }

  @IntMethod:
    @@Operator: mg|CreateNodeStemMethod
    @@Param:
      @@@Name: bag
      @@@Type: HASH
    @@Param:
      @@@Name: obj
      @@@Type: HASH
    @@Param:
      @@@Name: opt
      @@@Type: HASH
    @@Return:
      @@@Type: HASH
      @@@PerlDef:
        $obj->{<H::infoset|content>} = $opt->{<H::infoset|content>};
        __CODE{mg|setOwnerProp||ManakaiDOM|all::
          $bag => $bag,
          $ownerref => {$opt->{<H::tc|ownerDocument>}},
          $ownee1hprop => {<H::tc|revOwnerDocument>},
          $ownee => {$obj},
          $owner0prop => {<H::tc|ownerDocument>},
        }__;
        $r = $obj;
  @mg:owner0: tc|ownerDocument
  @mg:origin0: infoset|parent

  @CAttr:
    @@Name: childNodes
    @@enDesc:
      A list of nodes that contains all children of the node.
    @@Get:
      @@@Type: c|NodeList
      @@@enDesc:
        Since <IF::CharacterData> nodes cannot have child nodes,
        the node list is always empty.
      @@@PerlDef:
        __CODE{tc|createEmptyNodeList::
          $r => $r,
        }__;

  @CMethod:
    @@Name: appendChild
    @@enDesc:
      Adds a node to the end of the list of children of the node.
      If that node is already in the tree, it is first removed.
    @@Param:
      @@@Name: newChild
      @@@Type: Node
      @@@enDesc:
        The node to add.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node added.
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_BAD_TYPE
        @@@@enDesc:
          The type of the node does not allow any children.
      @@@PerlDef:
        __EXCEPTION{MDOMX|HIERARCHY_BAD_TYPE::
          MDOMX|param-name => 'newChild',
          c|node => {$newChild},
        }__;

  @CMethod:
    @@Name: insertBefore
    @@enDesc:
      Inserts a node before the existing child node of the node.
    @@Param:
      @@@Name: newChild
      @@@Type: Node
      @@@enDesc:
        The node to add.
    @@Param:
      @@@Name: refChild
      @@@Type: Node
      @@@enDesc:
        The node before which the <P::newChild> node is inserted.
      @@@nullCase:
        @@@@enDesc:
          The <P::newChild> node is inserted at the end.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node added.
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_BAD_TYPE
        @@@@enDesc:
          The type of the node does not allow any children.
      @@@PerlDef:
        __EXCEPTION{MDOMX|HIERARCHY_BAD_TYPE::
          MDOMX|param-name => 'newChild',
          c|node => {$newChild},
        }__;

  @CMethod:
    @@Name: replaceChild
    @@enDesc:
      Replaces a node by another node.
    @@Param:
      @@@Name: newChild
      @@@Type: Node
      @@@enDesc:
        The node to add.
    @@Param:
      @@@Name: oldChild
      @@@Type: Node
      @@@enDesc:
        The node to remove.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node replaced.
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_BAD_TYPE
        @@@@enDesc:
          The type of the node does not allow any children.
      @@@PerlDef:
        __EXCEPTION{MDOMX|HIERARCHY_BAD_TYPE::
          MDOMX|param-name => 'newChild',
          c|node => {$newChild},
        }__;

  @CMethod:
    @@Name: manakaiAppendText
    @@Param:
      @@@Name: string
      @@@Type: DOMString
      @@@enDesc:
        The string to append.
      @@@InCase:
        @@@@Type: DISPerl|SCALAR||ManakaiDOM|all
        @@@@enDesc:
          A copy of the string value referenced from the value
          is appended.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node itself.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the node to insert the string or a <IF::Text> node
          is read-only.
      @@@PerlDef:
        __DEEP{
          if ($self-><AG::Node.ownerDocument>
                   -><AG::Document.strictErrorChecking> and
              $self-><AG::Node.manakaiReadOnly>) {
            __UNDEEP{__EXCEPTION{MDOMX|NOMOD_THIS::
            }__}__;
          }
          my $v;
          __CODE{mg|getNodeStemPropValueRef||ManakaiDOM|all::
            $r => $v,
            $prop => {<H::infoset|content>},
            $ref => $self,
          }__;
          $$v .= ref $string eq 'SCALAR' ? $$string : $string;
          $r = $self;
        }__;

  @CAttr:
    @@Name: nodeValue
    @@enDesc:
      The value of the node.
    @@Type: DOMString
    @@Get:
      @@@disDef:
        @@@@DISPerl:cloneCode: .data.get
    @@Set:
      @@@NodeReadOnlyError:
      @@@disDef:
        @@@@DISPerl:cloneCode: .data.set

  @CL3Attr:
    @@Name: textContent
    @@enDesc:
      The text content of the node.
    @@Type: DOMString
    @@Get:
      @@@disDef:
        @@@@DISPerl:cloneCode: .data.get
    @@Set:
      @@@nullCase:
        @@@@enImplNote:
          The DOM Level 3 Core specification is unclear on 
          setting <DOM::null> to the <A::Node.textContent>
          attribute to the node whose type is so defined
          that it has same effect as <A::Node.nodeValue>.
      @@@NodeReadOnlyError:
      @@@disDef:
        @@@@DISPerl:cloneCode: .data.set

  @Attr:
    @@Name: data
    @@enDesc:
      The character data of the node.

      The DOM implementation may not put arbitary limits on the
      amount of data that may be stored in a <IF::CharacterData> node.
      However, implementation limits may mean that the entirely
      of a node's data may not fit into a single <TYPE::DOMString>.
      In such cases, applications may call <M::CharacterData.substringData>
      to retrieve the data in appropriately sized pieces.

      If the node is a <IF::DOMXML|CDATASection>, it is the
      content of the <XML::CDATA> section.  Since DOM implementation
      does no lexical check on the content of the <XML::CDATA>
      section, <A::CharacterData.data> might include the character
      sequence equals to <SGML::MSE>, i.e. <XML::]]<gt>> in XML.
    @@Type: DOMString
    @@Get:
      @@@iRaises:
        @@@@@: c|DOMSTRING_SIZE_ERR
        @@@@enDesc:
          When it would return more characters than fit in a
          <TYPE::DOMString> variable on the implementation platform.
      @@@PerlDef:
        my $v;
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $v,
          $prop => {<H::infoset|content>},
          $ref => $self,
        }__;
        $r = $$v;
    @@Set:
      @@@NodeReadOnlyError:
      @@@PerlDef:
        __CODE{tc|NodeReadOnlyError:: $node => $self}__;
        my $v;
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $v,
          $prop => {<H::infoset|content>},
          $ref => $self,
        }__;
        $$v = defined $given ? $given : '';
                ## NOTE: Setting NULL is supported for
                ##       compatibility with |textContent|.

    @@Test:
      @@@QName: CharacterData.nodeValue.data.textContent.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
  
        for my $node (
          $doc-><M::Document.createTextNode> ('initial value'),
          $doc-><M::Document.createComment> ('initial value'),
          $doc-><M::Document.createCDATASection> ('initial value'),
        ) {
          $test->id ($node-><AG::Node.nodeType>.'.nodeValue.get');
          $test->assert_equals ($node-><AG::Node.nodeValue>, 'initial value');

          $test->id ($node-><AG::Node.nodeType>.'.textContent.get');
          $test->assert_equals ($node-><AG::Node.textContent>,
                                'initial value');

          $test->id ($node-><AG::Node.nodeType>.'.data.get');
          $test->assert_equals ($node-><AG::CharacterData.data>,
                                'initial value');

          $node-><M::Node.manakaiSetReadOnly> (false);

          $node-><AS::Node.nodeValue> ('value1');

          $test->id ($node-><AG::Node.nodeType>.'.nodeValue.set.nodeValue');
          $test->assert_equals ($node-><AG::Node.nodeValue>, 'value1');

          $test->id ($node-><AG::Node.nodeType>.'.nodeValue.set.textContent');
          $test->assert_equals ($node-><AG::Node.textContent>, 'value1');

          $test->id ($node-><AG::Node.nodeType>.'.nodeValue.set.data');
          $test->assert_equals ($node-><AG::CharacterData.data>, 'value1');

          $node-><AS::Node.nodeValue> ('');

          $test->id ($node-><AG::Node.nodeType>.'.nodeValue.empty.nodeValue');
          $test->assert_equals ($node-><AG::Node.nodeValue>, '');

          $test->id ($node-><AG::Node.nodeType>.'.nodeValue.empty.text');
          $test->assert_equals ($node-><AG::Node.textContent>, '');

          $test->id ($node-><AG::Node.nodeType>.'.nodeValue.empty.data');
          $test->assert_equals ($node-><AG::CharacterData.data>, '');

          $node-><AS::Node.textContent> ('value3');

          $test->id ($node-><AG::Node.nodeType>.'.textContent.set.nodeValue');
          $test->assert_equals ($node-><AG::Node.nodeValue>, 'value1');

          $test->id ($node-><AG::Node.nodeType>.'.textContent.set.text');
          $test->assert_equals ($node-><AG::Node.textContent>, 'value1');

          $test->id ($node-><AG::Node.nodeType>.'.textContent.set.data');
          $test->assert_equals ($node-><AG::CharacterData.data>, 'value1');

          $node-><AS::Node.textContent> ('');

          $test->id ($node-><AG::Node.nodeType>.'.text.empty.nodeValue');
          $test->assert_equals ($node-><AG::Node.nodeValue>, '');

          $test->id ($node-><AG::Node.nodeType>.'.textContent.empty.text');
          $test->assert_equals ($node-><AG::Node.textContent>, '');

          $test->id ($node-><AG::Node.nodeType>.'.textContent.empty.data');
          $test->assert_equals ($node-><AG::CharacterData.data>, '');

          $node-><AS::Node.textContent> ('value4');
          $node-><AS::Node.textContent> (null);

          $test->id ($node-><AG::Node.nodeType>.'.text.null.nodeValue');
          $test->assert_equals ($node-><AG::Node.nodeValue>, '');

          $test->id ($node-><AG::Node.nodeType>.'.textContent.null.text');
          $test->assert_equals ($node-><AG::Node.textContent>, '');

          $test->id ($node-><AG::Node.nodeType>.'.textContent.null.data');
          $test->assert_equals ($node-><AG::CharacterData.data>, '');

          $node-><AS::CharacterData.data> ('value2');

          $test->id ($node-><AG::Node.nodeType>.'.data.set.nodeValue');
          $test->assert_equals ($node-><AG::Node.nodeValue>, 'value2');

          $test->id ($node-><AG::Node.nodeType>.'.data.set.textContent');
          $test->assert_equals ($node-><AG::Node.textContent>, 'value2');

          $test->id ($node-><AG::Node.nodeType>.'.data.set.data');
          $test->assert_equals ($node-><AG::CharacterData.data>, 'value2');
     
          $node-><AS::CharacterData.data> ('');

          $test->id ($node-><AG::Node.nodeType>.'.data.empty.nodeValue');
          $test->assert_equals ($node-><AG::Node.nodeValue>, '');

          $test->id ($node-><AG::Node.nodeType>.'.data.empty.textContent');
          $test->assert_equals ($node-><AG::Node.textContent>, '');

          $test->id ($node-><AG::Node.nodeType>.'.data.empty.data');
          $test->assert_equals ($node-><AG::CharacterData.data>, '');

          $node-><M::Node.manakaiSetReadOnly> (true);

          $test->id ($node-><AG::Node.nodeType>.'.nodeValue.set.ro');
          $test->assert_exception (code => sub {
            $node-><AS::Node.nodeValue> ('value1');
          }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);
          $test->assert_equals ($node-><AG::Node.nodeValue>, '');

          $test->id ($node-><AG::Node.nodeType>.'.textContent.set.ro');
          $test->assert_exception (code => sub {
            $node-><AS::Node.textContent> ('value1');
          }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);
          $test->assert_equals ($node-><AG::Node.nodeValue>, '');

          $test->id ($node-><AG::Node.nodeType>.'.data.set.ro');
          $test->assert_exception (code => sub {
            $node-><AS::CharacterData.data> ('value1');
          }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);
          $test->assert_equals ($node-><AG::Node.nodeValue>, '');
        }

  @enImplNote:
    @@ddid: todo
    @@@:
      {TODO::
        length, appendData, insertData, deleteData, substringData,
        replaceData
      }
##CharacterData

IFCls1Def:
  @IFQName: Text
  @ClsQName: ManakaiDOMText

  @IFISA: CharacterData
  @ClsISA: ManakaiDOMCharacterData

  @enDesc:
    A <IF::Text> object represents a textual content of an
    <IF::Element> or <IF::Attr> (termed <DFN::character data>
    in XML).  If there is no markup inside an element's content,
    the text is contained in a single <IF::Text> object that
    is the only child of the element.  If there is markup,
    it is parsed into the information items (elements,
    comments, and so on) that form the list of children of the element,
    where sequences of character information items consist 
    <IF::Text> nodes.

    When a document is first made available via the DOM,
    there is only one <IF::Text> node for each block
    of text.  Applications may create adjacent <IF::Text> nodes
    that represents the contents of a given element without any
    intervening markup, but should be aware that there is no way
    to represent the separations between these nodes in
    XML or HTML, so they will not in general persisten between
    DOM editing sessions.  The <M::Node.normalize> method
    merges any such adjacent <IF::Text> nodes into a single
    node for each block of text.

    No lexical check or parsing is done on the content of a <IF::Text> node
    and some characters must be escaped, depending on its position
    in the document, during serialization using character or
    general entity references.

  @Description:
    @@lang:en
    @@@:
      The textual content of an "Element" or "Attr".
    \
      When a document is first made available via the DOM, 
      there is only one "Text" node for each block of text. 
      DOM applications may create adjust "Text" nodes that 
      represent the contents of a given node (but there is no 
      way to represent the separation between these nodes in 
      XML or HTML so they will not persist between DOM editing sessions 
      in general).

  @CODE:
    @@QName: tc|createTextForTest
    @@PerlDef:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
      $text = $doc-><M::Document.createTextNode> ('text');

  @CAttr:
    @@Name: nodeType
    @@Type: unsignedShort
    @@dis:actualType: NodeType
    @@Get:
      @@@disDef:
        @@@@DISLang:constValue: Node.TEXT_NODE

    @@Test:
      @@@QName: Text.nodeType.test
      @@@PerlDef:
        my $text;
        __CODE{tc|createTextForTest:: $text => $text}__;

        $test->id ('nodeType');
        $test->assert_num_equals
                 (actual_value => $text-><AG::Node.nodeType>,
                  expected_value => <C::Node.TEXT_NODE>);

  @Test:
    @@QName: Text.parentNode.1.test
    @@PerlDef:
      my $text;
      __CODE{tc|createTextForTest:: $text => $text}__;

      $test->assert_null ($text-><AG::Node.parentNode>);

  @Test:
    @@QName: Text.isSameNode.1.test
    @@PerlDef:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

      my $el = $doc-><M::Document.createTextNode> ('a');

      my $el2 = $doc-><M::Document.createTextNode> ('a');
      
      $test->id ('same');
      $test->assert_equals ($el, $el);
      
      $test->id ('diff');
      $test->assert_not_equals ($el, $el2);
      
      $test->id ('doc');
      $test->assert_not_equals ($el, $doc);
  @Test:
    @@QName: Text.isSameNode.2.test
    @@PerlDef:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

      my $el = $doc-><M::Document.createTextNode> ('a');

      my $el2 = $doc-><M::Document.createTextNode> ('a');
      
      $test->id ('same');
      $test->assert_true ($el-><M::Node.isSameNode> ($el));
      
      $test->id ('diff');
      $test->assert_false ($el-><M::Node.isSameNode> ($el2));
      
      $test->id ('doc');
      $test->assert_false ($el-><M::Node.isSameNode> ($doc));

  @LXTest:
    @@QName: Text.readOnly.test
    @@PerlDef:
      my $text;
      __CODE{tc|createTextForTest:: $text => $text}__;

      $test->id ('default');
      $test->assert_false ($text-><AG::Node.manakaiReadOnly>);

  @CAttr:
    @@Name: nodeName
    @@enDesc:
      The node name.
    @@DOMMain:isNamespaceUnaware:1
    @@Type: DOMString
    @@Get:
      @@@DefaultValue:
        @@@@@: \#text
        @@@@ContentType:
          DISCore:String
      @@@disDef:
        @@@@DISLang:nop:

    @@Test:
      @@@QName: Text.nodeName.test
      @@@PerlDef:
        my $text;
        __CODE{tc|createTextForTest:: $text => $text}__;

        $test->assert_equals ($text-><AG::Node.nodeName>, '#text');

  @Test:
    @@QName: Text.appendChild.test
    @@PerlDef:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
      my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

      my $text = $doc-><M::Document.createTextNode> ('data');
      my $node2 = $doc-><M::Document.createTextNode> ('2');

      for my $node (<Code::tc|createNodesForTest+dt>) {
        $test->id ('appendChild.'.$node-><AG::Node.nodeType>);
        $test->assert_exception (code => sub {
          $text-><M::Node.appendChild> ($node);
        }, exception_subtype => <Q::MDOMX|HIERARCHY_BAD_TYPE>);

        $test->id ('insertBefore.'.$node-><AG::Node.nodeType>);
        $test->assert_exception (code => sub {
          $text-><M::Node.insertBefore> ($node);
        }, exception_subtype => <Q::MDOMX|HIERARCHY_BAD_TYPE>);

        $test->id ('replaceChild.'.$node-><AG::Node.nodeType>);
        $test->assert_exception (code => sub {
          $text-><M::Node.replaceChild> ($node, $node2);
        }, exception_subtype => <Q::MDOMX|HIERARCHY_BAD_TYPE>);
      }

  @Test:
    @@QName: Text..=.1.test
    @@PerlDef:
      my $doc;
      __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;

      my $node = $doc-><M::Document.createTextNode> ('');

      $node-><M::Node.manakaiAppendText> ('aaaa');
      $test->id ('1.class');
      $test->assert_isa ($node, <IFName::Text>);
      $test->id ('1.value');
      $test->assert_equals ($node-><AG::t|CharacterData.data>, 'aaaa');

      $test->id (2);
      $node-><M::Node.manakaiAppendText> ('bbbb');
      $test->assert_equals ($node-><AG::t|CharacterData.data>, 'aaaabbbb');

  @CL3Method:
    @@Name: getFeature
    @@enDesc:
      Returns a specialized object that implements the specialized APIs.
    @@Param:
      @@@Name: feature
      @@@Type: DOMString
      @@@dis:actualType: f|FeatureNameString
    @@Param:
      @@@Name: version
      @@@Type: DOMString
      @@@dis:actualType: f|FeatureVersionString
    @@Return:
      @@@Type: DOMMain|DOMObject
      @@@nullCase:
      @@@PerlDef:
        $feature =~ s/^\+//;
        __CODE{f|getFeatureImpl::
          $self => $self,
          $feature => $feature, $version => $version, $r => $r,
          $base_class => {<ClassName::ManakaiDOMText>},
        }__;
        unless (defined $r) {
          __DEEP{
            $r = $self->SUPER::get_feature ($feature, $version);
          }__;
        }

    @@Test:
      @@@QName: Text.getFeature.test
      @@@PerlDef:
        my $node;
        __CODE{tc|createTextForTest:: $text => $node}__;

        for (
          [Core => '1.0', <IFName::Text||ManakaiDOM|ManakaiDOM1>],
          [Core => '2.0', <IFName::Text||ManakaiDOM|ManakaiDOM2>],
          [Core => '3.0', <IFName::Text||ManakaiDOM|ManakaiDOM3>],
          [XML => '1.0', <IFName::Text||ManakaiDOM|ManakaiDOM1>],
          [XML => '2.0', <IFName::Text||ManakaiDOM|ManakaiDOM2>],
          [XML => '3.0', <IFName::Text||ManakaiDOM|ManakaiDOM3>],
        ) {
          $test->id ($_->[0].'.'.$_->[1]);
          my $sp = $node-><M::Node.getFeature> ($_->[0], $_->[1]);
          $test->assert_isa ($sp, $_->[2]);
        }

  @L3Attr:
    @@Name: isElementContentWhitespace
    @@enDesc:
      Whether the text node contains element content white spaces.

      The text node is determined to contain white space in element
      content during the load of the document or if validation occurs
      while using <M::Document.normalizeDocument>.
    @@enImplNote:
      @@@ddid: ??
      @@@@:
        <IF::Text> with non-white-space-characters or with
        no white space character?

        <IF::CDATASection>?
    @@Type: boolean
    @@Get:
      @@@PerlDef:
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $r,
          $prop => {<H::infoset|elementContentWhitespace>},
          $ref => $self,
        }__;
    @@LXSet:
      @@@enImplNote:
        {TODO::
          Clarification is necessary.
        }
      @@@NodeReadOnlyError:
      @@@PerlDef:
        __CODE{tc|NodeReadOnlyError:: $node => $self}__;
        __CODE{mg|setNodeStemPropValue||ManakaiDOM|all::
          $given => $given,
          $prop => {<H::infoset|elementContentWhitespace>},
          $ref => $self,
        }__;

    @@Test:
      @@@QName: Text.isElementContentWhitespace.test
      @@@PerlDef:
        my $node;
        __CODE{tc|createTextForTest:: $text => $node}__;
        $node-><AS::Node.nodeValue> (' ');

        $test->id ('default');
        $test->assert_false ($node-><AG::Text.isElementContentWhitespace>);

        $test->id ('set.true');
        $node-><AS::Text.isElementContentWhitespace> (true);
        $test->assert_true ($node-><AG::Text.isElementContentWhitespace>);

        $test->id ('set.false');
        $node-><AS::Text.isElementContentWhitespace> (true);
        $test->assert_false ($node-><AG::Text.isElementContentWhitespace>);

  @L3Attr:
    @@Name: wholeText
     @@Description:
       @@@lang:en
       @@@@:
         All text of logically-adjacent text nodes.
     @@ImplNote:
       @@@lang:en
       @@@@:
         The DOM Level 3 Core Specification is unclear about 
         <IF::DOMXML:CDATASection>s.
         They should also be included (c.f. the definition for 
         <A::Text.replaceWholeText>).
         \
         What about unexpanded entity references?
    @@Type: DOMString
    @@Get:
      @@@enImplNote:
        {TODO::
          Implement this.
        }

  @L3Method:
    @@Name: replaceWholeText
     @@Param:
        @@@Name:  content
        @@@Type:  
          DOMMain:DOMString
     @@Return:
        @@@Type:  Text
    @@enImplNote:
      {ISSUE::
        isElementContentWhitespace
      }

  @Method:
    @@Name: splitText
     @@Description:
       @@@lang:en
       @@@@:
         Break this node into two nodes.  After being split, 
         this node will contain all the content up to the break point 
         and a new node of the same type will contain all the content 
         at and after the break point.
      \
         If the original node had a parent node, the new node is 
         inserted as the next sibling of this node.

      {ISSUE::
         isElementContentWhitespace
      }
     @@Param:
        @@@Name:  offset
        @@@Type:  
          DOMMain:unsigned-long||ManakaiDOM|all
        @@@Description:
          @@@@lang:en
          @@@@@:
            The 16-bit unit offset at which to split.
     @@Return:
        @@@Type:  Text
        @@@Description:
          @@@@lang:en
          @@@@@: The new node, of the same type as this node.
       @@@dx:raises:
         @@@@@: c|NEGATIVE_INDEX_ERR
         @@@@enDesc:
           The <P::offset> is negative.
       @@@dx:raises:
         @@@@@: c|OUT_OF_UPPER_BOUND_ERR
         @@@@enDesc:
           The <P::offset> is greater than the number of
           16-bit units.
       @@@dx:raises:
         @@@@@: MDOMX|NOMOD_THIS
         @@@@enDesc:
           The node is read-only.
       @@@dx:raises:
         @@@@@: MDOMX|NOMOD_PARENT
         @@@@enDesc:
           The parent node is read-only.
         @@@@For: ManakaiDOM|ManakaiDOM
      @@@PerlDef:
        @@@@@ForCheck: !ManakaiDOM|all
        @@@@@enImplNote:
          {TODO::
            Implement this.
          }
        @@@@@@:
          my $node = $self->{<H::mn:node>};
          my $parentNode = $node->{<H::infoset:parent>};
          if ($node->{<H::DOMCore:read-only>}) {
            __EXCEPTION{
              MDOMX:NOMOD_THIS::
            }__;
          } elsif ($parentNode and $parentNode->{<H::DOMCore:read-only>}) {
            __EXCEPTION{
              MDOMX:NOMOD_PARENT::
            }__;
          }
          my $ds = \$node->{<H::infoset:content>};
          my $after;
          try {
            my $offset32 = <ClassM::DOMMain:ManakaiDOMStringExtend
                                   .findOffset32> ($offset);
            $after = substr ($$ds, $offset32);
            substr ($$ds, $offset32) = '';
          ## TODO: Catch StringIndexOutOfBoundsException
          };
          my $newNode;
          if ($node->{<H::DOMCore:nodeType>} eq <H::DOMCore:TextNode>) {
            $newNode = <ClassM::ManakaiDOMText.newObject> ($node);
          } elsif ($node->{<H::DOMCore:nodeType>} eq
                   <H::DOMXML:CDATASectionNode>) {
            $newNode = <ClassM::DOMXML:ManakaiDOMCDATASection.newObject> ($node);
          } else {
            __EXCEPTION{
              MDOMX:MDOM_DEBUG_BUG||ManakaiDOM:Perl::
                MDOMX:values => {+{
                  <H::DOMCore:nodeType> => $node->{<H::DOMCore:nodeType>},
                }},
            }__;
          }
          $newNode->{<H::infoset:content>} = $after;
          __CODE{mn|setXRefNode||ManakaiDOM|Perl::
            $referrer => {$newNode},
            $propName => {<H::DOMCore:ownerDocument>},
            $referent => {$parentNode->{<H::DOMCore:ownerDocument>}},
          }__;
          if ($parentNode) {
            $parentNode-><M::NodeStem.importTree> ($newNode);
            A: for my $i (0..$#{$parentNode->{<H::infoset:children>}}) {
              if ($parentNode->{<H::infoset:children>}->[$i]->{<H::mn:nodeID>} eq
                  $node->{<H::mn:nodeID>}) {
                splice @{$parentNode->{<H::infoset:children>}},
                       $i + 1, 0, $newNode;
                last A;
              }
            }
            $newNode->{<H::infoset:parent>} = $parentNode;
          }
          __CODE{mn|setXRefNode||ManakaiDOM|Perl::
            $referrer => {$newNode},
            $propName => {<H::DOMCore:ownerDocument>},
            $referent => {$node->{<H::DOMCore:ownerDocument>}},
          }__;
##Text

IFCls1Def:
  @IFQName: Comment
  @ClsQName: ManakaiDOMComment

  @IFISA: CharacterData
  @ClsISA: ManakaiDOMCharacterData

  @enDesc:
    A <IF::Comment> object represents the content of a comment,
    i.e. all the characters between the starting <XML::<!--> and
    ending <XML::--<gt>> in XML.

    No lexical check is done on the content of a <IF::Comment>
    and it is therefore possible to have the character sequence
    <CODE::--> in the content, which is illegal in a comment
    per XML specification.  Such <IF::Comment> node cannot be
    serialized in XML.

  @CODE:
    @@QName: tc|createCommentForTest
    @@PerlDef:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
      $text = $doc-><M::Document.createComment> ('text');

  @CAttr:
    @@Name: nodeType
    @@Type: unsignedShort
    @@dis:actualType: NodeType
    @@Get:
      @@@disDef:
        @@@@DISLang:constValue: Node.COMMENT_NODE

    @@Test:
      @@@QName: Comment.nodeType.test
      @@@PerlDef:
        my $text;
        __CODE{tc|createCommentForTest:: $text => $text}__;

        $test->id ('nodeType');
        $test->assert_num_equals
                 (actual_value => $text-><AG::Node.nodeType>,
                  expected_value => <C::Node.COMMENT_NODE>);

  @Test:
    @@QName: Comment.parentNode.1.test
    @@PerlDef:
      my $text;
      __CODE{tc|createCommentForTest:: $text => $text}__;

      $test->assert_null ($text-><AG::Node.parentNode>);

  @Test:
    @@QName: Comment.isSameNode.1.test
    @@PerlDef:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

      my $el = $doc-><M::Document.createComment> ('a');

      my $el2 = $doc-><M::Document.createComment> ('a');
      
      $test->id ('same');
      $test->assert_equals ($el, $el);
      
      $test->id ('diff');
      $test->assert_not_equals ($el, $el2);
      
      $test->id ('doc');
      $test->assert_not_equals ($el, $doc);
  @Test:
    @@QName: Comment.isSameNode.2.test
    @@PerlDef:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

      my $el = $doc-><M::Document.createComment> ('a');

      my $el2 = $doc-><M::Document.createComment> ('a');
      
      $test->id ('same');
      $test->assert_true ($el-><M::Node.isSameNode> ($el));
      
      $test->id ('diff');
      $test->assert_false ($el-><M::Node.isSameNode> ($el2));
      
      $test->id ('doc');
      $test->assert_false ($el-><M::Node.isSameNode> ($doc));

  @LXTest:
    @@QName: Comment.readOnly.test
    @@PerlDef:
      my $text;
      __CODE{tc|createCommentForTest:: $text => $text}__;

      $test->id ('default');
      $test->assert_false ($text-><AG::Node.manakaiReadOnly>);
  
  @CAttr:
    @@Name: nodeName
    @@enDesc:
      The node name.
    @@DOMMain:isNamespaceUnaware:1
    @@Type: DOMString
    @@DOMMain:isNamespaceUnaware:1
    @@Get:
      @@@disDef: 
        @@@@DISLang:value:
          @@@@@@: \#comment
          @@@@@ContentType:
            DISCore:String

    @@Test:
      @@@QName: Comment.nodeName.test
      @@@PerlDef:
        my $text;
        __CODE{tc|createCommentForTest:: $text => $text}__;

        $test->assert_equals ($text-><AG::Node.nodeName>, '#comment');

  @Test:
    @@QName: Comment.appendChild.test
    @@PerlDef:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
      my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

      my $comment = $doc-><M::Document.createComment> ('data');
      my $node2 = $doc-><M::Document.createComment> ('data');

      for my $node (<Code::tc|createNodesForTest+dt>) {
        $test->id ('appendChild.'.$node-><AG::Node.nodeType>);
        $test->assert_exception (code => sub {  
          $comment-><M::Node.appendChild> ($node);
        }, exception_subtype => <Q::MDOMX|HIERARCHY_BAD_TYPE>);

        $test->id ('insertBefore.'.$node-><AG::Node.nodeType>);
        $test->assert_exception (code => sub {  
          $comment-><M::Node.insertBefore> ($node);
        }, exception_subtype => <Q::MDOMX|HIERARCHY_BAD_TYPE>);

        $test->id ('replaceChild.'.$node-><AG::Node.nodeType>);
        $test->assert_exception (code => sub {  
          $comment-><M::Node.replaceChild> ($node, $node2);
        }, exception_subtype => <Q::MDOMX|HIERARCHY_BAD_TYPE>);
      }

  @Test:
    @@QName: Comment..=.1.test
    @@PerlDef:
      my $doc;
      __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;

      my $node = $doc-><M::Document.createComment> ('');

      $node-><M::Node.manakaiAppendText> ('aaaa');
      $test->id ('1.class');
      $test->assert_isa ($node, <IFName::Comment>);
      $test->id ('1.value');
      $test->assert_equals ($node-><AG::CharacterData.data>, 'aaaa');

      $test->id (2);
      $node-><M::Node.manakaiAppendText> ('bbbb');
      $test->assert_equals ($node-><AG::CharacterData.data>, 'aaaabbbb');

  @CL3Method:
    @@Name: getFeature
    @@enDesc:
      Returns a specialized object that implements the specialized APIs.
    @@Param:
      @@@Name: feature
      @@@Type: DOMString
      @@@dis:actualType: f|FeatureNameString
    @@Param:
      @@@Name: version
      @@@Type: DOMString
      @@@dis:actualType: f|FeatureVersionString
    @@Return:
      @@@Type: DOMMain|DOMObject
      @@@nullCase:
      @@@PerlDef:
        $feature =~ s/^\+//;
        __CODE{f|getFeatureImpl::
          $self => $self,
          $feature => $feature, $version => $version, $r => $r,
          $base_class => {<ClassName::ManakaiDOMComment>},
        }__;
        unless (defined $r) {
          __DEEP{
            $r = $self->SUPER::get_feature ($feature, $version);
          }__;
        }

    @@Test:
      @@@QName: Comment.getFeature.test
      @@@PerlDef:
        my $node;
        __CODE{tc|createCommentForTest:: $text => $node}__;

        for (
          [Core => '1.0', <IFName::Comment||ManakaiDOM|ManakaiDOM1>],
          [Core => '2.0', <IFName::Comment||ManakaiDOM|ManakaiDOM2>],
          [Core => '3.0', <IFName::Comment||ManakaiDOM|ManakaiDOM3>],
          [XML => '1.0', <IFName::Comment||ManakaiDOM|ManakaiDOM1>],
          [XML => '2.0', <IFName::Comment||ManakaiDOM|ManakaiDOM2>],
          [XML => '3.0', <IFName::Comment||ManakaiDOM|ManakaiDOM3>],
        ) {
          $test->id ($_->[0].'.'.$_->[1]);
          my $sp = $node-><M::Node.getFeature> ($_->[0], $_->[1]);
          $test->assert_isa ($sp, $_->[2]);
        }
##Comment

NodeTypeDef:
  @IFQName: DocumentFragment
  @ClsQName: ManakaiDOMDocumentFragment
  
  @enDesc:
    The <IF::DocumentFragment> interface is originally designed
    as a <QUOTE::lightweight> or <QUOTE::minimum> <IF::Document> object.
    It is useful to extract a portion of a document tree or to
    create a new fragment of a document, for the purposes of e.g.
    implementing a command like cut or rearranging a document
    by moving fragments around.  While a <IF::Document> object could
    fulfill this role, a <IF::Document> object can potentially
    be a heavyweight object, depending on the undelying implementation.
  
    Furthrmore, various operations, such as inserting nodes as
    cildren of another <IF::Node>, may take <IF::DocumentFragment>
    nodes as arguments; this result in all the child nodes of the
    <IF::DocumentFragment> node being moved to the child list
    of that node.

    The children of a <IF::DocumentFragment> node are zero or more
    nodes representing the tops of any subtrees defining the
    structure of the document.  A <IF::DocumentFragment> node
    does not need to represent a well-formed XML document.  For
    example, a <IF::DocumentFragment> node might have only one
    child node and that child node could be a <IF::Text? node.

  @IntMethod:
    @@Operator: mg|CreateNodeStemMethod
    @@Param:
      @@@Name: bag
      @@@Type: HASH
    @@Param:
      @@@Name: obj
      @@@Type: HASH
    @@Param:
      @@@Name: opt
      @@@Type: HASH
    @@Return:
      @@@Type: HASH
      @@@PerlDef:
        $obj->{<H::infoset|children>} = [];
        __CODE{mg|setOwnerProp||ManakaiDOM|all::
          $bag => $bag,
          $ownerref => {$opt->{<H::tc|ownerDocument>}},
          $ownee1hprop => {<H::tc|revOwnerDocument>},
          $ownee => {$obj},
          $owner0prop => {<H::tc|ownerDocument>},
        }__;
        $r = $obj;
  @mg:subnode1a: infoset|children
  @mg:owner0: tc|ownerDocument

  @CODE:
    @@QName: tc|createDFForTest
    @@PerlDef:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
      $df = $doc-><M::Document.createDocumentFragment>;

  @CAttr:
    @@Name: nodeType
    @@Type: unsignedShort
    @@dis:actualType: NodeType
    @@Get:
      @@@disDef:
        @@@@DISLang:constValue: Node.DOCUMENT_FRAGMENT_NODE

    @@Test:
      @@@QName: DF.nodeType.test
      @@@PerlDef:
        my $df;
        __CODE{tc|createDFForTest:: $df => $df}__;

        $test->id ('nodeType');
        $test->assert_num_equals
                 (actual_value => $df-><AG::Node.nodeType>,
                  expected_value => <C::Node.DOCUMENT_FRAGMENT_NODE>);

  @Test:
    @@QName: DF.parentNode.1.test
    @@PerlDef:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

      my $df = $doc-><M::Document.createDocumentFragment>;

      $test->assert_null ($df-><AG::Node.parentNode>);

  @Test:
    @@QName: DF.isSameNode.1.test
    @@PerlDef:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

      my $el = $doc-><M::Document.createDocumentFragment>;

      my $el2 = $doc-><M::Document.createDocumentFragment>;
      
      $test->id ('same');
      $test->assert_equals ($el, $el);
      
      $test->id ('diff');
      $test->assert_not_equals ($el, $el2);
      
      $test->id ('doc');
      $test->assert_not_equals ($el, $doc);
  @Test:
    @@QName: DF.isSameNode.2.test
    @@PerlDef:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

      my $el = $doc-><M::Document.createDocumentFragment>;

      my $el2 = $doc-><M::Document.createDocumentFragment>;
      
      $test->id ('same');
      $test->assert_true ($el-><M::Node.isSameNode> ($el));
      
      $test->id ('diff');
      $test->assert_false ($el-><M::Node.isSameNode> ($el2));
      
      $test->id ('doc');
      $test->assert_false ($el-><M::Node.isSameNode> ($doc));

  @LXTest:
    @@QName: DF.readOnly.test
    @@PerlDef:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

      my $el = $doc-><M::Document.createDocumentFragment>;

      $test->id ('default');
      $test->assert_false ($el-><AG::Node.manakaiReadOnly>);

  @CMethod:
    @@Name: appendChild
    @@enDesc:
      Adds a node to the end of the list of children of the node.
      If that node is already in the tree, it is first removed.
    @@Param:
      @@@Name: newChild
      @@@Type: Node
      @@@enDesc:
        The node to add.
      @@@InCase:
        @@@@Type: DocumentFragment
        @@@@enDesc:
          The entire contents of the document fragment are
          moved into the child list of the node.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node added.  If the <P::newChild> node is a <IF::DocumentFragment>
        node, then the <P::newChild> node <kwd:MUST> be returned.
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_BAD_TYPE
        @@@@enDesc:
          If the node is of a type that does not allow children of
          the type of the <P::newChild> node.
 
          If the <A::Document.strictErrorChecking> is set to <DOM::false>,
          this exception <kwd:MAY-NOT> be thrown.
      @@@dx:raises:
        @@@@@: c|DIFFERENT_DOCUMENT_ERR
        @@@@enDesc:
          If the <P::newChild> node was created from a different
          document than the one to which the node was created or
          the node does not belong to any document.

          If the <A::Document.strictErrorChecking> is set to <DOM::false>,
          this exception <kwd:MAY-NOT> be thrown.
      @@@dx:raises: 
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the node is read-only.

          If the <A::Document.strictErrorChecking> is set to <DOM::false>,
          this exception <kwd:MAY-NOT> be thrown.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_SRC_PARENT
        @@@@enDesc:
          If the previous parent of the <P::newChild> node is read-only
          <SRC::DOM 2 Errata, DOM 3>.

          If the <A::Document.strictErrorChecking> is set to <DOM::false>,
          this exception <kwd:MAY-NOT> be thrown.
      @@@dx:raises:
        @@@@@: t|HIERARCHY_DOCUMENT_FRAGMENT_ITSELF_ERR
        @@@@enDesc:
          If <P::newChild> is the node itself.
        @@@@For: ManakaiDOM|ManakaiDOM
      @@@PerlDef:
        if ($self eq $newChild) {
          __EXCEPTION{t|HIERARCHY_DOCUMENT_FRAGMENT_ITSELF_ERR::
            MDOMX|param-name => 'newChild',
          }__;
        }
        my $self_od = $self-><AG::Node.ownerDocument>;
        my $child_od = $newChild-><AG::Node.ownerDocument>;
        my $child_nt = $newChild-><AG::Node.nodeType>;
        __CODE{tc|appendChildImpl1::
          $self => $self, $self_od => $self_od,
          $newChild => $newChild, $child_od => $child_od, $child_nt => $child_nt,
          $r => $r,
          $allowedNodeTypes => {{
            <C::Node.TEXT_NODE> => true,
            <C::Node.ENTITY_REFERENCE_NODE> => true,
            <C::Node.ELEMENT_NODE> => true,
            <C::Node.PROCESSING_INSTRUCTION_NODE> => true,
            <C::Node.CDATA_SECTION_NODE> => true,
            <C::Node.COMMENT_NODE> => true,
          }},
        }__;

  @CMethod:
    @@Name: insertBefore
    @@enDesc:
      Inserts a node before the existing child node of the node.

      Inserting a node before itself is implementation dependent.
    @@Param:
      @@@Name: newChild
      @@@Type: Node
      @@@enDesc:
        The node to insert.  If the <P::newChild> is already in 
        the tree, it is first removed.
      @@@InCase:
        @@@@Type: DocumentFragment
        @@@@enDesc:
          All of children of the <P::newChild> node are inserted,
          in the same order, before <P::refChild>.
    @@Param:
      @@@Name: refChild
      @@@Type: Node
      @@@enDesc:
        The reference node, i.e. the node before which the new node
        must be inserted.
      @@@nullCase:
        @@@@enDesc:
          The <P::newChild> node is inserted at the end of the list
          of children.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node being inserted.
      @@@enImplNote:
        What is returned if <P::newChild> is a <IF::DocumentFragment>?
        See also <M::Node.appendChild>'s return value.
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_BAD_TYPE
        @@@@enDesc:
          If the node is of a type that does not allow children of
          the type of the <P::newChild> node.
      @@@dx:raises:
        @@@@@: c|DIFFERENT_DOCUMENT_ERR
        @@@@enDesc:
          If the <P::newChild> node was created from a different
          document than the one that created the node.
        @@@@enImplNote:
          The DOM specification ignores the fact that <IF::Document>s
          and <IF::x|DocumentType>s are created from 
          <IF::c|DOMImplementation> :-)
      @@@dx:raises: 
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the node is read-only.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_SRC_PARENT
        @@@@enDesc:
          If the previous parent of the <P::newChild> node is read-only
          <SRC::DOM 1 SE, DOM 2, 3>.
      @@@dx:raises:
        @@@@@: c|NOT_CHILD_ERR
        @@@@enDesc:
          If the <P::refChild> node is not a child of the node.
      @@@c:reports:
        @@@@@: t|insert-before-itself
        @@@@enDesc:
          If the <P::newChild> node is same as the <P::refChild> node.
          Then, the result is implementation dependent.
        @@@@For: ManakaiDOM|ManakaiDOM
      @@@dx:raises:
        @@@@@: t|HIERARCHY_DOCUMENT_FRAGMENT_ITSELF_ERR
        @@@@enDesc:
          If <P::newChild> is the node itself.
        @@@@For: ManakaiDOM|ManakaiDOM
      @@@PerlDef:
        if ($self eq $newChild) {
          __EXCEPTION{t|HIERARCHY_DOCUMENT_FRAGMENT_ITSELF_ERR::
            MDOMX|param-name => 'newChild',
          }__;
        }
        my $self_od = $self-><AG::Node.ownerDocument>;
        my $child_od = $newChild-><AG::Node.ownerDocument>;
        my $child_nt = $newChild-><AG::Node.nodeType>;
        __CODE{tc|insertBeforeImpl1::
          $self => $self, $self_od => $self_od,
          $newChild => $newChild, $refChild => $refChild,
          $child_od => $child_od, $child_nt => $child_nt,
          $r => $r,
          $allowedNodeTypes => {{
            <C::Node.TEXT_NODE> => true,
            <C::Node.ENTITY_REFERENCE_NODE> => true,
            <C::Node.ELEMENT_NODE> => true,
            <C::Node.PROCESSING_INSTRUCTION_NODE> => true,
            <C::Node.CDATA_SECTION_NODE> => true,
            <C::Node.COMMENT_NODE> => true,
          }},
        }__;

  @CMethod:
    @@Name: replaceChild
    @@enDesc:
      Replaces a child node with another node.

      Replacing a node with itself is implementation dependent <SRC::DOM3>.
    @@Param:
      @@@Name: newChild
      @@@Type: Node
      @@@enDesc:
        The new node to put in the child list.

        If the <P::newChild> node is already in the tree,
        it is first removed.
      @@@InCase:
        @@@@Type: DocumentFragment
        @@@@enDesc:
          The <P::oldChild> node is replaced by all of the 
          <IF::DocumentFragment> children, which are inserted
          in the same order <SRC::DOM1 SE, DOM2, DOM3>.
    @@Param:
      @@@Name: oldChild
      @@@Type: Node
      @@@enDesc:
        The node being replaced in the list.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node replaced.
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_BAD_TYPE
        @@@@enDesc:
          If the node is of a type that does not allow children of
          the type of the <P::newChild> node.
      @@@dx:raises:
        @@@@@: c|DIFFERENT_DOCUMENT_ERR
        @@@@enDesc:
          If the <P::newChild> node was created from a different
          document than the one that created the node.
        @@@@enImplNote:
          The DOM specification ignores the fact that <IF::Document>s
          and <IF::x|DocumentType>s are created from 
          <IF::c|DOMImplementation> :-)
      @@@dx:raises: 
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the node is read-only.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_SRC_PARENT
        @@@@enDesc:
          If the previous parent of the <P::newChild> node is read-only
          <SRC::DOM1 SE, DOM2, DOM3>.
      @@@dx:raises:
        @@@@@: c|NOT_CHILD_ERR
        @@@@enDesc:
          If the <P::oldChild> node is not a child of the node.
      @@@c:reports:
        @@@@@: t|replaced-by-itself
        @@@@enDesc:
          If the <P::newChild> node is same as the <P::oldChild> node.
          Then, the result is implementation dependent.
        @@@@For: ManakaiDOM|ManakaiDOM
      @@@dx:raises:
        @@@@@: t|HIERARCHY_DOCUMENT_FRAGMENT_ITSELF_ERR
        @@@@enDesc:
          If <P::newChild> is the node itself.
        @@@@For: ManakaiDOM|ManakaiDOM
      @@@PerlDef:
        if ($self eq $newChild) {
          __EXCEPTION{t|HIERARCHY_DOCUMENT_FRAGMENT_ITSELF_ERR::
            MDOMX|param-name => 'newChild',
          }__;
        }
        my $self_od = $self-><AG::Node.ownerDocument>;
        my $child_od = $newChild-><AG::Node.ownerDocument>;
        my $child_nt = $newChild-><AG::Node.nodeType>;
        __CODE{tc|replaceChildImpl1::
          $self => $self, $self_od => $self_od,
          $newChild => $newChild, $refChild => $oldChild,
          $child_od => $child_od, $child_nt => $child_nt,
          $r => $r,
          $allowedNodeTypes => {{
            <C::Node.TEXT_NODE> => true,
            <C::Node.ENTITY_REFERENCE_NODE> => true,
            <C::Node.ELEMENT_NODE> => true,
            <C::Node.PROCESSING_INSTRUCTION_NODE> => true,
            <C::Node.CDATA_SECTION_NODE> => true,
            <C::Node.COMMENT_NODE> => true,
          }},
        }__;

  @Test:
    @@QName: DF.attributes.test
    @@PerlDef:
      my $text;
      __CODE{tc|createDFForTest:: $df => $text}__;

      $test->assert_null ($text-><AG::Node.attributes>);

  @CAttr:
    @@Name: nodeName
    @@enDesc:
      The node name.
    @@DOMMain:isNamespaceUnaware:1
    @@Type: DOMString
    @@Get:
      @@@disDef:
        @@@@DISLang:value:
          @@@@@@: \#document-fragment
          @@@@@ContentType:
            DISCore:String

    @@Test:
      @@@QName: DF.nodeName.test
      @@@PerlDef:
        my $text;
        __CODE{tc|createDFForTest:: $df => $text}__;

        $test->assert_equals ($text-><AG::Node.nodeName>,
                              '#document-fragment');

    @@Test:
      @@@QName: DF.appendChild.1.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createTextNode> ('pi');

        my $return = $dtd-><M::Node.appendChild> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: DF.appendChild.1.3.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createElement> ('pi');

        my $return = $dtd-><M::Node.appendChild> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Element>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: DF.appendChild.1.4.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createCDATASection> ('d');

        my $return = $dtd-><M::Node.appendChild> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|CDATASection>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: DF.appendChild.1.5.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createComment> ('pi');

        my $return = $dtd-><M::Node.appendChild> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Comment>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: DF.appendChild.1.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createEntityReference> ('pi');

        my $return = $dtd-><M::Node.appendChild> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|EntityReference>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: DF.appendChild.1.6.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createProcessingInstruction> ('pi');

        my $return = $dtd-><M::Node.appendChild> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|ProcessingInstruction>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: DF.insertBefore.1.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createTextNode> ('pi');

        my $return = $dtd-><M::Node.insertBefore> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: DF.insertBefore.1.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createEntityReference> ('pi');

        my $return = $dtd-><M::Node.insertBefore> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|EntityReference>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: DF.insertBefore.1.3.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createElement> ('pi');

        my $return = $dtd-><M::Node.insertBefore> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Element>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: DF.insertBefore.1.4.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createCDATASection> ('pi');

        my $return = $dtd-><M::Node.insertBefore> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|CDATASection>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: DF.insertBefore.1.5.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createComment> ('pi');

        my $return = $dtd-><M::Node.insertBefore> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Comment>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: DF.insertBefore.1.6.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createProcessingInstruction> ('pi');

        my $return = $dtd-><M::Node.insertBefore> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|ProcessingInstruction>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('return');
        $test->assert_equals ($return, $pi);

    @@Test:
      @@@QName: DF.appendChild.has.parent.1.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createDocumentFragment>;

        my $piparent = $doc-><M::Document.createElementNS> (null, 'e');
        my $pi = $doc-><M::Document.createTextNode> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.appendChild> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: DF.appendChild.has.parent.1.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createDocumentFragment>;

        my $piparent = $doc-><M::Document.createElementNS> (null, 'e');
        my $pi = $doc-><M::Document.createEntityReference> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.appendChild> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|EntityReference>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: DF.appendChild.has.parent.1.3.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createDocumentFragment>;

        my $piparent = $doc-><M::Document.createElementNS> (null, 'e');
        my $pi = $doc-><M::Document.createElement> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.appendChild> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Element>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: DF.appendChild.has.parent.1.4.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createDocumentFragment>;

        my $piparent = $doc-><M::Document.createElementNS> (null, 'e');
        my $pi = $doc-><M::Document.createCDATASection> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.appendChild> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|CDATASection>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: DF.appendChild.has.parent.1.5.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createDocumentFragment>;

        my $piparent = $doc-><M::Document.createElementNS> (null, 'e');
        my $pi = $doc-><M::Document.createComment> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.appendChild> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Comment>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: DF.insertBefore.has.parent.1.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createDocumentFragment>;

        my $piparent = $doc-><M::Document.createElementNS> (null, 'e');
        my $pi = $doc-><M::Document.createTextNode> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.insertBefore> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: DF.insertBefore.has.parent.1.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createDocumentFragment>;

        my $piparent = $doc-><M::Document.createElementNS> (null, 'e');
        my $pi = $doc-><M::Document.createEntityReference> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.insertBefore> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|EntityReference>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: DF.insertBefore.has.parent.1.3.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createDocumentFragment>;

        my $piparent = $doc-><M::Document.createElementNS> (null, 'e');
        my $pi = $doc-><M::Document.createElement> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.insertBefore> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Element>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: DF.insertBefore.has.parent.1.4.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createDocumentFragment>;

        my $piparent = $doc-><M::Document.createElementNS> (null, 'e');
        my $pi = $doc-><M::Document.createCDATASection> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.insertBefore> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|CDATASection>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: DF.insertBefore.has.parent.1.5.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createDocumentFragment>;

        my $piparent = $doc-><M::Document.createElementNS> (null, 'e');
        my $pi = $doc-><M::Document.createComment> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.insertBefore> ($pi);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Comment>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi);
    @@Test:
      @@@QName: DF.appendChild.documentfragment.1.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createDocumentFragment>;

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createTextNode> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.appendChild> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: DF.appendChild.documentfragment.1.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createDocumentFragment>;

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createEntityReference> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.appendChild> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|EntityReference>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: DF.appendChild.documentfragment.1.3.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createDocumentFragment>;

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createElement> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.appendChild> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Element>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: DF.appendChild.documentfragment.1.4.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createDocumentFragment>;

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createCDATASection> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.appendChild> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|CDATASection>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: DF.appendChild.documentfragment.1.5.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createDocumentFragment>;

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createComment> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.appendChild> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Comment>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: DF.insertBefore.documentfragment.1.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createDocumentFragment>;

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createTextNode> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.insertBefore> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: DF.insertBefore.documentfragment.1.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createDocumentFragment>;

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createEntityReference> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.insertBefore> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|EntityReference>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: DF.insertBefore.documentfragment.1.3.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createDocumentFragment>;

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createElement> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.insertBefore> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Element>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: DF.insertBefore.documentfragment.1.4.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createDocumentFragment>;

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createCDATASection> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.insertBefore> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|CDATASection>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: DF.insertBefore.documentfragment.1.5.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createDocumentFragment>;

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createComment> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.insertBefore> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Comment>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: DF.replaceChild.documentfragment.1.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createDocumentFragment>;
        my $pi0 = $doc-><M::Document.createTextNode> ('pi0');
        $dtd-><M::Node.appendChild> ($pi0);

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createTextNode> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.replaceChild> ($piparent, $pi0);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi0);
    @@Test:
      @@@QName: DF.replaceChild.documentfragment.1.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createDocumentFragment>;
        my $pi0 = $doc-><M::Document.createTextNode> ('pi0');
        $dtd-><M::Node.appendChild> ($pi0);

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createEntityReference> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.replaceChild> ($piparent, $pi0);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|EntityReference>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi0);
    @@Test:
      @@@QName: DF.replaceChild.documentfragment.1.3.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createDocumentFragment>;
        my $pi0 = $doc-><M::Document.createTextNode> ('pi0');
        $dtd-><M::Node.appendChild> ($pi0);

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createElement> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.replaceChild> ($piparent, $pi0);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Element>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi0);
    @@Test:
      @@@QName: DF.replaceChild.documentfragment.1.4.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createDocumentFragment>;
        my $pi0 = $doc-><M::Document.createTextNode> ('pi0');
        $dtd-><M::Node.appendChild> ($pi0);

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createCDATASection> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.replaceChild> ($piparent, $pi0);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::tx|CDATASection>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi0);
    @@Test:
      @@@QName: DF.replaceChild.documentfragment.1.5.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createDocumentFragment>;
        my $pi0 = $doc-><M::Document.createTextNode> ('pi0');
        $dtd-><M::Node.appendChild> ($pi0);

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createComment> ('pi');
        $piparent-><M::Node.appendChild> ($pi);

        my $return = $dtd-><M::Node.replaceChild> ($piparent, $pi0);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 1);

        my $item = $child-><M::NodeList.item> (0);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Comment>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi0);

    @@Test:
      @@@QName: DF.appendChild.documentfragment.2.1.test
      @@@enDesc:
        Empty document fragment.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createDocumentFragment>;

        my $piparent = $doc-><M::Document.createDocumentFragment>;

        my $return = $dtd-><M::Node.appendChild> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 0);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: DF.insertBefore.documentfragment.2.test
      @@@enDesc:
        Empty document fragment.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createDocumentFragment>;

        my $piparent = $doc-><M::Document.createDocumentFragment>;

        my $return = $dtd-><M::Node.insertBefore> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 0);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: DF.replaceChild.documentfragment.2.test
      @@@enDesc:
        Empty document fragment.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createDocumentFragment>;
        my $pi0 = $doc-><M::Document.createTextNode> ('pi0');
        $dtd-><M::Node.appendChild> ($pi0);

        my $piparent = $doc-><M::Document.createDocumentFragment>;

        my $return = $dtd-><M::Node.replaceChild> ($piparent, $pi0);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 0);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi0);

    @@Test:
      @@@QName: DF.appendChild.documentfragment.3.test
      @@@enDesc:
        Three PIs in document fragment.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createDocumentFragment>;

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createTextNode> ('pi');
        my $pi2 = $doc-><M::Document.createEntityReference> ('pi2');
        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $piparent-><M::Node.appendChild> ($pi);
        $piparent-><M::Node.appendChild> ($pi2);
        $piparent-><M::Node.appendChild> ($pi3);

        my $return = $dtd-><M::Node.appendChild> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 3);

        my $item = $child-><M::NodeList.item> (0);
        my $item2 = $child-><M::NodeList.item> (1);
        my $item3 = $child-><M::NodeList.item> (2);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);
        $test->id ('child.item.node2');
        $test->assert_isa ($item2, <IFName::Node>);
        $test->id ('child.item.node3');
        $test->assert_isa ($item3, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);
        $test->id ('child.item.pi2');
        $test->assert_isa ($item2, <IFName::tx|EntityReference>);
        $test->id ('child.item.pi3');
        $test->assert_isa ($item3, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);
        $test->id ('child.item.equals2');
        $test->assert_equals ($item2, $pi2);
        $test->id ('child.item.equals3');
        $test->assert_equals ($item3, $pi3);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi3);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);
        $test->id ('parent2');
        my $parent2 = $item2-><AG::Node.parentNode>;
        $test->assert_equals ($parent2, $dtd);
        $test->id ('parent3');
        my $parent3 = $item3-><AG::Node.parentNode>;
        $test->assert_equals ($parent3, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: DF.insertBefore.documentfragment.3.test
      @@@enDesc:
        Three PIs in document fragment.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createDocumentFragment>;

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createTextNode> ('pi');
        my $pi2 = $doc-><M::Document.createEntityReference> ('pi2');
        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $piparent-><M::Node.appendChild> ($pi);
        $piparent-><M::Node.appendChild> ($pi2);
        $piparent-><M::Node.appendChild> ($pi3);

        my $return = $dtd-><M::Node.insertBefore> ($piparent);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 3);

        my $item = $child-><M::NodeList.item> (0);
        my $item2 = $child-><M::NodeList.item> (1);
        my $item3 = $child-><M::NodeList.item> (2);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);
        $test->id ('child.item.node2');
        $test->assert_isa ($item2, <IFName::Node>);
        $test->id ('child.item.node3');
        $test->assert_isa ($item3, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);
        $test->id ('child.item.pi2');
        $test->assert_isa ($item2, <IFName::tx|EntityReference>);
        $test->id ('child.item.pi3');
        $test->assert_isa ($item3, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);
        $test->id ('child.item.equals2');
        $test->assert_equals ($item2, $pi2);
        $test->id ('child.item.equals3');
        $test->assert_equals ($item3, $pi3);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi3);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);
        $test->id ('parent2');
        my $parent2 = $item2-><AG::Node.parentNode>;
        $test->assert_equals ($parent2, $dtd);
        $test->id ('parent3');
        my $parent3 = $item3-><AG::Node.parentNode>;
        $test->assert_equals ($parent3, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $piparent);
    @@Test:
      @@@QName: DF.replaceChild.documentfragment.3.test
      @@@enDesc:
        Three PIs in document fragment.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createDocumentFragment>;
        my $pi0 = $doc-><M::Document.createTextNode> ('pi0');
        $dtd-><M::Node.appendChild> ($pi0);

        my $piparent = $doc-><M::Document.createDocumentFragment>;
        my $pi = $doc-><M::Document.createTextNode> ('pi');
        my $pi2 = $doc-><M::Document.createEntityReference> ('pi2');
        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $piparent-><M::Node.appendChild> ($pi);
        $piparent-><M::Node.appendChild> ($pi2);
        $piparent-><M::Node.appendChild> ($pi3);

        my $return = $dtd-><M::Node.replaceChild> ($piparent, $pi0);

        my $child = $dtd-><AG::Node.childNodes>;

        $test->id ('child.length');
        $test->assert_num_equals
                 (actual_value => 0+@$child,
                  expected_value => 3);

        my $item = $child-><M::NodeList.item> (0);
        my $item2 = $child-><M::NodeList.item> (1);
        my $item3 = $child-><M::NodeList.item> (2);

        $test->id ('child.item.node');
        $test->assert_isa ($item, <IFName::Node>);
        $test->id ('child.item.node2');
        $test->assert_isa ($item2, <IFName::Node>);
        $test->id ('child.item.node3');
        $test->assert_isa ($item3, <IFName::Node>);

        $test->id ('child.item.pi');
        $test->assert_isa ($item, <IFName::Text>);
        $test->id ('child.item.pi2');
        $test->assert_isa ($item2, <IFName::tx|EntityReference>);
        $test->id ('child.item.pi3');
        $test->assert_isa ($item3, <IFName::Text>);

        $test->id ('child.item.equals');
        $test->assert_equals ($item, $pi);
        $test->id ('child.item.equals2');
        $test->assert_equals ($item2, $pi2);
        $test->id ('child.item.equals3');
        $test->assert_equals ($item3, $pi3);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi3);

        $test->id ('parent');
        my $parent = $item-><AG::Node.parentNode>;
        $test->assert_equals ($parent, $dtd);
        $test->id ('parent2');
        my $parent2 = $item2-><AG::Node.parentNode>;
        $test->assert_equals ($parent2, $dtd);
        $test->id ('parent3');
        my $parent3 = $item3-><AG::Node.parentNode>;
        $test->assert_equals ($parent3, $dtd);

        $test->id ('former.parent.child');
        my $piparentchild = $piparent-><AG::Node.childNodes>;
        $test->assert_num_equals
                 (actual_value => 0+@$piparentchild,
                  expected_value => 0);

        $test->id ('return');
        $test->assert_equals ($return, $pi0);

    @@Test:
      @@@QName: DF.appendChild.badtype.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $comment = $doc-><M::Document.createDocumentFragment>;
        my $pi0 = $doc-><M::Document.createTextNode> ('pi0');
        $comment-><M::Node.appendChild> ($pi0);

        for my $node (
          $docx-><M::d|DocumentXDoctype.createDocumentTypeDefinition> ('d'),
          $doc-><M::Document.createAttribute> ('a'),
          $docx-><M::d|DocumentXDoctype.createGeneralEntity> ('ge'),
          $docx-><M::d|DocumentXDoctype.createNotation> ('not'),
          $docx-><M::d|DocumentXDoctype.createElementTypeDefinition> ('et'),
          $docx-><M::d|DocumentXDoctype.createAttributeDefinition> ('at'),
          #test:nodeTypes
        ) {
          $test->id ('appendChild.'.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.appendChild> ($node);
          }, exception_subtype => <Q::MDOMX|HIERARCHY_BAD_TYPE>);

          $test->id ('insertBefore.'.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.insertBefore> ($node);
          }, exception_subtype => <Q::MDOMX|HIERARCHY_BAD_TYPE>);

          $test->id ('replaceChild.'.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.replaceChild> ($node, $pi0);
          }, exception_subtype => <Q::MDOMX|HIERARCHY_BAD_TYPE>);
        }

    @@Test:
      @@@QName: DF.appendChild.wrongdoc.test
      @@@PerlDef:
        my $doc0;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc0}__;

        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $comment = $doc0-><M::Document.createDocumentFragment>;

        for my $node (
          $doc-><M::Document.createTextNode> ('pi'),
          $doc-><M::Document.createEntityReference> ('e'),
          $doc-><M::Document.createComment> ('c'),
          $doc-><M::Document.createCDATASection> ('cs'),
          $doc-><M::Document.createElement> ('el'),
        ) {
          $test->id ('type='.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.appendChild> ($node);
          }, exception_subtype => <Q::c|DIFFERENT_DOCUMENT_ERR>);
        }
    @@Test:
      @@@QName: DF.insertBefore.wrongdoc.test
      @@@PerlDef:
        my $doc0;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc0}__;
        my $docx0 = $doc0-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $comment = $doc0-><M::Document.createDocumentFragment>;
        my $pi0 = $doc0-><M::Document.createTextNode> ('pi0');
        $comment-><M::Node.appendChild> ($pi0);

        for my $node (
          $doc-><M::Document.createTextNode> ('pi'),
          $doc-><M::Document.createEntityReference> ('ent'),
          $doc-><M::Document.createComment> ('c'),
          $doc-><M::Document.createCDATASection> ('cs'),
          $doc-><M::Document.createElement> ('el'),
        ) {
          $test->id ('appendChild.'.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.appendChild> ($node);
          }, exception_subtype => <Q::c|DIFFERENT_DOCUMENT_ERR>);

          $test->id ('insertBefore.'.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.insertBefore> ($node);
          }, exception_subtype => <Q::c|DIFFERENT_DOCUMENT_ERR>);

          $test->id ('replaceChild.'.$node-><AG::Node.nodeType>);
          $test->assert_exception (code => sub {
            $comment-><M::Node.replaceChild> ($node, $pi0);
          }, exception_subtype => <Q::c|DIFFERENT_DOCUMENT_ERR>);
        }

    @@Test:
      @@@QName: DF.appendChild.readonly.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createDocumentFragment>;
        my $pi0 = $doc-><M::Document.createTextNode> ('pi0');
        $dtd-><M::Node.appendChild> ($pi0);
        $dtd-><M::Node.manakaiSetReadOnly> (true);

        $test->id ('pi');
        my $node = $doc-><M::Document.createTextNode> ('pi');

        $test->assert_exception (code => sub {
          $dtd-><M::Node.appendChild> ($node);
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);

        $test->id ('pi.insertBefore');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.insertBefore> ($node);
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);

        $test->id ('pi.replaceChild');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.replaceChild> ($node, $pi0);
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);

        $test->id ('fragment');
        my $node2 = $doc-><M::Document.createDocumentFragment>;
        $node2-><M::Node.appendChild> ($node);

        $test->assert_exception (code => sub {
          $dtd-><M::Node.appendChild> ($node2);
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);

        $test->id ('fragment.insertBefore');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.insertBefore> ($node2);
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);

        $test->id ('fragment.replaceChild');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.replaceChild> ($node2, $pi0);
        }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);

    @@Test:
      @@@QName: DF.appendChild.readonly.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createDocumentFragment>;
        my $pi0 = $doc-><M::Document.createTextNode> ('pi0');
        $dtd-><M::Node.appendChild> ($pi0);

        $test->id ('pi');
        my $el = $doc-><M::Document.createElementNS> (null, 'e');
        my $node = $doc-><M::Document.createTextNode> ('pi');
        $el-><M::Node.appendChild> ($node);
        $el-><M::Node.manakaiSetReadOnly> (true);

        $test->assert_exception (code => sub {
          $dtd-><M::Node.appendChild> ($node);
        }, exception_subtype => <Q::MDOMX|NOMOD_SRC_PARENT>);

        $test->id ('pi.insertBefore');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.insertBefore> ($node);
        }, exception_subtype => <Q::MDOMX|NOMOD_SRC_PARENT>);

        $test->id ('pi.replaceChild');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.replaceChild> ($node, $pi0);
        }, exception_subtype => <Q::MDOMX|NOMOD_SRC_PARENT>);

        $test->id ('fragment');
        my $node2 = $doc-><M::Document.createDocumentFragment>;
        my $node3 = $doc-><M::Document.createTextNode> ('pi');
        $node2-><M::Node.appendChild> ($node3);
        $node2-><M::Node.manakaiSetReadOnly> (true);

        $test->assert_exception (code => sub {
          $dtd-><M::Node.appendChild> ($node2);
        }, exception_subtype => <Q::MDOMX|NOMOD_SRC_PARENT>);

        $test->id ('fragment.insertBefore');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.insertBefore> ($node2);
        }, exception_subtype => <Q::MDOMX|NOMOD_SRC_PARENT>);

        $test->id ('fragment.replaceChild');
        $test->assert_exception (code => sub {
          $dtd-><M::Node.replaceChild> ($node2, $pi0);
        }, exception_subtype => <Q::MDOMX|NOMOD_SRC_PARENT>);

    @@Test:
      @@@QName: DF.insertBefore.refChild.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createDocumentFragment>;

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.insertBefore> ($pi2, $pi1);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi2);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi1);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: DF.insertBefore.refChild.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $dtd = $doc-><M::Document.createDocumentFragment>;

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $dtd-><M::Node.insertBefore> ($pi3, $pi2);

        # pi1, pi3, pi2

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi1);

        $test->id ('firstChild.nextSibling');
        $test->assert_equals ($dtd-><AG::Node.firstChild>
                                  -><AG::Node.nextSibling>, $pi3);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi2);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 3);

    @@Test:
      @@@QName: DF.insertBefore.refChild.3.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createDocumentFragment>;

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $dtd-><M::Node.appendChild> ($pi3);

        # pi1, pi2, pi3

        $dtd-><M::Node.insertBefore> ($pi2, $pi1);
 
        # pi2, pi1, pi3

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi2);

        $test->id ('firstChild.nextSibling');
        $test->assert_equals ($dtd-><AG::Node.firstChild>
                                  -><AG::Node.nextSibling>, $pi1);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi3);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 3);

    @@Test:
      @@@QName: DF.insertBefore.refChild.4.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createDocumentFragment>;

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $dtd-><M::Node.appendChild> ($pi3);

        # pi1, pi2, pi3

        $dtd-><M::Node.insertBefore> ($pi3, $pi1);
 
        # pi3, pi1, pi2

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi3);

        $test->id ('firstChild.nextSibling');
        $test->assert_equals ($dtd-><AG::Node.firstChild>
                                  -><AG::Node.nextSibling>, $pi1);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi2);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 3);

    @@Test:
      @@@QName: DF.insertBefore.refChild.not_found_err.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createDocumentFragment>;

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');

        my $pi4 = $doc-><M::Document.createTextNode> ('pi4');

        # pi1, pi2

        $test->assert_exception (code => sub {
          $dtd-><M::Node.insertBefore> ($pi4, $pi3);
        }, exception_subtype => <Q::c|NOT_CHILD_ERR>);

    @@Test:
      @@@QName: DF.insertBefore.refChild=newChild.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createDocumentFragment>;

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        # pi1, pi2

        my $eh_called = false;
        my $cfg = $doc-><AG::Document.domConfig>;
        $cfg-><M::c|DOMConfiguration.setParameter> ('error-handler' => sub {
          my (undef, $err) = @_;
          $eh_called = true;
          $test->assert_equals ($err-><AG::c|DOMError.severity>,
                                <C::c|DOMError.SEVERITY_WARNING>);
          $test->assert_equals ($err-><AG::c|DOMError.type>,
                                <Q::t|insert-before-itself>);
          $test->assert_equals ($err-><AG::c|DOMError.relatedData>, $pi2);
          $test->assert_null ($err-><AG::c|DOMError.relatedException>);
          $test->assert_isa ($err-><AG::c|DOMError.location>,
                             <IFName::c|DOMLocator>);
          $test->assert_not_null ($err-><AG::c|DOMError.message>);
        });

        $test->assert_false ($eh_called);
        $dtd-><M::Node.insertBefore> ($pi2, $pi2);
        $test->assert_true ($eh_called);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi1);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi2);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: DF.replaceChild.oldChild=newChild.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createDocumentFragment>;

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        # pi1, pi2

        my $eh_called = false;
        my $cfg = $doc-><AG::Document.domConfig>;
        $cfg-><M::c|DOMConfiguration.setParameter> ('error-handler' => sub {
          my (undef, $err) = @_;
          $eh_called = true;
          $test->assert_equals ($err-><AG::c|DOMError.severity>,
                                <C::c|DOMError.SEVERITY_WARNING>);
          $test->assert_equals ($err-><AG::c|DOMError.type>,
                                <Q::t|replace-by-itself>);
          $test->assert_equals ($err-><AG::c|DOMError.relatedData>, $pi2);
          $test->assert_null ($err-><AG::c|DOMError.relatedException>);
          $test->assert_isa ($err-><AG::c|DOMError.location>,
                             <IFName::c|DOMLocator>);
          $test->assert_not_null ($err-><AG::c|DOMError.message>);
        });

        $test->assert_false ($eh_called);
        $dtd-><M::Node.replaceChild> ($pi2, $pi2);
        $test->assert_true ($eh_called);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi1);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi2);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: DF.appendChild.sameparent.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createDocumentFragment>;

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        # pi1, pi2

        my $return = $dtd-><M::Node.appendChild> ($pi1);

        # pi2, pi1

        $test->id ('return');
        $test->assert_equals ($return, $pi1);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi2);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi1);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: DF.insertBefore.sameparent.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createDocumentFragment>;

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        # pi1, pi2

        my $return = $dtd-><M::Node.insertBefore> ($pi1);

        # pi2, pi1

        $test->id ('return');
        $test->assert_equals ($return, $pi1);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi2);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi1);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: DF.appendChild.sameparent.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createDocumentFragment>;

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        # pi1, pi2

        my $return = $dtd-><M::Node.appendChild> ($pi2);

        # pi1, pi2

        $test->id ('return');
        $test->assert_equals ($return, $pi2);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi1);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi2);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: DF.insertBefore.sameparent.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createDocumentFragment>;

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        # pi1, pi2

        my $return = $dtd-><M::Node.insertBefore> ($pi2);

        # pi1, pi2

        $test->id ('return');
        $test->assert_equals ($return, $pi2);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi1);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi2);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$dtd-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: DF.replaceChild.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createDocumentFragment>;

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $dtd-><M::Node.appendChild> ($pi3);

        # pi1, pi2, pi3

        my $pi9 = $doc-><M::Document.createTextNode> ('pi9');
        my $return = $dtd-><M::Node.replaceChild> ($pi9, $pi1);

        # pi9, pi2, pi3

        $test->id ('return.node');
        $test->assert_isa ($return, <IFName::Node>);
        $test->id ('return.pi');
        $test->assert_isa ($return, <IFName::Text>);
        $test->id ('return');
        $test->assert_equals ($return, $pi1);

        my $c = $dtd-><AG::Node.childNodes>;

        $test->id ('length');
        $test->assert_num_equals (actual_value => 0+@$c, expected_value => 3);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi9);

        $test->id ('firstChild.nextSibling');
        $test->assert_equals ($dtd-><AG::Node.firstChild>
                                  -><AG::Node.nextSibling>, $pi2);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi3);
 
        $test->id ('parent');
        $test->assert_equals ($pi9-><AG::Node.parentNode>, $dtd);

        $test->id ('return.parent');
        $test->assert_null ($pi1-><AG::Node.parentNode>);

    @@Test:
      @@@QName: DF.replaceChild.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createDocumentFragment>;

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $dtd-><M::Node.appendChild> ($pi3);

        # pi1, pi2, pi3

        my $pi9 = $doc-><M::Document.createTextNode> ('pi9');
        my $return = $dtd-><M::Node.replaceChild> ($pi9, $pi2);

        # pi1, pi9, pi3

        $test->id ('return.node');
        $test->assert_isa ($return, <IFName::Node>);
        $test->id ('return.pi');
        $test->assert_isa ($return, <IFName::Text>);
        $test->id ('return');
        $test->assert_equals ($return, $pi2);

        my $c = $dtd-><AG::Node.childNodes>;

        $test->id ('length');
        $test->assert_num_equals (actual_value => 0+@$c, expected_value => 3);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi1);

        $test->id ('firstChild.nextSibling');
        $test->assert_equals ($dtd-><AG::Node.firstChild>
                                  -><AG::Node.nextSibling>, $pi9);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi3);
 
        $test->id ('parent');
        $test->assert_equals ($pi9-><AG::Node.parentNode>, $dtd);

        $test->id ('return.parent');
        $test->assert_null ($pi2-><AG::Node.parentNode>);

    @@Test:
      @@@QName: DF.replaceChild.3.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createDocumentFragment>;

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $dtd-><M::Node.appendChild> ($pi3);

        # pi1, pi2, pi3

        my $pi9 = $doc-><M::Document.createTextNode> ('pi9');
        my $return = $dtd-><M::Node.replaceChild> ($pi9, $pi3);

        # pi1, pi2, pi9

        $test->id ('return.node');
        $test->assert_isa ($return, <IFName::Node>);
        $test->id ('return.pi');
        $test->assert_isa ($return, <IFName::Text>);
        $test->id ('return');
        $test->assert_equals ($return, $pi3);

        my $c = $dtd-><AG::Node.childNodes>;

        $test->id ('length');
        $test->assert_num_equals (actual_value => 0+@$c, expected_value => 3);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi1);

        $test->id ('firstChild.nextSibling');
        $test->assert_equals ($dtd-><AG::Node.firstChild>
                                  -><AG::Node.nextSibling>, $pi2);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi9);
 
        $test->id ('parent');
        $test->assert_equals ($pi9-><AG::Node.parentNode>, $dtd);

        $test->id ('return.parent');
        $test->assert_null ($pi3-><AG::Node.parentNode>);

    @@Test:
      @@@QName: DF.replaceChild.sameparent.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createDocumentFragment>;

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $dtd-><M::Node.appendChild> ($pi3);

        # pi1, pi2, pi3

        my $return = $dtd-><M::Node.replaceChild> ($pi3, $pi1);

        # pi3, pi2

        $test->id ('return.node');
        $test->assert_isa ($return, <IFName::Node>);
        $test->id ('return.pi');
        $test->assert_isa ($return, <IFName::Text>);
        $test->id ('return');
        $test->assert_equals ($return, $pi1);

        my $c = $dtd-><AG::Node.childNodes>;

        $test->id ('length');
        $test->assert_num_equals (actual_value => 0+@$c, expected_value => 2);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi3);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi2);
 
        $test->id ('parent');
        $test->assert_equals ($pi3-><AG::Node.parentNode>, $dtd);

        $test->id ('return.parent');
        $test->assert_null ($pi1-><AG::Node.parentNode>);

    @@Test:
      @@@QName: DF.replaceChild.sameparent.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        my $dtd = $doc-><M::Document.createDocumentFragment>;

        my $pi1 = $doc-><M::Document.createTextNode> ('pi1');
        $dtd-><M::Node.appendChild> ($pi1);

        my $pi2 = $doc-><M::Document.createTextNode> ('pi2');
        $dtd-><M::Node.appendChild> ($pi2);

        my $pi3 = $doc-><M::Document.createTextNode> ('pi3');
        $dtd-><M::Node.appendChild> ($pi3);

        # pi1, pi2, pi3

        my $return = $dtd-><M::Node.replaceChild> ($pi1, $pi3);

        # pi2, pi1

        $test->id ('return.node');
        $test->assert_isa ($return, <IFName::Node>);
        $test->id ('return.pi');
        $test->assert_isa ($return, <IFName::Text>);
        $test->id ('return');
        $test->assert_equals ($return, $pi3);

        my $c = $dtd-><AG::Node.childNodes>;

        $test->id ('length');
        $test->assert_num_equals (actual_value => 0+@$c, expected_value => 2);

        $test->id ('firstChild');
        $test->assert_equals ($dtd-><AG::Node.firstChild>, $pi2);

        $test->id ('lastChild');
        $test->assert_equals ($dtd-><AG::Node.lastChild>, $pi1);
 
        $test->id ('parent');
        $test->assert_equals ($pi1-><AG::Node.parentNode>, $dtd);

        $test->id ('return.parent');
        $test->assert_null ($pi3-><AG::Node.parentNode>);

    @@Test:
      @@@QName: DF.appendChild.itself.test
      @@@enDesc:
        See SuikaWiki
        <URI::http://suika.fam.cx/gate/2005/sw/appendChild#anchor-1>.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $df = $doc-><M::Document.createDocumentFragment>;
        $df-><M::Node.appendChild>
               ($doc-><M::Document.createTextNode> ('text1'));
        $df-><M::Node.appendChild>
               ($doc-><M::Document.createElement> ('e'));
        $df-><M::Node.appendChild>
               ($doc-><M::Document.createTextNode> ('text2'));

        $test->assert_exception (code => sub {
          $df-><M::Node.appendChild> ($df);
        }, exception_subtype => <Q::t|HIERARCHY_DOCUMENT_FRAGMENT_ITSELF_ERR>);
    @@Test:
      @@@QName: DF.insertBefore.itself.test
      @@@enDesc:
        See SuikaWiki
        <URI::http://suika.fam.cx/gate/2005/sw/appendChild#anchor-1>.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $df = $doc-><M::Document.createDocumentFragment>;
        $df-><M::Node.appendChild>
               ($doc-><M::Document.createTextNode> ('text1'));
        $df-><M::Node.appendChild>
               ($doc-><M::Document.createElement> ('e'));
        $df-><M::Node.appendChild>
               ($doc-><M::Document.createTextNode> ('text2'));

        $test->assert_exception (code => sub {
          $df-><M::Node.insertBefore> ($df);
        }, exception_subtype => <Q::t|HIERARCHY_DOCUMENT_FRAGMENT_ITSELF_ERR>);
    @@Test:
      @@@QName: DF.replaceChild.itself.test
      @@@enDesc:
        See SuikaWiki
        <URI::http://suika.fam.cx/gate/2005/sw/appendChild#anchor-1>.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $df = $doc-><M::Document.createDocumentFragment>;
        $df-><M::Node.appendChild>
               ($doc-><M::Document.createTextNode> ('text1'));
        $df-><M::Node.appendChild>
               ($doc-><M::Document.createElement> ('e'));
        $df-><M::Node.appendChild>
               ($doc-><M::Document.createTextNode> ('text2'));

        $test->assert_exception (code => sub {
          $df-><M::Node.replaceChild> ($df, $df-><AG::Node.firstChild>);
        }, exception_subtype => <Q::t|HIERARCHY_DOCUMENT_FRAGMENT_ITSELF_ERR>);

  @CMethod:
    @@Name: manakaiAppendText
    @@Param:
      @@@Name: string
      @@@Type: DOMString
      @@@enDesc:
        The string to append.
      @@@InCase:
        @@@@Type: DISPerl|SCALAR||ManakaiDOM|all
        @@@@enDesc:
          A copy of the string value referenced from the value
          is appended.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node itself.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the node to insert the string or a <IF::Text> node
          is read-only.
      @@@disDef:
        @@@@DISPerl:cloneCode: ManakaiDOMAttr.manakaiAppendText

    @@Test:
      @@@QName: DF..=.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $node = $doc-><M::Document.createDocumentFragment>;

        $node-><M::Node.manakaiAppendText> ('string');
        $test->id ('1.class');
        $test->assert_isa ($node, <IFName::DocumentFragment>);
        $test->id ('1.value');
        $test->assert_equals ($node-><AG::Node.textContent>, 'string');
        $test->id ('1.length');
        $test->assert_num_equals
                 (expected_value => 1,
                  actual_value => 0+@{$node-><AG::Node.childNodes>});

        $test->id (2);
        $node-><M::Node.manakaiAppendText> ('STRING');
        $test->assert_equals ($node-><AG::Node.textContent>, 'stringSTRING');
        $test->assert_num_equals
                 (expected_value => 1,
                  actual_value => 0+@{$node-><AG::Node.childNodes>});

        $node-><M::Node.appendChild>
                 ($doc-><M::Document.createEntityReference> ('er'));

        $test->id (3);
        $node-><M::Node.manakaiAppendText> ('text');
        $test->assert_equals ($node-><AG::Node.textContent>, 'stringSTRINGtext');
        $test->assert_num_equals
                 (expected_value => 3,
                  actual_value => 0+@{$node-><AG::Node.childNodes>});

  @CL3Method:
    @@Name: getFeature
    @@enDesc:
      Returns a specialized object that implements the specialized APIs.
    @@Param:
      @@@Name: feature
      @@@Type: DOMString
      @@@dis:actualType: f|FeatureNameString
    @@Param:
      @@@Name: version
      @@@Type: DOMString
      @@@dis:actualType: f|FeatureVersionString
    @@Return:
      @@@Type: DOMMain|DOMObject
      @@@nullCase:
      @@@PerlDef:
        $feature =~ s/^\+//;
        __CODE{f|getFeatureImpl::
          $self => $self,
          $feature => $feature, $version => $version, $r => $r,
          $base_class => {<ClassName::ManakaiDOMDocumentFragment>},
        }__;
        unless (defined $r) {
          __DEEP{
            $r = $self->SUPER::get_feature ($feature, $version);
          }__;
        }

    @@Test:
      @@@QName: DF.getFeature.test
      @@@PerlDef:
        my $node;
        __CODE{tc|createDFForTest:: $df => $node}__;

        for (
          [Core => '1.0', <IFName::DocumentFragment||ManakaiDOM|ManakaiDOM1>],
          [Core => '2.0', <IFName::DocumentFragment||ManakaiDOM|ManakaiDOM2>],
          [Core => '3.0', <IFName::DocumentFragment||ManakaiDOM|ManakaiDOM3>],
          [XML => '1.0', <IFName::DocumentFragment||ManakaiDOM|ManakaiDOM1>],
          [XML => '2.0', <IFName::DocumentFragment||ManakaiDOM|ManakaiDOM2>],
          [XML => '3.0', <IFName::DocumentFragment||ManakaiDOM|ManakaiDOM3>],
        ) {
          $test->id ($_->[0].'.'.$_->[1]);
          my $sp = $node-><M::Node.getFeature> ($_->[0], $_->[1]);
          $test->assert_isa ($sp, $_->[2]);
        }

  @CL3Attr:
    @@Name: baseURI
    @@enDesc:
      The base URI of the node.
    @@Type: DOMString
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          If it is not available.
      @@@PerlDef:
        __DEEP{
          $r = $self-><AG::Node.ownerDocument>-><AG::Node.baseURI>;
        }__;

    @@L3Test:
      @@@QName: DocumentFragment.baseURI.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $df = $doc-><M::Document.createDocumentFragment>;
 
        $test->id ('initial');
        $test->assert_null ($df-><AG::Node.baseURI>);

        $test->id ('doc.uri');
        $doc-><AS::Document.manakaiEntityBaseURI> (q<ftp://suika.fam.cx/>);
        $test->assert_equals ($df-><AG::Node.baseURI>,
                              q<ftp://suika.fam.cx/>);
##DocumentFragment

ForDef:
  @QName: tc|ForChildNodeList
  @enDesc:
    For node lists returned by the attribute <A::Node.childNodes>.
  @ISA: ManakaiDOM|ForClass

ForDef:
  @QName: tc|ForGetNodeList
  @enDesc:
    For node lists returned by e.g. the method <M::Element.getElementsByTagName>.
  @ISA: ManakaiDOM|ForClass

ForDef:
  @QName: tc|ForEmptyNodeList
  @enDesc:
    For always-empty node lists.
  @ISA: ManakaiDOM|ForClass

ResourceDef:
  @DISCore:resourceType:
    @@@: dis|MultipleResource
    @@ForCheck:
      !ManakaiDOM|ForIF !tc|ForChildNodeList !tc|ForGetNodeList
      !tc|ForEmptyNodeList
  @ForCheck: ManakaiDOM|DOM

  @resourceFor: ManakaiDOM|ForIF
  @IFQName: NodeList
  @DISCore:resourceType:
    @@@: DISLang|Interface
    @@ForCheck: ManakaiDOM|ForIF

  @DOMMain:implementFeature:
    @@@: c|CoreFeature10
    @@ForCheck: ManakaiDOM|DOM1
  @DOMMain:implementFeature:
    @@@: c|CoreFeature20
    @@ForCheck: ManakaiDOM|DOM2
  @DOMMain:implementFeature:
    @@@: c|CoreFeature30
    @@ForCheck: ManakaiDOM|DOM3

  @resourceFor:
    @@@: tc|ForChildNodeList
    @@For: ManakaiDOM|ManakaiDOMLatest
  @QName:
    @@@: ManakaiDOMChildNodeList
    @@ForCheck: tc|ForChildNodeList
  @DISCore:resourceType:
    @@@: DISLang|Class
    @@ForCheck: tc|ForChildNodeList

  @AppISA:
    @@ForCheck: tc|ForChildNodeList
    @@ContentType: DISPerl|Perl
    @@@:
      Tie::Array

  @resourceFor:
    @@@: tc|ForGetNodeList
    @@ForCheck:
      ManakaiDOM:ManakaiDOM !=ManakaiDOM:ManakaiDOM
  @QName:
    @@@: ManakaiDOMGetElementsNodeList
    @@ForCheck: tc|ForGetNodeList
  @rdf:type:
    @@@: DISPerl|Class
    @@ForCheck: tc|ForGetNodeList

  @AppISA:
    @@ForCheck: tc|ForGetNodeList
    @@ContentType: DISPerl|Perl
    @@@:
      Tie::Array

  @resourceFor:
    @@@: tc|ForEmptyNodeList
    @@ForCheck: ManakaiDOM|ManakaiDOMLatest
  @QName:
    @@@: ManakaiDOMEmptyNodeList
    @@ForCheck: tc|ForEmptyNodeList
  @DISCore:resourceType:
    @@@: DISLang|Class
    @@ForCheck: tc|ForEmptyNodeList

  @Implement:
    @@@: NodeList||ManakaiDOM|ManakaiDOM
    @@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM
  @Implement:
    @@@: NodeList||ManakaiDOM|ManakaiDOM1
    @@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM1
  @Implement:
    @@@: NodeList||ManakaiDOM|ManakaiDOM2
    @@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM2
  @Implement:
    @@@: NodeList||ManakaiDOM|ManakaiDOM3
    @@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM3
  @Implement:
    @@@: NodeList||ManakaiDOM|ManakaiDOMLatest
    @@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOMLatest

  @enDesc:
    Objects implementing the <IF::NodeList> interface are used
    to represent ordered collections of nodes.

    The <IF::NodeList> objects are live <SRC::DOM1, DOM2, DOM3>; which means
    that the <IF::NodeList> objects are always <QUOTE::up-to-date>.
    For example, a <IF::NodeList> obtained from the 
    <A::Node.childNodes> attribute of an empty element would 
    have its <A::NodeList.length> value of <CODE::1> after
    a <M::Node.appendChild> operation would have appended a node
    to the element.

    {NOTE:: How this collection is implemented is neither defined
            nor constrained.
    }

    The items in the <IF::NodeList> are accessible via
    an ordinal index, starting from zero.

  @enDesc:
    @@For: ManakaiDOM|ManakaiDOM
    @@@:
      In the manakai implementation, <IF::NodeList> can be 
      dereferenced as if it is an array reference.  For 
      example, <Perl::@a = @$nodeList> result in the array
      <Perl::@a> containing all <IF::Node>s in the <Perl::$nodeList>.
      Please note that <Perl::@a> is just a Perl array and
      it is <EM::not> live.

  @enDesc:
    {NOTE:: <IF::NodeList>s are different from <IF::NamedNodeMap>s
            in that <IF::NodeList>s are <EM::ordered> and
            <IF::NamedNodeMap>s are not.
    }

  @Method:
    @@Name: item
    @@Perlop: FETCH
    @@enDesc:
      Returns an item in the collection.
    @@Param:
      @@@Name: index
      @@@Type: unsignedLong
      @@@enDesc:
        The index of the item to retrieve into the collection.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The <P::index>th node in the collection.
      @@@nullCase:
        @@@@enDesc:
          If the <P::index> is greater than or equal
          to the number of nodes in the collection.
      @@@PerlDef:
        @@@@ForCheck: tc|ForChildNodeList
        @@@@@:
          my $v;
          __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
            $r => $v,
            $prop => {<H::infoset|children>},
            $ref => {$$$self},
          }__;
          if (defined $v->[$index]) {
            __CODE{mg|createNodeRefFromID||ManakaiDOM|all::
              $bag => {<Code::mg|getNodeBag||ManakaiDOM|all:: $ref = {$$$self}>},
              $stemid => {$v->[$index]},
              $ref => $r,
              $opt => {{}},
            }__;
          }
      @@@PerlDef:
        @@@@ForCheck: tc|ForGetNodeList
        @@@@@:
          __DEEP{
            my @target = @{$self-><AG::Node.childNodes>};
            my $i = 0;
            my $chk;
            __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
              $r => $chk,
              $prop => {<H::tc|nodeFilter>},
              $ref => $self,
            }__;
            T: while (@target) {
              my $target = shift @target;
              my $nt = $target-><AG::Node.nodeType>;
              if ($nt == <C::Node.ELEMENT_NODE>) {
                if ($chk->($target)) {
                  if (++$i == $index) {
                    $r = $target;
                    last T;
                  }
                }
              }
              unshift @target, @{$target-><AG::Node.childNodes>};
            } # T
          }__;
        @@@@enImplNote:
          {TODO::
            Improve the implementation.
          }
      @@@PerlDef:
        @@@@ForCheck: tc|ForEmptyNodeList
        @@@@@: \

    @@Test:
      @@@ForCheck: tc|ForChildNodeList
      @@@QName: ChildNodeList.item.1.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        my $doc = $el-><AG::Node.ownerDocument>;
        my $cl = $el-><AG::Node.childNodes>;

        my $e1 = $doc-><M::Document.createElementNS> (null, 'e');
        $el-><M::Node.appendChild> ($e1);
        my $e2 = $doc-><M::Document.createElementNS> (null, 'e');
        $el-><M::Node.appendChild> ($e2);
        my $e3 = $doc-><M::Document.createElementNS> (null, 'e');
        $el-><M::Node.appendChild> ($e3);

        $test->id ('0');
        $test->assert_equals ($cl-><M::NodeList.item> (0), $e1);

        $test->id ('1');
        $test->assert_equals ($cl-><M::NodeList.item> (1), $e1);

        $test->id ('2');
        $test->assert_equals ($cl-><M::NodeList.item> (2), $e1);

        $test->id ('3');
        $test->assert_null ($cl-><M::NodeList.item> (3));

        $test->id ('-1');
        $test->assert_null ($cl-><M::NodeList.item> (-1));

    @@Test:
      @@@ForCheck: tc|ForChildNodeList
      @@@QName: ChildNodeList.item.2.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        my $doc = $el-><AG::Node.ownerDocument>;
        my $cl = $el-><AG::Node.childNodes>;

        $test->id ('0');
        $test->assert_null ($cl-><M::NodeList.item> (0));

        $test->id ('1');
        $test->assert_null ($cl-><M::NodeList.item> (1));

        $test->id ('-1');
        $test->assert_null ($cl-><M::NodeList.item> (-1));

  @IntMethod:
    @@Perlop: STORE
    @@Description:
      @@@lang:en
      @@@@:
        Sets an item. 
    @@Param:
      @@@Name:index
      @@@Type: unsignedLong
      @@@Description:
        @@@@lang:en
        @@@@@:
          An ordinal index in the list.  If the <P::index> is greater 
          than the number of items, then it is appended to the end of 
          the list.  A negative index is converted into a positive 
          index by Perl. 
    @@Param:
      @@@Name:value
      @@@Type: Node
      @@@Description:
        @@@@lang:en
        @@@@@:
          The node to set at the <P::index>th position in the list. 
    @@Return:
      @@@Type:Node
      @@@Description:
        @@@@lang:en
        @@@@@:
          The old node that has been replaced to the new <P::value>. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            No node has been removed from this list. 
      @@@Exception:
        @@@@@: c|NOMOD_NODELIST_ERR
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            A <IF::NodeList> returned by <M::Document.getElementsByTagNameNS> 
            or like is unable to be edited. 
        @@@@ForCheck: tc|ForGetNodeList
      @@@Exception:
        @@@@@: c|NOMOD_NODELIST_ERR
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            A <IF::NodeList> is unable to be edited. 
        @@@@ForCheck: tc|ForEmptyNodeList
      @@@disDef:
        @@@@DOMMain:raiseException: c|NOMOD_NODELIST_ERR
        @@@@ForCheck: tc|ForGetNodeList
      @@@disDef:
        @@@@DOMMain:raiseException: c|NOMOD_NODELIST_ERR
        @@@@ForCheck: tc|ForEmptyNodeList
      @@@Exception:
        @@@@ForCheck: tc|ForChildNodeList
          @@@@Type: DOMException
          @@@@Name: HIERARCHY_REQUEST_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Either this node is of a type that does not allow 
              children of the type of the "newChild" node [DOM 1, 2, 3],
              the node to put in is one of ancestors of this node 
              [DOM 1, 2, 3], the node to put in is this node itself
              [DOM 2 Errata, 3], or this 
              node is of type "Document" and the result of the 
              replacement would add a second "DocumentType" or "Element" node.
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              Special treatment required for the "DocumentFragment" node.
        @@@Exception:
        @@@@ForCheck: tc|ForChildNodeList
          @@@@Type: DOMException
          @@@@Name: WRONG_DOCUMENT_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The new node was created from a different document.
        @@@Exception:
        @@@@ForCheck: tc|ForChildNodeList
          @@@@Type: DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Either this node is read-only [DOM 1, 2, 3] or the parent of the 
              new node is read-only [DOM 1 SE, 2, 3].
      @@@PerlDef:
        @@@@ForCheck: tc|ForChildNodeList
        @@@@@:
          __DEEP{
            my $current = $self->[$index];
            if ($current) {
              $r = $$$self-><M::Node.replaceChild> ($value, $current);
            } else {
              $$$self-><M::Node.appendChild> ($value);
            }
          }__;

  @IntMethod:
    @@Perlop: DELETE
    @@Description:
      @@@lang:en
      @@@@:
        Removes an item from this list. 
        \
        Unlike the deletion for Perl's standard array, this method 
        removes an item and moves the rest of the array (i.e. items 
        whose index is greater than <P::index>) one position, since 
        the <IF::NodeList> cannot contain a <DOM::null> value. 
    @@Param:
      @@@Name:index
      @@@Type: unsignedLong
      @@@Description:
        @@@@lang:en
        @@@@@:
          An ordinal index in the list.  If the <P::index> is greater 
          than the number of items, then no item is removed.
          A negative index is converted into a positive 
          index by Perl. 
    @@Return:
      @@@Type:Node
      @@@Description:
        @@@@lang:en
        @@@@@:
          The node removed from this list. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            No node has removed from this list. 
      @@@Exception:
        @@@@@: c|NOMOD_NODELIST_ERR
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            A <IF::NodeList> returned by <M::Document.getElementsByTagNameNS> 
            or like is unable to be edited. 
        @@@@ForCheck: !tc|ForChildNodeList
      @@@disDef:
        @@@@DOMMain:raiseException: c|NOMOD_NODELIST_ERR
        @@@@ForCheck: !tc|ForChildNodeList
      @@@Exception:
        @@@@ForCheck: tc|ForChildNodeList
          @@@@Type: DOMException
          @@@@Name: HIERARCHY_REQUEST_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Either this node is of a type that does not allow 
              children of the type of the "newChild" node [DOM 1, 2, 3],
              the node to put in is one of ancestors of this node 
              [DOM 1, 2, 3], the node to put in is this node itself
              [DOM 2 Errata, 3], or this 
              node is of type "Document" and the result of the 
              replacement would add a second "DocumentType" or "Element" node.
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              Special treatment required for the "DocumentFragment" node.
      @@@Exception:
        @@@@ForCheck: tc|ForChildNodeList
          @@@@Type: DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Either this node is read-only [DOM 1, 2, 3] or the parent of the 
              new node is read-only [DOM 1 SE, 2, 3].
      @@@PerlDef:
        @@@@ForCheck: tc|ForChildNodeList
        @@@@@:
          __DEEP{
            my $current = $self->[$index];
            if ($current) {
              $r = $$$self-><M::Node.removeChild> ($current);
            }
          }__;

  @Attr:
    @@Name: length
    @@Perlop: FETCHSIZE
    @@enDesc:
      The number of nodes in the list.
    @@Type: unsignedLong
    @@Get:
      @@@PerlDef:
        @@@@ForCheck: tc|ForChildNodeList
        @@@@@:
          my $v;
          __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
            $r => $v,
            $prop => {<H::infoset|children>},
            $ref => {$$$self},
          }__;
          $r = @$v;
      @@@PerlDef:
        @@@@ForCheck: tc|ForGetNodeList
        @@@@@:
          __DEEP{
            my @target = @{$self-><AG::Node.childNodes>};
            $r = 0;
            my $chk;
            __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
              $r => $chk,
              $prop => {<H::tc|nodeFilter>},
              $ref => $self,
            }__;
            T: while (@target) {
              my $target = shift @target;
              my $nt = $target-><AG::Node.nodeType>;
              if ($nt == <C::Node.ELEMENT_NODE>) {
                if ($chk->($target)) {
                  $r++;
                }
              }
              unshift @target, @{$target-><AG::Node.childNodes>};
            } # T
          }__;
      @@@PerlDef:
        @@@@ForCheck: tc|ForEmptyNodeList
        @@@@@:\

    @@Test:
      @@@ForCheck: tc|ForChildNodeList
      @@@QName: ChildNodeList.length.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        my $doc = $el-><AG::Node.ownerDocument>;
        my $cl = $el-><AG::Node.childNodes>;

        $test->id ('initial');
        $test->assert_num_equals
                 (actual_value => 0+@$cl, expected_value => 0);

        $test->id ('1');
        $el-><M::Node.appendChild> ($doc-><M::Document.createComment> ('c'));
        $test->assert_num_equals
                 (actual_value => 0+@$cl, expected_value => 1);

        $test->id ('2');
        $el-><M::Node.appendChild> ($doc-><M::Document.createComment> ('c'));
        $test->assert_num_equals
                 (actual_value => 0+@$cl, expected_value => 2);

        $test->id ('0');
        $el-><AS::Node.textContent> ('');
        $test->assert_num_equals
                 (actual_value => 0+@$cl, expected_value => 0);

  @IntMethod:
    @@Perlop: STORESIZE
    @@Description:
      @@@lang:en
      @@@@:
        Changes the size of this node list.
    @@Param:
      @@@Name:count
      @@@Type: unsignedLong
      @@@Description:
        @@@@lang:en
        @@@@@: 
          The new length of this list.  If the <P::count> 
          is smaller than the current <A::NodeList.length>, <P::count>th or 
          greater index'th items are removed from this list.  Otherwise, 
          no action.
    @@Return:
      @@@NoModGetNodeList:
      @@@PerlDef:
        @@@@ForCheck: tc|ForChildNodeList
        @@@@@:
          __DEEP{
            my $current_length = @$self;
            if ($current_length > $count) {
              for (my $i = $current_length - 1; $i >= $count; $i--) {
                $$$self-><M::Node.removeChild> ($self->[$i]);
              }
            }
          }__;

  @IntMethod:
     @@Perlop: EXISTS
     @@Description:
       @@@lang:en
       @@@@:
         Returns whether an item exists in this list or not. 
     @@Param:
       @@@Name:index
       @@@Type: unsignedLong
       @@@Description:
         @@@@lang:en
         @@@@@:
           The ordinal index of the item to test. 
     @@Return:
      @@@Type: boolean
      @@@PerlDef:
        @@@@ForCheck: tc|ForChildNodeList
        @@@@@:
          my $v;
          __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
            $r => $v,
            $prop => {<H::infoset|children>},
            $ref => {$$$self},
          }__;
          $r = CORE::exists $v->[$index];
      @@@PerlDef:
        @@@@ForCheck: tc|ForGetNodeList
        @@@@@:
          __DEEP{
            $r = (defined $self-><M::NodeList.item> ($index));
          }__;
      @@@PerlDef:
        @@@@ForCheck: tc|ForEmptyNodeList
        @@@@@:\

  @IntMethod:
    @@Perlop: ==
    @@enDesc:
      Returns whether two node list are equal or not.

      Two node lists are equal if and only if their
      <A::NodeList.length>s are equal and their
      <M::NodeList.item>s at the same indeces are equal respectively.
    @@Param:
      @@@Name: arg
      @@@Type: NodeList
      @@@enDesc:
        The node list to compare.
    @@Return:
      @@@Type: boolean
      @@@TrueCase:
        @@@@enDesc:
          Two node lists are equal.
      @@@FalseCase:
        @@@@enDesc:
          Otherwise.
      @@@PerlDef:
        __DEEP{
          EQ: {
            last EQ unless UNIVERSAL::isa ($arg, <IFName::NodeList>);

            my $length1 = $self-><AG::NodeList.length>;
            my $length2 = $arg-><AG::NodeList.length>;
            last EQ unless $length1 == $length2;

            for my $i (0..($length1-1)) {
              unless ($self-><M::NodeList.item> ($i)
                          == $arg-><M::NodeList.item> ($i)) {
                last EQ;
              }
            }

            $r = true;
          } # EQ
        }__;

  @IntMethod:
    @@ForCheck: !tc|ForEmptyNodeList
    @@Perlop:TIEARRAY
    @@ManakaiDOM:isStatic:1
    @@Description:
      @@@lang:en
      @@@@:
        Binds a node list to an array.  This method is intended to 
        be called by Perl <Perl::tie> function. 
    @@Param:
      @@@Name: nodeList
      @@@Type: NodeList
      @@@Description:
        @@@@lang:en
        @@@@@:
          A node list that is tied with an array. 
    @@Return:
      @@@Type: NodeList
      @@@Description:
        @@@@lang:en
        @@@@@:
          The node list to which the array has bound, 
          i.e. <P::nodeList>.
      @@@PerlDef:
        $r = $nodeList;

  @IntMethod:
    @@Perlop:CLEAR
    @@Description:
      @@@lang:en
      @@@@:
        Removes all items from this list. 
    @@Return:
      @@@NoModGetNodeList:
      @@@Exception:
        @@@@ForCheck: tc|ForChildNodeList
          @@@@Type: DOMException
          @@@@Name: HIERARCHY_REQUEST_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Either this node is of a type that does not allow 
              children of the type of the "newChild" node [DOM 1, 2, 3],
              the node to put in is one of ancestors of this node 
              [DOM 1, 2, 3], the node to put in is this node itself
              [DOM 2 Errata, 3], or this 
              node is of type "Document" and the result of the 
              replacement would add a second "DocumentType" or "Element" node.
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              Special treatment required for the "DocumentFragment" node.
      @@@Exception:
        @@@@ForCheck: tc|ForChildNodeList
          @@@@Type: DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              Either this node is read-only [DOM 1, 2, 3] or the parent of the 
              new node is read-only [DOM 1 SE, 2, 3].
      @@@PerlDef:
        @@@@ForCheck: tc|ForChildNodeList
        @@@@@:
          __DEEP{
            my $length = @$self;
            for (1..$length) {
              $$$self-><M::Node.removeChild> ($$$self-><AG::Node.firstChild>);
            }
          }__;

  @IntMethod:
    @@Perlop:@{}
    @@Description:
      @@@lang:en
      @@@@:
        Returns an array representation of this node list. 
        \
        {NOTE:: It is intended that most operations through the 
                array is as like ones in DOM Level 0 JavaScript 
                implementations as possible. 
        \
        }
    @@Return:
      @@@Type: DISPerl|ARRAY||ManakaiDOM|all
      @@@PerlDef:
        @@@@ForCheck: !tc|ForEmptyNodeList
        @@@@@:
          tie my @list, ref $self, $self;
          $r = \@list;
      @@@PerlDef:
        @@@@ForCheck: tc|ForEmptyNodeList
        @@@@@: \

  @CODE:
    @@QName: tc|createChildNodeList
    @@ForCheck: tc|ForChildNodeList
    @@enDesc:
      Creats a new child node list.
    @@PerlDef:
      $r = bless \\($node), <ClassName::ManakaiDOMChildNodeList>;

  @CODE:
    @@QName: tc|createGetElementsNodeList
    @@ForCheck: tc|ForGetNodeList
    @@enDesc:
      Creates a new <IF::NodeList> for get elements methods.
      
      <Perl::$node>: The node reference from which the traversal
                     starts.

      <Perl::$chk>: The node filter for elements.

      <Perl::$r>: The created node list.
    @@PerlDef:
      __CODE{mg|createNodeRefFromID||ManakaiDOM|all::
        $bag => {<Code::mg|getNodeBag||ManakaiDOM|all:: $ref = $node>},
        $stemid => {<Code::mg|getNodeID||ManakaiDOM|all:: $ref = $node>},
        $ref => $r,
        $opt => {{}},
      }__;
      __CODE{mg|setNodeRefPropValue||ManakaiDOM|all::
        $given => $chk,
        $prop => {<H::tc|nodeFilter>},
        $ref => $node,
      }__;

  @CODE:
    @@QName: tc|createEmptyNodeList
    @@ForCheck: tc|ForEmptyNodeList
    @@enDesc:
      Creats a new empty node list.
    @@PerlDef:
      $r = bless [], <ClassName::ManakaiDOMEmptyNodeList>;
##NodeList

IntPropDef:
  @QName: tc|nodeFilter
  @mg:nodeRefKey: filter

ElementTypeBinding:
  @Name:NoModGetNodeList
  @ElementType:
    DISCore:resourceType
  @ShadowContent: DISCore|Resource
  @ShadowSibling:
    @@dx:raises:
      @@@@: c|NOMOD_NODELIST_ERR
      @@@Description:
        @@@@lang:en
        @@@@@:
          A <IF::NodeList> returned by <M::Document.getElementsByTagNameNS> 
          or like is unable to be edited. 
      @@@ForCheck: !tc|ForEmptyNodeList
    @@disDef:
      @@@DOMMain:raiseException: c|NOMOD_NODELIST_ERR
      @@@ForCheck: !tc|ForEmptyNodeList

ElementTypeBinding:
  @Name: Perlop
  @ElementType:
    dis:Operator
  @ShadowContent:
    @@ContentType: DISPerl|Perl
    @@For: ManakaiDOM|Perl

ForDef:
  @QName: tc|ForAttrMap
  @enDesc:
    For element attributes named node map class.
  @ISA: ManakaiDOM|ForClass

ForDef:
  @QName: tc|ForETMap
  @enDesc:
    For element type definition list named node map class.
  @ISA: ManakaiDOM|ForClass

ForDef:
  @QName: tc|ForATMap
  @enDesc:
    For attribute definition list named node map class.
  @ISA: ManakaiDOM|ForClass

ForDef:
  @QName: tc|ForEntityMap
  @enDesc:
    For entity list named node map class.
  @ISA: ManakaiDOM|ForClass

ForDef:
  @QName: tc|ForNotationMap
  @enDesc:
    For notation list named node map class.
  @ISA: ManakaiDOM|ForClass

ResourceDef:
  @rdf:type:
    @@@:
      dis:MultipleResource
    @@ForCheck: !ManakaiDOM|ForIF !ManakaiDOM|ForClass
  @ForCheck: ManakaiDOM|DOM

  @resourceFor: ManakaiDOM|ForIF
  @IFQName: NamedNodeMap
  @DISCore:resourceType:
    @@@: DISLang|Interface
    @@ForCheck: ManakaiDOM|ForIF

  @f:implements:
    @@@: c|CoreFeature10
    @@ForCheck: ManakaiDOM|DOM1
  @f:implements:
    @@@: c|CoreFeature20
    @@ForCheck: ManakaiDOM|DOM2
  @f:implements:
    @@@: c|CoreFeature30
    @@ForCheck: ManakaiDOM|DOM3

  @resourceFor:
    @@@: tc|ForAttrMap
    @@ForCheck: ManakaiDOM|ManakaiDOM1
  @QName:
    @@@: ManakaiDOMAttrMap
    @@ForCheck: tc|ForAttrMap

  @resourceFor:
    @@@: tc|ForETMap
    @@ForCheck: ManakaiDOM|ManakaiDOMLatest
  @QName:
    @@@: ManakaiDOMElementTypeDefMap
    @@ForCheck: tc|ForETMap
 
  @f:implements:
    @@@: d|Feature30
    @@ForCheck: tc|ForETMap ManakaiDOM|DOM3

  @resourceFor:
    @@@: tc|ForATMap
    @@ForCheck: ManakaiDOM|ManakaiDOMLatest
  @QName:
    @@@: ManakaiDOMAttrDefMap
    @@ForCheck: tc|ForATMap

  @f:implements:
    @@@: d|Feature30
    @@ForCheck: tc|ForATMap ManakaiDOM|DOM3

  @resourceFor:
    @@@: tc|ForEntityMap
    @@ForCheck: ManakaiDOM|ManakaiDOM1 ManakaiDOM|DOMXMLFeature
  @QName:
    @@@: ManakaiDOMEntityMap
    @@ForCheck: tc|ForEntityMap

  @f:implements:
    @@@: x|XMLFeature10
    @@ForCheck: tc|ForEntityMap ManakaiDOM|DOM1
  @f:implements:
    @@@: x|XMLFeature20
    @@ForCheck: tc|ForEntityMap ManakaiDOM|DOM2
  @f:implements:
    @@@: x|XMLFeature30
    @@ForCheck: tc|ForEntityMap ManakaiDOM|DOM3
  @f:implements:
    @@@: x|XMLVersionFeature10
    @@ForCheck: tc|ForEntityMap ManakaiDOM|DOM3
  @f:implements:
    @@@: x|XMLVersionFeature11
    @@ForCheck: tc|ForEntityMap ManakaiDOM|DOM3 ManakaiDOM|DOMXMLFeatureXML11

  @resourceFor:
    @@@: tc|ForNotationMap
    @@ForCheck: ManakaiDOM|ManakaiDOM1 ManakaiDOM|DOMXMLFeature
  @QName:
    @@@: ManakaiDOMNotationMap
    @@ForCheck: tc|ForNotationMap

  @f:implements:
    @@@: x|XMLFeature10
    @@ForCheck: tc|ForNotationMap ManakaiDOM|DOM1
  @f:implements:
    @@@: x|XMLFeature20
    @@ForCheck: tc|ForNotationMap ManakaiDOM|DOM2
  @f:implements:
    @@@: x|XMLFeature30
    @@ForCheck: tc|ForNotationMap ManakaiDOM|DOM3
  @f:implements:
    @@@: x|XMLVersionFeature10
    @@ForCheck: tc|ForNotationMap ManakaiDOM|DOM3
  @f:implements:
    @@@: x|XMLVersionFeature11
    @@ForCheck: tc|ForNotationMap ManakaiDOM|DOM3 ManakaiDOM|DOMXMLFeatureXML11

  @DISCore:resourceType:
    @@@: DISLang|Class
    @@ForCheck: ManakaiDOM|ForClass

  @AppISA:
    @@@: 
      Tie::Array
    @@ContentType: DISPerl|Perl
    @@ForCheck: ManakaiDOM|ForClass

  @Implement:
    @@@: NamedNodeMap||ManakaiDOM|ManakaiDOM
    @@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM
  @Implement:
    @@@: NamedNodeMap||ManakaiDOM|ManakaiDOM1
    @@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM1
  @Implement:
    @@@: NamedNodeMap||ManakaiDOM|ManakaiDOM2
    @@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM2
  @Implement:
    @@@: NamedNodeMap||ManakaiDOM|ManakaiDOM3
    @@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM3
  @Implement:
    @@@: NamedNodeMap||ManakaiDOM|ManakaiDOMLatest
    @@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOMLatest

  @enDesc:
    An object implementing the <IF::NamedNodeMap> interface represents
    a collection of nodes that can be accessed by name.  Unlike
    <IF::NodeList>, a <IF::NamedNodeMap> object does not maintain
    any particular order.  Nodes contained in a <IF::NamedNodeMap>
    may also be accessed by an ordinal index, starting from
    <CODE::0> (zero), but this is simply
    to allow convenient enumeration of the contents of the collection.

    A <IF::NamedNodeMap> object is live.

  @enImplNote:
    @@ddid: order
    @@@:
      That is, node order is preserved as long as no change
      is made to the collection?

  @enImplNote:
    @@ddid: usecases
    @@@:
      In DOM Core module, the only place where <IF::NamedNodeMap>
      is returned is <A::Node.attributes> attribute.  In DOM XML module,
      <A::x|DocumentType.entities> and <A::x|DocumentType.notations>
      are also <IF::NamedNodeMap>s.

      In manakai DOM <MDOM::XDoctype> module, 
      <A::d|DocumentTypeDefinition.elementTypes>, 
      <A::d|DocumentTypeDefinition.generalEntities>,
      <A::d|DocumentTypeDefinition.parameterEntities>,
      <A::d|DocumentTypeDefinition.notations>, and
      <A::d|ElementTypeDefinition.attributeDefinitions> attributes
      are <IF::NamedNodeMap>s.

  @ImplNote:
    @@lang:en
    @@@:
      An element may have two (or more) attributes that have the same 
      <A::Node.nodeName>, but different <A::Node.namespaceURI>s. 
      Which of them is returned by DOM Level 1 methods is 
      implementation dependent.  The only guarantee is 
      that all methods that access a named item by its <A::Node.nodeName> 
      will access the same item, and all methods by its namespace URI
      and local name will access the same item. 
      <SRC::<CITE::DOM Level 2 Core> <sw010:csection::1.4.8 XML Namespaces>,
      <CITE::DOM Level 3 Core> <sw010:csection::1.3.3 XML Namespaces>>

  @enDesc:
    @@For: ManakaiDOM|ManakaiDOM
    @@@:
      In the manakai implementation, <IF::NamedNodeMap>s can be 
      dereferenced as if it is an array reference or a hash reference.
      Dereferencing as an array reference provides an access to
      items by ordinal index, like <M::.item> method; 
      Dereferencing as a hash reference
      provides by name, like <M::.getNamedItem> method.

      {TODO:: How namespace-aware node can be accessed?
      }

      {TODO:: This is <EM::not> implemented yet!
      }

  @IntMethod:
    @@Perlop: %{}
    @@enDesc:
      In manakai's Perl binding, a <IF::NamedNodeMap> object can be
      dereferenced as if it is a hash reference.  For example,
      <Perl::$map-<lt>{name}> will return the same <IF::Node> as
      <Perl::$map-<lt>get_named_item ('name')> would return.  However, it does
      not currently support substitions to hash values (e.g. 
      <Perl::$map-<lt>{name} = $node> does not work).
    @@enImplNote:
      {TODO::
        $map->{$ns, $ln} for attribute maps should be allowed.
      }

      Should $map->{$key} = $node be allowed?  What if 
      $key differs from $node->node_name?
    @@Return:
      @@@Type: HASH
      @@@PerlDef:
        tie my %list, ref $self, $self;
        $r = \%list;

    @@Test:
      @@@ForCheck: tc|ForAttrMap
      @@@QName: AttrMap.P.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest}__;
        my $doc = $el-><AG::Node.ownerDocument>;
        my $em = $el-><AG::Node.attributes>;

        $test->id ('hash.scalar');
        $test->assert_not_null (scalar %$em);

        $test->id ('key.no');
        $test->assert_null ($em->{et1});
        $test->assert_null ($em->{et2});
        $test->id ('exists.no');
        $test->assert_false (exists $em->{et1});
        $test->assert_false (exists $em->{et2});

        $test->id ('setNamedItem');
        my $et1 = $doc-><M::Document.createAttribute> ('et1');
        $em-><M::NamedNodeMap.setNamedItem> ($et1);

        $test->id ('key.et1');
        my $v1 = $em->{et1};
        $test->assert_equals ($v1, $et1);
        $test->id ('exists.et1');
        $test->assert_true (exists $em->{et1});
        $test->id ('not.exists.et2');
        $test->assert_false (exists $em->{et2});

        $test->id ('keys');
        my @keys = keys %$em;
        $test->assert_num_equals
                 (actual_value => 0 + @keys,
                  expected_value => 1);
        $test->assert_equals ($keys[0], 'et1');
        
        $test->id ('setNamedItem.2');
        my $et2 = $doc-><M::Document.createAttribute> ('et2');
        $em-><M::NamedNodeMap.setNamedItem> ($et2);

        $test->id ('keys.2');
        @keys = keys %$em;
        $test->assert_num_equals
                 (actual_value => 0 + @keys,
                  expected_value => 2);
        $test->assert_not_equals ($keys[0], $keys[1]);
        $test->assert_true ($keys[0] eq 'et1' or $keys[0] eq 'et2');
        $test->assert_true ($keys[1] eq 'et1' or $keys[1] eq 'et2');
        
        $test->id ('delete');
        delete $em->{et1};
        $test->assert_false (exists $em->{et1});
        $test->assert_true (exists $em->{et2});

        $test->id ('clear');
        %$em = ();
        $test->assert_num_equals
                 (actual_value => 0 + keys %$em,
                  expected_value => 0);

    @@XDTest:
      @@@ForCheck: tc|ForEntityMap
      @@@QName: EntityMap.P.test
      @@@PerlDef:
        my $dtd;
        __CODE{d|newDoctypeForTest}__;
        my $doc = $dtd-><AG::Node.ownerDocument>;
        my $em = $dtd-><AG::d|DocumentTypeDefinition.generalEntities>;

        $test->id ('hash.scalar');
        $test->assert_not_null (scalar %$em);

        $test->id ('key.no');
        $test->assert_null ($em->{et1});
        $test->assert_null ($em->{et2});
        $test->id ('exists.no');
        $test->assert_false (exists $em->{et1});
        $test->assert_false (exists $em->{et2});

        $test->id ('setNamedItem');
        my $et1 = $doc-><M::d|DocumentXDoctype.createGeneralEntity>
                          ('et1');
        $em-><M::NamedNodeMap.setNamedItem> ($et1);

        $test->id ('key.et1');
        my $v1 = $em->{et1};
        $test->assert_equals ($v1, $et1);
        $test->id ('exists.et1');
        $test->assert_true (exists $em->{et1});
        $test->id ('not.exists.et2');
        $test->assert_false (exists $em->{et2});

        $test->id ('keys');
        my @keys = keys %$em;
        $test->assert_num_equals
                 (actual_value => 0 + @keys,
                  expected_value => 1);
        $test->assert_equals ($keys[0], 'et1');
        
        $test->id ('setNamedItem.2');
        my $et2 = $doc-><M::d|DocumentXDoctype.createGeneralEntity>
                          ('et2');
        $em-><M::NamedNodeMap.setNamedItem> ($et2);

        $test->id ('keys.2');
        @keys = keys %$em;
        $test->assert_num_equals
                 (actual_value => 0 + @keys,
                  expected_value => 2);
        $test->assert_not_equals ($keys[0], $keys[1]);
        $test->assert_true ($keys[0] eq 'et1' or $keys[0] eq 'et2');
        $test->assert_true ($keys[1] eq 'et1' or $keys[1] eq 'et2');
        
        $test->id ('delete');
        delete $em->{et1};
        $test->assert_false (exists $em->{et1});
        $test->assert_true (exists $em->{et2});

        $test->id ('clear');
        %$em = ();
        $test->assert_num_equals
                 (actual_value => 0 + keys %$em,
                  expected_value => 0);

    @@XDTest:
      @@@ForCheck: tc|ForNotationMap
      @@@QName: NotationMap.P.test
      @@@PerlDef:
        my $dtd;
        __CODE{d|newDoctypeForTest}__;
        my $doc = $dtd-><AG::Node.ownerDocument>;
        my $em = $dtd-><AG::d|DocumentTypeDefinition.notations>;

        $test->id ('hash.scalar');
        $test->assert_not_null (scalar %$em);

        $test->id ('key.no');
        $test->assert_null ($em->{et1});
        $test->assert_null ($em->{et2});
        $test->id ('exists.no');
        $test->assert_false (exists $em->{et1});
        $test->assert_false (exists $em->{et2});

        $test->id ('setNamedItem');
        my $et1 = $doc-><M::d|DocumentXDoctype.createNotation>
                          ('et1');
        $em-><M::NamedNodeMap.setNamedItem> ($et1);

        $test->id ('key.et1');
        my $v1 = $em->{et1};
        $test->assert_equals ($v1, $et1);
        $test->id ('exists.et1');
        $test->assert_true (exists $em->{et1});
        $test->id ('not.exists.et2');
        $test->assert_false (exists $em->{et2});

        $test->id ('keys');
        my @keys = keys %$em;
        $test->assert_num_equals
                 (actual_value => 0 + @keys,
                  expected_value => 1);
        $test->assert_equals ($keys[0], 'et1');
        
        $test->id ('setNamedItem.2');
        my $et2 = $doc-><M::d|DocumentXDoctype.createNotation>
                          ('et2');
        $em-><M::NamedNodeMap.setNamedItem> ($et2);

        $test->id ('keys.2');
        @keys = keys %$em;
        $test->assert_num_equals
                 (actual_value => 0 + @keys,
                  expected_value => 2);
        $test->assert_not_equals ($keys[0], $keys[1]);
        $test->assert_true ($keys[0] eq 'et1' or $keys[0] eq 'et2');
        $test->assert_true ($keys[1] eq 'et1' or $keys[1] eq 'et2');
        
        $test->id ('delete');
        delete $em->{et1};
        $test->assert_false (exists $em->{et1});
        $test->assert_true (exists $em->{et2});

        $test->id ('clear');
        %$em = ();
        $test->assert_num_equals
                 (actual_value => 0 + keys %$em,
                  expected_value => 0);

    @@XDTest:
      @@@ForCheck: tc|ForETMap
      @@@QName: ETMap.P.test
      @@@PerlDef:
        my $dtd;
        __CODE{d|newDoctypeForTest}__;
        my $doc = $dtd-><AG::Node.ownerDocument>;
        my $em = $dtd-><AG::d|DocumentTypeDefinition.elementTypes>;

        $test->id ('hash.scalar');
        $test->assert_not_null (scalar %$em);

        $test->id ('key.no');
        $test->assert_null ($em->{et1});
        $test->assert_null ($em->{et2});
        $test->id ('exists.no');
        $test->assert_false (exists $em->{et1});
        $test->assert_false (exists $em->{et2});

        $test->id ('setNamedItem');
        my $et1 = $doc-><M::d|DocumentXDoctype.createElementTypeDefinition>
                          ('et1');
        $em-><M::NamedNodeMap.setNamedItem> ($et1);

        $test->id ('key.et1');
        my $v1 = $em->{et1};
        $test->assert_equals ($v1, $et1);
        $test->id ('exists.et1');
        $test->assert_true (exists $em->{et1});
        $test->id ('not.exists.et2');
        $test->assert_false (exists $em->{et2});

        $test->id ('keys');
        my @keys = keys %$em;
        $test->assert_num_equals
                 (actual_value => 0 + @keys,
                  expected_value => 1);
        $test->assert_equals ($keys[0], 'et1');
        
        $test->id ('setNamedItem.2');
        my $et2 = $doc-><M::d|DocumentXDoctype.createElementTypeDefinition>
                          ('et2');
        $em-><M::NamedNodeMap.setNamedItem> ($et2);

        $test->id ('keys.2');
        @keys = keys %$em;
        $test->assert_num_equals
                 (actual_value => 0 + @keys,
                  expected_value => 2);
        $test->assert_not_equals ($keys[0], $keys[1]);
        $test->assert_true ($keys[0] eq 'et1' or $keys[0] eq 'et2');
        $test->assert_true ($keys[1] eq 'et1' or $keys[1] eq 'et2');
        
        $test->id ('delete');
        delete $em->{et1};
        $test->assert_false (exists $em->{et1});
        $test->assert_true (exists $em->{et2});

        $test->id ('clear');
        %$em = ();
        $test->assert_num_equals
                 (actual_value => 0 + keys %$em,
                  expected_value => 0);

    @@XDTest:
      @@@ForCheck: tc|ForATMap
      @@@QName: ATMap.P.test
      @@@PerlDef:
        my $dtd;
        __CODE{d|newDoctypeForTest}__;
        my $doc = $dtd-><AG::Node.ownerDocument>;
        my $etd = $doc-><M::d|DocumentXDoctype.createElementTypeDefinition>
                          ('etd');
        my $em = $etd-><AG::d|ElementTypeDefinition.attributeDefinitions>;
        undef $dtd;

        $test->id ('hash.scalar');
        $test->assert_not_null (scalar %$em);

        $test->id ('key.no');
        $test->assert_null ($em->{et1});
        $test->assert_null ($em->{et2});
        $test->id ('exists.no');
        $test->assert_false (exists $em->{et1});
        $test->assert_false (exists $em->{et2});

        $test->id ('setNamedItem');
        my $et1 = $doc-><M::d|DocumentXDoctype.createAttributeDefinition>
                          ('et1');
        $em-><M::NamedNodeMap.setNamedItem> ($et1);

        $test->id ('key.et1');
        my $v1 = $em->{et1};
        $test->assert_equals ($v1, $et1);
        $test->id ('exists.et1');
        $test->assert_true (exists $em->{et1});
        $test->id ('not.exists.et2');
        $test->assert_false (exists $em->{et2});

        $test->id ('keys');
        my @keys = keys %$em;
        $test->assert_num_equals
                 (actual_value => 0 + @keys,
                  expected_value => 1);
        $test->assert_equals ($keys[0], 'et1');
        
        $test->id ('setNamedItem.2');
        my $et2 = $doc-><M::d|DocumentXDoctype.createAttributeDefinition>
                          ('et2');
        $em-><M::NamedNodeMap.setNamedItem> ($et2);

        $test->id ('keys.2');
        @keys = keys %$em;
        $test->assert_num_equals
                 (actual_value => 0 + @keys,
                  expected_value => 2);
        $test->assert_not_equals ($keys[0], $keys[1]);
        $test->assert_true ($keys[0] eq 'et1' or $keys[0] eq 'et2');
        $test->assert_true ($keys[1] eq 'et1' or $keys[1] eq 'et2');
        
        $test->id ('delete');
        delete $em->{et1};
        $test->assert_false (exists $em->{et1});
        $test->assert_true (exists $em->{et2});

        $test->id ('clear');
        %$em = ();
        $test->assert_num_equals
                 (actual_value => 0 + keys %$em,
                  expected_value => 0);

  @IntMethod:
    @@Perlop: @{}
    @@enDesc:
      In manakai's Perl binding, a <IF::NamedNodeMap> object can be
      dereferenced as if it is an array reference.  For example,
      <Perl::$map-<lt>[2]> will return the same <IF::Node> as
      <Perl::$map-<lt>item (2)> would return.  However, it does
      not support substitions to array items (e.g. <Perl::$map-<lt>[2] = $node>
      does not work).
    @@Return:
      @@@Type: DISPerl|ARRAY||ManakaiDOM|all
      @@@PerlDef:
        @@@@ForCheck: tc|ForAttrMap
        @@@@@:
          tie my @list, <ClassName::ManakaiDOMAttrMapArray>, $self;
          $r = \@list;
      @@@PerlDef:
        @@@@ForCheck: tc|ForETMap
        @@@@@:
          tie my @list, <ClassName::ManakaiDOMElementTypeDefMapArray>, $self;
          $r = \@list;
      @@@PerlDef:
        @@@@ForCheck: tc|ForATMap
        @@@@@:
          tie my @list, <ClassName::ManakaiDOMAttrDefMapArray>, $self;
          $r = \@list;
      @@@PerlDef:
        @@@@ForCheck: tc|ForEntityMap
        @@@@@:
          tie my @list, <ClassName::ManakaiDOMEntityMapArray>, $self;
          $r = \@list;
      @@@PerlDef:
        @@@@ForCheck: tc|ForNotationMap
        @@@@@:
          tie my @list, <ClassName::ManakaiDOMNotationMapArray>, $self;
          $r = \@list;

    @@Test:
      @@@ForCheck: tc|ForAttrMap
      @@@QName: AttrMap.@.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;
        my $doc = $el-><AG::Node.ownerDocument>;
        my $em = $el-><AG::Node.attributes>;

        $test->id ('length.0');
        $test->assert_num_equals
                 (actual_value => 0 + @$em,
                  expected_value => 0);

        $test->id ('fetch.0.no');
        $test->assert_null ($em->[0]);
        $test->id ('exists.0');
        $test->assert_false (exists $em->[0]);
        $test->id ('exists.-1');
        $test->assert_false (exists $em->[-1]);

        $test->id ('setNamedItem');
        my $et1 = $doc-><M::Document.createAttribute> ('et1');
        $em-><M::NamedNodeMap.setNamedItem> ($et1);

        $test->id ('length.1');
        $test->assert_num_equals
                 (actual_value => 0 + @$em,
                  expected_value => 1);

        $test->id ('0.fetch.0');
        $test->assert_equals ($em->[0], $et1);
        $test->id ('0.fetch.-1');
        $test->assert_equals ($em->[-1], $et1);
        $test->id ('0.fetch.1.no');
        $test->assert_null ($em->[1]);
        $test->id ('0.exists.0');
        $test->assert_true (exists $em->[0]);
        $test->id ('0.exists.-1');
        $test->assert_true (exists $em->[-1]);
        $test->id ('0.exists.1.no');
        $test->assert_false (exists $em->[1]);

        $test->id ('delete.0');
        delete $em->[0];
        $test->assert_false (exists $em->[0]);

    @@XDTest:
      @@@ForCheck: tc|ForETMap
      @@@QName: ETMap.@.test
      @@@PerlDef:
        my $dtd;
        __CODE{d|newDoctypeForTest}__;
        my $doc = $dtd-><AG::Node.ownerDocument>;
        my $em = $dtd-><AG::d|DocumentTypeDefinition.elementTypes>;

        $test->id ('length.0');
        $test->assert_num_equals
                 (actual_value => 0 + @$em,
                  expected_value => 0);

        $test->id ('fetch.0.no');
        $test->assert_null ($em->[0]);
        $test->id ('exists.0');
        $test->assert_false (exists $em->[0]);
        $test->id ('exists.-1');
        $test->assert_false (exists $em->[-1]);

        $test->id ('setNamedItem');
        my $et1 = $doc-><M::d|DocumentXDoctype.createElementTypeDefinition>
                          ('et1');
        $em-><M::NamedNodeMap.setNamedItem> ($et1);

        $test->id ('length.1');
        $test->assert_num_equals
                 (actual_value => 0 + @$em,
                  expected_value => 1);

        $test->id ('0.fetch.0');
        $test->assert_equals ($em->[0], $et1);
        $test->id ('0.fetch.-1');
        $test->assert_equals ($em->[-1], $et1);
        $test->id ('0.fetch.1.no');
        $test->assert_null ($em->[1]);
        $test->id ('0.exists.0');
        $test->assert_true (exists $em->[0]);
        $test->id ('0.exists.-1');
        $test->assert_true (exists $em->[-1]);
        $test->id ('0.exists.1.no');
        $test->assert_false (exists $em->[1]);

        $test->id ('delete.0');
        delete $em->[0];
        $test->assert_false (exists $em->[0]);

    @@XDTest:
      @@@ForCheck: tc|ForEntityMap
      @@@QName: EntityMap.@.test
      @@@PerlDef:
        my $dtd;
        __CODE{d|newDoctypeForTest}__;
        my $doc = $dtd-><AG::Node.ownerDocument>;
        my $em = $dtd-><AG::d|DocumentTypeDefinition.generalEntities>;

        $test->id ('length.0');
        $test->assert_num_equals
                 (actual_value => 0 + @$em,
                  expected_value => 0);

        $test->id ('fetch.0.no');
        $test->assert_null ($em->[0]);
        $test->id ('exists.0');
        $test->assert_false (exists $em->[0]);
        $test->id ('exists.-1');
        $test->assert_false (exists $em->[-1]);

        $test->id ('setNamedItem');
        my $et1 = $doc-><M::d|DocumentXDoctype.createGeneralEntity>
                          ('et1');
        $em-><M::NamedNodeMap.setNamedItem> ($et1);

        $test->id ('length.1');
        $test->assert_num_equals
                 (actual_value => 0 + @$em,
                  expected_value => 1);

        $test->id ('0.fetch.0');
        $test->assert_equals ($em->[0], $et1);
        $test->id ('0.fetch.-1');
        $test->assert_equals ($em->[-1], $et1);
        $test->id ('0.fetch.1.no');
        $test->assert_null ($em->[1]);
        $test->id ('0.exists.0');
        $test->assert_true (exists $em->[0]);
        $test->id ('0.exists.-1');
        $test->assert_true (exists $em->[-1]);
        $test->id ('0.exists.1.no');
        $test->assert_false (exists $em->[1]);

        $test->id ('delete.0');
        delete $em->[0];
        $test->assert_false (exists $em->[0]);

    @@XDTest:
      @@@ForCheck: tc|ForNotationMap
      @@@QName: NotationMap.@.test
      @@@PerlDef:
        my $dtd;
        __CODE{d|newDoctypeForTest}__;
        my $doc = $dtd-><AG::Node.ownerDocument>;
        my $em = $dtd-><AG::d|DocumentTypeDefinition.notations>;

        $test->id ('length.0');
        $test->assert_num_equals
                 (actual_value => 0 + @$em,
                  expected_value => 0);

        $test->id ('fetch.0.no');
        $test->assert_null ($em->[0]);
        $test->id ('exists.0');
        $test->assert_false (exists $em->[0]);
        $test->id ('exists.-1');
        $test->assert_false (exists $em->[-1]);

        $test->id ('setNamedItem');
        my $et1 = $doc-><M::d|DocumentXDoctype.createNotation>
                          ('et1');
        $em-><M::NamedNodeMap.setNamedItem> ($et1);

        $test->id ('length.1');
        $test->assert_num_equals
                 (actual_value => 0 + @$em,
                  expected_value => 1);

        $test->id ('0.fetch.0');
        $test->assert_equals ($em->[0], $et1);
        $test->id ('0.fetch.-1');
        $test->assert_equals ($em->[-1], $et1);
        $test->id ('0.fetch.1.no');
        $test->assert_null ($em->[1]);
        $test->id ('0.exists.0');
        $test->assert_true (exists $em->[0]);
        $test->id ('0.exists.-1');
        $test->assert_true (exists $em->[-1]);
        $test->id ('0.exists.1.no');
        $test->assert_false (exists $em->[1]);

        $test->id ('delete.0');
        delete $em->[0];
        $test->assert_false (exists $em->[0]);

    @@XDTest:
      @@@ForCheck: tc|ForATMap
      @@@QName: ATMap.@.test
      @@@PerlDef:
        my $dtd;
        __CODE{d|newDoctypeForTest}__;
        my $doc = $dtd-><AG::Node.ownerDocument>;
        my $etd = $doc-><M::d|DocumentXDoctype.createElementTypeDefinition>
                          ('et1');
        my $em = $etd-><AG::d|ElementTypeDefinition.attributeDefinitions>;
        undef $dtd;

        $test->id ('length.0');
        $test->assert_num_equals
                 (actual_value => 0 + @$em,
                  expected_value => 0);

        $test->id ('fetch.0.no');
        $test->assert_null ($em->[0]);
        $test->id ('exists.0');
        $test->assert_false (exists $em->[0]);
        $test->id ('exists.-1');
        $test->assert_false (exists $em->[-1]);

        $test->id ('setNamedItem');
        my $et1 = $doc-><M::d|DocumentXDoctype.createAttributeDefinition>
                          ('et1');
        $em-><M::NamedNodeMap.setNamedItem> ($et1);

        $test->id ('length.1');
        $test->assert_num_equals
                 (actual_value => 0 + @$em,
                  expected_value => 1);

        $test->id ('0.fetch.0');
        $test->assert_equals ($em->[0], $et1);
        $test->id ('0.fetch.-1');
        $test->assert_equals ($em->[-1], $et1);
        $test->id ('0.fetch.1.no');
        $test->assert_null ($em->[1]);
        $test->id ('0.exists.0');
        $test->assert_true (exists $em->[0]);
        $test->id ('0.exists.-1');
        $test->assert_true (exists $em->[-1]);
        $test->id ('0.exists.1.no');
        $test->assert_false (exists $em->[1]);

        $test->id ('delete.0');
        delete $em->[0];
        $test->assert_false (exists $em->[0]);

  @Method:
    @@Name: getNamedItem
    @@Perlop: FETCH
    @@enDesc:
      Retrieves a node specified by name.
    @@NSVersion: .getNamedItemNS
    @@Param:
      @@@Name: name
      @@@Type: DOMString
      @@@dis:actualType:
        @@@@@: DOMMain|ManakaiDOMXMLName
        @@@@ManakaiDOM:noInputNormalize: 1
      @@@enDesc:
        The <A::Node.nodeName> of a node to retrieve.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        A <IF::Node> with the specified <P::name>.
      @@@nullCase:
        @@@@enDesc:
          If the <P::name> does not identify any node in the map.
      @@@PerlDef:
        @@@@ForCheck: tc|ForAttrMap
        @@@@@:
          __DEEP{
            $r = ($$$self)-><M::Element.getAttributeNode> ($name);
          }__;
      @@@PerlDef:
        @@@@ForCheck: !tc|ForAttrMap
        @@@@@:
          my $list;
          __FOR{tc:ForETMap::
            __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
              $r => $list,
              $prop => {<H::d|elementTypes>},
              $ref => {$$$self},
            }__;
          }__;
          __FOR{tc:ForATMap::
            __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
              $r => $list,
              $prop => {<H::d|attributeDefinitions>},
              $ref => {$$$self},
            }__;
          }__;
          __FOR{tc:ForEntityMap::
            __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
              $r => $list,
              $prop => {<H::d|generalEntities>},
              $ref => {$$$self},
            }__;
          }__;
          __FOR{tc:ForNotationMap::
            __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
              $r => $list,
              $prop => {<H::d|notations>},
              $ref => {$$$self},
            }__;
          }__;
          if (defined $list->{$name}) {
            __CODE{mg|createNodeRefFromID||ManakaiDOM|all::
              $bag => {<Code::mg|getNodeBag||ManakaiDOM|all::
                                $ref = {$$$self}>},
              $stemid => {$list->{$name}},
              $ref => $r,
              $opt => {{}},
            }__;
          }

    @@Test:
      @@@ForCheck: tc|ForAttrMap
      @@@QName: AttrMap.getNamedItem.test
      @@@PerlDef:
        my $el;
        __CODE{createElementForTest:: $el => $el}__;

        my $map = $el-><AG::Node.attributes>;
        $test->assert_isa ($map, <IFName::NamedNodeMap>);
        
        $test->id ('no.attr.node');
        $test->assert_null ($map-><M::NamedNodeMap.getNamedItem> ('a1'));

        $test->id ('dom1.attr.node');
        $el-><M::Element.setAttribute> ('a1', 'value1');
        my $a1 = $map-><M::NamedNodeMap.getNamedItem> ('a1');
        $test->assert_isa ($a1, <IFName::Attr>);
        $test->assert_num_equals
                 (actual_value => $a1-><AG::Node.nodeType>,
                  expected_value => <C::Node.ATTRIBUTE_NODE>);
        $test->assert_equals ($a1-><AG::Node.nodeName>, 'a1');
        $test->assert_equals ($a1-><AG::Node.nodeValue>, 'value1');
        undef $a1;

        $test->id ('dom1.attr.node.removed');
        $el-><M::Element.removeAttribute> ('a1');
        $test->assert_null ($map-><M::NamedNodeMap.getNamedItem> ('a1'));
    @@Test:
      @@@ForCheck: tc|ForAttrMap ManakaiDOM|DOM2
      @@@QName: AttrMap.getNamedItem.qname.test
      @@@PerlDef:
        my $el;
        __CODE{createElementForTest:: $el => $el}__;

        my $map = $el-><AG::Node.attributes>;
        $test->assert_isa ($map, <IFName::NamedNodeMap>);
        
        $test->id ('dom2.attr.node');
        $el-><M::Element.setAttributeNS> ('http://attr.example/', 'ns:a1', 'v1');
        my $a1 = $map-><M::NamedNodeMap.getNamedItem> ('ns:a1');
        $test->assert_isa ($a1, <IFName::Attr>);
        $test->assert_num_equals
                 (actual_value => $a1-><AG::Node.nodeType>,
                  expected_value => <C::Node.ATTRIBUTE_NODE>);
        $test->assert_equals ($a1-><AG::Node.nodeName>, 'ns:a1');
        $test->assert_equals ($a1-><AG::Node.nodeValue>, 'v1');
        undef $a1;
        $test->assert_null ($map-><M::NamedNodeMap.getNamedItem> ('a1'));

        $test->id ('dom2.attr.node.removed');
        $el-><M::Element.removeAttributeNS> ('http://attr.example/', 'a1');
        $test->assert_null ($map-><M::NamedNodeMap.getNamedItem> ('ns:a1'));

    @@Test:
      @@@ForCheck: tc|ForAttrMap
      @@@QName: AttrMap.getNamedItem.setNamedItem.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;
        my $doc = $el-><AG::Node.ownerDocument>;

        my $em = $el-><AG::Node.attributes>;
        $test->assert_isa ($em, <IFName::t|NamedNodeMap>);

        $test->id ('getNamedItem.none');
        $test->assert_null ($em-><M::NamedNodeMap.getNamedItem> ('et1'));

        my $et1 = $doc-><M::Document.createAttribute>
                          ('et1');
        $test->assert_isa ($et1, <IFName::Attr>);

        $test->id ('setNamedItem.et1');
        my $r1 = $em-><M::NamedNodeMap.setNamedItem> ($et1);
        $test->assert_null ($r1);

        $test->id ('getNamedItem.et1');
        my $r2 = $em-><M::NamedNodeMap.getNamedItem> ('et1');
        $test->assert_equals ($r2, $et1);
        $test->assert_equals
                 ($r2-><AG::Attr.ownerElement>, $el);
        $test->assert_equals
                 ($et1-><AG::Attr.ownerElement>, $el);

        my $et2 = $doc-><M::Document.createAttribute>
                          ('et1');
        $test->assert_isa ($et2, <IFName::Attr>);
        $test->assert_not_equals ($et1, $et2);

        $test->id ('setNamedItem.et2');
        my $r3 = $em-><M::NamedNodeMap.setNamedItem> ($et2);
        $test->assert_equals ($r3, $et1);

        $test->id ('getNamedItem.et2');
        my $r4 = $em-><M::NamedNodeMap.getNamedItem> ('et1');
        $test->assert_equals ($r4, $et2);

        $test->id ('setNamedItem.et2.by.et2');
        my $r5 = $em-><M::NamedNodeMap.setNamedItem> ($et2);
        $test->assert_null ($r5);
        $test->assert_equals ($em-><M::NamedNodeMap.getNamedItem> ('et1'), $et2);

    @@XDTest:
      @@@ForCheck: tc|ForETMap
      @@@QName: etmap.getNamedItem.setNamedItem.test
      @@@PerlDef:
        my $dtd;
        __CODE{d|newDoctypeForTest}__;
        my $doc = $dtd-><AG::Node.ownerDocument>;

        my $em = $dtd-><AG::d|DocumentTypeDefinition.elementTypes>;
        $test->assert_isa ($em, <IFName::t|NamedNodeMap>);

        $test->id ('getNamedItem.none');
        $test->assert_null ($em-><M::NamedNodeMap.getNamedItem> ('et1'));

        my $et1 = $doc-><M::d|DocumentXDoctype.createElementTypeDefinition>
                          ('et1');
        $test->assert_isa ($et1, <IFName::d|ElementTypeDefinition>);

        $test->id ('setNamedItem.et1');
        my $r1 = $em-><M::NamedNodeMap.setNamedItem> ($et1);
        $test->assert_null ($r1);

        $test->id ('getNamedItem.et1');
        my $r2 = $em-><M::NamedNodeMap.getNamedItem> ('et1');
        $test->assert_equals ($r2, $et1);
        $test->assert_equals
                 ($r2-><AG::d|ElementTypeDefinition.ownerDocumentTypeDefinition>,
                  $dtd);
        $test->assert_equals
                 ($et1-><AG::d|ElementTypeDefinition.ownerDocumentTypeDefinition>,
                  $dtd);

        my $et2 = $doc-><M::d|DocumentXDoctype.createElementTypeDefinition>
                          ('et1');
        $test->assert_isa ($et2, <IFName::d|ElementTypeDefinition>);
        $test->assert_not_equals ($et1, $et2);

        $test->id ('setNamedItem.et2');
        my $r3 = $em-><M::NamedNodeMap.setNamedItem> ($et2);
        $test->assert_equals ($r3, $et1);

        $test->id ('getNamedItem.et2');
        my $r4 = $em-><M::NamedNodeMap.getNamedItem> ('et1');
        $test->assert_equals ($r4, $et2);

        $test->id ('setNamedItem.et2.by.et2');
        my $r5 = $em-><M::NamedNodeMap.setNamedItem> ($et2);
        $test->assert_null ($r5);
        $test->assert_equals ($em-><M::NamedNodeMap.getNamedItem> ('et1'), $et2);

    @@XDTest:
      @@@ForCheck: tc|ForEntityMap
      @@@QName: EntityMap.getNamedItem.setNamedItem.test
      @@@PerlDef:
        my $dtd;
        __CODE{d|newDoctypeForTest}__;
        my $doc = $dtd-><AG::Node.ownerDocument>;

        my $em = $dtd-><AG::d|DocumentTypeDefinition.generalEntities>;
        $test->assert_isa ($em, <IFName::t|NamedNodeMap>);

        $test->id ('getNamedItem.none');
        $test->assert_null ($em-><M::NamedNodeMap.getNamedItem> ('et1'));

        my $et1 = $doc-><M::d|DocumentXDoctype.createGeneralEntity>
                          ('et1');
        $test->assert_isa ($et1, <IFName::x|Entity>);

        $test->id ('setNamedItem.et1');
        my $r1 = $em-><M::NamedNodeMap.setNamedItem> ($et1);
        $test->assert_null ($r1);

        $test->id ('getNamedItem.et1');
        my $r2 = $em-><M::NamedNodeMap.getNamedItem> ('et1');
        $test->assert_equals ($r2, $et1);
        $test->assert_equals
                 ($r2-><AG::x|Entity.ownerDocumentTypeDefinition>,
                  $dtd);
        $test->assert_equals
                 ($et1-><AG::x|Entity.ownerDocumentTypeDefinition>,
                  $dtd);

        my $et2 = $doc-><M::d|DocumentXDoctype.createGeneralEntity>
                          ('et1');
        $test->assert_isa ($et2, <IFName::x|Entity>);
        $test->assert_not_equals ($et1, $et2);

        $test->id ('setNamedItem.et2');
        my $r3 = $em-><M::NamedNodeMap.setNamedItem> ($et2);
        $test->assert_equals ($r3, $et1);

        $test->id ('getNamedItem.et2');
        my $r4 = $em-><M::NamedNodeMap.getNamedItem> ('et1');
        $test->assert_equals ($r4, $et2);

        $test->id ('setNamedItem.et2.by.et2');
        my $r5 = $em-><M::NamedNodeMap.setNamedItem> ($et2);
        $test->assert_null ($r5);
        $test->assert_equals ($em-><M::NamedNodeMap.getNamedItem> ('et1'), $et2);

    @@XDTest:
      @@@ForCheck: tc|ForNotationMap
      @@@QName: NotationMap.getNamedItem.setNamedItem.test
      @@@PerlDef:
        my $dtd;
        __CODE{d|newDoctypeForTest}__;
        my $doc = $dtd-><AG::Node.ownerDocument>;

        my $em = $dtd-><AG::d|DocumentTypeDefinition.notations>;
        $test->assert_isa ($em, <IFName::t|NamedNodeMap>);

        $test->id ('getNamedItem.none');
        $test->assert_null ($em-><M::NamedNodeMap.getNamedItem> ('et1'));

        my $et1 = $doc-><M::d|DocumentXDoctype.createNotation>
                          ('et1');
        $test->assert_isa ($et1, <IFName::x|Notation>);

        $test->id ('setNamedItem.et1');
        my $r1 = $em-><M::NamedNodeMap.setNamedItem> ($et1);
        $test->assert_null ($r1);

        $test->id ('getNamedItem.et1');
        my $r2 = $em-><M::NamedNodeMap.getNamedItem> ('et1');
        $test->assert_equals ($r2, $et1);
        $test->assert_equals
                 ($r2-><AG::x|Notation.ownerDocumentTypeDefinition>,
                  $dtd);
        $test->assert_equals
                 ($et1-><AG::x|Notation.ownerDocumentTypeDefinition>,
                  $dtd);

        my $et2 = $doc-><M::d|DocumentXDoctype.createNotation>
                          ('et1');
        $test->assert_isa ($et2, <IFName::x|Notation>);
        $test->assert_not_equals ($et1, $et2);

        $test->id ('setNamedItem.et2');
        my $r3 = $em-><M::NamedNodeMap.setNamedItem> ($et2);
        $test->assert_equals ($r3, $et1);

        $test->id ('getNamedItem.et2');
        my $r4 = $em-><M::NamedNodeMap.getNamedItem> ('et1');
        $test->assert_equals ($r4, $et2);

        $test->id ('setNamedItem.et2.by.et2');
        my $r5 = $em-><M::NamedNodeMap.setNamedItem> ($et2);
        $test->assert_null ($r5);
        $test->assert_equals ($em-><M::NamedNodeMap.getNamedItem> ('et1'), $et2);

  @Method:
    @@Name: setNamedItem
    @@enDesc:
      Adds a node using its <A::Node.nodeName> attribute.  If a node
      with that name is already present in the map, it is replaced
      by the new one.  Replacing a node by itself has no effect.

      As the <A::Node.nodeName> is used to derive the name under which
      the node is stored, multiple nodes the names would clash
      cannot be stored.
    @@enImplNote:
      @@@ddid: repbyitself
      @@@@:
        <QUOTE::Replacing a node by itself has no effect> clause is 
        clarified by DOM Level 2 errata.
    @@NSVersion: .setNamedItemNS
    @@Param:
      @@@Name: arg
      @@@Type: Node
      @@@enDesc:
        A node to store to the map.
      @@@enImplNote:
        The node will later be accessible using the value of <A::Node.nodeName>
        attribute.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        If <P::arg> replaces an existing node, the replaced <IF::Node>.
      @@@nullCase:
        @@@@enDesc:
          No replacement occurred.
        @@@@enImplNote:
          What is returned if replace-by-itself?  It has no effect,
          so it does no <QUOTE::replacement>, and <DOM::null>
          should be returned?
      @@@dx:raises:
        @@@@@: c|DIFFERENT_DOCUMENT_ERR
        @@@@enDesc:
          If <P::arg> was created from a different document than
          the one that created the map.
        @@@@enDesc:
          @@@@@ddid: no-doc
          @@@@@ForCheck: !tc|ForAttrMap ManakaiDOM|ManakaiDOM
          @@@@@@:
            If the map is attached to a <IF::x|DocumentType> 
            whose <A::Node.ownerDocument> is <DOM::null>.
      @@@dx:raises:
        @@@@@: c|NOMOD_NAMEDNODEMAP_ERR
        @@@@enDesc:
          If the map is read-only.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the node to which the map is attached is read-only.
      @@@dx:raises:
        @@@@@: c|INUSE_ATTRIBUTE_ERR
        @@@@enDesc:
          If <P::arg> is an <IF::Attr> that is already an attribute
          of another <IF::Element>.
        @@@@ForCheck: !tc|ForETMap !tc|ForATMap !tc|ForEntityMap !tc|ForNotationMap
      @@@dx:raises:
        @@@@@: c|INUSE_DEFINITION_ERR
        @@@@enDesc:
          If <P::arg> is a definition node that is already used
          for another node.
        @@@@ForCheck: !tc|ForAttrMap
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_BAD_TYPE
        @@@@enDesc:
          If an attempt is made to add a node that is unable to
          belong to the map.
        @@@@enImplNote:
          Added by DOM Level 2 errata.
        @@@@For: ManakaiDOM|DOM2
      @@@c:reports:
        @@@@@: t|replace-by-itself
        @@@@enDesc:
          If the <P::arg> node is same as the node that is in the map.
          Then, the method call has no effect.
        @@@@enImplNote:
          This case is clarified by DOM Level 2 errata.
        @@@@For: ManakaiDOM|ManakaiDOM
      @@@PerlDef:
        @@@@ForCheck: tc|ForAttrMap
        @@@@@:
          __DEEP{
            $r = ($$$self)-><M::Element.setAttributeNode> ($arg);
          }__;
      @@@PerlDef:
        @@@@ForCheck: !tc|ForAttrMap
        @@@@@:
          my $list;
          my $expected_type;
          __FOR{tc:ForETMap::
            __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
              $r => $list,
              $prop => {<H::d|elementTypes>},
              $ref => {$$$self},
            }__;
            $expected_type = <C::Node.ELEMENT_TYPE_DEFINITION_NODE>;
          }__;
          __FOR{tc:ForATMap::
            __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
              $r => $list,
              $prop => {<H::d|attributeDefinitions>},
              $ref => {$$$self},
            }__;
            $expected_type = <C::Node.ATTRIBUTE_DEFINITION_NODE>;
          }__;
          __FOR{tc:ForEntityMap::
            __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
              $r => $list,
              $prop => {<H::d|generalEntities>},
              $ref => {$$$self},
            }__;
            $expected_type = <C::Node.ENTITY_NODE>;
          }__;
          __FOR{tc:ForNotationMap::
            __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
              $r => $list,
              $prop => {<H::d|notations>},
              $ref => {$$$self},
            }__;
            $expected_type = <C::Node.NOTATION_NODE>;
          }__;
          if ($$$self-><AG::Node.ownerDocument>
                     -><AG::Document.strictErrorChecking>) {
            unless ($arg-><AG::Node.ownerDocument>
                        eq $$$self-><AG::Node.ownerDocument>) {
              __EXCEPTION{c|DIFFERENT_DOCUMENT_ERR::
              }__;
            }
            if ($$$self-><AG::Node.manakaiReadOnly>) {
              __EXCEPTION{c|NOMOD_NAMEDNODEMAP_ERR::
              }__;
            }
            my $owner_def;
            __CODE{mg|getNodeStemProp0Node||ManakaiDOM|all::
              $r => $owner_def,
              $prop => {<H::d|ownerDefinition>},
              $ref => $arg,
            }__;
            if ($owner_def and not $owner_def eq $$$self) {
              __EXCEPTION{c|INUSE_DEFINITION_ERR::
                MDOMX:param-name => 'arg',
                c:node => {$arg},
              }__;
              ## NOTE: If equals to owner, then replace-by-itself error.
            }
            if ($arg-><AG::Node.nodeType> != $expected_type) {
              __EXCEPTION{MDOMX|HIERARCHY_BAD_TYPE::
                c:nodeType => {$arg-><AG::Node.nodeType>},
                MDOMX:param-name => 'arg',
              }__;
            }
          } # strictErrorChecking
          SET: {
            my $name = $arg-><AG::Node.nodeName>;
            if (defined $list->{$name}) {
              __CODE{mg|createNodeRef||ManakaiDOM|all::
                $bag => {<Code::mg|getNodeBag||ManakaiDOM|all::
                                    $ref = {$$$self}>},
                $stem => {$list->{$name}},
                $ref => $r,
                $opt => {{}},
              }__;
              if ($r eq $arg) {
                __c:ERROR{t|replace-by-itself::
                  c:relatedData => {$arg},
                }__;
                # no return value
                last SET;
              }
            }
            $list->{$name} = <Code::mg|getNodeID||ManakaiDOM|all::
                                        $ref = $arg>;
            __CODE{mg|setNodeStemProp0Node||ManakaiDOM|all::
              $prop => {<H::d|ownerDefinition>},
              $ref => $arg,
              $given => $self,
            }__;
          } # SET

    @@enImplNote:
      @@@ForCheck: !tc|ForETMap
      @@@ddid: nsattrnodename
      @@@@:
        {P:: If a <IF::NamedNodeMap> contains two nodes:
            
             - <A::Node.nodeName> equals to <CODE::ns1:ln>, and
 
             - <A::Node.nodeName> equals to <CODE::ns2:ln>,
               <A::Node.localName> equals to <CODE::ln>, and 
               <A::Node.namespaceURI> equals to <URI::http://www.example/>,
              
             then what result is lead by an attempt to add a node
             with <A::Node.nodeName> equals to <CODE::ns1:ln>,
             <A::Node.localName> equals to <CODE::ln>, and
             <A::Node.namespaceURI> equals to <URI::http://www.example/>?
        }

    @@Test:
      @@@ForCheck: tc|ForAttrMap
      @@@QName: AttrMap.setNamedItem.dom1.test
      @@@PerlDef:
        my $doc;
        my $el;
        __CODE{createElementForTest:: $el => $el}__;

        $doc = $el-><AG::Node.ownerDocument>;

        my $map = $el-><AG::Node.attributes>;

        $test->assert_null ($map-><M::NamedNodeMap.getNamedItem> ('a1'));

        $test->id ('set.new.node');
        my $a1 = $doc-><M::Document.createAttribute> ('a1');
        $a1-><AS::Attr.value> ('value1');
        $map-><M::NamedNodeMap.setNamedItem> ($a1);
        my $a1r = $map-><M::NamedNodeMap.getNamedItem> ('a1');
        $test->assert_isa ($a1r, <IFName::Attr>);
        $test->assert_num_equals
                 (actual_value => $a1r-><AG::Node.nodeType>,
                  expected_value => <C::Node.ATTRIBUTE_NODE>);
        $test->assert_equals ($a1r-><AG::Node.nodeName>, 'a1');
        $test->assert_equals ($a1r-><AG::Node.nodeValue>, 'value1');
        $test->assert_equals ($a1r, $a1);
        $test->assert_equals ($el-><M::Element.getAttribute> ('a1'), 'value1');

        $test->id ('replace.node');
        my $a2 = $doc-><M::Document.createAttribute> ('a1');
        $a2-><AS::Attr.value> ('value2');
        $test->assert_not_equals ($a1, $a2);
        my $ra1 = $map-><M::NamedNodeMap.setNamedItem> ($a2);
        $test->assert_equals ($ra1, $a1);
        my $a2r = $map-><M::NamedNodeMap.getNamedItem> ('a1');
        $test->assert_equals ($a2r, $a2);
        $test->assert_equals ($el-><M::Element.getAttribute> ('a1'), 'value2');
     @@enImplNote:
       {TODO:: Namespace aware test required
       }

  @Method:
    @@Name: removeNamedItem
    @@enDesc:
      Removes a node specified by name.
    @@enDesc:
      @@@ddid: attr
      @@@ForCheck: !tc|ForETMap !tc|ForATMap !tc|ForEntityMap !tc|ForNotationMap
      @@@enDesc:
        If the removed attribute is known to have a default value,
        an attribute immediately appears containing the default
        value as well as the corresponding namespace URI, local name,
        and prefix when applicable.
    @@NSVersion: .removeNamedItemNS
    @@Param:
      @@@Name: name
      @@@Type: DOMString
      @@@dis:actualType: 
        @@@@@: DOMMain|ManakaiDOMXMLName
        @@@@ManakaiDOM:noInputNormalize: 1
      @@@enDesc:
        The <A::Node.nodeName> of the node to remove.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node removed from the map.
      @@@dx:raises:
        @@@@@: c|NO_NAMED_NODE_ERR
        @@@@enDesc:
          If there is no node named as <P::name> in the map.
      @@@dx:raises:
        @@@@@: c|NOMOD_NAMEDNODEMAP_ERR
        @@@@enDesc:
          If the map is read-only.
        @@@@enImplNote:
          Added by DOM Level 1 (first edition) errata.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the node to which the map is attached is read-only.
        @@@@For: ManakaiDOM|ManakaiDOM
      @@@enImplNote:
        In DOM Level 1 Specification (first edition), it is defined that 
        in case there is no node with <P::name> then <DOM::null> should be
        returned while <X::c|NO_NAMED_NODE_ERR> exception is also specified.
        The former is removed by DOM Level 1 (first edition) errata.
      @@@PerlDef:
        @@@@ForCheck: tc|ForAttrMap
        @@@@@:
          my $el = $$$self;
          __DEEP{ 
            $r = $el-><M::Element.getAttributeNode> ($name);
          }__;
          unless ($r) {
            __EXCEPTION{c|NO_NAMED_NODE_ERR::
              c|name => {$name},
              MDOMX|param-name => 'name',
            }__;
          }
          __DEEP{
            $r = $el-><M::Element.removeAttributeNode> ($r);
          }__;
      @@@PerlDef:
        @@@@ForCheck: !tc|ForAttrMap
        @@@@@:
          my $list;
          __FOR{tc:ForETMap::
            __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
              $r => $list,
              $prop => {<H::d|elementTypes>},
              $ref => {$$$self},
            }__;
          }__;
          __FOR{tc:ForATMap::
            __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
              $r => $list,
              $prop => {<H::d|attributeDefinitions>},
              $ref => {$$$self},
            }__;
          }__;
          __FOR{tc:ForEntityMap::
            __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
              $r => $list,
              $prop => {<H::d|generalEntities>},
              $ref => {$$$self},
            }__;
          }__;
          __FOR{tc:ForNotationMap::
            __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
              $r => $list,
              $prop => {<H::d|notations>},
              $ref => {$$$self},
            }__;
          }__;
          if ($$$self-><AG::Node.ownerDocument>
                     -><AG::Document.strictErrorChecking>) {
            if ($$$self-><AG::Node.manakaiReadOnly>) {
              __EXCEPTION{c|NOMOD_NAMEDNODEMAP_ERR::
              }__;
            }
          } # strictErrorChecking

          if (defined $list->{$name}) {
            __CODE{mg|createNodeRef||ManakaiDOM|all::
              $bag => {<Code::mg|getNodeBag||ManakaiDOM|all::
                                  $ref = {$$$self}>},
              $stem => {$list->{$name}},
              $ref => $r,
              $opt => {{}},
            }__;
            __CODE{mg|deleteNodeStemPropValue||ManakaiDOM|all::
              $prop => {<H::d|ownerDefinition>},
              $ref => $r,
            }__;
          } else {
            __EXCEPTION{c|NO_NAMED_NODE_ERR::
              c|name => {$name},
              MDOMX|param-name => 'name',
            }__;
          }

    @@Test:
      @@@QName: AttrMap.removeNamedItem.test
      @@@ForCheck: tc|ForAttrMap
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;
        my $doc = $el-><AG::Node.ownerDocument>;
        my $em = $el-><AG::Node.attributes>;
        undef $el;

        $test->id ('setNamedItem');
        my $et1 = $doc-><M::Document.createAttribute> ('et1');
        $em-><M::NamedNodeMap.setNamedItem> ($et1);
        $test->assert_equals
                 ($em-><M::NamedNodeMap.getNamedItem> ('et1'), $et1);

        $test->id ('removeNamedItem.noremove');
        $test->assert_exception (code => sub {
          $em-><M::NamedNodeMap.removeNamedItem> ('et2');
        }, exception_subtype => <Q::c|NO_NAMED_NODE_ERR>);

        $test->id ('removeNamedItem.remove');
        my $et3 = $em-><M::NamedNodeMap.removeNamedItem> ('et1');
        $test->assert_equals ($et3, $et1);
        $test->assert_null ($em-><M::NamedNodeMap.getNamedItem> ('et1'));

        undef $em;

    @@XDTest:
      @@@QName: ETMap.removeNamedItem.test
      @@@ForCheck: tc|ForETMap
      @@@PerlDef:
        my $dtd;
        __CODE{d|newDoctypeForTest}__;
        my $doc = $dtd-><AG::Node.ownerDocument>;
        my $em = $dtd-><AG::d|DocumentTypeDefinition.elementTypes>;
        undef $dtd;

        $test->id ('setNamedItem');
        my $et1 = $doc-><M::d|DocumentXDoctype.createElementTypeDefinition>
                          ('et1');
        $em-><M::NamedNodeMap.setNamedItem> ($et1);
        $test->assert_equals
                 ($em-><M::NamedNodeMap.getNamedItem> ('et1'), $et1);

        $test->id ('removeNamedItem.noremove');
        $test->assert_exception (code => sub {
          $em-><M::NamedNodeMap.removeNamedItem> ('et2');
        }, exception_subtype => <Q::c|NO_NAMED_NODE_ERR>);

        $test->id ('removeNamedItem.remove');
        my $et3 = $em-><M::NamedNodeMap.removeNamedItem> ('et1');
        $test->assert_equals ($et3, $et1);
        $test->assert_null ($em-><M::NamedNodeMap.getNamedItem> ('et1'));

        undef $em;

    @@XDTest:
      @@@QName: ATMap.removeNamedItem.test
      @@@ForCheck: tc|ForATMap
      @@@PerlDef:
        my $dtd;
        __CODE{d|newDoctypeForTest}__;
        my $doc = $dtd-><AG::Node.ownerDocument>;
        my $etd = $doc-><M::d|DocumentXDoctype.createElementTypeDefinition>
                          ('et1');
        my $ad = $etd-><AG::d|ElementTypeDefinition.attributeDefinitions>;
        undef $dtd;
        undef $etd;

        $test->id ('setNamedItem');
        my $at1 = $doc-><M::d|DocumentXDoctype.createAttributeDefinition>
                          ('at1');
        $ad-><M::NamedNodeMap.setNamedItem> ($at1);
        $test->assert_equals
                 ($ad-><M::NamedNodeMap.getNamedItem> ('at1'), $at1);

        $test->id ('removeNamedItem.noremove');
        $test->assert_exception (code => sub {
          $ad-><M::NamedNodeMap.removeNamedItem> ('at2');
        }, exception_subtype => <Q::c|NO_NAMED_NODE_ERR>);

        $test->id ('removeNamedItem.remove');
        my $at3 = $ad-><M::NamedNodeMap.removeNamedItem> ('at1');
        $test->assert_equals ($at3, $at1);
        $test->assert_null ($ad-><M::NamedNodeMap.getNamedItem> ('at1'));

        undef $ad;

    @@XDTest:
      @@@QName: EntityMap.removeNamedItem.test
      @@@ForCheck: tc|ForEntityMap
      @@@PerlDef:
        my $dtd;
        __CODE{d|newDoctypeForTest}__;
        my $doc = $dtd-><AG::Node.ownerDocument>;
        my $em = $dtd-><AG::d|DocumentTypeDefinition.generalEntities>;
        undef $dtd;

        $test->id ('setNamedItem');
        my $et1 = $doc-><M::d|DocumentXDoctype.createGeneralEntity>
                          ('et1');
        $em-><M::NamedNodeMap.setNamedItem> ($et1);
        $test->assert_equals
                 ($em-><M::NamedNodeMap.getNamedItem> ('et1'), $et1);

        $test->id ('removeNamedItem.noremove');
        $test->assert_exception (code => sub {
          $em-><M::NamedNodeMap.removeNamedItem> ('et2');
        }, exception_subtype => <Q::c|NO_NAMED_NODE_ERR>);

        $test->id ('removeNamedItem.remove');
        my $et3 = $em-><M::NamedNodeMap.removeNamedItem> ('et1');
        $test->assert_equals ($et3, $et1);
        $test->assert_null ($em-><M::NamedNodeMap.getNamedItem> ('et1'));

        undef $em;

    @@XDTest:
      @@@QName: NotationMap.removeNamedItem.test
      @@@ForCheck: tc|ForNotationMap
      @@@PerlDef:
        my $dtd;
        __CODE{d|newDoctypeForTest}__;
        my $doc = $dtd-><AG::Node.ownerDocument>;
        my $em = $dtd-><AG::d|DocumentTypeDefinition.notations>;
        undef $dtd;

        $test->id ('setNamedItem');
        my $et1 = $doc-><M::d|DocumentXDoctype.createNotation>
                          ('et1');
        $em-><M::NamedNodeMap.setNamedItem> ($et1);
        $test->assert_equals
                 ($em-><M::NamedNodeMap.getNamedItem> ('et1'), $et1);

        $test->id ('removeNamedItem.noremove');
        $test->assert_exception (code => sub {
          $em-><M::NamedNodeMap.removeNamedItem> ('et2');
        }, exception_subtype => <Q::c|NO_NAMED_NODE_ERR>);

        $test->id ('removeNamedItem.remove');
        my $et3 = $em-><M::NamedNodeMap.removeNamedItem> ('et1');
        $test->assert_equals ($et3, $et1);
        $test->assert_null ($em-><M::NamedNodeMap.getNamedItem> ('et1'));

        undef $em;

  @IntMethod:
    @@Perlop: DELETE
    @@enDesc:
      Removes a node specified by name.
    @@enDesc:
      @@@ddid: attr
      @@@ForCheck: tc|ForAttrMap
      @@@enDesc:
        If the removed attribute is known to have a default value,
        an attribute immediately appears containing the default
        value as well as the corresponding namespace URI, local name,
        and prefix when applicable.
    @@Param:
      @@@Name: key
      @@@Type: DOMString
      @@@enDesc:
        The <A::Node.nodeName> of the node to remove.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node removed from the map.
      @@@enImplNote:
        Is this return value OK?
      @@@nullCase:
        @@@@enDesc:
          If there is no node named as <P::name> in the map.
      @@@dx:raises:
        @@@@@: c|NOMOD_NAMEDNODEMAP_ERR
        @@@@enDesc:
          If the map is read-only.
      @@@PerlDef:
        try {
          $r = $self-><M::NamedNodeMap.removeNamedItem> ($key);
        } catch <IF::c|DOMException> with {
          my $err = shift;
          unless ($err->subtype eq <Q::c|NO_NAMED_NODE_ERR>) {
            $err->throw;
          }
        };

  @Method:
    @@Name: item
    @@enDesc:
      Returns the <P::index>th item in the map.
    @@Param:
      @@@Name: index
      @@@Type: idl|unsignedLong||ManakaiDOM|all
      @@@enDesc:
        The ordinal index of a node to retrieve.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node at the <P::index>th position in the map.
      @@@nullCase:
        @@@@enDesc:
          If <P::index> is greater than or equal to the number of nodes
          in the map.
      @@@PerlDef:
        @@@@ForCheck: tc|ForAttrMap
        @@@@@:
          FIND: {
            my $i = 0;
            my $attrs;
            __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
              $r => $attrs,
              $prop => {<H::infoset|attributes>},
              $ref => {$$$self},
            }__;
            for my $ns (sort {$a cmp $b} keys %{$attrs}) {
              for my $ln (sort {$a cmp $b} keys %{$attrs->{$ns}}) {
                if ($i++ == $index) {
                  __CODE{mg|createNodeRefFromID||ManakaiDOM|all::
                    $bag => {<Code::mg|getNodeBag||ManakaiDOM|all::
                                        $ref = {$$$self}>},
                    $stemid => {$attrs->{$ns}->{$ln}},
                    $ref => $r,
                    $opt => {{}},
                  }__;
                  last FIND;
                }
              }
            }
          } # FIND
      @@@PerlDef:
        @@@@ForCheck: !tc|ForAttrMap
        @@@@@:
          my $list;
          __FOR{tc:ForETMap::
            __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
              $r => $list,
              $prop => {<H::d|elementTypes>},
              $ref => {$$$self},
            }__;
          }__;
          __FOR{tc:ForATMap::
            __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
              $r => $list,
              $prop => {<H::d|attributeDefinitions>},
              $ref => {$$$self},
            }__;
          }__;
          __FOR{tc:ForEntityMap::
            __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
              $r => $list,
              $prop => {<H::d|generalEntities>},
              $ref => {$$$self},
            }__;
          }__;
          __FOR{tc:ForNotationMap::
            __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
              $r => $list,
              $prop => {<H::d|notations>},
              $ref => {$$$self},
            }__;
          }__;
          my $key = $index >= 0 ? [sort {$a cmp $b} keys %$list]->[$index]
                                : null;
          if (defined $key and defined $list->{$key}) {
            __CODE{mg|createNodeRefFromID||ManakaiDOM|all::
              $bag => {<Code::mg|getNodeBag||ManakaiDOM|all::
                                  $ref = {$$$self}>},
              $stemid => {$list->{$key}},
              $ref => $r,
              $opt => {{}},
            }__;
          }
    
    @@Test:
      @@@QName: AttrMap.item.test
      @@@ForCheck: tc|ForAttrMap
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;
        my $doc = $el-><AG::Node.ownerDocument>;
        my $em = $el-><AG::Node.attributes>;
        
        $test->id ('no.item');
        $test->assert_null ($em-><M::NamedNodeMap.item> (-1));
        $test->assert_null ($em-><M::NamedNodeMap.item> (0));
        $test->assert_null ($em-><M::NamedNodeMap.item> (1));
        $test->assert_null ($em-><M::NamedNodeMap.item> (2));

        $test->id ('two.items');
        my $et1 = $doc-><M::Document.createAttribute>
                          ('et1');
        $el-><M::Element.setAttributeNode> ($et1);
        my $et2 = $doc-><M::Document.createAttribute>
                          ('et2');
        $el-><M::Element.setAttributeNode> ($et2);

        $test->assert_null ($em-><M::NamedNodeMap.item> (-1));
        $test->assert_null ($em-><M::NamedNodeMap.item> (2));
        my $item0 = $em-><M::NamedNodeMap.item> (0);
        my $item1 = $em-><M::NamedNodeMap.item> (1);
        $test->assert_not_null ($item0);
        $test->assert_not_null ($item1);
        $test->assert_not_equals ($item0, $item1);
        $test->assert_true ($et1 eq $item0 or $et2 eq $item0);
        $test->assert_true ($et1 eq $item1 or $et2 eq $item1);
    
    @@XDTest:
      @@@QName: ETMap.item.test
      @@@ForCheck: tc|ForETMap
      @@@PerlDef:
        my $dtd;
        __CODE{d|newDoctypeForTest}__;
        my $doc = $dtd-><AG::Node.ownerDocument>;
        my $em = $dtd-><AG::d|DocumentTypeDefinition.elementTypes>;
        
        $test->id ('no.item');
        $test->assert_null ($em-><M::NamedNodeMap.item> (-1));
        $test->assert_null ($em-><M::NamedNodeMap.item> (0));
        $test->assert_null ($em-><M::NamedNodeMap.item> (1));
        $test->assert_null ($em-><M::NamedNodeMap.item> (2));

        $test->id ('two.items');
        my $et1 = $doc-><M::d|DocumentXDoctype.createElementTypeDefinition>
                          ('et1');
        $dtd-><M::d|DocumentTypeDefinition.setElementTypeDefinitionNode> ($et1);
        my $et2 = $doc-><M::d|DocumentXDoctype.createElementTypeDefinition>
                          ('et2');
        $dtd-><M::d|DocumentTypeDefinition.setElementTypeDefinitionNode> ($et2);

        $test->assert_null ($em-><M::NamedNodeMap.item> (-1));
        $test->assert_null ($em-><M::NamedNodeMap.item> (2));
        my $item0 = $em-><M::NamedNodeMap.item> (0);
        my $item1 = $em-><M::NamedNodeMap.item> (1);
        $test->assert_not_null ($item0);
        $test->assert_not_null ($item1);
        $test->assert_not_equals ($item0, $item1);
        $test->assert_true ($et1 eq $item0 or $et2 eq $item0);
        $test->assert_true ($et1 eq $item1 or $et2 eq $item1);
    
    @@XDTest:
      @@@QName: ATMap.item.test
      @@@ForCheck: tc|ForATMap
      @@@PerlDef:
        my $dtd;
        __CODE{d|newDoctypeForTest}__;
        my $doc = $dtd-><AG::Node.ownerDocument>;
        my $etd = $doc-><M::d|DocumentXDoctype.createElementTypeDefinition>
                          ('et1');
        my $ad = $etd-><AG::d|ElementTypeDefinition.attributeDefinitions>;
        undef $dtd;
        
        $test->id ('no.item');
        $test->assert_null ($ad-><M::NamedNodeMap.item> (-1));
        $test->assert_null ($ad-><M::NamedNodeMap.item> (0));
        $test->assert_null ($ad-><M::NamedNodeMap.item> (1));
        $test->assert_null ($ad-><M::NamedNodeMap.item> (2));

        $test->id ('two.items');
        my $at1 = $doc-><M::d|DocumentXDoctype.createAttributeDefinition>
                          ('at1');
        $etd-><M::d|ElementTypeDefinition.setAttributeDefinitionNode> ($at1);
        my $at2 = $doc-><M::d|DocumentXDoctype.createAttributeDefinition>
                          ('at2');
        $etd-><M::d|ElementTypeDefinition.setAttributeDefinitionNode> ($at2);

        $test->assert_null ($ad-><M::NamedNodeMap.item> (-1));
        $test->assert_null ($ad-><M::NamedNodeMap.item> (2));
        my $item0 = $ad-><M::NamedNodeMap.item> (0);
        my $item1 = $ad-><M::NamedNodeMap.item> (1);
        $test->assert_not_null ($item0);
        $test->assert_not_null ($item1);
        $test->assert_not_equals ($item0, $item1);
        $test->assert_true ($at1 eq $item0 or $at2 eq $item0);
        $test->assert_true ($at1 eq $item1 or $at2 eq $item1);
    
    @@XDTest:
      @@@QName: EntityMap.item.test
      @@@ForCheck: tc|ForEntityMap
      @@@PerlDef:
        my $dtd;
        __CODE{d|newDoctypeForTest}__;
        my $doc = $dtd-><AG::Node.ownerDocument>;
        my $em = $dtd-><AG::d|DocumentTypeDefinition.generalEntities>;
        
        $test->id ('no.item');
        $test->assert_null ($em-><M::NamedNodeMap.item> (-1));
        $test->assert_null ($em-><M::NamedNodeMap.item> (0));
        $test->assert_null ($em-><M::NamedNodeMap.item> (1));
        $test->assert_null ($em-><M::NamedNodeMap.item> (2));

        $test->id ('two.items');
        my $et1 = $doc-><M::d|DocumentXDoctype.createGeneralEntity>
                          ('et1');
        $dtd-><M::d|DocumentTypeDefinition.setGeneralEntityNode> ($et1);
        my $et2 = $doc-><M::d|DocumentXDoctype.createGeneralEntity>
                          ('et2');
        $dtd-><M::d|DocumentTypeDefinition.setGeneralEntityNode> ($et2);

        $test->assert_null ($em-><M::NamedNodeMap.item> (-1));
        $test->assert_null ($em-><M::NamedNodeMap.item> (2));
        my $item0 = $em-><M::NamedNodeMap.item> (0);
        my $item1 = $em-><M::NamedNodeMap.item> (1);
        $test->assert_not_null ($item0);
        $test->assert_not_null ($item1);
        $test->assert_not_equals ($item0, $item1);
        $test->assert_true ($et1 eq $item0 or $et2 eq $item0);
        $test->assert_true ($et1 eq $item1 or $et2 eq $item1);
    
    @@XDTest:
      @@@QName: NotationMap.item.test
      @@@ForCheck: tc|ForNotationMap
      @@@PerlDef:
        my $dtd;
        __CODE{d|newDoctypeForTest}__;
        my $doc = $dtd-><AG::Node.ownerDocument>;
        my $em = $dtd-><AG::d|DocumentTypeDefinition.notations>;
        
        $test->id ('no.item');
        $test->assert_null ($em-><M::NamedNodeMap.item> (-1));
        $test->assert_null ($em-><M::NamedNodeMap.item> (0));
        $test->assert_null ($em-><M::NamedNodeMap.item> (1));
        $test->assert_null ($em-><M::NamedNodeMap.item> (2));

        $test->id ('two.items');
        my $et1 = $doc-><M::d|DocumentXDoctype.createNotation>
                          ('et1');
        $dtd-><M::d|DocumentTypeDefinition.setNotationNode> ($et1);
        my $et2 = $doc-><M::d|DocumentXDoctype.createNotation>
                          ('et2');
        $dtd-><M::d|DocumentTypeDefinition.setNotationNode> ($et2);

        $test->assert_null ($em-><M::NamedNodeMap.item> (-1));
        $test->assert_null ($em-><M::NamedNodeMap.item> (2));
        my $item0 = $em-><M::NamedNodeMap.item> (0);
        my $item1 = $em-><M::NamedNodeMap.item> (1);
        $test->assert_not_null ($item0);
        $test->assert_not_null ($item1);
        $test->assert_not_equals ($item0, $item1);
        $test->assert_true ($et1 eq $item0 or $et2 eq $item0);
        $test->assert_true ($et1 eq $item1 or $et2 eq $item1);

  @Attr:
    @@Name: length
    @@Perlop: FETCHSIZE
    @@enDesc:
      The number of nodes in the map.
    @@Type: idl|unsignedLong||ManakaiDOM|all
    @@Get:
      @@@PerlDef:
        @@@@ForCheck: tc|ForAttrMap
        @@@@@:
          my $list;
          __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
            $r => $list,
            $prop => {<H::infoset|attributes>},
            $ref => {$$$self},
          }__;
          for my $l (values %$list) {
            $r += grep {$l->{$_}} keys %$l;
          }
      @@@PerlDef:
        @@@@ForCheck: tc|ForETMap
        @@@@@:
          my $list;
          __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
            $r => $list,
            $prop => {<H::d|elementTypes>},
            $ref => {$$$self},
          }__;
          $r = @{[map {$_} values %$list]};
      @@@PerlDef:
        @@@@ForCheck: tc|ForATMap
        @@@@@:
          my $list;
          __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
            $r => $list,
            $prop => {<H::d|attributeDefinitions>},
            $ref => {$$$self},
          }__;
          $r = @{[map {$_} values %$list]};
      @@@PerlDef:
        @@@@ForCheck: tc|ForEntityMap
        @@@@@:
          my $list;
          __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
            $r => $list,
            $prop => {<H::d|generalEntities>},
            $ref => {$$$self},
          }__;
          $r = @{[map {$_} values %$list]};
      @@@PerlDef:
        @@@@ForCheck: tc|ForNotationMap
        @@@@@:
          my $list;
          __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
            $r => $list,
            $prop => {<H::d|notations>},
            $ref => {$$$self},
          }__;
          $r = @{[map {$_} values %$list]};

    @@Test:
      @@@QName: AttrMap.length.test
      @@@ForCheck: tc|ForAttrMap
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;
        my $doc = $el-><AG::Node.ownerDocument>;
        my $et = $el-><AG::Node.attributes>;

        $test->id ('length.0');
        $test->assert_num_equals
                 (actual_value => $et-><AG::NamedNodeMap.length>,
                  expected_value => 0);

        $test->id ('length.1');
        my $et1 = $doc-><M::Document.createAttribute>
                          ('et1');
        $el-><M::Element.setAttributeNode> ($et1);
        $test->assert_num_equals
                 (actual_value => $et-><AG::NamedNodeMap.length>,
                  expected_value => 1);

        $test->id ('length.1');
        my $et2 = $doc-><M::Document.createAttribute>
                          ('et2');
        $el-><M::Element.setAttributeNode> ($et2);
        $test->assert_num_equals
                 (actual_value => $et-><AG::NamedNodeMap.length>,
                  expected_value => 2);
    @@XDTest:
      @@@QName: ETMap.length.test
      @@@ForCheck: tc|ForETMap
      @@@PerlDef:
        my $dtd;
        __CODE{d|newDoctypeForTest}__;
        my $doc = $dtd-><AG::Node.ownerDocument>;
        my $et = $dtd-><AG::d|DocumentTypeDefinition.elementTypes>;

        $test->id ('length.0');
        $test->assert_num_equals
                 (actual_value => $et-><AG::NamedNodeMap.length>,
                  expected_value => 0);

        $test->id ('length.1');
        my $et1 = $doc-><M::d|DocumentXDoctype.createElementTypeDefinition>
                          ('et1');
        $dtd-><M::d|DocumentTypeDefinition.setElementTypeDefinitionNode> ($et1);
        $test->assert_num_equals
                 (actual_value => $et-><AG::NamedNodeMap.length>,
                  expected_value => 1);

        $test->id ('length.1');
        my $et2 = $doc-><M::d|DocumentXDoctype.createElementTypeDefinition>
                          ('et2');
        $dtd-><M::d|DocumentTypeDefinition.setElementTypeDefinitionNode> ($et2);
        $test->assert_num_equals
                 (actual_value => $et-><AG::NamedNodeMap.length>,
                  expected_value => 2);
    @@XDTest:
      @@@QName: ATMap.length.test
      @@@ForCheck: tc|ForATMap
      @@@PerlDef:
        my $dtd;
        __CODE{d|newDoctypeForTest}__;
        my $doc = $dtd-><AG::Node.ownerDocument>;
        my $etd = $doc-><M::d|DocumentXDoctype.createElementTypeDefinition>
                          ('et1');
        my $at = $etd-><AG::d|ElementTypeDefinition.attributeDefinitions>;

        $test->id ('length.0');
        $test->assert_num_equals
                 (actual_value => $at-><AG::NamedNodeMap.length>,
                  expected_value => 0);

        $test->id ('length.1');
        my $at1 = $doc-><M::d|DocumentXDoctype.createAttributeDefinition>
                          ('at1');
        $etd-><M::d|ElementTypeDefinition.setAttributeDefinitionNode> ($at1);
        $test->assert_num_equals
                 (actual_value => $at-><AG::NamedNodeMap.length>,
                  expected_value => 1);

        $test->id ('length.2');
        my $at2 = $doc-><M::d|DocumentXDoctype.createAttributeDefinition>
                          ('at2');
        $etd-><M::d|ElementTypeDefinition.setAttributeDefinitionNode> ($at2);
        $test->assert_num_equals
                 (actual_value => $at-><AG::NamedNodeMap.length>,
                  expected_value => 2);
    @@XDTest:
      @@@QName: EntityMap.length.test
      @@@ForCheck: tc|ForEntityMap
      @@@PerlDef:
        my $dtd;
        __CODE{d|newDoctypeForTest}__;
        my $doc = $dtd-><AG::Node.ownerDocument>;
        my $et = $dtd-><AG::d|DocumentTypeDefinition.generalEntities>;

        $test->id ('length.0');
        $test->assert_num_equals
                 (actual_value => $et-><AG::NamedNodeMap.length>,
                  expected_value => 0);

        $test->id ('length.1');
        my $et1 = $doc-><M::d|DocumentXDoctype.createGeneralEntity>
                          ('et1');
        $dtd-><M::d|DocumentTypeDefinition.setGeneralEntityNode> ($et1);
        $test->assert_num_equals
                 (actual_value => $et-><AG::NamedNodeMap.length>,
                  expected_value => 1);

        $test->id ('length.1');
        my $et2 = $doc-><M::d|DocumentXDoctype.createGeneralEntity>
                          ('et2');
        $dtd-><M::d|DocumentTypeDefinition.setGeneralEntityNode> ($et2);
        $test->assert_num_equals
                 (actual_value => $et-><AG::NamedNodeMap.length>,
                  expected_value => 2);
    @@XDTest:
      @@@QName: NotationMap.length.test
      @@@ForCheck: tc|ForNotationMap
      @@@PerlDef:
        my $dtd;
        __CODE{d|newDoctypeForTest}__;
        my $doc = $dtd-><AG::Node.ownerDocument>;
        my $et = $dtd-><AG::d|DocumentTypeDefinition.notations>;

        $test->id ('length.0');
        $test->assert_num_equals
                 (actual_value => $et-><AG::NamedNodeMap.length>,
                  expected_value => 0);

        $test->id ('length.1');
        my $et1 = $doc-><M::d|DocumentXDoctype.createNotation>
                          ('et1');
        $dtd-><M::d|DocumentTypeDefinition.setNotationNode> ($et1);
        $test->assert_num_equals
                 (actual_value => $et-><AG::NamedNodeMap.length>,
                  expected_value => 1);

        $test->id ('length.1');
        my $et2 = $doc-><M::d|DocumentXDoctype.createNotation>
                          ('et2');
        $dtd-><M::d|DocumentTypeDefinition.setNotationNode> ($et2);
        $test->assert_num_equals
                 (actual_value => $et-><AG::NamedNodeMap.length>,
                  expected_value => 2);

  @IntMethod:
    @@Perlop: STORESIZE
    @@Param:
      @@@Name: count
      @@@Type: idl|unsignedLong||ManakaiDOM|all
    @@Return:
      @@@dx:raises:
        @@@@@: c|NOMOD_NAMEDNODEMAP_ERR
        @@@@enDesc:
          If the map is read-only.
      @@@PerlDef:
        __DEEP{
          my $length = $self-><AG::NamedNodeMap.length>;
          if ($length > $count) {
            for (my $i = $length - 1; $i >= $count; $i--) {
              my $item = $self-><M::NamedNodeMap.item> ($i);
              $self-><M::NamedNodeMap.removeNamedItem>
                       ($item-><AG::Node.nodeName>);
            }
          }
        }__;

  @IntMethod:
    @@Perlop: EXISTS
    @@enDesc:
      <Perl::EXISTS> for tied hash.
    @@Param:
      @@@Name: key
      @@@Type: DOMString
    @@Return:
      @@@Type: idl|boolean||ManakaiDOM|all
      @@@PerlDef:
        @@@@ForCheck: !tc|ForETMap !tc|ForATMap !tc|ForEntityMap !tc|ForNotationMap
        @@@@@:
          __DEEP{
            $r = defined ($self-><M::NamedNodeMap.getNamedItem> ($key));
          }__;
      @@@PerlDef:
        @@@@ForCheck: tc|ForETMap
        @@@@@:
          my $list;
          __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
            $r => $list,
            $prop => {<H::d|elementTypes>},
            $ref => {$$$self},
          }__;
          $r = exists $list->{$key};
      @@@PerlDef:
        @@@@ForCheck: tc|ForATMap
        @@@@@:
          my $list;
          __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
            $r => $list,
            $prop => {<H::d|attributeDefinitions>},
            $ref => {$$$self},
          }__;
          $r = exists $list->{$key};
      @@@PerlDef:
        @@@@ForCheck: tc|ForEntityMap
        @@@@@:
          my $list;
          __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
            $r => $list,
            $prop => {<H::d|generalEntities>},
            $ref => {$$$self},
          }__;
          $r = exists $list->{$key};
      @@@PerlDef:
        @@@@ForCheck: tc|ForNotationMap
        @@@@@:
          my $list;
          __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
            $r => $list,
            $prop => {<H::d|notations>},
            $ref => {$$$self},
          }__;
          $r = exists $list->{$key};

  @IntMethod:
    @@Perlop: FIRSTKEY
    @@enDesc:
      <Perl::FIRSTKEY> for tied hash.
    @@Return:
      @@@Type: DOMString
      @@@PerlDef:
        @@@@ForCheck: tc|ForAttrMap
        @@@@@:
          __DEEP{
            my $node = $self-><M::NamedNodeMap.item> (0);
            $r = $node ? $node-><AG::Node.nodeName> : null;
            __CODE{mg|setNodeStemPropValue||ManakaiDOM|all::
              $given => {1},
              $prop => {<H::tc|hashPosition>},
              $ref => {$$$self},
            }__;
          }__;
      @@@PerlDef:
        @@@@ForCheck: tc|ForETMap
        @@@@@:
          my $list;
          __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
            $r => $list,
            $prop => {<H::d|elementTypes>},
            $ref => {$$$self},
          }__;
          my $a = keys %$list; # reset
          $r = each %$list;
      @@@PerlDef:
        @@@@ForCheck: tc|ForATMap
        @@@@@:
          my $list;
          __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
            $r => $list,
            $prop => {<H::d|attributeDefinitions>},
            $ref => {$$$self},
          }__;
          my $a = keys %$list; # reset
          $r = each %$list;
      @@@PerlDef:
        @@@@ForCheck: tc|ForEntityMap
        @@@@@:
          my $list;
          __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
            $r => $list,
            $prop => {<H::d|generalEntities>},
            $ref => {$$$self},
          }__;
          my $a = keys %$list; # reset
          $r = each %$list;
      @@@PerlDef:
        @@@@ForCheck: tc|ForNotationMap
        @@@@@:
          my $list;
          __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
            $r => $list,
            $prop => {<H::d|notations>},
            $ref => {$$$self},
          }__;
          my $a = keys %$list; # reset
          $r = each %$list;

  @IntMethod:
    @@Perlop: NEXTKEY
    @@enDesc:
      <Perl::NEXTKEY> for tied hash.
    @@Param:
      @@@Name: lastkey
      @@@Type: DOMString
    @@Return:
      @@@Type: DOMString
      @@@PerlDef:
        @@@@ForCheck: tc|ForAttrMap
        @@@@@:
          __DEEP{
            my $i;
            __CODE{mg|get++NodeStemPropValue||ManakaiDOM|all::
              $r => $i,
              $prop => {<H::tc|hashPosition>},
              $ref => {$$$self},
            }__;
            my $node = $self-><M::NamedNodeMap.item> ($i);
            $r = $node ? $node-><AG::Node.nodeName> : null;
          }__;
      @@@PerlDef:
        @@@@ForCheck: tc|ForETMap
        @@@@@:
          my $list;
          __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
            $r => $list,
            $prop => {<H::d|elementTypes>},
            $ref => {$$$self},
          }__;
          $r = each %$list;
      @@@PerlDef:
        @@@@ForCheck: tc|ForATMap
        @@@@@:
          my $list;
          __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
            $r => $list,
            $prop => {<H::d|attributeDefinitions>},
            $ref => {$$$self},
          }__;
          $r = each %$list;
      @@@PerlDef:
        @@@@ForCheck: tc|ForEntityMap
        @@@@@:
          my $list;
          __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
            $r => $list,
            $prop => {<H::d|generalEntities>},
            $ref => {$$$self},
          }__;
          $r = each %$list;
      @@@PerlDef:
        @@@@ForCheck: tc|ForNotationMap
        @@@@@:
          my $list;
          __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
            $r => $list,
            $prop => {<H::d|notations>},
            $ref => {$$$self},
          }__;
          $r = each %$list;

  @IntMethod:
    @@ForCheck: !tc|ForAttrMap
    @@Perlop: SCALAR
    @@enDesc:
      <Perl::SCALAR> for tied hash.
    @@Return:
      @@@Type: DOMString
      @@@PerlDef:
        @@@@ForCheck: tc|ForETMap
        @@@@@:
          my $list;
          __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
            $r => $list,
            $prop => {<H::d|elementTypes>},
            $ref => {$$$self},
          }__;
          $r = scalar %$list;
      @@@PerlDef:
        @@@@ForCheck: tc|ForATMap
        @@@@@:
          my $list;
          __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
            $r => $list,
            $prop => {<H::d|attributeDefinitions>},
            $ref => {$$$self},
          }__;
          $r = scalar %$list;
      @@@PerlDef:
        @@@@ForCheck: tc|ForEntityMap
        @@@@@:
          my $list;
          __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
            $r => $list,
            $prop => {<H::d|generalEntities>},
            $ref => {$$$self},
          }__;
          $r = scalar %$list;
      @@@PerlDef:
        @@@@ForCheck: tc|ForNotationMap
        @@@@@:
          my $list;
          __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
            $r => $list,
            $prop => {<H::d|notations>},
            $ref => {$$$self},
          }__;
          $r = scalar %$list;

  @L2Method:
    @@Name: getNamedItemNS
    @@enDesc:
      Retrieves a node specified by local name and namespace URI.
    @@NoNSVersion: .getNamedItem
    @@XML2Feature:
    @@Param:
      @@@Name: namespaceURI
      @@@Type: DOMString
      @@@dis:actualType: ManakaiDOM|ManakaiDOMNamespaceURI
      @@@enDesc:
        The namespace URI of the node to retrieve.
    @@Param:
      @@@Name: localName
      @@@Type: DOMString
      @@@enDesc:
        The local name of the node to retrieve.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The <IF::Node> with the specified <P::localName> and
        <P::namespaceURI>.
      @@@nullCase:
        @@@@enDesc:
          If the pair of <P::localName> and <P::namespaceURI>
          does not identify any node in the map.
        @@@@enDesc:
          @@@@@ddid:nons
          @@@@@ForCheck: !tc|ForAttrMap ManakaiDOM|ManakaiDOM
          @@@@@@:
            If it is a <IF::NamedNodeMap> containing element type definitions,
            attribute definitions, entities, or notations attached to
            <IF::d|DocumentTypeDefinition> or <IF::d|ElementTypeDefinition>
            nodes.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_IMPL_NOSUPPORT_XMLNS
        @@@@enDesc:
          If the implementation does not support the <Feature::XML> feature
          and the language exposed through the <IF::Document> does
          not support XML namespaces.
      @@@PerlDef:
        @@@@ForCheck: tc|ForAttrMap
        @@@@@:
          __DEEP{
            $r = ($$$self)-><M::Element.getAttributeNodeNS>
                              ($namespaceURI, $localName);
          }__;
      @@@PerlDef:
        @@@@ForCheck: !tc|ForAttrMap
        @@@@@: \

    @@L2Test:
      @@@QName: AttrMap.getNamedItemNS.test
      @@@ForCheck: tc|ForAttrMap
      @@@PerlDef:
        my $el;
        __CODE{createElementForTest:: $el => $el}__;
        my $as = $el-><AG::Node.attributes>;

        my $uri = 'http://www.example/';
        my $ln = 'el1';
        my $qn = 'p:el1';
        my $value = 'value1';

        $test->id ('get.no');
        $test->assert_null ($as-><M::NamedNodeMap.getNamedItemNS> ($uri, $ln));
   
        $test->id ('set.text');
        $el-><M::Element.setAttributeNS> ($uri, $qn => $value);

        $test->id ('get.item');
        my $item0 = $as-><M::NamedNodeMap.getNamedItemNS> ($uri, $ln);
        $test->assert_isa ($item0, <IFName::Attr>);
        $test->assert_equals ($item0-><AG::Attr.ownerElement>, $el);
        $test->assert_equals ($item0-><AG::Attr.value>, $value);

  @L2Method:
    @@Name: setNamedItemNS
    @@enDesc:
      Adds a node using its <A::Node.namespaceURI> and <A::Node.localName>.
      If a node with that namespace URI and that local name is already
      present in the map, it is replaced by the new one.  Replacing a
      node by itself has no effect.
    @@enImplNote:
      @@@ddid: repbyitself
      @@@@:
        <QUOTE::Replacing a node by itself has no effect> clause
        is clarified by DOM Level 2 errata.
    @@NoNSVersion: .setNamedItem
    @@XML2Feature:
    @@Param:
      @@@Name: arg
      @@@Type: Node
      @@@enDesc:
        A node to store to the map.
      @@@enImplNote:
        The node will later be accessible using the value of 
        its <A::Node.namespaceURI> and <A::Node.localName> attributes.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        If the new <IF::Node> replaces an existing node, the replaced
        <IF::Node>.
      @@@nullCase:
        @@@@enDesc:
          If no replacement is occurred.
      @@@dx:raises:
        @@@@@: c|DIFFERENT_DOCUMENT_ERR
        @@@@enDesc:
          If <P::arg> was created from a different document than
          the one that created the map.
      @@@dx:raises:
        @@@@@: c|NOMOD_NAMEDNODEMAP_ERR
        @@@@enDesc:
          If the map is read-only.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the node to which the map is attached is read-only.
        @@@@For: ManakaiDOM|ManakaiDOM
      @@@dx:raises:
        @@@@@: c|INUSE_ATTRIBUTE_ERR
        @@@@enDesc:
          If <P::arg> is an <IF::Attr> that is already an attribute
          of another <IF::Element>.
        @@@@ForCheck: !tc|ForETMap !tc|ForATMap
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_BAD_TYPE
        @@@@enDesc:
          If an attempt is made to add a node that is unable to
          belong to the map.
        @@@@enImplNote:
          Added by DOM Level 2 errata.
        @@@@For: ManakaiDOM|DOM2
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_IMPL_NOSUPPORT_XMLNS
        @@@@enDesc:
          If the implementation does not support the <Feature::XML> feature
          and the language exposed through the <IF::Document> does
          not support XML namespaces.
      @@@dx:raises:
        @@@@ForCheck: !tc|ForAttrMap ManakaiDOM|ManakaiDOM
        @@@@@: c|NO_NS_NAMEDNODEMAP_ERR
        @@@@enDesc:
          If it is a <IF::NamedNodeMap> containing element type definitions,
          attribute definitions, entities, or notations attached to
          <IF::d|DocumentTypeDefinition> or <IF::d|ElementTypeDefinition>
          nodes.  They does not support XML namespaces.
      @@@c:reports:
        @@@@@: t|replace-by-itself
        @@@@enDesc:
          If the <P::arg> node is same as the current node in the map.
          The method has no effect in this case.
        @@@@enImplNote:
          This case is clarified by DOM Level 2 errata.
        @@@@For: ManakaiDOM|ManakaiDOM
      @@@PerlDef:
        @@@@ForCheck: tc|ForAttrMap
        @@@@@:
          __DEEP{
            $r = ($$$self)-><M::Element.setAttributeNodeNS> ($arg);
          }__;
      @@@disDef:
        @@@@ForCheck: !tc|ForAttrMap ManakaiDOM|DOMXMLFeature
        @@@@DOMMain:raiseException: c|NO_NS_NAMEDNODEMAP_ERR
      @@@disDef:
        @@@@ForCheck: !tc|ForAttrMap !ManakaiDOM|DOMXMLFeature
        @@@@DOMMain:raiseException: MDOMX|MDOM_IMPL_NOSUPPORT_XMLNS

    @@L2Test:
      @@@QName: AttrMap.setNamedItemNS.test
      @@@ForCheck: tc|ForAttrMap
      @@@PerlDef:
        my $el;
        __CODE{createElementForTest:: $el => $el}__;
        my $as = $el-><AG::Node.attributes>;
        my $doc = $el-><AG::Node.ownerDocument>;

        my $uri = 'http://www.example/';
        my $ln = 'el1';
        my $qn = 'p:el1';
        my $value = 'value1';

        $test->id ('get.no');
        $test->assert_null ($as-><M::NamedNodeMap.getNamedItemNS> ($uri, $ln));

        $test->id ('set.item');
        my $item0 = $doc-><M::Document.createAttributeNS> ($uri, $qn);
        $item0-><AS::Attr.value> ($value);
        my $item2 = $as-><M::NamedNodeMap.setNamedItemNS> ($item0);
        $test->assert_null ($item2);
 
        my $item3 = $as-><M::NamedNodeMap.getNamedItemNS> ($uri, $ln);
        $test->assert_equals ($item3, $item0);

        $test->id ('set.item.4');
        my $item4 = $doc-><M::Document.createAttributeNS> ($uri, $qn);
        my $item5 = $as-><M::NamedNodeMap.setNamedItemNS> ($item4);
        $test->assert_equals ($item5, $item0);
        
        my $item6 = $as-><M::NamedNodeMap.getNamedItemNS> ($uri, $ln);
        $test->assert_equals ($item6, $item4);

     @@L3Test:
       @@@QName: NamedNodeMap.Attr.setNamedItemNS.replace-by-itself.Test
       @@@ForCheck: tc|ForAttrMap
       @@@PerlDef:
         my $doc;
         __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

         my $eh_called = false;

         my $del = $doc-><M::Document.createElementNS> (null, 'e');
         $del-><M::Element.setAttributeNS> (null, 'attr' => 'value');

           my $attr = $del-><M::Element.getAttributeNodeNS> (null, 'attr');

           my $cfg = $doc-><AG::Document.domConfig>;
           $cfg-><M::c|DOMConfiguration.setParameter> ('error-handler' => sub {
             my (undef, $err) = @_;
             $eh_called = true;
             $test->assert_equals ($err-><AG::c|DOMError.severity>,
                                   <C::c|DOMError.SEVERITY_WARNING>);
             $test->assert_equals ($err-><AG::c|DOMError.type>,
                                   <Q::t|replace-by-itself>);
             $test->assert_equals ($err-><AG::c|DOMError.relatedData>, $attr);
             $test->assert_null ($err-><AG::c|DOMError.relatedException>);
             $test->assert_isa ($err-><AG::c|DOMError.location>,
                                <IFName::c|DOMLocator>);
             $test->assert_not_null ($err-><AG::c|DOMError.message>);
           });

           $test->assert_false ($eh_called);
           $del-><AG::Node.attributes>
               -><M::NamedNodeMap.setNamedItemNS> ($attr);
           $test->assert_true ($eh_called);

           $test->assert_equals ($del-><M::Element.getAttributeNodeNS>
                                   (null, 'attr'), $attr);

           $attr = null;

  @L2Method:
    @@Name: removeNamedItemNS
    @@enDesc:
      Removes a node specified by local name and namespace URI.
    @@NoNSVersion: .removeNamedItem
    @@enDesc:
      @@@ddid: attr
      @@@ForCheck: !tc|ForETMap !tc|ForATMap !tc|ForEntityMap !tc|ForNotationMap
      @@@@:
        If the removed attribute is known to have a default value,
        an attribute immediately appears containing the default value
        as well as the corresponding namespace URI, local name, 
        and prefix when applicable.
    @@XML2Feature:
    @@Param:
      @@@Name: namespaceURI
      @@@Type: DOMString
      @@@dis:actualType: ManakaiDOM|ManakaiDOMNamespaceURI
      @@@enDesc:
        The namespace URI of the node to remove.
    @@Param:
      @@@Name: localName
      @@@Type: DOMString
      @@@enDesc:
        The local name of the node to remove.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node removed from the map.
      @@@dx:raises:
        @@@@@: c|NO_NAMED_NODE_NS_ERR
        @@@@enDesc:
          If there is no node with the specified <P::namespaceURI>
          and <P::localName> in the map.

          If it is a <IF::NamedNodeMap> containing element type definitions,
          attribute definitions, entities, or notations attached to
          <IF::d|DocumentTypeDefinition> or <IF::d|ElementTypeDefinition>
          nodes.  They does not support XML namespaces.
      @@@dx:raises:
        @@@@@: c|NOMOD_NAMEDNODEMAP_ERR
        @@@@enDesc:
          If the map is read-only.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_IMPL_NOSUPPORT_XMLNS
        @@@@enDesc:
          If the implementation does not support the <Feature::XML> feature
          and the language exposed through the <IF::Document> does
          not support XML namespaces.
      @@@PerlDef:
        @@@@ForCheck: tc|ForAttrMap
        @@@@@:
          my $el = $$$self;
          __DEEP{ 
            $r = $el-><M::Element.getAttributeNodeNS>
                        ($namespaceURI, $localName);
          }__;
          unless ($r) {
            __EXCEPTION{c|NO_NAMED_NODE_NS_ERR::
              infoset|namespaceName => {$namespaceURI},
              c|name => {$localName},
              infoset|localName => {$localName},
              MDOMX|param-name => 'name',
            }__;
          }
          __DEEP{
            $r = $el-><M::Element.removeAttributeNode> ($r);
          }__;
      @@@disDef:
        @@@@ForCheck: !tc|ForAttrMap ManakaiDOM|DOMXMLFeature
        @@@@DOMMain:raiseException: c|NO_NAMED_NODE_NS_ERR
      @@@disDef:
        @@@@ForCheck: !tc|ForAttrMap !ManakaiDOM|DOMXMLFeature
        @@@@DOMMain:raiseException: MDOMX|MDOM_IMPL_NOSUPPORT_XMLNS

  @IntMethod:
    @@Perlop: ==
    @@enDesc:
      Returns whether two <IF::NamedNodeMap>s are equals.
   
      Two <IF::NamedNodeMap>s are equal if they have the same
      <A::NamedNodeMap.length> and for each node that exists in
      one map there is a node that exists in the other map 
      and is equal, although not necessarily at the same index.
    @@enImplNote:
      See also <M::Node.isEqualNode>.
    @@Param:
      @@@Name:arg
      @@@Type:NamedNodeMap
      @@@Description:
        @@@@lang:en
        @@@@@:
          The node list to compare equality with.
    @@Return:
      @@@Type:DOMMain|boolean||ManakaiDOM|all
      @@@PerlDef:
        @@@@@:
          __DEEP{
            my $length1 = $self-><AG::NamedNodeMap.length>;
            my $length2 = $arg-><AG::NamedNodeMap.length>;
            if ($length1 == $length2) {
              CHK: {
                for my $i (0..$length1-1) {
                  my $node1 = $self-><M::NamedNodeMap.item> ($i);
                  my $node2 = $arg-><M::NamedNodeMap.item> ($i);
                  unless ($node1 == $node2) {
                    last CHK;
                  }
                }
                $r = true;
              } # CHK
            }
          }__;
        @@@@enImplNote:
          In manakai, nodes in namespace unaware <IF::NamedNodeMap> are
          ordered by their <A::Node.nodeName>.
 
        @@@@enImplNote:
          {TODO::
            Add test for elementTypes and attributeDefinitions
            (they requires == equality for element type definition
             and attribute definition nodes being defined)
          }

  @IntMethod:
    @@ForCheck: ManakaiDOM|ManakaiDOM3
    @@Operator: ManakaiDOM|MUErrorHandler
    @@enDesc:
      When a <IF::ecore|ErrorInterface||ManakaiDOM|Perl> is <Perl::report>ed
      with an <Perl::-object> of <IF::NamedNodeMap> that represents
      a set of attributes, then this method is invoked.
      
      The method calls the <cfg::error-handler> if the error is of 
      <IF::c|DOMError>.  Otherwise, including the cases of <IF::c|DOMException>s,
      the error is rethrown so that appropriate <Perl::catch> clause
      can catch the error.
    @@enImplNote:
      For implementations which does not have the
      <IF::c|DOMError||ManakaiDOM|ManakaiDOM3> interface, the method
      is defined in the <Class::ManakaiDOM|ManakaiDOMObject> class
      and it is not overridden here.
    @@Param:
      @@@Name: err
      @@@Type: ecore|ErrorInterface||ManakaiDOM|Perl
      @@@enDesc:
        The reported error object.
    @@Return:
      @@@Type: DISPerl|Any
      @@@enDesc:
        If the <P::err> is a <IF::c|DOMError>, then the return value
        of the error handler.

           {NOTE:: If the error is thrown, the method never returns.
           }
      @@@nullCase:
        @@@@enDesc:
          No error handler.
      @@@PerlDef:
          __DEEP{
            ($$$self)->___report_error ($err);
          }__;

  @IntMethod:
    @@Perlop: TIEARRAY
    @@ManakaiDOM:isStatic:1
    @@Param:
      @@@Name: map
      @@@Type: NamedNodeMap
    @@Return:
      @@@Type: NamedNodeMap
      @@@PerlDef:
        $r = bless \\($$$map), $self;

  @IntMethod:
    @@Perlop: TIEHASH
    @@ManakaiDOM:isStatic:1
    @@Param:
      @@@Name: map
      @@@Type: NamedNodeMap
    @@Return:
      @@@Type: NamedNodeMap
      @@@PerlDef: $r = $map;

  @CODE:
    @@ForCheck: tc|ForAttrMap ManakaiDOM|ManakaiDOMLatest
    @@QName: getAttrMap
    @@enDesc:
      Creates an attribute node map from an element node.
    @@PerlDef:
      $map = bless \\($node), <ClassName::t|ManakaiDOMAttrMap>;
      __CODE{mg|orSetNodeStemPropValue||ManakaiDOM|all::
        $given => {-1},
        $prop => {<H::tc|hashPosition>},
        $ref => $node,
      }__;

  @CODE:
    @@ForCheck: tc|ForETMap ManakaiDOM|ManakaiDOMLatest
    @@QName: getElementTypeDefNodeMap
    @@enDesc:
      Creates an element type definition node map from a document
      type definition node.
    @@PerlDef:
      $map = bless \\($node), <ClassName::t|ManakaiDOMElementTypeDefMap>;

  @CODE:
    @@ForCheck: tc|ForATMap ManakaiDOM|ManakaiDOMLatest
    @@QName: getAttrDefNodeMap
    @@enDesc:
      Creates an attribute definition node map from a document
      type definition node.
    @@PerlDef:
      $map = bless \\($node), <ClassName::t|ManakaiDOMAttrDefMap>;

  @CODE:
    @@ForCheck: tc|ForEntityMap ManakaiDOM|ManakaiDOMLatest
    @@QName: getEntityNodeMap
    @@enDesc:
      Creates an entity node map from a document
      type definition node.
    @@PerlDef:
      $map = bless \\($node), <ClassName::t|ManakaiDOMEntityMap>;

  @CODE:
    @@ForCheck: tc|ForNotationMap ManakaiDOM|ManakaiDOMLatest
    @@QName: getNotationNodeMap
    @@enDesc:
      Creates a notation node map from a document
      type definition node.
    @@PerlDef:
      $map = bless \\($node), <ClassName::t|ManakaiDOMNotationMap>;
##NamedNodeMap

IntPropDef:
  @QName: tc|hashPosition
  @mg:nodeStemKey: hpos
  @enDesc:
    Index for <Perl::each>.

ResourceDef:
  @rdf:type:
    @@@: dis|MultipleResource
    @@ForCheck: !ManakaiDOM|ForIF !ManakaiDOM|ForClass
  @ForCheck: ManakaiDOM|ManakaiDOM

  @enDesc:
    <IF::NamedNodeMap> implementation for tied array.

  @DISCore:resourceType:
    @@@: DISLang|Class
    @@ForCheck: ManakaiDOM|ForClass

  @resourceFor:
    @@@: tc|ForAttrMap
    @@For: ManakaiDOM|ManakaiDOMLatest
  @QName:
    @@@: ManakaiDOMAttrMapArray
    @@ForCheck: tc|ForAttrMap
  @ISA:
    @@@: ManakaiDOMAttrMap
    @@ForCheck: tc|ForAttrMap

  @resourceFor:
    @@@: tc|ForETMap
    @@For: ManakaiDOM|ManakaiDOMLatest
  @QName:
    @@@: ManakaiDOMElementTypeDefMapArray
    @@ForCheck: tc|ForETMap
  @ISA:
    @@@: ManakaiDOMElementTypeDefMap
    @@ForCheck: tc|ForETMap

  @resourceFor:
    @@@: tc|ForATMap
    @@For: ManakaiDOM|ManakaiDOMLatest
  @QName:
    @@@: ManakaiDOMAttrDefMapArray
    @@ForCheck: tc|ForATMap
  @ISA:
    @@@: ManakaiDOMAttrDefMap
    @@ForCheck: tc|ForATMap

  @resourceFor:
    @@@: tc|ForEntityMap
    @@For: ManakaiDOM|ManakaiDOMLatest
  @QName:
    @@@: ManakaiDOMEntityMapArray
    @@ForCheck: tc|ForEntityMap
  @ISA:
    @@@: ManakaiDOMEntityMap
    @@ForCheck: tc|ForEntityMap

  @resourceFor:
    @@@: tc|ForNotationMap
    @@For: ManakaiDOM|ManakaiDOMLatest
  @QName:
    @@@: ManakaiDOMNotationMapArray
    @@ForCheck: tc|ForNotationMap
  @ISA:
    @@@: ManakaiDOMNotationMap
    @@ForCheck: tc|ForNotationMap

  @AppISA:
    Tie::Array

  @IntMethod:
    @@Perlop: FETCH
    @@Param:
      @@@Name: index
      @@@Type: idl|unsignedLong||ManakaiDOM|all
    @@Return:
      @@@Type: Node
      @@@nullCase:
      @@@PerlDef:
        __DEEP{
          $r = $self-><M::NamedNodeMap.item> ($index);
        }__;

  @IntMethod:
    @@Perlop: EXISTS
    @@enDesc:
      <Perl::EXISTS> for tied array.
    @@Param:
      @@@Name: index
      @@@Type: idl|unsignedLong||ManakaiDOM|all
    @@Return:
      @@@Type: idl|boolean||ManakaiDOM|all
      @@@PerlDef:
        __DEEP{
          my $length = $self-><AG::NamedNodeMap.length>;
          $r = ($index < $length);
        }__;
  
  @enImplNote:
    @@@ddid: perl.store
    @@@@:
      <Perl::STORE> is not implemented.

  @IntMethod:
    @@Perlop: DELETE
    @@enDesc:
      Removes a node specified by index.
    @@enDesc:
      @@@ddid: attr
      @@@ForCheck: tc|ForAttrMap
      @@@enDesc:
        If the removed attribute is known to have a default value,
        an attribute immediately appears containing the default
        value as well as the corresponding namespace URI, local name,
        and prefix when applicable.
    @@Param:
      @@@Name: index
      @@@Type: idl|unsignedLong||ManakaiDOM|all
      @@@enDesc:
        The ordinal index of the node to remove.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node removed from the map.
      @@@enImplNote:
        Is this return value OK?
      @@@nullCase:
        @@@@enDesc:
          If there is no node named as <P::name> in the map.
      @@@dx:raises:
        @@@@@: c|NOMOD_NAMEDNODEMAP_ERR
        @@@@enDesc:
          If the map is read-only.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the node to which the map is attached is read-only.
      @@@PerlDef:
        __DEEP{
          my $item = $self-><M::NamedNodeMap.item> ($index);
          if ($item) {
            $r = $self-><M::NamedNodeMap.removeNamedItem>
                            ($item-><AG::Node.nodeName>);
          }
        }__;
##NamedNodeMapArray
