Module:
  @QName: MDOM|TreeCore
  @enFN:
    DOM Tree Core Module
  @enDesc:
    The manakai DOM Tree Core Module implements a part of the W3C DOM
    Core module related to tree structural model for HTML or XML documents.

  @Namespace:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/DOM/TreeCore/

  @DISCore:author: DISCore|Wakaba
  @License: license|Perl+MPL
  @Date:
    $Date: 2006/04/01 17:52:32 $

  @Require:
    @@Module:
      @@@QName: Util|Grove
      @@@WithFor: ManakaiDOM|all
    @@Module:
      @@@QName: MDOM|DOMCore
      @@@WithFor: ManakaiDOM|ManakaiDOMLatest
    @@Module:
      @@@QName: MDOM|Document
      @@@WithFor: ManakaiDOM|ManakaiDOMLatest
    @@Module:
      @@@QName: MDOM|Element
      @@@WithFor: ManakaiDOM|ManakaiDOMLatest
    @@Module:
      @@@QName: MDOM|XML
      @@@WithFor: ManakaiDOM|ManakaiDOMLatest
    @@Module:
      @@@QName: MDOM|XDoctype
      @@@WithFor: ManakaiDOM|ManakaiDOMLatest
    @@Module:
      @@@WithFor: ManakaiDOM|ManakaiDOM
    @@Module:
      @@@WithFor: ManakaiDOM|ManakaiDOM1
    @@Module:
      @@@WithFor: ManakaiDOM|ManakaiDOM2
    @@Module:
      @@@WithFor: ManakaiDOM|ManakaiDOM3
  @DefaultFor: ManakaiDOM|ManakaiDOMLatest

Namespace:
  @c:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#
  @cfg:
    http://suika.fam.cx/www/2006/dom-config/
  @dis:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#dis--
  @doc:
    http://suika.fam.cx/~wakaba/archive/2005/7/tutorial#
  @d:
    http://suika.fam.cx/~wakaba/archive/2004/dom/xdt#
  @DOMMain:
    http://suika.fam.cx/~wakaba/archive/2004/dom/main#
  @dx:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/DOMException#
  @dxm:
    http://suika.fam.cx/~wakaba/archive/2004/dis/XML#
  @ecore:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Error/Core/
  @ev:
    http://www.w3.org/2001/xml-events
  @f:
    http://suika.fam.cx/~wakaba/archive/2004/dom/feature#
  @fe:
    http://suika.fam.cx/www/2006/feature/
  @idl:
    http://suika.fam.cx/~wakaba/archive/2004/dis/IDL#
  @infoset:
    http://www.w3.org/2001/04/infoset#
  @kwd:
    http://suika.fam.cx/~wakaba/archive/2005/rfc2119/
  @lang:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#
  @license:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/license#
  @ManakaiDOM:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#
  @ManakaiDOMCore:
    http://suika.fam.cx/~wakaba/archive/2004/mdom-core#
  @MDOM:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#ManakaiDOM.
  @MDOMX:
    http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#
  @mg:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/Grove/
  @null:
    http://suika.fam.cx/~wakaba/-temp/2003/09/27/null
  @rdf:
    http://www.w3.org/1999/02/22-rdf-syntax-ns#
  @rdfs:
    http://www.w3.org/2000/01/rdf-schema#
  @sw010:
    urn:x-suika-fam-cx:markup:suikawiki:0:10:
  @t:
    http://suika.fam.cx/~wakaba/archive/2004/dom/tree#
  @tc:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/DOM/TreeCore/
  @td:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/DOM/Document/
  @te:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/DOM/Element/
  @test:
    http://suika.fam.cx/~wakaba/archive/2004/dis/Test#
  @tx:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/DOM/XML/
  @urigen:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/URI/Generic/
  @Util:
    http://suika.fam.cx/~wakaba/archive/2005/manakai/Util/
  @xml:
    http://www.w3.org/XML/1998/namespace
  @xml-dtd:
    http://www.w3.org/TR/REC-xml
  @xmlns:
    http://www.w3.org/2000/xmlns/

ElementTypeBinding:
  @Name: ClsDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType:
      @@@@: dis|MultipleResource
      @@@ForCheck: !ManakaiDOM|ForIF !ManakaiDOM|ForClass
    @@resourceFor:
      @@@@: ManakaiDOM|ForClass
    @@For: ManakaiDOM|ManakaiDOMLatest

    @@DISCore:resourceType:
      @@@@: DISLang|Class
      @@@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: CODE
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISPerl|BlockCode
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: Method
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Method
    @@ForCheck: !=ManakaiDOM|ManakaiDOM

ElementTypeBinding:
  @Name: L12Method
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Method
    @@ForCheck: !=ManakaiDOM|ManakaiDOM
  ## Modified in DOM Level 2

ElementTypeBinding:
  @Name: L13Method
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Method
    @@ForCheck: !=ManakaiDOM|ManakaiDOM
  ## Modified in DOM Level 3

ElementTypeBinding:
  @Name: CMethod
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Method
    @@ForCheck: !=ManakaiDOM|ManakaiDOM ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: IL1OnlyMethod
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|Method
    @@ForCheck:
      !=ManakaiDOM|ManakaiDOM ManakaiDOM|DOM1 !ManakaiDOM|DOM2
      ManakaiDOM|ForIF

ElementTypeBinding:
  @Name: L2Method
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|Method
    @@ForCheck: !=ManakaiDOM|ManakaiDOM ManakaiDOM|DOM2

ElementTypeBinding:
  @Name: CL2Method
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|Method
    @@ForCheck: !=ManakaiDOM|ManakaiDOM ManakaiDOM|DOM2 ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: L3Method
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Method
    @@ForCheck: !=ManakaiDOM|ManakaiDOM ManakaiDOM|DOM3

ElementTypeBinding:
  @Name: CL3Method
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Method
    @@ForCheck: !=ManakaiDOM|ManakaiDOM ManakaiDOM|DOM3 ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: LXMethod
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Method
    @@ForCheck: !=ManakaiDOM|ManakaiDOM ManakaiDOM|ManakaiDOMLatest

ElementTypeBinding:
  @Name: IntMethod
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Method
    @@ForCheck:
      ManakaiDOM:ManakaiDOM !=ManakaiDOM:ManakaiDOM ManakaiDOM|ForClass
    @@ManakaiDOM:isForInternal: 1

ElementTypeBinding:
  @Name: Param
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|MethodParameter

ElementTypeBinding:
  @Name: Return
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|MethodReturn

ElementTypeBinding:
  @Name: Attr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Attribute
    @@ForCheck: !=ManakaiDOM|ManakaiDOM

ElementTypeBinding:
  @Name: CAttr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|Attribute
    @@ForCheck: !=ManakaiDOM|ManakaiDOM ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: IntAttr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Attribute
    @@ForCheck: ManakaiDOM|ForClass
    @@ManakaiDOM:isForInternal: 1

ElementTypeBinding:
  @Name: L2Attr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Attribute
    @@ForCheck: !=ManakaiDOM|ManakaiDOM ManakaiDOM|DOM2

ElementTypeBinding:
  @Name: L12Attr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Attribute
    @@ForCheck: !=ManakaiDOM|ManakaiDOM ManakaiDOM|DOM1
  # Modified in DOM Level 2

ElementTypeBinding:
  @Name: L13Attr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Attribute
    @@ForCheck: !=ManakaiDOM|ManakaiDOM ManakaiDOM|DOM1
  # Modified in DOM Level 3

ElementTypeBinding:
  @Name: CL2Attr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Attribute
    @@ForCheck: !=ManakaiDOM|ManakaiDOM ManakaiDOM|DOM2 ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: L3Attr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Attribute
    @@ForCheck: !=ManakaiDOM|ManakaiDOM ManakaiDOM|DOM3
  ## Note that there are attributes introduced in DOM Level 3
  ## but also defined for lower levels as internal attributes
  ## for the purpose of internal use.

ElementTypeBinding:
  @Name: CL3Attr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Attribute
    @@ForCheck: !=ManakaiDOM|ManakaiDOM ManakaiDOM|DOM3 ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: LXAttr
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|Attribute
    @@ForCheck: !=ManakaiDOM|ManakaiDOM ManakaiDOM|ManakaiDOMLatest

ElementTypeBinding:
  @Name: Get
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|AttributeGet

ElementTypeBinding:
  @Name: Set
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|AttributeSet

ElementTypeBinding:
  @Name: LXSet
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type: DISLang|AttributeSet
    @@ForCheck: ManakaiDOM|ManakaiDOMLatest

ElementTypeBinding:
  @Name: InCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:InCase

ElementTypeBinding:
  @Name: nullCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      ManakaiDOM:InCase
    @@Value:
      @@@is-null:1

ElementTypeBinding:
  @Name: Constants
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|ConstGroup
    @@ForCheck: ManakaiDOM|ForIF !=ManakaiDOM|ManakaiDOM
    @@Type: unsignedShort
    @@subsetOf: unsignedShort

ElementTypeBinding:
  @Name: L3Bitmasks
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|ConstGroup
    @@ForCheck: ManakaiDOM|ForIF !=ManakaiDOM|ManakaiDOM
    @@Type: unsignedShort
    @@subsetOf: unsignedShort

ElementTypeBinding:
  @Name: Const
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|Const

ElementTypeBinding:
  @Name: LXConst
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|Const
    @@Description:
      @@@lang:en
      @@@ddid:manakai
      @@@@:
        {NOTE::
          This is a manakai extension.
        }

ElementTypeBinding:
  @Name: PerlDef
  @ElementType:
    dis:Def
  @ShadowContent:
    @@ContentType:
      lang:Perl
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: PerlDefC
  @ElementType:
    dis:Def
  @ShadowContent:
    @@ContentType:
      lang:Perl

ElementTypeBinding:
  @Name: XML2Feature
  @ElementType:
    dis:ImplNote
  @ShadowContent:
    @@ImplNote:
      @@@lang:en
      @@@@:
        The <CITE::DOM Level 2 Core> specification said that HTML-only 
        DOM Level 2 implementations does not need to implement this member. 
        The DOM Level 2 Errata withdraws it and it requires HTML-only 
        DOM implementations throw a <X::DOMException.NOT_SUPPORTED_ERR>. 

ElementTypeBinding:
  @Name: enImplNote
  @ElementType:
    dis:ImplNote
  @ShadowContent:
    @@lang:en

ElementTypeBinding:
  @Name: enFN
  @ElementType:
    dis:FullName
  @ShadowContent:
    @@lang:en

ElementTypeBinding:
  @Name: NodeTypeDef
  @ElementType: 
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      @@@@: dis|MultipleResource
      @@@ForCheck: !ManakaiDOM|ForIF !ManakaiDOM|ForClass
    @@resourceFor: ManakaiDOM|ForIF
    @@resourceFor:
      @@@@: ManakaiDOM|ForClass
      @@@ForCheck: ManakaiDOM|ManakaiDOMLatest
    @@For: ManakaiDOM|DOM1
    @@For: =ManakaiDOM|ManakaiDOM

    @@rdf:type:
      @@@@: DISLang|Interface
      @@@ForCheck: ManakaiDOM|ForIF

    @@rdf:type:
      @@@@: DISLang|Class
      @@@ForCheck: ManakaiDOM|ForClass

    @@ISA:
      @@@@: Node
      @@@ForCheck: ManakaiDOM|ForIF
    @@ISA:
      @@@@: ManakaiDOMNode
      @@@ForCheck: ManakaiDOM|ForClass

    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOM||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOM1||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM1
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOM2||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM2
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOM3||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM3
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOMLatest||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOMLatest

    @@f:implements:
      @@@@: DOMCore|CoreFeature10
      @@@For: ManakaiDOM|DOM1
    @@DOMMain:implementFeature:
      @@@@: DOMCore|CoreFeature20
      @@@For: ManakaiDOM|DOM2
    @@DOMMain:implementFeature:
      @@@@: DOMCore|CoreFeature30
      @@@For: ManakaiDOM|DOM3
    @@DOMMain:implementFeature:
      @@@@: tx|XMLFeature10
      @@@For: ManakaiDOM|DOM1 ManakaiDOM|DOMXMLFeature
    @@DOMMain:implementFeature:
      @@@@: tx|XMLFeature20
      @@@For: ManakaiDOM|DOM2 ManakaiDOM|DOMXMLFeature
    @@DOMMain:implementFeature:
      @@@@: tx|XMLFeature30
      @@@For: ManakaiDOM|DOM3 ManakaiDOM|DOMXMLFeature
    @@DOMMain:implementFeature:
      @@@@: tx|XMLVersionFeature10
      @@@For: ManakaiDOM|DOM3 ManakaiDOM|DOMXMLFeature
    @@DOMMain:implementFeature:
      @@@@: tx|XMLVersionFeature11
      @@@For: ManakaiDOM|DOM3 ManakaiDOM|DOMXMLFeatureXML11

ElementTypeBinding:
  @Name: IFCls1Def
  @ElementType: 
    dis:ResourceDef
  @ShadowContent:
    @@rdf:type:
      @@@@: dis|MultipleResource
      @@@ForCheck: !ManakaiDOM|ForIF !ManakaiDOM|ForClass
    @@resourceFor: ManakaiDOM|ForIF
    @@resourceFor:
      @@@@: ManakaiDOM|ForClass
      @@@ForCheck: ManakaiDOM|ManakaiDOMLatest
    @@For: ManakaiDOM|DOM1
    @@For: =ManakaiDOM|ManakaiDOM

    @@rdf:type:
      @@@@: DISLang|Interface
      @@@ForCheck: ManakaiDOM|ForIF

    @@rdf:type:
      @@@@: DISLang|Class
      @@@ForCheck: ManakaiDOM|ForClass
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOM||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOM1||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM1
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOM2||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM2
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOM3||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM3
    @@Implement:
      @@@@: ||ManakaiDOM|ManakaiDOMLatest||ManakaiDOM|ForIF
      @@@ContentType: DISCore|TFPQNames
      @@@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOMLatest

    @@f:implements:
      @@@@: c|CoreFeature10
      @@@For: ManakaiDOM|DOM1
    @@f:implements:
      @@@@: c|CoreFeature20
      @@@For: ManakaiDOM|DOM2
    @@f:implements:
      @@@@: c|CoreFeature30
      @@@For: ManakaiDOM|DOM3
    @@f:implements:
      @@@@: tx|XMLFeature10
      @@@For: ManakaiDOM|DOM1 ManakaiDOM|DOMXMLFeature
    @@f:implements:
      @@@@: tx|XMLFeature20
      @@@For: ManakaiDOM|DOM2 ManakaiDOM|DOMXMLFeature
    @@f:implements:
      @@@@: tx|XMLFeature30
      @@@For: ManakaiDOM|DOM3 ManakaiDOM|DOMXMLFeature
    @@f:implements:
      @@@@: tx|XMLVersionFeature10
      @@@For: ManakaiDOM|DOM3 ManakaiDOM|DOMXMLFeature
    @@f:implements:
      @@@@: tx|XMLVersionFeature11
      @@@For: ManakaiDOM|DOM3 ManakaiDOM|DOMXMLFeatureXML11

ElementTypeBinding:
  @Name: IFQName
  @ElementType:
    dis:QName
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForIF

ElementTypeBinding:
  @Name: ClsQName
  @ElementType:
    dis:QName
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: IFISA
  @ElementType:
    dis:ISA
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForIF

ElementTypeBinding:
  @Name: ClsISA
  @ElementType:
    dis:ISA
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: disDef
  @ElementType:
    dis:Def
  @ShadowContent:
    @@ContentType:
      lang:dis
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: Code
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISPerl|InlineCode
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: IntPropDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISCore|Property
    @@For: =ManakaiDOM|all

ElementTypeBinding:
  @Name: RPropDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISSource|ResourceProperty
    @@For: =ManakaiDOM|all

ElementTypeBinding:
  @Name: Test
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: test|StandaloneTest
    @@ForCheck: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: L2Test
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: test|StandaloneTest
    @@ForCheck: ManakaiDOM|ForClass ManakaiDOM|DOM2

ElementTypeBinding:
  @Name: L3Test
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: test|StandaloneTest
    @@ForCheck: ManakaiDOM|ForClass ManakaiDOM|DOM3

ElementTypeBinding:
  @Name: LXTest
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: test|StandaloneTest
    @@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOMLatest

ElementTypeBinding:
  @Name: XDTest
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: test|StandaloneTest
    @@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOMLatest

ClsDef:
  @ClsQName: ManakaiDOMImplementationTC

  @enDesc:
    The <Class::ManakaiDOMImplementationTC> class implements
    two factory methods to create DOM <IF::Document> or
    <IF::tx|DocumentType> defined in DOM Level 2 or higher.

  @Test:
    @@QName: Impl.new.mg.test
    @@PerlDef:
      local $Message::Util::Grove::GCLatency = 0;

      my $impl;
      __CODE{tc|createImplForTest:: $impl => $impl}__;

      my $bag = $impl->{<H::mg|nodeBag>};
      my $id = $impl->{<H::mg|nodeIDReference>};
        
      $test->id ('interface');
      $test->assert_isa ($impl, <IFName::f|MinimumImplementation>);
        
      $test->id ('interface');
      $test->assert_isa ($impl, <IFName::c|DOMImplementation>);
        
      $test->id ('class');
      $test->assert_isa ($impl, <ClassName::ManakaiDOMImplementationTC>);

      undef $impl;

      $test->id ('gc');
      $test->assert_null ($bag->{$$id});

  @CODE:
    @@QName: tc|createImplForTest
    @@PerlDef:
      $impl = <ClassName::c|ManakaiDOMImplementation>->_new;

  @CL2Method:
    @@Name: createDocument
    @@enDesc:
      Creates a DOM <IF::Document> object of the specified type
      with its document type.
    @@DOMMain:isNamespaceAware: 1
    @@XML2Feature:
    @@Param:
      @@@Name: namespaceURI
      @@@Type: DOMString
      @@@dis:actualType: ManakaiDOM|ManakaiDOMNamespaceURI
      @@@enDesc:
        The namespace URI of the document element.
      @@@nullCase:
    @@Param:
      @@@Name: qualifiedName
      @@@Type: DOMString
      @@@enDesc:
        The XML Namespaces 1.0 <SRC::DOM2, DOM3> qualified
        name of the document element.
      @@@InCase:
        @@@@Type: ARRAY
        @@@@enDesc:
          A reference to the array that contains the namespace
          prefix (zeroth item) and the local name (first item)
          of the attribute.  The namespace prefix <kwd:MAY>
          be <DOM::null> to indicate that the qualified name
          contains no <CHAR::COLON> character.
      @@@nullCase:
        <SRC::DOM3>
    @@Param:
      @@@Name: doctype
      @@@Type: tx|DocumentType
      @@@enDesc:
        The type of the document to create.

        The <IF::Node.ownerDocument> attribute of the <P::doctype>
        node is set to the document being created.
      @@@nullCase:
    @@Return:
      @@@Type: Document
      @@@enDesc:
        The newly created <IF::Document> object with its
        document element.

        If the <P::namespaceURI>, <P::qualifiedName>, and
        <P::doctype> are <DOM::null>, the returned <IF::Document>
        is empty with no document element.  <SRC::DOM3>

        Based on the <IF::tx|DocumentType> given to create the document, 
        the implementation may instantiate specialized <IF::Document>
        object that support additional features than
        the <Feature::Core>.  On the other hand, setting the
        <IF::tx|DocumentType> after the document was created
        makes this very unlikely to happen.  <SRC::DOM3>
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_BAD_NAME
        @@@@enDesc:
          If the specified qualified name is not an XML 1.0 <SRC::DOM3>
          <CODE::Name>.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_NS_MALFORMED_QNAME
        @@@@enDesc:
          If the <P::qualifiedName> is malformed.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_NS_PREFIX_WITH_NULL_URI
        @@@@enDesc:
          If the <P::qualifiedName> has a prefix and the
          <P::namespaceURI> is <DOM::null>.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_NS_NULL_QNAME_WITH_NON_NULL_URI
        @@@@enDesc:
          If the <P::qualifiedName> is <DOM::null> and
          the <P::namespaceURI> is different from <DOM::null>.  <SRC::DOM3>
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_NS_XML_WITH_OTHER_URI
        @@@@enDesc:
          If the <P::qualifiedName> has a prefix that is <XML::xml> and
          the <P::namespaceURI> is different
          from <URI::http://www.w3.org/XML/1998/namespace>.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_NS_XMLNS_WITH_OTHER_URI
        @@@@enDesc:
          If the <P::qualifiedName> has a prefix that is <XML::xmlns>
          and the <P::namespaceURI> is different from
          <URI::http://www.w3.org/2000/xmlns/>.  <SRC::manakai>
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_NS_XMLNSQ_WITH_OTHER_URI
        @@@@enDesc:
          If the <P::qualifiedName> is <XE::xmlns> and
          the <P::namespaceURI> is different from 
          <URI::http://www.w3.org/2000/xmlns/>.  <SRC::manakai>
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_NS_OTHER_WITH_XMLNS_URI
        @@@@enDesc:
          If the <P::namespaceURI> is <URI::http://www.w3.org/2000/xmlns/>
          and neither the <P::qualifiedName> nor its prefix is
          <XML::xmlns>.  <SRC::manakai>
      @@@iRaises:
        @@@@@: c|NSURI_WHERE_NO_XML_FEATURE_ERR
        @@@@enDesc:
          If the implementation does not support the <Feature::XML>
          feature but the <P::namespaceURI> is different from <DOM::null>.
          <SRC::DOM3>
      @@@dx:raises:
        @@@@@: c|DIFFERENT_DOCUMENT_ERR
        @@@@enDesc:
          If the <P::doctype> has already been used with a different document
          or was created from a different implementation.
      @@@iRaises:
        @@@@@: MDOMX|MDOM_IMPL_NOSUPPORT_XMLNS
        @@@@enDesc:
          If the implementation does not support the <Feature::XML>
          feature and the language exposed through the <IF::Document>
          does not support XML namespaces.
        @@@@enImplNote:
          What <IF::Document>?  The created one?
      @@@PerlDef:
        require Message::DOM::Document;

        my $bag = <Code::mg|getNodeBag||ManakaiDOM|all:: $ref = $self>;
        my $stem;
        __CODE{mg|createNodeStem||ManakaiDOM|all::
          $bag => $bag,
          $stem => $stem,
          $class => {<ClassName::td|ManakaiDOMDocument>},
          $opt => {{
            <H::f|implementation> => $self,
          }},
        }__;
        __CODE{mg|createNodeRef||ManakaiDOM|all::
          $bag => $bag,
          $stem => $stem,
          $ref => $r,
          $opt => {{
          }},
        }__;

        if (defined $doctype) {
          __DEEP{
            $r-><M::Node.appendChild> ($doctype);
          }__;
        }

        if (defined $qualifiedName) {
          __DEEP{
            my $el = $r-><M::Document.createElementNS>
                           ($namespaceURI, $qualifiedName);
            $r-><M::Node.appendChild> ($el);
            $r = $el-><AG::Node.ownerDocument>;
                   ## Choose the class based on document element type
          }__;
        } elsif (defined $namespaceURI) {
          __EXCEPTION{MDOMX|MDOM_NS_NULL_QNAME_WITH_NON_NULL_URI::
            MDOMX|param-name => 'namespaceURI',
            infoset|namespaceURI => {$namespaceURI},
          }__;
        }

    @@Test:
      @@@QName: Impl.createDoc.1.test
      @@@PerlDef:
        local $Message::Util::Grove::GCLatency = 0;

        my $impl;
        __CODE{tc|createImplForTest:: $impl => $impl}__;

        my $bag = $impl->{<H::mg|nodeBag>};
        my $id = $impl->{<H::mg|nodeIDReference>};

        my $doc = $impl-><M::c|DOMImplementation.createDocument>;
        
        $test->id ('interface');
        $test->assert_isa ($doc, <IFName::Document>);
        
        $test->id ('class');
        $test->assert_isa ($doc, <ClassName::td|ManakaiDOMDocument>);

        my $doc_id = $doc->{<H::mg|nodeIDReference>};

        undef $impl;

        $test->id ('gc.impl.1');
        $test->assert_not_null ($bag->{$$id});

        $test->id ('gc.doc.1');
        $test->assert_not_null ($bag->{$$doc_id});

        undef $doc;

        $test->id ('gc.impl.2');
        $test->assert_null ($bag->{$$id});

        $test->id ('gc.doc.2');
        $test->assert_null ($bag->{$$doc_id});
    @@Test:
      @@@QName: Impl.createDoc.2.test
      @@@PerlDef:
        local $Message::Util::Grove::GCLatency = 0;

        my $impl;
        __CODE{tc|createImplForTest:: $impl => $impl}__;

        my $bag = $impl->{<H::mg|nodeBag>};
        my $id = $impl->{<H::mg|nodeIDReference>};

        my $doc = $impl-><M::c|DOMImplementation.createDocument>;
        
        $test->id ('interface');
        $test->assert_isa ($doc, <IFName::Document>);
        
        $test->id ('class');
        $test->assert_isa ($doc, <ClassName::td|ManakaiDOMDocument>);

        my $doc_id = $doc->{<H::mg|nodeIDReference>};

        undef $doc;

        $test->id ('gc.impl.1');
        $test->assert_not_null ($bag->{$$id});

        $test->id ('gc.doc.1');
        $test->assert_null ($bag->{$$doc_id});

        undef $impl;

        $test->id ('gc.impl.2');
        $test->assert_null ($bag->{$$id});

        $test->id ('gc.doc.2');
        $test->assert_null ($bag->{$$doc_id});
    @@Test:
      @@@QName: Impl.createDoc.3.test
      @@@PerlDef:
        local $Message::Util::Grove::GCLatency = 1;

        my $impl;
        __CODE{tc|createImplForTest:: $impl => $impl}__;

        my $bag = $impl->{<H::mg|nodeBag>};
        my $id = $impl->{<H::mg|nodeIDReference>};

        my $doc = $impl-><M::c|DOMImplementation.createDocument>;
        
        $test->id ('interface');
        $test->assert_isa ($doc, <IFName::Document>);
        
        $test->id ('class');
        $test->assert_isa ($doc, <ClassName::td|ManakaiDOMDocument>);

        my $doc_id = $doc->{<H::mg|nodeIDReference>};

        undef $doc;
        undef $impl;

        $test->id ('gc.impl.1');
        $test->assert_null ($bag->{$$id});

        $test->id ('gc.doc.1');
        $test->assert_null ($bag->{$$doc_id});

  @CL2Method:
    @@Name: createDocumentType
    @@enDesc:
      Creates an empty <IF::tx|DocumentType> node.  Entity
      declarations and notations are not made available.
      Entity reference expansions and default attribute additions do
      not occur.
    @@DOMMain:isNamespaceAware: 1
    @@XML2Feature:
    @@enDesc:
      @@@ddid: manakai
      @@@For: ManakaiDOM|ManakaiDOM
      @@@@:
        In manakai, the method <M::c|DOMImplementation.createDocumentType>
        is <EM::deprecated>; use the method
        <M::DocumentX.createDocumentTypeDefinition> instead.
    @@Param:
      @@@Name: qualifiedName
      @@@Type: DOMString
      @@@enDesc:
        The XML Namespaces 1.0 <SRC::DOM2, DOM3> qualified name of
        the document type to be created.
    @@Param:
      @@@Name: publicId
      @@@Type: DOMString
      @@@enDesc:
        The public identifier of the external subset.
      @@@nullCase:
        @@@@enDesc:
          The external subset has no public identifier or
          the document type has no external subset.  <SRC::manakai>
    @@Param:
      @@@Name: systemId
      @@@Type: DOMString
      @@@enDesc:
        The system identifier of the external subset.
      @@@nullCase:
        @@@@enDesc:
          The external subset has no system identifier or
          the document type has no external subset.  <SRC::manakai>
    @@enImplNote:
      @@@ddid: badparam
      @@@@:
        Can <P::systemId> and / or <P::publicId> be <DOM::null>?

        What should happen if <P::publicId> is non-<DOM::null>
        and <P::systemId> is <DOM::null>?

        What should happen if <P::publicId> or <P::systemId> 
        is ill-formed?
    @@Return:
      @@@Type: tx|DocumentType
      @@@enDesc:
        The newly created <IF::tx|DocumentType> node with
        <A::Node.ownerDocument> set to <DOM::null>.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_BAD_NAME
        @@@@enDesc:
          If the <P::qualifiedName> is not an XML 1.0 <CODE::Name>
          <SRC::DOM3>.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_NS_MALFORMED_QNAME
        @@@@enDesc:
          If the <P::qualifiedName> is malformed.
      @@@enImplNote:
        @@@@ddid: strict
        @@@@@:
          The <A::Document.strictErrorChecking> attribute is
          <EM::not> applied to these errors, since it has no
          associated <IF::Document> node.
      @@@iRaises:
        @@@@@: MDOMX|MDOM_IMPL_NOSUPPORT_XMLNS
        @@@@enDesc:
          This exception may be raised if the implementation does not support 
          the feature <Feature::XML> and the language exposed through
          the document does not support XML namespaces.
        @@@@enImplNote:
          <QUOTE::Document>?  What document?
      @@@PerlDef:
        ## Validate |qualifiedName| - don't use |InputProcessor|
        ## since it refers |strictErrorChecking| attribute.
        unless (<Code::DOMMain|testXML10Name:: $INPUT = $qualifiedName>) {
          __EXCEPTION{MDOMX|MDOM_BAD_NAME::
            infoset|name => {$qualifiedName},
            MDOMX|param-name => 'qualifiedName',
            infoset|version => '1.0',
          }__;
        }
        unless (<Code::DOMMain|testXML10QName:: $INPUT = $qualifiedName>) {
          __EXCEPTION{MDOMX|MDOM_NS_MALFORMED_QNAME::
            infoset|name => {$qualifiedName},
            MDOMX|param-name => 'qualifiedName',
            infoset|version => '1.0',
          }__;
        }

        require Message::DOM::XDoctype;
        my $bag = <Code::mg|getNodeBag||ManakaiDOM|all:: $ref = $self>;
        my $stem;
        __CODE{mg|createNodeStem||ManakaiDOM|all::
          $bag => $bag,
          $stem => $stem,
          $class => {<ClassName::d|ManakaiDOMDocumentTypeDefinition>},
          $opt => {{
            <H::infoset|name> => \$qualifiedName,
            <H::f|implementation> => $self,
          }},
        }__;
        __CODE{mg|createNodeRef||ManakaiDOM|all::
          $bag => $bag,
          $stem => $stem,
          $ref => $r,
          $opt => {{
          }},
        }__;

        if (defined $publicId){ 
          $r-><AS::tx|DocumentType.publicId> ($publicId);
        }
        if (defined $systemId){ 
          $r-><AS::tx|DocumentType.systemId> ($systemId);
        }
        $r-><M::Node.manakaiSetReadOnly> (true, true);

    @@L2Test:
      @@@QName: DOMImplDoc.createDocumentType.ncname.test
      @@@PerlDef:
        my $impl;
        __CODE{tc|createImplForTest:: $impl => $impl}__;

        $test->id ('create');
        my $dtype = $impl-><M::c|DOMImplementation.createDocumentType> ('qname');
        $test->assert_isa ($dtype, <IFName::tx|DocumentType>);

        $test->id ('nodeName');
        $test->assert_equals ($dtype-><AG::Node.nodeName>, 'qname');
    @@L2Test:
      @@@QName: DOMImplDoc.createDocumentType.qname.test
      @@@PerlDef:
        my $impl;
        __CODE{tc|createImplForTest:: $impl => $impl}__;

        $test->id ('create');
        my $dtype = $impl-><M::c|DOMImplementation.createDocumentType>
                             ('pfx:qname');
        $test->assert_isa ($dtype, <IFName::tx|DocumentType>);

        $test->id ('nodeName');
        $test->assert_equals ($dtype-><AG::Node.nodeName>, 'pfx:qname');
    @@L2Test:
      @@@QName: DOMImplDoc.createDocumentType.non.name11.test
      @@@PerlDef:
        my $impl;
        __CODE{tc|createImplForTest:: $impl => $impl}__;

        $test->id ('create');
        $test->assert_exception (code => sub {
          $impl-><M::c|DOMImplementation.createDocumentType> ('12345');
        }, exception_subtype => <Q::MDOMX|MDOM_BAD_NAME>);
    @@L2Test:
      @@@QName: DOMImplDoc.createDocumentType.name11.non.name10.test
      @@@PerlDef:
        my $impl;
        __CODE{tc|createImplForTest:: $impl => $impl}__;

        $test->id ('create');
        $test->assert_exception (code => sub {
          $impl-><M::c|DOMImplementation.createDocumentType>
                   ("\x{3001}\x{3002}");
                   ## A Name in XML 1.1 but not in XML 1.0.
        }, exception_subtype => <Q::MDOMX|MDOM_BAD_NAME>);
    @@L2Test:
      @@@QName: DOMImplDoc.createDocumentType.non.qname11.test
      @@@PerlDef:
        my $impl;
        __CODE{tc|createImplForTest:: $impl => $impl}__;

        $test->id ('create');
        $test->assert_exception (code => sub {
          $impl-><M::c|DOMImplementation.createDocumentType> (':aa');
        }, exception_subtype => <Q::MDOMX|MDOM_NS_MALFORMED_QNAME>);
    @@L2Test:
      @@@QName: DOMImplDoc.createDocumentType.qname11.non.qname10.test
      @@@PerlDef:
        my $impl;
        __CODE{tc|createImplForTest:: $impl => $impl}__;

        $test->id ('create');
        $test->assert_exception (code => sub {
          $impl-><M::c|DOMImplementation.createDocumentType>
                   ("a:\x{3005}b");
                    ## A QName in XMLNames 1.1 but not in XMLNames 1.0.
        }, exception_subtype => <Q::MDOMX|MDOM_NS_MALFORMED_QNAME>);
    @@L2Test:
      @@@QName: DOMImplDoc.createDocumentType.pubid.sysid.test
      @@@PerlDef:
        my $impl;
        __CODE{tc|createImplForTest:: $impl => $impl}__;

        $test->id ('create');
        my $dtype = $impl-><M::c|DOMImplementation.createDocumentType>
                             ('qname', 'pubid', 'sysid');
        $test->assert_isa ($dtype, <IFName::tx|DocumentType>);

        $test->id ('nodeName');
        $test->assert_equals ($dtype-><AG::Node.nodeName>, 'qname');

        $test->id ('publicId');
        $test->assert_equals ($dtype-><AG::tx|DocumentType.publicId>, 'pubid');

        $test->id ('systemId');
        $test->assert_equals ($dtype-><AG::tx|DocumentType.systemId>, 'sysid');
##DOMImplementationTC

ResourceDef:
  @QName: Document
  @AliasFor: td|Document
  @For: ManakaiDOM|DOM

ResourceDef:
  @QName: DocumentFragment
  @AliasFor: td|DocumentFragment
  @For: ManakaiDOM|DOM

ResourceDef:
  @QName: Element
  @AliasFor: te|Element
  @For: ManakaiDOM|DOM

ResourceDef:
  @QName: Attr
  @AliasFor: te|Attr
  @For: ManakaiDOM|DOM

ResourceDef:
  @QName: DOMString
  @AliasFor: DOMMain|DOMString
  @For: ManakaiDOM|DOM

ResourceDef:
  @QName: DOMImpl
  @AliasFor: c|DOMImplementation
  @For: ManakaiDOM|DOM

ResourceDef:
  @QName: boolean
  @AliasFor: idl|boolean||ManakaiDOM|all

ResourceDef:
  @QName: unsignedLong
  @AliasFor: idl|unsignedLong||ManakaiDOM|all

ResourceDef:
  @QName: unsignedShort
  @AliasFor: idl|unsignedShort||ManakaiDOM|all

ResourceDef:
  @QName: ARRAY
  @AliasFor: DISPerl|ARRAY||ManakaiDOM|all

ResourceDef:
  @QName: HASH
  @AliasFor: DISPerl|HASH||ManakaiDOM|all

ResourceDef:
  @QName: DocumentX
  @AliasFor: d|DocumentXDoctype
  @For: ManakaiDOM|ManakaiDOMLatest

ResourceDef:
  @QName: DTDef
  @AliasFor: d|DocumentTypeDefinition
  @For: ManakaiDOM|ManakaiDOMLatest

ResourceDef:
  @QName: ETDef
  @AliasFor: d|ElementTypeDefinition
  @For: ManakaiDOM|ManakaiDOMLatest

ResourceDef:
  @QName: ATDef
  @AliasFor: d|AttributeDefinition
  @For: ManakaiDOM|ManakaiDOMLatest

IFCls1Def:
  @IFQName: Node
  @ClsQName: ManakaiDOMNode

  @ClsISA: f|ManakaiHasFeatureByGetFeature
  @Implement: ecore|MUErrorTarget||ManakaiDOM|Perl
  @DISLang:role:
    @@@: mg|NodeRefRole
    @@enImplNote:
      If it is necessary to add a role, then add to
      the <IF::tx|CDATASection>, too.

  @enDesc:
    The <IF::Node> interface is the primary datatype for the entire 
    document object model.  It represents a single node in the 
    document tree.

    The <IF::Node> interface is not implemented alone; the <IF::Node>
    objects are expected to implement one or more additional
    interfaces according to its node type.  For example, a node
    whose <A::Node.nodeType> equals to <C::Node.ELEMENT_NODE>
    would also implement the <IF::Element> interface.

  @IntMethod:
    @@Operator: mg|CreateNodeRefMethod
    @@Param:
      @@@Name: obj
      @@@Type: HASH
    @@Param:
      @@@Name: opt
      @@@Type: HASH
    @@Return:
      @@@Type: Node
      @@@PerlDef:
        my $class;
        CLS: {
          if (defined $opt->{<H::mg|nodeRefClass>}) {
            $class = $opt->{<H::mg|nodeRefClass>};
            IFCHK: {
              for (@{$opt->{<H::mg|nodeRefInterfaces>} or []}) {
                last IFCHK unless $$class->isa ($_);
              }
              last CLS;
            } # IFCHK
          }
          $class = \$self;
        } # CLS
        $r = bless $obj, $$class;

  @IntMethod:
    @@Operator: mg|CreateNodeStemMethod
    @@Param:
      @@@Name: bag
      @@@Type: HASH
    @@Param:
      @@@Name: obj
      @@@Type: HASH
    @@Param:
      @@@Name: opt
      @@@Type: HASH
    @@Return:
      @@@Type: HASH
      @@@PerlDef:
        __CODE{mg|setOwnerProp||ManakaiDOM|all::
          $bag => $bag,
          $ownerref => {$opt->{<H::tc|ownerDocument>}},
          $ownee1hprop => {<H::tc|revOwnerDocument>},
          $ownee => {$obj},
          $owner0prop => {<H::tc|ownerDocument>},
        }__;
        $r = $obj;

  @Code:
    @@QName: tc|createNodesForTest
    @@PerlDef:
          $doc-><M::Document.createAttribute> ('a'),
          $docx-><M::d|DocumentXDoctype.createAttributeDefinition> ('at'),
          $doc-><M::Document.createCDATASection> ('cs'),
          $doc-><M::Document.createComment> ('c'),
          $doc,
          $doc-><M::Document.createDocumentFragment>,
          $docx-><M::d|DocumentXDoctype.createDocumentTypeDefinition> ('d'),
          $docx-><M::d|DocumentXDoctype.createGeneralEntity> ('ge'),
          $doc-><M::Document.createElement> ('e'),
          $docx-><M::d|DocumentXDoctype.createElementTypeDefinition> ('et'),
          $doc-><M::Document.createEntityReference> ('er'),
          $docx-><M::d|DocumentXDoctype.createNotation> ('not'),
          $doc-><M::Document.createProcessingInstruction> ('pi'),
          $doc-><M::Document.createTextNode> ('text'),
          #test:nodeTypes

  @Code:
    @@QName: tc|createNodesForTest+dt
    @@PerlDef:
          $doc-><M::Document.createAttribute> ('a'),
          $docx-><M::d|DocumentXDoctype.createAttributeDefinition> ('at'),
          $doc-><M::Document.createCDATASection> ('cs'),
          $doc-><M::Document.createComment> ('c'),
          $doc,
          $doc-><M::Document.createDocumentFragment>,
          $docx-><M::d|DocumentXDoctype.createDocumentTypeDefinition> ('d'),
          $doc-><AG::Document.implementation>
              -><M::c|DOMImplementation.createDocumentType> ('dt'),
          $docx-><M::d|DocumentXDoctype.createGeneralEntity> ('ge'),
          $doc-><M::Document.createElement> ('e'),
          $docx-><M::d|DocumentXDoctype.createElementTypeDefinition> ('et'),
          $doc-><M::Document.createEntityReference> ('er'),
          $docx-><M::d|DocumentXDoctype.createNotation> ('not'),
          $doc-><M::Document.createProcessingInstruction> ('pi'),
          $doc-><M::Document.createTextNode> ('text'),
          #test:nodeTypes

  @Code:
    @@QName: tc|createNodesForTest-doc-dtdef
    @@PerlDef:
          $doc-><M::Document.createAttribute> ('a'),
          $docx-><M::d|DocumentXDoctype.createAttributeDefinition> ('at'),
          $doc-><M::Document.createCDATASection> ('cs'),
          $doc-><M::Document.createComment> ('c'),
          # |Document|
          $doc-><M::Document.createDocumentFragment>,
          # |DocumentType| / |DocumentTypeDefinition|
          $docx-><M::d|DocumentXDoctype.createGeneralEntity> ('ge'),
          $doc-><M::Document.createElement> ('e'),
          $docx-><M::d|DocumentXDoctype.createElementTypeDefinition> ('et'),
          $doc-><M::Document.createEntityReference> ('er'),
          $docx-><M::d|DocumentXDoctype.createNotation> ('not'),
          $doc-><M::Document.createProcessingInstruction> ('pi'),
          $doc-><M::Document.createTextNode> ('text'),
          #test:nodeTypes

  @Code:
    @@QName: tc|createNodesForTest-el-attr
    @@PerlDef:
          # |Attribute|
          $docx-><M::d|DocumentXDoctype.createAttributeDefinition> ('at'),
          $doc-><M::Document.createCDATASection> ('cs'),
          $doc-><M::Document.createComment> ('c'),
          $doc,
          $doc-><M::Document.createDocumentFragment>,
          $docx-><M::d|DocumentXDoctype.createDocumentTypeDefinition> ('d'),
          $docx-><M::d|DocumentXDoctype.createGeneralEntity> ('ge'),
          # |Element|
          $docx-><M::d|DocumentXDoctype.createElementTypeDefinition> ('et'),
          $doc-><M::Document.createEntityReference> ('er'),
          $docx-><M::d|DocumentXDoctype.createNotation> ('not'),
          $doc-><M::Document.createProcessingInstruction> ('pi'),
          $doc-><M::Document.createTextNode> ('text'),
          #test:nodeTypes

  @Test:
    @@QName: Node.interfaces.test
    @@PerlDef:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
      my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

      for my $node (<Code::tc|createNodesForTest>) {
        $test->id ($node-><AG::Node.nodeName>.'.Node');
        $test->assert_isa ($node, <IFName::Node>);

        $test->id ($node-><AG::Node.nodeName>.'.MUErrorTarget');
        $test->assert_isa
                 ($node, <IFName::ecore|MUErrorTarget||ManakaiDOM|Perl>);

        $test->id ($node-><AG::Node.nodeName>.'.GetFeature');
        $test->assert_isa ($node, <IFName::f|GetFeature>);
      }

  @IntMethod:
    @@Operator:
      @@@@: DESTROY
      @@@ContentType: DISPerl|Perl
    @@Return:
      @@@disDef:
        @@@@DISPerl:cloneCode: mg|NodeRef||ManakaiDOM|all.destroy

  @IntMethod:
    @@Operator: ManakaiDOM|MUErrorHandler
    @@enDesc:
      When a <IF::ecore|ErrorInterface||ManakaiDOM|Perl> is <Perl::report>ed
      with an <Perl::-object> of <IF::Node>, then this method is invoked.
      
      The method calls the <cfg::error-handler> if the error is of 
      <IF::c|DOMError>.  Otherwise, including the cases of <IF::c|DOMException>s,
      the error is rethrown so that appropriate <Perl::catch> clause
      can catch the error.
    @@Param:
      @@@Name: err
      @@@Type: ecore|ErrorInterface||ManakaiDOM|Perl
      @@@enDesc:
        The reported error object.
    @@Return:
      @@@Type: DISPerl|Any
      @@@enDesc:
        If the <P::err> is a <IF::c|DOMError>, then the return value
        of the error handler.

           {NOTE:: If the error is thrown, the method never returns.
           }
      @@@nullCase:
        @@@@enDesc:
          No error handler.
      @@@PerlDef:
        if ($err->isa (<IFName::c|DOMError||ManakaiDOM|ManakaiDOM>)) {
          __DEEP{
            A: {
              my $doc = $self-><AG::Node.ownerDocument>;
              if (not defined $doc) {
                if ($self-><AG::Node.nodeType> == <C::Node.DOCUMENT_NODE>) {
                  $doc = $self;
                } else {  ## DOCUMENT_TYPE_NODE
                  CORE::warn $err;
                  last A;
                }
              }
              my $cfg = $doc-><AG::Document.domConfig>;
              my $h = $cfg-><M::c|DOMConfiguration.getParameter>
                               ('error-handler');
              $r = $h-><M::c|DOMErrorHandler.handleError> ($err);
            } # A
          }__;
        } else {
          $err-><M::ecore|ErrorInterface||ManakaiDOM|Perl.throw>;
        }

  @Constants:
    @@QName: NodeType
    @@enDesc:
      A <Q::NodeType> value is an integer indicating which type
      the node is.

      {NOTE::
        Numeric codes up to 200 are reserved to W3C for
        possible future use. <SRC::DOM1SE, DOM2, DOM3>
      }

    @@Const:
      @@@Name: ELEMENT_NODE
      @@@intValue: 1
      @@@enDesc:
        The node is an <IF::Element>.
    @@Const:
      @@@Name: ATTRIBUTE_NODE
      @@@intValue: 2
      @@@enDesc:
        The node is an <IF::Attr>.
    @@Const:
      @@@Name: TEXT_NODE
      @@@intValue: 3
      @@@enDesc:
        The node is a <IF::Text>.
    @@Const:
      @@@Name: CDATA_SECTION_NODE
      @@@intValue: 4
      @@@enDesc:
        The node is a <IF::tx|CDATASection>.
    @@Const:
      @@@Name: ENTITY_REFERENCE_NODE
      @@@intValue: 5
      @@@enDesc:
        The node is an <IF::tx|EntityReference>.
    @@Const:
      @@@Name: ENTITY_NODE
      @@@intValue: 6
      @@@enDesc:
        The node is an <IF::tx|Entity>.
    @@Const:
      @@@Name: PROCESSING_INSTRUCTION_NODE
      @@@intValue: 7
      @@@enDesc:
        The node is a <IF::tx|ProcessingInstruction>.
    @@Const:
      @@@Name: COMMENT_NODE
      @@@intValue: 8
      @@@enDesc:
        The node is a <IF::Comment>.
    @@Const:
      @@@Name: DOCUMENT_NODE
      @@@intValue: 9
      @@@enDesc:
        The node is a <IF::Document>.
    @@Const:
      @@@Name: DOCUMENT_TYPE_NODE
      @@@intValue: 10
      @@@enDesc:
        The node is a <IF::tx|DocumentType>.
    @@Const:
      @@@Name: DOCUMENT_FRAGMENT_NODE
      @@@intValue: 11
      @@@enDesc:
        The node is a <IF::DocumentFragment>.
    @@Const:
      @@@Name: NOTATION_NODE
      @@@intValue: 12
      @@@enDesc:
        The node is a <IF::tx|Notation>.

    @@LXConst:
      @@@Name: ELEMENT_TYPE_DEFINITION_NODE
      @@@intValue: 81001
      @@@enDesc:
        The node is an <IF::d|ElementTypeDefinition>.
    @@LXConst:
      @@@Name: ATTRIBUTE_DEFINITION_NODE
      @@@intValue: 81002
      @@@enDesc:
        The node is an <IF::d|AttributeDefinition>.

  @Attr:
    @@Name: nodeType
    @@enDesc:
      A code representing the type of the underlying object.
    @@Type: unsignedShort
    @@dis:actualType: NodeType
    @@Get:
      @@@PerlDef:
        ## TODO: Assertion

  @L2Attr:
    @@Name: localName
    @@enDesc:
      The local part of the qualified name of the node.
    @@DOMMain:isNamespaceAware:1
    @@Type: DOMString
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          If the type of the node is different from <C::Node.ELEMENT_NODE>
          and <C::Node.ATTRIBUTE_NODE>.
      @@@nullCase:
        @@@@enDesc:
          If it is a DOM Level 1 node.
      @@@PerlDef:
        my $v;
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $v,
          $prop => {<H::infoset|localName>},
          $ref => $self,
        }__;
        $r = defined $v ? $$v : null;
      @@@enImplNote:
        @@@@ddid: dom1
        @@@@@:
          {NOTE::
            Manakai no longer supports DOM Level 1 nodes.
          }

    @@L2Test:
      @@@QName: Node.localName.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        for my $node (<Code::tc|createNodesForTest-el-attr>) {
          $test->id ($node-><AG::Node.nodeType>);
          $test->assert_null ($node-><AG::Node.localName>);
        }

  @L2Attr:
    @@Name: namespaceURI
    @@enDesc:
      The namespace URI of the node.

        {NOTE::
           This is <EM::not> a computed value that is the result
           of a namespace lookup based on an examination of the
           namespace declarations in scope.  It is merely the
           namespace URI given at creation time.
        }
    @@DOMMain:isNamespaceAware:1
    @@Type: DOMString
    @@dis:actualType: ManakaiDOM|ManakaiDOMNamespaceURI
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          If the namespace is unspecified.
      @@@nullCase:
        @@@@enDesc:
          If the type of the node is different from <C::Node.ELEMENT_NODE>
          or <C::Node.ATTRIBUTE_NODE>.
      @@@nullCase:
        @@@@enDesc:
          If it is a DOM Level 1 node.
      @@@PerlDef:
        my $v;
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $v,
          $prop => {<H::infoset|namespaceName>},
          $ref => $self,
        }__;
        $r = defined $v ? $$v : null;
      @@@enImplNote:
        @@@@ddid:dom1
        @@@@@:
          {NOTE::
            Manakai no longer supports DOM Level 1 nodes.
          }

    @@L2Test:
      @@@QName: Node.namespaceURI.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        for my $node (<Code::tc|createNodesForTest-el-attr>) {
          $test->id ($node-><AG::Node.nodeType>);
          $test->assert_null ($node-><AG::Node.namespaceURI>);
        }

  @L2Attr:
    @@Name: prefix
    @@enDesc:
      The namespace prefix of the node.
    @@DOMMain:isNamespaceAware:1
    @@Type: DOMString
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          If the namespace prefix is unspecified.
      @@@nullCase:
        @@@@enDesc:
          If the type of the node is different from <C::Node.ELEMENT_NODE>
          or <C::Node.ATTRIBUTE_NODE>.
      @@@nullCase:
        @@@@enDesc:
          If it is a DOM Level 1 node.
      @@@PerlDef:
        $r = null;
    @@Set:
      @@@enDesc:
        Setting this attribute, when permitted, changes the 
        <A::Node.nodeName>, as well as <A::Element.tagName>
        or <A::Attr.name> attributes when applicable.

        Changining the namespace prefix of an attribute that
        is known to have a default value does not make a
        new attribute with the default value and the original
        prefix appear, since the <A::Node.namespaceURI> and
        <A::Node.localName> do no change.

        If the attribute value is defined to be <DOM::null>,
        setting it has no effect, including if the node is read-only.
        <SRC::DOM3>
      @@@nullCase:
        @@@@enDesc:
          Makes the namespace prefix unspecified.  <SRC::DOM3>
      @@@InCase:
        @@@@Value:
          @@@@@@: \
          @@@@@ContentType: DISCore|String
        @@@@enDesc:
          Implementation dependent.  <SRC::DOM3>
        @@@@enImplNote:
          In Firefox 1.5 it is same as <DOM::null>.  In Opera 8.5 and
          9 TP1 it has no effect.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_BAD_NAME
        @@@@enDesc:
          If the specified value contains an illegal character 
          <SRC::DOM2, DOM3>, according to XML 1.0 <SRC::DOM2 Errata> or
          according to the XML version in use specified in the
          <A::Document.xmlVersion> attribute <SRC::DOM3>.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the node is read-only.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_NS_BAD_NCNAME
        @@@@enDesc:
          If the specified prefix is malformed <SRC::DOM2, DOM3>
          per the XML Namespaces specification <SRC::DOM3>.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_NS_PREFIX_WITH_NULL_URI
        @@@@enDesc:
          If the <A::Node.namespaceURI> of the node is <DOM::null>.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_NS_XML_WITH_OTHER_URI
        @@@@enDesc:
          If the specified prefix is <XML::xml> and
          the <A::Node.namespaceURI> of the node is different
          from <URI::http://www.w3.org/XML/1998/namespace>.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_NS_XMLNS_WITH_OTHER_URI
        @@@@enDesc:
          If the node is an attribute and the specified prefix
          is <XML::xmlns> and the <A::Node.namespaceURI> of the node
          is different from <URI::http://www.w3.org/2000/xmlns/>.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_NS_QNAME_IS_XMLNS
        @@@@enDesc:
          If the node is an attribute and the qualified name
          of the node is <XML::xmlns>.
      @@@c:reports:
        @@@@@: t|setting-prefix-no-effect-because-of-document
        @@@@enDesc:
          If the the document does not support XML namespace
          so that setting the attribute value has no effect.
      @@@c:reports:
        @@@@@: t|setting-prefix-no-effect-because-of-node
        @@@@enDesc:
          If the the node does not support XML namespace
          so that setting the attribute value has no effect.
      @@@PerlDef:
        __c|ERROR{t|setting-prefix-no-effect-because-of-node::
          c|relatedData => {$self},
        }__;

    @@L2Test:
      @@@QName: Node.prefix.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestNoErr:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        for my $node (<Code::tc|createNodesForTest-el-attr>) {
          $test->id ($node-><AG::Node.nodeType>.'.get');
          $test->assert_null ($node-><AG::Node.prefix>);

          $test->id ($node-><AG::Node.nodeType>.'.set');
          $node-><AS::Node.prefix> ('node-value');
          $test->assert_null ($node-><AG::Node.prefix>);
        }

  @Attr:
    @@Name: parentNode
    @@enDesc:
      The parent of the node.
    @@Type: Node
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          If the node has no parent.
      @@@PerlDef:
        __CODE{mg|getNodeStemProp0Node||ManakaiDOM|all::
          $r => $r,
          $prop => {<H::infoset|parent>},
          $ref => $self,
          $opt => {{
            <H::mg|nodeRefInterfaces> => [<IFName::Node>],
          }},
        }__;

    @@XDTest:
      @@@QName: Node.parentNode.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        for my $node (<Code::tc|createNodesForTest>) {
          $test->id ('initial.'.$node-><AG::Node.nodeType>);
          $test->assert_null ($node-><AG::Node.parentNode>);
        }

  @L12Attr:
    @@Name: ownerDocument
    @@enDesc:
      The <IF::Document> object associated with the node.
    @@Type: Document
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          If the node is a <IF::Document>.
      @@@nullCase:
        @@@@enDesc:
          If the node is a <IF::tx|DocumentType> that is not
          used with any <IF::Document> yet.
      @@@PerlDef:
        __CODE{mg|getNodeStemProp0Node||ManakaiDOM|all::
          $r => $r,
          $prop => {<H::tc|ownerDocument>},
          $ref => $self,
          $opt => {{
            <H::mg|nodeRefInterfaces> => [<IFName::Document>],
          }},
        }__;

    @@Test:
      @@@QName: Node.ownerDocument.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        for my $node (<Code::tc|createNodesForTest-doc-dtdef>) {
          $test->id ($node-><AG::Node.nodeType>);
          $test->assert_equals ($node-><AG::Node.ownerDocument>, $doc);
        }

    @@Test:
      @@@QName: Node.ownerDocument.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        $test->assert_null ($doc-><AG::Node.ownerDocument>);

    @@Test:
      @@@QName: Node.ownerDocument.3.test
      @@@PerlDef:
        my $dt;
        __CODE{d|createDTForTest:: $dt => $dt}__;
        $test->assert_null ($dt-><AG::Node.ownerDocument>);

    @@XDTest:
      @@@QName: Node.ownerDocument.4.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>, '3.0');

        my $dtdef = $docx-><M::DocumentX.createDocumentTypeDefinition> ('dt1');

        $test->assert_equals ($dtdef-><AG::Node.ownerDocument>, $doc);

  @L3Method:
    @@Name: isSameNode
    @@Perlop: eq
    @@enDesc:
      Returns whether the node is the same node as the given one.

      This method provides a way to determine whether two
      <IF::Node> references returned by the implementation
      reference the same object.  When two <IF::Node> references
      are references to the same object, even if through a proxy,
      the references may be used completely interchangeably,
      such that all attributes have the same values and calling
      the same DOM methods on either reference always has exactly
      the same effect.
    @@Param:
      @@@Name: other
      @@@Type: Node
      @@@enDesc:
        The node to test against.
    @@Return:
      @@@Type: boolean
      @@@TrueCase:
        @@@@enDesc:
          If the nodes are same.
      @@@FalseCase:
        @@@@enDesc:
          Otherwise.
      @@@PerlDef:
        if (UNIVERSAL::isa ($other, <IFName::Node||ManakaiDOM|ManakaiDOM>) and
            $other->isa ('HASH') and
            exists $other->{<H::mg|nodeIDReference>}) {
          $r = ($other->{<H::mg|nodeIDReference>}
                    eq $self->{<H::mg|nodeIDReference>});
        }

  @LXAttr:
    @@Name: manakaiReadOnly
    @@enDesc:
      Whether the node is read-only or not.
    @@Type: boolean
    @@TrueCase:
      @@@enDesc:
        If the node is read-only.
    @@FalseCase:
      @@@enDesc:
        If the node is <EM::not> read-only.
    @@Get:
      @@@PerlDef:
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $r,
          $prop => {<H::c|read-only>},
          $ref => $self,
        }__;

    @@CODE:
      @@@QName: tc|NodeReadOnlyError
      @@@PerlDef:
        if ($node-><AG::Node.manakaiReadOnly>) {
          __EXCEPTION{MDOMX|NOMOD_THIS::
          }__;
        }

  @LXMethod:
    @@Name: manakaiSetReadOnly
    @@enDesc:
      Sets the value of the <A::Node.manakaiReadOnly> attribute.
    @@Param:
      @@@Name: newValue
      @@@Type: boolean
      @@@enDesc:
        The new value of the attribute.
    @@Param:
      @@@Name: deep
      @@@Type: boolean
      @@@enDesc:
        Whether descendants' read-only flags should also
        be set or not.
      @@@TrueCase:
        @@@@enDesc:
          {P:: In addition to the node itself, the attribute value
               <kwd:MUST> be set as <P::newValue> as if the method 
               was invoked with the same parameters for each node from:

            - <A::Node.childNodes>,

            - <A::Node.attributes> (if the node is an <IF::Element>),

            - <A::d|DocumentTypeDefinition.elementTypes>
              (if the node is a <IF::d|DocumentTypeDefinition>),

            - <A::d|DocumentTypeDefinition.generalEntities>
              (if the node is a <IF::d|DocumentTypeDefinition>),

            - <A::d|DocumentTypeDefinition.notations>
              (if the node is a <IF::d|DocumentTypeDefinition>), and
            
            - <A::d|ElementTypeDefinition.attributeDefinitions>
              (if the node is an <IF::d|ElementTypeDefinition>)

               of the node.
          }
      @@@FalseCase:
        @@@@enDesc:
          Only the <A::Node.manakaiReadOnly> attribute of
          the node itself is set.
    @@Return:
      @@@PerlDef:
        if ($deep) {
          my @target = ($self);
          while (@target) {
            my $target = shift @target;

            __CODE{mg|setNodeStemPropValue||ManakaiDOM|all::
              $given => {$newValue},
              $prop => {<H::c|read-only>},
              $ref => $target,
            }__;

            push @target, @{$target-><AG::Node.childNodes>};

            my $nt = $target-><AG::Node.nodeType>;
            if ($nt == <C::Node.ELEMENT_NODE>) {
              push @target, @{$target-><AG::Node.attributes>};
            } elsif ($nt == <C::Node.ELEMENT_TYPE_DEFINITION_NODE>) {
              push @target, @{$target-><AG::ETDef.attributeDefinitions>};
            } elsif ($nt == <C::Node.DOCUMENT_TYPE_NODE>) {
              my $targetx = $target-><M::Node.getFeature>
                                       (<Q::fe|XDoctype>, '3.0');
              push @target, @{$targetx-><AG::DTDef.elementTypes>};
              push @target, @{$targetx-><AG::DTDef.generalEntities>};
              push @target, @{$targetx-><AG::DTDef.notations>};
            }
          }
        } else { # not deep
          __CODE{mg|setNodeStemPropValue||ManakaiDOM|all::
            $given => {$newValue},
            $prop => {<H::c|read-only>},
            $ref => $self,
          }__;
        }

    @@Test:
      @@@QName: Node.manakaiSetReadOnly.1.test
      @@@enDesc:
        <P::deep> = <DOM::false>
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        for my $node (<Code::tc|createNodesForTest>) {
          $test->id ('set.true.1.'.$node-><AG::Node.nodeName>);
          $node-><M::Node.manakaiSetReadOnly> (true, false);
          $test->assert_true ($node-><AG::Node.manakaiReadOnly>);

          $test->id ('set.false.'.$node-><AG::Node.nodeName>);
          $node-><M::Node.manakaiSetReadOnly> (false, false);
          $test->assert_false ($node-><AG::Node.manakaiReadOnly>);

          $test->id ('set.true.2.'.$node-><AG::Node.nodeName>);
          $node-><M::Node.manakaiSetReadOnly> (true, false);
          $test->assert_true ($node-><AG::Node.manakaiReadOnly>);
        }
    @@Test:
      @@@QName: Element.manakaiSetReadOnly.1.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        my $doc = $el-><AG::Node.ownerDocument>;

        my $c1 = $doc-><M::Document.createElement> ('c1');
        $el-><M::Node.appendChild> ($c1);
        my $c2 = $doc-><M::Document.createTextNode> ('c2');
        $el-><M::Node.appendChild> ($c2);
        my $c3 = $doc-><M::Document.createElement> ('c3');
        $c1-><M::Node.appendChild> ($c3);
        my $c4 = $doc-><M::Document.createAttribute> ('c4');
        $el-><M::Element.setAttributeNode> ($c4);
        my $c5 = $doc-><M::Document.createEntityReference> ('c5');
        $c4-><M::Node.appendChild> ($c5);

        $el-><M::Node.manakaiSetReadOnly> (true, true);
        for ($c1, $c2, $c3, $c4, $c5) {
          $test->id ($_-><AG::Node.nodeName>.'.true.1');
          $test->assert_true ($_-><AG::Node.manakaiReadOnly>);
        }

        $el-><M::Node.manakaiSetReadOnly> (false, true);
        for ($c1, $c2, $c3, $c4, $c5) {
          $test->id ($_-><AG::Node.nodeName>.'.false');
          $test->assert_false ($_-><AG::Node.manakaiReadOnly>);
        }

        $el-><M::Node.manakaiSetReadOnly> (true, true);
        for ($c1, $c2, $c3, $c4, $c5) {
          $test->id ($_-><AG::Node.nodeName>.'.true.2');
          $test->assert_true ($_-><AG::Node.manakaiReadOnly>);
        }
    @@Test: 
      @@@QName: DTDef.manakaiSetReadOnly.1.test
      @@@PerlDef:
        my $dtd;
        __CODE{d|createDTDefForTest:: $dtdef => $dtd}__;

        my $doc = $dtd-><AG::Node.ownerDocument>;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>, '3.0');

        my $c1 = $doc-><M::Document.createProcessingInstruction> ('c1');
        $dtd-><M::Node.appendChild> ($c1);
        my $c2 = $docx-><M::DocumentX.createElementTypeDefinition> ('c2');
        $dtd-><M::DTDef.setElementTypeDefinitionNode> ($c2);
        my $c3 = $docx-><M::DocumentX.createGeneralEntity> ('c3');
        $dtd-><M::DTDef.setGeneralEntityNode> ($c3);
        my $c4 = $docx-><M::DocumentX.createNotation> ('c4');
        $dtd-><M::DTDef.setNotationNode> ($c4);
        my $c5 = $doc-><M::Document.createTextNode> ('c5');
        $c3-><M::Node.appendChild> ($c5);

        $dtd-><M::Node.manakaiSetReadOnly> (true, true);
        for ($c1, $c2, $c3, $c4, $c5) {
          $test->id ($_-><AG::Node.nodeName>.'.true.1');
          $test->assert_true ($_-><AG::Node.manakaiReadOnly>);
        }

        $dtd-><M::Node.manakaiSetReadOnly> (false, true);
        for ($c1, $c2, $c3, $c4, $c5) {
          $test->id ($_-><AG::Node.nodeName>.'.false');
          $test->assert_false ($_-><AG::Node.manakaiReadOnly>);
        }

        $dtd-><M::Node.manakaiSetReadOnly> (true, true);
        for ($c1, $c2, $c3, $c4, $c5) {
          $test->id ($_-><AG::Node.nodeName>.'.true.2');
          $test->assert_true ($_-><AG::Node.manakaiReadOnly>);
        }
    @@Test: 
      @@@QName: ETDef.manakaiSetReadOnly.1.test
      @@@PerlDef:
        my $et;
        __CODE{d|createETDefForTest:: $etdef => $et}__;

        my $doc = $et-><AG::Node.ownerDocument>;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>, '3.0');

        my $c1 = $docx-><M::DocumentX.createAttributeDefinition> ('c1');
        $et-><M::ETDef.setAttributeDefinitionNode> ($c1);
        my $c2 = $doc-><M::Document.createTextNode> ('c2');
        $c1-><M::Node.appendChild> ($c2);

        $et-><M::Node.manakaiSetReadOnly> (true, true);
        for ($c1, $c2) {
          $test->id ($_-><AG::Node.nodeName>.'.true.1');
          $test->assert_true ($_-><AG::Node.manakaiReadOnly>);
        }

        $et-><M::Node.manakaiSetReadOnly> (false, true);
        for ($c1, $c2) {
          $test->id ($_-><AG::Node.nodeName>.'.false');
          $test->assert_false ($_-><AG::Node.manakaiReadOnly>);
        }

        $et-><M::Node.manakaiSetReadOnly> (true, true);
        for ($c1, $c2) {
          $test->id ($_-><AG::Node.nodeName>.'.true.2');
          $test->assert_true ($_-><AG::Node.manakaiReadOnly>);
        }

  @Attr:
    @@Name: childNodes
    @@enDesc:
      A node list containing the children of the node.  If there are
      no children, this is a list containing no nodes.
    @@Type: NodeList
    @@Get:
      @@@PerlDef:
        __CODE{tc|createChildNodeList::
          $node => $self,
          $r => $r,
        }__;

    @@Test:
      @@@QName: Node.childNodes.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        for my $node (<Code::tc|createNodesForTest>) {
          my $cn = $node-><AG::Node.childNodes>;

          $test->id ('interface.'.$node-><AG::Node.nodeType>);
          $test->assert_isa ($cn, <IFName::NodeList>);

          $test->id ('length.'.$node-><AG::Node.nodeType>);
          $test->assert_num_equals
                   (actual_value => $cn-><AG::NodeList.length>, 
                    expected_value => 0);
        }

  @Attr:
    @@Name: firstChild
    @@enDesc:
      The first child of the node.
    @@Type: Node
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          If there is no child node.
      @@@PerlDef:
        my $v;
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $v,
          $prop => {<H::infoset|children>},
          $ref => $self,
        }__;
        if (defined $v and defined $v->[0]) {
          __CODE{mg|createNodeRefFromID||ManakaiDOM|all::
            $bag => {<Code::mg|getNodeBag||ManakaiDOM|all:: $ref = $self>},
            $stemid => {$v->[0]},
            $ref => $r,
            $opt => {{
              <H::mg|nodeRefInterfaces> => [<IFName::Node>],
            }},
          }__;
        }

    @@Test:
      @@@QName: Node.firstChild.lastChild.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        for my $node (<Code::tc|createNodesForTest>) {
          $test->id ('default.firstChild.'.$node-><AG::Node.nodeType>);
          $test->assert_null ($node-><AG::Node.firstChild>);

          $test->id ('default.lastChild.'.$node-><AG::Node.nodeType>);
          $test->assert_null ($node-><AG::Node.lastChild>);
        }

  @Attr:
    @@Name: lastChild
    @@enDesc:
      The last child of the node.
    @@Type: Node
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          If there is no child node.
      @@@PerlDef:
        my $v;
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $v,
          $prop => {<H::infoset|children>},
          $ref => $self,
        }__;
        if (defined $v and defined $v->[0]) { # If 0, then there is -1
          __CODE{mg|createNodeRefFromID||ManakaiDOM|all::
            $bag => {<Code::mg|getNodeBag||ManakaiDOM|all:: $ref = $self>},
            $stemid => {$v->[-1]},
            $ref => $r,
            $opt => {{
              <H::mg|nodeRefInterfaces> => [<IFName::Node>],
            }},
          }__;
        }

  @Attr:
    @@Name: previousSibling
    @@enDesc:
      The node immediately preceding the node.
    @@Type: Node
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          If there is no such node.
      @@@PerlDef:
        __DEEP{
          my $parent = $self-><AG::Node.parentNode>;
          if (defined $parent) {
            S: for my $sib (@{$parent-><AG::Node.childNodes>}) {
              if ($sib eq $self) {
                last S;
              } else {
                $r = $sib;
              }
            }
          }
        }__;

  @Attr:
    @@Name: nextSibling
    @@enDesc:
      The node immediately following the node.
    @@Type: Node
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          If there is no such node.
      @@@PerlDef:
        __DEEP{
          my $parent = $self-><AG::Node.parentNode>;
          if (defined $parent) {
            my $next;
            S: for my $sib (@{$parent-><AG::Node.childNodes>}) {
              if ($next) {
                $r = $sib;
                last S;
              } elsif ($sib eq $self) {
                $next = true;
              }
            }
          }
        }__;

    @@Test:
      @@@QName: Node.previousSibling.nextSibling.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $container = $doc-><M::Document.createElementNS> (null, 'c');

        my $e1 = $doc-><M::Document.createElementNS> (null, 'e1');
        $container-><M::Node.appendChild> ($e1);

        my $e2 = $doc-><M::Document.createElementNS> (null, 'e2');
        $container-><M::Node.appendChild> ($e2);

        my $e3 = $doc-><M::Document.createElementNS> (null, 'e3');
        $container-><M::Node.appendChild> ($e3);

        $test->id ('e1.prev');
        $test->assert_null ($e1-><AG::Node.previousSibling>);

        $test->id ('e1.next');
        $test->assert_equals ($e1-><AG::Node.nextSibling>, $e2);

        $test->id ('e2.prev');
        $test->assert_equals ($e2-><AG::Node.previousSibling>, $e1);

        $test->id ('e2.next');
        $test->assert_equals ($e2-><AG::Node.nextSibling>, $e3);

        $test->id ('e3.prev');
        $test->assert_equals ($e3-><AG::Node.previousSibling>, $e2);

        $test->id ('e3.next');
        $test->assert_null ($e3-><AG::Node.nextSibling>);

  @L13Method:
    @@Name: appendChild
    @@enDesc:
      Adds a node to the end of the list of children of the node.
      If that node is already in the tree, it is first removed.
    @@Param:
      @@@Name: newChild
      @@@Type: Node
      @@@enDesc:
        The node to add.
      @@@InCase:
        @@@@Type: DocumentFragment
        @@@@enDesc:
          The entire contents of the document fragment are
          moved into the child list of the node.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node added.
      @@@enImplNote:
        The specification is unclear on what node should or should
        not be returned if the <P::newChild> is a <IF::DocumentFragment>.

        In Firefix 1.5, Opera 9 TP1, and WinIE 6 (Windows XP SP2),
        the <IF::DocumentFragment> node is returned.
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_BAD_TYPE
        @@@@enDesc:
          If the node is of a type that does not allow children of
          the type of the <P::newChild> node.
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_ANCESTOR_OR_SELF
        @@@@enDesc:
          If the <P::newChild> node is one of the node's ancestor
          <SRC::DOM1, DOM2, DOM3> or the node itself <SRC::DOM2 Errata, DOM3>.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_SECOND_DOC_ELEMENT
        @@@@enDesc:
          If the node is of type <IF::Document> and an attempt
          is made to append a second <IF::DocumentType> node
          <SRC::DOM3> where the <cfg::cfg|strict-document-children>
          configuration parameter is set to <DOM::true> <SRC::manakai>.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_SECOND_DOCTYPE
        @@@@enDesc:
          If the node is of type <IF::Document> and an attempt
          is made to append a second <IF::tx|DocumentType> node
          <SRC::DOM3> where the <cfg::cfg|strict-document-children>
          configuration parameter is set to <DOM::true> <SRC::manakai>.
      @@@dx:raises:
        @@@@@: c|HIERARCHY_WRONG_DOCTYPE_ERR
        @@@@enDesc:
          If the node is of type <IF::Document> and an attempt
          is made to append a <IF::tx|DocumentType> node after
          an <IF::Element> node where the <cfg::cfg|strict-document-children>
          configuration parameter is set to <DOM::true>.  <SRC::manakai>
        @@@@enImplNote:
          Although such document type node is not prohibited
          by DOM specification, Firefox 1.5 and Opera 9 TP1
          throws an <X::c|DOMException.HIERARCHY_REQUEST_ERR>.
      @@@dx:raises:
        @@@@@: c|DIFFERENT_DOCUMENT_ERR
        @@@@enDesc:
          If the <P::newChild> node was created from a different
          document than the one that created the node.
        @@@@enImplNote:
          The DOM specification ignores the fact that <IF::Document>s
          and <IF::tx|DocumentType>s are created from 
          <IF::c|DOMImplementation> :-)

          It allows a <IF::tx|DocumentType> node being added to
          the tree after a <IF::Document> is instantiated (see the
          DOM definition of <M::c|DOMImplementation.createDocumentType>).
          However, it does not define for appending methods
          to set the <A::Node.ownerDocument> attribute anywhere.
      @@@dx:raises: 
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the node is read-only.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_SRC_PARENT
        @@@@enDesc:
          If the previous parent of the <P::newChild> node is read-only.
          <SRC::DOM2 Errata, DOM3>
      @@@iRaises:
        @@@@@: t|REMOVE_DOCUMENT_TYPE_ERR
        @@@@enDesc:
          If the <P::newChild> node is a child of the <IF::Document> node
          and the DOM implementation does not support the removal
          of the <IF::tx|DocumentType> child. <SRC::DOM3>
      @@@iRaises:
        @@@@@: t|REMOVE_DOCUMENT_ELEMENT_ERR
        @@@@enDesc:
          If the <P::newChild> node is a child of the <IF::Document> node
          and the DOM implementation does not support the removal
          of the <IF::Element> child. <SRC::DOM3>
      @@@dx:raises:
        @@@@@: t|HIERARCHY_DOCUMENT_FRAGMENT_ITSELF_ERR
        @@@@enDesc:
          If <P::newChild> is the node itself.  <SRC::manakai>
      @@@PerlDef:
        ## TODO: Assertion
    
  @L13Method:
    @@Name: insertBefore
    @@enDesc:
      Inserts a node before the existing child node of the node.

      Inserting a node before itself is implementation dependent.
      <SRC::DOM3>
    @@Param:
      @@@Name: newChild
      @@@Type: Node
      @@@enDesc:
        The node to insert.  If the <P::newChild> is already in 
        the tree, it is first removed.
      @@@InCase:
        @@@@Type: DocumentFragment
        @@@@enDesc:
          All of children of the <P::newChild> node are inserted,
          in the same order, before <P::refChild>.
    @@Param:
      @@@Name: refChild
      @@@Type: Node
      @@@enDesc:
        The reference node, i.e. the node before which the new node
        must be inserted.
      @@@nullCase:
        @@@@enDesc:
          The <P::newChild> node is inserted at the end of the list
          of children.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node being inserted.
      @@@enImplNote:
        What is returned if <P::newChild> is a <IF::DocumentFragment>?
        See also <M::Node.appendChild>'s return value.
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_BAD_TYPE
        @@@@enDesc:
          If the node is of a type that does not allow children of
          the type of the <P::newChild> node.
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_ANCESTOR_OR_SELF
        @@@@enDesc:
          If the <P::newChild> node is one of the node's ancestor
          <SRC::DOM1, DOM2, DOM3> or the node itself <SRC::DOM2 Errata, DOM3>.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_SECOND_DOC_ELEMENT
        @@@@enDesc:
          If the node is of type <IF::Document> and an attempt
          is made to append a second <IF::tx|DocumentType> node
          <SRC::DOM3> where the <cfg::cfg|strict-document-children>
          configuration parameter is set to <DOM::true> <SRC::manakai>.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_SECOND_DOCTYPE
        @@@@enDesc:
          If the node is of type <IF::Document> and an attempt
          is made to append a second <IF::tx|DocumentType> node
          <SRC::DOM3> where the <cfg::cfg|strict-document-children>
          configuration parameter is set to <DOM::true> <SRC::manakai>.
      @@@dx:raises:
        @@@@@: c|HIERARCHY_WRONG_DOCTYPE_ERR
        @@@@enDesc:
          If the node is of type <IF::Document> and an attempt
          is made to append a <IF::tx|DocumentType> node after
          an <IF::Element> node where the <cfg::cfg|strict-document-children>
          configuration parameter is set to <DOM::true>.  <SRC::manakai>
        @@@@enImplNote:
          Although such document type node is not prohibited
          by DOM specification, Firefox 1.5 and Opera 9 TP1
          throws an <X::c|DOMException.HIERARCHY_REQUEST_ERR>.
      @@@dx:raises:
        @@@@@: c|DIFFERENT_DOCUMENT_ERR
        @@@@enDesc:
          If the <P::newChild> node was created from a different
          document than the one that created the node.
        @@@@enImplNote:
          The DOM specification ignores the fact that <IF::Document>s
          and <IF::tx|DocumentType>s are created from 
          <IF::c|DOMImplementation> :-)
      @@@dx:raises: 
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the node is read-only.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_SRC_PARENT
        @@@@enDesc:
          If the previous parent of the <P::newChild> node is read-only
          <SRC::DOM1SE, DOM2, DOM3>.
      @@@dx:raises:
        @@@@@: c|NOT_CHILD_ERR
        @@@@enDesc:
          If the <P::refChild> node is not a child of the node.
      @@@iRaises:
        @@@@@: t|REMOVE_DOCUMENT_TYPE_ERR
        @@@@enDesc:
          If the node is of type <IF::Document> and the DOM implementation
          does not support the insertion of a <IF::tx|DocumentType> child.
          <SRC::DOM3>
      @@@iRaises:
        @@@@@: t|REMOVE_DOCUMENT_ELEMENT_ERR
        @@@@enDesc:
          If the node is of type <IF::Document> and the DOM implementation
          does not support the insertion of a <IF::tx|Element> child.
          <SRC::DOM3>
      @@@iRaises:
        @@@@@: t|REMOVE_DOCUMENT_TYPE_ERR
        @@@@enDesc:
          If the <P::newChild> node is a child of the <IF::Document> node
          and the DOM implementation does not support the removal
          of the <IF::tx|DocumentType> child.  <SRC::manakai>
      @@@iRaises:
        @@@@@: t|REMOVE_DOCUMENT_ELEMENT_ERR
        @@@@enDesc:
          If the <P::newChild> node is a child of the <IF::Document> node
          and the DOM implementation does not support the removal
          of the <IF::Element> child.  <SRC::manakai>
      @@@dx:raises:
        @@@@@: t|HIERARCHY_DOCUMENT_FRAGMENT_ITSELF_ERR
        @@@@enDesc:
          If <P::newChild> is the node itself.  <SRC::manakai>
      @@@c:reports:
        @@@@@: t|insert-before-itself
        @@@@enDesc:
          If the <P::newChild> node is same as the <P::refChild> node.
          Then, the result is implementation dependent.
      @@@PerlDef:
        ## TODO: Assertion

       @@@L3Test:
         @@@@QName: Node.insertBefore.insert-before-itself.Test
         @@@@PerlDef:
           my $impl = <Class::c|ManakaiDOMImplementation>->_new;
           my $doc = $impl-><M::c|DOMImplementation.createDocument>
                              ('http://www.example/', 'ex');

           my $eh_called = false;

           my $del = $doc-><AG::Document.documentElement>;
           my $el = $doc-><M::Document.createElementNS>
                       ('http://www.example/', 'element');
           $del-><M::Node.appendChild> ($el);

           my $cfg = $doc-><AG::Document.domConfig>;
           $cfg-><M::c|DOMConfiguration.setParameter> ('error-handler' => sub {
             my (undef, $err) = @_;
             $eh_called = true;
             $test->assert_equals ($err-><AG::c|DOMError.severity>,
                                   <C::c|DOMError.SEVERITY_WARNING>);
             $test->assert_equals ($err-><AG::c|DOMError.type>,
                                   <Q::t|insert-before-itself>);
             $test->assert_equals ($err-><AG::c|DOMError.relatedData>, $el);
             $test->assert_null ($err-><AG::c|DOMError.relatedException>);
             $test->assert_isa ($err-><AG::c|DOMError.location>,
                                <IFName::c|DOMLocator>);
             $test->assert_not_null ($err-><AG::c|DOMError.message>);
           });

           $test->assert_false ($eh_called);
           $del-><M::Node.insertBefore> ($el, $el);
           $test->assert_true ($eh_called);

           $test->assert_equals ($del-><AG::Node.firstChild>, $el);

           $el = null;

    @@enImplNote:
      @@@ddid: mod
      @@@@:
        Modified in DOM Level 3.

  @L13Method:
    @@Name: replaceChild
    @@enDesc:
      Replaces a child node with another node.

      Replacing a node with itself is implementation dependent <SRC::DOM3>.
    @@Param:
      @@@Name: newChild
      @@@Type: Node
      @@@enDesc:
        The new node to put in the child list.

        If the <P::newChild> node is already in the tree,
        it is first removed.
      @@@InCase:
        @@@@Type: DocumentFragment
        @@@@enDesc:
          The <P::oldChild> node is replaced by all of the 
          <IF::DocumentFragment> children, which are inserted
          in the same order <SRC::DOM1SE, DOM2, DOM3>.
    @@Param:
      @@@Name: oldChild
      @@@Type: Node
      @@@enDesc:
        The node being replaced in the list.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node replaced.
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_BAD_TYPE
        @@@@enDesc:
          If the node is of a type that does not allow children of
          the type of the <P::newChild> node.
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_ANCESTOR_OR_SELF
        @@@@enDesc:
          If the <P::newChild> node is one of the node's ancestor
          <SRC::DOM1, DOM2, DOM3> or the node itself <SRC::DOM2 Errata, DOM3>.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_SECOND_DOC_ELEMENT
        @@@@enDesc:
          If the node is of type <IF::Document> and an attempt
          is made to append a second <IF::tx|DocumentType> node
          <SRC::DOM3> where the <cfg::cfg|strict-document-children>
          configuration parameter is set to <DOM::true> <SRC::manakai>.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_SECOND_DOCTYPE
        @@@@enDesc:
          If the node is of type <IF::Document> and an attempt
          is made to append a second <IF::tx|DocumentType> node
          <SRC::DOM3> where the <cfg::cfg|strict-document-children>
          configuration parameter is set to <DOM::true> <SRC::manakai>.
      @@@dx:raises:
        @@@@@: c|HIERARCHY_WRONG_DOCTYPE_ERR
        @@@@enDesc:
          If the node is of type <IF::Document> and an attempt
          is made to append a <IF::tx|DocumentType> node after
          an <IF::Element> node where the <cfg::cfg|strict-document-children>
          configuration parameter is set to <DOM::true>. <SRC::manakai>
        @@@@enImplNote:
          Although such document type node is not prohibited
          by DOM specification, Firefox 1.5 and Opera 9 TP1
          throws an <X::c|DOMException.HIERARCHY_REQUEST_ERR>.
      @@@dx:raises:
        @@@@@: c|DIFFERENT_DOCUMENT_ERR
        @@@@enDesc:
          If the <P::newChild> node was created from a different
          document than the one that created the node.
        @@@@enImplNote:
          The DOM specification ignores the fact that <IF::Document>s
          and <IF::tx|DocumentType>s are created from 
          <IF::c|DOMImplementation> :-)
      @@@dx:raises: 
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the node is read-only.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_SRC_PARENT
        @@@@enDesc:
          If the previous parent of the <P::newChild> node is read-only
          <SRC::DOM1SE, DOM2, DOM3>.
      @@@dx:raises:
        @@@@@: c|NOT_CHILD_ERR
        @@@@enDesc:
          If the <P::oldChild> node is not a child of the node.
      @@@iRaises:
        @@@@@: t|REMOVE_DOCUMENT_TYPE_ERR
        @@@@enDesc:
          If the node is of type <IF::Document> and the DOM implementation
          does not support the replacement of a <IF::tx|DocumentType> child
          <SRC::DOM3>.
      @@@iRaises:
        @@@@@: t|REMOVE_DOCUMENT_ELEMENT_ERR
        @@@@enDesc:
          If the node is of type <IF::Document> and the DOM implementation
          does not support the replacement of a <IF::tx|Element> child
          <SRC::DOM3>.
      @@@iRaises:
        @@@@@: t|REMOVE_DOCUMENT_TYPE_ERR
        @@@@enDesc:
          If the <P::newChild> node is a child of the <IF::Document> node
          and the DOM implementation does not support the removal
          of the <IF::tx|DocumentType> child.  <SRC::manakai>
      @@@iRaises:
        @@@@@: t|REMOVE_DOCUMENT_ELEMENT_ERR
        @@@@enDesc:
          If the <P::newChild> node is a child of the <IF::Document> node
          and the DOM implementation does not support the removal
          of the <IF::Element> child.  <SRC::manakai>
      @@@dx:raises:
        @@@@@: t|HIERARCHY_DOCUMENT_FRAGMENT_ITSELF_ERR
        @@@@enDesc:
          If <P::newChild> is the node itself.  <SRC::manakai>
      @@@c:reports:
        @@@@@: t|replaced-by-itself
        @@@@enDesc:
          If the <P::newChild> node is same as the <P::oldChild> node.
          Then, the result is implementation dependent.
      @@@PerlDef:
        ## TODO: Assertion

      @@@L3Test:
        @@@@QName: Node.replaceChild.replace-by-itself.Test
        @@@@PerlDef:
          my $impl;
          __CODE{tc|createImplForTest:: $impl => $impl}__;
          my $doc = $impl-><M::c|DOMImplementation.createDocument>
                              ('http://www.example/', 'ex');

           my $eh_called = false;

           my $del = $doc-><AG::Document.documentElement>;
           my $el = $doc-><M::Document.createElementNS>
                       ('http://www.example/', 'element');
           $del-><M::Node.appendChild> ($el);

           my $cfg = $doc-><AG::Document.domConfig>;
           $cfg-><M::c|DOMConfiguration.setParameter> ('error-handler' => sub {
             my (undef, $err) = @_;
             $eh_called = true;
             $test->assert_equals ($err-><AG::c|DOMError.severity>,
                                   <C::c|DOMError.SEVERITY_WARNING>);
             $test->assert_equals ($err-><AG::c|DOMError.type>,
                                   <Q::t|replace-by-itself>);
             $test->assert_equals ($err-><AG::c|DOMError.relatedData>, $el);
             $test->assert_null ($err-><AG::c|DOMError.relatedException>);
             $test->assert_isa ($err-><AG::c|DOMError.location>,
                                <IFName::c|DOMLocator>);
             $test->assert_not_null ($err-><AG::c|DOMError.message>);
           });

           $test->assert_false ($eh_called);
           $del-><M::Node.replaceChild> ($el, $el);
           $test->assert_true ($eh_called);

           $test->assert_equals ($del-><AG::Node.firstChild>, $el);

           $el = null;

      @@@enImplNote:
        Test for doctype/child::pi and attrdef/(text | entref)
        is included in <Module::MDOM|XDoctype> module.

    @@ResourceDef:
      @@@DISCore:resourceType:
        @@@@@: dis|MultipleResource
        @@@@ForCheck:
          ManakaiDOM|ForClass
          !tc|ForAppendChild !tc|ForInsertBefore !tc|ForReplaceChild
      @@@resourceFor: tc|ForAppendChild
      @@@resourceFor: tc|ForInsertBefore
      @@@resourceFor: tc|ForReplaceChild

      @@@QName:
        @@@@@: tc|appendChildImpl1
        @@@@ForCheck: tc|ForAppendChild
      @@@QName:
        @@@@@: tc|insertBeforeImpl1
        @@@@ForCheck: tc|ForInsertBefore
      @@@QName:
        @@@@@: tc|replaceChildImpl1
        @@@@ForCheck: tc|ForReplaceChild

      @@@DISCore:resourceType: DISPerl|BlockCode

      @@@enDesc:
        <Perl::$self>, <Perl::$newChild>, <Perl::$refChild> (insertBefore
        or replaceChild : <CODE::oldChild>),
        <Perl::$child_od>, <Perl::$child_nt>,
        <Perl::$r>, <Perl::$allowedNodeTypes>, <Perl::$self_od>.
  
      @@@PerlDef:
        __DEEP{
          my $strict = $self_od-><AG::Document.strictErrorChecking>;

          ## -- Node Type check
          my @new_child;
          if ($allowedNodeTypes->{$child_nt}) {
            push @new_child, $newChild;
          } elsif ($child_nt == <C::Node.DOCUMENT_FRAGMENT_NODE>) {
            for my $cn (@{$newChild-><AG::Node.childNodes>}) {
              unless ($allowedNodeTypes->{$cn-><AG::Node.nodeType>}) {
                __UNDEEP{__EXCEPTION{MDOMX|HIERARCHY_BAD_TYPE::
                  MDOMX|param-name => 'newChild',
                  c|node => {$newChild},
                }__}__;
              }
              push @new_child, $cn;
            }
          } else {
            __UNDEEP{__EXCEPTION{MDOMX|HIERARCHY_BAD_TYPE::
              MDOMX|param-name => 'newChild',
              c|node => {$newChild},
            }__}__;
          }

          my $nc_parent = @new_child ? $new_child[0]-><AG::Node.parentNode>
                                     : null;
          if ($strict) {
            ## -- Wrong-document check
            unless ($self_od eq $child_od) {
              __UNDEEP{__EXCEPTION{c|DIFFERENT_DOCUMENT_ERR::
                MDOMX|param-name => 'newChild',
                c|node => {$newChild},
              }__}__;
            }

            ## -- Read-onlyness check
            if ($self-><AG::Node.manakaiReadOnly>) {
              __UNDEEP{__EXCEPTION{MDOMX|NOMOD_THIS::
              }__}__;
            }
            if (@new_child) {
              if ($nc_parent and
                  $nc_parent-><AG::Node.manakaiReadOnly>) {
                __UNDEEP{__EXCEPTION{MDOMX|NOMOD_SRC_PARENT::
                }__}__;
              }
            }
          }

          ## -- Insert at...
          my $index = -1; # last
          __FOR{!tc:ForAppendChild:: # tc:ForAppendChild & tc:ForReplaceChild
            if (defined $refChild) {
              if ($refChild eq $newChild) {
                __FOR{tc:ForInsertBefore::
                  __UNDEEP{__c|ERROR{t|insert-before-itself::
                    c|relatedData => {$refChild},
                  }__}__;
                }__;
                __FOR{tc:ForReplaceChild::
                  __UNDEEP{__c|ERROR{t|replace-by-itself::
                    c|relatedData => {$refChild},
                  }__}__;
                }__;
              }

              my $cns = $self-><AG::Node.childNodes>;
              my $cnsl = @$cns;
              C: {
                $index = 0;
                for my $i (0..($cnsl-1)) {
                  my $cn = $cns->[$i];
                  if ($cn eq $refChild) {
                    $index += $i;
                    last C;
                  } elsif ($cn eq $newChild) {
                    $index = -1; # offset
                  }
                }
                __FOR{tc:ForInsertBefore::
                  __UNDEEP{__EXCEPTION{c|NOT_CHILD_ERR::
                    MDOMX|param-name => 'refChild',
                    c|node => {$refChild},
                  }__}__;
                }__;
                __FOR{tc:ForReplaceChild::
                  __UNDEEP{__EXCEPTION{c|NOT_CHILD_ERR::
                    MDOMX|param-name => 'oldChild',
                    c|node => {$refChild},
                  }__}__;
                }__;
              } # C
            } else { # |oldChild| is not defined
              __FOR{tc:ForReplaceChild::
                __UNDEEP{__EXCEPTION{c|NOT_CHILD_ERR::
                  MDOMX|param-name => 'oldChild',
                  c|node => {$refChild},
                }__}__;
              }__;
            }
          }__; # FOR !tc:ForAppendChild

          ## -- Removes from parent
          if ($nc_parent) {
            if ($child_nt == <C::Node.DOCUMENT_FRAGMENT_NODE>) {
              __CODE{mg|setNodeStemPropValue||ManakaiDOM|all::
                $given => {[]},
                $prop => {<H::infoset|children>},
                $ref => $newChild,
              }__;
            } else {
              my $v;
              __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
                $r => $v,
                $prop => {<H::infoset|children>},
                $ref => $nc_parent,
              }__;
              RP: for my $i (0..$#$v) {
                my $nodeid = $v->[$i];
                if (<Code::mg|nodeIDMatch||ManakaiDOM|all::
                        $noderef = {$new_child[0]},
                        $nodeid = $nodeid>) {
                  splice @$v, $i, 1, ();
                  last RP;
                }
              } # RP
            }
          }

          ## -- Rewrite the |parentNode| properties
          for my $nc (@new_child) {
            __CODE{mg|setNodeStemProp0Node||ManakaiDOM|all::
              $prop => {<H::infoset|parent>},
              $ref => $nc,
              $given => $self,
            }__;
          }

          my $children;
          __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
            $r => $children,
            $prop => {<H::infoset|children>},
            $ref => $self,
          }__;

          __FOR{tc:ForAppendChild::
            ## -- Adds to children list
            push @$children, map {
              <Code::mg|getNodeID||ManakaiDOM|all:: $ref = $_>
            } @new_child;
            $r = $newChild;
          }__;

          __FOR{tc:ForInsertBefore::
            ## -- Adds to children list
            if ($index == -1) {
              push @$children, map {
                <Code::mg|getNodeID||ManakaiDOM|all:: $ref = $_>
              } @new_child;
            } else {
              splice @$children, $index, 0, map {
                <Code::mg|getNodeID||ManakaiDOM|all:: $ref = $_>
              } @new_child;
            }
            $r = $newChild;
          }__;

          __FOR{tc:ForReplaceChild::
            ## -- Replaces the node
            splice @$children, $index, 1, map {
              <Code::mg|getNodeID||ManakaiDOM|all:: $ref = $_>
            } @new_child;
            __CODE{mg|deleteNodeStemPropValue||ManakaiDOM|all::
              $prop => {<H::infoset|parent>},
              $ref => $refChild,
            }__;
            $r = $refChild;
          }__;
        }__;

  @LXMethod:
    @@Name: manakaiAppendText
    @@enDesc:
      For manakai's Perl binding, the <Perl::.=> operator on
      a <IF::Node> object appends a string to the text content
      of the node.

      If the node is a <IF::DocumentFragment>, <IF::tx|EntityReference>, 
      <IF::Element>, <IF::Attr>, <IF::tx|Entity>, or
      <IF::d|AttributeDefinition> node, then the string
      is appended to the end of the text content of the node.  That is,
      if the last child node, if any, is a <IF::Text>, then its 
      <A::CharacterData.data> is extended by inserting the string
      at the end of it.  Otherwise, a new <IF::Text> node whose
      <A::CharacterData.data> is set to the string is inserted
      at the end of the child list of the node.

      If the node is a <IF::Document> and the <cfg::cfg|strict-document-children>
      configuration parameter is set to <DOM::false>, then the string
      is appended as if it were a <IF::DocumentFragment> node.  Otherwise,
      the operation has no effect.

      If the node is a <IF::tx|ProcessingInstruction>, <IF::Comment>,
      <IF::Text>, or <IF::CDATASection> node, then the string
      is appended to its <A::Node.textContent> value.

      For other types of nodes, the operation has no effect.
    @@enImplNote:
      {ISSUE::
        It would be nice if the <Perl::.=> operator is overloaded
        by this method.  However, it makes perl unstable and causes
        segmentation fault at least in Perl 5.8.1 and 5.8.7 on Linux.
      }
    @@Param:
      @@@Name: string
      @@@Type: DOMString
      @@@enDesc:
        The string to append.
      @@@InCase:
        @@@@Type: DISPerl|SCALAR||ManakaiDOM|all
        @@@@enDesc:
          A copy of the string value referenced from the value
          is appended.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node itself.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the node to insert the string or a <IF::Text> node
          is read-only.
      @@@PerlDef:
        $r = $self;

  @L13Method:
    @@Name: removeChild
    @@enDesc:
      Removes a child node from the list of children of the node
      and returns it.
    @@Param:
      @@@Name: oldChild
      @@@Type: Node
      @@@enDesc:
        The node to remove.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node removed.
      @@@NodeReadOnlyError:
      @@@dx:raises:
        @@@@@: c|NOT_CHILD_ERR
        @@@@enDesc:
          If the <P::oldChild> is not a child of the node.
      @@@iRaises:
        @@@@@: t|REMOVE_DOCUMENT_TYPE_ERR
        @@@@enDesc:
          If the node is a <IF::Document> and the implementation
          does not support the removal of the <IF::tx|DocumentType>
          child.  <SRC::DOM3>
      @@@iRaises:
        @@@@@: t|REMOVE_DOCUMENT_ELEMENT_ERR
        @@@@enDesc:
          If the node is a <IF::Document> and the implementation
          does not support the removal of the <IF::Element>
          child.  <SRC::DOM3>
      @@@PerlDef:
        if ($self-><AG::Node.ownerDocument>
                 -><AG::Document.strictErrorChecking> and
            $self-><AG::Node.manakaiReadOnly>) {
          __EXCEPTION{MDOMX|NOMOD_THIS::
          }__;
        }
        __CODE{tc|removeChildImpl}__;

    @@CODE:
      @@@QName: tc|removeChildImpl
      @@@PerlDef:
          F: {
            my $i = -1;
            for my $cld (@{$self-><AG::Node.childNodes>}) {
              $i++;
              if ($cld eq $oldChild) {
                my $v;
                __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
                  $r => $v,
                  $prop => {<H::infoset|children>},
                  $ref => $self,
                }__;
                splice @$v, $i, 1, ();
                __CODE{mg|deleteNodeStemPropValue||ManakaiDOM|all::
                  $prop => {<H::infoset|parent>},
                  $ref => $oldChild,
                }__;
                $r = $oldChild;
                last F;
              }
            }
            __EXCEPTION{c|NOT_CHILD_ERR::
              MDOMX|param-name => 'oldChild',
              c|node => {$oldChild},
            }__;
          } # F

    @@Test:
      @@@QName: Node.removeChild.1.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        my $doc = $el-><AG::Node.ownerDocument>;

        my $c1 = $doc-><M::Document.createElementNS> (null, 'e');
        $el-><M::Node.appendChild> ($c1);

        my $c2 = $doc-><M::Document.createElementNS> (null, 'f');
        $el-><M::Node.appendChild> ($c2);

        my $c3 = $doc-><M::Document.createElementNS> (null, 'g');
        $el-><M::Node.appendChild> ($c3);

        my $return = $el-><M::Node.removeChild> ($c1);

        $test->id ('return');
        $test->assert_equals ($return, $c1);

        $test->id ('parentNode');
        $test->assert_null ($c1-><AG::Node.parentNode>);

        $test->id ('firstChild');
        $test->assert_equals ($el-><AG::Node.firstChild>, $c2);

        $test->id ('lastChild');
        $test->assert_equals ($el-><AG::Node.lastChild>, $c3);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$el-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: Node.removeChild.2.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        my $doc = $el-><AG::Node.ownerDocument>;

        my $c1 = $doc-><M::Document.createElementNS> (null, 'e');
        $el-><M::Node.appendChild> ($c1);

        my $c2 = $doc-><M::Document.createElementNS> (null, 'f');
        $el-><M::Node.appendChild> ($c2);

        my $c3 = $doc-><M::Document.createElementNS> (null, 'g');
        $el-><M::Node.appendChild> ($c3);

        my $return = $el-><M::Node.removeChild> ($c2);

        $test->id ('return');
        $test->assert_equals ($return, $c2);

        $test->id ('parentNode');
        $test->assert_null ($c2-><AG::Node.parentNode>);

        $test->id ('firstChild');
        $test->assert_equals ($el-><AG::Node.firstChild>, $c1);

        $test->id ('lastChild');
        $test->assert_equals ($el-><AG::Node.lastChild>, $c3);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$el-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: Node.removeChild.3.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        my $doc = $el-><AG::Node.ownerDocument>;

        my $c1 = $doc-><M::Document.createElementNS> (null, 'e');
        $el-><M::Node.appendChild> ($c1);

        my $c2 = $doc-><M::Document.createElementNS> (null, 'f');
        $el-><M::Node.appendChild> ($c2);

        my $c3 = $doc-><M::Document.createElementNS> (null, 'g');
        $el-><M::Node.appendChild> ($c3);

        my $return = $el-><M::Node.removeChild> ($c3);

        $test->id ('return');
        $test->assert_equals ($return, $c3);

        $test->id ('parentNode');
        $test->assert_null ($c3-><AG::Node.parentNode>);

        $test->id ('firstChild');
        $test->assert_equals ($el-><AG::Node.firstChild>, $c1);

        $test->id ('lastChild');
        $test->assert_equals ($el-><AG::Node.lastChild>, $c2);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$el-><AG::Node.childNodes>},
                  expected_value => 2);

    @@Test:
      @@@QName: Node.removeChild.4.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        my $doc = $el-><AG::Node.ownerDocument>;

        my $c1 = $doc-><M::Document.createElementNS> (null, 'e');
        $el-><M::Node.appendChild> ($c1);

        my $return = $el-><M::Node.removeChild> ($c1);

        $test->id ('return');
        $test->assert_equals ($return, $c1);

        $test->id ('parentNode');
        $test->assert_null ($c1-><AG::Node.parentNode>);

        $test->id ('firstChild');
        $test->assert_null ($el-><AG::Node.firstChild>);

        $test->id ('lastChild');
        $test->assert_null ($el-><AG::Node.lastChild>);

        $test->id ('length');
        $test->assert_num_equals
                 (actual_value => 0+@{$el-><AG::Node.childNodes>},
                  expected_value => 0);

  @Attr:
    @@Name: attributes
    @@enDesc:
      A named node map containing the attributes of the node.
    @@Type: NamedNodeMap
    @@Get:
      @@@enDesc:
        A <IF::NamedNodeMap> containing the attribute nodes,
        if the node is an <IF::Element>.
      @@@nullCase:
        @@@@enDesc:
          If the node is not an <IF::Element>.
      @@@PerlDef: \

    @@Test:
      @@@QName: Node.attributes.test
      @@@enDesc:
        Other than <IF::Element>.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        for my $node (
          $doc-><M::Document.createAttribute> ('a'),
          $docx-><M::d|DocumentXDoctype.createAttributeDefinition> ('at'),
          $doc-><M::Document.createCDATASection> ('cs'),
          $doc-><M::Document.createComment> ('c'),
          $doc,
          $doc-><M::Document.createDocumentFragment>,
          $docx-><M::d|DocumentXDoctype.createDocumentTypeDefinition> ('d'),
          $docx-><M::d|DocumentXDoctype.createGeneralEntity> ('ge'),
          # |Element|
          $docx-><M::d|DocumentXDoctype.createElementTypeDefinition> ('et'),
          $doc-><M::Document.createEntityReference> ('er'),
          $docx-><M::d|DocumentXDoctype.createNotation> ('not'),
          $doc-><M::Document.createProcessingInstruction> ('pi'),
          $doc-><M::Document.createTextNode> ('text'),
          #test:nodeTypes
        ) {
          $test->id ($node-><AG::Node.nodeType>);
          $test->assert_null ($node-><AG::Node.attributes>);
        }

  @Attr:
    @@Name: nodeName
    @@enDesc:
      The name of the node.

      - <IF::Attr>::: The name of the attribute.  <SRC::DOM1, DOM2>
                      Same as <A::Attr.name>. <SRC::DOM3>

      - <IF::d|AttributeDefinition>::: The attribute name. <SRC::manakai>
 
      - <IF::tx|CDATASection>::: <DOM::#cdata-section>.

      - <IF::Comment>::: <DOM::#comment>.

      - <IF::Document>::: <DOM::#document>.

      - <IF::DocumentFragment>::: <DOM::#document-fragment>.

      - <IF::tx|DocumentType>::: The document type name.  <SRC::DOM1, DOM2>
            Same as <A::tx|DocumentType.name>.  <SRC::DOM3>

      - <IF::Element>::: The tag name of the element.  <SRC::DOM1, DOM2>
                         Same as <A::Element.tagName>.  <SRC::DOM3>

      - <IF::d|ElementTypeDefinition>::: The element type name. <SRC::manakai>

      - <IF::tx|Entity>::: The entity name.

      - <IF::tx|EntityReference>::: The entity name.

      - <IF::tx|Notation>::: The notation name.

      - <IF::tx|ProcessingInstruction>::: The target of the 
            processing instruction.  <SRC::DOM1, DOM2>  Same as 
            <A::tx|ProcessingInstruction.target>.  <SRC::DOM3>

      - <IF::tx|Text>::: <DOM::#text>.
    @@DOMMain:isNamespaceUnaware:1
    @@Type: DOMString
    @@Get:
      @@@PerlDef:
        ## TODO: Assertion

  @Attr:
    @@Name: nodeValue
    @@enDesc:
      The value of the node.

      - <IF::Attr>::: The value of the attribute.  <SRC::DOM1, DOM2>
            Same as <IF::Attr.value>.  <SRC::DOM3>

      - <IF::ATDef>::: The normalized default value. <SRC::manakai>

      - <IF::tx|CDATASection>::: The content of the <XML::CDATA> section.
            <SRC::DOM1, DOM2, DOM3>  Same as <A::CharacterData.data>.
            <SRC::DOM3>

      - <IF::Comment>::: The content of the comment.  <SRC::DOM1, DOM2, DOM3>
            Same as <A::CharacterData.data>.  <SRC::DOM3>

      - <IF::Document>, <IF::DocumentFragment>, <IF::tx|DocumentType>,
        <IF::Element>, <IF::ETDef>, <IF::tx|Entity>, <IF::tx|EntityReference>,
        <IF::tx|Notation>::: <DOM::null>.
   
      - <IF::tx|ProcessingInstruction>::: The entire content excluding
            the target.  <SRC::DOM1, DOM2>  Same as
            <IF::tx|ProcessingInstruction.data>.  <SRC::DOM3>

      - <IF::Text>:::The content of the text node.  <SRC::DOM1, DOM2, DOM3>
            Same as <A::CharacterData.data>.  <SRC::DOM3>
    @@Type: DOMString
    @@Get:
      @@@enDesc:
        {LI:: <IF::ATDef>:::
          The concatenation of the text content of every
          child node.  For <IF::Text> children, the
          text content of a node is the <A::Node.textContent>
          attribute value.  For <IF::tx|EntityReference>
          children, the text content of a node is the
          <A::Node.textContent> attribute value with
          any <CODE::U+0009>, <CODE::U+000A>, and
          <CODE::U+000D> replaced by <CODE::U+0020>.
        
          If the <A::ATDef.declaredType>
          of the node is different from 
          <C::ATDef.NO_TYPE_ATTR>,
          <C::ATDef.UNKNOWN_ATTR>, or
          <C::ATDef,CDATA_ATTR>, the value
          is further modified by discarding any leading
          and trailing <CODE::U+0020> characters and
          by replacing sequences of <CODE::U+0020> characters
          by a single <CODE::U+0020> character.  <SRC::manakai>
        }
      @@@nullCase:
        @@@@enDesc:
          If the node is a <C::Node.ATTRIBUTE_TYPE_DEFINITION_NODE> and
          the <A::ATDef.defaultType> is different from
          <C::ATDef.FIXED_DEFAULT> or <C::ATDef.EXPLICIT_DEFAULT>.
          <SRC::manakai>
      @@@iRaises:
        @@@@@: c|DOMSTRING_SIZE_ERR
        @@@@enDesc:
          When it would return more characters than fit in a
          <IF::DOMString> variable on the implementation platform.
      @@@PerlDef:
        $r = null;
    @@Set:
      @@@enDesc:
        If the attribute value is defined to be <DOM::null>,
        setting it has no effect, including if the node is read-only.
        <SRC::DOM2 Errata, DOM3>

        {LI:: <IF::ATDef>:::
          Any children are removed and if the new value
          is not empty or <DOM::null>, replaced by a single
          <IF::Text> node containgin the value the
          attribute is set to.
        
          If the <A::ATDef.defaultType>
          is different from <C::ATDef.FIXED_DEFAULT>
          or <C::ATDef.EXPLICIT_DEFAULT>, however,
          setting the attribute has no effect.  <SRC::manakai>
        }
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          When the node is read-only and if the attribute value is not defined
          to be <DOM::null>.
       @@@c:reports:
         @@@@@: c|setting-node-value-no-effect
         @@@@enDesc:
           Setting the attribute value has no effect, since the
           node value is defined as <DOM::null>.
       @@@PerlDef:
         __c|ERROR{t|setting-node-value-no-effect::
           c|relatedData => {$self},
         }__;

    @@XDTest:
      @@@QName: Node.nodeValue.null.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestNoErr:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        for my $node (
          # |Attr|
          # |AttributeDefinition|
          # |CDATASection|
          # |Comment|
          $doc,
          $doc-><M::Document.createDocumentFragment>,
          $docx-><M::d|DocumentXDoctype.createDocumentTypeDefinition> ('d'),
          $docx-><M::d|DocumentXDoctype.createGeneralEntity> ('gent'),
          $doc-><M::Document.createElement> ('e'),
          $docx-><M::d|DocumentXDoctype.createElementTypeDefinition> ('et'),
          $doc-><M::Document.createEntityReference> ('er'),
          $docx-><M::d|DocumentXDoctype.createNotation> ('not'),
          # |ProcessingInstruction|
          # |Text|
          #test:nodeTypes
        ) {
          $test->id ('get.'.$node-><AG::Node.nodeType>);
          $test->assert_null ($node-><AG::Node.nodeValue>);

          $node-><M::Node.manakaiSetReadOnly> (false);

          $test->id ('set.'.$node-><AG::Node.nodeType>);
          $node-><AS::Node.nodeValue> ('node-value');
          $test->assert_null ($node-><AG::Node.nodeValue>);

          $node-><M::Node.manakaiSetReadOnly> (true);

          $test->id ('roset.'.$node-><AG::Node.nodeType>);
          $node-><AS::Node.nodeValue> ('node-value');
          $test->assert_null ($node-><AG::Node.nodeValue>);
        }

     @@L3Test:
       @@@QName: Node.nodeValue.Set.null.noEffect.Test
       @@@enDesc:
           This test ensures that attempts to set <A::Node.nodeValue>
           of <IF::Element> or <IF::Document> node never change its value
           and warnings are reported.

             {NOTE:: This test is restricted to DOM Level 3 or higher,
                     since the <IF::c|DOMError> interface is introduced
                     in that level of DOM.
             }
       @@@PerlDef:
           my $impl = <Class::c|ManakaiDOMImplementation>->_new;
           my $doc = $impl-><M::c|DOMImplementation.createDocument>
                              ('http://www.example/', 'ex');

           my $eh_called = 0;
           my $current_node;

           my $cfg = $doc-><AG::Document.domConfig>;
           $cfg-><M::c|DOMConfiguration.setParameter> ('error-handler' => sub {
             my (undef, $err) = @_;
             $eh_called++;
             $test->assert_equals ($err-><AG::c|DOMError.severity>,
                                   <C::c|DOMError.SEVERITY_WARNING>);
             $test->assert_equals ($err-><AG::c|DOMError.type>,
                                   <Q::t|setting-node-value-no-effect>);
             $test->assert_equals ($err-><AG::c|DOMError.relatedData>,
                                   $current_node);
             $test->assert_null ($err-><AG::c|DOMError.relatedException>);
             $test->assert_isa ($err-><AG::c|DOMError.location>,
                                <IFName::c|DOMLocator>);
             $test->assert_not_null ($err-><AG::c|DOMError.message>);
           });

           my $del = $doc-><AG::Document.documentElement>;
           $current_node = $del;
           $del-><AS::Node.nodeValue> ('non-null value');

           $test->assert_null ($del-><AG::Node.nodeValue>);
           $test->assert_equals ($eh_called, 1);

           $current_node = $doc;
           $doc-><AS::Node.nodeValue> ('non-null value');
            
           $test->assert_equals ($doc-><AG::Node.nodeValue>);
           $test->assert_equals ($eh_called, 2);

           $current_node = null;

  @L3Attr:
    @@Name: textContent
    @@enDesc:
      The text content of the node and its descendants.
    @@Type: DOMString
    @@Get:
      @@@enDesc:
        The text content of the node.  No serialization is performed
        and the returned string does not contain any markup.  No
        white space normalization is performed.

        - <IF::Attr>, <IF::ATDef>, <IF::Element>, <IF::tx|Entity>,
          <IF::tx|EntityReference>, <IF::DocumentFragment>:::
              Concatenetion of the <A::Node.textContent> value
              of every child node, excluding <IF::Comment> and
              <IF::tx|ProcessingInstruction> nodes.  This is the
              empty string if the node has no children.  Returned
              string does not contain the white spaces in element
              content (<A::Node.isElementContentWhitespace>).

        - <IF::tx|CDATASection>, <IF::Comment>, <IF::tx|ProcessingInstruction>,
              <IF::Text>::: <A::Node.nodeValue>.

        - <IF::tx|DocumentType>, <IF::ETDef>,
              <IF::tx|Notation>::: <DOM::null>.

        - <IF::Document>::: <DOM::null>. <SRC::DOM3>  However,
              if the <cfg::cfg|strict-document-children> configuration
              parameter is set to <DOM::false>, then the attribute
              value is the concatenation of the <A::Node.textContent>
              value of every child node, excluding <IF::tx|DocumentType>,
              <IF::Comment>, and <IF::tx|ProcessingInstruction> nodes and
              <IF::Text> nodes whose <A::Node.isElementContentWhitespace>
              attribute value is <DOM::true>.  <SRC::manakai>
      @@@nullCase:
        @@@@enDesc:
          If the type of the node is <IF::Document>, <IF::tx|DocumentType>,
          <IF::ETDef>, or <IF::tx|Notation>.
      @@@iRaises:
        @@@@@: c|DOMSTRING_SIZE_ERR
        @@@@enDesc:
          When it would return more characters than fit in a <IF::DOMString>
          variable on the implementation platform.
      @@@PerlDef:
        __DEEP{
          $r = '';
          my @target = @{$self-><AG::Node.childNodes>};
          C: for my $node (@target) {
            my $nt = $node-><AG::Node.nodeType>;
            if ($nt == <C::Node.TEXT_NODE> or
                $nt == <C::Node.CDATA_SECTION_NODE>) {
              $r .= $node-><AG::CharacterData.data>
                unless $node-><AG::Text.isElementContentWhitespace>;
            } elsif ($nt == <C::Node.ELEMENT_NODE> or
                     $nt == <C::Node.ENTITY_REFERENCE_NODE>) {
              unshift @target, @{$node-><AG::Node.childNodes>};
            }
          }
        }__;
    @@Set:
      @@@enDesc:
        Any possible children the node may have are removed and
        if the new string is not empty or <DOM::null>, it is replaced
        by a single <IF::Text> node containing the string the
        attribute is set to.  No parsing is performed and the
        input string is taken as pure textual content.

        If the attribute value is defined to be <DOM::null>,
        setting it has no effect.

        If it is a <IF::Document> node and the 
        <cfg::cfg|strict-document-children> configuration parameter
        is set to <DOM::false>, then any possible children the
        node may have are removed and if the new string is not
        empty or <DOM::null>, it is replaced by a single
        <IF::Text> node containing the string the attribute is 
        set to.  No parsing is performed and the input string is
        taken as pure textual content.  <SRC::manakai>

        If it is an <IF::d|ElementTypeDefinition> node, then
        setting the attribute has no effect, including if
        the node is read-only.  <SRC::manakai>

        If it is an <IF::d|AttributeDefinition> node, then
        any possible children the node may have are removed and
        if the new string is not empty or <DOM::null>, it is
        replaced by a single <IF::Text> node containing
        the string the attribute is set to.  No parsing or
        white space normalization is performed and the input
        string is taken as pure textual content.  However,
        the implementation <kwd:MAY> normalize the attribute
        value according to the schemas in use or their builtin
        knowledge as in <IF::Attr> (see <sw010:csection::Interface
        <CODE::Attr>> in DOM Level 3 Core specification).  <SRC::manakai>
      @@@nullCase:
        @@@@enDesc:
          All children are removed.
      @@@NodeReadOnlyError:
      @@@PerlDef:
        __CODE{tc|setNodeTextContent::
          $node => $self,
          $given => $given,
          $ownerDocument => {$self-><AG::Node.ownerDocument>},
        }__;

    @@Test:
      @@@QName: Node.textContent.1.test
      @@@enDesc:
        Defined as <DOM::null>.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestNoErr:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        $doc-><AG::Document.domConfig>
            -><M::c|DOMConfiguration.setParameter>
                (<Q::cfg|strict-document-children> => true);

        for my $node (
          $docx-><M::DocumentX.createDocumentTypeDefinition> ('dt1'),
          $docx-><M::DocumentX.createElementTypeDefinition> ('et1'),
          $docx-><M::DocumentX.createNotation> ('nt1'),
          $doc-><AG::Document.implementation>
              -><M::c|DOMImplementation.createDocumentType> ('dt2'),
          $doc,
        ) {
          $test->id ($node-><AG::Node.nodeName>.'.get');
          $test->assert_null ($node-><AG::Node.textContent>);

          $test->id ($node-><AG::Node.nodeName>.'.set');
          $node-><AS::Node.textContent> ('new-text-content');
          $test->assert_null ($node-><AG::Node.textContent>);

          $test->id ($node-><AG::Node.nodeName>.'.set.ro');
          $node-><M::Node.manakaiSetReadOnly> (true);
          $node-><AS::Node.textContent> ('new-text-content');
          $test->assert_null ($node-><AG::Node.textContent>);
        }

    @@Test:
      @@@QName: Node.textContent.2.test
      @@@enDesc:
        Defined as concateneation.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTestNoErr:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        $doc-><AG::Document.domConfig>
            -><M::c|DOMConfiguration.setParameter>
                (<Q::cfg|strict-document-children> => false);

        for my $node (
          $doc,
          $doc-><M::Document.createElement> ('e'),
          $doc-><M::Document.createAttribute> ('a'),
          $docx-><M::DocumentX.createGeneralEntity> ('ge'),
          $doc-><M::Document.createEntityReference> ('er'),
          $doc-><M::Document.createDocumentFragment>,
          $docx-><M::DocumentX.createAttributeDefinition> ('at'),
          #test:nodeTypes
        ) {
          $test->id ('empty');
          $test->assert_equals ($node-><AG::Node.textContent>, '');

          $node-><M::Node.manakaiSetReadOnly> (false);
          $node-><AS::Node.textContent> ('text1');

          $test->id ('set.textContent');
          $test->assert_equals ($node-><AG::Node.textContent>, 'text1');
          
          $test->id ('set.childNodes.length');
          $test->assert_num_equals
                   (actual_value => 0+@{$node-><AG::Node.childNodes>},
                    expected_value => 1);

          $node-><AS::Node.textContent> ('');

          $test->id ('empty.textContent');
          $test->assert_equals ($node-><AG::Node.textContent>, '');
          
          $test->id ('empty.childNodes.length');
          $test->assert_num_equals
                   (actual_value => 0+@{$node-><AG::Node.childNodes>},
                    expected_value => 0);

          $node-><AS::Node.textContent> ('text2');
          $node-><AS::Node.textContent> (null);

          $test->id ('null.textContent');
          $test->assert_equals ($node-><AG::Node.textContent>, '');
          
          $test->id ('null.childNodes.length');
          $test->assert_num_equals
                   (actual_value => 0+@{$node-><AG::Node.childNodes>},
                    expected_value => 0);

          $test->id ('ro.set');
          $node-><AS::Node.textContent> ('text4');
          $node-><M::Node.manakaiSetReadOnly> (true);
          $test->assert_exception (code => sub {
            $node-><AS::Node.textContent> ('text3');
          }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);
          $test->assert_equals ($node-><AG::Node.textContent>, 'text4');
        }

  @ResourceDef:
    @@QName: tc|setNodeTextContent
    @@rdf:type: DISPerl|BlockCode
    @@Description:
      @@@lang:en
      @@@@:
        Sets a string as the text content of a node.
    @@ForCheck:
      ManakaiDOM:ForClass
    @@PerlDef:
      __CODE{tc|NodeReadOnlyError:: $node => $node}__;
 
      my @__old_children = @{$node-><AG::Node.childNodes>};
      for my $__old_child (@__old_children) {
        __CODE{mg|deleteNodeStemPropValue||ManakaiDOM|all::
          $prop => {<H::infoset|parent>},
          $ref => $__old_child,
        }__;
      }

      my @__new_children;
      if (defined $given and length $given) {
        my $__text = $ownerDocument-><M::Document.createTextNode> ($given);
        push @__new_children, <Code::mg|getNodeID||ManakaiDOM|all::
                                       $ref = $__text>;
        __CODE{mg|setNodeStemProp0Node||ManakaiDOM|all::
          $prop => {<H::infoset|parent>},
          $ref => $__text,
          $given => $node,
        }__;
      }

      __CODE{mg|setNodeStemPropValue||ManakaiDOM|all::
        $given => {\@__new_children},
        $prop => {<H::infoset|children>},
        $ref => $node,
      }__;

  @L3Bitmasks:
    @@QName: DocumentPosition

     @@Description:
       @@@lang:en
       @@@@:
         A bitmask indicating the relative document position of a node 
         with respect to another node.

     @@Const:
        @@@Name:  DOCUMENT_POSITION_DISCONNECTED
        @@@intValue:  0x01
        @@@Description:
          @@@@lang:en
          @@@@@:
            The two nodes are disconnected.  Order between disconnected nodes 
            is always implementation-specific.
     @@Const:
        @@@Name:  DOCUMENT_POSITION_PRECEDING
        @@@intValue:  0x02
        @@@Description:
          @@@@lang:en
          @@@@@:
            The node precedes the reference node.
     @@Const:
        @@@Name:  DOCUMENT_POSITION_FOLLOWING
        @@@intValue:  0x04
        @@@Description:
          @@@@lang:en
          @@@@@: The node fllows the reference node.
     @@Const:
        @@@Name:  DOCUMENT_POSITION_CONTAINS
        @@@intValue:  0x08
        @@@Description: 
          @@@@lang:en
          @@@@@:
            The node contains the reference node.  A node that 
            contains is always preceding, too.
     @@Const:
        @@@Name:  DOCUMENT_POSITION_CONTAINED_BY
        @@@intValue:  0x10
        @@@Description:
          @@@@lang:en
          @@@@@:
            The node is contained by the reference node. 
            A node that is contained is always following, too.
     @@Const:
        @@@Name:  DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC
        @@@intValue:  0x20
        @@@Description:
          @@@@lang:en
          @@@@@:
            The determination of preceding versus following is 
            implementation-specific.

  @Method:
    @@Name: cloneNode
    @@DISCore:resourceType: DISLang|Constructor
    @@Operator: DISPerl|CloneMethod
    @@enDesc:
      Returns a duplicate of the node, i.e. serves as a generic
      copy constructor for nodes.

      - The duplicate node has no parent, i.e. <A::Node.parentNode>
        is <DOM::null>.  <SRC::DOM1, DOM2, DOM3>

      - The duplicate node has no user data, i.e. user data 
        associated to the node is not carried over.  However,
        if any <IF::c|UserDataHandlers> has been specified along with
        the associated data, those handlers will be called with
        the appropriate parameters before the method returns.  <SRC::DOM3>

      - If the node is an <IF::Element>, all attributes and their values,
        including those representing defaulted attributes (i.e.
        attributes whose <A::Attr.specified> are <DOM::false>),
        but the method does not copy any children it contains
        unless it is a deep clone (i.e. <P::deep> is <DOM::true>).
        <SRC::DOM1, DOM2, DOM3>

      - Cloning an <IF::Attr> directly, as oppsed to be cloned
        as part of an <IF::Element> cloning operation, returns
        a specified attribute (i.e. its <A::Attr.specified> is
        set to <DOM::true>).  <SRC::DOM1, DOM2, DOM3>

      - Cloning an <IF::Attr> always clones its children, since 
        they represent its value, no matter whether this is a 
        deep clone or not.  <SRC::DOM3>

      - Cloning an <IF::tx|EntityReference> automatically constructs
        its subtree if a corresponding <IF::tx|Entity> is available,  
        no matter whether this is a deep clone or not.  <SRC::DOM3>

      - Cloning any other type of node simply returns a copy of the node.
        <SRC::DOM1, DOM2, DOM3>

      - Cloning <IF::Document>, <IF::tx|DocumentType>, <IF::tx|Entity>,
        <IF::tx|Notation> nodes is implementation dependent.
        <SRC::DOM1SE, DOM2, DOM3>

      - Cloning an immutable subtree results in a mutable copy, but
        the children of an <IF::tx|EntityReference> clone are
        read-only.  <SRC::DOM2, DOM3>

      - Cloning a node does not copy the event listeners attached to it.
        <SRC::DOM2 Events, DOM3 Events>

      {NOTE:: <IF::c|UserDataHandler>s are prohibitted to throw exceptions;
              if a <IF::c|UserDataHandler> that is registered to the node
              being cloned throws an exception, then the result of
              the method is undefined.
      }

      {ISSUE::
        Relationship to style sheets??
      }
    @@Param:
      @@@Name: deep
      @@@Type: boolean
      @@@enDesc:
        Whether the subtree under the node should be recursively cloned
        or not.
      @@@TrueCase:
        @@@@enDesc:
          Recusively clones the subtree under the node.
      @@@FalseCase:
        @@@@enDesc:
          Doesn't clone the subtree under the node.
    @@Return:
      @@@Type:  Node
      @@@enDesc: The duplicate node.
      @@@dx:raises:
        @@@@@: c|CLONE_NODE_TYPE_NOT_SUPPORTED_ERR
        @@@@enDesc:
          The node is of type <IF::Document>, <IF::tx|DocumentType>,
          <IF::tx|Entity>, or <IF::tx|Notation> and the implementation
          does not support cloning that type of node.  <SRC::DOM1SE>
        @@@@enImplNote:
          Only in DOM1SE; they are implementation dependent
          in DOM1SE, DOM2, and DOM3.
      @@@PerlDef:
        __DEEP{
          my $od = $self-><AG::Node.ownerDocument>;
          my $strict_check = $od-><AG::Document.strictErrorChecking>;
          $od-><AS::Document.strictErrorChecking> (false);
          my $cfg = $od-><AG::Document.domConfig>;
          my $er_copy_asis = $cfg-><M::c|DOMConfiguration.getParameter>
                                     (<Q::cfg|clone-entity-reference-subtree>);
          my @udh;
          my @node = ([$self]);
          while (@node) {
            my ($node, $parent) = @{shift @node};
            my $nt = $node-><AG::Node.nodeType>;
            my $clone;
            if ($nt == <C::Node.ELEMENT_NODE>) {
              $clone = $od-><M::Document.createElementNS>
                              ($node-><AG::Node.namespaceURI>,
                               [$node-><AG::Node.prefix>,
                                $node-><AG::Node.localName>]);
              if ($parent) {
                $parent-><M::Node.appendChild> ($clone);
              } else {
                $r = $clone;
              }
              my $attrs = $node-><AG::Node.attributes>;
              my $attrsMax = $attrs-><AG::NamedNodeMap.length> - 1;
              for my $i (0..$attrsMax) {
                my $attr = $attrs-><M::NamedNodeMap.item> ($i);
                push @node, [$attr, $clone] if $attr-><AG::Attr.specified>;
              }
              if ($deep) {
                push @node, map {[$_, $clone]} @{$node-><AG::Node.childNodes>};
              }
            } elsif ($nt == <C::Node.TEXT_NODE>) {
              $clone = $od-><M::Document.createTextNode>
                              ($node-><AG::CharacterData.data>);
              if ($parent) {
                $parent-><M::Node.appendChild> ($clone);
              } else {
                $r = $clone;
              }
              $clone-><AS::Text.isElementContentWhitespace> (true)
                if $node-><AG::Text.isElementContentWhitespace>;
            } elsif ($nt == <C::Node.ATTRIBUTE_NODE>) {
              $clone = $od-><M::Document.createAttributeNS>
                              ($node-><AG::Node.namespaceURI>,
                               [$node-><AG::Node.prefix>,
                                $node-><AG::Node.localName>]);
              if ($parent) {
                $parent-><M::Element.setAttributeNodeNS> ($clone);
              } else {
                $r = $clone;
              }
              $clone-><AS::Attr.specified> (true);
              push @node, map {[$_, $clone]} @{$node-><AG::Node.childNodes>};
            } elsif ($nt == <C::Node.COMMENT_NODE>) {
              $clone = $od-><M::Document.createComment>
                              ($node-><AG::CharacterData.data>);
              if ($parent) {
                $parent-><M::Node.appendChild> ($clone);
              } else {
                $r = $clone;
              }
            } elsif ($nt == <C::Node.CDATA_SECTION_NODE>) {
              $clone = $od-><M::Document.createCDATASection>
                              ($node-><AG::CharacterData.data>);
              if ($parent) {
                $parent-><M::Node.appendChild> ($clone);
              } else {
                $r = $clone;
              }
            } elsif ($nt == <C::Node.PROCESSING_INSTRUCTION_NODE>) {
              $clone = $od-><M::Document.createProcessingInstruction>
                              ($node-><AG::tx|ProcessingInstruction.target>,
                               $node-><AG::tx|ProcessingInstruction.data>);
              if ($parent) {
                $parent-><M::Node.appendChild> ($clone);
              } else {
                $r = $clone;
              }
            } elsif ($nt == <C::Node.ENTITY_REFERENCE_NODE>) {
              $clone = $od-><M::Document.createEntityReference>
                              ($node-><AG::Node.nodeName>);
              if ($er_copy_asis) {
                $clone-><M::Node.manakaiSetReadOnly> (false);
                $clone-><AS::Node.textContent> ('');
                for (@{$node-><AG::Node.childNodes>}) {
                  $clone-><M::Node.appendChild>
                            ($_-><M::Node.cloneNode> (true));
                }
                $clone-><AS::tx|EntityReference.manakaiExpanded>
                          ($node-><AG::tx|EntityReference.manakaiExpanded>);
                $clone-><M::Node.manakaiSetReadOnly> (true, true);
              } # copy asis
              if ($parent) {
                $parent-><M::Node.appendChild> ($clone);
              } else {
                $r = $clone;
              }
            } elsif ($nt == <C::Node.DOCUMENT_FRAGMENT_NODE>) {
              $clone = $od-><M::Document.createDocumentFragment>;
              $r = $clone;
              push @node, map {[$_, $clone]} @{$node-><AG::Node.childNodes>};
            } elsif ($nt == <C::Node.DOCUMENT_NODE>) {
              $od-><AS::Document.strictErrorChecking> ($strict_check);
              __UNDEEP{__EXCEPTION{c|CLONE_NODE_TYPE_NOT_SUPPORTED_ERR::
                c|node => $node,
              }__}__;
            } elsif ($nt == <C::Node.DOCUMENT_TYPE_NODE>) {
              $od-><AS::Document.strictErrorChecking> ($strict_check);
              __UNDEEP{__EXCEPTION{c|CLONE_NODE_TYPE_NOT_SUPPORTED_ERR::
                c|node => $node,
              }__}__;
            } elsif ($nt == <C::Node.ENTITY_NODE>) {
              $od-><AS::Document.strictErrorChecking> ($strict_check);
              __UNDEEP{__EXCEPTION{c|CLONE_NODE_TYPE_NOT_SUPPORTED_ERR::
                c|node => $node,
              }__}__;
            } elsif ($nt == <C::Node.NOTATION_NODE>) {
              $od-><AS::Document.strictErrorChecking> ($strict_check);
              __UNDEEP{__EXCEPTION{c|CLONE_NODE_TYPE_NOT_SUPPORTED_ERR::
                c|node => $node,
              }__}__;
            } else {
              ## TODO: Assertion
            }

            my $udhs;
            __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
              $r => $udhs,
              $prop => {<H::t|userData>},
              $ref => $self,
            }__;
            push @udh, [$node => $clone, $udhs] if $udhs and %$udhs;
          } # @node
          $od-><AS::Document.strictErrorChecking> (true) if $strict_check;

          ## Calling user data handlers if any
          for my $sd (@udh) {
            my $src = $sd->[0];
            my $src_ud = $sd->[2];
            for my $key (keys %{$src_ud}) {
              my $dh = $src_ud->{$key}->[1];
              if ($dh) {
                $dh-><M::c|UserDataHandler.handle>
                        (<C::c|UserDataHandler.NODE_CLONED>,
                         $key, $src_ud->{$key}->[0], $src, $sd->[1]);
              }
            }
          }
        }__;

    @@enImplNote:
      @@@ddid:udh
      @@@@:
        When are <IF::UserDataHandler>s invoked?  After a node
        is cloned?  Or, all nodes are cloned?  In any order?

        {TODO::
         
           - Clarification for default attributes

           - Define cloning for DTDef, ETDef, and ATDef.
        }

    @@L3Test:
      @@@QName: Node.CloneNode.UserDataHandler.Test
      @@@PerlDef:
        my $impl;
        __CODE{tc|createImplForTest:: $impl => $impl}__;
        my $doc = $impl-><M::c|DOMImplementation.createDocument>
                              ('http://www.example/', 'ex');
        my $node = $doc-><AG::Document.documentElement>;

        my $udh_called = false;

        $node-><M::Node.setUserData> ('key' => {}, sub {
          my ($self, $op, $key, $data, $src, $dest) = @_;
          $udh_called = true;

          $test->assert_equals ($op, <C::c|UserDataHandler.NODE_CLONED>);
          $test->assert_equals ($key, 'key');
          $test->assert_equals (ref $data, 'HASH');
          $test->assert_not_null ($src);
          $test->assert_equals ($src-><AG::Node.localName>, 'ex');
          $test->assert_not_null ($dest);
          $test->assert_equals ($dest-><AG::Node.localName>, 'ex');
        });

        my $clone = $node-><M::Node.cloneNode>;

        $test->assert_true ($udh_called);

        $node-><M::Node.setUserData> ('key', null, null);

    @@XDTest:
      @@@QName: EntityReference.cloneNode.clone-entity-reference-subtree.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docd = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>, '3.0');
        my $dtd = $docd-><M::d|DocumentXDoctype.createDocumentTypeDefinition>
                           ('doctype');
          my $et = $docd-><M::d|DocumentXDoctype.createGeneralEntity>
                             ('ent1');
          $et-><AS::Node.textContent> ('replacement text content');
          $et-><AS::tx|Entity.hasReplacementTree> (true);
        $dtd-><M::DTDef.setGeneralEntityNode> ($et);
        $doc-><M::Node.appendChild> ($dtd);

        $doc-><AG::Document.domConfig>
            -><M::c|DOMConfiguration.setParameter>
                (<Q::cfg|clone-entity-reference-subtree> => false);
                # DOM 3 definition

        $test->id ('original');
        my $ent = $doc-><M::Document.createEntityReference> ('ent1');
        $test->assert_isa ($ent, <IFName::tx|EntityReference>);
        $test->assert_equals ($ent-><AG::Node.textContent>,
                              'replacement text content');
        $test->assert_true ($ent-><AG::tx|EntityReference.manakaiExpanded>);
        $ent-><M::Node.manakaiSetReadOnly> (false, true);

        $test->id ('change');
        $ent-><AS::Node.textContent> ('another text');
        $test->assert_equals ($ent-><AG::Node.textContent>,
                              'another text');

        $test->id ('clone');
        my $clone = $ent-><M::Node.cloneNode>;
        $test->assert_isa ($clone, <IFName::tx|EntityReference>);
        $test->assert_equals ($clone-><AG::Node.textContent>,
                              'replacement text content');
        $test->assert_true ($clone-><AG::tx|EntityReference.manakaiExpanded>);
    @@XDTest:
      @@@QName: EntityReference.cloneNode.clone-entity-reference-subtree.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docd = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>, '3.0');
        my $dtd = $docd-><M::d|DocumentXDoctype.createDocumentTypeDefinition>
                           ('doctype');
          my $et = $docd-><M::d|DocumentXDoctype.createGeneralEntity>
                             ('ent1');
          $et-><AS::Node.textContent> ('replacement text content');
          $et-><AS::tx|Entity.hasReplacementTree> (true);
        $dtd-><M::DTDef.setGeneralEntityNode> ($et);
        $doc-><M::Node.appendChild> ($dtd);

        $doc-><AG::Document.domConfig>
            -><M::c|DOMConfiguration.setParameter>
                (<Q::cfg|clone-entity-reference-subtree> => true);

        $test->id ('original');
        my $ent = $doc-><M::Document.createEntityReference> ('ent1');
        $test->assert_isa ($ent, <IFName::tx|EntityReference>);
        $test->assert_equals ($ent-><AG::Node.textContent>,
                              'replacement text content');
        $test->assert_true ($ent-><AG::tx|EntityReference.manakaiExpanded>);
        $ent-><M::Node.manakaiSetReadOnly> (false, true);

        $test->id ('change');
        $ent-><AS::Node.textContent> ('another text');
        $test->assert_equals ($ent-><AG::Node.textContent>,
                              'another text');

        $test->id ('clone');
        my $clone = $ent-><M::Node.cloneNode>;
        $test->assert_isa ($clone, <IFName::tx|EntityReference>);
        $test->assert_equals ($clone-><AG::Node.textContent>,
                              'another text');
        $test->assert_true ($clone-><AG::tx|EntityReference.manakaiExpanded>);
    @@XDTest:
      @@@QName: EntityReference.cloneNode.clone-entity-reference-subtree.3.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docd = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>, '3.0');
        my $dtd = $docd-><M::d|DocumentXDoctype.createDocumentTypeDefinition>
                           ('doctype');
          my $et = $docd-><M::d|DocumentXDoctype.createGeneralEntity>
                             ('ent1');
          $et-><AS::Node.textContent> ('replacement text content');
          $et-><AS::tx|Entity.hasReplacementTree> (true);
        $dtd-><M::DTDef.setGeneralEntityNode> ($et);
        $doc-><M::Node.appendChild> ($dtd);

        $doc-><AG::Document.domConfig>
            -><M::c|DOMConfiguration.setParameter>
                (<Q::cfg|clone-entity-reference-subtree> => true);

        $test->id ('original');
        my $ent = $doc-><M::Document.createEntityReference> ('ent1');
        $test->assert_isa ($ent, <IFName::tx|EntityReference>);
        $test->assert_equals ($ent-><AG::Node.textContent>,
                              'replacement text content');
        $test->assert_true ($ent-><AG::tx|EntityReference.manakaiExpanded>);
        $ent-><M::Node.manakaiSetReadOnly> (false, true);

        $test->id ('change');
        $ent-><AS::Node.textContent> ('');
        $test->assert_equals ($ent-><AG::Node.textContent>, '');
        $ent-><AS::tx|EntityReference.manakaiExpanded> (false);
        $test->assert_false ($ent-><AG::tx|EntityReference.manakaiExpanded>);

        $test->id ('clone');
        my $clone = $ent-><M::Node.cloneNode>;
        $test->assert_isa ($clone, <IFName::tx|EntityReference>);
        $test->assert_equals ($clone-><AG::Node.textContent>, '');
        $test->assert_false ($clone-><AG::tx|EntityReference.manakaiExpanded>);

  @enImplNote:
    @@ddid: pending
    @@@:
      baseURI, compareDocumentPosition, isDefaultNamespace,
      isEqualNode, isSupported, lookupNamespaceURI,
      lookupPrefix, normalize

  @L3Method:
    @@Name: getFeature
    @@enDesc:
      Returns a specialized object that implements the specialized
      APIs of the specified feature and version.  This method also
      allow the implementation to provide specialized objects
      that do not support the <IF::Node> interface.

        {NOTE:: The specialized object may also obtained by
                using binding-specific casting methods but
                it is not necessarily expected to.
        }
    @@Param:
      @@@Name: feature
      @@@Type: DOMString
      @@@dis:actualType: f|FeatureNameString
      @@@enDesc:
        The name of the feature to request.
      @@@InCase:
        @@@@Label:
          @@@@@lang:en
          @@@@@@:
            Feature name prepended by a <CHAR::PLUS SIGN>
        @@@@enDesc:
          Any <CHAR::PLUS SIGN> will be ignored since it is
          not significant in the context of this method.
    @@Param:
      @@@Name: version
      @@@Type: DOMString
      @@@dis:actualType: f|FeatureVersionString
      @@@enDesc:
        The version number of the feature to request.
      @@@enImplNote:
        {ISSUE:: null? empty?
        }
    @@Return:
      @@@Type: DOMMain|DOMObject
      @@@enDesc:
        An object that implements the specialized APIs of
        the specified feature and version.

        If it implements the <IF::Node> interface, it must
        delegate to the primary core <IF::Node> and not return
        results icosistent with the primary core <IF::Node>.
      @@@nullCase:
        @@@@enDesc:
          If there is no object that implements interfaces
          associated with the specified feature and version.
      @@@PerlDef:
        $feature =~ s/^\+//;
        __CODE{f|getFeatureImpl::
          $self => $self,
          $feature => $feature, $version => $version, $r => $r,
          $base_class => {<ClassName::ManakaiDOMNode>},
        }__;

    @@Test:
      @@@QName: Node.getFeature.hasFeature.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        no warnings 'uninitialized';
        for my $node (<Code::tc|createNodesForTest+dt>) {
          for my $f (
            [Core => '1.0', <IFName::Node||ManakaiDOM|ManakaiDOM1>],
            [Core => '2.0', <IFName::Node||ManakaiDOM|ManakaiDOM2>],
            [Core => '3.0', <IFName::Node||ManakaiDOM|ManakaiDOM3>],
            [Core => '', <IFName::Node||ManakaiDOM|ManakaiDOM>],
            [Core => null, <IFName::Node||ManakaiDOM|ManakaiDOM>],
            [XML => '1.0', <IFName::Node||ManakaiDOM|ManakaiDOM1>],
            [XML => '2.0', <IFName::Node||ManakaiDOM|ManakaiDOM2>],
            [XML => '3.0', <IFName::Node||ManakaiDOM|ManakaiDOM3>],
            [XML => '', <IFName::Node||ManakaiDOM|ManakaiDOM>],
            [XML => null, <IFName::Node||ManakaiDOM|ManakaiDOM>],
            [XMLVersion => '1.0', <IFName::Node||ManakaiDOM|ManakaiDOM3>],
            [XMLVersion => '1.1', <IFName::Node||ManakaiDOM|ManakaiDOM3>],
            [XMLVersion => '', <IFName::Node||ManakaiDOM|ManakaiDOM>],
            [XMLVersion => null, <IFName::Node||ManakaiDOM|ManakaiDOM>],
            ['-unknown-feature', '3.0', false],
            ['-unknown-feature', '', false],
            ['-unknown-feature', null, false],
          ) {
            $test->id ($node-><AG::Node.nodeName>.'.get.'.$f->[0].'.'.$f->[1]);
            my $gf = $node-><M::Node.getFeature> ($f->[0], $f->[1]);
            if ($f->[2]) {
              $test->assert_isa ($gf, $f->[2]);
            } else {
              $test->assert_null ($gf);
            }

            $test->id ($node-><AG::Node.nodeName>.'.get.+'.$f->[0].'.'.$f->[1]);
            my $gfp = $node-><M::Node.getFeature> ('+'.$f->[0], $f->[1]);
            if ($f->[2]) {
              $test->assert_isa ($gfp, $f->[2]);
            } else {
              $test->assert_null ($gfp);
            }

            $test->id ($node-><AG::Node.nodeName>.'.has.'.$f->[0].'.'.$f->[1]);
            my $hf = $node-><M::f|GetFeature.hasFeature> ($f->[0], $f->[1]);
            if ($f->[2]) {
              $test->assert_true ($hf);
            } else {
              $test->assert_false ($hf);
            }

            $test->id ($node-><AG::Node.nodeName>.'.has.+'.$f->[0].'.'.$f->[1]);
            my $hfp = $node-><M::f|GetFeature.hasFeature> ('+'.$f->[0], $f->[1]);
            if ($f->[2]) {
              $test->assert_true ($hfp);
            } else {
              $test->assert_false ($hfp);
            }

            $test->id ($node-><AG::Node.nodeName>.'.is.'.$f->[0].'.'.$f->[1]);
            my $if = $node-><M::Node.isSupported> ($f->[0], $f->[1]);
            if ($f->[2]) {
              $test->assert_true ($if);
            } else {
              $test->assert_false ($if);
            }

            $test->id ($node-><AG::Node.nodeName>.'.is.+'.$f->[0].'.'.$f->[1]);
            my $ifp = $node-><M::Node.isSupported> ('+'.$f->[0], $f->[1]);
            if ($f->[2]) {
              $test->assert_true ($ifp);
            } else {
              $test->assert_false ($ifp);
            }
          }
        }

  @L3Method:
    @@Name: getUserData
    @@enDesc:
      Retrieves the object associated to a key on the node.
    @@Param:
      @@@Name: key
      @@@Type: DOMMain|DOMString
      @@@enDesc:
        The key the object is associated to.
    @@Return:
      @@@Type: DOMMain|DOMUserData
      @@@enDesc:
        The object associated to the given <P::key> on the node.
      @@@nullCase:
        @@@@enDesc:
          No object is associated.
      @@@PerlDef:
        my $v;
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $v,
          $prop => {<H::t|userData>},
          $ref => $self,
        }__;
        $r = $v->{$key}->[0];


  @L3Method:
    @@Name: setUserData
    @@enDesc:
      Associates an object to a key on the node.  The object can later
      be retrieved from the node by calling <M::Node.getUserData>
      method with the same key.
    @@enDesc:
      @@@ForCheck: ManakaiDOM|Perl ManakaiDOM|ForClass
      @@@ddid: pleak
      @@@@:
        {NOTE:: Application developers are advised to be careful
                to include direct or indirect references to the node
                itself as user data or in user data handlers.
                They would result in memory leak problems unless
                the circular references are removed later.
                
                It would be a good practive to eusure that every user data
                registered to a node is later unregistered by setting
                <DOM::null> as a data for the same key.
        }
    @@Param:
      @@@Name: key
      @@@Type: DOMMain|DOMString
      @@@enDesc:
        The key to associate the <P::data> to.
    @@Param:
      @@@Name: data
      @@@Type: DOMMain|DOMUserData
      @@@enDesc:
        The object to associate to the given key.
      @@@nullCase:
        @@@@enDesc:
          Removes any existing association to the <P::key>.
    @@Param:
      @@@Name: handler
      @@@Type: c|UserDataHandler
      @@@enDesc:
        The handler to associate to the <P::key>.
      @@@nullCase:
        @@@@enDesc:
          No handler is associated.
    @@Return:
      @@@Type: DOMMain|DOMUserData
      @@@enDesc:
        The object previously associated to the <P::key> on the node.
      @@@nullCase:
        @@@@enDesc:
          No object was associated.
      @@@PerlDef:
        __CODE{mg|orSetNodeStemPropValue||ManakaiDOM|all::
          $given => {{}},
          $prop => {<H::t|userData>},
          $ref => $self,
        }__;
        my $v;
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $v,
          $prop => {<H::t|userData>},
          $ref => $self,
        }__;
        $r = $v->{$key}->[0];

        if (defined $data) {
          $v->{$key} = [$data, $handler];

          if (defined $handler) {
            my $rc = sub {
              my ($bag, $nid) = @_;
              my $nh = <Code::mg|createNodeRefHashFromID||ManakaiDOM|all::
                                  $stemid = $nid, $bag = $bag>;
              my $uds;
              __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
                $r => $uds,
                $prop => {<H::t|userData>},
                $ref => $nh,
              }__;
              for my $key (keys %$uds) {
                if (defined $uds->{$key}->[1]) {
                  $uds->{$key}->[1]->($uds->{$key}->[1],
                                      <C::c|UserDataHandler.NODE_DELETED>,
                                      $key, $uds->{$key}->[0]);
                }
              }
            }; # rc
            __CODE{mg|setNodeStemPropValue||ManakaiDOM|all::
              $given => $rc,
              $prop => {<H::mg|onunload>},
              $ref => $self,
            }__;
          }
        } else {
          CORE::delete $v->{$key};
        }

  @L3Test:
    @@QName: GetSetUserDataTest
    @@PerlDef:
      my $impl;
      __CODE{tc|createImplForTest:: $impl => $impl}__;

      my $node = $impl-><M::c|DOMImplementation.createDocument>;

      my $data = ['2'];
      my $handler = sub { 1 };

      $test->assert_null
               ($node-><M::Node.setUserData> ('key1', $data, $handler),
                uri => <Q::GetSetUserDataTest.InitialReturnNull>);

      my $key1_data = $node-><M::Node.getUserData> ('key1');
      $test->assert_not_null ($key1_data);
      $test->assert_equals ($data->[0], $key1_data->[0]);

      my $data2 = ['4'];
      
      $test->assert_equals ($node-><M::Node.setUserData> ('key1', $data2, null),
                            $data);
      
      $test->assert_equals ($node-><M::Node.getUserData> ('key1'), $data2);

      $node-><M::Node.setUserData> ('key1', null, $handler);
      $test->assert_null ($node-><M::Node.getUserData> ('key1'));

      $node-><M::Node.setUserData> ('key1', null, null);
      $test->assert_null ($node-><M::Node.getUserData> ('key1'));

    @@L3Test:
      @@@QName: Node.Deleted.UserDataHandler
      @@@PerlDef:
        local $Message::Util::Grove::GCLatency = 0;

        my $impl;
        __CODE{tc|createImplForTest:: $impl => $impl}__;
        my $doc = $impl-><M::c|DOMImplementation.createDocument>
                              ('http://www.example/', 'ex');
        my $node = $doc-><AG::Document.documentElement>;

        my $udh_called = false;

        $node-><M::Node.setUserData> ('key' => {}, sub {
          my ($self, $op, $key, $data, $src, $dest) = @_;
          $udh_called = true;

          $test->id ('self');
          $test->assert_isa ($self, <IFName::c|UserDataHandler>);
          $test->id ('operation');
          $test->assert_equals ($op, <C::c|UserDataHandler.NODE_DELETED>);
          $test->id ('key');
          $test->assert_equals ($key, 'key');
          $test->id ('data');
          $test->assert_equals (ref $data, 'HASH');
          $test->id ('src');
          $test->assert_null ($src);
          $test->id ('dest');
          $test->assert_null ($dest);
        });

        undef $doc;
        undef $node;
        undef $impl;

        $test->id ('called');
        $test->assert_true ($udh_called);
        
  @L2Method:
    @@Name: hasAttributes
    @@enDesc:
      Returns whether the node has any attribute nodes.
    @@Return:
      @@@Type: boolean
      @@@TrueCase:
        @@@@enDesc:
          If the node has any attributes.
      @@@FalseCase:
        @@@@enDesc:
          Otherwise.
      @@@PerlDef:
        my $attrs;
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $attrs,
          $prop => {<H::infoset|attributes>},
          $ref => $self,
        }__;
        A: for (values %{$attrs or {}}) {
          if (keys %$_) {
            $r = true;
            last A;
          }
        }

    @@Test:
      @@@QName: Node.hasAttributes.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        for my $node (
          <Code::tc|createNodesForTest-el-attr>,
          $doc-><M::Document.createAttribute> ('at1'),
        ) {
          $test->id ($node-><AG::Node.nodeName>);
          $test->assert_false ($node-><M::Node.hasAttributes>);
        }
    @@Test:
      @@@QName: Element.hasAttributes.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        $test->id ('initial');
        $test->assert_false ($el-><M::Node.hasAttributes>);

        $test->id ('1');
        $el-><M::Element.setAttribute> (a => 'b');
        $test->assert_true ($el-><M::Node.hasAttributes>);

        $test->id ('2');
        $el-><M::Element.setAttribute> (c => 'd');
        $test->assert_true ($el-><M::Node.hasAttributes>);

        $test->id ('2-1');
        $el-><M::Element.removeAttribute> ('c');
        $test->assert_true ($el-><M::Node.hasAttributes>);

        $test->id ('not.specified');
        $el-><M::Element.getAttributeNode> ('a')
           -><AS::Attr.specified> (false);
        $test->assert_true ($el-><M::Node.hasAttributes>);

        $test->id ('1-1');
        $el-><M::Element.removeAttribute> ('a');
        $test->assert_false ($el-><M::Node.hasAttributes>);

  @Method:
    @@Name: hasChildNodes
    @@enDesc:
      Returns whether the node has any children.
    @@Return:
      @@@Type: boolean
      @@@TrueCase:
        @@@@enDesc:
          If the node has any children.
      @@@FalseCase:
        @@@@enDesc:
          Otherwise.
      @@@PerlDef:
        my $v;
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $v,
          $prop => {<H::infoset|children>},
          $ref => $self,
        }__;
        $r = (@{$v or []} > 0);

    @@Test:
      @@@QName: Node.hasChildNodes.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        for my $node (<Code::tc|createNodesForTest+dt>) {
          $test->id ($node-><AG::Node.nodeName>);
          $test->assert_false ($node-><M::Node.hasChildNodes>);
        }
    @@Test:
      @@@QName: Doc.hasChildNodes.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        $test->id ('initial');
        $test->assert_false ($doc-><M::Node.hasChildNodes>);

        $test->id ('1');
        $doc-><M::Node.appendChild> ($doc-><M::Document.createComment> (''));
        $test->assert_true ($doc-><M::Node.hasChildNodes>);

        $test->id ('2');
        $doc-><M::Node.appendChild> ($doc-><M::Document.createComment> (''));
        $test->assert_true ($doc-><M::Node.hasChildNodes>);

        $test->id ('2-1');
        $doc-><M::Node.removeChild> ($doc-><AG::Node.firstChild>);
        $test->assert_true ($doc-><M::Node.hasChildNodes>);

        $test->id ('1-1');
        $doc-><M::Node.removeChild> ($doc-><AG::Node.firstChild>);
        $test->assert_false ($doc-><M::Node.hasChildNodes>);

  @L3Attr:
    @@Name: baseURI
    @@enDesc:
      The base URI of the node.
    @@Type: DOMString
    @@dis:actualType: ManakaiDOM|ManakaiDOMURI
    @@Get:
      @@@enDesc:
        The absolute base URI of the node.
      @@@nullCase:
        @@@@enDesc:
          If the DOM implementation was unable to obtain the base absolute
          URI.
      @@@PerlDef:
        $r = null;
    @@enImplNote:
      See <URI::http://suika.fam.cx/gate/2005/sw/baseURI>.

  @L3Method:
    @@Name: compareDocumentPosition
     @@Param:
        @@@Name:  other
        @@@Type:  Node
     @@Return:
        @@@Type:  
          DOMMain:unsigned-short||ManakaiDOM|all
        @@@actualType: DocumentPosition
#        @@@Exception[list]:  DOMException

  @L3Method:
    @@Name: lookupNamespaceURI
    @@enDesc:
      Looks up the namespace URI associated to the given prefix,
      starting from the node.  This method ignores DOM Level 1 nodes.
    @@DOMMain:isNamespaceAware: 1
    @@Param:
      @@@Name: prefix
      @@@Type: DOMString
      @@@enDesc:
        The prefix to look for.
      @@@nullCase:
        @@@@enDesc:
          The default namespace URI, if any, is returned.
    @@Return:
      @@@Type: DOMString
      @@@dis:actualType: ManakaiDOM|ManakaiDOMNamespaceURI
      @@@enDesc:
        The associated namespace URI.

        {LI:: <IF::Element>::: 

           = If the namespace of the element is not <DOM::null> 
             and the prefix of the element is equal to the <P::prefix>
             (note that it could be <DOM::null>), then return
             the namespace of the element.

           {OLI:: If the element has attributes, for each
                  DOM Level 2 valid local namespace declaration attributes
                  of the element,

                  {SpecIssue::
                    What is the <QUOTE::DOM Level 2 valid local namespace
                    declaration attributes>?
                  }

                  {OLI:: If the prefix of the attribute is <XML::xmlns>
                         and the local name of the attribute is equal
                         to the <P::prefix>,

                    = If the value of the attribute is not empty,
                      return the value of the attribute.

                    = Otherwise, return unknown (<DOM::null>).

                  }

                  {OLI:: If the local name of the attribute is <XML::xmlns>
                         and the <P::prefix> is <DOM::null>, 

                    = If the value of the attribute is not empty,
                      return the value of the attribute.

                    = Otherwise, return unknown (<DOM::null>).

                  }

           }

           = If the element has an ancestor element, then
             the return value is same as that of the 
             <M::Node.lookupNamespaceURI> method on the ancestor
             element with the same parameter.

           = Otherwise, return <DOM::null>.

        }

        {LI:: <IF::Document>::: Same as the return value
                  of the <M::Node.lookupNamespaceURI> method
                  on the <A::Document.documentElement> of the node.

                  {SpecIssue::
                    If there is no document element, then?
                  }

        }

        {LI:: <IF::tx|Entity>, <IF::tx|Notation>, <IF::tx|DocumentType>,
              <IF::DocumentFragment> <SRC::DOM3>, <IF::ETDef>, and
              <IF::ATDef> <SRC::manakai>:::  <DOM::null>.

              {ISSUE::
                Should for <IF::ETDef>s return something different?
                If so, for <IF::ATDef>s should return what for its owner
                definition does.
              }
        }

        {LI:: <IF::Attr>:::

           = If the attribute has the owner element, then
             the return value is same as that of the 
             <M::Node.lookupNamespaceURI> method on the owner element
             with the same parameter.

           = Otherwise, return unknown (<DOM::null>).
        }

        {LI:: Otherwise::

           = If the node has an ancestor element, then
             the return value is same as that of the
             <M::Node.lookupNamespaceURI> method on the ancestor
             element with the same parameter.

           = Otherwise, return unknown (<DOM::null>).
        }
      @@@nullCase:
        @@@@enDesc:
          If no namespace URI is found.
      @@@PerlDef:
        __DEEP{
          $prefix = null if defined $prefix and $prefix eq '';
              # implementation dependent
          my $nt = $self-><AG::Node.nodeType>;
          if ($nt == <C::Node.ELEMENT_NODE>) {
            my $el = $self;
            EL: {
              my $elns = $el-><AG::Node.namespaceURI>;
              if (defined $elns) {
                my $elpfx = $el-><AG::Node.prefix>;
                if ((not defined $prefix and not defined $elpfx) or
                    (defined $prefix and defined $elpfx and $prefix eq $elpfx)) {
                  $r = $elns;
                  last EL;
                }
              }
              AT: for my $attr (@{$el-><AG::Node.attributes>}) {
                my $attrns = $attr-><AG::Node.namespaceURI>;
                next AT if not defined $attrns or $attrns ne <Q::xmlns:>;
                my $attrpfx = $attr-><AG::Node.prefix>;
                if (not defined $prefix) {
                  my $attrln = $attr-><AG::Node.localName>;
                  if ($attrln eq 'xmlns') {
                    my $attrval = $attr-><AG::Attr.value>;
                    $r = length $attrval ? $attrval : null;
                    last EL;
                  }
                } elsif (defined $prefix and
                         defined $attrpfx and $attrpfx eq 'xmlns') {
                  my $attrln = $attr-><AG::Node.localName>;
                  if ($attrln eq $prefix) {
                    my $attrval = $attr-><AG::Attr.value>;
                    $r = length $attrval ? $attrval : null;
                    last EL;
                  }
                }
              } # AT
              $el = $el-><AG::Node.manakaiParentElement>;
              redo EL if defined $el;
              $r = null;
            } # EL;
          } else {
            my $el = $nt == <C::Node.DOCUMENT_NODE>
                       ? $self-><AG::Document.documentElement> :
                     $nt == <C::Node.ATTRIBUTE_NODE>
                       ? $self-><AG::Attr.ownerElement> :
                     $self-><AG::Node.manakaiParentElement>;
            if (defined $el) {
              $r = $el-><M::Node.lookupNamespaceURI> ($prefix);
            } else {
              $r = null;
            }
          }
        }__;

    @@Test:
      @@@QName: Node.lookupNamespaceURI.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);
  
        for my $node (<Code::tc|createNodesForTest+dt>) {
          $test->id ($node-><AG::Node.nodeName>.'.1');
          $test->assert_null ($node-><M::Node.lookupNamespaceURI> ('ns1'));

          $test->id ($node-><AG::Node.nodeName>.'.xml');
          $test->assert_null ($node-><M::Node.lookupNamespaceURI> ('xml'));

          $test->id ($node-><AG::Node.nodeName>.'.xmlns');
          $test->assert_null ($node-><M::Node.lookupNamespaceURI> ('xmlns'));

          $test->id ($node-><AG::Node.nodeName>.'.null');
          $test->assert_null ($node-><M::Node.lookupNamespaceURI> (null));

          $test->id ($node-><AG::Node.nodeName>.'.empty');
          $test->assert_null ($node-><M::Node.lookupNamespaceURI> (''));
        }
    @@Test:
      @@@QName: Node.lookupNamespaceURI.2.test
      @@@enDesc:
        Namespace declared as the prefix of the element itself.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createElementNS> ('about:', 'el');

        $test->id ('not.defined');
        $test->assert_null ($el-><M::Node.lookupNamespaceURI> ('ns1'));

        $test->id ('element.prefix');
        $el-><AS::Node.prefix> ('ns1');
        $test->assert_equals ($el-><M::Node.lookupNamespaceURI> ('ns1'),
                              'about:');

        $test->id ('element.xmlns');
        $el-><M::Element.setAttributeNS> (<Q::xmlns:>, 'xmlns:ns1', 'DAV:');
        $test->assert_equals ($el-><M::Node.lookupNamespaceURI> ('ns1'),
                              'about:');
    @@Test:
      @@@QName: Node.lookupNamespaceURI.3.test
      @@@enDesc:
        Namespace declared as the attribute of the element itself.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createElementNS> ('about:', 'el');

        $test->id ('not.defined');
        $test->assert_null ($el-><M::Node.lookupNamespaceURI> ('ns1'));

        $test->id ('element.xmlns');
        $el-><M::Element.setAttributeNS> (<Q::xmlns:>, 'xmlns:ns1', 'DAV:');
        $test->assert_equals ($el-><M::Node.lookupNamespaceURI> ('ns1'),
                              'DAV:');

  @L3Method:
    @@Name: lookupPrefix
    @@enDesc:
      Looks up the prefix associated to the given namespace URI,
      starting from the node.  This method ignores DOM
      Level 1 nodes and all default namespace declarations.

        {NOTE::
           To look up the default namespace, use the
           <M::Node.isDefaultNamespace> method instead.
        }
    @@DOMMain:isNamespaceAware: 1
    @@Param:
      @@@Name: namespaceURI
      @@@Type: DOMString
      @@@dis:actualType: ManakaiDOM|ManakaiDOMNamespaceURI
      @@@enDesc:
        The namespace URI to look for.
      @@@nullCase:
        @@@@enDesc:
          <DOM::null> is returned.
    @@Return:
      @@@Type: DOMString
      @@@enDesc:
        An associated namespace prefix.

        If more than one prefix are associated to the
        namespace URI, the returned namespace prefix is 
        implementation dependent.

        {P:: What this method will return is defined by the algorithm
             <DFN::<CODE::lookupNamespace>>:
        
          = If the <P::namespaceURI> is <DOM::null> or an empty
            string, then return <DOM::null>.

          = If the node is an <IF::Element>, then the return value
            is defined by the algorithm <CODE::lookupNamespacePrefix>
            with both <CODE::element> and <CODE::originalElement> parameters
            set to the node.

          {OLI::
            If the node is a <IF::Document>, then the return value
            is defined by the algorithm <CODE::lookupNamespacePrefix>
            with its <CODE::element> parameter set to the
            <A::Document.documentElement> of the node.

              {SpecIssue::
                - If <A::Document.documentElement> is <DOM::null>, then?

                - What is the <CODE::originalElement>?
              }
          }

          {LI:: If the node is an <IF::tx|Entity>, <IF::tx|Notation>,
                <IF::DocumentFragment>, <IF::tx|DocumentType> <SRC::DOM3>,
                <IF::ETDef>, or <IF::ATDef> <SRC::manakai>, then
                return <DOM::null>.

                {ISSUE::
                  Are <IF::ETDef>s should return something different?
                  If so, <IF::ATDef>s should return its owner 
                  definition does.
                }
          }

          {OLI:: If the node is an <IF::Attr>,

            {OLI:: If the node has an <A::Attr.ownerElement>, then
                   the return value is defined by the algorithm
                   <CODE::lookupNamespacePrefix> with its <CODE::element>
                   parameter set to the <A::Attr.ownerElement> of the node.
 
                   {SpecIssue::
                     What is the <CODE::originalElement>?
                   }

            }

            = Otherwise, return <DOM::null>.

          }

          {OLI:: If the node has an ancestor <IF::Element>, then
                 the return value is defined by the algorithm
                 <CODE::lookupNamespacePrefix> with its <CODE::element>
                 parameter set to the ancestor element.

                 {SpecIssue::
                   What is the <CODE::originalElement>?
                 }
          }

          = Otherwise, return <DOM::null>.

        }

        {P:: The algorithm <DFN::<CODE::lookupNamespacePrefix>> is defined
             as:

           = If the <CODE::element> has a namespace,
             the <CODE::element>'s namespace is equal to <P::namespaceURI>,
             the <CODE::element> has a prefix, and
             the <M::Node.lookupNamespaceURI> method on the
             <CODE::originalElement> with its parameter set
             to the prefix of the <CODE::element> returns
             the <P::namespaceURI>, then return the prefix
             of the <CODE::element>.
 
           {OLI:: If the <CODE::element> has attributes, for each
                  DOM Level 2 valid local namespace declaration
                  attribute of the <CODE::element>, 
         
                    {SpecIssue::
                      What is the <QUOTE::DOM Level 2 valid local
                      namespace declaration attributes>?
                    }

                  = If the prefix of the attribute is <XML::xmlns>,
                    the value of the attribute is equal to the
                    <P::namespaceURI>, and the <M::Node.lookupNamespaceURI>
                    method on the <CODE::originalElement> with its
                    parameter set to the local name of the attribute
                    returns the <P::namespaceURI>, then return
                    the local name of the attribute.  Exit the algorithm.
           }

           = If the <CODE::element> has an ancestor element,
             then the return value is defined by the algorithm
             <CODE::lookupNamespacePrefix> with the <CODE::element>
             parameter set to the ancestor element and the
             <CODE::originalElement> parameter set to the current
             <CODE::originalElement> value.

           = Otherwise, return <DOM::null>.
        }
      @@@nullCase:
        @@@@enDesc:
          If no prefix is found.
      @@@PerlDef:
        unless (defined $namespaceURI) {
          $r = null;
        } else {
          __DEEP{
            my $nt = $self-><AG::Node.nodeType>;
            if ($nt == <C::Node.ELEMENT_NODE>) {
              my $el = $self;
              EL: {
                my $elns = $el-><AG::Node.namespaceURI>;
                if (defined $elns and $elns eq $namespaceURI) {
                  my $elpfx = $el-><AG::Node.prefix>;
                  if (defined $elpfx) {
                    my $oelpfx = $self-><M::Node.lookupNamespaceURI> ($elpfx);
                    if (defined $oelpfx and $oelpfx eq $elpfx) {
                      $r = $elpfx;
                      last EL;
                    }
                  }
                }
                AT: for my $attr (@{$el-><AG::Node.attributes>}) {
                  my $attrpfx = $attr-><AG::Node.prefix>;
                  next AT if not defined $attrpfx or $attrpfx ne 'xmlns';
                  my $attrns = $attr-><AG::Node.namespaceURI>;
                  next AT if not defined $attrns or $attrns ne <Q::xmlns:>;
                  my $attrln = $attr-><AG::Node.localName>;
                  my $oelpfx = $self-><M::Node.lookupNamespaceURI> ($attrln);
                  next AT unless defined $oelpfx;
                  if ($oelpfx eq $attrln) {
                    $r = $attrln;
                    last EL;
                  }
                }
                $el = $el-><AG::Node.manakaiParentElement>;
                redo EL if defined $el;
                $r = null;
              } # EL
            } else {
              my $el = $nt == <C::Node.DOCUMENT_NODE>
                         ? $self-><AG::Document.documentElement> :
                       $nt == <C::Node.ATTRIBUTE_NODE>
                         ? $self-><AG::Attr.ownerElement> :
                       $self-><AG::Node.manakaiParentElement>;
              if (defined $el) {
                $r = $el-><M::Node.lookupPrefix> ($namespaceURI);
              } else { 
                $r = null;
              }
            }
          }__;
        }

    @@Test:
      @@@QName: Node.lookupPrefix.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        $doc-><AG::Document.domConfig>
            -><M::c|DOMConfiguration.setParameter> ('error-handler' => sub { });
          # No warnings
  
        for my $node (<Code::tc|createNodesForTest+dt>) {
          $test->id ($node-><AG::Node.nodeName>.'.1');
          $test->assert_null ($node-><M::Node.lookupPrefix>
                                       ('http://www.w3.org/1999/xhtml'));

          $test->id ($node-><AG::Node.nodeName>.'.xml');
          $test->assert_null ($node-><M::Node.lookupPrefix> (<Q::xml:>));

          $test->id ($node-><AG::Node.nodeName>.'.xmlns');
          $test->assert_null ($node-><M::Node.lookupPrefix> (<Q::xmlns:>));

          $test->id ($node-><AG::Node.nodeName>.'.null');
          $test->assert_null ($node-><M::Node.lookupPrefix> (null));

          $test->id ($node-><AG::Node.nodeName>.'.empty');
          $test->assert_null ($node-><M::Node.lookupPrefix> (''));
        }

  @L3Method:
    @@Name: isDefaultNamespace
    @@enDesc:
      Checks whether the specified namespace URI is the default
      namespace or not.  This method ignores DOM Level 1 nodes.
    @@DOMMain:isNamespaceAware: 1
    @@Param:
      @@@Name: namespaceURI
      @@@Type: DOMString
      @@@dis:actualType: ManakaiDOM|ManakaiDOMNamespaceURI
      @@@enDesc:
        The namespace URI to look for.
      @@@enImplNote:
        {SpecIssue::
          Is <DOM::null> or an empty string allowed?
        }
    @@Return:
      @@@Type: boolean
      @@@enDesc:
        {LI:: <IF::Element>:::

           = If the <IF::Element> has no prefix, return
             whether the namespace of the <IF::Element> is
             equal to the <P::namespaceURI>.

           {OLI:: If the <IF::Element> has a valid DOM Level 2
                  default namespace declaration, i.e. an attribute
                  whose <A::Node.localName> is <XA::xmlns>,
                  return whether the value of the atribute
                  is equal to the <P::namespaceURI> or not.

                  {SpecIssue:: Are <DOM::null> and empty string
                    allowed as <P::namespaceURI>?
                  }
           }

           = If the <IF::Element> has an ancestor <IF::Element>,
             the return value is same as that of the
             <M::Node.isDefaultNamespace> method on the
             ancestor element with the same parameter.

           = Otherwise, return unknown (<DOM::false>).

        }

        {LI:: <IF::Document>::: Same as the return value
                  of the <M::Node.isDefaultNamespace> method
                  on the document element of the node with 
                  the same parameter.

                  {SpecIssue:: If no document element, then?
                  }
        }

        {LI:: <IF::tx|Entity>, <IF::tx|Notation>, <IF::tx|DocumentType>,
              <IF::DocumentFragment> <SRC::DOM3>, <IF::ETDef>, and
              <IF::ATDef> <SRC::manakai>::: Unknown (<DOM::false>).

                  {ISSUE::
                    Should attriute definition be checked for 
                    <IF::ETDef>?  If so, also for <IF::ATDef>.
                  }
        }

        {LI:: <IF::Attr>::: 

          = If the <IF::Attr> has an owner <IF::Element>, the return
            value is that of the <M::Node.isDefaultNamespace>
            method on that owner <IF::Element> with the same parameter.

          = Otherwise, return unknown (<DOM::false>).

        }

        {LI:: Otherwise:::

          = If the <IF::Node> has an ancestor <IF::Element>, the return
            value is that of the <M::Node.isDefaultNamespace>
            method on that ancestor <IF::Element> with the same parameter.

          = Otherwise, return unknown (<DOM::false>).

        }
      @@@TrueCase:
        @@@@enDesc:
          If the specified <P::namespaceURI> is the default namespace.
      @@@FalseCase:
        @@@@enDesc:
          Otherwise.
      @@@PerlDef:
        __DEEP{
          my $nt = $self-><AG::Node.nodeType>;
          if ($nt == <C::Node.ELEMENT_NODE>) {
            my $el = $self;
            EL: {
              my $elpfx = $el-><AG::Node.prefix>;
              unless (defined $elpfx) {
                my $elns = $el-><AG::Node.namespaceURI>;
                if (defined $namespaceURI and defined $elns) {
                  $r = ($namespaceURI eq $elns);
                } else {
                  $r = not (defined $namespaceURI or defined $elns);
                }
                last EL;
              }
              my $xmlns = $el-><M::Element.getAttributeNS>
                                 (<Q::xmlns:>, 'xmlns');
              if (defined $xmlns) {
                if (defined $namespaceURI) {
                  $r = ($namespaceURI eq $xmlns);
                } else {
                  $r = ($xmlns eq '');
                }
                last EL;
              }
              $el = $el-><AG::Node.manakaiParentElement>;
              redo EL if defined $el;
              $r = null;
            } # EL;
          } else {
            my $el = $nt == <C::Node.DOCUMENT_NODE>
                       ? $self-><AG::Document.documentElement> :
                     $nt == <C::Node.ATTRIBUTE_NODE>
                       ? $self-><AG::Attr.ownerElement> :
                     $self-><AG::Node.manakaiParentElement>;
            if (defined $el) {
              $r = $el-><M::Node.isDefaultNamespace> ($namespaceURI);
            } else {
              $r = null;
            }
          }
        }__;

    @@Test:
      @@@QName: Node.isDefaultNamespace.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        $doc-><AG::Document.domConfig>
            -><M::c|DOMConfiguration.setParameter> ('error-handler' => sub { });
          # No warnings
  
        for my $node (
          <Code::tc|createNodesForTest-el-attr>,
          $doc-><M::Document.createAttributeNS> (null, 'attr1'),
        ) {
          $test->id ($node-><AG::Node.nodeName>.'.1');
          $test->assert_false ($node-><M::Node.isDefaultNamespace> ('about:'));

          $test->id ($node-><AG::Node.nodeName>.'.xml');
          $test->assert_false ($node-><M::Node.isDefaultNamespace> (<Q::xml:>));

          $test->id ($node-><AG::Node.nodeName>.'.xmlns');
          $test->assert_false
                   ($node-><M::Node.isDefaultNamespace> (<Q::xmlns:>));

          $test->id ($node-><AG::Node.nodeName>.'.null');
          $test->assert_false ($node-><M::Node.isDefaultNamespace> (null));

          $test->id ($node-><AG::Node.nodeName>.'.empty');
          $test->assert_false ($node-><M::Node.isDefaultNamespace> (''));
        }
    @@Test:
      @@@QName: Node.isDefaultNamespace.2.test
      @@@enDesc:
        Namespace declared as the namespace URI of the element itself.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createElementNS> ('about:', 'el');

        $test->id ('element.default');
        $test->assert_true ($el-><M::Node.isDefaultNamespace> ('about:'));

        $test->id ('element.prefix');
        $el-><AS::Node.prefix> ('ns1');
        $test->assert_false ($el-><M::Node.isDefaultNamespace> ('about:'));

        $test->id ('element.xmlns');
        $el-><M::Element.setAttributeNS> (<Q::xmlns:>, 'xmlns', 'DAV:');
        $test->assert_false ($el-><M::Node.isDefaultNamespace> ('about:'));

        $test->id ('element.xmlns.empty');
        $el-><M::Element.setAttributeNS> (<Q::xmlns:>, 'xmlns', '');
        $test->assert_false ($el-><M::Node.isDefaultNamespace> ('about:'));
    @@Test:
      @@@QName: Node.isDefaultNamespace.3.test
      @@@enDesc:
        Namespace declared as the attribute of the element itself.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createElementNS> ('about:', 'p:el');

        $test->id ('not.defined');
        $test->assert_false ($el-><M::Node.isDefaultNamespace> ('about:'));

        $test->id ('element.xmlns');
        $el-><M::Element.setAttributeNS> (<Q::xmlns:>, 'xmlns', 'about:');
        $test->assert_true ($el-><M::Node.isDefaultNamespace> ('about:'));

        $test->id ('element.xmlns.empty');
        $el-><M::Element.setAttributeNS> (<Q::xmlns:>, 'xmlns', '');
        $test->assert_false ($el-><M::Node.isDefaultNamespace> ('about:'));
    @@Test:
      @@@QName: Node.isDefaultNamespace.4.test
      @@@enDesc:
        The null default namespace on an element.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        $doc-><AG::Document.domConfig>
            -><M::c|DOMConfiguration.setParameter> ('error-handler' => sub { });
          # No warnings

        my $el = $doc-><M::Document.createElementNS> ('about:', 'p:el');

        $test->id ('not.defined.null');
        $test->assert_false ($el-><M::Node.isDefaultNamespace> (null));
        $test->id ('not.defined.empty');
        $test->assert_false ($el-><M::Node.isDefaultNamespace> (''));
          ## Strange result!

        $el-><M::Element.setAttributeNS> (<Q::xmlns:>, 'xmlns', 'DAV:');
        $test->id ('xmlns.null');
        $test->assert_false ($el-><M::Node.isDefaultNamespace> (null));
        $test->id ('xmlns.empty');
        $test->assert_false ($el-><M::Node.isDefaultNamespace> (''));

        $el-><M::Element.setAttributeNS> (<Q::xmlns:>, 'xmlns', '');
        $test->id ('xmlns.empty.null');
        $test->assert_true ($el-><M::Node.isDefaultNamespace> (null));
        $test->id ('xmlns.empty.empty');
        $test->assert_true ($el-><M::Node.isDefaultNamespace> (''));

  @LXAttr:
    @@Name: manakaiParentElement
    @@enDesc:
      The parent element of the node.
    @@Type: Element
    @@Get:
      @@@enDesc:
        = If the <A::Node.parentNode> of the node is <DOM::null>,
          return <DOM::null>.

        = Otherwise, if the <A::Node.parentNode> is an <IF::Element>,
          return it.

        = Otherwise, return the <A::Node.manakaiParentElement>
          of the <A::Node.parentNode> of the node.  It might be <DOM::null>.

            {ISSUE::
              Should owner element be returned for <IF::Attr>?
            }
      @@@nullCase:
        @@@@enDesc:
          If the node has no parent element.
      @@@PerlDef:
        my $n = $self-><AG::Node.parentNode>;
        N: while (defined $n) {
          if ($n-><AG::Node.nodeType> == <C::Node.ELEMENT_NODE>) {
            $r = $n;
            last N;
          } else {
            $n = $n-><AG::Node.parentNode>;
          }
        } # N

    @@Test:
      @@@QName: Node.manakaiParentElement.1.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        my $doc = $el-><AG::Node.ownerDocument>;

        $test->id ('no.parent');
        $test->assert_null ($el-><AG::Node.manakaiParentElement>);

        my $el2 = $doc-><M::Document.createElement> ('el2');
        $el-><M::Node.appendChild> ($el2);

        $test->id ('parent.element');
        $test->assert_equals ($el2-><AG::Node.manakaiParentElement>, $el);

        my $er1 = $doc-><M::Document.createEntityReference> ('er1');
        $er1-><M::Node.manakaiSetReadOnly> (false, true);
        $el-><M::Node.appendChild> ($er1);
        $er1-><M::Node.appendChild> ($el2);

        $test->id ('grandparent.element');
        $test->assert_equals ($el2-><AG::Node.manakaiParentElement>, $el);

  @L12Method:
    @@Name: normalize

     @@Description:
       @@@lang:en
       @@@@:
         Put all <IF::Text> nodes in the full depth of the sub-tree 
         underneath this <IF::Node>, including attribute nodes 
         attaced to the <IF::Element>, 
         into a <QUOTE::normal> form where only structures separate
         <IF::Text> nodes, i.e. there are neither adjacent <IF::Text> 
         nodes nor empty <IF::Text> nodes. <SRC::DOM 1, 2, 3>
       \
         If the parameter <cfg::normalize-characters> of the 
         <A::Document.domConfig> is <DOM::true>, the characters 
         of the <IF::Text> nodes will also be fully normalized. 
         <SRC::DOM 3>

    Adjacent <IF::tx|CDATASection> nodes are not merged.
    <SRC::DOM1, DOM2, DOM3>

     @@ImplNote:
       @@@lang:en
       @@@@:
         The spec does not say to normalize nodes other than 
         <IF::Text> (such as <IF::tx|CDATASection>, 
         <IF::Comment> and so on).
     @@Return:
      @@@dx:raises:
         @@@@@:
           MDOMX:NOMOD_THIS
         @@@@Description:
           @@@@@lang:en
           @@@@@@:
             This node is read-only. 
         @@@@For:
           ManakaiDOM:ManakaiDOM
      @@@dx:raises:
         @@@@@: c|NOMOD_DESCENDANT_ERR
         @@@@Description:
           @@@@@lang:en
           @@@@@@:
             One of descendant (or attribute) is read-only. 
         @@@@For:
           ManakaiDOM:ManakaiDOM
     @@ImplNote:
       @@@lang:en
       @@@@:
         This method was defined in the "Element" interface in the DOM 
         Level 1, but has beem moved to the "Node" interface in the 
         DOM Level 2.

  @L2Method:
    @@Name: isSupported
    @@enDesc:
      Tests whether the DOM implementation implements a
      specific feature and the feature is supported by the node.
    @@Param:
      @@@Name: feature
      @@@Type: DOMString
      @@@dis:actualType: f|FeatureNameString
      @@@enDesc:
        The name of the feature to test.
      @@@InCase:
        @@@@Label:
          @@@@@lang:en
          @@@@@@:
            Feature name preceded by a <CHAR::PLUS SIGN>
        @@@@enDesc:
          The feature may not be directly castable.  <SRC::DOM3>
    @@Param:
      @@@Name: version
      @@@Type: DOMString
      @@@dis:actualType: f|FeatureVersionString
      @@@enDesc:
        The version number of the feature to test.
      @@@nullCase:
        @@@@enDesc:
          Don't specify a particular version for the <P::feature>.
          <SRC::DOM3>
      @@@InCase:
        @@@@Value:
          @@@@@@: \
          @@@@@ContentType: DISCore|String
        @@@@enDesc:
          Don't specify a particular version for the <P::feature>.
          <SRC::DOM3>
      @@@enImplNote:
        Don't specify a particular version if the parameter
        is not specified. <SRC::DOM2>
    @@Return:
      @@@Type: boolean
      @@@TrueCase:
        @@@@enDesc:
          If the specified feature is supported on the node.
      @@@FalseCase:
        @@@@enDesc:
          Otherwise.
      @@@PerlDef:
        __DEEP{
          $r = $self-><M::f|GetFeature.hasFeature> ($feature, $version);
        }__;

  @L3Method:
    @@Name: isEqualNode
    @@Perlop: ==
    @@enDesc:
      Tests whether two nodes are equal.  This method tests
      for equality of nodes, not sameness which can be
      tested with <M::Node.isSameNode>.

      {P:: Two nodes are equal if and only if:

        - The two nodes are of the same type.

        - String attributes <A::Node.nodeName>, <A::Node.localName>,
          <A::Node.namespaceURI>, <A::Node.prefix>, and
          <A::Node.value> are equal, i.e. they are both <DOM::null>
          or they have the same length and are character for
          character identical.

        - The <A::Node.attributes> <IF::NamedNodeMap>s are equal,
          i.e. they are both <DOM::null>, or they have the
          same length and for each node that exists in one
          map there is a node that exists in the other map
          and is equal, although not necessarily at the same index.
          <SRC::DOM3>  In addition, if they are not <DOM::null>,
          the number of the items that are equal to a string in one list
          is equal to the number of such items in the other list.
          <SRC::manakai>

        {LI:: The <A::Node.childNodes> <IF::NodeList>s are equal, i.e.
              they are both <DOM::null>, or they have the same
              length and contain equal nodes at the same index.

              {SpecIssue:: It can never <DOM::null> by definition.
              }
        }

        - If they are <IF::tx|DocumentType>s, the string
          attributes <A::tx|DocumentType.publicId>, 
          <A::tx|DocumentType.systemId>, and
          <A::tx|DocumentType.internalSubset> are equal.

        - If they are <IF::tx|DocumentType>s, the <A::tx|DocumentType.entities>
          <IF::NamedNodeMap>s are equal.

        - If they are <IF::tx|DocumentType>s, the <A::tx|DocumentType.notations>
          <IF::NamedNodeMap>s are equal.

        - If they are <IF::tx|DocumentType>s and at least one of them
          has the <Feature::fe|XDoctype> feature, their <A::DTDef.elementTypes>
          <IF::NamedNodeMap>s are equal, i.e. they both has the
          <Feature::fe|XDoctype> feature and their <A::DTDef.elementTypes>
          are equal (as defined for <A::Node.attributes> except 
          that they cannot be <DOM::null>), or the <A::DTDef.elementTypes>
          of the node that has the <Feature::fe|XDoctype> feature
          is empty (i.e. its <A::NamedNodeMap.length> is zero).
          <SRC::manakai>
          
        - If they are <IF::ETDef>s, their <A::ETDef.attributeDefinitions>
          <IF::NamedNodeMap>s are equal (as defined for 
          <A::Node.attributes> except that they cannot be <DOM::null>).
          <SRC::manakai>

        - If they are <IF::ATDef>s, the numeric attributes
          <A::ATDef.declaredType> and <A::ATDef.defaultType> are equal.
          <SRC::manakai>

        - If they are <IF::ATDef>s, the <A::ATDef.allowedToken>
          <IF::c|DOMStringList>s are equal, i.e. they have
          the same <A::c|DOMStringList.length> and for each string
          that exists in one list there is a string that
          exists in the other list and is equal, although
          not necessarily at the same index.  In addition, 
          the number of the items that are equal to a string in one list
          is equal to the number of such items in the other list.
      }

        {NOTE::
          As a general rule, anything not mentioned in the description
          above is not significant in consideration of equality checking.
          Note that future versions of the DOM specification
          may take into account more attributes and implementations
          conform to the DOM specification are expected to be
          updated accordingly.
        }
    @@Param:
      @@@Name: arg
      @@@Type: Node
      @@@enDesc:
        The node to compare equality with.
    @@Return:
      @@@Type: boolean
      @@@TrueCase:
        @@@@enDesc:
          If the nodes are equal.
      @@@FalseCase:
        @@@@enDesc:
          Otherwise.
      @@@PerlDef:
        __DEEP{
          EQ: {
            last EQ unless UNIVERSAL::isa
                             ($arg, <IFName::Node||ManakaiDOM|ManakaiDOM>);
            my $nt = $self-><AG::Node.nodeType>;
            last EQ unless $nt == $arg-><AG::Node.nodeType>;

            my @str_attr = qw/node_name local_name namespace_uri
                              prefix node_value/;
            push @str_attr, qw/public_id system_id internal_subset/
                if $nt == <C::Node.DOCUMENT_TYPE_NODE>;
            for my $attr_name (@str_attr) {
              my $v1 = $self->can ($attr_name) ? $self->$attr_name : null;
              my $v2 = $arg->can ($attr_name) ? $arg->$attr_name : null;
              if (defined $v1 and defined $v2) {
                last EQ unless ''.$v1 eq ''.$v2;
              } elsif (defined $v1 or defined $v2) {
                last EQ;
              }
            }

            my @num_eq_attr = qw/child_nodes attributes/;
            push @num_eq_attr, qw/entities notations/
                if $nt == <C::Node.DOCUMENT_TYPE_NODE>;
            push @num_eq_attr, qw/attribute_definitions/
                if $nt == <C::Node.ELEMENT_TYPE_DEFINITION_NODE>;
            push @num_eq_attr, qw/declared_type default_type allowed_tokens/
                if $nt == <C::Node.ATTRIBUTE_DEFINITION_NODE>;
            for my $attr_name (@num_eq_attr) {
              my $v1 = $self->can ($attr_name) ? $self->$attr_name : null;
              my $v2 = $arg->can ($attr_name) ? $arg->$attr_name : null;
              if (defined $v1 and defined $v2) {
                last EQ unless $v1 == $v2;
              } elsif (defined $v1 or defined $v2) {
                last EQ;
              }
            }

            if ($nt == <C::Node.DOCUMENT_TYPE_NODE>) {
              my $dt1 = $self-><M::Node.getFeature> (<Q::fe|XDoctype>, '3.0');
              my $dt2 = $arg->can ('get_feature')
                          ? $arg-><M::Node.getFeature> (<Q::fe|XDoctype>, '3.0')
                          : null;
              if (defined $dt1 and defined $dt2) {
                last EQ unless $dt1-><AG::DTDef.elementTypes>
                                   == $dt2-><AG::DTDef.elementTypes>;
              } elsif (defined $dt1) {
                last EQ unless $dt1-><AG::DTDef.elementTypes>
                                   -><AG::NamedNodeMap.length> == 0;
              } elsif (defined $dt2) {
                last EQ unless $dt2-><AG::DTDef.elementTypes>
                                   -><AG::NamedNodeMap.length> == 0;
              }
            }

            $r = true;
          } # EQ
        }__;

    @@Test:
      @@@QName: Node.isEqualNode.1.test
      @@@enDesc:
        All nodes are equal to themselves.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        for my $node (<Code::tc|createNodesForTest+dt>) {
          $test->id ($node-><AG::Node.nodeName>.'.isEqualNode.self');
          $test->assert_true ($node-><M::Node.isEqualNode> ($node));

          $test->id ($node-><AG::Node.nodeName>.'.==.self');
          $test->assert_num_equals
                   (actual_value => $node, expected_value => $node);

          $test->id ($node-><AG::Node.nodeName>.'.==.string');
          $test->assert_num_not_equals
                   (actual_value => $node, expected_value => 'string');

          $test->id ($node-><AG::Node.nodeName>.'.==.0');
          $test->assert_num_not_equals
                   (actual_value => $node, expected_value => 0);

          $test->id ($node-><AG::Node.nodeName>.'.==.empty');
          $test->assert_num_not_equals
                   (actual_value => $node, expected_value => '');

          $test->id ($node-><AG::Node.nodeName>.'.==.null');
          $test->assert_num_not_equals
                   (actual_value => $node, expected_value => null);
        }
    @@Test:
      @@@QName: Node.isEqualNode.2.test
      @@@enDesc:
        Empty element equality.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el1 = $doc-><M::Document.createElementNS> (null, 'type');
        my $el2 = $doc-><M::Document.createElementNS> (null, 'type');
        my $el3 = $doc-><M::Document.createElementNS> (null, 'TYPE');

        $test->id ('==');
        $test->assert_num_equals
                 (actual_value => $el1, expected_value => $el2);

        $test->id ('not.==');
        $test->assert_num_not_equals
                 (actual_value => $el1, expected_value => $el3);
    @@Test:
      @@@QName: Node.isEqualNode.3.test
      @@@enDesc:
        Empty elementNS equality.
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el1 = $doc-><M::Document.createElementNS> ('about:', 'type');
        my $el2 = $doc-><M::Document.createElementNS> ('about:', 'type');
        my $el3 = $doc-><M::Document.createElementNS> ('about:', 'TYPE');
        my $el4 = $doc-><M::Document.createElementNS> ('DAV:', 'type');

        $test->id ('equal');
        $test->assert_num_equals
                 (actual_value => $el1, expected_value => $el2);

        $test->id ('different.local.name');
        $test->assert_num_not_equals
                 (actual_value => $el1, expected_value => $el3);

        $test->id ('different.namespace.uri');
        $test->assert_num_not_equals
                 (actual_value => $el1, expected_value => $el4);

        $test->id ('different.prefix');
        $el2-><AS::Node.prefix> ('prefix');
        $test->assert_num_not_equals
                 (actual_value => $el1, expected_value => $el2);

  @LXAttr:
    @@Name: manakaiExpandedURI
    @@enDesc:
      The expanded URI of the name of the node.
    @@Type: DOMString
    @@dis:actualType: ManakaiDOM|ManakaiDOMURI
    @@Get:
      @@@enDesc:
        The contatenation of the <A::Node.namespaceURI> of the node, if it 
        is <EM::not> <DOM::null>, and the <A::Node.localName> of the node.
      @@@nullCase:
        @@@@enDesc:
          If the local name of the node is <DOM::null>.
      @@@PerlDef:
        __DEEP{
          my $ln = $self-><AG::Node.localName>;
          if (defined $ln) {
            $r = $self-><AG::Node.namespaceURI>;
            if (defined $r) {
              $r .= $ln;
            } else {
              $r = $ln;
            }
          } else {
            $r = null;
          }
        }__;

    @@Test:
      @@@QName: Node.manakaiExpandedURI.null.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

        for my $node (<Code::tc|createNodesForTest-el-attr>) {
          $test->id ($node-><AG::Node.nodeName>);
          $test->assert_null ($node-><AG::Node.manakaiExpandedURI>);
        }
    @@Test:
      @@@QName: Node.manakaiExpandedURI.element.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createElement> ('el');
        $test->assert_equals ($el-><AG::Node.manakaiExpandedURI>, 'el');
    @@Test:
      @@@QName: Node.manakaiExpandedURI.element.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createElementNS> ('about:', 'el');
        $test->assert_equals ($el-><AG::Node.manakaiExpandedURI>, 'about:el');
    @@Test:
      @@@QName: Node.manakaiExpandedURI.attribute.1.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createAttribute> ('attr');
        $test->assert_equals ($el-><AG::Node.manakaiExpandedURI>, 'attr');
    @@Test:
      @@@QName: Node.manakaiExpandedURI.attribute.2.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $el = $doc-><M::Document.createAttributeNS> ('about:', 'a:attr');
        $test->assert_equals ($el-><AG::Node.manakaiExpandedURI>, 'about:attr');
##Node

ElementTypeBinding:
  @Name: RoleDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: DISLang|Role
    @@ForCheck: =ManakaiDOM|all

RoleDef:
  @QName: tc|ElementRole
  @enDesc:
    Any class playing this role may be retrievable from 
    <M::Node.getFeature> method of an <IF::Element> node. 

RoleDef:
  @QName: tc|AttributeRole
  @enDesc:
    Any class playing this role may be retrievable from 
    <M::Node.getFeature> method of an <IF::Attr> node. 

RoleDef:
  @QName: tc|TextRole
  @enDesc:
    Any class playing this role may be retrievable from 
    <M::Node.getFeature> method of an <IF::Text> node. 

RoleDef:
  @QName: tc|CommentRole
  @enDesc:
    Any class playing this role may be retrievable from 
    <M::Node.getFeature> method of an <IF::Comment> node. 

RoleDef:
  @QName: tc|DocumentRole
  @enDesc:
    Any class playing this role may be retrievable from 
    <M::Node.getFeature> method of an <IF::Document> node. 

RoleDef:
  @QName: tc|DocumentFragmentRole
  @enDesc:
    Any class playing this role may be retrievable from 
    <M::Node.getFeature> method of an <IF::DocumentFragment> node. 

RoleDef:
  @QName: tc|DocumentTypeRole
  @enDesc:
    Any class playing this role may be retrievable from 
    <M::Node.getFeature> method of an <IF::tx|DocumentType> node. 

RoleDef:
  @QName: tc|EntityRole
  @enDesc:
    Any class playing this role may be retrievable from 
    <M::Node.getFeature> method of an <IF::tx|Entity> node. 

RoleDef:
  @QName: tc|EntityReferenceRole
  @enDesc:
    Any class playing this role may be retrievable from 
    <M::Node.getFeature> method of an <IF::tx|EntityReference> node. 

RoleDef:
  @QName: tc|ProcessingInstructionRole
  @enDesc:
    Any class playing this role may be retrievable from 
    <M::Node.getFeature> method of an <IF::tx|ProcessingInstruction> node. 

RoleDef:
  @QName: tc|NotationRole
  @enDesc:
    Any class playing this role may be retrievable from 
    <M::Node.getFeature> method of a <IF::tx|Notation> node. 

RoleDef:
  @QName: tc|CDATASectionRole
  @enDesc:
    Any class playing this role may be retrievable from 
    <M::Node.getFeature> method of a <IF::tx|CDATASection> node. 

RoleDef:
  @QName: tc|NamespaceRole
  @enDesc:
    Any class playing this role may be retrievable from 
    <M::Node.getFeature> method of a <IF::DOMXPath:Namespace> node. 

RoleDef:
  @QName: tc|ElementTypeDefinitionRole
  @enDesc:
    Any class playing the <Q::tc|ElementTypeDefinitionRole>
    might be retrieved by <M::Node.getFeature> method of
    an <IF::d|ElementTypeDefinition> node.

RoleDef:
  @QName: tc|AttributeDefinitionRole
  @enDesc:
    Any class playing the <Q::tc|AttributeDefinitionRole>
    might be retrieved by <M::Node.getFeature> method of
    an <IF::d|AttributeDefinition> node.

RoleDef:
  @QName: tc|AnyNodeRole
  @enDesc:
    Any class playing this role may be retrievable from 
    <M::Node.getFeature> method of a <IF::Node> node. 
  @subsetOf: tc|ElementRole
  @subsetOf: tc|AttributeRole
  @subsetOf: tc|DocumentRole
  @subsetOf: tc|DocumentFragmentRole
  @subsetOf: tc|DocumentTypeRole
  @subsetOf: tc|TextRole
  @subsetOf: tc|CommentRole
  @subsetOf: tc|EntityRole
  @subsetOf: tc|EntityReferenceRole
  @subsetOf: tc|NotationRole
  @subsetOf: tc|ProcessingInstructionRole
  @subsetOf: tc|CDATASectionRole
  @subsetOf: tc|NamespaceRole

IntPropDef:
  @QName: tc|defaultNodeRefClass
  @tc:nodeStemKey: dnrcls
  @enDesc:
    The Perl package name of the default class for the node reference.

RPropDef:
  @QName: tc|nodeStemKey
  @enDesc:
    Hash key for <Class::ManakaiDOMNode||ManakaiDOM|ManakaiDOMLatest>
    node stems.
  @subsetOf: mg|nodeStemKey

ForDef:
  @QName: tc|ForAppendChild
  @ISA: ManakaiDOM|ForClass

ForDef:
  @QName: tc|ForInsertBefore
  @ISA: ManakaiDOM|ForClass

ForDef:
  @QName: tc|ForReplaceChild
  @ISA: ManakaiDOM|ForClass

ElementTypeBinding:
  @Name: iRaises
  @ElementType:
    dx:raises
  @ShadowContent:
    @@ForCheck: ManakaiDOM|ForIF

IntPropDef:
  @QName: tc|ownerDocument
  @tc:nodeStemKey: od

IntPropDef:
  @QName: tc|revOwnerDocument
  @enDesc:
    Reversed relationship for <Q::tc|ownerDocument>.
  @Type: HASH
  @tc:nodeStemKey: do

ElementTypeBinding:
  @Name: enDesc
  @ElementType:
    dis:Description
  @ShadowContent:
    @@lang:en

ElementTypeBinding:
  @Name: NodeReadOnlyError
  @ElementType:
    dx:raises
  @ShadowContent:
    @@@: MDOMX|NOMOD_THIS
    @@Description:
      @@@lang:en
      @@@@:
        The node is read-only.

ElementTypeBinding:
  @Name: intValue
  @ElementType:
    dis:Value
  @ShadowContent:
    @@ContentType: DISCore|Integer

ElementTypeBinding:
  @Name: TrueCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType:
      ManakaiDOM:InCase
    @@Value:
      @@@@: 1
      @@@ContentType: DISCore|Boolean
    @@Type: idl|boolean||ManakaiDOM|all

ElementTypeBinding:
  @Name: FalseCase
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType:
      ManakaiDOM:InCase
    @@Value:
      @@@@: 0
      @@@ContentType: DISCore|Boolean
    @@Type: idl|boolean||ManakaiDOM|all

NodeTypeDef:
  @IFQName: CharacterData
  @ClsQName: ManakaiDOMCharacterData

  @enDesc:
    The <IF::CharacterData> interface extends the <IF::Node>
    interface with a set of attributes and methods for
    accessing character data in the DOM.  No DOM objects correspond 
    directly to the <IF::CharacterData> interface -- the
    <IF::Text> interface and the <IF::Comment> interface
    inherits this interface.

    {ps:: <doc:caption::Positions in character data>

    All <CODE::offset>s in this interface start from <CODE::0>.  Since strings in
    the DOM are represented in UTF-16, indexing
    on <IF::CharacterData> is done in 16-bit units, i.e. characters
    allocated in the range <CODE::U+10000> to <CODE::U+10FFFF>
    (inclusive) are counted as two units.
    }

    {NOTE:: DOM implementations may not put arbitary limits on 
            the amount of the data that may be stored in a 
            <IF::CharacterData> node.  This might make a node's
            data cannot fit into a single <TYPE::DOMString>.
            See also <X::DOMSTRING_SIZE_ERR>.
    }

  @IntMethod:
    @@Operator: mg|CreateNodeStemMethod
    @@Param:
      @@@Name: bag
      @@@Type: HASH
    @@Param:
      @@@Name: obj
      @@@Type: HASH
    @@Param:
      @@@Name: opt
      @@@Type: HASH
    @@Return:
      @@@Type: HASH
      @@@PerlDef:
        $obj->{<H::infoset|content>} = $opt->{<H::infoset|content>};
        __CODE{mg|setOwnerProp||ManakaiDOM|all::
          $bag => $bag,
          $ownerref => {$opt->{<H::tc|ownerDocument>}},
          $ownee1hprop => {<H::tc|revOwnerDocument>},
          $ownee => {$obj},
          $owner0prop => {<H::tc|ownerDocument>},
        }__;
        $r = $obj;
  @mg:owner0: tc|ownerDocument
  @mg:origin0: infoset|parent

  @CAttr:
    @@Name: childNodes
    @@enDesc:
      A list of nodes that contains all children of the node.
    @@Get:
      @@@Type: c|NodeList
      @@@enDesc:
        Since <IF::CharacterData> nodes cannot have child nodes,
        the node list is always empty.
      @@@PerlDef:
        __CODE{tc|createEmptyNodeList::
          $r => $r,
        }__;

  @CMethod:
    @@Name: appendChild
    @@enDesc:
      Adds a node to the end of the list of children of the node.
      If that node is already in the tree, it is first removed.
    @@Param:
      @@@Name: newChild
      @@@Type: Node
      @@@enDesc:
        The node to add.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node added.
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_BAD_TYPE
        @@@@enDesc:
          The type of the node does not allow any children.
      @@@PerlDef:
        __EXCEPTION{MDOMX|HIERARCHY_BAD_TYPE::
          MDOMX|param-name => 'newChild',
          c|node => {$newChild},
        }__;

  @CMethod:
    @@Name: insertBefore
    @@enDesc:
      Inserts a node before the existing child node of the node.
    @@Param:
      @@@Name: newChild
      @@@Type: Node
      @@@enDesc:
        The node to add.
    @@Param:
      @@@Name: refChild
      @@@Type: Node
      @@@enDesc:
        The node before which the <P::newChild> node is inserted.
      @@@nullCase:
        @@@@enDesc:
          The <P::newChild> node is inserted at the end.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node added.
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_BAD_TYPE
        @@@@enDesc:
          The type of the node does not allow any children.
      @@@PerlDef:
        __EXCEPTION{MDOMX|HIERARCHY_BAD_TYPE::
          MDOMX|param-name => 'newChild',
          c|node => {$newChild},
        }__;

  @CMethod:
    @@Name: replaceChild
    @@enDesc:
      Replaces a node by another node.
    @@Param:
      @@@Name: newChild
      @@@Type: Node
      @@@enDesc:
        The node to add.
    @@Param:
      @@@Name: oldChild
      @@@Type: Node
      @@@enDesc:
        The node to remove.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node replaced.
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_BAD_TYPE
        @@@@enDesc:
          The type of the node does not allow any children.
      @@@PerlDef:
        __EXCEPTION{MDOMX|HIERARCHY_BAD_TYPE::
          MDOMX|param-name => 'newChild',
          c|node => {$newChild},
        }__;

  @CMethod:
    @@Name: manakaiAppendText
    @@Param:
      @@@Name: string
      @@@Type: DOMString
      @@@enDesc:
        The string to append.
      @@@InCase:
        @@@@Type: DISPerl|SCALAR||ManakaiDOM|all
        @@@@enDesc:
          A copy of the string value referenced from the value
          is appended.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node itself.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the node to insert the string or a <IF::Text> node
          is read-only.
      @@@PerlDef:
        __DEEP{
          if ($self-><AG::Node.ownerDocument>
                   -><AG::Document.strictErrorChecking> and
              $self-><AG::Node.manakaiReadOnly>) {
            __UNDEEP{__EXCEPTION{MDOMX|NOMOD_THIS::
            }__}__;
          }
          my $v;
          __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
            $r => $v,
            $prop => {<H::infoset|content>},
            $ref => $self,
          }__;
          $$v .= ref $string eq 'SCALAR' ? $$string : $string;
          $r = $self;
        }__;

  @CAttr:
    @@Name: nodeValue
    @@enDesc:
      The value of the node.
    @@Type: DOMString
    @@Get:
      @@@disDef:
        @@@@DISPerl:cloneCode: .data.get
    @@Set:
      @@@NodeReadOnlyError:
      @@@disDef:
        @@@@DISPerl:cloneCode: .data.set

  @CL3Attr:
    @@Name: textContent
    @@enDesc:
      The text content of the node.
    @@Type: DOMString
    @@Get:
      @@@disDef:
        @@@@DISPerl:cloneCode: .data.get
    @@Set:
      @@@nullCase:
        @@@@enImplNote:
          The DOM Level 3 Core specification is unclear on 
          setting <DOM::null> to the <A::Node.textContent>
          attribute to the node whose type is so defined
          that it has same effect as <A::Node.nodeValue>.
      @@@NodeReadOnlyError:
      @@@disDef:
        @@@@DISPerl:cloneCode: .data.set

  @CL3Attr:
    @@Name: baseURI
    @@enDesc:
      The base URI of the node.
    @@Type: DOMString
    @@Get:
      @@@nullCase:
        @@@@enDesc:
          If it is not available.
      @@@PerlDef:
        __DEEP{
          my $pe = $self-><AG::Node.parentNode>;
          W: {
            while (defined $pe) {
              my $nt = $pe-><AG::Node.nodeType>;
              if ($nt == <C::Node.ELEMENT_NODE> or
                  $nt == <C::Node.ATTRIBUTE_NODE> or
                  $nt == <C::Node.DOCUMENT_NODE> or
                  $nt == <C::Node.DOCUMENT_FRAGMENT_NODE> or
                  $nt == <C::Node.ENTITY_NODE>) {
                $r = $pe-><AG::Node.baseURI>;
                last W;
              } elsif ($nt == <C::Node.ENTITY_REFERENCE_NODE>) {
                if ($pe-><AG::tx|EntityReference.manakaiExternal>) {
                  $r = $pe-><AG::tx|EntityReference.manakaiEntityBaseURI>;
                  last W;
                }
              }
              $pe = $pe-><AG::Node.parentNode>;
            }
            if ($pe) {
              $r = $pe-><AG::Node.baseURI>;
            } else {
              $r = $self-><AG::Node.ownerDocument>-><AG::Node.baseURI>;
            }
          } # W
        }__;

  @Attr:
    @@Name: data
    @@enDesc:
      The character data of the node.

      The DOM implementation may not put arbitary limits on the
      amount of data that may be stored in a <IF::CharacterData> node.
      However, implementation limits may mean that the entirely
      of a node's data may not fit into a single <TYPE::DOMString>.
      In such cases, applications may call <M::CharacterData.substringData>
      to retrieve the data in appropriately sized pieces.

      If the node is a <IF::tx|CDATASection>, it is the
      content of the <XML::CDATA> section.  Since DOM implementation
      does no lexical check on the content of the <XML::CDATA>
      section, <A::CharacterData.data> might include the character
      sequence equals to <SGML::MSE>, i.e. <XML::]]<gt>> in XML.
    @@Type: DOMString
    @@Get:
      @@@iRaises:
        @@@@@: c|DOMSTRING_SIZE_ERR
        @@@@enDesc:
          When it would return more characters than fit in a
          <TYPE::DOMString> variable on the implementation platform.
      @@@PerlDef:
        my $v;
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $v,
          $prop => {<H::infoset|content>},
          $ref => $self,
        }__;
        $r = $$v;
    @@Set:
      @@@NodeReadOnlyError:
      @@@PerlDef:
        __CODE{tc|NodeReadOnlyError:: $node => $self}__;
        my $v;
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $v,
          $prop => {<H::infoset|content>},
          $ref => $self,
        }__;
        $$v = defined $given ? $given : '';
                ## NOTE: Setting NULL is supported for
                ##       compatibility with |textContent|.

    @@Test:
      @@@QName: CharacterData.nodeValue.data.textContent.test
      @@@PerlDef:
        my $doc;
        __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
  
        for my $node (
          $doc-><M::Document.createTextNode> ('initial value'),
          $doc-><M::Document.createComment> ('initial value'),
          $doc-><M::Document.createCDATASection> ('initial value'),
        ) {
          $test->id ($node-><AG::Node.nodeType>.'.nodeValue.get');
          $test->assert_equals ($node-><AG::Node.nodeValue>, 'initial value');

          $test->id ($node-><AG::Node.nodeType>.'.textContent.get');
          $test->assert_equals ($node-><AG::Node.textContent>,
                                'initial value');

          $test->id ($node-><AG::Node.nodeType>.'.data.get');
          $test->assert_equals ($node-><AG::CharacterData.data>,
                                'initial value');

          $node-><M::Node.manakaiSetReadOnly> (false);

          $node-><AS::Node.nodeValue> ('value1');

          $test->id ($node-><AG::Node.nodeType>.'.nodeValue.set.nodeValue');
          $test->assert_equals ($node-><AG::Node.nodeValue>, 'value1');

          $test->id ($node-><AG::Node.nodeType>.'.nodeValue.set.textContent');
          $test->assert_equals ($node-><AG::Node.textContent>, 'value1');

          $test->id ($node-><AG::Node.nodeType>.'.nodeValue.set.data');
          $test->assert_equals ($node-><AG::CharacterData.data>, 'value1');

          $node-><AS::Node.nodeValue> ('');

          $test->id ($node-><AG::Node.nodeType>.'.nodeValue.empty.nodeValue');
          $test->assert_equals ($node-><AG::Node.nodeValue>, '');

          $test->id ($node-><AG::Node.nodeType>.'.nodeValue.empty.text');
          $test->assert_equals ($node-><AG::Node.textContent>, '');

          $test->id ($node-><AG::Node.nodeType>.'.nodeValue.empty.data');
          $test->assert_equals ($node-><AG::CharacterData.data>, '');

          $node-><AS::Node.textContent> ('value3');

          $test->id ($node-><AG::Node.nodeType>.'.textContent.set.nodeValue');
          $test->assert_equals ($node-><AG::Node.nodeValue>, 'value3');

          $test->id ($node-><AG::Node.nodeType>.'.textContent.set.text');
          $test->assert_equals ($node-><AG::Node.textContent>, 'value3');

          $test->id ($node-><AG::Node.nodeType>.'.textContent.set.data');
          $test->assert_equals ($node-><AG::CharacterData.data>, 'value3');

          $node-><AS::Node.textContent> ('');

          $test->id ($node-><AG::Node.nodeType>.'.text.empty.nodeValue');
          $test->assert_equals ($node-><AG::Node.nodeValue>, '');

          $test->id ($node-><AG::Node.nodeType>.'.textContent.empty.text');
          $test->assert_equals ($node-><AG::Node.textContent>, '');

          $test->id ($node-><AG::Node.nodeType>.'.textContent.empty.data');
          $test->assert_equals ($node-><AG::CharacterData.data>, '');

          $node-><AS::Node.textContent> ('value4');
          $node-><AS::Node.textContent> (null);

          $test->id ($node-><AG::Node.nodeType>.'.text.null.nodeValue');
          $test->assert_equals ($node-><AG::Node.nodeValue>, '');

          $test->id ($node-><AG::Node.nodeType>.'.textContent.null.text');
          $test->assert_equals ($node-><AG::Node.textContent>, '');

          $test->id ($node-><AG::Node.nodeType>.'.textContent.null.data');
          $test->assert_equals ($node-><AG::CharacterData.data>, '');

          $node-><AS::CharacterData.data> ('value2');

          $test->id ($node-><AG::Node.nodeType>.'.data.set.nodeValue');
          $test->assert_equals ($node-><AG::Node.nodeValue>, 'value2');

          $test->id ($node-><AG::Node.nodeType>.'.data.set.textContent');
          $test->assert_equals ($node-><AG::Node.textContent>, 'value2');

          $test->id ($node-><AG::Node.nodeType>.'.data.set.data');
          $test->assert_equals ($node-><AG::CharacterData.data>, 'value2');
     
          $node-><AS::CharacterData.data> ('');

          $test->id ($node-><AG::Node.nodeType>.'.data.empty.nodeValue');
          $test->assert_equals ($node-><AG::Node.nodeValue>, '');

          $test->id ($node-><AG::Node.nodeType>.'.data.empty.textContent');
          $test->assert_equals ($node-><AG::Node.textContent>, '');

          $test->id ($node-><AG::Node.nodeType>.'.data.empty.data');
          $test->assert_equals ($node-><AG::CharacterData.data>, '');

          $node-><M::Node.manakaiSetReadOnly> (true);

          $test->id ($node-><AG::Node.nodeType>.'.nodeValue.set.ro');
          $test->assert_exception (code => sub {
            $node-><AS::Node.nodeValue> ('value1');
          }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);
          $test->assert_equals ($node-><AG::Node.nodeValue>, '');

          $test->id ($node-><AG::Node.nodeType>.'.textContent.set.ro');
          $test->assert_exception (code => sub {
            $node-><AS::Node.textContent> ('value1');
          }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);
          $test->assert_equals ($node-><AG::Node.nodeValue>, '');

          $test->id ($node-><AG::Node.nodeType>.'.data.set.ro');
          $test->assert_exception (code => sub {
            $node-><AS::CharacterData.data> ('value1');
          }, exception_subtype => <Q::MDOMX|NOMOD_THIS>);
          $test->assert_equals ($node-><AG::Node.nodeValue>, '');
        }

  @Attr:
    @@Name: length
     @@Description:
       @@@lang:en
       @@@@: 
         The number of 16-bit units of the "data".
    @@Offset16Note:
     @@Get:
      @@@Type: unsignedLong
        @@@Description:
          @@@@lang:en
          @@@@@: The number of 16-bit units of the "data".
      @@@PerlDef:
        my $v = $self-><AG::CharacterData.data>;
        $r = CORE::length $v;
        $r++ while $v =~ /[\x{10000}-\x{10FFFF}]/g;

  @Method:
    @@Name: substringData
     @@Description:
       @@@lang:en
       @@@@:
         Extract a range of data from the node.
    @@Offset16Note:
     @@Param:
        @@@Name:  offset
      @@@Type: unsignedLong
        @@@Description:
          @@@@lang:en
          @@@@@: Start offset of substring to extract.
     @@Param:
        @@@Name:  count
      @@@Type: unsignedLong
        @@@Description:
          @@@@lang:en
          @@@@@:
          The number of 16-bit units to extract.  If the sum of the
          parameters offset and count exceeds the length of the
          DOMString then all 16-bit units from offset to the end
          of the DOMString are returned.
    @@Return:
      @@@Type: DOMString
      @@@Description:
        @@@@lang:en
        @@@@@: The specified substring.
#      @@@Exception:
#        @@@@Type: DOMException
#        @@@@Name: INDEX_SIZE_ERR
#        @@@@Description:
#          @@@@@lang:en
#          @@@@@@:
#            The specified "offset" is negative or greater than
#            the number of 16-bit units in the "DOMString", or the specified
#            "count" is negative.
      @@@iRaises:
        @@@@@: c|DOMSTRING_SIZE_ERR
        @@@@enDesc:
          When it would return more characters than fit in a
          <TYPE::DOMString> variable on the implementation platform.
#      @@@Exception:
#        @@@@Type: 
#          ManakaiDOM:ManakaiDOMImplementationException
#        @@@@Name: MDOM_INDEX_IN_SURROGATE_PAIR
#        @@@@Description:
#          @@@@@lang:en
#          @@@@@@: An attempt is made to break surrogate pair.
#      @@@PerlDef:
#        __DEEP{
#          my $v = $self-><AG::CharacterData.data>;
#          my $offset32 = <ClassM::DOMMain:ManakaiDOMStringExtend.findOffset32>
#                            ($v, $offset);
#          my $coffset32 = <ClassM::DOMMain:ManakaiDOMStringExtend.findOffset32>
#                            ($v, $offset + $count);
#          $r = substr $v, $offset32, $coffset32 - $offset32;
#        }__;

  @Method:
    @@Name: appendData
     @@Description:
       @@@lang:en
       @@@@:
         Append the string to the end of the character data of the node.
     @@Param:
        @@@Name:  arg
      @@@Type: DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The string to append.
    @@Return:
      @@@NodeReadOnlyError:
      @@@PerlDef:
        __DEEP{
          $self-><M::Node.manakaiAppendText> (\$arg);
        }__;

  @Method:
    @@Name: insertData
     @@Description:
       @@@lang:en
       @@@@: Insert a string at the specified 16-bit unit offset. 
    @@Offset16Note:
    @@Param:
      @@@Name: offset
      @@@Type: unsignedLong
      @@@Description:
        @@@@lang:en
        @@@@@: The offset from which to insert.
    @@Param:
      @@@Name: arg
      @@@Type: DOMString
      @@@Description:
        @@@@lang:en
        @@@@@: The DOMString to insert.
    @@Return:
#      @@@Exception:
#        @@@@Type: DOMException
#        @@@@Name: INDEX_SIZE_ERR
#        @@@@Description:
#          @@@@@lang:en
#          @@@@@@:
#            The specified "offset" is negative or greater than
#            the number of 16-bit units in the DOMString.
      @@@NodeReadOnlyError:
#      @@@Exception:
#        @@@@Type: 
#          ManakaiDOM:ManakaiDOMImplementationException
#        @@@@Name: MDOM_INDEX_IN_SURROGATE_PAIR
#        @@@@Description:
#          @@@@@lang:en
#          @@@@@@: An attempt is made to break surrogate pair.
#      @@@PerlDef:
#        if ($self->{<H::mn:node>}->{<H::DOMCore:read-only>}) {
#          __EXCEPTION{
#            MDOMX:NOMOD_THIS::
#          }__;
#        }
#        __DEEP{
#          my $offset32 = <ClassM::DOMMain:ManakaiDOMStringExtend.findOffset32>
#                            ($offset);
#          substr ($self->{<H::mn:node>}->{<H::infoset:content>},
#                  $offset32, 0) = $arg;
#        }__;

  @Method:
    @@Name: deleteData
     @@Description:
        @@@lang:en
        @@@@: 
          Remove a range of 16-bit units from the node.
    @@Offset16Note:
    @@Param:
      @@@Name: offset
      @@@Type: unsignedLong
      @@@Description:
        @@@@lang:en
        @@@@@: The offset from which to start removing.
    @@Param:
      @@@Name: count
      @@@Type: unsignedLong
      @@@Description:
        @@@@lang:en
        @@@@@:
          The number of 16-bit units to delete.  If the sum of the
          parameters offset and count exceeds the length of the
          DOMString then all 16-bit units from offset to the end
          of the DOMString are deleted.
    @@Return:
#      @@@Exception:
#        @@@@Type: DOMException
#        @@@@Name: INDEX_SIZE_ERR
#        @@@@Description:
#          @@@@@lang:en
#          @@@@@@:
#            The specified "offset" is negative or greater than
#            the number of 16-bit units in the DOMString, or the specified
#            "count" is negative.
      @@@NodeReadOnlyError:
#      @@@Exception:
#        @@@@Type: 
#          ManakaiDOM:ManakaiDOMImplementationException
#        @@@@Name: MDOM_INDEX_IN_SURROGATE_PAIR
#        @@@@Description:
#          @@@@@lang:en
#          @@@@@@: 
#            An attempt is made to break surrogate pair.
#      @@@PerlDef:
#        if ($self->{<H::mn:node>}->{<H::DOMCore:read-only>}) {
#          __EXCEPTION{
#            MDOMX:NOMOD_THIS::
#          }__;
#        }
#        __DEEP{
#          my $offset32 = <ClassM::DOMMain:ManakaiDOMStringExtend.findOffset32>
#                            ($offset);
#          substr ($self->{<H::mn:node>}->{<H::infoset:content>}, $offset32, 0)
#            = '';
#        }__;

  @Method:
    @@Name: replaceData
    @@Description:
      @@@lang:en
      @@@@:
        Replace the characters starting at the specified 16-bit unit 
        offset with the specified string.
    @@Offset16Note:
    @@Param:
      @@@Name: offset
      @@@Type: unsignedLong
      @@@Description:
        @@@@lang:en
        @@@@@: The offset from which to start replacing.
    @@Param:
      @@@Name: count
      @@@Type: unsignedLong
      @@@Description:
        @@@@lang:en
        @@@@@:
          The number of 16-bit units to replace.  If the sum of the
          parameters offset and count exceeds the length of the
          DOMString then all 16-bit units from offset to the end
          of the DOMString are replaced.
    @@Param:
      @@@Name: arg
      @@@Type: DOMString
      @@@Description:
        @@@@lang:en
        @@@@@: The DOMString with which the range is replaced.
    @@Return:
#      @@@Exception:
#        @@@@Type: DOMException
#        @@@@Name: INDEX_SIZE_ERR
#        @@@@Description:
#          @@@@@lang:en
#          @@@@@@:
#            The specified "offset" is negative or greater than
#            the number of 16-bit units in the DOMString, or the specified
#            "count" is negative.
      @@@NodeReadOnlyError:
#      @@@Exception:
#        @@@@Type: 
#          ManakaiDOM:ManakaiDOMImplementationException
#        @@@@Name: MDOM_INDEX_IN_SURROGATE_PAIR
#        @@@@Description:
#          @@@@@lang:en
#          @@@@@@: An attempt is made to break surrogate pair.
      @@@PerlDef:
#        if ($self->{<H::mn:node>}->{<H::DOMCore:read-only>}) {
#          __EXCEPTION{
#            MDOMX:NOMOD_THIS::
#          }__;
#        }
#        __DEEP{
#          my $offset32 = <ClassM::DOMMain:ManakaiDOMStringExtend.findOffset32>
#                            ($offset);
#          my $coffset32 = <ClassM::DOMMain:ManakaiDOMStringExtend.findOffset32>
#                            ($offset + $count);
#          substr ($self->{<H::mn:node>}->{<H::infoset:content>},
#                  $offset32, $coffset32 - $offset32) = $arg;
#        }__;
##CharacterData

ElementTypeBinding:
  @Name: Offset16Note
  @ElementType:
    dis:Description
  @ShadowContent:
    @@lang:en
    @@@:
      {NOTE::
        Since strings are hold as sequences of characters in Perl
        rather than as sequences of UTF-16 code units in DOM,
        use of this method would be a bad choice in the viewpoint
        of performance.  Usually applications should prefer normal
        string functions of Perl.
      }
    @@For: ManakaiDOM|ManakaiDOM
    @@ddid:Offset16Note

IFCls1Def:
  @IFQName: Text
  @ClsQName: ManakaiDOMText

  @IFISA: CharacterData
  @ClsISA: ManakaiDOMCharacterData
  
  @DISLang:role: tc|TextRole

  @enDesc:
    A <IF::Text> object represents a textual content of an
    <IF::Element> or <IF::Attr> (termed <DFN::character data>
    in XML).  If there is no markup inside an element's content,
    the text is contained in a single <IF::Text> object that
    is the only child of the element.  If there is markup,
    it is parsed into the information items (elements,
    comments, and so on) that form the list of children of the element,
    where sequences of character information items consist 
    <IF::Text> nodes.

    When a document is first made available via the DOM,
    there is only one <IF::Text> node for each block
    of text.  Applications may create adjacent <IF::Text> nodes
    that represents the contents of a given element without any
    intervening markup, but should be aware that there is no way
    to represent the separations between these nodes in
    XML or HTML, so they will not in general persisten between
    DOM editing sessions.  The <M::Node.normalize> method
    merges any such adjacent <IF::Text> nodes into a single
    node for each block of text.

    No lexical check or parsing is done on the content of a <IF::Text> node
    and some characters must be escaped, depending on its position
    in the document, during serialization using character or
    general entity references.

  @enImplNote:
    @@ddid: props
    @@@:
      {P:: Required internal properties:

        - <Q::tc|ownerDocument>.

        - <Q::infoset|content>.

      }

      {P:: Optional internal properties:

        - <Q::infoset|parent>.

        - <Q::c|read-only>.

      }

  @CODE:
    @@QName: tc|createTextForTest
    @@PerlDef:
      my $__doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $__doc}__;
      $text = $__doc-><M::Document.createTextNode> ('text');

  @CAttr:
    @@Name: nodeType
    @@Type: unsignedShort
    @@dis:actualType: NodeType
    @@Get:
      @@@disDef:
        @@@@DISLang:constValue: Node.TEXT_NODE

    @@Test:
      @@@QName: Text.nodeType.test
      @@@PerlDef:
        my $text;
        __CODE{tc|createTextForTest:: $text => $text}__;

        $test->id ('nodeType');
        $test->assert_num_equals
                 (actual_value => $text-><AG::Node.nodeType>,
                  expected_value => <C::Node.TEXT_NODE>);

  @Test:
    @@QName: Text.parentNode.1.test
    @@PerlDef:
      my $text;
      __CODE{tc|createTextForTest:: $text => $text}__;

      $test->assert_null ($text-><AG::Node.parentNode>);

  @Test:
    @@QName: Text.isSameNode.1.test
    @@PerlDef:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

      my $el = $doc-><M::Document.createTextNode> ('a');

      my $el2 = $doc-><M::Document.createTextNode> ('a');
      
      $test->id ('same');
      $test->assert_equals ($el, $el);
      
      $test->id ('diff');
      $test->assert_not_equals ($el, $el2);
      
      $test->id ('doc');
      $test->assert_not_equals ($el, $doc);
  @Test:
    @@QName: Text.isSameNode.2.test
    @@PerlDef:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

      my $el = $doc-><M::Document.createTextNode> ('a');

      my $el2 = $doc-><M::Document.createTextNode> ('a');
      
      $test->id ('same');
      $test->assert_true ($el-><M::Node.isSameNode> ($el));
      
      $test->id ('diff');
      $test->assert_false ($el-><M::Node.isSameNode> ($el2));
      
      $test->id ('doc');
      $test->assert_false ($el-><M::Node.isSameNode> ($doc));

  @LXTest:
    @@QName: Text.readOnly.test
    @@PerlDef:
      my $text;
      __CODE{tc|createTextForTest:: $text => $text}__;

      $test->id ('default');
      $test->assert_false ($text-><AG::Node.manakaiReadOnly>);

  @CAttr:
    @@Name: nodeName
    @@enDesc:
      The node name.
    @@DOMMain:isNamespaceUnaware:1
    @@Type: DOMString
    @@Get:
      @@@DefaultValue:
        @@@@@: \#text
        @@@@ContentType:
          DISCore:String
      @@@disDef:
        @@@@DISLang:nop:

    @@Test:
      @@@QName: Text.nodeName.test
      @@@PerlDef:
        my $text;
        __CODE{tc|createTextForTest:: $text => $text}__;

        $test->assert_equals ($text-><AG::Node.nodeName>, '#text');

  @Test:
    @@QName: Text.appendChild.test
    @@PerlDef:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
      my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

      my $text = $doc-><M::Document.createTextNode> ('data');
      my $node2 = $doc-><M::Document.createTextNode> ('2');

      for my $node (<Code::tc|createNodesForTest+dt>) {
        $test->id ('appendChild.'.$node-><AG::Node.nodeType>);
        $test->assert_exception (code => sub {
          $text-><M::Node.appendChild> ($node);
        }, exception_subtype => <Q::MDOMX|HIERARCHY_BAD_TYPE>);

        $test->id ('insertBefore.'.$node-><AG::Node.nodeType>);
        $test->assert_exception (code => sub {
          $text-><M::Node.insertBefore> ($node);
        }, exception_subtype => <Q::MDOMX|HIERARCHY_BAD_TYPE>);

        $test->id ('replaceChild.'.$node-><AG::Node.nodeType>);
        $test->assert_exception (code => sub {
          $text-><M::Node.replaceChild> ($node, $node2);
        }, exception_subtype => <Q::MDOMX|HIERARCHY_BAD_TYPE>);
      }

  @Test:
    @@QName: Text..=.1.test
    @@PerlDef:
      my $doc;
      __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;

      my $node = $doc-><M::Document.createTextNode> ('');

      $node-><M::Node.manakaiAppendText> ('aaaa');
      $test->id ('1.class');
      $test->assert_isa ($node, <IFName::Text>);
      $test->id ('1.value');
      $test->assert_equals ($node-><AG::CharacterData.data>, 'aaaa');

      $test->id (2);
      $node-><M::Node.manakaiAppendText> ('bbbb');
      $test->assert_equals ($node-><AG::CharacterData.data>, 'aaaabbbb');

  @CL3Method:
    @@Name: getFeature
    @@enDesc:
      Returns a specialized object that implements the specialized APIs.
    @@Param:
      @@@Name: feature
      @@@Type: DOMString
      @@@dis:actualType: f|FeatureNameString
    @@Param:
      @@@Name: version
      @@@Type: DOMString
      @@@dis:actualType: f|FeatureVersionString
    @@Return:
      @@@Type: DOMMain|DOMObject
      @@@nullCase:
      @@@PerlDef:
        $feature =~ s/^\+//;
        __CODE{f|getFeatureImpl::
          $self => $self,
          $feature => $feature, $version => $version, $r => $r,
          $base_class => {<ClassName::ManakaiDOMText>},
        }__;
        unless (defined $r) {
          __DEEP{
            $r = $self->SUPER::get_feature ($feature, $version);
          }__;
        }

    @@Test:
      @@@QName: Text.getFeature.test
      @@@PerlDef:
        my $node;
        __CODE{tc|createTextForTest:: $text => $node}__;

        for (
          [Core => '1.0', <IFName::Text||ManakaiDOM|ManakaiDOM1>],
          [Core => '2.0', <IFName::Text||ManakaiDOM|ManakaiDOM2>],
          [Core => '3.0', <IFName::Text||ManakaiDOM|ManakaiDOM3>],
          [XML => '1.0', <IFName::Text||ManakaiDOM|ManakaiDOM1>],
          [XML => '2.0', <IFName::Text||ManakaiDOM|ManakaiDOM2>],
          [XML => '3.0', <IFName::Text||ManakaiDOM|ManakaiDOM3>],
        ) {
          $test->id ($_->[0].'.'.$_->[1]);
          my $sp = $node-><M::Node.getFeature> ($_->[0], $_->[1]);
          $test->assert_isa ($sp, $_->[2]);
        }

  @LXTest:
    @@QName: Text.baseURI.test
    @@PerlDef:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $pi = $doc-><M::Document.createTextNode> ('text');
       
        $test->id ('default');
        $test->assert_null ($pi-><AG::Node.baseURI>);

        $test->id ('doc');
        $doc-><AS::Document.documentURI> (q<http://doc.test/>);
        $test->assert_equals
                 ($pi-><AG::Node.baseURI>,
                  q<http://doc.test/>);

        $test->id ('el');
        my $el = $doc-><M::Document.createElementNS> (null, 'e');
        $el-><M::Element.setAttributeNS> (<Q::xml:>, 'xml:base',
                                          q<http://el.test/>);
        $el-><M::Node.appendChild> ($pi);
        $test->assert_equals
                 ($pi-><AG::Node.baseURI>,
                  q<http://el.test/>);

        $test->id ('ent');
        my $ent = $doc-><M::Document.createEntityReference> ('ent');
        $ent-><M::Node.manakaiSetReadOnly> (false, true);
        $ent-><AS::tx|EntityReference.manakaiExternal> (true);
        $ent-><AS::tx|EntityReference.manakaiEntityBaseURI>
                (q<http://ent.test/>);
        $el-><M::Node.appendChild> ($ent);
        $ent-><M::Node.appendChild> ($pi);
        $test->assert_equals
                 ($pi-><AG::Node.baseURI>,
                  q<http://ent.test/>);

  @L3Attr:
    @@Name: isElementContentWhitespace
    @@enDesc:
      Whether the text node contains element content white spaces.

      The text node is determined to contain white space in element
      content during the load of the document or if validation occurs
      while using <M::Document.normalizeDocument>.
    @@enImplNote:
      @@@ddid: ??
      @@@@:
        <IF::Text> with non-white-space-characters or with
        no white space character?

        <IF::CDATASection>?
    @@Type: boolean
    @@Get:
      @@@PerlDef:
        __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
          $r => $r,
          $prop => {<H::infoset|elementContentWhitespace>},
          $ref => $self,
        }__;
    @@LXSet:
      @@@enImplNote:
        {TODO::
          Clarification is necessary.
        }
      @@@NodeReadOnlyError:
      @@@PerlDef:
        __CODE{tc|NodeReadOnlyError:: $node => $self}__;
        __CODE{mg|setNodeStemPropValue||ManakaiDOM|all::
          $given => $given,
          $prop => {<H::infoset|elementContentWhitespace>},
          $ref => $self,
        }__;

    @@Test:
      @@@QName: Text.isElementContentWhitespace.test
      @@@PerlDef:
        my $node;
        __CODE{tc|createTextForTest:: $text => $node}__;
        $node-><AS::Node.nodeValue> (' ');

        $test->id ('default');
        $test->assert_false ($node-><AG::Text.isElementContentWhitespace>);

        $test->id ('set.true');
        $node-><AS::Text.isElementContentWhitespace> (true);
        $test->assert_true ($node-><AG::Text.isElementContentWhitespace>);

        $test->id ('set.false');
        $node-><AS::Text.isElementContentWhitespace> (false);
        $test->assert_false ($node-><AG::Text.isElementContentWhitespace>);

  @L3Attr:
    @@Name: wholeText
     @@Description:
       @@@lang:en
       @@@@:
         All text of logically-adjacent text nodes.
     @@ImplNote:
       @@@lang:en
       @@@@:
         The DOM Level 3 Core Specification is unclear about 
         <IF::tx|CDATASection>s.
         They should also be included (c.f. the definition for 
         <A::Text.replaceWholeText>).
         \
         What about unexpanded entity references?
    @@Type: DOMString
    @@Get:
      @@@enImplNote:
        {TODO::
          Implement this.
        }

  @L3Method:
    @@Name: replaceWholeText
     @@Param:
        @@@Name:  content
        @@@Type:  
          DOMMain:DOMString
     @@Return:
        @@@Type:  Text
    @@enImplNote:
      {ISSUE::
        isElementContentWhitespace
      }

  @Method:
    @@Name: splitText
     @@Description:
       @@@lang:en
       @@@@:
         Break this node into two nodes.  After being split, 
         this node will contain all the content up to the break point 
         and a new node of the same type will contain all the content 
         at and after the break point.
      \
         If the original node had a parent node, the new node is 
         inserted as the next sibling of this node.

      {ISSUE::
         isElementContentWhitespace
      }
     @@Param:
        @@@Name:  offset
        @@@Type:  
          DOMMain:unsigned-long||ManakaiDOM|all
        @@@Description:
          @@@@lang:en
          @@@@@:
            The 16-bit unit offset at which to split.
     @@Return:
        @@@Type:  Text
        @@@Description:
          @@@@lang:en
          @@@@@: The new node, of the same type as this node.
       @@@dx:raises:
         @@@@@: c|NEGATIVE_INDEX_ERR
         @@@@enDesc:
           The <P::offset> is negative.
       @@@dx:raises:
         @@@@@: c|OUT_OF_UPPER_BOUND_ERR
         @@@@enDesc:
           The <P::offset> is greater than the number of
           16-bit units.
       @@@dx:raises:
         @@@@@: MDOMX|NOMOD_THIS
         @@@@enDesc:
           The node is read-only.
       @@@dx:raises:
         @@@@@: MDOMX|NOMOD_PARENT
         @@@@enDesc:
           The parent node is read-only.
         @@@@For: ManakaiDOM|ManakaiDOM
      @@@PerlDef:
        @@@@@ForCheck: !ManakaiDOM|all
        @@@@@enImplNote:
          {TODO::
            Implement this.
          }
        @@@@@@:
          my $node = $self->{<H::mn:node>};
          my $parentNode = $node->{<H::infoset:parent>};
          if ($node->{<H::DOMCore:read-only>}) {
            __EXCEPTION{
              MDOMX:NOMOD_THIS::
            }__;
          } elsif ($parentNode and $parentNode->{<H::DOMCore:read-only>}) {
            __EXCEPTION{
              MDOMX:NOMOD_PARENT::
            }__;
          }
          my $ds = \$node->{<H::infoset:content>};
          my $after;
          try {
            my $offset32 = <ClassM::DOMMain:ManakaiDOMStringExtend
                                   .findOffset32> ($offset);
            $after = substr ($$ds, $offset32);
            substr ($$ds, $offset32) = '';
          ## TODO: Catch StringIndexOutOfBoundsException
          };
          my $newNode;
          if ($node->{<H::DOMCore:nodeType>} eq <H::DOMCore:TextNode>) {
            $newNode = <ClassM::ManakaiDOMText.newObject> ($node);
          } elsif ($node->{<H::DOMCore:nodeType>} eq
                   <H::tx|CDATASectionNode>) {
            $newNode = <ClassM::tx|ManakaiDOMCDATASection.newObject> ($node);
          } else {
            __EXCEPTION{
              MDOMX:MDOM_DEBUG_BUG||ManakaiDOM:Perl::
                MDOMX:values => {+{
                  <H::DOMCore:nodeType> => $node->{<H::DOMCore:nodeType>},
                }},
            }__;
          }
          $newNode->{<H::infoset:content>} = $after;
          __CODE{mn|setXRefNode||ManakaiDOM|Perl::
            $referrer => {$newNode},
            $propName => {<H::DOMCore:ownerDocument>},
            $referent => {$parentNode->{<H::DOMCore:ownerDocument>}},
          }__;
          if ($parentNode) {
            $parentNode-><M::NodeStem.importTree> ($newNode);
            A: for my $i (0..$#{$parentNode->{<H::infoset:children>}}) {
              if ($parentNode->{<H::infoset:children>}->[$i]->{<H::mn:nodeID>} eq
                  $node->{<H::mn:nodeID>}) {
                splice @{$parentNode->{<H::infoset:children>}},
                       $i + 1, 0, $newNode;
                last A;
              }
            }
            $newNode->{<H::infoset:parent>} = $parentNode;
          }
          __CODE{mn|setXRefNode||ManakaiDOM|Perl::
            $referrer => {$newNode},
            $propName => {<H::DOMCore:ownerDocument>},
            $referent => {$node->{<H::DOMCore:ownerDocument>}},
          }__;
##Text

IFCls1Def:
  @IFQName: Comment
  @ClsQName: ManakaiDOMComment

  @IFISA: CharacterData
  @ClsISA: ManakaiDOMCharacterData

  @DISLang:role: tc|CommentRole

  @enDesc:
    A <IF::Comment> object represents the content of a comment,
    i.e. all the characters between the starting <XML::<!--> and
    ending <XML::--<gt>> in XML.

    No lexical check is done on the content of a <IF::Comment>
    and it is therefore possible to have the character sequence
    <CODE::--> in the content, which is illegal in a comment
    per XML specification.  Such <IF::Comment> node cannot be
    serialized in XML.

  @enImplNote:
    @@ddid: props
    @@@:
      {P:: Required internal properties:

        - <Q::tc|ownerDocument>.

        - <Q::infoset|content>.

      }

      {P:: Optional internal properties:

        - <Q::infoset|parent>.

        - <Q::c|read-only>.

      }

  @CODE:
    @@QName: tc|createCommentForTest
    @@PerlDef:
      my $__doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $__doc}__;
      $text = $__doc-><M::Document.createComment> ('text');

  @CAttr:
    @@Name: nodeType
    @@Type: unsignedShort
    @@dis:actualType: NodeType
    @@Get:
      @@@disDef:
        @@@@DISLang:constValue: Node.COMMENT_NODE

    @@Test:
      @@@QName: Comment.nodeType.test
      @@@PerlDef:
        my $text;
        __CODE{tc|createCommentForTest:: $text => $text}__;

        $test->id ('nodeType');
        $test->assert_num_equals
                 (actual_value => $text-><AG::Node.nodeType>,
                  expected_value => <C::Node.COMMENT_NODE>);

  @Test:
    @@QName: Comment.parentNode.1.test
    @@PerlDef:
      my $text;
      __CODE{tc|createCommentForTest:: $text => $text}__;

      $test->assert_null ($text-><AG::Node.parentNode>);

  @Test:
    @@QName: Comment.isSameNode.1.test
    @@PerlDef:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

      my $el = $doc-><M::Document.createComment> ('a');

      my $el2 = $doc-><M::Document.createComment> ('a');
      
      $test->id ('same');
      $test->assert_equals ($el, $el);
      
      $test->id ('diff');
      $test->assert_not_equals ($el, $el2);
      
      $test->id ('doc');
      $test->assert_not_equals ($el, $doc);
  @Test:
    @@QName: Comment.isSameNode.2.test
    @@PerlDef:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

      my $el = $doc-><M::Document.createComment> ('a');

      my $el2 = $doc-><M::Document.createComment> ('a');
      
      $test->id ('same');
      $test->assert_true ($el-><M::Node.isSameNode> ($el));
      
      $test->id ('diff');
      $test->assert_false ($el-><M::Node.isSameNode> ($el2));
      
      $test->id ('doc');
      $test->assert_false ($el-><M::Node.isSameNode> ($doc));

  @LXTest:
    @@QName: Comment.readOnly.test
    @@PerlDef:
      my $text;
      __CODE{tc|createCommentForTest:: $text => $text}__;

      $test->id ('default');
      $test->assert_false ($text-><AG::Node.manakaiReadOnly>);
  
  @CAttr:
    @@Name: nodeName
    @@enDesc:
      The node name.
    @@DOMMain:isNamespaceUnaware:1
    @@Type: DOMString
    @@DOMMain:isNamespaceUnaware:1
    @@Get:
      @@@disDef: 
        @@@@DISLang:value:
          @@@@@@: \#comment
          @@@@@ContentType:
            DISCore:String

    @@Test:
      @@@QName: Comment.nodeName.test
      @@@PerlDef:
        my $text;
        __CODE{tc|createCommentForTest:: $text => $text}__;

        $test->assert_equals ($text-><AG::Node.nodeName>, '#comment');

  @Test:
    @@QName: Comment.appendChild.test
    @@PerlDef:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;
      my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>);

      my $comment = $doc-><M::Document.createComment> ('data');
      my $node2 = $doc-><M::Document.createComment> ('data');

      for my $node (<Code::tc|createNodesForTest+dt>) {
        $test->id ('appendChild.'.$node-><AG::Node.nodeType>);
        $test->assert_exception (code => sub {  
          $comment-><M::Node.appendChild> ($node);
        }, exception_subtype => <Q::MDOMX|HIERARCHY_BAD_TYPE>);

        $test->id ('insertBefore.'.$node-><AG::Node.nodeType>);
        $test->assert_exception (code => sub {  
          $comment-><M::Node.insertBefore> ($node);
        }, exception_subtype => <Q::MDOMX|HIERARCHY_BAD_TYPE>);

        $test->id ('replaceChild.'.$node-><AG::Node.nodeType>);
        $test->assert_exception (code => sub {  
          $comment-><M::Node.replaceChild> ($node, $node2);
        }, exception_subtype => <Q::MDOMX|HIERARCHY_BAD_TYPE>);
      }

  @Test:
    @@QName: Comment..=.1.test
    @@PerlDef:
      my $doc;
      __CODE{tc|createDocumentForTestDA:: $doc => $doc}__;

      my $node = $doc-><M::Document.createComment> ('');

      $node-><M::Node.manakaiAppendText> ('aaaa');
      $test->id ('1.class');
      $test->assert_isa ($node, <IFName::Comment>);
      $test->id ('1.value');
      $test->assert_equals ($node-><AG::CharacterData.data>, 'aaaa');

      $test->id (2);
      $node-><M::Node.manakaiAppendText> ('bbbb');
      $test->assert_equals ($node-><AG::CharacterData.data>, 'aaaabbbb');

  @CL3Method:
    @@Name: getFeature
    @@enDesc:
      Returns a specialized object that implements the specialized APIs.
    @@Param:
      @@@Name: feature
      @@@Type: DOMString
      @@@dis:actualType: f|FeatureNameString
    @@Param:
      @@@Name: version
      @@@Type: DOMString
      @@@dis:actualType: f|FeatureVersionString
    @@Return:
      @@@Type: DOMMain|DOMObject
      @@@nullCase:
      @@@PerlDef:
        $feature =~ s/^\+//;
        __CODE{f|getFeatureImpl::
          $self => $self,
          $feature => $feature, $version => $version, $r => $r,
          $base_class => {<ClassName::ManakaiDOMComment>},
        }__;
        unless (defined $r) {
          __DEEP{
            $r = $self->SUPER::get_feature ($feature, $version);
          }__;
        }

    @@Test:
      @@@QName: Comment.getFeature.test
      @@@PerlDef:
        my $node;
        __CODE{tc|createCommentForTest:: $text => $node}__;

        for (
          [Core => '1.0', <IFName::Comment||ManakaiDOM|ManakaiDOM1>],
          [Core => '2.0', <IFName::Comment||ManakaiDOM|ManakaiDOM2>],
          [Core => '3.0', <IFName::Comment||ManakaiDOM|ManakaiDOM3>],
          [XML => '1.0', <IFName::Comment||ManakaiDOM|ManakaiDOM1>],
          [XML => '2.0', <IFName::Comment||ManakaiDOM|ManakaiDOM2>],
          [XML => '3.0', <IFName::Comment||ManakaiDOM|ManakaiDOM3>],
        ) {
          $test->id ($_->[0].'.'.$_->[1]);
          my $sp = $node-><M::Node.getFeature> ($_->[0], $_->[1]);
          $test->assert_isa ($sp, $_->[2]);
        }

  @LXTest:
    @@QName: Comment.baseURI.test
    @@PerlDef:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

        my $pi = $doc-><M::Document.createComment> ('data');
       
        $test->id ('default');
        $test->assert_null ($pi-><AG::Node.baseURI>);

        $test->id ('doc');
        $doc-><AS::Document.documentURI> (q<http://doc.test/>);
        $test->assert_equals
                 ($pi-><AG::Node.baseURI>,
                  q<http://doc.test/>);

        $test->id ('el');
        my $el = $doc-><M::Document.createElementNS> (null, 'e');
        $el-><M::Element.setAttributeNS> (<Q::xml:>, 'xml:base',
                                          q<http://el.test/>);
        $el-><M::Node.appendChild> ($pi);
        $test->assert_equals
                 ($pi-><AG::Node.baseURI>,
                  q<http://el.test/>);

        $test->id ('ent');
        my $ent = $doc-><M::Document.createEntityReference> ('ent');
        $ent-><M::Node.manakaiSetReadOnly> (false, true);
        $ent-><AS::tx|EntityReference.manakaiExternal> (true);
        $ent-><AS::tx|EntityReference.manakaiEntityBaseURI>
                (q<http://ent.test/>);
        $el-><M::Node.appendChild> ($ent);
        $ent-><M::Node.appendChild> ($pi);
        $test->assert_equals
                 ($pi-><AG::Node.baseURI>,
                  q<http://ent.test/>);
##Comment

ResourceDef:
  @QName: DocumentFragment
  @AliasFor: td|DocumentFragment
  @For: ManakaiDOM|DOM

ForDef:
  @QName: tc|ForChildNodeList
  @enDesc:
    For node lists returned by the attribute <A::Node.childNodes>.
  @ISA: ManakaiDOM|ForClass

ForDef:
  @QName: tc|ForGetNodeList
  @enDesc:
    For node lists returned by e.g. the method <M::Element.getElementsByTagName>.
  @ISA: ManakaiDOM|ForClass

ForDef:
  @QName: tc|ForEmptyNodeList
  @enDesc:
    For always-empty node lists.
  @ISA: ManakaiDOM|ForClass

ResourceDef:
  @DISCore:resourceType:
    @@@: dis|MultipleResource
    @@ForCheck:
      !ManakaiDOM|ForIF !tc|ForChildNodeList !tc|ForGetNodeList
      !tc|ForEmptyNodeList
  @ForCheck: ManakaiDOM|DOM

  @resourceFor: ManakaiDOM|ForIF
  @IFQName: NodeList
  @DISCore:resourceType:
    @@@: DISLang|Interface
    @@ForCheck: ManakaiDOM|ForIF

  @f:implements:
    @@@: c|CoreFeature10
    @@ForCheck: ManakaiDOM|DOM1
  @f:implements:
    @@@: c|CoreFeature20
    @@ForCheck: ManakaiDOM|DOM2
  @f:implements:
    @@@: c|CoreFeature30
    @@ForCheck: ManakaiDOM|DOM3

  @resourceFor:
    @@@: tc|ForChildNodeList
    @@For: ManakaiDOM|ManakaiDOMLatest
  @QName:
    @@@: ManakaiDOMChildNodeList
    @@ForCheck: tc|ForChildNodeList
  @DISCore:resourceType:
    @@@: DISLang|Class
    @@ForCheck: tc|ForChildNodeList

  @AppISA:
    @@ForCheck: tc|ForChildNodeList
    @@ContentType: DISPerl|Perl
    @@@:
      Tie::Array

  @resourceFor:
    @@@: tc|ForGetNodeList
    @@ForCheck:
      ManakaiDOM:ManakaiDOM !=ManakaiDOM:ManakaiDOM
  @QName:
    @@@: ManakaiDOMGetElementsNodeList
    @@ForCheck: tc|ForGetNodeList
  @DISCore:resourceType:
    @@@: DISPerl|Class
    @@ForCheck: tc|ForGetNodeList

  @AppISA:
    @@ForCheck: tc|ForGetNodeList
    @@ContentType: DISPerl|Perl
    @@@:
      Tie::Array

  @resourceFor:
    @@@: tc|ForEmptyNodeList
    @@ForCheck: ManakaiDOM|ManakaiDOMLatest
  @QName:
    @@@: ManakaiDOMEmptyNodeList
    @@ForCheck: tc|ForEmptyNodeList
  @DISCore:resourceType:
    @@@: DISLang|Class
    @@ForCheck: tc|ForEmptyNodeList

  @Implement:
    @@@: NodeList||ManakaiDOM|ManakaiDOM
    @@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM
  @Implement:
    @@@: NodeList||ManakaiDOM|ManakaiDOM1
    @@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM1
  @Implement:
    @@@: NodeList||ManakaiDOM|ManakaiDOM2
    @@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM2
  @Implement:
    @@@: NodeList||ManakaiDOM|ManakaiDOM3
    @@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM3
  @Implement:
    @@@: NodeList||ManakaiDOM|ManakaiDOMLatest
    @@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOMLatest

  @enDesc:
    Objects implementing the <IF::NodeList> interface are used
    to represent ordered collections of nodes.

    The <IF::NodeList> objects are live <SRC::DOM1, DOM2, DOM3>; which means
    that the <IF::NodeList> objects are always <QUOTE::up-to-date>.
    For example, a <IF::NodeList> obtained from the 
    <A::Node.childNodes> attribute of an empty element would 
    have its <A::NodeList.length> value of <CODE::1> after
    a <M::Node.appendChild> operation would have appended a node
    to the element.

    {NOTE:: How this collection is implemented is neither defined
            nor constrained.
    }

    The items in the <IF::NodeList> are accessible via
    an ordinal index, starting from zero.

  @enDesc:
    @@For: ManakaiDOM|ManakaiDOM
    @@@:
      In the manakai implementation, <IF::NodeList> can be 
      dereferenced as if it is an array reference.  For 
      example, <Perl::@a = @$nodeList> result in the array
      <Perl::@a> containing all <IF::Node>s in the <Perl::$nodeList>.
      Please note that <Perl::@a> is just a Perl array and
      it is <EM::not> live.

  @enDesc:
    {NOTE:: <IF::NodeList>s are different from <IF::NamedNodeMap>s
            in that <IF::NodeList>s are <EM::ordered> and
            <IF::NamedNodeMap>s are not.
    }

  @Method:
    @@Name: item
    @@Perlop: FETCH
    @@enDesc:
      Returns an item in the collection.
    @@Param:
      @@@Name: index
      @@@Type: unsignedLong
      @@@enDesc:
        The index of the item to retrieve into the collection.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The <P::index>th node in the collection.
      @@@nullCase:
        @@@@enDesc:
          If the <P::index> is greater than or equal
          to the number of nodes in the collection.
      @@@PerlDef:
        @@@@ForCheck: tc|ForChildNodeList
        @@@@@:
          my $v;
          __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
            $r => $v,
            $prop => {<H::infoset|children>},
            $ref => {$$$self},
          }__;
          if ($index >= 0 and defined $v->[$index]) {
            __CODE{mg|createNodeRefFromID||ManakaiDOM|all::
              $bag => {<Code::mg|getNodeBag||ManakaiDOM|all:: $ref = {$$$self}>},
              $stemid => {$v->[$index]},
              $ref => $r,
              $opt => {{
                <H::mg|nodeRefInterfaces> => [<IFName::Node>],
              }},
            }__;
          }
      @@@PerlDef:
        @@@@ForCheck: tc|ForGetNodeList
        @@@@@:
          __DEEP{
            my @target = @{$$self->[0]-><AG::Node.childNodes>};
            my $i = -1;
            T: while (@target) {
              my $target = shift @target;
              my $nt = $target-><AG::Node.nodeType>;
              if ($nt == <C::Node.ELEMENT_NODE>) {
                if ($$self->[1]->($target)) {
                  if (++$i == $index) {
                    $r = $target;
                    last T;
                  }
                }
              }
              unshift @target, @{$target-><AG::Node.childNodes>};
            } # T
          }__;
        @@@@enImplNote:
          {TODO::
            Improve the implementation.
          }
      @@@PerlDef:
        @@@@ForCheck: tc|ForEmptyNodeList
        @@@@@: \

    @@Test:
      @@@ForCheck: tc|ForChildNodeList
      @@@QName: ChildNodeList.item.1.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        my $doc = $el-><AG::Node.ownerDocument>;
        my $cl = $el-><AG::Node.childNodes>;

        my $e1 = $doc-><M::Document.createElementNS> (null, 'e');
        $el-><M::Node.appendChild> ($e1);
        my $e2 = $doc-><M::Document.createElementNS> (null, 'e');
        $el-><M::Node.appendChild> ($e2);
        my $e3 = $doc-><M::Document.createElementNS> (null, 'e');
        $el-><M::Node.appendChild> ($e3);

        $test->id ('0');
        $test->assert_equals ($cl-><M::NodeList.item> (0), $e1);

        $test->id ('1');
        $test->assert_equals ($cl-><M::NodeList.item> (1), $e2);

        $test->id ('2');
        $test->assert_equals ($cl-><M::NodeList.item> (2), $e3);

        $test->id ('3');
        $test->assert_null ($cl-><M::NodeList.item> (3));

        $test->id ('-1');
        $test->assert_null ($cl-><M::NodeList.item> (-1));

    @@Test:
      @@@ForCheck: tc|ForChildNodeList
      @@@QName: ChildNodeList.item.2.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        my $doc = $el-><AG::Node.ownerDocument>;
        my $cl = $el-><AG::Node.childNodes>;

        $test->id ('0');
        $test->assert_null ($cl-><M::NodeList.item> (0));

        $test->id ('1');
        $test->assert_null ($cl-><M::NodeList.item> (1));

        $test->id ('-1');
        $test->assert_null ($cl-><M::NodeList.item> (-1));

  @IntMethod:
    @@Perlop: STORE
    @@Description:
      @@@lang:en
      @@@@:
        Sets an item. 
    @@Param:
      @@@Name:index
      @@@Type: unsignedLong
      @@@Description:
        @@@@lang:en
        @@@@@:
          An ordinal index in the list.  If the <P::index> is greater 
          than the number of items, then it is appended to the end of 
          the list.  A negative index is converted into a positive 
          index by Perl. 
    @@Param:
      @@@Name:value
      @@@Type: Node
      @@@Description:
        @@@@lang:en
        @@@@@:
          The node to set at the <P::index>th position in the list. 
    @@Return:
      @@@Type:Node
      @@@Description:
        @@@@lang:en
        @@@@@:
          The old node that has been replaced to the new <P::value>. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            No node has been removed from this list. 
      @@@dx:raises:
        @@@@@: c|NOMOD_NODELIST_ERR
        @@@@enDesc:
          A <IF::NodeList> returned by <M::Document.getElementsByTagNameNS> 
          or like is unable to be edited. 
        @@@@ForCheck: tc|ForGetNodeList
      @@@dx:raises:
        @@@@@: c|NOMOD_NODELIST_ERR
        @@@@enDesc:
          A <IF::NodeList> is unable to be edited. 
        @@@@ForCheck: tc|ForEmptyNodeList
      @@@disDef:
        @@@@DOMMain:raiseException: c|NOMOD_NODELIST_ERR
        @@@@ForCheck: tc|ForGetNodeList
      @@@disDef:
        @@@@DOMMain:raiseException: c|NOMOD_NODELIST_ERR
        @@@@ForCheck: tc|ForEmptyNodeList
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_BAD_TYPE
        @@@@enDesc:
          If the node is of a type that does not allow children of
          the type of the <P::newChild> node.
        @@@@ForCheck: tc|ForChildNodeList
      @@@dx:raises:
        @@@@@: c|DIFFERENT_DOCUMENT_ERR
        @@@@enDesc:
          If the <P::newChild> node was created from a different
          document than the one that created the node.
        @@@@ForCheck: tc|ForChildNodeList
      @@@NodeReadOnlyError:
        @@@@ForCheck: tc|ForChildNodeList
      @@@PerlDef:
        @@@@ForCheck: tc|ForChildNodeList
        @@@@@:
          __DEEP{
            my $current = $self->[$index];
            if ($current) {
              $r = $$$self-><M::Node.replaceChild> ($value, $current);
            } else {
              $$$self-><M::Node.appendChild> ($value);
            }
          }__;

  @IntMethod:
    @@Perlop: DELETE
    @@Description:
      @@@lang:en
      @@@@:
        Removes an item from this list. 
        \
        Unlike the deletion for Perl's standard array, this method 
        removes an item and moves the rest of the array (i.e. items 
        whose index is greater than <P::index>) one position, since 
        the <IF::NodeList> cannot contain a <DOM::null> value. 
    @@Param:
      @@@Name:index
      @@@Type: unsignedLong
      @@@Description:
        @@@@lang:en
        @@@@@:
          An ordinal index in the list.  If the <P::index> is greater 
          than the number of items, then no item is removed.
          A negative index is converted into a positive 
          index by Perl. 
    @@Return:
      @@@Type:Node
      @@@Description:
        @@@@lang:en
        @@@@@:
          The node removed from this list. 
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            No node has removed from this list. 
      @@@dx:raises:
        @@@@@: c|NOMOD_NODELIST_ERR
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            A <IF::NodeList> returned by <M::Document.getElementsByTagNameNS> 
            or like is unable to be edited. 
        @@@@ForCheck: !tc|ForChildNodeList
      @@@disDef:
        @@@@DOMMain:raiseException: c|NOMOD_NODELIST_ERR
        @@@@ForCheck: !tc|ForChildNodeList
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_BAD_TYPE
        @@@@enDesc:
          If the node is of a type that does not allow children of
          the type of the <P::newChild> node.
        @@@@ForCheck: tc|ForChildNodeList
      @@@NodeReadOnlyError:
        @@@@ForCheck: tc|ForChildNodeList
      @@@PerlDef:
        @@@@ForCheck: tc|ForChildNodeList
        @@@@@:
          __DEEP{
            my $current = $self->[$index];
            if ($current) {
              $r = $$$self-><M::Node.removeChild> ($current);
            }
          }__;

  @Attr:
    @@Name: length
    @@Perlop: FETCHSIZE
    @@enDesc:
      The number of nodes in the list.
    @@Type: unsignedLong
    @@Get:
      @@@PerlDef:
        @@@@ForCheck: tc|ForChildNodeList
        @@@@@:
          my $v;
          __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
            $r => $v,
            $prop => {<H::infoset|children>},
            $ref => {$$$self},
          }__;
          $r = @$v;
      @@@PerlDef:
        @@@@ForCheck: tc|ForGetNodeList
        @@@@@:
          __DEEP{
            my @target = @{$$self->[0]-><AG::Node.childNodes>};
            $r = 0;
            T: while (@target) {
              my $target = shift @target;
              my $nt = $target-><AG::Node.nodeType>;
              if ($nt == <C::Node.ELEMENT_NODE>) {
                if ($$self->[1]->($target)) {
                  $r++;
                }
              }
              unshift @target, @{$target-><AG::Node.childNodes>};
            } # T
          }__;
      @@@PerlDef:
        @@@@ForCheck: tc|ForEmptyNodeList
        @@@@@:\

    @@Test:
      @@@ForCheck: tc|ForChildNodeList
      @@@QName: ChildNodeList.length.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;

        my $doc = $el-><AG::Node.ownerDocument>;
        my $cl = $el-><AG::Node.childNodes>;

        $test->id ('initial');
        $test->assert_num_equals
                 (actual_value => 0+@$cl, expected_value => 0);

        $test->id ('1');
        $el-><M::Node.appendChild> ($doc-><M::Document.createComment> ('c'));
        $test->assert_num_equals
                 (actual_value => 0+@$cl, expected_value => 1);

        $test->id ('2');
        $el-><M::Node.appendChild> ($doc-><M::Document.createComment> ('c'));
        $test->assert_num_equals
                 (actual_value => 0+@$cl, expected_value => 2);

        $test->id ('0');
        $el-><AS::Node.textContent> ('');
        $test->assert_num_equals
                 (actual_value => 0+@$cl, expected_value => 0);

  @IntMethod:
    @@Perlop: STORESIZE
    @@Description:
      @@@lang:en
      @@@@:
        Changes the size of this node list.
    @@Param:
      @@@Name:count
      @@@Type: unsignedLong
      @@@Description:
        @@@@lang:en
        @@@@@: 
          The new length of this list.  If the <P::count> 
          is smaller than the current <A::NodeList.length>, <P::count>th or 
          greater index'th items are removed from this list.  Otherwise, 
          no action.
    @@Return:
      @@@NoModGetNodeList:
      @@@PerlDef:
        @@@@ForCheck: tc|ForChildNodeList
        @@@@@:
          __DEEP{
            my $current_length = @$self;
            if ($current_length > $count) {
              for (my $i = $current_length - 1; $i >= $count; $i--) {
                $$$self-><M::Node.removeChild> ($self->[$i]);
              }
            }
          }__;

  @IntMethod:
     @@Perlop: EXISTS
     @@Description:
       @@@lang:en
       @@@@:
         Returns whether an item exists in this list or not. 
     @@Param:
       @@@Name:index
       @@@Type: unsignedLong
       @@@Description:
         @@@@lang:en
         @@@@@:
           The ordinal index of the item to test. 
     @@Return:
      @@@Type: boolean
      @@@PerlDef:
        @@@@ForCheck: tc|ForChildNodeList
        @@@@@:
          my $v;
          __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
            $r => $v,
            $prop => {<H::infoset|children>},
            $ref => {$$$self},
          }__;
          $r = CORE::exists $v->[$index];
      @@@PerlDef:
        @@@@ForCheck: tc|ForGetNodeList
        @@@@@:
          __DEEP{
            $r = (defined $self-><M::NodeList.item> ($index));
          }__;
      @@@PerlDef:
        @@@@ForCheck: tc|ForEmptyNodeList
        @@@@@:\

  @IntMethod:
    @@Perlop: ==
    @@enDesc:
      Returns whether two node list are equal or not.

      Two node lists are equal if and only if their
      <A::NodeList.length>s are equal and their
      <M::NodeList.item>s at the same indeces are equal respectively.
    @@Param:
      @@@Name: arg
      @@@Type: NodeList
      @@@enDesc:
        The node list to compare.
    @@Return:
      @@@Type: boolean
      @@@TrueCase:
        @@@@enDesc:
          Two node lists are equal.
      @@@FalseCase:
        @@@@enDesc:
          Otherwise.
      @@@PerlDef:
        __DEEP{
          EQ: {
            last EQ unless UNIVERSAL::isa ($arg, <IFName::NodeList>);

            my $length1 = $self-><AG::NodeList.length>;
            my $length2 = $arg-><AG::NodeList.length>;
            last EQ unless $length1 == $length2;

            for my $i (0..($length1-1)) {
              unless ($self-><M::NodeList.item> ($i)
                          == $arg-><M::NodeList.item> ($i)) {
                last EQ;
              }
            }

            $r = true;
          } # EQ
        }__;

  @IntMethod:
    @@ForCheck: !tc|ForEmptyNodeList
    @@Perlop:TIEARRAY
    @@ManakaiDOM:isStatic:1
    @@Description:
      @@@lang:en
      @@@@:
        Binds a node list to an array.  This method is intended to 
        be called by Perl <Perl::tie> function. 
    @@Param:
      @@@Name: nodeList
      @@@Type: NodeList
      @@@Description:
        @@@@lang:en
        @@@@@:
          A node list that is tied with an array. 
    @@Return:
      @@@Type: NodeList
      @@@Description:
        @@@@lang:en
        @@@@@:
          The node list to which the array has bound, 
          i.e. <P::nodeList>.
      @@@PerlDef:
        $r = $nodeList;

  @IntMethod:
    @@Perlop:CLEAR
    @@Description:
      @@@lang:en
      @@@@:
        Removes all items from this list. 
    @@Return:
      @@@NoModGetNodeList:
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_BAD_TYPE
        @@@@enDesc:
          If the node is of a type that does not allow children of
          the type of the <P::newChild> node.
        @@@@ForCheck: tc|ForChildNodeList
      @@@NodeReadOnlyError:
        @@@@ForCheck: tc|ForChildNodeList
      @@@PerlDef:
        @@@@ForCheck: tc|ForChildNodeList
        @@@@@:
          __DEEP{
            my $length = @$self;
            for (1..$length) {
              $$$self-><M::Node.removeChild> ($$$self-><AG::Node.firstChild>);
            }
          }__;

  @IntMethod:
    @@Perlop:@{}
    @@Description:
      @@@lang:en
      @@@@:
        Returns an array representation of this node list. 
        \
        {NOTE:: It is intended that most operations through the 
                array is as like ones in DOM Level 0 JavaScript 
                implementations as possible. 
        \
        }
    @@Return:
      @@@Type: DISPerl|ARRAY||ManakaiDOM|all
      @@@PerlDef:
        @@@@ForCheck: !tc|ForEmptyNodeList
        @@@@@:
          tie my @list, ref $self, $self;
          $r = \@list;
      @@@PerlDef:
        @@@@ForCheck: tc|ForEmptyNodeList
        @@@@@: \

  @CODE:
    @@QName: tc|createChildNodeList
    @@ForCheck: tc|ForChildNodeList
    @@enDesc:
      Creats a new child node list.
    @@PerlDef:
      $r = bless \\($node), <ClassName::ManakaiDOMChildNodeList>;

  @CODE:
    @@QName: tc|createGetElementsNodeList
    @@ForCheck: tc|ForGetNodeList
    @@enDesc:
      Creates a new <IF::NodeList> for get elements methods.
      
      <Perl::$node>: The node reference from which the traversal
                     starts.

      <Perl::$chk>: The node filter for elements.

      <Perl::$r>: The created node list.
    @@PerlDef:
      $r = bless \[$node, $chk], <ClassName::ManakaiDOMGetElementsNodeList>;

  @CODE:
    @@QName: tc|createEmptyNodeList
    @@ForCheck: tc|ForEmptyNodeList
    @@enDesc:
      Creats a new empty node list.
    @@PerlDef:
      $r = bless [], <ClassName::ManakaiDOMEmptyNodeList>;
##NodeList

ElementTypeBinding:
  @Name:NoModGetNodeList
  @ElementType:
    DISCore:resourceType
  @ShadowContent: DISCore|Resource
  @ShadowSibling:
    @@dx:raises:
      @@@@: c|NOMOD_NODELIST_ERR
      @@@Description:
        @@@@lang:en
        @@@@@:
          A <IF::NodeList> returned by <M::Document.getElementsByTagNameNS> 
          or like is unable to be edited. 
      @@@ForCheck: !tc|ForEmptyNodeList
    @@disDef:
      @@@DOMMain:raiseException: c|NOMOD_NODELIST_ERR
      @@@ForCheck: !tc|ForEmptyNodeList

ElementTypeBinding:
  @Name: Perlop
  @ElementType:
    dis:Operator
  @ShadowContent:
    @@ContentType: DISPerl|Perl
    @@For: ManakaiDOM|Perl

ForDef:
  @QName: tc|ForAttrMap
  @enDesc:
    For element attributes named node map class.
  @ISA: ManakaiDOM|ForClass

ForDef:
  @QName: tc|ForETMap
  @enDesc:
    For element type definition list named node map class.
  @ISA: ManakaiDOM|ForClass

ForDef:
  @QName: tc|ForATMap
  @enDesc:
    For attribute definition list named node map class.
  @ISA: ManakaiDOM|ForClass

ForDef:
  @QName: tc|ForEntityMap
  @enDesc:
    For entity list named node map class.
  @ISA: ManakaiDOM|ForClass

ForDef:
  @QName: tc|ForNotationMap
  @enDesc:
    For notation list named node map class.
  @ISA: ManakaiDOM|ForClass

ResourceDef:
  @rdf:type:
    @@@:
      dis:MultipleResource
    @@ForCheck: !ManakaiDOM|ForIF !ManakaiDOM|ForClass
  @ForCheck: ManakaiDOM|DOM

  @resourceFor: ManakaiDOM|ForIF
  @IFQName: NamedNodeMap
  @DISCore:resourceType:
    @@@: DISLang|Interface
    @@ForCheck: ManakaiDOM|ForIF

  @f:implements:
    @@@: c|CoreFeature10
    @@ForCheck: ManakaiDOM|DOM1
  @f:implements:
    @@@: c|CoreFeature20
    @@ForCheck: ManakaiDOM|DOM2
  @f:implements:
    @@@: c|CoreFeature30
    @@ForCheck: ManakaiDOM|DOM3

  @resourceFor:
    @@@: tc|ForAttrMap
    @@ForCheck: ManakaiDOM|ManakaiDOM1
  @QName:
    @@@: ManakaiDOMAttrMap
    @@ForCheck: tc|ForAttrMap

  @resourceFor:
    @@@: tc|ForETMap
    @@ForCheck: ManakaiDOM|ManakaiDOMLatest
  @QName:
    @@@: ManakaiDOMElementTypeDefMap
    @@ForCheck: tc|ForETMap
 
  @f:implements:
    @@@: d|Feature30
    @@ForCheck: tc|ForETMap ManakaiDOM|DOM3

  @resourceFor:
    @@@: tc|ForATMap
    @@ForCheck: ManakaiDOM|ManakaiDOMLatest
  @QName:
    @@@: ManakaiDOMAttrDefMap
    @@ForCheck: tc|ForATMap

  @f:implements:
    @@@: d|Feature30
    @@ForCheck: tc|ForATMap ManakaiDOM|DOM3

  @resourceFor:
    @@@: tc|ForEntityMap
    @@ForCheck: ManakaiDOM|ManakaiDOM1 ManakaiDOM|DOMXMLFeature
  @QName:
    @@@: ManakaiDOMEntityMap
    @@ForCheck: tc|ForEntityMap

  @f:implements:
    @@@: tx|XMLFeature10
    @@ForCheck: tc|ForEntityMap ManakaiDOM|DOM1
  @f:implements:
    @@@: tx|XMLFeature20
    @@ForCheck: tc|ForEntityMap ManakaiDOM|DOM2
  @f:implements:
    @@@: tx|XMLFeature30
    @@ForCheck: tc|ForEntityMap ManakaiDOM|DOM3
  @f:implements:
    @@@: tx|XMLVersionFeature10
    @@ForCheck: tc|ForEntityMap ManakaiDOM|DOM3
  @f:implements:
    @@@: tx|XMLVersionFeature11
    @@ForCheck: tc|ForEntityMap ManakaiDOM|DOM3 ManakaiDOM|DOMXMLFeatureXML11

  @resourceFor:
    @@@: tc|ForNotationMap
    @@ForCheck: ManakaiDOM|ManakaiDOM1 ManakaiDOM|DOMXMLFeature
  @QName:
    @@@: ManakaiDOMNotationMap
    @@ForCheck: tc|ForNotationMap

  @f:implements:
    @@@: tx|XMLFeature10
    @@ForCheck: tc|ForNotationMap ManakaiDOM|DOM1
  @f:implements:
    @@@: tx|XMLFeature20
    @@ForCheck: tc|ForNotationMap ManakaiDOM|DOM2
  @f:implements:
    @@@: tx|XMLFeature30
    @@ForCheck: tc|ForNotationMap ManakaiDOM|DOM3
  @f:implements:
    @@@: tx|XMLVersionFeature10
    @@ForCheck: tc|ForNotationMap ManakaiDOM|DOM3
  @f:implements:
    @@@: tx|XMLVersionFeature11
    @@ForCheck: tc|ForNotationMap ManakaiDOM|DOM3 ManakaiDOM|DOMXMLFeatureXML11

  @DISCore:resourceType:
    @@@: DISLang|Class
    @@ForCheck: ManakaiDOM|ForClass

  @AppISA:
    @@@: 
      Tie::Array
    @@ContentType: DISPerl|Perl
    @@ForCheck: ManakaiDOM|ForClass

  @Implement:
    @@@: NamedNodeMap||ManakaiDOM|ManakaiDOM
    @@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM
  @Implement:
    @@@: NamedNodeMap||ManakaiDOM|ManakaiDOM1
    @@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM1
  @Implement:
    @@@: NamedNodeMap||ManakaiDOM|ManakaiDOM2
    @@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM2
  @Implement:
    @@@: NamedNodeMap||ManakaiDOM|ManakaiDOM3
    @@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOM3
  @Implement:
    @@@: NamedNodeMap||ManakaiDOM|ManakaiDOMLatest
    @@ForCheck: ManakaiDOM|ForClass ManakaiDOM|ManakaiDOMLatest

  @enDesc:
    An object implementing the <IF::NamedNodeMap> interface represents
    a collection of nodes that can be accessed by name.  Unlike
    <IF::NodeList>, a <IF::NamedNodeMap> object does not maintain
    any particular order.  Nodes contained in a <IF::NamedNodeMap>
    may also be accessed by an ordinal index, starting from
    <CODE::0> (zero), but this is simply
    to allow convenient enumeration of the contents of the collection.

    A <IF::NamedNodeMap> object is live.

  @enImplNote:
    @@ddid: order
    @@@:
      That is, node order is preserved as long as no change
      is made to the collection?

  @enImplNote:
    @@ddid: usecases
    @@@:
      In DOM Core module, the only place where <IF::NamedNodeMap>
      is returned is <A::Node.attributes> attribute.  In DOM XML module,
      <A::tx|DocumentType.entities> and <A::tx|DocumentType.notations>
      are also <IF::NamedNodeMap>s.

      In manakai DOM <MDOM::XDoctype> module, 
      <A::d|DocumentTypeDefinition.elementTypes>, 
      <A::d|DocumentTypeDefinition.generalEntities>,
      <A::d|DocumentTypeDefinition.parameterEntities>,
      <A::d|DocumentTypeDefinition.notations>, and
      <A::d|ElementTypeDefinition.attributeDefinitions> attributes
      are <IF::NamedNodeMap>s.

  @ImplNote:
    @@lang:en
    @@@:
      An element may have two (or more) attributes that have the same 
      <A::Node.nodeName>, but different <A::Node.namespaceURI>s. 
      Which of them is returned by DOM Level 1 methods is 
      implementation dependent.  The only guarantee is 
      that all methods that access a named item by its <A::Node.nodeName> 
      will access the same item, and all methods by its namespace URI
      and local name will access the same item. 
      <SRC::<CITE::DOM Level 2 Core> <sw010:csection::1.4.8 XML Namespaces>,
      <CITE::DOM Level 3 Core> <sw010:csection::1.3.3 XML Namespaces>>

  @enDesc:
    @@For: ManakaiDOM|ManakaiDOM
    @@@:
      In the manakai implementation, <IF::NamedNodeMap>s can be 
      dereferenced as if it is an array reference or a hash reference.
      Dereferencing as an array reference provides an access to
      items by ordinal index, like <M::.item> method; 
      Dereferencing as a hash reference
      provides by name, like <M::.getNamedItem> method.

      {TODO:: How namespace-aware node can be accessed?
      }

      {TODO:: This is <EM::not> implemented yet!
      }

  @IntMethod:
    @@Perlop: %{}
    @@enDesc:
      In manakai's Perl binding, a <IF::NamedNodeMap> object can be
      dereferenced as if it is a hash reference.  For example,
      <Perl::$map-<lt>{name}> will return the same <IF::Node> as
      <Perl::$map-<lt>get_named_item ('name')> would return.  However, it does
      not currently support substitions to hash values (e.g. 
      <Perl::$map-<lt>{name} = $node> does not work).
    @@enImplNote:
      {TODO::
        $map->{$ns, $ln} for attribute maps should be allowed.
      }

      Should $map->{$key} = $node be allowed?  What if 
      $key differs from $node->node_name?
    @@Return:
      @@@Type: HASH
      @@@PerlDef:
        tie my %list, ref $self, $self;
        $r = \%list;

    @@Test:
      @@@ForCheck: tc|ForAttrMap
      @@@QName: AttrMap.P.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest}__;
        my $doc = $el-><AG::Node.ownerDocument>;
        my $em = $el-><AG::Node.attributes>;

        $test->id ('hash.scalar');
        $test->assert_not_null (scalar %$em);

        $test->id ('key.no');
        $test->assert_null ($em->{et1});
        $test->assert_null ($em->{et2});
        $test->id ('exists.no');
        $test->assert_false (exists $em->{et1});
        $test->assert_false (exists $em->{et2});

        $test->id ('setNamedItem');
        my $et1 = $doc-><M::Document.createAttribute> ('et1');
        $em-><M::NamedNodeMap.setNamedItem> ($et1);

        $test->id ('key.et1');
        my $v1 = $em->{et1};
        $test->assert_equals ($v1, $et1);
        $test->id ('exists.et1');
        $test->assert_true (exists $em->{et1});
        $test->id ('not.exists.et2');
        $test->assert_false (exists $em->{et2});

        $test->id ('keys');
        my @keys = keys %$em;
        $test->assert_num_equals
                 (actual_value => 0 + @keys,
                  expected_value => 1);
        $test->assert_equals ($keys[0], 'et1');
        
        $test->id ('setNamedItem.2');
        my $et2 = $doc-><M::Document.createAttribute> ('et2');
        $em-><M::NamedNodeMap.setNamedItem> ($et2);

        $test->id ('keys.2');
        @keys = keys %$em;
        $test->assert_num_equals
                 (actual_value => 0 + @keys,
                  expected_value => 2);
        $test->assert_not_equals ($keys[0], $keys[1]);
        $test->assert_true ($keys[0] eq 'et1' or $keys[0] eq 'et2');
        $test->assert_true ($keys[1] eq 'et1' or $keys[1] eq 'et2');
        
        $test->id ('delete');
        delete $em->{et1};
        $test->assert_false (exists $em->{et1});
        $test->assert_true (exists $em->{et2});

        $test->id ('clear');
        %$em = ();
        $test->assert_num_equals
                 (actual_value => 0 + keys %$em,
                  expected_value => 0);

    @@XDTest:
      @@@ForCheck: tc|ForEntityMap
      @@@QName: EntityMap.P.test
      @@@PerlDef:
        my $dtd;
        __CODE{d|createDTDefForTest:: $dtdef => $dtd}__;
        my $doc = $dtd-><AG::Node.ownerDocument>;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>, '3.0');
        my $em = $dtd-><AG::d|DocumentTypeDefinition.generalEntities>;

        $test->id ('hash.scalar');
        $test->assert_not_null (scalar %$em);

        $test->id ('key.no');
        $test->assert_null ($em->{et1});
        $test->assert_null ($em->{et2});
        $test->id ('exists.no');
        $test->assert_false (exists $em->{et1});
        $test->assert_false (exists $em->{et2});

        $test->id ('setNamedItem');
        my $et1 = $docx-><M::d|DocumentXDoctype.createGeneralEntity>
                          ('et1');
        $em-><M::NamedNodeMap.setNamedItem> ($et1);

        $test->id ('key.et1');
        my $v1 = $em->{et1};
        $test->assert_equals ($v1, $et1);
        $test->id ('exists.et1');
        $test->assert_true (exists $em->{et1});
        $test->id ('not.exists.et2');
        $test->assert_false (exists $em->{et2});

        $test->id ('keys');
        my @keys = keys %$em;
        $test->assert_num_equals
                 (actual_value => 0 + @keys,
                  expected_value => 1);
        $test->assert_equals ($keys[0], 'et1');
        
        $test->id ('setNamedItem.2');
        my $et2 = $docx-><M::d|DocumentXDoctype.createGeneralEntity>
                          ('et2');
        $em-><M::NamedNodeMap.setNamedItem> ($et2);

        $test->id ('keys.2');
        @keys = keys %$em;
        $test->assert_num_equals
                 (actual_value => 0 + @keys,
                  expected_value => 2);
        $test->assert_not_equals ($keys[0], $keys[1]);
        $test->assert_true ($keys[0] eq 'et1' or $keys[0] eq 'et2');
        $test->assert_true ($keys[1] eq 'et1' or $keys[1] eq 'et2');
        
        $test->id ('delete');
        delete $em->{et1};
        $test->assert_false (exists $em->{et1});
        $test->assert_true (exists $em->{et2});

        $test->id ('clear');
        %$em = ();
        $test->assert_num_equals
                 (actual_value => 0 + keys %$em,
                  expected_value => 0);

    @@XDTest:
      @@@ForCheck: tc|ForNotationMap
      @@@QName: NotationMap.P.test
      @@@PerlDef:
        my $dtd;
        __CODE{d|createDTDefForTest:: $dtdef => $dtd}__;
        my $doc = $dtd-><AG::Node.ownerDocument>;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>, '3.0');
        my $em = $dtd-><AG::d|DocumentTypeDefinition.notations>;

        $test->id ('hash.scalar');
        $test->assert_not_null (scalar %$em);

        $test->id ('key.no');
        $test->assert_null ($em->{et1});
        $test->assert_null ($em->{et2});
        $test->id ('exists.no');
        $test->assert_false (exists $em->{et1});
        $test->assert_false (exists $em->{et2});

        $test->id ('setNamedItem');
        my $et1 = $docx-><M::d|DocumentXDoctype.createNotation>
                          ('et1');
        $em-><M::NamedNodeMap.setNamedItem> ($et1);

        $test->id ('key.et1');
        my $v1 = $em->{et1};
        $test->assert_equals ($v1, $et1);
        $test->id ('exists.et1');
        $test->assert_true (exists $em->{et1});
        $test->id ('not.exists.et2');
        $test->assert_false (exists $em->{et2});

        $test->id ('keys');
        my @keys = keys %$em;
        $test->assert_num_equals
                 (actual_value => 0 + @keys,
                  expected_value => 1);
        $test->assert_equals ($keys[0], 'et1');
        
        $test->id ('setNamedItem.2');
        my $et2 = $docx-><M::d|DocumentXDoctype.createNotation>
                          ('et2');
        $em-><M::NamedNodeMap.setNamedItem> ($et2);

        $test->id ('keys.2');
        @keys = keys %$em;
        $test->assert_num_equals
                 (actual_value => 0 + @keys,
                  expected_value => 2);
        $test->assert_not_equals ($keys[0], $keys[1]);
        $test->assert_true ($keys[0] eq 'et1' or $keys[0] eq 'et2');
        $test->assert_true ($keys[1] eq 'et1' or $keys[1] eq 'et2');
        
        $test->id ('delete');
        delete $em->{et1};
        $test->assert_false (exists $em->{et1});
        $test->assert_true (exists $em->{et2});

        $test->id ('clear');
        %$em = ();
        $test->assert_num_equals
                 (actual_value => 0 + keys %$em,
                  expected_value => 0);

    @@XDTest:
      @@@ForCheck: tc|ForETMap
      @@@QName: ETMap.P.test
      @@@PerlDef:
        my $dtd;
        __CODE{d|createDTDefForTest:: $dtdef => $dtd}__;
        my $doc = $dtd-><AG::Node.ownerDocument>;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>, '3.0');
        my $em = $dtd-><AG::d|DocumentTypeDefinition.elementTypes>;

        $test->id ('hash.scalar');
        $test->assert_not_null (scalar %$em);

        $test->id ('key.no');
        $test->assert_null ($em->{et1});
        $test->assert_null ($em->{et2});
        $test->id ('exists.no');
        $test->assert_false (exists $em->{et1});
        $test->assert_false (exists $em->{et2});

        $test->id ('setNamedItem');
        my $et1 = $docx-><M::d|DocumentXDoctype.createElementTypeDefinition>
                          ('et1');
        $em-><M::NamedNodeMap.setNamedItem> ($et1);

        $test->id ('key.et1');
        my $v1 = $em->{et1};
        $test->assert_equals ($v1, $et1);
        $test->id ('exists.et1');
        $test->assert_true (exists $em->{et1});
        $test->id ('not.exists.et2');
        $test->assert_false (exists $em->{et2});

        $test->id ('keys');
        my @keys = keys %$em;
        $test->assert_num_equals
                 (actual_value => 0 + @keys,
                  expected_value => 1);
        $test->assert_equals ($keys[0], 'et1');
        
        $test->id ('setNamedItem.2');
        my $et2 = $docx-><M::d|DocumentXDoctype.createElementTypeDefinition>
                          ('et2');
        $em-><M::NamedNodeMap.setNamedItem> ($et2);

        $test->id ('keys.2');
        @keys = keys %$em;
        $test->assert_num_equals
                 (actual_value => 0 + @keys,
                  expected_value => 2);
        $test->assert_not_equals ($keys[0], $keys[1]);
        $test->assert_true ($keys[0] eq 'et1' or $keys[0] eq 'et2');
        $test->assert_true ($keys[1] eq 'et1' or $keys[1] eq 'et2');
        
        $test->id ('delete');
        delete $em->{et1};
        $test->assert_false (exists $em->{et1});
        $test->assert_true (exists $em->{et2});

        $test->id ('clear');
        %$em = ();
        $test->assert_num_equals
                 (actual_value => 0 + keys %$em,
                  expected_value => 0);

    @@XDTest:
      @@@ForCheck: tc|ForATMap
      @@@QName: ATMap.P.test
      @@@PerlDef:
        my $dtd;
        __CODE{d|createDTDefForTest:: $dtdef => $dtd}__;
        my $doc = $dtd-><AG::Node.ownerDocument>;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>, '3.0');
        my $etd = $docx-><M::d|DocumentXDoctype.createElementTypeDefinition>
                          ('etd');
        my $em = $etd-><AG::d|ElementTypeDefinition.attributeDefinitions>;
        undef $dtd;

        $test->id ('hash.scalar');
        $test->assert_not_null (scalar %$em);

        $test->id ('key.no');
        $test->assert_null ($em->{et1});
        $test->assert_null ($em->{et2});
        $test->id ('exists.no');
        $test->assert_false (exists $em->{et1});
        $test->assert_false (exists $em->{et2});

        $test->id ('setNamedItem');
        my $et1 = $docx-><M::d|DocumentXDoctype.createAttributeDefinition>
                          ('et1');
        $em-><M::NamedNodeMap.setNamedItem> ($et1);

        $test->id ('key.et1');
        my $v1 = $em->{et1};
        $test->assert_equals ($v1, $et1);
        $test->id ('exists.et1');
        $test->assert_true (exists $em->{et1});
        $test->id ('not.exists.et2');
        $test->assert_false (exists $em->{et2});

        $test->id ('keys');
        my @keys = keys %$em;
        $test->assert_num_equals
                 (actual_value => 0 + @keys,
                  expected_value => 1);
        $test->assert_equals ($keys[0], 'et1');
        
        $test->id ('setNamedItem.2');
        my $et2 = $docx-><M::d|DocumentXDoctype.createAttributeDefinition>
                          ('et2');
        $em-><M::NamedNodeMap.setNamedItem> ($et2);

        $test->id ('keys.2');
        @keys = keys %$em;
        $test->assert_num_equals
                 (actual_value => 0 + @keys,
                  expected_value => 2);
        $test->assert_not_equals ($keys[0], $keys[1]);
        $test->assert_true ($keys[0] eq 'et1' or $keys[0] eq 'et2');
        $test->assert_true ($keys[1] eq 'et1' or $keys[1] eq 'et2');
        
        $test->id ('delete');
        delete $em->{et1};
        $test->assert_false (exists $em->{et1});
        $test->assert_true (exists $em->{et2});

        $test->id ('clear');
        %$em = ();
        $test->assert_num_equals
                 (actual_value => 0 + keys %$em,
                  expected_value => 0);

  @IntMethod:
    @@Perlop: @{}
    @@enDesc:
      In manakai's Perl binding, a <IF::NamedNodeMap> object can be
      dereferenced as if it is an array reference.  For example,
      <Perl::$map-<lt>[2]> will return the same <IF::Node> as
      <Perl::$map-<lt>item (2)> would return.  However, it does
      not support substitions to array items (e.g. <Perl::$map-<lt>[2] = $node>
      does not work).
    @@Return:
      @@@Type: DISPerl|ARRAY||ManakaiDOM|all
      @@@PerlDef:
        @@@@ForCheck: tc|ForAttrMap
        @@@@@:
          tie my @list, <ClassName::ManakaiDOMAttrMapArray>, $self;
          $r = \@list;
      @@@PerlDef:
        @@@@ForCheck: tc|ForETMap
        @@@@@:
          tie my @list, <ClassName::ManakaiDOMElementTypeDefMapArray>, $self;
          $r = \@list;
      @@@PerlDef:
        @@@@ForCheck: tc|ForATMap
        @@@@@:
          tie my @list, <ClassName::ManakaiDOMAttrDefMapArray>, $self;
          $r = \@list;
      @@@PerlDef:
        @@@@ForCheck: tc|ForEntityMap
        @@@@@:
          tie my @list, <ClassName::ManakaiDOMEntityMapArray>, $self;
          $r = \@list;
      @@@PerlDef:
        @@@@ForCheck: tc|ForNotationMap
        @@@@@:
          tie my @list, <ClassName::ManakaiDOMNotationMapArray>, $self;
          $r = \@list;

    @@Test:
      @@@ForCheck: tc|ForAttrMap
      @@@QName: AttrMap.@.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;
        my $doc = $el-><AG::Node.ownerDocument>;
        my $em = $el-><AG::Node.attributes>;

        $test->id ('length.0');
        $test->assert_num_equals
                 (actual_value => 0 + @$em,
                  expected_value => 0);

        $test->id ('fetch.0.no');
        $test->assert_null ($em->[0]);
        $test->id ('exists.0');
        $test->assert_false (exists $em->[0]);
        $test->id ('exists.-1');
        $test->assert_false (exists $em->[-1]);

        $test->id ('setNamedItem');
        my $et1 = $doc-><M::Document.createAttribute> ('et1');
        $em-><M::NamedNodeMap.setNamedItem> ($et1);

        $test->id ('length.1');
        $test->assert_num_equals
                 (actual_value => 0 + @$em,
                  expected_value => 1);

        $test->id ('0.fetch.0');
        $test->assert_equals ($em->[0], $et1);
        $test->id ('0.fetch.-1');
        $test->assert_equals ($em->[-1], $et1);
        $test->id ('0.fetch.1.no');
        $test->assert_null ($em->[1]);
        $test->id ('0.exists.0');
        $test->assert_true (exists $em->[0]);
        $test->id ('0.exists.-1');
        $test->assert_true (exists $em->[-1]);
        $test->id ('0.exists.1.no');
        $test->assert_false (exists $em->[1]);

        $test->id ('delete.0');
        delete $em->[0];
        $test->assert_false (exists $em->[0]);

    @@XDTest:
      @@@ForCheck: tc|ForETMap
      @@@QName: ETMap.@.test
      @@@PerlDef:
        my $dtd;
        __CODE{d|createDTDefForTest:: $dtdef => $dtd}__;
        my $doc = $dtd-><AG::Node.ownerDocument>;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>, '3.0');
        my $em = $dtd-><AG::d|DocumentTypeDefinition.elementTypes>;

        $test->id ('length.0');
        $test->assert_num_equals
                 (actual_value => 0 + @$em,
                  expected_value => 0);

        $test->id ('fetch.0.no');
        $test->assert_null ($em->[0]);
        $test->id ('exists.0');
        $test->assert_false (exists $em->[0]);
        $test->id ('exists.-1');
        $test->assert_false (exists $em->[-1]);

        $test->id ('setNamedItem');
        my $et1 = $docx-><M::d|DocumentXDoctype.createElementTypeDefinition>
                          ('et1');
        $em-><M::NamedNodeMap.setNamedItem> ($et1);

        $test->id ('length.1');
        $test->assert_num_equals
                 (actual_value => 0 + @$em,
                  expected_value => 1);

        $test->id ('0.fetch.0');
        $test->assert_equals ($em->[0], $et1);
        $test->id ('0.fetch.-1');
        $test->assert_equals ($em->[-1], $et1);
        $test->id ('0.fetch.1.no');
        $test->assert_null ($em->[1]);
        $test->id ('0.exists.0');
        $test->assert_true (exists $em->[0]);
        $test->id ('0.exists.-1');
        $test->assert_true (exists $em->[-1]);
        $test->id ('0.exists.1.no');
        $test->assert_false (exists $em->[1]);

        $test->id ('delete.0');
        delete $em->[0];
        $test->assert_false (exists $em->[0]);

    @@XDTest:
      @@@ForCheck: tc|ForEntityMap
      @@@QName: EntityMap.@.test
      @@@PerlDef:
        my $dtd;
        __CODE{d|createDTDefForTest:: $dtdef => $dtd}__;
        my $doc = $dtd-><AG::Node.ownerDocument>;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>, '3.0');
        my $em = $dtd-><AG::d|DocumentTypeDefinition.generalEntities>;

        $test->id ('length.0');
        $test->assert_num_equals
                 (actual_value => 0 + @$em,
                  expected_value => 0);

        $test->id ('fetch.0.no');
        $test->assert_null ($em->[0]);
        $test->id ('exists.0');
        $test->assert_false (exists $em->[0]);
        $test->id ('exists.-1');
        $test->assert_false (exists $em->[-1]);

        $test->id ('setNamedItem');
        my $et1 = $docx-><M::d|DocumentXDoctype.createGeneralEntity>
                          ('et1');
        $em-><M::NamedNodeMap.setNamedItem> ($et1);

        $test->id ('length.1');
        $test->assert_num_equals
                 (actual_value => 0 + @$em,
                  expected_value => 1);

        $test->id ('0.fetch.0');
        $test->assert_equals ($em->[0], $et1);
        $test->id ('0.fetch.-1');
        $test->assert_equals ($em->[-1], $et1);
        $test->id ('0.fetch.1.no');
        $test->assert_null ($em->[1]);
        $test->id ('0.exists.0');
        $test->assert_true (exists $em->[0]);
        $test->id ('0.exists.-1');
        $test->assert_true (exists $em->[-1]);
        $test->id ('0.exists.1.no');
        $test->assert_false (exists $em->[1]);

        $test->id ('delete.0');
        delete $em->[0];
        $test->assert_false (exists $em->[0]);

    @@XDTest:
      @@@ForCheck: tc|ForNotationMap
      @@@QName: NotationMap.@.test
      @@@PerlDef:
        my $dtd;
        __CODE{d|createDTDefForTest:: $dtdef => $dtd}__;
        my $doc = $dtd-><AG::Node.ownerDocument>;
        my $em = $dtd-><AG::d|DocumentTypeDefinition.notations>;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>, '3.0');

        $test->id ('length.0');
        $test->assert_num_equals
                 (actual_value => 0 + @$em,
                  expected_value => 0);

        $test->id ('fetch.0.no');
        $test->assert_null ($em->[0]);
        $test->id ('exists.0');
        $test->assert_false (exists $em->[0]);
        $test->id ('exists.-1');
        $test->assert_false (exists $em->[-1]);

        $test->id ('setNamedItem');
        my $et1 = $docx-><M::d|DocumentXDoctype.createNotation>
                          ('et1');
        $em-><M::NamedNodeMap.setNamedItem> ($et1);

        $test->id ('length.1');
        $test->assert_num_equals
                 (actual_value => 0 + @$em,
                  expected_value => 1);

        $test->id ('0.fetch.0');
        $test->assert_equals ($em->[0], $et1);
        $test->id ('0.fetch.-1');
        $test->assert_equals ($em->[-1], $et1);
        $test->id ('0.fetch.1.no');
        $test->assert_null ($em->[1]);
        $test->id ('0.exists.0');
        $test->assert_true (exists $em->[0]);
        $test->id ('0.exists.-1');
        $test->assert_true (exists $em->[-1]);
        $test->id ('0.exists.1.no');
        $test->assert_false (exists $em->[1]);

        $test->id ('delete.0');
        delete $em->[0];
        $test->assert_false (exists $em->[0]);

    @@XDTest:
      @@@ForCheck: tc|ForATMap
      @@@QName: ATMap.@.test
      @@@PerlDef:
        my $dtd;
        __CODE{d|createDTDefForTest:: $dtdef => $dtd}__;
        my $doc = $dtd-><AG::Node.ownerDocument>;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>, '3.0');
        my $etd = $docx-><M::d|DocumentXDoctype.createElementTypeDefinition>
                          ('et1');
        my $em = $etd-><AG::d|ElementTypeDefinition.attributeDefinitions>;
        undef $dtd;

        $test->id ('length.0');
        $test->assert_num_equals
                 (actual_value => 0 + @$em,
                  expected_value => 0);

        $test->id ('fetch.0.no');
        $test->assert_null ($em->[0]);
        $test->id ('exists.0');
        $test->assert_false (exists $em->[0]);
        $test->id ('exists.-1');
        $test->assert_false (exists $em->[-1]);

        $test->id ('setNamedItem');
        my $et1 = $docx-><M::d|DocumentXDoctype.createAttributeDefinition>
                          ('et1');
        $em-><M::NamedNodeMap.setNamedItem> ($et1);

        $test->id ('length.1');
        $test->assert_num_equals
                 (actual_value => 0 + @$em,
                  expected_value => 1);

        $test->id ('0.fetch.0');
        $test->assert_equals ($em->[0], $et1);
        $test->id ('0.fetch.-1');
        $test->assert_equals ($em->[-1], $et1);
        $test->id ('0.fetch.1.no');
        $test->assert_null ($em->[1]);
        $test->id ('0.exists.0');
        $test->assert_true (exists $em->[0]);
        $test->id ('0.exists.-1');
        $test->assert_true (exists $em->[-1]);
        $test->id ('0.exists.1.no');
        $test->assert_false (exists $em->[1]);

        $test->id ('delete.0');
        delete $em->[0];
        $test->assert_false (exists $em->[0]);

  @Method:
    @@Name: getNamedItem
    @@Perlop: FETCH
    @@enDesc:
      Retrieves a node specified by name.
    @@NSVersion: .getNamedItemNS
    @@Param:
      @@@Name: name
      @@@Type: DOMString
      @@@dis:actualType:
        @@@@@: DOMMain|ManakaiDOMXMLName
        @@@@ManakaiDOM:noInputNormalize: 1
      @@@enDesc:
        The <A::Node.nodeName> of a node to retrieve.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        A <IF::Node> with the specified <P::name>.
      @@@nullCase:
        @@@@enDesc:
          If the <P::name> does not identify any node in the map.
      @@@PerlDef:
        @@@@ForCheck: tc|ForAttrMap
        @@@@@:
          __DEEP{
            $r = ($$$self)-><M::Element.getAttributeNode> ($name);
          }__;
      @@@PerlDef:
        @@@@ForCheck: !tc|ForAttrMap
        @@@@@:
          my $list;
          my $ifs;
          __FOR{tc:ForETMap::
            __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
              $r => $list,
              $prop => {<H::d|elementTypes>},
              $ref => {$$$self},
            }__;
            $ifs = [<IFName::ETDef>];
          }__;
          __FOR{tc:ForATMap::
            __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
              $r => $list,
              $prop => {<H::d|attributeDefinitions>},
              $ref => {$$$self},
            }__;
            $ifs = [<IFName::ATDef>];
          }__;
          __FOR{tc:ForEntityMap::
            __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
              $r => $list,
              $prop => {<H::d|generalEntities>},
              $ref => {$$$self},
            }__;
            $ifs = [<IFName::tx|Entity>];
          }__;
          __FOR{tc:ForNotationMap::
            __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
              $r => $list,
              $prop => {<H::d|notations>},
              $ref => {$$$self},
            }__;
            $ifs = [<IFName::tx|Notation>];
          }__;
          if (defined $list->{$name}) {
            __CODE{mg|createNodeRefFromID||ManakaiDOM|all::
              $bag => {<Code::mg|getNodeBag||ManakaiDOM|all::
                                $ref = {$$$self}>},
              $stemid => {$list->{$name}},
              $ref => $r,
              $opt => {{ 
                <H::mg|nodeRefInterfaces> => $ifs,                
              }},
            }__;
          }

    @@Test:
      @@@ForCheck: tc|ForAttrMap
      @@@QName: AttrMap.getNamedItem.test
      @@@PerlDef:
        my $el;
        __CODE{createElementForTest:: $el => $el}__;

        my $map = $el-><AG::Node.attributes>;
        $test->assert_isa ($map, <IFName::NamedNodeMap>);
        
        $test->id ('no.attr.node');
        $test->assert_null ($map-><M::NamedNodeMap.getNamedItem> ('a1'));

        $test->id ('dom1.attr.node');
        $el-><M::Element.setAttribute> ('a1', 'value1');
        my $a1 = $map-><M::NamedNodeMap.getNamedItem> ('a1');
        $test->assert_isa ($a1, <IFName::Attr>);
        $test->assert_num_equals
                 (actual_value => $a1-><AG::Node.nodeType>,
                  expected_value => <C::Node.ATTRIBUTE_NODE>);
        $test->assert_equals ($a1-><AG::Node.nodeName>, 'a1');
        $test->assert_equals ($a1-><AG::Node.nodeValue>, 'value1');
        undef $a1;

        $test->id ('dom1.attr.node.removed');
        $el-><M::Element.removeAttribute> ('a1');
        $test->assert_null ($map-><M::NamedNodeMap.getNamedItem> ('a1'));
    @@Test:
      @@@ForCheck: tc|ForAttrMap ManakaiDOM|DOM2
      @@@QName: AttrMap.getNamedItem.qname.test
      @@@PerlDef:
        my $el;
        __CODE{createElementForTest:: $el => $el}__;

        my $map = $el-><AG::Node.attributes>;
        $test->assert_isa ($map, <IFName::NamedNodeMap>);
        
        $test->id ('dom2.attr.node');
        $el-><M::Element.setAttributeNS> ('http://attr.example/', 'ns:a1', 'v1');
        my $a1 = $map-><M::NamedNodeMap.getNamedItem> ('ns:a1');
        $test->assert_isa ($a1, <IFName::Attr>);
        $test->assert_num_equals
                 (actual_value => $a1-><AG::Node.nodeType>,
                  expected_value => <C::Node.ATTRIBUTE_NODE>);
        $test->assert_equals ($a1-><AG::Node.nodeName>, 'ns:a1');
        $test->assert_equals ($a1-><AG::Node.nodeValue>, 'v1');
        undef $a1;
        $test->assert_null ($map-><M::NamedNodeMap.getNamedItem> ('a1'));

        $test->id ('dom2.attr.node.removed');
        $el-><M::Element.removeAttributeNS> ('http://attr.example/', 'a1');
        $test->assert_null ($map-><M::NamedNodeMap.getNamedItem> ('ns:a1'));

    @@Test:
      @@@ForCheck: tc|ForAttrMap
      @@@QName: AttrMap.getNamedItem.setNamedItem.test
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;
        my $doc = $el-><AG::Node.ownerDocument>;

        my $em = $el-><AG::Node.attributes>;
        $test->assert_isa ($em, <IFName::tc|NamedNodeMap>);

        $test->id ('getNamedItem.none');
        $test->assert_null ($em-><M::NamedNodeMap.getNamedItem> ('et1'));

        my $et1 = $doc-><M::Document.createAttribute>
                          ('et1');
        $test->assert_isa ($et1, <IFName::Attr>);

        $test->id ('setNamedItem.et1');
        my $r1 = $em-><M::NamedNodeMap.setNamedItem> ($et1);
        $test->assert_null ($r1);

        $test->id ('getNamedItem.et1');
        my $r2 = $em-><M::NamedNodeMap.getNamedItem> ('et1');
        $test->assert_equals ($r2, $et1);
        $test->assert_equals
                 ($r2-><AG::Attr.ownerElement>, $el);
        $test->assert_equals
                 ($et1-><AG::Attr.ownerElement>, $el);

        my $et2 = $doc-><M::Document.createAttribute>
                          ('et1');
        $test->assert_isa ($et2, <IFName::Attr>);
        $test->assert_not_equals ($et1, $et2);

        $test->id ('setNamedItem.et2');
        my $r3 = $em-><M::NamedNodeMap.setNamedItem> ($et2);
        $test->assert_equals ($r3, $et1);

        $test->id ('getNamedItem.et2');
        my $r4 = $em-><M::NamedNodeMap.getNamedItem> ('et1');
        $test->assert_equals ($r4, $et2);

        $test->id ('setNamedItem.et2.by.et2');
        my $r5 = $em-><M::NamedNodeMap.setNamedItem> ($et2);
        $test->assert_null ($r5);
        $test->assert_equals ($em-><M::NamedNodeMap.getNamedItem> ('et1'), $et2);

    @@XDTest:
      @@@ForCheck: tc|ForETMap
      @@@QName: etmap.getNamedItem.setNamedItem.test
      @@@PerlDef:
        my $dtd;
        __CODE{d|createDTDefForTest:: $dtdef => $dtd}__;
        my $doc = $dtd-><AG::Node.ownerDocument>;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>, '3.0');

        my $em = $dtd-><AG::d|DocumentTypeDefinition.elementTypes>;
        $test->assert_isa ($em, <IFName::tc|NamedNodeMap>);

        $test->id ('getNamedItem.none');
        $test->assert_null ($em-><M::NamedNodeMap.getNamedItem> ('et1'));

        my $et1 = $docx-><M::d|DocumentXDoctype.createElementTypeDefinition>
                          ('et1');
        $test->assert_isa ($et1, <IFName::d|ElementTypeDefinition>);

        $test->id ('setNamedItem.et1');
        my $r1 = $em-><M::NamedNodeMap.setNamedItem> ($et1);
        $test->assert_null ($r1);

        $test->id ('getNamedItem.et1');
        my $r2 = $em-><M::NamedNodeMap.getNamedItem> ('et1');
        $test->assert_equals ($r2, $et1);
        $test->assert_equals
                 ($r2-><AG::d|ElementTypeDefinition.ownerDocumentTypeDefinition>,
                  $dtd);
        $test->assert_equals
                 ($et1-><AG::d|ElementTypeDefinition.ownerDocumentTypeDefinition>,
                  $dtd);

        my $et2 = $docx-><M::d|DocumentXDoctype.createElementTypeDefinition>
                          ('et1');
        $test->assert_isa ($et2, <IFName::d|ElementTypeDefinition>);
        $test->assert_not_equals ($et1, $et2);

        $test->id ('setNamedItem.et2');
        my $r3 = $em-><M::NamedNodeMap.setNamedItem> ($et2);
        $test->assert_equals ($r3, $et1);

        $test->id ('getNamedItem.et2');
        my $r4 = $em-><M::NamedNodeMap.getNamedItem> ('et1');
        $test->assert_equals ($r4, $et2);

        $test->id ('setNamedItem.et2.by.et2');
        my $r5 = $em-><M::NamedNodeMap.setNamedItem> ($et2);
        $test->assert_null ($r5);
        $test->assert_equals ($em-><M::NamedNodeMap.getNamedItem> ('et1'), $et2);

    @@XDTest:
      @@@ForCheck: tc|ForEntityMap
      @@@QName: EntityMap.getNamedItem.setNamedItem.test
      @@@PerlDef:
        my $dtd;
        __CODE{d|createDTDefForTest:: $dtdef => $dtd}__;
        my $doc = $dtd-><AG::Node.ownerDocument>;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>, '3.0');

        my $em = $dtd-><AG::d|DocumentTypeDefinition.generalEntities>;
        $test->assert_isa ($em, <IFName::tc|NamedNodeMap>);

        $test->id ('getNamedItem.none');
        $test->assert_null ($em-><M::NamedNodeMap.getNamedItem> ('et1'));

        my $et1 = $docx-><M::d|DocumentXDoctype.createGeneralEntity>
                          ('et1');
        $test->assert_isa ($et1, <IFName::tx|Entity>);

        $test->id ('setNamedItem.et1');
        my $r1 = $em-><M::NamedNodeMap.setNamedItem> ($et1);
        $test->assert_null ($r1);

        $test->id ('getNamedItem.et1');
        my $r2 = $em-><M::NamedNodeMap.getNamedItem> ('et1');
        $test->assert_equals ($r2, $et1);
        $test->assert_equals
                 ($r2-><AG::tx|Entity.ownerDocumentTypeDefinition>,
                  $dtd);
        $test->assert_equals
                 ($et1-><AG::tx|Entity.ownerDocumentTypeDefinition>,
                  $dtd);

        my $et2 = $docx-><M::d|DocumentXDoctype.createGeneralEntity>
                          ('et1');
        $test->assert_isa ($et2, <IFName::tx|Entity>);
        $test->assert_not_equals ($et1, $et2);

        $test->id ('setNamedItem.et2');
        my $r3 = $em-><M::NamedNodeMap.setNamedItem> ($et2);
        $test->assert_equals ($r3, $et1);

        $test->id ('getNamedItem.et2');
        my $r4 = $em-><M::NamedNodeMap.getNamedItem> ('et1');
        $test->assert_equals ($r4, $et2);

        $test->id ('setNamedItem.et2.by.et2');
        my $r5 = $em-><M::NamedNodeMap.setNamedItem> ($et2);
        $test->assert_null ($r5);
        $test->assert_equals ($em-><M::NamedNodeMap.getNamedItem> ('et1'), $et2);

    @@XDTest:
      @@@ForCheck: tc|ForNotationMap
      @@@QName: NotationMap.getNamedItem.setNamedItem.test
      @@@PerlDef:
        my $dtd;
        __CODE{d|createDTDefForTest:: $dtdef => $dtd}__;
        my $doc = $dtd-><AG::Node.ownerDocument>;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>, '3.0');

        my $em = $dtd-><AG::d|DocumentTypeDefinition.notations>;
        $test->assert_isa ($em, <IFName::tc|NamedNodeMap>);

        $test->id ('getNamedItem.none');
        $test->assert_null ($em-><M::NamedNodeMap.getNamedItem> ('et1'));

        my $et1 = $docx-><M::d|DocumentXDoctype.createNotation>
                          ('et1');
        $test->assert_isa ($et1, <IFName::tx|Notation>);

        $test->id ('setNamedItem.et1');
        my $r1 = $em-><M::NamedNodeMap.setNamedItem> ($et1);
        $test->assert_null ($r1);

        $test->id ('getNamedItem.et1');
        my $r2 = $em-><M::NamedNodeMap.getNamedItem> ('et1');
        $test->assert_equals ($r2, $et1);
        $test->assert_equals
                 ($r2-><AG::tx|Notation.ownerDocumentTypeDefinition>,
                  $dtd);
        $test->assert_equals
                 ($et1-><AG::tx|Notation.ownerDocumentTypeDefinition>,
                  $dtd);

        my $et2 = $docx-><M::d|DocumentXDoctype.createNotation>
                          ('et1');
        $test->assert_isa ($et2, <IFName::tx|Notation>);
        $test->assert_not_equals ($et1, $et2);

        $test->id ('setNamedItem.et2');
        my $r3 = $em-><M::NamedNodeMap.setNamedItem> ($et2);
        $test->assert_equals ($r3, $et1);

        $test->id ('getNamedItem.et2');
        my $r4 = $em-><M::NamedNodeMap.getNamedItem> ('et1');
        $test->assert_equals ($r4, $et2);

        $test->id ('setNamedItem.et2.by.et2');
        my $r5 = $em-><M::NamedNodeMap.setNamedItem> ($et2);
        $test->assert_null ($r5);
        $test->assert_equals ($em-><M::NamedNodeMap.getNamedItem> ('et1'), $et2);

  @Method:
    @@Name: setNamedItem
    @@enDesc:
      Adds a node using its <A::Node.nodeName> attribute.  If a node
      with that name is already present in the map, it is replaced
      by the new one.  Replacing a node by itself has no effect.

      As the <A::Node.nodeName> is used to derive the name under which
      the node is stored, multiple nodes the names would clash
      cannot be stored.
    @@enImplNote:
      @@@ddid: repbyitself
      @@@@:
        <QUOTE::Replacing a node by itself has no effect> clause is 
        clarified by DOM Level 2 errata.
    @@NSVersion: .setNamedItemNS
    @@Param:
      @@@Name: arg
      @@@Type: Node
      @@@enDesc:
        A node to store to the map.
      @@@enImplNote:
        The node will later be accessible using the value of <A::Node.nodeName>
        attribute.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        If <P::arg> replaces an existing node, the replaced <IF::Node>.
      @@@nullCase:
        @@@@enDesc:
          No replacement occurred.
        @@@@enImplNote:
          What is returned if replace-by-itself?  It has no effect,
          so it does no <QUOTE::replacement>, and <DOM::null>
          should be returned?
      @@@dx:raises:
        @@@@@: c|DIFFERENT_DOCUMENT_ERR
        @@@@enDesc:
          If <P::arg> was created from a different document than
          the one that created the map.
        @@@@enDesc:
          @@@@@ddid: no-doc
          @@@@@ForCheck: !tc|ForAttrMap ManakaiDOM|ManakaiDOM
          @@@@@@:
            If the map is attached to a <IF::tx|DocumentType> 
            whose <A::Node.ownerDocument> is <DOM::null>.
      @@@dx:raises:
        @@@@@: c|NOMOD_NAMEDNODEMAP_ERR
        @@@@enDesc:
          If the map is read-only.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the node to which the map is attached is read-only.
      @@@dx:raises:
        @@@@@: c|INUSE_ATTRIBUTE_ERR
        @@@@enDesc:
          If <P::arg> is an <IF::Attr> that is already an attribute
          of another <IF::Element>.
        @@@@ForCheck: !tc|ForETMap !tc|ForATMap !tc|ForEntityMap !tc|ForNotationMap
      @@@dx:raises:
        @@@@@: c|INUSE_DEFINITION_ERR
        @@@@enDesc:
          If <P::arg> is a definition node that is already used
          for another node.
        @@@@ForCheck: !tc|ForAttrMap
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_BAD_TYPE
        @@@@enDesc:
          If an attempt is made to add a node that is unable to
          belong to the map.
        @@@@enImplNote:
          Added by DOM Level 2 errata.
        @@@@For: ManakaiDOM|DOM2
      @@@c:reports:
        @@@@@: t|replace-by-itself
        @@@@enDesc:
          If the <P::arg> node is same as the node that is in the map.
          Then, the method call has no effect.
        @@@@enImplNote:
          This case is clarified by DOM Level 2 errata.
        @@@@For: ManakaiDOM|ManakaiDOM
      @@@PerlDef:
        @@@@ForCheck: tc|ForAttrMap
        @@@@@:
          __DEEP{
            $r = ($$$self)-><M::Element.setAttributeNode> ($arg);
          }__;
      @@@PerlDef:
        @@@@ForCheck: !tc|ForAttrMap
        @@@@@:
          my $list;
          my $expected_type;
          my $ifs;
          __FOR{tc:ForETMap::
            __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
              $r => $list,
              $prop => {<H::d|elementTypes>},
              $ref => {$$$self},
            }__;
            $expected_type = <C::Node.ELEMENT_TYPE_DEFINITION_NODE>;
            $ifs = [<IFName::ETDef>];
          }__;
          __FOR{tc:ForATMap::
            __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
              $r => $list,
              $prop => {<H::d|attributeDefinitions>},
              $ref => {$$$self},
            }__;
            $expected_type = <C::Node.ATTRIBUTE_DEFINITION_NODE>;
            $ifs = [<IFName::ATDef>];
          }__;
          __FOR{tc:ForEntityMap::
            __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
              $r => $list,
              $prop => {<H::d|generalEntities>},
              $ref => {$$$self},
            }__;
            $expected_type = <C::Node.ENTITY_NODE>;
            $ifs = [<IFName::tx|Entity>];
          }__;
          __FOR{tc:ForNotationMap::
            __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
              $r => $list,
              $prop => {<H::d|notations>},
              $ref => {$$$self},
            }__;
            $expected_type = <C::Node.NOTATION_NODE>;
            $ifs = [<IFName::tx|Notation>];
          }__;
          if ($$$self-><AG::Node.ownerDocument>
                     -><AG::Document.strictErrorChecking>) {
            unless ($arg-><AG::Node.ownerDocument>
                        eq $$$self-><AG::Node.ownerDocument>) {
              __EXCEPTION{c|DIFFERENT_DOCUMENT_ERR::
              }__;
            }
            if ($$$self-><AG::Node.manakaiReadOnly>) {
              __EXCEPTION{c|NOMOD_NAMEDNODEMAP_ERR::
              }__;
            }
            my $owner_def;
            __CODE{mg|getNodeStemProp0Node||ManakaiDOM|all::
              $r => $owner_def,
              $prop => {<H::d|ownerDefinition>},
              $ref => $arg,
              $opt => {{
                <H::mg|nodeRefInterfaces> => [<IFName::Node>],
              }},
            }__;
            if ($owner_def and not $owner_def eq $$$self) {
              __EXCEPTION{c|INUSE_DEFINITION_ERR::
                MDOMX:param-name => 'arg',
                c:node => {$arg},
              }__;
              ## NOTE: If equals to owner, then replace-by-itself error.
            }
            if ($arg-><AG::Node.nodeType> != $expected_type) {
              __EXCEPTION{MDOMX|HIERARCHY_BAD_TYPE::
                c:nodeType => {$arg-><AG::Node.nodeType>},
                MDOMX:param-name => 'arg',
              }__;
            }
          } # strictErrorChecking
          SET: {
            my $name = $arg-><AG::Node.nodeName>;
            if (defined $list->{$name}) {
              __CODE{mg|createNodeRefFromID||ManakaiDOM|all::
                $bag => {<Code::mg|getNodeBag||ManakaiDOM|all::
                                    $ref = {$$$self}>},
                $stemid => {$list->{$name}},
                $ref => $r,
                $opt => {{
                  <H::mg|nodeRefInterfaces> => $ifs,
                }},
              }__;
              if ($r eq $arg) {
                __c:ERROR{t|replace-by-itself::
                  c:relatedData => {$arg},
                }__;
                undef $r; # no return value
                last SET;
              }
            }
            $list->{$name} = <Code::mg|getNodeID||ManakaiDOM|all::
                                        $ref = $arg>;
            __CODE{mg|setNodeStemProp0Node||ManakaiDOM|all::
              $prop => {<H::d|ownerDefinition>},
              $ref => $arg,
              $given => {$$$self},
            }__;
          } # SET

    @@enImplNote:
      @@@ForCheck: !tc|ForETMap
      @@@ddid: nsattrnodename
      @@@@:
        {P:: If a <IF::NamedNodeMap> contains two nodes:
            
             - <A::Node.nodeName> equals to <CODE::ns1:ln>, and
 
             - <A::Node.nodeName> equals to <CODE::ns2:ln>,
               <A::Node.localName> equals to <CODE::ln>, and 
               <A::Node.namespaceURI> equals to <URI::http://www.example/>,
              
             then what result is lead by an attempt to add a node
             with <A::Node.nodeName> equals to <CODE::ns1:ln>,
             <A::Node.localName> equals to <CODE::ln>, and
             <A::Node.namespaceURI> equals to <URI::http://www.example/>?
        }

    @@Test:
      @@@ForCheck: tc|ForAttrMap
      @@@QName: AttrMap.setNamedItem.dom1.test
      @@@PerlDef:
        my $doc;
        my $el;
        __CODE{createElementForTest:: $el => $el}__;

        $doc = $el-><AG::Node.ownerDocument>;

        my $map = $el-><AG::Node.attributes>;

        $test->assert_null ($map-><M::NamedNodeMap.getNamedItem> ('a1'));

        $test->id ('set.new.node');
        my $a1 = $doc-><M::Document.createAttribute> ('a1');
        $a1-><AS::Attr.value> ('value1');
        $map-><M::NamedNodeMap.setNamedItem> ($a1);
        my $a1r = $map-><M::NamedNodeMap.getNamedItem> ('a1');
        $test->assert_isa ($a1r, <IFName::Attr>);
        $test->assert_num_equals
                 (actual_value => $a1r-><AG::Node.nodeType>,
                  expected_value => <C::Node.ATTRIBUTE_NODE>);
        $test->assert_equals ($a1r-><AG::Node.nodeName>, 'a1');
        $test->assert_equals ($a1r-><AG::Node.nodeValue>, 'value1');
        $test->assert_equals ($a1r, $a1);
        $test->assert_equals ($el-><M::Element.getAttribute> ('a1'), 'value1');

        $test->id ('replace.node');
        my $a2 = $doc-><M::Document.createAttribute> ('a1');
        $a2-><AS::Attr.value> ('value2');
        $test->assert_not_equals ($a1, $a2);
        my $ra1 = $map-><M::NamedNodeMap.setNamedItem> ($a2);
        $test->assert_equals ($ra1, $a1);
        my $a2r = $map-><M::NamedNodeMap.getNamedItem> ('a1');
        $test->assert_equals ($a2r, $a2);
        $test->assert_equals ($el-><M::Element.getAttribute> ('a1'), 'value2');
     @@enImplNote:
       {TODO:: Namespace aware test required
       }

  @Method:
    @@Name: removeNamedItem
    @@enDesc:
      Removes a node specified by name.
    @@enDesc:
      @@@ddid: attr
      @@@ForCheck: !tc|ForETMap !tc|ForATMap !tc|ForEntityMap !tc|ForNotationMap
      @@@enDesc:
        If the removed attribute is known to have a default value,
        an attribute immediately appears containing the default
        value as well as the corresponding namespace URI, local name,
        and prefix when applicable.
    @@NSVersion: .removeNamedItemNS
    @@Param:
      @@@Name: name
      @@@Type: DOMString
      @@@dis:actualType: 
        @@@@@: DOMMain|ManakaiDOMXMLName
        @@@@ManakaiDOM:noInputNormalize: 1
      @@@enDesc:
        The <A::Node.nodeName> of the node to remove.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node removed from the map.
      @@@dx:raises:
        @@@@@: c|NO_NAMED_NODE_ERR
        @@@@enDesc:
          If there is no node named as <P::name> in the map.
      @@@dx:raises:
        @@@@@: c|NOMOD_NAMEDNODEMAP_ERR
        @@@@enDesc:
          If the map is read-only.
        @@@@enImplNote:
          Added by DOM Level 1 (first edition) errata.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the node to which the map is attached is read-only.
        @@@@For: ManakaiDOM|ManakaiDOM
      @@@enImplNote:
        In DOM Level 1 Specification (first edition), it is defined that 
        in case there is no node with <P::name> then <DOM::null> should be
        returned while <X::c|NO_NAMED_NODE_ERR> exception is also specified.
        The former is removed by DOM Level 1 (first edition) errata.
      @@@PerlDef:
        @@@@ForCheck: tc|ForAttrMap
        @@@@@:
          my $el = $$$self;
          __DEEP{ 
            $r = $el-><M::Element.getAttributeNode> ($name);
          }__;
          unless ($r) {
            __EXCEPTION{c|NO_NAMED_NODE_ERR::
              c|name => {$name},
              MDOMX|param-name => 'name',
            }__;
          }
          __DEEP{
            $r = $el-><M::Element.removeAttributeNode> ($r);
          }__;
      @@@PerlDef:
        @@@@ForCheck: !tc|ForAttrMap
        @@@@@:
          my $list;
          my $ifs;
          __FOR{tc:ForETMap::
            __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
              $r => $list,
              $prop => {<H::d|elementTypes>},
              $ref => {$$$self},
            }__;
            $ifs = [<IFName::ETDef>];
          }__;
          __FOR{tc:ForATMap::
            __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
              $r => $list,
              $prop => {<H::d|attributeDefinitions>},
              $ref => {$$$self},
            }__;
            $ifs = [<IFName::ATDef>];
          }__;
          __FOR{tc:ForEntityMap::
            __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
              $r => $list,
              $prop => {<H::d|generalEntities>},
              $ref => {$$$self},
            }__;
            $ifs = [<IFName::tx|Entity>];
          }__;
          __FOR{tc:ForNotationMap::
            __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
              $r => $list,
              $prop => {<H::d|notations>},
              $ref => {$$$self},
            }__;
            $ifs = [<IFName::tx|Notation>];
          }__;
          if ($$$self-><AG::Node.ownerDocument>
                     -><AG::Document.strictErrorChecking>) {
            if ($$$self-><AG::Node.manakaiReadOnly>) {
              __EXCEPTION{c|NOMOD_NAMEDNODEMAP_ERR::
              }__;
            }
          } # strictErrorChecking

          if (defined $list->{$name}) {
            __CODE{mg|createNodeRefFromID||ManakaiDOM|all::
              $bag => {<Code::mg|getNodeBag||ManakaiDOM|all::
                                  $ref = {$$$self}>},
              $stemid => {$list->{$name}},
              $ref => $r,
              $opt => {{
                <H::mg|nodeRefInterfaces> => $ifs,
              }},
            }__;
            __CODE{mg|deleteNodeStemPropValue||ManakaiDOM|all::
              $prop => {<H::d|ownerDefinition>},
              $ref => $r,
            }__;
            CORE::delete $list->{$name};
          } else {
            __EXCEPTION{c|NO_NAMED_NODE_ERR::
              c|name => {$name},
              MDOMX|param-name => 'name',
            }__;
          }

    @@Test:
      @@@QName: AttrMap.removeNamedItem.test
      @@@ForCheck: tc|ForAttrMap
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;
        my $doc = $el-><AG::Node.ownerDocument>;
        my $em = $el-><AG::Node.attributes>;
        undef $el;

        $test->id ('setNamedItem');
        my $et1 = $doc-><M::Document.createAttribute> ('et1');
        $em-><M::NamedNodeMap.setNamedItem> ($et1);
        $test->assert_equals
                 ($em-><M::NamedNodeMap.getNamedItem> ('et1'), $et1);

        $test->id ('removeNamedItem.noremove');
        $test->assert_exception (code => sub {
          $em-><M::NamedNodeMap.removeNamedItem> ('et2');
        }, exception_subtype => <Q::c|NO_NAMED_NODE_ERR>);

        $test->id ('removeNamedItem.remove');
        my $et3 = $em-><M::NamedNodeMap.removeNamedItem> ('et1');
        $test->assert_equals ($et3, $et1);
        $test->assert_null ($em-><M::NamedNodeMap.getNamedItem> ('et1'));

        undef $em;

    @@XDTest:
      @@@QName: ETMap.removeNamedItem.test
      @@@ForCheck: tc|ForETMap
      @@@PerlDef:
        my $dtd;
        __CODE{d|createDTDefForTest:: $dtdef => $dtd}__;
        my $doc = $dtd-><AG::Node.ownerDocument>;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>, '3.0');
        my $em = $dtd-><AG::d|DocumentTypeDefinition.elementTypes>;
        undef $dtd;

        $test->id ('setNamedItem');
        my $et1 = $docx-><M::d|DocumentXDoctype.createElementTypeDefinition>
                          ('et1');
        $em-><M::NamedNodeMap.setNamedItem> ($et1);
        $test->assert_equals
                 ($em-><M::NamedNodeMap.getNamedItem> ('et1'), $et1);

        $test->id ('removeNamedItem.noremove');
        $test->assert_exception (code => sub {
          $em-><M::NamedNodeMap.removeNamedItem> ('et2');
        }, exception_subtype => <Q::c|NO_NAMED_NODE_ERR>);

        $test->id ('removeNamedItem.remove');
        my $et3 = $em-><M::NamedNodeMap.removeNamedItem> ('et1');
        $test->assert_equals ($et3, $et1);
        $test->assert_null ($em-><M::NamedNodeMap.getNamedItem> ('et1'));

        undef $em;

    @@XDTest:
      @@@QName: ATMap.removeNamedItem.test
      @@@ForCheck: tc|ForATMap
      @@@PerlDef:
        my $dtd;
        __CODE{d|createDTDefForTest:: $dtdef => $dtd}__;
        my $doc = $dtd-><AG::Node.ownerDocument>;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>, '3.0');
        my $etd = $docx-><M::d|DocumentXDoctype.createElementTypeDefinition>
                          ('et1');
        my $ad = $etd-><AG::d|ElementTypeDefinition.attributeDefinitions>;
        undef $dtd;
        undef $etd;

        $test->id ('setNamedItem');
        my $at1 = $docx-><M::d|DocumentXDoctype.createAttributeDefinition>
                          ('at1');
        $ad-><M::NamedNodeMap.setNamedItem> ($at1);
        $test->assert_equals
                 ($ad-><M::NamedNodeMap.getNamedItem> ('at1'), $at1);

        $test->id ('removeNamedItem.noremove');
        $test->assert_exception (code => sub {
          $ad-><M::NamedNodeMap.removeNamedItem> ('at2');
        }, exception_subtype => <Q::c|NO_NAMED_NODE_ERR>);

        $test->id ('removeNamedItem.remove');
        my $at3 = $ad-><M::NamedNodeMap.removeNamedItem> ('at1');
        $test->assert_equals ($at3, $at1);
        $test->assert_null ($ad-><M::NamedNodeMap.getNamedItem> ('at1'));

        undef $ad;

    @@XDTest:
      @@@QName: EntityMap.removeNamedItem.test
      @@@ForCheck: tc|ForEntityMap
      @@@PerlDef:
        my $dtd;
        __CODE{d|createDTDefForTest:: $dtdef => $dtd}__;
        my $doc = $dtd-><AG::Node.ownerDocument>;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>, '3.0');
        my $em = $dtd-><AG::d|DocumentTypeDefinition.generalEntities>;
        undef $dtd;

        $test->id ('setNamedItem');
        my $et1 = $docx-><M::d|DocumentXDoctype.createGeneralEntity>
                          ('et1');
        $em-><M::NamedNodeMap.setNamedItem> ($et1);
        $test->assert_equals
                 ($em-><M::NamedNodeMap.getNamedItem> ('et1'), $et1);

        $test->id ('removeNamedItem.noremove');
        $test->assert_exception (code => sub {
          $em-><M::NamedNodeMap.removeNamedItem> ('et2');
        }, exception_subtype => <Q::c|NO_NAMED_NODE_ERR>);

        $test->id ('removeNamedItem.remove');
        my $et3 = $em-><M::NamedNodeMap.removeNamedItem> ('et1');
        $test->assert_equals ($et3, $et1);
        $test->assert_null ($em-><M::NamedNodeMap.getNamedItem> ('et1'));

        undef $em;

    @@XDTest:
      @@@QName: NotationMap.removeNamedItem.test
      @@@ForCheck: tc|ForNotationMap
      @@@PerlDef:
        my $dtd;
        __CODE{d|createDTDefForTest:: $dtdef => $dtd}__;
        my $doc = $dtd-><AG::Node.ownerDocument>;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>, '3.0');
        my $em = $dtd-><AG::d|DocumentTypeDefinition.notations>;
        undef $dtd;

        $test->id ('setNamedItem');
        my $et1 = $docx-><M::d|DocumentXDoctype.createNotation>
                          ('et1');
        $em-><M::NamedNodeMap.setNamedItem> ($et1);
        $test->assert_equals
                 ($em-><M::NamedNodeMap.getNamedItem> ('et1'), $et1);

        $test->id ('removeNamedItem.noremove');
        $test->assert_exception (code => sub {
          $em-><M::NamedNodeMap.removeNamedItem> ('et2');
        }, exception_subtype => <Q::c|NO_NAMED_NODE_ERR>);

        $test->id ('removeNamedItem.remove');
        my $et3 = $em-><M::NamedNodeMap.removeNamedItem> ('et1');
        $test->assert_equals ($et3, $et1);
        $test->assert_null ($em-><M::NamedNodeMap.getNamedItem> ('et1'));

        undef $em;

  @IntMethod:
    @@Perlop: DELETE
    @@enDesc:
      Removes a node specified by name.
    @@enDesc:
      @@@ddid: attr
      @@@ForCheck: tc|ForAttrMap
      @@@enDesc:
        If the removed attribute is known to have a default value,
        an attribute immediately appears containing the default
        value as well as the corresponding namespace URI, local name,
        and prefix when applicable.
    @@Param:
      @@@Name: key
      @@@Type: DOMString
      @@@enDesc:
        The <A::Node.nodeName> of the node to remove.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node removed from the map.
      @@@enImplNote:
        Is this return value OK?
      @@@nullCase:
        @@@@enDesc:
          If there is no node named as <P::name> in the map.
      @@@dx:raises:
        @@@@@: c|NOMOD_NAMEDNODEMAP_ERR
        @@@@enDesc:
          If the map is read-only.
      @@@PerlDef:
        try {
          $r = $self-><M::NamedNodeMap.removeNamedItem> ($key);
        } catch <IF::c|DOMException> with {
          my $err = shift;
          unless ($err->subtype eq <Q::c|NO_NAMED_NODE_ERR>) {
            $err->throw;
          }
        };

  @Method:
    @@Name: item
    @@enDesc:
      Returns the <P::index>th item in the map.
    @@Param:
      @@@Name: index
      @@@Type: idl|unsignedLong||ManakaiDOM|all
      @@@enDesc:
        The ordinal index of a node to retrieve.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node at the <P::index>th position in the map.
      @@@nullCase:
        @@@@enDesc:
          If <P::index> is greater than or equal to the number of nodes
          in the map.
      @@@PerlDef:
        @@@@ForCheck: tc|ForAttrMap
        @@@@@:
          FIND: {
            my $i = 0;
            my $attrs;
            __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
              $r => $attrs,
              $prop => {<H::infoset|attributes>},
              $ref => {$$$self},
            }__;
            for my $ns (sort {$a cmp $b} keys %{$attrs}) {
              for my $ln (sort {$a cmp $b} keys %{$attrs->{$ns}}) {
                if ($i++ == $index) {
                  __CODE{mg|createNodeRefFromID||ManakaiDOM|all::
                    $bag => {<Code::mg|getNodeBag||ManakaiDOM|all::
                                        $ref = {$$$self}>},
                    $stemid => {$attrs->{$ns}->{$ln}},
                    $ref => $r,
                    $opt => {{
                      <H::mg|nodeRefInterfaces> => [<IFName::Attr>],
                    }},
                  }__;
                  last FIND;
                }
              }
            }
          } # FIND
      @@@PerlDef:
        @@@@ForCheck: !tc|ForAttrMap
        @@@@@:
          my $list;
          my $ifs;
          __FOR{tc:ForETMap::
            __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
              $r => $list,
              $prop => {<H::d|elementTypes>},
              $ref => {$$$self},
            }__;
            $ifs = [<IFName::ETDef>];
          }__;
          __FOR{tc:ForATMap::
            __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
              $r => $list,
              $prop => {<H::d|attributeDefinitions>},
              $ref => {$$$self},
            }__;
            $ifs = [<IFName::ATDef>];
          }__;
          __FOR{tc:ForEntityMap::
            __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
              $r => $list,
              $prop => {<H::d|generalEntities>},
              $ref => {$$$self},
            }__;
            $ifs = [<IFName::tx|Entity>];
          }__;
          __FOR{tc:ForNotationMap::
            __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
              $r => $list,
              $prop => {<H::d|notations>},
              $ref => {$$$self},
            }__;
            $ifs = [<IFName::tx|Notation>];
          }__;
          my $key = $index >= 0 ? [sort {$a cmp $b} keys %$list]->[$index]
                                : null;
          if (defined $key and defined $list->{$key}) {
            __CODE{mg|createNodeRefFromID||ManakaiDOM|all::
              $bag => {<Code::mg|getNodeBag||ManakaiDOM|all::
                                  $ref = {$$$self}>},
              $stemid => {$list->{$key}},
              $ref => $r,
              $opt => {{
                 <H::mg|nodeRefInterfaces> => $ifs,
              }},
            }__;
          }
    
    @@Test:
      @@@QName: AttrMap.item.test
      @@@ForCheck: tc|ForAttrMap
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;
        my $doc = $el-><AG::Node.ownerDocument>;
        my $em = $el-><AG::Node.attributes>;
        
        $test->id ('no.item');
        $test->assert_null ($em-><M::NamedNodeMap.item> (-1));
        $test->assert_null ($em-><M::NamedNodeMap.item> (0));
        $test->assert_null ($em-><M::NamedNodeMap.item> (1));
        $test->assert_null ($em-><M::NamedNodeMap.item> (2));

        $test->id ('two.items');
        my $et1 = $doc-><M::Document.createAttribute>
                          ('et1');
        $el-><M::Element.setAttributeNode> ($et1);
        my $et2 = $doc-><M::Document.createAttribute>
                          ('et2');
        $el-><M::Element.setAttributeNode> ($et2);

        $test->assert_null ($em-><M::NamedNodeMap.item> (-1));
        $test->assert_null ($em-><M::NamedNodeMap.item> (2));
        my $item0 = $em-><M::NamedNodeMap.item> (0);
        my $item1 = $em-><M::NamedNodeMap.item> (1);
        $test->assert_not_null ($item0);
        $test->assert_not_null ($item1);
        $test->assert_not_equals ($item0, $item1);
        $test->assert_true ($et1 eq $item0 or $et2 eq $item0);
        $test->assert_true ($et1 eq $item1 or $et2 eq $item1);
    
    @@XDTest:
      @@@QName: ETMap.item.test
      @@@ForCheck: tc|ForETMap
      @@@PerlDef:
        my $dtd;
        __CODE{d|createDTDefForTest:: $dtdef => $dtd}__;
        my $doc = $dtd-><AG::Node.ownerDocument>;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>, '3.0');
        my $em = $dtd-><AG::d|DocumentTypeDefinition.elementTypes>;
        
        $test->id ('no.item');
        $test->assert_null ($em-><M::NamedNodeMap.item> (-1));
        $test->assert_null ($em-><M::NamedNodeMap.item> (0));
        $test->assert_null ($em-><M::NamedNodeMap.item> (1));
        $test->assert_null ($em-><M::NamedNodeMap.item> (2));

        $test->id ('two.items');
        my $et1 = $docx-><M::d|DocumentXDoctype.createElementTypeDefinition>
                          ('et1');
        $dtd-><M::d|DocumentTypeDefinition.setElementTypeDefinitionNode> ($et1);
        my $et2 = $docx-><M::d|DocumentXDoctype.createElementTypeDefinition>
                          ('et2');
        $dtd-><M::d|DocumentTypeDefinition.setElementTypeDefinitionNode> ($et2);

        $test->assert_null ($em-><M::NamedNodeMap.item> (-1));
        $test->assert_null ($em-><M::NamedNodeMap.item> (2));
        my $item0 = $em-><M::NamedNodeMap.item> (0);
        my $item1 = $em-><M::NamedNodeMap.item> (1);
        $test->assert_not_null ($item0);
        $test->assert_not_null ($item1);
        $test->assert_not_equals ($item0, $item1);
        $test->assert_true ($et1 eq $item0 or $et2 eq $item0);
        $test->assert_true ($et1 eq $item1 or $et2 eq $item1);
    
    @@XDTest:
      @@@QName: ATMap.item.test
      @@@ForCheck: tc|ForATMap
      @@@PerlDef:
        my $dtd;
        __CODE{d|createDTDefForTest:: $dtdef => $dtd}__;
        my $doc = $dtd-><AG::Node.ownerDocument>;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>, '3.0');
        my $etd = $docx-><M::d|DocumentXDoctype.createElementTypeDefinition>
                          ('et1');
        my $ad = $etd-><AG::d|ElementTypeDefinition.attributeDefinitions>;
        undef $dtd;
        
        $test->id ('no.item');
        $test->assert_null ($ad-><M::NamedNodeMap.item> (-1));
        $test->assert_null ($ad-><M::NamedNodeMap.item> (0));
        $test->assert_null ($ad-><M::NamedNodeMap.item> (1));
        $test->assert_null ($ad-><M::NamedNodeMap.item> (2));

        $test->id ('two.items');
        my $at1 = $docx-><M::d|DocumentXDoctype.createAttributeDefinition>
                          ('at1');
        $etd-><M::d|ElementTypeDefinition.setAttributeDefinitionNode> ($at1);
        my $at2 = $docx-><M::d|DocumentXDoctype.createAttributeDefinition>
                          ('at2');
        $etd-><M::d|ElementTypeDefinition.setAttributeDefinitionNode> ($at2);

        $test->assert_null ($ad-><M::NamedNodeMap.item> (-1));
        $test->assert_null ($ad-><M::NamedNodeMap.item> (2));
        my $item0 = $ad-><M::NamedNodeMap.item> (0);
        my $item1 = $ad-><M::NamedNodeMap.item> (1);
        $test->assert_not_null ($item0);
        $test->assert_not_null ($item1);
        $test->assert_not_equals ($item0, $item1);
        $test->assert_true ($at1 eq $item0 or $at2 eq $item0);
        $test->assert_true ($at1 eq $item1 or $at2 eq $item1);
    
    @@XDTest:
      @@@QName: EntityMap.item.test
      @@@ForCheck: tc|ForEntityMap
      @@@PerlDef:
        my $dtd;
        __CODE{d|createDTDefForTest:: $dtdef => $dtd}__;
        my $doc = $dtd-><AG::Node.ownerDocument>;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>, '3.0');
        my $em = $dtd-><AG::d|DocumentTypeDefinition.generalEntities>;
        
        $test->id ('no.item');
        $test->assert_null ($em-><M::NamedNodeMap.item> (-1));
        $test->assert_null ($em-><M::NamedNodeMap.item> (0));
        $test->assert_null ($em-><M::NamedNodeMap.item> (1));
        $test->assert_null ($em-><M::NamedNodeMap.item> (2));

        $test->id ('two.items');
        my $et1 = $docx-><M::d|DocumentXDoctype.createGeneralEntity>
                          ('et1');
        $dtd-><M::d|DocumentTypeDefinition.setGeneralEntityNode> ($et1);
        my $et2 = $docx-><M::d|DocumentXDoctype.createGeneralEntity>
                          ('et2');
        $dtd-><M::d|DocumentTypeDefinition.setGeneralEntityNode> ($et2);

        $test->assert_null ($em-><M::NamedNodeMap.item> (-1));
        $test->assert_null ($em-><M::NamedNodeMap.item> (2));
        my $item0 = $em-><M::NamedNodeMap.item> (0);
        my $item1 = $em-><M::NamedNodeMap.item> (1);
        $test->assert_not_null ($item0);
        $test->assert_not_null ($item1);
        $test->assert_not_equals ($item0, $item1);
        $test->assert_true ($et1 eq $item0 or $et2 eq $item0);
        $test->assert_true ($et1 eq $item1 or $et2 eq $item1);
    
    @@XDTest:
      @@@QName: NotationMap.item.test
      @@@ForCheck: tc|ForNotationMap
      @@@PerlDef:
        my $dtd;
        __CODE{d|createDTDefForTest:: $dtdef => $dtd}__;
        my $doc = $dtd-><AG::Node.ownerDocument>;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>, '3.0');
        my $em = $dtd-><AG::d|DocumentTypeDefinition.notations>;
        
        $test->id ('no.item');
        $test->assert_null ($em-><M::NamedNodeMap.item> (-1));
        $test->assert_null ($em-><M::NamedNodeMap.item> (0));
        $test->assert_null ($em-><M::NamedNodeMap.item> (1));
        $test->assert_null ($em-><M::NamedNodeMap.item> (2));

        $test->id ('two.items');
        my $et1 = $docx-><M::d|DocumentXDoctype.createNotation>
                          ('et1');
        $dtd-><M::d|DocumentTypeDefinition.setNotationNode> ($et1);
        my $et2 = $docx-><M::d|DocumentXDoctype.createNotation>
                          ('et2');
        $dtd-><M::d|DocumentTypeDefinition.setNotationNode> ($et2);

        $test->assert_null ($em-><M::NamedNodeMap.item> (-1));
        $test->assert_null ($em-><M::NamedNodeMap.item> (2));
        my $item0 = $em-><M::NamedNodeMap.item> (0);
        my $item1 = $em-><M::NamedNodeMap.item> (1);
        $test->assert_not_null ($item0);
        $test->assert_not_null ($item1);
        $test->assert_not_equals ($item0, $item1);
        $test->assert_true ($et1 eq $item0 or $et2 eq $item0);
        $test->assert_true ($et1 eq $item1 or $et2 eq $item1);

  @Attr:
    @@Name: length
    @@Perlop: FETCHSIZE
    @@enDesc:
      The number of nodes in the map.
    @@Type: idl|unsignedLong||ManakaiDOM|all
    @@Get:
      @@@PerlDef:
        @@@@ForCheck: tc|ForAttrMap
        @@@@@:
          my $list;
          __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
            $r => $list,
            $prop => {<H::infoset|attributes>},
            $ref => {$$$self},
          }__;
          for my $l (values %$list) {
            $r += grep {$l->{$_}} keys %$l;
          }
      @@@PerlDef:
        @@@@ForCheck: tc|ForETMap
        @@@@@:
          my $list;
          __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
            $r => $list,
            $prop => {<H::d|elementTypes>},
            $ref => {$$$self},
          }__;
          $r = @{[map {$_} values %$list]};
      @@@PerlDef:
        @@@@ForCheck: tc|ForATMap
        @@@@@:
          my $list;
          __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
            $r => $list,
            $prop => {<H::d|attributeDefinitions>},
            $ref => {$$$self},
          }__;
          $r = @{[map {$_} values %$list]};
      @@@PerlDef:
        @@@@ForCheck: tc|ForEntityMap
        @@@@@:
          my $list;
          __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
            $r => $list,
            $prop => {<H::d|generalEntities>},
            $ref => {$$$self},
          }__;
          $r = @{[map {$_} values %$list]};
      @@@PerlDef:
        @@@@ForCheck: tc|ForNotationMap
        @@@@@:
          my $list;
          __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
            $r => $list,
            $prop => {<H::d|notations>},
            $ref => {$$$self},
          }__;
          $r = @{[map {$_} values %$list]};

    @@Test:
      @@@QName: AttrMap.length.test
      @@@ForCheck: tc|ForAttrMap
      @@@PerlDef:
        my $el;
        __CODE{tc|createElementForTest:: $el => $el}__;
        my $doc = $el-><AG::Node.ownerDocument>;
        my $et = $el-><AG::Node.attributes>;

        $test->id ('length.0');
        $test->assert_num_equals
                 (actual_value => $et-><AG::NamedNodeMap.length>,
                  expected_value => 0);

        $test->id ('length.1');
        my $et1 = $doc-><M::Document.createAttribute>
                          ('et1');
        $el-><M::Element.setAttributeNode> ($et1);
        $test->assert_num_equals
                 (actual_value => $et-><AG::NamedNodeMap.length>,
                  expected_value => 1);

        $test->id ('length.1');
        my $et2 = $doc-><M::Document.createAttribute>
                          ('et2');
        $el-><M::Element.setAttributeNode> ($et2);
        $test->assert_num_equals
                 (actual_value => $et-><AG::NamedNodeMap.length>,
                  expected_value => 2);
    @@XDTest:
      @@@QName: ETMap.length.test
      @@@ForCheck: tc|ForETMap
      @@@PerlDef:
        my $dtd;
        __CODE{d|createDTDefForTest:: $dtdef => $dtd}__;
        my $doc = $dtd-><AG::Node.ownerDocument>;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>, '3.0');
        my $et = $dtd-><AG::d|DocumentTypeDefinition.elementTypes>;

        $test->id ('length.0');
        $test->assert_num_equals
                 (actual_value => $et-><AG::NamedNodeMap.length>,
                  expected_value => 0);

        $test->id ('length.1');
        my $et1 = $docx-><M::d|DocumentXDoctype.createElementTypeDefinition>
                          ('et1');
        $dtd-><M::d|DocumentTypeDefinition.setElementTypeDefinitionNode> ($et1);
        $test->assert_num_equals
                 (actual_value => $et-><AG::NamedNodeMap.length>,
                  expected_value => 1);

        $test->id ('length.1');
        my $et2 = $docx-><M::d|DocumentXDoctype.createElementTypeDefinition>
                          ('et2');
        $dtd-><M::d|DocumentTypeDefinition.setElementTypeDefinitionNode> ($et2);
        $test->assert_num_equals
                 (actual_value => $et-><AG::NamedNodeMap.length>,
                  expected_value => 2);
    @@XDTest:
      @@@QName: ATMap.length.test
      @@@ForCheck: tc|ForATMap
      @@@PerlDef:
        my $dtd;
        __CODE{d|createDTDefForTest:: $dtdef => $dtd}__;
        my $doc = $dtd-><AG::Node.ownerDocument>;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>, '3.0');
        my $etd = $docx-><M::d|DocumentXDoctype.createElementTypeDefinition>
                          ('et1');
        my $at = $etd-><AG::d|ElementTypeDefinition.attributeDefinitions>;

        $test->id ('length.0');
        $test->assert_num_equals
                 (actual_value => $at-><AG::NamedNodeMap.length>,
                  expected_value => 0);

        $test->id ('length.1');
        my $at1 = $docx-><M::d|DocumentXDoctype.createAttributeDefinition>
                          ('at1');
        $etd-><M::d|ElementTypeDefinition.setAttributeDefinitionNode> ($at1);
        $test->assert_num_equals
                 (actual_value => $at-><AG::NamedNodeMap.length>,
                  expected_value => 1);

        $test->id ('length.2');
        my $at2 = $docx-><M::d|DocumentXDoctype.createAttributeDefinition>
                          ('at2');
        $etd-><M::d|ElementTypeDefinition.setAttributeDefinitionNode> ($at2);
        $test->assert_num_equals
                 (actual_value => $at-><AG::NamedNodeMap.length>,
                  expected_value => 2);
    @@XDTest:
      @@@QName: EntityMap.length.test
      @@@ForCheck: tc|ForEntityMap
      @@@PerlDef:
        my $dtd;
        __CODE{d|createDTDefForTest:: $dtdef => $dtd}__;
        my $doc = $dtd-><AG::Node.ownerDocument>;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>, '3.0');
        my $et = $dtd-><AG::d|DocumentTypeDefinition.generalEntities>;

        $test->id ('length.0');
        $test->assert_num_equals
                 (actual_value => $et-><AG::NamedNodeMap.length>,
                  expected_value => 0);

        $test->id ('length.1');
        my $et1 = $docx-><M::d|DocumentXDoctype.createGeneralEntity>
                          ('et1');
        $dtd-><M::d|DocumentTypeDefinition.setGeneralEntityNode> ($et1);
        $test->assert_num_equals
                 (actual_value => $et-><AG::NamedNodeMap.length>,
                  expected_value => 1);

        $test->id ('length.1');
        my $et2 = $docx-><M::d|DocumentXDoctype.createGeneralEntity>
                          ('et2');
        $dtd-><M::d|DocumentTypeDefinition.setGeneralEntityNode> ($et2);
        $test->assert_num_equals
                 (actual_value => $et-><AG::NamedNodeMap.length>,
                  expected_value => 2);
    @@XDTest:
      @@@QName: NotationMap.length.test
      @@@ForCheck: tc|ForNotationMap
      @@@PerlDef:
        my $dtd;
        __CODE{d|createDTDefForTest:: $dtdef => $dtd}__;
        my $doc = $dtd-><AG::Node.ownerDocument>;
        my $docx = $doc-><M::Node.getFeature> (<Q::fe|XDoctype>, '3.0');
        my $et = $dtd-><AG::d|DocumentTypeDefinition.notations>;

        $test->id ('length.0');
        $test->assert_num_equals
                 (actual_value => $et-><AG::NamedNodeMap.length>,
                  expected_value => 0);

        $test->id ('length.1');
        my $et1 = $docx-><M::d|DocumentXDoctype.createNotation>
                          ('et1');
        $dtd-><M::d|DocumentTypeDefinition.setNotationNode> ($et1);
        $test->assert_num_equals
                 (actual_value => $et-><AG::NamedNodeMap.length>,
                  expected_value => 1);

        $test->id ('length.1');
        my $et2 = $docx-><M::d|DocumentXDoctype.createNotation>
                          ('et2');
        $dtd-><M::d|DocumentTypeDefinition.setNotationNode> ($et2);
        $test->assert_num_equals
                 (actual_value => $et-><AG::NamedNodeMap.length>,
                  expected_value => 2);

  @IntMethod:
    @@Perlop: STORESIZE
    @@Param:
      @@@Name: count
      @@@Type: idl|unsignedLong||ManakaiDOM|all
    @@Return:
      @@@dx:raises:
        @@@@@: c|NOMOD_NAMEDNODEMAP_ERR
        @@@@enDesc:
          If the map is read-only.
      @@@PerlDef:
        __DEEP{
          my $length = $self-><AG::NamedNodeMap.length>;
          if ($length > $count) {
            for (my $i = $length - 1; $i >= $count; $i--) {
              my $item = $self-><M::NamedNodeMap.item> ($i);
              $self-><M::NamedNodeMap.removeNamedItem>
                       ($item-><AG::Node.nodeName>);
            }
          }
        }__;

  @IntMethod:
    @@Perlop: EXISTS
    @@enDesc:
      <Perl::EXISTS> for tied hash.
    @@Param:
      @@@Name: key
      @@@Type: DOMString
    @@Return:
      @@@Type: idl|boolean||ManakaiDOM|all
      @@@PerlDef:
        @@@@ForCheck: !tc|ForETMap !tc|ForATMap !tc|ForEntityMap !tc|ForNotationMap
        @@@@@:
          __DEEP{
            $r = defined ($self-><M::NamedNodeMap.getNamedItem> ($key));
          }__;
      @@@PerlDef:
        @@@@ForCheck: tc|ForETMap
        @@@@@:
          my $list;
          __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
            $r => $list,
            $prop => {<H::d|elementTypes>},
            $ref => {$$$self},
          }__;
          $r = exists $list->{$key};
      @@@PerlDef:
        @@@@ForCheck: tc|ForATMap
        @@@@@:
          my $list;
          __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
            $r => $list,
            $prop => {<H::d|attributeDefinitions>},
            $ref => {$$$self},
          }__;
          $r = exists $list->{$key};
      @@@PerlDef:
        @@@@ForCheck: tc|ForEntityMap
        @@@@@:
          my $list;
          __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
            $r => $list,
            $prop => {<H::d|generalEntities>},
            $ref => {$$$self},
          }__;
          $r = exists $list->{$key};
      @@@PerlDef:
        @@@@ForCheck: tc|ForNotationMap
        @@@@@:
          my $list;
          __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
            $r => $list,
            $prop => {<H::d|notations>},
            $ref => {$$$self},
          }__;
          $r = exists $list->{$key};

  @IntMethod:
    @@Perlop: FIRSTKEY
    @@enDesc:
      <Perl::FIRSTKEY> for tied hash.
    @@Return:
      @@@Type: DOMString
      @@@PerlDef:
        @@@@ForCheck: tc|ForAttrMap
        @@@@@:
          __DEEP{
            my $node = $self-><M::NamedNodeMap.item> (0);
            $r = $node ? $node-><AG::Node.nodeName> : null;
            __CODE{mg|setNodeStemPropValue||ManakaiDOM|all::
              $given => {1},
              $prop => {<H::tc|hashPosition>},
              $ref => {$$$self},
            }__;
          }__;
      @@@PerlDef:
        @@@@ForCheck: tc|ForETMap
        @@@@@:
          my $list;
          __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
            $r => $list,
            $prop => {<H::d|elementTypes>},
            $ref => {$$$self},
          }__;
          my $a = keys %$list; # reset
          $r = each %$list;
      @@@PerlDef:
        @@@@ForCheck: tc|ForATMap
        @@@@@:
          my $list;
          __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
            $r => $list,
            $prop => {<H::d|attributeDefinitions>},
            $ref => {$$$self},
          }__;
          my $a = keys %$list; # reset
          $r = each %$list;
      @@@PerlDef:
        @@@@ForCheck: tc|ForEntityMap
        @@@@@:
          my $list;
          __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
            $r => $list,
            $prop => {<H::d|generalEntities>},
            $ref => {$$$self},
          }__;
          my $a = keys %$list; # reset
          $r = each %$list;
      @@@PerlDef:
        @@@@ForCheck: tc|ForNotationMap
        @@@@@:
          my $list;
          __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
            $r => $list,
            $prop => {<H::d|notations>},
            $ref => {$$$self},
          }__;
          my $a = keys %$list; # reset
          $r = each %$list;

  @IntMethod:
    @@Perlop: NEXTKEY
    @@enDesc:
      <Perl::NEXTKEY> for tied hash.
    @@Param:
      @@@Name: lastkey
      @@@Type: DOMString
    @@Return:
      @@@Type: DOMString
      @@@PerlDef:
        @@@@ForCheck: tc|ForAttrMap
        @@@@@:
          __DEEP{
            my $i;
            __CODE{mg|get++NodeStemPropValue||ManakaiDOM|all::
              $r => $i,
              $prop => {<H::tc|hashPosition>},
              $ref => {$$$self},
            }__;
            my $node = $self-><M::NamedNodeMap.item> ($i);
            $r = $node ? $node-><AG::Node.nodeName> : null;
          }__;
      @@@PerlDef:
        @@@@ForCheck: tc|ForETMap
        @@@@@:
          my $list;
          __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
            $r => $list,
            $prop => {<H::d|elementTypes>},
            $ref => {$$$self},
          }__;
          $r = each %$list;
      @@@PerlDef:
        @@@@ForCheck: tc|ForATMap
        @@@@@:
          my $list;
          __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
            $r => $list,
            $prop => {<H::d|attributeDefinitions>},
            $ref => {$$$self},
          }__;
          $r = each %$list;
      @@@PerlDef:
        @@@@ForCheck: tc|ForEntityMap
        @@@@@:
          my $list;
          __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
            $r => $list,
            $prop => {<H::d|generalEntities>},
            $ref => {$$$self},
          }__;
          $r = each %$list;
      @@@PerlDef:
        @@@@ForCheck: tc|ForNotationMap
        @@@@@:
          my $list;
          __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
            $r => $list,
            $prop => {<H::d|notations>},
            $ref => {$$$self},
          }__;
          $r = each %$list;

  @IntMethod:
    @@ForCheck: !tc|ForAttrMap
    @@Perlop: SCALAR
    @@enDesc:
      <Perl::SCALAR> for tied hash.
    @@Return:
      @@@Type: DOMString
      @@@PerlDef:
        @@@@ForCheck: tc|ForETMap
        @@@@@:
          my $list;
          __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
            $r => $list,
            $prop => {<H::d|elementTypes>},
            $ref => {$$$self},
          }__;
          $r = scalar %$list;
      @@@PerlDef:
        @@@@ForCheck: tc|ForATMap
        @@@@@:
          my $list;
          __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
            $r => $list,
            $prop => {<H::d|attributeDefinitions>},
            $ref => {$$$self},
          }__;
          $r = scalar %$list;
      @@@PerlDef:
        @@@@ForCheck: tc|ForEntityMap
        @@@@@:
          my $list;
          __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
            $r => $list,
            $prop => {<H::d|generalEntities>},
            $ref => {$$$self},
          }__;
          $r = scalar %$list;
      @@@PerlDef:
        @@@@ForCheck: tc|ForNotationMap
        @@@@@:
          my $list;
          __CODE{mg|getNodeStemPropValue||ManakaiDOM|all::
            $r => $list,
            $prop => {<H::d|notations>},
            $ref => {$$$self},
          }__;
          $r = scalar %$list;

  @L2Method:
    @@Name: getNamedItemNS
    @@enDesc:
      Retrieves a node specified by local name and namespace URI.
    @@NoNSVersion: .getNamedItem
    @@XML2Feature:
    @@Param:
      @@@Name: namespaceURI
      @@@Type: DOMString
      @@@dis:actualType: ManakaiDOM|ManakaiDOMNamespaceURI
      @@@enDesc:
        The namespace URI of the node to retrieve.
    @@Param:
      @@@Name: localName
      @@@Type: DOMString
      @@@enDesc:
        The local name of the node to retrieve.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The <IF::Node> with the specified <P::localName> and
        <P::namespaceURI>.
      @@@nullCase:
        @@@@enDesc:
          If the pair of <P::localName> and <P::namespaceURI>
          does not identify any node in the map.
        @@@@enDesc:
          @@@@@ddid:nons
          @@@@@ForCheck: !tc|ForAttrMap ManakaiDOM|ManakaiDOM
          @@@@@@:
            If it is a <IF::NamedNodeMap> containing element type definitions,
            attribute definitions, entities, or notations attached to
            <IF::d|DocumentTypeDefinition> or <IF::d|ElementTypeDefinition>
            nodes.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_IMPL_NOSUPPORT_XMLNS
        @@@@enDesc:
          If the implementation does not support the <Feature::XML> feature
          and the language exposed through the <IF::Document> does
          not support XML namespaces.
      @@@PerlDef:
        @@@@ForCheck: tc|ForAttrMap
        @@@@@:
          __DEEP{
            $r = ($$$self)-><M::Element.getAttributeNodeNS>
                              ($namespaceURI, $localName);
          }__;
      @@@PerlDef:
        @@@@ForCheck: !tc|ForAttrMap
        @@@@@: \

    @@L2Test:
      @@@QName: AttrMap.getNamedItemNS.test
      @@@ForCheck: tc|ForAttrMap
      @@@PerlDef:
        my $el;
        __CODE{createElementForTest:: $el => $el}__;
        my $as = $el-><AG::Node.attributes>;

        my $uri = 'http://www.example/';
        my $ln = 'el1';
        my $qn = 'p:el1';
        my $value = 'value1';

        $test->id ('get.no');
        $test->assert_null ($as-><M::NamedNodeMap.getNamedItemNS> ($uri, $ln));
   
        $test->id ('set.text');
        $el-><M::Element.setAttributeNS> ($uri, $qn => $value);

        $test->id ('get.item');
        my $item0 = $as-><M::NamedNodeMap.getNamedItemNS> ($uri, $ln);
        $test->assert_isa ($item0, <IFName::Attr>);
        $test->assert_equals ($item0-><AG::Attr.ownerElement>, $el);
        $test->assert_equals ($item0-><AG::Attr.value>, $value);

  @L2Method:
    @@Name: setNamedItemNS
    @@enDesc:
      Adds a node using its <A::Node.namespaceURI> and <A::Node.localName>.
      If a node with that namespace URI and that local name is already
      present in the map, it is replaced by the new one.  Replacing a
      node by itself has no effect.
    @@enImplNote:
      @@@ddid: repbyitself
      @@@@:
        <QUOTE::Replacing a node by itself has no effect> clause
        is clarified by DOM Level 2 errata.
    @@NoNSVersion: .setNamedItem
    @@XML2Feature:
    @@Param:
      @@@Name: arg
      @@@Type: Node
      @@@enDesc:
        A node to store to the map.
      @@@enImplNote:
        The node will later be accessible using the value of 
        its <A::Node.namespaceURI> and <A::Node.localName> attributes.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        If the new <IF::Node> replaces an existing node, the replaced
        <IF::Node>.
      @@@nullCase:
        @@@@enDesc:
          If no replacement is occurred.
      @@@dx:raises:
        @@@@@: c|DIFFERENT_DOCUMENT_ERR
        @@@@enDesc:
          If <P::arg> was created from a different document than
          the one that created the map.
      @@@dx:raises:
        @@@@@: c|NOMOD_NAMEDNODEMAP_ERR
        @@@@enDesc:
          If the map is read-only.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the node to which the map is attached is read-only.
        @@@@For: ManakaiDOM|ManakaiDOM
      @@@dx:raises:
        @@@@@: c|INUSE_ATTRIBUTE_ERR
        @@@@enDesc:
          If <P::arg> is an <IF::Attr> that is already an attribute
          of another <IF::Element>.
        @@@@ForCheck: !tc|ForETMap !tc|ForATMap
      @@@dx:raises:
        @@@@@: MDOMX|HIERARCHY_BAD_TYPE
        @@@@enDesc:
          If an attempt is made to add a node that is unable to
          belong to the map.
        @@@@enImplNote:
          Added by DOM Level 2 errata.
        @@@@For: ManakaiDOM|DOM2
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_IMPL_NOSUPPORT_XMLNS
        @@@@enDesc:
          If the implementation does not support the <Feature::XML> feature
          and the language exposed through the <IF::Document> does
          not support XML namespaces.
      @@@dx:raises:
        @@@@ForCheck: !tc|ForAttrMap ManakaiDOM|ManakaiDOM
        @@@@@: c|NO_NS_NAMEDNODEMAP_ERR
        @@@@enDesc:
          If it is a <IF::NamedNodeMap> containing element type definitions,
          attribute definitions, entities, or notations attached to
          <IF::d|DocumentTypeDefinition> or <IF::d|ElementTypeDefinition>
          nodes.  They does not support XML namespaces.
      @@@c:reports:
        @@@@@: t|replace-by-itself
        @@@@enDesc:
          If the <P::arg> node is same as the current node in the map.
          The method has no effect in this case.
        @@@@enImplNote:
          This case is clarified by DOM Level 2 errata.
        @@@@For: ManakaiDOM|ManakaiDOM
      @@@PerlDef:
        @@@@ForCheck: tc|ForAttrMap
        @@@@@:
          __DEEP{
            $r = ($$$self)-><M::Element.setAttributeNodeNS> ($arg);
          }__;
      @@@disDef:
        @@@@ForCheck: !tc|ForAttrMap
        @@@@DOMMain:raiseException: c|NO_NS_NAMEDNODEMAP_ERR

    @@L2Test:
      @@@QName: AttrMap.setNamedItemNS.test
      @@@ForCheck: tc|ForAttrMap
      @@@PerlDef:
        my $el;
        __CODE{createElementForTest:: $el => $el}__;
        my $as = $el-><AG::Node.attributes>;
        my $doc = $el-><AG::Node.ownerDocument>;

        my $uri = 'http://www.example/';
        my $ln = 'el1';
        my $qn = 'p:el1';
        my $value = 'value1';

        $test->id ('get.no');
        $test->assert_null ($as-><M::NamedNodeMap.getNamedItemNS> ($uri, $ln));

        $test->id ('set.item');
        my $item0 = $doc-><M::Document.createAttributeNS> ($uri, $qn);
        $item0-><AS::Attr.value> ($value);
        my $item2 = $as-><M::NamedNodeMap.setNamedItemNS> ($item0);
        $test->assert_null ($item2);
 
        my $item3 = $as-><M::NamedNodeMap.getNamedItemNS> ($uri, $ln);
        $test->assert_equals ($item3, $item0);

        $test->id ('set.item.4');
        my $item4 = $doc-><M::Document.createAttributeNS> ($uri, $qn);
        my $item5 = $as-><M::NamedNodeMap.setNamedItemNS> ($item4);
        $test->assert_equals ($item5, $item0);
        
        my $item6 = $as-><M::NamedNodeMap.getNamedItemNS> ($uri, $ln);
        $test->assert_equals ($item6, $item4);

     @@L3Test:
       @@@QName: NamedNodeMap.Attr.setNamedItemNS.replace-by-itself.Test
       @@@ForCheck: tc|ForAttrMap
       @@@PerlDef:
         my $doc;
         __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

         my $eh_called = false;

         my $del = $doc-><M::Document.createElementNS> (null, 'e');
         $del-><M::Element.setAttributeNS> (null, 'attr' => 'value');

           my $attr = $del-><M::Element.getAttributeNodeNS> (null, 'attr');

           my $cfg = $doc-><AG::Document.domConfig>;
           $cfg-><M::c|DOMConfiguration.setParameter> ('error-handler' => sub {
             my (undef, $err) = @_;
             $eh_called = true;
             $test->assert_equals ($err-><AG::c|DOMError.severity>,
                                   <C::c|DOMError.SEVERITY_WARNING>);
             $test->assert_equals ($err-><AG::c|DOMError.type>,
                                   <Q::t|replace-by-itself>);
             $test->assert_equals ($err-><AG::c|DOMError.relatedData>, $attr);
             $test->assert_null ($err-><AG::c|DOMError.relatedException>);
             $test->assert_isa ($err-><AG::c|DOMError.location>,
                                <IFName::c|DOMLocator>);
             $test->assert_not_null ($err-><AG::c|DOMError.message>);
           });

           $test->assert_false ($eh_called);
           $del-><AG::Node.attributes>
               -><M::NamedNodeMap.setNamedItemNS> ($attr);
           $test->assert_true ($eh_called);

           $test->assert_equals ($del-><M::Element.getAttributeNodeNS>
                                   (null, 'attr'), $attr);

           $attr = null;

  @L2Method:
    @@Name: removeNamedItemNS
    @@enDesc:
      Removes a node specified by local name and namespace URI.
    @@NoNSVersion: .removeNamedItem
    @@enDesc:
      @@@ddid: attr
      @@@ForCheck: !tc|ForETMap !tc|ForATMap !tc|ForEntityMap !tc|ForNotationMap
      @@@@:
        If the removed attribute is known to have a default value,
        an attribute immediately appears containing the default value
        as well as the corresponding namespace URI, local name, 
        and prefix when applicable.
    @@XML2Feature:
    @@Param:
      @@@Name: namespaceURI
      @@@Type: DOMString
      @@@dis:actualType: ManakaiDOM|ManakaiDOMNamespaceURI
      @@@enDesc:
        The namespace URI of the node to remove.
    @@Param:
      @@@Name: localName
      @@@Type: DOMString
      @@@enDesc:
        The local name of the node to remove.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node removed from the map.
      @@@dx:raises:
        @@@@@: c|NO_NAMED_NODE_NS_ERR
        @@@@enDesc:
          If there is no node with the specified <P::namespaceURI>
          and <P::localName> in the map.

          If it is a <IF::NamedNodeMap> containing element type definitions,
          attribute definitions, entities, or notations attached to
          <IF::d|DocumentTypeDefinition> or <IF::d|ElementTypeDefinition>
          nodes.  They does not support XML namespaces.
      @@@dx:raises:
        @@@@@: c|NOMOD_NAMEDNODEMAP_ERR
        @@@@enDesc:
          If the map is read-only.
      @@@dx:raises:
        @@@@@: MDOMX|MDOM_IMPL_NOSUPPORT_XMLNS
        @@@@enDesc:
          If the implementation does not support the <Feature::XML> feature
          and the language exposed through the <IF::Document> does
          not support XML namespaces.
      @@@PerlDef:
        @@@@ForCheck: tc|ForAttrMap
        @@@@@:
          my $el = $$$self;
          __DEEP{ 
            $r = $el-><M::Element.getAttributeNodeNS>
                        ($namespaceURI, $localName);
          }__;
          unless ($r) {
            __EXCEPTION{c|NO_NAMED_NODE_NS_ERR::
              infoset|namespaceName => {$namespaceURI},
              c|name => {$localName},
              infoset|localName => {$localName},
              MDOMX|param-name => 'name',
            }__;
          }
          __DEEP{
            $r = $el-><M::Element.removeAttributeNode> ($r);
          }__;
      @@@disDef:
        @@@@ForCheck: !tc|ForAttrMap
        @@@@DOMMain:raiseException: c|NO_NAMED_NODE_NS_ERR

  @IntMethod:
    @@Perlop: ==
    @@enDesc:
      Returns whether two <IF::NamedNodeMap>s are equals.
   
      Two <IF::NamedNodeMap>s are equal if they have the same
      <A::NamedNodeMap.length> and for each node that exists in
      one map there is a node that exists in the other map 
      and is equal, although not necessarily at the same index.  <SRC::DOM3>
      In addition, the number of the items that are equal to a string in one list
      is equal to the number of such items in the other list.  <SRC::manakai>
    @@enImplNote:
      See also <M::Node.isEqualNode>.
    @@Param:
      @@@Name: arg
      @@@Type: NamedNodeMap
      @@@enDesc:
        The node map to compare equality with.
    @@Return:
      @@@Type: boolean
      @@@TrueCase:
        @@@@enDesc:
          If the maps are equal.
      @@@FalseCase:
        @@@@enDesc:
          Otherwise.
      @@@PerlDef:
        @@@@@:
          __DEEP{
            my $length1 = $self-><AG::NamedNodeMap.length>;
            my $length2 = $arg-><AG::NamedNodeMap.length>;
            if ($length1 == $length2) {
              CHK: {
                for my $i (0..$length1-1) {
                  my $node1 = $self-><M::NamedNodeMap.item> ($i);
                  my $node2 = $arg-><M::NamedNodeMap.item> ($i);
                  unless ($node1 == $node2) {
                    last CHK;
                  }
                }
                $r = true;
              } # CHK
            }
          }__;
        @@@@enImplNote:
          In manakai, nodes in namespace unaware <IF::NamedNodeMap> are
          ordered by their <A::Node.nodeName>.

  @IntMethod:
    @@Operator: ManakaiDOM|MUErrorHandler
    @@enDesc:
      When a <IF::ecore|ErrorInterface||ManakaiDOM|Perl> is <Perl::report>ed
      with an <Perl::-object> of <IF::NamedNodeMap> that represents
      a set of attributes, then this method is invoked.
      
      The method calls the <cfg::error-handler> if the error is of 
      <IF::c|DOMError>.  Otherwise, including the cases of <IF::c|DOMException>s,
      the error is rethrown so that appropriate <Perl::catch> clause
      can catch the error.
    @@enImplNote:
      For implementations which does not have the
      <IF::c|DOMError||ManakaiDOM|ManakaiDOM3> interface, the method
      is defined in the <Class::ManakaiDOM|ManakaiDOMObject> class
      and it is not overridden here.
    @@Param:
      @@@Name: err
      @@@Type: ecore|ErrorInterface||ManakaiDOM|Perl
      @@@enDesc:
        The reported error object.
    @@Return:
      @@@Type: DISPerl|Any
      @@@enDesc:
        If the <P::err> is a <IF::c|DOMError>, then the return value
        of the error handler.

           {NOTE:: If the error is thrown, the method never returns.
           }
      @@@nullCase:
        @@@@enDesc:
          No error handler.
      @@@PerlDef:
          __DEEP{
            ($$$self)->___report_error ($err);
          }__;

  @IntMethod:
    @@Perlop: TIEARRAY
    @@ManakaiDOM:isStatic:1
    @@Param:
      @@@Name: map
      @@@Type: NamedNodeMap
    @@Return:
      @@@Type: NamedNodeMap
      @@@PerlDef:
        $r = bless \\($$$map), $self;

  @IntMethod:
    @@Perlop: TIEHASH
    @@ManakaiDOM:isStatic:1
    @@Param:
      @@@Name: map
      @@@Type: NamedNodeMap
    @@Return:
      @@@Type: NamedNodeMap
      @@@PerlDef: $r = $map;

  @CODE:
    @@ForCheck: tc|ForAttrMap ManakaiDOM|ManakaiDOMLatest
    @@QName: getAttrMap
    @@enDesc:
      Creates an attribute node map from an element node.
    @@PerlDef:
      $map = bless \\($node), <ClassName::ManakaiDOMAttrMap>;
      __CODE{mg|orSetNodeStemPropValue||ManakaiDOM|all::
        $given => {-1},
        $prop => {<H::tc|hashPosition>},
        $ref => $node,
      }__;

  @CODE:
    @@ForCheck: tc|ForETMap ManakaiDOM|ManakaiDOMLatest
    @@QName: getElementTypeDefNodeMap
    @@enDesc:
      Creates an element type definition node map from a document
      type definition node.
    @@PerlDef:
      $map = bless \\($node), <ClassName::ManakaiDOMElementTypeDefMap>;

  @CODE:
    @@ForCheck: tc|ForATMap ManakaiDOM|ManakaiDOMLatest
    @@QName: getAttrDefNodeMap
    @@enDesc:
      Creates an attribute definition node map from a document
      type definition node.
    @@PerlDef:
      $map = bless \\($node), <ClassName::ManakaiDOMAttrDefMap>;

  @CODE:
    @@ForCheck: tc|ForEntityMap ManakaiDOM|ManakaiDOMLatest
    @@QName: getEntityNodeMap
    @@enDesc:
      Creates an entity node map from a document
      type definition node.
    @@PerlDef:
      $map = bless \\($node), <ClassName::ManakaiDOMEntityMap>;

  @CODE:
    @@ForCheck: tc|ForNotationMap ManakaiDOM|ManakaiDOMLatest
    @@QName: getNotationNodeMap
    @@enDesc:
      Creates a notation node map from a document
      type definition node.
    @@PerlDef:
      $map = bless \\($node), <ClassName::ManakaiDOMNotationMap>;
##NamedNodeMap

IntPropDef:
  @QName: tc|hashPosition
  @tc:nodeStemKey: hpos
  @enDesc:
    Index for <Perl::each>.

ResourceDef:
  @rdf:type:
    @@@: dis|MultipleResource
    @@ForCheck: !ManakaiDOM|ForIF !ManakaiDOM|ForClass
  @ForCheck: ManakaiDOM|ManakaiDOM

  @enDesc:
    <IF::NamedNodeMap> implementation for tied array.

  @DISCore:resourceType:
    @@@: DISLang|Class
    @@ForCheck: ManakaiDOM|ForClass

  @resourceFor:
    @@@: tc|ForAttrMap
    @@For: ManakaiDOM|ManakaiDOMLatest
  @QName:
    @@@: ManakaiDOMAttrMapArray
    @@ForCheck: tc|ForAttrMap
  @ISA:
    @@@: ManakaiDOMAttrMap
    @@ForCheck: tc|ForAttrMap

  @resourceFor:
    @@@: tc|ForETMap
    @@For: ManakaiDOM|ManakaiDOMLatest
  @QName:
    @@@: ManakaiDOMElementTypeDefMapArray
    @@ForCheck: tc|ForETMap
  @ISA:
    @@@: ManakaiDOMElementTypeDefMap
    @@ForCheck: tc|ForETMap

  @resourceFor:
    @@@: tc|ForATMap
    @@For: ManakaiDOM|ManakaiDOMLatest
  @QName:
    @@@: ManakaiDOMAttrDefMapArray
    @@ForCheck: tc|ForATMap
  @ISA:
    @@@: ManakaiDOMAttrDefMap
    @@ForCheck: tc|ForATMap

  @resourceFor:
    @@@: tc|ForEntityMap
    @@For: ManakaiDOM|ManakaiDOMLatest
  @QName:
    @@@: ManakaiDOMEntityMapArray
    @@ForCheck: tc|ForEntityMap
  @ISA:
    @@@: ManakaiDOMEntityMap
    @@ForCheck: tc|ForEntityMap

  @resourceFor:
    @@@: tc|ForNotationMap
    @@For: ManakaiDOM|ManakaiDOMLatest
  @QName:
    @@@: ManakaiDOMNotationMapArray
    @@ForCheck: tc|ForNotationMap
  @ISA:
    @@@: ManakaiDOMNotationMap
    @@ForCheck: tc|ForNotationMap

  @AppISA:
    Tie::Array

  @IntMethod:
    @@Perlop: FETCH
    @@Param:
      @@@Name: index
      @@@Type: idl|unsignedLong||ManakaiDOM|all
    @@Return:
      @@@Type: Node
      @@@nullCase:
      @@@PerlDef:
        __DEEP{
          $r = $self-><M::NamedNodeMap.item> ($index);
        }__;

  @IntMethod:
    @@Perlop: EXISTS
    @@enDesc:
      <Perl::EXISTS> for tied array.
    @@Param:
      @@@Name: index
      @@@Type: idl|unsignedLong||ManakaiDOM|all
    @@Return:
      @@@Type: idl|boolean||ManakaiDOM|all
      @@@PerlDef:
        __DEEP{
          my $length = $self-><AG::NamedNodeMap.length>;
          $r = ($index < $length);
        }__;
  
  @enImplNote:
    @@@ddid: perl.store
    @@@@:
      <Perl::STORE> is not implemented.

  @IntMethod:
    @@Perlop: DELETE
    @@enDesc:
      Removes a node specified by index.
    @@enDesc:
      @@@ddid: attr
      @@@ForCheck: tc|ForAttrMap
      @@@enDesc:
        If the removed attribute is known to have a default value,
        an attribute immediately appears containing the default
        value as well as the corresponding namespace URI, local name,
        and prefix when applicable.
    @@Param:
      @@@Name: index
      @@@Type: idl|unsignedLong||ManakaiDOM|all
      @@@enDesc:
        The ordinal index of the node to remove.
    @@Return:
      @@@Type: Node
      @@@enDesc:
        The node removed from the map.
      @@@enImplNote:
        Is this return value OK?
      @@@nullCase:
        @@@@enDesc:
          If there is no node named as <P::name> in the map.
      @@@dx:raises:
        @@@@@: c|NOMOD_NAMEDNODEMAP_ERR
        @@@@enDesc:
          If the map is read-only.
      @@@dx:raises:
        @@@@@: MDOMX|NOMOD_THIS
        @@@@enDesc:
          If the node to which the map is attached is read-only.
      @@@PerlDef:
        __DEEP{
          my $item = $self-><M::NamedNodeMap.item> ($index);
          if ($item) {
            $r = $self-><M::NamedNodeMap.removeNamedItem>
                            ($item-><AG::Node.nodeName>);
          }
        }__;
##NamedNodeMapArray

ElementTypeBinding:
  @Name: boolCParam
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType:
      @@@@: c|DOMConfigurationParameter
      @@@For: ManakaiDOM|DOM
    @@DISCore:resourceType:
      @@@@: DISSource|ResourceProperty
      @@@For: =ManakaiDOM|all
    @@For: ManakaiDOM|ManakaiDOMLatest
    @@For: =ManakaiDOM|all
    @@Type: idl|boolean||ManakaiDOM|all
    @@subsetOf:
      @@@@: c|anyDOMConfigurationParameter
      @@@For: =ManakaiDOM|all
    @@multipleProperties:
      @@@@: DISCore|Single
      @@@For: =ManakaiDOM|all
    @@dataType: 
      @@@@: DISCore|Boolean
      @@@For: =ManakaiDOM|all

ElementTypeBinding:
  @Name: nodeProp
  @ElementType: 
    tc:nodeStemKey
  @ShadowContent:
    @@For: =ManakaiDOM|all

boolCParam:
  @QName: cfg|clone-entity-reference-subtree
  @nodeProp: cerst
  @c:targetType: tc|Document
  @TrueCase:
    @@c:isSupported: 1
    @@enDesc:
      When the method <M::Node.cloneNode> clones an <IF::tx|EntityReference>
      node, it just copies its child nodes as for <IF::Attr> nodes.
      In addition, the flag that indicates whether the entity reference
      is expanded or not is copied to the cloned node.

      The cloned <IF::tx|EntityReference> and its subtree are set
      to read-only.

      Note that <M::Node.adoptNode> and <M::Node.importNode> methods
      does not affect by this configuration parameter.
    @@enImplNote:
      {ISSUE::
        Should <M::Node.adoptNode> do as <M::Node.cloneNode> would do?
      }
  @FalseCase:
    @@IsSupportRequired: 1
    @@IsDefault: 1
    @@c:isSupported: 1
    @@enDesc:
      When the method <M::Node.cloneNode> clones an <IF::tx|EntityReference>
      node, it simply creates a new <IF::tx|EntityReference> node
      as if the method <M::Document.createEntityReference> with appropriate
      node name parameter is invoked.

      This is the DOM Level 3 (or earlier) conformant behavior.
  @L3Test:
    @@QName: cfg.clone-entity-reference-subtree.test
    @@PerlDefC:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

      my $cfg = $doc-><AG::Document.domConfig>;

      $test->id ('default.false');
      $test->assert_false ($cfg-><M::c|DOMConfiguration.getParameter>
                                  (<Q::cfg|clone-entity-reference-subtree>));
   
      $test->id ('false.to.true');
      $cfg-><M::c|DOMConfiguration.setParameter>
              (<Q::cfg|clone-entity-reference-subtree> => true);
      $test->assert_false ($cfg-><M::c|DOMConfiguration.getParameter>
                                   (<Q::cfg|clone-entity-reference-subtree>));
      
      $test->id ('true.to.false');
      $cfg-><M::c|DOMConfiguration.setParameter>
              (<Q::cfg|clone-entity-reference-subtree> => false);
      $test->assert_false ($cfg-><M::c|DOMConfiguration.getParameter>
                                   (<Q::cfg|clone-entity-reference-subtree>));

      $test->id ('reset');
      $cfg-><M::c|DOMConfiguration.setParameter>
              (<Q::cfg|clone-entity-reference-subtree> => true);
      $cfg-><M::c|DOMConfiguration.setParameter>
              (<Q::cfg|clone-entity-reference-subtree> => null);
      $test->assert_false ($cfg-><M::c|DOMConfiguration.getParameter>
                                  (<Q::cfg|clone-entity-reference-subtree>));

boolCParam:
  @QName: cfg|dtd-default-attributes
  @nodeProp: dtddefault
  @c:targetType: tc|Document
  @TrueCase:
    @@IsSupportRequired: 1
    @@IsDefault: 1
    @@c:isSupported: 1
    @@enDesc:
      DTD default attributes, if any, are created by <M::Document.createElement>
      and <M::Document.createElementNS> methods.

      {ISSUE::
        removeAttribute* should also.
      }

      This is the DOM Level 3 (or earlier) conformant behavior.
  @FalseCase:
    @@c:isSupported: 1
    @@enDesc:
      DTD default attributes are not created by <M::Document.createElement>
      and <M::Document.createElementNS> methods.

      {ISSUE::
        removeAttribute* should also.
      }
  @L3Test:
    @@QName: cfg.dtd-default-attributes.test
    @@PerlDefC:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

      my $cfg = $doc-><AG::Document.domConfig>;
      my $pname = <Q::cfg|dtd-default-attributes>;

      $test->id ('default.true');
      $test->assert_true ($cfg-><M::c|DOMConfiguration.getParameter> ($pname));
      
      $test->id ('true.to.false');
      $cfg-><M::c|DOMConfiguration.setParameter> ($pname => false);
      $test->assert_false ($cfg-><M::c|DOMConfiguration.getParameter> ($pname));
   
      $test->id ('false.to.true');
      $cfg-><M::c|DOMConfiguration.setParameter> ($pname => true);
      $test->assert_false ($cfg-><M::c|DOMConfiguration.getParameter> ($pname));

      $test->id ('reset');
      $cfg-><M::c|DOMConfiguration.setParameter> ($pname => false);
      $cfg-><M::c|DOMConfiguration.setParameter> ($pname => null);
      $test->assert_true ($cfg-><M::c|DOMConfiguration.getParameter> ($pname));

boolCParam:
  @QName: cfg|xml-id
  @nodeProp: xmlid
  @c:targetType: tc|Document
  @TrueCase:
    @@IsSupportRequired: 1
    @@IsDefault: 1
    @@c:isSupported: 1
    @@enDesc:
      When an attribute node whose <A::Node.nodeName> is <XA::xml:id>
      or whose <A::Node.localName> is <XA::id> and <A::Node.namespaceURI>
      is <URI::http://www.w3.org/XML/1998/namespace> is created,
      via <M::Document.createAttributeNS> for example, then
      the node is typed as an identifier as defined in 
      <CITE::xml:id Specification>.

        {ISSUE::
          Should be limited to DTD [attribute type]?  Or should XML Schema
          or any other schema language's ID typing be also allowed?
        }

      If the <Feature::fe|XDoctype> feature is supported, newly
      created attribute definition nodes are also typed as identifiers.

      Note that if the attribute is typed as another type by schema
      associated to the document, then that type information takes precedence.

      {ISSUE::
        normalizeDocument
      }
  @FalseCase:
    @@c:isSupported: 1
    @@enDesc:
      Creation of <XA::xml:id> attribute or attribute definition nodes 
      is done as for other attributes.

  @L3Test:
    @@QName: cfg.xml-id.test
    @@PerlDefC:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

      my $cfg = $doc-><AG::Document.domConfig>;
      my $pname = <Q::cfg|xml-id>;

      $test->id ('default.true');
      $test->assert_true ($cfg-><M::c|DOMConfiguration.getParameter> ($pname));
      
      $test->id ('true.to.false');
      $cfg-><M::c|DOMConfiguration.setParameter> ($pname => false);
      $test->assert_false ($cfg-><M::c|DOMConfiguration.getParameter> ($pname));
   
      $test->id ('false.to.true');
      $cfg-><M::c|DOMConfiguration.setParameter> ($pname => true);
      $test->assert_false ($cfg-><M::c|DOMConfiguration.getParameter> ($pname));

      $test->id ('reset');
      $cfg-><M::c|DOMConfiguration.setParameter> ($pname => false);
      $cfg-><M::c|DOMConfiguration.setParameter> ($pname => null);
      $test->assert_true ($cfg-><M::c|DOMConfiguration.getParameter> ($pname));

boolCParam:
  @QName: cfg|strict-document-children
  @nodeProp: sdocchild
  @c:targetType: tc|Document
  @TrueCase:
    @@IsSupportRequired: 1
    @@IsDefault: 1
    @@c:isSupported: 1
    @@enDesc:
      Methods <M::Node.appendChild>, <M::Node.insertBefore>, and
      <M::Node.replaceChild> on <IF::Document> nodes only allow
      <IF::tx|DocumentType> (maximum of one), <IF::Element> (maximum of one),
      <IF::Comment>, and <IF::tx|ProcessingInstruction> nodes become
      children of <IF::Document> nodes.  In addition, they does 
      not allow an <IF::Element> node before the <IF::tx|DocumentType> node.

      This is the DOM Level 3 (or earlier) conformant behavior.

        {NOTE::
          Once a node is added to the child list of the <IF::Document>
          node during the configuration parameter is set to <DOM::false>,
          the node has never removed just because the parameter
          has been changed to <DOM::true>.
        }
  @FalseCase:
    @@c:isSupported: 1
    @@enDesc:
      Methods <M::Node.appendChild>, <M::Node.insertBefore>, and
      <M::Node.replaceChild> on <IF::Document> nodes allow
      <IF::Text>, <IF::tx|CDATASection>, and <IF::tx|EntityReference>
      nodes added as children.  In addition, they also allow
      more than one <IF::Element> nodes, and <IF::Element> nodes
      preceding <IF::tx|DocumentType> nodes in the <IF::Document>
      children list.

      It also changes how <A::Node.textContent> and
      <A::Node.manakaiAppendText> do act.
  @L3Test:
    @@QName: cfg.strict-document-children.test
    @@PerlDefC:
      my $doc;
      __CODE{tc|createEmptyDocumentForTest:: $doc => $doc}__;

      my $cfg = $doc-><AG::Document.domConfig>;

      my $cname = <Q::cfg|strict-document-children>;

      $test->id ('default.true');
      $test->assert_true ($cfg-><M::c|DOMConfiguration.getParameter> ($cname));
   
      $test->id ('true.to.false');
      $cfg-><M::c|DOMConfiguration.setParameter> ($cname => false);
      $test->assert_false ($cfg-><M::c|DOMConfiguration.getParameter> ($cname));

      $test->id ('false.to.true');
      $cfg-><M::c|DOMConfiguration.setParameter> ($cname => true);
      $test->assert_false ($cfg-><M::c|DOMConfiguration.getParameter> ($cname));

      $test->id ('reset');
      $cfg-><M::c|DOMConfiguration.setParameter> ($cname => false);
      $cfg-><M::c|DOMConfiguration.setParameter> ($cname => null);
      $test->assert_true ($cfg-><M::c|DOMConfiguration.getParameter> ($cname));

ElementTypeBinding:
  @Name: ErrDef
  @ElementType:
    dis:ResourceDef
  @ShadowContent:
    @@DISCore:resourceType: c|DOMErrorType
    @@For: ManakaiDOM|DOM3
    @@ecore:textFormatter: ecore|MUErrorFormatter||ManakaiDOM|Perl

ElementTypeBinding:
  @Name: errname
  @ElementType:
    c:errorType
  @ShadowContent:
    @@ContentType: DISCore|String

ErrDef:
  @QName: wf-invalid-character-in-node-name
  @errname: wf-invalid-character-in-node-name
  @enDesc:
    If the <cfg::c|well-formed> configuration parameter is set to 
    <DOM::true> and a <A::Node.nodeName> contains invalid character
    according to its node type.

    Or, in <IF::DOMLS|LSSerializer>, if a character that cannot 
    be represented in the output character encoding is occurred
    within markup.
  @c:severity: c|SEVERITY_ERROR

ErrDef:
  @QName: wf-invalid-character
  @errname: wf-invalid-character
  @enDesc:
    If the <cfg::well-formed> configuration parameter is set to
    <DOM::true> and the text content inside <IF::Attr>, <IF::Element>,
    <IF::Comment>, <IF::Text>, or <IF::tx|CDATASection> node
    or the data inside <IF::tx|ProcessingInstruction> node contains
    invalid characters.

    Or, in <IF::DOMLS:LSSerializer>, if the <cfg::split-cdata-sections>
    parameter is set to <DOM::false> and a <IF::tx|CDATASection>
    node contains characters that cannot be represented in the
    specified output encoding.  This error is not recoverable.
  @c:severity: c|SEVERITY_ERROR

ErrDef:
  @QName: t|setting-node-value-no-effect
  @enDesc:
    An attempt is made to set the <A::Node.nodeValue> that is 
    defined as <DOM::null>.  The operation has no effect.
  @c:severity: c|SEVERITY_WARNING
  @c:relatedData:
    @@enDesc:
      The node whose node value is attempted to change.

ErrDef:
  @QName: t|insert-before-itself
  @enDesc:
    An attempt is made to insert a node before itself.
    The result is implementation dependent; it has no effect
    in manakai.
  @c:severity: c|SEVERITY_WARNING
  @c:relatedData:
    @@enDesc:
      The node attempted to insert.

ErrDef:
  @QName: t|replace-by-itself
  @enDesc:
    An attempt is made to replace a node by itself.
    The result is implementation dependent; it has no effect
    in manakai.
  @c:severity: c|SEVERITY_WARNING
  @c:relatedData:
    @@enDesc:
      The node attempted to replace.

ErrDef:
  @QName: t|setting-prefix-no-effect-because-of-node
  @enDesc:
    An attempt is made to set the <A::Node.prefix> that is 
    defined as <DOM::null> since it is not an <IF::Element> or <IF::Attr>
    node or since it is a DOM Level 1 (i.e. namespace unaware) node.
    The operation has no effect.
  @c:severity: c|SEVERITY_WARNING
  @c:relatedData:
    @@enDesc:
      The node attempted to change its prefix.

ErrDef:
  @QName: t|setting-prefix-no-effect-because-of-document
  @enDesc:
    An attempt is made to set the <A::Node.prefix> that is 
    defined as <DOM::null> since its owner document does
    not support XML namespaces.  The operation has no effect.
  @c:severity: c|SEVERITY_WARNING
  @c:relatedData:
    @@enDesc:
      The node attempted to change its prefix.

IntPropDef:
  @QName: t|userData
  @enDesc:
    A hash reference whose value is a reference to the array of 
    data and its handler.
  @rdfs:domain: Node
  @rdfs:range: DISPerl|HASH
  @tc:nodeStemKey: ud

IntPropDef:
  @QName: c|read-only
  @enDesc:
    Whether a node is read-only or not.
  @Type: DISPerl|Boolean
  @tc:nodeStemKey: ro
