Namespace:
  @DOMXML:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/dom-core#
  @infoset:
     http://www.w3.org/2001/04/infoset#
  @lang:
     http://suika.fam.cx/~wakaba/archive/2004/8/18/lang#
  @license:
     http://suika.fam.cx/~wakaba/archive/2004/8/18/license#
  @MDOM:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#ManakaiDOM.
  @ManakaiDOM:
    http://suika.fam.cx/~wakaba/archive/2004/8/18/manakai-dom#
  @MDOM_EXCEPTION:
     http://suika.fam.cx/~wakaba/archive/2004/8/4/manakai-dom-exception#
  @null:
    http://suika.fam.cx/~wakaba/-temp/2003/09/27/null
  @TreeCore: \
  @xhtml1:
    http://www.w3.org/1999/xhtml
  @xml:
    http://www.w3.org/XML/1998/namespace
  @xmlns:
    http://www.w3.org/2000/xmlns/
Module:
  @QName: 
    MDOM:ManakaiDOMCore
  @BindingName:
    @@prefix:
      Message::DOM::
    @@ContentType:
      lang:Perl
    @@For:
      ManakaiDOM:ManakaiDOM
  @FullName:
    @@lang:en
    @@@: Manakai DOM Core Module
  @Namespace:
    http://suika.fam.cx/~wakaba/archive/2004/mdom-core#
  
  @Description:
    @@lang:en
    @@@:
      The Manakai DOM Core Module provides supplemental interfaces 
      that should be used with the DOM Core Module.
  
  @Author:
    @@FullName:Wakaba
    @@Mail:w@suika.fam.cx
  @License:
     license:Perl+MPL
  @Date.RCS:
     $Date: 2004/11/07 07:22:16 $

  @Require:
    @@Module:
      @@@Name:ManakaiDOMMain
    @@Module:
      @@@Name: DOMCore
  @DefaultFor:
    ManakaiDOM:ManakaiDOMLatest

  @Feature:
    @@QName: 
      ManakaiDOM:ManakaiDOMCore
    @@Version: 1.0
    @@For:
      ManakaiDOM:DOM1
    @@Description:
      @@@lang:en
      @@@@: The Manakai DOM Core Module, Level 1.
    @@Contrib:
      DOMCore:DOMImplementation::DOM1
    @@Contrib:
      DOMCore:DOMImplementation::DOM2
    @@Contrib:
      DOMCore:DOMImplementation::DOM3
  @Feature:
    @@QName:
      ManakaiDOM:ManakaiDOMCore
    @@Version: 2.0
    @@For:
      ManakaiDOM:DOM2
    @@Description:
      @@@lang:en
      @@@@: The Manakai DOM Core Module, Level 2.
    @@Contrib:
      DOMCore:DOMImplementation::DOM2
    @@Contrib:
      DOMCore:DOMImplementation::DOM3
  @Feature:
    @@QName:
      ManakaiDOM:ManakaiDOMCore
    @@Version: 3.0
    @@For:
      ManakaiDOM:DOM3
    @@Description:
      @@@lang:en
      @@@@: The Manakai DOM Core Module, Level 3.
    @@Contrib:
      DOMCore:DOMImplementation::DOM3

ClassDef:
  @Name: ManakaiDOMNodeObjectNode
  @Type:
    ManakaiDOM:Class
  @For:
    ManakaiDOM:ManakaiDOM

  @Description:
    @@lang:en
    @@@:
      The extended internal interface for the "ManakaiDOMNodeObject" 
      object used as a "Node".

  @ISA:
    ManakaiDOM:ManakaiDOMNodeObject
  @IntAttr:
    @@Name: textContent
    @@Description:
      @@@lang:en
      @@@@:
        Get text content of this node.
    @@ImplNote:
      @@@lang:en
      @@@@:
        This attribute is parallel to the attribute "textContent" of 
        the "Node" interface.
    @@Get:
      @@@Type:
        DOMMain:DOMString
      @@@Def:
        @@@@Type:
          lang:Perl
        @@@@@:
          if ({
                <Q:infoset:Element> => 1,
                <Q:infoset:Attribute> => 1,
                <Q:DOMXML:Entity> => 1,
                <Q:DOMXML:EntityReference> => 1,
                <Q:DOMCore:DocumentFragment> => 1,
              }->{$self->{<Q:DOMCore:nodeType>}}) {
            __DEEP{
              for (@{$self->{<Q:infoset:children>}}) {
                if ($_->{<Q:DOMCore:nodeType>} eq <Q:DOMCore:Text>) {
                  unless ($_->{<Q:infoset:elementContentWhitespace>}) {
                    $r .= $_->__SUPER{ManakaiDOMNodeObjectNode::}__::__INT{textContent}__;
                  }
                } elsif ($_->{<Q:DOMCore:nodeType>} ne <Q:infoset:Comment> and
                   $_->{<Q:DOMCore:nodeType>} ne
                                       <Q:infoset:ProcessingInstruction>) {
                  $r .= $_->__SUPER{ManakaiDOMNodeObjectNode}__::__INT{textContent}__;
                }
              }
            }__;
          } elsif ({
                     <Q:DOMCore:Text> => 1,
                     <Q:DOMXML:CDATASection> => 1,
                     <Q:infoset:Comment> => 1,
                     <Q:infoset:ProcessingInstruction> => 1,
                   }->{$self->{<Q:DOMCore:nodeType>}}) {
            $r = $self->{<Q:infoset:content>};
          } else {
            $r = null;
          }
        @@@ImplNote:
          @@@@lang:en
          @@@@@:
            ISSUE: Element content does not allow non-whitespace 
            character data or CDATA section.  In invalid document, 
            how this is?
      @@ImplNote:
        @@@lang:en
        @@@@:
          Setting is not defined - use the attribute "textContent" of 
          the  "Node" interface.
      @@Level: 1
      @@SpecLevel:1
  @IntMethod:
    @@Name: contentBaseURI
    @@Description:
      @@@lang:en
      @@@@:
        The base URI by which URI references in the content of 
        this node should be resolved, as per the XML Base Specification.
    @@Param:
      @@@Name:useInfosetProperty
      @@@Type:boolean
      @@@Description:
        @@@@lang:en
        @@@@@:
          Whether the <InfosetP:base URI> property of the XML Infoset, 
          if any, should be used to compute the base URI.
    @@Return:
      @@@Type:
        DOMMain:DOMString
      @@@Description:
        @@@@lang:en
        @@@@@:
          The base URI.
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The DOM implementation is unable to obtain an absolute URI.
      @@@Def:
        @@@@Type:
          lang:Perl
        @@@@@:
          $r = null;
          if ($useInfosetProperty and defined $self->{<Q:infoset:baseURI>}) {
            ## Note: In XML Infoset, <Q:infoset:Document>, 
            ##       <Q:infoset:Element> and <Q:infoset:ProcessingInstruction>
            ##       allow <Q:infoset:baseURI>.  In addition, 
            ##       <Q:DOMCore:Entity> and <Q:DOMCore:EntityReference>
            ##       may have it, if it is <Q:ManakaiDOM:isExternalEntity>,
            ##       in this implementation.
            $r = $self->{<Q:infoset:baseURI>};
          } else {
            if ($self->{<Q:DOMCore:nodeType>} eq <Q:infoset:Element>) {
              if ($self->{<Q:infoset:attributes>}
                       ->{<Q:xml:>}->{'base'}) {
                $r = $self->{<Q:infoset:attributes>}
                          ->{<Q:xml:>}->{'base'}
                              ## Condition insensitive
                          ->__SUPER{ManakaiDOMNodeObjectNode::}__::__INT{contentBaseURI}__
                                                     ($useInfosetProperty);
              } elsif ($self->{<Q:infoset:attributes>}
                            ->{<Q:ManakaiDOM:noNS>}->{'xml:base'}) {
                $r = $self->{<Q:infoset:attributes>}
                          ->{<Q:ManakaiDOM:noNS>}->{'xml:base'}
                              ## Condition insensitive
                          ->__SUPER{ManakaiDOMNodeObjectNode::}__::__INT{contentBaseURI}__
                                                     ($useInfosetProperty);
              }
              if (not defined $r and $self->{<Q:infoset:parent>}) {
                $r = $self->{<Q:infoset:parent>}
                          ->__SUPER{ManakaiDOMNodeObjectNode::}__::__INT{contentBaseURI}__
                                                     ($useInfosetProperty);  
              }
            } elsif ($self->{<Q:DOMCore:nodeType>} eq <Q:infoset:Attribute>) {
              if ((defined $self->{<Q:infoset:localName>} and
                   $self->{<Q:infoset:localName>} eq 'base' and
                   defined $self->{<Q:infoset:namespaceName>} and
                   $self->{<Q:infoset:namespaceName>} eq <Q:xml:>) or
                  (not defined $self->{<Q:infoset:localName>} and
                   $self->{<Q:DOMCore:name>} eq 'xml:base')) {
                $r = $self->__SUPER{ManakaiDOMNodeObjectNode::}__::__INT{textContent}__;
                if (defined $r and __CODE{isRelativeDOMURI: in => r}__) {
                  if ($self->{<Q:infoset:ownerElement>} and
                      $self->{<Q:infoset:ownerElement>}->{<Q:infoset:parent>}) {
                    my $base = $self->{<Q:infoset:ownerElement>}
                                    ->{<Q:infoset:parent>}
                                    ->__SUPER{ManakaiDOMNodeObjectNode::}__::__INT{contentBaseURI}__
                                                     ($useInfosetProperty);
                    if (defined $base) {
                      require URI;
                      $r = URI->new_abs ($r, $base)->as_string;
                    } else {
                      $r = null;
                    }
                  } else {
                    $r = null;
                  }
                }
              } else { # not xml:base
                if ($self->{<Q:infoset:ownerElement>}) {
                  $r = $self->{<Q:infoset:ownerElement>}
                            ->__SUPER{ManakaiDOMNodeObjectNode::}__::__INT{contentBaseURI}__
                                                      ($useInfosetProperty);
                }
              }
            } elsif ({
                       <Q:DOMCore:Text> => 1,
                       <Q:DOMXML:CDATASection> => 1,
                       <Q:infoset:DocumentTypeDeclaration> => 1,
                       <Q:infoset:Comment> => 1,
                       <Q:infoset:ProcessingInstruction> => 1,
                       <Q:DOMXML:Notation> => 1, ## but does not have content
                     }->{$self->{<Q:DOMCore:nodeType>}}) {
              if ($self->{<Q:infoset:parent>}) {
                $r = $self->{<Q:infoset:parent>}
                          ->__SUPER{ManakaiDOMNodeObjectNode::}__::__INT{contentBaseURI}__
                                                      ($useInfosetProperty);
              }
            } elsif ($self->{<Q:DOMCore:nodeType>} eq <Q:infoset:Document>) {
              ## 2. The base URI of the protocol entity
                # <Q:infoset:baseURI>
              ## 3. The URI to retrieve the protocol entity
              ## 4. The application defined base URI
              if (defined $self->{<Q:DOMCore:documentURI>} and
                  not __CODE{isRelativeDOMURI: in => r}__) {
                $r = $self->{<Q:DOMCore:documentURI>};
              }
            } elsif ({
                       <Q:DOMXML:Entity> => 1,
                       <Q:DOMXML:EntityReference> => 1,
                     }->{$self->{<Q:DOMCore:nodeType>}}) {
              if ($self->{<Q:ManakaiDOM:isExpanded>}) {
                if ($self->{<Q:ManakaiDOM:isExternalEntity>}) {
                  ## 2. Tge base URI of the protocol entity
                    # <Q:infoset:baseURI>
                  ## 3. The URI to retrieve the protocol entity
                  ## 4. The application defined base URI
                  if (defined $self->{<Q:DOMCore:documentURI>} and
                    not __CODE{isRelativeDOMURI: in => r}__) {
                    $r = $self->{<Q:DOMCore:documentURI>};
                  }
                  ## Should <Q:infoset:systemIdentifier> +
                  ## <Q:infoset:declarationBaseURI> also be used?
                }
              } else {
                if ($self->{<Q:infoset:parent>}) {
                  $r = $self->{<Q:infoset:parent>}
                            ->__SUPER{ManakaiDOMNodeObjectNode::}__::__INT{contentBaseURI}__
                                                      ($useInfosetProperty);
                }
              }
            } else {
              # <Q:DOMCore:DocumentFragment> or 
              # unknown node types
            }
          }
    @@ImplNote:
      @@@lang:en
      @@@@:
        This internal method assumes that the document is an XML 
        document and the base URI is computed by the XML Base 
        Specification.
    @@ImplNote:
      @@@lang:en
      @@@@:
        ISSUE: More study required for the base URI of document type- 
        or entity-related node types.
  @IntMethod:
    @@Name:htmlBaseURI
    @@Description:
      @@@lang:en
      @@@@:
        Return the base URI, as the document is an HTML document.
    @@Return:
      @@@Type:
        ManakaiDOM:ManakaiDOMURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          An absolute URI.  Although the HTML 4 Specification 
          refers the RFC 2396, the return value is a DOM URI 
          (URI reference, IRI reference or some other identifier), 
          if the source document is broken (see HTML 4 Appendix) or 
          the base URI is provided from the source other than 
          the content of the HTML document (ex. the DOM URI 
          used to retrieve the document or the value of 
          the <A:Document.documentURI>).
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The DOM implementation was not able to obtain an 
            absolute URI.
      @@@Def:
        @@@@Type:
          lang:Perl
        @@@@@:
          $r = null;
          my $doc = $self->{<Q:TreeCore:node>}->{<Q:DOMCore:ownerDocument>};
          if ($doc and $doc->{<Q:DOMCore:hasFeature>}->{HTML}) {
            HTML: {
              DOC: for (@{$doc->{<Q:infoset:children>}}) {
                if ($_->{<Q:DOMCore:nodeType>} eq <Q:infoset:Element> and
                    (defined $_->{<Q:infoset:localName>} and
                     $_->{<Q:infoset:localName>} eq 'html' and
                     ((defined $_->{<Q:infoset:namespaceName>} and
                       $_->{<Q:infoset:namespaceName>} eq <Q:xhtml1:>) or
                      not defined $_->{<Q:infoset:namespaceName>})) or
                    (not defined $_->{<Q:infoset:localName>} and
                     $_->{<Q:DOMCore:name>} eq 'html')) {
                  for (@{$_->{<Q:infoset:children>}}) {
                    if ($_->{<Q:DOMCore:nodeType>} eq <Q:infoset:Element> and
                        (defined $_->{<Q:infoset:localName>} and
                         $_->{<Q:infoset:localName>} eq 'head' and
                         ((defined $_->{<Q:infoset:namespaceName>} and
                           $_->{<Q:infoset:namespaceName>} eq <Q:xhtml1:>) or
                          not defined $_->{<Q:infoset:namespaceName>})) or
                        (not defined $_->{<Q:infoset:localName>} and
                         $_->{<Q:DOMCore:name>} eq 'head')) {
                      for (@{$_->{<Q:infoset:children>}}) {
                        if ($_->{<Q:DOMCore:nodeType>} eq <Q:infoset:Element> and
                            (defined $_->{<Q:infoset:localName>} and
                             $_->{<Q:infoset:localName>} eq 'base' and
                             ((defined $_->{<Q:infoset:namespaceName>} and
                               $_->{<Q:infoset:namespaceName>} eq <Q:xhtml1:>) or
                              not defined $_->{<Q:infoset:namespaceName>})) or
                            (not defined $_->{<Q:infoset:localName>} and
                             $_->{<Q:DOMCore:name>} eq 'base')) {
                          my $a = $_->{<Q:infoset:attributes>}
                                    ->{<Q:null:>}->{href} ||
                                  $_->{<Q:infoset:attributes>}
                                    ->{<Q:ManakaiDOM:noNS>}->{href};
                          if ($a) {
                            $r = $a->__SUPER{ManakaiDOMNodeObjectNode}__::__INT{textContent}__;
                            unless (__CODE{isRelativeDOMURI: in => r}__) {
                              $r = null;
                            } else {
                              last HTML;
                            }
                          }
                          last DOC;
                        }
                      }
                      last DOC;
                    }
                  }
                  last DOC;
                }
              } # DOC
              if (defined $doc->{<Q:infoset:baseURI>}) {
                $r = $doc->{<Q:infoset:baseURI>};
                $r = null if __CODE{isRelativeDOMURI: in => r}__;
              } elsif (defined $doc->{<Q:DOMCore:documentURI>}) {
                $r = $doc->{<Q:DOMCore:documentURI>};
                $r = null if __CODE{isRelativeDOMURI: in => r}__;
              }
            } # HTML
          }
       @@@@ImplNote:
         @@@@@lang:en
         @@@@@@:
           TODO: <HTML:codebase> attribute should be considered by option.
       @@@@ImplNote:
         @@@@@lang:en
         @@@@@@:
           ISSUE: How treat base URI of <IF:DocumentType>, ...
  @IntMethod:
    @@Name:lookupNamespacePrefix
    @@Description:
      @@@lang:en
      @@@@:
        Lookup the namespace prefix associated to the given namespace URI. 
        This node must be of type <IF:Element>. 
    @@ImplNote:
      @@@lang:en
      @@@@:
        This internal method implements the <DOM:lookupNamespacePrefix> 
        <SRC:<CITE:DOM Level 3 Core Specification> B.2 Namespace Prefix Lookup>.
    @@SpecLevel:3
    @@Param:
      @@@Name:namespaceURI
      @@@Type:
        ManakaiDOM:ManakaiDOMNamespaceURI
      @@@Description:
        @@@@lang:en
        @@@@@:
          The namespace URI.  <DOM:null> is not allowed; it must be 
          checked before the call of this internal method.
    @@Param:
      @@@Name:originalElement
      @@@Type:
        ManakaiDOM:ManakaiDOMNodeObjectNode
      @@@Description:
        @@@@lang:en
        @@@@@:
          The element node object to which the original request to lookup the 
          <P:namespaceURI> is issued.
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The original node the request is issued is not an <IF:Element> node.
    @@Return:
      @@@Type: 
        DOMMain:DOMString
      @@@Description:
        @@@@lang:en
        @@@@@: The namespace prefix.
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The associated namespace prefix does not found.
      @@@Def:
        @@@@Type:
          lang:Perl
        @@@@@:
          $r = null;
          FIND: {
          if ($originalElement) {
            if (defined $self->{<Q:infoset:namespaceName>} and
                $self->{<Q:infoset:namespaceName>} eq $namespaceURI and
                defined $self->{<Q:infoset:prefix>} and
                $originalElement->__SUPER{ManakaiDOMNodeObjectNode::}__::__INT{lookupNamespaceURI}__
                      ($self->{<Q:infoset:prefix>}) eq $namespaceURI) {
              $r = $self->{<Q:infoset:prefix>};
              last FIND;
            }
            for (values %{$self->{<Q:infoset:attributes>}->{<Q:xmlns:>}||{}}) {
              if (defined $_->{<Q:infoset:prefix>} and
                  $_->{<Q:infoset:prefix>} eq 'xmlns' and
                  $_->__SUPER{ManakaiDOMNodeObjectNode::}__::__INT{textContent}__
                    eq $namespaceURI and
                  $originalElement->__SUPER{ManakaiDOMNodeObjectNode::}__::__INT{lookupNamespaceURI}__
                            ($_->{<Q:infoset:localName>}) eq $namespaceURI) {
                $r = $_->{<Q:infoset:localName>};
                last FIND;
              }
            }
          }
            ## If element has ancestor element
            my $n = $self;
            ANCESTOR: {
              if ($n->{<Q:infoset:parent>}) {
                $n = $n->{<Q:infoset:parent>};
                if ($n->{<Q:DOMCore:nodeType>} eq <Q:infoset:Element>) {
                  $r = $n->__SUPER{ManakaiDOMNodeObjectNode::}__::__INT{lookupNamespacePrefix}__
                                               ($namespaceURI, $originalElement);
                  last FIND;
                } else {
                  redo ANCESTOR;
                }
              }
            }
          } # FIND
     @@ImplNote:
       @@@lang:en
       @@@@:
         Before returning found prefix, the algorithm needs to make 
         sure that the prefix is not redefined.  This is why 
         <P:originalElement> is required.
  @IntMethod:
    @@Name:isDefaultNamespace
    @@Description:
      @@@lang:en
      @@@@:
        Return whether the given namespace URI is the 
        default namespace.
    @@ImplNote:
      @@@lang:en
      @@@@:
        This internal method implements the <DOM:isDefaultNamespace> 
        <SRC:<CITE:DOM Level 3 Core Specification> B.3 Default Namespace Lookup>.
    @@SpecLevel:3
    @@Param:
      @@@Name:namespaceURI
      @@@Type:
        ManakaiDOM:ManakaiDOMNamespaceURI
      @@@Description:
        @@@@lang:en
        @@@@@: The namespace URI to look for.
    @@Return:
      @@@Type:boolean
      @@@Def:
        @@@@Type:
          lang:Perl
        @@@@@:
          if ($self->{<Q:DOMCore:nodeType>} eq <Q:infoset:Element>) {
            if (not defined $self->{<Q:infoset:prefix>}) {
              if (defined $namespaceURI and
                  defined $self->{<Q:infoset:namespaceName>} and
                  $namespaceURI eq $self->{<Q:infoset:namespaceName>}) {
                $r = true;
              } elsif (not defined $namespaceURI and
                       not defined $self->{<Q:infoset:namespaceName>}) {
                $r = true;
              }
              # else false
            } elsif ($self->{<Q:infoset:attributes>}
                          ->{<Q:infoset:xmlns:>}->{xmlns}) {
              my $v = $self->{<Q:infoset:attributes>}
                           ->{<Q:infoset:xmlns:>}->{xmlns}
                           ->__SUPER{ManakaiDOMNodeObjectNode::}__::__INT{textContent}__;
              if (defined $namespaceURI and $namespaceURI eq $v) {
                $r = true;
              } elsif (not defined $namespaceURI and not length $v) {
                $r = true;
              }
              # else false
            } else {
              ## If element has ancestor element
              my $n = $self;
              ANCESTOR: {
                if ($n->{<Q:infoset:parent>}) {
                  $n = $n->{<Q:infoset:parent>};
                  if ($n->{<Q:DOMCore:nodeType>} eq <Q:infoset:Element>) {
                    $r = $n->__SUPER{ManakaiDOMNodeObjectNode::}__::__INT{isDefaultNamespace}__
                                               ($namespaceURI);
                    last ANCESTOR;
                  } else {
                    redo ANCESTOR;
                  }
                }
                # false
              }
            }
          } elsif ($self->{<Q:DOMCore:nodeType>} eq <Q:infoset:Document>) {
            for (@{$self->{<Q:infoset:children>}}) {
              if ($_->{<Q:DOMCore:nodeType>} eq <Q:infoset:Element>) {
                $r = $_->__SUPER{ManakaiDOMNodeObjectNode::}__::__INT{isDefaultNamespace}__
                                               ($namespaceURI);
                last;
              }
            }
          } elsif ($self->{<Q:DOMCore:nodeType>} eq <Q:infoset:Attribute>) {
            if ($self->{<Q:infoset:ownerElement>}) {
              $r = $self->{<Q:infoset:ownerElement>}
                        ->__SUPER{ManakaiDOMNodeObjectNode::}__::__INT{isDefaultNamespace}__
                                               ($namespaceURI);
              last FIND;
            }
          } elsif ({
                     <Q:DOMXML:Entity> => 1,
                     <Q:DOMXML:Notation> => 1,
                     <Q:DOMXML:DocumentType> => 1,
                     <Q:DOMCore:DocumentFragment> => 1,
                   }->{$self->{<Q:DOMCore:nodeType>}}) {
            #
          } else {
          #} elsif ({
          #           <Q:DOMCore:Text> => 1,
          #           <Q:DOMCore:Comment> => 1,
          #           <Q:DOMXML:EntityReference> => 1,
          #           <Q:DOMXML:CDATASection> => 1,
          #           <Q:infoset:ProcessingInstruction> => 1,
          #         }->{$self->{<Q:DOMCore:nodeType>}}) {
            ## If node has ancestor element
            my $n = $self;
            ANCESTOR: {
              if ($n->{<Q:infoset:parent>}) {
                $n = $n->{<Q:infoset:parent>};
                if ($n->{<Q:DOMCore:nodeType>} eq <Q:infoset:Element>) {
                  $r = $n->__SUPER{ManakaiDOMNodeObjectNode::}__::__INT{isDefaultNamespace}__
                                               ($namespaceURI);
                  last ANCESTOR;
                } else {
                  redo ANCESTOR;
                }
              }
              # false
            }
          } # nodeType
  @IntMethod:
    @@Name:lookupNamespaceURI
    @@Description:
      @@@lang:en
      @@@@:
        Lookup the namespace URI associated to the given prefix.
    @@ImplNote:
      @@@lang:en
      @@@@:
        This internal method implements the <DOM:lookupNamespaceURI> 
        <SRC:<CITE:DOM Level 3 Core Specification> B.4 Namespace URI Lookup>.
    @@SpecLevel:3
    @@Param:
      @@@Name:prefix
      @@@Type:
        DOMMain:DOMString
      @@@Description:
        @@@@lang:en
        @@@@@: The namespace prefix.
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@: Look for the default namespace URI.
    @@Return:
      @@@Type:
        ManakaiDOM:ManakaiDOMNamespaceURI
      @@@Description:
        @@@@lang:en
        @@@@@: The namespace URI.
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@: No namespace URI associated.
      @@@Def:
        @@@@Type:
          lang:Perl
        @@@@@:
          $r = null;
          FIND: {
          if ($self->{<Q:DOMCore:nodeType>} eq <Q:infoset:Element>) {
            if (defined $self->{<Q:infoset:localName>} and
                defined $self->{<Q:infoset:namespaceName>} and
                ((defined $self->{<Q:infoset:prefix>} and defined $prefix and
                  $self->{<Q:infoset:prefix>} eq $prefix) or
                 (not defined $self->{<Q:infoset:prefix>} and
                  not defined $prefix))) {
              $r = $self->{<Q:infoset:namespaceName>};
              last FIND;
            }
            for (values %{$self->{<Q:infoset:attributes>}->{<Q:xmlns:>}||{}}) {
              if (defined $_->{<Q:infoset:prefix>} and defined $prefix and
                  $_->{<Q:infoset:prefix>} eq 'xmlns' and
                  $_->{<Q:infoset:localName>} eq $prefix) {
                ## Non default namespace
                $r = $_->__SUPER{ManakaiDOMNodeObjectNode::}__::__INT{textContent}__;
                $r = null unless length $r;
                last FIND;
              } elsif (not defined $prefix and
                       $_->{<Q:infoset:localName>} eq 'xmlns') {
                ## Default namespace
                $r = $_->__SUPER{ManakaiDOMNodeObjectNode::}__::__INT{textContent}__;
                $r = null unless length $r;
                last FIND;
              }
            }
            ## If element has ancestor element
            my $n = $self;
            ANCESTOR: {
              if ($n->{<Q:infoset:parent>}) {
                $n = $n->{<Q:infoset:parent>};
                if ($n->{<Q:DOMCore:nodeType>} eq <Q:infoset:Element>) {
                  $r = $n->__SUPER{ManakaiDOMNodeObjectNode::}__::__INT{lookupNamespaceURI}__
                                               ($prefix);
                  last FIND;
                } else {
                  redo ANCESTOR;
                }
              }
            }
          } elsif ($self->{<Q:DOMCore:nodeType>} eq <Q:infoset:Document>) {
            for (@{$self->{<Q:infoset:children>}}) {
              if ($_->{<Q:DOMCore:nodeType>} eq <Q:infoset:Element>) {
                $r = $_->__SUPER{ManakaiDOMNodeObjectNode::}__::__INT{lookupNamespaceURI}__
                                               ($prefix);
                last FIND;
              }
            }
          } elsif ($self->{<Q:DOMCore:nodeType>} eq <Q:infoset:Attribute>) {
            if ($self->{<Q:infoset:ownerElement>}) {
              $r = $self->{<Q:infoset:ownerElement>}
                        ->__SUPER{ManakaiDOMNodeObjectNode::}__::__INT{lookupNamespaceURI}__
                                               ($prefix);
              last FIND;
            }
          } elsif ({
                     <Q:DOMXML:Entity> => 1,
                     <Q:DOMXML:Notation> => 1,
                     <Q:DOMXML:DocumentType> => 1,
                     <Q:DOMCore:DocumentFragment> => 1,
                   }->{$self->{<Q:DOMCore:nodeType>}}) {
            #
          } else {
          #} elsif ({
          #           <Q:DOMCore:Text> => 1,
          #           <Q:DOMCore:Comment> => 1,
          #           <Q:DOMXML:EntityReference> => 1,
          #           <Q:DOMXML:CDATASection> => 1,
          #           <Q:infoset:ProcessingInstruction> => 1,
          #         }->{$self->{<Q:DOMCore:nodeType>}}) {
            ## If node has ancestor element
            my $n = $self;
            ANCESTOR: {
              if ($n->{<Q:infoset:parent>}) {
                $n = $n->{<Q:infoset:parent>};
                if ($n->{<Q:DOMCore:nodeType>} eq <Q:infoset:Element>) {
                  $r = $n->__SUPER{ManakaiDOMNodeObjectNode::}__::__INT{lookupNamespaceURI}__
                                               ($prefix);
                  last FIND;
                } else {
                  redo ANCESTOR;
                }
              }
            }
          } # nodeType
          } # FIND
      @@@ImplNote:
        @@@@lang:en
        @@@@@:
          No-namespace nodes are ignored <SRC:DOM 3>.

  @IntMethod:
    @@Name:isEqualNode
    @@Operator:
      @@@Type:
        lang:Perl
      @@@@:==
    @@Description:
      @@@lang:en
      @@@@:
        Check whether two nodes are equal.
    @@Param:
      @@@Name:arg
      @@@Type:
        ManakaiDOM:ManakaiDOMNodeObjectNode
      @@@Description:
        @@@@lang:en
        @@@@@:
          The node object to compare equality with.
    @@Return:
      @@@Type:boolean
      @@@Def:
        @@@@Type:
          lang:Perl
        @@@@@:
          __CLASS{Node::DOM3}__->__INT{getNodeReference}__ ($self, true) ==
          __CLASS{Node::DOM3}__->__INT{getNodeReference}__ ($arg, true)
            ? true : false;
    @@ImplNote:
      @@@lang:en
      @@@@:
        See <M:Node.isEqualNode>.  This internal method might need to 
        be modified if future version of DOM modify the specification.
    @@SpecLevel:3

  @IntMethod:
    @@Name:getElementBy
    @@Description:
      @@@lang:en
      @@@@:
        Return an element that met the given condition.
    @@Param:
      @@@Name:check
      @@@Type:
        DOMMain:Object
      @@@Description:
        @@@@lang:en
        @@@@@:
          A code reference.  The code referred is called with a 
          parameter of this <IF:ManakaiDOMNodeObjectNode> object 
          when an <IF:Element> node is determined whether it could 
          be returned.  The code should return either <DOM:true> or 
          <DOM:false>.
    @@Param:
      @@@Name:index
      @@@Type:
        DOMMain:Object
      @@@Description:
        @@@@lang:en
        @@@@@:
          A reference to the ordinal index of the element to return.
      @@@In:1
      @@@Out:
        @@@@@:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The number of <IF:Element> nodes with which <P:check> has 
            returned <DOM:true> is minused from the original value. 
            \
            For example, if the original <P:index> is <CODE:4> and 
            there is three <P:check>-<DOM:true> <IF:Element> nodes, 
            then <P:index> would result in <CODE:1> and this method 
            itself would return <DOM:null>.  If there is five (or more)
            such nodes, 
            <P:index> would be <CODE:-1> and the return value would be 
            the fiveth matching node.
      @@@InCase:
        @@@@Value:0
        @@@@Description:
          @@@@@lang:en
          @@@@@@:
            The first <IF:Element> node with which <P:check> has returned 
            <DOM:true> is returned.
    @@Return:
      @@@Type:
        ManakaiDOMNodeObjectNode
      @@@Description:
        @@@@lang:en
        @@@@@:
          The <IF:Element> node that met the condition.
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@:There is no such node.
      @@@Def:
        @@@@Type:
          lang:Perl
        @@@@@:
          for (@{$self->{<Q:infoset:children>}}) {
            last if $$index < 0;
            if ($_->{<Q:DOMCore:nodeType>} eq <Q:infoset:Element>) {
              if ($check->($_)) {
                if ($$index-- == 0) {
                  $r = $_;
                  last;
                }
              }
              $r = $_->__SUPER{ManakaiDOMNodeObjectNode::}__::__INT{getElementBy}__
                        ($check, $index);
              last if $$index == -1;
            } elsif ({
                       <Q:DOMXML:EntityReference> => 1,
                     }->{$_->{<Q:DOMCore:nodeType>}}) {
              $r = $_->__SUPER{ManakaiDOMNodeObjectNode::}__::__INT{getElementBy}__
                         ($check, $index);
              last if $$index == -1;
            }
          }
  @IntMethod:
    @@Name:getElementsBy
    @@Description:
      @@@lang:en
      @@@@:
        Return descendant elements that met the given condition.
    @@Param:
      @@@Name:check
      @@@Type:
        DOMMain:Object
      @@@Description:
        @@@@lang:en
        @@@@@:
          A code reference.  The code referred is called with a 
          parameter of this <IF:ManakaiDOMNodeObjectNode> object 
          when an <IF:Element> node is determined whether it could 
          be returned.  The code should return either <DOM:true> or 
          <DOM:false>.
    @@Return:
      @@@Type:
        DOMMain:Object
      @@@Description:
        @@@@lang:en
        @@@@@:
          An array reference to the <IF:Element> nodes that meet the condition.
      @@@Def:
        @@@@Type:
          lang:Perl
        @@@@@:
          $r = [];
          for (@{$self->{<Q:infoset:children>}}) {
            if ($_->{<Q:DOMCore:nodeType>} eq <Q:infoset:Element>) {
              if ($check->($_)) {
                push @$r, $_;
              }
         \    push @$r,
         \         @{$_->__SUPER{ManakaiDOMNodeObjectNode::}__::__INT{getElementsBy}__
         \               ($check)};
            } elsif ({
                       <Q:DOMXML:EntityReference> => 1,
                     }->{$_->{<Q:DOMCore:nodeType>}}) {
         \    push @$r,
         \         @{$_->__SUPER{ManakaiDOMNodeObjectNode::}__::__INT{getElementsBy}__
         \               ($check)};
            }
          }

## ClassDef:ManakaiDOMNodeObjectNode

ClassDef:
  @Name:  ManakaiDOMChildNodeList
  @For:
    ManakaiDOM:ManakaiDOM
  @Type:
    ManakaiDOM:Class

  @ISA:
    ManakaiDOM:ManakaiDOMNodeReference
  @Implement: 
    DOMCore:NodeList
  @Description:
    @@lang:en
    @@@:
      An ordered collection of child nodes.
  @Method:
     @@Name:  item
     @@Description:
       @@@lang:en
       @@@@:
         Return a child node.
     @@Param:
        @@@Name:  index
        @@@Type:  unsigned-long
        @@@Description:
          @@@@lang:en
          @@@@@: The index of the node into the child node list.
     @@Return:
        @@@Type:  Node
        @@@Description:
          @@@@lang:en
          @@@@@: 
            The child node at the "index"th position.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The "index" is invalid, i.e. it is greater than or 
              equal to the number of nodes in the list.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            $r = $self->{<Q:TreeCore:node>}->{<Q:infoset:children>}->[$index];
            if (defined $r) {
                   ## Condition sensitive
              $r = __CLASS{Node}__->__INT{getNodeReference}__ ($r);
            }
    @@SpecLevel:1
    @@Level[list]:
      1
      2
      3
  @Attr:
     @@Name:  length
     @@Description:
       @@@lang:en
       @@@@:
         The number of nodes in the list.
     @@Get:
        @@@Type:  unsigned-long
        @@@Def:
          @@@@Type:
             lang:Perl
          @@@@@:
            $r = @{$self->{<Q:TreeCore:node>}->{<Q:infoset:children>}};

  @IntMethod:
    @@Name: isEqualNodeList
    @@Operator:
      @@@Type:
        lang:Perl
      @@@@:==
    @@Description:
      @@@lang:en
      @@@@:
        Return whether two <IF:NodeList>s are equal.
    @@Param:
      @@@Name:arg
      @@@Type:ManakaiDOMChildNodeList
      @@@Description:
        @@@@lang:en
        @@@@@:
          The node list to compare equality with.
    @@Return:
      @@@Type:boolean
      @@@Def:
        @@@@Type:
          lang:Perl
        @@@@@:
   \      EQ: {
   \        last EQ unless @{$self->{<Q:TreeCore:node>}
   \                              ->{<Q:infoset:children>}} ==
   \                       @{$arg->{<Q:TreeCore:node>}
                                 ->{<Q:infoset:children>}};
            for my $i (0..$#{$self->{<Q:TreeCore:node>}
                                  ->{<Q:infoset:children>}}) {
              unless ($self->{<Q:TreeCore:node>}
                                  ->{<Q:infoset:children>}->[$i] ==
                      $arg->{<Q:TreeCore:node>}
                                  ->{<Q:infoset:children>}->[$i]) {
                last EQ;
              }
            }
            $r = true;
          }
    @@ImplNote:
      @@@lang:en
      @@@@:
        See: <M:Node.isEqualNode>.
    @@SpecLevel:3
## IF:ManakaiDOMChildNodeList

ClassDef:
  @Name: ManakaiDOMGetElementsNodeList
  @Type: 
    ManakaiDOM:Class
  @For:
    ManakaiDOM:ManakaiDOM
  @ISA:
    ManakaiDOM:ManakaiDOMNodeReference
  @Implement:
    DOMCore:NodeList
  @Description:
    @@lang:en
    @@@:
      An ordered collection of nodes, returned by <CODE:getElementsBy>-methods.
  @Method:
     @@Name:  item
     @@Description:
       @@@lang:en
       @@@@:
         Return an item in the collection.
     @@Param:
        @@@Name:  index
        @@@Type:  unsigned-long
        @@@Description:
          @@@@lang:en
          @@@@@: The index of the item into the collection.
     @@Return:
        @@@Type:  
          DOMCore:Node
        @@@Description:
          @@@@lang:en
          @@@@@: 
            The node at the <P:index>th position in the collection.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The <P:index> is greater than or 
              equal to the number of nodes in the list.
       @@@Def:
         @@@@Type:
           lang:Perl
         @@@@@:
           $r = $self->{<Q:TreeCore:node>}
                     ->__SUPER{ManakaiDOMNodeObjectNode::}__::__INT{getElementBy}__
                         ($self->{<Q:ManakaiDOMCore:nodeMatch>}, \$index);
           if (defined $r) {
                  ## Conditional
             $r = __CLASS{Node}__->__INT{getNodeReference}__ ($r, $self);
           }
         @@@@ImplNote:
           @@@@@lang:en
           @@@@@@:
             TODO: Cache mechanism required.
     @@SpecLevel:1
     @@Level[list]:
       1
       2
       3
  @Attr:
     @@Name:  length
     @@Description:
       @@@lang:en
       @@@@:
         The number of nodes in the list.
     @@Get:
        @@@Type:  unsigned-long
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            my $l = $self->{<Q:TreeCore:node>}
                         ->__SUPER{ManakaiDOMNodeObjectNode::}__::__INT{getElementsBy}__
                             ($self->{<Q:ManakaiDOMCore:nodeMatch>});
            $r = @$l;
## IF:ManakaiDOMGetElementsNodeList

IF:
  @Name: ManakaiDOMAttributes
  @ISA:
    ManakaiDOM:ManakaiDOMNodeReference::
  @Implement:
    DOMCore:NamedNodeMap
  @Description:
    @@lang:en
    @@@:
      A list of attributes attached to an <IF:Element> node.

  @ImplNote:
    @@lang:en
    @@@:
      An element may have two (or more) attributes that have the same 
      <A:Node.nodeName>, but different <A:Node.namespaceURI>s. 
      Which of them is returned by DOM Level 1 methods is 
      implementation dependent.  The only guarantee is 
      that all methods that access a named item by its <A:Node.nodeName> 
      will access the same item, and all methods by its namespace URI
      and local name will access the same item. 
      <SRC:<CITE:DOM Level 2 Core> 1.4.8 XML Namespaces,
      <CITE:DOM Level 3 Core> 1.3.3 XML Namespaces>

  @IntMethod:
    @@Name:selectAttrNodeObject
    @@Description:
      @@@lang:en
      @@@@:
        Select an <IF:ManakaiDOMNodeObject> object that represents an 
        <IF:Attr> node.
    @@NSVersion:selectAttrNodeObjectNS
    @@Param:
      @@@Name:name
      @@@Type:
        DOMMain:DOMString
      @@@Description:
        @@@@lang:en
        @@@@@:
          The name of the attribute to select.
    @@Return:
      @@@Type: 
        ManakaiDOM:ManakaiDOMNodeObject
      @@@Description:
        @@@@lang:en
        @@@@@:
          The <IF:ManakaiDOMNodeObject> object.
      @@@InCase:
        @@@@Value:
          @@@@@is-null:1
        @@@@Description:
          @@@@@lang:en
          @@@@@@: There is no such attribute.
      @@@Def:
        @@@@Type:
          lang:Perl
        @@@@@:
            my $attr = $self->{<Q:TreeCore:node>}->{<Q:infoset:attributes>};
            if ($attr->{<Q:ManakaiDOM:noNS>}->{$name}) {
              $r = $attr->{<Q:ManakaiDOM:noNS>}->{$name};
              __WHEN{IS{<Q:DOMCore:removeAttribute>}::
                delete $attr->{<Q:ManakaiDOM:noNS>};
              }__;
            } elsif ($name eq 'xmlns') {
              for my $a (keys %{$attr->{<Q:xmlns:>}||{}}) {
                if ($attr->{<Q:xmlns:>}->{$a}->{<Q:infoset:localName>}) {
                  $r = $attr->{<Q:xmlns:>}->{$a};
                  __WHEN{IS{<Q:DOMCore:removeAttribute>}::
                    delete $attr->{<Q:xmlns:>}->{$a};
                  }__;
                  last;
                }
              }
            } elsif ($name eq 'xmlns:xmlns') {
              # 
            } else {
              for my $ns (keys %$attr) {
                if ($ns eq <Q:ManakaiDOM:noNS>) {
                  # 
                } else {
                  for my $a (keys %{$attr->{$ns}||{}}) {
                    if (defined $attr->{$ns}->{$a}->{<Q:infoset:prefix>} and
                        $attr->{$ns}->{$a}->{<Q:infoset:prefix>}.':'.
                        $attr->{$ns}->{$a}->{<Q:infoset:localName>} eq $name) {
                      $r = $attr->{$ns}->{$a};
                      __WHEN{IS{<Q:DOMCore:removeAttribute>}::
                        delete $attr->{$ns}->{$a};
                      }__;
                      last;
                    } elsif (not defined $attr->{$ns}->{$a}->{<Q:infoset:prefix>}
                         and
                         $attr->{$ns}->{$a}->{<Q:infoset:localName>} eq $name) {
                      $r = $attr->{$ns}->{$a};
                      __WHEN{IS{<Q:DOMCore:removeAttribute>}::
                        delete $attr->{$ns}->{$a};
                      }__;
                      last;
                    }
                  }
                }
              }
            }
    @@ImplNote:
      @@@lang:en
      @@@@:
        The same internal method is defined in <IF:Element>.

  @Method:
     @@Name:  getNamedItem
     @@Description:
       @@@lang:en
       @@@@: Retrieve an attribute node specified by name.
     @@NSVersion:getNamedItemNS
     @@Param:
        @@@Name:  name
        @@@Type:  
           DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@:
            The <A:nodeName> of a node to retrieve, i.e. 
            the qualified name of the attribute.
     @@Return:
        @@@Type:  
          DOMCore:Attr
        @@@Description:
          @@@@lang:en
          @@@@@:
            The attribute node.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The <P:name> does not identify any node in this map.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            __INT{{selectAttrNodeObject}}__;
            if ($r) {
                         ## Condition sensitive
              $r = __CLASS{Node}__->__INT{getNodeReference}__ ($r, $self);
            }
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              This code is same as <M:Element.getAttributeNode>.
    @@SpecLevel:1
    @@Level[list]:
      1
      2
      3
  @Method:
     @@Name:  setNamedItem
     @@Description:
       @@@lang:en
       @@@@:
         Add a node using its <A:nodeName> attribute.  If a node with 
         that name is already present in this map, it is replaced 
         by the new one.
         \
         Replacing a node by itself has no effect.
     @@ImplNote:
       @@@lang:en
       @@@@: 
         <QUOTE:Replacing ... no effect> is clarified by the DOM Level 2 Errata. 
     @@NSVersion:setNamedItemNS
     @@Param:
        @@@Name:  arg
        @@@Type:  
          DOMCore:Attr
        @@@Description:
          @@@@lang:en
          @@@@@: A node to store in this map.
     @@Return:
        @@@Type:  
          DOMCore:Attr
        @@@Description:
          @@@@lang:en
          @@@@@:
            If the "arg" node replaces an existing node, the replaced node.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The "arg" node does not replace any node in the map.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: WRONG_DOCUMENT_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The "arg" node was created from a different document.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: This map is read-only.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: INUSE_ATTRIBUTE_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The "arg" node is already an 
              attribute of another "Element" object.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: HIERARCHY_REQUEST_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              An attempt is made to add a node that is unable to 
              belong to this map.
          @@@@SpecLevel:2
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@: This exception has added by the DOM Level 2 Errata.
         @@@Def:
           @@@@Type:
             lang:Perl
           @@@@@:
            if ($self->{<Q:TreeCore:node>}->{<Q:DOMCore:read-only>}) {
              __EXCEPTION{
                DOMException.NO_MODIFICATION_ALLOWED_ERR.
                MDOM_EXCEPTION:NOMOD_THIS::
              }__;
            }
            my $attrNode = $arg->{<Q:TreeCore:node>};
            if ($attrNode->{<Q:infoset:ownerElement>}) {
              __EXCEPTION{
                DOMException.INUSE_ATTRIBUTE_ERR::
                  <Q:MDOM_EXCEPTION:param-name> => 'arg',
              }__;
            } elsif ($attrNode->{<Q:DOMCore:ownerDocument>}
                              ->{<Q:TreeCore:nodeID>} ne
                     $self->{<Q:TreeCore:node>}->{<Q:DOMCore:ownerDocument>}
                          ->{<Q:TreeCore:nodeID>}) {
              __EXCEPTION{
                DOMException.WRONG_DOCUMENT_ERR::
              }__;
            } elsif ($attrNode->{<Q:DOMCore:nodeType>} ne
                     <Q:infoset:Attribute>) {
              __EXCEPTION{
                DOMException.HIERARCHY_REQUEST_ERR.
                MDOM_EXCEPTION:HIERARCHY_BAD_TYPE::
                  <Q:MDOM_EXCEPTION:param-name> => 'arg',
                  <Q:DOMCore:nodeType> => $attrNode->{<Q:DOMCore:nodeType>},
              }__;
            }

            if (defined $attrNode->{<Q:infoset:localName>}) {
              $r = $self->{<Q:TreeCore:node>}->{<Q:infoset:attributes>}
                     ->{defined $attrNode->{<Q:infoset:namespaceName>}
                              ? $attrNode->{<Q:infoset:namespaceName>}
                              : <Q:null:>}
                     ->{$attrNode->{<Q:infoset:localName>}};
            } else {
              $r = $self->{<Q:TreeCore:node>}->{<Q:infoset:attributes>}
                     ->{<Q:ManakaiDOM:noNS>}
                     ->{$attrNode->{<Q:DOMCore:name>}};
            }

            if ($r->{<Q:TreeCore:nodeID>} eq $attrNode->{<Q:TreeCore:nodeID>}) {
              __WARNING{
                ManakaiDOMImplementationException.
                MDOM_REPLACE_BY_ITSELF_NO_EFFECT::
              }__;
              $r = $arg;
            } else {
              $attrNode->{<Q:infoset:ownerElement>} = $self->{<Q:TreeCore:node>};
              if (defined $attrNode->{<Q:infoset:localName>}) {
                $self->{<Q:TreeCore:node>}->{<Q:infoset:attributes>}
                     ->{defined $attrNode->{<Q:infoset:namespaceName>}
                              ? $attrNode->{<Q:infoset:namespaceName>}
                              : <Q:null:>}
                     ->{$attrNode->{<Q:infoset:localName>}} = $attrNode;
              } else {
                $self->{<Q:TreeCore:node>}->{<Q:infoset:attributes>}
                     ->{<Q:ManakaiDOM:noNS>}
                     ->{$attrNode->{<Q:DOMCore:name>}} = $attrNode;
              }
              if ($r) {
                delete $r->{<Q:infoset:parent>};
                $r->__SUPER{ManakaiDOMNodeObject::}__::__INT{orphanate}__;
                     ## Condition sensitive
                $r = __CLASS{Node}__->__INT{getNodeReference}__ ($r, $self)
                  if defined wantarray;
              }
            }
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              It is unclear whether the node should be returned if 
              the node is <QUOTE:replaced> by itself.
            \
              This code is almost same as <M:Element.setAttributeNode>.
              The parameter <P:newAttr> in that method is named as 
              <P:arg> in this method.
    @@SpecLevel:1
    @@Level[list]:
      1
      2
      3
  @Method:
     @@Name:  removeNamedItem
     @@Description:
        @@@lang:en
        @@@@:
          Remove an attribute node specified by name.
     @@ImplNote:
       @@@lang:en
       @@@@:
         New non-<A:specified> attribute will be generated if the schema 
         defines some default value for the attribute removed.
     @@NSVersion:removeNamedItemNS
     @@Param:
        @@@Name:  name
        @@@Type:  
           DOMMain:DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The "nodeName" of the node to remove.
     @@Return:
        @@@Type:  
            DOMCore:Attr
        @@@Description:
          @@@@lang:en
          @@@@@: The attribute node removed from this map.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NOT_FOUND_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: There is no node named "name" in this map.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: This map is read-only.
          @@@@SpecLevel:1
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              This exception is added by the DOM Level 1 First Edition Errata.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            if ($self->{<Q:TreeCore:node>}->{<Q:DOMCore:read-only>}) {
              __EXCEPTION{
                DOMException.NO_MODIFICATION_ALLOWED_ERR.
                MDOM_EXCEPTION:NOMOD_THIS::
              }__;
            }
            __INT{{selectAttrNodeObject: <Q:DOMCore:removeAttribute>}}__;
            if ($r) {
              delete $r->{<Q:infoset:ownerElement>};
              $r->__SUPER{ManakaiDOMNodeObject::}__::__INT{orphanate}__;
                  ## Condition sensitive
              $r = __CLASS{Node}__->__INT{getNodeReference}__ ($r, $self)
                  if defined wantarray;
            } else {
              __EXCEPTION{
                DOMException.NOT_FOUND_ERR::
              }__;
            }
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              TODO: Default attribute
            \
              This code is almost same as <M:Element.removeAttribute>. 
              This method returns an <IF:Attr> removed but that method 
              does not (<M:Element.removeAttributeNode> does).
    @@SpecLevel:1
    @@Level[list]:
      1
      2
      3
  @Method:
     @@Name:  item
     @@Description:
       @@@lang:en
       @@@@:
         Return an attribute attached to the element.
     @@Param:
        @@@Name:  index
        @@@Type:  unsigned-long
        @@@Description:
          @@@@lang:en
          @@@@@: The index of the item into this map.
     @@Return:
        @@@Type: 
           DOMCore:Attr
        @@@Description:
          @@@@lang:en
          @@@@@: 
            The node at the <P:index>th position in the map.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: 
              The "index" is invalid, i.e. it is greater than or 
              equal to the number of nodes in this map.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            my $i = 0;
            FIND: for my $ns (sort keys %{$self->{<Q:TreeCore:node>}
                                               ->{<Q:infoset:attributes>}}) {
              for my $ln (sort keys %{$self->{<Q:TreeCore:node>}
                                           ->{<Q:infoset:attributes>}->{$ns}}) {
                if ($i++ == $index) {
                  $r = $self->{<Q:TreeCore:node>}->{<Q:infoset:attributes>}
                            ->{$ns}->{$ln};
                  last FIND;
                }
              }
            }
            if ($r) {
                         ## Condition sensitive
              $r = __CLASS{Node}__->__INT{getNodeReference}__ ($r, $self);
            }
    @@ImplNote:
      @@@lang:en
      @@@@:
        How ordering attributes is not specified.
    @@Level[list]:
      1
      2
      3
    @@SpecLevel:1
  @Attr:
     @@Name:  length
     @@Description:
       @@@lang:en
       @@@@: The number of attribute nodes attached to the element.
     @@Get:
        @@@Type:  unsigned-long
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            for (values %{$self->{<Q:TreeCore:node>}->{<Q:infoset:attributes>}}) {
              $r += keys %$_;
            }

  @IntMethod:
     @@Name: selectAttrNodeObjectNS
     @@Description:
       @@@lang:en
       @@@@:
         Select a <IF:ManakaiDOMNodeObject> object that represents 
         an <IF:Attr> node, by namespace URI and local name.
     @@NoNSVersion:selectAttrNodeObject
     @@Param:
        @@@Name:  namespaceURI
        @@@Type:
          ManakaiDOM:ManakaiDOMNamespaceURI
        @@@Description:
          @@@@lang:en
          @@@@@:
            The namespace URI of the attribute to select.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The attribute to select has no namespace.
     @@Param:
        @@@Name:  localName
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The local name of the attribute to select.
     @@Return:
        @@@Type:
          ManakaiDOM:ManakaiDOMNodeObject
        @@@Description:
          @@@@lang:en
          @@@@@:
            The <IF:ManakaiDOMNOdeObject> object.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: There is no such attribute.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            my $attr = $self->{<Q:TreeCore:node>}->{<Q:infoset:attributes>};
            $namespaceURI = <Q:null:> unless defined $namespaceURI;
            $r = $attr->{$namespaceURI}->{$localName};
            __WHEN{IS{<Q:DOMCore:removeAttribute>}::
              delete $attr->{$namespaceURI}->{$localName} if $r;
            }__;
    @@ImplNote:
      @@@lang:en
      @@@@:
        The same internal method is defined in <IF:Element>.

  @Method:
     @@Name:  getNamedItemNS
     @@Description:
       @@@lang:en
       @@@@:
         Retrieve an attribute node specified by local name and namespace URI.
     @@NoNSVersion:getNamedItem
     @@Param:
        @@@Name:  namespaceURI
        @@@Type:
          ManakaiDOM:ManakaiDOMNamespaceURI
        @@@Description:
          @@@@lang:en
          @@@@@:
            The namespace URI of the node to retrieve.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The node to retrieve has no namespace.
     @@Param:
        @@@Name:  localName
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The local name of the node to retrieve.
     @@Return:
        @@@Type:
          DOMCore:Attr
        @@@Description:
          @@@@lang:en
          @@@@@:
            An attribute node with the specified local name and 
            namespace URI.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The "namespaceURI" and "localName" does not identify 
              any node in this map.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NOT_SUPPORTED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The DOM implementation does not support the feature "XML" and 
              the language exposed through the "Document" does not 
              support XML Namespaces.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            __INT{{selectAttrNodeObjectNS}}__;
            if ($r) {
                         ## Condition sensitive
              $r = __CLASS{Node}__->__INT{getNodeReference}__ ($r, $self);
            }
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              Same code as <M:Element.getAttributeNodeNS>.
     @@Level[list]:
        2
        3
     @@SpecLevel:2
  @Method:
     @@Name:  setNamedItemNS
     @@Description:
       @@@lang:en
       @@@@:
         Add a node using its "namespaceURI" and "localName". 
         If a node with that namespace URI and that local name 
         is already present in this map, it is replaced by the new one. 
         Replacing a node by itself has no effect.
     @@NoNSVersion:setNamedItem
     @@Param:
        @@@Name:  arg
        @@@Type:
          DOMCore:Attr
        @@@Description:
          @@@@lang:en
          @@@@@: An attribute node to set to this attribute.
     @@Return:
        @@@Type:
          DOMCore:Attr
        @@@Description:
          @@@@lang:en
          @@@@@:
            If the "arg" node replaces an existing node, the replaced node.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The "arg" node replaces no existing node in this map.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: WRONG_DOCUMENT_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The "arg" node was created from a different document.
         @@@Exception:
           @@@@Name:NO_MODIFICATION_ALLOWED_ERR
           @@@@Type:DOMException
           @@@@SubType:
             @@@@@QName: 
               MDOM_EXCEPTION:NOMOD_THIS
             @@@@@Description:
               @@@@@@lang:en
               @@@@@@@:
                 This map is read-only.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: INUSE_ATTRIBUTE_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              The "arg" node is already an 
              attribute of another "Element" object.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: HIERARCHY_REQUEST_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              An attempt is made to add a node that is unable to 
              belong to this map.
          @@@@SpecLevel:2
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@: This exception has been added by the DOM Level 2 Errata. 
         @@@Exception:
           @@@@Name:NOT_SUPPORTED_ERR
           @@@@Type:DOMException
           @@@@SubType:
             @@@@@QName:
               MDOM_EXCEPTION:MDOM_IMPL_NOSUPPORT_XML
             @@@@@Description:
               @@@@@@lang:en
               @@@@@@@:
                 The DOM implementation does not support the feature 
                 <Feature:XML> and the language exposed through the 
                 <IF:Document> does not support XML Namespaces.
             @@@@@SpecLevel:2
           @@@@SubType:
             @@@@@QName:
               MDOM_EXCEPTION:MDOM_NODE_NOSUPPORT_XMLNS
             @@@@@Description:
               @@@@@@lang:en
               @@@@@@@:
                 The <P:arg> node does not support XML Namespace.
             @@@@@SpecLevel[list]:
         @@@Def:
           @@@@Type:
             lang:Perl
           @@@@@:
            if ($self->{<Q:TreeCore:node>}->{<Q:DOMCore:read-only>}) {
              __EXCEPTION{
                DOMException.NO_MODIFICATION_ALLOWED_ERR.
                MDOM_EXCEPTION:NOMOD_THIS::
              }__;
            }
            my $attrNode = $arg->{<Q:TreeCore:node>};
            if ($attrNode->{<Q:infoset:ownerElement>}) {
              __EXCEPTION{
                DOMException.INUSE_ATTRIBUTE_ERR::
                  <Q:MDOM_EXCEPTION:param-name> => 'arg',
              }__;
            } elsif ($attrNode->{<Q:DOMCore:ownerDocument>}
                              ->{<Q:TreeCore:nodeID>} ne
                     $self->{<Q:TreeCore:node>}->{<Q:DOMCore:ownerDocument>}
                          ->{<Q:TreeCore:nodeID>}) {
              __EXCEPTION{
                DOMException.WRONG_DOCUMENT_ERR::
              }__;
            } elsif ($attrNode->{<Q:DOMCore:nodeType>} ne
                     <Q:infoset:Attribute>) {
              __EXCEPTION{
                DOMException.HIERARCHY_REQUEST_ERR.
                MDOM_EXCEPTION:HIERARCHY_BAD_TYPE::
                  <Q:MDOM_EXCEPTION:param-name> => 'arg',
                  <Q:DOMCore:nodeType> => $attrNode->{<Q:DOMCore:nodeType>},
              }__;
            }

            if (defined $attrNode->{<Q:infoset:localName>}) {
              $r = $self->{<Q:TreeCore:node>}->{<Q:infoset:attributes>}
                     ->{defined $attrNode->{<Q:infoset:namespaceName>}
                              ? $attrNode->{<Q:infoset:namespaceName>}
                              : <Q:null:>}
                     ->{$attrNode->{<Q:infoset:localName>}};
            } else {
              __EXCEPTION{
                DOMException.NOT_SUPPORTED_ERR.
                MDOM_EXCEPTION:MDOM_NODE_NOSUPPORT_XMLNS::
                  <Q:MDOM_EXCEPTION:param-name> => 'arg',
              }__;
            }

            if ($r->{<Q:TreeCore:nodeID>} eq $attrNode->{<Q:TreeCore:nodeID>}) {
              __WARNING{
                ManakaiDOMImplementationException.
                MDOM_REPLACE_BY_ITSELF_NO_EFFECT::
              }__;
              $r = $arg;
            } else {
              $attrNode->{<Q:infoset:ownerElement>} = $self->{<Q:TreeCore:node>};
              if (defined $attrNode->{<Q:infoset:localName>}) {
                $self->{<Q:TreeCore:node>}->{<Q:infoset:attributes>}
                     ->{defined $attrNode->{<Q:infoset:namespaceName>}
                              ? $attrNode->{<Q:infoset:namespaceName>}
                              : <Q:null:>}
                     ->{$attrNode->{<Q:infoset:localName>}} = $attrNode;
              } else {
                $self->{<Q:TreeCore:node>}->{<Q:infoset:attributes>}
                     ->{<Q:ManakaiDOM:noNS>}
                     ->{$attrNode->{<Q:DOMCore:name>}} = $attrNode;
              }
              if ($r) {
                delete $r->{<Q:infoset:parent>};
                $r->__SUPER{ManakaiDOMNodeObject::}__::__INT{orphanate}__;
                     ## Condition sensitive
                $r = __CLASS{Node}__->__INT{getNodeReference}__ ($r, $self)
                  if defined wantarray;
              }
            }
          @@@@ImplNote:
            @@@@@lang:en
            @@@@@@:
              It is unclear whether the node should be returned if 
              the node is <QUOTE:replaced> by itself.
             \
              This code is almost same as <M:Element.setAttributeNodeNS>
              without some points.
     @@Level[list]:  
        2
        3
     @@ImplNote:
       @@@lang:en
       @@@@:
         The DOM Level 2 Specification said that the HTML-only DOM 
         implenentations do not need to implement this method. 
         The DOM Level 2 Errata and the DOM Level 3 Specification 
         says that the NOT_SUPPORTED_ERR should be raised.
     @@SpecLevel:2
  @Method:
     @@Name:  removeNamedItemNS
     @@Description:
        @@@lang:en
        @@@@:
          Remove a node specified by local name and namespace URI.
     @@ImplNote:
       @@@lang:en
       @@@@:
         New non-"specified" attribute will be generated if the schema 
         defines some default value for the attribute removed.
     @@NoNSVersion:removeNamedItem
     @@Param:
        @@@Name:  namespaceURI
        @@@Type:
          ManakaiDOM:ManakaiDOMNamespaceURI
        @@@Description:
          @@@@lang:en
          @@@@@: The namespace URI of the node to remove.
        @@@InCase:
          @@@@Value:
            @@@@@is-null:1
          @@@@Description:
            @@@@@lang:en
            @@@@@@: The node to remove has no namespace.
     @@Param:
        @@@Name:  localName
        @@@Type:  DOMString
        @@@Description:
          @@@@lang:en
          @@@@@: The local name of the node to remove.
     @@Return:
        @@@Type: 
          DOMCore:Attr
        @@@Description:
          @@@@lang:en
          @@@@@: The node removed from this map.
        @@@Exception:
          @@@@Type: DOMException
          @@@@Name: NOT_FOUND_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@:
              There is no node with the specified "namespaceURI" and 
              "localName" in the map.
        @@@Exception:
          @@@@Type: 
             DOMCore:DOMException
          @@@@Name: NO_MODIFICATION_ALLOWED_ERR
          @@@@Description:
            @@@@@lang:en
            @@@@@@: This map is read-only.
         @@@Exception:
           @@@@Type: 
             DOMCore:DOMException
           @@@@Name: NOT_SUPPORTED_ERR
          @@@@SubType:
            @@@@@QName:
              MDOM_EXCEPTION:MDOM_IMPL_NOSUPPORT_XML
            @@@@@Description:
              @@@@@@lang:en
              @@@@@@@:
                The DOM implementation does not support the feature 
                <Feature:XML> and the language exposed through 
                the <IF:Document> does not support XML Namespaces.
        @@@Def:
          @@@@Type:
            lang:Perl
          @@@@@:
            if ($self->{<Q:TreeCore:node>}->{<Q:DOMCore:read-only>}) {
              __EXCEPTION{
                DOMException.NO_MODIFICATION_ALLOWED_ERR.
                MDOM_EXCEPTION:NOMOD_THIS::
              }__;
            }
            __INT{{selectAttrNodeObjectNS: <Q:DOMCore:removeAttribute>}}__;
            if ($r) {
              delete $r->{<Q:infoset:ownerElement>};
              $r->__SUPER{ManakaiDOMNodeObject::}__::__INT{orphanate}__;
                     ## Condition sensitive
              $r = __CLASS{Node}__->__INT{getNodeReference}__ ($r, $self)
                  if defined wantarray;
            } else {
              __EXCEPTION{
                DOMException.NOT_FOUND_ERR::
              }__;
            }
         @@@@ImplNote:
           @@@@@lang:en
           @@@@@@:
             TODO: default attribute
         @@@@ImplNote:
           @@@@@lang:en
           @@@@@@:
             Almost same as <M:Element.removeAttributeNS>.
     @@ImplNote:
       @@@lang:en
       @@@@:
         The DOM Level 2 Specification said that the HTML-only DOM 
         implenentations do not need to implement this method. 
         The DOM Level 2 Errata and the DOM Level 3 Specification 
         says that the NOT_SUPPORTED_ERR should be raised.
     @@Level[list]:  
        2
        3
     @@SpecLevel:2

  @IntMethod:
    @@Name: isEqualNamedNodeMap
    @@Operator:
      @@@Type:
        lang:Perl
      @@@@:==
    @@Description:
      @@@lang:en
      @@@@:
        Return whether two <IF:NamedNodeMap>s are equal.
    @@Param:
      @@@Name:arg
      @@@Type:ManakaiDOMAttributes
      @@@Description:
        @@@@lang:en
        @@@@@:
          The node list to compare equality with.
    @@Return:
      @@@Type:boolean
      @@@Def:
        @@@@Type:
          lang:Perl
        @@@@@:
          EQ: {
            for my $ns (keys %{$self->{<Q:TreeCore:node>}
                                    ->{<Q:infoset:attributes>}}) {
              last EQ unless $arg->{<Q:TreeCore:node>}
                                 ->{<Q:infoset:attributes>}->{$ns};
              last EQ unless keys (%{$arg->{<Q:TreeCore:node>}
                                 ->{<Q:infoset:attributes>}->{$ns}}) ==
                             keys (%{$self->{<Q:TreeCore:node>}
                                 ->{<Q:infoset:attributes>}->{$ns}});
              for my $ln (keys %{$self->{<Q:TreeCore:node>}
                                      ->{<Q:infoset:attributes>}->{$ns}}) {
                last EQ unless $arg->{<Q:TreeCore:node>}
                                   ->{<Q:infoset:attributes>}->{$ns}->{$ln};
                last EQ unless $self->{<Q:TreeCore:node>}
                                    ->{<Q:infoset:attributes>}->{$ns}->{$ln} ==
                               $arg->{<Q:TreeCore:node>}
                                    ->{<Q:infoset:attributes>}->{$ns}->{$ln};
              }
            }
            $r = true;
          }
    @@ImplNote:
      @@@lang:en
      @@@@:
        See: <M:Node.isEqualNode>.
    @@SpecLevel:3
## IF:ManakaiDOMAttributes

## ManakaiDOMCore.dis ends here
